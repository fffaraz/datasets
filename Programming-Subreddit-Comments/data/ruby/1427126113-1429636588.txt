This wasn't discussed in detail in /u/rdsubhas article, so here's the ELI5: &gt; I am mostly confused about unicorn/puma vs nginx. They all seem like web-servers, but clearly nginx is different from unicorn. I have no idea how they interact with each other in order to serve web applications. If you use an nginx + Unicorn/Puma setup, nginx is the web server, while Unicorn/Puma are application servers. [This Google image search for "web application server" should give you an idea what their relationship is.](https://www.google.com.ph/search?q=web+application+server&amp;tbm=isch) As a web server, nginx's main job is to serve static files. In a typical Rails app, that's your precompiled assets. It cannot process your application code, however, so it's set up as [reverse proxy](http://en.wikipedia.org/wiki/Reverse_proxy) to direct the requests that require processing to your application server. As application servers, Unicorn/Puma/Thin/etc processes the requests and returns HTML/JSON/etc responses to the user. Why the separation? One reason is that web servers (and by extension, load balancers and CDNs) do more than just serve static files e.g. virtual hosting, HTTPS, gzip compression. Another reason is that web servers can serve static files a lot faster than application servers - 100-1000x speedup in terms of requests per second is not unheard of. Do they have to be separate? Not really. As mentioned by the others, there's Passenger which is usually installed as a combined web server + app server system with either Apache or nginx as the web server and Passenger as the app server, removing the need to manually link the two tiers. Which approach is better? It's a matter of preference. There are pros and cons of both, but for beginners I'll have to lean towards just going with Passenger. In an Ubuntu server, [Brightbox Ruby packages](https://www.brightbox.com/docs/ruby/ubuntu/) + [installing Passenger via APT](https://www.phusionpassenger.com/documentation/Users%20guide%20Nginx.html#install_on_debian_ubuntu) is hard to beat in terms of simplicity. (As a side note, more newbie web devs start with PHP so more are familiar with the combined "web + app" server - the Apache MPM prefork + mod_php combo in their (X)AMP setup. Nowadays though, more and more PHP devs prefer to use the separated approach in their servers e.g. nginx/Apache MPM evented + PHP-FPM.) &gt; I know Capistrano is used to deploy code, but I have no idea what that actually means. Deploy tools like Capistrano and Mina simplify points 4 to 6 (and even up to 9 if properly configured) of /u/rdsubhas's article to a single `cap production deploy` or `mina deploy`. You'll see what I mean when you read the article and the documentation of both tools. &gt; Lastly, how do these tools interact with hosts such as AWS or digital ocean. That `cap production deploy` or `mina deploy`? You run that on your local machine. Capistrano/Mina will connect to your server and do all those things for you. (As another side note, I may make it sound easy, but in reality you're going to need a day or two of trial and error to get these tools working. The docs aren't exactly beginner friendly, not to mention Capistrano had a big jump from version 2 to 3. But yeah, your deploys do get much more smoother once you finally get them working.)
Bummer there's no word2vec wrapper
Actually, I was more interested in the etymology of the 'eigen-' prefix as it exists in many fields other than the Ruby language. The eigenclass is by far the most trivial use of the word I have come across. Eigenclasses are merely a nuanced symantec reassignment of the word self.
ya but the takeaway here is that is really hammer in the whole object oriented environment that ruby gives you. Its all just sending messages to objects.
Is the lack of threading in the non enterprise version a deal breaker in any way?
IMO you should rephrase this so it sounds a little less like a pamphlet
This is really good. I especially liked section 9, using Foreman with your services.
That's a question only you can answer.
derp, 2 seconds later I find that http://www.rubydoc.info/gems/lotusrb at the bottom has some examples.
I'm waiting for version 1.2.3 Get off my lawn.
I think this is a cool project, and we need competition in the Ruby web framework space. But these guys' marketing is way too slick. That's the world we live in now, but some of the claims they're making are just false. &gt; The solution is to send a HTTP header (X-Frame-Options) that regulates which source can embed your web application resources. Again, Lotus is the first Ruby web framework that enables this defense by default. [Rails has added this header by default since like 2012.](https://github.com/rails/rails/blob/798a14a6388ac525109e550d72bba0b1118e5e2e/actionpack/lib/action_dispatch/railtie.rb#L22) Meanwhile, they only just added output sanitization and still don't have CSRF protection. Again, I really don't want to shit on the work other people do on their free time, but they need to calm down the rhetoric about how shipping everything as a separate gem is some kind of revolutionary idea. Rails has shipped as several separate gems since 2008, and although no one does it, [you can use all the parts of Rails independently](https://github.com/nateberkopec/rails_lightweight_stack/blob/master/config.ru).
Why would somebody choose rvm over just installing a stable Ruby release? Would that be for multiple sites on one server requiring different Ruby versions? I had trouble with it and went to 2.1.5 stable. I just wanted to see if I could build a ruby server and that got my rails app running.
Try finding a local ruby user group or meetup. Finding someone in person to help is ideal. 
cool
Thanks!
i'd recommend coderbyte which shows other people's solutions to the problems once you submit yours.
i think you should start playing with gems ... just find simple looking ones and go through the exercise of getting it to work (although gems can get out of date quickly and many do not work as described). If it interests you, learn web frameworks like Rails or Sinatra. 
From their [README](https://github.com/lotus/lotus): &gt; Unlike other Ruby web frameworks, Lotus has flexible conventions for code structure. Developers can arrange the layout of their projects as they prefer. There is a suggested architecture that can be easily changed with a few settings. Which worries me. And for me, would be a reason not to use it. * Strong conventions make the app recognisable. I can open any Rails app, and if it is somewhat reasonably developed, know what is going on within hours. * Strong, enforced conventions somewhat take the pain away from the often lamented "black magick". when you place a certain-named file in a certain directory it magically becomes the view for a controller action. Whether this is good or not, is a second thing. But if you can configure how that "certain named" behaves and where that certain directory lives, I fear for an explosion of spaghetti. * Strong conventions take a lot of discussion and choices to be made away. The framework dictates how you do it. Not your nutty co-worker or that former architect who liked to try new stuff. You also don't need to think where to place stuff and how to name it. All of that is already decided for you (up to certain points). Can anyone with experience on lotus comment on this? Is this configurable-convention concept a good thing, or are my worries somewhat realisitc? I've also been glancing at [trailblazer](https://github.com/apotonick/trailblazer) which has a different organisation of code then Rails. But it leaves you one choice: Rails Way or Trailblazer Way. Anyone with experience who knows how lotus and trailblazer differ or compare? 
Hey OP, try your hand out at codewars.com -- its a site where users give each other small coding challenges and you have to write your solution to each. You can start at the lowest level land work your way up. Best of all, after passing each challenge, you can see the code of all other people who passed it, and discuss solutions with each other! Its a great complementary tool to codecademy. I teach a bit of coding at uni and I have students use codecademy / codewars / github as my trinity of tools for learning / training / developing.
Very valuable. Wish you had written this years ago before I learned it the hard way. :)
Any opinons on using this compared to Sinatra or Padrino?
I tried codewars after finishing the codecademy ruby courses and found it WAY to hard. I don't know if I'm just stupid, or I tried it when there were just extra hard challenges up at the time, but the concepts asked at that time were far from what was learned in the codecademy courses. Right now I'm still looking for a good resource that starts where codecademy ends.
I understand -- note that you can choose exercises that are rated the easiest (8 kyu) and then even sort them to see the easiest (or most popular ones) first! Many of those should be quite doable! For example, here's one that asks you to write a method that returns the second element in an array, or nil if it does not exist: http://www.codewars.com/kata/array-number-second
&gt; Rails has added this header by default since like 2012. https://twitter.com/lotus_rb/status/580311447923724289
AFAIK DNSimple and Envato are for their HTTP API
one particular feature I like is Lotus::Container, for you could mount multiple version of your API app Lotus::Container.configure do mount Web::Application, at: '/' mount ApiV1::Application, at: '/api/v1' mount ApiV2::Application, at: '/api/v2' end Furthermore, you could cut overhead of View layer and using your own custom json renderer you like.
The one I got on the day I signed up was about a matrix of arrays (lets say 4x4) and you should output the diagonal values (first value from the first array, second value from the second array, third from the third, etc.). I browsed through the answers and they completely flew over my head.
&gt; I've also been glancing at trailblazer which has a different organisation of code then Rails. But it leaves you one choice: Rails Way or Trailblazer Way. Anyone with experience who knows how lotus and trailblazer differ or compare? Trailblazer has an strong convention on constructing view with cell objects composition. On the other hand, Lotus is different, more like Rails for users render template and partial but also different because Lotus has a separate View class where users can include helpers mixin or place their templating methods/logic that are ready to be used in the templates. 
&gt; My client is offering up to £45k LOL, that's a terrible offer. Tell your client to up his game. That offer is about £30K less than a respectable developer would accept for those responsibilities.
http://www.jenv.be/
I used Sinatra, because it is a popular framework. Ofcourse I could use Cuba or just a Rack based application, but I wanted to try Sinatra. I will be happy to see the results of Cuba comparing to Lotus if you would like to make such benchmark and share the results :)
Developers have two states of mind: 1. I am a god. 2. I have no idea what I'm doing. You get used to it. 
And a new version of pg_morph gem is ready: http://blog.lunarlogic.io/2015/playing-with-black-matter-continuation/
just FYI, there are 2 more existing alternatives if you are looking for extra inspiration * https://github.com/jmettraux/rufus-scheduler * https://github.com/tomykaira/clockwork (mentioning this cause I see `whenever`mentioned in the readme but not these) 
What's your end result? Do you want to reuse/return the array later or just print each item's value *2? (so print 2,6,10,14,18, one line each, then throw away the array? Or reuse [2,6,10,14,18] later on? Reuse the unmodified array later? Print will put it all on the same line, puts will put each output on a new line `[1,3,5,7,9].each { |item| print item * 2 }` will print each on one line.
[Heroku offers an VERY basic version of this](https://addons.heroku.com/scheduler), but it doesn't allow for jobs less frequent than daily or have a history or result recorded. An adapter for one of these scheduler libs that hooked into the heroku scheduler would be awesome if anyone is interested in a side project.
Why must it be dependent on Rails?
Are you just trying to learn ruby or are you trying to pick up rails? someone asked this earlier about what it takes to be a full stack rails dev, so I wrote a blog post about it: I want to this in an entry level rails developer 1. Build a CRUDL application 1. Understand and apply bootstrap 1. Build a to-do application or any simple super basic app that requires a few controllers, models, etc. 1. Use slightly obscure gems, like the twitter, koala, mandrill, kaminari, jbuilder, etc. to prove to me that they can read the documentation and figure out how to use a gem. Bonuses 1. Understanding a testing framework (rspec is my preference) 1. Knowing some basic javascript (jquery) 1. Know TDD 1. Knowing Thin Controllers, Fat Models 1. Attends the local ruby on rails meetup [source: kcoleman.me](http://www.kcoleman.me/blog/2014/06/13/entry-level-rails/)
&gt; Are you just trying to learn ruby or are you trying to pick up rails? Both. I have 10+ years of web dev experience in Java and ColdFusion before that. Am doing this for myself for now, not necessarily looking for an entry level job. Thanks for your input! 
`letters.map(&amp;:something)` I love this shorthand because it is deliberate. More impressive is the implementation ... because it makes so much sense ... this just calls map with a block that is produced by calling to_proc on the symbol :something. 
Yeah, so you're probably best off to just work on a few side projects 
[Kernel#sleep is your friend](http://ruby-doc.org/core-2.2.0/Kernel.html#method-i-sleep)
how do you think we used to get around not having to do callbacks in ActiveRecords? ```.send(:update_without_callbacks)``` ;P
Nice that it has a web UI BTW. I haven't seen a scheduler with a UI.
I like it. Too bad I don't really post much on stackoverflow.
I think you should start writing software, now. Sure, Rails too. 10+ years of webdev/Java/ColdFusion experience will serve you well, since you understand what's going on and what the intents are, you'll figure it out, you are well positioned to start messing with Rails, if that's your ultimate goal, start right now, you don't need to give yourself assignments first. You already know how to program, you already know how the web works, now you know ruby, it's time for Rails. I don't understand the trend these days for "how do I up my game" (that's the phrase that seems to show up weekly on self posts here, I'm glad you didn't use it ha) by exersizes and online games and tutorials. Start building stuff! That's how you do it. Do all that other stuff you list as you build stuff, and then you'll learn it because it will connect with what you're building, and the things you are curious about when building will guide your research. 
I wrote [Gaspar](https://github.com/mashable/gaspar) to do something similar; the key difference is that it uses Redis to perform interprocess synchronization of scheduled tasks, so Gaspar can run in the background in multiple processes, and the same task won't get run multiple times for a given iteration. It's basically just a redis synchronization wrapper with a DSL on top of rufus-scheduler, but it works nicely. We use it for doing things like scheduled email sends, periodic updates of time-dependent rankings, background sitemap rebuilds, and that kind of jazz.
I came from Java too so I understand how fresh Ruby must feel right now! I'm with the others commenting here that you should build stuff sooner than later. Especially given your fairly strong Webdev background. My suggestion is to jump into Sinatra and ActiveRecord headfirst. Start prototyping your next idea, or just rebuild an old project. Doing this will guide your learning tremendously and motivate why you need the next steps. The koans and such will sink in much better when you have a context to relate them to. After a couple months of Sinatra, you'll be ready for the books you mentioned. And you'll soon understand why rails does what it does. Best of luck and happy hacking!
From the readme, this looks like a combination of whenever and resque / sidekiq. Pretty nice. 
ya, ha, we kinda abused it. but I actually don't think its even an option anymore, at least in Rails 4 maybe. update_column() is what you want now.
Is this safe to run multiple crono daemons for resiliency? E.g. Two daemons running, only one will acquire the job presumably via a transactional lock while the other fails. Then they all try again next time a job is ready to run.
Thanks! Do you go to the ruby meetups?
We had great success with [whenever](https://github.com/javan/whenever) on both Rails and Sinatra projects. Plus, it has a really nifty capistrano integration :)
i have been occasionally. its been about 6 months though - depends on my mood. i float between 'creative mad scientist dev' and 'entrepreneurial workaholic' moods. lately i've just been keeping to myself and trying to finish what i've started
I was thinking the same thing. Cron is such a fundamental part of every Unix distro that I have a very high level of trust in it. Ruby, on the other hand, is awesome for its flexibility, etc... We've had plenty of issues where a web dyno would just die in heroku. I wouldn't want that to kill my scheduler. One other thing you might consider is using rake rather than plain ruby scripts. That's what we're using to queue jobs in sidekiq and I really like how clean it is.
Yeah, if cron is down, your ruby app definitely is! Re: rake. I will. I need to go back in an tweak some scheduling stuff anyway.
I just set mine up to email me the results when it runs...or you could stick em in a log file.
I didn't, somehow I had written my own hackish solution before I found out about them, i.e. I use cron to schedule tasks, and invoke a private API server which queues subprocesses. I like clockwork because it basically does the same thing, it queues stuff, and leaves distribution/locking/repetition to a bg job manager, but it really depends on your needs.
As someone who is roughly equally skilled in both Java &amp; Ruby at a fairly high level, my commentary on your plan is this: *TLDR:* Strongly focus on learning the core language features, NOT libraries &amp; frameworks. Learning libraries and frameworks is of MUCH less value than in Java-land, because of how Ruby is setup. Focus especially on meta-programming &amp; learning the object model. *Short revision of language syntax + features:* Always helpful. Focus on learning the features that facilitate meta-programming &amp; pure-OOP; those are the biggest divide between Ruby &amp; Java, and will give you the most bang for your buck in mastering. *Tour of core libs/ Understanding the ecosystem:* Another thing which is always helpful, but (this is going to suprise you); NOT that helpful. This is the single biggest thing I see with Java folks being exposed to Ruby; knowing the ecosystem &amp; libraries is just not as important. The reason is that Ruby is so damn productive that it is very often easier to simply write your own library than find one for whatever it is you need. By the same token, if it takes you more than 15-30 min to understand how to use a library, you are probably better off not bothering &amp; again just writing your own. This is completely different from Java-Land, where you are expected to become expert in a finite set of frameworks (eg Spring, Hibernate, etc.). Bear in mind that most Ruby libs are just a few hundred lines of code, vs. a thousands+ that you see in the Java ecosystem. Caveats: always make a token effort to see if there is something in common usage for your need, to avoid NIH syndrome. In the web/REST/network area specifically, there are several very good options already so just use one of those (Rails, Sinatra, etc.) *Koans:* Meh, I always found them kinda trite frankly, but they can't hurt *Small scripting tasks on my local computer:* $%^&amp; yes. Practical experience slinging Ruby code is what you really need to focus on. *Sinatra / Rails more in depth:* If you are going to learn any libraries, these would be 2 good examples to actually focus on. Doing so is probably less net gain for you then just focusing on the core language though. 
What's the performance like? And does it have GPU acceleration? If not, while neat, it's probably not a viable option.
Can't be bothered really. Speed is not my real beef, memory usage and ease of deployment is. Speed is important but only because running a suite of tests is a PITA when you get a lot of them.
Enjoyed this, thanks.
You're actually asking a fairly complicated question—how do you combine two asynchronous, recurring, unpredictable (well, one is unpredictable anyway) events into a single program? You might be able to use threads, but Ruby threads kind of suck and I'm not sure how nicely Sinatra plays with them. Easiest way is to split this into two scripts. One that scrapes data and dumps it to a file every ten seconds, and a Sinatra-based web daemon that listens for connections, reads the data from a file when it gets one, and displays the result before going back to sleep to wait for the next connection. If you're on a Unix system, you can use /tmp as a location to store temporary files. Simply have your scraper output data to a file there. It's as easy as `IO.binwrite("/tmp/mydata", YAML.dump(score_var)"`. Then in the web script, you retrieve it with `score_var = YAML.load(IO.binread("/tmp/mydata"))`. Of course, this leaves open the possibility of a race condition: What if you try to read from the file while it's being written to? I'm not sure right off the top of my head, but Unix may handle this for you by blocking the read until the file is closed for writing, so you may not even have to worry about it. But one way to solve it would be to write to *two* files, each named something like `"/tmp/mydata_#{Time.now.to_f}"` (make sure you put a slight delay between writing the two files). Then the reader script lists all files in /tmp starting with "mydata", and reads it from the *second* newest file. That way you can be sure it's never open for writing. If you use this approach, the scraper script should tidy up after itself by always deleting every data file except for at least the three newest ones. Hope all of that makes sense. There are probably plenty of other ways to do this—named pipes, network sockets, threads, and so on—but this is probably the simplest way I can think of to accomplish this.
Hi ! Can you point me out to the exact tutorial you are following? Is the command run locally or on the Heroku server? As far as I remember, running db migrate on heroku is more something like: heroku run rake db:migrate Are you using Postgresql locally?
This is how heroku works: You have your application. When you create it, there is literally nothing in it. It (heroku) has no idea what application it will be or what it will use. Once you push your repository with your app to heroku, it will do some magic and detect what language/type of application it is. Depending on what it detects, heroku uses one of many "build packs" they have. In these build packs are steps they do for running your application. These steps DO NOT include database preparation. Reason is simple, you can use one of many database solutions they offer, or even have application without database. If you want to have postgres database from heroku, you have to add it in the form of postgres add-on. There are many add-ons you can add to your application, you can find them when you look around in heroku dashboard. Once you add postgres add-on, heroku will configure ENV variable with your database url. This url contains all information you require for connecting and you can read it from your application. --- On the other hand, it looks like you are running command not on heroku, but locally. From that error and short google search, it looks like your local postgres server might be configured incorrectly.
It looks pretty *dashing*! I think I will give it a go soon.
I toyed with this a year ago. It's pretty neat but ultimately went with geckoboard. My time is worth more than $19/mo. 
Hey, read the discussion, that is a really valuable twitter feed to read. I know of some hellish scenarios where we had trouble with it in the UI side. We where at a point that we could not reasonably keep track of what happened and where. And really good point about the Node.js - It makes you feel like you are not writing an event based system and all code is in single place. Can you expand a little bit about the difference between UI events and User events that you mentioned in your tweets?
If it bothers you a lot, just read this https://rebuilding-rails.com/
Thanks firstly for the detailed reply! That is a very helpful perspective - I did not know that about Ruby libraries and you probably saved me a lot of time. The mixin and module stuff is very interesting and obviously different from Java land; I'm sure the best patterns are different. Can you recommend a single (if possible) strong resource (book/site) that will help me with the core stuff as you suggested?
Sure. I didn't said that Sinatra doesn't fulfill its role. I think it is and that is why I used it in a benchmark. I am just pointing out that there is an alternative with a well organised source code. For example we can write our applications in a single file, but how long such project would survive? ;). Sometimes we have to take a look at the code from tools that we are using and for me it is not easy to read such code. This is only my personal opinion ;) &gt; than pretty code that doesn't. In my opinion Lotus also works ;)
No I don't want to re-use it, I just want to print out each value *2
Lotus doesn't require a view layer
This looks good to me [1] pry(main)&gt; odds = [1,3,5,7,9] =&gt; [1, 3, 5, 7, 9] [2] pry(main)&gt; odds.each { |odd| puts odd * 2 } 2 6 10 14 18 =&gt; [1, 3, 5, 7, 9] [3] pry(main)&gt; Note: `puts` will put the statement on a new line each time. `print` will put it on the same line. So with print you'd get `26101418`. You don't need *=, that's just for editing something in-place to be used again (like `x = 1, x *= 3; x` would return `3`). I couldn't get in-place renaming to work in this context (to end up with a [2,6,...] array at the end) anyways.
Someone else has already answered what it does, but I'll explain why for ya here: Ruby has short-circuit evaluation, and (nearly) everything is an expression. This means that if I use a logical binary operation, it will evaluate the operands exactly until the value for the whole function is known. So if I do: foo || foo = [] The interpreter first attempts to evaluate `foo`. If `foo` has been initialized to a truey value (anything except `nil` or `false`), then the logical OR operation is guaranteed to be true, since a logical OR only requires that one or more operands be `true` for the operation itself to be `true`. If the first operand is truey, then the whole expression stops evaluation and returns the value for the first operand, without ever evaluating the second operand. If `foo` has not been initialized, then it will be `nil`, which is falsey. Since a single falsey value does not guarantee a result in a logical OR, the interpreter must now evaluate the second operand: `foo = []`. Evaluating this initializes `foo`, and the OR expression returns the value of the second operand as it's own value, i.e., `[]`. This same sort of reasoning applies to logical AND, as well, which is why you'll occasionally see (not recommended) code like `foo &amp;&amp; foo.method`. This is basically equivalent to: `if foo { foo.method }`. If `foo` is falsey, there's no need to evaluate the second operand to determine the value of the boolean expression, but if `foo` is truey, you still need to know if the second operand is truey to evaluate the entire expression.
So that will instantiate foo as a new array provided foo hasn't been previously defined, and take its value if it has? If I'm right then isn't that a bit redundant, because if its defined you can just use foo? EDIT: Thanks to /u/wmjbyatt, I fully understand now. This is really handy o.o
So if Ruby evaluates both sides of the expression, why does it not complain if there's no operand on the left side of the =, as in /u/Kimos's example? Surely the = itself requires a left side operand to be properly evaluated?
No problem! Short-circuiting is a really cool feature, but I'd definitely recommend against using it too much. It usually doesn't express intention very clearly and can get involved in tangling up readability. There's definitely positive use-cases, though. In my Rails project, I currently use it in my `Decorator` classes with something like: def phone_number resource.phone_number || 'None' end Which just allows me to do `decorated_object.phone_number` in my views without cluttering it with logic. I hate logic in views.
 foo ||= bar is Ruby syntactic sugar. `||=` is an actual Ruby operator that is equivalent to the short-circuit assignment.
Ah, okay. Makes sense - thanks :)
I've played with it as well - not too hard to get up and running + integrates nicely with batman.js, fits nicely in with simple stats like performance + server monitoring +1 for for gecko mention, https://developer.geckoboard.com/#introduction) looks like it has nice widget library
Dashing also hosts perfectly on heroku which is excellent. Ultimately however at $19/mo, assuming you make even as little as $20/hr as a programmer, if you spend more than 1 hour/month maintaining a dashing setup plus the costs to host it, you're throwing away money.
Thanks for the RabbitMQ tip! Pub-sub is great even when applied in-process, i.e. w/o a message queue like RabbitMQ. I really like using wisper - it's simple and short (in terms of LOC) which is important when you stumble upon a bug.
Fantastic. This works. How can I deploy this script on web ? The problem is all the sites are blocked in my company and the only way I know is to parse score from some site and display it somewhere on the web ? What would be a good solution for that ? Guys thanks for your time. I'm not that much into ruby but just trying to solve a problem here.
Fantastic. This works. How can I deploy this script on web ? The problem is all the sites are blocked in my company and the only way I know is to parse score from some site and display it somewhere on the web ? What would be a good solution for that ? Guys thanks for your time. I'm not that much into ruby but just trying to solve a problem here.
Also consider looking at Ducksboard.
Okay, so I was just playing around with Sinatra a bit, and it looks like you can use a thread-based solution. The trick though is that you apparently have to store the information in a global variable. You should be able to use the following code as a template for what you want to do: require 'sinatra' $foo = 0 $start_time = Time.now t = Thread.new do loop do $foo += 1 sleep 1 end end get "/" do "Time is #{Time.now - $start_time}&lt;br&gt;$foo is #{$foo}!" end If you run this, you'll see that $foo is correctly being incremented once per second, and every time you reload the page you should see the latest value of `$foo`. Just put your scraper code in the thread loop, change sleep to 10 (or whatever frequency you want it to be), and you should be all set.
So is it similar to terenary operator in php or java? 
It's kinda like in c++ how you have a += b is basically a = a + b; and so foo ||= bar; is the same as foo = foo || bar 'if foo is falsey, initialize it to bar, otherwise it keep it the same'
&gt; [turbolinks] replace only parts of the page that changed Not true. 
Please correct me if I am wrong on this... But is the statement "if foo has not been initialized, then it will be nil" slightly different? Running the `foo || foo = []` yields the following: irb(main):001:0&gt; foo NameError: undefined local variable or method `foo' for main:Object from (irb):1 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):002:0&gt; foo || foo = [] NameError: undefined local variable or method `foo' for main:Object from (irb):2 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):003:0&gt; foo =&gt; nil irb(main):004:0&gt; foo || foo = [] =&gt; [] irb(main):005:0&gt; foo =&gt; [] So in the first two sections of evaluation, we have errors thrown because we are doing conditional evaluation based on variables that have not been set yet. We still see that when we get `foo || foo = []`. But something interesting happens at that point. The foo variable is recognized... but it's defaulted to nil. Only after the item is ran again are we having foo set to []. Now... consider the same type of expression but with 2x variables that have not been initialized. irb(main):001:0&gt; bar NameError: undefined local variable or method `bar' for main:Object from (irb):1 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):002:0&gt; baz NameError: undefined local variable or method `baz' for main:Object from (irb):2 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):003:0&gt; bar || baz = [] NameError: undefined local variable or method `bar' for main:Object from (irb):3 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):004:0&gt; bar NameError: undefined local variable or method `bar' for main:Object from (irb):4 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):005:0&gt; baz =&gt; nil irb(main):006:0&gt; bar || baz = [] NameError: undefined local variable or method `bar' for main:Object from (irb):6 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):007:0&gt; bar NameError: undefined local variable or method `bar' for main:Object from (irb):7 from /Users/jamesondecko/.rbenv/versions/2.0.0-p195/bin/irb:12:in `&lt;main&gt;' irb(main):008:0&gt; baz =&gt; nil Here, we can tell that only baz is being recognized and initialized as a variable (still nil). But it's also never able to be set to an empty array because the first condition can never evaluate (bar never is able to be initialized). To OP... Is there much of a point to this? Not really... but I find it very helpful to open up a console session whenever I have some weird concerns about orders of operations or how a piece of ruby really works. I think you were probably referencing the `foo ||= 'temp'` syntax others were referencing but I still think your example was fun to play around with. You learn a lot about the language when you try to tinker with it a bit! 
Is there a typo in the first code snippet? (boardcast instead of broadcast)
You're never assigning a member of the `things` array to `i`, that's why.
[informit.com](http://www.informit.com/store/ruby-way-solutions-and-techniques-in-ruby-programming-9780132808262) says "All source code for this book may be downloaded at www.rubyhacker.com" but it doesn't seem to be there. Perhaps try tweeting the author, [@hal_fulton](https://twitter.com/hal_fulton).
No reasoning behind why it's like that, though there's a link on that answer to a page that has other links to threads/pages that discuss ``||=``and at the moment, going through some of the example code people posted (years ago btw), I've tried them on ruby 2.1.2 and ``a = a || b`` and ``a || a = b`` behaved the same in all cases. I'd like to see a case where it behaves differently on 2.X. Maybe 1.8/1.9 were different? Still though, is there a difference? If the first operand is ``falsey``, the second gets evaluated and so on, so ``a = a || b`` would set ``a`` to ``b`` if ``a`` is falsey (since ``a || b`` will return ``b`` if ``a`` is falsey), and ``a || a = b`` would set ``a`` to ``b`` if ``a`` is falsey. Am i missing something here?
Nice response, you should mentor minions.
Yes they did and Dashing a looking to move away from it.
I remember coming across operators and thinking "wtf is this?" and having it be impossible to google, especially if you don't know the term "operator". This is the most readily available comprehensive list of operators I can find: http://www.tutorialspoint.com/ruby/ruby_operators.htm
I did not say that Grape does not have such feature. In fact, being a framework designed for HTTP API app, Grape offers much more features out of the box that Lotus probably will not provide. My bad in explaining the container feature. Imagine you are writing a web app that consume data from API. With Lotus Container, end-to-end integration between web app (that consume API) and API app become much easier, for you don't have to mock/stub/VCR responses. Furthermore, for startup app at initial stage, deployment would be simplified much too. In conclusion, I don't think it is fair to compare 2 frameworks, for they are designed for different purposes, each would have each advantages and users should go for what they really need.
Thank you.
The problem with these is they tend to be geared towards using databases as the source of information. Some of our data lives in DBs, but most of the time it exists in proprietary applications and can only be extracted via API.
Absolutely can't stand this style of coding. I'm certainly glad Rails does NOT work like this out of the box.
http://blog.firsthand.ca/2014/06/dont-commit-your-secrets.html
There's another project which these solutions might suit, previously a team attempted to use Xtraction but realised it did not have the features required. Dashing makes it easy to pull data from an API and get near-real-time information, which I think is most of the time what we'll be looking for.
Thanks for your assistance anyway, my boss was nailing me because I went ahead and implemented this dashboard and hadn't reviewed the options with him. At least I can have some confidence it seems the right way.
/u/wmjbyatt explains it well, but I'd like to be doubly clear that you got the core point. &gt; instantiate foo as a new array provided foo hasn't been previously defined if foo has been defined as *nil* or *false*, it'll still set the value to a new array &gt; foo = nil =&gt; nil &gt; foo || [] =&gt; [] &gt; foo = false =&gt; false &gt; foo || [] =&gt; [] &gt; foo = 1 =&gt; 1 &gt; foo || [] =&gt; 1 
Thank you for your response, but I found my issue... rackup does not support multi-threading. Using either ruby app.rb or serving it with unicorn (or i'm sure other servers) it works as intended. Yet another time where I don't know whether to be happy I figured it out or frustrated that I had it right the whole time and was trying to debug nothing for hours....
You are using UDP in your Python script, TCP in your Ruby. Also, don't know what version of Ruby you're using, but with 2.2.1, I did this... require 'socket' socket = TCPSocket.new '127.0.0.1', 80 num_bytes_sent = socket.send "Message", 0 while line = socket.gets do puts line end HTH a little
You can either create an example file config/secrets.example.yml Or you can get those values from environment variables secret_token: &lt;%= ENV['SECRET_TOKEN'] || 'development_token' %&gt; Personally I usually go with latter.
That's ridiculous. Clearly there is a memory leak in sinatra.
Interested to see where the Actor model in ruby thing is at - does anyone know?
So I went over that guide and other pages linked around there and found [this guide](http://www.enterprisedb.com/docs/en/9.3/pginstguide/PostgreSQL_Installation_Guide-07.htm#TopOfPage). According to it, you were prompted for service account password during installation (see Fig 3.4). It also setup postgres so it runs as a background service on port 5432 (that is default value). So your username should be "postgres" and your password should be anything you specified during that installation. Their [ruby starter application](https://github.com/heroku/ruby-getting-started) is Rails app, so database configuration is in config/database.yml. Read through it to get better idea how database configuration works. In your case, under `development:` it should be something like: development: &lt;&lt;: *default database: ruby-getting-started_development host: localhost port: 5432 username: postgres password: &lt;your postgres password&gt; this would probably also work: development: &lt;&lt;: *default url: postgres://postgres:&lt;yourpass&gt;@localhost:5432/ruby-getting-started_development It is basically the same thing.
I doubt the ruby version is going to be an issue with something this simple - there's no "modern" syntax in your code, and as far as I can tell the basic TCPSocket syntax hasn't changed since ruby 1.8.6
Glad you were able to figure it out! Enjoy your learning!
Just make sure you actually understand what you did there. `heroku` commands usually work with your heroku application. If you are going to develop locally, you should be able to run your app without using heroku at all. What /u/vanakenm mentioned is command for migrating database on heroku servers. You then pulled that database to your local database. That is not how standard workflow is supposed to work ;) Normally you would have your local development database that you would create, migrate and seed and just use for development. Without it affecting heroku in any way. Then after developing stable version of your app, you would push the changes to heroku and run `heroku run rake db:migrate` or any other commands you need, to get your heroku database to a state that will work with your new version.
Ah, I see. I have much to learn. 
&gt; These days I find Ruby not really well suited to anything that's more complicated than a simple CRUD app or a reasonably simple API. Did you post this to /r/ruby as flamebait? Although I respect your decision to use other tools, I respectfully disagree your thesis of *Rails Apps are hard to work and reason with.* The crux of your experience sounds like a lack of ability to write maintainable code. It's possible refactor the design patterns of a rails solution and still benefit from the Rails ecosystem.
I'm guessing this scenario is so common that many experts here must have seen and solved it for production. Currently I'm opening and closing connections in the beginning and end of the route handlers. There has to be a better way! Would love to learn the right solution from the experts here.
"Easy to read" is relative. If you think it's not worth getting used to, that's fine, but I would say the tradeoffs of keyword args are definitely worth it, since you don't have to sprinkle `opts[:option1] ||= some_default` (or whatever the best practice is) in every method I want default options.
[**@rbates**](https://twitter.com/rbates): &gt;[2015-03-26 16:02:49 UTC](https://twitter.com/rbates/status/581124152511229953) &gt;Hello, world! ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/30dztm%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Is there a reason for using Passenger as opposed to Puma? If you shift to Puma, you gain a multithreaded webserver, and that immediately simplifies connection pool management. If you're brave, and are willing to run on JRuby, you can also use Trinidad, which is an excellent and reasonably lightweight rack-based webserver.
&gt; since you don't have to sprinkle opts[:option1] ||= some_default Could you elaborate on the pattern you're using the ** in to achieve this? My assumption is that you're setting opts = c in a method that uses **c. I don't quite see how that would avoid an antipattern of checking for defaults.
I disagree with you. It looks fine to me.
That's fine, but would you care to elaborate on why you think this is a better ruby practice?
Because you don't have to do it manually? Have you ever seen rails code with the horrible `extract_options!` method being called? Using this `**args` approach obviates the need for that muck.
I hate the dagger lambda operator.
Oh believe me, I'm not arguing that this is comparable to the antipatterns often used in extracting options. I'm just asking why you think that it's better than (for example): def some_method(a, opts = { }, *c) To me, using the ** version opens you up to method calls like the ones I used as an example in my previous comment. I find it much cleaner to read someone else's code when they would write such a call as: some_method('a', { opt1: true, opt2: false }, 'one, 'two', 'three') instead of some_method('a', 'one', 'two', 'three', opt1: true, opt2: false) Sure, it's subjective on the preference, but I'm more interested in why the latter is objectively better code. I'm not asking why it *could* be better code, but rather why it *is* better code.
Thank you! I'll take a look at Puma.
You said so yourself it's subjective, i find the latter significantly more readable, especially since option arguments typically appear *at the end* of the args list, it seems weird to have it in the middle, i don't think i've ever used an API like that, actually. 
Sounds like a Bond villan :-D Edit: typo
I'm a big Ruby fan but I thought this was a good read; some fair criticisms here from someone who's done Ruby apps for 8 years. Clojure certainly seems to be picking up steam, and Elixer is pretty neat. I don't know, to me it seemed like some decent points from someone who had been there and done that.
&gt; i don't think i've ever used an API like that, actually. That's the kind of example I'm looking for. Actual use case where it would be more useful to stick them on the end if you needed to interface with another system. Thanks!
Don't read number 9, lookup Avdi Grimm's blog about using `fetch` instead.
A proper connection pool indeed won't create and close connections for every request -- and I agree that is likely to be a performance problem -- but you don't need to share the pool between processeses to do this. One pool per process should be fine, no? I don't know Sequel, but ActiveRecord does this automatically by default. You can control pool size with the `pool` attribute in an AR connection dictionary -- this is a maximum, it won't open them all up at startup, but just as needed. I think maybe it is 5 by default. But the connection pool is not shared between processes, and there is no way to do so. In general, I think most modern databases can handle a pretty large number of simultaneous open connections just fine, probably larger than you need. So there's no need to pool them between processes. If you have 4 processes each with a 10-connection pool, that's a maximum of 40 possible open connections -- that's probably just fine for your db. **And actually** the only reason you need more than _one_ connection per process is if you do have a multi-threaded app server (see other comment sub-thread above). Without a multi-threaded app server, each process is really only going to be using 1 connection max anyway. But with AR, it'll still be kept open and re-used, not opened and closed with each request. One exception to the idea that your db can surely handle as many connections as you might want, is when you are using a multi-tenant database host or platform that limits your connections. For instance, Heroku postgres makes you pay for certain max simultaneous open db connections, and it's easy to run out of them if you're using a multi-process deploy where each process is ALSO multi-threaded. However, I have no good solution there -- I'm pretty sure there's simply no good way to pool connections between/across processes. There _might_ be some database proxy solutions that would let you do that; each process really connects to the proxy, and the proxy pools connections it uses to connect to the real database. That's the only realistic way I can think of to pool connections between processes. I'm not sure if such tools exist, they would likely be db-dependent, and it definitely wouldn't be worth the added complexity (and perf overhead) unless you had a really good reason for it. I think you have a legit question about Sequel -- how do you pool and reuse db connections with Sequel, instead of opening and closing on every request? I agree you want to make sure to do that. Doesn't matter pasenger or puma or something else, you do want to do that. Sorry, I don't know Sequel though. I wouldn't worry about pooling accross/between processes, it should not be needed. And unless you are running a multi-threaded app server, your pool size can prob be 1 per process. 
Regarding de-indenting heredocs, there is a core extension in activesupport, `String#strip_heredoc`. `require 'active_support/core_ext/string/strip'`.
It says a list? If you have an array, you can call `#to_h` on it or pass it to `Hash.[]` as `Hash[*ary]`. Edit: To get the same semantics with `#to_h` you'd have to slice it first, e.g., `ary.each_slice(2).to_h`.
Wow. Glad to see him back. His videos were super useful to a lot of people I know.
Maybe a post on /r/ruby when done would help. Kudos on the book. Fantastic read. 
Now we just need to hear from _why. I don't care if he comes back, I just want to know if he is alive and well.
Thank you for the for detailed response! I will take a look and play with all these options. At a quick glance, I will probably use delayed_job for this project, but sidekiq will fit into another project that I will be starting soon. Again thanks for the help!
Cheers, glad to have helped! Best of luck building your project up. :)
So happy to see him back. Even if he doesn't continue railscasts
twitter gem? Nice to see him active. 
And here's reddit delivering. Upvotes for you.
Crono #perform should really be #trigger
Vim monster uses rcodetools. Is that gem still actively maintained?
You just don' want to work on ruby in windows. You want to use Linux (Or a mac). 1. Either in a Linux virtual machine on windows (Something https://www.vagrantup.com/ was designed for) 2. Use an online service like https://www.nitrous.io/ which provide you with development boxes and online IDEs. Trying to do ruby work in windows is like trying to win a horse race with a donkey, you are handicapping yourself for no great gain. Finally, whenever following a tutorial look at the date, this one is from 2012 which is Jurassic era in dev terms. try and stick with this year or last year.
For those who don't know why he left, it was burnout: &gt; I had originally planned to return to RailsCasts on September 2, however I do not feel ready yet. I don't want to return until I am fully ready to avoid getting burnt out. It is hard to predict exactly when that will be, but in the meantime I have extended all subscriptions automatically by another month (no need to press a button). New subscribers will be charged the initial $9 and then extended as well. &gt; Thank you for your patience during this time! :) &gt; --Ryan &gt; 
use [pik](https://github.com/vertiginous/pik)
This. If you want to make performance comparisons on 2.1.5 vs 2.2.1, you need to perform all tests on the same system so that you're controlling for every variable except the one you're testing for.
Okay, but what if OP doesnt have access to a linux machine and that's why they're asking? Sure they could dualboot, it's not too hard overall with tutorials, but it's not helpful to tell them to just use something else.
None of the things I mentioned require dual-booting so I am not sure where you are getting that idea from. One is a VM solution on windows and one was a hosted solution. As for telling him to use something else, I rather agree with this opinion when it comes to this kind of thing: http://weblogs.asp.net/alex_papadimoulis/408925
amazingo!
Try profiling it and see if you can pinpoint any hangups or glaring issues. https://github.com/ruby-prof/ruby-prof
Actually I did. Most of the time was spent looking for partials, a significant par of the time was running Dir[]
The author didn't even attribute the comic to Randall. 
Important to note that the message above is from 2013.
I believe Sequel comes with a connection pool already built-in, if you create an instance of Sequel.connect, I'm thinking you're ok for a simple app. Repeating "Sequel.connect" is not necessary, like you said.
If you are using RVM, RVM makes it easy to run benchmarks with multiple versions of ruby. https://rvm.io/set/tests It would be interesting to see the results of the benchmark. Also, posting your benchmark code in a gist would be helpful.
Thanks for this. I'm yet to try IRB. I have Sublime text and use that as my scratch pad. But for when I want to play around with code and then run it, I really enjoyed using FireBug/JSFiddle. 
There's a gem to do this: https://github.com/kmcphillips/acts_as_permalink class User &lt; ActiveRecord::Base acts_as_permalink end 
One liners are fun and all, but if I get hired after you leave I would be pissed that I can't easily figure out what the methods do.
Funny still seeing this pop up years after writing it.
Could try http://repl.it/languages/Ruby
/u/cmd-t the source is mentioned there: http://take.ms/0weY2
That should be `(i+1)%4==0`. You could avoid that business by using `each_slice`, which seems to be slightly faster anyway: benchmark.report('flat_map slice') do whatever = (1..500_000).to_a whatever.each_slice(4).flat_map { |xs| xs &lt;&lt; 'x' } end user system total real flat_map 0.090000 0.000000 0.090000 ( 0.090408) flat_map slice 0.070000 0.000000 0.070000 ( 0.073332)
You are getting a [stack overflow](http://en.wikipedia.org/wiki/Stack_overflow) error because for larger arguments, too many recursive calls are made. Each call gets its own stack frame, consuming memory, and memory is finite. I don't know about the 1.9 Windows build but I can at least tell you that I do get a SystemStackError exception when running that on 1.9.3 on Linux, and on 2.0, 2.1, and 2.2 on Windows.
hilarious really
You're right–I was referring to /u/kovax's example, not yours. I didn't see your version until after I'd posted. Not sure why I didn't think about using flat_map (especially when it was staring me right in the face), but oh well.
You might be interested in this also. This will open a console window in the browser: https://github.com/rails/web-console
Didn't see this until I'd posted and refreshed, but you're correct. Well done. However, this still does incorrectly add an element to the end of the array if it has a number of elements that's not divisible by four. Easily fixed, but something to be aware of. BTW, wanna guess how I know you're a Haskeller? :)
Yeah, the extra element is a subtle consideration I missed. It looks like it can be fixed by chaining another method without affecting performance here. `x:xs` shows up in Scala as well, maybe all the MLs. I did pick it up from Haskell, but you can tell I'm not a real Haskeller, because I used `&lt;&lt;` which modifies `xs` in place. :)
Yep, you're right. I've fixed my code. Not sure how that got mixed up. :)
I understand why I am getting a stack overflow with the 2.0 build. What I don't understand is why the first one does *not* get a stack overflow but instead just crashes Ruby. Is there a known bug somewhere?
Except you've got a double `flat_map`, which slows it down considerably: whatever.**flat_map**.each_slice(4).**flat_map**{ |x| x &lt;&lt; 'x' if x.size == 4 } Benchmark.bm do |benchmark| benchmark.report( "flat_map" ) do whatever = ( 1 .. 1_000_000 ).to_a whatever.flat_map.with_index { |x,i| (i+1)%4==0 ? [ x, 'x' ] : x } end benchmark.report( "flat_map slice" ) do whatever = ( 1 .. 1_000_000 ).to_a whatever.each_slice(4).flat_map{ |x| x &lt;&lt; 'x' if x.size == 4 } end end user system total real flat_map 0.390000 0.030000 0.420000 ( 0.410424) flat_map slice 0.330000 0.020000 0.350000 ( 0.350398)
How does one go about reading that code? Honestly asking.
A quick search of https://bugs.ruby-lang.org shows a 2.2 Mac OS X Dir[] performance regression, but it looks like they were closed as fixed. Here are the links, if this is the same regression, you should report its reappearance and include links to the previous fixes. https://bugs.ruby-lang.org/issues/10631 https://bugs.ruby-lang.org/issues/10015
It's a bit of a mind bender, but the Y combinator is a way to achieve recursion with anonymous lambdas. http://en.wikipedia.org/wiki/Fixed-point_combinator#The_factorial_function If you have trouble understanding the wiki article (and even if you do understand it), I invite you to watch a great presentation on the topic by the late Jim Weireich: https://www.youtube.com/watch?v=FITJMJjASUs
Best Patterns: The patterns are honestly not going to be that different, you just have more tools in the toolbox; and generally it is much easier and possible to keep everything very simple. The biggest mistake I see other Java folks make regarding Ruby is they make too big of a deal about solving particular problems, not realizing that while Java may need a 3rd party lib &amp; 1000's of lines of code, Ruby can do it with maybe a 100 or so. Bear in mind I have a different perspective from a lot of Rubyists on this topic, eg. I strongly disagree with the party line on Dependency Injection being useless/unneeded in Ruby land (most of the rationale I have seen for said statement displays a lack of understanding on what DI is and why it is useful). That is a bit of the Java side of me infecting the Ruby side. Resources: I can recommend 2 books in particular: * [The Ruby Way](http://www.amazon.com/The-Ruby-Way-Second-Edition/dp/0672328844) 1st edition of this book was what really got me into Ruby &amp; what I could do with it when I started ~10 years ago. Note that it is written with the assumption you are already strongly familiar with the basic Ruby syntax * [Metaprogramming w/ Ruby](http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476) this will take you on a whirlwind tour of Ruby's metaprogramming aspects, which are what really set the language apart from everything else, and specifically give it a leg-up over java in terms of programmer productivity. 
Design by Contract and D.I are of course very familiar to me coming from Spring. Thanks a bunch for the advice and book references! This kind of perspective is what I was looking for.
I've heard about pik, but I'm not too confident using a tool that's no longer maintained, and the last update was 4 years ago.
yeah, it is, I worked on windows only until about May of last year. I switched to linux and used it exclusively about 2 weeks ago, and it's amazing what a big difference it makes and how much of a better programmer/ computer user it can make you, just in the way it operates.
Yeesh. That's what I get for writing code on a Friday afternoon. :) You're absolutely right.
Hey Andy, this looks pretty cool! I'm really liking the syntax simplification. I'm considering including this in a few of my gems that currently leverage Concerns to add extra polymorphic association chains to ActiveRecord models. You mention in the article that the Concern approach is really just lipstick on a pig. How are you addressing that problem with SuperModule? What's actually going on under the hood?
This is broken, further, it's *inherently* broken. Observe: module Foo include SuperModule def self.hello self end end Now let's mix it into a class: class World include Foo end Now let's run the `hello` method: World.hello #=&gt; Foo What? The 'self' of the method is still the module, even though we're calling it on the class. This is due to the fact that when you define the method on the class you're just binding a proc wrapper of the method, and the proc wrapper just calls the original method -- which is a *bound* method to the `Foo` class. There is no way around this brokenness aside from doing something horrible with the `method_source` gem and re-evaling the source code in the context of the class. This brokenness alone is enough for me not to use `SuperModule` -- but honestly, this is the kind of project that you should write on a rainy day just for the challenge of it, but not actually use in production, too much magic, too many leaky abstractions, too many edge-cases, and quite frankly just not worth it. :) For the record, I wrote a project much like it, but in C, so it doesn't have the bound method limitation you have in pure Ruby https://github.com/banister/include_complete (no longer works in ruby 2.0+). It's cool you wrote a gem like this, but IMO, not cool that you're actually marketing it as a legitimate alternative to ActiveSupport::Concern. It's cute, but that's it. :)
What is wrong with RubyInstaller?
Look up "methods" and "blocks". You can enter multiple lines of code and they will be "saved as a whole" that you can then invoke later by calling that method within the interpreter. Blocks are just that, (potentially) multiple lines that will execute when you "close" the block. "Procs" are another one, a bit more advanced, but you don't need to understand them completely to achieve what you are looking for (see "call" method re: procs). You should aim to get comfortable writing larger programs in some kind of text editor in the medium term, though; you will not need to employ any of the above structures and could just write things in the order you wish them to be executed. Edit: clarity.
It's just a bug. 1.9.3 is not even supported any longer.
Here is how I would write it: array.select.with_index { |item, index| (index + 1) % 4 == 0 } I decided to test the performance against another version below: require "benchmark/ips" whatever = (1..500_000).to_a Benchmark.ips do |x| x.config(:time =&gt; 5, :warmup =&gt; 2) x.report("flat map") do whatever.flat_map.with_index { |x,i| (i+1)%4==0 ? [ x, 'x' ] : x } end x.report("select with index") do whatever.select.with_index { |item, index| (index + 1) % 4 == 0 } end x.compare! end Calculating ------------------------------------- flat map 1.000 i/100ms select with index 1.000 i/100ms ------------------------------------------------- flat map 8.334 (±12.0%) i/s - 42.000 select with index 18.579 (± 5.4%) i/s - 93.000 Comparison: select with index: 18.6 i/s flat map: 8.3 i/s - 2.23x slower The code above has the benefit of being more intention revealing, and performs 2.23x faster
A bit sad examples are not rendered without javascript enabled. No failsafe solution in such a trivial case :(
Rufus scheduler FTW
The file should not be closed in the ensure block unless block_given is true.
What do you mean by 'pre configured headers for every language but Ruby'? That Python example there looks like it's using standard HTTP interactions to make the request, so there's probably nothing Python specific in the API itself, it just happens to be the language they provided that example in. Unless there's something you're not showing us in the URL that causes the API to return data specific to a given language that's supposed to be parsed as code (something that would be a *really* bad idea). What is the API actually throwing back? XML? JSON? Something proprietary? You'll probably want to write your gem to take the data the API returns and convert it into Ruby objects. I've done it before for the Cisco AXL SOAP API (or at least parts of it) using [Savon](http://savonrb.com/) for the SOAP calls and [roxml](https://github.com/Empact/roxml) for the XML to ruby object bindings. Mind you, I ended up overriding roxml quite a bit to do what I wanted and the public project hasn't been touched for a while, so you might not want to use it.
Agreed. Double splat only looks weird to people because it's new. I prefer it to implicit hashes as the final argument.
 Write Great Ideas Down and Set Them Aside Yup. I've started keeping a simple text file with various refactoring ideas, projects, blog posts, etc. It gives me some place to put ideas so I can forget them and then come across them later and either refine them or execute on them or whatever.
redirect_to simply sends a 302 redirect HTTP header.
Look at the readme. There is another repo it links to as a possible replacement
redirect_to: You give either a url, or a controller/action route (which Rails knows how to turn into a URL). Rails then sends a 302 redirect to the browser. This is a response to the user's browser that says "instead of showing you a cool page, I'd like you to go over here instead". Once it redirects you, it's identical to the situation where you just navigated to the other url directly. It hits Rails as a separate request, goes through the router, gets pointed to a new controller action, and then that does its thing. render: render is how you tell Rails what you should send to the user, for them to see. Render is always called ***exactly once*** in every action. If you don't call render explicitly, it will call it at the end with default parameters (eg. if you hit FooController's bar action, it will render the template in app/views/foo/bar.html.haml). If you call it more than once, Rails will throw an error. Render is how you hook together the controller part of Rails (which knows how to interpret and respond to HTTP requests) and the view part of Rails (which knows how to build a web page to show to the user). Does this clear things up? Feel free to ask followup questions
~~I think your case expression is wrong,~~ try: case dir when 'w' ... else ... end
I was bored, so here's a couple of different solutions to your problem. I'm posting these mainly for you to see some of the cool things ruby is capable of - I find one of the best ways to learn is reading new techniques for solving familiar problems! walk = ['w','n', 's', 'e', 's'] # Final position should be (0, -1) # One solution... def step(dir) case dir when 'w' puts "west" [1, 0] when 'e' puts "east" [-1, 0] when 'n' puts "north" [0, 1] else puts "south" [0, -1] end end x, y = walk .map { |dir| step(dir) } .inject([0,0]) do |result, step| result[0] += step[0] result[1] += step[1] result end puts "Final coordinate is: (#{x}, #{y})" # A different solution... a = walk.count {|dir| dir == 'e'} - walk.count {|dir| dir == 'w'} b = walk.count {|dir| dir == 'n'} - walk.count {|dir| dir == 's'} puts "(Altertative) Final coordinate is: (#{a}, #{b})"
Yeah, that's good :) And another way is Array.new(8) { Array.new(8) { '0' } }
thoughtworks interview, hum? :-)
hah no, actually doing some codewars problems
Well done README with tons of examples. Kudos!
Rack-compatible? It looks like literally all it does is wrap Rack, and then expect you to invoke Rack in order to use it. I feel like I'm taking crazy pills here. What the actual fuck is the point of this?
braver words have not been spoken on a ruby subreddit
you need to learn basics of oop. The article is the model in your system, it would not contain any scraping logic. You likely will need to scrap a bunch of sites differently, so I would maybe make an abstract class that holds common methods for scraping, and then have a single class per websites that inherit from that abstract class has has a distinct scrap method with all the logic to scrape that website and return the data. I would name the scrapers to match the websites name like: class UsatodayCom &lt; AbstractSiteScraper def run scrape #... do scraping here and return a hash of the data {:title=&gt;title etc... return data end end You then would want to make a Factory than can create a new Objects that know that to scrape the urls based on the url pattern: class SiteScraperFactory def make(url) # domain_name = get the domain name from url without dot # class_name = domain_name.classfiy #should be UsatodayCom # klass = Object.const_get(class_name) # return klass.new end end url = "usatoday.com/some-article or nyt.com/other-article" site_scraper = SiteScraperFactory.make(url) Article.new(site_scraper.scrape) 
I think i am understanding what the difference now is..., while rendering is called once, automatically ignoring what url is the user's request and giving another link. While redirect_to first attempts to go to the user's request and then make a detour, making the action called twice. May i know if i understood this correctly? thanks for the reply!
Not quite, but close! redirect_to ignores what the user's request was, and sends them to a different link render is the part of the action that decides what html to send to the user
I read it more like Rack + convention + helpers. Writing a webapp with nothing but rack is doable but involves a lot of boilerplate. And while rack offers a lot of convention already, it (rightly so) stays away from setting conventions in areas such as sessions, persistence, views. There is a good place for a framework there. Even if such a framework is mostly documentation and hardly code.
See if you can get it added to the next http://www.madebymarket.com/blog/dev/ruby-web-benchmark-report.html
Found an example while browsing V8. They use a quick sort until the length is &lt;= 22, then they switch to insertion sort. Big O only matters as the size moves towards infinity. And even then, there are many other things to take into consideration before making an implementation decision. https://github.com/v8/v8-git-mirror/blob/7c347c545e33d279b5aa476e754a5358201be846/src/array.js#L849-850
Just gotta flip `OPT_TAILCALL_OPTIMIZATION` 0 to 1 and you're good to go! https://github.com/ruby/ruby/blob/c8e2ccec862e5c1c3ea2d8ea57c38147c7ed2e26/vm_opts.h#L22 I [walked through it](http://blog.turing.io/2015/02/09/rubys-support_joke-easter-eggs/) for `SUPPORT_JOKE` down there at the bottom.
Author here, I'm sorry for the trouble. I will update the article to reflect some of these issues you experienced.
Thanks for the pointer, fixed them.
&gt; 1.8.7 Just so you know, ruby 1.8.7 has been EOL (End of Life) since June 2013: https://www.ruby-lang.org/en/news/2013/06/30/we-retire-1-8-7/ 1.9.3 is also EOL since 23th February 2015: https://www.ruby-lang.org/en/news/2015/02/23/support-for-ruby-1-9-3-has-ended/ This means that both do not receive any security updates whatsoever.
I would only mention it, as both 1.8.7 and 1.9.3 are EOL (June 2013, Feb 2015 respectively). They should not be used anymore.
Hey there! It sounds like you have two related problems. 1. How to stop and step through code with a debugger in Ruby. 2. How to structure a "sandbox" Ruby project so that you can quickly try out ideas. The good news is, both of these are excellent skills to develop. In fact, I consider both of these essential parts of my "toolbox" as a Ruby developer. I'll try to keep this brief, but here's an overview of what I consider good practice. [I've created a small Github repo for you which demonstrates this stuff.](https://github.com/mhink/example-testbed) (Gotta give credit where credit is due- it's more or less an extremely stripped-down version of [RASK](https://github.com/bokmann/RASK), which I'm absolutely in love with for "large-scale" scripts.) --- First off, it's helpful to "own" your own directory structure. Here's what usually shows up in my testbeds: /.ruby-version Depending on the machine, I use `rbenv` or `rvm` to manage my Ruby version. This file indicates to them which Ruby version should be used when running stuff in this project. Saves a lot of headaches in the cases where you don't realize that you're not running your code against the same Ruby version/dependencies you thought you were. /bin/ This directory is for Ruby scripts that are executable directly from the command line. Generally speaking, I use this directory very little because `rake` (see below) is my usual entry point. /lib/ This is your bread and butter. It's where all the code that will be `require`'d into your testbed will live. Within this directory, you can organize your Ruby any way you see fit. /Gemfile USE BUNDLER. Even for the smallest sandbox. As you create these sandboxes/testbeds over and over, your Gemfiles will begin to be useful records of the tools you're using. /Rakefile If used it already, you'll probably recognize that `rake` is the Swiss Army Knife of Ruby. This will be the main entry point for your testbed. At the beginning of the script, you'll `require` in your Bundler dependencies and the Ruby classes/modules you've stored in `/lib/`, and then the Rake tasks you define will call into those. 
Why wouldn't you just use pry?
My own reasoning would be because we need a healthy ecosystem of tools.
Your comment isn't very helpful. What makes this choice healthier than pry?
OP is saying that having 2 (or more) gems with the same goal is healthy as it encourages both to keep innovating, which is better for the end user. 
Will look into it. Thanks for the link!
Stylistically it seems pretty good. I might do an extract method on line 23 and name it a method that describes what is happening. Also line 25 could probably be written to be a little more readable. These are subjective judgements on style though. Also I don't think you are implementing a general binary search. Ex/ I don't think that this would work: BinarySearch.new(range: [1,2,3,7,10,15,20,59], target: 7).find[:index] this should return the index associated with 7 which is 3. I think to get it working for a general case you might have to change lines 23 (to work on the indices and not the values), line 32 to check array[index] == target, and line 36 and 40 to be something like array[0..index.pred] and array[index.succ..-1]. I don't have time to boot up the code right now and have written comment without running it...soooo I could be wrong. EDIT: My comment is for an old version of the code here: https://gist.github.com/revdan/7e47c3c893e24c220bdf/c7635973fe9294b7d075816a21754c02062f58ee
A general response to this thread of comments: If something seems redundant, lacks adequate detail, is silly or down-right stupid then chances are it wasn't meant for you in the first place. When you feel like "of course x = x and y is y. I'm not a moron!", remember you are not the only person reading the docs. Documentation serves multiple audiences and is always a complex balancing act between them. The documentation will shift and change as the audience of Eldr changes. The same thing applies to the framework itself. If it seems stupid, redundant etc -- maybe you wonder why "does this even exist?!" or feel like "of course it is rack all fucking frameworks are built on rack!" then it probably isn't the framework for you. There is probably a framework for you out there and if there isn't, well, go and build it! I wont be hurt if what I built isn't for you just don't try and ruin it for the people it is for. But I'm sure most of you were just seeking upvotes for your clever jokes and weren't trying to provide actual critique. I was not your audience.
Thanks!
irb packages everything in the same gem and pry is modular. It can take a few minutes to get pry setup for a project because everything is packaged as separate plugins. For most projects the tradeoff for having modularity/hackability is worth it -- what is a few extra minutes on a 50+ hour project. But irb can be useful when you just want hop into some random code instantly. Edit: Remote Sessions are not actually in irb. Example remove.
What happens in Array#mean if the array is empty? 
Some thoughts: 1. Use keyword arguments instead of the `opts.fetch` shenanigans. 2. Why monkey patch `Array` with a method your only going to use once? It only makes the code more confusing. 3. What does `zone_in` mean? It's not a very descriptive method name, how about `search`? 4. Why isn't all of `BinarySearch` static? As you can see in the tests, you only every use it this form: `BinarySearch.new({range:(1..1000)}).zone_in...`, that is an immediate indicator that you don't need to instantiate an instance of `BinarySearch`, that call should be `BinarySearch.search({range:(1..1000)}, 53)`. Additionally `BinarySearch` doesn't work when `zone_in` is called multiple times, the count doesn't reset, another sign it should be static. 5. The `RangeSlicer` class is a completely unnecessary abstraction. It exists only to make the code appear 'more engineered' while actually making it 'harder to read'. 6. What's the point of a `private` `attr_reader`? 7. Your method to test thread safety isn't a great idea, actually I don't even know what it's attempting to test. In general I would say this smells like an attempt to create the most wtf enterprise worthy approach to BinSearch possible. Algorithm Issues: 1. The entire concept of calculating the mean value of the array doesn't work in any sort of general way. Just start at the midpoint of the array and bisect from there. As it sits, I wouldn't really call this `BinarySearch` but more just a really slow way to search a range.
&gt; Why monkey patch Array with a method your only going to use once? It only makes the code more confusing. I agree but, given that this requires an array, I think OP should monkey patch Array with a binary_search method. It's always a good learning experience to reimplements STL functionality. Plus, you could look at the MRI source if you needed a hint.
thanks! fixed
Nowhere apparently. After a quick google search, I'm pretty certain my memory was wrong. oops. Sorry about that.
Keyword arguments allow defaults, that is part of their reason for existing: def foo(bar: 'default') puts bar end foo() -&gt; 'default' foo(bar: 'test') -&gt; 'test'
I don't think I've ever taken more than 10 seconds to type `gem "pry"` into any `Gemfile` or just use `$ pry` because it's installed by default on my system?
+1 This was one of the best fundamental updates to the language in ruby 2.0+; using the "old style" workaround in favour of this is silly!
When writing tests, try to write the descriptions of `describe` including any nested `it` / `describe` blocks as if you were reading them in full. That is, read this: describe 'SomeClass' do describe '#some_method' do it 'does something' describe 'when using something else' do it 'does something else' do end end end end As this: SomeClass#some_method does something SomeClass#some_method when using something else does something else This makes it easier to grok what's going on, especially when looking at the output of test failures. Some good examples for this: * https://github.com/rubysl/rubysl-socket/blob/25fab7dfad24c1a6e48dc29b82ae1e2443922b73/spec/addrinfo/initialize_spec.rb * https://github.com/rubinius/rubinius/blob/3682bd3dd118c08110979c6fe029b79d7362d4b3/spec/ruby/core/array/bsearch_spec.rb
How is that better than New Relic?
Has anyone used it yet? How does it compare to terminal-table?
You'll probably want to ask /u/jdlshore since these were his tweets :)
Does this work for you? class BasePage def load(url) go.to(self.class::URL) end end
Where are the libraries? How can I connect to postgres? How do I write a web app or a desktop app?
Yea, that's a major problem of ruby, the release cycle doesn't really match the vendor cycles. Usually, you'd use $PATH trickery and something like [rbenv](https://github.com/sstephenson/rbenv) to get around that. Personally, I'd solve it using docker or other ways of container stuff, just to encapsulate it. Makes me glad I don't have to do it server side anymore. 
This works, but you forgot to remove the "url" arument from the method :) I can't see a cleaner way of doing this if the URL is saved as constant, but then I have to ask: Why is it saved as a constant? If you used an instance variable instead, this whole problem disappears: class BasePage def load puts "my URL is: #{url}" end end class LoginPage &lt; BasePage attr_reader :url def initialize @url = '/login.html' end end Also, once we've done this, we could remove the use of inheritance (which may be desirable; I can't say without more context): module LoadablePage def load puts "my URL is: #{url}" end end class LoginPage include LoadablePage attr_reader :url def initialize @url = '/login.html' end end
I'm not sure if I'm following the OP properly, but I'd make it a method call, not a constant. Having code in a superclass call a method that might be over-ridden by a sub-class is pretty ordinary. class BasePage def load go.to( self.page_url ) end def page_url raise "Sub-class must implement page_url" # or use a default home page? end end def LoginPage &lt; BasePage def page_url "http://example.com" # Or, sure, return LoginPage::URL if you want end end LoginPage.new.load # works just fine There are other ways to clean that up or make it more flexible, but that shows the basic pattern, which is perfectly ordinary OO polymorphism. Sure, you could do it with module mix-ins instead of classes (mixins are nothing more than multiple inheritance in ruby, don't let anyone tell you otherwise)
Well, Enumerable itself does it. If you mix-in Enumerable, "The class must provide a method each, which yields successive members of the collection." But yeah, if you wind up with lots of such requirements, rather than one or two methods that must be implemented, it gets messy. The method required by the mixin should probably be fundamental to the 'thingness' of the thing in some way. Ha, that made no sense. The alternative is writing methods that take arguments, but the arguments are still going to need to be of some 'type'. Meaning, have methods the implementation expects them to have, duck-typing still relies on the thing being able to quack like a duck. It's sort of a kind of duck-typing, I don't care what you are, but you have to have a #name like a, um, named duck. Whether it's an argument or the host class. But yes, I think you are right to try to make these expectations as concise and elegant as possible. (And in your code example, you're missing a method definition in PrintName which makes it a little bit more confusing, I have to guess on what you meant, and I think I guessed right). 
Okay, so instead of raising, BasePage can have a `page_url` that just takes you to the home page. Now it's not an "abstract" class at all. Shrug. Inheritance in general can get tricky, there are some people who are against inheritance hieararchies at all, think inheritance was a bad idea in OO in the first place, and want to find a way to do it without inheritance. I think that's a valid approach (but invalid to think using module mixins is anything but inheritance, it's not an alternative). The alternative to inheritance is 'composition', helper objects. class PageLoader def load_url(url) go.to(url) end end class LoginPage attr_accessor :page_loader def initialize @page_loader = PageLoader.new end def load page_loader.load_page(my_url) end end That's the way to share code implementation without inheritance. Some people would like it better. Does that feel better to you? It also gets you "dependency injection", you can easily switch out the `@page_loader` for another if you want. I don't know if either one is really 'the ruby way' over the other. But 'prefer composition to inheritance' is a good guideline. Or, sure, you could do it in a super-class, instead of a helper object, but without relying on specific methods being present, pass the argument explicitly: class BasePage def load_page(url) go.to(url) end end class LoginPage &lt; BasePage URL = "http://example.com" # Note this method is `load` which takes no args, but it calls # superclass `load_url` which takes an arg. def load self.load_url(URL) end end I don't know if that's what you meant to write in your original example? Your original example has errors, so I'm not sure what you meant, but I don't think there's anything wrong with what I just wrote either. Or you could do the same with a module mix-in instead of a super-class -- but the module mixin provides a `load_page(url)` method that takes an argument, instead of assuming that the host class will have a #url method. Again, module mixins are really nothing more than multiple inheritance. If the module _only_ has that one method, `load_url`, it seems reasonable. All are valid choices, IMO, for this simple toy example, without context. (I would _not_ do it based on assuming the host class has a certain constant, rather than method. Stick to methods in your "contracts"). I think coding is a craft, you just got to get the feel for it. Hopefully looking at all of these alternatives helps give you some ideas. 
Personally, I think it's helpful to think of module mixins as nothing more than multiple inheritance (of an abstract base class, since you can't instantiate a module mixin directly, you can _only_ include it in another class, effectively as a superclass). And it's got all the downsides of multiple inheritance. I think many rubyists are rather too quick to reach for it, out of a misguided belief that it's somehow an alternative to inheritance. You use it whenever you need multiple inheritance, when you're going to need to mix it in to more than one class that does not share an inheritance hieararchy. I think you are on the right track with your suspicion of it's use here, relying on the concrete class to implement certain methods. A helper object as in my example in another post is an alternative. But when mixins are well-designed and work, they work well. Enumerable is an example of one that works well. You can't avoid "coupling" entirely of course. Objects working together will have to assume _something_ about the objects they work with. But yes, you want to make these assumptions targetted, clear, comprehensible, documented, ideally tested with automated testing. (Trying to make objects assume _nothing_ about the other objects they work with just leads you down the over-abstraction path to Java FactoryMethodFactoryConstructorFactory).
Thanks for clearing it up for me jrochkind. It's a hard concept to 'grasp' when your coming for compiled languages. Would you prefer to be more elegant and write methods with arguments or since it's already require duck-typing, you just directly addressing the class? I guess the secret is to keep your modules short, simple so the concrete class owner can quickly understand what he needs to implement. 
I think in this case, I'd use a method with an argument in the superclass (or module mixin), or use a helper object (composition). It's hard to tell in this example, because the module only depends on one method in the host class, which can be fine. (I'd depend on a method, not a constant though!). But since this is just a toy example, and the nature of the method depended upon, I could see it grow to depending on a lot more (or have other modules used in the same class depending on yet other methods), which would be less fine. &gt; I guess the secret is to keep your modules short, simple so the concrete class owner can quickly understand what he needs to implement Absolutely. 
lies « statistics « bechmarks « biased research « own "studies" 
Module/Inheritance: * Yes, my quick answer there does introduce a bit of coupling. Your solution does not, but then it could have been written without any form of inheritance, and just used a helper class: . class PageLoader def self.load(url) go.to(url) end end class LoginPage URL = '/login.html' def load PageLoader.load(URL) end end Is this approach better? Maybe. I can't possibly say from just a few lines of code. I'd have to see the rest of the project -- what's the existing coding style? How to the different pages relate to one another? How are other dependencies loaded? ... * You can always do a "raise ArgumentError" sort of thing in the base class/module, if it's becoming a cause of concern. * When choosing to use a module/inheritance pattern, I tend to look at two key things: Does it make sense to instanciate an instance of the base class? And, does the base class "own" anything (e.g. define its own instance variables). If the answer to both of these is "no" (as is the case above), then inheritance is probably a bad idea -- bt like I say, it might make sense in your project, depending on the wider context. Constants/Variables: Constants in ruby are a bit crap. Nothing is *really* constant, in the way you're probabyl used to in C# or whatever. For example: [1] pry(main)&gt; TEST = "hello world" =&gt; "hello world" [2] pry(main)&gt; TEST = "this is a constant, right?" (pry):2: warning: already initialized constant TEST (pry):1: warning: previous definition of TEST was here =&gt; "this is a constant, right?" [3] pry(main)&gt; puts TEST this is a constant, right? Or what about private methods in ruby? [4] pry(main)&gt; class Klass [4] pry(main)* private [4] pry(main)* def cant_call_me [4] pry(main)* puts "Oh... Maybe you can!" [4] pry(main)* end [4] pry(main)* end =&gt; :cant_call_me [5] pry(main)&gt; Klass.new.cant_call_me NoMethodError: private method `cant_call_me' called for #&lt;Klass:0x0000000227ec80&gt; from (pry):10:in `__pry__' [6] pry(main)&gt; Klass.new.send(:cant_call_me) Oh... Maybe you can! In other words, there are various valid techniques to dealing with "constants" in ruby, but none of them are perfect. The exact way you choose to implement this will depend on the rest of your code. As a general principal, therefore, I like to use "barewords" when possible - check out this great webcast on it: http://devblog.avdi.org/2012/10/01/barewords/
I've seen Shelly Cloud being promoted in the past but I have to admit that I just glanced at the pricing and didn't look into what they actually DO. Since jrochkind was impressed then I took a second look and they do seem quite impressive indeed. Automatic backups, zero downtime deployments(with 2+ app servers), simple setup of things like ElasticSearch, apparently simple scaling and so on. I'm impressed as well. Of course, it comes at a price obviously but still. 
What?
Now make sure Unicorn stays up. Bonus points for supporting zero-down-time deploys.
What do you mean? This is a sample app deployed to two platforms and the result of simple stress tests. Nothing less, nothing more. I added a link to the application repository and I gave command. You can run this test by yourself and check the results ;)
Well it could just be me of course, but at first glance I didn't previously get the whole "we are more like Heroku than we are like a VPS provider". Explaining up front that you have automatic managed backups and load balancing / scaling out of the box couldn't hurt though!
Two of these are data serialization formats (arguably not data stores, but close enough I suppose), and the other five are data structures, not data stores at all.
The receiver is accessed using `self`. For example, you can upcase the first element of the receiver like so `self[0].upcase!`. Maybe I just don't understand the context of these lessons, but I'm a little concerned over how weird the code is. It is not idiomatic Ruby at all. For example 1. `define_method(:upcase)` instead of `def upcase` 2. unnecessary use of `self` 3. unnecessary temporary variables e.g. `upcased_string` 4. unnecessary empty parens `()` 5. misuse of `each` instead of `map` Here's how I would do that first exercise in beautiful, idiomatic Ruby. class Array def upcase! map!(&amp;:upcase) end end
This seems a bit too fast for a beginner video (if it's meant to be for beginners). Changing classes like that is more intermediary material. Also while everything you need to know somehow is in the video (as you will see soon) it is not really explained. The main 'trick' in this case is `self`. Self is the object. She uses `self.each` to access the elements of this object and pushes the changed elements into an array (using each here isn't the best way, that should be a `map` operation, but anyway...). A better way would look like `["a", "b", "c"].map(&amp;:upcase)` though that's not what the video is about. So since you can access the array content with `self` you can obviously (or maybe not that obviously) use it to change those elements. class Array define_method(:upcase!) do self.each_with_index do |s, i| self[i] = s.upcase end end end That's not the most elegant way, but I'm too lazy to make it perfect and that's most likely what the video expects you to do. In most cases to think about a problem is to split it in smaller tasks until you reach a level where you can solve it with those basic building blocks like loops. Often you have a complex data structure and want to apply some functionality on it's basic elements like in this case. Sometimes you just need to break it up, in other cases you would want to filter certain elements. From there you will often build up new data structures. Often enough just the same array you started with, just each element modified. Another very common thing is to merge elements into smaller things (very typical would be a sum over an array). But in this case the confusion was only about how to use self which is simply a matter of learning the basic syntax. This should have been explained in an earlier video.
Thanks for the reply. In the intro video, they explained that the coding will be a little redundant and less efficient at first. Which explains the overuse of () (probably to drive home where each method is in the block. Or self to describe what is going on in the code. 
The receiver is the object on which the function is being called (basically what precedes the '.' in a method call). In Ruby, typically, methods that are called on arrays and strings return copies of the original (.upcase returns a COPY of the string with all uppercase letters) and the original isn't changed, while functions ending in '!' actually change the original object(receiver). In some languages, like Python, objects are often immutable, which means you can't even change the original. In Ruby, it's not always the case. What they're asking you to do is write a function that changes the original, so that if you run string = 'hello' string.upcase! then string #=&gt; 'HELLO' whereas string = 'hello' string.upcase string #=&gt; 'hello' If you use a method like .upcase, you have to assign it to a variable to access the changed string, because it creates a new object (a copy of the original). http://ruby-doc.org/core-2.2.0/String.html#method-i-upcase And like the other dude said, the way you access the original object from within that object's definition (its class definiton), is with 'self'.
Why would you do your helper class with class methods? Those are essentially global methods, you're just using the class as a namespace. Use a real object, and now you can even switch it out for another object 'dependency injection' style, for free. 
Thanks. Full disclosure: I'm the guy that wrote Sidekiq and Inspeqtor so I'm slightly biased. I wanted a good tool to monitor Rails and Sidekiq in production.
that is killer!
I was just hacking together something very quick as a proof of concept... I really don't think you should be reading too much into this, especially given how little is known about the wider context of the application. But yes, I would probably use instance methods for this. It really depends on what the "load" method actually does! Notice I didn't pick on your unnecessary use of "self", or un-rubyist use of 4 spaces ;)
can you explain how map!(&amp;:upcase) works?
`map!(&amp;:upcase)` is the equivalent of `map! {|item| item.upcase}` `map!` will iterate through the array and replace each item by what is returned by the block passed into it. In this case, instead of specifying a block for `map!` a Proc is passed in. The Proc can be used in place of a block. [Symbols have a `#to_proc` method](http://ruby-doc.org/core-2.2.1/Symbol.html#method-i-to_proc). The `&amp;:upcase` is just syntactic sugar for calling the `to_proc` method on `:upcase` symbol. This method returns a Proc, if you're not familiar with Procs, you can think of them as wrappers for blocks. The Proc takes an argument and sends itself as the message. So the Symbol#to_proc implementation might look like this: def to_proc Proc.new do |obj| obj.send(self) end end
Have you required 'spec_helper' in your spec file or, your .rspec file ?
oh wait yeah now it came back to me, right. What set me a bit off was the "missing" object that's calling the map! method. It's not really missing but it's an implicit self, right??
Yup, it's an implicit self, which in this case is the instance of the Array.
Well that's a straw man argument. AFAIK there are no gems for "opening a file for reading". I googled too. I am not aware of anyone who recommends gems for something that can be replaced by one line of code. The hyperbole is strong with you.
I'm not really an 'expert' by any means, but in response to your second question, I usually just open irb (actually pry, but whatever) and just start experimenting. I think failing often on your way to a solution is better than just sitting and "thinking" how something might be done right the first time.
For the record, your module isn't doing what you think it does -- you didn't define a method :)
&gt;AFAIK there are no gems for "opening a file for reading". It was just meant to be a made up example.
The top of your test is explicitly requiring the file. Do you have a spec/spec_helper.rb file already? If not, just create a blank one. You can put any global rspec configuration or initialization in there if and when you need it later. If you do have one, maybe your require path is having issues. You can try using `require_relative 'spec_helper'` if you just have a `require` instead.
Thank you for the advice! It turns out, I just manually deleted all of my Ruby files and then reinstalled 1.9.3, and it seems to work now. Also, I think what could have happened though was I typed "rspec --init" several folders back (I think this means in the same PATH? Sorry, I'm new to Ruby), so when I was actually in the directory I needed to be in, the "bundle exec rspec spec/(spec file).rb" command was getting all confused. I deleted the spec folder and spec_helper file, along with the .rspec file that "rspec --init" created in my User directory, and everything seems fine now.
Oh man - good luck with epicodus. Those folks are *awesome.*
Oh yeah? How do you rate it? Anything I should know to expect going in?
Same tests against https://ninefold.com/ please.
This is called the [template method pattern](http://en.wikipedia.org/wiki/Template_method_pattern)
Huh? a module is (effectively) a superclass. In your case the module requires some methods to be implemented in the subclass in order to do its thing. This is exactly the template method pattern.
OK, I see your point. I was sure your implying to abstract class or interface being a 'template' to concrete classes. 
The "snake" is redundant. The following runs exactly like you'd expect: [1] pry(main)&gt; def no_snake(param="default1", *, named_param: "default2", **) [1] pry(main)* puts "param: #{param}, named_param: #{named_param}" [1] pry(main)* end =&gt; :no_snake [2] pry(main)&gt; no_snake param: default1, named_param: default2 =&gt; nil [3] pry(main)&gt; no_snake("hello world") param: hello world, named_param: default2 =&gt; nil [4] pry(main)&gt; no_snake(named_param: "hello again") param: default1, named_param: hello again =&gt; nil [5] pry(main)&gt; no_snake("hello", named_param: "one more time") param: hello, named_param: one more time =&gt; nil [6] pry(main)&gt; no_snake("hello", "ignore", "me", named_param: "one more time", other_param: "ignore me too") param: hello, named_param: one more time =&gt; nil The only time I'm aware of that you "need" to use the underscore placeholder in ruby is as a placeholder for blocks, e.g. my_object.method_that_yields { |var1, _, _, var2| do_something(var1, var2) } Edit: Actually, just realised - another (normally "bad") similar use is when you only want to save some variables returned by a function: var1, var2, _ = method_that_returns_an_array_of_3
I did now! For some reason I heard about the 'template pattern' on a different context. Thanks! :)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Composition over inheritance**](https://en.wikipedia.org/wiki/Composition%20over%20inheritance): [](#sfw) --- &gt; &gt;__Composition over inheritance__ (or __Composite Reuse Principle__) in [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) is a technique by which classes may achieve polymorphic behavior and [code reuse](https://en.wikipedia.org/wiki/Code_reuse) by [containing other classes](https://en.wikipedia.org/wiki/Object_composition) that implement the desired functionality instead of through [inheritance](https://en.wikipedia.org/wiki/Inheritance_(computer_science\)). &gt;Some languages, notably [Go](https://en.wikipedia.org/wiki/Go_(programming_language\)), use type composition exclusively. &gt;==== &gt;[**Image**](https://i.imgur.com/CPB2TM0.png) [^(i)](https://commons.wikimedia.org/wiki/File:UML_diagram_of_composition_over_inheritance.svg) - *This diagram shows how the fly and sound behaviour of an animal can be designed in a flexible way by using the composition over inheritance design principle. [1]* --- ^Interesting: [^Inheritance ^\(object-oriented ^programming)](https://en.wikipedia.org/wiki/Inheritance_\(object-oriented_programming\)) ^| [^BaseBean](https://en.wikipedia.org/wiki/BaseBean) ^| [^Liskov ^substitution ^principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle) ^| [^Object ^composition](https://en.wikipedia.org/wiki/Object_composition) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpxqi45) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpxqi45)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I found this to be helpful. Thank you.
From [the FAQ](https://docs.npmjs.com/misc/faq): &gt; The first seed that eventually grew into this flower was a bash utility named "pm", which was a shortened descendent of "pkgmakeinst", a bash function that was used to install various different things on different platforms, most often using Yahoo's yinst. If npm was ever an acronym for anything, it was node pm or maybe new pm. &gt;So, in all seriousness, the "npm" project is named after its command-line utility, which was organically selected to be easily typed by a right-handed programmer using a US QWERTY keyboard layout, ending with the right-ring-finger in a postition to type the - key for flags and other command-line arguments. That command-line utility is always lower-case, though it starts most sentences it is a part of.
When in doubt, destroy everything! 
Hi! Original article author here. Let's start with a simpler example, like 123. A permutation is all possible rearrangements: 123, 132, 213, 231, 312, 321 There are 6 options, which is also 3 * 2 * 1. How can we see this? Well, we have 3 choices for the first digit (1, 2 or 3). Once we have picked that, we have 2 choices for the next digit, and only 1 choice for the third. The factorial computes the number of choices we have because it's doing the work for us (decrement and multiply). If you actually want to print the permutations, you can go the same way: have a loop that picks an item, prints it, removes it from the list, then continues with the next items. (So if you pick "1" at fist, then you only have 2, 3, 4, 5 for the remaining things to print.) See if you can get the permutations for "123" and then extend it to "12345". Eventually you'll probably want a recursive function for this.
Great article, thank you ! Actually If I have 123 and I choose to split the numbers to [1,2,3], I will change the first with the next in the array. so 123 will become 223. How will I proceed to the next number? One logical explanation would be to try every number, which seems a bit like sudoku. Having 123 I change the first digit: 123 -&gt; [next in the array][next in the array but "different from the rest two"(?)][3]. What's the idea ? 
I've had trouble with the following; it gives me a script parsing error (malformed syntax): def callee(some_var, one: nil, two: nil, **rest) # do some stuff end def caller(some_var, one: nil, two: nil, **rest) callee some_var, one: one, two: two, rest.merge( {random: true} ) end It says there's a syntax error on the line that executes `callee`. Any idea why?
It's not ridiculous. It's very complicated for me! Why did you use `each_with_index`?
No prob, glad it helped. So, the trick isn't to replace items in the existing array, but to create new arrays. For example, we start with [1, 2, 3], the full array, and pull out the first item. Now we have: [1] + [2, 3] which is closer to what we want, the first item is fixed and we can loop through the remaining items. The general idea is For each item in the array, pull it out as a the prefix For each of the remaining items, pull it out as the prefix Keep going until you have only one item left. Print out the prefixes then this item. So it'll be something like [1] + [2,3] =&gt; [1] + [2] + [3] [1] + [2,3] =&gt; [1] + [3] + [2] [2] + [1,3] =&gt; ... [3] + [1,2] =&gt; ... 
The Ruby interpreter can't parse that without you helping it along a little bit. Try def caller(some_var, one: nil, two: nil, **rest) callee some_var, { one: one, two: two }, rest.merge( {random: true} ) end
dat localhost
We have regions in France and Canada so EU and NA
When I said "I hardly ever use any gems at all" I mean that most of my code does not depend on any gems. That doesn't mean that most of my projects have an empty `Gemfile`, it just means when I add a gem to a project, I am generally confining its use to where it is most helpful. And there are very, very few gems (any?) that I will install when I start a new project. &gt; I can't help but think when I read things like this that you must not be doing anything very complicated. That is untrue, but I think you interpreted my post as NIMBYism. It is not NIMBYism. I don't bang out JSON parsers by hand, or write my own templating library, etc. I do tend to avoid frameworks, though, and I've had a lot of success writing good software without one.
I tend to agree with you concerning frameworks. Frameworks seem to really get in the way on any long term project. Sometimes even on short term projects. 
Thanks for the blog post! However, I would also encourage developers to understand and leverage their existing tools as much as possible before adding additional complexity (and points of failure) into their applications. Postgres offers Materialized Views which are capable of providing similar cached representations of the decaying score, and very efficiently at that.
This is a tutorial I made showcasing the [Volt framework](http://www.voltframework.com). The [end product](https://typing-calculator.herokuapp.com/) is a typing speed calculator that updates in real time as the user types. Volt allows you to accomplish this with Ruby code only by using the [Opal gem](http://opalrb.org/) to compile Ruby to Javascript. This is one of my first tutorials so feel free to leave any issues or tips on the comment section of the blog or on here. 
Maybe it is a good idea but i am not sure if they still allows to create new apps. I will consider it for the next blog post ;)
Ugh. This is what I've been trying to do for some time with RVM and Sinatra. Not pleasant, I might add... I'll probably try eye. Hope it helps.
Why not just run an update query every N minutes instead of pushing it to ES?
The only issue with PG's materialized views was blocking readers during refreshes. It could get nasty as your dataset gets larger. Fortunately that is fixed on 9.4 if you use `REFRESH MATERIALIZED VIEW CONCURRENTLY`.
Pretty cool, I hadn't bothered to look at Volt before. Something that jumped out at me looking at the github repo is tidy up your code a little. There are lots of arbitrary spacings and trailing whitespace in the templates especially but also elsewhere. You could consider covering how to test your application in a follow-up, since it's ruby everywhere it'd be quite interesting to see how it's done. 
Thank you for the advice, I'll make sure to tidy up the code. I'll also try and add some testing once I'm proficient at it.
Awesome. Always love a Volt demonstration! One thing I'd note; you don't need a database for this particular project, so MongoDB is not actually necessary.
This thread has been linked to from another place on reddit. - [/r/programming] [I just released a Ruby Gem for visually analyzing GitHub data. (X-POST /r/ruby)](http://www.reddit.com/r/programming/comments/317f89/i_just_released_a_ruby_gem_for_visually_analyzing/) [](#footer)*^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote. ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
Yeah. &gt; Ninefold decided to close their App Deployment functionality and the US region. This means that you have to migrate your entire Rails application before 24 May 2015. In this blog post, I will show you how to move your stack to Shelly Cloud. * http://help.ninefold.com/apps/how_to_migrate_your_rails_app_off_of_ninefold/ * https://shellycloud.com/blog/2015/03/how-to-migrate-rails-application-from-ninefold
I wouldn't recommend learning a language by looking at other projects, that comes after. I would recommend reading a proper book. ["The Ruby Programming Language"](http://shop.oreilly.com/product/9780596516178.do) does the job.
http://ruby-doc.org/core-2.2.1/Object.html#method-i-is_a-3F
I am new to Ruby but this seems like it would work def add(word, meaning = nil) @entries[word.to_sym] = meaning end If you just pass a string to word it will set its value to nil but if you pass a string to both word and meaning it will set it.
I would say the opposite. I learnt using trial and error. I tried to make a real life program, and whenever I came across an error I googled it. I rarely make the same error twice.
Are you learning Ruby in order to learn Rails? If so, look at Michael Hartl's free [Ruby on Rails Tutorial](https://www.railstutorial.org/). In it, you actually build a web app from the ground up. It's also a good way to see how Ruby classes and methods interact with each other.
Just a hint, you can use string interpolation in order to simplify your code. Like such: earthquake_levels = [1, 5, 9.1, 9.2, 9.5] earthquake_levels.each do |v| joules_formula = 10 ** (1.5 * v + 4.8) energy_joules = "%.4E" % joules_formula energy_tnt_tons = "%.4E" % (joules_formula.to_f / 4.184e9) puts "#{energy_joules} Joules or #{energy_tnt_tons} tons of TNT" end 
I don't. I'm also reading a book :) But sometimes a real project can learn you a lot compared to code sections from a book.
http://codereview.stackexchange.com/questions/tagged/ruby?sort=votes&amp;pageSize=15 But better avoid [ruby-on-rails] tag.
Thanks for this! Pretty cool. We're kind of similar, but I'm trying to provide graphs for pretty much everything, as well include multiple user accounts in the same graph for comparison.
Nice work and I recommend calling the gem git_graph
If you use JRuby (which runs Ruby on the JVM) you can call Java from your Ruby code. Really great for leveraging existing code.
Something relevant and interesting: A while ago, I stumbled across [this pull request](https://github.com/ruby/ruby/pull/791), trying to add the method: Regexp#to_proc to the ruby core library. The idea of this method was simple - just like how you can already do: some_object.map(&amp;:some_method) # (Symbol#to_proc) Which is equivalent to: some_object.map { |yielded_object| yielded_object.some_method } The proposed pull request would allow you to also do something like this: some_object.select(&amp;/pattern/) As a shorthand for: some_object.select { |yielded_object| yielded_object =~ /pattern/ } **However**(!!!) - As I (and others) pointed out, this can already be achieved perfectly well with Enumerable#grep: some_object.grep(/pattern/) Thus making Symbol#to_proc redundant. So you won't be seeing this addition made in (core) ruby, but feel free to have a go implementing it yourself, if you want a challenge!
How about...ask questions. Java was on my resume, Ruby wasn't. I got a promotion and a reassignment to something they no I have zero experience in.
Thanks. I just learned about selenium today. I'm on Ubuntu and that version of Mozilla was having NONE of it. Had to switch to chrome default and things magically started moving. Unfortunately the readability is for the ease of use of the client, so we're sticking with that. It's about looking pretty, not just coverage.
Is the JSON well formed? Are API calls that should error causing an error properly? For each API call, are each of the data elements that you expect to be delivered being delivered? If the API points should be allowed only by authed users responding to unauthed users? Authed users? Are edge cases that have been fixed for any of those things specifically tested... You know, testing.
Agreed. Secure whats behind the routes, not the routes themselves. We have nothing to hide.... in our routes.
Err... Marijuana guides? Sounds... interesting. 
Its an open source site for growing stuff, don't act like it wasn't the first thing you thought of too!
 Use String#to_sym, see String class docs for more details. irb(main):001:0&gt; 2.send( '+'.to_sym, 2) =&gt; 4
Heads up, your huge logo could be saved to the dimensions similar to the div its placed in and, you know, optimized for web. =/ Starting image: 2M Optimized: 5.6K Anyways thanks for the link -- interesting gem...
a single-element array? so why not: ["+".to_sym] or -&gt; s {[s.to_sym]}.call("+")
Ah yes this works, thank you. I tried this earlier but I wasn't branching properly. Thanks again!
no problem. 
IMHO monkey patching should need a pretty high watermark, over use of monkey patching is one of my biggest pet peeves.
&gt; Unlike with PRY, you are still in your normal IRB. Honest question: why do I give a shit if I'm in my normal IRB? Pry is better in almost every way than IRB right out of the box, and either way I need to get a gem for the extra functionality.
Sorry I meant complex from an API consumer point of view as explained in the article. ActiveSupport::Concern's implementation is inspiringly simple and elegant. However, the solution from a consumer's perspective can still be considered over-engineered due to requiring extra ritual and boiler-plate code to simply call and define class methods instead of the developer "simply calling and defining class methods" with no extra overhead. With our programming jobs requiring us to deal with talking to project stakeholders, analyzing business problems, architecting solutions that address additional non-functional security/performance/usability concerns, writing team-maintainable code, thinking of information presentation in HTML/CSS or some widget-library, moving across multiple programming languages like Ruby and JavaScript, thinking about data persistence structures and optimizations, among many many other things to deal with just to deliver a tiny piece of working software, it is VERY IMPORTANT to cut the FAT everywhere it is discovered to help stay as focused as possible on delivering software value while upping productivity and quality. ActiveSupport::Concern discovered and cut some of the FAT in Ruby's self.base(included). SuperModule discovers more remaining FAT and cuts it out as well.
NOTE: Originally I only read a few lines of your reddit reply before I closed the browser and got to other work, so I just noticed you mentioned the method_source library too. Please ignore my ignorance about it in my other response. Just took a quick look at include_complete. Very nice. I wish I've heard of it before. The problem it solves has frustrated me for a long time, and I never liked ActiveSupport::Concern's DSL lipstick solution for it. Nonetheless, I see two gotchas in it, which might have hindered its adoption: * Due to reliance on C extensions, it is not vanilla JRuby friendly (even if JRuby is starting to support some form of C extensions lately) * From an API design standpoint, it puts the onus on the consumer to remember to use include_complete, which would not work with any externally written modules not aware of include_complete, thus limits its use only to internally written modules, greatly discouraging developers from adopting it. **On the other hand just like ActiveSupport::Concern, SuperModule is written in pure Ruby, thus supporting JRuby and Rubinius out of the box; and its use from the Ruby gem producer side encapsulates its API mechanics from consumers, thus allowing consumers to continue to include external library modules (in this case super modules) with basic Ruby include syntax.**
 2.2.1 :001 &gt; :"+" =&gt; :+ 2.2.1 :002 &gt; 
&gt; a salaried position working with Cucumber/Ruby You poor bastard. Cucumber is the pits.
Cucumber doesn't depend on Selenium. It's common to use it to control Capybara, and Selenium is one of the drivers it supports, but there are other options such as Capybara Webkit or Poltergeist which are often faster since they don't need to start up a full app.
Why wouldn't you test that it's returning what you expect it to return in the JSON, not just that it's returning JSON? I think one of the best guides to writing tests is whatever you are testing manually with your own eyes. When you finished writing `getPersonDetails`, you did something to make sure it actually worked, right? You executed it somehow. And sure, you made sure it returned a JSON hash and didn't raise an exception. But did you look at the JSON hash to make sure it contained what you expected it to contain? If it had returned `{}`, that'd be valid JSON, but is that what you expected it to return, would you have thought "great, it's json so it's working"? Whatever you're testing by eye/hand, automate that test. Eventually you realize there's seldom reason to test by eye/hand at all, instead of writing tests. 
yes
I've picked it up. I've only had time to read the first chapter but I liked the way he wrote it. Here's the table of contents: 1. What Makes Ruby Code Fast * What Makes Ruby Code Slow * Optimize Memory * Get into the Performance Mindset 2. Fix Common Performance Problems * Save Memory * Optimize Your Iterators * Write Less Ruby * Takeaways 3. Make Rails Faster * Make ActiveRecord Faster * Make ActionView Faster * Takeaways 4. Profile * Measure with ruby-prof * Visualize with ruby-prof Printers * Visualize with KCachegrind (QCachegrind) * Takeaways 5. Learn to Optimize with the Profiler * Takeaways 6. Profile Memory * Detect Excessive Memory Usage * Profile Memory with Ruby-Prof * Measure Memory Yourself with GC#stat and GC::Profiler * Takeaways 7. Measure * Minimize External Factors * Make Internals Behave Predictably * Analyze and Compare Measurements Using Statistics * Takeaways 8. Test Performance * Benchmark * Assert Performance * Report Slowdowns and Optimizations * Test Rails Application Performance * Takeaways 9. Think Out of the Box 10. Tune Up the Garbage Collector
You are right. From OPs description it sounded like he was going to be doing unit test which is why I suggested moving away from it. 
Rspec is for unit tests and other developer level tests. cucumber is for acceptance testing and integration testing. Vastly different requirements.
RHEL 6.3 shipped months after Ruby 1.9.3, but still only had Ruby 1.8.7. So it's not really a release cycle problem.
I love DAS but I'd say it's more for an intermediate/advanced level of developer than someone new to Ruby.
This doesn't really cover Ruby in depth, but it is a superb guide to good OOD, and is suitable for all levels.
I'd recommend holding off on Metaprogramming Ruby until you have a solid foundation. You can do plenty in Ruby without ever needing any metaprogramming.
Ping 
http://exercism.io/ - solve problems, get code review. In the meantime, review other people's code. You'll learn as much (or more) by reading and trying to give useful feedback than by solving the problems themselves. It's an awesome site.
This guy is 100% accurate, if exercisms are easy, and you're not an asshole, you'll get a job.
definitely has taught me some stuff so far!
I figure the syntax is simple enough and the API documentation is readily available online. Any sufficiently motivated person can wing their way through grokking basic ruby. Languages aren't hard. Frameworks are hard. Good application design is harder. 
The point of Exercism isn't just to implement something that solves the problem; they are typically very easy with Ruby's standard library. The point is for you to refactor after you've solved the problem to make use of objects. I don't want to make assumptions about your work, but that's something I often see even experienced developers struggle with, especially when they see simple problems. 
Does anyone know his book? Is it good for a medium minitest guy?
Try: * [SPOJ Sphere Online Judge](http://www.spoj.com/) * [Hacker Rank](https://www.hackerrank.com/) They both have a good selection of algorithmic problems that will stretch you much further. Another good resource in the field of BioInformatics is: * [Rosalind](http://rosalind.info/problems/locations/) The people behind Rosalind (I think it's the same team) also have 2 great BioInformatics courses on Coursera: * [Bioinformatics Algorithms (Part 1)](https://www.coursera.org/course/bioinformatics) * [Bioinformatics Algorithms (Part 2)](https://www.coursera.org/course/bioinformatics2) I'm not sure how, but I think part 1 has been split into separate, shorter courses.
screaming
gelastic
It is not Ruby. It is Rails. Why is it so hard to understand?
if you just use a API, rails maybe is big for this, so, maybe sinatra. :)
I mean, the URL has rails in it, so presumably SOMEBODY knew
I tend to prefer Sinatra for lighter-weight projects like this, though of course it's a matter of personal preference. You may find [sinatra-activerecord](https://github.com/janko-m/sinatra-activerecord) interesting. 
Also take a look at [https://github.com/rails-api/rails-api](https://github.com/rails-api/rails-api)
rails validators do a lot more than what the example code does, so it's more code that does less. Cleaner in a certain sense I guess...
I would never recommend someone new to development use sinatra for a publicly facing API (frankly even most ruby developers should stick with rails). There are a lot of things rails does that are important regardless of the type of rendering used. There should be very little logic in your view layer anyway so I'm not even sure where the idea that rails isn't suited for apis comes from. 
Maybe divide the problem into two: 1) data storage and access and 2) display/manipulation in browser (mobile or desktop using bootstrap 3?). Now, I have a shortcut for 1) -- use https://github.com/begriffs/postgrest/blob/master/README.md. It's a simple backend API you can easily run on Heroku or some such service with most the work already done for you. You could get a basic version running in a day and test it out. It's also open source and fast and standards compliant and probably better than a homespun backend you'd build in the same amount of time. I'd dig around with a toy project during an afternoon using this if I were you. For 2), that's the meat of your project it seems. I'd spend most learning time on this problem instead. Maybe try something very basic with no special styles at all or any complicated front end JavaScript framework? I'd be cautious with scope creep... front end is very easy to blow time on; figure out if your project is gonna work in reality first with small experiments. You can test things with jsfiddle even. I'd caution against waiting too long before doing a very simple early rough draft actually deployed somewhere public. It's very easy to get lost in the weeds. 
There are a bunch of helpful libraries and online examples for making json APIs in rails. Sinatra would be a fun way to build it too potentially, but if you're project is more than just a personal experiment, and you're asking this question, then sticking with rails would be a better idea. If you're building this primarily to learn stuff, I'd suggest building it in rails and sinatra in parallel at first. That will let you do it bare-bones in sinatra, with less magic involved so you understand everything, while keeping anchored to sanity via rails, which if you're following a good guide, will show you sensible, maintainable, ways of doing things (which you can really fail at in sinatra if you're doing something new). At some point down the line you can shelve whichever one seems less promising. &gt; database tables will have a limited constant number of rows that represent variables rather than objects/resources Can you elaborate on that? 
Yes, you can do this with Rails. Make sure to disable some of the middleware that you don't plan on using, like session-related middlewares, to improve performance, among other things.
Why are these posts downvoted? I have been reading on Sinatra a bit and it seems to be VERY easy. 
&gt; Can you elaborate on that? Yes, sorry I didnt make it clear. My backend, if I manage to make it that is, will analyze data samples that it will get from another third party api (this is approved by said api owner), and save to its database various stats, such as averages, of various variables. Therefore, I will not need the kind of models and resources that Rails seems to focus on (well they could be useful, but Im not sure this is the intended use), because the number of rows of my database will be limited and final, one for each statistic, does this make sense? This is for a contest and I have very limited time, I need to get it done fast and I dont care about security or optimization. I'm even actually considering calculating said stats locally with my computer and hardcode them into the backend if things go wrong, but I really would prefer to do it with an API for obvious reasons (reutilization of the project for similar things, making changes, learning...) Thanks!
Try writing a migration and then running the rake task. Db:migrate runs the migrations doesn't it? Rails generate would write the file but Sinatra you have to do that part manually I've had good luck with sequel and Sinatra. If active record keeps giving you problems, check out the sequel gem.
Second this. Jbuilder is terrible, I've had to rip it out of all my production projects. AvtiveModel::Serializers is fast, nice to write, and is similar to the way you would to it in another framework.
Though I can't see myself applying this pattern any time soon it was an interesting read and gave some food for thought.
All of those examples are contrived. Have you ever had a real world app with a user model like that? 
If the data will change and you will need to recalculate them, you might consider storing them in something like redis, instead of database. In your case, it seems like there won't be any searching or calculations over your data (the one you have in your local database). That means, you don't really need database at all. If I understand this correctly, you are going to check some third party API periodically and update some kind of calculated data you want to serve over your own JSON API. In that case, you could just store the calculated data in memory, for faster access. Also you might consider storing final JSONs instead of the data, if you are not going to work with them (stuff like searching etc.)
I took a look into redis before, but maybe its not the best option since it seems to be some sort of key-value database (maybe I'm wrong, I didnt read much on it), but I need to group data, not just a bunch of key-values. &gt; If I understand this correctly, you are going to check some third party API periodically and update some kind of calculated data you want to serve over your own JSON API. In that case, you could just store the calculated data in memory, for faster access. Also you might consider storing final JSONs instead of the data, if you are not going to work with them (stuff like searching etc.) Not exactly: I will get some data from a third party API to get the calculated data and save it, and from then on said calculated data will never change. The reason for a backend for this is to be able to make changes and for serving the same for the mobile app and the web frontend, although hardcoding the data into both of those is actually an option. Either way, the data needs to be persistent since it will only be calculated once. Anyway I'm starting to realize that maybe the design I have in mind doenst really make sense after all... Its the first time I do something like this.
This tends to be a very downvote-happy sub. It's getting kinda old, honestly. Another commenter in this thread mentioned that you get more for free with Rails, which is certainly true and it means that a project put together by a relative newbie is less likely to suffer from the various common security pitfalls. You also get other handy things with rails, like database connection pool management and so on. But on the other hand, I'd say that you'll learn way more about ruby if you use Sinatra, because you'll have to build something from the ground up and pull in other components to work with Sinatra (like ActiveRecord). So really, I'd say you should choose Rails if you want to build something production-ready *right now*, or Sinatra if you like its smaller footprint and/or your primary goal is experimentation and learning ruby *the language*, not Rails *the framework*. It goes without saying that before you deploy a web app to a serious production environment, especially if that web app deals in personal data, you should understand the common security pitfalls and how to avoid them. That's true whether you're using Sinatra, Rails, or any other framework.
Oh. My. Word. That's exactly what I needed! You mentioning rake db:create_migration made it all click. I'm off and running now, thanks a ton! 
What is brew?
I had this exact problem an hour ago. gem install therubyracer
As a counter counter point: https://github.com/digitalocean/kartograph
Maybe try reading the [docs](http://jekyllrb.com/docs/installation/), node (or another javascript runtime) is needed to support coffeescript which is needed by jekyll. So choose your bloat or your your site generator... 
By the way, if you want to give the migration a certain name: `rake db:migrate NAME=some_migration_name`
jbuilder is very slow, because the rails view pipeline is very slow. When using jbuilder, in order to DRY up your JSON models, you end up creating template partials and including them in loops and in other views. Well it turns out the `partial` command takes forever to run, and it often runs dozens of times per view. Apps that are primarily JSON APIs will see the majority of their CPU time is spent in the stupid `partial!` method, needlessly. Here are two relevant GitHub issues addressing the performance concerns. As you can see, the issues are closed without resolution (other than to use `cache`, which is unacceptable). https://github.com/rails/jbuilder/issues/45 https://github.com/rails/jbuilder/issues/127 Wouldn't it be nice if you had a tool that was as beautiful and expressive as jbuilder but was also fast and didn't mess around with saving your code as view templates? Something you could test directly without having to invoke a controller action? That's what `ActiveModel::Serializers` is! By writing serializer classes, you are doing things the same way you would do them if you were writing in other languages or frameworks and enjoying code reuse and fast performance.
Huh. The more you know. I know Rails does so much of this for you and the 'syntax' to do it is a little simpler to remember. But I'm excited to learn a way to use all of this outside of Rails. I'm working on a small project for work and our development team has all of their stuff set up using Sinatra and ActiveRecord, so I'm trying to work within those boundaries. 
I can understand Jekyll's view that it's not Jekyll's job to decide which JS runtime to use and automatically install, although it could do a better job of explaining the error. They discussed it quite a bit [here](https://github.com/jekyll/jekyll/issues/2327).
Just as a defense for Redis- it is a key-value store, but it's a *really fast* key-value store which supports lots of types of values that can be super useful in some cases.
&gt; calculated data will never change If this is the case, then using redis is pointless. Depending on the amount of the data, I would also consider an option of statically generated site, with something like middleman. But this is only viable if the amount of data isn't huge and you don't need to do any dynamic content at all. That also means no localization (middleman can do this, but it would be pain compared to other solutions), authentication or updating content. Also disclaimer upfront, I have never actually generated json with middleman so I can't tell how complicated it would be. Middleman can use different templating languages, so it might be possible to use jbuilder. ActiveModel Serializers should always be possible to use. So how it would work: You would download and preprocess all the data from third party API upfront locally. You would generate some kind of data file (ie. csv or yaml) or local database. Middleman for example works nice with yaml files, but I would not consider processing megabytes of text file data an "elegant" solution, and "elegant" is what ruby is about :). So consider this upfront when gathering your data. If the amount is not huge, small yaml would be nice. Then you would write your templates for json and html sites in language you prefer (erb, haml, slim, jbuilder) and build static versions of all the pages you have on your site, based on this local data. Result would be a lot of .json and .html files with your data hard coded inside. Advantages: - Result is blazing fast. You can't get much faster than that, without some magic. You could host it on AWS S3 in free tier and you are set. - Since the pages are static, there is nothing to secure. - You know upfront what you are getting, so no surprises. Disadvantages: - You would need to regenerate all the pages locally if you would want to update the data. This is biggest one, so really think before going this way. If there is possibility you might want to update the data later, it could be less comfortable than other solution. - If you ever leave the project and someone else might get it after you, they might hate you if you won't leave the middleman source for them :) 
is where your message goes, its posted on the supplied link
How do you handle versioning with AMS? I always struggle with that, and keep coming back to Jbuilder because it's just ridiculously easy to version views with it. And personally, I don't want to build an API without versioning...
^Smile ^Link ^Bot ^is ^currently ^in ^beta. ^Please ^leave ^feedback ^if ^you ^encounter ^any ^issues. ***** Please consider using this link to **Amazon Smile** and Amazon will donate a percentage of the price to the charity of your choice. [http://smile.amazon.com/Exploring-Everyday-Things-Ruby-Learning/dp/1449315151](http://smile.amazon.com/Exploring-Everyday-Things-Ruby-Learning/dp/1449315151?%74%61%67=%72%65%64%73%6D%69%6C%69%6E%62%6F%74%2D%32%30) ***** ^Learn ^more ^about [^Amazon ^Smile](http://smile.amazon.com) ^| [^About ^this ^bot](http://www.reddit.com/r/smile_link_bot/wiki/index) ^| [^Leave ^feedback](http://www.reddit.com/r/smile_link_bot)
I think you'll find the switchover very easy.
https://github.com/sagivo/algorithms Here are a bunch of algorithms done in ruby.
I don't know such resources myself, but would also be interested in seeing what anyone else can offer. 
The book was written with beginners and intermediates in mind. You can download the first two chapters for free and see whether or not it's what you're looking for. Disclaimer: I'm the author. :)
Anyone used it on production? It works be nice if anyone could your their experience. Looks very interesting.
Ruby algorithms and data structures: https://github.com/kanwei/algorithms Data Structures and Algorithms with Object-Oriented Design Patterns in Ruby: http://www.brpreiss.com/books/opus8/ Basic Data Structures and Algorithms in Ruby: http://www.theodinproject.com/ruby-programming/data-structures-and-algorithms
Take a look at Russ Olsens book http://designpatternsinruby.com if you're used to the Gang of Four and patterns, it's a great walkthrough from old to new, he's a great guy as well
Have you tried running this text? It should be pretty trivial to open irb and run it or to put it in a script. That said, this, in isolation, will give you an error.
I am done with this beyond giving an example (assuming I am actually able to get anything out of your two posts -- its fng hard). Assuming I was able to read these two really obtuse questions/posts, how about in English: Hi, I am trying to create a ruby application which presents a editable text area to be shown natively (not in a browser) on linux/mac/windows platform. I would like to be able to use True Type Fonts inside of this editable area and I have some still as of yet unknown/weird coordinate needs too. I am unsure where to start. Can anyone offer any help? Is this more readable than: Looking for suggestions for ways to **some fragments of an internalized solution or assumption around a solution to a problem that I will not state**,. **some fragments of an internalized solution or assumption around a solution to a problem that I will not state** and solution works (**mind you I have not really stated a problem yet, so you have no idea what a solution could be**) on GNU/Linux Mac OS and Windows. By your username I am assuming you are Brazilian or Portuguese, please accept that I am not really criticizing your English -- but your issue of not really describing a problem, but instead spitting out random things that in your head are (or must be at least in your mind) related to a problem. Its like you have had a ton of internal dialogue about this but are just randomly taking elements of your own thoughts instead of conveying the real problem to people that are new to it and have no access (thank god) to your thoughts. 
A bit on the subject, but I wrote a blog post a while back that attempts to explain Rack as simple as possible: [What is Rack in Ruby?](http://www.whynot.io/ruby/what-is-rack-in-ruby/)
Clever Algorithms, google it. I have a pdf if you need one
Autoloading is actually provided by active support, the dependencies module. You can include it in any project and be good to go. However, learning how to manage dependencies is a good, general programming skill, and it's useful to go without auto loading unless it's super necessary.
Wow from what I can see some of you guys are really liking my site. If anyone could tell me how to run it in production mode that would be awesome!
The thing about algorithms is: the language doesn't matter. Various languages are similar enough that if you are proficient in one, you can generally read the others without much trouble. Patterns just do not vary so much that you won't recognize things like variable assignments, conditionals, loops, etc. You should be able to look at an example in Java, study it, and the implement it in Ruby. The difficulty will be in understanding what the code is doing, and reading it in Ruby isn't going to be any easier in that regard. 
One option if you're using active support: require 'active_support' ActiveSupport::Dependencies.autoload_paths = [ 'lib/' ]
I think `URL` should be `DATABASE_URL`
Should it actually be the word: "DATABASE_URL" I just used URL as a place holder... Doesn't the URL that heroku gives me go there? The postgress://username:password@host/db Something of that sort?
I haven't used DevDocs (so forgive me if I'm missing something big), but it's interface reminds me of [Dash](https://kapeli.com/dash). I just checked and it has a LaTeX docset, so that might be another option for you to check out if you're unable to find someone to build a DevDocs integration.
http://ruby-doc.org/core-2.1.0/Module.html#method-i-autoload
It's how Heroku passes along configuration from their end to you. It includes both infrastructure information, and any information you hope they keep secret for you (like encryption keys, service credentials, etc). Read a bit about on the justification for it [here](http://12factor.net/config).
Think of environment variables as a special hash that is built into Unix (Linux/MacOS). Different applications can all access it. Ruby gives you direct access to it through a hash called ENV.
Good book, but it's not about algorithms.
It's probably a bad ENV var. Here's the deal: * Heroku follows the [12factor](http://12factor.net/) methodology, which puts most configs inside of `ENV` vars. These variables are set from the Heroku panel. Some of these vars are preset for you. * In the case of Heroku SQL, the ENV var is already setup for you. * Heroku lists ENV vars inside of `https://dashboard.heroku.com/apps/YOUR_APP_NAME_HERE/settings` Check out your ENV vars and make sure there isnt a typo.
I've had such problems due to Rails' auto-loading, I consider it an anti-feature. 
&gt; Can I make games in Ruby? Yes as in mostly any other language. &gt; Which framework will be good for it? There are various game libraries and bindings to game engines. Which one would be good would very much depend on the kind of game you want to write. &gt; Will they be better than games in Python? No. Also not worse. It depends on your programming and design skills. But depending on your specific type of game it may be easier to find good libraries for one or the other. Also there are other languages, I hear that Lua is used for scripting in games. If this is mostly about some simple game to start, it won't matter much which of those languages you use. If you want to start a larger project you should google it. Maybe put the decision about the game engine you want to use first (if you want to use one) and decide about language depending on what users of this game engine prefer. This question is discussed over and over again (Not only Ruby vs Python but mostly any other language). You should google this, since there is much more information about this online than a random question here can give you. http://www.reddit.com/r/gamedev/comments/26oq4m/is_ruby_viable_for_video_game_development/ http://gamedev.stackexchange.com/questions/3574/is-ruby-a-suitable-language-for-game-development 
Hey! I'm the author. The book is a collection of my experience building support for DSLs for my client work. Other developers on my projects have been interested in the techniques to make any metaprogramming easy to understand and debug so I made a book about it. (Although it's not all metaprogramming) The price goes up from $12 to $24 tomorrow, so today's a good day to grab it if you're interested.
True, my thought was that learning to translate patterns gives insight into how ruby works differently which should help him translate algorithms written in other languages. Otherwise studying some of the code in the standard libraries might help as well, there are plenty of algorithms in them. 
If by testing library you mean the rspec expectations pieces then sure, you need a testing library otherwise, not so much. And sure, you can write full-stack tests in rspec but have fun getting a non developer to make sense of them. And lastly, yes you CAN fire up cucumber to do a unit test. The times when that makes sense are vastly outnumbered the times where it doesn't. 
For sure, i'm just wondering if the resources are out there because i want them to be in a language i am most comfortable with to start. 
Just a quick note that I made a new release today, [SuperModule v1.1.0](https://github.com/AndyObtiva/super_module), with the following changes: * Brand new `self`-friendly algorithm that ensures true mixing of super module singleton methods into the including base class or module, thus always returning the actual base class or module `self` when invoking a super module inherited singleton method (thanks to [Banister](https://github.com/banister) for [reporting previous limitation on Reddit and providing suggestions](http://www.reddit.com/r/ruby/comments/30j66y/step_aside_activesupportconcern_supermodule_is/)) * New `included_super_modules` inherited singleton method that provides developer with a list of all included super modules similar to the Ruby `included_modules` method. * No more use for method_missing (Thanks to Marc-André Lafortune for bringing up as a previous limitation in [AirPair article reviews](https://www.airpair.com/ruby/posts/step-aside-activesupportconcern-supermodule-is-the-new-sheriff-in-town)) * New dependency on [Banister](https://github.com/banister)'s [method_source](https://github.com/banister/method_source) library to have the self-friendly algorithm eval inherited class method sources into the including base class or module. * Refactorings, including break-up of the original SuperModule into 3 modules in separate files * More RSpec test coverage, including additional method definition scenarios, such as when adding dynamically via `class_eval` and `define_method` I am going to write more test cases before I leave v1.1.x in peace. Please use this time to experiment with SuperModule, incorporate into your projects, and report additional feedback.
Generally when you want to memoize a value like this you use @expense ||= build_expense The &amp;&amp; version would always evaluate build_expense if @expense exists, and would short circuit when it does not, which is the opposite of your desired behavior.
Generally you would want to use: def expense_data @expense ||= build_expense end But you also have to trade off performance. Mainly asking two important questions. 1) Is build_expense allowed to return false or nil? 2) Is build_expense computationally intensive even if returning false or nil? I don't necessarily believe these apply to your situation but for the benefit of anyone else thinking about using the "||=" pattern. If yes to both these questions then you need to watch out. nil and false values of @expense will cause build_expense to rerun each time it is called. ex/ def build_expense some_expensive_method_that_can_return_nil || false end In view: &lt;div&gt;&lt;%= expense_data if expense_data%&gt;&lt;/div&gt; This would cause the some_expensive_method_that_can_return_nil to be run twice if "||=" pattern is used. 
 def expense_data @expense ||= build_experience end This way @expense is memoized like /r/lumancerErrant said. The next time expense_data is hit, it'll see that @expense already has a value so it won't call build_expense.
In regards to `each_with_object`, same here - I sometimes forget to use it. It can be useful at times. In any case, this article can be something that I can point newcomers to. 
I read this as Daniel Radcliffe and was very confused for a while.
Harry Potter and the Postmortem of Gem Availability
For the last case, this is what I'd use ``` [Person.new, Person.new, Cop.new, Person.new].collect { |x| x if x.can_be_robbed? } ```
Same. Even though I know it says David I keep reading it as Daniel.
It depends on your use case. Note that the `take_while` method only returns 2 `Person`s, whilst your method returns all 3. `take_while` steps through the array, one element at a time, and stops when it reaches the first Cop. (I.e. the first object for which the block returns false.) `collect` is acting more like a `map`, so is executed on *all* objects in the array. This is a very different behaviour.
glad this is the top comment. my first thought was "man, harry potter codes in ruby, eh.."
Yep it's kinda like a free online version of Dash. I've been using Dash but wanted to switch when I found DevDocs.
What is "self" in your second example? That should answer your question, hopefully. 
[Apparently, Google is confused, too](http://i.imgur.com/715q80D.jpg)
Ruby's an object-oriented language -- By defining the behavior of objects in classes, a programmer can write code which resembles the behavior of objects in the real world. For larger applications, this abstraction tends to be preferable over writing all programs as a strict sequence of commands. Take some time to read up on object-oriented programming. I think the question you're asking is "Why have multiple classes? Why not make everything one big class?" Check out [Chapter 1](https://books.google.com/books?id=VRCv_bATuSIC&amp;pg=PA1&amp;source=gbs_toc_r&amp;cad=4#v=onepage&amp;q&amp;f=false) of Practical Object-Oriented Design in Ruby, by Sandy Metz, and consider the intricacies of stepping on cats!
&gt; Without specifying a class, what does that mean? It means, firstly, that I execute speak out in the open, not after any object. It also means that self is meaningless. self won't refer to any object (since I don't execute this method on any object). self will actually refer to the main function (the function in which all the code you write executes). You can't iterate over that. It just does nothing. It's pointless. Technically, `self` will always refer to the receiver which isn't decided at definition time, but at call time, e.g.: def speak self.each {|i| print "#{i} and "} end t = [1,2,3] method(:speak).unbind.bind(t).call &gt; 1 and 2 and 3 and =&gt; [1, 2, 3]
Thank you for this! Follow-up question: why make a class when you could just supply an argument for a created method (like in your last example)? 
I hope this sets a precedent, and paves a way for other open source software communities. A lot of this stuff is really important to a whole lot of people and businesses, and very few of them have a meaningful way (and unfortunately interest) to support the projects they use to make money off of. I think OpenSSL really opened a lot of people's eyes about open source software and that it needs to be supported full-time. For mission critical software, that shouldn't really be owned by a single company, I think Ruby Together using the non-profit model is a great idea.
Oh yeah, hang on, I misread this - I guess kshadeslayer meant to use `select` here, not `collect`, because the above code is wrong!! You'd actually need to either do: [Person.new, Person.new, Cop.new, Person.new].collect { |x| x if x.can_be_robbed? }.compact or [Person.new, Person.new, Cop.new, Person.new].select { |x| x.can_be_robbed? } ...Since the original code would just return an array with `Cop`s replaced with `nil`!
As long as you're not trying to directly sell something, I think it's probably fine. A link to your GitHub project should be fine. A direct link to a live app is probably okay too, as long as you don't have to register or anything (and it'd be nice to provide a link to the source code as well if you really want to discuss techniques, strategies, etc.). A link to buy your app on the App Store for just $2.99 would most likely not be kosher. I'm not a moderator or anything, so that's just my two cents' worth.
To come to better abstractions. Additionally to what /u/socket_wrench said, I suggest to look into CRC (Class Responsibility Collaboration). That is a fairly easy concept to arrive at classes which covers basic aspects. In Ruby there are numerous ways, not only classes and methods with additional arguments. We also have modules and adding methods to individual objects. Maybe if you study Ruby's standard library you'll get a grasp how classes are defined and what they can be used for.
I'm fine with it too, but my point was that there should be *something* "free" about the link - e.g. an extract from the book, or a subset of the podcasts publicly available, or whatever. The link should be more than *just* an advert.
 if 9 * 36 sum = "&gt;5" print "Congratulations!" else sum = "&lt;5" print "Failure!" end This doesn't even make sense. I can see what you're *trying* to do (I think), but there are several mistakes. First, let's try spacing it out: (FYI: One-line if statements like this *are* possible, but you need to add a `then` after the `if` condition. However, this is generally a bad idea - space your code out!!) if 9 * 36 sum = "&gt;5" print "Congratulations!" else sum = "&lt;5" print "Failure!" end Why are you setting a `sum` variable to be these strings?? Surely you wanted to make a comparison instead! So, let's try again: if 9 * 36 &gt; 5 print "Congratulations!" else print "Failure!" end Next, in ruby, `print` does not add a new line character to the end of the string, whereas `puts` does. You almost certainly want a new line to print, so let's fix that: if 9 * 36 &gt; 5 puts "Congratulations!" else puts "Failure!" end I'd probably stop here. But if you want to make your code more compact, since it *is* fairly simple, you could squash this into a one-line if/else statement by using the [ternary operator](http://stackoverflow.com/questions/4252936/how-do-i-use-the-conditional-operator-in-ruby): puts (9 * 36 &gt; 5 ? 'Congratulations!' : 'Failure!')
Isn't `token_authenticatable`deprecated in devise?
We use [New Relic](http://newrelic.com) and it does a fantastic job.
We are considering new relic - was hoping for open source alternative. 
&gt; The other alternative is to install nodeJS but that requires you to now get familiar with an entirely new environment and ecosystem. Excuse me, but how exactly? I've installed NodeJS as my JS runtime several times pretty much brainlessly...
Well, usually (and a generic good practice) basic functionality should be placed under mygem.rb and all extensions or libraries that provide functionality to the gem, should go under the mygem folder. Some people, as you say, use the mygem.rb file as a gateway to just load/require/extend other files into the gem namespace. Depending on what you want to achieve with the gem, this might be a good practice as well. Maybe you want to define a gem that provides many extensions to another app or library, maybe you want to create a gem that is self-contained in all its functionallity or maybe you just want to create a standalone binary that uses the gem extensions for different purposes. As a rule of thumb, the mygem.rb file should be where you define the core namespace for the gem and its basic functionality, the rest can be splitted and structured inside the mygem folder. 
But what if I don't have 'basic functionality'? the Gem is basically a place where I dump all my common code. Almost like a set of helpers used across all the three project. Each file is a stand alone entity without any 'basic functionality' I can share on the main gem rb file.
That creates scaffolding for the gem. I usually organize my folders and files according to modules/classes. For example a folder might represent a module while a file might represent a class. It all depends though.
Graphite-tattle seems to be a bit of a dead project (I implemented it and it works though with a few bugs and gotchas) so I'll add [seyren](https://github.com/scobal/seyren) to alerting platforms that use statsd/graphite. StatsD is awesome in that it's UDP and you can measure metrics as well as time things. 
Yes, I'm sorry. I should have been more consist. Indeed 'common_gem' and 'mygem.rb' are the same gem. So what you suggest is this (note that I'm following the mygem.rb example this time around): mygem.rb: require 'mygem/setup' mygem/setup.rb: module MyGem module Setup def self.init # Common setup for all project end end end And when you want to use the gem from the app: require 'MyGem' MyGem::Setup::init Is that correct?
Looks like you got a ton of good info here. Figured I'd pass along a free course I wrote, which might also help: http://brandonhilkert.com/courses/build-a-ruby-gem/
Thanks, I wasn't aware of the convention between file system storage and module namespace. I'll change my Gem to support this. Does it mean that my 'my_gem.r can only include 'require' calls, and that my app should require this only instead accessing the specific files? So technically, I should require all my files from my_gem.rb, and then call them so from within my app: require 'my_gem' MyGem::Foo:Baz Instead what I currently do - which is leaving my_gem.rb empty, and accessing it this way: require 'my_gem/foo/baz' MyGem::Foo:Baz
Thanks brandon, I'll check it out! :)
We use it as well. With a company sized budget, it is well worth it. The stats are really amazing. Response time broken down into every layer. Server stats with CPU and RAM usage broken down by app, disk IO. It's incredible.
If you want something similar, check out a gem called `require-all`.
where does phantomas fail at providing this information?
In the code that you have shown there is no point having a class. That's one of the nice things about Ruby, you can write just enough code to do what you want, you aren't force to write a heap of boiler plate just to get something trivial working. Ruby allows your code to evolve as your requirements become more complex. For example, you might start with a simple procedural script. The control flows from the top line by line down to the end and exits. Then as you add more functionality you might find you are duplicating functionality, or you have some areas that have complicated logic. You might then take these parts of your code and create functions that you can call. By moving the repetition or complex logic into stand alone code blocks you will simplify the core of your program making it easier to understand and maintain. Then as your program grows you might find that some of these functions are related. Maybe they carry out related operations, maybe they operate on the same variables, maybe they need to share state, maybe if you could group some of their local variables into a separate container and move them out of the functions they will become easier to understand and work with. Now you have a case for creating classes. A Class is a container for similar functionality that operates on shared attributes and state. Just like adding functions to your script made it easier to use, so to does adding classes. 
Thanks, I last researched that part of things a few years ago.
maybe. i am having trouble understanding how any other tool could succeed in providing this information based on your given scenario. by this virtue, my impression is that all tools are synthetic in that they are not actual users, under constraints based on geolocation or software preferences interfering with normal network behaviors. ideally, automating these kinds of benchmarks would just cover the MOST popular scenarios and situations. normal 4g user for example, normal desktop user, etc. not so much worried about super users as an edge case at this point
Why does your Angular example store the auth data in a cookie effectively sending the data twice for every request? localStorage is a better approach. If your going to send a cookie with every request, you may as well just let devise set the user in a session cookie. But, if you really want to use `$cookies` you should at least set `secure: true` to avoid leaking the e-mail and token on non-ssl requests and should probably also check for a secured request in your interceptor to avoid leaking the headers. 
Well at least it's not on the most dreaded list.
Would have to agree. Especially when I saw Notepad++ as the top editor. That makes me question the rest of the statistics. 
Because Ruby developers are too busy having fun developing while the other guys spend their life on SO. Rubyists weren't even aware that there was a survey.
Lol. Notepad++... What a joke.
That is borderline nonsense. 
 Your code runs fine over here. A few notes though. You should never use global variables. Either the method ```load_board``` should return the game board or you should implement this using classes which will allow you to have state (i.e., store the game board in an instance variable ). Also, check out the docs for [Array](http://ruby-doc.org/core-2.2.1/Array.html) as there are definitely a few methods in there that will help you end up with more concise code. Good luck!
Obviously not always the case, but Ruby at scale can be a nightmare to deal with. Especially in highly concurrent systems.
Not enough need for self assurance Too much getting shit done?
Very nice list! I am assuming that this list isn't ordered by most popular gems cuz gems like devise and rails api aren't at the top. Bookmarked for reference.
Ruby's biggest problem is that she doesn't take her love to town
Accept the one true language as your lord and saviour lest you spend the afterlife as a Wordpress plugin developer. As penance, I want you to recite one red green refactor, and ten chunky bacons. 
maybe becauce the survey also states that most favourite text editor is Notepad++
well it make sense &gt;A little over 50% of developers were on windows machines. On windows you don't use "text editors", you use IDE's. If you are going to use a text editor for the occasional file type not supported in the IDE, notepad++ is the most common choice on windows.
I spent some spare time over the last year learning the basics of Ruby, and I've finally given up. Why? Multiple incomplete ways of doing things really annoyed me. For example (and this is going from memory, so correct me if I'm wrong), in earlier versions of Ruby, a hash was defined: key =&gt; value All good. In later releases, you could use: key: value Great, makes sense. However, IIRC you can't use this new method if the key (or value?) is a symbol, so: :key : :value isn't valid, but: :key =&gt; :value is. (again, I'm going from memory here) Ruby's introduced a new way of expressing something, but sometimes I can't use it and have to go back to the older method. What a PITA. As a newbie, I spent hours trying to work out why my new hash wouldn't work, until I stumbled on a post that explained it. I appreciate there's a lot of dedicated Rubyists, and I'm not trying to dismiss them, but rather to offer an opinion as to why I'm moving away from it.
You're mistaken, or misremembering. The `key: value` syntax automatically makes `key` a symbol. You don't have to use it though. The thing is, in Ruby, there are lots of ways to do everything, even simple stuff. Some ways are more efficient than others, but no way is “correct”. That level of freedom is either liberating or scary, depending on the kind of programmer you are. If you find it scary, you won't like Ruby.
What's a "survey"?
Well, the most loved language is apparently Swift, so there you go. Swift is crap. The only way you can make Swift look even remotely good is by comparing it to Objective-C. And I'm saying that as a huge Mac fanboi. It's a real shame that MacRuby basically imploded. It definitely had the potential to be a first-class replacement for Objective-C. I have no idea why Apple thought it was necessary to develop an entire programming language rather than backing MacRuby as the general-purpose successor to ObjC. I guess they saw Go and decided it was the thing to do.
I prefer https://www.ruby-toolbox.com/ because it gives download counts and other metrics. 
In ruby &lt; 1.9 (and I feel very sorry for you, if you're still on 1.8!) you must use: :key =&gt; value If you're on ruby 1.9+ (which you should be, since only ruby 2.0+ is even officially supported any more!!) then you can also use the syntax: key: value And that's pretty much it! There's no need to throw your hands up and claim it's super complicated! {key: value} == {:key =&gt; value} # =&gt; true The only thing you seem confused about is what `key:` really means. This is a shorthand available for (the most common use case, of) when you want to use a *symbol* as the key to your hash. Symbols are not strings. 'key' == :key # =&gt; false {:key =&gt; value} == {:'key' =&gt; value} == {key: value} == {'key': value} # =&gt; true (all SYMBOLS) {'key': value} == {'key' =&gt; value} # =&gt; false (the left uses a SYMBOL, the right uses a STRING) The "old method" is *necessary*, for when you need to use anything other than symbols as your keys. What language do you prefer over ruby, out of interest?
maybe js, scala, golang :) EDIT also, I think ruby is going down. There is not more super active developers for ruby. The language itself seems to remain in the past for concurrency(same for python or php). 
Ruby keeps true to the [TMTOWTDI](http://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it) motto. I always liked that there was more than one way, because it gives Ruby this post-modern, perlish feel. There is just more expression in the language. However lots of developers really dislike it for good reasons, too. For example if you're working in a team, you are sure to see all the possible ways. Especially in teams with mixed experience and with little interaction, TMTOWTDI can become a problem. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**There's more than one way to do it**](https://en.wikipedia.org/wiki/There%27s%20more%20than%20one%20way%20to%20do%20it): [](#sfw) --- &gt; &gt;__There's more than one way to do it__ (__TMTOWTDI__ or __TIMTOWTDI__, pronounced *Tim Toady*) is a [Perl](https://en.wikipedia.org/wiki/Perl) programming motto. The language was designed with this idea in mind, in that it “doesn't try to tell the programmer how to program.” As proponents of this motto argue, this philosophy makes it easy to write concise statements like &gt;or the more traditional &gt;or even the more verbose: &gt; --- ^Interesting: [^List ^of ^software ^development ^philosophies](https://en.wikipedia.org/wiki/List_of_software_development_philosophies) ^| [^Perl ^language ^structure](https://en.wikipedia.org/wiki/Perl_language_structure) ^| [^Python ^syntax ^and ^semantics](https://en.wikipedia.org/wiki/Python_syntax_and_semantics) ^| [^Perl ^Object ^Environment](https://en.wikipedia.org/wiki/Perl_Object_Environment) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq57euq) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq57euq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
https://www.youtube.com/watch?v=Qmk1wq9yT-Y
haha. let's be objective for a moment. * https://www.openhub.net/p/go * https://www.openhub.net/p/scala * https://www.openhub.net/p/ruby Go and Ruby have approximately the same number of commits/month, which is *insane* considering the hype and youth of Go. Scala isn't even the same ballpark.
This. It seems like there are too many ways to do everything. Functions without parenthesis. Return values without return. Everyone is using a different convention in the examples I see. In Rails I also see lots of methods that take many forms of arguments and I'm never really sure how the parameters I pass are processed, unless I read the code directly, because the documentation is lacking. It leads to a lot of magical code.
Relevant as ever: http://www.terminally-incoherent.com/blog/2007/02/05/programmer-hierarchy/ That image is probably older than half of this sub :)
The community is on github, having discussions on the different projects that use ruby https://github.com/trending?l=ruby&amp;since=weekly
the ruby community is at http://parley.rubyrogues.com/
you have concurrency with jruby and rubinius that work with almost all gems. nowadays even the ruby http servers are optimized for them https://github.com/puma/puma
More than half of the respondents are under 30. The Ruby community is *probably* a little older, but the main takeaway is that this is a survey dominated by the less experienced. Over 78% are self-taught or learned to code at University. Both are unideal ways to be introduced to Ruby. The first camp will be dominated by languages where there are plentiful junior dev jobs and the learning curve is low (PHP, Javascript), the latter will be learning what their professors learned or believe industry wants (Java, C++, etc.). Both groups will find Ruby a little alien. The majority spend less than 5 hours/week on side projects. That means their coding is dominated by work, not by fun. That is not a good way to get introduced to Ruby. More than 50% are on Windows based OSes. That's not Ruby. We're OS X and Linux, right? A third of them are using Notepad++ which suggests an uncurious crowd. 9.3% don't bother to use revision control at all which suggests an amateur outlook. 4.5% do not understand the tabs/spaces dilemma. This suggests a lack of exposure to colleagues and team mates. So what this has shown is that the Stack Overflow guys are not quite like us. It is no surprise that they have skipped over Ruby. I'm not saying Ruby is better and that we should look down on these guys (95%+ male), it's just a highly opinionated culture over here, and we tend to be people who demand and expect certain things. We are dominated by Unix, fun projects and finding better tools - and where they don't exist, we make them. That's a very different demographic to the one I'm sensing in those results.
Fewer issues = fewer posts to SO = decreasing %. Having fewer problems we need to go to SO about is a good thing.
I've thought this one over, too. It's painful for me, because I love Ruby. I still think it's the best tool for the job 90% of the time. A lot of the new stuff coming out talks about things like concurrency, but the Ruby ecosystem has had that stuff for years. I use such tools today and get great performance with an enjoyable syntax. I sure do miss the old days when `_why` was still out there, or hell, when Ryan Bates was still producing content (he's out of hiding this month, by the way). You're right though- the community is dying down. I use Ruby everyday for a [variety](http://farmbot.it) of [opensource project](http://www.openfarm.cc), but I'm still left wondering where the community has gone. As for me, I'm mostly on freenode and Reddit, as well as the local scene here in Chicago. EDIT: Ruby5 is pretty active, too.
They're at work :)
\#ruby and \#ruby-lang channels on freenode are almost always bustling. Other than Rubyconfs and Railsconfs, there are almost always local Ruby meetups in your area. I know in LA there are several on meetup.com alone just for Ruby. In my town we have a Ruby meetup once a month and have 10-20 people show up. It's pretty fun. People talk about what they're working on or what gem helped them out recently. We also do a Code Kata at the start as a group on codewars.com.
It comes down to the right tool for the job. When you're learning, you have to learn things in an example where it doesn't always apply, because that thing is useful later on and works perfectly for that other situation. But if you don't practice it, it won't be in your 'toolbelt'. However, a very good example of classes being used is for video games. Imagine your hero and his party are fighting a battle against a Dire Wolf. Where would you put the functionality of the enemy? class DireWolf def attack(party_member) # causes 4 +/- 1 + 2*wolf_level damage # to a party member party_member.decrease_hp_by 3 + rand(2) + 2*self.level #don't forget to animate the attack! #(there are many ways to do this, # this is just an example) animation_queue &lt;&lt; DireWolf.attack_animation #since the wolf makes a physical attack with # its body, it can take damage while attacking if party_member.has_spikey_armor? self.decrease_hp_by(party_member.spikey_armor.damage) end end So then in other parts of your code, you may see this: enemy = DireWolf.new enemy.level = 3 #lets say the party is an array of the party members # if you use .sample on an array, it will grab a random # element of that array until battle.over? enemy.attack(party.sample) party.each do |member| member.attack(enemy) end end And this is just one of the more 'obvious' use cases of classes. (also, this leads into inheritance where you could imagine the DireWolf class is a child of the Monster class or the Enemy class, but if that doesn't make sense yet, don't worry about it) Good luck! If you have any more questions or any questions about this example, feel free to ask!
True - like Perl, Ruby is a power-tool. It's great for experts because you can express whatever you want and make amazing things quickly and efficiently, but for other people (especially beginners) it just offers a faster and more efficient way to accidentally lop off a finger.
[**@yukihiro_matz**](https://twitter.com/yukihiro_matz/) &gt; [2014-08-01 14:49 UTC](https://twitter.com/yukihiro_matz/status/495219763883163648) &gt; My vague plan for Ruby GIL is 1) add more abstract concurrency e.g. actors 2) add warning when using threads directly 3) then remove GIL ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
The ELK stack has been the greatest thing to happen to our Rails logging! Searching through app logs for anomalies has proven incredibly valuable. I had to use Lograge though to cut down on the otherwise absurd amounts of logs that would be generated. Lograge + logstash-logger is a winning combo for ELK logging.
It's really great in small projects (few thousand lines of code, only a few developers), but it can get rather complicated fast.
I recommend checking out [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby), it's got some great higher-level concurrency abstractions, based on mature patterns/API's from other languages but made idiomatic for ruby. Also, awesomely, it works identically in any ruby (MRI, JRuby, rbx). It's logic of course won't be truly parallel in MRI, but there are times when you need concurrency for I/O heavy tasks so MRI is fine, and it's super convenient to be able to write concurrency code that just works, semantically if not performance characteristics, regardless of ruby platform. It does have platform-specific optimizations for JRuby (pure Java implementations of same API for performance), and in some cases MRI/rbx (compiled C implementations). It's pretty damn awesome for concurrency in ruby. 
Solved my problem, solution (ugly but works) is in the original post, at the top under the EDIT:
It's also becoming big in "the enterprise" for automated testing.
I get on #ruby on freenode, almost every day at work. I think most everything has shifted to Github now, where it's a lot harder to just have a conversation with other random people, but it's a lot easier to share code. Mailing lists are now generally only for specific groups working on a project. There are so many decent options, it's sort of split up the community in many different directions.
I hate it because it's a facilitator of cargo cult programming. I've seen so many devs copy and paste code off of there without knowing what is doing. You'll occasionally get wonderful answers to questions that are beautiful and informative, but that's not the norm. Far too often, people jump into stack overflow without reading the docs. The mods can be quote draconian in their view of a repeat question. Never mind that an ecosystem can change or an api can drift. To be clear it is much better than all of the pay wall sites that existed before it, but I prefer a good blog post explaining the problem and solution, or better yet, good documentation. The ruby community tends to dislike cargo cult solutions (even though they are everywhere). I suppose I clearly made a bad assumption that other devs in the community viewed it similarly to me. I was mistaken. To be fair, stack overflow helps millions of programmers every day, and that is a good thing. It's great for junior devs who are just learning and have a timeline. Really is great for anyone needing an immediate solution. I just don't like the cost of repeated immediate solutions without real learning. 
These are some good basic ideas, but as I know all too well - from experience - parsing can get *really complicated*. (As you mentioned, nokogiri is an example of this!). [Here's some parsing I improvised a while ago](https://github.com/tom-lord/regexp-examples/blob/master/lib/regexp-examples/parser.rb). I think it could perhaps be tidied up a little by your nice use of `peek` and `getch` (which would help a little with my very confusing `@current_position`). But regardless, I think that clas is going to look horribly ugly (or confusingly abstracted) in some areas, no matter what...
But coffeescript is. Strange stuff...
I happen to agree with you about the new duplicative syntaxes, with that one being a good example. But I love ruby anyway. Perhaps because I've been developing it before they added those syntaxes, so were less confused by them. 
Your line line.split.map(&amp;:to_s) has a few problems: * The default argument for split is (depending on your system) probably whitespace. You want split(//) * You're not chomping the line You probably want something like board = File.open('mines.txt').map{|ln| ln.chomp.split(//)} board.shift # (remove that first line) 
Yeah, I think people are switching to node.js and such, because that's where the jobs are. It's something I've had to do as well.
How active is that forum? I always hear it mentioned on the show, but have yet to actually check it out
I'd say that's more of a lexer than a parser, but it's true that modern parsing techniques often kind of blend the phases. You're going to run into headaches trying to do any non-trivial parsing with just StringScanner though. Those interested in parsing in ruby may be interested in [parslet](http://kschiess.github.io/parslet/). There are some other ruby parsing gems available too. 
Try looking at [rcodetools](https://rubygems.org/gems/rcodetools/versions/0.8.5.0). It does what your are looking for. Its dated but it still works. ( I had to make some changes to the source code though) Edit:formatting
freenode/#ruby isn't just about Rails at all.
I do not know. I want to know, but I don't.
Perhaps because Ruby is not as popular as it once was. When you look at some of the other languages - Python is becoming more useful and enjoyed by many - PHP is ubiquitous. Ruby is a mature language, but fewer people are using it.
Something like.. https://github.com/JoshCheek/seeing_is_believing?
G+
In my purely anecdotal experience, nodejs
You think so? I'm just about to start applying for Ruby jobs and I'm a little unsure of where to start. Now I'm curious, is it even worth starting?
I think you're fine to apply for Ruby jobs. Knowing Ruby and/or Rails isn't going to mess up your career. Plus, if you ever change technologies you can bring all of the wonderful ideas that Rails and Ruby has with you.
Is this is even the 'right practice'? to hold the hash as constant? I'm mainly doing so, because constant being initialized while I require the file. Maybe It should be a class? then I can `initialize` the hash table as expose it with accessor? 
The only programming community I know of in my small Scandinavian town is RubyGirls (boys can also tag along). 
Seems plausible, there's a TON of Java and C# out there, and of course now, quite a lot of Javascript. It's OK though, there are plenty of other cool languages out there that don't dominate the landscape but aren't going to disappear anytime soon either.
Oh wow I was really close. So the map method makes (1..self) work? Meaning it turns the object into a workable number? I'm surprised to see how close I was. I forgot include the last **end** and the formatting got a bit messed up. I had wanted to make a range of numbers do the counting but was jnaware on how to make it work with self. I could easy do (x..y) but making it work with the object was throwing me through a loop..
Actually I have figured out what you're doing wrong. Since you're setting the @p value to the list of URLs in the same route that loads this Haml file, it will never update without a refresh. You will need to use jquery's asynchronous features to load the list in the background and then reload the images. Here's what you need to do: 1. Remove the setting of @p in your get '/' route and create a new route that you can call behind the scenes. Ideally, it should return a Json array of urls (this is easy to work with in Jquery) 2. Change your haml file to call that new route behind the scenes and load those files into your div. Check out the documentation for [$.post](https://api.jquery.com/jquery.post/) (or [$.ajax](https://api.jquery.com/jquery.ajax/)) to see what I mean.
It's been a while but 1..self works because of range syntax. Since you're operating with self being a number that works in a range you're good to go
They're referring to actual real life meet ups not online ones.
Hey, me too! Welcome... to both of us? I'm enjoying it so far. 
I love Prawn. Gives lots of direct control.
I see, my bad.
&gt; maybe. i am having trouble understanding how any other tool could succeed in providing this information based on your given scenario. A RUM tool hooks into the browser to obtain details about the page it was loaded on, and so has access to what that particular user actually experienced. The distinction is that we aren't making a request in order to measure performance, but rather are tacking performance measurements on to requests that are already being made to do real things. These two categories are good at different things. For monitoring performance regressions, which seems to be what you're most interested in, synthetic tests are totally the way to go - they eliminate a lot of variability, giving you a clearer picture of how your changes are actually affecting things. But RUMs are important to look at periodically to make sure your worldview isn't too far off from reality - and are especially useful for higher-level execs and managers. Here are a couple articles that might cover this better than I am: * http://www.stevesouders.com/blog/2012/11/14/comparing-rum-synthetic-page-load-times/ * http://blog.smartbear.com/web-monitoring/where-rum-fits-in/ * http://blog.smartbear.com/web-monitoring/synthetic-and-real-user-monitoring-better-together/
Yup. I played with Rails while it was still 0.x stuff, but didn't get serious with it until 2.x. I still haven't migrated an app to 4.x, as I've been waiting for 4.2, but I guess that's out now. I've been doing ".NET" since 1994, when VB was at 3.0, and did a LOT of work with 6.0. The Rails upgrades were discrete, well documented, and took over best practice relatively quickly. The upgrades to various Windows subsystems, like COM to DCOM, were NOT well documented, and Microsoft -- as a victim of their own success -- were forced to continue to support the old ways and libraries, for years and years. In my previous example, you can read XML with XMLTextReader, XMLDocument, and XMLReader. Which one is best? Depends. Which one should I use? Depends. Sure, you can read someone's opinion and speed test, but my experience is that those speed differences don't always hold up for my particular situation. You want to read XML in a Rails app? Basically, the answer is Nokogiri. Sure, there are others, but that's the one that most people seem to use, and it shows up in searching on the topic. There's a "best" way to do it. My point about .NET is that you can't reach this consensus in the .NET world. There are 3 or 4 or 5 ways to do anything, and they all suck in different ways. Sorry. A lot of words to make a point. YMMV.
&gt; Do you think most people answering the SO survey are largely building "highly concurrent systems" "at scale", such that that effects the survey results? really? Probably not? &gt; I'm also not even sure what you meant exactly, maybe you mean Rails? I dunno. I mean any Ruby-based web framework. It's not exactly a secret that some of Ruby's weaknesses are concurrency and memory usage. I feel like this came across as attacking Ruby, but I love Ruby and I do it professionally :).
I have loved ruby for over 10 years now but am kind of cheating on her with Elixir. :O I hang out in irc on freenode.net
`{'key': value}` doesn't work by the way!
Anyone can join you just need to pay $10(for a year)
How are you learning? I'm both doing a night class one day a week and doing CodeAcademy. 
I agree with this. As someone who is learning both Ruby and Javascript, I just don't run into as many issues in Ruby and can quickly figure things out on my own. With javascript on the other hand..............
map is like each, except the result of each run of the block is collected into an array, which is returned by map, obviating the need for you to perform manual collection.
Thank you! :javascript setInterval(function(){ $.ajax({ url: "/posts", cache: false }) .done(function( html ) { $("#jax").hide().attr("src", html).fadeIn(700); }); }, 5000); I am using this right now - It seems to work how I want it too - jax is just the ID of the image i wanted to change
Yeah!!
Yeah my initial statement was lacking in detail and honestly deserved the down votes. But you're right it's only part of a larger Google-my-problem-away approach. I do see some value for young programmers because getting stuff done increases confidence. It's just when learning stops because of it, I think. 
Thanks for the answer, I genuinely do appreciate the clarification :) Out of curiosity, what if the *value* is a symbol? It seems that 1.9 introduced a new way of adding keys and values to a hash, but there are still times when you have to use the old method. As a newbie, I've got to be aware of both ways of adding to a hash, rather than one way. The new version doesn't do anything functionally different, so why add it?
The hardcore JS developers don't seem to like Coffeescript as much as those who focus on other languages.
I have used prawn to great success in multiple projects!
Generally speaking I think it's a code smell when you pass around hashes and the like. Wrapping it up in an object is the way to go. For your original question, ruby is dynamic and flexible, so no matter what you do, another developer can easily get at the underlying data and modify it. I think you should solve your problem with documentation instead of trying to make it unable to be altered.
It may be that the Ruby community has grown so large that it is now disseminated into lots of different corners of the internet thus losing that concentrated energy and intimate atmosphere of the earlier days. It is a very popular language for learning to program and indeed most of the code bootcamps focus on Rails and thus Ruby by extension. /begin rant My thoughts are this may have even hurt the community in that google+, facebook, reddit, and other mediums for ruby groups get flooded with not just beginner questions, but also, irritatingly, lazy questions. Someone asking for the umpteenth time the same kind of questions like, "Why am I getting a NoMethodError: undefined method...?" is exhausting and may drive a lot of the more experienced programmers away from these public outlets. That particular question is like calling a car mechanic and saying, "What's wrong with my car? It won't start?", and expecting them to just magically know. Well, it could be the starter, might be a bad battery or a bad alternator not charging the battery, maybe a spark plug. By the way, that isn't a rant against newbies. I'm a newbie myself and I don't think there are stupid questions, just lazy ones. Really, really lazy ones from people who have absolutely no desire to problem-solve or troubleshoot. One of the first things they should teach with programming should be how to debug, and that process should not involve SO or google (at least until you get the idea), IMO. /end rant
Why use Notepad++ over Sublime on windows?
Yeah I've had the same experience. I tried to start a Ruby group in my city, and I didn't realize it until now that the only people that showed up were familiar with Rails. I guess that is the only thing most people have been exposed to at their work.
It's Prawn, I guess, but honestly it's really painful to get anything that looks nice if your PDF is complicated. I'd try to find a solution that avoids Ruby PDF generation at all if your document is much more complicated than the example you give. If user input that will be reflected on the form is controlled strictly, it will be a lot easier.
Putting the method signature at the end of the method definition can become unreadable pretty fast. Also, the fact that it doesn't offer any performance improvement is not recommended for production.
Perhaps :) It might be okay to use inside a library, where you want to use pattern-matching techniques a la Erlang or OCaml but Ruby doesn't support…
Some of us just prefer not to associate with the "community", because it contains a lot of language zealotry some of us prefer not to be a part of.
Is Ruby still not common in Universities? I did C++/Java in school 8 years ago but I've met some professors (very, very non-tenured/freelance though) who teach Ruby at the local college recently. You'd think an insanely marketable skill would make it into schools by now.
&gt; Out of curiosity, what if the value is a symbol? Values can be whatever you like; the syntax does not change at all. { symbol_key1: "string value", symbol_key2: :symbol_value, symbol_key3: 123, symbol_key4: MyAwesomeClass.new } &gt; The new version doesn't do anything functionally different, so why add it? Well firstly, let me just reiterate that the old version is *necessary* in ruby, since you can use absolutely anything as a hash key! (Although, 90% of the time, you will be using symbols.) { 1 =&gt; 2, /regex/ =&gt; OpenStruct.new, Module.new =&gt; Float::INFINITY } # 100% valid syntax, although this is a very silly example! This syntax is consistent with many languages - such as [php "arrays"](http://php.net/manual/en/language.types.array.php), or [perl hash](http://perlmaven.com/perl-hashes). Adding the new syntax was certainly [controvertial](http://logicalfriday.com/2011/06/20/i-dont-like-the-ruby-1-9-hash-syntax/), and yes it doesn't technically "add" anything to the language. However, it makes the ruby syntax more compatible with many other languages - such as [python "dictionaries"](http://www.tutorialspoint.com/python/python_dictionary.htm) or [racket "hash tables"](http://docs.racket-lang.org/reference/hashtables.html). The idea is that the syntax provides a nicer, shorter, simpler syntax for the most common use case - which is also consistent with the syntax used in other languages. You still might not like it, which is fine. But the idea that [There Is More Than One Way To Do It](http://www.urbandictionary.com/define.php?term=TIMTOWDI) is at the heart of ruby, and - in my opinion - is largely what makes it so popular, because you are not tied down to loads of arbitrary syntax constraints that you might not like.
I recently used prawn for a project. The extra work to design the template was a definite con. On the other hand I found once I made a few helper methods for things I was doing - bullet points, etc and weighed up ease of deployment if we need to change servers or even platforms later on I'm very happy with how it turned out.
If you wanted you could do: typesig def sum(a, b) a + b end, [Numeric, Numeric] =&gt; Numeric don't know if that'll be better. You could disable `typesig` in production, by overriding it: def typesig(sym, _hash) sym end
Stop using global variables. In ruby, variables that start with a `$` are global. 99.99% of the time, this is a bad and unnecessary idea. Read the [ruby style guide](https://github.com/styleguide/ruby), especially regarding the use of soft indents (2 spaces). I don't want to even try debugging that code, because it's riddled with global variables (so it's very hard to see what gets changed where - the flow control is completely broken!), and I suspect there may be some fiddly bugs in there caused by [shallow copying](http://kakubei.blogspot.co.uk/2013/05/shallow-vs-deep-copies-and-marshaling.html) of arrays. (Again, made all the more difficult to debug with global variables everywhere!) If I were to write this from scratch, I'd make the whole thing much more Object Oriented -- it would be a lot easier to read/debug if there was a `Board` class (with a `Board#print` method, rather than using `pp_board(board)`), and a `Cell` class (rather than just using strings to represent each cell!). This would eliminate most of your confusing `oldarray.each { |j| if newarray[i][j] = != "*" ....` code, because instead you could write some **much** more human-readable code, like `board.is_mine?(row_guess, col_guess)`, `board.update_cell(row_guess, col_guess)`, `board.print`, `cell.is_mine?`, .... We could go through your code to debug+fix it, but I think you'd learn a LOT more about ruby/programming in general if you had a go at creating this game the "right" way, rather than just using lots of arrays, strings, `.each` blocks and global variables!
One thing that I would do is instead of writing the tests inline, try writing them a Test::Unit tests instead.
is module include/prepend really metaprogramming? I know this line gets really fuzzy, depending on the subject. I always thought of it as loose inheritance.. kinda
It's really fuzzy... But maybe, yeah. In my opinion, at least. For example, you can use Module prepend like a cleaner way of doing `alias_method_chain`. Or you can use `Klass.include MyModule` to effectively mokey-patch a class. Or if you want to investigate the whole `Klass.ancestors` logic, then looking at how including/prepending modules (and in what order!) affects this, along with the singleton class (e.g. `define_singleton_method`) Like I said, there's a huge amount you could extend this with - it's up to you where to draw the line!
yup. hmm. I think with at least the list you provided, coming up with examples for each of those wouldn't be too bad. 
Groupon switched to node.js AFAIK?
Wrap them in if user_signed_in? For example (in haml) #title Welcome to my blog! - if user_signed_in? = link_to 'New Post' #blog-posts .post - if user_signed_in? = link_to 'Edit' = link_to 'Delete' .post-body Welcome to my first blog post. I hope you enjoy it!
It's worth getting familiar with the devise code too https://github.com/plataformatec/devise/blob/42c35236326a218e37d2a9ff2ab69c4bd93371fe/lib/devise/controllers/helpers.rb#L82
The whole code is a mess at the moment. Your suggest may clean it up *a little*, but the only good suggestion IMO is to re-write it "properly". Use objects. Use shorter, legible methods. Remove global variables. Use simpler operators, like `+=`. ...
[Im getting a really weird error that isnt telling me much.](http://imgur.com/Vsm1dGD,D3B6SlJ) Thanks so much for the help. Im very new to this. 
This post is without any merit. All these websites could (maybe just as easily) have been created with another language or another framework. There is nothing rails specific about these websites. Some even switched to other frameworks and languages.
Facebook is written in PHP. Does that mean I should write everything in PHP?
Could have? Sure. Should have..probably not.
Let's say you've got a social site with user profiles. Only users who are signed in can see some details of a profile (if user_signed_in?). On a user's own profile they can see edit links (if @user == current_user). Edit: A more complete answer is that user_signed_in? returns a bool and current_user returns the User instance. The User instance is not nil, so it can be used for checking if the user is signed in just like user_signed_in?, but in addition to authentication it can be used for authorization.
Is the &lt;% end %&gt; necessary? I only use haml, and it just uses indentation to end blocks like this.
 def #{mapping}_signed_in? !!current_#{mapping} end So "if user_signed_in?" is the same is "if !!current_user". The double not is to ensure a boolean is returned, not just a truthy or falsy value.
yup, makes total sense. thanks.
Anything that is computable can be computed in any Turing complete language. Thus, is there *ever* really any merit to highlighting the feats of a programming language? By your logic, I suppose not.
Yes I understand that. Asking what the difference between signed in and current user is. I get it. Thanks though
Rails has its use cases, but you shouldn't let that blind you to everything else out there. Best to learn a few things, and then make an informed decision.
thanks :), i would think about that :P ,is there a similiar gem for ruby ? 
It's also incredibly easy and fun to contribute to. The author is really nice and would probably help you integrate your gem, if that would help.
Ah, now that I read that again I think I'm wrong. Disregard.
Signed in returns a boolean, current_user returns the User instance.
FWIW, I was the person who made the post you mentioned, and I never intended it to be like, "is Ruby on the decline??? OH no!" Maybe it is, maybe it isn't. I do know however, that almost all Rubyists I know, if you ask them why they use ruby, they'd say, "Because I effin' love Ruby." And it surprises me that somehow the language didn't make the list. I find the Ruby community to be really vibrant. I read great books that use Ruby (Understanding Computation is phenomenal! Shout out to POODR as well) watch fascinating talks online, subscribe to great screencasts (we do miss rbates though) and attend great meetups. That's why I am surprised it wasn't on the list, because I effin' love it.
&gt; Dealing with repetitive methods that function the same I once did this for an XMLRPC client. I presumed if the method wasn't defined, you were trying to call the remote service. This created 2 problems: 1. (minor problem) Real bugs in the code using my client required a roundtrip call and error response from the service. 2. (major problem) method_missing is invoked via exception handling, making the performance god awful when compared with a later version that looped over all the RPC method names on the API, using define_method to define a bunch of identical methods with different names when the class is first defined.
The beerdb gem include a pre-made database schema (SQL), that is, tables and columns and indexes etc.; see the source here e.g. [schema.rb](https://github.com/beerkit/beer.db.models/blob/master/lib/beerdb/schema.rb) - and it includes Ruby models (using the ActiveRecord machinery). To fill-up the "empty" database you can use (read-in) any of the public domain beer.db datasets; see the [beer.db - open beer n brewery data project](https://github.com/openbeer). Cheers.
For HTML-&gt;PDF we use https://docraptor.com They have a simple API and getting documents to look decent isn't too hard. It's powered by PrinceXML which you could also look into grabbing and running on your own servers.
Yes, it seems like it. But it looks like nokogiri devs say don't use it because they don't want to support it.
An easy improvement would be to combine the loops: words.each do |word| if word.include?("re") || word.include?("me") || word.include?("bo") my_arr &lt;&lt; word end end which can be simplified to words.each do |word| my_arr &lt;&lt; word if %w(re me bo).include?(word) end Next, I would recommend reading up on using the `inject` (aka `reduce`) method.
&gt; Not sure I get the point of plugging another language in /r/ruby though. the ruby community has historically been very interested in exploring new languages. 
Nice! I tried this method but I kept getting error, I see now its because I kept the "if" in there: words.each do |word| if word.include?("re") || if word.include?("me") || if word.include?("re") my_arr &lt;&lt; word end end Thanks for that!
Using a regex to match the word and select to do the 'loop': p File.read('mess_around.txt').split(' ').select { |word| word =~ /bo|re|me/ } Just using a regex (this is likely the best performing solution by far in addition to being the simplest): p File.read('mess_around.txt').scan(/\b(?=\w*bo|re|me)\w+\b/) Also, it's "do re mi" if you were going for the musical thing :p
&gt; %w(re me bo).include?(word) I'm on mobile so I can't check right now, but I'm pretty sure that checks to see if `word` *equals* one of [re|me|bo], not whether it *contains* one of [re|me|bo].
What level of programming are you at?
I've been a software developer for nearly 10 years. My CS core concepts are strong, having worked with no less than half a dozen languages in my university/professional career. However, I recently quit my job to get into iOS development and put older and more boring technologies behind me. I'm working on some portfolio apps right now and have created a Rails JSON API that I tend to get hung up on from time to time, with no one to bounce questions off. Usually super simple embarrassing questions. I tend to more get caught up on simple syntax issues, ruby especially. I often just don't get ruby, haha.
Because in a general discussion of "how to build a parser," "don't build a parser" isn't really contributing. The use cases for parsers is wider than reading your own config/data in the format you pick for yourself. Knowing how to write a parser is a useful skill.
Elixir seems really cool. I can't really think of a use case for it, though... if I want Ruby, I'll use Ruby, and if I'm going to use an uncommon functional language, I might as well use Haskell and get the type system.
I started writing a project in Elixir, because I have to say, the language and the syntax interested me. I wanted a language that definitely had a stronger typing system (Elixir, unfortunately, didn't have one as strong as I'd have liked, but that didn't really bother me). I wanted a language that didn't feel as bloated as Ruby, and felt more "clean" (i.e. less syntaxic noise). Elixir fit the last two goals, having a decent sized core library, and comes integrated with a package manager. My main problem with Elixir is project/application/project management. Everything goes through `mix`, which is fine, but **I have no fucking clue how to make an application _run_**. Everything else is in the documentation, stated clearly; but there's nothing that shows how to _execute_ an application. Alright, that's ok, I mean, it's not that bad. But how do you end up creating a web application that serves requests if you can't actually execute the application? I'm sure I'm missing something somewhere, so this isn't that big of a deal. However, a _lot_ of Elixir uses things from Erlang, and if you want to use Elixir extensively, you have to know quite a few things about Erlang as well (most likely just the basics, like the core library and the way things function in the VM). That's fine, but there's literally nothing on Erlang on the "Getting Started" of elixir. Hum. Another thing is that Elixir _has_ exceptions. However, Erlang apparently, does not. The custom in Erlang is to return a tuple, `{atom, any}`, with `atom` normally being `:ok` or `:error`. This means that some functions in Elixir returns a tuple, and some functions throw an exception; with no clear indication in what user code should do. Weird. Finally, I feel like Elixir is _way_ too rigid to actually perform a decent amount of work. It is hard to prototype in the language in the first place; let alone the rigidity of the immutability and the way state works. I am all for immutability; I love the concept - but I _don't_ like the way it's integrated into the language here. All in all, it's a decent language, I just feel it needs to work on its documentation and API a bit more to make it feel like a solid language to work with. My last point about immutability could be skipped over if the rest of my points are resolved, and I'd love to write in Elixir.
It looks like you can pass configure flags with the `-C` option when installing with rvm: $ rvm install 2.2.0 -C --with-jemalloc See the Configure Flags section on this page: https://rvm.io/rubies/installing
Don't do this. Post your questions publicly. Others who have your question will find it and the answers will be public. If you do it by pm, at best you're a help vampire, draining the resources of the community for not really much gain. Volunteers only give so many hours. This is actually worse than just not contributing to the community because you're taking away from it. At worst you're going to get answers that don't have the benefit of crowdsourced vetting and you're going to get some bad advice in a vacuum. I'm glad you asked though. There are no bad questions. Now people that search this will see more info about why it's a bad idea.
Yes.
&gt; My main problem with Elixir is project/application/project management. Everything goes through mix, which is fine, but I have no fucking clue how to make an application run. mix --help One of the options should be "mix run"
Regex is clearly the best solution, note you can construct it with `Regexp#union` which may be useful: p File.read('mess_around.txt').split.grep Regexp.union %w[bo me re]
I'm not sure about his point about Go targeting C++ people and Rust targeting JavaScript people... As I see it both target different kind of C++ people - fast, compiled to binary code, statically typed and so on. Only similarities I see between them and JS are: lack of semicolons, function as a first class citizens - those are true for many modern languages though - and some variant of `function` keyword on the beginning of function declaration.
Erlang does have exceptions.
You don't _have_ to use mix on a production server: http://www.phoenixframework.org/v0.11.0/docs/advanced-deployment 
You can also use open instead of File.open(..., 'r') for this simple case: matches = open('f.rb').read.split(' ').select do |word| word =~ /re|me|bo/ end p matches 
Prawn - Tons of flexibility, control over everything, a ton of work. wicked_pdf (wkhtmltopdf) - Using html/css, way easier, sometimes can give you problems, not as efficient/fast.
The Haskell concurrency and exception models are pretty broken, from what I can tell.
&gt; It may be that the Ruby community has grown so large that it is now disseminated into lots of different corners of the internet thus losing that concentrated energy and intimate atmosphere of the earlier days. Dissemination makes a lot of sense. But: if the community as a whole would have grown so much then there could still be plenty of traffic in the "classic" places. Since that is not the case I assume that the growth - if at all - was not that spectacular. I also agree to your statement about lazy questions. These days I do not even bother to reply "What did *you* find out?" - instead I just ignore them.
In my city even the LUG has died. I am not aware of any Ruby meetups. But that is also not the type of exchange I am missing. Earlier on Ruby talk there were interesting discussions about algorithms and particular solutions. That has completely died away. The discussions nowadays revolve around fairly basic topics. OTOH, maybe the interesting and more challenging things have been sorted out so there may be less need for these types of discussions.
The nested if statements are somewhat of a strawman implementation. You could just use one `if/ elsif` and it would be more concise, DRY, and readable than anything there. Or I could be missing something.
...And it looks like you just never defined `google_oauth2`. One might have thought that this would be the first thing to try and fix, given that the error message says: `undefined method google_oauth2`.
Downvoted for defending /r/ruby? Many of you should be ashamed, idiots.
That's a good point about it being a strawman, I agree now that you mention it. The only problem being I believe you have to do one `if` / `else` branch after you check the size, when you load the uploaded file into a `MiniMagick::Image`: if @uploaded_file.size &gt; MAX_SIZE Left("Picture size must be no larger than #{MAX_SIZE} bytes") else image = MiniMagick::Image.open(value.tempfile.path) if !image.valid? Left("Picture must be a valid image format") elsif !ALLOWED_FORMATS.include?(image.type) Left("Picture must be an image of type #{ALLOWED_FORMATS.join(' or ')}") elsif image.width &gt; MAX_WIDTH or image.height &gt; MAX_HEIGHT Left("Picture dimensions must be within #{MAX_WIDTH}x#{MAX_HEIGHT}") else Right(image) end end I'll update the article, thank you for the feedback!
If you're worried about performance you probably shouldn't be using ruby.
Gotcha!
I'm working on Rails apps that are getting 20K req/min and just ticking along; Ruby perf is getting it done for me.
If you are doing anything algorithm heavy ruby is the the right tool for the job, there are much faster alternatives (C, Go, etc). However if it is a web application ruby is just fine. But you will have to use caching very liberally, which you should be doing anyways. An ecommerce site I launched yesterday had 180,000 unique users, 1.5 million page views in 12hrs. It's powered by ruby on rails spree ecommerce framework. https://github.com/spree/spree 
First point: `mix help` or `mix help [task you want to know about]`. Secondly, you can't really have immutability without it being baked into the language. If anyting, Elixir makes for a more flexible feel in working with immutability because of its multiple assignment, which - as opposed to Erlang - makes you much less aware of when you're destroying and recreating a value rather than mutating it.
Such benchmarks are pretty ridiculous without mentioning your infrastructure. I could scale like that with 20.000 AWS instances and COBOL. 
I agree to you, it gives many situations where you have to read a non standard format (e.g. logs), but I have to recommend to have a look at [parslet](http://kschiess.github.io/parslet/). By using it, you can always focus on the structure you want to parse. ;)
How does this compare to new relic? I prefer the command line and already know more about this gem than I do with a year of working with new relic. (i really haven't put any time into new relic but I also feel like I shouldn't have to)
Your version is definitely cleaner in some ways than his original version(s). Your version is also 120 lines instead of 40-50. I'm not sure I'd prefer yours, I find yours takes a lot longer to understand what's going on than the original. It might be interesting to simply create a validator class using ruby idioms that is both clean, flexible, and concise, without un-needed engineering. It shouldn't be that hard to turn his nightmare of nested if/else into a simple series of guard clauses, without adding 80 lines. (Also, in a Rails app, Rails i18n should clearly be used for those failed validation messages)
❤️❤️❤️🚀🚀🚀
Nope far from it. I use a wide variety of operating systems and languages. But by all means enlighten me on the new technology of which you speak... I'd be shocked if you were using an operating system younger than you are.
Another simple and light weight implementation of observers is simply using the stdlib Observable: http://ruby-doc.org/stdlib-2.0/libdoc/observer/rdoc/Observable.html It's got a kinda weird aspect though, where the observed object needs to call #changed, or notifications will be ignored. I could see some uses for that in some cases, but I think it's odd that it's mandatorily baked in to the stdlib implementation. 
I think it's better to try to come out with your own idea, or build something for friends or family. You'll be much more inclined to put a good effort into it. Or think of a repetitive task that you do which involves manipulating data, or maybe something online, and see if you can automate it. If you're really stuck, the common practice web app is a blog engine, or a todo list manager.
Excellent stuff, thanks for your reply :) There are actually a few repetitive tasks that I could have ruby deal with!
If this is better to post in /r/rails let me know! But this is a gem i quickly whipped up to edit copy in a web app. It uses a good chunk of Rails functionality to work in the backend but I would like it to be able to stand on its own to be used in Sinatra and the sort. There's a lot that needs to get done on it yet(like any testing at all), but the core functionality works. I'm just stoked on pushing my first gem. There will be more commits to come! And pull requests are welcome!
&gt; i find yours takes a lot longer to understand than the original I disagree. Sort of. It might take longer to FULLY understand all the intricate details of this version, sure. However (!!!), just look at the main `validate` method here. It's really trivially obvious exactly what is being validated, assuming you don't care about the precise implementation. I'm not saying his implementation is perfect (frankly, i didn't even read it with very much scrutiny), but it's much more legible, quickly (on a high level) understandable, and most importantly testable. 
Check out [codekatas](http://codekata.com/). They're relatively quick and designed to be done multiple times. It's nice to create a github account just for your code katas and you can see how your coding style has changed - or maybe this is awful because i can guarantee from personal experience that it is huge cringefest.
You'd definitely be shocked then, I'm 33.
I wrote the comment which convinced him to delete his post. It pointed out that his nested if statements could be written more clearly as `if/ elsif`. And he deleted it in order take my critique (which he did graciously, and upvoted me for the effort) into account, and edit his blog. I'd also like to point out that the point of the article wasn't how best to validate file uploads. It was about Haskell stuff and algebraic something... monads... in Ruby (from what I remember, I was on my first cup of coffee when I read it). I also used the term "straw man" in that the nesting didn't really represent good style, and a similar non-nested implementation could be achieved with standard `if else`'s. But it was really just to point out that the examples weren't really apples to apples. Still, I don't see the need to jump down his throat for trying to introduce new concepts. He just needs to pick a better example (or don't even bother comparing just do a show and tell).
If you're not worried about performance, you're not producing a product that matters. Every software product has performance constraints, for some it's measured in CPU cycles, and some it's measured in milliseconds. Making your app 10% or even 100% faster in Ruby is sometimes all it takes. It might not reach the speed of C, but relative speed still matters. You could argue if you're worried about performance you shouldn't be writing it in &lt;any language ever&gt; and instead build custom single purpose hardware instead.
&gt; I think the original original author didn't seem to realize he could use negation in an if condition, or that he could use return to return early. I did actually if you read the article; I specifically called out using a bunch of returns as not very idiomatic Ruby, as well as the danger of forgetting the `return` in each conditional or forgetting the final `true` on the last line. The benefit of the `&gt;-&gt;` is it ensures you're returning an `Either` at the end of each block. The implementation I stupidly didn't consider was just the regular `if` / `elsif` without the returns that /u/Flopsey pointed out, although I'd still argue you can't do it all in a single `if` / `elsif` readable - you need the one `if` / `else` to set `image` in the `else` branch.
Yeah, sure... But I mean that in a polite, confrontation avoiding, I don't want internet strangers to think I'm an a-hole kind of way, so.. not... actually. So, I'm saying "absolutely" but under the assumption that everyone forgets about it. Actually, I'm sorry I'm probably not available and will have to decline. In all seriousness, don't let the grumpy gus get you down about it. Really your post was fine, good even. And forget the straw man comment, just don't use nested if statements, OP took that in a far harsher direction than it was intended. I don't really get the blogging impulse as a rule. But I know it's hard to put yourself out there on something you worked hard on. And it's great that you're open to criticism, and not defensive. That will help you grow, but you also need a thicker skin, learn to ignore the attacks and focus on the constructive parts. Really, the only thing you have to remember going forward is that programmers have spoke and they really don't care about Haskell. I'm joking... sort of. There has to be a relevant XKCD.
&gt; At any rate my opinion is that there are simple idiomatic solutions that neither require Haskell idioms nor require the over-engineering of this OP's version. Yep, agreed! I'll revise my article to show a better example. I think the original article that introduced the kleisli gem did a much better job showing the possible composition: http://thoughts.codegram.com/cleaner-safer-ruby-api-clients-with-kleisli/
Cool. Personally I use early returns _all the time_ in validation code, they are made for it. In fact, the 'guard clause', I would argue, is quite idiomatic ruby. A validation method is funny in that it's pretty much _all_ guard clauses, ha, but that's just what validation is. http://www.thechrisoshow.com/2009/02/16/using-guard-clauses-in-your-ruby-code/ http://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html Here's another ruby style guide that encourages them, quite to get around the nested if/else mess you found yourself in: https://github.com/bbatsov/ruby-style-guide#no-nested-conditionals It looks like "rubocop" (never used it myself, just found this example googling ruby guard clause) even recommends guard clauses as _good_ style: http://www.rubydoc.info/github/bbatsov/rubocop/master/Rubocop/Cop/Style/GuardClause
One thing to remember is that the higher level abstractions that Haskell uses are *really difficult* to apply in other languages, because Haskell has language features specifically to make those abstractions easier. They're also less useful in dynamic languages, because you can do things like: def validate result = { valid: true, errors: [] } unless valid_size(@image) result[:valid] = false result[:errors] &lt;&lt; "Image over 1MB" end # ... result end Generally, it's hard to write good Haskell from an OO/imperative background because you're not using Haskell idioms. Haskell idioms are great in Haskell. They're not necessarily good in Ruby.
True... I kinda just wanted to provide a rough counterpoint to the claim. Burden of proof is on original poster anyhow, I think.
&gt; Actually, I'm sorry I'm probably not available and will have to decline. No problem, I know that's a lot to ask for now that I think about it. I have friends who do Ruby that can read over any future posts. It wouldn't take much to catch a blunder the size of the one I made... I feel pretty ashamed about it! But I'm really grateful with how you tactfully pointed it out, and I will use that feedback to make the next iteration better. &gt; I don't really get the blogging impulse as a rule. But I know it's hard to put yourself out there on something you worked hard on. Honestly you're on to something. I can say overall (taking more than just this post into consideration) it's really not worth the time and energy based on what you get out of it. The dog I had grown up with since childhood just died a couple days ago and here I sit, wasting my small mental reserves defending something I had already taken down against some snarky Reddit post. I guess the alternative is to just let things go, like you mentioned. &gt; Really, the only thing you have to remember going forward is that programmers have spoke and they really don't care about Haskell. Haha :). I think the thing I have to remember is to just stick with the Haskell learning and leave the Ruby backports to the more experienced and more patient! And dare I say more masochistic. Let me just say one last time that I really appreciated your comments both in substance and tone. You seem like a really nice person, and I'll take your sage advice to heart.
Yeah if there's anything I learned from this experience, it's that I should spend less time writing blargh posts and more time learning Haskell!
My question then is this: why are there two different modes of performing what seems to be the same thing? Why are there exceptions and then functions that return a tuple (in Elixir)? And which should I use?
I'm not saying that immutability is bad; I completely understand the good things about having immutability. It's just really awkward to handle on a practical level, since every time something is mutated you have to propagate the changes all the way back up, which causes quite a bit of code churn if you weren't expecting something to change.
I did see `mix help`; but my point was that the "Getting Started" page should basically hold your hand until the point where you've released your first application and know how to run it (basically) on a production server. It should also give you a deeper understanding of how, and why, `mix` is necessary to the task of creating and managing projects, and what is the extent of its usefulness and powers. Elixir's immutability is great, and I understand it _must_ be baked into the language; but the bottom line is, Elixir is not that great to prototype in, since it is so rigid in its belief of immutability.
About the Getting Started: It really shouldn't. If you aren't learning on your own, you aren't that invested in it, and that's okay. About Mix: It's not necessary but like Leiningen in Clojure, it's an incredible help once you get past 2-3 files. I agree it should be more apparent *what* Mix is, because I get that question too often. To cover it now, as briefly as I can, Mix is an extensible build tool (not unlike Rake) which contains the package manager Hex (not unlike gem). As for immutability, there's not much I can do there. I don't find it a hindrance for productivity and by extension prototyping, but clearly that's a matter of preference. It's too much of a core idea in functional languages to break with, except for certain multiparadigm languages like Mathematica and Julia, which are often called functional without really being there philosophically. Apropos though, if Elixir feels rigid to you, you might enjoy Julia. While it doesn't have OTP or the BEAM VM, it does have a similar concurrency model, friendly syntax and macros.
It does, it needs a ton of docs. I just made it today. It is to have content in a rails app that you can edit on the fly even in production.
I am evaluating it. I tried using a lambda function, but it cut me off from so many rails variables that I figured this would be easier. I'd much rather use a lambda though of possible.
The link is a good read, it clearly shows how sanitizing via regex is a very hard problem (in this case the sanitation is markdown -&gt; html conversion). 
New Relic is mostly for server/application monitoring. It answers questions like: "How much time am I spending talking to the database vs running code?" or "which API calls are slow". New Relic does have a thread profiler, but it's pretty basic and won't catch a lot of Ruby issues, which are often problems with excessive object allocation. If I want detailed profiling I generally use https://github.com/ruby-prof/ruby-prof You shouldn't run it all the time in production but it's generally fast enough that you can run in on a single node to collect enough data without causing too much interruption. 
Check out [`instance_exec`](http://ruby-doc.org/core-2.2.1/BasicObject.html#method-i-instance_exec)
I'd say just do tutorials on codecademy for a week. then challenge yourself with codewars exercises where you can see others' more idiomatic solutions. then, build something yourself. after a month or so of developing in Ruby, read the Eloquent Ruby book to get your bearings set for good. 
I'm not sure you understand the point of immutability because when things are immutable, all your code can safely assume that their variables (now a misnomer as they won't "vary") will NOT change.
&gt; You can also check what's the current gemset; Are you sure that's the proper command? I just checked it, and it shows me the current Ruby version I'm working with.
If there is a gemset enabled the Ruby version will be followed by `@` and the name of the gemset. $ rvm current ruby-2.2.1@mygemset You can also do `rvm gemset list` and the current gemset will be marked by an arrow.
There should be no need to sudo if RVM is working properly.
Just to be sure: Does ‘rvm current’ works with the default and global gemsets? Or just custom ones? (Ruby rookie here)
OP can program already. Rails for zombies is a bad idea then.
search for the "ruby hacking guide"
This one. [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104/ref=sr_1_1?ie=UTF8&amp;qid=1428739103&amp;sr=8-1&amp;keywords=eloquent+ruby) is a great kick start for learning about idiomatic Ruby. It includes advice about style, not just how you lay out your code in the editor but about how to use Ruby as a language. For example, if I recall correctly, it touches on Metaprogramming near the end and shows how it's used by Ruby devs. It's clearly written and a joy to read and I wish a similar book existed for other languages I have attempted to and still want to learn (ObjC, Haskell).
Use `sudo -E` to preserve your shell environment and it will work. Whether you really want to install gems this way is open to debate. Most just avoid using system ruby entirely. Everybody mentions rvm which I've used but I prefer [rbenv](https://github.com/sstephenson/rbenv). I mean people still use `rvm gemset`? I used that a ton in Ruby 1.8.7/pre-bundler but not since.
Agreed about the i18n; that's what was driving the move-all-string-literals-into-one-method bit. All your i18n is easy to find and change. Since you mentioned Rails, though, I'd point out that the original OP's post mentioned Rails only in passing; neither his code nor mine use any Rails dependencies *per se* beyond the ActiveSupport extensions to numeric types. Either of our code should play just fine with Sinatra or Lotus or JoeBobsAmazingFramework provided it uses (or does not actively break) that one ActiveSupport module (and its dependencies). The first version *is* longer/more complex than I'd like; I'll have v2 up in 48 hours or so (from now) that will address much of that (IMO). Overengineering isn't a good thing. On the other hand, neither is *under*engineering, and I've seen that become more of an issue lately than ISTR from a few years ago. I come out of a background and languages (Smalltalk/Lisp/Forth/Dylan/early C++) that tend to train people to think in/work with a large collection of small, simple objects; anything more than 60-90 lines (what fits comfortably on two A4 printed listing pages) and I start looking for ways to restructure things. One of my major continuing issues with Rails is the degree to which large, complex code is tolerated if not outright encouraged. There's got to be a happy medium *somewhere*. As far as "creating a validator class using ruby idioms that is both clean, flexible and concise", what I see the promised v2 of my version as doing is breaking out validations from the current checklist format into a series of objects that each do *one* validation, like [`#verify_allowed_format`](https://gist.github.com/jdickey/8eaf646fbd754408c6d9#file-avatar_validator_v1-rb-L108-L112). That's made easier in this particular case because each of the requirements is independent of the others (format doesn't care about size, etc.). Thanks!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bazooka Joe**](https://en.wikipedia.org/wiki/Bazooka%20Joe): [](#sfw) --- &gt; &gt;__Bazooka Joe__ is a [comic strip](https://en.wikipedia.org/wiki/Comic_strip) character, featured on small comics included inside individually wrapped pieces of [Bazooka](https://en.wikipedia.org/wiki/Bazooka_(chewing_gum\)) [bubblegum](https://en.wikipedia.org/wiki/Bubblegum). He wears a black [eyepatch](https://en.wikipedia.org/wiki/Eyepatch), lending him a distinctive appearance. He is one of the more recognizable American advertising characters of the 20th century, due to worldwide distribution, and one of the few identifiable ones associated with a candy. &gt;With sales of Bazooka bubble gum down, Bazooka Candy Brands announced in November 2012 that they will no longer include the comic strip in their packaging. The new wrapper will include [brain teasers](https://en.wikipedia.org/wiki/Brain_teaser), instructions, and [codes](https://en.wikipedia.org/wiki/Code) that can be used to unlock videos and video games. The company stated that Bazooka Joe and other characters will occasionally appear on the new packaging. &gt;==== &gt;[**Image from article**](https://i.imgur.com/kdngHx0.gif) [^(i)](https://en.wikipedia.org/wiki/File:Bazooka_Joe.gif) --- ^Interesting: [^Bazooka ^Joe ^\(band)](https://en.wikipedia.org/wiki/Bazooka_Joe_\(band\)) ^| [^Bazooka ^\(chewing ^gum)](https://en.wikipedia.org/wiki/Bazooka_\(chewing_gum\)) ^| [^Woody ^Gelman](https://en.wikipedia.org/wiki/Woody_Gelman) ^| [^Wesley ^Morse](https://en.wikipedia.org/wiki/Wesley_Morse) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq8qf7r) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq8qf7r)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Honestly if you don't want the features of rvm, as most people never use them. Drop down to chruby. It's only 75ish LoCs. Much easier to understand than rbenv and has given me less headaches because I know what's going on.
Exercism.IO for any language you want to learn imho
&gt; pretty testable I'm not particularly defending /u/jdickey 's implementation. I agree that is could be re-factored much more clearly. However, I do think there's an important reason why your code (or at least, this coding style) is NOT easy to test. Rails validators, for example, do not work like your code - and for good reason. Your `validate` method returns when it encounters the **first** error! This means your test data must be valid for *all other criteria*, which could get really annoying! And if your `validate` method (or perhaps, your style of validation when applied in another context - say, XML schema validation) were to check for 100 different things then this could get seriously annoying for the user to only see one error message at a time! A much better way to handle this, I think (and what the Rails creators think) is to stick all of your error messages in an array. You can then do something like this: my_file.validate # =&gt; false my_file.errors # =&gt; ["Picture must be a valid image format", "Picture width must be &lt; 1000", "Picture height must be &lt; 800"] Also, there is a second reason why your approach is flawed from a testing point of view. It's all to do with making each method in ruby *as simple as possible*. Your `validate` method is already doing at least 4 things, which is a clear sign that it be easier to test if broken down into 4+ methods. If your test framework requires the use of stubbing objects etc, then it's easy to fall down the trap of writing tests that are closely tied to the *implementation*, rather than the *behaviour*. ..... With that all said, I think your code is, by far, easier to read than either the original author's (crazy nested `if` statements) implementation, or /u/jdickey 's. However, the general coding style of sticking the whole validation into one method with lots of `elsif`s is a big red flag to me that the code could easily become a pain to maintain (especially with tests).
If you're already an experienced developer I would recommend [Programming Ruby](https://pragprog.com/book/ruby/programming-ruby).
yeah, I hear ya! 
So replace shit with shit? gotcha
So where would I put my .rb files? When I navigate to the folder I had them stored in, it just says that ruby is found in the following packages. 
Depends on the project. If it's a fresh ("green fields") project, you can most likely do whatever you want. But if you're joining an existing team, working on an older project (which will most likely be the case, especially for new developers!), you're probably going to be restricted in all sorts of ways. How is source control done? How are code reviews done? Is there an enforced coding style? How are tests run? What's the deployment strategy? How is data backed up? *How are software versions managed?* ... I definitely think it's valuable for new developers to learn about the "most popular" answer to all these sorts of questions, because there's a very high chance you'll **need** to know about them, at some point. I think that (at least for now, in the current state of the ruby development industry), you should first learn how to use rvm/rbenv, and only then switch to chruby after reading the pros/cons.
I mean yeah, all of those things are normal, but none of those things you mention have anything to do with your coding env.
Use a parser generator, ruby has a tonne of gems
My previous job involved lots of SSHing between servers. These were all configured with fairly "vanilla" setups, so that several people could use them without conflicting configuration. Could I have used chruby here? Yes, but I would have had to install it over and over again - or I could have just used rvm, which all servers were pre-configured with! I also used to work in an "air-gapped" network, i.e. no direct internet connection, for security reasons. Many packages, such as chruby, were not available in the local software repository - but more "common" ones, such as rvm, were. Could I have made the effort to get chruby into the repository? Yes, but again, it was easier to just go with what's there already... I've also done quite a bit of pair programming, where I find myself sat at someone else's desk (or vice versa) for a while. Once again, using less common tools like chruby might be just fine, but it's definitely worth knowing what the "common" tools for the job are! Or maybe your job will involve some kind of "tech support" type role. Rvm gemsets, user permissions, etc are quite a common thing for people to need help with! Or maybe you're reading a ruby tutorial, such as a "Getting started with Rails 4" guide. There's a very high chance that the system installation part of the tutorial will talk about `rvm`. Even if you deviate from the guide at this point, you'll probably want to know what `rvm` *is* (and why you're not using it), so why not learn that beforehand? Basically, there are loads of situations where knowing the basics of `rvm` can come in handy. You shouldn't jump to choosing a "better" tool for the job, without first learning what the "normal" tool is. If `chruby` does, one day, become more commonly used than `rvm` then most of what I said above obviously becomes irrelevant!
I was an experienced PHP developer and rails for zombies was very helpful, but thanks for the down votes anyway :-/
Hi again! Not in any particular order... Always keep things in perspective. The thing that pushed *my* buttons about the original post was that one of the *many* new Rubyists perusing /r/ruby (and /r/rails) of late might get the idea that this was somehow code that *wouldn't* get you (at least) yelled at on any respectable team. That having been said... No, I wouldn't put all the validators together, certainly not with the model they validate. DI (which Ruby makes *ridiculously* easy and which is a G-dsend during testing) is a *lot* easier to keep straight in your head when you're not battling against "but they're all together here". That's a battle I've fought and lost consistently enough that I avoid it where possible. Too many classes usually results from less-experienced devs misunderstanding the SRP, often in conjunction with the ISP. The point isn't to break everything into the smallest semi-useful chunks; it's to give each unit, at each level of your architecture, one level-appropriate reason to change. Another way of looking at it is, if a domain rule or invariant changes, any and all code you need to change in response should be focused on what changed, not that and a dozen other things. Being "poorly thought out" is *the* problem; too many people are mis-trained into thinking that Agile means you start coding first and think about how it all works later, if at all. It's not that people can't "see the forest for the trees" as that they're expending titanic effort to produce the most highly-polished [root nodules](https://en.wikipedia.org/wiki/Root_nodule) yet seen. Hooking everything together and making it all fit for original purpose then becomes a *titanic* effort. "If you fail to plan, you're planning to fail" applies here, too. And yeah, nested ifs are one of my Top Five Indicators that somebody's seriously under-thought the problem at hand. We Rubyists have [tools](https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/cop/metrics/block_nesting.rb) to rap us on the knuckles when we get carried away; too few projects actually use them. Thanks for an interesting conversation indeed.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Root nodule**](https://en.wikipedia.org/wiki/Root%20nodule): [](#sfw) --- &gt; &gt;__Root nodules__ occur on the roots of plants (primarily [Fabaceae](https://en.wikipedia.org/wiki/Fabaceae)) that associate with [symbiotic](https://en.wikipedia.org/wiki/Symbiotic) [nitrogen-fixing](https://en.wikipedia.org/wiki/Nitrogen_fixation) [bacteria](https://en.wikipedia.org/wiki/Bacterium). Under [nitrogen](https://en.wikipedia.org/wiki/Nitrogen)-limiting conditions, capable plants form a symbiotic relationship with a host-specific strain of bacteria known as [rhizobia](https://en.wikipedia.org/wiki/Rhizobia). This process has evolved multiple times within the Fabaceae, as well as in other species found within the [Rosid](https://en.wikipedia.org/wiki/Rosid) clade. &gt;Within legume nodules, nitrogen gas from the atmosphere is converted into [ammonia](https://en.wikipedia.org/wiki/Ammonia), which is then assimilated into [amino acids](https://en.wikipedia.org/wiki/Amino_acids) (the building blocks of proteins), [nucleotides](https://en.wikipedia.org/wiki/Nucleotides) (the building blocks of [DNA](https://en.wikipedia.org/wiki/DNA) and [RNA](https://en.wikipedia.org/wiki/RNA) as well as the important energy molecule [ATP](https://en.wikipedia.org/wiki/Adenosine_triphosphate)), and other cellular constituents such as [vitamins](https://en.wikipedia.org/wiki/Vitamin), [flavones](https://en.wikipedia.org/wiki/Flavone), and [hormones](https://en.wikipedia.org/wiki/Plant_hormones). Their ability to [fix](https://en.wikipedia.org/wiki/Nitrogen_fixation) gaseous nitrogen makes legumes an ideal agricultural organism as their requirement for nitrogen fertilizer is reduced. Indeed high nitrogen content blocks nodule development as there is no benefit for the plant of forming the symbiosis. The energy for splitting the nitrogen gas in the nodule comes from sugar that is translocated from the leaf (a product of [photosynthesis](https://en.wikipedia.org/wiki/Photosynthesis)). [Malate](https://en.wikipedia.org/wiki/Malate) as a breakdown product of sucrose is the direct carbon source for the bacteroid. Nitrogen fixation in the nodule is very oxygen sensitive. Legume nodules harbor an iron containing protein called [leghaemoglobin](https://en.wikipedia.org/wiki/Leghaemoglobin), closely related to animal [myoglobin](https://en.wikipedia.org/wiki/Myoglobin), to facilitate the conversion of nitrogen gas to ammonia. &gt;==== &gt;[**Image**](https://i.imgur.com/5WCtJkt.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:Root-nodule01.jpg) - *Cross section though a soybean \(Glycine max 'Essex'\) root nodule. The bacterium, Bradyrhizobium japonicum, colonizes the roots and establishes a nitrogen fixing symbiosis. This high magnification image shows part of a cell with single bacteroids within their symbiosomes. In this image, endoplasmic reticulum, dictysome and cell wall can be seen.* --- ^Interesting: [^Rhizobium ^galegae](https://en.wikipedia.org/wiki/Rhizobium_galegae) ^| [^Dalbergieae](https://en.wikipedia.org/wiki/Dalbergieae) ^| [^Frankia](https://en.wikipedia.org/wiki/Frankia) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cq8ygwt) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cq8ygwt)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I've only ever heard good things about the Haskell concurrency model, though I've never used it myself (still a noob~). Given that Elixir is purpose-built for it, I'm sure it has a better story. Haskell partitions code into two kinds: pure code and impure code (otherwise known as IO). Exceptions can be thrown anywhere, but only caught in IO code. As a result, it's strongly discouraged to write pure code that throws exceptions. Generally, Haskell programmers try to make their functions work for arbitrary input, using things like optional types or error-recording types to indicate that a function might fail. 
There are several things wrong with the code in that blog post that have nothing to do with Ruby vs Haskell: 1. Unrelated validations should not be mixed. The size of a _file_ has nothing to do with an _image_. Use a separate file validator to check the size. Why is a _validator_ responsible for handling file -&gt; image conversion? Parsing a file into an image has nothing to do with validation. This should not be done in a validator. Really you should be checking the file size lower in the stack, otherwise you could get blasted with a lot of data your just going to throw away. 2. Speaking of mixed concerns, why is the validator responsible for generating a json response? I could understand generating a json representation of the object, but that it not what is being done, it's clearly a structured response for the API. This also doesn't belong in a validator. 3. Why does this validator need to be instantiated? Why aren't the methods static? There should be no need to store state here, no need for these allocations. You'd think a Haskell guy would be well aware of the dangers of storing unnecessary state. 4. `@valid` is always `truthy`. It's a `validator` with a `@valid` attribute that even if it's 'invalid' will always pass `if @valid`. (╯°□°）╯︵ ┻━┻ There are plenty of good patterns for validation. I like ActiveModel's approach and would probably use it here. Specifically I would write a separate validator for each requirement and and call them in sequence until one failed. Separate tip: you can use ActiveModel outside of an ORM, e.g. you can use all or part of it on POROs. 
I think the knee-jerk dump on Mongo is getting a bit old. Mongo has some good uses. I think the bad rap it gets is from all the people who just assume that it can replace their relational database, and don't understand what they're getting into.
Not bad, but this has been done a billion times before :)
It's a nice idea, although this has been done plenty of times before - e.g. [if, by Paul Macur](https://github.com/mudge/if) and [ifelse, by Jim Wise](https://github.com/jimwise/ifelse). I don't really like your choice of names for this gem, either - I think you got the wrong end of the stick here slightly. I would have called it something like "smalltalk_if". It might also be worth mentioning in the README that this is a "just for fun" gem, and is not recommended for use in production code. The null object pattern, or "active nothing", is a more generic principle about being able able to send the same (chains of) messages to all objects. Check out this [awesome blog post](http://devblog.avdi.org/2011/05/30/null-objects-and-falsiness/) by Avdi Grimm, and the gem he later created using the idea: [naught](https://github.com/avdi/naught). *This* is, in my opinion, more like what a gem called "active nothing" should be doing. Thanks for the link to the ruby conference video too ([link for the lazy](https://youtu.be/9lv2lBq6x4A)) - I found it really well presented; maybe I'll even make it down there for the 2016 talks!
Read a ruby style guide. There are various guides available, but they are 95% in agreement with one another - e.g. "use 2-spaces soft indents" https://github.com/bbatsov/ruby-style-guide Handling `nil` nicely is a more complicated topic, but for starters you can use `.nil?` instead of `== nil` - and probably need to redesign the code somehow if you're doing these checks often!
This seems MUCH more focused on the rails framework than in ruby, which is what the OP asked for. 
Care to correct?
&gt; You can't define class methods with a singleton_class though wat? Yes you can. By 'class method' i just mean a method that has the class as the receiver. So, for an `instance_eval` the instance method is always defined on the singleton class. If the receiver is a singleton class itself, then the instance method is defined on the singleton class of the singleton class. EDIT: terminology here gets confusing, i meant using `class_eval` in this case will define an instance method on the singleton class (which will be a class method on the class). But using `instance_eval` will define a class method on the singleton class (which will be an instance method on the singleton class of the singleton class) :) 
Yes but AFAIK you can’t rename a gem.
You can, sort of. You can yank ("hide") the gem, and re-publish the gem under a new name. Not *quite* the same as renaming it, but pretty close... Google it :) 
&gt; atomic methods of 3-5 lines each That is not what atomic means in the context of computer science. I'd be careful using that terminology while helping new folks, it will confuse them later. 
noted -- its not what atomic means in any field for that matter.
A module is nice if you have one set of shared values that you'd like to require in different files. If you need more than one read only hash you should consider writing a simple data container for the purpose. You could model a class after my example module and add any extra methods you need. Another solution would be to, as others have responded, construct a regular hash and freeze the values (recursively if necessary). If you want to preserve most of the regular hash functionality, a solution would be to create a module that redefines certain behaviors of a hash, and extend existing hashes with it after you've set them up with their initial values. You could probably subclass Hash with similar results, but then you'd have to rewrite all the initialization stuff and that would probably be a pain. # By extending a regular ruby hash with this module the hash will behave as if # it were an immutable object. The brackets and fetch methods will return copies # of values and the assignment method will raise an exception. # # Other methods that should be redefined for a truly immutable hash object. # :delete, :delete_if, :reject!, :select!, :keep_if, :merge!, :update module ReadOnlyHash def [](key) value = super(key) value ? value.dup : default end def []=(key, value) raise StandardError, "assignment on a read only hash" end def fetch(key) super(key).dup end def fetch(key, default) value = super(key, default) value ? value.dup : default end def fetch(key, &amp;block) if has_key?(key) super(key).dup else yield end end end # Example: # require_relative 'read_only_hash' # Create a hash and set it up with any values it should contain. hash = {foo: "bar", baz: "qux"} hash[:zux] = "cav" # Extend the hash with new read-only behavior hash.extend(ReadOnlyHash) hash[:baz] # =&gt; "qux" hash.fetch(:foo) # =&gt; "bar" x = hash[:zux] x = "changed it" hash[:zux] # =&gt; "cav" hash[:incorrect_key] # =&gt; nil hash.fetch(:incorrect_key) # =&gt; KeyError: key not found: :incorrect_key hash.fetch(:incorrect_key, "a default value") # =&gt; "a default value" hash.fetch(:incorrect_key) { puts "executing block because key was not found" } # =&gt; "executing block because key was not found" hash[:foo] = "new value" # =&gt; StandardError: assignment on a read only hash
Also, the File was not closed properly in the original variant: my_file = File.open("mess_around.txt", "r")
 my_arr = [] File.foreach("mess_around.txt") do |line| my_arr.concat(line.scan(/\w*(?:bo|[mr]e)\w*/)) end p my_arr Notes: * A single regex is most likely faster than three comparisons via #include? - regardless whether done with an array or coded individually. * File.foreach() avoids reading the whole file into memory. * File.foreach() closes the file properly. * There will be an Array generated per line in the input file. That can be avoided by using the block form of #scan. Edit: formatting.
here is what I came up with: https://gist.github.com/NullVoxPopuli/9f89ef70cd2b509cc22c It looks like the scenario I was talking about is in the case of define_method. I did not know that until now, so thanks for getting me to actually run through this. here is the output: $ ruby test.rb me.singleton_class.instance_eval klass.say_instance_eval: undefined method `say_instance_eval' for MyClass:Class instance.say_instance_eval: undefined method `say_instance_eval' for #&lt;MyClass:0x00000000d09cb0&gt; klass.self_say_instance_eval: undefined method `self_say_instance_eval' for MyClass:Class instance.self_say_instance_eval: undefined method `self_say_instance_eval' for #&lt;MyClass:0x00000000d09cb0&gt; klass.dynamic_defined: undefined method `dynamic_defined' for MyClass:Class instance.dynamic_defined: define_method instance_eval me.singleton_class.class_eval klass.say_class_eval: undefined method `say_class_eval' for MyClass:Class instance.say_class_eval: class_eval klass.self_say_class_eval: undefined method `self_say_class_eval' for MyClass:Class instance.self_say_class_eval: undefined method `self_say_class_eval' for #&lt;MyClass:0x00000000d05e08&gt; klass.dynamic_defined: undefined method `dynamic_defined' for MyClass:Class instance.dynamic_defined: define_method class_eval MyClass.singleton_class.instance_eval klass.say_instance_eval: undefined method `say_instance_eval' for MyClass:Class instance.say_instance_eval: undefined method `say_instance_eval' for #&lt;MyClass:0x00000000b52fe8&gt; klass.self_say_instance_eval: undefined method `self_say_instance_eval' for MyClass:Class instance.self_say_instance_eval: undefined method `self_say_instance_eval' for #&lt;MyClass:0x00000000b51850&gt; klass.dynamic_defined: define_method instance_eval instance.dynamic_defined: undefined method `dynamic_defined' for #&lt;MyClass:0x00000000b500b8&gt; MyClass.singleton_class.class_eval klass.say_class_eval: class_eval instance.say_class_eval: undefined method `say_class_eval' for #&lt;MyClass:0x00000000b4eb00&gt; klass.self_say_class_eval: undefined method `self_say_class_eval' for MyClass:Class instance.self_say_class_eval: undefined method `self_say_class_eval' for #&lt;MyClass:0x00000000b4d638&gt; klass.dynamic_defined: define_method class_eval instance.dynamic_defined: undefined method `dynamic_defined' for #&lt;MyClass:0x00000000b4c468&gt; If you run this yourself, (after installing the colorize gem), you'll see that the first two green define_method outputs are what I was mentioning in my comment in the code that you commented on. I hope this makes sense and I'm not crazy. haha
College student here. Ruby is nowhere to be seen. Python is taught at MIT and I am assuming other top schools, but for everyone else it's C, C++, or Java. &gt;You'd think an insanely marketable skill would make it into schools by now. Ha, most universities do not care about that. Our school was supposed to have a Web App Programming course taught with Rails, but it got changed and now we are doing 2003-era PHP.
&gt; VB 6.0 and prior is not .NET, and is such a vastly different beast that it's not even comparable. Well, been there and done that, and I see it as very comparable. Agree to disagree. Different strokes, and all that. &gt; I'm not sure what you mean by it being difficult to find out which one is the right tool for the job. What? No love for XMLTextReader? And that's my point. In saying it's a moot question, you've glossed right over another option that muddies the waters. And your linked article also references XMLPathDocument, a *fourth* option I hadn't even known about. Sheesh! You're contending that it's at least as easy to find direction with "Windows" tools as it is with "FOSS" tools? Quick: EntityFramework, or nHibernate? Or Dapper? Or something else? And why? Oops! Trick question! After months of research and trial and error, I wrote my own database library, because they all fall apart, for my situation, in some critical aspect. In Ruby, the answer is obvious, and *good*. I know I must have way more hours invested in Rails than .NET, even though I've logged a lot of time in the latter as well. After a *month* of wrangling with the ORM question, and settling on EF, I wrote a Rails version to duplicate my .NET app at the time. It took a single hour to write, and the first try ran *10 times* faster to parse large XML files and stick the results in a database through an ORM. After taking an optimization swipe at it, it was 20 times faster. Your mileage obviously varies.
yeah, sorry about the confusion :-( I learned a wii bit though :-)
The code is over a year old. I'm surprised it still works well.
Why would you want us to do that? 
+1 for "use what you know/like" best - both technologies will allow you to reach your goal as far as the languages are concerned. Now, you are building a CMS? From scratch or using some existing CMS/library/framework? I would not create a CMS by myself today, except if I wanted to sell one - enough options already on the market IMHO.
Fair enough. About your initial question, you may want to make a short evaluation of the available libraries that could make your work easier - you probably want rendering from a markup (redcloth or equivalent in Ruby), version management and others, and building them would probably not bring you much value (I suppose you do have an idea about what would make your CMS valuable). Even so, maybe look at some open source implementations like LocomotiveCMS, Refinery or Nesta - maybe some of them allow for easy extension (check the licence about commercial reuse), and could give you a nice place to start. Worse case, they may give you ideas.
RubyKoans linked in the side bar. Great intro for someone who already knows how to program.
Thanks! I'll check it out!
Circuit breakers are a very important pattern to use but this: &gt; Resource drivers are monkey-patched to be aware of Semian Sounds like a terrible idea.
It's difficult to guarantee that every remote call goes through Semian without patching at the lowest possible level in a very large Ruby code base (several 100k LOC).
I've recently started using [HackerRank.com](http://hackerrank.com). It's got four domains: algorithms, linux scripting, artificial intelligence, and functional programming. They've got competitions as well. It'd be a great way to practice any language.
13 points of analysis. This is not a speed comparison. This is primarily a project health comparison, with speed being a footnote. This could also be a template for comparing the health of projects. I made this because I work with people who still cling to Haml, which I consider to be a (nearly) dead project, and IMO, this proves that.
&gt; "Haml again somewhere in ass" What did I just read? 
Just as a note: https://github.com/k0kubun/hamlit - a high performance Haml implementation
Thanks 5larm, I will be checking the link. Your help is most appreciated :) By the way, would you recommend reading the book you linked? it seems a bit outdated (2001).
Eloquent Ruby was the most eye-opening programming related book to date for me. I'm certainly no Ruby expert, but Eloquent Ruby was such a fascinating read and had so many light-bulb moments. OP, I'd recommend Eloquent Ruby and Practical Object Oriented Design in Ruby. Both are great books.
Ruby changelogs I always find difficult to read.. How do you know what changed between the last point release, when the log goes all the way back to 2013 with no version numbers given?
I saw Matz talk at a 2014 Thanksgiving event at Heroku and the impression I got was that he didn't seriously think optional typing was right for Ruby. Maybe I misinterpreted what he meant, but I took him to say "I did a lot of work to figure out how typing in Ruby could work, so that I could reject it from a place of knowledge and experience." Maybe I'm misinterpreting that he meant the decision to reject typing had been made, but I'm pretty sure he meant that just because he had done a lot of research and experimenting with typing (and presented on it) it didn't mean it was a done deal. Though maybe there is more in the comments of those issues rather than my impressions from seeing various talks :-)
Production count isn't as important as maintainers right? Regardless of number of applications that use it, c++ is actively maintained. 
I guess you have a different interpretation to me of what a "dead project" means. I'd only say a project is "dead" when (almost) no one is actively using it. Which is *definitely* not the case with Haml!
Read the discussion in that link. There is a lot of debate about this exact issue, and to some extent it's still an open question. &gt; Matz (2011): &gt; in dynamic language like Ruby, optional typing should honor duck typing, I don't think previous discussion consider this aspect deeply enough. &gt; Scala supports statically checked duck typing. See http://markthomas.info/blog/?pf. &gt; Duck typing in Go https://en.wikipedia.org/wiki/Duck_typing#In_Go There also lots of in-depth blog posts discussing potential implementation details, if you're interested.
I agree it's pretty silly that the official changelog gives you no way to know what changes were in what release. There's a ruby github, although I don't think the ruby core team does their main development in that repo still (I could be wrong), it does faithfully mirror it if not. Which means if you want to look at every commit (and the official changelog seems to be a line for every commit anyway) you can: https://github.com/ruby/ruby/compare/v2_2_1...v2_2_2 Github hooray. No idea why they name their tags with underscores. 
I'd say its effectively dead when no one is using it on *new* projects.
62 open issues, many of them serious bugs, many with no discussion, and many going back many, many years. 11 open pull requests, and almost zero development activity. The community is moving to Slim, and it appears that the tipping point has been reached.
Yep. And this attitude is what I fight at work. Do we have the resources on our small team to support Haml ourselves? No? Then don't fucking use it!
It's from the linked performance tests http://graffzon.tumblr.com/post/15303347654/comparsion-of-haml-slim-erb
Haml predates them all and they likely wouldn't exist either if it weren't for Haml. Show some respect son.
I'm a Haml hater. I &lt;3 Slim. Once open source has been abandoned by the community it becomes a liability to a business using it.
If you were just using ERB, you would have one less thing to worry about, and wouldn't need to spend time transfering from haml to hamlit to slim, instead of actually developing your app. Now, I'll admit, I've never seen the appeal of haml _anyway_. But I understand many people do, different strokes for different folks, okay, some people see a lot of benefit in using haml/slim instead of ERB. But I think you've got to evaluate whether the amount of benefit you think you are getting from haml/slim is worth having to deal with... this sort of thing. Of course, if the mental energy or effort required to deal with "oh, I better switch from haml to slim, with an intermediate stop at hamlit" is, in your opinion, actually pretty small, okay then. Me, I just stick to ERB and don't worry about it. 
ERB is a different beast entirely. I could add it, but it really isn't a contender for people looking for an alternate HTML syntax, since that's not what it is. But you are welcome to fork or copy the gist!
Do you have the resources on your team to support slim yourselves? Do you have reason to believe slim won't eventually come to the same fate as haml? After all, haml used to be quite popular, it seemed a pretty safe bet, as good as anything. Or just when it does, you'll move on to whatever's next? Me, I just stick with ERB, and this is one of the reasons why. As long as there's a Rails, ERB will be maintained, and if Rails is no longer maintained, I've got bigger problems. :) But just one of the reasons why, certainly even without that, I never saw much point to haml/slim, I realize I'm in the minority, at least in online discussions. 
That's true.
Yes indeed! https://opalist.curated.co/issues.rss
New website up today! http://opalist.co
Why don't they use the stdlib implementation? 
Yup, very unlikely, but fickle is the keyword there.
Check out this screencast on removing conditionals from your Ruby code via concrete classes. This video will soon be re-edited and recorded and posted on WWW.RUBYCASTS.IO
Looks like that tells you differences between 2.1.0 and 2.2.0, but not 2.2.0--&gt;2.2.1--&gt;2.2.2. It starts with "NEWS for Ruby 2.2.0" and "Changes since the 2.1.0 release"
If you're upgrading from 2.1 (edit, well, apparently from previous versions also) look out for the [default arguments change](https://bugs.ruby-lang.org/issues/10314). That bit me on an app that used [typus](https://github.com/typus/typus). 
I just changed it to be a &lt;&lt; str[hold - b] and it worked. but both work equally when i run it in the terminal
What does the error message actually say? Is there a good reason why you couldn't just do `str.reverse`?
Yeah, they added all that in a patch release from 2.2.1 to 2.2.2. They also added built-in AI (a machine learning engine that's kind of like Siri, kind of like Clippy), quantum computing, and it'll make you toast for breakfast. 
Why would you call that a 'truth table'? Is this a common thing to do? This is what I know as a truth table, regarding boolean logic: http://en.wikipedia.org/wiki/Truth_table
The problem is that coderbyte is running Ruby version 1.8.7. In this version of Ruby the [String#[]](http://ruby-doc.org/core-1.8.7/String.html#method-i-5B-5D) method is different than in newer versions. If you click on that link to see the documentation for the method, you will see that when String#[] is passed a single Fixnum parameter, it will return a Fixnum. A TypeError is raised when you try to pass a Fixnum to the [String#+](http://ruby-doc.org/core-1.8.7/String.html#method-i-2B) method because it expects a String input. The [String#&lt;&lt;](http://ruby-doc.org/core-1.8.7/String.html#method-i-3C-3C) method gets around this by converting the Fixnum to the proper String character before concatenating the two strings. Keep this in mind when writing your solutions for coderbyte as there have been many other changes to common Ruby methods since 1.8.7. Check the 1.8.7 documentation if you run into trouble. Also, Codecademy has a Ruby 1.8.7 environment you can test things out in [here](http://labs.codecademy.com/).
I've never heard of CoderByte, but 1.8.7 is very outdated now – it was released in [May 2008](https://www.ruby-lang.org/en/news/2008/05/31/ruby-1-8-7-has-been-released/) and officially retired in [June 2013](https://www.ruby-lang.org/en/news/2013/06/30/we-retire-1-8-7/).
Don't worry about the syntax too much for now, as long as it works on your machine. You likely have a more updated version of Ruby installed. The problem is with coderbyte using a very outdated version of Ruby.
Ah wait, by bad, the `do` is indeed optional. I just always include it for consistency, and also (in ruby code, in general) it's fairly unusual to actually use `while` loops! It's almost always easier/better to user iterators, like `.each`, or `.map`. But I repeat: If you want help then **show the error**!!!
&gt; So, to summarise this "zero cost", I need to: &gt; &gt; * Read all the documentation on your website. &gt; * ... I said there is zero switching cost *from* InfraRuby not *to* InfraRuby. Have fun with your straw man! 
&gt; If we change our mind and want to stop using infraruby, I have to go back and undo all of the steps mentioned above. (Or leave them in, as a big confusing - soon to be out of date - code smell!) So I suppose all of the server reconfiguration, deployment script reconfiguration, tests reconfiguration and "static types" code cleanup does not qualify as switching cost *from* infraruby? I was pointing out that there is a significant cost going in *both* directions, on a "complex" system. (And you would need to read the documentation in order to know how to switch *from* infraruby too! So that's not even a complete strawman!) Yes, if your project is just something simple running on one machine, then you can effortlessly stop using infraruby (and not bother to clean up the code). This is clearly the spin that your marketing team are taking. However, once you look at the wider picture, it's obvious that the "zero effort" line is nonsense.
Yeah, completely agree. Not a good term for it, but nonetheless a good technique – for unit tests. I would probably recommend against it for integration tests as it makes it too easy to balloon your run time and testing all the edge cases isn't really what integration tests are meant for.
I really want Opal to succeed, and on the few small projects I've used it on, its quite lovely.
&gt; So I suppose all of the server reconfiguration, deployment script reconfiguration, tests reconfiguration and "static types" code cleanup does not qualify as switching cost from infraruby? * server reconfiguration * deployment script reconfiguration If you use some tools outside InfraRuby for configuration or whatever then you should use those tools in such a way that you retain the zero switching cost that InfraRuby allows. If those tools make that hard for you then I suggest you take that up with the authors of those tools. * tests reconfiguration You can (and should!) use a Ruby interpreter for development and testing, so no reconfiguration is needed for that. * static types The type annotations are written in comments, so you could just keep those as documentation. &gt; (And you would need to read the documentation in order to know how to switch from infraruby too! So that's not even a complete strawman!) In an InfraRuby project you would use Ruby interpreters for development and testing, so you would already know how to do that! For example, the site at http://infraruby.com/ is written in InfraRuby, using MRI and JRuby for testing. (JRuby because the "live" feature runs in a Java sandbox, written in Java.) 
For better or worse, we are forever stuck with JavaScript in the browser. How do you imagine that ever changing? Let's say tomorrow a new version of Chrome comes out with support for Dart (pardon the bad example - [RIP Dart VM in Chrome](http://techcrunch.com/2015/03/25/google-will-not-integrate-its-dart-programming-language-into-chrome/)) or IE with support for the .NET family of languages (oops, another bad example, [RIP Silverlight](https://support.microsoft.com/en-us/lifecycle?c2=12905)). Anyhow, let's just *say* it happens, and let's pretend that everyone agrees on the favorite language to rule them all (now I'm really trolling, but bear with me), and that's the language that gets integrated into the browser. Now who would develop for this new runtime knowing that it is limited to a single browser vendor? Granted, that happened with IE in the past and almost happened with Webkit in the more recent past when it seemed like it would become the new IE because, you know, the "mobile revolution". But I don't see how this would be a desirable outcome for the web. The point is, what we have is *bad*, but it's as good as it can get. It will not get better. Hence the compile-to-JS movement. I am willing to bet that your *(insert favorite language)* already compiles to JS :) 
I use slim because it's much cleaner than haml and feels very elegant. Easier on the eye. It doesn't hurt that it's also faster :)
Nice idea. A couple of things that would be really useful: * Use the existing quote mark style (`'` or `"`) * An option to keep the Gemfile sorted alphabetically * A way to specify which group(s) to add a gem to
The post itself is about a trick to avoid testing. Author gives no reasons why one should skip ahead and stop testing/TDD other then a personal story of how he did not manage to keep his efficiency. But I think it has some great ideas how you can start building a test-suite in that project that has no tests yet.
How does the Whipsnake compare to the Sidewinder in regard to comfort and dominance? 
The issue is that sometimes updating one gem can cause others to update in the Gemfile.lock. In theory, if every gem author used semantic versioning, and specified dependencies correctly, this wouldn't be a problem, but that's often not the case.
Looks like this was fun to make, but why would I actually use it? In any "real" project, it would be quicker + easier for me to just open the `Gemfile` with a text editor and make changes that way! This also gives me better control of things like: * What order the gems are listed/grouped in (e.g. `group :development` blocks of related gems) * How comments are included in the list (e.g. A short message explaining why the gem is needed in the project) * Specifying the gem version some more advanced way (e.g. `"&gt;= 4.1.0", "&lt; 4.3.2"`) * Specific git repo/branch/tag/platform/commit for the gem (e.g. `git: "git@github.com:MyUsername/my_fork.git", branch: :experimental` * When to require the gem (e.g. `require: false`), * The gem engine/engine version (e.g. `:engine =&gt; "jruby", :engine_version =&gt; "1.6.7"`) .. And sure, you add most of these capabilities make your `gemput` gem, but would it ever really be better than just editing the text file manually??
My advise is stop trying to write C code in Ruby. This means you LinkedList! It is physically impossible to create a linked list in ruby that is performant. If you want a linked list, do it as a C extension. As far as learning 'proper' ruby: Destroy All Software (http://destroyallsoftware.com/screencasts/catalog) Ruby Tapas (http://www.rubytapas.com) Rubycasts (http://rby.io) Also, brush up on a bit of LISP and Smalltalk to write better Ruby. Here is a video on removing conditionals from your ruby code: https://www.youtube.com/watch?v=JhIYw1Y7pY0
Because it's most common delimiter for shell script commands in Dockerfile. Any requests for support other delimiters?
How would it happen? I would imagine an open source browser with a pluggable architecture and different companies investing in maintaining support for the languages they want to see in the browser. Either that or we start running full fledge OS in the browser with asm.js or something.
[async](http://opalrb.org/blog/2014/05/07/promises-in-opal/) [event-binding](http://opalrb.org/docs/jquery/)
I think an important bit here is that if you want folks to run the test suite you have to make the test suite easy to run. So set up CI, set up [parallel tests](https://github.com/grosser/parallel_tests), etc - make running tests as painless as possible. And put a chart up somewhere showing test count or coverage or whatever - make it visible. Got to sell it!
&gt; While these tools and development methods are great for organized teams with a product that is going through the maturity phase, they can encumber the feature rollout process quite significantly for a startup team. This is just wrong. For those who actually practice TDD long enough to master it, the initial investment cost is offset by two factors: 1. an improved feedback loop making it take less time to see if your changes worked, and 2. the act of slowing down to question "why" you are implementing a certain piece of code reduces waste. That second point is really important. Until you are very, very experienced as a professional programmer (talking decades here, not years), the most surefire way to improve your development velocity is to be more judicious about the code you write. &gt; Testing is expensive and is a hard sell to management. I don't agree. I have never heard of a place where management would both know we were writing tests and didn't think it was a good idea for us to write tests.
Man ain't that the truth. And I'm still sorting through the details... apparently I'm a slow learner...
hehe, just teasing you. Nice blog post! :)
There might be a world where Opal works with Ember. I would love to live in that world.
&gt; I'm getting a runtime error that the 'find' method can not be found Module methods are invoked with the module name as a receiver -- so you want to call `Foo.find`. (The same is true for class methods.) &gt; Modules are mostly a mix-in tool. Not *just* a mix-in tool, though. They also let you create a whole separate namespace and that's one reason module methods would be useful. Imagine that Ruby has no support for any kind of mathematic operation. You sit down and write a ton of methods for that yourself -- `add`, `subtract`, `pi`, `square_root`, `log`, etc. And because those methods are really useful, you want to share them with people, so you package them as a gem and submit them to the gem repository. Someone downloads your gem, requires it, and finds that it's overwriting the `log` method they already use to write error-logs, or the `add` method they use to concatenate arrays. It's a name clash. And even if they don't clash with existing methods, throwing a ton of methods, variables, constants, etc into the "top level" (global namespace) of a program is considered ugly and improper. So instead, you write a module, `Math`, and you make all of your methods module methods, naming them `self.add`, `self.log`, etc. Now when people require your gem, they call `Math.square_root(4815)` and the like, having to name the method each time. That prevents name clashes and keeps things organised in large apps. A good use for modules, even if you never have to mix them in.
If it looks like a duck and quacks like a duck, then it is a duck. If char num = '1' allows num + 1 = 2 or num**2 then it doesn't matter if it's a string, because it acts like an integer. If you really want to get a better grasp on stuff, I would suggest using 'p' instead of 'puts' from now on. It will help you better visualize your code.
This is a similar series of actions recommended by Sandi Metz in POODR. Though the jargon is substantially different. In her jargon I would call this 'Identifying Ducktypes &amp; Replacing with Inheritance' . That being said, it's an excellent strategy and your example was delightfully well thought out and easy to follow. Thanks for sharing it. As an aside, I'd like to point out that this methodology only really works within the context of this example because it is so well suited to inheritance. However inheritance imposes it's own set of woes. Consider the distinction between Live and Dead food. I won't say your model breaks, but it becomes much more complicated. At that point I would argue the value of a conditional is worth having so long as it is well placed; likely on the Stomach class.
Does it work with angular?
 "hello".index('e') #=&gt; 1 "hello".index('lo') #=&gt; 3 "hello".index('a') #=&gt; nil "hello".index(?e) #=&gt; 1 "hello".index(/[aeiou]/, -3) #=&gt; 4
Thank you! The instructions on the assignment said don't use String#rindex method. Is this different?
If this is a homework assignment then it's likely that they're asking you to write a linear search function. So write an each loop that goes over each character with an index and compare it to the character to be found. When it is found, stop and return the index.
Errors are almost always displayed just like a Ruby error.
Tools like SLIM and HAML
would love feedback on how to improve this...
That's a watermark on the video on YouTube. If you have that clip from a different source handy on YouTube, I'm happy to switch it out.
Seemed like the community was going to support HAML forever, too. Honestly, your reasoning seems really flawed. Here's a technical breakdown of ERB vs. slim. ERB pros: 1. Erb requires no additional dependencies. You can render erb templates with zero gems. Ziltch. One less thing that you have to maintain over the course of your project's history. One less thing that might peg another gem in your `Gemfile.lock` to an earlier version, etc. 1. If you know ruby, and you know HTML, the overhead of learning erb is minimal. Slim is a pretty reasonable learning curve for experienced rubyists. It is a hurdle, however, for front end programmers. 1. The visual resemblance between the HTML coming out of `.html.erb` and the template itself is less cognitive overhead than always "compiling" slim into html in your mind. Slim pros: 1. Less typing 1. ?? And, yeah, I also moved on from `restful_authentication` and `attachment_fu`. I moved on by not allowing myself to get caught up in the myriad of problems associated with superfluous library dependencies by littering my projects with "popular" gems that offer little meaningful value on top of what ships out of the box with ruby or a framework like rails.
And I consider most of that reasoning flawed. I use tools to make me more productive. Front end people I work with love Slim, and I actually haven't worked with someone who would choose HTML over Haml or Slim in many years.
If you don't need state, use a module. The rule I USE IS THIS: If it is a THING use a CLASS if it is a UTILITY, use a MODULE. But first you should extend all the methods onto the CLASS level... module Utility extend seld def some_method 'some return' end end Utility.some_method Personally I love these type objects as they are immutable by nature, and very easy to specialize into a single responsibility, via the SRP. If you are interested in a video on the subject: https://www.youtube.com/watch?v=2AM84E66Osk And my Ruby programming Manifesto covers utility modules as well: https://github.com/rubylove/ruby_programming_manifesto
You could supply `#sort` with a block to customize the ordering, but much better would be to simply `#rotate` the sorted array into place using the `#index` of the first element which satisfies your new definition of "first".
That's a bit ambiguous. Do you want to sort the list alphabetically, then rotate it until the words beginning with "f" are first? Or do you want to sort the entire list with an alternate alphabetical order? In other words, in your sorted list, which comes first: "fannie" or "fred"? In the former arrangement, "fannie" is before "fred", but in the latter it's the other way around. For the first one, sort the array, and then `rotate` it until the first element &gt;= "f" (you can do this in one step by using `find`). Make sure you match or convert case when doing the comparison (and the sort as well—use `sort_by(&amp;:downcase)` to get a case insensitive sort). For the second one, write a Caesar cipher function and then use `array.sort_by{ |v| caesar( offset, v )`. You can find the offset for a given letter with `(a..z).to_a.index(letter)`.
I'm not too sure of the syntax of splitting the halves. I just know enough to ruby to make a simple backend for my iOS front end. Do you mind showing me the syntax. Thanks!
Elixir makes the Erlang VM more accessible to Rubyists. Its even built by veteran Rubyists. Elixir becomes a great complementary language to create fault-tolerant services that support your RoR or Sinatra web apps. All using very Rubyesque syntax. So if anything, it adds mileage to Ruby (which is dropping in popularity in almost every language index). We should be extremely happy about that.
&gt; The fact that expectations have been patched directly into core objects has been a source of (mostly unjustified) gripes for years now Monkey patching every object with methods is a bad idea, it's considered poor form in your own code so I don't get why the author thinks it's OK for your test framework. 
I don't want to go to war over the point, but developers tend to get a little hysterical when it comes to monkeypatching, IMO. Yes, it's certainly possible to shoot yourself in the foot with indiscriminate use of open classes, but use of phrases like "bad idea" and "poor form" indicate that the dangers are more theoretical than actual. I'd challenge you to find a real example where including Minitest::Expectations in Object led to an issue with a method being overridden.
I did this gem a while ago as a prof of concept in order to avoid monkey patching in Minitest (among other things): https://github.com/pabloh/refinements_file . But I wasn't really fully satisfied with it. Maybe I'll give it another go sometime this month.
Probably because of logical consistency when you're setting a variable equal to a method of the same name in the same space. I never would have thought to do it that way until I read the posts in here and I kinda understand the rejection status on the default arguments link. It doesn't make any sense to write an expression where the interpreter treats the exact same thing, foo, in two completely different ways. It's probably better to think of the old behavior as a bug rather than the new behavior as a bug.
There's nothing wrong with it if that's what you prefer. Plenty of people use assertions with spec-style blocks to get the best of both worlds.
The change only looks the same from the API level, but the reasons for the two changes were different - method lookup in one case, and support for multithreading in the other.
You're passing a reference to the same object. Most languages work like this because cloning an object every time it is passed into a method would cause you to run out of memory very quickly (imagine duplicating an array with 10000 elements for example).
Ruby is pass-by-reference or pass-by-value? It's pass-by-value, but all the values are references.
I see, thanks for clearing that up.
I don't want it to work like that but it does make it the point, thanks. 
Also, BTW: Why don't you just add a rake task: rake infraruby:delete_all_typechecks This would be a big step towards allowing users to *genuinely* remove infraruby from their application, relatively painlessly. ...Except that I suspect you will never do this, as there is no (financial) business case for implementing such a feature. So I guess I'll just implement it myself, then?... Oh wait, no I can't - because it's a **closed source** project! Another example of why I'd generally want to steer clear of using anything like this in a big system.
interesting. didnt know about this before
Oh it's expected behavior once I started thinking about things the right way. My initial confusion was because I was thinking that a singleton method would be called before a class method, when actually a class method *is* a singleton method. I wrote up the post because the error message had surprised me "what, the superclass method is right there??" and thought it might be enlightening for others.
The reason you're getting so many downvotes is because you don't seem to have even tried looking up the answer yourself, before asking for help. http://ruby-doc.org/core-2.2.1/Array.html Google. Read things. Try stuff. *Then* ask a question, if you're still stuck. I not sure I've ever actually *used* the `rotate` method before, but here's a solution to your problem that I found within 1 minute of skimming the documentation: text_array = ["bob", "alice", "dave", "carol", "frank", "eve", "jordan", "isaac", "harry", "george"] sorted_array = text_array.sort sorted_array.rotate ( sorted_array.find_index { |y| y &gt;= 'f' }.to_i ) # to_i is needed in case find_index returns nil # =&gt; ["frank", "george", "harry", "isaac", "jordan", "alice", "bob", "carol", "dave", "eve"] ...But you might find a cleaner way of doing this, I don't know. Read the docs.
Not specifically Ruby, but by a great Rubyist: Dave Copeland
Yeah, but it's something different, for those how don't want to have to deal with cron.
My immediate thought when I read this was: How the heck are you getting any meaningful values?? And after reading some more, I decided that, for the most part, you aren't. &gt; To score a language, simply figure out how many characters it costs to “prevent” a certain type of error, and add that to the total. Newlines, spaces, and tabs do not count, but all other punctuation does. Huh?? So looking at one of your metrics: &gt; Test for Null Variable Reference Let's try it in ruby: my_object.some_method # where my_object might be nil Then in rails (*not* in core ruby!), we can do: my_object.try(:some_method) By your metric, this (Maybe? Does rails count as "ruby"?) gives the language a "safety score" of 6. But so what?? Surely measuring how easy it is to fall into this trap in the first place is 1000x more important than how many characters long the "try" method is!! (Edit: and it looks like [some of the "solution" implementations](https://github.com/steveshogren/blog-source/blob/bb4efb82060dc84b389bc8442d73520dac981c9b/source/javascripts/sliders.js#L410) are clearly flawed, too - e.g. no distinction between nil and false) And some of your metrics don't really even make sense to apply to ruby - for example: &gt; Passing Wrong Type to Method * Ruby is a dynamically typed ("duck typed") language, so you should not *care* what object type is passed to a method! All you should ever care about is what methods your object responds to. * This question has so many possible answers, regardless... You could use `respond_to?(:method_name)`, `is_a?(class_name)`, `.class == class_name`, you could use a [ruby compiler](http://infraruby.com/) to make the code statically typed, you could use a [ruby gem](https://github.com/gogotanaka/Rubype) to raise runtime exceptions upon bad input. * ...And in all the above cases, what actually makes the code "safe"? Do you still need to catch the exception and handle it somehow? It depends on the application!! I'm sure I could learn a lot about languages by seeing their "answers" to all your questions, but I'm also convinced your method for quantifying the data is fairly meaningless. I mean, using your method of analysis, I bet some really silly languages like [golfscript](http://www.golfscript.com/golfscript/examples.html) would come out as being "safest"!
&gt; By your metric, this (Maybe? Does rails count as "ruby"?) gives the language a "safety score" of 6. I'd think those would fall under two different "languages", in this case a raw Ruby and a Rails. Same with Clojure, Schema Clojure, and Typed Clojure, which have entirely different safety profiles. To me, this is valuable to show the relative merits of different community libraries and frameworks. &gt; so you should not care what object type is passed to a method! All you should ever care about is what methods your object responds to. These mean the same thing to me, it is like saying you don't care that your peg is square, just that the hole accepts the shape. Either way, to verify at runtime, it requires an understanding of both shape and hole to ensure a match. &gt; Surely measuring how easy it is to fall into this trap in the first place is 1000x more important than how many characters long the "try" method is!! I think for me, measuring how much it costs to add in a check does start to tell me how often it is used: if it is hard to use, it almost certainly won't be used as much. An unused safety check is a vector for errors. &gt; This question has so many possible answers, regardless... You could use respond_to&gt;(:method_name), is_a?(class_name), .class == class_name I may not know as much about Ruby, but I would guess one of these is considered idiomatic, and the rest are less common. Unless, in the case where the three are used interchangeably, then I would think that interesting information as well. I haven't had to add something yet that has such a variance, but if that is truly the case, I would just pick the smallest... &gt; I mean, using your method of analysis, I bet some really silly languages like golfscript would come out as being "safest"! Unless they provide enforced checks or compiler errors, they cannot even score in the negative. So at best they would be a low positive. I would love to see it though! Someone suggested last night that they want to score Java in keystrokes required to generate the code inside Intellij, which I think would be a hilariously great submission! Remember, this isn't about power, it is about the cost of safety. If the cost of safety is low in a language like APL, that is because every function is pretty much one character. It has nothing to do with its suitability or power or library value or performance. A lot of things go into choosing a language, this is just one small dimension. I have found it very useful nonetheless. I think having a terminology to talk about how errors occur in a language is how we will start to make them all equally safe. 
Could you give some criteria for who you feel would be a good mentor for this mentorship? It likely ain't me, but it might help others see themselves in the role.
&gt; I'd think those would fall under two different "languages" Fair enough. Although often, an "optimal" solution can be achieved by using a gem, which is outside the standard library. Sometimes these gems may even be considered best practice, and other times they're "just for fun". So it's hard to assess this perfectly. &gt; [Dynamic/static typing] mean the same thing to me, it is like saying you don't care that your peg is square, just that the hole accepts the shape. But can you not see how from a "language safety" perspective, there is a **huge** difference?? You write/test code with a whole different mentality in dynamically typed languages! In dynamic languages, as a rule of thumb, the code is quicker to write but must be tested more thoroughly. This means it is naturally "less safe", but you mitigate this through more rigorous testing. And so the code itself should very rarely be doing safety checks like `my_object_is_a?(class_name)`or `my_object.respond_to?(method_name)` because the test suite ensures it's being called correctly! (Whereas in static languages, a misused function would simply not compile.) &gt; I may not know as much about Ruby, but I would guess one of these is considered idiomatic, and the rest are less common. My point was that these methods are doing different things. Of those I listed, using `my_object.respond_to?(method_name)` would be the most "idiomatic", but it is very important to realise: This is *not* actually answering your original question! Here I am checking the object's methods, NOT the object's class. The correct answer to your question is probably: `my_object.is_a?(class_name)` (although this also returns true for derived classes - is that what you expect?), but this is generally something to avoid doing in dynamic languages. Heck, you could even do something really dirty like `my_object.not_a_real_method rescue 'whoops'` to make your code "safe", not that this is a good idea!! &gt; A lot of things go into choosing a language, this is just one small dimension. I appreciate that, and I certainly wasn't accusing you of judging each language purely on this table. I do, however, still question whether the numbers in this table (especially when comparing totally different types of languages - such as static vs dynamic) are even meaningful. A 20 second google gave me [this](http://tobyho.com/2008/03/30/how-safe-is-your-programming/) comparison (which I'm guessing you've already seen?), and IMO that's a lot better. It doesn't go over-the-top in trying to quantify each aspect of safety, by something so arbitrary as number of characters used. If I were you, I'd consider re-writing the useful data you've gathered into something more like a "How to implement these safety checks in each language" guide.
For what it's worth, I made a [Ruby monkeypatch manager gem](https://github.com/pmarreck/pachinko) which basically allows you to write a monkeypatch in such a way that if an assertion (that the patch is still necessary) doesn't pass, *at runtime,* the patch won't be applied and you get a console message. The tricky bit is, of course, writing the test case to assert the patch is still necessary. This is meant mostly for self-expiring bugfix patches and not for feature-adds. Although you could for example ensure that your feature-add doesn't namespace-clobber some same-named feature added by another gem. I was forced to write this after looking at the old repo I was responsible for and seeing tons of unchecked monkeypatches, still running, that fixed bugs that have long since been patched up, leading of course to unpredictable behavior/bugs. It was these kinds of Ruby shenanigans which drove me to [Elixir](http://elixir-lang.org/), by the way, which already happens to implement this Transproc idea (out of the box) as a simple pipe operator: |&gt; (see [this blog post](http://www.spacevatican.org/2014/10/20/stuff-that-in-your-pipe/) for a demo)
1. I've tested this, yes 2. I use idiomatic hash initialization. So long as `HashWithIndifferentAccess` and all other subclasses implement idiomatic initialization properly, [this will work as well](http://en.wikipedia.org/wiki/Convention_over_configuration). 3. Of course you can have either `String` or `Symbol` keys. I don't understand your concern.
... Are you quoting me in a separate comment thread? If you have a strict rule against monkey-patching, do you avoid rails, where it's already implemented all over the place? Also, I did not suggest to gem the monkey-patch. I feel this sort of change should remain in the "local application source code scope". If I were going to create a gem _and_ wanted to use this syntax, I might consider namespace via object composition to prevent collisions and forward method calls via delegation, but it would be just as easy to avoid it altogether. I don't consider this worse than introducing an inter-gem dependency, which comes with its own headaches.
&gt; So to summarise, infraruby is great at long as you conform to the impossibly strict system guidelines that the infraruby developers had accounted for. No. Let me be clear: we make claims about the tools we ship, not whatever other tools you may be using. InfraRuby code is also Ruby code. InfraRuby projects are also Ruby projects. Every InfraRuby project is created with a gemspec, a Gemfile, a lib/foo.rb file, and a Rakefile with a "spec" task (which uses a Ruby interpreter), just like other Ruby projects. So you can always use your InfraRuby code *with Ruby interpreters* with zero switching cost, because it's already set up that way. We don't ship configurations for Travis CI, say, or any other tools, but if you wish to use Travis CI, you can add ".travis.yml" to your InfraRuby project, just as you would for other Ruby projects. 
&gt; Oh wait, no I can't - because it's a closed source project! The standard InfraRuby rake tasks are defined in the "infraruby-task" gem, which is available under the MIT license. Only the compiler and runtime are proprietary. The surrounding tools, compatibility packages and gem substitutes are all available under the MIT license. You can find details here: http://infraruby.com/blog/the-many-licenses-of-infraruby Ya got any more straw men? 
App Academy?
Ruby actually makes testing a pretty low cost activity. It's not free, but it's A lot nicer than JUnit or testing C programs. 
On it's face automated testing might seem an easy sell because less bugs, etc but I've worked with enough founders who think that a certain amount of bugs is expected and acceptable and that testing overhead prevents them from jamming in as many features as possible or easily pivoting. Not saying it's right or wrong but it's a very different set of thoughts and concerns. 
You don't want to include all of SASS if you just want some colour changing code.
Did you file a bug report?
You may have to re-install ruby. Likely, the Mysql installer installed a new / different version of some c libraries that ruby is using. I recommend looking into using vagrant if you are planning on doing development on that machine long term, so that the ruby code and db systems can run on linux, while you do your code editing on the windows machine. Note: You could try install the gem rb-readline to prevent it from using the c library for getting user input, but if any other commands are breaking, you may be out of luck.
I'm doing a deep uninstall of Ruby using Iobit Uninstaller now, then I'll reboot and do a (hopefully) clean install. Will report back if that works. I'll probably look into Vagrant at some point. I've been programming for a while but am completely new to Ruby, didn't want to over-complicate things at first.
I don't really know either, but similar to what dvito said - I wonder if it has something to do with a shared library. Maybe the `C:\Windows\SysWOW64\ntdll.dll` mentioned in the output. The fact that Ruby is not handling it well may be a bug.
Haven't looked in-depth yet but these kind of initiatives are always an excellent idea to figure out best practices since nothing brings out collaboration better than saying "This is the way to do it" and wait for all the disagreements :p
Nope didn't fix it. Wtf.
Okay this fixed it...for some reason. Doing a clean install from http://railsinstaller.org/en didn't work. But I noticed that was installing a flightly out of date version of Ruby. Clean install from http://rubyinstaller.org/downloads/ seems to be working. Why this is the case (the install I've been running for a while now from http://railsinstaller.org/en has been working), no idea. But huzzah regardless! 
&gt; You can find details here: http://infraruby.com/blog/the-many-licenses-of-infraruby Ah okay, fair enough, this is better than I thought. However, there's till one big problem: I cannot make a pull request to your code!! As far as I can work out, the source code is not actually stored anywhere public online - I had to fetch and unpack the gem to read it. And that gem's README points you to [this github page](https://github.com/InfraRuby), which doesn't contain any of the code. (Or maybe it does, in private repos? In which case, why are they private?) By the way, tell your developers to stop mixing tabs and spaces. This can get very annoying in various environments, and is trivial to fix. Also, stop unnecessarily writing `return` all over the place; it's not idiomatic in ruby. I'm also a little surprised to see that even your own gems don't use InfraRuby!!!
One implementation (`_`); two aliases (`value`) and `expect`). `alias` is crack cocaine for the API writer.
&gt; It sounds like you are saying it is not an idiomatic practice to check the shape or class of a parameter in Ruby. Instead, it sounds like the current best practice is attempt to eliminate those errors with unit or integration tests instead That's a very broad statement to make, and not one I feel qualified to give a complete answer to. All I can say with certainty is: "It depends". Sometimes (rarely), you need to do type checks (`is_a?(class_name)`). Other times, you need to check behaviour (`responds_to?(method_name)`). Other times, you can write one simple integration test to ensure the code works. There is no black and white answer to what constitutes "best practice". &gt; I would say if there is no idiomatic way to check for that error vector in Ruby other than test suites, then it gets the full penalty. I put in the full penalty for cases like that, where something either can't or is not recommended to be checked In that case, all dynamic languages should automatically receive your penalty, and all static languages should not. Or in other words, you're asking the wrong question - what you should be asking is: "Is the language statically typed?" And then, of course, discussing the "safety" of dynamic languages opens a whole new debate... For example, the application framework and test methodology has a huge impact on the "safety" which your table obviously doesn't account for. tl;dr: Rather than asking such specific questions about "how efficiently can you write code to do X", I think a better approach would be to ask "how likely is it that an X error will happen?". &gt; I find it interesting that in a less safe language, it appears to be idiomatic to have fewer safety checks That's not quite what I meant. I'm saying that the language is "less safe" **because** there are fewer safety checks (surrounding type safety, especially). And to implement your own type safety all over a dynamic language completely defeats the purpose of it being *dynamic*! Several of your questions all come back to the same issues surrounding dynamic vs static language safety. (Putting wrong type into variable; Incorrect Type Casting; Passing Wrong Type to Method, Calling or Setting Misspelled Method, Field, Function, Variable; Guaranteed Code Evaluation When Passed To a Function.) There are all "non-issues" for statically typed code, and discussing how dangerous they are in dynamic languages is much more complicated than simply asking "how many characters does it take to check for this?". &gt; I had seen that, but I didn't like how broad it was, and how it wouldn't allow the weighting of certain checks. I also didn't like how it ignored the nuance between easy and difficult for runtime checks. Some checks, say, in Clojure, are super easy, and so happen a lot, whereas others are difficult or un-idiomatic, and so are very rare. I wanted to explore this as an one explanation for why those variances happen. I like the idea of adding a better weighting, but I don't like the method you've currently used to calculate it. I think you're comparing apples and oranges with some of your questions, and the "difficulty" of implementing some checks is highly debatable.
Oh, yeah, that's what I meant to say. My question of "why?!" still remains :P
...And this is why 99.9% of rails projects are not done on Windows ;)
That's a really cool little hack, I can't believe I haven't seen it before! Another method that's good to be aware of is [module_function](http://apidock.com/ruby/Module/module_function).
I'm a little confused about what you're asking for: &gt; We've got a very good student application, and an extra slot to accept that student, but no mentor for the slot Are you looking for a personal mentor, or a project mentor? Are you looking for someone to help write code, review code, or actually manage the project (issue prioritisation, time allocations, etc)? How many hours/week do you estimate this will involve? I may be interested in helping out, depending on what it involves. I'm a professional (primarily) ruby developer, with ~2 years experience, and know all the main tools of the trade (github, rspec, etc.). However, the project looks dauntingly big - I hope the mentor isn't expected to understand the whole thing in depth, or that could take a long time!
&gt; if you don't find it useful, shrug, that is unfortunate I find discussions around the *implementations* of ensuring safety extremely useful. I guess the most valuable way I would interpret your data is: "How safe is each language, using idiomatic safety precautions and no tests?". (And unsurprisingly, dynamic languages are "less safe"!) But as you say: &gt; [Asking "how likely is it that an X error will happen?"] would be epic data to have, but I have no idea how to measure that! ...and I don't have a great answer here either, sorry :( I guess the best you could do is maybe some sort of analysis on the frequency of errors encountered in several "production" applications -- i.e. How often do these "bugs" pop up in real world code that's supposedly been reviewed and tested? But this still leaves you with 2 problems: 1. How the heck would you get this data? (No idea!) 2. How "critical" are the systems you're analysing? E.g. an uncaught exception in a web application is much less important than one in a nuclear weapon device!
Congrats on getting it working. Weve actually rewritten small projects because a sudden requirement change was "host on windows" and the incompatibilities are that painful. I love ruby, but between the base ruby and the community packages, ruby on windows is just too sketchy for my liking.
It's not ruby. Ruby itself works fine on windows (except for some minor issues). The problem are C extensions (because it's C, it won't work on both systems without heavy changes) and the fact that a lot of tools depend on UNIX-only solutions (e.g. Redis) or functions (e.g. fork).
Find someone in your area and volunteer. Its much easier to find groups IRL.
Does anyone know of a resource similar to this but covering testing of a rails-api app? 
&gt; I will add that in this particular case, it would be helpful if you had some idea of the goals. Do you use visualization software in your job, day to day? How familiar are you with Gnuplot, Matplotlib, other plotting tools? My day job does not, unfortunately, involve any data visualisation stuff. However, I have a degree in maths and as such did some work in MatLab, as well as playing around with things like Wolfram Alpha's graphical tools. I've also played around with various other visualisation frameworks -- [here is an (unfinished) project](https://rawgit.com/tom-lord/eurovision_map/9b356923da595bbd64c2df9053804b63549c1487/eurovision_map.html) I wrote that shows an interactive map of the Eurovision song contest voting results. (The first and only thing I've written in jQuery, so the code probably does not conform to "best practices"!) It sounds like this won't take up too much of my time (or in other words, I wouldn't be disappointingly uninvolved), and as such I'd me more than happy to help :)
Thanks for sharing this. Does anyone have any examples of how to test an application when you're using a third party API to get data or carry out a function? Eg testing that a user can see their last 5 Twitter mentions when the Rails app has allowed them to connect via Twitter and has a page that should display this information.
This is very useful and helpful - I think it deserves at least one positive comment :-)
Instead of SecureRandom.uuid wouldn't it be better to do something like: idempotency_key: "stripe_transaction_#{transaction.id}"
New Zealand's tiny and incredibly free of bureaucracy (source: I'm a Kiwi who just moved to the UK). Lots of places - especially not-for-profits, which are probably the places that need volunteer programmers the most - are likely to be pretty approachable by email. [Forest &amp; Bird](http://forestandbird.org.nz/) (currently 503-ing) is one of the big wildlife-specific orgs that I'm aware of, but you might find luck helping out places like [Aotearoa 350](http://350.org.nz/) or [Generation Zero](http://www.generationzero.org/). Alternatively, your local Green Party MP probably doesn't have an amazing website. One other place you could look is the [Societies Office](http://www.societies.govt.nz/cms) webpage. You might be able to hunt through the list of incorporated societies and find something that suits your cause. (Although I've never used it for this - just for the presumably somewhat more mind-numbing process of actually maintaining and incorporated society.)
I brought everything up to the latest version. It's working great. No problem running my older projects with RVM.
If one transaction fails I will create a new one with a new ID. I am mapping transaction (in my db) with charges (stripes api).
Er, the block will never be called? even with this? def fun puts "hello" end x = 3 fun{ x += 1}
oh so the block gets called every time there is a yield statement?
Yes, unless you `yield` in your method or take the block as an argument and `call` it, it will never be executed. If you've never tried IRB, I suggest you check it out. It's really awesome for figuring out things like this.
Devise allows users to sign up to a website. What do you mean when you say you are trying to "sign up a new user"?
If you're running something like RVM then upgrading the system shouldn't effect it, as the system's Ruby version is independent. That's the point of RVM.
I'm on Yosemite and like it a lot. I've shared your pain though. Currently, I use Vagrant www.vagrantup.com to set up virtualboxes to do my development on and that has been a huge boon to keeping my physical machine's OS separate from my various development environments. It also allows me to do things like have different versions of Postgres installed and hop around very different infrastructures as needed.
Yosemite installer copies every file from /use/local individually. It can take hours without an SSD. Some people move that folder elsewhere, then move it back into place. You should be fine. Rbenv seems to be a little more forgiving than rvm.
I always install my system from scratch to avoid issues, takes a bit longer but I avoid obscure errors.
PROTIP - If you are using brew / rvm if you move /usr/local out of the way before you do major upgrades, then move it back after your upgrade can be as much as 3 hours shorter.
From what it sounds like I was once in the same boat as you. If figured this part out, but slowly realized I needed more functionality. I ended up having to go further and create a CRUD controller to handle devise so I could: add custom fields, list all users, edit them and create an admin namespace. Below I tried to piece together only what you asked for. But like I said I did a few other things so I might be missing a part. If it doesn't work let me know and I can give you more info... What you need to do is override the Devise::RegistrationsController * Create a new controller - registrations_controller.rb # registrations_controller.rb # Overrides default Devise::RegistrationsController to allow users to register users class RegistrationsController &lt; Devise::RegistrationsController # disable default no_authentication action skip_before_action :require_no_authentication, only: [:new, :create, :cancel] protected # The default sign_up method signs in new user upon creation # I just commented it out so you can see what the default method looks like def sign_up(resource_name, resource) # sign_in(resource_name, resource) end end 2. Then change the devise route to use the custom controller devise_for :admin, controllers: { registrations: "registrations" } Like I said I ended up having to take this further which you will most like find that you have to do as well. If you if more help Let me know and I can create a gist and explain in more detail what I had to do. Edit: Formatting
OK, I will try this. 
It will be easier to start with the local companies and if you are saying that there is less paperwork - the better for me. Thanks for the links and suggestions, I'll start to contact them directly. Also I tweeted couple Green Party MPs - I understood that Green party in NZ is actually green as opposed to some European countries :)
Why didn't you just fix the problem? RVM/rbenv aren't terribly complicated (although RVM can do some weird shit to your terminal env). 
Just give yourself a lot of time, I always do stuff like that on Friday afternoons so I have the weekend to fix it before work on Monday! Most errors are googleable.
I tried for an hour and gave up. 
Thank you for your very involved response. Just for beginners, I'm wanting to make a simple text environment, such as a MUD, though possibly just single person. Obviously I'd eventually like to do graphics of some kind, but on my last few tries, I wanted to do something fairly simple, that I knew how to do in C/C++, but couldn't figure out how to do. It turns out Ruby has a very simple command word to do that thing, that I just didn't know. But I feel like, even if you can't do something based on building simple bits, even if it has already been condensed for you, there's something wrong. To be specific, it was producing combinations of 3 elements out of 10 elements. This experience was really frustrating, and I haven't got around to trying Ruby again. This is kind of a repeated issue with me in studying programming. I don't know what things to try, and then some way or another, I hit an impassable roadblock, and can't bring myself to go on.
I provide commercial support for an NFP and I'd urge you to think long term about any volunteering you do. With surprising regularity, my paid work is put on hold because someone has contacted them, due to the type of work they do, and offered to volunteer. Volunteers typically last a few weeks, or at best a few months, before turning to focus on paid opportunities elsewhere. They say it won't happen, but it always does. At this point I inevitably walk into a mess, and because no one wants that volunteer's work to go to waste, I charge them for weeks on end of playing with ridiculous platforms like "PHP on Windows with a Microsoft Access backend", on a project I could have done in a day in Rails. The point being that unless you can offer long term support for whatever you create, you can be costing them more than saving them.
&gt; The issue is everything else that needs to change. We don't ship everything else. The tools we do ship have zero switching cost. If you wish to use a Ruby interpreter, you'd type `bundle exec ruby bin/foo.rb`, just as you would with other Ruby projects. If you choose to use other tools for deployment then you should include that command in your script, just as you would with other Ruby projects. Obviously you *could* instead choose to make that hard for yourself, just as you could with any product or service, but you don't honestly visit GitHub's site, for example, read "build software better, together", and say "that's all lies because *my* team is dysfunctional"! &gt; So yes, it's "zero switching cost", as long as your system is perfectly configured for it. An ordinary system using standard tools is what you've just described as "impossibly strict" and "perfectly configured". Ya got any more straw men? 
&gt; I cannot make a pull request to your code!! We are not interested in receiving pull requests from you. 
TIMTOWTDIBSCINABTE I really don't see the point in adding aliases for the sake of it... If you're aliasing something like `build` to `new`, then it makes sense. But aliasing `_` to `expect`?! That just seems pointless and confusing to me!
You could always, you know, run the code and see what happens?
From the perspective of the method think of the block just as an anonymous function. Since it does not have a name there needs to be some way to invoke it and that is "yield". You can even pass arguments to the block by providing an argument list to "yield": yield(1) yield 2 yield 3, 4, 5 If you need to store the block or pass it on to another method then the ampersand notation comes handy: def f(x, y, z, &amp;b) @attribute = b # store it g(&amp;b) # pass it on @attribute.call # later call it end *Note: I mixed idioms that you typically would not mix in a single method.* This is frequently done if your object is some kind of collection of items and has an Enumerable member: def each(&amp;b) @enum.each(&amp;b) # @enum could be an Array self # conventionally each returns self end Hope that helps. As /u/jabbaroni and /u/tomthecool suggested, try a few things out in IRB or with a small script.
 def fun1 puts "hello 1" end x = 3 fun1{ x += 1} puts x def fun2 puts "hello 2" yield end x = 3 fun2{ x += 1} puts x Run these :)
Just a thought, you could create a yaml file to store all of the text in and meet the ruby footprint small.
Hmm... I just tried this out, and it didn't work for me. Then I checked how my vim behaves *without* adding anything to `.vimrc`, and found that the tags already link properly for me! So I must have already configured this somewhere, and changing `.vimrc` is giving me some weird conflict... Then, I realised: I'm using the [vim-ruby plugin](https://github.com/vim-ruby/vim-ruby)! I don't fully understand the source code, but [it looks like](https://github.com/vim-ruby/vim-ruby/blob/58d5306294738b55b3c1633fbb9bea6850796c62/syntax/ruby.vim#L202) all of this (and much more) is already being taken care of for me. Nevertheless, it's always good to learn something new about alternative system configuration :)
I'd look at adding some objects to your code. For example you might have an "Enemy" class something like this: class Enemy def initialize(name, max_health) @name = name @health = max_health end def damage(amount) @health -= amount end def dead? @health &lt;= 0 end end goblin = Enemy.new("Goblin", 10) goblin.damage(20) if goblin.dead? puts "RIP Goblin" end
Do you know about classes? If so perhaps create a Creature base class that the Player and Minion inherit from which has health and damage instance variables and an attack function like this class Creature attr_accessor :health, :damage def initialize(health, damage) @health, @damage = health, damage end def attack(minion) minion.health -= @damage end end Now you can make # Player has 4 health and does 3 damage Creature player(5, 3) Creature minionA(3, 2) # Player attacks the minion player.attack(minionA) 
ffs, how many of these do we need? Most of them have no use beyond a bit of academic amusement. **Less code does not necessarily mean better code**.
Per another post here, wouldn't you want some sort of parent class that Dog and Hero could inherent the do_damage method from to ensure consistency across all critters and make updating it easy?
If you haven't heard of it, ruby-warrior is a fun programming game you can play. It's open source, so you can look at how rbates has done the health, among other things.
When a method calls super, what method will be run? Sometimes it's difficult to know, particularly with a codebase that uses module inclusion to spread behavior among classes. With super_method you can get a method and inspect it to find out more about it. For example you can get a method's super_method and call source_location to view it's source. So it helps with debugging. In the example in the article, a method definition in one class is skipped. The example `child.public_method(:name).super_method.call` shows how to run a method from an ancestor while avoiding doing anything defined in the instance's immediate parent class. With that, you could skip over some implementation that you don't want.
Yes! Same for HP/mana. I just assumed that the OP might be new to Ruby/OO and didn't want to introduce any more concepts.
I'm still relatively new to programming--would you mind elaborating a bit further on the details of why?
Wow, this is so nostalgic for me. When I was first learning how to program, my first "big project" was a text based RPG written in C++. Even though the language is different, the code still looks kind of the same, and I can see the similarities in both projects. I'll address your combat system question a little bit lower, but want to talk a bit about some other things that it took me a while to figure out. 1. Take a look at your code and you'll notice that all of your different "rooms" are all represented entirely in code. It's easy to manage now, but imagine if you had 100 rooms! You would be nesting dozens of `switch/case` statements, and the code would become very long and hard to follow. I did the same thing. I would look into moving all of your "room" information into "flat files" (text files). Whenever you want to display a rooms description, simply open the correct file and read the description out. This way your code is a lot easier to follow, and all of the "content" is in the files. 2. Ruby is an Object Oriented language, and there are some really neat and powerful features you can make use of. For example, each room could be an "object", with attributes named "title" and "description". Then you can print a room name with `puts @room.title`, or the description with `@room.description`. This is a good way to update your current codebase to use objects without changing too much at the same time. 3. Let's take Object Oriented programming to the next level. Right now, you don't have any real representation of the current player. I'd recommend making a `Player` object, and you can have this object have attributes like `name`, `level`, and `health`. You can add methods to this object like `attack` (to start combat, which i'll touch upon next), or `look` to show the current room's description. 4. Combat! If you make some of the changes above, you'll notice that you have "objects" that represent everything in your game world. Then you can use any of the approaches others have given in this thread to facilitate combat. I know this is a lot to take in, and my answer isn't particularly the answer to the question you asked. Feel free to PM me and I can try and help out a bit more, give further explanation, or even start chatting over Google Hangouts if it will help. **Further Reading** * [Introduction to Ruby Classes/Objects/Variables](http://phrogz.net/programmingruby/tut_classes.html) * [Reading files in Ruby (StackOverflow)](http://stackoverflow.com/questions/5545068/what-are-all-the-common-ways-to-read-a-file-in-ruby)
Super helpful, thanks for explaining.
Appreciate all the detail--very helpful. So I get why modules make sense here--but depending on how you were structuring things, would it potentially make sense to have the demon damage immunity example inherit from some sort of optional immunity attribute that could be set in the parent class? That way demons, or trolls or w/e could inherit damage immunity anytime their object was instantiated with that optional attribute set. It seems like in this case, health variables would be traits of the object, whereas combat actions seem like clear candidates to separate out into the separate combat module. Or am I missing some cases that would make what I'm proposing a poor decision?
Thanks, I'll check the video! :-)
&gt; Would it potentially make sense to have the demon damage immunity example inherit from some sort of optional immunity attribute that could be set in the parent class? That way demons, or trolls or w/e could inherit damage immunity anytime their object was instantiated with that optional attribute set. Great question. You're right that this would work, and it seems like a fine solution at first. In fact, this is exactly what I'd expect 99% of junior developers to do, and even a lot of senior developers who should have learnt better by now! You should always try to avoid "optional behaviour" in base classes (or included modules). It works fine as a "quick fix", but as the code grows, you need to keep adding more and more boolean flags. There is a huge amount of [good material](https://www.youtube.com/watch?v=9lv2lBq6x4A) available for you to study this in more detail, but again let's just see what happens to our code base if you do this. Let's say we end up with lots of optional behaviour in the base class: `critical_hit` (slim chance of doing double damage), `swing_and_miss` (slim change of doing 0 damage), `immortal` (cannot be hit), `immune_weapons` (cannot be hurt by some types of weapon), `one_hit_ko` (slim chance of one-hit kill), `agile` (slim change of dodging attacks), `recoil` (some weapons have a slim chance of hurting the attacker)... you get the idea! Using inheritance, the code *works*, but gradually gets more and more messy: class Character def initialize(max_health, name: "unnamed", **options) @hp = max_health @name = name @options = options @immune_weapons = options[:immune_weapons] || [] end def attack(target, weapon) damage = rand(...) if @options[:swing_and_miss] # Maybe set damage = 0 ... target.do_damage(damage, weapon) weapon_recoil(weapon) return end if @options[:critical_hit] # Maybe set damage = max * 2 end if @options[:one_hit_ko] # set damage = Float::Infinity ??!?! end target.do_damage(damage, weapon) weapon_recoil(weapon) end def do_damage(damage, weapon) if @options[:immune] puts "Cannot be attacked!" elsif @immune_weapons.include? weapon.type puts "Immune to weapon type: #{weapon}" else if @options[:agile] # Maybe dodge... else # "Normal" do_damage end end end private def weapon_recoil(weapon) # ... end end Our `Character` class is growing out of control! Lots of `if` statements, duplicated code, `return` statements halfway through methods, ... Pretty soon it could be hundreds of lines long, and all sorts of confusing bugs start to appear. How do we **test** this code, when there are so many possible flow paths? How does someone new to the project read a 500-line `do_damage` method and understand what the heck is going on? Don't feel too bad if you end up with code like this as a new programmer - there are plenty of people on 3 times my salary that make this exact mistake! Often it starts out as an easy quick-fix to put a bit of conditional logic in there, but over time it grows out of control and becomes unmaintainable! This is where dependency injection comes in. Basically, the idea is to extract shared behaviour into *new objects*, and pass these into the class. These new objects can then be easily tested in isolation, and the code remains much easier to read. I'm not going to rewrite the whole thing, but here's the basic idea: class Giant &lt; Character # ... end class Human &lt; Character # ... end class BasicAttack def get_damage(character) # Some rand() thing do with character.min_damage and character.max_damage end end class ClumsyAttack def get_damage(character) # Some "might be zero" logic end end class Character def initialize(max_health, name: "unnamed", attack_type: BasicAttack.new) @hp = max_health @name = name @attack_type = attack_type end def attack(target, weapon) damage = @attack_type.get_damage(self) target.do_damage(damage) weapon_recoil(weapon) end def do_damage(damage, weapon) # ... end private def weapon_recoil(weapon) # ... end end tom = Human.new(100, name: "Tom") hagrid = Giant.new(150, name: "Hagrid", attack_type: ClumsyAttack.new) hagrid.attack tom Hopefully you can at least see that this approach makes the code WAY more maintainable! You could have clumsy humans, non-clumsy giants, you could even dynamically change an object's attack type. And adding new attack types does not pollute the existing code! You can also test each attack type separately, and even test a Character with a "mocked" `attack_type` class - i.e. test `Character#attack` method without knowing anything about the `attack_type` behaviour! This makes tracking down bugs a hundred times easier. Writing code like this can be a bit confusing at first, but - depending on the project - can be an absolute life saver further down the line.
Ok, so if I'm following correctly, dependency injection basically instantiates an object from one class (ie. BasicAttack) inside the class where you desire the injected behavior/attributions (ie. Character). Is that accurate? It's a little fuzzy and I'll need to study this a bit, but I think I get the general concept if what I stated above is accurate. So at what point does it make sense to start defining things like attacks, creatures etc. in a YAML file? I still haven't done much with them, but they seem like ways of listing out attributes and such that can later be consumed by my code and acted upon. Really appreciate all the detail you provided btw--definitely learning some things here. I wish I could find more Ruby tutorials that were along the theme of an RPG like this--for some reason it just makes it click so much easier.
&gt; Ok, so if I'm following correctly, dependency injection basically instantiates an object from one class (ie. BasicAttack) inside the class where you desire the injected behavior/attributions (ie. Character). Is that accurate? Yes, that's the idea. You're abstracting behaviour into *new objects*, which means each class is only responsible for one thing. ("Single Responsibility Principle".) It's a really simple, but powerful (and often confusing!) idea. [Here's another](https://www.youtube.com/watch?v=8bZh5LMaSmE) great talk on some of the topics I discussed above. &gt; at what point does it make sense to start defining things like attacks, creatures etc. in a YAML file YAML files are not for "writing code", they are for configuration. For example, one common use for them is defining a bunch of translations so that your program works in multiple languages without `if` statements all over the place or needing to have all translations saved in RAM. I'd actually be more inclined to use JSON here, so you could define an *array* of characters. But whatever - the implementation depends on how your game ends up evolving. (For example, perhaps you'd prefer to have each character config saved in *its own* YAML file, because the config is growing too big! E.g. I'd hate to have one huge file defining every property for all 151 pokemon!!!) You could use them, for example, for pre-defining a bunch of characters like this: # config/characters.json [ { class: Human, name: "Tom", max_health: 100 }, { class: Giant, name: "Hagrid", max_health: 150, attack_type: ClumsyAttack }, # ... ] There are lots of ways to do this, so it really depends on your game. Perhaps you'd want to define `stage_1` characters in one file, `stage_2` in another file, etc? Perhaps you'd want to group characters by class, i.e. have a `human.json`, `giant.json`, etc? Perhaps you'd rather stick with YAML, and could do something like use names for the top level keys: # config/characters.yaml Tom: class: Human max_health: 100 Hagrid: class: Giant max_health: 150 damage_type: ClumsyAttack If your character stores are getting big and complicated, and start to cause memory/performance issues, maybe you should consider compiling them into a [PStore](http://ruby-doc.org/stdlib-1.9.2/libdoc/pstore/rdoc/PStore.html)? Or maybe you could even implement a [database](https://github.com/sparklemotion/sqlite3-ruby) into the game (which would allow things like easily adding/editing characters through the UI). Have a look at similar projects to whatever it is you're making. See what they've used (and remember it might not be a good design choice!!) for inspiration. There's no one-size-fits-all approach to programming, and it's excellent that you're making the effort to learn new approaches :)
Personally, what I do is `require` external dependencies I haven't control, and `require_relative` files of my own. Something like this: # lib/my_gem.rb require "virtus" # external dependency require_relative "my_gem/settings" # my own file whose relative paths I control I don't mean this to be kind of "best" practice, but it makes some order to the chaos :)
Kiba (a declaration row-based processing DSL which helps you transform your data) is now available as a rubygem (v0.0.5), comes with proper documentation and is used in production by a couple of people already (in addition to me :P).
Great feedback, thanks! I'll probably just link to [this article](http://thibautbarrere.com/2015/04/05/how-to-write-solid-data-processing-code/) as the why. I'll update the readme, thanks!
This all makes tons of sense. But going back to your line about YAML being for configuration--does that mean a YAML file would be more appropriately suited towards booting up the game world and setting a configuration file for the world's starting state, with perhaps separate YAML files for various components? # config/world.yaml MainCity: population: 50 inns: 2 blacksmiths: 1 I guess the question you've sparked with me now is...would it make sense for characters to be initially configured with the YAML and what are the tradeoffs/benefits of using YAML vs. a DB or JSON array. I think at this point, if we're talking more about a real game, the DB makes a ton of sense if the game is going to store persistent state across playing sessions, although without digging into it yet, Pstore looks interesting. I have to say, you communicate all of this incredibly well for someone with my experience level. I've learned enough to date to be able to grok the concepts and the code, but your explanation of the nuances between them is exactly the sort of "intermediate" wisdom I've had trouble finding in tutorials. They usually just focus on "this is the best way" or "this is the way we do it" vs. the "well...you *could* do it this way, but here are the things you should be aware of." If you have a blog or anything you've written, would love to read it. If you don't, you should seriously consider it--or creating a screencast.
You have to run the program from a command prompt
Install Linux on a VM and learn why you should only develop on Windows if you hate yourself (or doing .NET stuff).
&gt; I am saying that 99% of "real world" projects have all sorts of odd configuration So you're saying "that's all lies because *my* configuration is dysfunctional" then? The tools we ship give you zero switching cost. If your configuration takes that away then your configuration is the problem. And just to be clear: I said you can switch *from* InfraRuby at zero cost, not that you can integrate an InfraRuby project into your configuration at zero cost. So, that understood, you can integrate an InfraRuby project into your configuration just as you would with other Ruby projects, because InfraRuby projects are also Ruby projects and follow the same conventions: a gemspec, a Gemfile, a lib/foo.rb file, and a Rakefile, just like other Ruby projects. You have a lot of options. For example, if you wish to execute the "foo-main" program with a Ruby interpreter, you could add `rake main` into your deployment script and also add that task into the Rakefile for the project, like this: task "main" =&gt; "program:foo-main" That task will invoke `bundle exec ruby bin/foo-main.rb` (assuming the Rakefile defines the "foo-main" program tasks). If you *further* wish to use the InfraRuby runtime, you could define that rake task depending on a flag, like this, for example: if USE_INFRARUBY_CORE task "main" =&gt; "program:foo-main:core:execute" else task "main" =&gt; "program:foo-main" end You could set that flag in the Rakefile directly or indirectly, through a configuration file or through the environment, or in some other way. And this is what you call "impossibly strict" and "perfectly configured"! &gt; It's not a straw man argument at all. Once again: I said you can switch *from* InfraRuby at zero cost, not that you can integrate an InfraRuby project into your configuration at zero cost. I hope you kept the receipts for all those straw men! 
Is this what you are using? http://railsinstaller.org/en If it's freezing then your computer has something wrong with it most likely. The general comments here for use *nix are correct, with Windows you will just generally encounter more pain as a someone starting out in Ruby, and I don't know of any professional Ruby developer that would work on Windows. 
&gt; So you're saying "that's all lies because my configuration is dysfunctional" then? &gt; The tools we ship give you zero switching cost. If your configuration takes that away then your configuration is the problem. I'm saying that 99% of real world projects are, as you call it, "dysfunctional". Have you actually witnessed anybody in another company implement your "zero cost switch" in a large project?
There are a few [installation tutorials for Windows](https://www.youtube.com/results?search_query=ruby+install+windows) on youtube. Maybe they'll help you to install it properly. If the Ruby installer added the Ruby bin directory to your PATH environment variable, you should be able to execute ruby.exe or irb.exe from the command line (cmd.exe). 
It actually runs really well in Wine on Linux if you're wondering. 
Why do you think `require_relative` ought to be avoided? I use it all the time, and don't experience any pain.
Something that wasn't completely obvious from the readme, but how might you join two sources with a "merge" step? 
May I suggest a cloud development environment to get you started? https://c9.io/
As a rubyist who works in data warehousing this looks very exciting, thank you!
This looks like a really cool way to get started.
I'll be sharing more ETL, but also at some point data warehousing demos on the [blog](http://thibautbarrere.com/), make sure to subscribe. Glad you find Kiba useful :-)
Oh I see so you want to keep the first file, but based on one key, lookup rows in the other file, and merge accordingly into rows with all the resulting columns. You'd do it like this: source MyCsvSource, 'first_file.csv' transform MyMergingLookup, 'second_file.csv', 'the_key' Then you'd implement MyMergingLookup based on your needs (eg: differently if you have 1M rows or 50 rows in your second file). Here is how I implemented a naive lookup for one column: https://gist.github.com/thbar/dd2d206984e3f68f5130 This can be a starting point to achieve a whole-row lookup instead (let me know if you need help, I'm offline to bring the kids at school but can expand later today). This one is in-memory, but for larger set you could totally load the look-up table in redis, a database, or similar...
Indeed currently this is not possible (and this is something which was possible in activewarehouse-etl before, though). I am currently thinking about how to properly bring this feature back, because indeed it's very useful (and something I've been using a couple of times too). I create an issue to track that down, please subscribe [here](https://github.com/thbar/kiba/issues/4). 
Anyone who uses Ruby to build an actual game can handle running Linux on a VM
&gt; I'm saying that 99% of real world projects are, as you call it, "dysfunctional". Have you actually witnessed 99% of real world projects? &gt; Have you actually witnessed anybody in another company implement your "zero cost switch" in a large project? You are trying to set up that straw man again! We make claims about the tools we ship, not about the state of your configuration, obviously. Do you really not understand that? 
&gt; Have you actually witnessed 99% of real world projects? Lol... Now who's using a strawman? ;) I have seen lots of real world projects. I can confidently say that (almost?) all of them would be very non-trivial to switch ruby interpreter for. (Yes, it would be trivial in *your own dev environment*. But not so simple across the entire network.) &gt; We make claims about the tools we ship, not about the state of your configuration, obviously. The claims you make are unrealistic. They are only true under "lab conditions". My question was not a straw man argument, I am asking whether you have actually put your "zero cost switch" claim to test in the real world, and seen if it holds water. It's like saying "this car will cost £0 to fix in its MOT for the first 10 years .... ^^as ^^long ^^as ^^you ^^never ^^drive ^^it ". Your statement is true, but has a *huge* hidden clause.
You really should put at least a condensed explanation or at least an expanded abbreviation and/or link to the explanation in the github readme. 
Those seem like valid reasons for you to prefer `require` over `require_relative`. However, they aren't compelling enough to convince me that there ought to be any "best practice" in play here. I haven't felt any pain splitting projects that use `require_relative` even liberally. I still tend to follow ruby load path conventions when I use it, however. I mean, if you use `require_relative` to target any random path, you ought to know at the outset what you're getting yourself into. Your preference is valid, my experience just doesn't justify meriting it with an absolute. IIRC, `require_relative` *is* more performant, since it never has to scan load paths. In projects with tons of gems, additional gems seem to slow down *each and every* require in *every gem*. I could be wrong (or that problem could be outdated). Either way, cheers!
Thanks nwallins. You mentioned I should always pack my code into a Gem. I didn't pack my current project in a gem structure, because I don't plan it to be a Gem (it's automation layer based on Cucumber directory structure). It means I won't be adding `lib` to my `LOAD_PATH`, but will have to add multiple directories instead. Is this OK? or I should pack it anyhow in a gem folder structure just so I can easily include just the `lib` directory?
Linux is definitely worth learning and some of the ways to work with it on vms are pretty good. Vagrant, like a bunch of other people mentioned, is a great choice. An alternative route that would help you learn a lot about computers is to dual boot your computer. Linux doesn't take up much space so it wouldn't have to be a big partition. There are quite a few good tutorials online. If you're going to go this route make sure that you don't let grub overwrite the mbr (master boot loader). I know this is a more drastic option, but it might be worth your time if you're getting into coding seriously. Also fwiw, I've been using ruby on my Windows partition for a couple of months with no problems.
If you're following ruby load path conventions, why do you prefer require_relative over just require? I think you are missing my point about splitting between projects. Let's say you have a project, and a file A in that project needs to require a second file B, and it does it with `require_relative '../../something/b.rb'`. If later you move B to another gem, but leave A where it was, you will obviously have to change that `require_relative.` In fact, you'll have to change it to a straight `require`, it doesn't make sense to use `require_relative` to go from one project to an external gem. If you had used load paths and straight `require` from the start, you would not need to edit the source code in A at all when you remove B to another gem. Using standard load paths and `require` works whether you are requiring a file from the same project or a gem dependency, it can be agnostic towards this, which `require_relative` can not be. One you are using gems, you need to use `require` for source from a gem dependency, so to me it makes sense to just use it consistently everywhere. Why not? My understanding of the phrase "best practice" is that it's indeed not absolute, a best practice is not absolute, it's just a guideline for when you don't have a reason to do things differently. I am not sure I understand your reasons for preferring `require_relative` -- performance? But sure, if you have reasons to prefer to do things differently that work for you, no "best practice" can force you to do otherwise. 
Yes, that's a fine way to edit the load path. If you are a gem, you don't need to do that manually at all, rubygems takes care of it for you. I'm not sure what you mean by " is a Gem file structure (with lib folder) is always the preferred way?" As opposed to what? If you are writing a gem, then a gem file structure is what you're going to have, right? If it's not a gem, using a `lib` folder is still probably a good convention, but if you have a reason to prefer something else, you can do something else. 
Cucumber need the following directory structure to work: |-features |--- step_definition |--- support The only things my project does, is to run cucumber tests. My options are: 1. To follow the gem standard directory structure (with `lib` folder) and put the `feature` folder into my `lib` folder 2. Add 'features' and an extra folder to my `LOAD_PATH` variable. Technically, my project is not a 'gem'. Should I still follow the structure of a gem? (`lib` folder, file named about the gem/project that include it etc) 
I would probably stick to the conventional structure of cucumber . I'm not familiar with cucumber myself. You can add `features` to your load path, but that won't actually work. If a class is called Foo::Bar, then to `require 'foo/bar'`, the class needs to be on `${some_load_path_dir}/foo/bar.rb`. But you have intervening step_definitions support. You could possibly add features/step_definitions to the load path, depending on how things are organized in there. But doesn't cucumber generally load everything in step_definitions for you? I think you probably want to figure out how cucumber works, and how to tell cucumber where your step definitions are. Cucumber probably already has features for dealing wtih this, which may or may not manipulate the LOAD_PATH for you behind the scenes. Rather than fighting with cucumber, do what cucumber wants. I didn't know you were talking about Cucumber here until now. I am not very familiar with Cucumber. i'd try asking someone very familiar with cucumber the right way to do what you want -- are you trying to supply step definitions from a gem? If your step definitions are just in your project, do you need to do anything special at all, can't you just run cucumber as normal and it will find them? If it's not, I'd ask for tips from someone that knows cucumber. Sounds like you have a cucumber question, not a generic "how should I structure my ruby project" question. 
I did .net until I switched to Ruby maybe 8 years ago or so. MS IDE is gorgeous - switching to Vim is going to be kind of brutal. No idea about running this on windows - I can't imagine it'd be a great experience but two guys at work do this (through putty I think). If you're going to be doing Ruby for work - I'd strongly advise getting a Mac. We use vim at work and I've been vim'ing for 3 years now. It grows on you but there aren't many bells and whistles. Debugging: binding.pry is probably the easiest way to debug a Rails app. http://pryrepl.org/ Code Complete: There are a few plugins but they're mostly meh. Code completion on a duck typed language is hard. Running specs: command line is the easiest way imo - although there are plugins to do this from vim. Our guy Shane at work has a sweet vim setup that most of us use. Checkout his dot or .vim repos... pretty gorgeous vim. https://github.com/sds
If I couldn't I would have gone with Mac (or even better, Linux), but sadly everything around here is Microsoft oriented (active directory), so it must be Windows. Debugging: I don't code a Rails app, but I guess binding.pry can work for strict ruby. I'll have a look on it. Code Complete: Something basic would do. If my Method has a local variable, I would love to be able to autocomplete it. Running Spec/Cucumber - Commandline will not let me debug those tests. Is it possible to debug it using pry? I'll check the Vim Setup you linked, thank you very much wiseleyb :-) 
I'd been using vim for Ruby / Rails development for several years, but recently I discovered [spacemacs](https://github.com/syl20bnr/spacemacs) and probably won't be going back. Vim provides great control over your text editing and I'm addicted to Vim keybindings, but tbh the rest of the ecosystem is fiddly and brittle. I had a pretty extensive set of plugins that required updating and sometimes would stop working for reasons I rarely had time to dig into. Spacemacs takes everything I love about vim and provides all the tooling to meet my requirements beyond editing. That said, Rubymine is pretty sweet - the Vim keybindings plugin is *very* good so I'd try using the Vim plugin with Rubymine before switching. At the last Railsconf I saw one of the core Rails developers (Xavier Noria) using and advocating for Rubymine so there are definitely 'power users' on Rubymine. Also, debugging etc on Windows is just going to suck. Your best bet to have a fully supported Ruby ecosysystem is to take the hit and run virtualization (e.g. virtualbox) to get a Linux enviroment.
Yes, I didn't come with too much expectations. But I'm interesting to know how people around code in Ruby. Code completion is luxury, but some tasks like debugging are required. If Vim is only used as editor, everything else is done by external tools?
I use atom for editing, binding.pry for debugging (pry-byebug) and the terminal for running specs.
Thanks, I was just testing out the Vim plugin for RubyMine. Sadly spaceemacs does not support windows :-( But I'll play around with it, maybe there is an easy way to make it work. Thanks!
I wasn't aware of Atom - Cool, I will check it out :-) Are you able to run spec from the command line AND debug them using binding.pry?
If your workflow demands those features, I would use RubyMine or some IDE. You can get something working with Vim that will come close, but those things will feel clunky in comparison to what you might get with an IDE. I've tried Eclim, and the code complete features were nice, but there still was not good debugger support. Look into using Guard for auto-running tests/cucumber feature files.
yup. you just put binding.pry in the source file whenever you want your breakpoint to be. binding.pry works in the rails console, as well as when running the server. :-)
i'm not sure who told you vim is 'official' development env for ruby - i'm sure majority of newcomers are staring with tools like sublime text or textmate and only few are hardcore(not a second outside it) vim users. oh and there is also emacs and you can be pretty sure number of emacsers is similar to number of vimers and both camps will religiously defend their tool. so imo - sublime text if you're just starting out, vim/emacs for quick editing without getting out of console. if you ever get to hardcore level, vim/emacs can be just as productive as any other IDE but what's great about them is you are not attached to your machine - with same success you can be running vim/emacs via ssh on a remote machine and never care about losing your ability to develop when something happens to your laptop.
I got it up and running on Windows fairly easily. Spaceemacs that is. Problem was settings not sticking, and I didn't have a whole lot of time to mess around with it at the time. But it is certainly possible to get running, and without too much of a hassle. Hopefully you'll have better luck than me with the settings. :)
I use Atom and I love it. Multiple cursors, git line status, autocompletion, jumpy, rubocop linter, so many many more extensions. But its a bit on the bleeding edge and ain't the fastest thing. If you like a solid experience, try out SublimeText. Both with Atom and Sublime you will give you a closer to IDE experience, though they are editors. And I would say stick with those for the long haul. Ruby is wonderful in that it gets better the deeper you go. Wizards and GUIs kinda kill that learning, imo.
What he/she said(probably he tbh)
This is really cool. Great series; keep 'em coming.
Yes, I'm aware about Cygwin. It might work, I'll give it a try, Thanks!
Will give it a try, thank you!
You are currently driving a Ferrari and are looking to replace it with a Gremlin. You're going to spend weeks and months familiarizing yourself with Vi/m just to get to the point that you are already at with Rubymine JUST to get work done.
So in you own opinion, does it WORTH spending that extra time to learn Vim? or it's something left from the old school days and today is just not worth to dig into?
&gt; Excellent. That's what I was looking for. As a 'Vim user' - would you suggested someone to dive into Vim? is the worth the same? By the way, regarding the 'official' dev platform, it's something I hear and read about in many sources. For example: Well, I keep hearing love about Vim everyone. Forum posts, articles etc. For example: http://www.sitepoint.com/editor-rubyists-use/ If you like the terminal more than GUI's, and the keyboard more than the mouse, I would suggest to give Gvim a chance. For me, I was really captivated by the notion of not having to move my hand as much. However I was comfortable with it after I really started using it daily, it probably took me around 2 years to really feel super comfortable. That is a lot, but also had a lot of time available. I wasn't in school and in a not very demanding job where I would log into different servers and edit stuff with vim. Yeah, I think it's the de facto tool that not only Ruby users use, but a lot of programmers too. I think the plugins some people have developed really add a lot to the value. There's also the added win that if you use what most people are using, you can learn how they do certain things. things that helped me along the way were cheat sheets, the help sections, vimtutor and a mentor so I can figure out how to call things.
Yes, everything else is done outside of vim. Testing, debugging, running code, etc. If you have to use pure vim, definitely check out CTAGS. It's a decent replacement for Rubymine's CMD-Click follow through function.
Is it comparable to Fugitive.vim though?
You force your devs to use rubymine?
You're not a "real programmer" for blindly bashing someone's choice either with laughable "arguments". Productive programmers are defined by their knowledge, ability to ask questions and seek answers, persistence, drive to learn and so on. Editor/IDE choice has nothing to do with it, it is not a defining nor a common trait. Get over it.
For everything else, there is the terminal.
This is slick. 
Personally I use it to show intent. Also protected, private are slightly different in the context of inheritance. Everything is permissible in Ruby, so the best practice is to ask yourself, just because it is, should I do it?
Thanks! Yeah, it's a good way to do readers and writers in ruby, but the fact that we both decided upon _having_ an abstract reader and writer interface, implemented via objects like this -- I think points to the fact that we both worked on previous ETL projects that didn't turn out quite right, and both learned the same thing from our experience. :) Another thing we do in traject is have some properties which can be set on the command line OR in the configuration file, with command-line settings overwriting configuration file. 
Your solution, while concise, is VERY obtuse to someone new to ~~Ruby~~ Programming. Especially the `words.max_by(&amp;:length)` version. If someone is just starting to get their head around iterators, these shortened versions can look like black magic. It's like making someone do arithmetic by hand before letting them use a calculator. Yeah, you'll never do it 'for real', but it's important to understand what you're simplifying before you simplify it. 
I used Vim exclusivly for almost 3 years before trying RubyMine with the vim-plugin, but switched back after about 3 months because the plugin is just not good enough.
In what ways specifically?
Yes, I think I'll use private when possible too. As you mentioned, it a clear message about how the class works. Thanks!
Use what you're most comfortable and productive with. But having a basic understanding of vim is a good idea for those cases when a terminal is all you have available. I'm an IDE guy and I love Rubymine. There are too many benefits that I get from that environment, from code completion, finding method usage, jumping directly to a method definition, visual diffs integrated with source control, visual debugging, etc., that I can't see how I could ever be that productive using just a shell/VIM environment. However, I'm proficient enough with vim that I can use it if it's all I have available. Basically if you know how to open lines, find, yank, paste, and save and you'll have enough in a pinch when you're editing a crontab or config file.
The most primary reason for packaging (Ruby, etc.) software is to enable it to run, hassle-free, on machines other than the one the software was developed upon. The primary features that packaging manages for you: * Dependencies * PATH * LOAD_PATH You need these features. You can try to hand-roll them yourself, or you can rely on standard package management tooling. There is an initial investment to be made, in terms of learning the package tooling and structure, but it pays off when the number of non-local execution environments scales beyond, say N=2. Also note that you can build packages and distribute them on your own, *without* publicly releasing them on http://rubygems.org/
According to the annual Ruby survey, 37.9% of developers use Vim, and 4.5% use Emacs: http://www.askr.me/ruby So while Vim is in no way 'official', it is used much more than Emacs.
I'm not sure this can work on my scenario. I have a Cucucmber project (web automation). In order to run any of the automation tests, I have to use the Cucumber command line executable. The Cucumber executable is looking for specific folders and files in order to initiate the run. I guess I can 'wrap' what Cucumber executable, so people just add my gem, and call those 'warped' cucumber calls , but this seems to be a bit of a hassle? 
I'm not sure this can work on my scenario. I have a Cucucmber project (web automation). In order to run any of the automation tests, I have to use the Cucumber command line executable. The Cucumber executable is looking for specific folders and files in order to initiate the run. I guess I can 'wrap' what Cucumber executable, so people just add my gem, and call those 'warped' cucumber calls , but this seems to be a bit of a hassle?
Dunno about Cucumber integration. Perhaps this is one of those cases where `require_relative` is absolutely the right way to go.
I use Rubymine for some projects but I've never found the git integration to be all that useful. The 'git blame' in the gutter thing is nice but I've never found a use for anything else. 
&gt; MS IDE is gorgeous Sorry, what's up with that meme? I hear it over and over, and it's the most hideous thing I have ever seen, and slow and bloated even on decent hardware. My aesthetic must be all screwed up I guess. I see beauty in small and simple things. Visual Studio just could not fit its giant a** into that category.
So I can move the whole folder to a temp location so that during the upgrade usr/local does not exist? 
We have a profile for Cucumber that drops you into a pry debug session whenever there's an error.
But you're saying if they wanted to learn vim instead you wouldn't let them do it in company hours?
Well, that's unfortunate. I get why the RubyGems team wants to reduce their support load, so no gripes there. But I've had issues in the past where yanked gems have halted deploys, messed up CI, and create confusion in a team because some gem author decided we shouldn't be using that particular version any longer. In those cases, at least the gem was retrievable. Of course, running your own gem server is the best way around this problem. But I've yet to meet anyone doing this (selection bias for sure).
Why not develop on a Linux VM?
If the yanked gem is preventing your deploys and causing failures on your CI that is probably a good thing. Yanked gems are sometimes removed for very serious reasons (major security flaws, etc.) and if your project is using one you should probably address immediately by upgrading / downgrading.
Yeah - you can absolutely debug with pry when you run your specs - super, super useful. 
Frankly, if this is a concern, you should be mirroring your needed gems locally. Don't have CI and production depend on https://rubygems.org/
A little late to this party but these links might help you: * https://gist.github.com/polarblau/5817541 * http://stackoverflow.com/questions/3839167/is-there-a-way-to-set-up-simple-http-authentication-for-an-app-on-heroku
That's the conclusion I came to a while ago. I'm happy there's a solution. I just think it's unfortunate that published artifacts can become unpublished. I'm sure it happens in other environments, but I can't recall ever encountering something removed from maven central (other than snapshots), CPAN, PyPi, CRAN, or others. For better or worse, people carry those expectations over and so the prevailing wisdom of running your own gem server doesn't really surface until you've been burned. Compounding the issue, it's not readily clear that a gem has been yanked and that's why installation has failed. I've had to explain this to several people at the local user group. At least with the new change, both Bundler and gem will be consistent in their inability to install the gem.
Here 'ya go, in plain 'ol ruby, using the fabulous `Array#product` method :) [1] pry(main)&gt; (1..3).to_a.product (4..6).to_a =&gt; [[1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]] BTW, regarding: &gt; True array comprehension will respect laziness and support filtering operations. It seems like there's no way to make `Array#product` return an enumerable, so no laziness AFAICT. Hope someone else can chime in on that...
Ah.. I missed the `#product` method. I knew ruby had to have a method for that. :-)
Will give it a try then, thank you :)
If you do end up wanting to learn vim and want to get to some of its most useful features quickly and without digging through six different guides, I can recommend Practical Vim: Edit Text at the Speed of Thought by Drew Neil: https://pragprog.com/book/dnvim/practical-vim I'd been using vim for more than 10 years, then I found that book and noticed that I hadn't even discovered some of the most powerful parts of the editor. Also, with today's plugin managers for vim, extending vim's functionality to shape it to something you like has become much easier. With IDEs you immediately get a whole pile of features to learn, with vim you get the basics and then shape it to your style of working in the years to come.
&gt; Of course, running your own gem server is the best way around this problem. But I've yet to meet anyone doing this (selection bias for sure). My previous company did this, because development was (painfully) all done on an airgapped network. [Gem in a Box](https://github.com/geminabox/geminabox) was what we used to use.
&gt; Is this even possible? or should I just buy RubyMine? Thanks! Buy it, it is a good investment. I use vim and Rubymine, I tend to spend about 80% of my time in RM and coming from a C# background it is nice to have a good IDE. There is a lot of hype about vim and a lot of it is well deserved, but to be really good at it you should be prepared to spend quit a bit of time learning it. The code completion and insight, refactoring, ruby/rails commands like bundle, etc etc is all there in RM. 
*My hopefully constructive criticism....* Some of your techniques seem really sketchy to me... For example: # Original: def foo if bar # ... (1) else # .... (2) end end # After refactoring: def foo send("foo_if_#{bar}") end private def foo_if_true # ...(1) end def foo_if_false # ...(2) end I don't see how this is any better... In fact, I'd say it's worse! Sure, you've split up the code into shorter methods and deleted the evil `if` statement, but is this actually a good pattern to use? Is it easier to test? Not really, because you should still be testing the `foo` function directly, and stubbing out the value of `bar`. Is the pattern easier to maintain? Not really, it doesn't make the code any simpler... In fact, the pattern is fundamentally flawed! All you've really done is *hide* the `if` statement, not remove it. Suppose the code is one day expanded to: def foo send("foo_if_bar_#{bar}") send("foo_if_baz_#{baz}") end private def foo_if_bar_true # ...(1) end def foo_if_bar_false # ...(2) end def foo_if_baz_true # ...(3) end def foo_if_baz_false # ...(4) end Notice how I had to include `bar` and `baz` into the method names, in order to make them unique! The new method names make it obvious that the `if` is really still there, only hidden. Also, I really don't like your excessive use of inheritance. *Wide* inheritance for such minimal changes in behaviour is IMO a very poor design. The theory of what you're trying to achieve is perfectly good, but it's not an appropriate tool to be using in the example of this video. Lastly, why are your tests just a bunch of `puts` statements? It would be much easier to see if tests were passing if you used `rspec`/similar!
I'll check this book out, thanks :)
For those new to Ruby gem building who want to dip in before spending anything, there's a great free guide here: http://guides.rubygems.org/make-your-own-gem/
I wonder if that ends up being about "separation of concerns". And of course "cohesion", although I admit the "cohesion" concept is one I haven't totally gotten a handle on. When the component has a clear, well-defined, **and simple** API, then it is unlikely to have to change in breaking ways, and if it does have to change in ways that will break clients/dependents, the changes will be small, manageable, and understandable, it will be clear what you need to change and easy to change it. What gives something a clear and simple API is usually clear "separation of concerns" -- the dependents don't have to know very much at all about the dependency, what they do have to know is limited to... well, exactly only what they have to know to interface with what the component does. Is kept as minimal as possible. Which is what 'separation of concerns' is basically about? A lot of it really is about interface/API, and "abstraction" in it's old best CS sense -- well-designed abstraction means a dependent doesn't need to know about the internal implementation of it's dependency, can treat it as a 'black box' only needing to know the 'interface', which is ideally clear, simple, and parsimonious. And it's exactly that (and only that?) that results in low fragility (and I don't know if there's a better term than fragility for... fragility). This all holds whether the dependency/dependent relationship is a superclass/subclass; a component and the software users of that component; or even an HTTP api and the clients of that api; or probably anything else that's two software components where one depends on another -- one accesses or depends upon the functionality or services of another. 
@brandonhilkert, hi! Will there be more examples in the book? (are you going to work on the book and on actualizing it?) I'm rather new to Ruby and would like to see more real examples step by step.
FYI: The awesome-events repo collects Ruby events (meetups, conferences, camps, etc.) from around the world. I’m from Austria, thus, I’ve started w/ Central Europe. New events, meetup, camps, conferences, and more welcome. Cheers.
How was a yanked gem retrievable, previous to this change? It halted your deploy/messed up your CI becuase it was _not_ retrievable, right? Was there an alternate method of retrieving yanked gems? I understand you found the previous situation unsatisfactory too, I'm just trying to understand how things used to work and how they are changing. I thought yanked gems were already not retrievable? 
Seems like this post should be titled "*Enumerable* is one of the workhorses of Ruby. "
I think the idea of connascence is helpful here also; see [Gregory Brown's post from 2011](http://blog.rubybestpractices.com/posts/gregory/056-issue-24-connascence.html). I'm still absorbing that idea and trying to figure out the tension between classic OO, where object instances get passed around all over the place, and "type to name" connascence reductions, which I think would result in less of that and more passing around of built-in types.
You've got a lot of replies, and they're all really good. I do have a small feeling it's not what you were asking though. To assign a variable, you've actually already done it some in your code in a few places. So, if you wanted a solution more in line with what you've already written, it's just &gt; goblin_health = 20 to give your goblin 20 health points. The other answers though, do lead into some things that you should learn and will make things much easier in the long run, for example in this case, as someone else points out, everything is entirely represented by code and is very linear. They are all really great replies. If you're interested, I often do pairing (coding while letting other people be connected to my machine) and would be happy to code through some of this with you at some point in time. :) The easiest set-up is if you're familiar with linux and know how to use SSH, but, there's many different ways I can set this up if you do want to give it a shot. 
So if we depend on a gem and someone yanks it, the gem is unavailable, source is gone, and nothing can be done about it? This doesn't really seem to fix anything, it moves the problem.
Hm, I'm not familiar with 'connascence.' But in general, over-use of primitive types instead of targetted 'custom' classes, I've frequently seen suggested as the way to bad design rather than good concise design. This viewpoint seems especially popular from the Smalltalk world, and I tend to consider the old school Smalltalkers to be good sources for good OO design. 