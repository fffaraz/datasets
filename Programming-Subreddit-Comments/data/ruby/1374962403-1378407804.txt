Be an active contributor to Open Source projects. Having a long list of languages and buzzwords on your CV won't help if your GitHub profile is empty.
You will very definitely need some Javascript skills - mostly because Rails is a web thing, and web uses Javascript, but also many other things like MongoDB use Javascript. Getting decent at HTML/CSS stuff while at it won't hurt. Getting comfortable with languages used by popular databases - SQL (mysql, postgresql) and Javascript again (mongo) - is another essential thing to do. Some people mentioned deployment stuff, but there's massive diversity of deployment setups, and they have relatively little in common. Getting some experience with AWS is definitely going to be helpful, but it's relatively difficult to learn that on your own. For other languages and technologies you won't really get that much complementarity. And whatever else, learn to regexp.
How about Scrum, Kanban, test driven development, behavior driven development, and cost/time estimation? It is always helpful to have a developer that knows the management side of a project.
I would recommend avoiding coffee script if you're not already proficient at js, and I agree that node.js would be a great compliment to your rails learnings. The two frameworks are very different and node does things rails cannot (and vice versa).
Contribute to open source projects, or work on side projects and put them on GitHub. Spruce up your StackOverflow account. Listing languages/technologies on your CV only get you so far...
Opinions on getting familiar with something like docker? https://www.youtube.com/watch?v=wW9CAH9nSLs Also, pretty crazy how varnish has such a nice understandable website, while nginx is so horrific in comparison.
Can I ask your reasons for avoiding CS? 
Isn't really a 'few' lines of code judging from the github but it's an interesting little game.
not bad
I think he's referring to the lines of code you're made to type in
This is really fun!! Level three was awesome
Thanks for the site. I've got kidsruby downloaded for my daughter, but this will help a bunch.
Wow, awesome adaptation of the gem to the web!
Auto audio warning.
I am not able to clear level 4. Need some help!
You need to keep moving forward if you're being attacked. How can you tell you're being attacked? The hint about saving your `@health` variable should be exploited.
I somehow got it into an inconsistent state. Now `warrior.walk!` does some random action like walking backwards or resting and resting my health to 0. It's still pretty cool though.
I came from ruby myself and if i were you I would just learn obj-c. The language is actually a joy to work with once you get to know it a little and pretty similar to ruby in many ways. You'll find out that most of the time is spent learning the frameworks rather than the language and those were almost all written with obj-c in mind.
I see. Do you have any websites you recommend in particular? Maybe www.otierney.net/objective-c.html and www.cocoadevcentral.com/d/learn_objectivec/
RubyMotion has an EULA that seems to make it unusable for most purposes. http://www.rubymotion.com/eula/ 
Apple's getting started guide is quite good and I've heard good things about the big nerd ranch books. Personally I learn best by just starting to build things though. Once you're a bit more experienced I would highly recommend subscribing to nshipster.com Edit: those two resources you linked to seem pretty outdated, it's a good thing to know how the retain/release cycle works and suchs, but you should use ARC.
Okay, sounds good. I'll get started with Objective-C, then.
Do you have specific examples of this?
i've used obj-c a fair amount and it certainly is not a joy to work with. Not only is the code verbose and ugly but it's an utter pain just doing simple refactors, you often have to update both the header files as well as the implementation file. Have you actually gone the ruby motion route? i think unless you have actually tried BOTH RubyMotion *and* obj-c then you're not really in a position to advise one over the other :)
Nicely done! I'm up to level 6 so far. I haven't programmed in Ruby much before this. Good practice for people new to Ruby. edit: Update. Finished all 9 levels.
Us Xcode's refactor tool, it will save you having to change it in more than one place. It's a little verbose in its naming (which is the same in rubymotion) but other than that I don't find it as bad and as far as ugly goes, well that's not very objective (pun intended;)) To be fair I haven't used ruby motion per se but I've done a fair bit of ruby (and still do)
Of course i've used the refactor tool, but it doesn't have options for every kind of refactor, and the ones it does have are just the simple ones :) You don't think it's ugly? Just check out this code for FRP in obj-c ;) [[self.textField.rac_textSignal filter:^BOOL(NSString *value) { return [value length] &gt;= 3; }] subscribeNext:^(NSString *value) { NSLog(@"Text field has been updated: %@", value); }]; From here: http://www.teehanlax.com/blog/reactivecocoa/
to me, that's line noise. Ugh.
You could also learn LUA and use corona SDK. Just an alternative to consider.
Just learn Obj-C. It's really not that bad (I would go so far as to call it the Ruby of compiled languages). Your first apps will suck and that's ok, you'll get better. Objective-C is a beautiful language and Cocoa is an amazing framework. If you need assistance [Ray Wenderlich](http://www.raywenderlich.com) has your back Ninja Edit: I have found most of the transitive environments for Objective-C (phonegap, corona, etc…) to be seriously lacking as well. Users **will** notice. 
I'm a somewhat experienced ruby programmer, and I still find this fun and challenging. As I've gone through the levels, I've found myself having to rethink my design to adopt to the new requirements that the game presents. This really mimics the importance and practice of writing change-friendly, lean code, and the frustration of getting lulled into a false sense of security about how well your code is written.
Fair point.
Same case here. I'd say go along with RubyMotion. 
Have you thought about writing in C or C++. JK Ruby is a more pleasing language to write and to read, but there are more considerations in this decision. IDE. I hear a lot that a major benefit to using Ruby Motion is that you don't have to use XCode, but I think this is misguided. While it is an IDE and has a large memory footprint, &gt; 500MB, it is a very powerful editor and has a lot of tools that make using it pretty cool. Support Obviously XCode, iOS, and the SDK are locked down. But so is Ruby motion. So far it seems like the producers have done a good job keeping up, but in the long run would put my money on apple to keep going. You don't want to get caught up shit creek if iOS 9 comes out and Ruby Motion doens't have the funding to support it for 7 months. Cost. Ruby motion is VERY expensive, one liscence I think is $200 and I inquired about a bulk or trial liscence and at the time at least they totally didn't. Add that on top of the $200 per year for a developer liscence. Debugger. If you don't mind command line debugging, then you'll be ok with Ruby motion. If you are inexperience with debugging, or preffer a GUI debuger, then XCode is pretty awesome. Coherrence. The vast majority of example and library code for iOS is written in Objective-C. Meaning that a translation would have to be made into ruby. The differences could be minor in some cases, but any time translation has to be made there could be error. Market Penetration (LOL). If you are trying to get a job as an iOS developer I'd recommend that you learn Object-C. If you aren't then it matters less. But if hirering iOS developers might be a thing, more will be available that know objective-C. Also, finding help on stack overflow will be more difficult for Ruby motion. In summary, Objective-C is the safer choice. But there's nothing wrong with going for Ruby motion, as long as you understand the costs and risks before hand. GOOD LUCK!
Hmm... 18 sections, with some stupid layout code that hides the scrollbar on a tablet. Random Lawyerese bullshit including some likely DMCA boilerplate (section 3, but IANAL).
hint: define a variable at the beginning to hold the health then set it at the end of the play_turn method. You just need to figure out the right check for what to with it from there.
Is the method 'stairs?' working for anyone else? 
I don't have experience with RubyMotion and I love ruby, but learn obj-c if you want to do iOS development. #1 More docs/more devs to ask. iOS development guides will assume you are using obj-c #2 Obj-c is not that bad. It's not ruby and the library has its quirks but you can pick it up quickly and for the edge cases, you can ask a lot (see #1) #3 iOS development has interesting tools. Instruments and Static analizers for example. I don't know if RubyMotion has an equivalent but it's worth thinking about the toolchain, not just the language. I'm assuming obj-c libraries work with RM by default. #4 It's a better thing to define yourself as a developer vs a ruby developer. I will always love ruby but I'm a better programmer because I'm not happy with just doing ruby, there's more than one way to do it :)
I guess you shouldn't expect nothing more than linguistic zealotry from most programmers. I've seen Java programmers mock Ruby syntax so it's obviously not a rational reaction.
I noticed this as well, where my warrior would attack backwards, instead of feeling for a wall.
I never tried it or needed to use it. Maybe they missed it in testing?
Great selection of points, agree 100%. The main effort is all in learning the framework, which I found to be most of the work by far when i dabbled in iOS before.
Stop thinking about learning and start doing. The only way you grok anything is by creating something.
Somethings that might help a newbie would be were to go look for tutorials and help. What are the best books on Ruby and Ruby on Rails? What is the most common use of Ruby in the industry? What type of developer would most likely use it on a daily basis? Like others I've found the fastest way to learn a programming language is to try to code something with it. Come up with an idea and try to make it work.
Don't take advice from someone who openly admits to having never used RubyMotion. See [here](http://www.reddit.com/r/ruby/comments/1j8d7c/ruby_developer_trying_to_get_into_ios_development/cbc7jmx)
syntax wise, if you compare it to ruby, objective-c is really ugly and way more verbose. then again, you are posting in /r/ruby 
Your #4 point has not been a concern in reality. RubyMotion usually lags behind new SDK releases *by one day*. I'm developing RubyMotion against iOS7 beta SDKs right now even. Since RM was released it's gone from iOS5-&gt;iOS6-&gt;iOS7 and while we're technically at the mercy of HipByte to release updates, they do take it very seriously and push them as quickly as possible (Laurent Sansonetti does the releases and is based in Europe, so the delay is generally about as long as the timezone offset and sleeping time delays). Hitting beta bugs in Apple's toolchain has been far more annoying.
Lots of things. For instance, all the methods that manipulate arrays, like map, reduce, delete_if, keep_if, and how exactly they work. Want a new array with every int higher than 4 from the old array? A newbie would do this: new = [] for x in old do new &lt;&lt; x if x &gt; 4 end A seasoned developer would simply do this: new = old.keep_if { |x| x &gt; 4 } Want the sum of every element of the array? arr.reduce { |x, y| x+y } Want a factorial? Of course you can do the normal way: def factorial(x) if x &lt; 1 1 else x*factorial(x-1) end end But you can also do this: def factorial(x) (1..x).reduce(1) { |x, y| x*y } end Which will not have stack overflows. Of course, you can also set this: RubyVM::InstructionSequence.compile_option = { :tailcall_optimization =&gt; true, :trace_instruction =&gt; false } And make this: def factorial(x) def fact_helper(x, acc) if x &lt; 1 acc else fact_helper(x-1, x*acc) end end fact_helper(x, 1) end And it will not overflow because it is tail-call optimized. But then, the second solution is shorter and effective (and you won't need to set compile options).
 "string".class.ancestors # =&gt; [String, NSMutableString, NSString, Comparable, NSObject, Kernel]
Thanks for this! Super helpful! I enjoy that you can do simple things like that with one method on an array instead of long(er) functions.
That when you are coding something and working with things like arrays, keep a good reference of Enumerable around. Can really save you time on doing things. That said, you just really need to dive in and code something you want to make :)
singleton class != singleton pattern, conflating these two left me confused for &gt; week
Ruby and Rails having a steep learning curve is not a lie. On the upside there has never been more documentation, videos, tutorials available for learning. What helped me learn quite a bit was to keep a second editor window open with the source of Rails loaded so that I could look at the source to see how things worked.
shit dawg when were #reduce, #keep_if, and #delete_if added?
that ruby semantic naming conventions don't stretch as far as to naming gems.
&gt;def initialize(start_port, end_port, host) Yet, the article reads &gt;ruby scanner.rb localhost 1 100 $ ruby portscan.rb 1 100 localhost D, [2013-07-29T12:42:59.939857 #1272] DEBUG -- : Shutdown completed cleanly
Read great ruby source code on Github for ideas on structure and functions you haven't used or thought of before. e.g. Read this project's code for inspiration https://github.com/meskyanichi/backup
Throw away the functional knowledge of how a programming language is supposed to work, but keep the abstracted. I can't tell you how many people I see get frustrated with ruby because they're trying to treat it like C, as they would with python. Don't use `for` (i've never actually seen `for` in production ruby code), embrace `Enumerable` and all its wonderful tools. And try as hard as you can to adopt OO coding. When it settles in its better than the alternatives Finally, find some project you want to do, something you could do in other languages, but do it in ruby. For me, that was creating the [snoo](http://rubygems.org/gems/snoo) rubygem, which is an api wrapper for reddit.
Background: I ran a reasonably-successful roleplaying MUSH (a type of MUD that emphasizes roleplaying over hack-n-slash style action) based on the Wing Commander theme until a few months ago, when I shut it down for inactivity. I've decided to opensource all the code, including a bunch of custom Ruby systems I wrote and the "drivers" to hook Ruby up to PennMUSH, in the hopes that someone else can use them. :) It's not perfect Ruby code (it was a learning project, after all) but it has been reasonably thoroughly debugged by the players of my game :) Check out the page, feel free to message or comment if you have questions, or connect to my 'support game' (which is running all the code, if you wanna kick tires) using a MUD client (or raw telnet) at wcmush.com 2199.
I would think they're rather old, since these methods come from Lisp, which inspired Ruby in some ways.
Uppity to the vizzote because that's fa real.
In Ruby 1.9+, you can drop the &amp; for that particular form as well: arr.reduce(:+)
I came from PHP, and I found myself doing things "the PHP way" too much. Look at other Ruby code and take hints. For example, instead of... if invoice.paid == true do.something end You can do... do.something if invoice.paid?
Sorry, I'm just being a license snob. It's not Ruby or MIT or BSD so I default to no. Reading over it more closely, it looks like it's mostly concerned with piracy. So... Probably ok. False alarm on my part.
Cool, thanks!
&gt; # With a start and end index &gt; array[2, 4] #=&gt; [3, 4, 5] It's actually a start index and a length. So, array[2, 4] means taking 4 elements starting at index 2. array[2, 2] would be [3, 4] for example
That's because grok only recently became an actual word. Before that it was just a geek pop culture reference originating from Robert A. Heinlein's book *Stranger in a Strange Land* and was used informally by fans - particularly in geek cultures where people identified themselves as not truly a part of the mainstream.
Actually, the host is read as ARGV[0]. Sorry, that bit is a little bit confusing. Are you still having a hard time running it? 
You can do that in 1.8.7 too.
Depends on how much is going on inside the conditional. The if/end way is more readable and more efficient in something like this: if invoice.paid? do.something do.something_else do.a_third_thing end do.something if invoice.paid? do.something_else if invoice.paid? do.a_third_thing if invoice.paid?
I wish I understood blocks and took the time to learn RSpec early on. It's the main reason my earliest ruby was so offensively awful. Once you "level up" take the time to learn how `#respond_to?`, `#method_missing`, and `#send` work (and the correct times to use them). Although there is constant debate on their appropriateness. Do yourself a favor and write a few basic ruby programs before diving into Rails. At first glance Rails is full of magic that can make no sense to a new developer. Learning some basic ruby concepts will make learning Rails *much* easier. Lastly: Don't be afraid to show us code. Ruby folk are a nice community and we'll try our best to help you along (provided you are willing to learn).
The Man from Mars would totally agree. 
Well... There's ruby warrior https://github.com/ryanb/ruby-warrior , which has some additional levels, and is a bit more challenging, includes up and down directions, controllable golems. There's a pretty cool gui wrapper for this as well: https://github.com/Spooner/ruby_armor but it looks like profile loading is a bit broken, and the project may be abandoned.
This is shifty advice. Coming from those languages listed you should start by digging into the global interpreter lock, event machine and a read over mega programming with ruby to see what you get in return for the GIL. 
JavaScript complimenting OP's Ruby skills: $('body').html('&lt;p&gt;FelixFortis, your Ruby skills are just ' + '&lt;strong&gt;mad&lt;/strong&gt;!&lt;/p&gt;')
[gem list](http://i.imgur.com/9eOgiqp.png) [error](http://i.imgur.com/fmYmgZ7.png) :(
http://stackoverflow.com/questions/14168093/midi-music-support-in-html5. You can play midis through the audio tag and javascript
I am going to kind of copy /u/hvis comment but for a different reason: The one thing I wish I knew was: **write tests** Let me repeat: *tests are not optional*. Specially seeing that you are coming from compiled languages. While programming Ruby, it is very easy to make stupid errors of small variable name changes, or ruby symbol changes (:color vs :colour) and you won't notice that the code is wrong until it is too late. There is no "undefined variable" warning/error, the majority of times your code will "run" (i.e., the ruby interpreter will load the file and start executing it) and will blow 3 hours later when certain line is used... As it is not type-checked, you have to "hope" that what you get is of certain type, and be very defensive (.responds_to?), using duck-type. All this is specially important if you are doing a bigg-ish non-trivial application. 
I wholeheartedly agree. Reading this book got me able to wrap my head around the object model, and thus the language stopped seeming like magic. I feel like things just all made sense after this.
Testing is *never* optional! (On non-trivial stuff anyway) and it is always necessary to reiterate that. I worked as a QA specialist during my internship rotation in college. Testing is king. If you have a brilliant application that is broken, it's not brilliant anymore now is it? You're not the first person that I've heard that from especially about Ruby though. Thanks for the input! Personally, I'll always be a tester at heart. 
I think the two most important think for me are "After you've learnt Ruby you'll laugh in the face of people who say that in Java everything is an object (because ruby takes it a fair bit further)", and "Blocks are a hell of a lot simpler than they seem to be at first glance".
&gt; it is very easy to make stupid errors of small variable name changes, or ruby symbol changes (:color vs :colour) and you won't notice that the code is wrong until it is too late There's no equivalent of "use strict" (as it is in Perl) ?
Working through the [Ruby Koans](http://rubykoans.com/) is a really good way to learn Ruby. I know the Koans are mentioned in the [/r/ruby](http://www.reddit.com/r/ruby) sidebar, but I think they are worth mentioning here, too.
Signals are tricky. When you mix them with interpreter state they just get trickier. To actually solve this sort of problem correctly and reliably, you'll have to do something like having a dedicated signal handling thread and use the [self-pipe trick](http://rubysource.com/the-self-pipe-trick-explained/) to move your signal reaction code from the signal handler to the dedicated (but normal) thread. It'd be nice if Ruby did this for you, but in general once you're dealing with signals you're largely expected to know what you're doing and want all of the control.
Probably. Just double checking I was not incorrectly using it. 
Who still uses 1.8.7? Lazy library authors, that's who.
I work with a team of php developers and a team of perl developers. You can always tell which wrote a particular ruby file. The code isn't necessarily bad, it just tends not to use Ruby's sugar or style. So I definitely agree with reading other people's Ruby, especially if it's written by a full-time ruby developer. Codecademy also helps here, their refactoring lessons onwards in particular.
No, because it wouldn't be possible to know until runtime if something is defined. E.g. an undefined local variable could equally be a method call. method_missing is defined on every object and is called when a method is not defined. These things are both strengths and weaknesses of ruby. Fantastic for meta-programming and DSLs etc, can be hard for debugging programs too though.
A bit of an aside, but, actually, your example is a bit of an anti-pattern. It breaks the "tell, don't ask" principle. In general, calling only a single method on an object leads to less coupled code. If your example were inside an object who's responsibility it is to orchestrate behaviours of multiple other objects/systems then it would be fine to call three methods on three different objects within that 'if' block.
Alternatively bail out of the method early return unless invoice.paid? do.something do.another_thing I've been using this style quite a lot recently, but the great thing about ruby is that they all read nicely!
singleton class in fact is singleton pattern. it's a class that can only have 1 instance. well unless you start duplicating objects, but even then - singleton class is duplicated as well and remains singleton.
[RVM](http://rvm.io). That being said, RVM absolutely is a crutch. You should also learn how to do without it, what other tools exist to do the same jobs, and when you don't need any tool at all.
Or skip RVM and try [rbenv](https://github.com/sstephenson/rbenv). It's simpler and it transparently works with Emacs (a big plus IMO).
And the biggest mistake n00bs (in any language) make about tests is: if you're using it primarily (or even non-trivially) for validation/verification of existing code, You're Doing It Wrong™. Good tests are a *design tool*, not a verification tool. If, in an earlier life, you came out of an ISO 9000 environment, you constantly heard the mantra "say what you'll do; do what you say; prove you did, or fix it". TDD/BDD/DDD/LSMFTDD change that to "show what you'll do while you're doing it, then make it better". You think you know what you're doing, then you poke at it for a year, and then you finally wrap your head around it.
Yeah, "don't try to learn Emacs at the same time" is quite right. :) Still, it should work just as transparently in most other editors. No real need for dedicated plugins, etc.
Don't you have to hit square 100 exactly? If you overshoot you don't move.
Note that [nmap](http://nmap.org/) crafts raw packets for TCP SYN/connect()/ACK/Window/Maimon/Null/FIN/Xmas scans, UDP scans, SCTP scans, IP protocol scans, Service/OS/MAC address fingerprinting and even has a [Lua scripting engine](http://nmap.org/book/nse.html) for advanced fingerprinting/data-collection.
IME, ||= and &amp;&amp;= tend to end up pretty readable in practice unless you put too much other logic on the same line. 
While I prefer rbenv of the two, I didn't suggest it because it's a two-step: you need ruby-build or ruby-install to go with it. RVM's *only* saving grace is that it's good for newbies because it tries to do everything for you. The stack I prefer is chruby, ruby-install and gemsh. They're all tiny, and do a single, simple job, so the source for each is easy to get your head around. Also: no binstubs or shims. Ever.
I don't think I like them either. I just stuffed this trick into a script I wrote earlier this morning, but had to leave an explanation comment because I know I'll have no idea what the hell it means in a few months.
Cool trick, but it encourages mutating variables, which I don't like. I'd prefer creating a new variable "formatted_name" in this case.
Don't use it (unless you're playing [ruby golf](http://rubysource.com/ruby-golf/)). Always think of the maintainer (probably you in a couple of months)! Using "&amp;&amp;=" will cause a mental delay (and maybe even confusion).
Pretty bad example: options[:name] &amp;&amp;= options[:name].strip Compare readability, ease of maintenance (think of how a diff will look), and letter count ;) options[:name].strip! if options[:name]
You cheated and used another method :) Not all methods have their bang pair.
I use ||= because it's idiomatic, but it's definitely weird. If you want what the linked article is trying to achieve look at [andand](https://github.com/raganwald/andand) instead.
Just to clarify, he means automated tests. You probably knew that, but just in case, Ruby (on Rails) has amazing frameworks (rspec is my favourite) for fully automated testing. One bash command (bundle exec rspec) will test EVERYTHING of your app, assuming you write good tests. Make a change and you're not sure itll work? bundle exec rspec, you'll know right away. Beautiful!
Congrats on the migration. I'm Chief Engineer of a relatively new startup, and one of my primary missions as I see it is to ensure that we never, ever have to go through the level of pain and stop-work that you describe. We're using a BDD, write tests *first* as design declaration, continuous-deployment approach while we add new features to our product. We anticipate making a *huge* architectural change by the end of the year, from our current megalithic Rails app to a distributed, service-component architectural style. I have a lot more faith in our ability to scale that via EC2 (say, in response to being Slashdotted) than what we're working with presently. This plan has, naturally enough, led to a certain amount of questioning from higher management. I'm adding this blog post to a fast-growing list of "here's a near-best-case description of what we can look forward to if we don't clean up our act now, *before* we're a household name." Because, obviously, if we crash and burn for a week, we *won't* be "a household name", except for would-be startup guys to tell scary stories to their boards at night.
Here's my explanation of why: The **||** and **&amp;&amp;** operators will only check as many parts as they need to to get a proper result. So if **a** = **true** and **b** = **false**, then when (**a || b**) comes along, Ruby doesn't even evaluate **b** to check if it's **true** or **false**, since it doesn't matter for the **||** operation. Here's a more concise illustration: &gt; bool = lambda {|name, r| puts "#{name} was called"; return r} &gt; a = bool.call("first", true) &amp;&amp; bool.call("second", true) first was called second was called =&gt; true &gt; a = bool.call("first", false) &amp;&amp; bool.call("second", true) first was called =&gt; false Here you can see that when the first part of the **&amp;&amp;** evaluation occurs, if it returns **false**, Ruby doesn't even look at the second part, and promptly sets the variable to the returned value, **false**. With the **||** operation, it only checks the second one if the first one is **false**. &gt; a = bool.call("first", true) || bool.call("second", true) first was called =&gt; true &gt; a = bool.call("first", false) || bool.call("second", true) first was called second was called =&gt; true So **&amp;&amp;=** and **||=** are really just like **+=**. &gt; a[:k] = 7 &gt; a[:k] = a[:k] + 3 &gt; # is the same as &gt; a[:k] += 3 =&gt; 10 &lt;-- the result of 7 + 3 &gt; a[:k] = a[:k] &amp;&amp; 3 &gt; # is the same as &gt; a[:k] &amp;&amp;= 3 =&gt; 3 &lt;-- since this was the returned value of the (a[:k] &amp;&amp; 3) calculation **EDIT**: Because of this, if a[:k] is **false**, then Ruby won't set it to the second value in a &amp;&amp;= scenario. That is, the author of the article claims: &gt;It's useful when you want to preprocess some value, but only when it exists. **nil** and **false** will both cause the second part of a &amp;&amp; operation to not process. Just a slight semantic distinction. :) Happy coding! 
 new = old.keep_if { |x| x &gt; 4 } That code doesn't make much sense (since you're marketing it as code by a seasoned dev). keep_if will update the array (some may argue that it should come with a !, but the name of the method is clear on its intentions. If you're assigning the result to a new variable (and want to keep old intact), you should use something like #collect or #reject new = old.collect { |x| x &gt; 4 } new = old.reject { |x| x &lt;= 4 } Otherwise, there's no need for two variables (old/new): array.keep_if { |x| x &gt; 4 } Which, if you're doing very often, may help you save some object allocation time. 
Or options[:name].try(:strip!)
Object#try isn't Ruby, it's a method provided by Rails (specifically, ActiveSupport).
&gt; options[:name] ||= 'Bond' &gt; # instead of &gt; options[:name] = 'Bond' unless options[:name] &gt; &gt; Seems to imply the two are equivalent. They are. &gt; Really though, ||= literally means the first thing equals itself or the other thing: &gt; options[:name] = options[:name] || 'Bond' Actually it doesn't. `options[:name] ||= 'Bond'` will only call the `[]=` operator if `options['name']` is falsy, i.e. it won't assign it to itself if it's truthy - it will just keep it unchanged (just like the version using `unless` would); `options[:name] = options[:name] || 'Bond'` will call the []= operator in either case. One way to see the difference is this piece of code: h = Hash.new(true) p h # Prints the empty hash h[23] ||= 0 # Does not assign anything because `h[23]` is already true p h # Still prints the empty hash h[42] = h[42] || 0 # Assigns h[42] = h[42] p h # Prints {42 =&gt; true}
Just because it's not a core language function doesn't make it not ruby.
Right, every time you write a + 2, you should write a.+(2) No one wants that syntactic sugar.
Interesting, thanks for the link. I was recently working in a language where all variables were const by default and you had to actually decide when you absolutely needed to allow mutations. It was a very interesting time programming in that style. From a quick glance, that's similar to the clojure model -- const by default? However, given that ruby is not such a language, and is designed for mutation, I'd be concerned that creation-by-mutation leads to unnecessary object creation and inflates memory usage until the end of scope, at least. Since there's a reference to the original object, it can't be garbage collected, whereas the temporary created during mutation (if any) can be collected asap. Unless I have it all wrong :)
Huzzah, we're learning! So, the behavior you speak of is correct, though there are a couple things at play here. You are right in that `options[:name] = options[:name] || 'Bond'` is yet just another approximation. Firstly, it should be noted that `||=` is apparently handled a little differently depending on if it's called on a variable assignment, method assignment, or indexing assignment, such that each of the following are treated differently^1: a ||= b a.c ||= b a[c] ||= b A hash assignment would fall under the last one. (On a side note, these behaviors can be found scattered throughout the specs in [the rubyspec repo](https://github.com/rubyspec/rubyspec), but they're not all in one place, which makes it a little more difficult to comprehend). But that's not really important for this discussion, as the behavior you mentioned can be illustrated without using hashes at all: &gt;&gt; class Blah &gt;&gt; def hi &gt;&gt; puts "reading" &gt;&gt; @hi &gt;&gt; end &gt;&gt; def hi= value &gt;&gt; puts "writing" &gt;&gt; @hi = value &gt;&gt; end &gt;&gt; end =&gt; nil &gt;&gt; b = Blah.new =&gt; #&lt;Blah:0x007fdb4e8021a0&gt; &gt;&gt; b.hi reading =&gt; nil &gt;&gt; b.hi ||= 'there' reading writing =&gt; "there" &gt;&gt; b.hi ||= 'now' reading =&gt; "there" The important thing is that the more appropriate expansion is: options[:name] ||= 'Bond' # is equivalent to options[:name] || options[:name] = 'Bond' ...but with its own operator precedence (it has the precedence of an assignment like `=`^2). Reading through my explanation of the evaluation of the `||` operator above, the exact behavior you described becomes apparent. There's a more literal explanation of the Ruby spec on the `||=` operator on [this StackOverflow post](http://stackoverflow.com/a/12287783/366381), or of course the PDF Ruby spec itself (the link to which seems to keep moving), and [the definitive list of ||= posts](https://www.ruby-forum.com/topic/151660/) is helpful too. ^1 http://stackoverflow.com/a/2505285/366381 ^2 https://github.com/rubyspec/rubyspec/blob/624bdd6e27263b4f0f8585a383cd7ce533edd9f6/language/precedence_spec.rb
I'm personally a fan of writing everything that doesn't require layout in markdown, but that's me.
Just out of curiosity, why didn't you use the wonderful [redcarpet gem](https://github.com/vmg/redcarpet)? It is faster than kramdown. P.S. Loved interacting with you at RubyConf India.
Thanks for the assist. When I'm in the first part on creating the route, do I just use the same code I used originally to calculate calls? When I try to do that and test it, I get an unexpected token error. I've tried to insert the coffeescript into my index.erb directly and in a referenced js file. Any idea? What can I show you to help?
Kramdown is written in pure ruby and therfore cross Ruby compatible, so you can use it in JRuby, rubinius, etc. Emails should be sent in a background task anyway, so losing a few miliseconds per email shouldn't have a catastrophic effect. 
Holy crap this is super cool. I hate hate hate writing emails twice and so I never do it. Definitely using this asap. Major props.
Here's a working implementation: https://gist.github.com/anonymous/1914d2014c3d6a180f73
I've done something similar to this, using a custom redcarpet parser for text based emails that tries to do pretty text formatting (based around redcarpet strip), but your approach is a lot cleaner. Bravo I assume you want people to do something like use a layout for their complex emails? I personally hate emails with banners and all that, but sometimes they are required for a project
Don't you know that anything written in Ruby needs to have a silly name? Like Nokogiri or Hpricot. Anyone googling for this project is going to find a lot of unrelated results.
Yeah. Should be called room or roam or rabbi or something else fun
There is a logging gem called logging.
What does it have to do with knowing Ruby? Not everything is an object in Java because not everything is an object in Java.
Matt, thanks. This is a great project for a new-ish coder like me. Even though I haven't completed the project yet, I understand probably 70% of what you laid out and the other 30% is probably searchable. Seems like a pretty good ratio. This is also a great example of a "real world" project that has an immediately recognizable practical use. I really dig stuff like this and I hope you keep posting more walk-through tutorials like it.
Glad you found it useful, and thanks for the vote of confidence!
Isn't that what Capistrano is for? I use it for automating SSH tasks. The ability to run stuff over multiple servers is very useful.
For those of you new to Sinatra, I definitely encourage you to check it out. I've been building web apps with it for a little over a year now, and I find it a joy to work with. It's very simple, no cruft, and none of the Rails magic. Of course, the magic is what makes Rails popular, but I like being closer to the metal when the project allows.
It doesn't matter how well prepared you are if Rails core team decide to release a new version of Rails that break compatibility on so many levels. You have to sit down and rewrite a big chunk of your code. To say that the core team did a terrible job with a Rails 2 &gt; Rails 3 transition is to say nothing :) I've been doing Rails since 2004 and I've never seen anything like this.
https://github.com/cldwalker/tux ^ very helpful for debugging. Also: this is one of my favorite sinatra based projects: http://shopify.github.io/dashing/
Damn hipsters trying to make descriptive names a thing.
Dude thank you!! I needed something like this
Yeah, I think Capistrano has this down already.
Kudos for spending time on a configuration language. It's pretty hard stuff. I wrote something on top of Rye myself, called [Rudy](https://github.com/solutious/rudy). I'm not recommending it b/c it needs be rewritten but it's a point of reference. There's also Capistrano (another wrapper around net-ssh) as others have mentioned as well as [Vlad](http://rubyhitsquad.com/Vlad_the_Deployer.html) (a wrapper around OpenSSH's `ssh`). Both of those have their strengths and weaknesses. A total barebones approach would be to leverage host configuration in `~/.ssh/config` and then running commands directly from a one-liner like: $ ssh USER@example.com uptime 01:24:02 up 3 days, 4:37, 0 users, load average: 0.00, 0.01, 0.05
After a relatively short time, most of the extraneous symbols ([] in particular) will be filtered out by your brain, much like they are when you write plain HTML. Also XCode has very nice handling of that particular irritation, so you often don't need to type them verbosely. Just finishing a message call with a single `]` will place it at the beginning of the call for you. Really, it just doesn't hurt you to be able to work with more languages, and you will probably become more profficient with Ruby just because you have wider exposure to language concepts. Knowing C and Objective C will never hurt your marketability either. Edit: Finally, even though the code sample above looks ugly, when you write your own code, you are quickly able to read other code more easily. Take the plunge, the benefits outstrip any imagined drawbacks. 
...except JRuby.
What is the point? Dynos are cheap, developers aren't.
As a novice who has been learning Ruby and working his way through Hartl's Rails Tutorial, can you give more insight into specific examples of how you do things in Sinatra vs. Rails? Trying to get a better sense of whether I might be overwhelming myself with Rails as it seems there is a lot of "process" to learn in order to do things the right way. I'm still just trying to wrap my head around the basics of where to set things up within the MVC framework, let alone all the advanced things he gets into with unit tests in Rspec. He gives the syntax so I can follow along, but I'm left with the feeling that I'd never be able to replicate anything he does on my own.
 I quite like C# in comparison to say, Java. Due to C# and .Net being intertwined is C#'s biggest problem.
I second your opinion. Some developers don't raise money to do stuff and have to resort to such methods to survive as long as possible. If you raise just a bit of money, or keep your day job/freelance, $30/month isn't a problem at all and all that engineering work is for naught. What happens is that they just prolong not being successful by wasting precious time getting around paying $30/month. They don't realize the real opportunity cost is the time that could have been better spent building product. 
Side projects. Dynos are cheap for a full fledged business. Dynos are expensive to run out of your own pocket for something that's not making much/any money yet.
This is really helpful, I appreciate the thoughtful post. I think I'm on Chapter 7 which is where you code your own login validation from scratch. I was surprised they were throwing such an advanced concept at the reader at that point, but I see why, and I'm glad to understand the guts of how something like that works. I had previously done the Javascript and Ruby tracks of Codecademy, and am comfortable with HTML/CSS and hacking together Javascript/PHP by Googling things or Stack Exchange. I should mention I'm also learning general database concepts now with a Coursera Intro to Databases course and a book on MySQL I picked up. My reasons for starting going down the path of Ruby and Rails were that I truly wanted to be able to create a "web app" that worked with a database. I had a few general ideas for apps, but the idea of piecing it all together was very overwhelming for me (and still is) as I still don't have a good understanding of the general workflow of how to work with a given language for a given task, and more importantly, core concepts of doing different components (like the login validation). I wish there was a language agnostic book that walked through key components of different web dev concepts and the structure of those components. Anyway, I have a rough grasp of MVC, but I think my issue is I haven't seen enough real world examples of the "right way" to do it to feel comfortable with it in my own use cases. I started learning Rails, but then went back and focused on learning Ruby via Chris Pine's "Learn to Program" book which I completed. Having that foundation of Ruby made Rails much easier, but I think Rails might still be too advanced. That said, I wonder if switching to Sinatra would make my road even more difficult because it lacks a lot of that magic. 
&gt; They don't realize the real opportunity cost is the time that could have been better spent building product. Or they don't care because the work is for fun towards an experiment or learning experience and not a product in its own right. Sometimes yak shaving is yak shaving.. and sometimes what looks like yak shaving is someone just playing around or learning.
That's perfectly fine, but you'd be surprised (perhaps) at how many startups are spinning their wheels creating yak shavings.
Because once you know it (and it takes quite a while to claim any level of mastery with it) most operations are much faster to complete than with conventional editors. Honestly though, the quickest way to start a holy war in any programming group is to start asking which editor is best. I don't think this is a very good use of anyone's time.
well i use it sometimes to edit a file without the need to open sublime. like the database.yml in a rails app. it's pretty fast too.. press i to start editing, and :wq to save and exit... done 
[Real programmers use it.](http://xkcd.com/378/)
watch a master perform magic with vim, it only takes watching a few of these videos, to see the extent to which vim can extend your effectiveness via the homerow and muscle memory. 1. http://www.youtube.com/watch?v=SkdrYWhh-8s 2. https://peepcode.com/products/play-by-play-benorenstein 3. http://vimcasts.org/ 4. https://www.destroyallsoftware.com/screencasts Further when combined with iterm2, solarized, and powerline vim is certainly not lacking in visual flair. However you may want to start here https://github.com/fatih/subvim
I would add another benefit. Properly written .vimrc files will give you the same font, syntax highlighting, shortcuts, and plugins on every platform vim supports. Having the same editor everywhere is wonderful. That and the visual studio makefile it ships actually works so you can trivially have an up to date vim on Windows.
There is stuff I can do in vim that I can't do easily in any other editor, For example, If I need a make extensive non trivial changes to a file. I can have vim record all my actions, save it to a macro and then perform the macro whenever I want. The macro can be something like: Take the third word after the 2nd ':', capitalize it and stick it on the end. Also, vim can work with many buffers, I can easily pull and push to multiple buffers and explore them with a quick keystroke I have an extensive amount of plugins that I heavily rely in (Thank you Tim Pope) I can locate something much faster on a page than a user using a mouse. (not even close) I never have to take my fingers off the keyboard, (coding with a mouse slows down the process considerably) Vim is one with every language I work with, with syntax coloring, automatic indent, brace matching, etc... After working with Vim, the movement actions become ingrained and then you don't even realize how you navigate the page. It's like watching yourself tie a shoe. The bad side all of this is that when I game, I have to remap my games to use the vim motions or I am completely fubared.. 
I dunno, I just always assumed it was "most of them" judging purely by how many of my wistfully started personal projects descend into a yak shaving hell. Reflecting on what I just said... I think I probably need to work on my willingness to compromise with myself.
Watched the videos, none really showed off any real Vim power to speak of (I only watched the free version of the second link, wasn't going to pay $13 for it) The first one definitely *talked* about powerful Vim features, but displayed very little. It's not that I don't agree that Vim is powerful, I was just a little disappointed with the videos.
&gt; (except to refresh the browser) Check out [LiveReload](https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei). It works great in combination with [guard-livereload](https://github.com/guard/guard-livereload).
I like a clean desktop: I've got 5 terminals open (tabbed) and maybe another three in tmux. If I work on a project I'll probably open up another 2-5 Terminals for VIM. VIM has a great macro recorder and very powerful commands (experiment with .) But sure, having ctags is no visual studio, api documentation isn't well integrated, etc. And sublime sure looks good, I like the overview mode. Forgot to mention search and replace, as a VIM user I think it's broken in every other editor (don't know about emacs though).
I think you have this down. Vim just seems to have that same design and feel to it. I don't use it much either, I prefer something that's a little nicer on the eyes and friendly. I know the basics so I'm pretty comfortable editing files on servers over SSH, but other then that I just use sublime as well.
There *is* a GUI version of Vim, called GVim. It's very good. However, you can always press ctrl+z whilst in the terminal version and it will background the program for you so you can perform other terminal operations. You then press 'fg' to return to it. The biggest draw for me is that I can move freely around in the text, perform advanced editing operations, etc., all without either A) complicated keyboard shortcuts, or B) my hands leaving the keyboard
 0 func foo() { 1 // comment 2 bar(42, "yes"); 3 } For example you need to change text in the quotes to "no", you are on the line 0. In conventional editor you should do this: 1. *Move you hand from home row to the bottom right edge of keyboard* 2. Press Down 3. Down 4. Ctrl+Right *(using both hands or two fingers)* 6. Ctrl+Right *(using both hands or two fingers)* 7. Right 1. Shift + Ctrl + Right.* (now using three fingers) 1. Shift + Left *(using both hands or two fingers)* 1. Shift + Left *(using both hands or two fingers)* 1. *Move your hand back to home row away from arrows.* 1. Type no What you press in vim: 1. 2 1. j 1. c 1. i 1. " 1. no Meaning: 2j - jump two lines down (line numbers displayed so you see how many lines down). ci" - change text inside quotes. If vim keystrokes seems strange to you - it just seems. It's like walking. Once you learned it's mostly automatic. 
I also came to Ruby from .NET. First, Ruby is different. It is impossible to use autocomplete using type. Vim uses words from open files which is good. Vim is really fast. Plugins helps a lot. It is easy to do remote pairing with Vim. Sublime is not as popular because it is relatively new.(and because it provides less although it is easier to learn)
Have you ever seen some martial arts guy do some weird movement, an odd thrust or jerk or unnatural movement, and thought, "What a dumb person, for doing this extra movement?" And then yet, their body joints last for a hundred years and their spines are straight and their necks don't hurt, but they do these terrible things all the time. It's because they use vim. 
To be honest. I didn't get the power of vim until I subscribed to Destroy All Software. In any case I would highly recommend this series of screencasts if you are interested in learning Ruby. After having watched the first dozen videos watching Gary Bernhardt explain software patterns using ruby in vim, I decided to bite the bullet and spent about a week getting up to speed with vim after years of coding in textmate and then 6 months with sublime. It was slow at first, but I've been using vim fulltime for a year now and can't imagine going back. I would say just by the fact that you are curious about vim that you are a good candidate for picking it up and learning it and really enjoying it.
 :2s/yes/no/ I tend to fall back to less efficient patterns which my clumsy fingers are less likely to screw up. *sigh* There are just soooo many ways of doing something though which is what I really like about using vim.
&gt; differences between the Rails magic vs. the Sinatra "vocabulary" Yeah, I can't imagine you would considering I didn't write it with that in mind. Depending on my weekend, maybe I'll put together a rails specific implementation. Check my blog on Monday (or sometime next week). &gt; Are you able to think of any examples that are even more specific? Nothing worth sidetracking your progress on the rails tutorial honestly.
Personal preference. I tend to see it less among ruby developers, who tend to use things like TextMate or [SublimeText](/r/SublimeText). Learning a basic subset of Vim is useful, because it lets you change configs or other things on a server where a full checkout isnt warranted, or something similar. I just dont care for the console inteface because there are some things a mouse is better at, such as selecting large, odd shaped text selections.
Vim has become the new hip editor among web developers using Macs. Vim is cool, better than those proprietary editors, but I suggest you give Emacs a try as well and decide which you like best.
Thanks for the encouragement. My main thing right now is that I'm spending a lot of time mastering ruby, and when I have to stop for 5 minutes to figure out how to comment multiple lines I feel like I'm wasting my study time. Vim is definitely on the list, I'm just wary of the three weeks or so of time it will take to ramp up while I'm moving at a glacial pace in Ruby. 
Yea, sure! Also one could use simply `/yes` to jump there. And then `:s//no` to replace it. Or `2jtycw`. Many ways as you say. And all tend to be much better then ones of other editors.
I mean, I'm familiar with what they do, just not under those names. Guess I need to play with `Array` more.
Because with a few keystrokes you can achieve miracles. &gt; It's a terminal application, which means that unless you work with TMUX you either do some terminal or you code you can't do both. Of course you can: alt+tab.
This is what I would do: /yes cw no */* stands for search, *cw* stands for change word. Magic.
exactly used for any language, on any os, isn't a huge clunky IDE, and runs well on pretty much any computer (e.g. laptop, netbook, desktop). it's a technical tool for technical people
Well, it probably provides very few people with a career or significant source of income, I'll accept that. On the other hand, I'd probably favour someone in an interview who had mastered vim. Not so much for its usefulness towards getting the job done, although that is a plus, but more for what it says about them and their attitude to learning/reaping rewards of previous efforts. Someone who has taken the fall of a few weeks short-term optimal productivity in aim of servicing a longer term goal may be someone who is more likely to write cleaner more maintainable code. They may choose to learn a language that would be more appropriate to getting the job done in a particular context. They may spend two days on what could be a five-minute fix, but results in a thousand-fold improvement elsewhere and huge cost-savings. Admittedly, to play devil's advocate to my own argument, they may also be yak-shavers, who constantly tool-up and don't focus on lean principles. However, I think it's easier to focus a yak-shaver than it is to instill diligence and good standards in a cowboy-coder. That may or may not be true, but a lot of gut feeling thinking goes on in the interview process. Besides, true mastery of anything takes more than a few weeks. So I don't think you'd get as much long-term reward from 2 weeks of ruby learning as from 2 weeks of vim. 2 weeks of ruby is not enough to become employable, however 2 weeks of vim is enough to become proficient enough to replace your main editor. You're going to be still learning both after you've become productive in either for a long time yet. If you want a simple start though, check out YADR: https://github.com/skwp/dotfiles
It works perfectly in Emacs.
It takes a considerable amount of effort to learn vim. It takes twice as much to unlearn it. 
try :!&lt;command&gt; or :sh. Or for fun and profit !&lt;command&gt;
Why not use a text editor in vintage mode?
And on top of being an awesome tool used for editing, it's also extremely useful when playing around in the python console/irb/or just plain needing to edit the second word in a long command I'm trying out for the first time...
With my LD_PRELOAD hack this is how you do it in a ~~conventional editor~~ any application you wish, no need to move your hands anywhere (I'm using this to edit this comment): 1. 2x Alt+K (2x down) 2. Alt+O (End) 3. 3x Alt+J (3x left) 4. 3x Shift+Alt+J (3x left and select) 5. no Perhaps not as good as the Vim way, but it works **everywhere** and has almost zero learning curve.
I don't see the point. Vim is the nicest text editor out there. Why should I use another text editor with integrated poorly emulated version of original one. I see the point of vintage mode in IDEs though. But that's another story.
My simple reasons for using vim: - Vim lets me work efficiently both locally and remotely. - I keep my editing environment the same whether local or remote. - All I need is putty on a windows machine and I'm "almost" as efficient as if using Linux. - No need to worry about what the IDE needs (e.g. Git/FTP). Just ssh and go! Edit: removed because I'm stupid!
There is a long list of reasons that--even when I was using Visual Studio for work--I would use vim. But I'll give you a quick one: `dat`. I just removed a pair of XML tags and everything in between. Awesome, right? Now, I'm sure there was some sort of key combination in whatever IDE you use that can accomplish something similar, but how was I supposed to figure that out without spending hours memorizing all the shortcuts? How did I know the vim command so easily? Well 1. `d` starts a delete command, which then waits for a "size" or "selection" 2. `a` will select *all of something* (inclusive), which waits for me to pick what 3. `t` stands for "tag" (or "XML tag") which finishes the "select all" and "delete" commands. Every keystroke in vim is a command, and you're free to combine them in a mind-boggling number of ways. So, while an IDE might have plenty of shortcuts and macros I could tap into, I already know how to do all of it and more by combining a few commands in vim. Delete 3 lines? `3dd`. 'Yank' everything until a ';'? `yt;`. Format a line? `==`. Format 3 lines? `=3j` Format an entire file? `1G` `=G`. Best part, most of this is vi--not even vim. I'm hardly scratching the surface here. You don't write your programs by selecting from a menu, so why should you limit the tools you use to point-and-click?
ITT: people playing [vimgolf](http://vimgolf.com/)
Vim is not like other editors. It is a text editor first and a composition tool second. Whereas most other editors are primarily composition tools, with their editing options a close second. You see this from the interface. In Visual Studio the default action is to insert new text and the editor helps you out as you do this. To make complicated modifications you need to apply modifiers to your keystrokes and often use dialogs that appear over the interface. Whereas in vim every key is by default a movement or a way of modifying text. To move to a specific location or perform a sophisticated permutation requires only a few keystrokes and the text composition part is simple and barebones(backspace often does not even work as expected without changing a setting). As a result of this I find myself physically typing very little of the text I create in it. If there is a similar loop somewhere I will grab it and make changes instead of starting from scratch. As a result of this I use them for different things. At work I code in netbeans in windows because that is what we have our projects set up in, but I have a hotkey to open the current file in vim(gvim for windows is not bad, and it is much better when you make some changes to make it look more like console vim). Then I toggle back and forth as I need to.
livereload + autocmd BufLeave,FocusLost * silent! wall 
Command line &gt; GUI
Vi for quick fixes on a production machine or busybox device. Sublime text everywhere else for me.
Alright, so I've written lots of Ruby, but done minimal Rails work. I completed Hartl's tutorial but besides that the majority of my Rails experience has been through configuring 3rd party Rails apps and experimenting with Locomotive CMS. All I'm saying is that I love Ruby but am definitely a Rails outsider. I think the best example of why I like working with Sinatra can be found by generating a new Rails app. "rails new helloworld" generates apx 33 files and 38 directories. That is a WHOLE lot of material to get your head around for "hello world", and each time you run another rails generator multiple new files are created which you are expected to find and modify the "Rails way". In contrast, my basic Sinatra app starts with about 12 files and 6 directories (including Rspec tests), and I personally create them all so I know exactly what they're doing and why they're there. But hell, if you want to start simple you can actually create a single file Sinatra app, check out the example on the homepage: http://www.sinatrarb.com/ Sinatra provides easy route definition, view templating, and allows for integration of Rack middleware. Because it is lower level, lighter, and devoid of the magical Rails generators, the resulting applications are far more transparent than Rails apps. I think this makes it a much better way to get into Ruby web development, as it forces you to really know what you're doing and why, and to learn Ruby in a more direct way. Check out http://www.sinatrarb.com/intro.html for the hello world and an overview of Sinatra's features. I'd be interested to hear your thoughts on it as a beginner, and would be happy to try and answer any other questions you have. Happy coding!
This. It's not the speed, but the lack of context switching. This is most obvious in Vim's elimination of the need for a mouse or arrow keys, but it also manifests itself more subtly. The movements and key commands have become so natural over time (and *seem* more natural for that matter, like in the way Vim treats a document as a collection of paragraphs, words, and characters rather than a blob of text) that I spend more time thinking about what I'm going to do and less how I'm going to do it. Macros and working inside Tmux are cool too.
T.I.L. `c·i`, thanks!
Nothing is more frustrating than Vim emulation modes. It usually takes about 60 seconds to start running into all the ways they fail to replicate real Vim.
NP! `i"` is just one of many text object commands. Please refer to `:h text-objects` to see them all.
Wow are you me? This is what I say to anyone looking into iOS as well. This is the correct mentality to have for software development in general, using the right tool for the right job is the mark of a seasoned and competent developer.
Write an iOS app! No seriously iOS is stupid hot right now and there are simply not enough developers available for demand right now.
[This stackoverflow post describes the power of vim in the best way possible. It shows examples and shows how they work in the grammar of vim not just here's x cool thing and y cool thing.](http://stackoverflow.com/a/1220118) 
Great idea. I hate that they keep saying vim "ninjas" on the web page though. Ninja, guru, etc are awful buzzwords. 
Mono might be 99% of how you use C#, however Mono is 0.1% of how the industry uses C#. It also doesn't help that C# language spec is controlled by MS. I can't say they've done their usual terrible job with it though. C# is a nice enough C style OO language, syntax wise, and I think a reasonable improvement over Java. But no, as I say, my gripe with C#, is very .Net specific and it's slew of crappy "built to be redundant next product cycle" *Features*. Honestly I don't want to get into that discussion at all, every year that I don't have to work with .Net is like a year after a prison stretch. Never want to go back, never want to think about it.
:x
Rockstaaaaarrrr!! /s
I didn't know about ci", thanks, you've just sped up my Vim workflow! Although I might replace it with a slightly more powerful version. That's another reason Vim is so awesome, there are always little ways you can improve.
No I wouldn't: Command-F yes Enter no
That's 13 keypresses to Icedp's 8. If distances increase, Icedp's solution is still 8 or 9 keypresses; yours increase linearly. One-character-per-keypress movement is simply not comparable, efficiency-wise, to the vim way. I already paid the learning curve cost; so it's not a factor for me.
Yeah, I've been hippily using it for 20 years. If you're good with emacs, more power to you; but "trying out" vim and emacs means studying for months each before you know enough to evaluate. Someone once said that while traditional GUI editors are good for text entry, nothing beats vim for text *editing*. And emacs is an OS, not an editor, really. :p
You can use Vim in a window with Gvim. I recommend Gvim a lot because if you forget a key binding there's a drop down menu you can use that also lists the keyboard short cuts. I strongly recommend you use Vim for two weeks before you make a decision about it because of its learning curve. In the terminal type vimtutorial (might be vim-tutorial) and a nice interactive program comes up which walks you through the basics. 
&gt; And emacs is an OS, not an editor, really. Yawn, same tired jokes **ad nauseum**. 
Ruby developers are firmly rooted in the command-line and the web. Most of the bells and whistles of an IDE are available as commands, editor plugins or web-apps. Also, checkout [Emacs](http://emacsrocks.com/) and [Sublime Text](http://www.sublimetext.com/). &gt; It's a terminal application, which means that unless you work with TMUX you either do some terminal or you code you can't do both. You can open multiple tabs/terminals or use `gvim`/`kvim`/`macvim`.
Honestly, investing a couple months in something to decide whether you're going to use it for the rest of your life isn't too much to ask. I spent years playing with editors. Emacs won, because it let me build the editor I really wanted.
I'm a weirdo. I use both. I've got twenty years of experience with both of them, and they both occupy different niches in my life. I'm better with vim than I am with emacs, but the things that emacs is good at, emacs is *excellent* at. And likewise, the things that vim is good at, vim is *amazing* at. Me, I'm a fan of vim's navigation superpowers. It feels like you're teleporting through your code. On the other hand, emacs is a hacker's dream. You can reprogram it to do anything you want--all you have to do is learn how to code in Lisp.
vim is available pretty much everywhere and has been used and developed extensively over the past 30+ years. Same with emacs. Vim's design is widely praised because most of the commands are designed to be performed without your fingers leaving the home row of your keyboard. My friend has been using vim exclusively for the past eight years and when I look at him code it's scary how fast he writes. You know how C is the lingua franca of programmers? Well, vim is like the binder clip. Everyone has it, everyone uses it and it's probably the most useful thing known to man.
What if you have `0x2FC523C` in quotes, would you type `Command-F 0x2FC532C`? Oops I mean `Command-F 0x2FC523C`, damn it we in the wrong place of the file now. How would we go back?.. oops
Can you do this in submlime vim mode? ``` :map &lt;f5&gt; :w &lt;cr&gt; :call system("tmux send -t0 'rspec spec/models/my_model_spec.rb'") &lt;cr&gt; ``` That lets me press the `&lt;f5&gt;` key and write the file, and then tell the left tmux pane to run the test. Vim's integration with UNIX is the electrolytes I crave most. It's not just hjkl for me. If that can be done in sublime with the vim plugin, I may actually consider using it.
Here are my reasons (granted I haven't used other IDEs in 5+ years so they might now have some of these features). * Window splits. I often have at least 2 open at the same time. * I don't have to touch the mouse. I find using the mouse slows you down. * It integrates with CLI utils like sort, etc. * I can run it on remote servers over ssh. Also, pretty much every *nix/OS X machine has vim installed. * There are some awesome plugins I use for my job like rails.vim and fugitive * Highly customizable (I have lots of customizations, commands, etc which is why I don't use other IDEs with fake vim support) * It works inside tmux/screen. This is awesome for TDD. See [my video](https://vimeo.com/55122881) * I love keyboard-based navigation (I can go to different words, paragraphs, lines by hitting only 1-2 keys) If you're interested in learning vim. I recommend checking out [Yehuda's article on vim](http://yehudakatz.com/2010/07/29/everyone-who-tried-to-convince-me-to-use-vim-was-wrong/).
I don't know about you guys, but my terminal app can do tabbed sessions. What's this about not being able to do both?
ZZ
This needs to be in a book of quotes somewhere. It's poetic!
Textmate and Sublime text both have recordable, replayable macros.
I'm suspicious that you learned vim sufficiently to make such a sweeping statement. Vim may not be for everybody, but what you're saying is flat wrong. What specifically can't you do in vim? If we want to compare personal experiences, my experience has been that great programmers spend most of their time figuring out *what* to type, and very little time actually typing it. It's the programmer, not the tool.
The worst is when you have alljkbcwa bunch of custom key commands.. then even ssh-vim trips you up.jk:wq
You're not weird. Best workflow ever.
I'd use my trackpad and double tap :-)
I confess, I have my doubts as to the ergonomicness of a modifier-based solution. Though I also have AltGr mappings to "edit anywhere", I try to use vimlike plugins wherever possible. In the case of this comment, evil + "edit with emacs" for chrome.
Well, it certainly beats using the arrow keys.
Do you know what gem should one use to do user/password authentication on a sinatra app?
This is great!
Good Luck Dude , I am also learning Ruby on Rails. CHEERS WOrld is for us who try.
You sir have have hit the nail on the head. It's the one thing that people seem to miss when taking about vim.
It would be even better if it dropped rmagick (and replace it with mini_magick for example).
There were quite a few VIM fanatics on my team. Over the past couple years there's been a quiet migration to RubyMine. It's not Visual Studio + Resharper but it's close. 
"A library for making beautiful graphs." Yeah but... http://www.flotcharts.org/flot/examples/tracking/index.html
http://vimgolf.com/
Good news! I don't think it will matter much that you don't have a formal background. Since you are into web, I suggest you give either Rails (Ruby) or Django (Python) a spin. I think Ruby is great for lots of web stuff. Also it has many options beyond just Rails (take [Middleman](http://middlemanapp.com/) for example) for building websites, even static ones. If you haven't seen it, [The Rails Tutorial](http://ruby.railstutorial.org/) is free online and very popular for diving in on Rails. It might be of use to you.
I disagree. That's like saying you'd like to be a writer without learning how to write. It makes no sense. It's like the difference between reading about nunchucks vs actually using them... Most of the best developers I know use either Vim or Emacs. I don't believe this is a coincidence. 
&gt; That's like saying you'd like to be a writer without learning how to write That seems like a faulty analogy to me. A better analogy (imo) would be a writer who prints vs one who writes in cursive. Both put the same words to paper, one just may be faster or easier to edit than the other. Likewise, Vim/Emacs may help you write faster (which is great), but someone who writes in Vim is not going to inherently write better code than someone using SublimeText or RubyMine. We're talking about two different ways of writing the *exact same lines of code*, not knowing how to use Vim does not make you "a writer who can't actually write".
/r/ruby will probably not like this post, but here are some things to consider. PHP is an awful language, but depending on your metro area it could be the one that has the most jobs available. Ruby jobs were *very* rare where I came from (Phoenix), and that's part of the reason I moved to the San Francisco Bay Area. Search on dice.com for various languages and skills and see what comes up. In the Bay Area, novice backend Ruby developers are not in demand. You either need a LOT of experience or significant Java, front-end, mobile, or scaling experience. If I were in your boat I'd focus considerable/most of your attention on JavaScript since you have an HTML/CSS background already and front-end developers/JavaScript "ninjas" are very rare. Depending on where you're from, a lack of a CS background can hurt you. Where I'm from nobody ever asked if I had a degree (i had years of PHP experience instead) but up in the Bay it's a prerequisite for many jobs. 
Why's Poignant Guide to Ruby is interesting, though I would go through a couple of tutorials first to get the basics in hand. 
That makes sense. I am a bit apprehensive about Codecademy because I've often read that similar complaint, plus since the tracks are essentially done by qualified users, that some important things that you might need down the road (even on the same track) get overlooked. Did you find that true as well?
I didn't notice that they overlooked any important concepts, but they kind of hurriedly go over objects and loops and stuff like that, but then again, my first introduction to this was in college and we spent much much longer drilling in these concepts, so my gauge on how much time should be spent on a concept might be a little skewed. I've written less than 100 lines of Ruby outside the context of the class, but I would consider it a decent jumping off point for learning the language. They do cover a lot of the "this is how rubyists do it" things, which is helpful, but for a lot of the stuff, you're just going to have to get your hands dirty and write code yourself. Now, maybe if you're wanting to get a deeper understanding of the programming paradigm, you might want to find a "how to learn to program book" or take CA's programming class to delve a little deeper into the why. 
I tell most people now to learn both at the same time. The reason being, if you sit down with a Ruby Programming Language book for a couple weeks and only do that, it probably won't motivate you as much. If you sit down and follow a Rails tutorial, you've got a better chance of feeling some 'wow, that's neat!' accomplishment faster. This will help push you forward. But, learn both for sure, in parallel is fine. Probably the biggest thing to watch out for when learning Rails is to be aware of extensions it adds to Ruby with its ActiveSupport module. The [guide](http://guides.rubyonrails.org/active_support_core_extensions.html) covers it pretty quickly so it's really not a big deal. At the end of the day, Rails is Ruby, so if you are learning Rails you are learning Ruby =) EDIT: As a side note, if you feel overwhelmed learning with Rails at any point and get frustrated, you can take a break and try a smaller framework, like [Sinatra](http://www.sinatrarb.com/).
That sounds like an approach I could also consider. It's just I want to make sure splitting the time doesn't end up with half-assed knowledge or anything. Any idea how you might structure learning both at the same time? I would imagine something like beginning with basic Ruby, then a few hours later learning Rails or Sinatra, and just repeating that over and again?
You're right, I meant the designing stuff in particular as most of my work from beginning to end was all me, so front end as in the entire process of making a site look good and interact well on the user's end (I just confused what I meant when I replied). I'll definitely look into JS too now. How did you find the learning curve to be when you began? That's another consideration I had when narrowing it down -- I wanted something, of all of them, that has a rather easy learning curve compared to the others (but of course still challenging). Whatever I go with will be my first language, so the easier to grasp, the better. Of course I'm not looking for a quick fix, btw, I just know how I learn.
That makes a lot of sense and is in line with what I've heard about CA. I think I'll try it when I begin Ruby, I'll just have another guide open to guide me through the parts that maybe they missed. I like to get my hands dirty with this stuff, it's very exciting to see something come alive from nothing. And I'll look into the whys of programming as well. If for nothing else than to get my mind prepped for what is about to happen, lol.
do you use some sort of plugin for natural language? ..or were you just using that as an example?
&gt;Vim is the nicest text editor out there. Absolute statements like these are counter productive
I just have omitted IMHO there. Because IMHO is pointless, every sentence I wrote is IMHO. I tried a lot of editors including Sublime and Emacs. For me - vim is the nicest text editor out there. IMHO, so far, as far as I know.
for what its worth using insert mode is considered using Vim badly. You lose all your functionality in insert mode.
If you use a manual loop, there's a 95% chance you're doing it wrong. Ruby's built in iterators (each, etc) are fantastic.
The first one would be (on top of my head) something along the lines of :g/&lt;pattern&gt;/ .-1 d And the second one something like this. :g/^$/d
Looks nice. Any chance there's also a gem for this?
Hah, that is very good advice. Thanks a lot! BTW, I have been looking around more for other opinions just to get a general vibe. I hear Python is the easiest to learn vs Ruby (structurally at least), but that Ruby is generally regarded as the best language for web. Why is that? I know Google was built on Python and sites like Twitter on Ruby, but does it basically boil down to Rails vs Django or is it the speed and abilities of the languages themselves? I figure my main focus will be web-based for sure, so whatever will be best for that is what I'll likely choose, but I can't understand those statements as to why one is [arguably, of course] superior over the other. Many Rails tutorials focus on making a Twitter clone, but I believe Django could do the same and it strikes me odd that I've had a hard time finding that example (but did on Tutsplus).
[Answer](http://www.reddit.com/r/learnprogramming/comments/1jrnrp/ruby_not_sure_what_spec_file_wants_passed_to_it/cbhte1z)!
awesome, I remember using this way back, cool to see it still around!
Code School offers a quick start (15 minutes) "try" Ruby course based on why's guide http://tryruby.org/levels/1/challenges/0
I'll be checking that out, thanks!
Panic!
Don't code like it's Java or C++. Code like it's Ruby.
http://stackoverflow.com/questions/10465839/key-binding-how-to-run-a-external-script-external-command-program-in-sublime Yups you can, it is built-in. You can also do the whole fancy passing in what you are highlighting or the line your cursor is on. 
It'll only seem slightly slower than usual then ;-) (Joke aside, I've been getting about 40KB/sec out of it for years. I wonder if they/we/anyone could officially mirror the main builds on S3 or something in future.)
[You didn't know you needed unite.vim](http://bling.github.io/blog/2013/06/02/unite-dot-vim-the-plugin-you-didnt-know-you-need/)
No, he needs it in case of emergency.
using your mouse is way slower. That time adds up, and is worse on your body
Great post, thanks for sharing :)
Very nice. I've read other "block, prof, lamda" pieces and thought this would just be a rehash, but it finally helped me really understand the difference. :)
Have worked with sequel in several of my rails project, I found it to be much for friendly and lighter than, active records. I will recommend sequel to anyone anyday. 
let me guess "it's like facebook, but...!" ;)
Scrappers are against the Craigslist TOS... Using them will get you banned. Making an app that uses them will get your users banned.
Exactly! Like Facebook, but for squirrels!
Thanks for the reply, you make an interesting point. One might even argue that having to deal with a newbie on top of building and shipping a project from scratch would make a guru less inclined to help out. I just want to have my cake and eat it, and am looking for resources that point to gurus that have said that they are looking for that kind of challenge. Still, the guru would talk to me before making any kind of commitment. If I present a fully fleshed out idea, along with the completed market research that I've done and how the idea fills a real need, then it's not quite the same as making a gamble with an unknown quantity. I'm perfectly happy to code it on my own over a number of years, or to find funding and hire a guru instead, but like I said, I want to have my cake and eat it. And as to your last point: although that's true - 9 out of 10 companies fail in the first year, and 9 out of 10 of those that make it past the first year don't make it to 10 years - it's also a very misleading statement. Almost every billion dollar company was started by a person or collection of people who were on their third, seventh, tenth business. They just had the grit to keep going. Those businesses that failed were just practice runs for the main event. So although statistically most businesses fail, they are only really there to serve as the foundations for the businesses that succeed - the main event businesses. I'm not saying that my idea is going to be a home run. I'm just saying that it'll be a far more interesting path to walk than what the 9-5 zombies are walking. In my opinion :P
Sweet! Where do you work? I wanna freeload on your stuff too.
That must be frustrating. But in some ways, it's better hiring the right person and then training them than hiring someone with the right skills who doesn't click with the company.
Well shit man! Nutbook changes everything! When do I invest?
I've never contributed to any open source before, I'm not sure where I would start. Any ideas for projects on Github that might be a fit for someone relatively inexperienced?
Thanks! Any ideas for projects where I could get started?
I think Code School has an Objective-C course, I'll check it out :)
We've had pretty good luck with that approach. It's not ideal but so far everyone we've gambled on has panned out. 
Sorry, I misspelled 'prostitutes'. Same company name though.
time to start learning to code then
http://stackoverflow.com/questions/43649/how-to-get-involved-in-an-open-source-project
It's short and sweet. I like it!
+1 - would love to see a community-backed s3/cloudfront mirror of ruby. As @sferik pointed out [here](https://github.com/ruby/www.ruby-lang.org/issues/259#issuecomment-22202131), there is a semi-official cloudfront mirror by 37signals, used for ruby-build. You can find a set of ruby md5 sums [here](https://github.com/postmodern/ruby-install/blob/master/share/ruby-install/ruby/md5.txt). But for example all 2.0 releases don't seem to be available on that mirror :(
Maybe I'm missunderstanding the authors point, but: _"I would not expect that calling #reverse on my custom Array would change its class."_ ....would *anyone* _really_ expect inheriting from a class to affect the return type of its superclass methods? Similarly the DNA example...why would anyone expect a string operator to call the superclasses constructor? This is a VERY VERY confused article... (p.s. I'm sure I've written worse)
May I be blunt? A "guru" isn't what you need. What you need is a business plan. The *fact* that you have come here first looking for a "guru" tells us "gurus" to stay the hell clear. Put together a clear business plan and you might interest someone, you may even obtain the interest of business angels/mentors to help you along the way. Without it though the best you can hope for is someone who will help you prototype something and learn along the way.
&gt; ....would anyone really expect inheriting from a class to affect the return type of its superclass methods? In cases like this, absolutely. I would expect `#reverse` to return an object of the same type as the receiver. They are not, from the point of view of the caller, "its superclass methods". They are being called on the object itself. It is an implementation detail that they dispatch to the superclass. Returning an object with a different type from the receiver breaks the abstraction by leaking its implementation. It should be guaranteed not to happen and one can do things like `self.class.new` in your own classes to ensure it. Explicitly referencing your own class by name (esp. in a super-class) is wrong *because* it breaks subclassing in this way. Edit: Also, up until 1.9.3, `#reverse` *did* return an object of the receiver's class. https://github.com/rubyspec/rubyspec/blob/master/core/array/reverse_spec.rb
I agree. I don't get why the author would expect to get a `List` back after calling `to_a` in the first example. I would be very confused if I call `to_a` and get anything other than an `Array`. This is class inheritance, not generic templating.
I agree with you about the `#to_a` case because its contract is "returns an `Array`".
How is that different from other class methods? If you're inheriting the reverse method, and the reverse method returns an array... By what magic would one possibly expect it to return some other type of object? I can't even begin to imagine how that interpretive monstrosity would look. 
It doesn't require any magic at all. It just requires Liskov-substitutability and dynamic access to `self.class`, both of which Ruby has. See http://www.reddit.com/r/ruby/comments/1jvsz0/beware_subclassing_ruby_core_classes/cbiubks Do you realize that up until 1.9.3, `#reverse` *did* return an object of the receiver's class? And has again since 2.0? https://github.com/rubyspec/rubyspec/blob/master/core/array/reverse_spec.rb
&gt; In that case, reopen the parent, add a to_blahblahblah method, and call that on #reverse. Absolutely not. This is exactly the opposite of what you should do! Now you're violating LSP *and* Open/Close *and* Dependency Inversion! Now you've only got two SOLID principles left... and I think I could make an argument that you're violating SRP too! &gt; Having the parent class return objects of the child class type *This is not what is happening*. The fact that the method is eventually dispatched to a parent class is an *implementation detail* that should be hidden by the inheritance abstraction! All it requires is dynamic use of `self.class` instead of hard-coding the name of the class! One could make a cogent argument that *this is why `self.class` exists* in the first place. &gt; just think of the number of bugs it would cause, how slow that would make some basic operations (and Ruby is slow enough, thankyou), the memory bloat.... Show me exactly how it would cause bugs or performance problems, because it does not. Again, the behavior I'm suggesting *was the actual behavior of Ruby* up until 1.9.3 and *is the current behavior of Ruby* as of 2.0!
Because the pre- and post- 1.9.3 behavior is correct. The 1.9.3 behavior is a bug.
P.S. You've demonstrated I was wrong on the reverse example, what about the Dna constructor?
I think inheriting Dna from String is wrong for a different reason that, for me, supersedes arguments based on implementation details of a given Ruby runtime. When Dna inherits String, Dna inherits *all* the behavior from String even though only *one* behavior (`#tr`) is actually needed, and that behavior is contingent on storing the sequence as a String. It's a violation of SRP. It also doesn't make sense semantically: Dna is not a kind of String. It can be represented as a String for some use cases, but inheritance implies a false equivalence. Nor does it makes sense to pass a Dna object in places where you would normally pass a String (that's LSP again). Also, a String is just one way to store the data that should be encapsulated by a Dna object. A [rope](http://en.wikipedia.org/wiki/Rope_\(data_structure\)) is probably more appropriate for many use cases given the size of most genomes. So, inheriting from String couples the implementation of Dna to the String as its data structure, implies a semantic equivalence that does not exist, implies a parent/child relationship that does not exist, implies that Dna has responsibilities and behaviors that are nonsensical (how do you upcase a dna? What behavior of actual DNA does `dna.gsub 'A', 'This is not a valid nucleotide!'` model?), and thus spends the scarce resource of single inheritance unwisely and for negative benefit.
Thanks for your reply, but can't I have both? Couldn't a veteran help me put together a better business plan if we can talk through my idea and make it 'our' idea? Why does looking for a veteran coder tell a veteran to stay clear? If someone needs the help of someone more experienced, shouldn't he ask for it? How else would people know what he's looking for? I wouldn't ever be looking for a handout, or to do any less work than the other guy. Neither would I ask anyone to jump on board with a half-baked idea. I do my due diligence. I could understand anyone telling me to push off if I said "Hey, wanna build this for me for free, lol?", but that wouldn't be the case. I would be saying "Hey, I've got this idea and I have these skills, here's what I've got so far, here's the market gap and how I plan to fill it, but I need help with this part. What do you think, can we build something awesome together?" That's how start-ups happen. One guy has one set of skills, another guy has another. They share a vision, team up and work together to bring that vision to life. It seems that the coders I speak to are invariably more interested in building something that is fun and challenging and makes a difference than they are about making a lot of money. I mean how much awesome stuff has been coming out for years now for absolutely free? The guys that built it seem to mostly have done it out of curiosity, to make their own lives easier as well as other people's, or just for fun. Heck, the open-source community do it everyday. So my thought process is that if I come across a veteran coder who is looking for something new, and I present him/her with a compelling idea, is it really so far-fetched that they might say "Why not?"? What I'm really looking for with my post is just a place where such coders might congregate while looking for the next thing that they might want to build. Then I can talk to them. And other people in my boat can read this post and then go there as well.
Everyones different, some people might be interested, sure. IMO, without a business plan you will come across as ill-prepared and you are not putting yourself in the strongest position for a discussion with any potential _partner_ and a lot of the people you want to attract will immediately place you in the "guy with the next facebook" category. Seriously, if its a good idea, find ways to *sell* it and you will attract the people you want.
No worries! I get shit wrong on an minutely basis. It's not a big deal. &lt;3
I have to wonder whether or not this behavior is found in implementations like Rubinius that try and write Ruby in Ruby as much as possible, and avoid dropping down into lower level languages.
lol I hope you never review anything I write (for self esteem reasons). Your reply reminded me of this post: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ 
I am happy to be gentle with beginners because I do not want to scare them away, and because making mistakes is how people learn. I also try to be sensitive to how much ego investment people have into their work and I try to adapt my critiques to their ability to accept criticism. I think a survey of my github PR comments would convince you that I do not breathe fire *all* the time. With that said, OP's article was posted on the technical blog of a professional software development consultancy by someone who appears to self-identify as a professional software developer and who has put themselves in the role of trying to instruct others. I hold educators to a very high standard and I would not want a beginner to come away from this post with the idea that this code is exemplary when I think it is *deeply* flawed. I admit that my remarks were somewhat harsh but I hope they make sense in context. Edit: Also that PHP post is wonderful but I would replace "concise" with "expressive" in his list of desirable language properties. It's a subtle distinction but, I think, an important one.
Ubuntu 10.04 was EOL april 2013.. so basing your system on that seems... flawed..
thanks for taking the time to outline the struggles inherent in this undertaking. I'm afraid i'm not your target audience for this project, because we've got passenger installation automated with our configuration management software
That thought will give pause to a *lot* of folk considering new projects in Rails. Yeah, having one tool that can do all that for you feels great. But, like many things in life, it can do as much *to* you as *for* you… an idea I am much more personally familiar with now than a year ago. Good points. 
Python provides a set of wrapper classes that can be inherited from to leverage the functionality of core classes: UserString, UserList, UserDict etc
10.04 Server is EOL in 2015. https://wiki.ubuntu.com/Releases
great!
Agreed.
So funny that this was posted... I'm just starting out and spent all day yesterday trying to grasp the differences. so thanks. 
Yea the Code School course is a good start but the key is to just write and app and get it in the store. Once you have an app in the store recruiters swarm you like sharks, idk its just so hot right now.
No, because that post was just the front page of the blog, so the dupe detector didn't find it.
Yeah, I've tried bootstrap before and really enjoyed it, and Zurb's foundation is pretty awesome too. I'd really like to start getting more and more of my app to be client side. Angular looks pretty powerful, any special reasons why you'd recommend it over say Backbone or Ember?
Thanks for the reply, those things hadn't even crossed my mind, I'll definitely look into them.
Thanks!
So, you're just going to leave it here? :) Two posts, that are exactly the same, posted a couple of days apart....
They won't be the same the next time the blog gets an update.
These are great comments, ReinH. Agree with you on all points - the presentation you provide is outstanding. Just started learning Ruby 9wks ago, and was doing a quick and simple implementation of a LinkedList in Ruby for my fellow classmates @ the Flatiron School in NYC. Appreciate you looking through the post!
BTW I always enjoy it when people explain basic CS concepts in Ruby. I think it's a great pedagogic language. &lt;3
Another nice link about this is Dissecting a Ruby Block by Pat Shaughnessy from RubyConf 2012: http://confreaks.com/videos/1286-rubyconf2012-dissecting-a-ruby-block It goes a little into ruby internals (C-based implementation of blocks vs lambdas), but it's definitely worth watching for a deeper understanding of blocks.
&gt; The (lambda) notation is a reminder that while procs and *blocks* are very similar, even both instances of the Proc class, they are also slightly different. *lambdas The explanation about what return does could have been a bit clearer. In other words, return inside a lamda returns from the lambda only, and program execute resumes from where the lambda was called, while return inside a proc not only returns from the proc but also returns from the method that called the proc; it's like return-squared. Which is more commonly used in Ruby, lambas or procs?
It doesn't actually return from the method that called the proc, it returns from the context where the proc was defined. I think procs are more common than lambdas, esp if you take into account 'blocks' (which have the same semantics as procs)
This is great. 
Very nice article and answered a burning question for me, but this bit on the end is confusing: &gt;Proc is short for procedure, which is a set of instructions packaged as a unit to perform a specific task. In different languages these may be called functions, routines, methods, or the generic term callable units. They are usually made to be called multiple times and from multiple times in a program. So when would I use a Proc/lambda vs a standard function?
Very cool! My company's internal wiki is going to be hosting a bit of extra software come Monday.
Something similar I found a while back: http://ascii.io/
http://rubygems.org/search?utf8=%E2%9C%93&amp;query=flot
We increment our passenger deployments via apt/dpkg. 
Why isn't showing the log enough? Not criticizing, just curious.
Ember and backbone are plenty awesome, just haven't used them.
Neat idea - does it handle cursor control for text-based applications like vim?
This is amazing. Thanks for posting..... 
"‘return’ inside of a proc triggers the code outside of the method where the proc **is being executed**" So the blog is wrong. How helpful.
He can make a living by supporting his free product much like apache does. 
You can also just use [resque-pool](https://github.com/nevans/resque-pool) to get all of your jobs in a yaml file as well as manage all of your workers.
Here a supplementary blog. It's an oldie that really cleared it up for me. http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/
This is one of the best examples of providing constructive criticism. Not only did Vasilly solve the problem for the user, he also generously pointed out in a full-length blog post his error, and then showcased it to the rest of the world. This is a win on almost every level.
pushws and popws are only defined in IRB. In fact, these methods appear to be added as singleton methods to objects when they become an IRb "workspace". &gt;&gt; method(:pushws).owner =&gt; #&lt;Class:#&lt;Object:0x000000025346c8&gt;&gt; &gt;&gt; class &lt;&lt;self; def hello; puts "hi"; end; end =&gt; nil &gt;&gt; method(:hello).owner =&gt; #&lt;Class:#&lt;Object:0x000000025346c8&gt;&gt; &gt;&gt; hello hi =&gt; nil
I don't use IRB, is there an equivalent for `pry`?
In pry, you can use 'cd' to go into an object, just like how you would navigate the file system on the command line.
Key bindings in sublime text are just files too, so you can actually do the exact same thing. Only caveat is that they live inside the installation folder, rather than at ~/
Having met matz before at rubycon, I can say he's a very humble guy who more than anything is in awe of what his project has done. If you get a chance to meet him take it. He's a really nice, intelligent guy. On the other hand, I don't need people who propagate fairy tales and bullshit to corroborate this. I find it insulting that religion is trying to ride on his coat tails.
This is what Mormons do. It is a core of their faith to proselytize, and they have fully embraced the internet in this regard. 
It was his own decision to be part of this campaign. Obviously to him it's not fairy tales. So nothing bad there.
skepticalMartian did not 'get about it' as you portray his post. He just mentioned that he, like most people, don't need folks propagating fairy tales and BS. If you dis-agree with his perspective that's fine. Maybe there are people who like folks propagating fairy tales and BS :) Exaggeration, Mis-characterization etc don't really add value.
Oh, I'm not mad at him. I just think religion has a way of trying to take credit for things where it shouldn't. It's interesting that in their "bigger campaign" everyone is a successful well adjusted person with some enviable virtue or trait that sets them apart. It's a lot like a product review where anything that could be seen as negative had been carefully deleted. Apparently the Mormon church is only comprised of the best of humanity.
I agree that religion shouldn't take credit for things that are unrelated. I however don't think this is what this ad was trying to do. The campaign is about showing Mormons as normal everyday people. If you felt that the ad's intentions were otherwise then the Mormon church needs to work harder on its advertising campaign.
I think he meant that church propaganda is not a normal way of finding out about inventors of technology. Whether the church is good or bad.
so, out of all the "normal everyday people" to choose from, they selected a notable programming celebrity.
Unfortunately this is hard to fix in Ruby because of features like eval and Proc#binding
And Larry Wall, creator of Perl, and in Matz's own words his "hero, actually" belongs to the Church of the Nazarene. It's far between religious programmers. I find it refreshing.
As much as I love Ruby, I'm not sure it was particularly "designed" as much as cobbled together. It took the same route as Perl, copied elements from it, and then copied various features Matz thought were cool from other languages and Unix utilities. There are plenty of wtf's in Ruby.
The "more than one way to do things" philosophy may lead to some wtf's, but it's also a conscious design choice. I happen to like this "craziness" of Ruby. If you want more rigidity, Python has it. On the other hand, Ruby's object model -- yet another conscious design choice -- is arguably more rigid than Python's. "Cobbled together" is not the phrase I would use to describe it. 
I agree. The Thinkpad was much more shocking to me.
What large, organized grouping of people *doesn't* take credit for it's constituents' accomplishments? We're all taught Ben Franklin was a "great American", for instance. Did his Americanness have anything to do with his genius? Humans are just tribal at bottom. With most organizations this kind of taking credit happens naturally, but with something as reviled as Mormonism they need a P.R. campaign.
I happen to agree. The Book of Mormon is a bit... wild. See the musical instead!
Nice post! Thanks!
I agree, ruby pays the bills here and matz played a big part in that. I owe him my respect. My respect for the Mormon church on the other hand dropped by several orders of magnitude.
With the assumption that you have basic programming skills, I find "Teach yourself scheme in fixnum days" book really useful (its free: http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html) I also like "Realm of Racket", just out on the stores and very fun! If you are a heavy technical person, the specification for Scheme is about 30 pages and very clear, but I prefer other learning systems :)
this is not the time for rational inquiry
There are lots of "I'm a mormon" videos out there that do chronicle normal every day people such as moms raising kids and some dude that likes to paint and such. Judging by your reaction to this though I doubt you care to watch any of them. This is just the only one you have heard of so it makes sense that you think they only selected notable people. But the fact is there are LOTS of these videos and most of them are about fairly normal people.
Agreed. Ruby borrows (steals?) the best parts of Perl, Smalltalk, and Lisp, and creates a coherent whole (show me a wtf-less language and I will show you a language no one uses). Python, on the other hand, has plenty of rigidity but the places where conflicting philosophies meet are ugly as hell; it's a procedural language with object orientation tacked on, and the bolts are clearly showing.
But what should he use? Am I missing something?
Anyway Mats seems a nice guy :)
I'm going to go ahead and assume they're from the die-hard mac camp. To them, using anything else is somehow wrong.
Here comes /r/atheism! Remember guys, keep religious arguments in /r/DebateReligion, not here. Everyone is entitled to believe what they want to believe, hence freedom.
Agreed. These men did greater things that the typical /r/atheism redditor so whatever they say I just don't care. I'm a Baha'i and typically I keep it to myself, but it does help me cope with the stresses that coding brings sometimes. I won't go into details, but I can see why Matz would become a Mormon. Sometimes you just need to be a part of something larger than yourself (or your language in this case).
I can only speak for myself, but my answer was meant as a joke. There's nothing wrong at all with Matz using a Thinkpad, it's just... shocking. Much the same as there's nothing wrong with Matz being a mormon, it's just, well you know.
He agreed and wanted to be part of this campaign. There was no 'exploitation'.. sheesh.
Yeah, why on EARTH would a programmer use a computer?! That's just shocking!
A little ashamed of how long it took me to figure out I could turn on English subtitles.
self pic of SkepticalMartian: http://i.imgur.com/nxcKA9B.jpg
So, people who are abused and financially bled by Scientology are also not exploited, right? I mean, they agreed to it.
Seriously, dude, why go there? Not every atheist feels the need to threadjack every discussion even tangentially related to religion -- particularly when the submitter added an explicit caveat to the thread title. I mean, I certainly don't. Your first paragraph I wholly agree with.
The giant parfait at 2:46 pleased me far more than it should have.
Ask a Hawaiian native.
The submitter *added* the caveat. That means if you watch the video you need to watch it within its' context. There is nothing surprising here. Obviously the LDS church has an agenda behind making this video. We all have an agenda. You obviously have an anti religious agenda which you're pushing. Again, if an LDS church member had posted a link to the video on this subreddit, *without* mentioning that it was a religious piece, then I would be on your side. This is not the case.
Don't be surprised by people hating on the LDS church and anything that can be remotely connected to it. I'm not mormon, but go to school in Utah, and I can't tell you the number of bigots assuming that because I live in Utah, I must be Mormon, and therefore, must be stupid
Not every atheist, but every ratheist does. I know how to get rid of him though, mention /u/jij
I love that quote. Steve Yegge's blog posts are excellent fodder for use against the "durr python master race" crowd
We /r/atheism people prefer python ;)
There are [plenty of people](http://en.wikipedia.org/wiki/List_of_atheists_in_science_and_technology) who [have done things](http://en.wikipedia.org/wiki/List_of_agnostics) which have had an arguably more profound impact on mankind without subscribing to a religion (go ahead and count the number of times you see "nobel prize" in those lists), so I'm wondering what you think this proves.
GIDSWAD explains a lot about the atheismrebooted crowd…
But can they explain... fucking magnets, how do they work?
I'm an Episcopalian, and (I'd like to think) an accomplished developer. I really see no relation between the two, other than a general live-and-let-live, non-judgemental philosophy at the set intersection. No, wait, that's just my religion. I harshly judge emacs users and Windows programmers, what am I saying?
Is it read only, or can it make changes to the psd? (I'm looking to insert a new layer with a note. )
No, that's not what I meant. They are free to believe or not believe, but the majority of religious arguments are started by atheists. This is /r/ruby, not /r/atheism o /r/DebateReligion. Just look at the threads here saying that Matz is no longer respectable because he's Mormon. That's crazy...
Really? This is dumb. Agree or disagree, Ruby is one of the best languages out there (and it's fun as hell) so why hate on a language because the creator is mormon?
Most of the time you'll also want to check File.readable? or File.writable? (with File.file?) In order to perform either of these operations you need execute permission on the parent directory. And if you're writing to a new file you'll need both write and execute permission on the parent directory (on a Unixy OS).
I love Ruby and will continue to advocate its usage. It's my favorite language. Morminism is bad news though. I felt a little dissapointed.
FWIW, in the Unix world, directories are considered to be (special kinds of) files. In fact, ["everything is a file"](http://en.wikipedia.org/wiki/Everything_is_a_file).
Why does one's personal, private, faith bother you? Besides this video did you even know he was LDS? My fiancee is former LDS and she loves to put the church down, but every time she does I want to remind her that it was her choice to leave, and it's everyone else's choice to stay. Looking down on them for that is very immature, and if you want to put it in another perspective, how do you feel when LDS members look down their nose at you for leaving? Sucks, doesn't it. Take the higher road, ignore his faith, and enjoy Ruby for what it is.
I wish I truly understood that Rails != Ruby. My introduction to Ruby was through Rails and I'm grateful for that BUT Rails just happens to be the most highly "marketed" piece of Ruby software out there. The ruby language itself is really cool and it can be used for all kinds of different things. System administration, data scraping, FUN, coding gui interfaces in visual basic, etc... Additionally there are a lot of alternatives to Rails. One I particularly like is [padrino](http://www.padrinorb.com/) (built on Sinatra). I guess my point is that I wish I had known that the Ruby ecosystem is huge and taken time to explore it earlier. There's a ton of cool patterns and things to learn from other people's code. :) 
What is wrong with checking for nils? 
It's often seen as a violation of "don't ask, tell." The assertion is that your methods should be confidently passing messages to to their associated objects, instead of timidly error checking. I find code does usually read cleaner when there's less nil checking. That being said, sometimes going too far out of your way to avoid it can contort the code into something worse.
Linux is less painful when setting up OSS like Ruby, but it is certainly supported, especially for development. However, I would strongly recommend against using Windows as a production server. You will have a better time using an IDE like JetBrains or IntelliJ, where the IDE uses JRuby and the whole toolchain is integrated.
Unfortunately those methods do not work well with ACLs. I thought I was clever by making gcc executable-only by users in the compiler group (for increased security). It broke the installation of gems with native extensions. Turns out mkmf checks whether gcc is usable by checking whether it is `File.executable?`, which only checks the normal Unix permissions but not the ACLs...
I don't agree with choosing `x.between?(1, 6)` over `x &gt; 0 &amp;&amp; x &lt; 7`. I would never be able to remember whether the parameters of `between?` are included or excluded.
Ruby provides File.ftype to identify, more generally, the type of file.
As long as you set up ruby with RubyInstaller and set up the development kit for building gems, you should have very little trouble (if any) in Windows. The only problem you might face is that some webservers (like Unicorn if I remember correctly) do not support Windows, although there are many alternatives. 
If you have not been a part of the church, it is very difficult to articulate the impact it has on your life. It can quite literally lead to years of therapy and mental instability. 
I'm a former alter boy. Let's talk about ruined childhoods....
Scientology and Mormonism couldn't be more different. This argument is a bit silly. "They were both made around the same time, so they are the same thing." And in reality they weren't. Mormonism was created 200 years ago.
Its a bit slow compare to running the same application on a Linux machine. 
If you're going to work in windows, I'd recommend using Cygwin as a shell.
In an exclusive range only the end is actually excluded - `(0...7).cover?(0) # =&gt; true`. That said using ranges instead of `between?` is not a bad idea and I've seen it from time to time in the wild.
Yes. I can't remember when I needed a doubly-exclusive range though, so it's not as big of an obstacle.
This. Exactly this. I went through the entirety of his tutorial and while I think I learnt a fair amount about making software, such as the existence of tests and version control I absolutely came away with no real understanding of how to do anything he had said on my own.
Listen, I was never really an alter boy. I don't give two shits about your experience with Mormonism, or his, or anybody else. My problem is that people are turning on Matz because he's a Mormon and that's about the dumbest thing I ever heard. It's like hating on Chick-fil-a because the owner has his views against gay marriage. The chicken is fucking delicious. You can't taste bigotry! I just get annoyed at people who feel like the have to hate on Matz now because he has a faith. That's stupid.
In many cases, "~&gt; x.x" is far more desirable than "~&gt; x.x.x". If the gem in question follows semantic versioning, you'll get far fewer dependency conflicts that way. Personally, dependency conflicts annoy me far more than occasional breakage because someone didn't strictly follow semantic versioning.
I'm of the opinion this is unnecessary. Gemfile.lock already makes sure the gems are locked down to a specific version. If I, or someone, want to run "bundle update" then it's on them to make sure the tests pass, and their code passes code review. Providing pessimistic operators in Gemfile can be seen as defensive programming. I just haven't seen a situation where not adding pessimistic, or other, operators caused a problem on a project.
You might want to state those reasons so you can hear counterpoints and rightfully compare all the pros and cons. Windows and Ruby will technically work together but they're not the friendliest of bedfellows. I use Ruby on Windows, Linux and OSX almost daily and for Windows it's just a more painful experience overall. I wouldn't willingly choose to use Windows for general development for anything except .Net work (I'm driving IE integration testing with Ruby/RSpec/Capybara, so it's at least minimized for me). Need to change your environment path persistently? Have fun pounding away at your GUI. Want to create aliases and macros for commands? Now you're writing batch files and custom command prompt shortcuts. Need to copy and paste from the command prompt? Oh, you're only two clicks away. Tab completion of commands for discoverability of command features? Pretty much out of the question. Want to keep Guard running while you code? Now you've got an entirely separate window constantly running instead of backgroundable with tmux/screen. External dependencies like ImageMagick, Qt, Memcached, Redis, Node? Go chase down some installers instead of the super convenient and upgradable package managers everywhere else (Chocolately barely even compares). You're probably using git; git's totally not built with Windows in mind, have fun with that impedance mismatch (they actually ship Bash with Git for Windows). Need to change ruby versions all the sudden? Relaunch that command prompt. Want to run ruby 1.9 in command prompt A but 2.0 in command prompt B simultaneously? Good luck sir. Pik kinda does this stuff, but it's not wholley the same as RBenv/RVM workflows. Multiple users for the system with their own separate rubies (common setup on linux)? I don't even... Want to mirror your production setup to your dev environment exactly? I've literally never heard of a production Ruby server running on a Windows host. Basically, the Ruby ecosystem has a built up tons of command-line oriented features and leans heavily on Unix principles and Windows is just terribly deficient at command line work. These deficiencies pretty much forces you into using an IDE for anything non-trivial because a giant IDE is less painful than trying to use the Windows OS itself for those tasks. Whereas *nix OSs provide a lot of powerful command line features and you can mostly get away with using an editor instead of an IDE.
Better is `~&gt; x.y, &gt;= x.y.z`. I filed a bug: https://github.com/joonty/pessimize/issues/8
Just out of curiosity--what have you tried next and have you had any success? I took a brief detour from Rails while I got another Wordpress project live, but plan on finishing the tutorial and then finding another one, or possibly doing a short Sinatra tutorial to see if I want to go that route with my focus.
I tried Ruby on Windows a few weeks ago and ran into quite a few issues with an existing project - eventmachine (which is a dependency of quite a few gems), sqlite3, rails (~3.2.3?), sass-rails (possibly a few other gems) all had issues. Whilst it is possible to work around the issues, I came to the conclusion that Windows is essentially "not supported". I know you say "not rails", I found issues with webrick and sinatra serving lots of (coffeescript) files which was trivially fixed by moving to thin. If I had come across the problem under windows and not been able to quickly switch webservers (thin depends on eventmachine) that would have been a real head scratcher. I'd recommend dual booting or a remote host but at a pinch you could run a VM (e.g. vagrant).
Interestingly, the `to_s.chars.map! &amp;:to_i` solution pulls ahead speedwise the more digits there are in the number: https://gist.github.com/havenwood/6245044
Agreed, good point.
just to make sure it's clear... i didn't author this gem.. just thought it was cool. the author is Jonathan Cairns (http://joncairns.com/) 
It isn't recommended to checkin the `Gemfile.lock` file when working on a rubygem (see http://yehudakatz.com/2010/12/16/clarifying-the-roles-of-the-gemspec-and-gemfile/ ). For applications, this is less of an issue. However, could still be useful if you want to upgrade your gems (with `bundle update`), but only for minor versions (eg 1.2.3 to 1.2.5, but not 2.3 to 2.4). You could do this by running `pessimize`, then `bundle update`, `git checkout Gemfile`, then finally `bundle install`. It would be nice if bundler had an option to do this, eg `bundle update --minor`, but it doesn't to the best of my knowledge.
I can't replicate your warning, but you can configure inspections in File &gt; Preferences &gt; Project settings &gt; Inspections (this is on mac, not sure where preferences are on pc) There you can select what you want to be warned about and what you don't want.
As an atheist, I couldn't give a shit about what religion Matz subscribes to. Or anyone for that matter. Matz is a clever, good person. That's all that matters.
Ah, but that's the other problem. The inspection that triggers this warning is the "Unresolved ruby reference" one, something that is very useful in any other context. I don't want to outright kill that, just have it not complain when I read in a config file. What about this conffile = YAML.load(File.read('config.yml')) It then highlights the "config.yml" with the "implicit required file" warning. 
Maybe it just doesn't know where config.yml is located. Specifying a full path might not be an option as you say, but you should be able to specify the path relative to the directory in which the line of code resides, e.g.: conffile = YAML.load( File.expand_path('config.yml', File.dirname(__FILE__)) ) (assuming config.yml is in the same directory as the current file.)
That works for that particular line, but then when I try to parse the conffile variable (which now contains a hash) with something else, say another module, the warning appears at that point. My end goal here was to load up the config file, iterate through a plugins section in it, and require all of the files returned.
No, it's not deep or complex unless you want to get in to the levels of deception people use. It's a way of making up things and attempting to convince others that it's true by means of trickery and broken arguments.
I've just gotten used to seeing it and ignore it. Not ideal, also not the most annoying thing about RubyMine.
I've only gotten this when dynamically requiring something: file = 'my_thing' require_relative "#{file}" I agree it's kinda dumb on RM's part, but I've just disregarded it. If it bugs you enough, you might log an issue with JetBrains...
A critique on the essay itself, not the overall message. The conclusion raises points that are not covered or supported by the preceding essay. There is a sloppiness in failing to support claims made across the article. Yes, the title implies that it's an opinion piece, but the entire body of the essay purports to provide absolute facts. Overall it boils down to this: Rails is the bandwagon where the smart people are, so jump on that bandwagon and save yourself some effort. My addendum: there will be newer bandwagons in the future, so don't get overly attached to any of them. That said, Rails is good.
Please use [Cinch IRC Library](https://github.com/cinchrb/cinch/) to build off of. "gem install cinch" It's not for logging. It not for auto voicing. It's just for talking. Feel free to add to it and I will merge as quickly as I can :) Sorry if this seems spamish, just trying to get a new project out there. I believe together we can build something awesome!
I think it's a little more than just a "bandwagon". It's an intelligent way to deal with a specific problem. It could be argued (as you have) that smart people work on rails because other smart people work on rails - but it's just as easy to say smart people work on rails because it does the job it's supposed to do. I'm sure the ordinal properties of chickens and eggs will come in to this at some point. That said, opinions on the subject of rails and its overall quality are going to vary wildly depending on who you're talking to. I would agree that Rails does what it intends to do well enough to consider it a viable solution if you have a problem that Rails solves.
I use the term bandwagon to indicate that Rails usage has reached a critical mass. Virtually every problem I've needed to solve has already been solved by someone else. StackOverflow code snippets or Gems are generally available, so there's a demonstrable bonus effect to the bandwagon rather than just being cool. I'm still not sold on Rails apps as being maintainable longterm, but it's certainly fantastic to start projects with. Agree with your well-put statements.
Funny you should say sloppy, that's how most RoR code I've worked with could be described as well and the reason I avoid it (for now). 
I think code organization is what really helps with long term maintainability. So long as one keeps strong practices and a solid test base, whatever tool they use should be able to last a while.
Damn it I just learned Cinch :P I'll be sure to check it out :D
Speaking mostly about Ruby, funny is the article titled with Rails.
That explains the downvotes I guess.
I've been learning Rails slowly over a few months now and if I'm honest - I don't like it. Ruby, fine I'm sold. Rack/Sinatra? Yup, great stuff. Rails though has a massive learning curve and as I've climbed up it I've found that I'm throwning more and more of the "conventions" away e.g. I've stuck with ActiveRecord to avoid problems but would seriously prefer to replace it with datamapper; Scaffolds quickly got abandoned; erb got replaced with Haml+Coffeescript; Fixtures get replaced with factory girl; Unit::Test gets replaced with rspec.... That all these things *can* get replaced is a wonderful thing of course but to a certain extent I can't help but feel that Rails as a framework is now only rolling from momentum and we would be better served by something which said "Hey, Rails was great but we can do things better"...
www.imgur.com/YXtdG4U
Sorry, whats the point of your circlejerk here? The only languages without examples of bad code are the ones nobody uses.
First came the "I am a Scientologist" videos. Then the "I am a Mormon" videos. Birds of a feather...
&gt; Rails though has a massive learning curve and as I've climbed up it I've found that I'm throwning more and more of the "conventions" away […] Things you've listed aren't really conventions (maybe that's why you wrote "conventions"). They're just tools that help you with some design patterns or other concepts. RSpec instead of Unit::Test? Cool, I use that, too. Scaffolds? Yeah, generators usually create too much unnecessary code. Erb? C'mon, Haml is much better. Factories? I prefer them over fixtures, too. I don't think Rails is "rolling from momentum". You still use in your project that gigantic codebase that sits behind Rails magic. It's not that you throw away some parts of Rails, you just use other tools. Rails still evolve, new ideas are merged into the main branch and so on. Four years ago Rails was (were?) good and now they're even better. I've actually just picked up Rails again after a two years long break and they still give me the same amount of joy.
Strictly speaking, no they are not conventions in the rails sense...but many resources (especially online and those for the newcomer) will present and refer to them as such and I've found myself often digging for the "right" way to do things (which of course there isn't always an answer for). Maybe its just the case that introductory texts need be a little more honest about Rails shortcomings and the alternatives, maybe that way I would have enjoyed learning Rails more, and maybe as my familiarity grows I'll start to feel some of this "joy" which people talk about :)
So I'm not totally crazy :) Opened a ticket with JB, and they immediately called it a bug and opened a ticket on their tracker, so here's hoping! http://youtrack.jetbrains.com/issue/RUBY-14096
Not sure why "having defaults" is a point of criticism.
Downvoted for "circlejerk" out of principle, but yeah, this.
&gt;It's like hating on Chick-fil-a because the owner has his views against gay marriage. Actually, the problem with the Chik-fil-a owner isn't that he has his views (he's allowed to be as much of a bigoted piece of shit he wants to be), it's that he uses proceeds from the stores to contribute to groups which push discredited, anti scientific, homophobic "conversion therapy". Actions, not beliefs, in other words. Hope you know what that delicious chicken is helping to pay for...
If youre going to have defaults, have good ones because they do the job well. Part of my criticism is that Rails has a steep learning curve, it doesn't have to be made steeper by learning what parts of the Rails ecosystem have arisen to address shortcomings in the basic Rails offerings.
The reason this works is because you're defining the method where it wasn't defined before. If you hadn't defined - or + on your new classes to begin with, Ruby wouldn't know what to do and you'd get a crash. Ruby doesn't support method overloading in the traditional sense because you can't actually call the method a different way or with a different set of parameters. When you redefine a method, the old method is gone unless you aliased it. In Java I can define doSomething(string myString) and doSomething(int myInt) and that would be an overloaded method because they differ in input types.
Just to be clear, you would contend that the defaults were a *little* better in the case that HAML was the out-of-box templating language? Is it that there's a default templating language at all? I think that might steepen the learning curve.
&gt; I'm still not sold on Rails apps as being maintainable longterm I am, and I'll tell you why. I've taken over the codebases of a dozen or so web apps in my career, and the homegrown apps have always been much harder to figure out and upgrade than any rails app. The rails apps are typically in poor shape, but relative to the non rails apps, they are a pleasure. 
I disagree, but I gave you an upvote. I disagree because most code I've inherited from other teams/people is sloppy. The question is whether or not rails code bases are better than the non rails code bases, and in my experience they are. 
Nice! Yeah, I've always found them to be really responsive. Glad to hear it.
Actually there are the concepts of polymorphism, method overriding, method overloading and operator overloading. In operator overloading you cannot change the number of operands. There are other rules, you can see that here: http://www.cs.fsu.edu/~myers/cop3330/notes/overload.html
That's all a matter of preference. I've been building Rails apps since 1.6, and tried all of those libs. In the end, I've stuck with AR over mongo/datamapper, never use scaffolds, love me some erb, hate coffeescript (too much abstraction) so running with pure JS, love/hate with FactoryGirl but it's still brilliant, and rspec definitely beats out TestUnit for me. Important thing for me was to keep at it and keep an open mind, even when I cursed the heck out of it.
I find it weird that he think replacing ERB with HAML+CoffeeScript will reduce the learning curve. HTML mixed with Ruby? Too steep of a learning curve. HTML pre-processor that uses indentation syntax plus Ruby to generate HTML and Javascript preprocessor? Yeah, easier to learn.
Replacing defaults is a good very good feature. Maybe the defaults could be better. Anyways, the reason why I prefer Sinatra over RoR is that Sinatra is a lot easier to manage. Less magic, less abstractions.
I use Rails and love Ruby. I recommend it everywhere. The only problem I see with Rails I see is that new versions require knowledge of Rails to use or learn. Previously newcomers to Ruby and Rails could jump in, now there appears to me to have a dependency of knowing Rails first hand. It's no longer newbie friendly - it has become inward looking, whereas before it was outwards looking.
I am saying that the *combined* burden of having to learn first the "rails way" and then "the *quote* right *unquote* way" increases the learning curve. It's no single instance of "oh this tool is better than the one that ships with Rails" or "yeah, all the books say do it this way but in reality dont do that, do this" or the instances of "Well thats how Rails does it but there are use-cases where you need to consider this"; its the multiple instances of such which *I* have experienced while trying to learn Rails well enough to tackle my first real-world project with it. 
I agree with your statement, in the sense that ALL of the things you mention are important to measuring maintainability. Not just code organization. However it does read like "You really need confidence to go to the moon. The rocket, a space suit, and a lander are pretty useful too"
&gt; I am saying that the combined burden of having to learn first the "rails way" and then "the quote right unquote way" increases the learning curve. As I mention in my other comment, you don't need to learn them all at once... and it's probably best not to. &gt; its the multiple instances of such which I have experienced while trying to learn Rails well enough to tackle my first real-world project with it Honestly (and please don't take this as an attack), but after having taught Rails to a number of people over the years, a new Rails developer's first project is *always* spent fighting against the framework. It's inevitable—Rails is huge, and definitely channels people into a particular way of doing things. But as they come to learn more of Rails, and the benefits Rails provides when doing things the standard way, their second project works much smoother.
Yeah obviously the tools can help make that happen a lot. But someone well versed in even ASP VBScript can make a maintainable good application. 
There's a great discussion thread, including Twitter engineers, in [the /r/programming subreddit](http://www.reddit.com/r/programming/comments/1kisyg/rearchitecting_twitter_new_tweets_per_second/).
With only organized code?
Thanks for the input! That's good anecdotal evidence that Rails can be more maintainable than other codebases. My concerns are that (AFAICT): 1. there is nothing is rails forcing or even helping your code to be maintainable 2. the rapid evolution of the framework and gems - specifically the DSLs they introduce - degrades readability in short order. Both increasing the learning curve for newcomers and complicating maintenance for all. Thoughts on these issues? Have you had issues with a plethora of DSLs complicating codebases?
"1. there is nothing is rails forcing or even helping your code to be maintainable" We need some context to make this useful. There is certainly more in rails that helps you with this than a minimal framework like sinatra or if you want to roll your own on top of rack. It tells you where to put your models, views, controllers, layouts, tests, javascript files, stylesheets, routes, helpers, etc. It sets up an ApplicationController that all the other controllers inherit from, and I can go on and on. It even tells you how to make a gem to add functionality to a rails app. "the rapid evolution of the framework and gems - specifically the DSLs they introduce - degrades readability in short order." I think this is two distinct things. The pace of change of the framework, and the quality of the gems people often use. Regarding gem quality, this is the biggest headache I've faced and I've learned to be very careful when adding gems that add a lot of magic (and by magic I mean abstraction layers that I haven't taken the time to understand). On the topic of rate of change. The core of rails hasn't changed that much over the years. I've been using it since the pre-1.0 days and the core concepts are still the same. Rails 2.0 came out in 2007 and a lot is still the same. the big changes I can remember off the top of my head are AREL in ActiveRecord which was a very nice change, bundler which was the best thing ever, making things more modular in 3.0 which was a huge benefit, the asset pipeline, and now the background job queue thing and turbo links. I'm sure I forgot something, but that's over a period of 6 years. I really don't know what the alternative would be. I certainly wouldn't want it to have stayed the way it was in the 2.0 days with no bundler, less modularity, no arel, etc. I admit that there is a steep learning curve, but that learning curve roughly mirrors what it takes to be a good web developer. 9 times out of 10 I prefer the rails codebases after a few years than the homegrown frameworks, and I know of no other full stack framework that works as well. 
Wait what? I said it was delicious chicken.
Then I'm confused. Wanna talk this over a bunch of those little chicken nuggets they got? 
Thanks very much for the reponse!
KFC instead? Not only is the coleslaw amazing and the rotisserie really good when cooked right, but they don't support hatred :3
The Tweet is a little misleading. A prototype, incomplete version of Ruby, which was built to prove open source compiler technologies (which Oracle are really promoting), is closed source. If it were made open source, it would probably only be done so people could read the source. Not so people could use it.
Just consider what happens when you have 1000+ responses. That file is going to be huge and repetitive.
I am not sure how to condense it. I just started Ruby like last week! :P
Wow that is a great looking website!
He already talked about how it was possible to make a really fast ruby if you just removed a couple things. He should do that.
which things exactly? the things which make ruby 'ruby' :)
This. Very few engineering teams produce maintainable codebases, even ones with great engineers. Even ones built by "best practice" junkies.
You can also host your own with [SDoc](https://github.com/voloko/sdoc/), if you want.
Rails is pretty upfront about it being an [opinionated framework](http://www.martinfowler.com/bliki/EnterpriseRails.html). It's been subject to criticism, sure, but it shouldn't be a surprise. "Convention over configuration."
I don't know of any "beef." I like some things about Python better than Ruby, but Ruby is still my every day language of choice. It all depends on what you're trying to do.
&gt; Is this an inferiority complex, or is it indoctrination from the Ruby community? Holy loaded question, Batman. The Python guys do awesome stuff. It's a very nice language. But obviously, many people who have been using a particular language for a long time do so because they *like* things about that language. I like Ruby a lot. There are also things about it I don't like. Just like every language. 
I think some people are bigots and will argue against one or the other. But really it comes down to preference, available libraries and what you're trying to accomplish. When i tried python in the past, i didnt have the concept of the shell vs running a .py file. When i started learning ruby, rails was around and made it really tempting to get into. So since then i just kinda got into it. I have used a bit of python here and there, and I think it is a really nice toolset. 
IMO, people just like to think that what they are using is the best. They've put significant effort into learning it and want to justify that effort. vim vs emacs Mac OS vs Windows vs *BSD vs whatever linux distro they use static vs dynamic typing etc... 
Ruby programmer here, I have a friendly rivalry with Python programmer. We both obviously think our favorite language is the best language. For our funny little dispute it comes down to whitespace (I say it shouldn't be significant) and Objects (He says they should be used sparingly). On the other hand, I've noticed that there is some vitriol on Hacker News, there seem to be a fairly frequent "Why ruby isn't actually a programming language" articles.
I like pry. It's better than IRB. It can do anything IRB can do, better. And /u/banister is awesome
Pry is the shit.
I've also enjoyed using [ripl](https://github.com/cldwalker/ripl#readme) (with the `ripl/multi_line`, `ripl/auto_indent`, `ripl/color_result` plugins) as a lightweight irb replacement. Much smaller, faster and more modern than ye olde IRB. I also use Ruby's builtin debugger (`require 'debug'`) and Pry when I need to debug something. **PSA:** the downvote button is not the disagree button.
I like pry but ... I also really like it. I started using it over RubyMine for debugging. 
I use Pry daily. Indeed it is. Also, happy cake day!
Thank you for the fun exercise! Here's my pointy lambda submission http://exercism.io/submissions/5212ed560a9adcdbfb00004c
&gt; The things you can do in Pry, you can also do in debugger. And, unlike debugger, it doesn't fail to install with "No source for ruby-$VERSION" everytime Ruby releases a new patchset.
I maintain the Ruby instrumentation for [TraceView](http://www.appneta.com/products/traceview/) (web app performance monitoring). Check it out. I would appreciate any feedback any of you may have. This article shows how to use Russian doll caching in combination with a smarter page layout for better overall performance. I've been applying Russian doll caching to all of my views preemptively before I upgrade to Rails 4. Some of you may know me from [PasswordPusher](https://pwpush.com) or [Gameface](http://gameface.in). 
&gt; To fix this, I re-organized the page to group the logged-in specific content into one specific area. With logged-in content out of the way, we are then free to cache the rest of the page in well-defined fragments. I don't like the idea of letting your framework's technical constraints dictate your design choices. A much better option, IMO, is to make heavy use of `data-` attributes (or even CSS classes) to render nearly the same page for everyone, and use a tiny bit of non-cached JavaScript to decide which elements to actually show. This obviously isn't plausible for everything (some data is private to a user, period) but at least it lets you cache your menus without moving everything around.
Making extensions has been painfully easy. Here's two that I let out publicly: * https://github.com/PatrickTulskie/lita-ping * https://github.com/PatrickTulskie/lita-thats_what_she_said I didn't roll them into gems yet, but it's simple to link to those repos with your Gemfile. I've made others and ported stuff from other frameworks but I haven't gotten around to writing tests or wrapping them up for public release.
&gt; I don't like the idea of letting your framework's technical constraints dictate your design choices. That's understandable and good point. Most often though, the best performing apps are those that are designed from the ground up with performance in mind. (whatever the implementation details) `data-` attributes are a nice solution but the amount of content you can apply that to is limited. It largely depends on the app but the large majority of content is "for that user only" in which case data- attributes may not be a best fit. And then for me (who tries to avoid browser side coding when possible), JS/data- attribute coding can increase client side page complexity (where as page redesign has the goal of simplification). And the last thing that comes to mind is that I prefer to not expose logged-in links and resources to anonymous users (via view; page source). In any case, there's no "one solution fits all". Most often it's a mix of solutions that often gets the best results and data- attributes are a fair addition for specific things.
I love pry. It has been super helpful for me. When I get confused on how something works I just dig dig dig
This app is pretty cool. You can really get into some great discussions around code. I've learned a bunch from others nitpicking my submissions, and from reviewing others' code too.
Great catch! Thanks.
This seems like it would work well with [ZOMG, the OMG IDL parser](http://rubygems.org/gems/zomg) I wrote a while back.
But this way is so much more fun.
[Please don't extend objects at runtime](https://charlie.bz/blog/things-that-clear-rubys-method-cache)
In the end, coding is all about tradeoffs.
This blog uses telephone apps as an example, but is applicable to plenty of other applications.
Thanks for posting this! I use the sequel gem a lot in my day-to-day scripting activities, it's incredibly useful. Works great but there *are* alot of gotchas.
Everyone needs to use state machines more often.
It seems like the Hartl book covers everything that the Pragmatic Studios course does, is there really a difference? I'm learning Rails right now and just about finished with the Hartl book, I've been using Codeschool and Codeacademy to supplement my Ruby and Rails knowledge.
Cool I monkeypatch symbolize_keys into almost everything I write, esepcially if I'm going anywhere near YAML.
Seems like you would be better served just giving the hash to an OpenStruct.
Good point, I always forget that is a thing.
Datamappify looks excellent!
There's also [astruct](https://github.com/krainboltgreene/astruct) (my gem), which is a drop in replacement for ostruct with bug fixes, speed improvements, and better hash duck typing.
One of the thing that annoys me about Sequel is that everything needs to be a symbol. It doesn't accept strings (except for large SQL fragments). Given how often table and column names are either (a) dynamic, or (b) pulled from config files, it would be nice if I didn't have to .to_sym everything on the way in.
said no one. In my experience, a class with a state machine become so coupled to the state machine that testing becomes a huge headache. State machines aren't bad, but I have never thought that I need to use them more often.
As an aspiring Ruby on Rails dev this worries me. I have been thinking of looking in to Python and Django after finishing a few basic Rails apps.
You ought to; whatever you decide, it won't be a waste of your time. Django's getting popular and it's good to know the basics. IMO, there's a cultural difference in the communities. Some people seem totally ok with not being able to drill down and figure everything out in a page of code. In Rails, there's lots of mixins and monkey patching which make this difficult. For the most part, though, Rails really "just works", and offers so many software engineering benefits, that I've stuck with it. And the other culture, Python, seems to be more Java-influenced. Even though it's a highly dynamic language, the import statements make it easy to see where things come from (like in a staticly typed language). Also, the library docs are comprehensive like Javadocs. However, Python offers the interactive interpreter as well, "IDLE", equivalent to IRB/Pry.
Google: "how to create ruby accessors" or just "ruby accessors" gives plenty of adequate results if you can't remember attr_accessor, attr_reader, etc. I suppose I can understand wanting to have all the information on a single site, but it is readily available with a simple google...
For sure, there are lots of results. But I disagree about the "simple google". :-) There are lots of incorrect blog posts out there. And lots of posts about older language versions. It's not so much about finding it all one page; it's about finding it in one *click*, and knowing I have the right answer. My google search for those keywords returns the old (2008) doc by Matz translated into English. It doesn't say what Ruby version it applies to. Other than that, I don't get anything promising.
After seeing a whole lot of code that comes from students recently out of college...if we can bring a bit of sanity to the messy spaghetti setup of if statements I've seen, I'll take it. To each his own regarding coupling. Depends on the problem and how it's implemented. Each design pattern has its reasons for existence, doesn't mean state machines are bad in general.
I suspect I don't understand. I went to http://ruby-doc.org/ clicked 'core doc' and found http://ruby-doc.org/core-2.0/doc/syntax/modules_and_classes_rdoc.html almost immediately. It may not bother you the same way it bothered me, and it's been quite a long time since I was a python dev, but in python it seemed like there was no room to deviate from anything in the documents. (That was 'the one true way') At the end of the day programming is really about creating, so I wouldn't let anything but what works best for you be the deciding factor. …Even if significant whitespace is wrong =P
Thank you! That was the doc I had gotten stuck on, but couldn't find just now. And just like you, I thought, "Ah hah, I've found it." But no, the [Modules and classes doc](http://ruby-doc.org/core-2.0/doc/syntax/modules_and_classes_rdoc.html) omits vast amounts of basic info about how to create a class. In my case, it does not have the piece I was looking for: how to create accessors.
I agree the documentation situation is pretty bad, because "just read the specs" is not what i want to do. But between the Ruby Programming Language book (the O'reilly one that Matz coauthored) and the Dash documetation browser on my Mac (on Mac App Store), I can usually find core Ruby/Rails features. (Oh and the Rails guides, assuming you're on a modern Raila version. Heaven help you of you're a version or two behind) But it really gets bad if I'm trying to look up something from a gem though. Even the "well documented" ones like FactoryGirl or rabl. (Can you tell where I've spent the last week?)
I use [micromachine](https://github.com/soveran/micromachine) when I need a state machine in ruby, simple and useful.
 class Ruby attr_accessor :attribute_one, :attribute_two def initialize(attr1, atrr2) self.attribute_one = attr1 self.attribute_two = attr2 
you should really make sure to limit your searches for code to 1 year. Google has a good feature to do that 
`attr_accessor` and others are convenience methods that define some other methods for you. As such, they are not something that is on the same level as syntax for creating classes: it's just a method call. As such, the appropriate info is where it belongs: documented as [methods of `Module` class](http://ruby-doc.org/core-1.9.3/Module.html#method-i-attr_accessor). Basically, class Foo attr_accessor :bar end or the equivalent form where it is obvious it is a method call: class Foo attr_accessor(:bar) end is functionally equivalent to class Foo def bar; @bar; end def bar=(value); @bar = value; end end Saying that, I much prefer RubyDoc to Python's documentation. I can never find anything there, because it's organised as a textbook, and not a reference. I have exactly the opposite complaint: Python docs feel like they are for newbies, as they make you read sequentially; while RubyDoc, just like JavaDoc, is exactly what you'd expect as an experienced coder, where you can instantly go where you need to go as long as you have an idea of what you're looking for.
rdoc.info has doc for 99.9% of all gems and projects, plus all of stdlib, while apidoc and rubyonrails.com has the guides and info pertaining to rails
[rdoc.info](http://rdoc.info) Which you can get to by clicking the "documentation" link on [factory_girl's gem page](http://rubygems.org/gems/factory_girl)
Thanks for the great explanation. But from my point of view, as someone who's learning, it's not clear at all that this info belongs in Module, instead of the [Class documentation](http://ruby-doc.org/core-1.9.3/Class.html), which I had read. It didn't occur to me to look at its parent class, Module, for docs on "Class features". (I think this is a weakness of using the rdoc to explain these language concepts: it's auto-generated API docs, and so it follows the organization of the library architecture. And that architecture diverges from the concepts in the languages due to implementation needs.)
I would recommend https://github.com/troessner/transitions as it has small codebase and does not suffer featuritis.
&gt; I've been exclusively a Rails dev for the past six year, and have made many large apps. I've got a published gem, and have contributed to the rails guides. and &gt; from my point of view, as someone who's learning are decidedly at odds with each other. If you're looking for a reference, RubyDoc is awesome. If, however, you're looking for a *tutorial*, there's plenty of them around. For example, the official [20 minute quickstart](http://www.ruby-lang.org/en/documentation/quickstart/) introduces accessors on page 3 of 4. [Ruby Users Guide](http://www.rubyist.net/~slagell/ruby/) has a chapter named "Accessors". These and more are linked from the Ruby [documentation page](http://www.ruby-lang.org/en/documentation/). Not to even talk of many very good books, like [Programming Ruby](http://pragprog.com/book/ruby/programming-ruby).
So there I was, enjoying my morning read when... [Obstructed](http://i.imgur.com/HDTJoIx.png) - I'm assuming it's just me? Other than that, decent list. :)
Sure, but the only useful documentation link there is the Getting Started document on GitHub. The rest is internal class documentation that I couldn't care less about when using the DSL.
&gt; Depends on the problem and how it's implemented. Each design pattern has its reasons for existence, doesn't mean state machines are bad in general. I agree 110%. 
Soundcloud!
* [7 Great Websites Built Using Ruby on Rails](http://blog.idyllic-software.com/blog/bid/204058/7-Great-Websites-Built-Using-Ruby-on-Rails) (2012) * [The top 10 websites built with Ruby on Rails](http://www.railshosting.org/the-top-10-sites-built-with-ruby-on-rails) (2011) * [20 Best Sites Built with Ruby on Rails](http://www.developerdrive.com/2011/09/20-best-sites-built-with-ruby-on-rails/) (2011) * [50 of the Best Websites Developed Using Ruby on Rails](http://www.setfiremedia.com/blog/50-of-the-best-websites-developed-using-ruby-on-rails) (2010) * [121 sites using Ruby on Rails](http://lineofthought.com/tools/ruby-on-rails)
Shopify
They left out some big ones: - 37Signal - Funny or Die - Get Satisfaction - Groupon - Hulu - ~~justin.tv~~ ([Now using DJango](https://news.ycombinator.com/item?id=3461476)) - LivingSocial - UrbanDictionary - Rap Genius - Scribd - Shopify - Square - [Twitter](http://www.quora.com/Does-Twitter-still-use-Ruby-on-Rails) - Zendesk Edit: A few more - Airbnb - Kongregate - Bloomberg - Heroku (apis and web panels) - Pitchfork - Indiegogo
Especially glaring since Scribd is not at all quiet with their claim of being the largest Rails site on the web.
Twitter doesn't count. They originally wrote it in ruby on rails, and may still have some pieces written in ruby on rails, but for the most part they have converted off of it and use a jvm backend. 
Great hit
airbnb.com yammer.com stripe (uses ruby not rails though) kickstarter Digital Ocean
I feel like Justin.tv and Twitch.tv go hand-in-hand.
No they do not. Python and Java https://www.spotify.com/us/jobs/view/ouMTWfwP/
Wrong subreddit
Zeus doesn't always work ... Id love to use it, but our test suite will simply not work with it, and I don't have the time to futz with it
Justin.tv is actually django. There was a rewrite a bit back. Twitch is still Rails though.
Ruby gives me the following error: &gt; NameError: undefined local variable or method 'category' for main:Object I think we're using different implimentations ;)
That's why I linked that Quora question, Twitter engineers still claim they use Rails for parts of the site. Obviously anything as big as Twitter is going to use a whole host of varying tech to meet their needs. Square also uses a JVM backend but runs Rails on top of JRuby.
I've used state machines in a couple different projects (using the state_machine gem) and sometimes they are useful. My comment is that I think an attitude of "everyone needs to use state machines more often" is a dangerous one to have. They are a tool to solve a problem, but it should be used judiciously.
Interesting, but you missed the 'g'.
Also [Beanstalk](http://beanstalkapp.com) :]
The only thing I can think of is that could help convince people that 'rails can scale'. Other than that, I'm tempted to agree that the list is largely useless.
If you're using DuckDuckGo instead of Google, you can quickly search the Ruby Docs by prefacing a search with `!ruby`. Doing a search for `!ruby accessors` will redirect to the Ruby Doc search, where the first result is "[Accessors](http://www.ruby-doc.org/docs/ruby-doc-bundle/UsersGuide/rg/accessors.html)" from the User's Guide. This has replaced referring to [The Pickaxe](http://www.rubycentral.com/pickaxe/) for me.
Groupon…
&gt; Groupon 4th From the top 
Simple subject, short article :-) Still, it seemed to me far too few people were aware that those methods are considered deprecated, so I thought such a tiny article might be useful.
I really wanted to try to create a marketplace for all the snippets of code I find useful for my side projects. The goal here is to create a way for startup hackers like myself to stay fed until they hit it big. Excited for any and all feedback.
Yeah, this is the primary objection I have to it myself, and it's my own project! My thinking is that I'd love to be able to support myself on my own side projects while working on bigger things.
Don't your bigger things support you enough?
Great questions: * "mere snippets" isn't a great way to explain what this is, Passenger is distributed as a gem, these could be entire apps perhaps. down to $.99 and up to ? was my thinking * I've been thinking about this, and my current thought is that the marketplace will be curated. Thinking about creating testing requirements and perhaps producing a short videocast for each submission at first. In the end, that won't scale. I'd like to create a balance between cost/risk with a rating system and let the community self-govern quality * Much like above, the risk will be similar to open source projects. Members will hopefully gain reputation through submissions/purchases. Members will also have a bio page which links to their outside work/open source projects * There will be support requirements for submitters I think * Technically, some licenses would allow selling open source code, but I don't think I'd support it unless it came from the actual author (perhaps what they actually are selling is support?) Anyways, because it's curated this would be handled on a per-submission basis * Code is abundant, but solutions to common problems are not necessarily. The thought here is to encourage developers to take the problems they're solving, abstract them a little more, and perhaps let the rest of the community benefit from it. This is already common practice in open source, this just raises the benefits a bit.
Ha, don't I wish. By bigger projects I more mean "not gems", that doesn't necessarily mean they're more successful!
I would recommend looking into [mutant](https://github.com/mbj/mutant), that way submitters can't get away with writing tests that always pass. If the code is a web-app you could run an automated security scanner against it to check for basic things. The reputation model doesn't work wrt security, since vulnerabilities are not immediately discovered and even talented developers can accidentally introduce a vulnerability and the sloppiest developers eventually learn from their mistakes.
I like that, great find.
37signals sort of *developed* Ruby on Rails for their products... &gt;Ruby on Rails is a free web application framework created by David Heinemeier Hansson, one of the 37signals programmers. It was originally used to make 37signals' first product, Basecamp, and was since extracted and released as open source in 2004, as well as being the framework that 37signals use to make their web applications. — [#](http://en.wikipedia.org/wiki/37signals#Ruby_on_Rails)
HipChat is indeed based on XMPP, though the HipChat adapter for Lita was not designed to be a general XMPP adapter. It might work for that case, though. Let me know!
I work at Twitter. I'd say we're off of Rails to the point that you could say we're not a "Site Built with Ruby on Rails". Most of twitter.com is served off of our Scala web framework at this point.
My chat botting needs are fairly small for now are fully satisfied by: https://github.com/brettstimmerman/jabber-bot but lita does sound pretty sexy so I will definitely try to port some things whenever I get the chance.
Define, "jvm back end." What then, is the front end?
how about [workflow](https://github.com/geekq/workflow)?
Uses the jvm for server side code (java, jruby, scala, ...). Front end (browser code) is always some sort of html, css, and JavaScript. 
&gt; released as a gem for people to depend on &gt; Not v1.0.0 Are the words contained in SEMVEr really that hard to understand?
I was just looking at this the other day, looks really cool. What background should one have in order to contribute to a project like this? Linear algebra and C/C++?
Is there a changelog? Didn't see one in the repo
it's top ten according to http://www.alexa.com/ search
scumbag developer "No new code needed" first step is to install a totally new version of ruby
Seriously wtf. I was hoping for some operating system stuff or defaults I could tune. Adding a few thousand lines of code is way less daunting then upgrading ruby versions!
Did you mean an IDE? ;) I don't use rubymine myself, a friend send me that image, after that image, the closest I have found for that is ripper-tags.
It's called History.txt.
Thanks for your comment. NMatrix is a prototype right now. We didn't want to guarantee backwards compatibility until we got to v0.1.0. So I think we are adhering to the SEMVER principles.
The standard for most vim users is probably Exuberant ctags but it's not as nice with ruby as it is for C. Ripper-tags is an increasingly popular alternative for Ruby users. In either case something like Taglist would be used to convert them into a side-bar that you can browse through. Ars Technica did a 'how to do this with vim' article for a number of popular IDE features a few years back. http://arstechnica.com/information-technology/2009/05/vim-made-easy-how-to-get-your-favorite-ide-features-in-vim/ 
There's Taglist, apparently Vim's [most popular plugin](http://vim.sourceforge.net/scripts/script_search_results.php?order_by=rating), which provides an expandable buffer (like NERD tree) that lists your variables, methods, etc. With this and folding (for hiding and showing your nested modules, classes, methods, and routines; making them easier to take in at a glance) you get most of the same functionality.
Hey. So I've been working on this little program trying to get it finished before the semester began. (I'm a couple days late.) This app is designed with two use-cases in mind: 1. You want to spend a minimum amount of time on a task, or 2. You have a time estimate for a task already You can then check in &amp; out of tasks to allocate time towards your goals. Maybe it will help someone else work on their reasonable expectations -- Yesterday I thought my lab report was gonna take 90 minutes, and now I'm at 300 and counting. P.S. If anyone cares enough to look at the code, I definitely am open to criticism. This is already a rewrite from a god-class existence.
It's a 'tree' list showing the methods/variables/etc. for a particular file/module/class. You would use it to navigate to a method definition in order to figure out why the hell your code is breaking or to get a feeling for what the interface for a particular class is like without referring to the documentation. If you see a method named "setBalance()" on an Account class there's a good chance that the method can be used to set the account's balance. A short list like this is more convenient than reading the documentation or source code.
Interesting idea. Consider moving the classes into separate files structured under a `lib` directory rather than squashing them into one file. If you look at most gems, you can see an example of this file structure.
A simple rails project. Try a making a blog or a survey. There's lots of great tutorials on railscasts.com.
&gt; UrbanDictionary I had no idea. 
As soon as you released it for public consumption for people to depend on (rubygems) you stopped being 0.X.Y. More importantly you shouldn't care about backwards compatibility until 1.X.Y+. So no, you don't understand.
If no one cares about backwards compatibility until 1.X.Y, why do *you* seem to care so much? How is this hurting you or your workflow? If you'd explain instead of just being snarky, that'd be awesome.
For vim users, they might like to know that [tagbar](https://github.com/majutsushi/tagbar) is a newer plugin, that mirrors practically all of taglist's functionality, but is currently actively maintained and being added to. https://github.com/majutsushi/tagbar
For vim users, they might like to know that [tagbar](https://github.com/majutsushi/tagbar) is a newer plugin than taglist, that mirrors practically all of taglist's functionality, but is currently actively maintained and being added to. For example it has support for many other code tagging utilities other than just ctags. https://github.com/majutsushi/tagbar
I recently discovered [slop](https://github.com/leejarvis/slop) a pretty good options parser. Just thought you should know.
Oh neat, I had no idea. Will have to check it out.
Version two could be called Rubbit Harder.
The trouble with simply searching for it, is that you could find all the places where a method / class is only used, not where it's defined. If you specifically want to jump to the definition, then the tagbar/list can be very useful. It's also useful for seeing all of a module's classes/methods at a glance. I can see the name of a method somewhere down in the file (if I'm new to the file) simply by looking at the side of the screen, rather than needing to grok the entire file.
Do you already know javascript?
This is really helpful--thanks. So in essence, it sounds very similar to Dreamweaver's CSS navigation menu that lists out all the different divs/classes and jumps to them in the code view when selected. I can definitely see why that would be useful.
&gt; Where does SEMVER say this? It implies it, but not as clearly as we'd like. We're changing that: https://github.com/mojombo/semver/pull/152/files &gt; Then that person is a dumbass and shouldnt be using random gems they found on rubygems. Regardless of if that person is a dumb ass it shouldn't matter. There is no reason to release stuff on RubyGems unless you *want* people to depend on it. That's what people will assume and they're not in the wrong.
If you want to impress the living hell out of me, have a full integration test suite for your app written in Cucumber. Demonstrate knowledge of keeping clean frontend code bases. [This eloquent blog post](http://philipwalton.com/articles/decoupling-html-css-and-javascript/) does an incredible job of explaining some issues I have never quite been able to articulate. If you're looking for something more simple and entry level then disregard this. When I'm hiring a frontend engineer I'm usually looking for someone who is looking to build web *applications*, not web sites, and to be able to do that well requires a different, much more disciplined way of thinking about the frontend to keep things sustainable. If you're building a marketing site with limited interactivity you can get by with more simple sites that are just using jQuery for everything and cobbling stuff together (and that's really common with agency work). Not implying there's anything wrong with that at all (there's not much value in spending more time building a short lived marketing site like an app with a longer lifecycle); they're just two different classes of frontend development.
Yes. https://github.com/majutsushi/tagbar
i'm terribly sorry, but I won't trade 50% productivity for some fancy file tree orginization
so you updated ruby?
A lot of the common tools in Ruby, such as ActiveRecord, abstract away the underlying problem. When I interview candidates, I'm most impressed when they understand not only when to use abstractions, but also what those abstractions are doing. Any problem of sufficient complexity will require you to jump between levels of abstraction, and I want to know that you can do that. Make a demo site that uses all the latest and cool technologies. Be ready to explain why the choices actually are cool. Then be ready to tell me what they're doing. If you're using SASS, tell me what it's doing to your CSS. If you're using ActiveRecord, tell me what it's doing to your database. If you're using gems, tell me what it's doing to your runtime environment. The "what" that you're doing is usually a lot less important than the "why". You'll do whatever you feel is right for your employer and product, which is probably very different than what is right for your personal projects. What I want to know is that you made the right decisions for your personal projects, and for the right reasons. If you're copy/pasting just to make your site work, you're not too useful. If, on the other hand, you can evaluate your choices and defend them (even if they're wrong! that's okay!), I will be much more impressed.
Definitely read it as rube-it and then you blew my mind
If you are wanting to get into front end development, shouldn't you be focusing on a HTML5/CSS3/JavaScript app instead of Ruby?
Hey, meet * in vim. It's a lot smarter than you think
There's also [`OptionParser`](http://ruby-doc.org/stdlib-2.0/libdoc/optparse/rdoc/OptionParser.html) from stdlib.
have a full integration test suite for your app ~~written in Cucumber~~. FTFY
Feel free not to read it.
When I define a new method or important variable, I put a handful of comments above it. One of them is "Define: method_name". I can search for that and always be brought to the method definition. 
Build a simple rails or Sinatra app with a restful interface. Then build an Angular.js UI on top of it. Have a full test suite using guard/angular-scenario/phantomjs.
Honestly? Create a gem and open source it. Or do something with Sinatra, Grape, Poncho. Show me that you understand how to build RESTful API's. I don't want to review another candidates half baked rails app.
Open Source Software. Contribute to code and participate in mailing lists.
you can also vimgrep/ack 'def method_name' rather than relying on your comments.
In addition to things others have said about vim, the [vim-ruby](https://github.com/vim-ruby/vim-ruby) and [vim-rails](https://github.com/tpope/vim-rails) plugins are very handy.
These are my thoughts exactly.
What's the state of hashes preserving order?
Not sure I exactly understand the question. However hopefully this helps: prior to 1.9 the order of hash was undefined so was largely up to the implementation. 1.9+ Hash enumeration order is explicitly defined as insertion order. 
It's probably important to note that sort/sort_by returns an array of [[key1, value2], [key2, value2]], not a resorted hash. And obviously it also doesn't modify the original hash, so a hash's order will always stay the insertion order. http://showterm.io/87a3444828bafcd943020
For me, long files are a code smell (they contain too much complexity that should be elsewhere/split) -- if i ever find myself *needing* code folding or within-file jumping, it's a massive sign to me that I should refactor that file/class/module as a matter of priority.
Rubbit Faster in JRuby.
My project isn't about selling code though. But if you can spinoff rubygems in a market place I can see the value. 
 [[key1, value2], [key2, value2]] should read: [[key1, value1], [key2, value2]] 
Ah yes, I am already doing HTML5/CSS3/JS, trying to tie it all together.
Haha, I'll keep this in mind and write Learn Rubbit the Hard Way tutorial.
Thanks for the advice. What would you think if I built clones of other web apps? What are your thoughts of showing that I can use APIs?
Thanks, I have a long way to go but I'll get there!!
Thanks, I'll check that out!
Will do.
Thanks!
Rspec and capybara? 
I doubt that. What command are you trying exactly?
Also a good example. 
Learn javascript, take advantage of jQuery. One of my mentors once said to me, it's better to know a language than know a library (which what jQuery is).
This! Why is this not the top comment?
You're solving the wrong problem. If your file is so complex that you need something like this, then you almost certainly need to refractor.
Then search for 'def foo', or just 'f foo', instead of just 'foo'. If that's too long, then set '/def ' to a key binding.
In some languages, this can get thrown, such as in JavaScript. For example is it '.prototype=foo' or '.prototype = foo'? Although code consistency, or a code for matter will fix that. Both being things I'd recommend (although I don't know of any for Vim, but most IDEs with a decent Vim plugin will do it, like Visual Studio).
Well that is the wrong question to ask - the correct question would be: "Given my interests, what looks like an interesting, active, busy open source project, and how can I contribute to it?" Really, you have to have enthusiasm for anything! The demonstration of this enthusiasm is what impresses employers. 
I believe `gd` and `gD` will find both versions of assignment (with and without spaces).
I've never understood why people do this, really. If you need a code navigator for a single file, then you probably need to throw that code away and refactor it. I can see this being helpful on those 2000 lines controllers that some apps have, but I would never want to work on a project like that ever again, so I'll say I don't need this feature at all :)
That was exactly the question, thank you.
Redbubble serves a few hundred million requests per month.
The Chef and puppet communities will like this. Maybe you should modify the users cookbook, to use your code ?
Bonus points if you make it so I can assign several groups to a user in a create/update resource... I should probably just suck it up and write those resources...
Group members are just an array of users... So should work out of box =&gt; #&lt;struct EtcUtils::Group name="adm", passwd="x", gid=4, members=["ubuntu", "foobar"]&gt;
I'll try to reach out to the community. Thanks!
Zeus is great for development, but doesn't help in CI
If you care about the privacy of your visitors you need to host assets yourself. I for one find it annoying that every site I visit initiates an interaction with 15 corporate entities.
I know this thread is a bit old but can you expand on this point a bit? What makes a Rails app half baked or what is very run of the mill to see from an applicant that makes you sigh and move on? Further, can you recommend anything for helping to better understand REST, RESTful APIs, etc.? Thanks 
Since this got upvoted, I feel compelled to elaborate. Grimm's book follows the same lines as other classic books on refactoring and writing clean code...the term "confident" code refers to the practice of writing methods and classes that aren't bogged down by constant nil-checks and convoluted if-else-branching statements. If you've read other OOP books, many of the concepts will be familiar, such as the idea of refactoring a method that requires specific strings or numbers by creating a separate object that contains the domain knowledge. The example he uses is a TrafficLight class that, at first iteration, has a **change_signal(some_string)** method that would require the client to know the correct signal strings, e.g. "stop", "caution", "go" Such a construct is prone to errors of typos and forces the client to read the source code. After a few refactorings and thoughts, Grimm shows how a **Signal** class that handles all the logic of moving from state to state (as a "Go" light should never jump straight to a "Stop" light) makes all **TrafficLight** client code much more "confident". Before I finished Grimm's book (when it was in pre-alpha stage), I thought that it mostly dealt with aesthetics (i.e. extract giant if-else statements into some other class), but I've come to see how all those small things propagate through the design of a larger project. For instance, one of his early tips deals with return values. A method called **find_members** typically returns an array of Member objects. But what happens when there are no members? A common mistake is to just return nil...but then that forces every other method that relies on **find_members** to check to see if the return value was **nil**. The easy fix is to just return an empty array, and all other dependent code will just iterate upon the result 0 times. The strategy is so simple that you wonder, "what's the big whoop"...but that's kind of the problem. As a novice, you think, "Well, my code is small enough that I can remember to nil check when using that method"...until the code isn't small enough, and you're now adding nil_checks with each new method rather than being able to find the source of your insecurity. As I've gotten better at coding, I've started to see how the small things add up. With each piece of cruft that I have to tack onto my codebases to make them run, I get a little demoralized. And before I know it, I no longer have any interest working with or maintaining that codebase. Writing "confident" code seems superfluous, but only if you don't consider the big picture. (And really, one of the main purposes of programming in Ruby is to reduce cognitive friction and despair...out of most programmers, Rubyists should appreciate how much elegance can improve the coding experience). What really sets this book off is its final chapters, in which Grimm walks through how he would refactor some real-life open source code. It's a wonderful example because it shows all of his principles in action (you can check his github pulls yourself) and it shows how even when you know nothing else about a certain real-world library, you can still have the wisdom to detect and fix code smells. I had never really contributed to other's open-source repos but after going through Grimm's book (and writing lots of shitty code that eventually got better), I've become much more confident about approaching and assessing well-used and maintained code bases 
I worked with Avdi previously and can say he has extensive Ruby knowledge and has really good insights about programming and code quality. Anyway's if you want to level up your Ruby skills I am sure you won't be disappointed.
What is the deal with all the versions? Also anyone know a discount code? I just got laid off so spending $55 on a book really isn't an option at the moment.
Check out this post of his: http://devblog.avdi.org/2013/05/19/confident-ruby-now-in-beta/ &gt; I intend to spend one month getting Confident Ruby into shape for a final release. At the end of that month, I will be raising the price to $35. Until then, you can still get it for $25. **As always, if you don’t have the scratch you can send me a postcard instead.** (he links to an email address, which I presume you should email for further instructions) The multiple versions of the book arise from him writing and releasing drafts as he went. 
There are three versions. * **Gold Label:** ($55) Comes with ebook and screencast and another ebook (about metaprogramming). * **Black Label:** ($45) Comes with ebook and screencast. * **Red Label:** ($35) Just the ebook. I don't know of any discount codes for you, but it looks like he'll exchange the ebook for a postcard. [From his original post about the book.](http://devblog.avdi.org/2012/06/05/confident-ruby-beta/) &gt; Pay with a postcard: For those who don’t have the budget for a $25 ebook, I’ll be offering a second option. Send me a handwritten picture postcard from wherever you are, with your email address, and I’ll send you a copy of the book. &gt; &gt; Want to take me up on my “pay with a postcard” option instead? Send me an email with “Confident Ruby Postcard Offer” in the subject, and you’ll receive the address to send it to, along with further instructions.
Sweet, thanks. I just sent him a letter. A postcard is something I can afford. Also I'm likely to pay him anyway when I get a job again, I'm just being overly cautious with my finances.
Is this for experienced OO developers, or noobs? 
I think the complaint about the book's time from initial sale to final publication is a valid one, though I don't recall him promising as short a time frame as a few months. I guess the question is if things would be much better off if he hadn't released anything until now, which would eliminate the psychological frustration of the customer of an endless ship date. That said, I found the book useful more than a year ago and so have been happy with the early purchase. I'm not sure what you want from him in terms of accomplishments...A github repo with more than 2,000 stars? I think it's been firmly established that programming is not a realm where argument-by-authority stands...i.e. "listen to me because I have written lots of popular code". Either your code is well-designed or it isn't -- it's out there in the open for anyone to scrutinize. I think Avdi has put enough code out there, through his blog and his books, for him to be judged as skilled or fraudulent. My opinion is that he's a pretty good and wise coder and perhaps an even better teacher and writer but as I mentioned in my other comment, his work will be familiar if you've read other indepth books on refactoring or PODOR. Speaking of PODOR, which I think is otherwise a fantastic book and one of the classics...one of my frustrations with it is the use of the bicycle abstraction as the ongoing example. Yes, I know, it's just a metaphor, and good programming involves being able to abstract concepts at will. However, one thing I like about Avdi's book is specific use cases. With a little more depth, it could be a sort of Ruby OOP Cookbook.
I think it's more for Ruby programmers who aren't yet experienced at OOP, the concept of orthogonality, and/or working on medium-to-large codebases. In other words, I think it's particularly helpful for those who are self-taught and haven't had the opportunity to work on coding full-time.
I can't tell. Are you trolling, or do you honestly have a problem with Avdi?
Sweet. Bought the Gold edition. Book looks good.
Getting POODR and Eloquent Ruby would be cheaper and much better :)
Those books changed my programming life. I can tack on The Well Grounded Rubyist to that list.
What's the point? What's it for?
This looks like a really inefficient way to write JSON.
In that case, *I'm* sorry. Props to you for puttin' something out there!
It sounds like you go what you wanted out of the book. But you might want to consider getting a text on design patterns. There's a heavy anti-pattern cargo cult mentality in the Ruby world, mostly because of its affiliation with Java, but things like the null object pattern truly are useful in most languages.
I just bought the book and read the first few pages. So far, I find it informative, with a touch of humour to make it fun to read. The "build your own adventure books" analogy to software programs in the introduction is great. This is an eye opener on how a small program will turn into a fiendish monster, unless the diligent developer uses refactoring to smooth out wrinkles each time new features are added and bugs are fixed.
That seems like a lot of ceremony and extra work just to get some searches working. If testing your scopes is a must, why not consider using fixtures to help set up your data for this test case? Much quicker than factories would have been, and they won't pollute your tests with all the noise created by the stubs. &gt;We should adopt a convention of treating ActiveRecord supplied query methods as though they are private, except in extenuating circumstances. I respectfully disagree. There is nothing inherently harmful about ActiveRecord query methods being used liberally in controllers. If you're worried about keeping public API's as tiny as possible, and dependencies as isolated as possible, rails is a horrible, horrible framework to choose. All that being said, the eventual code you have at the end looks really good. It seems like a cool pattern for being able to build small classes that can encapsulate queries nicely.
Well, while we're on the topic, I'll recommend another book I've liked ;) "Design Patterns in Ruby" by Russ Olsen http://www.amazon.com/Design-Patterns-Ruby-Russ-Olsen/dp/0321490452 It covers Gang of Four patterns (well, most of them) except in Ruby...an extremely helpful reference and very readable...my only caveat is that if you get it for Kindle, the code is not particularly well-formatted. 
Please send me a postcard (see the link at the end of the post) and will be *overjoyed* to send you a copy in return. I love postcards!!!
Two of my most favorite Ruby books! (disclosure: I did technical review for POODR, and Sandi was a technical reviewer for my book) I'd encourage anyone interested in my book to read them if they haven't already. In my opinion Confident Ruby is orthogonal to those books, dealing with different aspects of Ruby programming than they do. And if the cost is too much, you can always send me a postcard instead!
Thank you!
Thanks, I'm glad the analogy worked for you!
Thank you very much for your review!
Nice work (and website)! ~~Just one question - Do I need to restart my local server to see my changes in the code have effect? It was one of the primary reasons I could not stand sinatra. I know sinatra allows me to run under shotgun, but that was super annoying and came with it's own set of problems.~~ Since you made it so easy to get started, I took the 3 minutes to do that. It unfortunately does not autoreload the code, but since you made it easy to read, perhaps it's something I can bake myself. Again, nice work! 
I've had pretty good luck with sinatra-reloader. Don't know if that would play with this, though.
I most certainly will! I love postcards!
Ah yes, I enjoyed that one. I started working at a company that made heavy use of the "Proxy Pattern" as detailed in that book. I think if I hadn't worked through that book I would have been a lot more confused looking at the codebase. Edit: a word
Really nice code. I, too, tried reading through Sinatra, thinking I could contribute back - maybe tackle a few small bugs. Nightmare. Looks like the biggest thing "missing" here is built-in support for easy templates? Not a big deal I guess. I'm going to be starting a new JSON API project soon and assumed that I would use Sinatra. I may just have to give this a try instead.
Really? I'd say the ruby community is overwhelmingly embracing traditional OO design patterns.
How does it happen that a project as big and imporant as Sinatra ends up in one 1600+ line file?
Write test coverage for your code. Better yet, write the tests first.
Thanks for kind words. I'll try to hack tonight with the code reloading, will post here if I will succeed.
&gt; built-in support for easy templates there is a example which uses sinatra's templating logic, It's pretty straightforward. https://github.com/alisnic/nyny/tree/master/examples/templates &gt; "missing" My goal is to keep the core as simple as possible, I will soon create nyny-extensions which will have all the goodies someone would like to have.
I disagree, I don't think there is a "heavy anti-pattern cargo cult mentality in the Ruby world". Sure, occasionally someone will come along with a Java-bashing blog post; and newcomes will often try to write "unrubyesque" code that needs to be stamped out; but none of this qualifies as a "cargo cult mentality". I have found the situation to be the opposite. Ruby is, if anything, very much about using patterns, and finding new ones that apply particularly well to Ruby. Consider the mixin pattern introduced by Rails (what the Rails guys now call concerns). It's something you can do with idiomatic Ruby, and it's definitely a pattern that has become so popular that attempts (failed, in my opinion) have been made to add it to the language itself. Other popular patterns include builders (especially `instance_eval`-based DSLs), stateful jQuery-style expression chaining, lazy evaluation, proxies and the command pattern. Not unique to Ruby, but definitely used in a way that meshes with the "Ruby way".
How is your approach different from Sinatra? I am just wondering since your claim to have a significant better performance. 
sinatra-reloader works fine for me as well, so I don't know what his issues have been.
Answer the question if you can and leave it alone, why the pontification?
I am unable to answer your question because my inability to grasp the inner workings of Sinatra was one of the forces to drive the creation of NYNY. I am have no solid knowledge in benchmarks, my tests are pretty simple. If someone can come up with better benches, I would more than happy to learn from him/her and correct my statements about the performance if necessary.
You can just cal the Java code directly from your Rails app, because JRuby allows very easy calling of Java code. You can deploy the app on either Apache or Nginx using Phusion Passenger (https://www.phusionpassenger.com/)
Thanks. So the best way would be calling the Java Main method from within JRuby. I was not sure if I should do it that way or call Ruby from Java. 
A lot oop practices are kind of being poo-pooed by the younger set, kind of like how Enterprise Java was the rails communities' early boogeyman. Any good heuristics for separating the wheat from the chaff of oop?
One good heuristic is how much of a Smalltalk background the source has. E.g. Kent Beck and Sandi Metz. Ruby's OO model is based almost entirely on Smalltalk's, so solutions from that world tend to be more "with the grain". Of course I say that having had no Smalltalk background of my own! But I've tried hard to learn lessons from that community.
I do not have access to a SQLServer to test but have you tried the ActiveRecord SQLServer adapter? https://github.com/rails-sqlserver/activerecord-sqlserver-adapter 
Hey realntl, I appreciate the feedback, and sorry i wasn't able to persuade you :) The examples are a bit contrived, and, when working with sufficiently small applications, I think the approach I advocate might be overbearing. However, it has been my experience that well-managed, larger applications tend to stratify into layers. Controllers reside in the outer-most layer, and ActiveRecord objects reside in the inner-most layer. As applications grow and the domain develops, the distance between these layers increases. Eventually, it becomes an issue for a controller, for example, to reach across layers and know that the "blog_posts" table has an active column. Code like "@posts = BlogPost.where(:active =&gt; true)" compromises layer independence. Updating our schema would demand that we also update the controller when we just as easily could have authored a "BlogPost.active" method. I like to think that when maintaining strong layer independence, Rails continues to shine. We can still leverage all the good bits ActiveRecord offers without forcing the other layers to know/care about ActiveRecord's presence. I recently swapped out ActiveRecord for Mongoid on a couple of models, and really wished I had been more judicious about letting AR references leak. Maybe the trauma of that experience is what has got me so wound up about managing AR dependencies. Anyway, thanks for taking the time to read my post!
This "tip" is actually pretty bad. Eager loading can solve the nested-associations N+1 queries problem.
`sinatra/base.rb` is 1979 lines :P
You might try to figure out how to make this more useful. I.e. make it a way to quickly stamp the users info into a contact page (e.g. it gives a nicely formatted badge in html) or as the author in a piece of code. I dunno if similar stuff exists in the ruby ecosystem. I know that a lot of editors have auto authoring and such. 
One of sinatra's design goals is to be only one file. Probably for those that wish to eschew the use of rubygems for whatever reason.
After fiddling around, I came to the conclusion that it is just better and easier to use https://github.com/alexch/rerun. (as [sinatra FAQ says](http://www.sinatrarb.com/faq.html#reloading)). This should not be a problem considering NYNY's instant boot time. And 0 code changes are required in the codebase ;)
would anyone mind explaining (in the most basic fashion possible) what exactly this is? or even what Sinatra does? I'm very new and I browse github in the hopes that I understand something and I'm not having much success.
I'm in the same boat. What the hell does it do?
After a quick look (i wondering why you need so much files) i found Parser.parse_day_argument(day) ( https://github.com/sanarothe/day/blob/master/lib/parser.rb#L96 ). You can use http://www.ruby-doc.org/stdlib-2.0/libdoc/abbrev/rdoc/Abbrev.html
Kissmetrics as well 
They're Micro-Frameworks for web development. In this particular case, using Ruby. They essentially act as Routing layers for HTTP requests. That is to say, it reads a URL and calls an action based on that URL. Generally they will include some kind of templates for generating HTML, but more than that and you're getting out of the "Micro" realm. The real use case is for non-traditional web apps as micros allow you to use any code you want to actually fulfill the actions requested by the routes. So, if you've decided to interface with Git rather than say MySQL for data storage, you're not going to use a lot of the nifty components found in Rails. In fact, they may get in your way.
I have found tiny_tds to be the easiest way to connect to MS SQL. 
I've recently been tackling the source code of Sinatra. I've been trying to adapt it to the Lua web stack embedded within nginx. To be honest, I've found the test suite to be ultimate way to understand the Sinatra code. Since, it is a DSL, it is hard to test via unit tests, most of the tests are mock-apps. What exactly is the difficulty? PS-Shameless promotion -- https://github.com/jtarchie/sinatra-openresty
Yeah, the N+1 is an old problem that Rails has already offered a pretty good solution for (eager loading).
Puma is great. It is replacing every instance of Thin and Unicorn in our setups. Threads are great in a threaded environment like JRuby, and it can do multiple workers, Unicorn-style, as well.
Thanks! I only understood about 20% of that, though.
So unicorn assumes low latency connections, it was one of our reasons for using Thin as we have mobile connections to our server. I didn't notice benchmarks for Thin. And I know thin credits mongrel as well as a predecessor. Have you noticed significant changes going from Thin to Puma?
EW cucumber.
Unicorn assumes low latency connections to the reverse proxy, not the client. Just wanted to clarify that.
After reading the article I did not get a sense of how Ruby is brittle. If anything Ruby is more like silly putty. Very malleable and resilient, but can stretch away from you at times.
Rake was one file for a loooong time.
no, but I like to refactor my codes you know.
Actually Puma works great on MRI as well. There seems to be a misunderstanding that threading only works well on JRuby and Rubinius.
The brittleness, compared to Java, comes from the lack of static type checking and static analysis tools in general. 
That's not what I would call brittle. I'd call that loose.
I'll admit there was a bit of hyperbole in my statement. Sinatra's code is very *clean*, but IMO the 2000 line base.rb file is hellish to read. "What module am I in now?" I guess it's little more than personal preference. But I think a significant majority prefer smaller, concern-seperated files.
I know this will be downvoted to hell but this is how I read the article: Any time saved by not writing boilerplate code in Java is taken by writing more tests to detect typos in Ruby code. I use both languages and still feel that there isn't much if any additional productivity in Ruby compared to Java. All the boilerplate in Java is generated by an IDE. Go ahead, downvote me for my opinion.... 
As a Pythonista who kind of wandered in here by accident, I thought I'd add my two cents because I am going through the exact *opposite* transition. I thought I'd never like Java because it's so rigid. Writing quick Python scripts that do a ton of cool stuff is a lot of fun. The code is concise and readable. From what I understand you more or less get the same experience from Ruby. But after writing a few mid-sized apps at my job I am starting to gravitate to Java because - The compiler can help much more when refactoring, or working with shoddy documentation. If I change a parameter list or a field name in Python, I have *no way* (built-in to the language, anyway) to ensure all of the relevant code has been updated. With Java it won't even run (which is good). - The Java community puts a huge emphasis on interfaces, dependency injection, and true unit tests. And I am a big believer in unit tests and TDD. I say "true" unit tests because, for example, the Django idea of a unit test comes from outer space and involves hitting the database and sending URL requests. See https://docs.djangoproject.com/en/1.6/topics/testing/overview/#writing-tests where `create()` hits the db. Other examples on that page use the handy-dandy Django unit testing 'client' which in essence tests the entire Django stack and your test database in addition to whatever code you were actually trying to hit. Test suites in Django are either slow running and fragile, or they're overcomplicated and difficult to read as a consequence of all the hoops you have to jump through to mock out what you need to mock out.
About to start looking into this one. Can't give any insight yet. https://github.com/ulfurinn/wongi-engine
Think of something like a firewall config, it's basically a long list of if-then statements structured in a nicer way. 
Google is your friend. Imagine that your team is in charge of calculating the cost of airline fares. (This is a really complex use case, but I'll make it a bit simpler for the example) There exist an extremely large number of inputs for this cost calculation, but let's assume for the moment that your inputs are length of the flight, number of connections, and which airplane the flight uses (your company has an old airplane, a medium airplane, and a brand-new one.) Here's the spec: If the length of the flight is less than 1000 miles, the flight costs $500. Otherwise, it's $1000. If there are no connections (direct flight) and it's more than 1000 miles, multiply the cost by 1.5- otherwise, multiply by 1. If the flight uses the cheap airplane, multiply the cost by 0.8, for the normal, 1.0, and the nice new one, 1.2. Now, write a highly-available service that calculates these costs on demand. The basic idea is that you want to write this in such a way that you're abstracting out the actual rules involved so that you can specify them in a *declarative* way instead of programmatically. The end-game being that you can write tools to allow the business side of the company to manipulate these rules without having to rely on developers to change the software. As the business grows, the requirements eventually become more and more complex, and eventually if you keep aggressively refactoring (and come up with a good architecture) you'll eventually have something approaching a rules engine- the idea is that you'll be able to store these rules in a database and use them to calculate an airfare, even with an arbitrarily complicated system of rules. (It's basically offloading the responsibility for the actual fare calculation logic to the business guys, who are responsible for that sort of thing.) With that said, I honestly think the best idea in this case is to use Java, since it does in fact have mature libraries for this sort of thing.
I dislike Java primarily because of that damn boilerplate code.
That's what op is saying.
For the productivity I'm not sure that I have a gain. I think the gain is mainly in quality. For the same time/investment, I prefer by far a working testsuite than untested boilerplate code (Spring helped a lot reducing this noise). Detecting typos is just a side effect of having tests ;) The productivity gain is more in the (rails) stack, not the language. A few days to get redis installed via puppet, integrating resque in my app, a few pluggins for retry, stats, the built-in admin page and the deployment procedure. It's not comparable with my experience with quartz-scheduler and integrating it in a websphere application server, building my own admin page,... 
&gt; Any time saved by not writing boilerplate code in Java is taken by writing more tests to detect typos in Ruby code. Having moved from Java to Ruby two years ago, I actually thing you are sort of right. Except that a tested code base is of much more value to me than boiler plate code - ie, you still have to write your tests in Java... 
Are you using it in development?
Would be nice to have that done with Cucumber -type domain specific langue.
What is so horrible about a unit test that hits the db? Productivity over purity.
You were given a gift. Would you rather have quit your current job, started working for this person, then figured out what type of person he was and realized then it was a huge mistake? I wouldn't say you were shit on, I'd say the guy did you a huge favor. 
Its really easy to write a domain specific language in ruby that pretty much eliminates the need for such things. [Here](https://github.com/PeopleAdmin/stressque/blob/master/examples/demo.dsl) is a link to an example from a gem I authored for my company. And [here](https://github.com/PeopleAdmin/stressque/blob/master/lib/stressque/dsl.rb) is the code that will evaluate that into a ruby object graph. If you are new to ruby, you may need to look into tutorials on DSLs and/or metaprogramming for that to make much sense. EDIT: Fixed links.
I've found that a lot of programmers without a CS degrees can feel threatened by those who have one. Its no big deal when you have been around the block ~ everyone has strengths and weaknesses and in a team you play to these. Your guys reaction suggests he has yet to acquire the experience/maturity to understand that a good CS graduate has a lot of strengths to offer rather than being a personal threat to his position or ego.
Yeah! I hate all the dick measuring competitions in our industry. Just be a cool dude. Stop trying to one up each other.
Agree with all of the above. Still, it's also possible that the tone or way you mentioned the degree put him off somehow. More likely, that was the case with the guy before you in line. So it may be that this is still a good job for you. Apply. See what happens.
This is moving from one extreme to another. Many people are conscious of the fact that you don't need a college degree to be a great programmer, but it isn't that widely accepted yet. The bigger corporations find degrees a mandatory qualification criteria and refuse to entertain candidates who don't have the academic qualifications. This guy clearly was playing to the crowd and wanted to look 'cool' for 'sticking it to the system' or some equivalent phrase. He's probably insecure about his own standing (pointing out how he is 'one of the better programmers' without his degree). You should definitely be thankful you aren't working for this guy. One fanatical view says you need a college degree, the other is this guy. Anyone with any real common sense in hiring a programmer knows that a degree in computer science is definitely a good thing to have, just not a necessary thing to have.
I would recommend getting involved in an open source project fixing bugs/small issues. You'll get code review feedback that will improve your skills much faster than writing code in isolation. At the same time, I'd pick some sort of side project to get started on. Make it concerning something that you have an interest in outside of work. If you are a biker, make it a ride partner matchmaking service. If you like to read, make it a book sharing site. It doesn't matter if it is already done better by some other service, you just want a showcase of skill. Having an interest in and understanding of the topic/domain will ensure you keep at it and will be able to understand the desires/issues of users with a similar passion/interest.
Degrees are not simply certifications. They show a track record and provide a history of the person holding. Degrees are little pieces of paper that show you were taught how to learn and approach problems in some discipline or another. Throws me up the wall everytime people lose site of this.
sight* ;)
Be glad you didn't get hired there.
That's an integration test. It's not horrible, but the times when you want to run integration tests are typically not the same as when you want to run unit tests, primarily because they take longer. Also, you might be like me and coding on the train, and some integration tests that require external servers are impossible to run in that setting.
You don't, really. You could use JRuby or Groovy, for example.
Computer Science != Programming. Many people don't get this. Some do, and feel defensive. While most computer science majors also learn how to program, and consider that a primary skill, computer science programs teach more theoretical things like algorithms &amp; analysis, data structures, boolean logic, operating systems, assembly language, theory of computation, etc. It's a different set of skills. Maybe it's not necessary for this particular job, but CS-trained software developers bring a completely different game to the table for deep problems. 
From the title and description you gave, I think it may have been the tone you used. I have also learned through job interviews, the Ruby community in particular will often not ask or care if someone has a CS degree. I'm not saying his reaction was justified, but maybe next time wait until you are asked if you have a degree. I am on my 3rd full-time Ruby job and only 1 of them even asked if I have a degree.
Of course I'm biased, because I have a BS and an MS in CS, but I also have plenty of experience. I've seen people without CS degrees rising to Architect, CTO, VP of Engineering. I've also seen people with Masters and PhDs that can't program worth shit. That been said, with a dick like this, he's probably right when he says he's one of the "better programmers" with his metric of "better". I bet he means banging out code that functions correctly and does what the customer wants. We have these types of people at our company, degree and not. We use them to make prototypes of new product offerings that have never been tried before. Is it maintainable? no. Is it perfomant? Not at all. We acquired a startup company 2 years ago that had a product making good money, but each server could barely take 20 requests per second before they toppled over. Requests routinely took more than 3 seconds. So we couldn't throw new clients at it, and the existing clients were all angry at the percentage of 500 responses, and the slowness. We're almost done rewriting it, and the new code doesn't even break a sweat at 800 requests per second per server, and most requests take 100 ms or less. How? They had reinvented so many wheels, and done so much unnecessary computation due to bad design, no understanding of algorithms, nonsensical db schema, blocking when they shouldn't, etc. Go look at twitter's developer blog. Read about the things they have to do to handle the billions of tweets they shove through their systems. Do you think this guy could ever dream up of these things? In his defense, though, he'll probably sell his company for big money before learning how to scale. Your degree should have given you a fundamental understanding of how computers and programming works, which will give you a head start on guys like this.
as a programmer without a college degree, I completely understand where he is coming from. If like you said he had a swarm of people all kissing his ass. Every one of them were probably spewing out their accomplishments. I have been turned down for so many jobs because I don't have a college degree. I applied at a hospital, I was a perfect fit, the managers wanted to hire me. But HR refused to let them because they require all administrative employees to have college degrees. Perhaps you telling him that you have a degree was perceived as "I have a degree so hire me." It has been my experience to avoid mentioning anything about a college degree and impress them with my accomplishments and experience. All that being said. He could have responded better and not completely disregarded you on that one fact. 
"Degrees are little pieces of paper that show you were *taught how to do what you're told*". Which, in my opinion, is great. :) Disclaimer: Pending the school it was from.
This is kinda sad. I have a degree and work with people of varying degrees (no degree, PhD, masters, etc.). While he's right, it's not as important as it once was, there's no need to act like an ass about it. 
With that attitude I'd be willing to bet that he is not, in fact, one of the better programmers. 
anyone fiddled with the latest linux multiple process per socket model? I'd be interested to see which web server can take advantage of it best
I like to to think that a degree is a nice way of proving you have at one point known at least some of the things you should know within your field. But that does not matter at all if you get to an interview and the person turns out to be a complete tool. I am still in uni (1 year to go), but I think that it will be programming experience/past projects and my ability to show that I can solve problems that will get me a job, not the fact that I'll have a degree in something. As you said, the degree is (now) just more of a way to filter out unqualified applicants for larger companies that get thousands of applicants for the same positions. But if someone can prove that they have the skill-set needed to do a job, why would a company reject them just because they haven't got a degree. :/
As a programmer without a CS degree, this is spot on. Over the past 2 years I have been programming in Ruby, and my friends have been completing their CS degrees. Since I have been practicing Ruby for 2 years as a profession, and teach myself other languages along the way, I have vastly more programming skills and experience. However my friends with CS degrees bring a different perspective and experience to the table. This makes for a pretty good team, especially when exploring and adapting new technologies.
They make more money on the ones who continue their education.
A test that hits external API's is a way different animal than a test that hits the db. Orders of magnitude in the time domain. And one works on the train, and the other doesn't.
*edit. whoops
Even though I support CS Degrees, if you can't explain why it is relevant or gives you an edge, then people might just see a more expensive employee with student loans. 
In my experience, those that scoff at college degrees are often shit programmers that don't know enough to realize how bad they are. Getting your ass kicked in undergrad teaches you to keep learning and progressing even when you fuck up. Learning while simultaneously receiving a paycheck and not receiving a single note of negative feedback puts you into a mindset that you're good at what you do. There aren't a lot of people out there that will tell you that your code is outright shit to your face, and that you're making life miserable for your team. What usually happens is, they just stop dealing with you, accrue technical debt, and hope you leave the company before you really ruin things. I'm not saying that all programmers without a compsci degree are bad or conceited or poisonous to your team. I am saying that in all of the interviews I've done, people I've met, and situations I've encountered I've found that people that have a BS in compsci generally think differently and often have a particular humbleness that makes them pleasant to work with. There are always exceptions to this though and a few of my coworkers past and present definitely fit in that bucket. I'm sure I'll get down voted to hell by people without compsci degrees and there will be replies with "This famous person doesn't have a compsci degree!" but I think that misses the point. We're undervaluing people who have formal educations because suddenly that's the cool new thing to do.
Somebody's insecure.
I've always found the most important trait is not a degree but whether someone really loves what they are doing and is willing to put in the time investment into progressing their knowledge and skills. I got a degree because i love the subject and i've been studying for a long time before and after I started to progress my knowledge. No one has cared what I got apart from when I applied to a graduate position. 
I consider myself to be a "pretty good" programmer. I'm a high school dropout, but I've been writing code for a living for something like 12 years now. However, that doesn't mean that I'm not painfully aware of how much better I would be with a good systematic understanding of computer science, and it's difficult to get that outside of a university environment.
It's a good way to ensure that it stays small.
If the student didn't absorb the material then they wouldn't have passed with a good grade (if they passed at all)?
Yep. But they're both integration tests.
/endthread
Unless you dropped out of college yourself, it's hard to understand how alienating it is to get a livelihood without a degree. He probably has a huge chip on his shoulder, and now that he's in a position to influence hiring, he's taking it out on applicants.
I have met some great developers who didnt go to college, but I have also met some developers who sound just like the guy OP was talking about, one who was incredibly arrogant and would often rant against college as being useful saying only idiots would waste money on it... but he *just* found out how relations in sql databases work, over a year into being employed as a developer... When he posted that question to twitter it was amazing. "uh... thats what a foreign key is for, dude..." "What?" And, likewise, I have met some great devs who went to college, and some shitty devs who went to college.
While true, it doesn't mean that a CS degree isn't relevant to a software engineering job. My degree is in anthropology, and I've been doing engineering for almost 10 years. I've made it this far just fine, but I would never suggest that a CS degree isn't valuable. In reply to OP: mirroring other sentiment that you dodged a shitty working environment that has some really braindead bias.
The Overconfident Douche is a typecast in the Ruby and Rails world, unfortunately.
Good Guy Scumbag hiring manager - lets you know he's an asshole so that you don't make a mistake and work for him.
What you see here isn't just a guy that doesn't have a degree, but one who is very self-conscious about the fact that he lacks a degree. A CS degree doesn't make a programmer, and one can be a great programmer without one, but a CS education most certainly is *an asset*.
The tests are purposely designed like that to show the standouts. They are designed to be harder than what you have learned and aren't basic multiple choice tests like other majors. 
Bullet dodged.
Dammit, what'd you say? I feel left out now.
Ah, gotcha. It's sad that people looking to fill positions would be that hostile.
Why would you want to use the new model? It only solves a very specific problem and does not bring performance advantages.
&gt; I don't have a college degree, and I can honestly say that I'm one of the better programmers at my company. Sounds like someone I wouldn't want to work with.
&gt; I walked up to him, had small talk That was a good idea, but you should have had ruby instead, he'd have been more receptive that way. :-)
Ruby programmers seem to be incredibly insular. Like it can't be picked up like any other language. Silly. 
Fuck that guys, I don't have a degree either (and I'm doing great in the field) but I don't discount the value of one. People with that attitude feel they know everything and therefore have nothing to learn.
What part of the world did this happen in? All the ruby job ass-kissery I've witnessed has been from desperate companies trying to hire developers, not the other way around.
If you're the best programmer at your company, you need to find something more challenging, in my opinion. If you aren't constantly growing, you're constantly falling behind. Unless you're John Carmack. Then you're ok -- and I apologize, Mr. Carmack.
This isn't tennis where you need to play against better opponents in order to grow.
Even though I've encountered far more of them in python…
To be fair: He's probably insecure because he's run into the "degree required" mindset so much it's a knee-jerk reaction by now. I know in my early years I had to deal with a lot of snobbery from my degree wielding peers. I personally probably would have said something like "Great! So you're verified as trainable then."...
&gt; "Degrees are little pieces of paper that show you *can f--king finish something*". FTFY. At least that's how it's becoming for me. Have hired a couple of people without degrees that could write code, but could not actually finish anything to save their lives. 
I understand this... some people are idiots and get degrees. It's as if they collect 10 coupons from the back of cereal boxes and pick up a degree - that's how much they deserve it. I too have a degree and think that it's too easy to get a degree... you can have two people who get the same grades but may be worlds apart in the ability, workrate &amp; eagerness to learn. Having said that, i'd never act like this &amp; voice this if interviewing someone i don't know... it's just douchebag, dismissive behaviour... for all he knows you could be some kind of genius or have worked on some interesting / successful side projects etc...
The equivalent to the Computer Science degree in Denmark is called "Datalogi" (Datalogy), literally knowledge about information ([data is information](http://en.wikipedia.org/wiki/Data_\(disambiguation\)) and [logy is knowledge](http://en.wikipedia.org/wiki/Logy)). When people ask me what I studied, I tell them datalogy, and then I continue: "But not what you think datalogy means". We are not taught to use a computer, we are not taught to program, these things we have to teach ourselves while studying how to structure and visualise data, using data structures, algorithms etc.
You really need to get up to speed on the things available for autodidacts ... all that wonderful knowledge is available in books. Beyond that, there are tons of OCW (OpenCourseWare) full college courses (all material, notes, lectures, etc) available. It really isn't difficult to get outside of a university environment if you are motivated. There is nothing stopping you from acquisition of such knowledge, it is the golden age of the self-taught. - http://www.ocwconsortium.org/index.php?option=com_coursefinder&amp;view=search&amp;Itemid=9&amp;q=computer+science&amp;l=English - http://ocw.mit.edu/index.htm - ... 
... getting your ass kicked in undergrad. Maybe at MIT, CMU or a small handful of others, but that is not generally true. Sadly grads are coming out of universities unable to do FizzBuzz or answer basic CS questions... I have interviewed literally 300+ recent grads in the last decade in a half. There is a REASON every job asks for experience (even entry-level, which if you think about it ... is insane, but required unless you want to run a high paid internship that they didn't bother to do during their education) -- CS students are generally (with exceptions) entirely worthless. I don't know if it is rampant cheating, the idea the "CS is where the money is" causing people who hate it to take it, the general downfall of universities as they become HighSchool++ or what... but the quality of US college grads has been dropping like a rock for the last 15 years -- I am horrified by it. There are exceptions of course, grads with good GitHub profiles, grads with great internships, grads who started programming at 6, etc. But generally speaking it is scary bad... I would in many cases rather have someone who hasn't been ruined by a bad CS program to train. EDIT: This problem is why FizzBuzz was created: http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html ("Most good programmers should be able to write out on paper a program which does this in a under a couple of minutes. Want to know something scary? The majority of comp sci graduates can't." --Imran Ghory) 
True, can't overlook that aspect. 
No.
The [Expert Beginner](http://www.daedtech.com/how-developers-stop-learning-rise-of-the-expert-beginner).
Get on [Coursera](https://www.coursera.org/) and/or [Class Central](http://www.class-central.com/). There are a number of CS courses and many are good.
What is the purpose of having our jargon distuinguish between unit and integration tests? Why does hitting the database necessitate a change in terminology from "unit" to "integration?"
I think this depends on where you get your degree from. I was required to actively program, solve problems, and regularly submit code while in school. In addition to all the theoretical crap. It wasn't particularly *heavy* on the coding, I admit. But, to your point, my job right out of school was a Ruby on Rails web developer position. I was completely lost for 3 months.
Because the philosophy behind a unit test is to test the smallest part of your codebase in isolation. If a database and connecting to the database are involved, there's no "small" or "isolation" going on. 
It's not about opponents. It's about having people you can learn from, learn with, and build with. Being the smartest guy in the room can be comfortable, but it's hard to be challenged and grow in an environment like that (for most people). 
I have no idea why the word 'brittle' is applied there.
&lt;nitpick&gt;The test **is** running it&lt;/nitpick&gt;
Think of Sinatra as a DSL for expressing how a web server will respond to various requests.
Many Msc's and PhD's in CS are more theoretical. They can program far enough to prove the concept, and that's it. How they got into lead dev spots is beyond me, however.
How rude!
What a degree *should* indicate is that you've spent x amount of dollars and 3-6 years learning to efficiently work with computing. Which is not an easy task, at all. Now, that says nothing about whether or not you're anything special when sat down infront of a keyboard, but it *should* help with the problem of a company, scratching their heads at their software's performance problems, when 5 of their programmers have no intuitive idea whatsoever that they've implemented 10 core O(n^x) algorithms within the codebase for things they would have learnt have efficient data structures - if they had a CS degree.
&gt; Perhaps you telling him that you have a degree was perceived as "I have a degree so hire me." That's exactly what it's designed to do, but any possible employer doesn't have to be an absolute dick about a candidate employee mentioning what he thinks to be relevant experience. 
For a little extra detail, I think this StackOverflow answer gives a pretty brief and clear definition of the different types: http://stackoverflow.com/a/520116 My only minor gripe with that explanation is that the unit tests can also be on plain functions; there's no inherent connection to classes or any other OO concept.
Maybe I misinterpreted Poloniculmov's comment above (about not finding a typo until you run the code) as meaning you won't find it until run-time (i.e. when you run the app that uses the method). Not recommended. Sure, testing it *is* running it, no argument there. I guess if one wanted to really nitpick one could bring the old tree falling in the forest argument: if a method has a bug in it, but no-one ever calls it, is it buggy? :-)
I have seen developers defining a CLI class with a `#run` or `#parse` method that parses the arguments and sets various instance variables.
This is absolutely true (and I say this as a programmer who failed out of college, twice). CS : Programming :: Math : Arithmetic Not to mention the difference between being a good programmer and being a good developer...
Same here. I often go to the local Ruby meet-ups and they are all a bunch of cool people. On the other hand, the Python guys I had to work with at my last job were extremely difficult to get along with. I have never worked with people with such big egos and they made my life hell. I no longer work there (currently unemployed as of this week) and I couldn't be happier.
I cannot imagine where my career would be if I relied on my employers for challenging / stimulating work. The smartest guys in the room get to be the smartest guys in the room by putting in the time off hours. 
wouldn't wanna work for such a poop anyways...
What I meant was. A degree does not automatically make you qualified for a position. 
Hey, can you, like... Tell us what this company is, so none of us apply there?
A culinary art school doesn't just teach you how to cook though, they teach you how and when to utilize certain skills/tools. Just like art school won't make an artist, but it can equip them with some valuable knowledge.
It's about balance. A CS degree doesn't mean you're a good programmer. It also doesn't mean you're a bad programmer. Don't treat people like lepers due to how they were educated. Use them for whatever they do best. I had to do a bunch of stuff with non-linear calculus over the last few days, but I haven't used the stuff in so long I'd forgotten half of it. Turns out one of my sysadmins is pretty good at graph theory type stuff, so we put our heads together and as a result it all got done on time. This is how real teams function. You realize first and foremost that regardless of what your primary training consists of, you're all on the same side. No man is an island. It doesn't matter what you know, or what you think you know. What you can do is all that matters.
Simple explanation: he doesn't have a degree himself and resents anyone who does. If he were any good as a developer, he would know his personal shortcomings are irrelevant. In short, I agree with the others here: bullet dodged.
This. A million times, this.
Python users seem to be very polar. They are either awesome guys who are fuck yeah awesome, or lame schlubs who think that they are gods gift to programming. I've encountered a very small portion of the former, and a tremendous portion of the latter. Its actually one of the things that contributed to my quitting CS, transferring to COMM, and learning ruby
If I recall correctly, Sinatra does this well. Ah, I [did](https://github.com/sinatra/sinatra/blob/master/lib/sinatra/main.rb)!
You're saying exactly what I did. :)
Fuck that guy.
Never been more proud, -1 and Reddit gold! Thanks! 
Assuming you went to a decent college, you get exposed to a bunch of very useful stuff that you would otherwise have to really work hard to learn outside of a regular 9-5 programming job. Things like compilers, functional programming, artificial intelligence, graph theory, fourier transforms, group theory. While it's possible you could teach yourself all those things in your own time, it's a great deal of effort and is certainly (unless you work for a very interesting company) not going to be something you encounter as a normal everyday web developer. You could argue that such 'esoteric' skills are not important, and you'd be right if you just want to be an average programmer, but top-tier programmers who push the barriers and event new and sophisticated libraries and applications **do** know this stuff and it's part of the of the reason they're top-tier rather than just a middling programmer.
Where you GOing with this? 
:) 
I learned how to do FizzBuzz in 9th-grade highschool Pascal. I'm not sure what's going on with these people. 
Educated people are more expensive. He was probably looking for 'cheap and desperate.'
Indeed, I really only listed the most obvious ones, there are hundreds of others (a lot of them amazing). 
No clue, but the reason why FizzBuzz was created was because of this exact problem: http://www.codinghorror.com/blog/2007/02/why-cant-programmers-program.html Observation from Reginald Braithwaite: "Like me, the author is having trouble with the fact that 199 out of 200 applicants for every programming job can't write code at all. I repeat: they can't write any code whatsoever. "
This guy sounds like a douchebag. Q to you: do you want to work with people like that? With a thirst for knowledge and learning you should be seeking out the people who will help build your skills. This doesn't sound like a mentor. 
He's insecure. He's worried you think you are better than him because he didn't go to college. In order of priority I am going to look at a candidate based on: - Github profile - Employment history - Personal life/interests (interesting people are easier to get interested in things) - Education At 2 years experience, your degree is going to be a big part of your experience so I'd want to talk to you about it some more than I would somebody in their 30s, but it's still just a shortcut way for me to know that you should know your quicksort from your bubble sort and you're not going to glaze over when I point out your algorithm is clearly O(n^4) and we shouldn't deploy it into production... The guy did you a favour though. He's a jerk. He's not interested in you, he's interested in himself. Move on. And if you're ever in London looking for work, throw me a PM. :-) -- A CTO who hopefully isn't a jerk
Well... the article isn't even right. cheeses[1] = gruyere =&gt; "gruyere" cheeses =&gt; ["mozzarella", "gruyere", "gouda", "cheddar", "mascarpone"] First of all, `gruyere` will come up as an undefined local variable or method, and secondly, the correct line, `cheeses[1] = "gruyere"`, would replace `"gouda"` in the array, so the result is ["mozzarella", "gruyere", "cheddar", "mascarpone"] Now, this won't achieve what is talked about in the article, you'd need cheeses.insert(1, "gruyere") for that. Was that even run in irb or so? Would have caught both mistakes easily. 
Ah! You're totally right. Sorry about that, I was going back and forth between irb and my text editor. I'll make the changes soon.
I came here to say this. I would never subscribe to this guide after seeing this sample of the work.
That's interesting. If I had just read the name "Datalogy", I would have assumed it was akin to Information Science programs in the U.S. But the way you describe the skill base, its clearly closer to Comp. Sci.
Absolutely. I like to break it down into three independent disciplines: Programmer, Software Engineer, and Computer Scientist Each of these things are a fairly independent, if inter-related, set of skills. It's worth noting that most professionals have overlapping knowledge and skills from each of these three disciplines.
What about Struct? class SprintMountConfiguration &lt; Struct.new(:initial_angle_separation, :tube_mount_radius, :base_mount_radius)
&gt; class SprintMountConfiguration &lt; Struct.new(:initial_angle_separation, :tube_mount_radius, :base_mount_radius) OP says: &gt; I do not want to use attr_accessor, because I want to force the three variables to be defined up front but with Struct: 1.9.3p327 :001 &gt; class SprintMountConfiguration &lt; Struct.new(:initial_angle_separation, :tube_mount_radius, :base_mount_radius) 1.9.3p327 :002?&gt; end =&gt; nil 1.9.3p327 :003 &gt; SprintMountConfiguration.new =&gt; #&lt;struct SprintMountConfiguration initial_angle_separation=nil, tube_mount_radius=nil, base_mount_radius=nil&gt; Struct doesn't complain about missing attributes in constructor calls.
Unfortunately [this](http://bugs.ruby-lang.org/issues/5825) didn't make it in to ruby 2.0 because it solves your problem nicely. If you're dead set against typing it out you might be able to do something hacky like class Foo attr_reader :a, :b, :c, :d, :e def initialize(a, b, c, d, e) method(:initialize).parameters.map{ |(_, name)| instance_variable_set(:"@#{name}", eval(name.to_s)); } end end f = Foo.new(1, 2, 3, 4, 5) puts f.a # 1
No, given the options I'd rather type it out. My goal wasn't to avoid typing them for their own sake, but to save time and make the code cleaner. class Me def initialize(@name, @age, @location); end end That is *exactly* what I was after. Pity it wasn't implemented; it's perfect for this application. Oh well. Thanks anyway.
The first parameter to CSV.foreach should be: params['myfile'][:tempfile] not .read 
That does indeed work. Thanks!
Build knowing the ideas you have now will be vague recollections at best in the future. Strive for simplicity. Refactor to greatness.
Just don't forget to refer to them as self.initial_angle_separation inside the class, not @initial_angle_separation. I'm sure you know this, but I'll bet it's a gotcha for anyone who's new to Structs :)
&gt; most typical/practical high paying gigs, not so much. High pay has absolutely nothing to do with it. It's probably part of the problem, actually. I know a number of very average programmers who happen to work for a company that pays well -- and they correlate this salary to their skill level, and think they're awesome. They're not. It really depends on what you mean by a "big deal in IT". If all you're talking about is getting a job that pays well, then that's one thing, and there's plenty of epsilon semi-morons walking around who know a bit of rails and get luckily employed by a company that pays big bucks. Programming is as much a science as it is an art, all things being equal (i.e considering two people of equal creativity) - the person who knows more about the science simply has more tools at his disposal.
Ok, so your definition of a 'good developer' now includes someone who is not good programmer ('average') but is a good manager/communicator... This is not what i had in mind when i started this discussion, I'm not sure it makes sense to continue it when things are this vague and loose.
Of course it's not necessary, it would be stupid to argue it is. All that i'm saying is simply a truism: i.e the things you learn in college are often things you do not get a chance to learn in 9-5, and they add more tools to your toolbox. That's all. A simple example, you have a situation where a 'btree' datastucture would be useful. If you studied btrees in college you would know (1) to recognize when to use it (2) how to implement it if no library exists for that. A person who does not have that knowledge would possibly come up with a very inefficient solution to the same problem.
Preferred is SpringMountConfiguration = Struct.new(:initial_angle_separation, :tube_mount_radius, :base_mount_radius) do # methods end
I wish I could upvote this every day.
About ten years ago, I went to an Intel recruiting event. Some senior VP of widgets gave a lecture that was supposed to be about what they were hiring for and why we should work for Intel. He spend the whole hour talking about how great he was, then left the building. The poor HR people he left behind had no idea what they were hiring for or what skills and experience were preferred. I was astounded that Intel would waste the afternoon of 300+ talented candidates.
Oy. This is a reddit link to a link in reddit? Why? 
i was just recently in a similar situation but it was them telling me we can't continue interviewing because i don't have a college degree. it's actually sad. it made me really sad.
Thanks for making this! I used this a little bit when I started learning ruby.
Note that it's just a simple [Thread pool with Queue](https://github.com/eagletmt/bundler/commit/a671cc73c0cf035b9d0944bbfc16973ea4080112). Threading in Ruby &gt;= 1.9 works, we should be using more of it, especially now that even our phones have multiple cores.
I was under the impression the problem had been the dependency resolution portion and preventing conflicts, aggravated by needing to fetch the entire gem to get its dependency list. Any idea on how that was resolved? This self-documenting code really doesn't make it clear.
That was fixed a while ago. Now bundler requests metadata for individual gems from the new rubygems.org API, instead of the legacy bulk metadata API.
This is pretty cool!
That rubygems.org API has been down for a long time. After rubygems.org went offline for a few days and it was determined that endpoint was too expensive. Has that been re-enabled? It sounds like you're saying it has, in which case, do you know when it went live again?
I just checked out the github page and I like it. I am working on http://www.versioneye.com and we track versions for several languages. Actually I had already the same idea but I am glad that somebody else started it already. I keep an eye on it ;-) 
In Unicorn/Puma/Rainbows, the master process does not distribute connections. It merely creates the server sockets and lets child processes inherit them. Distribution of socket connections happens at the kernel level, not in userspace. There is literally no difference in overhead between the current prefork model and the new model.
Great software! Thanks for making it! I was wondering if you could recommend a good keyboard to use with it. I always struggle finding symbols/braces/etc on the ones I have. 
Would be nice if this also worked with bundle update.
Thanks, I will look into doing side projects for my interests.
Why bother taking up the gem name on rubygems if you think it's so unstable that its not even 1.0.0? If it's done suck it up and 1.0.0, but if it's not then don't take the gem name. Someone else might want to use it for something finished.
[Here's a screencast where someone implements "Conway's Game of Life" in Ruby using RSpec to write the test for a new piece of functionality first, and then implementing that piece of functionality.](http://www.rubyinside.com/screencast-coding-conways-game-of-life-in-ruby-the-tdd-way-with-rspec-5564.html) Hope that helps for a starter. There are other screencasts like this. I'll give you the honest truth- it was hard for me to learn to code this way (I've been programming for 20 years but have only done TDD for the last 1-2), but the payoff (like many things that start out hard) is in fact big, and well worth it. I would say that if you intend to become a developer without peer, learning this is the way to go. Once you see how awesome it is (once all is said and done), you won't want to go back. :) At my job we actually (only half jokingly) do something called DDD- Document-Driven Development. First we write the docs for something (forces us to think about how it will work to end-users), then we write the test for the rough framework of it (forces us to think about how the programmatic interface to the new code will look) and then we finally build the functionality. One advantage of writing the test first (among many) is that your test becomes the very first "client" of your code, so you get to use your code even before you have written it, which then informs how it's designed. You find that very quickly, things that are too complex or kind of ugly are also really hard or clumsy to use. Unit testing well also forces you to break up big methods into pieces and too many methods into separate objects. The best tests to learn how to write well are unit tests (where you "stub out" any collaborator objects). However, functional/integration tests (which test the collaboration of multiple objects) also need to be covered. But 90% of a test suite's code should (IMHO) be unit tests. Learning to write tests well will make you a better programmer in general. The best part of superfast unit tests (they're fast because they don't actually load up all the dependencies- they stub them out with fakes) is that it gives you the freedom to completely rip out the implementation of something and rewrite it from scratch while still having reasonable assurance that you didn't break something that used to work in the prior implementation (aka a "regression"). I structure my class code in such a way that when I "run" the class file (in Sublime Text 2 it would be command-B on Macs), it runs the unit test for that class. [Here's some sample code I wrote that does this.](https://gist.github.com/pmarreck/2896930) [Here's a "roman numeral" class I wrote that has some unit tests at the end of it.](https://gist.github.com/pmarreck/5104951) If the functionality is fully encompassed by a single file, sometimes I just put the test at the end of the file that way so that it doesn't need to have a second test file riding along.
Ever heard of semantic versioning (http://semver.org/) ? Also "finished" is a pretty laughable term when it comes to software.
Not only have I heard it, that's what I'm talking about. If he's released it for public consumption (he has) and it's being depended on (it's got a fair amount of downloads and has an active issue list), it should be marked 1.0.0.
lol, you again? &gt; If he's released it for public consumption (he has) and it's being depended on (it's got a fair amount of downloads and has an active issue list), it should be marked 1.0.0. False. The semver specs do not say this. The semver FAQ barely even implies this (it says it should "probably" be 1.0.0 if its being depended on in production environments). You have an open PR into semver that you submitted in order to retroactively pretend like you were right all along. I have no clue why youve decided to interpret one line in the FAQ as a steadfast rule and then badger every gem author in /r/ruby about it, but semver absolutely does not say what you are saying it does.
Neither the amount of downloads, issues nor users has anything to do with the version number used. Version numbers, whether you follow semver or not, give an indication of how stable the code-base is. The amount of issues might be the result of people using it (which is not the case as most of these issues are reported by me) but it does not contribute to more stable code (thus a stable version number). The reason I'm keeping the version at 0.X.Y for the time being is as following: 1. The internals will change as I learn more and try different things out until I'm fully satisfied with something that is maintainable for a longer period of time. 2. ruby-lint is still a fairly young project, not in terms of age by months but by the amount of things it supports/doesn't yet support (Ruby source code wise). Using a version number such as 1.0 would in my opinion falsely indicate that this would be different. I also fail to see how one shouldn't "take the gem name" unless it's "finished". If that were the case there would be no Gems on RubyGems and thus no easy way to install them (yeah good luck getting people to install Gems from Git including every dependency).
undefined method 'ask'. You need to post the ask method. You also are using "alert" as a method in 'alert "This not..."' and as a variable in 'alert = tempNote'. Was it a typo and is it supposed to be a variable? Is "alert" supposed to be the the thing that shows up? There's a lot of confusion by introducing so many different variables. I did some testing and I'm assuming that your 'ask' method is one that gets a string that was inputted from the command line? def ask(asking="") puts asking gets end If that's the case, then you need to strip the trailing "\n" when getting the input. Otherwise, your comparison to luDispNote will always fail. def ask(asking="") puts asking gets.strip end 
Thanks, I'll check it out. 
Probably because (a) you are assigning to alert, rather than calling alert in the second if block, and (b) your else blocks aren't outputting anything, they're just returning a string. Maybe you want: puts "Sorry, I didn't get that" Or possibly alert instead of puts. Separately, I think the code would benefit from using standard ruby naming conventions, like "display_note" for a variable. Is "lu" some kind of Hungarian notation prefix? Is that helpful?
thanks for the suggestion @mhink. This is definitely one option I am exploring
Protip: Don't use mocks or stubs. Seriously don't. Okay, only use them if you are mocking a call to an expensive external API. Why not use mocks and stubs? Because they will lead you down the road of false positives and brittleness. You are still learning though so you won't listen to me. Go ahead and go mock crazy, use them as much as you can, eschew fixtures and use mocks. When you are done with that try only mocking outgoing messages to an external class. So if one class makes a call to another, mock the message responses from the other class. After you are done with all that, try not using Mocks at all, and then see how you feel. Use a mock when you want to assert that a certain behavior is happening Use a stub when you just want to make sure a method call returns a certain value so you can carry on with a test of some other behavior. The key difference is that a mock is a type of assertion and will fail unless something happened, a stub never causes a test to fail directly. You use a mock when you want to verify some type of behavior is happening, you use a stub when you are testing something else than what is being stubbed.
Cheers mate. Can't wait till he releases it to the rest of us. Thanks for your advice. I got a better understanding of mocks/stubs with your explanation.
Probs because you assign to tempNote instead of luTempNote. But i'm pretty drunk right now, so wht do i know
With not much more to add, I'll second that.
What about mocking network stuff, e.g. external APIs?
I've yanked a lot of gems that I pushed up pre 0.x that I pushed before coming to this conclusion. I simply forgot to yank that one, thanks. It's now available.
why bother being negative? it doesn't add value to the discussion. And who releases at v1.0.0? v1.0.0 implies a stable API. &lt;v1.0.0 doesn't imply unstable software but that the API has not been finalized enough to call it a v1.0.0.
I'm not being negative. See the replies to my comment for negativity. I release at 1.0.0. In semantic versioning 0.X does imply unstable software. Go read the spec.
you're being very negative. the poster shows off some code and the best appreciation or acknowledgment you can give is a bunch of nonsense about how he is versioning the project. you can release at 1.0.0 but your way is not the way for everyone, nor should you assume it should be. &lt;1.0.0 in all the open source projects ive contributed to has not been for unstable software. it has been for software without a well defined API. that's how I define the jump between 0.X.X and 1.0.0. that's how a lot of other people do too. it's not how you do it, and thats fine. celebrate the code and not this nonsense. in respect to yorick, i'm not engaging you any longer.
You may see it as non-sense, but I don't and I definitely don't assume it should be for everyone. However, if you're going to pretend to use semantic versioning then you should probably follow the guidelines.
As a kickstart to understanding mock objects in a Ruby context, I recommend [this talk by Gregory Moeck](http://www.confreaks.com/videos/659-rubyconf2011-why-you-don-t-get-mock-objects). The best resources on the subject of mocks and stubs in general are the people who introduced the use of mocks and stubs to the testing world in the first place, Steve Freeman and Nat Pryce. Start with their paper ["Mock Roles, Not Objects"](http://jmock.org/oopsla2004.pdf), and if you want more, move on to the classic ["Growing Object Oriented Software, Guided by Tests"](http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627). The fundamental thing you will learn from all of these resources (which you are likely to see confusion about from people who were not introduced to mocks in the context of TDD) is that mocks and stubs are *tools for thinking through your object design*. They do not exist to speed up tests, or to simulate external code that you didn't write.
...I'd like to answer your question concretely, but I need to get my morning tea before I write any demo code. Be back later.
Why thank you! May I quote you?
Avdi is a dedicated Rubyist and teacher. Everything he does, he does to improve the Ruby community and everyone in it. I'd say buy it without a second thought. For further praise: When Sandi Metz's POODR book came out, I recommended it to a colleague who was relatively new to Ruby. Now that Confident Ruby is out, I would recommend Confident Ruby first and POODR second. And if you've already read POODR.. Read Confident Ruby. :)
&gt; Okay, only use them if you are mocking a call to an expensive external API . 
It's been four hours. I now imagine Avdi sitting in front a mug about [that big](http://3.bp.blogspot.com/-v3aTfCvwsOg/T1T-KuYaAUI/AAAAAAAAD2M/l_Rz3YGc4LE/s400/IMG_8590.JPG).
&gt; you should probably follow the guidelines. The guidelines in the actual spec only define 0.x.y as having an unstable public API. The spec literally says nothing about needing to be 1.0.0 if its publicly available or being used in production by anyone, so he *is* following them. If youre going to pretend to be the champion of semver, then you should probably understand the guidelines.
I could reply to you with a real answer, but I've already got -24 from discussing semantic versioning on this thread. No one is going to read this but you, so you win.
I'd give you a real answer, but I've already gotten -24 karma from just discussing this here. No one will see this, but you win.
Do you expect this to sell out soon? My boss offered to pay the registration fee, I guess I better get on that. Many thanks to you and everyone involved in organizing this, it's exciting to see something like this coming to Buffalo. I expect to learn a lot.
You know that annoying know-it-all-kid, who likes to lecture people all the time but is actually profoundly stupid. Yeah, that's you. You're that fucking guy. I've seen you around before, on twitter too -- and you're honestly a dick. A very average programmer who thinks he's all that. You're not. You're average -- get off your fucking high horse and live a little.
I honestly have never had this issue with Passenger. A quick google search found that if you're on brightbox, they do kill connections on deploys to prevent using up MySQL connections that go stale referenced here: set :passenger_restart_strategy, :hard Is the user using capistrano to deploy? Could be an issue there to kill any current processes before a rolling restart.
Going to throw in a recommendation for [Jeweler](https://github.com/technicalpickles/jeweler)...for awhile, it had been abandoned because of Bundler's ubiquity, but the author took it up again and it makes the process much easier. The benefits up front: 1. Will use your global git config to set up a git repo that you quick push to Github 2. Nice rake tasks to quickly bump versions 3. A rake task that builds the gem and pushes it to Rubygems 4. Sets up rspec, or your suite of choice (including optional mocking/stubs) right off the bat
thanks charlie babes
`andand` looks like it is similar to the `try` method that Rails provides. [10] pry(main)&gt; plain_hash = {'hello' =&gt; 'world'} =&gt; {"hello"=&gt;"world"} [11] pry(main)&gt; plain_hash['x'].upcase # =&gt; NoMethodError: undefined method `upcase' for nil:NilClass [12] pry(main)&gt; plain_hash['x'].try :upcase =&gt; nil [13] pry(main)&gt; plain_hash['hello'].try :upcase =&gt; "WORLD"
&gt; I mentioned before that POSIX message queues in Linux are implemented as file descriptors. This comes in handy when you want to support workers popping off multiple queues. We just call select(2) on each of the queue file descriptors Won't it work nicely with `EventMachine.watch` then, at least in theory?
I usually suggest against using these. I've run into so many issues when upgrading old rails projects.
I use `pry` as a console almost all the time, and of course `rspec` as my testing framework. `bundler` is also globally installed for obvious reasons but it provides a great gem generator as well, so I use that to make gems of all kinds. My own project, [pv](http://github.com/tubbo/pv) is another gem I include globally (it's meant to be included that way) because my work uses Pivotal Tracker for issue tracking and general project management, and I'm in the shell so much that I wanted something to quickly bring up a list of what I needed to get done.
What's the default permissions on these queues? User-readable? Group-readable? World-readable?
Interesting...I'd never seen that (and would've never guessed, given `try`'s connotation in other languages)
More dependencies isn't a good thing, but at least these aren't Rails-specific and have been relatively consistent through Ruby 1.8.7 to 2.0
Maybe not entirely that useful, but sure is one of my all-time favorites: [fsck](https://github.com/thorncp/fsck).
I love including that gem on partner projects :)
Also, [pry](https://github.com/pry/pry).
I would be VERY careful about subclassing Array or other core classes, and I definitely wouldn't advocate it. Here's a good write-up on the matter. http://words.steveklabnik.com/beware-subclassing-ruby-core-classes
pry, sextant (now part of Rails 4), better_errors, rumm (a plug for our new Rackspace CL)
My favorite, after `pry`: `its-it` https://github.com/ronen/its-it
So this is a library I've been working on. It's based on the Verbal Expressions idea, but I actually follow their specs better than most of their libraries do! In addition the library is very object focused with the DSL being secondary. 
usage examples?
pv looks quite cool, but you might want to find a different set of two letters, pv is already used for a really useful unix utility from 2002 called "pipe viewer" http://www.ivarch.com/programs/pv.shtml
haha i actually realized this when I accidentally ran `pv` on an ubuntu machine and APT gave me that "This program is not installed" error. For fun, I searched for 'pv' in APT and got a match. :) I'm not sure what to change it to...maybe `piv`? Also [this other guy named raul made 'pt'](https://github.com/raul/pt), which has a similar goal as mine. Realistically, I don't really care too much about this tool becoming popular...I wrote it for myself and for my own use case.
hehe :) &gt; Realistically, I don't really care too much about this tool becoming popular Fair enough, you can always pick a longer name and then create an alias, but tools are to solve problems. If someone needed to they could always fork the project.
Good point! I was thinking, maybe, I could just merge what was different between pt and pv and submit a PR to pt, since that's under more active development than my tool. Why have two solutions to the same problem? :)
Neat idea, but as someone who knows some good Regular Expression magic, it feels pretty clunky! Overall, I like the idea, though -- it'll help show people how to build regexes, especially. 
http://rubydoc.info/gems/TextualRegexp/1.8.6/frames Sorry for the shitty formatting. A similar project that Robert Klemme and I wrote. Well, I was pretty young and it was basically all him. I used to use it for all my regexp needs back in the day, but then I realized that all my regexps were pretty small and it was overkill.
The readme has one or two.
Ah shit, yeah, thanks.
Well at the very least you'll also gain the advantage of composable regex patterns.
&gt; http://rubydoc.info/gems/TextualRegexp/1.8.6/frames This looks like it pre-dates Verbal Expressions, cool! 
I like the concept of vagrant but prefer to spin up my own VBox development VM. This way I can mirror it as close as possible to my production environments.
yeah, it predates time itself.
Haha, that's awesome. I may steal a few of the ideas in here, like the repeat implementation. Do you care? I'll put it in the credits.
Have you looked at [Rubber](https://github.com/rubber/rubber)? Don't let the short description fool you. It can deploy to EC2, Digital Ocean, and as of recently, local vagrant VMs which would allow you to have identical development and production environments.
What problem does this actually solve? I'm not sure I'd ever use this for anything.
You've got a lot of good questions and points so here's what I think (and the reason I wrote this): 1. It is hard to extract intent from regular expressions. Especially since you can't break regular expressions up easily for commentary. Complex regular expressions can also be confusing even to the person who implemented it. Having english words that represent the arcane symbols improves the ability to garner intent from my brief study. 2. This library also gives regular expressions a composability that isn't inherit in the normal regular expression syntax. For complex expressions this can be great as you can share behavior just like methods among multiple patterns. 3. Verbal Expressions are going to be used, regardless of if the problem exists for which it is a solution. There are some semantic issues with Verbal Expressions standard and I address those with this library. Frankly, if it's going to exist I want something that works right at least. Overall I wrote this library because I need this library, but also because I think that Regular Expressions don't have to be the first step to learning Regular Expressions. I think that this library, and those like it, can help new developers build the vocabulary required to grasp verbal expressions without having to read rather terrible 90's manuals.
Definitely cool. Though, I have a cluster of ProxMox servers. Like knowing that my data is my data, no question. When the server fails or when it gets hacked, I know that it is because I'm an idiot and not that of another company.
&gt; What's wrong with that? I'll tell you: No commentary, no composability, and no introspection. With hexpress you can actually test the individual pieces of the pattern. EDIT1: Although thanks for reminding me about capture groups, I'll ahve to add that. EDIT2: `exp.http.domain.tld("com", "org")` is much smaller still. EDIT3: Why am I getting downvoted?
You can add as much commentary you want with... comments. regexp = %r{^ https?:// # Protocol \w+\. # Host (?&lt;domain&gt;[\w-]+\.(com|org)) /? $}x Composability is no trick. # Define some methods like this def http; 'https?'; end def domain; '\w+'; end def tld(*a); "(#{a.join('|')})"; end # Compose them like this reg = Regexp.compile(http + domain + tld) # Or like this reg = /#{http}(?&lt;domain&gt;#{domain})#{tld}/ # And then you can do this puts some_url.match(reg)[:domain] Introspection (which I assume you mean is the ability to test pieces of the regexp individually) is gained for free if you use a compositional strategy as above. Can you give me an actual use case for all of this that _can't_ already be done in a reasonable manner? I don't see this as being very useful apart from the novelty of verbal expressions which, while I think they're neat, don't think they're very useful either.
You're right about the comments, I didn't know! That said, let's be real here: You want every project that wants that behavior to implement their own http, domain, and tld methods **and then write the tests** while also understanding how Regexp.compile works? That's why we have libraries, to reduce the load of understanding in order to get things done. That's the problem I'm solving. EDIT1: By the way, I find it slightly amusing that your solution for my "I solve composability" is to propose everyone write parts of hexpress on their own. You've made my argument for me.
But I just showed you a much smaller and more elegant way to tackle composability. You can include small methods like these in a library and compose them as you wish. The bulk of this project is verbal expressions, and you haven't nearly convinced me they're a good idea. Can you give me a use case for them?
You added a parts after my last reply... &gt; understanding how Regexp.compile works It takes a string and produces a Regexp object. It's one of the most fundamental methods there is for working with regular expressions. I could have said Regexp.new, same thing. Expecting people to know what this method does is not exactly setting the bar too high. As for testing, you can test the methods I proposed, very easily. As easily as what Hexpress would generate. &gt; By the way, I find it slightly amusing that your solution for my "I solve composability" is to propose everyone write parts of hexpress on their own. You've made my argument for me. I find it slightly amusing that my solution fit in 4 lines of code, while yours takes nearly 1,000 lines and imposes an entire restrictive english-like DSL. I'll ask for the third (fourth?) time here: can you give me a use case for any of this that can't already be implemented in a reasonable manner?
Pretty sweet! Next step would probably be to make it grab a random word from some online API.
That's great! Keep on going on!
I feel like I've satisfied your question and given valid problems this gem solves. I clearly can't convince you and I'm OK with that.
You really haven't answered my question. Example code is not a use case. Where and when will this be both useful and more useful or practical than simply using regular expressions? I ask this question because I find the whole project rather silly. You've wrapped regular expressions in a cumbersome grammar that adds nothing and restricts you to the grammar. Other successful DSLs (I'm thinking specifically XML builders and things like Haml) wrap something that is cumbersome (XML, HTML) in something that is more succinct, more useful and less error prone. The DSL is shorter and easier than the thing it's generating and since the methods are generated programatically (or rely entirely on method_missing), no specific support for any feature of HTML or XML really needs to be built in. Hexpress is just the opposite of all of that, I'm asking for a use case because I'm wondering why you'd make such a thing. "Because I wanted to" is of course all the reason you need, but in posting it publicly and, by implication, promote its use I expected you'd be a little more eager to defend it. "See? You can parse a URL with it" is not really a compelling reason anyone would want to use it.
I'm not going to respond to someone who insults my work. I'm done with this discussion.
Awesome job! Welcome to the Ruby community :) I went through your program and tidied up a few things, restyled code the "ruby way," and added two new features (pulling words from a textfile dictionary and showing an ASCII-art hangman): [hangman.rb](https://github.com/christiangenco/hangman/blob/master/hangman.rb) You can see what I did, and why I did it, step by step by clicking "[history](https://github.com/christiangenco/hangman/commits/master/hangman.rb)" on that page. Going through that code should teach you a few cool new tricks in Ruby, like the [ternary if statement](http://www.howtogeek.com/howto/programming/ruby/ruby-if-else-if-command-syntax/), [Array#sample](http://www.ruby-doc.org/core-2.0.0/Array.html#method-i-sample), using [to_s](http://hackety.com/questions/4f29ab00a55d81000102be47), [heredocs](http://en.wikipedia.org/wiki/Here_document), [subtracting arrays](http://stackoverflow.com/questions/1192186/subtracting-one-array-from-another-in-ruby), and reducing the number of methods used (though this may just be a personal preference).
It's cool! Good job so far. Oh, and I kept losing :p &gt; "Mwahaha, the superior computer remains superior"
I think I found a bug, on the last chance the computer cheated and said my letter was not valid even though it was: &gt;Fool, this word does not contain your worthless letter r. You have 1 guesses left. &gt;a __ __ i __ i l a __ e &gt;n &gt;Mwahaha, the superior computer remains superior The word was obviously annihilate
&gt; annihilate does not have an `r`. Or am I misinterpreting your bug? 
[r] was the second last guess, he had one guess left. He than typed [n] and lost when he should win with the last possible guess. ~~The problem is there are two different checks for remaining turns:~~ **EDIT:** sorry it looks like I mixed up two different repositories... :-/ 
What I missed from the original version was an option to provide a list of words when initializing. The same goes for your version which is better but I would like to be able to provide one wordlist file for testing and one for production. The best way would be to allow some / all of these options: # (1) use a small list of words, hardcoded or in a special file HangmanGame.new.play # (2) provide a file HangmanGame.new({ :file =&gt; 'wordlist.txt' }).play # (3) provide an array of words HangmanGame.new({ :words =&gt; ['test', 'one', 'two', 'three'] }).play # (4) same as (3) but calling new with an array instead of a hash HangmanGame.new(%w{test one two three}).play 
That is correct.
 @game_letters.each do |l| output &lt;&lt; (@guessed_letters.include?(l) ? l : '__') + ' ' end output my suggestion would be @game_letters.map do |l| @guessed_letters.include?(l) ? l : '__' end.join(' ') or a bit uglier to read but: (@game_letters * " ").gsub(%r[[^#{@guessed_letters.join} ]],'__')
I think it's pretty good. Needs some optimization and better use of the standard library, but the OP's code is fairly organized and easy enough to follow. 
Because I only have a very occasional need for regular expressions, I find the regex syntax difficult to mentally parse. I'm sure it's all very elegant - t's certainly concise but so is minified code. I'll be at least grabbing this to play around with next time I need to write a regex. Thanks.
Gah, sorry, should have gone gender neutral. Fixed :D
woah, this is awesome. thank you, looking through it all now :]
The computer is an evil mastermind, after all. But seriously, thanks for finding this :] fixing now.
If you find anything missing let me know, I've already got 3 new features I need to work on just from posting here.
Are you downvoting me? Really?
His gripe against $1, $2, etc. is unfounded. He claims that a number can't convey that much information, but in this context, there isn't that much information to convey. It's pretty easy, obvious, and well-understood to know that $2 means "the second group from the last match".
You missed my point about numbers not conveying much info - when you have 2 groups in a regexp it's pretty clear which is which; but what happens when you have 5 groups? Keeping track of those becomes harder. Names always beat numbers as far as information goes. `Regexp.last_match[1]` is preferrable to `$1` for another reason entirely - it's makes it easier for a casual reader to understand what's going on and it's in line with established OO practices. 
BEGIN and END have no use in library code, but that is no reason to remove them. They make application code, particularly shell utilities and one-liners, much easier to write.
It might be easier to for someone who has never written ruby to understand the Regexp match variables, but libraries abound with Regexp match variables so rubyists are quite familiar with them. If you want to argue against excessive use of the grouping variables switching from `$5` to `Regexp.last_match[5]` is worse. Instead of two characters you have 20 making an expression using all five variables excessively noisy. The shorter `m[5]‘ gains no readability as you'll still wonder "which group is five?" Instead you should advocate for named captures which assign captured groups directly to local variables.