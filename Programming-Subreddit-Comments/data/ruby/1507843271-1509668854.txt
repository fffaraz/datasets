Mobile bug. It works fine on desktop, thanks for reminding me though.
I think that, when people say "you don't need CSRF protection for SPA with API", they mean more like "if you don't use cookies, you...". And they'd be right, as the token to identify the server-side session would not necessarily be part of the browser session (it could be generated via client-side API and stored at the client) and be accessible through javascript. This would mean not only that you're completely dependent of Javascript (duh, SPA!), but you'll expose yourself to a completely different attack surface (XSS...). I've seen a lot written about the drawbacks of this or that solution for this particular problem to know that there doesn't seem to be a silver bullet yet... But it seems that you are describing using cooked-based session to authenticate with the API. Well, without CSRF protection, I guess it's just as bad as non-SPA without it.
Well yes, that is the point :) if application uses sessions/cookies you need csrf protection. If other form of authentication (like described AWS signed requests viaCognito) then you don't need CSRF protection
You mentioned load average when doing some calculations. Is that a good indicator for all dyno types or just for performance dynos? 
&gt; I trust the people who wrote ls more than I trust somebody I don't know who wrote a gem. Why? How did the authors of `ls` earn your trust? What does a ruby library author need to do in order to earn your trust?
hey wait a second who works for heroku here
I think I read somewhere (can't find the link though), that a px large dyno on heroku should not exceed 8-12 in dyno load. Does this mean, when heroku reports 8 on dyno load, it actually fully utilize all 8 cores? This just contradicts when you are saying dyno load should not be higher than 1. And btw, what tool (gem) do you suggest to use in order to find cpu hungry endpoints? And thanks for a nice post btw!
Congrats! I just had a quick look and the code looks quite good. I didn't have any problems understanding it. Well done. Quick tip. You can refactor this code ``` def annual_income_func(monthly_net_income) annual_income = monthly_net_income * 12 return annual_income end ``` into more idiomatic Ruby ``` def annual_income(monthly_net_income) monthly_net_income * 12 end ``` * no need to add the _func suffix. It's pretty obvious that this is a function * use implicit return. It's shorter and very common in Ruby Enjoy Ruby and keep up the good work!
I had no idea about implicit return, I will probably switch all of the functions to it, if possible. Does it have any downsides, like potential errors? I added the _func suffix because I have a lot of variables with similar or the same names as their function counterparts. Is it acceptable for functions and variables to have the same name or do I need to distinguish them in the code?
There weren't enough dank performance discussions so I figured I would start one.
I'm not aware of any downsides, the basic gist is that if you don't explicit have a return statement a ruby method (they're called methods for some reason, not functions) will return the last line of the method. 
Ok cool. I’ll probably use it then, cleaner code and such. Also good to know they’re called methods. Anything that is: def code end is a method?
well - with a name yeah after def - yeah ;) def method name do some stuff end
Gotcha lol cool, thank you 
&gt; This just contradicts when you are saying dyno load should not be higher than 1. I would be interested in that link, because that's not my understanding. &gt; And btw, what tool (gem) do you suggest to use in order to find cpu hungry endpoints? I guess you could just pound endpoints with something like Apache Bench and watch the CPU numbers
It's best to understand __why__ someone recommends a value than just taking the value wholesale. Which is why it's great that Nate talks about his methodologies and some of the science behind why apps behave as they do. &gt; a px large dyno on heroku should not exceed 8-12 in dyno load Primer: I recommend my WTF is a thread video https://www.youtube.com/watch?v=WYW_zRF-y-I it talks about the differences between processes and threads and why you would want to use one or the other. Also talks about the differences in task types CPU versus IO. I haven't publically blogged about it yet but will shortly. It may help explain some of the minutiae of my response. I agree with Nate's post. Generally, I set threads to 5 and then add processes until I'm close to maxing out my memory (but make sure not to go over). If your app is a teeny tiny memory sipping thing (good for you, it's hard to make a really memory efficient Ruby app). Then you could add dozens or maybe even a hundred processes before you run out of memory. This isn't the best idea because once your CPU is working 100% of the time it can't do more. Additional processes actually cause contention because they're all waiting to be scheduled for the CPU. Which is why Nate recommends looking at CPU metrics in addition to raw. There's no hard limit of processes a PX Large could support. If your app is doing IO 99% of the time and you have no threads then it could likely benefit from more than 12 dynos, however at that point you're much better off with threads as context switching a thread is cheaper than switching a process. That being said most Rails apps tend to have a fairly consistent IO load and if you're seeing maybe 20-50% IO and using threads then if you keep adding processes into the dozens and hundreds (assuming you've got the memory) then you'll start making your app slower. I work for Heroku and the largest I've seen in the wild was 25 Ruby processes on a PX Large in their case it was too many. While there are decent rules of thumb i.e. 8-12 doesn't raise any red flags, but 25 or 50 would the actual number that's best for your app largely depends on...your app. It's better to use metrics to tune your performance than a magic number found on the internet. 
Great job! Welcome to the Ruby community. Good idea picking something that solves a real problem you have, that's the easiest way to learn IMO. * I would add some tests. To do that, the program needs to not actually *run itself* when it is `require`d. (So you'll need three files - one containing the program logic, one that requires that file and says `MyBudgetProgram.run`, that's the file you'll actually run at the CLI, then a third file for tests). May I suggest minitest? * I think you could use some classes and modules in here - better get comfortable with those next :) * You did a great job writing lots of comments. It makes it all very readable. [The style you used is called literate programming.](https://en.wikipedia.org/wiki/Literate_programming)
* I’ll definitely come back to this after I start to work with classes and modules and see how I can apply them to this code, thanks for the tip * I had no clue there were different comment styles! So interesting. Thank you for the link, it was interesting to read about. I used it because it made the most sense to me to use and also because as someone new to programming, it helps me keep track of what I’m doing. Explaining each line helped me solve all the bugs I encountered and remove unnecessary bits. Are there any disadvantages to literary style? Is it an obviously beginner style to use? Is there a preferred method or is it down to the coder to choose? * I’m not sure I know what you mean by tests. Is it something I should look up or am I just missing what you meant in your comment?
I can second the recommendation for DocRaptor. I am slightly less biased as I'm not an owner. 
Good start, however Rubocop will tell you a lot of advises.
What’s Rubocop?
 $ gem install rubocop $ rubocop simple_budget.rb
I’ll look into this 
Hi, sorry for a late reply. The -doc packages is general rule for all Fedora packages so as long as Ruby is concerned, you need to run: dnf install ruby-doc. Then ri File will work.
Uff, so people behind other OS projects don't have control over them? Maintaining means you have the ownership. GroceryBagHead did not say anything about contributing to other projects.
Thanks for the reply.
&gt;Why? How did the authors of ls earn your trust? because they wrote the operating system itself. They are famous and some of the highest regarded programmers in history. &gt;What does a ruby library author need to do in order to earn your trust? Build a reputation. How else.
The assumption is based on the fact that nobody has touched it in years.
Done a bit more investigation and it only seems to be when you use ruby 2.4.1 that this problem shows itself. Same application with ruby 2.4.0 and the generators show. So now need to work out why this is the case.....
ruby 2.4.2 does not have the issue so it must have been fixed then.
Rubocop is helpful because it encourages you to write Ruby in a style that is generally agreed by the community to be "idiomatic", whatever that may mean. You can configure your own Rubocop settings as well, but I would leave that be until you're more comfortable writing Ruby. It's a great tool, we use it extensively at my work, highly encourage you to use it. BTW it'll probably shout at you for the length of some of your methods. Your initial instinct will be to refactor it and break it out into smaller methods, which is a good first step. There are however nicer ways of achieving this -- you can learn about these techniques by reading [this book](http://www.poodr.com/) 
Please don't use ab. Its biggest problem is that it's not multithreaded, so the amount of requests it can point the endpoint with is limited by 1 CPU core. I recommend wrk instead.
Here is the link. https://kb.heroku.com/what-is-an-acceptable-amount-of-dyno-load It is actually from heroku. And it was between 12-16 in dyno load on PX large and you can see the different suggestions based on dyno type - which is why I assume it depends on the number of cores and if it shares the cores with other applications. Yeah, that is true, maybe I should phrase my question differently. I know a endpoint is really CPU intensive, could I then use stackprof e.g. to figure out what is causing the endpoint to be cpu intensive? 
Thanks for the detailed answered. I definitely see your point, it is just sometimes hard to see where you application is bottlenecking, if you don't know what your dyno load limit is - But I guess I should figure that out myself then. As you say, we are also currently running 25 rails processes on a PX large dyno, however we can't utilize that, as our CPU starts to bottleneck a lot earlier. I work at Tonsser, at we currently have a average response time of 175ms, where as 5% is spent in middleware, 45% spent in ruby, 35% spent in active record, 15% in redis give or take. My point is that, when you do raw math calculations on how much your web server can handle in terms of req/s, a PX large dyno with 20 processes (1 thread), should be able to handle (1 / 0,175)*20 = 114 req/s - but I guess all those examples does not include CPU at all, as that it is not the reality for our application at least, even though it should not be that CPU intensive. FYI, the link I was mentioning, was actually from heroku. https://kb.heroku.com/what-is-an-acceptable-amount-of-dyno-load
&gt; Are there any disadvantages to literary style? Is it an obviously beginner style to use? Is there a preferred method or is it down to the coder to choose? Well, Donald Knuth, the originator of the style, is kind of *the man*. So if Knuth did it, it's definitely not a "beginner style". It tends to not work so well if the program is split across more than ~ a dozen files. &gt; I’m not sure I know what you mean by tests. Example: https://github.com/seattlerb/minitest#unit-tests
I **strongly** recommend you to go 
has no downsides. in fact you may get better performance out of the implicit return. Not too confident in predicting what the interpreter does. But by first setting it to a variable you are actually storing a value in memory, then returning that value from memory to return. Its a small detail, and usually doesnt make much difference. But consider if a variable was several mb large! Think text blobs, images, etc. Then this could actually cause some issues with performance (even if it is small in the grand scheme of things)
It seems like your measuring stick is whether or not the project is fashionable. A ruby project in 2017 that hasn't been updated in 3 years _may just be_ as rock solid as `ls`.
We use unicorn in production and we increased from 16 to 32 workers per machine and noticed a major increase in requests/s (with quadcore+hyperthreading = 8 cores). This is because our workers are neither CPU nor Memory but IO bottlenecked (SQL communication for the most part). Memory is at ~9GB total but we have 32GB available: https://gist.github.com/2called-chaos/f2317226269b7939d00b0c94ea18604f
Is there an obvious way to tell if an app is IO bottlenecked?
Either by experiment: Add more workers or threads and see if performance increases. Or by metrics: Look at your CPU load average and make sure that you're using all the CPU you're given. This part is in the article, but not explicitly called out as finding IO bottlenecks. 
Why not use threads? You could get the same concurrency with only 7 processes and 5 threads per process. If you're worried about thread safety this gem is a good place to start https://github.com/ioquatix/rack-freeze
I don't know, it only introduces more (potential) problems for the benefit of some RAM (which honestly we have enough of) and we would have to switch to puma or something and we have a very stable unicorn setup so I guess "never change a running system". The one thing to mention though, due to seemless restarts we have to cope for double the RAM as peak when deploying. But if that would grow to a problem we could easily implement something with TTIN (increment the number of worker processes by one) and TTOU (decrease respectively) signals to decrease old workers and increase new workers programmatically.
From a computer sciencey standpoint, you should get better performance with multiple threads sharing the same cache of each process instead of each process having each process having to warm up the CPU cache every time it context switches. Also, the time to context switch thread is smaller than a process. In real life: I'm not sure how much it would actually matter given that Ruby is so far away from C-language speeds. &gt; "never change a running system". That's a 100% valid reason to not try something. "If it ain't broke...". That being said, if you ever do give it a shot I would be curious about the change in performance characteristics. Would make a good blog post. Let me know if you ever try it out. 
Read POODR http://www.poodr.com/ and then re-read it about once a year until you read it two years in a row and don't think you got anything out of it.
I have a library that wraps the writeexcel gem and makes the typical straightforward excel report super easy to make. I should package that up as a gem, it's by far the slickest thing I've used to solve this problem.
Docker ?
In OO languages, objects are sent "messages" which cause them to select "methods" to execute via a language-specific mechanism such as class inheritance. OO languages don't typically distinguish between functions (which return some value) and procedures (which don't return anything). Ruby methods and other OO langs always return something anyway. 
In OO languages, objects are sent "messages" which cause them to select "methods" to execute via a language-specific mechanism such as class inheritance. OO languages don't typically distinguish between functions (which return some value) and procedures (which don't return anything). Ruby methods and other OO langs always return something anyway. 
Sorry for the double post.
Looks very good for a first program! Two small things. I would look into the Hash data structure to store member data rather than an array. While member[2] is a bit hard to understand what it actually means, no one will missunderstand what member['annual_income'] is supposed to return. And I know it is a bit tricky, but in Ruby it is always never a good thing to loop over and range, get an index, and then fetch something out of an array. Instead of: (0...number_of_people).each do |user| combined_annual += members[user][2] end You can just do: members.each do |member| combined_annual += member[2] end Thus your functions actually do not need the number_of_people input. Keep it up! 
What a classic implicit reliance problem. Reminded me of this old Spolsky article about Microsoft's backwards compatibility methods: https://www.joelonsoftware.com/2000/05/24/strategy-letter-ii-chicken-and-egg-problems/
On Macs, Docker eats a ton of disk space. Once in a while I have to reset my Docker installation because it doesn't free that disk space, even if I remove images and containers. And Docker generally sucks more battery than native. Plus using Docker is just not as convenient as invoking tools directly and natively.
Well, in fact this happens because you're running docker inside a virtual machine.
Thanks this is all super helpful! I’ll revise my loops for sure and look into Hash. I hated the arrays because like you said, it’s vague and easy to misunderstand. 
Will do :)
Thank you :)
This sounds really useful, thank you 
You can also use Capybara for this. The syntax is slightly nicer, let's you swap out browser if needed, and many developers are already familiar with it. 
What is your problem? Not getting laid since the Carter Administration? Get a life and let go of the BS, my friend.
&gt;A ruby project in 2017 that hasn't been updated in 3 years may just be as rock solid as ls. "May be"? Yea I guess it "may be" but then again it may not be either. 
So well-written, thanks! 
I have no problem. You?
Have you tried Linux?
nihongo de? nihon jin ga futari imasundesu.
If you are interesting on this topic, I've done a gem called [Grell](https://github.com/mdsol/grell) for crawling sites. You can very easy scrap with it. In my company we use it to automatically check properties in the UI.
Taiwan nanoni nihongo ha naideshou :p All talks are in English or Mandarin, with simultaneous translation (Mandarin to English). Can't say for sure but usually 50% of the talks will be in English. 
Pony gem. https://github.com/benprew/pony
Sorry I don’t follow.. how so?
So, the alternative to not knowing is to actually evaluate libraries you're thinking about using. I know it's a bit more work than to glance at the github stars, but those stars are a terrible proxy for determining quality.
I meant that they're both rule enforcement problems. Old versions of windows didn't necessarily release memory after a program released it, so it was ok for SimCity to read memory right after releasing it without crashing. They didn't realize anyone relied on that behavior until they decided to enforce the rules in a later version of Windows. Old versions of MacOS didn't enforce forking/threading rules and many app servers relied on that. Now that they've started enforcing the rules, we see articles like this one. In general, I meant that humans are great at finding ways to rely on every aspect of the behavior of a given piece of software, even behavior the authors didn't intend to provide (like these two examples). 
Check out the Mail gem. https://github.com/mikel/mail#making-an-email
Found the problem myself, fixed it and sent a pull request: https://github.com/yaghmr/ruby-omegle/pull/1 
Do you want to add attachments/multi-part emails or choose your transport? If so the aforementioned Mail and Pony libraries will do. Pony depends on Mail. It adds a simple interface for sending via the well-known transports. Mail is a full-featured email handling library so, not sure what you define as "lightweight", but it may not be it. If you're sending simple text emails Ruby's `Net::SMTP` can be the most "lightweight": ``` require "net/smtp" message =&lt;&lt;MSG To: #{to} From: #{from} Subject: #{subject} CC: #{cc} #{body} MSG Net::SMTP.start(host, port) do |mail| mail.send_message message, from, to end ``` Do you want to email based on exceptions? If so I like [`Rack::MailExceptions`](https://github.com/rack/rack-contrib). It supports sending for caught and uncaught exceptions. It too depends on Mail. There are other options here, but this is probably the most lightweight. 
Why don't you break /u/Serializedrequests off with a coupon code..? 
You just won a free tshirt with those 3 prs. https://hacktoberfest.digitalocean.com Though it looks like the project hasnt been active.
&gt; 28699 deletions
Do you mean HTTP2 in Rails, or HTTP2 in Ruby? 
Something along the lines of alias :system, :old_system def system(*args) ... # do your stuff old_system(*args) end Please note that #system accept varied arguments. See https://ruby-doc.org/core-2.2.0/Kernel.html#method-i-system
Thanks, I found the following solution for handling both backtick and system, never though about alias until I needed it with the module &gt; module BacktickURI alias_method :standard_back_tick_call, :` #` #Comment for fixing Notepad++ highlighting, needs even back ticks alias_method :standard_system_call, :system def `(uri)#` standard_back_tick_call(uri) end def system uri standard_system_call uri end end
If /u/Serializedrequest (or you) want that it is easy to arrange, or an extended trial period, or whatever else eases the way. 
Rails, and Rack
it wasn't like that before.
[removed]
taylor = Singer.new.taylor.line1
Use puts taylor.line1 class Signer def line1 "play" end end taylor = Signer.new puts taylor.line1 [solution](https://gist.github.com/jasminsuljic/a545ebc2b2dcf18ae1ba1d52aa289502) 
Maybe you confused some numbers, as 339582 is the number of insertions. Or maybe it really was different three days ago, though the post is marked as having been made on the tenth.
&gt;So, the alternative to not knowing is to actually evaluate libraries you're thinking about using. If something hasn't been touched in years it's abandoned. That's the definition of abandoned. No software is perfect or bug free and your claim that this one is somehow extra special is laughable. The fact is that not even the author cares enough to revisit it and that means I won't either.
what is the system encoding? if it isn’t, set it to UTF-8 and rebuild your rubys, or if you can’t do it -&gt; see @jrochkind
:+1:
You have 2 statements `taylor = Singer.new` &amp; ` taylor.line1` on the same line. You can do this, but you have to seperate them with a semi-colon &lt;`;`&gt;. Even then, the *normal* Ruby idiom is to have each statement on its own line. class Singer def line1 'play' end end taylor = Singer.new taylor.line1 #=&gt; "play"
Thanks, didn't know about this, I just made an account :)
My first suggestion is to make a pair of HTTP clients for EACH thread, for four instances total. I can’t imagine that a Net::HTTP instance is thread-safe.
Just realized your the second person to recommend this book, two different posts lol. I don't even fully understand what OOP is so I super appreciate the suggested reading.
The most common way of keeping track of improvements on a project on github is to create issues tickets with a "improvement" label and you work on branches of your project that you merge with master and on the pr you reference the ticket associated with the changes. 
Ok cool, I’ll start trying to use these. Should I be working on my code in GitHub? The way I’ve been doing it is working in an editor on my laptop and then copying the changes to GitHub. 
No not like this, git is a versioning tool used by github and you should learn how to use it. Try https://try.github.io/levels/1/challenges/1 It will make things easier and that's how it's meant to be done. 
Do you mean actually editing the code using the in-browser editor on GitHub? If so, you don't have to do that. The much simpler and much more common way is to have a Git client installed on your laptop. Each time you make changes to your local files, you make a commit, and then you issue the `push` command which sends all your commits up to the GitHub repository/version for everyone to see. Then you, and other users, issue the `pull` command to download the changes everyone else has made. You don't need to keep track of versions -- that's what Git's already for, you can go back and forth in time to how the project was before a given commit, and the `branch` and `merge` commands let you and other people split the project into separate copies and merge them back together. It sounds as if you're just using Git(Hub) like a pastebin-style site to host code, missing out on what makes it so special and useful. 
Emacs and robe is a god send. 
r.is? 
Man, you nailed it in the head :) Congratulations and thank you! As a side note, I am aware of the thread-safety question, but I was expecting to see other kinds of errors possibly coming out of poorly implemented threading, for example deadlocks or variables getting screwed up, but instead I got this "Socket operation on non-socket" which completely put me off-road... How could that make one think there's some problem with threading, while it's telling in the first place that you're not operating on a socket at all? Mysteries of socket programming :) Indeed this is one of those cases where experience helps, and yours definitely helped! Very grateful to you! 
There is hanami-mailer: https://github.com/hanami/mailer/blob/master/README.md It's based on the very rock solid mail gem, hanami-mailer supports several template engines (ERB, HAML, Slim, etc..), default multipart (HTML + text), attachments, standard delivery strategies (SMTP, IMAP), test strategy, and custom strategies to integrate with vendor APIs like Mailchimp.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [hanami/mailer/.../**README.md** (master → 52eb4dd)](https://github.com/hanami/mailer/blob/52eb4dd54cbe7f30ce2f37a874ed7468dd43ea51/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
I'm pretty sure you just put your code inside: rt.on "page4" do view :whatever end
i said: simple and lightweight
 how can I redirect from "page4/" to "page4"?
Why it doesn't meet your requirements?
I'm not sure how to do it for all routes, off the top of my head, but for this single route: rt.on "page4" do rt.root { rt.redirect "/page4" } view :whatever end
When you initialize a hash with a value, that becomes the default value when a key is not found. So, `Hash.new([])` is equivalent to ``` ruby default = [] Hash.new do |hash, key| hash[key] = default end ```
Have a look at the API documentation for [Hash.new](https://ruby-doc.org/core-2.4.2/Hash.html#method-c-new) which explains this quite nicely. If you use a default value, i.e. `Hash.new(default_value)`, this single value is returned if a key is not found (if you don't specify anything, the default value is `nil`). However, *returning the default value doesn't mean that anything is stored in the hash*. Therefore the `inspect` result shows an empty hash.
You might wanna have a look at [Castaway](https://github.com/jamis/castaway) - it is a library for building screencasts and video presentations using a custom, Ruby-based DSL. It *should* be capable of what you need but I haven't used it myself.
Adding to that: the phenomenon at work is called "aliasing". Plenty about this can be found on the web.
`Process.setproctitle("My new title")` https://i.imgur.com/K8paG6c.png ~$ ps aux | grep new chaos 834 0,0 0,0 2432784 528 s002 R+ 1:00pm 0:00.00 grep new chaos 755 0,0 0,2 2509284 29836 s000 S+ 12:56pm 0:00.40 My new title Note: Does not work everywhere (e.g. mac's activity monitor, probably windows). 
re-read my question
because it's shitty
repetition
Take a look at the empty_root and slash_path_empty plugins. Also, you have greater chance of success if writing directly to Roda's mailing list.
My understanding (and I may be wrong) is that you don't need Rack or Rails to implement HTTP2 in order to serve your app with it. If you front the app with an Apache or Nginx reverse proxy (puma, unicorn), or use Passenger as a plugin with either of those you'll get it. These are common deployment configurations outside of HTTP2. I'm planing to migrate to just this configuration in a few months.
The plugins /u/rrrosenfeld mentioned can automatically handle route both `/path` and `/path/` routes. If you want to explicitly redirect the slash-ending paths, you do it with plain Ruby: route do |r| r.redirect request.path.chomp("/") if request.path.end_with?("/") # other routes end
or just `Singer.new.line1`
now "root" and "get true" aren't working, they return an empty response. other routes are working well.
&gt; How could that make one think there's some problem with threading, while it's telling in the first place that you're not operating on a socket at all? Yeah, that error is misleading, but the only answer I can truthfully give is: "lots of experience with sharing IO across threads". Very often when dealing with an IO interface (network, disk, serial, etc.), the state of that class expects that it only has one thread controlling it. In Ruby any library cannot be assumed to be thread-safe unless it explicitly says so. That, and you just have to expect that threading issues generate weird, hard-to-replicate bugs where you wouldn't expect them. That's another red flag. I'll post the answer on SO, thanks!
Oh, my bad, we have to account for root paths: r.redirect request.path.chomp("/"), 301 if request.path.end_with?("/") &amp;&amp; request.path != "/"
Initializing a variable simply means assigning it an initial value. In a language like C or Java where you need to declare your variables before using them you can declare but not initialize (though you'd still need to before using it to avoid an error). In a dynamic language like Ruby, you initialize variables when you create them because there is no need to declare a variable before using it. In any language though, you need to initialize a variable before using it. Hope that answers your question!
I'll try but I am new to coding. Its a boolean function so it either returns true or false. It counts from the square root of whatever number is passed to the function down to 2 and tests whether the number is divisible by this current number.
Thanks, what does the |li| and i mean ?
The |i| is a block parameter. It could have been named anything. It assigns the current value of the iteration to a variable, in this case named i. This code is iterating from the value of Math.sqrt(num).floor down to and including the value 2. With each iteration, the code returns false if i divides evenly into num, which would mean the number is not prime.
In Ruby, variables are initialized when they are assigned, for example I can do: a = 5 Which initializes the variable a, and assigns it a value of 5 simultaneously. 
Because Ruby doesn't require curly braces for hashes when they are the last argument in a method call, curly braces are not needed when an array contains a single hash: [lol: nil] == [{:lol =&gt; nil}]
A good example of when you need to initialize comes from working with arrays. If you want to do foo &lt;&lt; value you would first have to have foo = [ ] to initialize foo as an empty array
Why would you need rspec in irb in the first place? How hard is it to use plain ruby to make a comparison? I guess that extends to rspec in general when `assert` is all you really need.
This is an algorithm for finding factors of any number. You run through all the numbers between 2 and the square root of the given number. If any of those divide into the number, it is not prime. If none of the numbers divide into it then the number is prime. In this case the function runs from the square root down to 0 and uses the modulo (%) operator to test the division.
This might help more than an explanation https://repl.it/MfEt/1
Seems like it answers your question to me.
It was probably done to demo rspec interactively.
True. Although some Features might require it, like pushing to client etc? 
Using `999` as an example: `Math.sqrt(num)` gets the square root of the number. (31.6069613) `.floor` rounds down, (31) `downto(2)` returns an enumerator; calling `to_a` will return the numbers 2 through 31. `each` well you know what this is. `if num % i == 0` if num has no remainder when divided by `i`, we know it's divisible by _something_ so we can return false. A more OO-approach, tuned for verbosity: class Integer def prime? minimum_divisor = Math.sqrt(self).floor # Math.sqrt(9) would be 3; Math.sqrt(9).floor would be 3 possible_divisors = minimum_divisor.downto(2) # array-like of all numbers down to 2 possible_divisors.each do |divisor| if self % divisor == 0 return false end end return true # you could otherwise omit the explicit return and even true since all methods are true by default; out of all possible_divisors, self was not divisible by any with a quotient that had a remainder end end
if you dont need to declare a variable before using it, then why does the initialization method exist?
what "initialization method" are you referring to?
Initialization is for reating new objects, variables are for storing information
Are you referring to a constructor? class Hello def initialize(name) @name = name end def hello puts “Hello, #{@name}” end end The initialize method there is a contractor for the class - it gets called when you create an object of that class: h = Hello.new “themanspeaker”
So it seems like what you want to know is actually when to declare variables inside an initialization method inside something like a class? I'm not exactly what I'd call a competent rubyist, but I find myself doing it whenever I have a variable I need available to all the methods in my class. So for example, if ClassName.new takes an argument, I'd want that argument available to multiple ClassName methods, so I'd have something along the lines of &gt; &gt; def initialize(arg) &gt; &gt; @arg = arg &gt; &gt; end inside of the class. That way @arg is available to every other method inside of ClassName. 
Judging from OP's comment earlier, it sounds like there might be some confusion between initializing a **variable** and initializing an **object** (_i.e.,_ an instance of a class). As /u/orlandoduran mentioned, you might have seen a method definition like the one below before: def initialize(foo) @foo = foo end This method definition typically goes at (or near) the top of a class definition: class Bar def initialize(foo) @foo = foo end end What it initializes is not a variable, but an instance of the `Bar` class. It's saying, "Whenever someone calls, say, `Bar.new('boogers')`, create a new instance of `Bar`, and inside that new instance, set the instance variable `@foo` to the string `'boogers'." It's basically a special name for the `::new` class method.
That is pretty much how I was using it lol, I'll work through the challenge listed above and see if my current editor (Atom) can be used as a git client. I'll try to figure out how to do all of this so that I'm not using it like an old man lol
Thank you, will do!
You don't need to have your editor work as a Git client -- there are plugins that let you do that if you want, but usually people just use Git as its own external program. If you want a GUI for it I'd recommend GitKraken, but if you're comfortable with the CLI, just using that is easiest.
I’m good with CLI so if possible I’ll keep it that way. Trying to keep my workflow less cluttered so CLI is perfect 
They define a parameter i, enclosed in pipes | | (not capital I) that acts as a variable inside the curly braces. So i has values between the square root of num and 2, and if any of them are multiples of num (num % i == 0) then the number is not prime. Hope this helps!
The inject method must return the memo. `; memo` is just ending the last statement with a semicolon, and returning `memo` since it is the last value in the block. The reason this one works `puts [1,2,3,4].inject {|memo, num| memo += num}` is because `+=` returns the operand, in this case `memo`. 
Thank you!
You should use `each_with_object` instead of `inject` in this case.
then that still won't work if I have a nested route with "root" say # ................ r.on "categories" do rt.root do # show all categories end rt.on "category1" do # show category1 categories end end
and to me?
Well, you have yet to actually explain why that doesn't answer your question...
who obliged me?
I mean, if you want someone to eventually answer your question, you'll have to explain something. But if you just feel like being an asshole to people trying to help you, it's no skin off my nose. *shrugs*
what does it have to do with you?
You shouldn't have a nested `r.root` if you want to have no trailing slashes. `r.root` should be used only on top-level anyway. You should be able to replace it with `r.get true` here.
Second in the series - https://medium.com/@baweaver/reducing-enumerable-no-op-and-boolean-b2ce4ef8bd79 The fun ones are going to be things like lazy, slices, minmax, and sorting functions. Those ones will come out later in the week.
I have. In fact I came from Linux. The primary reason why I switched to a Mac is because a lot of Ruby users are on Macs and I need to be able to test the software that I develop for them, on the systems that they use.
Nice and lively explanations, but I am not sure I like your idea of calling any _less known for juniors_ language feature "black magic". Ruby already has a reputation of "being too magical", and proclaiming any feature not from the first page of tutorial "magic" is ... well, questionable.
The return statement is meant to return immediately once one factor has been found. 
With a boolean function you can just write the statement so that if it is true it will return true otherwise it will return false. That's the way I understand it at least.
The issue has been addressed in ruby-head https://github.com/ruby/ruby/commit/8b182a7f7d798ab6539518fbfcb51c78549f9733
Yes, I understand what you mean. This method could be modified to do that as well. def is_prime?(num) Math.sqrt(num).floor.downto(2).none? {|i| num % i == 0 } end This demonstrates that you were correct that the `each` method was not necessary, and neither was the `return` statement. However, I'm trying to alert you to something *beyond* what you said. If you call the OP's method on a number with lots of factors, it will return false (not a prime) **as soon as** it finds the first one. In other words, it will stop executing the `each` iterator when it finds a value of `i` that evenly divides the value of `num`. Example: Calling `is_prime?(30)` will attempt to check the numbers from 5 down to 2, but as soon as 5 is found to be a divisor, the method will return `false` and will not continue checking the numbers 4, 3, and 2. That's essentially why the `return false` is included in that code, because `each` doesn't have any built-in way to end the loop early once a factor has been found. You'll notice that in my code, I don't need to do that at all. That's because I'm using the `none?` method, which already knows how to exit early (and return `false`) on the first value of `i` that gives a value of `true` for the block calculation.
I misunderstood. I thought you were saying he needed the return statement to return early. Thank you I will look up "none?” I am really enjoying learning ruby coming from perl 5 before. I still have a lot more to learn. 
He *used* the return statement to return early, because it's an optimization. Why keep going through the rest of the numbers if you already know that `num` is not prime? However, he did not *need* to use it, because there are other methods that do essentially that same behavior for you.
Thank you so much.. Were looking for this eventually.
 Set.include IdempotentEnumerable Set.new(1..5).reject(&amp;:odd?) # =&gt; #&lt;Set: {2, 4}&gt; Hash.include IdempotentEnumerable Hash.idempotent_enumerable.constructor = :[] {a: 1, b: 2, c: 3}.first(2) # =&gt; {:a=&gt;1, :b=&gt;2} ...and other nice stuff. (Done mostly for custom specialized collections in my gems... But seems of generic usability.)
I think of `===` as meaning "member of set defined by". _Most_ of the traditional/conventional uses of it in ruby correspond to that. :)
Yeah, most sane ones. Technically a function is a map which has a domain set so if you abuse category theory a bit it's fair game for ===
I'd like to encourage us calling `===` the "member of set" operator instead of just the "case equals" operator, to encourage the continuation of a bit of consistency there. :)
ah, yeah. I use docker for everything now, so system now doesn't matter :-)
you're talking about an initializing method in a class, right?
Very nice. 
Can also just use https://github.com/brigade/db-query-matchers for single line tests around this (it uses ActiveSupport notifications under the hood)
I don't think this is Idempotent. Idempotent in programming means running the same task many time but the changes are only applied once. Enumerable has a well defined API that returns Arrays What you have done here is create a new Enumerable API that returns the same data type. Which is a good idea. I just reckon the name is misleading. 
Choose between implicit and explicit return based on which is clear or more readable in context.
Currently in Ruby stack traces that are many levels deep (chef for instance) in order to get to the actual error and the line of code where the problem exists, you have to scroll up from the bottom an unpredictable number of lines, all the while scanning with your eyes to get back up to the top. This is one thing python did right
As a professional Ruby dev, Ruby is a wonderful dynamic language and is so great and easy to write. I love it. It is popular for making the developer's life easier and happier when coding, and when you get down to it the only thing that really separates the languages is how easily it allows the developer to express their thoughts into code. However, I don't recommend pinning your career and growth as a developer on just one language. You will be much more hirable learning multiple languages. It will also help you in your personal growth embracing multiple languages and learning new things all the time, it keeps things interesting. Also don't spend any more time than necessary learning any framework such as rails. Just learn Ruby and you'll get much further toward creating the functionally you actually want
Yeah I ended up leaving explicit return for the functions that returned arrays because I felt it was more clear. 
That’s mostly the impression I’ve gotten with courses as well. I feel like if you’re motivated you can learn almost anything by yourself, and since coding is more of a trade it’s ok to not have a degree so long as you have provable skills. I’m loving Ruby right now. I had never heard of it before two months ago and just picked it at random. It’s been awesome. Towards the end of each week I start to feel like I’ve developed a new understanding of programming and the language, and then I stumble on something new and everything is foreign again. It’s incredibly motivating to have people like you encourage me. It means a lot to me that you and the other people on this post took the time to give me advice and experience. 
Good luck!
Thanks. Lovely. I will add to the article.
ORMs, the vietnam of computer science *heh*
This is great work! Thank you for creating this and sharing it. Here's a bit of feedback on the Ruby language areas, from most important to least important IMHO. Keep in mind that these are tiny points, and your gem is very, very good. * You have a strong preference for extending Math. Personally I like this, but many Ruby devs don't like gems that alter standards namespaces. For example, other people prefer their own Math.factorial, and many devs prefer you to check before clobbering any preexisting method. * Your tests are very good; they are clear, have good coverage, and thorough. Do pay special attention to any areas you typecast, because these areas tend to be missed or ignored by tests, and can turn up problems much later on. For example, consider how you do factorial of a string, such as Math.factorial("10"). * Decide if you're going to cast parameters or not, and stick to it. For example see Uniform. You cast the initialize parameters to_f, but you don't cast the density_function parameters. Do both or do neither. The worst-case for these tends to be when a user is sending along strings from data input such as stdin. * Your comment "TODO: Find a way to better test this instead of fixing some values." is good thinking. At the same time, math tests are often a really good time for fixing some values, because they are easier to hand-test on other implementations and hand-verify in reference books. Your simpson's rule test is one where I'd personally like to see some fixed values just to be on the safe side. * Improve your code by explicitly using input values and output values, rather than relying on array index position. For example, see your incomplete_beta_function. Consider that "each_with_index" tends to be a code smell whenever each element is independent of the others. * Consider caching, such as memoize. The speed improvements in stats for cached intermediate steps are amazing. * Generally the folder structure and module name matches the gem name. For example, your gem name is "ruby-statistics" so I would expect a module name "RubyStatistics". * The above point helps with name collisions. For example, one of my projects already has a "Statistics" lib. What happens when I add yours? Also shows up on your code in the line "if defined?(Statistics) &amp;&amp; !(defined?(StatisticalTest))". When is the first condition ever false? When is the first condition ever true, when it's also not because of your module? * When you load from full path, use Pathname, not "/". The reason is because Windows uses "\". 
Yup, you are right. I've just chosen the first "working" title that looked like "something close to what I've meant", then planned to rethink it before release, than was so relieved I've finished that just forgot to think on it again ¯\\\_(ツ)_/¯ Suggestions are welcome.
Awesome! Thanks for the feedback. I'll definitely prioritise this. I agree with you that testing is a really important part because you know, it's a "math" gem. Re: namespace. I had a couple of trouble trying to move from Statistics to RubyStatistics. Maybe I was doing something wrong. I will definitely try again. I don't feel comfortable with that. Again, thanks for the feedback. It's important to me that someone else took the time to do this review and I really appreciate it!
Will you cover reducing against an object _and_ an accessor method? It was mind-blowing to discover I could do this: user = User.first methods = [:posts, :first, :comments, :first] methods.reduce(user, :public-send) user.public_send(:posts).public_send(:first).public_send(:comments).public_send(:first) user.posts.first.comments.first.user Essentially a recursive `public_send` using The use case for this was a social media notification system where we needed to walk an association, via methods, to reach the given notified user. This was expensive as shit in practice, but it runs as a job on a worker. It looks a little like this: [ { notified_users: [{ post: :user }], title: 'Someone commented on your post.', content: "#{comment.user.name} wrote #{comment.content}", }, { notified_users: [{ user: :follower_users }], title: 'That person you follow commented on a post.', content: "#{comment.user.name} wrote #{comment.content}", } ] 
yes. 
&gt; When you load from full path, use Pathname, not "/". The reason is because Windows uses "\". I thought both Ruby and Windows also accept '/' in all cases anyway?
There's a lot of truth in this. Put simply, it's hard for those with less experience to appreciate what a problem it is to write code that isn't idiomatic for your language of choice. This has only become more important as large frameworks have gotten larger and more important. You see this a lot in libraries that get quasi-ported from one language to another. They get feature parity, and they get functional, but until they switch from the old language's idioms to the new, they never feel "right". This was rampant when .Net came out - every Java library had a .Net port, Hibernate -&gt; NHibernate, JUnit -&gt; NUnit, etc. They just felt wrong .Net until they started to adopt idiomatic .Net and leave behind the Java idioms. Around the same time, dependency injection was super hot and people tried to do that in Ruby as well. This article http://weblog.jamisbuck.org/2007/7/29/net-ssh-revisited is a good look back as Jamis Buck noticed he was caught up in this.
I remember looking at Needle and thinking "WTH is going on, has the world gone mad?"
I make a GREAT living picking up all the random dev tasks that get left behind by "devs" that have fallen into the same trap that this article describes. It's sort of a shame too because I believe it's a misunderstanding of the goal when sitting down to work on these things. Don't let "mastery" of a language stop you from going on new adventures, doing things you don't include in your self identity, or (most importantly) shipping product. I can't trash the article or the author too much, after all, this mindset has left enough work on the table for me to buy a VERY nice house and live a comfortable life.. But I can't honestly clap the author on the back for a solid insight either.. This article seems to very carefully describe the authors own mental hurdles, and not any real "truth" about writing code. The nil return on looking up a list member for example.. yes.. if you lean on poor practices, you will get bit when you move language to language.. practice good coding hygiene and you won't burn the store down.
I can see how applying for a senior or lead position to work on a technology stack you're not familiar is daunting, but with mentoring or support I don't see how you wouldn't be able to pick new technologies fast. Its very similar to learning natural languages, the more you know, the easier it becomes to pick up new ones.
In hindsight I would have been able to pick it up. But at the time my imposter syndrome was kicking into high gear. I didn't want them to see I was some kind of fraud. I didn't want to commit to something I didn't know I could do for sure. Also there's a bunch of other factors why I didn't push forwards with the job. I felt pretty burned by the facebook/gowalla deal and wasn't sure I wanted to get into yet another social network company. I also interviewed with foodspotting and I had the same reservations about working on another social network. At the time instagram had no revenue and no plans on having any. I didn't want to move to SF only to find out that the company no longer existed a month later. Working on a company that had cashflow (i.e. any kind of a business model) was high on my priority list. I would have potentially reached out to instagram had other plans fallen through, but at the time working for Heroku was a dream of mine. After I got an offer from Heroku I didn't have to go back and re-visit my prior decisions. Maybe if I had met them in person I may have changed my mind, but I can't go back in time, so I guess we'll never know. 
Sure, if you know what you are doing, you can pick up anything. I have 10 years+ of experience in ruby, and I am very effective in ruby, and capable of designing very robust and flexible architectures. If I started working in (eg) Python, how long would it take me to develop equivalent skill and capability working there? I dunno, it's probably not 10 years, but I know it's at minimum 1 year no matter how much mentoring or support i have. I'm going to be functioning at a so-called 'junior developer' level for a while, as I get the experience. 
&gt; if you lean on poor practices, you will get bit when you move language to language Each language though has different definitions of "good practice". For example Python is all about exceptions and many devs encourage you to use them for flow control. In Ruby this would result in really slow and unwieldy code. I've seen Ruby code written by python programmers where they've preferred exceptions for flow control. It was a mess. No shame though, if it was Python it would have been the right thing to do in those situations. Likewise, now that i'm writing Python I find it hard for me to use exceptions in situations when they would be better than explicit value checks. The larger point I have is that "good coding hygiene" isn't universal. &gt; not any real "truth" about writing code I really struggled to write a "here's what this all means" ending. In the end I just didn't. It's supposed to be a story, an anecdote, one perspective out of many. It's a story I felt was worth sharing, and I think there's something in there, I'm just not sure how to say it in fewer than 2,000 words. &gt; Don't let "mastery" of a language stop you from going on new adventures I agree with this. I know plenty of languages. I feel "proficient" in a few. Knowing more languages makes me a better programmer. If I had been looking for a change or an adventure I would have gone for it, but that wasn't the case. &gt; Don't let "mastery" of a language stop you from going on new adventures, doing things you don't include in your self identity, or (most importantly) shipping product. I think there's a spectrum. On one end of the spectrum there is the person who spends weeks twiddling the same 2 lines of code until they are PERFECT and does not ship anything. On the other end of the spectrum they crank out work like nobody's business, but no one but them can read the code, certainly they can't maintain or make any changes to it. I've been programming long enough to have worked with people on both ends and just about everything in-between. I can say that I think it helps to have a mix. Sometimes you need a prototype that you can put in production really fast to test an idea. Sometimes you know what you need, and any minor architecture issues now will result in huge headaches later. I think programmers need to know what style of programming they're happiest with and companies need to understand not all programs that run and meet requirements are built the same. I'm not a perfectionist but I struggle to produce a large volume of code. I need to work in a codebase with tests. I need to test my work. I need good documentation. I need time to write documentation. I need to go back to refactor and clean up as I work. When my work gets messy then I become drastically less productive and therefore less happy. I'm not saying that this is the only thing I'm able to do. I'm not saying I won't learn or try new things. The whole reason I signed up to get a Masters was to get out of my comfort zone. It's okay to know what makes you happy and to want to do more of it. 
My python is very rusty, I have been using Ruby for work to one degree or another since 2002 (when I finally said goodbye to Perl). C/C++ for quite a bit longer than that. They are my heavy lifters. I know and use Haskell, Javascript, Java and .NET enough to be pretty proficient. I would expect that while for the first ~6 months I would google more than a senior developer generally would, I could be writing better than junior developer level code immediately, and axiomatic python within 1-3 months. I am in my 4th decade as a developer, everything changes all the time, just keep learning -- pick jobs and projects based on the people and the work, technology is a distant 3rd.
Yeah but there is a difference between some basics of good code hygiene and the nuances of a certain pattern and how "pythonic" it is. There is a good foundation of stuff that transfers over and prevents most from stumbling into the same line of thinking you ran into. For what it's worth I'm probably representing the far extreme "lets learn this tech and hurl it into production" side of the spectrum. But I struggle with two things when recruiting/bringing up new folks.. the first is I need them to have this irrational need to open things up and see how they work inside. I can't teach that and it's what carries you through the days of struggling with something.. the second thing is the idea that "I know how to code, I can code in anything". Man if thats been broken out of someone, we struggle until it's built back into their mind. Mostly my group is supporting the ops portion of the code base, and thats spread across whatever languages and frameworks the tools required. Most of this stuff ends up in my groups hands (in fact, we have this group at all) because, it's a huge smattering of stuff "nobody is an expert on" and so nobody is willing to dive in and have a "basic" job committed into source with their name on it. The article read to me like you were suggesting that the title was a common myth that developers needed to get past.. But I think that idea itself is a common myth that developers need to get past. It's ok to commit code like you've glanced at the docs for five minutes, if you've only actually glanced at the docs for five minutes. There is value in high level people being bad at something new while they learn and get better. 
after looking more into this, i believe that i am talking about methods rather than variables since ruby does initialize variables automatically upon creation
Because rvm and rbenv grab Ruby from source and compiles it for your system it's not grabbing a binary and running it, both need to compile ruby. Unless you go through Ubuntu s repo but that ruby usually stagnates sadly unless there's a ppa for ruby idk if one exists though. 
hmm interesting, I was under the impression that rvm had a repository of binaries that were managed by rvm. What is "rvm list" doing then? Is it just listing available rubies that it has source code for? I'm going to have to do an experiment to see if an LTS ubuntu also requires compilation. I could have sworn I saw RVM on a LTS ubuntu just install a binary. 
I enjoyed the article, keep up the great work man!
You might be right I just grabbed this url http://syntaxi.net/2012/12/21/installing-binaries-in-rvm/ That looks like rvm can install certain binaries. Hope that link helps 
I use the bullet gem and set it to raise exceptions during integration tests.
Back on trusty the go to ppa is bright box. On xenial Ruby is caught up but you have to install the package with the correct version in the name
Thank you for the link. I think we got the answer. Looks like RVM is a whole year behind when it comes to Ubuntu releases. 
If you are doing this a lot, you can prebuild your own binaries and store them on a private web server. Look at &gt; rvm help prepare for some ideas.
Strange, `rvm prepare` is not a valid action [according to the docs](https://rvm.io/rvm/cli). This actually makes me wonder — is there a non-negligible performance benefit to compiling from source vs. using pre-built binaries? I don't know that much about rvm, but [this issue](https://github.com/rvm/rvm-binary) led me to [this repo](https://github.com/rvm/rvm-binary), which I think is not a source of binaries _per se_, but rather a tool that would allow you to compile ruby from source for a given target system. That way, you could compile the binaries for your VMs ahead of time and import them during the provisioning process.
I think a big part of whether or not to be comfortable with these situations depends on the rest of the team's makeup. If you're on a team that's already "doing python well", it's not nearly so hard to get up to speed on the idioms on the fly - if you're getting it wrong, code review should guide you to idiomatic code quickly. On the flip side, if you're supposed to come in and be the leader, or it's a greenfield project where nobody knows the language - that's not the time to learn. I worked at a place that was going to pivot to .Net MVC when that was the new hotness, and it was terrible. Partly because my boss was an idiot, but partly because none of us knew what idiomatic use of C# or even visual studio looked like. We ended up with a project that looked like a mix of languages, and none of it aged well, because of it.
Good work! This library inspired me to write better code. I'm happy to see such a progress!
[removed]
Check out my gem [simple_report](https://github.com/lostapathy/simple_report) gem. Right now it just supports excel export, but I plan to add an HTML output soon. I haven't really thought too much about pdf output, but you could wrap the HTML output with wicked_pdf?
Congrats, y'all!
I don't like wicked_pdf very much. It's quite heavy, and has unpredictable results in regards to pagination, word wrapping, etc. It also generates enormous PDF's out of tabular data that are very taxing to open. I recommend Prawn and its Table plugin instead.
I actually have had really good luck with wicked_pdf, I feel like we practically got away with murder at my last job. That said your point is a good one - it wouldn't be that hard to modify my gem to output via Prawn, I will put that on the todo. thanks!
Assuming you're using something like rack, and assuming you have a config.ru that looks like, require_relative 'app' run App I put, `Bundler.require(:default, ENV['RACK_ENV'].to_sym || :development)` in app.rb. There's probably a better/different way to do this, but I house a few microservices using Rack and this is how I do it. Inspiration, if you will.
Never heard of Rack before, but it looks like it's for the web. I'm just building a local tool to process video/image files.
You could make a file called 'pm_me_your_gold_plz.rb', add that `Bundler.require` line inside of it, and then require pm_me_your_gold_plz.rb everywhere :)
Well, `Sequel::Model#to_hash` is just an alias to `Sequel::Model#values`, which is a hash of raw column values that remain the same regardless of whether column methods were overriden. I was about to suggest using the [json_serializer](http://sequel.jeremyevans.net/rdoc-plugins/classes/Sequel/Plugins/JsonSerializer.html) plugin, but that one also reads the values directly. I think that overriding `User#created_at` like that is generally not a good idea, as it can lead to lots of surprises down the road. For example, if I'm new to your project, I would expect `User#created_at` to return a `Time` object. I recommend that you start using serializer classes provided by gems like [Yaks](https://github.com/plexus/yaks), [Roar](https://github.com/trailblazer/roar) or [jsonapi-rb](https://github.com/jsonapi-rb/jsonapi-rb). That way you won't pollute models with presentation logic.
I just read the details. This is amazing. Congrats!
Congratulations for the release!
Thanks for the hints. I am trying to create a serializer by myself as JSONAPI is a little bit too limited and is tightly attached to model logic, so it's difficult to create the object structure you want. 
If this is a just a local tool, I would follow the directory structure used for gems. Head to rubygems.org for a guide.
Nice. It would be also nice to mention gem installation requires Rust preinstalled. It would be also nice to support "fastest" claim with some benchmarks. Just sayin'
If you're intested in learning web development with Ruby, check out https://www.theodinproject.com/ It'll show you how to use Rails, which is a framework written in Ruby, to build websites. You'll also learn some javascript and some HTML and CSS along the way. Those are all things you'll need to know in order to build websites. If you're looking for just some more experience using ruby to solve problems and applying the syntax that you know, exercism.io is a good resource where you can try to solve problems, and then look at solutions that other's have come up with as well.
hey! i was in same boat. i followed the rails tutorial by hartl it was boring,but then i went through it again and made my own app and it totally works and does what i want! cant recommend it enough
thanks for the thorough explanation!
ah, so are you saying that if you have a variable that is not automatically initialized by having .new, then you need to explicitly create a method that will initiallize them?
What is the alternative to having such methods?
get/set is used for _reading_ and, more importantly, _changing_ the properties of an object. they're very important. _things_ in the real world respond to change. using _you_ as an example: your hair changes. your name (can) changes. your shoe size changes. your height changes. if we had to make a new _you_ every time we wanted to reflect these changes, the world would implode. god didn't give us enough ram or disk. 
Nice work. Very exciting!
if you want to set a value, cant you just declare it using a normal variable?
&gt; How do I make a website with ruby? Whatever you do, don't just go in Rails. You'll hurt yourself. Sinatra is nice: https://github.com/sinatra/sinatra &gt; How do I make a game with ruby? https://github.com/ruby2d/ruby2d
only inside the object.
to_json sucks. Require 'json' and use JSON.generate(Ruby object here)
The functional developer in me wants to disagree with your argument about memory, but the pragmatic educator in me thinks I shouldn’t even mention it. 
What would it look like? `foo.bar = baz` in Ruby already means "call method `bar=` with argument `baz` on object `foo`", so to avoid using a method we'd need to devise a new syntax.
(I know, I'm sorry)
&gt; I was about to suggest using the json_serializer plugin, but that one also reads Sequel::Model#values. Where did you get the idea `json_serializer` doesn't use your overrides? require 'sequel' DB = Sequel.sqlite DB.create_table(:examples) do primary_key :id String :reversible end class Example &lt; Sequel::Model plugin :json_serializer def reversible self[:reversible].reverse end end JSON.parse(Example.new(reversible: 'abcd').to_json) # =&gt; {"reversible"=&gt;"dcba"} OP, if you want one JSON document for each user, write `User.last(10).map { |user| user.to_json }`. If you want one JSON document with all the objects in an array, use `User.last(10).to_json`.
https://github.com/yivo/ruby-excel-readers-benchmarks Here you are 🙂
Not sure why anyone would downvote this question. First, let's clarify what getter and setter methods are. Let's start with a simple example. Here's a simple class: class Employee def initialize(name) @name = name end end You can instantiate this class like so: joanne = Employee.new('Joanne Rowling') Internally, you can access the `@name` variable directly: class Employee ... def full_name? @name.split.length &gt; 1 end end but if you try to access this attribute from outside, then you'll get a `NoMethodError`: &gt;&gt; joanne.name NoMethodError: undefined method `name' for #&lt;Employee:0x007fccdab64640&gt; What's going on? It's important to understand here that Ruby is an **object-oriented language**. You might have heard that "in Ruby, everything is an object," so wrapping your head around the object-oriented paradigm is critical. You may think of programming as arranging a series of instructions, but a better way to think about it (in OOP) is that you have a bunch of **objects** and you send those objects **messages**. When an object receives a message, it responds with the corresponding **method**. `joanne.name` isn't you picking up `joanne` to retrieving its `@name`. Rather, it's you sending the `name` message to the `joanne` object. `joanne` then takes the message and checks to see whether it has a method defined with the same name. If it does, it will run that method and give you back the return value. If not, you'll get a `NoMethodError` as described above. `joanne` has an internal instance variable called `@name`, but not a method to handle the `name` message from outside. So, in order to use `joanne.name`, you have to define one: class Employee ... def name @name end end This happens frequently enough that Ruby provides a shorthand for it: attr_reader :name --- This is a pretty simple facility in Ruby, and there are plenty of blog posts and stackoverflow/quora answers that go into it. The next time you have a question like this, you should try a combination of Googling and experimenting in the interactive console (`irb`) first — you'll get an answer much faster, and you'll build good habits for the long road of learning ahead of you. I'd also strongly recommend you read through a couple books about Ruby. (Remember to keep your laptop handy and try any examples yourself in the console!) Here are my favorites: * [Practical Object-Oriented Design in Ruby](https://www.amazon.com/dp/0321721330) by Sandi Metz * [The Well-Grounded Rubyist](https://www.amazon.com/dp/1617291692) by David Black Good luck!
Thanks a lot! I have missed that and does what I want by being minimalistic ! Works fine.
Hello! The other posts here are directing you to libraries and tutorials to accomplish the specific examples you gave, but I don't think that is really the question you are asking. I assume ruby is your first programming language. In that case you are at the first steps of a magical transformation: from syntax to philosophy; moving from how to why. You need to come up with a simple project and then write it. Or you can a suitable project suggestion online. * Choose projects that are simple to start, then scale up. It will be hard at times, but also rewarding. As you write more code you will be training your brain to think about problems in the right way. It will get easier. Another crucial skill to develop is how to google for help and understand the answer. Practice this regularly, but don't copy/paste, write out the code to train your muscle memory and to find parts that are irrelevant or awkward for your situation. *maybe start with a command line factorial calculator and then move on to Fibonacci sequences
This is a great question. Learning how to program is one thing; learning the process of software development is another discipline entirely. A program written only in Ruby must be run in the terminal; to build something that a layperson can use (like a web application or a game), you'll need to learn a whole ecosystem of tools and systems of which Ruby is only a small part. For instance, if you want to learn web development, in addition to learning a framework like Rails, you must learn databases, networks, some basic system administration (linux), web standards and protocols, etc. etc. If you just want to build a website that doesn't have all that complexity and logic behind it, you don't need ruby. Finding problems to work on is one of the biggest challenges for programmers. Rather than starting with the technology (Ruby), why don't you ask yourself what you'd like to build, and find out what tools or frameworks are to help you build it? You might be able to find a way to work Ruby into it; you might not. You'll learn something either way!
Whenever some asks you a question that needs answering you should add that information to your README. In this case requiring rust and a link to the benchmarks in the README would be good.
Outside of the normal things of webdevepment for profit, I've done an API tool to automatically send emails connecting to an SMTP, implement Conway's game of life, a utility for cloning AR records, a notes api to be used with react. Things attempted: a game bot/game scripting, web scrapper. Basically any software you can think of can be done in ruby. However you need to know the trade offs, garbage collected languages are usually bad at real time apps. For example, large string processing, real time software, games, audio/video processing, stuff like that.
agree I will update the README later today
&gt; How do I make a game with ruby? I have [a video](https://www.youtube.com/watch?v=QtIlyU2Br3o) that covers making a small game using the Gosu gem.
I don't speak nintendo. Could you please explain what is under this link?
virtus is no longer maintained. Not recommending using it.
Check out [dry-web-roda](https://github.com/dry-rb/dry-web-roda). They suggest a way to load &amp; store app settings (both secrets and not). You can configure your app using Ruby DSL &amp; load whatever you need from env vars. Practically the same way as everywhere. However, the way they implemented it in dry-web-roda is pretty interesting. Totally worth checking out. 
Oh, my mistake, I just saw `#values` being called in the `json_serializer` source code, but it is indeed being used for calling `#get_column_value` which calls the method. Good catch! If you want to do just `User.last(10).to_json`, make sure you don't have ActiveSupport loaded. If you have to use ActiveSupport, you can stop it from messing with your JSON serialization by doing `JSON.generate(User.last(10))`.
I use [dotenv](https://github.com/bkeepers/dotenv) accompanied with an `.env` file in development.
Nice! So, you specify the settings attributes with the coercion and everything, and dry-web finds the corresponding capitalized environment variables and populates the settings with those values? Very nice!
I'm glad it's being patched, but let's all keep in mind that the change to High Sierra is that it crashes _on purpose_ because forking before loading libraries was always unsafe and would cause random crashes. Many different tools should have been changed a long time ago, and the only way that Apple could make that happen was to throw an exception when the unsafe situation occurred.
why would I store "articles_per_page" in an env file?
Is there a way to read a particular tab in the .xlsx workbook? This is something we need to do most of the time.
@nibord, thank you for posting this comment. I agree with you that more developers should be aware of multi-threading / `fork` relationship concerns. I thought the [Passenger blog had a great article about these considerations](https://blog.phusion.nl/2017/10/13/why-ruby-app-servers-break-on-macos-high-sierra-and-what-can-be-done-about-it/). Greg Parker, who works on the Objective-C runtime, wrote a [concise and wonderful explanation about the High Sierra changes](http://www.sealiesoftware.com/blog/archive/2017/6/5/Objective-C_and_fork_in_macOS_1013.html) Iodine deals with this by forking before multi-thraeding, making sure no other threads are active (so the current thread owns any existing locks). Of course, gem and application developers might not be aware of these concerns and might end up adding unsafe code that will effect forking, but this is beyond what iodine could possibly control. As for the High Sierra patch, Ruby crashes were related to delayed library loading (lazy loading), which caused library code to be initialized after `fork` and multi-threading was already in motion. This behavior is definitely less than ideal as far as code safety and stability are concerned. The solution was to forcefully load the Objective C runtime library ahead of time, preventing it from being initialized during a lazy load of gems that use the Objective C runtime (such as `pg`).
Oh, I only saw the "secrets" part and glossed over the "non-secrets" part. In that case I would definitely recommend the suggestion from /u/Morozzzko, because even if it does include separate gems, it really is simple and it eliminates the decision process.
"The method of conditional branching for Ruby's 'if'".
no, there’s not, will do in next version
What am I missing here? Should I learn japanese?
Seems like an bot that automatically posts anything on that blog. The post itself is super simple compared to rubykoans or even "learn ruby in 10 minutes"
Unholy hell, that is the gayest shit I've seen in a while... And a talk about *fake news???* Oh the horror! Save us from the dreaded **white males,** brave SJWs!! Seriously, you people are fucking freaks. I am so sick of seeing retarded faggots dominating the IT industry. Constantly churning out your nihilistic, atheistic bullshit so that you can feel more comfortable about the Satanic lies you tell yourselves to stop feeling so bad about fucking someone of the same sex in the ass. And for voting in pedophiles and Satanists. And then you aberrations have the gall to talk about loving and caring and shit. All you talk about that shit for is for meaningless "virtue" points. Which, btw, is the opposite of virtue. So glad Matz stood up to you fuckers when he made a CoC (pronounced "cock" of course) that made you trannies angry. Hahahaha!!! How awesome! ## By the way: Elia did nothing wrong and meh was right. Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha!!!!!!!!! FUCK OFF AND DIE IN A FIRE YOU CANCEROUS SHIT
Okay /r/incels poster 😂
# HAHAHAHA, EVERYTHING IS ABOUT SEX FOR YOU FAGGOTS
You are not a good or decent human being. Therefore I’m happy my little conference brings me joy and you displeasure.
Cannot access site. Server download ?
Works for me. Try refreshing. Sometimes there is an intermediate HTTPS error that we haven’t been able to track down.
My main use of setters and getters is for objects to manipulate and examine their own internal state. Using methods rather than accessing instance variables directly permits subclasses and mixins to change behaviour. I tend to make get/setter methods private, because using them from outside the instance is an OO code smell, basically the first hint of excessive coupling. It's not for security. Private methods in Ruby are a closed door, but not a locked door. 
Is this the kind of community /u/jamesgorlick /u/ViralInfection /u/petercooper /u/postmodern /u/edendark are fostering? 
&gt; You are not a good or decent human being Neither is Hillary. But I'm sure you don't care.
you okay?
I'm the same as usual, thanks for asking.
Never heard of those people. Who are they?
Wish it was down... The damn thing looks like a half-assed gay porn site, tbh. Can't believe anyone would pay to go, let alone pay $200.
Best of luck with the conference @schneems . Wish I could come but getting from Aus to Austin is a little harder than just adding three letters. ;-) 
Same, one day I'll make it - keeping Ruby weird is one of the things I love about Ruby, no other language has that as a goal
FWIW it was offline for a little while for me too, right around when you tweeted it. Refreshed etc and no love but worked again a few minutes later.
Thanks for letting me know. We've done all our older sites the same as this one and it's the same setup I use to host my blog and none of them have the same issue. Honestly not sure what's going on. Wish I could say we did it to be weird, but it's just annoying. Sorry. 
Shoot me a PM if it's giving you trouble, I can share the notes or links that helped it click for me. It's a fantastically useful tool once you get it going.
I actually found this awesome tutorial on YouTube that helped a lot, thank you!
Would you follow up here with your experience? I always hear great things, but I'm _still_ trying to decide whether traveling to the US is worth it for the talk.
Looks like [they're aware](https://github.com/elabs/pundit/issues/484).
Absolutely!
very jealous of you right now. 
I will try to take comprehensive useful note! :D
If it's true, then why did you delete your comment?
i think something may have changed ...
I didn't. Someone else did apparently. Proves me right, if anything.
Sorry for the late reply. We use cloudflare for other things (ssl termination, ddos protection) so we basically get their cdn service for free, which is not charged by traffic. So we more or less pay nothing for several terabytes a month in traffic... Yes it overlaps with cloudfront - they are both cdn's, but cloudfront is metered, and in our case costs a lot more, in the magnitude of thousands of dollars.
This made me realize how many static analysis tools there is for Ruby. I only knew about Brakeman and Rubocop.
Thanks, keep hearing good things about cloudfront.
I had a great experience at poodgate last year and as a bonus two of the engineers I met there have come to work at the same company as me. Don’t be afraid to network :)
Thanks! Any other pro tips? Anything I can do now to better prepare for the course?
Variables and objects are separate concepts. The initialize method is about initializing an *object*. A variable may well refer to this object later on, but the initialization is nothing to do with the variable as such.
Why?
Seems like this[0] is one of the issues that was opened for the name change. [0]: https://github.com/thoughtbot/factory_bot/issues/921
tl;dr: A couple people got offended at the implication that a factory girl would "do the work for you". Others were just curious about the name and some thought it was kind of weird to have a gendered noun in their code base. The original devs explain that it was intended to be a positive reference, like Rosie the Riveter. They ultimately changed it because it was easier than answering questions about it all the time.
&gt;An explanation of the name change can be found in the [old factory_girl repository](https://github.com/thoughtbot/factory_girl).
So one guy gets awkward for no reason around his female coworker, all the people who took issue with the name were men and the only female in the conversation says they don't see an issue. There's a woman on my dev team and she never had issue with the name. rly makes u think 🤔
i always thought it was an andy warhol reference
Whew, I just got done crossing out "girl" in my dictionary too. Yay, we're now free of gendered nouns! 
-_-
Not for long, till first AI bot gets offended. 
I’m a man and I like the name change. Rly makes u think 🤔
This is a good change.
Great! I always felt the name was awkward to look at/talk about.
Hmm, so if you want the perspective of a woman, I can say that I personally never felt uncomfortable about the name. That joke about the factory girl skiing the work for you did make me uncomfortable though.
Actually I think this makes sense. I always feel like an idiot referring to an important part of our code base as "FactoryGirl". I *always* get weird looks from management, especially business management.
The point isn’t removing a gendered pronoun. It’s the context of that pronoun. When I started using this gem there was one woman at my Rails meetup. Now there are a dozen or more, and one of the leaders of the meetup is a woman. I don’t think there were any women on the dev team that made or named the original version of this gem. Times change. There were other “girl” gems that go renamed much faster. Such as “girlfriday”. These were a bit more on the nose. The factory girl name was never really significant. It’s not even a play on words like the awfully named “cocaine” gem. The new name is fewer characters and is more descriptive of the behavior of the library. 
Whatever. Silly to change the name. Even sillier to debate the name change. FactoryGirl better be an alias because I don’t want to have to refactor hundreds of factories. Lol
This is another good lesson in that you can't go wrong with naming a library after what it does, rather than something unrelated one finds amusing.
Just guessing here, but I think half of the issue is that you don't explain why you like the name change and the other half is that you're another man with the same opinion as other men as the parent comment mentions who likes the change where females say they're okay with the existing so it doesn't add as much value because you aren't the demographic the change is targeted at (assumingly). FWIW I've asked a lot of close dev friends and that trend of men caring and women not caring seems to be pretty true anecdotally.
Updated my post
&gt; The women who do work at my company have approached me privately and said “thank you for speaking out”. About various issues. Usually they don’t feel they can speak out without getting rail-roaded. They only speak up when there aren’t problems. &gt; My larger point is that there can be issues even when “no one is talking about them”. Just because you’ve never personally seen an issue does not mean it doesn’t happen. I understand, and sympathize with that. But I don't think we'll ever grow past issues like these without people speaking up and communicating like human beings. To people looking in, this could be perceived as a bunch of men deciding that a name is offensive to women, a few women chiming in it's not offensive, then it being renamed anyways. Look at https://github.com/thoughtbot/factory_bot/issues/921#issuecomment-243173849 for example.
Not sure why this is getting downvoted. Maybe people here are too young to remember the blog post you’re referencing.
What do her courses cost anyway? I can't find anything on her site.
I propose to change every gender noun in the code with "cuck" or a variation of it. Ex.: FactoryCuck. Upvote if you think is should be done. Downvote if you can't wait for this happen. Don't do anything if you think this will happen naturally.
From a male perspective, can I just say this is fucking bullshit and a waste of time? Thx. 
Therefore the problem was with the guy who made the joke about the factory girl doing all the work for you and NOT with the name of the library. Just my opinion though.
Why's that?
2200
&lt;3
Another woman chiming in going 'huh? Uncomfortable about what?' I liked the old name. It had positive connotations for women. But whatever.
Apparently it isn't. https://github.com/thoughtbot/factory_bot/issues/1055
why?
What were the positive connotations you saw in the old name?
Rosie the Riveter was strong and powerful. She got shit done! 💪🏻 
[removed]
I hate this whole fucking PC culture
Breaking change in a patch version? Do you all see now how feminism ruins everything?? Checkmate SJWs.
Hmm, well if I heard that joke in the moment, I can say that would have made me worry that that was the intention behind the name, and I was just too naive to pick up on it.
I use a Mac myself. I too find it a better experience than a PC.
As a woman ^^^^not a woman, I take offense at name "Rails". I associate it with "railing", or to be "[railed](https://www.urbandictionary.com/define.php?term=Railed)". This is literal rape. I want project to be renamed to something less triggering, like "Ruby on Trails".
*Here's the Urban Dictionary definition of* [***Railed***](http://www.urbandictionary.com/define.php?term=railed) : --- &gt;The act of fucking the living shit out of something or someone, preferably a female. --- _Damn dude, I fuckin' railed that ho all night._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:https://www.reddit.com/r/ruby/comments/77sjzr/factorygirl_has_been_renamed_to_factorybot/doooa4w) ^| ^(**Summon**: urbanbot, what is something?)
Thanks for the context. This is a pretty good take. 
I don't think this change has anything to do with feminism.
[removed]
Knowing how to implement semver is orthogonal to being a feminist.
I realize Poe's law is in effect here, so just to clarify, that was sarcasm on my part.
Agreed. It wasn't uniquely descriptive, or SEO-optimized, or commemorating a real historical entity. Was it offensive? Doesn't matter, the fact that we're here pondering that question at all is enough reason to change it. &gt; It’s the context of that pronoun. I'm not sure what you mean here. How would the context have made the name (in)appropriate?
There is an availability bias to “only men want this” because men outnumber women in our industry by quite a bit. When there is an issue you will always hear more male voices. Always. There is also a confirmation bias to “Ive never heard women speak up about this”. I’ve had a half dozen women comment privately to me about this thread but won’t comment publicly due to the hostile nature of the commenters. If your network doesn’t feel comfortable sharing negative opinions with you, you’ll only ever get positive reinforcement. I agree with “we must communicate like human beings”. But currently there are huge forces at play that prevent people from speaking honestly and earnestly. Unfortunately when some people try to speak up and share concerns they are shouted down and silenced. If you ever wondered why so many activists are “shouting” all the time, it’s because it’s the only way they can be heard.
The pronoun “girl” by itself or used in the right context is fine. The issue isn’t that “girl” was used in the name but that it’s inclusion elicited different reactions from people. Some of those reactions are bad. That’s the context. Different people have different takes. Some see it as empowering “Rosie the riveter”. Some see it as artistic “ a Warhol reference”. Some see it as misogynistic “making a girl do all the work for you while you get the credit” (or other variations). 
As a poster, I'd like to give a comment about why I posted it. It wasn't to mock anyone. For me the name was a clear cultural reference, event though I never listened to The Rolling Stones. It's just a title you know is there. But what works for me does not necessarily must work for others. If someone felt offended, name change may be justified (although it not very clear for me if someone really did feel that way). The original intention is to give you a heads-up that your projects will break with a path-version update (as described in https://github.com/thoughtbot/factory_bot/issues/1055). Mine did. My faith in Thoughtbot was fading away for some time already but now they basically lost my trust forever. Because you are not supposed to do things like that and there were many better ways to handle that.
that was a wonderful idea. I think others should follow suit, like those app servers like unicorn, which refers an extinct and since then a mythical animal, brought down by the hand of man; or puma, which not only offends its namesake endangered (by the hand of man, of course) wild animal, but also clearly rubs itself on the face of children of Bangladesh, who are forced into child labour for producing the shoes which bear the puma brand; or thin. God, Thin! Clearly making fun of fat people! I wonder what George Carlin would say if he programmed in ruby. 
Is that blog still available?
It was a long time ago, a rant about how it’s impossible to find any gems because their names were so divorced from their function. 
Computer dorks tend to be awkward around girls.
You fucking people. 
I love how a guy proposes the name change to keep code from being gendered and a women replies that she doesn't feel offended about this at all.
It’s the name of a Rolling Stones song off of their 1968 LP Beggar’s Banquet.
&gt; There is also a confirmation bias to “Ive never heard women speak up about this”. I’ve had a half dozen women comment privately to me about this thread but won’t comment publicly due to the hostile nature of the commenters. Somehow I have trouble believing this. People are just saying that this whole thing is stupid. The most hostile it got is someone saying "I hate this fucking PC culture". How is that so hostile that 6 of your colleagues are too scared to comment? Maybe where you work things are different but the women I work with have far more backbone and don't need people to speak for them. 
&gt; The pronoun “girl” by itself or used in the right context is fine. The issue isn’t that “girl” was used in the name but that it’s inclusion elicited different reactions from people. Some of those reactions are bad. That’s the context. You can make that argument about any word in any context. If what you say isn't offending someone you haven't found the right person.
Why would you use coding terms/names talking with management people........................................................................................................................................................................................................
Kind of offensive for non-biological consciences. (because everyone is offended by something, but I guess by now everyone is already expecting the Spanish Inquisition)
awww! I loved that it was called FactoryGirl :( 
Seriously. Why?? 
Imagine you go to [Burma to teach Ruby])(http://www.dailymail.co.uk/home/moslive/article-1312382/The-curse-blood-rubies-Inside-Burmas-brutal-gem-trade.html]) 
Right HORSE is way better than Unicorn. Oh wait, now we've named it after a beast of burden maybe that's offensive?? Oh I know, SERVER! Ah gosh I guess that's a bit slave-like isn't it? Uhhh This is hard. 
From a female perspective: I agree. Can we have beers now and get back to our TDD? 
But what does more women in your ruby meetup have to do with the name of this gem? Is it because there are more women you think the name should change ("Times change.")? I'm just really confused with what you're trying to say here I guess. My team is *mostly* women and we use and love FactoryGirl. And these are some of the biggest feminists I know. It was never even remotely considered offensive in our groups. 
Hopefully you never have to reference an Aaron Patterson’s blog post.
Yeah I'm fine with this. It'd be weird if it were called factory_boy too. 
they didn't follow semver!!?? Guys this is the real outrage right here. wtf.... 🤦‍♀️
Absolutely. That was my take too. 
Also a woman, and yeah, same here. The only thing that I care about here is that I now have to update my code, the old name was fine.
I've always kind of thought that was part of ruby's culture in some ways. If anything a part of its charm. 
It just really shows how divorced people are from reality. There's nothing wrong with gendering things, it's part of our humanity, pretending it doesn't exist by attempting to strip things like this out just leaves us with dull expressionless culture. 
Let’s do it like Django and avoid the master/slave problem by renaming it to leader. This surely won’t backfire when we’ll hold a conference talk in Germany. What’s leader in German again? Oh, it’s Führer...
Won't someone think of the bots? 
Nobody would care if it was factoryguy.
FactoryBot is a better name than FactoryGirl. But does that mean it makes sense to rename repo, gem and fuck up all the dependent projects because it may offend clinically offended? Just the magnitude of reach one must have to find it in any way inappropriate, wow.
Can you please explain little further? I've never interested in gem name before rename, but today I learned about Rosie the Riveter, and now I feel that _previous_ name was good. Because it makes a lot of sense for equality of men and women. “Factory Girl” name _may_ offend girls in _some_ cultures but will be totally fine in all other cultures. I belong to others as I don't have any idea about whether all that hype for renaming projects have any meaning at all.
&gt; I agree with “we must communicate like human beings”. But currently there are huge forces at play that prevent people from speaking honestly and earnestly. Agreed, unfortunately that seems to be a large problem. Hopefully the problem will be worked out soon. :) Just to look at it from how I imagine lots of people are viewing it, it's almost entirely men speaking out against it while the only women who are commenting on it are saying it's not a big deal. I'm 100% aware that's not the complete picture and don't believe that's the case, but if you take an outside in view that's how it seems. If you want to win people over it can't look like that from an outside view. They need to see people who feel that it's offensive speaking out about it rather than it appearing like men deciding what women are offended by.
my response would be the same if it was called FactoryBoy: it's weird and unnecessary. 
Okay then. I'm a woman developer, I'm not super annoyed about the name, but I'm still glad about the name change and I think it's thoughtful. The factory_girl name just has always been one of those instances to me where "us" always means men, and "girls" are "the opposite sex". People whose attention "we" want. And there's a lot of those instances at meetups and in the industry in general, it didn't use to rub me the wrong way, but it starts now as it adds up over the years.
I'm glad they finally changed it. I never found it offensive, it was just odd. It would have been just as weird if it was called FactoryBoy. 
Thanks for sharing, I'm glad it had a positive impact. :)
Ok. Now I’m a bit miffed... 
The only thing that's weird is your *interpretation* of the use of the term "boy". Calling for censorship based on your interpretation is communistic. 
Why in the hell wasn't this done in a major version update? Or even better, don't update the original factory girl gem, and create a brand new gem for factory bot (should be fine to just start a new gem at the current version number of factory girl). Really seems short sighted to change a bunch of code but the gem name still has "girl" in it.
Great, let's break millions lines of code for a stupid single complaint. 
It cuts both ways. There was a big debate over it for some time. I land in the “make it fun, but relevant” camp. Weird names are fun at first but when you’re facing a new project with 100 new dependencies you’ve never seen before it’s tedious to hunt each down and find out what it does.
From my perspective, it’s just one `sed`. I (and can promise you many other Ruby developers) were not comfy with the name. It harkened back to the day in which a woman in industry was the exception. No need to get this upset about a new name that doesn’t bother anyone.
Except FactoryBoy bears no cultural reference.
&lt;div class="tenor-gif-embed" data-postid="5040563" data-share-method="host" data-width="100%" data-aspect-ratio="1.7777777777777777"&gt;&lt;a href="https://tenor.com/view/planet-of-the-apes-1960s-charlton-heston-gif-5040563"&gt;Planet Of The Apes 1960s GIF&lt;/a&gt; from &lt;a href="https://tenor.com/search/planetoftheapes-gifs"&gt;Planetoftheapes GIFs&lt;/a&gt;&lt;/div&gt;&lt;script type="text/javascript" async src="https://tenor.com/embed.js"&gt;&lt;/script&gt;
Anything has some bad reactions. Kickstarting the universe is by far not the most popular thing to have happened. Unless it’s directly offensive for demonstrably objective reasons, you don’t break naming of a gem that is being used by almost every project that uses constructed data. A few centuries ago “girl” didn’t even mean female. A few years in the future “bot” might become offensive to someone. Maybe the second Luddite movement will arrive and word “factory” will offend them. So do we react to every shit that happens, or do we keep a promise to gem users?
Vast majority of developers are not native English speakers. They just remembered the particular set of symbols and moved on. The issue is in your head. More than that, this is not fixing anything.
This one? http://unethicalblogger.com/2011/11/13/ten-poorly-chosen-gem-names.html
Wait, your defense of the name is that most people can’t understand it? What?
I didn’t defend, I attacked your position. The meaning you attach to the name is not universal and claiming that your meaning is somehow special is laughable. Vast majority of gem users attach different meaning to its name - the function of the gem.
Why does it have to be a universal opinion?
If it was named factoryguy eventually someone would accuse it of not being "inclusive" enough and it would be renamed as well lol
"Communistic"? Yo, it's open source software and the open source community. Workers freely sharing their labor for the betterment of all. Bet your ass it's communistic.
Does changing the name to FactoryBot do anything to fix broken hiring practices and company cultures? I think we should change the name to FactoryPerson. I'm worried that the suffix "Bot" might upset people who are at risk for displacement due to workplace automation.
I'm more of a Linux person but one thing I like about Ubuntu is the notes it took from OS X in its UI design.
Open source is not communistic. No matter how desperate you are to make a point. 
&gt; someone would eventually accuse it of not being "inclusive" enough Some individual's interpretation of the name warrants a change? Still doesn't make it a valid reason to change the name. 
Does it bother you that men chose to make this decision on behalf of women even though the women who did choose to speak about it said they didn't care? Doesn't that strike you as being condescending the dismissive? Men in this case ignored the input of women and did something because they felt they knew better than the women what women wanted.
California values at work. I really hope technology companies all relocate en masse. It's becoming asinine and childish. 
So you like Vlad the Deployer more than Capistrano, eh? :-)
I would really want to ask them if they can show me an example of a real web application using these SOLID principles. When you have an MVC patters (rails or any other), you also have to deal with database, how can you use these principles? I searched github and googled high and low to find answer to this question, everybody is just rehashing book and no real life web app as reference. 
So that's all you're gonna say? You're just going to leave a comment complaining about everyone else? I'd say you contributed nothing to the conversation, but you actually detracted from it.
I prefer Arch linux with i3 as the windows manager, 'cause there's no better ui than no ui
but now what about all the inspired-by packages in other languages that are factory guy/girl/dude/whatever?
I hope mine make sense: https://github.com/NullVoxPopuli/drawers https://github.com/NullVoxPopuli/action_cable_client
Now we just need to fix the statue of liberty with a gender neutral sheet covering all but its eyes and we can all get back to the coding. 
Some conversations shouldn't be had. FactoryGirl is nearly 10 years old. 99.9% of tutorials are now using the wrong name. Why was this change made? You don't change the name 10 years in. But no, they've got to kowtow to the socjus crowd. You fucking people.
um, what joke?
Great question! Will ask!
Because they do gemba walks, and they see cards on our board with the word "FactoryGirl" and want to know what that is. A healthy agility-oriented shop doesn't have "top secret stuff that only the nerds know".
"tender lovemaking"... sheez... that shit just oozes brogrammer. Lame.
Not universal but held by more than a handful of easily offended people who have a disproportionate amount of influence because they play the sexism card. I also think it would be healthy to have more women in software development but this sure as hell won't make that happen. Another example: I recently visited a Ruby conference where a number of speakers where obviously selected because they're women even though they hardly had any speaking or technical experience, which just reinforces the stereotype that women are bad at tech. This kind of overcompensating just hits a nerve with me. I think a lot of people agree but are afraid of being called sexist bigots and so useless initiatives like this can gain traction. Instead of wasting our time on this, we could be organizing something positive like a RailsGirls event for example. 
The sad part is that most female comments said they didn’t have any issue with the name. Hen all male comments are whiteknighting and ignoring what actual females said. That is the sexist part of it. “We care about you. So we will do this thing we stereotype that you will think, and not actually listen to what you say”. 
Child labor?
https://github.com/ruby/bigdecimal/blob/master/test/test_bigdecimal.rb probably has everything you could ever possible need to figure out.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/bigdecimal/.../**test_bigdecimal.rb** (master → f3e6bfd)](https://github.com/ruby/bigdecimal/blob/f3e6bfde51375fb873f5ecda897338504743ff13/test/test_bigdecimal.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
Because people are morons sometimes, that’s why
Thanks, I meant to ask for a link to something as well but the post was getting long.
So any one can make joke about a project name, making people think that that was the original intention behind the name, and get the projects to change their name regardless of the real reason....
But I have Factory and Robot. The name should be changed again!!!
Find a word that doesn’t offend a single person in the world. 
Well, if you read the original discussion for the issue, you'd see that this was something they had stated discussing amongst themselves outside of that. 
 require 'bigdecimal' one_seventh = BigDecimal.new(1).div(7, 20) puts one_seventh.to_s('F') Here, the argument `20` represents the number of significant digits in the result.
Oh so you are just a bitter anti-sjw asshole. As I suspected. Carry on.
Carrying on, not name calling because I'm better than that. Ahem.
In one post: &gt; You fucking people. In another: &gt; not name calling because I'm better than that. ... ok.
FactoryGirl didn't bother me as a name. Also doesn't bother me? Changing the name to FactoryBot. Credit to thoughtbot for doing what they feel is the right thing.
I'm going to give you the benefit of the doubt and assume English isn't your first language.
[Fabrication](https://github.com/paulelliott/fabrication) is an object generation framework for Ruby.
If the gem is new, I would prefer the new name (I think it's nicer), but changing something that was working for years.....geeez, come on guys, you can do better. Reminds me of the Gemfile/gems.rb change :/
If you're arguing semantics in your choice of words, then ¯\_(ツ)_/¯. Alright then. You're right though! English was my second language! Have a nice day!
I don't think it is semantics. I think there's a material difference between a comment addressed to no one and "you're just an asshole."
Do you want me to say "you're right"? Mr. Non-Rhetorical - you are, in my estimation, unequivocally, 100% correct. I do hope that this victory on the internet, on this fine day, brings you some happiness. Congratulations. Have a lovely day.
Finally, some goddamn respect. As a gesture of goodwill, here's a useful English word you might not know: https://www.google.com/search?q=captious
Wow you're really carrying on. Glad to see you're above all this petty arguing like you said a couple comments ago.
Never in a million years would I claim to be above petty *arguing*, especially when I've been accused of hypocrisy on spurious grounds.
So much yes. People keep telling me they're afraid of magic with my 'drawers' gem
The author gives 'supernatural' as part of a definition of 'magic'. I think supernatural is a perfect term for metaprogramming actually. Metaprogramming means literally programming at a higher level to normal, and supernatural means literally at a higher level to nature and the normal way things work. 'cannot be explained by the laws of nature' is also a great definition of metaprogramming. It's behaviour that cannot be expressed without the use of a special set of metaprogramming methods. Seems like a great way to describe it to me!
No - supernatural is a terrible way to describe Metaprogramming. Supernatural is something that is fictional, not real, like monsters or ghosts or the devil. Meta Programming is just a skill to learn
I've always interperted the term magic to come from Clark's third law: &gt; Any sufficiently advanced technology is indistinguishable from magic. Author does not appear to consider this. On a more direct topic, anytime you try to dictate what words people should use to express an idea - success will be extremely hard to come by.
Well I just disagree. Not all definitions of supernatural are going to fit - it's an analogy. But the general idea of 'supernatural' - something working above normal nature, is exactly what metaprograming is. My dictionary even says that a definition is 'dealing with metaphysics'! So the analogy is just applying the idea from the physical world to the programming one.
&gt; you don’t break naming of a gem that is being used by almost every project that uses constructed data. That's a fair point. I didn't realize they had [broken dependencies](https://github.com/thoughtbot/factory_bot/issues/1055) - but that's just a mistake in versioning. There's nothing wrong with the word 'girl'. We see it every day in art and media. If someone tries to censor 'The Girl on the Train' or 'The Danish Girl' because of their names, that's a real cause for concern. But you gotta pick your battles. Thoughtbot could launch an awareness campaign about the origins of the gem name, publicly debate their critics, and thoroughly entangle themselves in a fraught sociopolitical issue. Or, they could say, "Hey, maybe gem names aren't that important as form of expression" and just find-replace in a new repo.
That gem looks amazing. I've always organized my non-rails apps like this. Thanks you. :)
&gt; I think supernatural is a perfect term for metaprogramming actually. 'Metaprogramming' is a perfect term for metaprogramming. Anything else is just showing off.
Sometimes someone isn't familiar with a term, and you need to use other terms that they do know to help them understand it initially.
If you're having a live conversation, fair enough. But not in a readme or other doc.
I concur but I would still probably describe "meta" in other terms. I wouldn't use supernatural since that conveys a completely different meaning, at least for me.
The one thing that's not addressed here is maintainability on teams. I loved the article, and philosophically agree pretty strongly. In personal projects (and maybe more often than I should in professional projects) I tend to lean pretty hard towards DRY and fun/clean DSLs. This can, when I don't keep myself in check, end up in a lot of "magical" metaprogramming or slightly more obscure design patterns. I strongly agree with the author that just because a junior dev doesn't understand something, that doesn't make it too complicated/magical/whatever. However, if you're trying to build a maintainable product on a team with engineers of mixed skill levels, you'll really be doing yourself a favor to curb those "too clever" solutions in favor of something a little more obvious/readable. That might just mean avoiding things that make code harder to grep through, like looping over an array of symbols to dynamically define a set of similar methods (and just statically define those methods instead). For personal projects, or even open source projects/gems, I say go nuts, stretch your brain muscles and have fun! But if you're working on a team, and potentially introducing something that doesn't necessarily *need* to be as complicated as it is, that can sometimes be detrimental to other engineers and your product. Just keep in mind there's always more context to what you're working on than the solution/code itself.
thanks for the extremely comprehensive answer man. appreciate you taking all this time in helping out a stranger. that cleared things up for me :)
This is great, thanks for sharing!
You do realize, that there's no battle here? It's a bunch of loud dudes claiming they know better what's good for women. Because a bunch of men deciding what's best for women is what feminism is all about. There's a link in the comments to the issue you linked that you can follow to see the discussion about the name change. Go on and count the number of women that were involved. Try and find a comment that attempts to invite one to a discussion.
&gt; You do realize, that there's no battle here? That's great news! So let's just drop it, and trust that the maintainers of the project are acting in its best interest.
That could quite literally get me fired.
I agree with the premise of this article, but I strongly disagree with the final conclusion. To me, something is magic if you cannot quickly and simply explain what something does or how it works to the average programmer. (Average here refers to the things that are considered pre-requisite knowledge for a language/framework, not to skill level) This is clearly an extremely subjective measure, and what "quickly", "simply", or "average" mean are up for interpretation, but ultimately our definition of "magic" changes over time. For me a very concrete example of what makes something magic is the two forms of invoking the [Active Record attributes API](http://api.rubyonrails.org/classes/ActiveRecord/Attributes/ClassMethods.html#method-i-attribute). Consider the following two (equivalent) method calls: attribute :price, :money attribute :price, Type::Money.new I would call the results of both of these magic, but the second one significantly less so. With the first one, I need to not only explain what `attribute` does, but also what `:money` refers to, how it ties to the `Money` type, how you figure out what object it maps to, etc. Even if it were a simple hash lookup (it's not), it still dramatically increases the "magic" level for me. Additionally, even if you don't fully understand what `attribute` does, you can *infer* a lot about what it is *able* to do based on the methods provided by `Money`. The only reason that I would still call the second version "magic" is due to the fact that it affects methods like `where`.
&gt; anytime you try to dictate what words people should use to express an idea - success will be extremely hard to come by. I'd just like to interject for a moment. What you’re referring to as Linux, is in fact, GNU/Linux, or as I’ve recently taken to calling it, GNU plus Linux. Linux is not an operating system unto itself, but rather another free component of a fully functioning GNU system made useful by the GNU corelibs, shell utilities and vital system components comprising a full OS as defined by POSIX.
As a robot, I just want to say that nobody asked anyone in our community how we feel about this. Typical.
Your management does gemba walks? That's pretty cool.
IMO, there's no such thing as _objectively_ magic code, because [magic is a point of view](https://www.rubypigeon.com/posts/definition-of-magic/)—it depends on the developer. I remember a tenderlove tweet asking people to show him examples of magic in Rails, because he didn't see it. He's made more commits to Rails than DHH, so it's not surprising that the codebase isn't magical to him. I think "implicitness" is a better, more objective, metric.
&gt; Any sufficiently advanced technology is indistinguishable from magic. Initially, I wanted to recite this and speculate on, but decided to stay more focused, I believe my answer can be deduced from the rest of the article (as well as an answer to your last phrase). When I started to use Ruby (in 2004), the "magic" was more positive word in relation to Ruby code. But currently, it became almost pejorative, and things are frequently going like "Son, don't use metaprogramming. Why? Because metaporgramming is _magic_, and magic is _bad_". It was "too much magic is bad" and "too clever code is bad" a while ago, but tend to lose "too much" part of the statements. That's the fact I want a reader to be aware of. (And, finally, I find it sometimes funny how people tend to recite jokes and metaphors of classic sci-fi authors as they are really "laws" in a sense "laws of physics".)
Related: https://bugs.ruby-lang.org/issues/14004
Ouch. When I first planned to write this post, I wanted to link to yours, then just forgot :( Closer to the point, I believe that my definition of magic has some value in it. Yes, implicit/explicit question is related, but for me, say, "implicit agreement coming from language itself" is much more important than "implicit agreement coming from library used". (Though, speaking of Rails and its added conventions, some may argue that you are indeed using "Ruby on Rails" language, and should master it, and then everything is obvious. I am OK with this approach, but at least people should be aware of it themselves.)
&gt; However, if you're trying to build a maintainable product on a team with engineers of mixed skill levels, you'll really be doing yourself a favor to curb those "too clever" solutions in favor of something a little more obvious/readable. Yes, that's obviously one of the points to consider. But in my head, it is not "too clever" (with metaprogramming) / "obvious/readable" (without metaprogramming) dichotomy. To be _maintainable_, code should be as concise and readable as possible. So, in a lot of cases (and I am saying it on real-life experience with a pretty large codebases, used by teams of variable experience), it is more robust to have something like class OneOfManySimilar &lt; SomeBase behaves_like :this but_changes(:that) { this_way } end ...instead of "explicit" specifying "oh, in your child class just reimplement those 15 methods in a meaningful way, and don't forget to add your class to that constant list of registered actions, and ...". Several times I've seen that some simple DSL introduction revealed bugs in the previous implementation or even architecture (e.g. "trying to generalize what can be generalized, we suddenly discovered class B was the only to implement `#methodname` in a different way; and class C should not, in fact, be part of this hierarchy"), and made everyone's, including newcomers and juniors, life easier. Of course, some balance is necessary. If you use `%[array of symbols].each { define_method ...` approach for defining just two slightly similary methods, it is probably not a wise decision. Or if you define a complicated DSL definition interface just to use it in one place. The same, though, may be said abone any language feature, metaprogramming is nothing special here.
The comments on that are pure, radioactive toxicity. Step 1: Deliberately bake misogyny and boorish childishness into a subculture Step 2: Wonder why functioning adults disrespect you Step 3: Go to Step 1 Step 4: Grow up.
Yes... if yours aren't, then there's a chance you're doing AINO. Management is supposed to *care* about the work you're doing (shocker, I know). One of the most basic ways to show you care about someone is to visit them, ask questions, and show interest. *Sometimes*, if you're worth your six figure salary, you might even get something out of your team's way.
I did this ans = (BigDecimal.new("1.0", 1000)/BigDecimal ("#{n}",1000)).to_s('F') But I an still only getting 15 places. I am not sure what I am doing wrong
Well, 4 people publically said that you're a nice guy, but 12 people privately confided in me that you're actually simultaneously a dick and a pussy, so it must be true.
moderation is important
https://www.youtube.com/watch?v=vKuJ9ujMQBQ
Here Here! (I would have used "Hear Hear!" but didn't want to offend deaf people).
Please don't use the word *guys*, it's a gendered pronoun and someone may find it offensive. 
I'm not disagreeing with you. I think both of our definitions are right! They are just different perspectives on the same thing. And they both lead to the same conclusion: it's not helpful to label code as magic, just because beginners won't understand it easily. The difference between us, I think, is that I'm not worried about people overusing the label "magic". Beginners say everything is magic, and that's ok with me, because I know it's due to their skill level, not necessarily a problem with the code. So instead of thinking "inheritance isn't magic", I think "inheritance is magic to you, at your current skill level, but not to an experienced Rubyist." I interpreted your article as a description of magic from the perspective of an experienced Rubyist, who has a good understanding of what is natural and unnatural in Ruby. That is useful, because if an experienced dev thinks something is magic, it might be a real problem with the code.
yeah, moderation is important because destructive personalities usually prefer bullying their critics over reflecting on themselves
Really hope it's sarcasm :).
Look interesting. Question is how (good) will it work on real world projects with metaprogramming and other fun stuff.
Another question: why do it? There are plenty of statically typed languages around...
Cool, I will save this to watch later
I imagine it'd be an opt-in sort of thing. Omitting types would just fail back to `any` objects, where essentially anything goes and you don't get the benefits of static checking. TypeScript works like this and it's fantastic.
This is a great presentation, well worth the watch. Proper live-coded examples, lots of reflections. A+ teaching here.
/u/zverok_kha Great post! Could you please reference me where I can learn more about "drivable is a method, defined for a Class directly or by extending with some module (which is not the best practice possible, yet still pretty easy to guess for any non-junior Rubyist)"? I am not familiar with this pattern. Thank you 
You can’t just use the / operator, because it won’t let you specify the significant figures of the result. I guess 15 is the default. Use the div method instead.
Not offensive, just annoying, especially in a thread about gendered things.
&gt; “Metaprogramming”, e.g. generation of code objects during code execution, is one of the most powerful Ruby features, and it is so because how natural it is for the language. And due to this naturality, it is one of the first and the best guesses for code design in most cases. I'm not sure what you mean here. Do you mean first and best thing you guess might work right when designing code? In which case I disagree. It's sometimes useful, but if it's the first thing you reach for, then it's unlikely to be the best thing to use in most cases. Do you mean first and best thing you might guess is behind the implementation when you see something mysterious in someone elses code? In which case it's kind of syllogistically true, but not too useful, since you still have no idea where it is implemented or how just by knowing it's some kind of "metaprogramming". 
Fwiw I’ve used the gem since it came out. I’ve had it in multiple projects and never knew there was a song by that name. I’ve even googled the name to see if it meant something and all I got was a movie with bad reviews. Interesting how so many people on this thread are 100% sure what the name meant but how many of those takes are different. 
There are women on this comment section.
A release that supported both names probably wouldn't have hurt. I wonder if getting your project to support the old name too is as simple as `FactoryGirl = FactoryBot`. 
Wikipedia suggests they haven't eliminated the word 'fuhrer' from german, and it's still a common word in the language. 
what is wrong with you?
And my knowledge being born a German is that it's still a word that isn't heard without a certain uneasyness in the voice when it's used on its own. And ofc 14yos giggle whenever it's used correctly.
For companies like Shopify (and other large Ruby houses), it is not cost efficient to switch to something that is statically typed. It is also not desirable. Ruby is a great language that gives a lot of benefits and would be made much better by simply adding type checking. By generating type contracts and applying these, we allow developers to write safer code and allow them to be able to traverse the code. Imagine this example: class A def foo puts "foo" end end class B def foo puts "bar" end end def my_method(my_var) my_var.foo end Does this example output foo or bar? You could argue to write more easily understood code, but `my_var` could be changed to what? `my_a_var` or `my_b_var`? How do you know what's being passed? Imagine this with a method like `.to_json` on objects. Of course, you could put a debugger in and print out the statement - but technically anything with the method `foo` would work - how do we use it? By using static typing, you make more readable code, more easily understood code, and you can start giving the compiler hints on how to compile and run the code - which means faster code. These are some of the reasons why the Ruby core contributors mostly agree that static typing is a reasonable goal that should be given some priority in the coming years. They dedicated a good 20-30+ minutes of their "Ruby Committers vs the World" segment at RubyKaigi this year. I work at Shopify on the developer productivity team (dev ops mixed with SRE) and I spoke at RubyKaigi this year. Between the two, it became evident that this is something worthwhile for the Ruby ecosystem (and a fun problem at that!) 
I don't have management, and I don't really care about agile all that much either, other than the good ideas that came out of XP. The notion of "getting to the gemba" from lean, on the other hand, is fascinating to me. Cheers.
&gt; By using static typing, you make more readable code, more easily understood code, and you can start giving the compiler hints on how to compile and run the code - which means faster code. This is the part that I find interesting. I'd love to hear more about this effort. I'd be wary, though, of expecting static types to improve your overall productivity all that much. I don't think there's a long list of companies that switched from Javascript to Typescript and found their productivity increase, for instance.
I want man pages to be renamed to document references.
I thought this was going to be talking about Grim. That's what i get for subbing to both /r/RWBY and /r/ruby None the less, an interesting read though.
funny, i came to this sub to see if /r/rwby was mentioned in the sidebar or something.
I work full time with Ruby backend, TypeScript front, and there is absolutely no question that I’m significantly more productive with TS. It astounds me when I jump back to Ruby and my IDE isn’t able to point out when I mistyped a variable or a method, or call a method with arguments in the wrong order, or act upon an uninitialized variable, or any number of other really trivial bugs. Also, check this out: “TL;DR: both Flow and TypeScript are pretty good, and conservatively either of them can prevent about 15% of the bugs that end up in committed code.” [https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/](https://blog.acolyer.org/2017/09/19/to-type-or-not-to-type-quantifying-detectable-bugs-in-javascript/)
Don't forget the migration is still ongoing for Typescript (We're switching to that too), and that's going to be a long tail effort. We expect improvements more long term. Right now, we're not heavily involved in any typing efforts but are talking with other larger Ruby orgs who all agree on typing. Personally, I'd like us to do more research before developing any strong opinions and possibly talk more with the academia world on typing. I know of one professor who is working on it, for example. Don't be too discounting on the benefit of a good lightweight IDE-esque experience. Ruby provides plenty of good shit to build fast, but those same benefits are a detriment at larger scale. They oftne encourage anti-patterns like metaprogramming, weird patterns in code structure, and often - with such variance in how to accomplish something - confusing layouts within the same application.
&gt; Someone else did apparently It was moderated. Also if you're not doing the math, this little outburst nearly stripped you of all karma. You might have an easier time if you delete your account and start over with a new attitude. 
But "terminal" and "xinput" are barely related… What does the OP really mean by that title?
First thing I read was wrong. Doesn't bode well for the rest of it. # Rescues all errors, an puts the exception object in `e` rescue =&gt; e 
&gt; Personally, I'd like us to do more research before developing any strong opinions and possibly talk more with the academia world on typing. I know of one professor who is working on it, for example. That's fair. Everyone has a different experience writing in a dynamic language like ruby. I have found that I can catch most mistakes compilers catch, and I still make the mistakes compiler's _can't_ catch. Everyone's mileage may vary, of course. &gt; Don't be too discounting on the benefit of a good lightweight IDE-esque experience. Ctags go a long way -- at least as far as is necessary. I can generally find the code I need very quickly without an IDE. &gt; Ruby provides plenty of good shit to build fast, but those same benefits are a detriment at larger scale. They oftne encourage anti-patterns like metaprogramming, weird patterns in code structure, and often - with such variance in how to accomplish something - confusing layouts within the same application. I would wager that at any definition of "scale," architectural qualities like natural seams and partitions matter more than type systems. That said, how do you reconcile this perspective with the fact that static typing will always be optional in ruby? What I mean is, if programmers can choose whether or not to annotate their interfaces with types, then there is _another_ source of variance. I've worked on massive rails codebases (700+ activerecord models, millions of rows per table, massive `lib/` directories with mixins that bestow hundreds of methods on every model in the project, etc). I don't think I'm yet ready to buy into the idea that allowing the language to act as a stricter goalie would make a dent in the complexity of those systems. I'm open to have my mind changed, though, so I'm interested to see how this all pans out.
Are you referring to the typo ("an puts" should have been "and puts")), or the fact that `rescue =&gt; e` rescues `StandardError` and its children? I fixed the typo. We talk about the difference between `rescue Exception =&gt; e` and `rescue =&gt; e` [later on the same page](https://www.exceptionalcreatures.com/guides/what-are-ruby-exceptions.html#rescuing-all-exceptions-the-wrong-way).
I was referring to "Rescues all errors". Judging by the number of Stack Overflow questions this is a pretty confusing topic and this doesn't help. If you're targeting new devs those paragraphs you linked to don't make it much better. What's the difference between an "Exception" and an "Error"? What does "all of the errors you'd want to rescue" mean?
&gt; Attack is calculated using data from Honeybadger.io How exactly is it calculated? Is a `NoMethodError` the most thrown exceptions followed by `TypeError` and `ArgumentError` on Honeybadger.io? If so, this would make a great counterargument to common claims that static typing only prevents the bugs "one wouldn't make anyway".
I think it's great test-wise, I did very similar strategies for testing parsing in isolation. From your high level tests, I assume "web_page" object is persisted beforehand since you're using FactoryGirl. This brings up an issue though, since you're passing an AR object in your Sidekiq job without "verifying the identity" before you process, you could run into this: https://github.com/mperham/sidekiq/wiki/Best-Practices#1-make-your-job-parameters-small-and-simple It's unlikely in a simple system, but it could cause incorrect results if your models were updated by something else (url changes in DB table before job runs), .. but again this is unlikely for a side-project ;) 
This is a fun project. Kudos to the dev or marketing team that came up with this.
We have a large effort at Shopify to "componentize" our core application. That is, to create partition between sections and have "mini rails apps" that are actually all one big rails apps. This addresses part of the problem - the partitioning. While I'm sure you may have no problems going without the IDE, many do have problems and I suspect many more who dont have problems will still see benefits to productivity. As for optional typing, this is a cultural problem imo. We could basically start enforcing that all new and changed code would be typed (via selective rubocop) as one way to help this. I can't really go much more into detail as I need to research more to formulate a good opinion.
Your posts bury a nugget of help in a mountain of asshole scorn. You can do better.
[removed]
Nice. Thanks for the constructive criticism. 
I hope y'all publish learnings that come out of your research efforts! &gt; As for optional typing, this is a cultural problem imo. We could basically start enforcing that all new and changed code would be typed (via selective rubocop) as one way to help this. I entirely agree, but the problems you cited related to "untyped" ruby (metaprogramming, "weird patterns in code structure") could also be viewed as cultural problems. Those kinds of problems caused by programmers banging out code in an undisciplined fashion don't go away with type systems, the programmers just end up doing the bare minimum to satisfy the compiler, even if the ensuing design doesn't make sense. Thanks for the discussion!
This is an interesting comment. In trying to think of what types of exceptions you DO still see in those languages, I kept coming back to them being represented by NoMethodError in Ruby. For example, an exception that you might otherwise commonly see in something like c# for example, might be index out of bounds. Or a null error. In most cases you run into a "nullish" problem in Ruby, it manifests as a NoMethodError... ``` things = [1,2,3] stuff = things[100] # =&gt; nil stuff.any_reasonable_method_you_expect_from_some_other_type # =&gt; NoMethodError ``` Meanwhile, it does of course also have some hand in those low hanging fruit errors that would have been caught by a compiler as you suppose. I think this same holds true for TypeError, as you are often passing `nil` into something that otherwise expects something else. Again, that wouldn't necessarily be caught by a compiler either. So, not disagreeing per se, but it does seem like the same exceptions that would be thrown in a static, compiled lang probably look like `NoMethodError` and `TypeError` in Ruby. Is there a ranking of caught c# exceptions? I'd imagine null errors and index out of bounds are some of the most common. Interesting way to look at that "topic."
&gt; metaprogramming Unfortunately this is the definition of Rails :) &gt; publish learnings that come out of your research efforts! Usually on our blog! https://engineering.shopify.com Cheers!
Basically I took a count of all the unique error classes in our database that exist in Ruby core/standard lib and sorted them by most occurrences first. Keep in mind that this excludes 3rd-party errors. `ActionView::Template::Error` is by far the most common, but that's a wrapper for a bunch of different error classes. :) So yes, `NoMethodError` is the most common (by a large margin). I haven't dug in this far, but my guess is that the most common error in Ruby is "undefined method for nil:NilClass".
*raises hand* Cofounder here. My wife does the artwork. :) Glad you like it!
Not a fan of the choice of words, but I kind of felt the same way. Your critique is a cheap shot. Maybe you just aren't explaining your idea well. You seem to be nitpicking the difference between an Exception and the Error classes. You talk about the site being unhelpful because of a vague reference to stack overflow questions, as if it's the author's responsibility to correct the issues of the world. It's a human website, for fun and for marketing, not a technical manual. It was fun to read, and informational. If you feel there is actually an issue with it, get to the point, and perhaps even suggest how it could be improved instead of waxing theoretical. `What does "all of the errors you'd want to rescue" mean?`? Really?
HAIL TO THE NIL, DESTROYER OF WORLDS!!!
I agree, `nil` is very likely the major cause of most of theses exceptions. I didn't have C#/Java in mind, though. I was thinking of languages with "proper" type systems. "Proper" meaning they would be honest and not ignore the existence of `null` [1]. So `stuff = things[100]` would have the type `Integer | NilClass` [2] or `Maybe Integer` [3], meaning you wouldn't be able to directly call `#+` on it without explicitly checking for `nil`. [1] However, Java has `@nullable`/`@notnull` annotations and a similar feature is proposed for C# as far as I know. [2] Called union types. Can be found in e.g. Pony, Crystal and TypeScript (+ `--strictNullChecks` compile flag). [3] Haskell, Elm, PureScript, OCaml, Rust, ...
Thanks! Having such a huge dataset about "bugs" in Ruby programs sounds interesting. Have you thought about publishing some statistics/an anonymized dataset?
I haven't, but that's a great idea.
How do you "not care" about agile? In 2017 that's a bit like saying you're a software engineer who doesn't care about a keyboard. Sure, it's *possible* to software development without using a keyboard, but there aren't many out there who try it any more (punch cards?)
I feel like I understand a bunch of things a lot better. Thank you.
OK, sure... Honeybadger make their living from exception handling. You expect them to have expert level knowledge and have clear and accurate documentation (This page I looked at is a copy/paste of Honeybadger technical manual ([Honeybadger.io Documentation : What are Ruby Exceptions?](https://docs.honeybadger.io/ruby/exceptions/what-are-ruby-exceptions.html#exception-objects))) Is it my responsibility to correct the documentation of a commercial product? Maybe it is. On the “Guides” page this statement is incorrect. # Rescues all errors, and puts the exception object in `e` rescue =&gt; e As Avdi Grimm states in his book “Exceptional Ruby” “…a bare rescue with no arguments following it is **not a catch-all**. By default rescue only captures StandardError and derived classes.” The section “Rescuing All Errors (The Right Way)” referred to by OP is also ambiguous. It states “if you want to rescue "all errors" you should rescue StandardError” and “all of the errors you'd want to rescue“ without explaining the reason why you should rescue StandardError and not rescue Exception. Again from Avdi Grimm’s “Exceptional Ruby” “The exceptions outside of the StandardError hierarchy typically represent conditions that can't reasonably be handled by a generic catch-all rescue clause.” And interchangeably using “Exception” and “Error” might confuse new developers, eg. “Rescuing All Exceptions” then “Rescuing All Errors”. Sure have fun with this, but it should be accurate, especially when the Ruby exception hierarchy is something new Ruby devs find confusing as evidenced by the number of questions that keep coming up, and the number of blog posts about it. This site reflects badly on their service. (And try to avoid telling your customers they are arseholes). 
When you call `sample()` with an integer you don't get a single word, you get an array of them. When you print out an array using string interpolation you're going to get the 'stringified' version of the array. What you probably want to do is join the array instead of just interpolating it into puts: ```ruby words = ['bing', 'bang', 'boom', 'zip', 'zoop', 'zam'] some_words = words.sample(3) some_joined_words = some_words.join(' ') puts "your words are #{some_joined_words}" ``` There are a whole bunch of ways to accomplish what you're doing, but `.join()` to join arrays into a string is probably the simplest and most readable.
I don't mind speaking up and telling someone when they are acting toxic. Ever shipped v1.0 of anything? I bet it contained lots of bugs. But nice people report them in a helpful manner and they get fixed.
I see! Okay, that does make sense. Thank you very much.
 I agree that we should clarify the difference between an Error and an Exception, which I fully understand. If you’d have given me the chance to have an opinion, I would have told you that. I would have even thanked you. I never called you an asshole. That said, given the approach you’ve take with me, I’m not going to defend you when others do. If you feel like I’ve wronged you in some way, it wasn’t my intention. I am happy to discuss it with you in person. josh@honeybadger.io
I don't care about stupid "karma." Hell, who cares about *real* karma anymore in this fucked up world of ours? Moderators on reddit make it look like people like me are the ones who deserve bad karma, when in reality the ones who deserve bad karma are all around us and they don't do their evil shit publicly. Instead, they're lauded and praised for other bullshit that they do to cover up their secret crimes. I sincerely hope folks like you learn to get a grip on reality and realize that angry people like me are angry for a reason and that there are **much** more dangerous beasts that you think are friends. Have a nice life and a nice, stupid conference where you encourage more bullshit in our society.
Just realized it's my cake day.
Upvoted. Tech seems amazingly consistent at attracting a high degree of destructive personalities. That this has been obvious as a vicious cycle for at least 35 years speaks volumes.
There is sample code from someone else that did use the / . I am not sure how it worked for them.
Happy cake day Richard! Nice video. Not sure if you've seen / read Jesse Stormer's book "Working with Unix Processes". For those looking for a more in depth look at processes (and threads) this is a fantastic read as well.
Anybody actually legitimately used Thread for something? The only time I felt I needed them when I wrote a web scraper. But it was randomly running out of memory and stuff. There was a period few years back when everybody were excited about EventMachine, Thin, Cramp (I had to work with that nonsense). Node.js was leaking pretty hard. What happened to all of that?
In some way querying external APIs is „web scraping“. That’s where I use threads all the time to parallelize requests which don‘t depend on each other. If you’re running out of memory try to use thread pools with a limited amount of threads: http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/FixedThreadPool.html
Puma, Sidekiq, timeout.rb, bundle install -j, ... the average chunk of code isn't going to be spawning threads manually, but I wouldn't say it's rare to have multiple threads running.
I learned this in school (I am not a native speaker). Since then it was validated by many (all?) woman I met (they also used guys to refer to a group). In short; that's what I learned in the English classes by female teachers. Here is a proof: https://www.collinsdictionary.com/dictionary/english/guys
You sure are into threads. Honestly though, I still have no idea how I'm going to use threads in my everyday Ruby life. I know I can use processes. For fighting memory leaks, for example. I gotta tell you, I was surprised by the number of people @ RailsClub who approached you to talk about threads. It was weird. I mean, here's a guy with a different cultural background, and all y'all have to ask is threads? How do you even use threads in every day Ruby? 
FYI: I've put together a [blockchain-lite gem / library](https://github.com/openblockchains/blockchain.lite.rb) and [an awesome blockchains page](https://github.com/openblockchains/awesome-blockchains). Happy blockchaining. Revolutinze the world a block at a time. Cheers.
&gt; I would wager that at any definition of "scale," architectural qualities like natural seams and partitions matter more than type systems. I have to agree. I think the class of errors that static typing catches early or even prevents is not the most expensive one. Issues in architecture or high refactoring efforts due to bad architectural structure cost way more. Thank you both for the interesting discussion! Just wanted to chime in to let you know this thread did not go unnoticed by me. :-)
* [`Parallel tests`](https://github.com/grosser/parallel_tests) makes a **big** difference when dealing with a large test suite. * Web scrapers are another good use, as you say. (You shouldn't run out of memory if the threads are handled properly?) * Another good use I've had is when importing multiple large files. YMMV depending on how the "import" actually works. * Asynchronous background jobs such as sending emails, generating files, analysing data, ... Possibly `ActiveJob` as you say; but I've also done this completely outside of Rails-world. Pretty much *anything* non-IO blocking where performance is key!
Is there a fork yet? I for one will never be referring to FactoryGirl as FactoryBot.
What kind of programming do you do? Web backends? Well then probably you don't need threads in your day to day work. Some people do other kinds of programming, and threads allow them to run blocking system calls concurrently, and on Rubinius and JRuby they allow them to run Ruby code in parallel and so making more efficient use of the 8 to 16 core processors we have these days.
What are the key benefits/drawbacks/differences between `RomFactory` and ~~`FactoryGirl`~~ `FactoryBot`/`Fabrication`? I see you've benchmarked this library as slightly [faster](https://github.com/rom-rb/rom-factory#performance), but is this primarily because of a better design, or because it's lighter on features? (What key features is it missing?) It sounds to me like the killer feature is still in the `v1.0.0` roadmap: Using this as a pure data generator without any specific persistence backend?
Interesting. How does this compare to using a message queue? I like the idea of just running one Faktory server in production, vs. say, having to run Kafka _and_ Zookeeper. Outside of just the bare metal infrastructure characteristics, though, logically speaking how would a project be shaped differently by using Faktory for background jobs instead of Kafka for messaging?
I would recommend asking on the Roda Google group.
Just skimming through but looks really cool for a polygot environment. What made you decide to *go* with Go vs. Crystal? Parallelism?
Ecosystem size. Crystal is still maintained by one small company.
I'm a native english speaker. If you're in a group it's fine when it's clear you're obviously referring to the group in general. However it's confusing because you can also use it to only refer to men. If you say "guys on this thread don't seem to like this change" it's ambiguous if you're referring to all the people or just to the men. If you assume one way or another you're not wrong since the statement is ambiguous. By not using "guys" to refer to a group of people you avoid that ambiguity and the intent is clear. Better alternatives than "guys" is "you all" or "yall". As it's clear you're not singling out just the men. I live in texas so this is second nature. "Guys" as a signifier of a group is north eastern colloquial. It's spread quite a bit and is generally understood, but can still cause confusion. As a programmer I don't like ambiguity, especially when it comes to writing on the internet, because it's much harder to interpret intent. 
He also has one about threads. I've only read that one. It was really informative, but didn't get into quite this detail. It's been years since i've read it, but I remember it being good.
Kafka and RabbitMQ will be much more complex to set up and administer. Faktory doesn't even support a configuration file today because I've specifically tried to minimize configuration options and have it "just work".
can you give us a compression between ruby vs go?
If I understand correctly, the main advantage of Faktory over Sidekiq is that the worker (or language specific) part concerns itself chiefly with processing jobs, and any other feature (logging, retry, I imagine eventually batch and so on) are relegated to the server. Correct me if I'm wrong though. I have a few questions: * Do you plan to implement all of Sidekiq features in Faktor For example, cron jobs, unique jobs, batching, etc. * How would I go about making backups of my server state? Admittedly I know nothing of RocksDB so this might be a dumb question, but we regularly make backups of our Redis DB, so if something happens we can always rollback to a previous state. * Are there plans to make a clustered mode? With Sidekiq and Redis this is easily achievable. Not only would we need this to scale on demand, but also for high availability. I'm unsure how you'd do that with an embedded database though.
Have you ever set up RabbitMQ? it's pretty damn painless.
a cultural problem? you just laid out your arguments, why do you now say it's some boogieman 'culture'?
I was actually referring to the maintainers of FactoryGirl, not people in this thread.
See, the term is too ambiguous. Use a more specific noun and avoid the ambiguity. 
The job processing is done in worker processes, implemented in whatever language you want. 1. Yes, but those features will likely be commercial. 2. Faktory has a CLI tool today which supports "backup" and "restore" commands. 3. Not at the moment. You will generally need to scale the worker processes, not Faktory itself. Just as you have one mysql, you'd have one faktory. You can shard and take frequent backups today. I do want to improve this; having real-time off-host replication like Redis would be great.
Hey, if you like Rabbit, use it. It's rather complex and overly general for my use cases. Background jobs are a more specialized message format but with specialization comes focus.
Does this (or faktory_worker_ruby) implement the ActiveJob interface? Also, what would be the benefit (besides getting rid of Redis) in switching to this from Sidekiq? Maybe not right away, but after more commercial features are released? (we are currently using Sidekiq Enterprise). 
I store non-secrets in the rackup file. If I need different configurations, I just use a different rackup file. So things like `dev.ru`. That file can even sometimes provides a wrapper app to add functionality to the main app if I need it via middleware or additional routes for debugging. Secrets I get from either the shell environment or Vault.
Not yet, help welcome. The advantage is language independence. Tons of people have asked me "We want something like Sidekiq but for $LANG". Now you can write one job in Ruby, another in Python, a third in Swift, etc and they all use the same infrastructure and conventions.
The fact that you assumed xer gender is alarming to say the least. 
If you're going to be a misoginist you deserve to have your code broken. 
Yes it does. It shows which projects are profeminism and which are conservative, alt right, white and masculine, or worse. If you can't take the time to update your name then that's on you...
I realize it's pretty new, so this is a lot to ask, but I'm gonna do it anyways, since I'm interested: do you happen to have a protocol document anywhere? I'd like to see the contract between the server and the job issuer, as well as the server and the worker. If not, no worries.
Check out the wiki, this is likely most relevant to you: https://github.com/contribsys/faktory/wiki/Worker-Lifecycle
Thanks!
Why not? Mistakes in _how_ they deployed it notwithstanding (since that mistake is readily fixable and has been fixed), what objective benefit is there to leaving a culturally specific name for a tool which also made some of its users uncomfortable? Bearing in mind that the changeover is optional at this point, and that implementing the change is a one-liner, I have a hard time constructing an argument to leave it as-is that isn't problematic or prevaricatory.
One is a pink-red colored gemstone. The other is a verb describing movement.
That's as absurd as asking people to decimalize their currency, adopt the metric system, use the internet to do... almost anything in contemporary society, or start writing the new year on their checks. In other words, cultural or personal inertia, specifically when it comes to revising tutorials, is a pretty fucking mealy-mouthed objection.
In other other words, you raise the same objection to my argument that other raised at other times, in other situations, where the objection's potency will have varied------and are pretending its potency is consistent across all cases. In other other other words, you didn't even comprehend what I was saying. You're confusing cultural inertia with the inherent value of persistent branding. You'll note, btw, I have actually managed to use the word 'inherent' correctly, unlike many of your ideological cohort.
I think you might over-value persistence over consistence. It's a tool, and as such its first job is to work. Since they're not selling anything, I'm not sure how relevant branding is in this case.
Seems promising. I've considered RabbitMQ should I need multi language support. Can you compare Faktory to RabbitMQ? Also, I fear that with the release with faktory sidekiq's (we all love it) will slow down in regards to progress and future development.
So people can find things. That's why it's valuable. That's what I said in my first fucking comment: all those thousands of tutorials are "misnamed" now. A year from now, noobs to the gem will have no idea about the name change. If you actually believed the words coming out of your mouth, you'd have changed your own name dozens of times by now. You don't, and it's not just because you like the way it sounds. 
The sidebar.
Everybody uses terms differently, obviously. I've come to associate "magic" with "non-local reasoning". That means monkeypatching (I wouldn't know where to look for some functionality), it also to some extend means overuse of inheritance (I dislike inheritance in general, but at least it's generally explicit and only becomes cumbersome when the inheritance chain (this includes mixins!) becomes very long and you'll have to dig through loads of source files, something Rails tends to be guilty of). Anything that mutates global state to be used somewhere completely differently also applies. Non-local reasoning has its place (there's an argument to be made that concerns like logging should maybe not be directly be part of the business logic but extracted with some form of aspect-oriented programming), but personally I try to rather limit its extent.
To play devil's advocate though, while "Führer" can be used to mean "leader", I find that in practice most people would say "Anführer" whereas "Führer" (aside from the Nazi meaning) has more of a "travel guide" connotation for me.
I sent you a copy of my book for beginners, so check your private messages.
Hoo boy... Ok. 1. Your first comment was "You fucking people." 2. I rather doubt "noobs to the gem" will have a problem since, you know, git saves code history and since most new coders will find the official docs and the first page of google hits the most useful. You know what's apt to be up to date for them a year from now? The official docs and the first page of google hits. Also, to be frank, when I was new I only had experience with Rails 3+, and yet I was able to at least grok what was going on in Rails 2 code, which had comparatively massive changes, because documentation, outdated as it may be, can still be valuable. 3. So your argument against mine is that changing my name (presumably my real name?), which is a bureaucratic nightmare and is honestly of little use or interest to many people, is equivalent to changing a gem name and namespace? That sounds like a false equivalency, or, in your terms, pretending that that argument's potency is consistent across all cases. It's a trivial, one-liner on the command line, not converting a ruby app to brainfuck. Hell, it's less complex than setting up a dev environment, or even upgrading rails by a minor version. 4. If consistency of branding is so important, isn't staying consistent with the -bot naming convention arguably more valuable to them as a company? Seems to me that would generate a much stronger association to anyone interested. Listen, I'm gonna level with you. You should've stopped with your first comment ("You fucking people."). It's pretty clear that that is the sum total of your material objection, that you dislike the change because it specifically makes the community less niche and more open to all, and that at best you're scrambling to make practical objections when it's an absolutely trivial change to implement in practice. Hell, I can send you a bash script to make the changes if you need it. The documentation will still be there, the code history will still be there, the outdated tutorials (which, by the way, will likely reflect significantly more problematically outdated samples of previous versions of the API) will be useful enough with less than 10 seconds of googling.
&gt; As a programmer I don't like ambiguity I really don't want to go into the whole "is guys exclusionary" debate (I'll happily use something else if that's what people prefer) but I find this particular attitude problematic. There is no natural language communication without ambiguity. Wanting to eradicate ambiguity in communication can only lead to despair and frustration; I suspect that such ideas underlie a lot of the weird notions that programming culture seems to cultivate; basically, the world is a messy, confusing place and no amount of standards, agreements and documents is every going to change that. People are simply not machines.
This should be the top discussion. The bickering about whether or not this renaming should have happened seems more about people having certain axes to grind and is of secondary interest IMHO. Doing this in a patch-version update is however just irresponsible.
It's-a me, the author. I'll be hanging around in the comments here, if you have any questions.
Try https://www.codecademy.com/
The cost to removing “guys” from my vernacular was outrageously cheap. It’s not like I’m asking you to do something outrageous. If you’re willfully avoiding such an easy behavior change, I can only assume you have malicious intent. 
Did you miss the part where I wrote "I'll happily use something else if that's what people prefer"?
I was talking about having the option of typing or not. If people don't understand why it's important (which they may not if they're siloed, for example), then they may not do it. If you teach people the benefits it has for your future self, coworkers, the company - then people do it. &gt; boogieman 'culture' I don't know if I like the term boogieman 'culture' being applied here. While engineering is often times technical problems, there is still a very human component that happens with the humans involved. Opinions will form, which means difference of opinion will happen - this can cause dissonance that must be respected and worked with (sometimes telling people to suck it up), but that is a cultural aspect that must be kept in mind.
Could you change the name to FacCentralist, as a Labour voter the use of the word "Tory" is offensive to me...
lol
I’ve had great luck with Learn Ruby The Hard Way, it’s free online 
Or you could just use objects and DI instead of class level interfaces, set up the object with doubles as dependencies (set up the test), then perform the action under test and assert you got the expected output (Arrange-Act-Assert). That way you don't need to monkey-patch your test runtime with calls to `stub_const` and `allow` and can have real reusable, loosely coupled code.
i don't see how it's a cultural thing. it has to do with whether they use typechecking or not. What human component do you suppose this links with? Lack of desire to be a good programmer? Look I'm not opposed to typechecking, I just don't think it's a cultural issue.
IMO stubbing constants is a seperate topic. It's the same thing, with or without DI. The article was meant to be more about turning mock expectations into state-based assertions.
I believe there are two completely different situations that are currently handled by test doubles/mocks/stubs: 1. When "it should call `ProcessManager#spawn`" is _exactly_ what you are testing; 2. When you are testing something different, just want to mock some subsystems that have too large side effects. IMO, for situation (1) the "custom double" approach is overkill. To do arrange-act-assert, one can just do this: expect(ProcessManager).to receive(:spawn).and_return(123) # arrange Commands::StartRecording.(cameras: [11, 22]) # act expect(ProcessManager).to have_received(:spawn).with(/camera_11/) # assert I did a small [rspec plugin](https://github.com/zverok/saharspec#send_messageobject-method-matcher) to handle it more gracefully: expect { Commands::StartRecording.(cameras: [11, 22]) }.to send_message(ProcessManager, :spawn) .with(/camera_11/).returning(123) My (2) (mocking side effect-full parts) is a completely different topic, but I am also not sure "custom doubles" would help here :)
/r/learnprogramming
Correct. For now this is mostly targetted at people who are using rom-rb or would like to start using rom-rb. Eventually, we want to make it a more general-purpose data generator.
How is POODR not on this list?
It's probably overkill if you're just mocking a single method call. In the real codebase that I took the example from, the mocks were getting pretty complicated. There were hardcoded PIDs, and each PID had different mocks for `#spawn`, `#exists?`, and sometimes `#kill`. Using a custom double really cleaned up the specs. The double _is_ there to prevent the side effects (2), but it doesn't really care which methods gets called on `ProcessManager` (1). It just wants to check whether the side effects would have happened, regardless of the methods called. So I still think it's useful for decoupling, in some situations. I have been experimenting recently with very DRY specs, so I will have to try saharspec!
Man, this rules. I love the simplicity and trustworthiness of Sidekiq. It’s one of THE crucial services that makes me stick with Ruby despite interest in moving on. Thank you for your work. Looking forward to seeing how this progresses.
Interestingly this was accomplished by changing [3 characters](https://github.com/ruby/ruby/commit/0ec889d7ed) in `parse.y`. Which also means it doesn't work when using curly braces, only `do..end`. 
Exactly my thoughts...Checked the list Just to see what number it was. lol 
[removed]
You are welcome to that opinion. Ruby has told programmers that they don't need type checking, now all of a sudden we tell them they need to. When you have thousands of employees, getting message out isn't as simple as saying "hey, y'all do this now, mmk?", nor will people remember that you said that even if you heard them say it. Not wanting to use types doesn't inherently make them bad and so we need to work with them to help them understand what benefits it provides.
I understand the sentiment. But ActiveSupport is more than just a bucket of helpers. ActiveSupport patches and expands core types. It's a test bed for new Ruby features, and backfills additions to ruby to versions that don't yet support it. It normalizes and expands support for dates and times. It's a pretty long list of general language improvements. There's a ton of value in knowing plain ruby. And pulling all of ActiveSupport into every project shouldn't be assumed. But "because it's related to rails" is a terrible reason to avoid a very stable, well maintained, versatile, useful library.
Your comment got cut off
I'd avoid it because it's large and most libs don't need it. Are there exceptions? Sure, but does a simple gem really need it? It's like Javascript and Lodash. Sure, it's a nice backfill and has good features but not every small project needs it. Consequentially that's why node modules gets 20 versions of the thing. 
Fixed! Thanks
Huge... /s That’s not on you, OP. Thanks for reporting.
I dig it! I tend to do something similar -- I package doubles (well, I call them substitutes) with my classes so that any code that depends on my classes can use the substitutes as dependencies. Glad to see someone talking about this stuff.
It's kinda pointless. What ruby core team needs to do is to go through all of ActiveSupport and aggressively merge into standard library everything that addresses real issues, and solved them in good ways. `Symbol#to_proc` started in ActiveSupport and it was one of the best things to happen to ruby. Ruby is doing this already, just at very slow pace. Methods like `Range#overlaps?`, `Hash#compact`/`Hash#compact!`, `Object#instance_values`, `Object#deep_dup`, `Module#parent`, `Gzip.compress`/`Gzip.decompress` etc. really should be there already. Something like `Duration` needs to be in standard library as well (but not `5.minutes`, that's silly, `Duration.new(minutes: 5)` is totally fine syntax for it).
A fun way to fill my inbox with more crap I don’t care about
When you said "Duration" I immediately thought of this gem: https://github.com/peleteiro/ruby-duration
Wow, what a horrendously beautiful heredoc hack in those tests… (To be fair to them, syntax tests are always awkward, and the end result looks better than most others I’ve seen)
&gt; The double is there to prevent the side effects (2), but it doesn't really care which methods gets called on ProcessManager (1). Well, in this case yes, any pre-created stub object is OK. I typically create them with `instance_double('ProcessManager', list: :of, methods: :here)`, then probably `stub_const` or stub `new`, and drop to some shared contexts. But completely custom stubs probably are also OK for this requirements. What I am thinking on the topic, though, that we need cleaner distinction between (1) and (2). In fact, clear understanding of "I need to stub this or that _subsystems_" probably may lead to cleaner code design, but people tend to mix "stub this a bit, and that a bit, and check those methods are really called" and so force.
Check out the odin project its a free online course that takes you through full stack development using rails on the backend
It's same idea, except one in ActiveSupport is actually maintained. [Even Python has it in its stdlib](https://docs.python.org/2/library/datetime.html#timedelta-objects). (exact details might be a bit tricky, but then that's one more reason to put it into stdlib instead of having people hack their own solution)
this looks dead to me - 2009/2010? anybody has experience with ruby in the SAP world?
&gt; I'd avoid it because it's large I really don't understand this concern. This has a minimal impact on your codebase besides maybe startup time which is likely negligible.
Magic is NOT wizardry. For example, David Copperfield making an object "disappear" is different from Gandalf literally making an object disappear. Lets forgo the supernatural analogy when it comes to coding.
CodeAcademy, for sure. Also, SoloLearn has a good mobile app for learning basic syntax while you’re pumping gas or waiting in line. After you complete those, find a project that interests you (like scraping data from a webpage) and find a tutorial for it by Googling. If you stick to projects and tutorials, you’ll learn faster and it will stick better. Most important: don’t quit when you feel like a moron. No one would be programming today if they had. Just take a break (or better, switch projects for a bit).
Says here it was killed off: https://blogs.sap.com/2010/12/18/blue-ruby-now-available-on-code-exchange/
I is, that's why I just posted it as a history gem. It's kind of amazing that it even existed - a Ruby meant for directly running on the SAPs ABAB runtime.
Any Ruby book since 1.9 will carry itself just fine. Few changes to Ruby as a whole have been made since 1.9. List is missing some of the greats, though. I'd stick to the sidebar and POODR.
I really must see if I can use `ensure` more often. As keywords go, it's probably the rarest in code that I write, after `__ENCODING__`.
expires_in: 1.minute vs expires_in: Duration.new(minutes: 1) There's a reason why we all love Ruby and it ain't verbosity.
&gt; What ruby core team needs to do is to go through all of ActiveSupport and aggressively merge into standard library everything that addresses real issues wowwowwow! that's quite the statement. So I guess you don't belong to the "ruby is a bloated language" camp, in which most campers claim the huge API surface in primitive types is a source of maintenance burden, lost opportunities to optimize opcodes, and overall confusion about the "one true way" of getting shit done. `Hash#compact/Hash#compact!` is at the very least as needless as its Array counterpart. Why is there a method for something I can express in one line of ruby? Both `array.{delete_if|reject|reject!}(&amp;:nil)` accomplish the same (the fact that I get 3 different ways of doing this should tell you something). Gzip is equally needless, as gzip compression is already part of the standard library, and AS just "sugars" it. The Duration comment misses the point. It's not that it needs to/could be in stdlib; it's that dialects like `5.minutes` bloat an already bloated (137 methods without it in ruby 2.4) API for the sake of "reading like english". Obviously, I wouldn't claim that AS is completely useless. Some of the stuff there is. Some of the stuff is actually decently implemented, it just breaks encapsulation by being monkey-patched in the global namespace (because rails refuses to use them as Refinements); some other stuff is a very "hack-y" workaround for a real business need, like deep_dup, which tries to work around the fact that **we really need a proper #dup implementation in ruby!**, but all this gets lost in the semantics because AS lives and dies by playing the kitchen sink approach. 
I did event-driven Rails 7 years ago. Spoiler: it's a terrible idea. http://www.mikeperham.com/2010/04/03/introducing-phat-an-asynchronous-rails-app/
... and then you end up with 1000+ methods in global namespace like some php.
&gt; So I guess you don't belong to the "ruby is a bloated language" camp Anybody who says that is wrong. There's a reason standard libraries for every new language are getting bigger and bigger. There's a bit of nonsense like pointless `map`/`collect` duplication etc., and other leftovers from early days, but rich APIs allow far more expressive code. For comparison try `create-react-app`, then count how many implementations of `Array#uniq` (each working in slightly different ways, and likely broken in some edge cases) got installed. Last time I checked I think it was 7. &gt; Why is there a method for something I can express in one line of ruby? This argument is just as bad as "why do we need for-each loops, when for(var x=0;x&lt;max;x++) can be expressed in one line" people coding in lesser languages use. Then their language gets for-each loops, and they never look back. &gt; Hash#compact/Hash#compact! is at the very least as needless as its Array counterpart. It's extremely common idiom and building block for other idioms, and deserves a method for expressiveness. &gt; it's that dialects like `5.minutes` Not a huge fan of this DSL, but durations are very important thing, even python has them and it's not exactly a big standard library kind of language by modern standards. &gt; Obviously, I wouldn't claim that AS is completely useless. AS was the best thing to happen to ruby. I mean, just `Symbol#to_proc` alone. It serves as widely used testing ground for new ruby features. As with all testing, not everything it tries works perfectly (like the whole `HashWithIndifferentAccess` nonsense), but that's a given. &gt; because rails refuses to use them as Refinements Refinements were a stupid idea, with no realistic use case, and they should have never been merged in. Nobody uses them, and for a good reason. They need to be taken out of ruby and shot. &gt; we really need a proper #dup implementation in ruby! For sure, but what is a "proper" implementation? If only there was a testing ground for that... Oh wait. If you're interested, I wrote about this stuff [here](http://t-a-w.blogspot.com/2016/09/the-next-ruby.html), and [here](http://t-a-w.blogspot.com/2017/06/11-small-improvements-for-ruby.html).
Great first effort... I saw a lot of teachable things in this code so I [forked it and refactored it](https://github.com/lankford/simple_budget)... I did it in much of a step by step way and may make a video of the process... Seems like you are probably a sysadmin or something... keep on coding... it gets easier.. and more useful as you go... good job.
I highly recommend ruby kickstart. It’s a series of exercise which will teach you both ruby and core aspects of programming at the same time. https://github.com/JoshCheek/ruby-kickstart
Does anyone use Hanami in production? What was your experience? Was it a new app or was it being rewritten? 
Keeping the double with the actual class isn't a bad idea. It might prompt you to update the double when you modify the class.
 req = Rack::Request.new(env) req.post? req.params["data"]
where did you get "env"? route do |r| rt.on "something" do r.post do # access params in "post".... how? end end end
`env` is populated by rack, which Roda (and _nearly_ every other ruby framework) is built upon. i haven't used roda before, but i'm guessing that route yields a request object, so you should just be able to access the params through that? i also don't think you have rt defined, so, ``` route do |r| r.on "something" do r.post do r.params['data'] end end end ```
not directly related, but this seems to be a fairly good example of using Roda in the real world: https://github.com/janko-m/shrine/tree/master/demo
you may find better luck searching stackoverflow.
Yup From footer: &gt; Made by people behind Semaphore
no have you tried that? it'll return only "data" from a URL
[removed]
what does r.params return?
I don't use Roda, so I can't be certain if it works, but I recommend trying a logger instead of puts. ``` require 'logger' logger = Logger.new($stdout) logger.debug("env is: " + ENV["RACK_ENV"]) ```
{}
can you provide an example that reproduces the problem?
&gt; For comparison try create-react-app, then count how many implementations of Array#uniq (each working in slightly different ways, and likely broken in some edge cases) got installed. Last time I checked I think it was 7. That's a bad comparison. JS has no stdlib, that's the problem. Ruby OTOH is bloated, and AS adds more bloat.
See [TimeMath2](https://github.com/zverok/time_math2), which I've been using for a while now, and it's lovely. No monkey-patches, cool abstraction, composable calculations (and composition beats method chaining, always).
It also made people thousands of rubyists think that monkey-patching is great, and then we end up with huge projects with completely unpredictible behaviors, as people solve their problems by adding more monkey-patches. My observation for many years now, has been that most rubyists are simple unable to come up with their own abstractions. A monkey-patch is not an abstraction, it's a shortcut to get shit done faster. For instance, a bunch of integer monkey-patches that add methods related to time calculations is not an abstraction, it's a bunch of "helper methods" added to a core class to make things look cute. As a community, we've lost more than we gained because of AS. Not to mention it's an aggressive library which doesn't give a shit about the rest of the run-time. See `Object` monkey-patches for a good example. I've lost count on the number of bug reports I've had because somebody had a problem due to `Object#try`, or `Class#include`. To make things worse people EXPECT that library maintainers will be addressing problems CAUSED BY AS, just because "Rails is popular".
You can access POST params via `Rack::Request#POST`: route do |r| r.post "something" do request.POST["param"] end end
I think you are talking about low-level technical events (as in reactor pattern, event machine, libev, etc). The webinar was about application level events such as: UserRegistered, BookSold, ProductShipped. I don't see how that's relevant to phat.
https://www.reddit.com/r/ruby/comments/77sjzr/factorygirl_has_been_renamed_to_factorybot/
Missed that... Thanks!
&gt; Those who were bothered by the name shared a concern that female-gendered names in male-dominated spaces can be problematic. I have a big problem with this line. Most women have female-gendered names. Is our presence problematic in male-dominated spaces? Really???
I have a Roda-based API which takes both JSON and `form-data`. Practically, we fetch JSON from `r.body` and Form from `r.params`. It works pretty decently. What seems odd to me is that you're talking about query parameters (if that's what you mean by "data from a URL") in the context of POST requests. You should probably consider sending *all* your data in the request body, leaving query parameters empty.
I don't send them in a query string
no
where did you get this?
it doesn't work
ok good talk
it's an ajax post request
At last, something to work with. So I take it you're using a web-browser to make those requests. Make sure you are actually sending any data. Modern browsers empower you with a tool to analyze outgoing XHR requests, including POST data. You should probably use it to make sure it's not Roda's problem. 
If you run `bundle exec rackup`, the `$RACK_ENV` the Gemfile will be evaluated before any Ruby code is run, and this includes setting the `$RACK_ENV`. I think it's better to specify both production and development gems in the Gemfile, but then *require* them depending on `ENV["RACK_ENV"]`. You can even use Bundler groups to separate development gems, though I think this information is only actually used when running `Bundler.require`: # Gemfile source "https://rubygems.org" gem "gem1" group :development do gem "gem2" end
What do you mean it doesn't work? It does work: require "roda" class App &lt; Roda route do |r| r.post "something" do request.POST["key"] end end end request = Rack::MockRequest.new(App) response = request.post("/something?key=foo", params: {key: "bar"}) response.body # =&gt; "bar" If you want people to help you, you have to cooperate and give more than 5%.
The `request` object obviously responds to `#POST`, so what's the point of your question?
Startup time in Ruby is very non-neglible, as `require` is fairly slow. That's the reason why we have Spring and Bootsnap, because requiring all of that code is slow, that's really the main thing that's making Rails boot time slow. For me `require "active_support/all"` takes about 0.35s, which is a lot, because this quickly adds up when you have other gems that load bunch of code as well. I don't use Rails, so I cannot using something like Spring even if I wanted to. But I don't want to and shouldn't need to, because gems can be lightweight if they choose to.
One of the unfortunate side effects of loading ActiveSupport that I experienced was overriding the original `#to_json` implementation given by the `JSON` standard library. When I was testing Shrine, I was surprised why `#to_json` is suddenly broken when I was testing ActiveRecord, and then I realized that ActiveSupport broke it. It took me some time to figure out how to repair that. Not cool.
[database.yml](https://devcenter.heroku.com/articles/concurrency-and-database-connections#connection-pool) 
I feel like I could be leaking connections. I have set the pool to 10 and the concurrency is 1. And right now, there's virtually 0 users on the websites, only the sidekiq jobs are running.
do a `ps aux | grep postgres` if you're running postgres and check it out, kill anything that's standing in the way. `SELECT * FROM pg_stat_activity;` too.
correct. I've forgotten to mention, I have an ajax post request. 
it's not about rack_env, it's also the fact that the 1st "puts" didn't execute.
thanks!
To prove that it indeed reads the POST parameters and not the GET parameters.
you're probably not including it anywhere. all because you have ruby code doesn't mean a Gemfile will automatically manage your dependencies. http://bundler.io/v1.15/guides/bundler_setup.html
Are you the same janko-m who made vim-test? If so, thank you - it's a great plugin that I use daily!
post parameters -- are post parameters, you're reading get ones. 
I said: ** puts "env is: " + ENV["RACK_ENV"]**
well, all gems in it work in my app
look at my answer. roda doesn't automatically load your gemfile. like in your other threads, you provide no context. i can imagine you're sitting there laughing or pulling your hair out — maybe you're trolling us. i don't know. we don't know how you're trying to load your gemfile. in fact i can guarantee that you're not even loading it because you think it's automatically loaded. frankly, i'm surprised i'm still — or anyone is — replying. it's an issue between you and your monitor, not of any library or ruby core. 
remove all require statements and tell me if it does. put up an example on github. on pastebin. upload it to rapidshare. something. we're shooting blind. if whatever you're working on is so top-secret that you can't share with us, great, reproduce it in another example. if you can't do that, you probably shouldn't be even typing on a keyboard in the first place, frankly.
 iPashkov:code ip$ bundle wow Fetching gem metadata from https://rubygems.org/.............. Fetching version metadata from https://rubygems.org/. Resolving dependencies... Using rack 2.0.3 Using bundler 1.13.6 Bundle complete! 1 Gemfile dependency, 2 gems now installed. Use `bundle show [gemname]` to see where a bundled gem is installed. iPashkov:code ip$ ruby app.rb wow hello iPashkov:code ip$ https://gist.github.com/anonymous/2587b27ac4eab8c03c87a77f8c253d6a 
Even greater — the same guy who made Shrine. Awesome tools, I tell ya
&gt; you're reading get ones. He's not reading GET parameters. You should probably read his code just a little bit more thoroughly 
I need to read ones that sent via post ajax request in body
You can set the pool to 20 or 100, it's the easiest param to tweak. Concurrency is how many threads run per process, but you could still be running multiple sidekiq processes. Also keep in mind a single web request could use several DB connections from the pool.
 r.body.rewind params=MultiJson.load(r.body.read) There is a big difference between POST parameters like in a form and sending json in a body. You are asking the wrong question.
Cool. Thanks. 
&gt; Anybody who says that is wrong. It's not that they're wrong, they have a different opinion. It's the "ruby is bloated" camp, and you don't belong to it. And I guess that's fine. Perfection should lie somewhere in the middle, as common saying goes. But then again, you say "rich", I say "bloated", where's the middle in that? :) &gt; This argument is just as bad as "why do we need for-each loops... This is where we have to have something in the middle for. My particular criticism against `#compact`, and `#uniq` for that matter, is that they could be derived from base enumerable methods (someone suggested that these could be `#map`, `#flat_map`, `#each`, `#filter`, `#reduce`). They were not because probably someone suggested to implement these "common" operations in C "for speed" for arrays, but these create future problems, because now that they are implemented in C, they can't generated bytecode that can be opt- and deoptimized (future of ruby will be JIT-ed), and someone has to maintain them; they bloat the core API, because `Array` now has 2 methods more (177 methods as of 2.4); and they generated confusion, because a) they feel "Enumerable", so people expect them to be defined in other Enumerators (like Hash, which you are vouching for), and b) their naming is confusing (`uniq` instead of `unique`; what does `compact` mean exactly?). Another recent example of AS "bloating" ruby core is `Enumerable#sum`. The only argument that can be made is "for speed". Otherwise, I can just keep doing `array.reduce(0, :+)`. Where do you draw the line? &gt; Not a huge fan of this DSL, but durations are very important thing, Agreed, and I didn't argue against it (maybe not in stdlib, but somewhere def.), I just wish that the `#minutes` doesn't pollute the Integer API (137 methods as of 2.4) even more. &gt; AS was the best thing to happen to ruby. I mean, just Symbol#to_proc alone. I did say in the end that I don't think that AS is completely useless. `Symbol#to_proc` was a good proposal. But with the good, you have to live with the bad. And the bad also generates assumptions that lead to proposals that might not bring great benefit and "bloat" ruby a bit more (see `Enumerable#sum`). The `HashWithIndifferentAccess` is particularly interesting, as you say it's nonsense. Lots of people feel differently, apparently. So different that it's in the genesis of one of the latest proto-proposals for ruby, which is "remove Symbols, or make Symbol a subset of String". Good luck debating what a Symbol was intended to be in the first place. And thank AS in the process :) &gt; Refinements were a stupid idea, with no realistic use case, and they should have never been merged in. Nobody uses them, I use them :) and I beg to differ. Refinements use-case was clear: scope monkey-patching to a namespace of a library, and avoid spreading these to user code. They were designed specifically for AS, which monkey-patches ruby first and foremost for rails internal use, but they forgot to ask AS maintainers if they really wanted to hide the scope of their changes (they didn't, as people came to expect AS monkey-patches, and backwards-incompatibility can hurt new rails adoptions). They're a bit limited however, and they don't cover the whole scope of monkey-patches seen around, and that's why they were not mass-adopted. &gt; For sure, but what is a "proper" implementation? If only there was a testing ground for that... Oh wait. A proper `Object#dup` ;) . And the testing ground isn't rails or AS necessarily, or its scope-limited (for rails purposes) `#deep_dup` implementation, but the whole of the gems space! Quick googling leads me to [this](https://github.com/gmodarelli/ruby-deepclone), [this](https://github.com/moiristo/deep_cloneable) or [this](https://github.com/sergeygaychuk/deep_clone). So to sum it up, I do agree there should be a testing ground for changes, I just don't think that the implicit nature of AS changes is the best way to "communicate" these changes. This implicitness causes more damage than benefit, even when you do acknowledge the benefit, because it'll influence the stability of "user-code". This implicitness is also a byproduct of ruby's global namespace "require", but that would be an even more pointless discussion to argue whose fault is it really. And I think I read your posts back then when you published them, just didn't comment, because my opinion is basically "some make sense, some don't... in my opinion". Just like you laud AS as "the best thing in ruby" but completely shoot Refinements. Which, as described above, I don't agree with at all. :) 
working why rewind? without it it works too 
Thanks, oops!
I guess I don't really get your concern. Why does that matter? The first approach reads really easily and is "human-friendly". Isn't that a concern too?
why would roda be running your gemfile? the gemfile is only run by bundle.
I think you *are* leaking connections. In a multithreaded environment, every time you perform a database action, Active Record checks out a connection from the pool if that hasn't already been done for that corresponding thread. But the caveat is that you have to put the connection back into the pool when you're done. In Rails web requests this is automatically done for you at the end of a request; outside Rails you have to do it yourself. You are calling `scheduler.every`. Maybe you're using Rufus? Not sure how Rufus works internally but if they spawn a new thread every time the timer fires then you'll exhaust your connection pool eventually. Read http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html Turn it into a habit to write code like this: begin ...perform your database actions here... ensure ActiveRecord::Base.clear_active_connections! end
Yep. And wherever that class goes, the double goes along with it. This is great when developing libraries. When the classes offered by the library come bundled with test doubles, it improves the usability of the whole library by leaps and bounds.
Depends what you mean by "production". We (I) use it for few small services at work, but it's nothing customer-facing or requiring heavy load. New apps. It was... bit painful tbh. Keep hitting things that are not working as expected/are not implemented yet.
I suppose this would be interesting to me if it wasn't for the price...
Love the new turbolinks. Literally can't find a reason to not use it anymore. Throw your brand color in the progress loading bar. Tadaa. Now you fancy.
Cheaper than many competitors and provides commercial experience. Basically you will get a chance to work alongside senior developers, contribute code and follow industry standards through working on a market leading ecomm platform. Crucial experience for your career.
So fancy! Yeah, it works really well, and the simplified API is great. I'm also working on a preloading plugin that can prefetch tagged links on hover. I might do a post about that soon.
I can't help but feel if you are getting offended by the name factory_girl, you are much too easily offended, and the rest of the world shouldn't have to bend over backwards to protect you from feeling uncomfortable. This update will result in real changes being made to literally thousands of projects worldwide. Rather than doing this, why don't the easily offended out there learn to not be so pathetic?
https://github.com/ippa/chingu Appears to have this functionality.
Please do!
The graphics gem has an example of drawing a circle right in the readme... What do you mean by "out of the box"?
Learn them both. I have used ruby professionally and python professionally. I'd still rather pick ruby if I'm making a web service or api. And python if doing in-memory data analysis or visualization. And scala if I'm dealing with large datasets that need to be distributed. And sometimes golang if I really need concurrency via fan-out/fan-in type architectures. Etc. Not everything is a nail that needs a hammer.
If I can get get the cache to behave with large N of links so that it doesn't blow out history and break the back button, I will!
Congrats!
It broke everything JS in my app last year, not early 2010s, so yeah, my first thing to do in a Rails app is to remove Turbolinks.
Alternatively, I think you can use `with_connection`. http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/ConnectionPool.html#method-i-with_connection
In the past I've seen watir hold on to a reference that's invalid, but it usually raises a stale object reference. I have a monkey patch for Watir::Element that provides one way around it: module Watir class Element def relocate @element = locate self end end end It can be injected between the element and the actual call in your code. Instead of "element.click" you'd use "element.relocate.click". It resets the cached copy of the element and forces Watir to properly find it again. This probably isn't your problem but it's worth a shot.
multiple processes do _not_ share a connection pool of course, they will each get your pool number of connections. 
I wrote a ginormous post about this once, if you're the kind of person who likes ginormous posts. The fundamentals are still the same in Rails 5 -- some slight additional complexity and/or features in Rails 5.1, but the fundamentals still mostly there. https://bibwild.wordpress.com/2014/07/17/activerecord-concurrency-in-rails4-avoid-leaked-connections/
With Rails 5, any Ruby code which touches Rails app code should wrap itself in the app's reloader, which handles all resource management, including connections. https://github.com/mperham/sidekiq/blob/master/lib/sidekiq/rails.rb#L41
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mperham/sidekiq/.../**rails.rb#L41** (master → ee3490d)](https://github.com/mperham/sidekiq/blob/ee3490d12f6746dbb4f937bebc01c7673d7ca713/lib/sidekiq/rails.rb#L41) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
This seems to have been the issue. Thanks a lot, I'll look into it along with the links posted by others.
So basically I can wrap all of my Rufus cronjobs inside something like this? Rails.application.reloader.wrap do # cronjobs end
Python and R own that space; if that’s what you’re going to be doing, the earlier you jump ship the happier you’ll be.
I have so many reasons not to use Turbolinks, but this bug is the greatest of them: https://github.com/turbolinks/turbolinks/issues/251 My users constantly ran into that. I put in special routes and workarounds, but they can’t totally fix what is basically an artefact of the brain damaged idea that reimplementing major parts of what browsers do was in any way a good idea. Most especially caching and basic navigation - things that web browsers do *very well indeed* already. The innumerable artefacts (over 100 open issues for really not a lot of code) and all the harnesses and shins you have to throw in as soon as you use a library or third-party code that isn’t Turbolinks aware (from Stripe to Vue to helpdesk buttons) are further symptoms of the underlying arrogance of “we know better than the browser”. Ugh. Turbolinks is a nasty architectural wart. Turn it off. Just turn the damn thing off and put proper cache-control headers on your assets instead and let the browser handle being fast. 
In case some other Middleware read it first and didn't rewind.
Then what space own Ruby?
Web
That's definitely not what I'm saying. Ideally Rufus handles all this for you, just like you don't need to wrap all your Sidekiq workers in the same.
All your data R belong to Python?
If you have a small team, want massive speed optimization out of the box, and aren't doing insane overly architected stuff it will likely be a very helpful tool with no major issues. Pretty much every third-party tool i've integrated into a rails app has been workable using the turbolinks:loaded api. However I understand your concern. If you have a larger engineering team who can focus on caching, javascript frameworks, or separate mobile apps then Turbolinks might not be the answer to increased optimization out of the box.. Heres a great talk from one of the creators that dives into the dogma behind why it was created / refactored: https://www.youtube.com/watch?v=SWEts0rlezA. 
I'm late to the party, and I understand the context and reason of the change, and it's also not my gem, but I gotta wonder, was it really necessary to rename a *~9 years old* gem, which is used by many, many developers, knowing that this would eventually lead to possibly hundreds of work-hours wasted collectively to change all references in all projects? The main issues I see with this change are: 1. Apart from [#921](https://github.com/thoughtbot/factory_bot/issues/921), there was no open discussion from the whole community, it seemed mostly an unilateral or internal decision (especially considering that the most upvoted comments on that issue were against the change). If such a big (IMO) change was needed, why not openly ask the community about it? 2. Fucking SemVer. [That](https://github.com/thoughtbot/factory_bot/issues/1055) was a major clusterfuck IMO.
I think you should use remote:true, and so the refresh will refresh the page and not submitting again. form_with is now here to replace form_tag and form_for. And remote: true is the new default value for form_with. Embrace JavaScript !
Thanks - great advice
Fair point - I was concerned that I might trip myself up if I combine at this early stage but make sense to use different languages for different goals. Thanks for the advice!
I'll give you that Turbolinks isn't perfect, and my article even says there are valid criticism and it isn't for every app. I'm specifically only advising using it for new apps with slim UIs that don't use things like Stripe, and want really quick page transitions without writing an SPA. If you can get a sub 100ms page transition with caching and alone, more power to you, I can't seem to manage that. I personally use it on a mid sized app in HealthCare, so no in app payment processing, no tracking scripts, and caching options are limited. Turbolinks does the job for me, and I rarely have issues. But, if you don't like it, that's valid. 
Submitting again after asking the user for permission *is the correct behaviour* for a web browser. Disabling that is just plain hostile. 
I didn't think of that, but of course.
I'll use it for my next hobby project. Have you tried it with Roda yet? They recently removed the websocket api, so if it's easy to use with Iodine, that would be perfect.
This looks very interesting. I'll definitely give it a go, but that may still mean a while before I would have anything to report. Meanwhile out = [404, {"Content-Length" =&gt; "10".freeze}.freeze, ["Not Found.".freeze].freeze].freeze Yikes. To be clear, I'm knocking the code pattern that lets this happen and not the project, but surely there should be a less totally horrible way of doing this.
I'm actually very curious about what you said. That's why I commented a few days ago. Would you mind pming me a tl;dr?
Hi, I've deployed a Hanami app on 0.7.0 (new app, not rewritten) almost a year ago and it's running in production since February this year. I found Hanami easy to work with even though there were fewer built-in features at the time as compared to other frameworks. I'm currently upgrading to 1.0.0. regards, seba
There is a better way! In the past I’ve used the [ice_nine gem](https://github.com/dkubb/ice_nine/blob/master/README.md) to deep freeze hashes. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [dkubb/ice_nine/.../**README.md** (master → 2380ec3)](https://github.com/dkubb/ice_nine/blob/2380ec33ef9c3302d0bdf6fb076a5fa6ec9bdc17/README.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply doyjoin.)^.
[removed]
We are using it on production at freework.com. I can recommend it for any project which should is not just a prototype and should run on production for more than a few months. We are very happy with it. Of course you have to implement some stuff on your own but our architecture is very clean and easily extendable. I can give more details for anyone interested. (Clean Architecture with hanami, ...)
&gt; surely there should be a less totally horrible way of doing this. So true 😂😂😂 My example code and applications is littered with testing and debugging code that I used. This one is when I tested for deeply frozen response objects. But I guess the joke is on me for doing a copy&amp;paste to the README without even looking.
I haven't tried it with [Roda](http://roda.jeremyevans.net/) yet, though Roda is high on my list of gems to explore. It sounds amazing and I heard many good things about it - not to mention that it was authored by Jeremy Evans, who also wrote the amazing Sequel gem. I authored [Plezi](http://www.plezi.io) to help me test iodine's Websocket API and for a while things moved from framework to server or the other way and different approaches were tested out. But I do think Roda is superior to Plezi in it's routing design. I might end up preferring Roda over Plezi, except that Plezi is less verbose and offers the ease of using "auto-dispatch" with Websockets, which made testing iodine really easy.
where's poignant guide? 
&gt; It also made thousands of rubyists think that monkey-patching is great Monkey patching _is_ great, it can also be abused. Every time I hit a problem with an external Java lib and find that I can't adapted it without forking and making major change because someone decided the thing I need to fix is `final` or doesn't have a seam were I can inject the change I praise monkey patching. &gt; A monkey-patch is not an abstraction, it's a shortcut to get shit done faster. Why is this a bad thing? Abstractions are not universally good, there is delicate balancing act between abstractions reducing complexity and abstractions increasing complexity. &gt; For instance, a bunch of integer monkey-patches that add methods related to time calculations is not an abstraction, it's a bunch of "helper methods" added to a core class to make things look cute. Again, why is this bad? I love `10.hours.ago` and `10.seconds`. Thankfully many language have picked this up, e.g. Scala with `10 seconds` or Go with `10 * time.Second`. &gt; As a community, we've lost more than we gained because of AS. Completely disagree, many stdlib methods have started in AS and many more should be moved over. &gt; Not to mention it's an aggressive library which doesn't give a shit about the rest of the run-time. I don't know what you mean by 'aggressive' here, you are free to include only the pieces and parts of ActiveSupport you want to use. Don't like a particular core extension? Don't load it. &gt; `Object#try` Which lead to adding the safe navigation operator to Ruby itself. &gt; `Class#include` Isn't a method, I assume you mean `Class.include` which I take to be referring to AS Concerns? I don't see the problem with Concerns, it's just a helper to avoid writing a bunch of boilerplate when defining mixins. &gt; To make things worse people EXPECT that library maintainers will be addressing problems CAUSED BY AS, just because "Rails is popular". Ignoring support for the most popular framework in the language is certainly your option, but it shouldn't be at all surprising that people want to use your gem in a Rails stack.
I hadn't known about this. Some more info with some other strategies: https://makandracards.com/makandra/42885-nested-activerecord-transaction-pitfalls
yep. There's nothing really about ruby that makes it unsuitable for that stuff, but Python is where that community lives. 
Is there any reason it wouldn't work with Rails?
From the readme, question: &gt; The slower your application code, the more threads you will need to keep the server running smoothly. Since this is running on MRI, this really only applies if your 'slow' code is slow because of IO, yes? If your slow code is CPU-heavy, more threads won't really help much. Or is there something fancy iodine is doing with it's own evented code that somehow have advantages here too, that I'm not conceiving of?
&gt; Is there any reason it wouldn't work with Rails? Not that I know. My basic Rails test applications work fine. However, ActiveRecord won't utilize iodine's native Websocket support. I would love it if you tested it using Rails too. I don't use Rails all that much - although it's great, I mostly approach web apps as lightweight services for AJAX/Websocket clients and use client side scripting as much as I can. 
Hello, I've updated the Slide Show (S9) command line tool (and library/gem) that lets you write your talks / slides / presentations in plain text w/ markdown conventions. Note: You can use any of the (Jekyll-compatible) theme packs such as reveal.js, bespoke.js, s6blank, etc. As an example, see the [Blockchain! Blockchain! Blockchain!](http://slideshow-s9.github.io/demos/blockchain.html) talk [(source in markdown)](https://github.com/geraldb/talks/blob/master/blockchain.md). Happy publishing &amp; talking. Cheers.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [geraldb/talks/.../**blockchain.md** (master → c2592e7)](https://github.com/geraldb/talks/blob/c2592e72e9af840cc23a753891caab03609ec311/blockchain.md) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply doz7s3a.)^.
&gt; this really only applies if your 'slow' code is slow because of IO, yes? Great question. Since Rack uses the application's return value for the response, a thread that is executing the Ruby application code cannot handle other events concurrently. However, IO blocking uses less CPU and allows context switching to occur, while CPU intensive tasks keep the blocking thread active. In a single threaded environment, there is no difference in performance, since the thread is blocking the whole application (no matter if it's waiting on IO or doing CPU heavy work, the application can't answer other requests until the thread returns to the iodine pool). In a multi-threaded design, IO work will block the thread but free the CPU (similar to `sleep`), meaning that other threads will be able to perform work during this time and improving performance. Let's observe the the following app: require 'iodine' # a global string will minimize temporary objects PATH_INFO = "PATH_INFO".freeze Iodine::Rack.app = proc do |env| if(env[PATH_INFO] == "/cpu") # run CPU for one second target = Time.now + 1; a = 0 a = a + 1 while Time.now &lt; target else sleep(1) unless env[PATH_INFO] == "/fast" end [200, {"Content-Length": (12 + env[PATH_INFO].length).to_s}, "Hello from: #{env[PATH_INFO]}"] end Iodine.threads = 1 Iodine.start We can test this app with: wrk -c24 -d5 -t8 http://localhost:3000/ # or wrk -c24 -d5 -t8 http://localhost:3000/cpu This app shows that in single thread mode, blocking IO and CPU heavy code will perform the same. (I got 0.79 Requests/sec on my first two tests) However, changing the `Iodine.threads` value will slowly expose a big difference in performance between the two. With `Iodine.threads = 12` I get 8.09 Requests/sec for the blocking IO emulation and 3.57 Requests/sec for the CPU load variation. This is still very low performance. Considering that the `/fast` URL (no sleep or CPU load) gave me 72,471 Requests/sec. The reason is that once all of the thread pool is engaged (all 12 threads are locked inside the Ruby application), the iodine server is left without any threads to handle network events and we're back in "square one". The more threads we add, the more context switches we can perform during blocking IO. However, during CPU load the context switching might add some responsiveness but it will also hinder overall performance (context switches cost CPU cycles and memory cache hits). Each application has a balance and this balance is often unique to the application. Iodine's "auto" mode goes by the rule of thumb that slightly prefers responsiveness over performance (processes = number of cores; thread-per-process = coresX2). If your code is faster, than a better approach might be processes = number of cores and thread-per-process = 1... it really depends on the application and what you're doing. &gt; is there something fancy iodine is doing with it's own evented code...? Yap... sort of. Iodine moves a lot of the IO management, parsing and pub/sub logic outside of the GIL (global instruction lock), allowing for more concurrency than you would get when running these tasks in the Ruby MRI. However, once the threads enter the application, they are just normal Ruby threads that behave the same as any other Ruby thread. I can't do anything about that part.
This is amazing. I have never written a gem but am willing to write something related to ML! Will subscribe.
Are you going to be doing this on random websites that you don't control? If so, nothing in Ruby is safe enough to do that. I would recommend you use a proper JavaScript parser and perform this transformation on the JavaScript AST.
Kind of. Today, in the right-now, the context of the script is known, and selectively executed. For example, when I was actually reverse engineering this code, I was going back and forth between pry, chrome dev tools (as a js env), and various de-obfuscators -- I very much understood what I was dropping in. But of course, it's easy to start to feel confident and comfortable -- and that's when you get got! Regarding the "nothing is safe to do that" -- I could see a possible situation related to writing a parser/scanner to break down the array and build my own, but it was soooo much easier to just `eval` it. But you're probably right. I don't know much enough about js to want to explore it too much outside of Ruby. My main goal after I wrapped up last night was to Ruby some stuff. Thanks for providing some terms and ideas to look into if I did want to legitimize this process.
You could step outside ruby a bit and have the whole thing run inside a sandboxed container. Then security etc becomes less worrisome. But at that point you might as well use a proper js parser instead of doing this in ruby as the other poster said.
I've used it, but not in ruby. Protobuf is useful when you've got a bunch of microservices, maybe in different languages, that want to talk to each other, because you can define the data structures once.
&gt; This app shows that in single thread mode, blocking IO and CPU heavy code will perform the same. &gt; (I got 0.79 Requests/sec on my first two tests) &gt; However, changing the Iodine.threads value will slowly expose a big difference in performance between the two. &gt; With Iodine.threads = 12 I get 8.09 Requests/sec for the blocking IO emulation and 3.57 Requests/sec for the CPU load variation. Interesting, i would have expected the cpu load variation to perform about the same with 12 threads as with 1. Since if the thing is really taking CPU the entire time, other threads won't be able to do much either. But it performs about 4x better. I wonder what the explanation is, if it is just a quirk of the testing simulation, or what. 
The ActiveRecord part doesn't actually do anything with WebSockets ever, but the newish Rails 5+ ActionCable component does. (Not sure if there might be older Action But I hear ya, it may or probably won't work with iodine, and/or take maximum advantage of iodine perfomrance. It would probably be interesting and useful to investigate further and see if it could be made to do so. I don't actually have much experience with or current uses of WebSockets myself.
Oops, yeah, I meant ActiveCable. It should work, since Iodine supports the Highjack API used by ActionCable... but that essentially takes the control away from iodine, so many of the advantages of using iodine are negated. 
&gt; Since if the thing is really taking CPU the entire time, other threads won't be able to do much either. But it performs about 4x better. I wonder what the explanation is, if it is just a quirk of the testing simulation, or what. Putting aside a number of (possibly) negligible factors (such as multi-core CPU and iodine running server tasks outside of the GIL), I think the reason is that the test is biased. ... Sorry... I just noticed it... The work takes 1 second to perform, but that means that the CPU task is time dependent instead of work dependent. This means that 4 threads running a one second task perform less work (use less CPU cycles) than 1 thread performing 4 one second tasks. &gt; I actually did similar simulations (IO-heavy vs CPU-heavy) with several different ruby app servers about 4 years ago... I just finished reading through the link you sent - it makes me feel slightly stupid trying to explain things you obviously know very well. By the way, iodine supports multi-threaded workers (the Passanger/Puma "hybrid" model), i.e.: Iodine.processes = 8 This will allow CPU bound tasks to run concurrently on multi-core CPU machines.
`default: nil` ?
but in the documenation it says "null", not "nil"
I would check the docs again, because "null" isn't defined in Ruby. "null: false" makes sense because null is a key name assigned the value "false" "default: null" doesn't make sense because null in this context should be a variable or a method result to assign to the key "default" 
but why do you assume that Sequal doesn't provide the variable "null"?
you really shouldn't be initializing the connection (or requiring something) inside the route. it should be done on boot. i'm guessing DB is alrady an instance of _something_. can you do a `puts DB.class` and see what it says?
&gt; but in the documenation it says "null", not "nil" no it doesn't
as I've said: why would I? 
there's no harm in connecting an instance during initialisation, even if you use it sparingly. in fact, it's _better_ to do so for something like this so you don't have to recreate the object many times. having said, it's difficult to see where this problem is without further context. could you kindly provide more of your code, or replicate this issue in an individual repo so people can poke around at it?
I don't see how it is better to do extra work. re-read my question.
👍 for IceNine as well. It's rightly getting used all over in the last year or so; an elegant solution to a very real problem.
The other poster is doing an admirable job of trying to help you. The code you posted isn't core Ruby, so it's meaningless without more context.
you're right, **why do more work**? _it's more work to do a `new` every time._ run this example to see what i mean: https://repl.it/NWbV/0 what's more work? to `sleep(10)` once on boot? or to `sleep(10)` every time you hit that route?
This place isn't stackoverflow. 
[99% it's this same guy](https://www.reddit.com/user/jimaru003)
&gt; you're right, why do more work? it's more work to do a new every time. &gt; I've said: it's used only in a single place!
This place isn't bing.com 
[and this guy](https://www.reddit.com/r/ruby/comments/73xqd6/how_can_i_render_slim_templates_in_roda/)
try not making it a constant and see what happens. i'm curious.
that's right. so what?
&gt; you only need to run sequel#new once if you do it on boot. but if a user doesn't come to a route where I connect to the db, the "sequel#new" will be called for nothing
ah, on boot......... when a new user comes, what happens? a new MyApp being created? Or is there only a single copy of MyApp running always?
This place isn't youtube.com 
this place isn't foxnews.com
Try Timestamp :created_at, default: Sequel::CURRENT_TIMESTAMP 
in theory, on boot, it will open a single idle connection and persist while your application is loaded. in development mode, your code _may_ reload based on your app server config or if you're using something like `shotgun` or `Rack::Reloader`. if it does, it _usually_ only reloads things like your models/controllers/routes, and not any database connections (you have to try pretty hard to make it reload your db connection every time you reload the page/fire against the rotue). in production, your code only reloads when you tell it to, usually after you deploy new code. this is good, because reloading is expensive. [according to the guy that wrote roda](https://github.com/jeremyevans/roda-sequel-stack), i would create a [`db.rb` file](https://github.com/jeremyevans/roda-sequel-stack/blob/master/db.rb) and then [require it in your models.rb or equivalent, at the top, only once](https://github.com/jeremyevans/roda-sequel-stack/blob/master/models.rb). 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jeremyevans/roda-sequel-stack/.../**db.rb** (master → 64ddb1e)](https://github.com/jeremyevans/roda-sequel-stack/blob/64ddb1e9e9c360d91d7b1dade289233888f9826a/db.rb) * [jeremyevans/roda-sequel-stack/.../**models.rb** (master → 64ddb1e)](https://github.com/jeremyevans/roda-sequel-stack/blob/64ddb1e9e9c360d91d7b1dade289233888f9826a/models.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
&gt; I don't have to because a user might not come to route where I connect to the db. it's very expensive to connect to the database which is why there are safeguards in place. the error you're experiencing is, i believe, a "feature" it's less expensive to `sleep(10)` once on boot than it is to `sleep(10)` every time someone hits a route.
that's right!
ok. but if I want to insert my own function?
ok, then keeping a db connection open must be expensive. a connection which a user might need once in a week.
I have no idea, I have always set them in my models, not the DB then.
it's more efficient to keep your car running at stoplights than it is to turn the car off and on again every time you're at a stoplight. there's no pattern that exists in modern software development that says "every time you need someone to connect to your database, initialize the connection to that database and then open a connection" i would take your philosophy up with matz, jeremyevans, and dhh.
Not in Ruby. Used it as the base for a RPC server for an in browser game. Very efficient for request size, but that gets thwarted by the HTTP header most of the time if you don't look into packaging multiple requests into one http request. Look at Thrift too to give you another similar tool. In terms of size and versatility a colleague of mine would always say "Nothing beats TLV". JSON is find until you find that you really need to cut down on the raw amount of data shared between your services.
activerecord does this on the model. i would follow their lead. [more info on hooks in sequel](https://github.com/jeremyevans/sequel/blob/master/doc/model_hooks.rdoc)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [jeremyevans/sequel/.../**model_hooks.rdoc** (master → c9cdc6f)](https://github.com/jeremyevans/sequel/blob/c9cdc6f02695194497844eb19620f44fc7225394/doc/model_hooks.rdoc) ---- ^(Shoot me a PM if you think I'm doing something wrong.)
&gt; this isn't the place to debate it. &gt; it is
why all you clones accounts are so harsh with people? 
Can you share the link of the document where it does?
how do you know that all are?
because it's not in the source.
The thing you want to parse isn't a ruby array, but a javascript one. That might seem like a technicality, because the subset you're dealing with is valid syntax in both, but it's worth considering, because [we already have a tool for doing that](https://gist.github.com/ttilberg/c23f39318f5efacdd3ec45f3e1b19ad4#file-converter-rb-L2). To answer your direct question, there are various ruby sandboxing tools and techniques, but they're complicated and rich in limitations -- the fact that something as simple as `$SAFE` isn't reliable protection is *why* it's been removed. Finally, I'll note that while it's useful to consider how easily you can solve a problem for yourself [just using stdlib / gems you're already using], I wouldn't actively avoid using gems to the extent you seem to be suggesting you'd prefer. The above-mentioned library was added to stdlib relatively recently -- if it had to be installed as a gem, it would still be the right way of solving the problem. Adding dependencies in some other environments is A Big Deal, and something to be considered carefully. Rubygems and Bundler make it trivial in Ruby, and you should avail yourself of that.
!!!!!!!!! Right there!!! Thanks, and great catch! Obviously, there’s plenty that could go wrong with this idea— but it’s not meant for a real application or anything. This is good enough for me. That should provide exactly what I’m trying to accomplish— leveraging the fact that an array of strings in Ruby and JS look the same. I’m not against gems, but for this specific thing, I was trying to keep it as a simple “scratch pad” kind of script I could reference in pry for exploration. I wanted to avoid dependencies to avoid a gemfile, but more importantly learn if it was easy to do this safely out of the box. Turns out— sounds like nope (except for this little trick you mentioned above). Thank you for the thoughtful response! 
&gt; I could see a possible situation related to writing a parser/scanner to break down the array and build my own... As u/v_krishna points out below... I already included that exact tool with `json`! A great moment of “if you can’t answer the question in an acceptable way, change the question.” Awesome. 
I’ve got Docker sitting right here, waiting to be used— not a bad idea to consider in such a situation! 
It says `:null`, not `null`. http://sequel.jeremyevans.net/rdoc/files/doc/schema_modification_rdoc.html#label-Column+options
not sure why you would do it this way, you can't make the database use a ruby method in some app somwhere. Just use the plugin? http://sequel.jeremyevans.net/rdoc-plugins/classes/Sequel/Plugins/Timestamps.html
is the same pattern. You are asking people for help, in they free time, for free. At least you should try to formulate correctly the issue, given as much details as you possible can. Second, replying to people in passive aggressive words does not help my 2 cetns
flatbuffers are also worth a look (if you're concerned about message size). Super compact but sacrifices stream-ability (you need to get to the end of the record before you can extract data from it) and the ability to modified an already 'converted' bundle.
Requring inside a block, that's just wtf, why? You should be pre-loading as much of the webapp as possible unless you want poor 95th percentile performance. Defining a constant every time a route is requested will cause issues when the route is requested again, constant already defined. Maybe you can just restart the server evertime that request is done? heh. The way Sequel works is that it won't try and establish a connection until it is used. So trying to only create a connection for this request is a waste of effort. Since you made it a constant the connection will also persist even after this block is ran so you just delayed doing it the correct way for the wrong reason in the wrong way. To fix it, you need to go back and understand the fundamentals of ruby and how ruby works when ran as a long lived http service.
I have a lot of experience with TLV. It's simple, efficient, and just works for what it does. But you don't get schemas or language bindings for free the way you do with protobufs (I presume, haven't looked at it in years). Validation, IO handling, typing and other contractual guarantees -- this is where all the concern (or otherwise buggy behavior) goes when using TLV.
`default: Sequel.function(:now)` `default: Sequel.function(:your_own_function)`
`default: Sequel.function(:now)` `default: Sequel.function(:your_own_function)`
I imagine he's not talking about Ruby, but rather MySQL functions (going from the `now()` in the example).
I see, but I don't think you can use mysql functions as defaults.
Don't feel stupid, I asked not just for me but for everyone else reading. :) 
he's exhausting. 
If you're going to replace ActiveSupport with a bucket of independent gems -- which are probably less mature and less well-supported than AS because almost anything is, although other things might be _better designed_ it's true -- what have you gained exactly?
Yes, I'm the same janko-m :). You're welcome, I'm glad you find it so useful!
Thank you for your kind words. &gt; I think we have our choice of several very high performance app servers these days... This really depends on how you measure performance. Sure both Puma and Passenger are fast and I love them. It's also quite easy to throw hardware at slower applications or when we need to serve more clients... However, when it comes to persistent connections, performance is very sketchy. For example, there are hidden issues with the `select` system call. On Windows it used to be limited to 64 connections per call ([by default it still is](https://msdn.microsoft.com/en-us/library/windows/desktop/ms740141.aspx)). On many \*nix based systems, it was historically limited to connection `fd &lt; 1024` since the upper bits were ([and sometimes still are](http://man7.org/linux/man-pages/man2/select.2.html#BUGS)) used by `select` to mark connection state. Having a server accept more connections than it's polling mechanism can handle can cause data structure corruption with really annoying results - and when persistent connections aren't too busy, this limit is a real concern. If you're lucky, the server crashes. On macOS I encountered a bug where the kernel data structures might get corrupted as well and the system had to be restarted. I think this is a rather bigger issue than the Ruby community is aware of. I'm happy to see gems such as [nio4r](https://github.com/socketry/nio4r), but it seems they sometimes use `select` under the hood and they mostly don't enforce a high-load polling engine (such as `epoll` or `kqueue` that are supported on some systems, but not enforced). This doesn't only effect Websockets, it also effects HTTP/2 and other persistent connection approaches. I remember how I was excited to push the [Websocket Rack Specification Draft](https://github.com/boazsegev/iodine/blob/f6e12b8a025ce77d8db3728fd1d508e4c0ad1e9b/SPEC-Websocket-Draft.md). After we got a semi-consensus about the draft, and the Puma team authored [a fork](https://github.com/puma/puma/pull/1054) to implement the concept... than the draft was abandoned by both the Puma team and the Passenger team. I'm guessing Puma couldn't implement the draft because [the server wouldn't handle enough persistent connections concurrently](https://github.com/puma/puma/issues/1303#issuecomment-304753858). I don't know why Passenger abandoned the idea. &gt; Other than websockets performance-with-convenience... Actually this is how the project started. Me and a friend were authoring a web-game. I really wanted to push for Ruby because of it's ease... However, we ended up using node.js because Ruby websockets weren't an alternative at the time. Too many connections would cause Ruby to crash. &gt; I wonder how hard it might be to make ActionCable use the iodine websockets API instead of rack-hijack I think this is a very good question... but I believe it will be very hard to push, even though it's also a matter of separation of concerns. At the moment ActionCable includes a Websocket server (using `nio4r` and hijacked sockets). There's a very high coupling between ActionCable's design and the server code. When using iodine, this server is totally circumvented, which means that a lot of the code would need to be rethought and entanglement should be dealt with. I'm not sure a server should be attached to a framework but I can't see the Rails team throwing months of work out the window and moving the code outside the framework.
1. Processes would only require some shell scripting. So, that would be simpler than introducing threading to an existing Ruby program. Not sure about speed though, that probably depends on how the CPU cache can (or cannot) be utilized. 2. + 3. That’s because processes really are out of the scope of Ruby’s language and runtime. The interpreter doesn’t need to care about them (except for providing a method to `fork`). 4. Yes, but afaik Ruby needs to be responsible for context switching in order to set/unset the GIL. 5. Which buzz? I didn’t notice any difference in the last 5 years. The only thing that changed was that Ruby got native threads in 1.9.
1. What do you mean "to share state" ? I don't see a way it doesn't happen in either case. Except If you mean sharing data between threads, which usually happens with an interface (file or db) which takes responsibility of handling this exchange. 2. So you could say that by using Processes they are actually processed in separate "real" threads by the O/S? 4. I read a lot of stuff about the stability of Ruby Threads processing. I have also read and listened live about Guilds by Matz. The whole talk about Threads is depressing and I don't see the way, possibly because of my lack of knowledge/experience regarding Threading. 
As far as the OS is concerned, threads and processes are extremely similar, yes. The key distinction is that a set of threads within a process all have access to the same memory. Processes communicate via external interfaces; threads can do that, but also use that shared memory to communicate directly -- if thread 1 sets a global variable, thread 2 sees the new value in that variable. Guilds are a current experimental project, which might allow ruby code in multiple threads to execute in parallel (which it currently can't and doesn't [in CRuby]). As it's currently being explored, it gets talked about.. but I'm not sure I'd say that translates to buzz around threads in general. I'm unclear on any "threads == frustration/depression" angle, sorry... they work for me.
I am not against threads in ruby at all and I don't see any major issue occuring, this is a language of choice/personal preference for me and not just "work". I am just afraid sometimes because as I already said I don't possess any significant knowledge in threading. Thanks for clearing things out.
What about running a Process into a Thread ? For example a popen3 system command into a Thread ? As far as I know there isn't a way to control multiple processes, except building a stack/queue manually. So in order to run multiple processes and track their statuses, I don't see any other way thant tracking pid files. 
Here's a description of processes and threads from Apple (https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html)... HTH... &gt; Each process (application) in OS X or iOS is made up of one or more threads, each of which represents a single path of execution through the application's code. Every application starts with a single thread, which runs the application's main function. Applications can spawn additional threads, each of which executes the code of a specific function. &gt; When an application spawns a new thread, that thread becomes an independent entity inside of the application's process space. Each thread has its own execution stack and is scheduled for runtime separately by the kernel. A thread can communicate with other threads and other processes, perform I/O operations, and do anything else you might need it to do. Because they are inside the same process space, however, all threads in a single application share the same virtual memory space and have the same access rights as the process itself. 
I think OP is referring to the many comments/posts along the lines of “Why I dropped Ruby like a bad habit, and switched to X: a language with REAL multithreading. I lost 40 pounds and gained 30 years back on my life.” As a relatively new rubyist, they are depressing to read because they shake your self confidence a little bit. I could have easily picked any other language to study and grow fond of. It makes it harder to want to investigate a different language in the same depth you’ve given Ruby when you’re still absorbing Ruby at breakthrough pace. There’s just not enough time in a day. This is my personal feeling about what I think OP is describing. 
Here is a list of threads in other subreddits about the same content: * [The surprising behaviour of calling split on strings](https://www.reddit.com/r/programming/comments/79hhsh/the_surprising_behaviour_of_calling_split_on/) on /r/programming with 1 karma (created at 2017-10-30 00:39:51 by /u/zetter) ---- ^^I ^^am ^^a ^^bot ^^[FAQ](https://www.reddit.com/r/DuplicatesBot/wiki/index)-[Code](https://github.com/PokestarFan/DuplicateBot)-[Bugs](https://www.reddit.com/r/DuplicatesBot/comments/6ypgmx/bugs_and_problems/)-[Suggestions](https://www.reddit.com/r/DuplicatesBot/comments/6ypg85/suggestion_for_duplicatesbot/)-[Block](https://www.reddit.com/r/DuplicatesBot/wiki/index#wiki_block_bot_from_tagging_on_your_posts) ^^Now ^^you ^^can ^^remove ^^the ^^comment ^^by ^^replying ^^delete!
&gt; What do you mean "to share state" ? Shared state is Ruby objects and values that can be accessed by more than one thread at the same time. Sharing state is the number one difference between threads and processes. A thread allows you uncontrolled access to mutable shared state, which is very efficient but can be hard to use. In some work loads, mutable shared state is the only tractable way we know of to parallelise an algorithm. In many work loads, I think it's the most elegant and natural way to do it, but that's an opinion. (You can do uncontrolled mutable shared memory between processes in Ruby, but not really in a way that is relevant to what we're talking about. Just mentioning this so someone doesn't attack me with this.) &gt; Except If you mean sharing data between threads, which usually happens with an interface (file or db) which takes responsibility of handling this exchange Well, probably yes in practice. But this just shifts the responsibility of the multithreading and sharing the data to the database, which then has to solve the same problem. People aren't writing many databases in Ruby, but if they did they couldn't then rely on another database to share their data - someone at some point in the stack is going to have to solve that problem. &gt; The whole talk about Threads is depressing Nobody knows what you are on about here. People are just talking about some new ideas for how to do parallelism and concurrency in Ruby. Nobody is upset about it.
I assume you are in favour of reintroducing `Array#tenth` too, then?
TL;DR: don't touch a running system
Consider two threads accessing the same variable `@foo`, performing (concurrently): @foo = @foo + 1 The result is **unknown** since these is actually three different instructions (or two different instructions): 1. get `@foo` value. 2. add +1. 3. store result in `@foo`. Here's a possible flow as far as multi-threading goes: 1. Thread `A` collects value of `@foo`. Value = 1; 1. --Context switch-- 2. Thread `B` collects value of `@foo`. Value = 1. 3. Thread `B` stores value in `@foo`, so now `@foo == 2`. 1. --Context switch-- 4. Thread `A` stores value in `@foo`, so now `@foo == 2`. As you can see, `@foo` could be either 2 or 3... which isn't really what you wanted. Now consider two threads accessing the same Array `@bar`, performing (concurrently): @bar &lt;&lt; data Will the data be contained in the Array... possibly. On truly concurrent models, this might result is the `@bar` array being corrupted (i.e. JRuby). On Ruby MRI it's **likely** (but not promised) that the data will be safely inserted. `@bar` should be protected by the GIL, so Array corruption isn't an issue. At best case scenario the ordering will be unknown.
Short of using a proper JS parser and assuming you only care about arrays of string, you can parse it as JSON: ``` JSON.parse('["console", "log"]') =&gt; ["console", "log"] ``` 
That's not a fair TL;DR at all... &gt; I had a similar piece of code that I needed to convert to Python so it could be integrated with another tool. The issue cropped up when translating a section of code to another language, for what sounds like a perfectly sensible reason. A *better* tl;dr would be: * In python/java/js/go/haskell/php/scala: &gt; `"".split(",") == [""]` because: &gt; `"xx".split(",")` is `["xx"]`, and &gt; `"x".split(",")` is `["x"]`, it naturally follows that &gt; `"".split(",")` is `[""]`. * Whereas in ruby/perl/awk: &gt; `"".split(",") == []` because: &gt; `"x,x".split(",")` has 2 fields and `["x", "x"]` has length 2. &gt; `"x".split(",")` has 1 field and `["x"]` has length 1. &gt; `"".split(",")` has 0 fields and `[]` has length 0. The "right" behaviour is a source of endless debate, and each language is likely to never change from its current implementation due to the subtle issues it would create.
&gt; The "right" behaviour is a source of endless debate, and each language is likely to never change from its current implementation due to the subtle issues it would create. We'll, the you go, you summed up my tldr ;)
All of the points you bring up are issues with Ruby, there are attempts to work around this with things like Guilds, but IMO until the core implementation is changed, threading will always be limited in Ruby and the best way to do real threading is with fork. Ruby suffers from some of the same issues as PHP. It is a great language, but the API is fragmented and limited.
I think to assume the empty string is a string with no fields is the same as to assume the number 0 has no information in other contexts. That is way the None, Null or Empty special value exists in every Information field. How many fields does this has?: ",,,," This? "," And this?: ""
This maybe of some use to you. https://www.jstorimer.com/pages/books
Thanks! One of the other folks here suggested the same thing (though not directly). This ended up being exactly the kind of thinking that got me over the hump. In the script I’m assessing, the JSON parser didn’t work, as some of the strings include `”` chars, and so were delineated with `'`: which JSON doesn’t like. However, reading it with a YAML parser worked correctly. Either way, it gave me a new way to think about the problem and avoid evaluating the code directly. Woo! Ruby Level Up!
Well... Sort of, but not really. Your "tl;dr" is a summary of the final paragraph of the article. It does not summarise the whole post and, if taken out of context, gives the wrong impression of what the post is actually all about.
Great breakdown... I like the Perl / Ruby / Awk way because of the way it works with iterators ... A lot of code does not need to be written to check edge cases.
I got it, this is a usual case that I've seen happening. But there are other thread-safe array-type structures like queues to use. Or it is possible that you will build a thread safe array manually. But after all, I don't expect everything to work with anything in any case and technology. It is obvious that customization is necessary. I don't get why people expect everything to work out of the box without any issues. This is a usual challenge in programming. Guilds may solve this but is it really necessary? 
I think I get it now. So the database has to solve how to work concurrently and you have to trust its processing power and algorithms. This is like moving the problem from one place to the other. Plus that using disk storage for either DB or files as the mediator between the requester and the processor adds more lag the slows down the whole system as it doesn't happen in memory. But it happens in systems like sidekiq or resque which as I understand have a "hybrid" solution for multiprocessing jobs concurrently and also putting them in a series to execute in workers and queues. As I understand you can't exceed a certain value of concurrent jobs or running X threads at the same time If you prefer. There is no gain in anything If I execute 20 threads at once If the system can process 4 or 8 maximum. So pushing them in a queue and popping them to be processed is inevitable finally. There is also the Actor model which I don't really understand and it seems that Guild might be based upon and I am going to read a little bit more about it before having an opinion. 
&gt; What are the actual downsides of using AS in a non-Rails project? This is an interesting question. I can think of two points: 1. AS is huge. Besides some useful features, it contains a lot of dubious things, as well as [plain wrong ones](http://ryanbigg.com/2017/06/current-considered-harmful). By pulling it in for some useful features, you risk that someone will use wrong ones because it's already in the Gemfile. 2. It is a Rails by-product. And it means you don't really have control of what will be included in AS. You may think that, for example, some extension of ActiveSupport::Notification would be useful, but unless core team (by hat I mean DHH) thinks it's fine or Rails will benefit from that, it's not gonna be taken into consideration. So it is actually a Rails utilities libraries, not general ones. Also, same goes for useless features: see CurrentAttributes linked above.
puts exec("sudo awk -F',' #{string}") or something along those lines I'd imagine.
Have a look at [The Odin Project](https://www.theodinproject.com/).
/u/BenBach Thanks for the kind words. Would you like freework.com to be featured on Hanami home page? Please let us to know https://twitter.com/hanamirb/status/924956501415997441 Thanks.
Was this posted by postwill?
[/u/jodusha](https://www.reddit.com/user/BenBach) Would be awesome. Thank you. Replied on twitter as well.
`def` defines a method. You write `def name(params...) ...` to use it. Of course there's a whole world of complexity to what this does, and what the parameters can be, and what you write after the `def`, so you'll need to be a bit more specific.
Type "def" and there you go.
How could I use it to jump to other parts of a program? I read somewhere that you can do that. 
Looks like a fun little project to unify all the different social media APIs under one roof, but I'm not sure I'd use this in a serious project. # Gemfile gem 'tumblr_client', git: 'git@github.com:postwill/tumblr_client.git' # gemspec spec.add_dependency 'twitter', '~&gt; 6.1.0' spec.add_dependency 'koala', '~&gt; 3.0.0' spec.add_dependency 'pinterest-api', '~&gt; 0.4.0' spec.add_dependency 'instagram_upload', '~&gt; 0.1.2' The problem is, not only does this gem package **all** of the above into your project (even if you only wanted, say, two of them), but it adds an extra layer to the dependency chain. Also, although the APIs are broadly similar for posting some simple text/image, there will also be a tonne of differences - such as the allowed post length, including a title, tagging, and so on. So for any "serious" project, I think you *need* to handle each social media API differently anyway, which makes this wrapper library redundant. ...But still, with that said, I can see this could be useful for small/personal projects.
Are you asking about the concept of subroutines in general? You're probably going to take ten steps backward and start from the very beginning of programming if you aren't yet familiar with these concepts.
Probably. 
&gt; I don't get why people expect everything to work out of the box without any issues. I'm not sure what you mean, but I think we're in agreement. These risks are normal and as far as I know. But this is what makes threads "hard", code needs to be written with concurrency in mind and synchronizing mechanisms (such as mutexes and conditional variables) should be used.And these mechanisms can be fragile if used incorrectly. it's impossible to safely use code that isn't designed to be thread safe in a multi-threaded environment. &gt; Guilds may solve this but is it really necessary? Guilds are an interesting approach for a solution. They are designed to mostly abstract away the synchronization mechanisms, theoretically allowing "unsafe" code to be called. Guilds aren't really necessary, but they promised to provide a great help at making it easier for developers to write thread-safe code, which should make life easier for everyone (especially people who don't have experience with locks and such).
"Proceseses" are literally just separate things on your computer. Like if you open the same ruby app twice, that's separate processes. The fact that a process is a 'child' of another is really just an OS bookkeeping thing, it's pretty much no different than any other entirely separate process, definitely as far as it's performance characteristics. 
I'm not sure what "running a Process into a Thread" means, I'm not sure it means anything. "Hybrid": When it comes to app servers, like puma or passenger, which is the only place I've seen it used (I think one of them invented the term used in this way) -- it means launching several processes, each of which has it's own internal multi-threading as well. Processes are entirely independent from each other. Threads each belong to a specific process. 
Yep. It's hard to use parallel tools w/ CircleCi 2.0 here, but is definitely worth it for local tests and a CI tool that can tell you the results. Also, in CI w/o parallelization you can add the test results to your artifacts.
Tutorials tends to be a bit heavier on the explanation.
thanks for breaking this down a little better
Using it as the backend for a Facebook Messenger bot in production since August, with basically a 1-1 matchup between messages and actions. We use the router to handle incoming calls by sending back routes (with url params included) as the payload of any buttons/links instead of DO_USER_ACTION or something like that. So far it's been fantastic to use! We did decide to use ActiveRecord so we could get off the ground quickly without having to dive too deep into the model layer, but everything else is great.
That looks great thank you I will definitely be giving it a shot.
Another reason not to use it (or any other gem like this) in production is that the social media sites WILL change their API and you will have to explain to your boss / client why your project doesn't work any more. Rather, have your client sign up with some 3rd party service that handles these integrations and then integrate with that and leave the responsibility up to them. And then you also don't have to include all those other libraries in your project, either ;)
You don't need to redefine `go_to_next_scene` in each class, that will just needlessly overwrite the original method. You can just call the method without having to write it, the interpreter will find it.
Unless I'm misunderstanding your code? It's easier to tease out these things with the full code, not comments.
I think you might want to look into blocks. It sounds like you might want to do some common class behavior, and then yield to the subclass for some details?
There is so much training materials out there for Ruby and so many paths you could choose. That said, I have consistently found Ruby Koans a great starting place for beginners: http://rubykoans.com It is a free, hands on, broad, and gentle introduction to the Ruby language that a beginner can finish in a few hours. Good luck on your journey.
Thank you for this. The JavaScript koans was a big help when I started that. Don't know why I didn't think to look for a Ruby one!
And now I am rushing to download the JavaScript Koans... thank you!
If you have many scenes that have a arbitrary number of things in common, you might want to consider using mixins to provide chunks of common behavior. (That is, using composition in addition to the inheritance you've already shown.) Example: maybe certain scenes offer the option to rest, if it's a safe place. You could define a module called RestableScene that provides the methods or data to allow them to enter a "rest" command, which gives them a description of making camp for the night and they recover health (or whatever). Any scene in which you include this module would make that command available. This pattern keeps you from overloading your base Scene class with lots of methods that are not used by many scenes, and it groups related methods that are required for complex shared behaviors. It also provides more clarity about what shared behavior is available in a given scene, since you'd generally include all the modules at the top of the class. I now realize that your scenes may be more granular than I'm thinking here, maybe representing an individual choice in a sequence of events, but I suppose this way of thinking might spark a useful idea even if it doesn't fit your game in the way I described.
I would split out the scene logic so that it's separate from the logic used to navigate between scenes. class DoNothingScene #no inheritance needed unless you are using shared logic #duck typing will work if all "Scene" types respond to a 'handle' method. #if you have some base logic available in Scene#handle, then inherit from Scene. def initialize(config) @number = config['number'] @text = config['text'] @next_scene_number = config['next_scene_number'] end def handle #... end end class SceneViewer attr_reader :scene_data, :current_scene def initialize(scenes) @scene_data = scenes.group_by(&amp;:number) end def scenes=(val) @scene_data = val.group_by(&amp;:number) end def scenes @scene_data.values end def show_first show(1) end def show(scene_number) return unless scene = @scene_data[scene_number] @current_scene = scene @current_scene.handle #.... end def show_next return unless current_scene show(current_scene.number + 1) end end
This does nothing. Array.new.inject(&amp;:*) # =&gt; nil but I think you already knew that. It means "Call * on all elements". Actually the `&amp;` isn't necessary, as `inject` takes just a symbol. https://stackoverflow.com/questions/1217088/what-does-mapname-mean-in-ruby
I understand inject. I don't understand what &amp;: does. It doesn't have to be inject, i see it on other enemerables and not sure where to look it up in the documentation.
Or does the : go with *? Perhaps that is my misunderstanding.
The "&amp;" in this scenario means that the following symbol is a method reference that gets converted to a proc and passed as a block. It is mostly useful for shortening simple blocks, for example array.map { |item| item.foo } can be written as array.map(&amp;:foo)
yes, this does like a nice way to do this, I forgot to mention that some of my scene classes have some methods of their own, for asking the user for input, finding the next scene number etc. based off the input. I've put the code on github, here's one of those classes: https://github.com/IceTimux/death-at-appledore-towers/blob/master/lib/choice_scene.rb
&amp; before symbol calls to_proc method on it. For example &amp;:foo is the same as :foo.to_proc. And this is the same as passing the following proc to method -&gt;(v) { v.foo }
You're right, Here's a link to the repo https://github.com/IceTimux/death-at-appledore-towers 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [IceTimux/death-at-appledore-towers/.../**choice_scene.rb** (master → cce28fd)](https://github.com/IceTimux/death-at-appledore-towers/blob/cce28fd36e1d6cca9ec3b5a63c9fe622ba1bce7b/lib/choice_scene.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dp4tnbv.)^.
I don't think I'm doing this, I call the method in the classes and provide the scene number as an argument.
It's a short hand way to express a block arr = [1,2,3,4,5] even = arr.select(&amp;:even?) # [2,4] # is the same as even = arr.select{|e| e.even?} arr = [true,nil,false,4,"23",:ugh] arr.map(&amp;:to_s) # ["true","","false","4","23","ugh"] 
https://stackoverflow.com
The `:` goes with `*`, it's the same as `:"*"` or `"*".to_sym` (except without any string being allocated). Same way you can have `:test` or `:key`. You can't do this with arbitrary strings or symbols, sometimes you need to put the value of the key in quotes (e.g. `:"` is a syntax error)
You might want to read a bit about this: http://ablogaboutcode.com/2012/01/04/the-ampersand-operator-in-ruby
https://www.google.co.id/maps/place/28°23'41.6"N+84°07'26.4"E/@28.3951048,84.1219821,14z/data=!4m5!3m4!1s0x0:0x0!8m2!3d28.3949!4d84.124
`&amp;` is an operator that converts a 'reified' proc object to a block argument, always: a_proc = proc { |thing| thing.downcase } a_proc.call("FOO") # =&gt; "foo" ["FOO"].map &amp;a_proc # =&gt; ["foo"] That part has been in ruby forever. If you use something that isn't already a lambda/proc with the `&amp;` operator, it will call a `to_proc` method on it, and then use that proc as the block argument. I think _that_ part has been in ruby forever too. ["FOO"].map &amp;Object.new TypeError: wrong argument type Object (expected Proc) class HasToProc ; def to_proc ; lambda { |x| x.downcase } ; end ; end ["FOO"].map &amp;HasToProc.new # =&gt; ["foo"] The next piece of the puzzle is that _symbols_ in ruby actually have a #to_proc method, that returns a proc object that just calls the method (or 'sends the message') identified by that symbol. (That is newer in ruby, although still old at this point, maybe ruby 1.9?) :downcase.to_proc # =&gt; #&lt;Proc:0x007f885d8dacb0(&amp;:downcase)&gt; :downcase.to_proc.call("FOO") # =&gt; "foo" `:anything.to_proc` produces a proc that is equivalent to `proc { |x| x.anything }`, or I guess technically `proc { |x| x.send(:anything) }`. Put `Symbol#to_proc` together with the behavior of the `&amp;` operator to turn a proc object into a block argument (and call `to_proc` on the arg to get a proc object if neccesary)... and there you have it! It is effectively a shorthand for creating a proc object that takes one argument and calls/sends the method named by the symbol to it -- and then passing it as a block argument (to any method at all that takes a block argument). Just by the semantics of the `&amp;` operator (which always turns a proc into a block argument), and the existence of the `to_proc` method on Symbols. `&amp;:` is not an operator or a thing, rather it's `&amp;` followed by `:symbol`. something.some_method &amp;:some_symbol Is exactly equivalent to: something.some_method { |x| x.some_symbol } Or for that matter: something.some_method &amp;(proc { |x| x.some_symbol })
multi-threaded concurrent programming is actually pretty hard, and a new thing to wrap your head around. it's not just you! I recommend checking out the tools in [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) (now a rails dependency already) for your multi-threaded concurrency needs, rather than building it yourself with `Thread.new`. Also some tutorials on multi-threaded concurrency, whether in ruby or not, it's a similar problem (except in modern languages that have concurrency primitives built in, it's differnet there. But similar in C, Java, Perl, whatever, to ruby. Different in Erlang.). 
Thanks a lot for the courage. I am working &amp; reading more than 12 hours a day and I feel so depressed when I see things 100x the difficulty I usually face. As I already said, I got a sense that Ruby is problematic in threading but from others comments I see that it's just "fake news" and the challenges that exist in other languages exist in Ruby too. Nothing special. And that made me love Ruby more !
So. Threading is hard in any language. There are some more recent languages that try to "bake in" support for various concurrency patterns to make it easier. Ruby is not one of them. I haven't used any of them extensively enough to say if they succeed, but some people like them (and try to duplicate some of what they do in other languages, like ruby, but there isn't consensus on what this should look like, and it's harder to do when the language hasn't baked them in from the start). Ruby's stdlib/core support for threading uses or mirrors the basic OS-level APIs that OSs have had since threading was invented, they are fairly low-level. And threading is hard, and in similar ways in ruby to other languages that do this (that is, nearly any language with support for multi-threading at all, that isn't newish). There is basically one particular "problematic" aspect of threading with MRI ruby. One reason threading is popular is to take advantage of the multiple CPU cores that modern computers all have; to be executing multiple computations simultaneously on more than one CPU at once. MRI Ruby can't do this, because, well, threading is hard, and when MRI was written they took an easier route of not supporting this. (It can particularly be an issue for C extensions in MRI). That's what people are usually talking about if they talk about anything _particularly_ problematic about threads in ruby. The "GIL" which prevents true parallel execution on multiple CPUs. JRuby doesn't have this limitation. And standard Python, for instance, shares this limitation. Threads were actually invented as an OS concept when almost all (or even all?) computers only had one CPU. They are still useful even without true multi-cpu parallelism. In some ways. Not in others that would be possible with true multi-cpu parallelism.
Great reply, thank U!
Well everything makes sense. TBH I don't get the full complexity of building such a system e.g. as ruby-concurrent. I don't have the knowledge for that. But I've build small scripts that spawn processes or create threads from a pool of 10s for system commands. They work great, I never had any significant issue. I was going to ask about Python but you already answered that. So we have two big communities right now Python and Ruby having almost the same perception about concurrency patterns. I think that for me this is enough to go on with what I really love. Because I believe that developers have usual "language crises" If they are using a long-lasting language and not investing time and building apps on something like PHP that will fade through the years. When you have 8 threads, what stops you from spawning 4 Processes with 2 internat threads each ? the processes will be assigned to CPUs by the O/S and threads will be run internally as children of each process. That's what I said "hybrid". With the knowledge I have right know, I don't see something bad and it seems like a usual programming problem. I never spoke about "pressing a button to apply concurrency", I understand all the difficulties and the riddles. My experience with threads are limited to running system commands in parallel - something like a job management module. It's a shame that people throw dust to Ruby or Python in order to manipulate people into using others. I have been in conferences that Elixir and Phoenix was presenting as the panacea while Rails is old school and Ruby has a lot of issues. I fell into the trap it seems and started being unsure about the future of Ruby. But this is all BS. One of the main reasons I chose Ruby is because the community and the people are simply awesome. 
&gt; When you have 8 threads, what stops you from spawning 4 Processes with 2 internat threads each ? the processes will be assigned to CPUs by the O/S and threads will be run internally as children of each process. That's what I said "hybrid". Only that: a) It could take a lot of RAM and b) it is complicated to set up, especially reliably. Since each process is really a completely independent thing, with no shared memory, communication between them is not really straightforward. If a process dies, you might not notice, you're not going to get an exception on it (like you do for a thread that raised, when you join anyway) and now you might need a semi-complicated 'supervisor' architecture to notice that it's died with an uncaught exception and figure out what to do about it. So it's complicated to deal with. It's a big pain. If you start down the road of trying it, you'll discover that. :) But as you note, that is indeed what puma or passenger enterprise (or iodine) do, because when you're talking web app servers, it really is crucial to making the most of your multi-CPU server in MRI. So it's worth the trouble. I've never run into a situation myself where it's worth the trouble. Usually things I want to make concurrent are mostly waiting on IO (whether the database, the file system, or a network API call), so the GIL is not so much an issue. "running system commands in parallel" is such a case too, becuase from the perspective of the _ruby_ process, waiting on the system command is just waiting on IO, your multiple system commands will be able to be executed with true parallelism even in MRI, no problem. And while the program is waiting on them, actual ruby code can still execute (on one CPU core) in parallel with them too. I never wrote anything about "pressing a button to apply concurrency" either, that's not from me. Not sure what you're being defensive about! It depends on what you're doing. There are things for which routine true CPU parallelization is really important, and ruby would not be a good choice -- although _JRuby_ would do fine there, and i have occasionally used JRuby for ETL-type things for that reason. Many people make entire careers in ruby without running into those things. But every language or platform has it's strengths and weaknesses. 
So what do you use personally If not Ruby to solve these challenges ?
Small correction: object.method(&amp;:symbol) is behaving more specifically like object.method do |*args| args.shift.public_send(:symbol, *args) end (with the natural meanings of shift and public_send, since this is implemented in C) c.f. https://github.com/ruby/ruby/blob/51b0230a9b440b8e6b6e6003006acaf7536e6dea/string.c#L10209 This enables invocations of methods with arity &gt; 0, as in `my_things.sort(&amp;:thing_comparator)`. 
I just use ruby so far (10+ years of working mostly in ruby), I don't work in domains where I'd need something else to the extent that the organization would want to run something else in addition to ruby. (I work for orgs with small development staffs). I mean, occasionally I have to do something in a legacy PHP app, or customize something written by someone else in Java. Or write some XSLT. But I do ruby. 
good call, thanks. I didn't realize it did that, has it always or is that newer than the first Symbol#to_proc? That does make it even more confusing to explain, heh. 
Great question, great explanation 
Did a bit of github archaeology. It's been like that since it was introduced in Ruby 1.8.7 (an import from ActiveSupport, converted to C), so at least a decade. Amusing puzzle: I think it might even technically be implemented as the C equivalent of object.method do |*args, &amp;block| args[0].public_send(:symbol, *args[1..-1], &amp;block) end How can `method` yield to this block *with a block*? Whether that is even possible, let alone useful, is left as an exercise for the reader :) The other interesting thing to note is that the default implementation of Symbol#to_proc is not just in C, it's passed inside MRI as a specifically recognised symbol-type block handler and is thereby much faster than the plain-Ruby equivalent. One may monkey-patch Symbol#to_proc, but for performance and sanity's sake, don't do that. 
This is a handy reference and fun to play with!
Someday there will actually be posts like this about Ruby and not rails, eh?
Absolutely awesome. First, you title your post in an "introductory-for-novice" manner, then fill it with very strong statements against current practices, and a lot of unorthodox suggestions, and general disgust to RSpec. Bravo!
I work in QA and Ruby is the language I use, I'm kind of saddened to see the Ruby hate over on /r/programming =(
ever notice how 99% of the blog posts here are self-promotion?
I'm afraid I don't why you have such an issue with "one assertion per test" - even the example code in the article doesn't take up many more lines than the "compact" version.
I'm fine with someone posting their own article if it's useful. It's much more annoying to read an article from an agency and be blasted by popups for newsletter subscriptions or work with us or whatever. This one didn't even end the article with "I'm good at performance, hire me as a consultant" so that was pleasant.
Some pragmatic tricks, some philosophical reasonings on how to test and why.
Do you have the option to shell out to the sftp command?
If so: I recommend [SSHFS](https://github.com/libfuse/sshfs) for the job, available in most package managers as I suspect you'll need more than a list of files.
Probably as a last option, I would prefer to stay in ruby if i can.
I've worked extensively with Net::SFTP and not found anything else that's anywhere near as comprehensive. I too have run into issues before with the higher versions of the SFTP protocol. In our case a server negotiated v6 and started sending v3 which caused all kinds of problems. If you don't /need/ the v4 protocol and you don't mind something a little hacky, you can do the following to force v3 (which I've found to be almost universally compatible). class Net::SFTP::Session HIGHEST_PROTOCOL_VERSION_SUPPORTED = 3 end In my case I have this in a Rails initializer, but you'll know where to put this in your software.
The multiple assertions wouldn't be terrible in this case if he'd bothered to supply clear error messages. "Expected nil got ''" would tell you nothing about WHY it failed without looking at the code. If he'd included a simple message like "Expected the middle name to be nil but got ''" would do wonders.
There's no maintainer. Good opportunity if someone cares to step up and help fix issues like these.
This is great, thank you.
hell yeah. 
Only from people who don't use it (or have to support rails)
You know, if you're going to examine a design pattern attached to a framework, the last you can do is present example code from that framework. Anyways, the term "service object" is a bit of a misnomer, because I've always seen it presented, and used, like you have it here, with a module containing class methods. I have yet to see an actual class be used when creating a service object.
I posted this, but I didn't write it, so this is just my view, but it seems that the author has probably seen service objects that are created in the way they describe in the first part of the post. You're right, in this context the name is off putting, which I think is part of the point of the post too. If you've only seen this pattern with modules and class methods, then it sounds like you're already doing the right thing, at least according to Avdi. :)
Nice writeup, chaining the `[]` operator onto the method subject is very cool. The snippets and counter-arguments made the pitch easy to follow. One thing did strike me as odd. On the 'formal RSpec approach': &gt; Contra: Only a small one: nobody will write tests unless you’ll bite them really hard. They will brag about “too much boilerplate”, “I need to write 10 lines of tests per each 1 line of code, I don’t have time”, “my code is too trivial to write all this stuff”. Then, they’ll either sneak into “impatient” approach shown above or just stop to write (enough) tests. And later: &gt; The good testing framework allows you to write concise, robust and elegant tests. That’s the only way to be sure good programmers would write them. These arguments don't mesh for me. If good programmers, using a good testing framework, are refusing to write effective tests... one of those might not be so good after all.
&gt; The answer is: it won’t be. A reader of the IpnProcessor code won’t have any clue where the story is continued, unless some kind soul leaves them a comment to guide them. But a single module namespace with a bunch of methods somehow makes that connection crystal clear? Also, what self respecting software engineer would just literally copy a method body into a new *instance* method, in a new class, that *doesn't require any arguments for initialization*, use it the way outlined in the article, and call it a day?
&gt; I have yet to see an actual class be used when creating a service object. You're probably just lucky on this one. Shit like `MyService.new.call(args)` is very common, why anyone is writing functors in Ruby is beyond me but it's extremely common. 
I'm on mobile now, but when i get a chance I'll post a link to the interface I typically see.
As a fan of sound, boring cryptography I hate to be "that guy", but HMAC-SHA1 has no known security issues. This is because the HMAC construction, by virtue of hashing twice, retains collision resistance in the event a collision vulnerability is found in the underlying hash function. There are no known attacks against HMAC-SHA1. That said, HMAC-SHA256 is a much better default. Good job!
So, while I nearly always fangirl squee and get excited when I see things involving Interactive Fiction, this is also a post I can offer a bit of decent feedback on. Looking at your github repo and reading your description, one of my first suggestions has already been slightly alluded to by /u/diragor. He recommends using a mixin whereas I would say this almost the perfect case for an implementation of the Strategy pattern. The Strategy pattern allows you to create an object and compose it's behaviors of different things in order to allow the interface for the object to remain the same despite differing behaviors. So, for example, you want the interface for a scene to 'execute' the scene when 'handle' is called, but, handle in different scenes does different things. A very rough and simplified implementation of this might look like. class Scene attr_reader :number, :text, :next_scenes, :behavior def initialize(config) @number = config[:number] @text = config[:text] @next_scenes = config[:next_scenes] @behavior = config[:behavior] end def handle @behavior.execute self end end class DoNothingBehavior def self.execute(scene) puts scene.text scene.next_scenes.first end end class DoSomethingElse def self.execute(scene) puts scene.text scene.next_scenes.sample end end s = Scene.new(number: 100, text: "This is text", next_scenes: [101], behavior: DoNothingBehavior) # =&gt; #&lt;Scene:0x005640fce4f230 # @behavior=DoNothingBehavior, # @next_scenes=[101], # @number=100, # @text="This is text"&gt; s.handle # =&gt; 101 s2 = Scene.new(number:101, text: "This is the next room", next_scenes: [102, 103, 104, 105], behavior: DoSomethingElse) s2.handle # =&gt; 104 # &gt;&gt; This is text # &gt;&gt; This is the next room I know this doesn't match your implementation entirely, even though I am fiddling with a much better example, I'm honestly just excited to babble about this and wanted to get into the conversation. ;) This implementation for example obeys an interface in which handle returns the number of the next scene to render, and I'm just invoking it manually to showcase that even though they're both just Scene class, they have differing behaviors. This is another method of composing classes and allows you to avoid the downfall of having 15 similarly named classes that replicate functionality entirely and extract the different functionality into easily modifiable chunks.
Once its out of the controller you can unit test it. I think his point is that sometimes the simplest thing possible - literally just moving the code into a namespace - is all you need. I see lots of “over-engineered” code all over the place, it’s refreshing to see this call for simplicity, questioning established patterns.
This. There's a bit of obsession with single-responsibilty leading with people advocating stuff like `UserCreate.new(config).call(params)`.
You're exactly the guy I want to hear from when it comes to these things. I did some further reading based on your comment and definitely learned something today. I'll soften the wording in the README and probably remove SHA1 from the "bad digests" check. Thank you!
I didn't write this for self-promotion but because I found something interesting during development, thought I would investigate a bit more and write it up because it might be useful for others. I could then just leave it at that or try to make the post more widely known. What good would the former do? Nothing because it wouldn't help anybody if nobody knew about it.
Check out codewars, it has some lighter challenges to start into things 
[removed]
Maybe I was not that clear here... But what I've meant is the following: the "formal RSpec approach" embraces redundancy for the sake of formality and documentation, and at that point a lot of good programmers are lost. But RSpec, being well-designed and flexible test framework also supports concise approach (when most of the tests are just one-liners), exactly the one I demonstrate. In other words, I made a distinction between RSpec-as-a-tool and "approach praised by RSpec authors", and I really like the former and not-that-much fan of the latter :)
&gt; In effect, these two Service Objects, IpnProcessor and ProductRedeemer, will form two steps in a process of product purchase and delivery. But how will that relationship be represented in the codebase? By having a process implemented somewhere else. Services should never know about process, they exist a layer below it. Otherwise you end up trying to control emergence in a madman’s Conway’s Game of Life. Service objects or not.
When you learn to program and your given typical, initial programming tasks to solve, don't concentrate immediately on the code you need to implement. First think the problem through in an abstract way, then maybe sketch your solution out on a piece of paper in pseudo-code or with diagrams or whatever helps you. Only then go back to your computer and implement the solution in Ruby. When I started studying Software Engineering back in 2000, there was an algorithm and data structure class consisting of a lecture and associated exercise lessons. The exercise lessons were a four or five hours block on Fridays and at the end we would get the exercises that needed to be solved until the next Friday. I only had one desktop computer and that was in my dorm room at the University but I nearly always went home over the weekend. Although I had no computer at home I thought the exercises through, sketched out the work on paper and sometimes even sketched out the needed Pascal program. Once I got back to the dorm and my computer on Sunday evening, I would just type everything in and the programs would mostly just work, even for edge cases. It was a bit different once the exercises grew more complex and more challenging but still, even then thinking everything through beforehand and sketching out a path to a solution greatly reduced the overall amount of time needed to complete the exercises.
ahh I see, thanks a lot for joining in! I like this implementation. I should read up more on design betters and SOLID principles haha 
Actually, using callable objects, i.e. ones that respond to `#call`, is quite useful in a bunch of scenarios. For example, if you have a configuration option `raise_on_error = true | false`, it would probably make more sense to change that to `action_on_error = callable_object`. Then the user can decide on how to react to an error, and the default value could be `proc {|error_msg| raise error_msg}`. However, I agree that `MyService.new.call(args)` is quite useless, it should be `MyService.call(args)`. Whether the class method `::call` creates a new object or not depends on the complexity of the implementation, and the caller shouldn't be bothered with it.
Codewars is cool because you can start with simple things and get confident about your skills. Just try to keep practicing, find something usefull to you, it could be anything and just make it. You'll feel great after that. So keep practicing and keep being confident, it will work out.
What's your coding experience? What other languages have you used and what was your impression of them? Do you have a background in computer science? This matters, for example I started off with Java, and nothing made sense to me. It wasn't until I started using Ruby that I "got it".
This is what I thought while reading the article. 
Besides what I listed above, I finished Sololearn JavaScript, that’s about it. I liked JavaScript because it was easier but I’m skeptical because being easier doesn’t always mean better? Completely shooting in the dark here. I have no background in computer science so I’m trying to get into a bootcamp like App Academy. If I switch to JavaScript then I’d try FullStack Academy. Should I switch to JavaScript then go back to Ruby to hopefully “get it”?
I switched to Coderbyte from Codewars because Codewars didn’t make sense but I’ll try again. Thanks. 
I’m a pretty “linear” thinker, is there any sources you can recommend for thinking abstractly?
I switched to Coderbyte from Codewars because Codewars didn’t make sense but I’ll try again. Thanks. 
What's a specific challenge you're stuck on? It's ok to skip individual exercises or switch to a different collection. I like [exercism](http://exercism.io/)
The first point is a very important one. Most of the logic in an application is not going to fit into the Model, View, or Controller category. That's the framework providing structure and architecture, but it doesn't mean every piece of logic has to fall in those buckets. Ruby is perfectly good at expressing logic independent of the Rails shell, and utilizing it is gong to make your Models and Controllers much more concise and easier to understand. 
Both Javascript and Ruby are on the same level of difficulty (with pluses and minuses for each). Programming languages are a way to convert concepts (usually logic based) into something a machine understands. Your first step is to grasp the underlying concepts that you are trying to solve, how you would structure your solution (procedural, object-orientated, functional) We are making some basic assumptions here as well, that you understand some of the fundamental building blocks of programming (variables, functions, data structures, control flow). Learn how the language packages up functionality with libraries and how you can use them. Where Javascript is easier is being able to interact with something visual (a webpage), with ruby you're stuck with command line unless you have a go at using Rails (which has it's own learning curve and hidden pitfalls).
He means try to solve the problem using a code-like language, or even just your spoken language. When you write it in ruby, make that the comments. Something like ``` # task: print the numbers from 5 to 95, skipping all numbers that end in 5 # loop from 5 to 95. Do: # do next iteration if ... # number % 5 is 0 # AND number %10 is NOT 0 # else # print number ```
I can't help but feeling that some of these troubles come from wanting to shoehorn everything into an OOP approach. The way I see it, a "service object" is just a way in Ruby to encode a procedure (or function, if it happens to be pure). The fact that you can make objects (or classes, even) callable (so the "redundant `IpnProcessor.new.process_ipn(args)`" problem goes away if you just use `ProcessIpn.(args)`) is just a nice bonus. In another language you might just `import processInput from 'processInput'` or so. The idea of attaching every "procedure" to one top-level module seems somewhat nightmarish to me, how big is the test file for that one going to grow?
I usually get stuck on the ones where they want you to make a method from scratch per se. For example, the reverse method. App Academy said to reverse the statements without using the existing method. I was stuck on that for over a month (this stuck period was when I read Ruby books) and when I finally looked at the solution I just said WTF, so I went to Coderbyte. Coderbyte let me pass using the reverse method but when I was looking at other users’ solution without the reverse method I was also like WTF. Then I buckled down and read Coderbyte’s step-by-step solution. The 4 steps made sense, the code necessarily didn’t. So I spent a few hours just trying to get what they wrote, googling what I didn’t understand. I “got” it but if you asked me to do it again I would need to refer back to the comments.
What issues are you encountering when attempting to run these commands in a shell script?
[Link to rdoc on making a cert] (http://ruby-doc.org/stdlib-2.0.0/libdoc/openssl/rdoc/OpenSSL/X509/Certificate.html#method-c-new) About halfway down the code starts with making a key and ends with a signed crt. This should help answer everything better than I can myself. 
i have no problems running the shell script. but i want to do the equivalent in ruby and avoid running a shell script all together
It sounds like you're not currently stuck on the reverse method, more unsatisfied with the path you took to get past it. Is there another exercise you're stuck on now? &gt; if you asked me to do it again I would need to refer back That's normal, I wouldn't expect to be able to do something from memory until I'd done it several times.
Try https://launchschool.com/exercises. You'll need to sign up first or login with Github. They have sections of Ruby challenges / exercises starting with the most basic. The first few hundred you can see the solutions for in the event you just can't make it work. The more advanced exercises can still be done but at that point you'd need to be a member of the site. I"m not a member but recommend the site for those exercises. The possibility of working through them successfully will give you some confidence and foundation moving ahead. The site also has an "open bookshelf" that can be useful. I read through their books on Ruby OOP and Regular expressions and found them to be useful. 
&gt; Why not just number % 10 == 5 straight away?
The [timecop gem](https://github.com/travisjeffery/timecop) is warmly recommended if you need to write specs around specific, frozen dates &amp; times (edge cases etc). If your app is heavily time-sensitive, it can also be useful to add the [javascript version of timecop](https://github.com/jamesarosen/Timecop.js) to the mix to also freeze time on the client side of your automated tests.
Thank god it’s normal! I thought I was just an idiot.😭 Now I’m on Coderbyte’s Letter Changes challenge, I’m going to try it again after taking some of the suggest tips. Hopefully I won’t get stuck. Thanks for all your advice 😊 
Join IRC, get on Freenode, and hop on the #ruby channel. We can help you get on your feet a bit. 
^ that And also, containerizing code could be a great solution to avoid all the `MyService.new.call(args)` nonsense. Such things as dry-container and dry-auto_inject actually prove to be beneficial to the cause. To use `container['namespace.service'].call(args)` is much simpler than ranting about instantiating service objects. Also, did I mention that containers can come with memoization and lazy evaluation? That stuff is awesome!
Oh just use google freely. That is not cheating, that's how most people do it. I'm a senior dev and still use Google and Stack Overflow very often. 
&gt; There's no maintainer. Good opportunity if someone cares to step up and help fix issues like these. how to get it to rubygems then?
No problem. Come back if you get stuck.
You're going about it all wrong. Most coding challenges are pretty worthless for someone in your position. They tend to emphasize algorithm design, optimization, efficiency, and obscure language tricks. These are fun little puzzles for a bored programmer, but for a beginner... that's like trying to learn English by solving riddles. Instead think about what you can **make**. As a Ruby novice you should be able to make a little text-based game, or a web scraper, or some kind of image generator ([netpbm](https://en.m.wikipedia.org/wiki/Netpbm_format) is a very easy image format to use). Working on a project like that is going to teach you so much more than any coding challenge.
**Netpbm format** A Netpbm format is any graphics format used and defined by the Netpbm project. The portable pixmap format (PPM), the portable graymap format (PGM) and the portable bitmap format (PBM) are image file formats designed to be easily exchanged between platforms. They are also sometimes referred to collectively as the portable anymap format (PNM), not to be confused with the related portable arbitrary map format. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Can we just call them command objects and move on with our lives? I can't tell you how many teams I've come across that confuse services as in "microservices" for services as in "service objects."
I don't think there's anything about `ProcessIpn.(args)` that is _not_ OOP. Objects should expose behaviors and encapsulate state. If anything, it's all the ActiveRecord models in our rails projects that _aren't_ OOP.
I would be inclined to agree with you, except if you read through the comments on the article itself he specifically calls out how this still isn't *really* testable. His excuse is something along the lines of "this feature can only be tested with integration tests."
I was wondering about this as well... He calls out how `ProcessIPN` and `RedeemProduct` aren't related. OK. Neither are `MyCoolApp.process_ipn` / `MyCoolApp.redeem_product`. Sure, with *just* those two methods defined in the module namespace, it's simple, and you can probably see that there's a (very loose, triggered by different requests/code paths) "relationship" between those two methods. Cool. Now, let's come back to the real world, building a real app, and add twenty-something more service methods to that namespace in that same file. Now tell me what's related to what, without comments pointing you there, and how you're going to manage this pattern at scale (both for code organization and testing). Pretty sure you'll just end up with a nearly identical directory/file structure, just opening up the same module over and over again, and polluting it with methods that are all loosely related because they're in the same app.
Right? I genuinely don't see how this is different structurally. It's not really any more or less testable. Once you add more than the two example methods you're going to desperately want to start breaking that 500 line module definition into multiple files... probably stuff like `/my_cool_app/process_ipn.rb` defining `module MyCoolApp; def process_ipn; end; end` and suddenly all his reasoning for this organizational structure falls apart.
I agree with what you're saying here, many times what you see in a Service Object is actually the Command pattern or some other pattern. But, I don't think that renders Service Objects obsolete. I am not sure where I picked this up, but my understanding of Service Objects was that they should exist at the network boundary of your application. Meaning, if you need to make repeated calls to an external thing over some network layer that a Service Object gives you a place to host this code, to re-use it, and to isolate it for testing purposes. The "big" benefit that seems to be pushed in the Rails world are the second-order effects it has like cleaning up your controllers. This is how I've been using Service Objects for... well, for a very long time now. As a result, I feel like I have a nice, re-usable pattern that, while it is heavily leaned upon in the applications I build, tends to only accumulate a couple of different modules/classes over the course of the applications life.
Well, this really comes down to what you consider "OOP" for which nobody ever seems to be able to give an authoritative definition. It is "OOP" by virtue of it being some message sent to some object, yes (and this is only because in Ruby, classes are objects, it would not be considered OOP in, say, Java). The question is whether there is really any significant difference, outside of syntax, between `ProcessIpn.(args)` and `process_ipn(args)`, assuming there was some way in Ruby to import procedures from other files the way it's possible in non-OOP (or less strictly OOP) languages? Honestly, I don't know. I feel like everyone keeps saying "proper OOP", but I've never seen that implemented anywhere in practice, and nobody can tell me what that's really supposed to be. I would prefer it if we phrased discussions more in terms of practical tradeoffs rather than in "this is not pure OOP" or (on the other side of the fence) "this is not pure FP and anyway you should use a monad transformer".
The same could be achieved with a class method, which is all the procedure inside a module is. You could define a fluent interface on the class-style more easily by naming the class as the action, instead of as a noun, like this: class ProcessIpn def initialize(*args) # Setup end def process # Do stuff... end def self.with(*args) processor = new *args processor.process end end Then invoke it like this: ProcessIpn.with whatever, args This is preferable to me in comparison with the approach advocated. By changing the class name to a verbal form you can align it with the actions that should be defined in the domain's ubiquitous language along with the things within the domain.
1. You submit fixes and PRs to the current maintainer to show capability. 2. You ask the maintainer if they would either restart maintenance or step aside and let someone else take over the project. 90% of the time, they will if you show the interest and capability to do so. 3. You merge your changes and push a new version since you are now the maintainer.
I've always heard such objects referred to as "gateways." I'm of the persuasion that "gateway" will lead to less ambiguity, since "service" is already overloaded so much.
&gt; Well, this really comes down to what you consider "OOP" for which nobody ever seems to be able to give an authoritative definition There is some good reading here, from the person who coined the term: https://softwareengineering.stackexchange.com/questions/46592/so-what-did-alan-kay-really-mean-by-the-term-object-oriented &gt; I would prefer it if we phrased discussions more in terms of practical tradeoffs rather than in "this is not pure OOP" or (on the other side of the fence) "this is not pure FP and anyway you should use a monad transformer". I don't even believe that FP and OOP are opposing language paradigms. OOP can be done in an FP language, for instance. Class oriented programming, on the other hand, is very incompatible with FP, and I think a lot of people mistake class oriented programming for object oriented programming. &gt; The question is whether there is really any significant difference, outside of syntax, between ProcessIpn.(args) and process_ipn(args), assuming there was some way in Ruby to import procedures from other files the way it's possible in non-OOP (or less strictly OOP) languages? If I put a file that defines `ProcessIpn.(args)` somewhere in ruby's load path, and then `require` it, haven't I just imported a procedure?
Hey, that's nice and that makes a lot of sense to me, thanks!
Just don’t freeze time in specs to avoid hitting edge cases, people always do it. Freeze/travel in order to test the edge case specifically.
skamansam was showing an example of how to use "code-like language" not giving showcasing ruby functions.
Hard to say. Maybe you need a different teaching style, like an in-person class instead of a self-driven tutorial? Maybe there are programming classes available at your local community college for cheap? It doesn't matter what language the courses are in. The problems you are having are related to learning how to "think like a programmer", computational/algorithmic thinking, not the language specifically. It's possible just switching languages will help, it's worth a try, but I suspect not, if you're still doing self-guided online tutorials for em. 
Yeah. Screw me for pointing out you can make the logic easier and more understandable.
Thanks for the pointer. I'll try to read that at some point. At the same time, it doesn't seem like that that is anywhere near the kind of definition that anyone seems to be using or anyone even is familiar with; come to think of it, maybe Erlang comes closer to it than "conventional OOP languages" do. Even then, my point still stands: I'd rather know *why* (or why not) I should make something conform to a "OOP / FP / something else" paradigm than simply "because Alan Kay or Simon Peyton Jones said so" (not that I'm accusing you of this). &gt; I don't even believe that FP and OOP are opposing language paradigms. That probably ends up depending on definitions as well. There are definitely different definitions of FP too, ranging from "anything dealing with higher order functions" to "only pure mathematical functions without side effects". Also, I'm curious, why do you think FP is incompatible with "class oriented programming"? Depending on definitions, Scala could be counted as an exception. &gt; If I put a file that defines ProcessIpn.(args) somewhere in ruby's load path, and then require it, haven't I just imported a procedure? In effect, yes, which I think was my point: we use a class, because we kind of have to in Ruby (unless we use a module), but we don't really use any kind of OOP feature in this case.
Better to start here, it encompasses all of the above and more (but with a SHA1 hash which you should swap to SHA256): http://ruby-doc.org/stdlib-2.0.0/libdoc/openssl/rdoc/OpenSSL.html#module-OpenSSL-label-X509+Certificates
Yes, I don't mean abstract in pure mathematical sense but nearer to what u/skamansam wrote. I found [this coding exercise](https://prepwork.appacademy.io/coding-test-1/practice-coding-exercise/) for the App Academy prepwork. There is one practice called "lucky_sevens?" which ask: "Write a function lucky_sevens?(numbers), which takes in an array of integers and returns true if any three consecutive elements sum to 7." - how would you go about that? Spoiler: Here is what I would do if I didn't knew Ruby well (the reason for this constraint is at the end of my comment): * First: What is the input? When is it valid? Since we need at least three elements in the input array, all other arrays can be ignored and false returned. You *could* also check if the input is an array but this is not done in most cases. * So, now we have got an array with at least three elements. It is clear that we need to iterate over the array in some way. And while iterating we need to access/store three consecutive elements to sum them up. Hmmm... do we really need to store three elements? What if the requirements change and we would need to sum 10 consecutive elements? * Thinking about this probably leads you to the idea to just store the sum and the first number. For the next sum, we would then just need to subtract the first number and add the new number. (Reasoning about the performance is not asked in the exercise but we would need to store two numbers -- sum and first_number -- and per iteration we would need two operations -- one subtration and one addition.) * Once we have a sum we need to check it if it is equal to seven. That's easy. * So now we know how to get the sum in each iteration. Next question is: When to start and stop the iteration? Stopping is easy: If we have a sum that is equal to seven, we return true. And if there are no more elements in the array, we return false. * Defining the start point also seems easy: Since the array has at least three elements, we create our first sum of the three elements and let first_number be the first element. Or do we? If we do it this way, we would need to check whether sum is seven and if not, start the iteration process with the *fourth* element in the array. * So we have this check once before the iteration and once in the iteration. Can we do better? Yes, yes we can. We use an a standard trick that is often applied on problems with boundaries: We pretend that we have one more element than we really have by virtually inserting 0 as 0th element, summing up 0, the first element and the second element (see: three elements) and setting first_element to 0. Then we start the iteration with the *third* element. This way the special boundary behaviour is turned into a non-special behaviour. Now that we have laid out our algorithm implementing it in any language is straightforward. However, *if* you already knew Ruby well you would remember that there are `Enumerable` methods for returning only parts of an array, `Enumerable#each_slice` and `Enumerable#each_cons` come to mind. The first returns non-overlapping, consecutive slices (e.g. `[1, 2, 3, 4].each_slice(2).to_a == [[1, 2], [3, 4]]`), the second one is the one we need. With it the exercise is reduced to `ary.each_cons(3).map(&amp;:sum).any? {|i| i == 7}`. This is not the best performing implementation but certainly one of the easiest and clearest ones.
Yup, screw you for not being at the correct abstraction level .
Thank you for your example 😊
I always thought Service objects should be called like `MyService.new(args).call()` ? That way you can instantiate them whenever and call them at your convenience.
I know exactly how you feel. I was in the same place at the start of my tech sector career. And I can hold out a bit of hope for you. I have been coding professionally in many different languages and styles and contexts for about 25 years, and I can safely say that after all that time &amp; practice, I very occasionally have a glimmer of insight that I might, one day, know what the hell I am doing. Patience, grasshopper. 
If all the peanut gallery sledging this article had an inkling of style, they'd realise this is a opening teaser intended to motivate something much more useful and is just the start of a train of thought. Pretty sure Avdi is going to throw out the junk-drawer approach in subsequent installments, raise the analysis meta-level to think more clearly about the problem domain, and refactor it into persistent state-machine process models and injectable/composable objects for policy &amp; side-effects. Which is what everyone writing so-called "service objects" to contain business rules should probably be using to begin with. 
I guess it depends. If you pass a service object around, then yes, `s = MyService.new(args)` and later `s.call` is okay. However, if you are always just using `MyService.new(args).call`, what's the benefit? I only see the problem that you need to know `::new(args)` additionally...
This benchmark can't tell you whether you should use strings or symbols for your hash keys because it doesn't measure the cost of lookup up a value when your key is the wrong type. In fact, no benchmark can do that because you need to balance the cost of creation against the cost of lookup and the frequency of lookup for your particular application. The best thing has been to always use the same type of hash key as the data source you're using for lookups. If you're getting values from user input, usually that is Strings. If your values come from another part of your library, maybe that is Symbols. Benchmark tl;dr: converting keys to look up values in a Hash is slower that using the "natural" key type. ``` $ cat t.rb require "benchmark/ips" STRING_KEYS = (1..1000).map{|x| "key_#{x}"}.shuffle FROZEN_KEYS = STRING_KEYS.map{|x| "fr_#{x}".freeze} SYMBOL_KEYS = STRING_KEYS.map(&amp;:to_sym) # If we use static values for Hash, speed improves even more. def symbol_hash SYMBOL_KEYS.collect { |k| [ k, rand(1..100)]}.to_h end def string_hash STRING_KEYS.collect { |k| [ k, rand(1..100)]}.to_h end # See this article for the discussion of using frozen strings instead of symbols # http://blog.arkency.com/could-we-drop-symbols-from-ruby/ def frozen_hash FROZEN_KEYS.collect { |k| [ k, rand(1..100)]}.to_h end SYMBOL_HASH = symbol_hash STRING_HASH = string_hash FROZEN_HASH = frozen_hash def lookup_symbol_hash_from_string SYMBOL_HASH[STRING_KEYS.sample.to_sym] end def lookup_string_hash_from_symbol STRING_HASH[SYMBOL_KEYS.sample.to_s] end def lookup_string_hash_from_string STRING_HASH[STRING_KEYS.sample] end def lookup_symbol_hash_from_symbol SYMBOL_HASH[SYMBOL_KEYS.sample] end Benchmark.ips do |x| puts "Lookup" x.report("Symbol Hash, Symbol Key") { lookup_symbol_hash_from_symbol } x.report("String Hash, String Key") { lookup_string_hash_from_string } x.report("Symbol Hash, String Key") { lookup_symbol_hash_from_string } x.report("String Hash, Symbol Key") { lookup_string_hash_from_symbol } x.compare! end $ ruby -v t.rb ruby 2.4.2p198 (2017-09-14 revision 59899) [x86_64-darwin17] Lookup Warming up -------------------------------------- Symbol Hash, Symbol Key 259.197k i/100ms String Hash, String Key 231.953k i/100ms Symbol Hash, String Key 203.959k i/100ms String Hash, Symbol Key 197.515k i/100ms Calculating ------------------------------------- Symbol Hash, Symbol Key 6.998M (± 2.9%) i/s - 34.992M in 5.004735s String Hash, String Key 5.407M (± 2.4%) i/s - 27.139M in 5.021924s Symbol Hash, String Key 4.018M (± 1.5%) i/s - 20.192M in 5.026624s String Hash, Symbol Key 3.788M (± 2.2%) i/s - 18.961M in 5.008168s Comparison: Symbol Hash, Symbol Key: 6997934.0 i/s String Hash, String Key: 5407394.5 i/s - 1.29x slower Symbol Hash, String Key: 4017928.8 i/s - 1.74x slower String Hash, Symbol Key: 3788016.8 i/s - 1.85x slower ```
The default should be hash with indifferent access. Allowing symbols and strings to form different keys causes tricky to find issues - especially in cases where you tested with symbols (and/or use symbols in the logic) but production uses strings - like with params in Rails. I've seen no case where there is benefit forming different keys for h[:a] and h['a'].
Yup, this is especially true in ruby, where we have fantastic tools (sometimes overused, admittedly) for sprinkling just a little bit of "magic/meta" in there to make the interface a joy to use.
Cool stuff indeed! I have two questions: how is this incompatible with rack &lt; 2? and how difficult would be to use this outside of the rack context? 
or: you just fork the project and define a new project name to be published into rubygems (ex: net-sftp2) 
Welcome to ruby :) The error is actually pretty helpful once you realize what it is saying. The error says you're trying to compare a "String" and `10`. The `10` part is pretty obvious, you can see it in a couple places in your code. So where does the "String" come into play? Well, what are you comparing with `10`? `fnum` So `fnum` must be a String, right? Indeed if you do `puts fnum.class` you'll see this is the case. What class is 10? `Integer` For the purposes of this program, you probably want to convert the user input from `gets` into an integer as well. That way you're not comparing proverbial apples and oranges :) Fortunately ruby has [`to_i`](https://ruby-doc.org/core-2.0.0/String.html#method-i-to_i) which will convert a string to an integer. --- Hopefully that helps. Asking questions is an A+ way to learn so you'll get no criticism from me for asking. But as a suggestion, I'd encourage you to continue to read the error messages thoroughly. The error messages in ruby aren't great but if you slow down and take a step back to try to understand them, they're often good enough. I hope you enjoy your ruby journey.
Alright, great. Thank you for your help! I appreciate it. 
&gt; The default should be hash with indifferent access. That would completely destroy a lot of Hash use cases. What needs to happen is getting rid of `Symbol` completely. `{a: 2, b: 3}` should just be two frozen `Strings`. There's a bit of code this change would break, but nowhere near as much as number of pointless `to_sym` / `to_s` and other shenanigans this gets rid of. 
Interesting post Chris 👍