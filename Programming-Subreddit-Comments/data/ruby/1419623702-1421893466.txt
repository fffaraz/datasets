Heh... as a middle aged dude that's been programming since age 10 with his Commodore 64, y'all need to hear this: **Get used to this feeling.** You know how many languages I've loved and mastered, and then watched them slowly fade away? My advice: master each one, learn its cool nuances, get good at it, but don't ever let a language, framework, or API define your competence. You're an engineer first, and a code slinger second. If you reverse those, I can assure you that's the fast track to management incompetence/irrelevance. Hey, if you **want** to be a manager, then by all means, move along, but those of us who've decided to define ourselves as engineers would just as soon you hurry it up, because your love-slave-to-a-language stuff cramps our style. You get in the way with your obsessions... "hobgoblins of a small mind" and all that...
Well, fix it faggot. 
Try using the -I and -r flags for rspec. -r requires a file and -I adds paths for rspec to lookup. I tried to replicate the problem, but it looks like its working on my machine. (im using a mac). Aslo, you can try ruby koans which looks like it has a windows version.
I haven't worked w/ Ruby on windows in a very long time, but the following error leads me to believe there is a problem with the base path having spaces in it: &gt; `load': cannot load such file -- D:/004 (LoadError) Which is probably because the following commend does not escape the space between -ID:/004 and Leren/ towards the end. &gt; C:/Ruby193/bin/ruby.exe -S rspec D:/004\ Leren/Ruby/learn_ruby/00_hello/hello_spec.rb -ID:/004 Leren/Ruby/learn_ruby/00_hello Now, this is not a fix, but a temporary lame workaround (would need to look into this deeper for a true solution): move the project to a path that doesn't have spaces in it.
Not yet. What feeds for Green Ruby are available?
Precisely. Languages are *tools*. Ruby's emergence, along with Python, was serendipitous because they exploited a niche that was ripe for disruption. In the '00s, the web languages were Java and PHP, and Java 6 (which was a significant improvement) wasn't released until 2006. Java didn't even have generics until 2004. In this environment, any halfway decent language was a breath of fresh air. It felt like *freedom*, and Ruby and Python thrived. However, Ruby and Python, like all tools, have weaknesses. Both are slow. Both suck at parallelism. Dynamic typing is pretty terrible when you start to get around 100k lines of code (or even before). Lack of interfaces means complex systems are hard to keep clean. This means that other languages have emerged to exploit the *new* niches. I think that in a few years the emergent languages will be excellent for parallelism, with strong first-class abstractions (Clojure's channels, Erlang's actors, etc.) and immutability/purity of functions (Haskell, Clojure, Scala, etc.). Python and Ruby will continue to exist and be used in certain niches, but I really think the era of the dynamic, interpreted language as the dominant paradigm on the server is nearing an end. Heck, at this point, I feel better using Java 8 than I do using Python.
Both the language ... and ...? The suspense is killing me!
I've found Clojure to be fun to work with. Though I don't think I'm one of the cool people.
This is part of a series I started in summer where I work through http://exercism.io/ exercises and then use them to talk about design/refactoring/whatever. Hope you enjoy.
Thanks! Hadn't thought of that. Will remove all spaces and try again. If that fails I'll turn on my old MacBook and hope it doesn't set itself on fire. 
Thanks! Will google ruby koans. Remove all spaces from paths and file names and if that doesn't help switch to my MacBook and hope it can deal with it. 
I'm not a huge fan of the solution they provide for this. It works perfectly fine and is readable for the test cases but if this were for some other application where you had to swap values like this I think it may be annoying to add new values. I like your interest in incorporating a bunch of Ruby's features into the solution but I wonder if you're making the problem more complicated than it needs to be. At essence what we need to do is look up one value based on another and vice versa. This can be very easily accomplished with a hash. This is what I provided for it: module Complement def self.translate strand, key strand.chars.map { |n| key[n] }.join end def self.dna_key { 'C' =&gt; 'G', 'G' =&gt; 'C', 'T' =&gt; 'A', 'A' =&gt; 'U' } end def self.of_dna strand translate strand, dna_key end def self.of_rna strand translate strand, dna_key.invert end end I like this solution because there is only one place to go to add new values to the key if need be. My intention here was to keep things simple.
I use it for my Rails projects also. Using `bin/rails` isn't that hard. Even that I have aliased `rails` to `bundle exec rails` and this is security and doesn't pollute my global gems. 
I'm holding out for the "Pattern Matching in Elixir for Rubyists writing Cofeescript" article.
Whoops, was going to be "both the language and the implementations". Decided to broke the idea into another paragraph, didn't clean up the edit. I should really set up a git repo of my internet comments so people can file bug reports and pull requests.
I believe that node will slowly take over the place of Ruby in the public internet backend development world, where Ruby seems to be most implanted. The advantage of doing both the backend and the frontend in only one language is too big to be dismissed. Node as initially taken over projects where there is a real-time component for example games/websokets based applications. But now the node ecosystem is maturing, and the community is increasing each year. There is no clearcut big web development framework like Rails, but several candidates like express or something more full stack like sails.js. The tendency seems to be to use node to build backends in projects where before Ruby/Rails was being used, and that tendency seems to be on the rise. 
Node body wants to code servers in js.
Then other programming language is going to get invented and they will move to that as well
[InfraRuby is a statically typed Ruby compiler](http://infraruby.com/live): valid InfraRuby programs are valid Ruby programs.
wth is this
To me that doesn't sound particularly useful, but its absolutely fine to make a non useful gem for fun and learning.
yes it is. http://www.nokogiri.org/ also https://github.com/sparklemotion/mechanize
Ruby isn't just Rails, people are building all of those "future things" you say will replace Rails in Ruby as well as JS. Checkout http://voltframework.com/
Totally a non sequitur, but I found in the documentation for nokogiri &gt;XML is like violence - if it doesn’t solve your problems, you are not using enough of it. 
Try breaking it up and write a service w/CLI to that uses your gem.
yeah for me i think its an exercise in learning. its been pretty useful while ive been looking for gigs on r/forhire, as ive got it running every minute and i get a jump on a new post that meets my criteria.
yeah i think if i move forward with it as a gem it will essentially function as a console app. i'll create a menu list in the console that will allow very basic choices, at least to start, such as subreddit and cron frequency. and then i'm leaning towards including some instructions in the README that tells a user how to initialize the app. 
Ruby owns the "developer happiness" space for me. It's catalogue of gems, and online documentation eco-system will take a lot of beating for the type of stuff I do (business web apps)..
Definitely use any excuse to write your first gem. Also think in terms of writing a library which is maximally useful for others. For example, the library API would have a generic call, and through config or introspection determine Mac and dispatch to `say`. Or maybe dispatch to `say` is handled by an executable in bin/
Yeah, in all of my Exercism posts I intentionally take things farther than I really need to. Mostly to emphasize a point. That's what I find interesting about Exercism, actually. It's trivial to get most exercises to pass, so how far do you want to push your code after the feature is "done"?
I'm glad he brings up Node. I've been coding in Node recently at work, and after spinning up a Rails project after work the other day, I'm reminded of just how much I prefer Ruby. It being dead is definitely news to me. 
Because ruby developers have already finished their tasks for the day while other developers are on SO. ;)
Becaues reddit is a collection of millions of people, and within those millions of redditors are people who like ruby. The same reason "reddit" likes python, .net, COBOL, BASIC, java, PHP, cats, dogs, ferrets, banana ice cream and satanism. 
Beat me to it! These two make it super easy to throw together a crawler.
but it seems that there are more redditors that use Ruby over other languages. I'm just curious as to why that may be so. 
do'h - my bad. I think it's because I subscribed to /ruby and didn't realize. Hence I am seeing ruby posts. Good call and sorry for my incompetence. 
How well does Nokigiri compile on Windows? I know it's kind of a pain in the ass for me on OSX and some of the Linux boxes I've tried to install it on.
Punk is dead.
Did dis dude jus did dis? 
Yeah， came here to say this
With ruby you will find joy.
The purpose of exercism is to educate and learn. The solution the author provides serves that purpose splendidly. It's a good demonstration of Ruby's object model. Often you'll write code with a much more pragmatic purpose. To serve pragmatic purposes, it's useful to provide the simplest solution that can possibly work. The canonical solution does that.
There's a lot of other interesting tech aside from Elixir. E.g, Clojure, Scala, OCaml, Haskell. Hell even swift if you like your walled gardens.
Don't be! It happens.
Added. Thanks. Cheers.
I removed all spaced from the path - seems to have worked! (yay!)
Tsssss! Keep this secret to avoid risks of Ruby being banned for firet class rsa cracking abilities.
&gt; The planet subscriptions (feed lists) are split into seven sections (sub planets), Sub planets? Like moons, or like continents?
It takes some time until you finnd out the details of how reddit works. If you want some slightly better idea how many people are interested i some language have a look at the umber of subscribers to the related subreddit: - Ruby: 26,178 - Python: 87,362 - PHP: 33,690 But this too is not that reliable.
The irony is that Gem authors take great pains to follow _actual_ semantic versioning (whether it matches with that website or not). This benefits everyone as we create an ecosystem of reusable components.
How is that even possible?
Whats JRuby? 
I don't know about the current ruby but the old ruby was historically really bad with numbers. It didn't really do unboxing for them so numeric calculations like 2 * 3; would translate into a full object 2 and a full object 3 and the multiplication would be something 2 object .multiply(3). So an additional method call on top of the object unboxing. My guess is that ruby has gone and done what most languages do, it is representing numbers as numbers and the operators on them is JITed to some reasonable set of instructions which don't have pointer dereffering or method calls.
 Cracked phrase is: kick it, CC That output shows it's successfully cracked the encryption.
If you have javascript work it is quicker than selenium with Capybara. 
Good question. Maybe like moons? All seven (now nine) sections have different feeds (and thus, different articles/posts/items). Cheers.
Sorry, I had just given the code a quick once over. I'm still highly suspicious (as should you be) with such massive performance improvements. After running the code a few times with 2.2 there is huge variance in the run time (2s - 50s) so I would not be jumping for joy too soon.
Yes, there's a huge variation in the time it runs for if you look at the number of intervals it has to run. I should have mentioned - I only included results that were able to be determined in a single interval in the results for both tests. They are the shortest to run.
Isn't there a way for us to pass a seeded value to OpenSSL so we can properly benchmark it?
Yes, but 90% of the time you can just emulate the request issued by the script, manually, without having to rely on a browser engine to do it for you (which will load tons of unecessary libs and stuff in order to run a single script).
haha I can try over 5 billion hashes per second using both my video cards with oclHashcat. The direction of high performance crypto is not Ruby. This is just a cool benchmark.
I'll look at Clojure again when it's not as dependent on the JVM, but in the meantime I like syntax AND macros. :) I have a really good friend who's been trying to get me into it (I LOVE Rich Hickey!), but Elixir seduced me away... Scala looks to be a swiss army knife of buzzwords, I think if a language tries to satisfy too many philosophies then it's going to suffer from too much complexity and maintenance down the line (I think Clojure has this problem to some degree, too... these two can "do OO" and "do functional" and can store plenty of state all over the place which is very OO-ish, it's trying to make everyone happy, maybe due to the Java heritage/VM) Haskell... Haskell, I like. I kind of dislike strict types (even though it leads to fewer runtime bugs and more optimizable code), but I can't argue at all with the strict separation of side-effect-free code from side-effect-causing code (the IO monad, basically) and think that every language that can should adopt this, because these two types of code are fundamentally different and should be treated differently IMHO. "Model code" vs. "interface code." I also like how every function is automatically curried (at least, if you come from Ruby) which leads to some nice compositional code. Haven't done anything with OCaml, although I believe other languages have borrowed some ideas from it. I mostly settled on Elixir because it sticks to a small number of time-tested philosophies, feels like Ruby, acts like a functional language with immutable data, has neato pattern-matching, is *severely* concurrent (thanks to the Erlang VM), embraces failure, looks like the Actor model (which is "the way forward" in a future concurrent decentralized world, IMHO), has simple primitives, creates useful new conventions which both simplify code as well as mental load (such as the first argument of all functions being the "thing acted upon"), etc. And lastly, Dave Thomas led me to Ruby with the very first Pickaxe book, which led me to much success, and he's hooked on Elixir, so I guess I'm following Dave Thomas AGAIN. :)
Woah, sounds like black magic !
The only way you can compare the runs is if p and q are always the same value for each run. Otherwise it makes no sense. (There may be other random values in there, I stopped looking when I found those.)
Why use modules and class methods? I've never understood people who program with those constructs. Where's the object orientation?
The problem doesn't really call for "object orientation." The tests showed usage such as: `Complement.of_dna`. I suppose I could have put these methods in a class but I generally don't do that if that class will never be instantiated (from the tests it is clear that it is not).
OMG! That's going in my *must keep* archives.
Travis is nice but fucking expensive if you need to run it on your own project. We have switched to CircleCI for our closed projects, but they don't support matrix builds (builds for more than one version of Ruby), so right now we are a bit stuck. I do favor their interface. Shippable.com offers matrix builds, and have a sane pricing model, but their product is horrible and buggy, specs would randomly fail, not report back to Github, and especially jruby had issues even starting. So we run Travis for our opensource projects (targeting most versions of Ruby), CircleCI for our closed projects (only targeting one version of Ruby).
Thanks for the info! How is the experience getting started with CircleCI?
[exit](http://www.ruby-doc.org/core-2.2.0/Kernel.html#method-i-exit) [exit!](http://www.ruby-doc.org/core-2.2.0/Kernel.html#method-i-exit-21) 
What kinds of projects do people use Elixir for?
Oh my God. Meaningless variable names. Unnecessary instance variables. Obfuscated and redundant conditionals. I feel like I'm reading Perl.
/r/shittyprogramming /r/badcode
I can handle `n` as the parameter, since it's a mathematical function, but `@i` and `@rt` break my heart. But yeah, the structure of the conditional tree and the use of `for` instead of an `each` loop really seem to be the bigger offenders.
Man, I am so sorry that I don't know enough about programming that I could actually help you out by explaining your mistakes or pointing you to good reference material. Apparently it seems like if I ever get to that elitist level I'll be more interested in belittling your efforts to show everyone how smart I am than I would be in helping you. 
I think it's still kind of new but my guess is that any one using Erlang might benefit from taking a look at Elixr in the near future. And there are a lot of people using Erlang. One example that comes to mind is League of Legend chat is powered by Erlang.
I don't have the time to type up a full explanation, but instead of rudely telling you that your code isn't the best, here are two variations on the same problem. # if I'm feeling fancy def factorial n raise "n must be an integer" unless n.is_a? Integer raise "n must be nonnegative" if n &lt; 0 1.upto(n + 1).reduce(:*) / (n + 1) end # if I want to write readable code def factorial n raise "n must be an integer" unless n.is_a? Integer raise "n must be nonnegative" if n &lt; 0 product = 1 1.upto(n + 1) do |i| product *= i end product / (n + 1) end Of course, I could add some comments as this algorithm is somewhat atypical, but you get the idea. If you have any questions about what's "wrong" with you code or why I changed what I did, please reply.
No need to supply `inject` with a starting point, as it will just take the first value. I'd also argue that it isn't a `RangeError` but an `ArgumentError`, but that's up to the individual programmer in my eyes. def fact(n) raise(ArgumentError, "n cannot be negative") if n &lt; 0 (1..n).reduce(:*) end Normally you'd have to give `reduce` or `inject` a `Proc` (`&amp;:*`), but it actually casts it to the `Proc` itself.
Ah, I see your reasoning behind that now.
That gives the wrong result for `n = 0` (`nil` instead of `0`), which is the reason I gave a starting point for inject. In the case of `n = 0`, `(1..0)` is emty, and `reduce` called with an empty enumeration returns nil without a starting arg.
Hm. I'm a beginner to Ruby myself and I don't get the feeling that it's code from someone that just finished the find-them-everywhere interactive tutorials. Seems like OP isn't new to programming, just this specific language. Probably used to writing code like it was posted above. I mean, look at that explicit return. That's a learned behavior that I shudder at the thought of doing in Ruby. You don't pick that up from Ruby resources, if anything you'd be shown the exact opposite and won't even know about explicit returns until you look at someone else's code. AND and OR keywords? Ew. From the perspective of someone that's used to coding as above it probably *does* seem like a better function even though it doesn't utilize any of the language's more powerful features and reads like a horrible mess to everyone else. Even so, I wouldn't be surprised to discover OP intended it to be a helpful post.
Bah! Who needs 0! anyway... oh what's this video about again? /brainfart
That overmultiply then divide thing is icky. Better to fix the input to a minimum of 1, if you're going to do it that way. You could use something like [1,n].max, for example.
There's already a gem for that: https://github.com/vanruby/canada
No.
Well, I'm not the /ruby police it just seemed harsh. Pointing him to a beginner book would definitely gotten the point across. Pointing to a 200 level book/post that you know would have helped too. Don't get me wrong, I appreciate you guys reading and commenting on beginner's posts but you're terrifying some. 
I think the "overmultiply" is specifically what OP was going for. I only watched a minute or two of the video, but my understanding was that the point of it was to provide a definition of `n!` that would be consistent for zero. If you say that n! = 1 * 2 * ... * (n - 1) * n = (n + 1)! / (n + 1) you can calculate `1!` as `1` and then apply the second definition to see that `0! = 1! / 1 = 1` (the subject of the video). As I hinted above, this is not the way you do or should see factorial implemented in any language, but this was the point of OP's post (I think?). `[1, n].max` seems icky to me. /u/nanothief's `(1..n).reduce 1, :*` is what I would've written.
Must have been a pretty nice bootcamp.
I could be mistaken but I don't think you need to use the `puts` in the `eats` method. Just putting the string there will return the value, if *I* understand correctly. **EDIT** https://eval.in/237802
Who actually *loves* COBOL?! I'd like to meet these sadistic bastards.
\#inspect is the equivalent to `var_dump()` in PHP?
It depends on your intention. If you intend for that method to output the string to STDOUT, then `puts` would work. Note that methods implicitly return the last value if there is no explicit return, so in this case the `eats` method is going to return `nil`, since that is the return value of `puts` and is the last value made by the `eats` method. 
You're sort of right but there's a more complete story. You don't need a class to define a method: def eats puts "That tasted great!" end eats # This will print "That tasted great!" Sometimes you want to group several methods together for use in several places, that's where modules come in: module Food def eats puts "That tasted great!" end def drinks puts "That tasted pretty good!" end end include Food eats # This will print "That tasted great!" drinks # This will print "That tasted pretty good!" Modules are used for much more than this, but I won't expand here because the question was about classes. Class are like a blueprint for objects. You used it correctly, the `new` method creates a new instance and a class can have numerous instances. One of the core distinctions for Classes/Objects is that they can contain more than just methods they also have state (generally called attributes: class Candy def initialize(taste) # This is the 'new' method @taste = taste end def eats "That tasted #{@taste}" end def drinks "That tasted pretty good!" end end chocolate = Candy.new("great!") warheads = Candy.new("sour!") puts chocolate.eats # This will print "That tasted great!" puts warheads.eats # This will print "That tasted sour!" Now the code in the class shares a lot of common logic but because each instance contains it's own state they can behave differently. One final thing, instead of using puts inside the method in the class I used it when I called `Candy#eats`, this is generally considered much better form as it doesn't offload presentation to the Class. Don't worry about that too much now, but getting in the habbit of not using puts/gets in your classes now will pay off later.
Depends what you want it to do. If you want to the class to print the string, you need `puts`, if you want it to return the string, you should not. Printing and returning as not the same thing.
At a basic level you are correct. You use them to logically group code together to be reusable. But in another sense you don't want to treat them like templates. They are objects, and you are defining the behavior and state (variables) of that object using your class definition. So different instances of an object can have different state, but have the same behavior. class Chocolate attr_reader :type def initialize(type_of_chocolate) @type = type_of_chocolate end def eaten puts "That is some tasty #{@type} chocolate" end end chocolate_1 = Chocolate.new('milk') chocolate_2 = Chocolate.new('belgian') puts chocolate1.eaten =&gt; 'That is some tasty milk chocolate' puts chocolate2.eaten =&gt; 'That is some tasty belgian chocolate' Another idea of grouping code together in Ruby is a module. A module doesn't have any state or behaviors, it only has simple functions that you can add into your program and call. module Foods def eat_chocolate puts "Mmm that is tasty" end end 
Yeah, I would think you wouldn't want a class deciding when to print something out. Return the value *then* decide whether to print it.
Nonsense. That would depend entirely on the situation.
Sure, more or less, I guess. 
This might be a bit more advanced than what OP was asking for, but I would have mentioned that a class of Chocolate shouldn't have a method called `eats`, as it is not the responsibility of the chocolate to be eaten.
&gt; subclassing Hash in general is perfectly valid. I disagree. I've never seen a single hash subclass that wasn't a memory or performance bottleneck and couldn't have benefitted from a cleaner interface. I've provided you with about 3 examples of real world use cases (Rack, Hashie::Mash, HashWithIndifferentAccess) that cause problems, as has Tenderlove. Please provide me with 3-4 valid (and real world) use cases for subclassing hash, that can't be accomplished better somehow else. 
I opened https://github.com/intridea/hashie/issues/257, we can discuss what/why and whether this can be improved there.
&gt; subclassing Hash in general is perfectly valid. I disagree. I've never seen a single hash subclass that wasn't a memory or performance bottleneck and couldn't have benefitted from a cleaner interface. I've provided you with about 3 examples of real world use cases (Rack, Hashie::Mash, HashWithIndifferentAccess) that cause problems, as has Tenderlove. Please provide me with 3-4 valid (and real world) use cases for subclassing hash, that can't be accomplished better somehow else. 
For anyone landing here late, performance fix in omniauth without removing dependency on Hashie::Mash - https://github.com/intridea/omniauth/pull/774.
Sorry, yes. I using `Hashie` as a synonym for `Hashie::Mash` in this article and the majority of my comments.
California DMV...
I'd recommend picking up a good language overview for understanding some of the nuances around modules, but the short answer is they are for organizing re-used code that doesn't define a class. That could mean the exact thing I showed above, just a group of methods that fit together in some logical unit, but they have some other uses as well. Possibly the most common other use would be for "mixins", as unfunco pointed out code could be better organized to move the `eats` method out of the `Candy` class. In my opinion it's debatable whether the method should be moved out of the `Candy` class, but for the sake of argument let's assume you also have a `Fruit` class: class Fruit def initialize(taste) # This is the 'new' method @taste = taste end def eats "That tasted #{@taste}" end def whatami "A fruit!" end end Now there's a common method of `eats`, traditional OO languages would suggest a parent class and inheritence, something like: class Food def initialize(taste) @taste = taste end def eats "That tasted #{@taste}" end end class Fruit &lt; Food ... # Rest of class here end class Candy &lt; Food ... # Rest of class here end Another popular opinion is that inheritance can get confusing (composition is frequently the answer here and you should read up on composition over inheritance) another potential solution is a "mixin" via a module. module Food def eats "That tasted #{@taste}" end end class Candy include Food # includes the 'Food' module inside the 'Candy' class ... # Rest of class end In this example I've defined `eats` in a module and included that module inside `Candy` (and presumably `Fruit` or whatever else). The end result is the same but all these allow for different code organization and maintenance. In general if you're confident that a method will only belong to a class it's fine to just put it into that class, when you're learning it can be tempting to either over or under use classes and modules and after a while you'll develop a sense for when to break out some logic into a new class or module.
Or we could get some Perl-style short-circuiting (and 2-space indents): def fact(n) n &lt; 0 and raise RangeError.new 'n cannot be negative' (1..n).inject(1, :*) end 
So, exo-planets then? ;-)
It is just a naming convention for methods, nothing intrinsic to the Ruby syntax. It usually implies that an exception may be thrown within the method (as in Active Record's #save!), or that the method has an important side effect rather than simply returning a value (Array#reject!). Edit for clarity: a non-bang method alternative is generally present.
I just wanted to know what it does.
The `!` itself is *part* of the method name. The writers of the method put that there to imply that side effects or exceptions may happen. For example, `Array#reject!`'s method definition would look like: class Array # [...] def reject! # method body... end end
Thanks for stepping up and being a good open-source citizen! I'll follow the ticket from my own account
Check out the ruby [style guide]( https://github.com/bbatsov/ruby-style-guide/blob/master/README.md#dangerous-method-bang)
Dynamic typing scales fine past 100k LoC, imo. If you can write 10k LoC neatly, you can compose a 100k LoC project out of well isolated 10k LoC units. The problem as I see it is that most programmers are terrible at isolation. One of the big problems with rails projects is the need to partition code along `app/` directories that represent object archetypes. Imagine `app/sales` or `app/ticketing` instead of `app/models` and `app/views`. Even when outside of rails projects, I find even the most anti-rails critics inadvertently advocate for railsy conventions. The inability to write code that articulates meaningful boundaries and clear separation along business function is probably the biggest problem I see with all the big ugly ruby projects I've worked with. Now, rails is actually a terrific piece of software, but rails projects should not grow by adding new `app/pattern_name_I_got_from_a_blog_post` directories.
It doesn't *do* anything. It's just a character you can use in names, like letters or an underscore. People use it to *mean* things. 
The problem with dynamic typing is not so much that it can't be *written* neatly, it's that it can't be *read* neatly; there is nothing inherent in the code that says "this will always return a value, and that value will be constrained to a certain set of classes." That makes it very hard for anyone to be *certain* they have a full view of the uses and intent of a class. In a team that has member turnover, changing business rules, and no single "architect" with a full view of a given application&amp;mdash;a description appropriate for something like 99.999% of projects&amp;mdash;it is inevitable that people unfamiliar with the driving forces of the initial design will be required to work on the code. If I can look above a function and see: calculateInterest :: CreditScore -&gt; Percentage It becomes a lot more obvious what is happening from the contract than: class Person def interest ... end end Of course, this method is pretty simple, so it doesn't quite match reality, where the type of most Ruby methods would be more like `Something -&gt; MassiveHashWithUndescribedMembers`.
It's just a character in the name, like 'q', or 'm' or sometimes 'y'.
An example would be if I do "some_string.sort!". In that context, what does ! do?
This is wrong. The `!` suffix should only be used on a method if it has a non-bang variant which is in some sense less 'dangerous' than the bang version. You should not use a `!` on a method if it does not have a non-bang variant.
In ruby, it typically means that the data will be modified in-place. my_string = "foo" a = my_string.reverse # returns a reversed *copy* of the string puts a puts my_string my_string.reverse! # actually reverses the string in-place puts my_string Would result in the following output... "oof" "foo" "oof" Edit: Oops. Your question was _sort!_, my reply used _reverse!_. Different method, same difference in behavior, though.
That is the rails convention. The ruby convention is more along the lines of modify-in-place (with a bang-method) vs. return-a-modified-copy (non-bang methods).
+1 for clarifying that they are, in fact, two separate methods. It's worth pointing out to OP that you're likely to encounter methods with question marks in the name. Like `some_string.empty?`. Just like with bang methods (!), the question mark is not doing anything special - it's just that ruby allows you to use the character as part of a method name so you can be more expressive and make your method names more readable.
I have a fix on https://github.com/intridea/hashie/pull/259. The culprit is the conversion used by the custom hash writer.
&gt; I don't share that view. I think you make a valid point, though. Reasonable people can disagree. :D &gt; If your objects aren't making this clear, your objects have a problem. I don't think this is really true, because the fundamental issue is that the malleability of objects makes it hard to *really* know. I mean, ***really*** know. Everyone knows about the `mathn` module issue, right? Where, if you require it, math immediately changes its meaning in your program... and that's part of the Ruby standard library! Insane. Another issue is that many standard patterns really don't help with the SOLID principles, and I think that's a mistake. Uncle Bob might be controversial, but all it takes is one look at a MVC framework project (Rails et al) to see how they would help. However, using the SOLID principles make other aspects of the OO design difficult... &gt; Once type systems become popular enough that you've got a bunch of different programmers of differing skill and domain knowledge working on projects, you will start to notice terrible types that obfuscate and hide key information. Oh, of course! Bad programmers will program badly in whatever language they have. At least you can avoid being poisoned by nulls from their crap code, though! Or having exceptions explode all over you. &gt; I will allow this: if your team is full of programmers who aren't in the habit of isolating, then they are probably better off with a type system that can give them fast, far-reaching feedback when they make changes. It doesn't take "full of," it takes one guy, in my experience... and that one guy can change. It could be me, the day that the CTO comes and says that our largest client *must have this feature* by the end of the day. Sure, I'll regret it later, but I don't think there's a programmer alive who hasn't been that guy, and it's a miserable fate however good the intentions were. And, you know, the fact is that I enjoy writing lisp code, so I'm not exactly the strictest type-Nazi in the world. However, the idea of trying to grok a 10kloc Clojure project, let alone a 100k one, fills me with dread.
When dealing with optimizing a small amount of text, I find it best to almost mechanically try to shorten the code. Let's start with picking the approach with the least amount of typing. def generate save_to_file convert_to_text convert_to_cleaned_up_comments relevant_violations end Way more confusing. But, I do see some redundant typing. `convert_to`, specifically. Let's hack off the `convert` bit. def generate save_to_file to_text to_cleaned_up_comments relevant_violations end Shorter, and loses no meaning. Good. Now, why not rephrase `to_cleaned_up_comments`. I don't know what `relevant_violations` is returning, but, thanks to contextual clues, I'm guessing it's comments. How about renaming `to_cleaned_up_comments` to `clean_up_comments`? I can't tell without the context, but the way I read the code, they appear to me to mean the same thing. If they don't, then there must be some other way to shorten it without losing meaning. def generate save_to_file to_text clean_up_comments relevant_violations end The "relevant" part seems unnecessary. I'd assume that a comment is relevant in this context precisely *because* it is in violation. Let's just shorten it to "violations." Now, I also feel like `to_text` is a bit misleading. In ruby, a method beginning with `to_*` is generally a type conversion helper. I don't like breaking that convention. How about adding back in the word `convert`? def generate save_to_file convert_to_text clean_up_comments violations end Okay, now it's time to address the fact that we're chaining four methods together with duct tape, spaces, and hope. This method should be two lines. We can reintroduce a temp var: def generate comments = clean_up_comments violations save_to_file convert_to_text comments end The first line of code does something meaningful to your domain. The second file handles some needed housekeeping. A final point of style, some rubyists really struggle with parens being omitted. We can indulge them a bit here: def generate comments = clean_up_comments violations save_to_file convert_to_text(comments) end
I really like your book, but I think (and please don't take this as an insult) you should get a native english speaker to proof-read it. The content is good, but some of your English is very unusual and sometimes ungrammatical.
Ruby core/stdlib disagrees.
View the documentation on rubydoc.info I'd link you, but I'm on my phone. It has functions for almost all of the reddit api 
This is the bare minimum amount of work to post a comment: require 'redditkit' # You'll need an authenticated client to post a comment so create one with a user name and password. client = RedditKit::Client.new('myusername', 'supersecretpassword') # You need a something to comment on, I'll just grab the first link in a subreddit. post = client.links('ruby').first # Finally, call submit_comment passing the link you want to comment on and the comment's text. client.submit_comment(post, "is where your message goes, its posted on the supplied link") All I did was quickly scan the reddit API documentation to get a feel for how it was laid out, then scanned the method list for the redditkit gem to see the syntax they used to wrap it. When in doubt, just look at the code for the gem. 
Well, that sucks. An unexpected turn of events since [this episode of Ruby Rogues](http://www.stitcher.com/podcast/ruby-rogues/e/181-rr-rubyinstaller-with-luis-lavena-35965543) with Luis Lavena where things looked so promising and future looked so bright, and Luis seemed full of optimism for the project. What happened? 
Is ungrammatical grammatically correct? Sounds weird. Wow, recursive :)
Check out the work Ryan Bigg is doing in this space too.
It's not a long book and is really easy to read through! I typically have a tough time willing myself through dense technical books but had no trouble with POODR. In fact I came away with not only a better standing of OOP in Ruby but in general as well.
Do not tell him. It is like "hey I found AK-47, how to shoot?" The time will come. Naturally.
Can you give an example of core/stdlib that violates this convention?
For almost anything, really... 
James was the founder of /r/ruby almost seven years ago: http://www.rubyinside.com/ruby-gets-its-own-reddit-702.html There's more information on https://news.ycombinator.com/item?id=8804624 which includes that he was in Mexico and involved in a car accident.
A link with no content at all :S
Start with http://www.reddit.com/dev/api
Well it's meant for more of a replacement for C as a system language. I do want to try it out for gamedev at some point, but just waiting for more stability. Maybe it's more applicable to some people, but i would think the strictness of the language would make it tricky to do web apps in a short time. Dynamic &amp; weak typed languages definitely allow us to get small apps done quickly.
I didn't know James, but I am sorry to hear of the untimely passing of any member of the community. I know he will be missed.
It's one of the unfortunate markers that Ruby has cemented itself as a mainstream language in that the deaths of prominent members are starting to become a recurring thing. 2014 was rough. RIP Jim Weirich, Ezra Zygmuntowicz, and James Golick.
Yes - several. array = %w( abc def ghi ) # =&gt; ["abc", "def", "ghi"] array.delete! 'test' NoMethodError: undefined method `delete!' for ["abc", "def", "ghi"]:Array String#replace There is .replace but no .replace! http://www.ruby-doc.org/core-2.1.4/String.html#method-i-replace Other parts in default Ruby behave as you mentioned, such as OptionParser having the methods .parse() and .parse!(). I also refer you to this bug report from a while ago in regards to *strip*: https://redmine.ruby-lang.org/issues/1550 I am sure you will agree to the statement made if even the author of the language in question made a statement such as "I admit the inconsistency." in the issue report. See further discussions on: https://www.ruby-forum.com/topic/133607 http://dablog.rubypal.com/2007/8/15/bang-methods-or-danger-will-rubyist Note specifically the statement and advice by drbrain in the last article.
"a non-bang method alternative is generally present." This is not a correct statement per se - see the other links in this thread, in particular some issues at the ruby bug tracker and drbrain's blog.
Feel saddened by his death. May his soul rest in peace.
We've lost so many good ones this year. :[ RIP to James, and many condolences to his family and friends. Stay safe in 2015 y'all.
Very unfortunate, RIP.
Sad news. RIP.
Sad news. My condolences go out to his friends and family. He will be missed.
If there is an afterlife, I am doubtless that he and Jim are up there doing silly and awesome things with Ruby, or whatever it is they write programs in in the afterlife. I hope they stocked up on Jazz and Scotch for him. 
You'll quickly start using underscores in place of spaces in filenames just to avoid escaping spaces. :)
I was thinking of just writing something in LaTeX. Is that a bad idea?
What? It's the OTHER way round, i said there should only be a `!` method IF there is a non-bang method, i didn't say that every non-bang method must have a bang alternative. That wouldn't even make sense...that would mean there'd have to be a `each!` method to go with `each` and a `split!` method to go with `split` and so on --- none of which make any sense.
Funny. On web it's always automatically lowercase and no spaces, but apparently on localhost I don't care. Don't think it will happen again though. PiTA to bug track ( especially since: user error)
Bad year. Rest in Peace, James.
Nice, thanks for the code snippet. I realize I could do something like that but I feel like (for my needs at least) it would be easier to just dump stderr/stdout to files so I don't have to keep track of the buffers (and don't have to worry about deadlocking). 
I'm using it to write a small turn-based game service (Risk type game) which receives all input in text (via socket/http) and it's true that strict typing makes it a bit more tricky to do it in a short time, but I believe it's just because I'm starting out and I often lazy-code my way through. With time it has gotten more intuitive and `match` makes it quite straightforward to accept input and "parse" it as what you expect, or fallback. I think it's a really fun language and so far it's the only language that has had me not miss Ruby while I'm coding in it, even though they're so different. 
Wow. RIP. I'll keep him in my thoughts. 
Wow, R.I.P James.
I did comment on this from Alien Blue but doesn't look like it submitted it... Thanks for the post, I've also been working on a book (on Graylog2) and have changed tools quite a bit. Maybe one day I'll actually finish it...
Why?
Met James back at my very first Ruby conference years ago. One of the more inspiring members of the Ruby community and his passing is a huge loss for all of us. RIP.
There isn't. Live it up now.
Here's an example: [EventMachine::HTTPResponseHeader](http://sources.debian.net/src/ruby-em-http-request/1.1.2-2/lib/em-http/http_header.rb/?hl=4#L4). This is a perfectly reasonable and quite elegant implementation of an object with fields which aren't well-defined, along with some additional specialised attributes / methods. There are many more [here](http://codesearch.debian.net/results/%3C%20Hash%20filetype%3Aruby/). Of course, you could always encapsulate Hash rather than subclassing, but subclassing is still a valid design decision.
In response to the trade off in speed and memory, you will essentially want to maximize the memory you use before you have GC. This means that on average less garbage collection is done, and when it is done you will be freeing more memory. This will result in less context switching into kernel mode. What this means for you is that you should tune GC to use as much memory as you can spare on your machine.
Good blog and good insights. But there is also something to be said about *not* providing free trials. For some SaaS products, providing free trials is very expensive because free trial users may use a significant portion of server resources. Unfortunately a SaaS that we are building falls in this category. I think that not providing free trials also acts as a quality indicator and as a filter against uncommitted customers. For Passenger Enterprise, we do not provide free trials, but instead we provide a money back guarantee of unspecified length. The message that we want to send is, this is a good product, and we are so confident about its quality that there is no need for a free trial, or a time limit on the money back guarantee. If you are not satisfied about it at any time, we will do our best to fix that, or give you your money back if we fail. But this is speculation. I'm not 100% sure whether things work like this psychologically, and maybe free trials would be a good thing to try in the future. The strange thing is, we've given free trials to people on request, but so far none have converted; most of the conversions come from people who never asked us anything before they buy.
Weird people still use shoulda_matchers? I guess this post is a year old though.
No, they should be working at once. Some are doing some basic stuff, which almost doesn't need IO and IO is not even loaded. Even so, like you say - I wouldn't expect them all to be on one CPU. That's not efficient, given Intel Turbo boost.
Not the time or place. Let people give condolences the way they feel without being an ass.
Just to follow up on this - free trials do work in most cases. The real aspect, from what I've seen, is what the user ends up with after the free trial ends. Also, I want to clarify, "trials" on their own also work pretty well. As you said, the major factor is the cost of allowing the trial to happen in the first place. If you convert 1 in 10 trials and the cost of a trial is 1/10th of the profit from a single account, you're break even on the first month if the metrics hold. You mentioned that you have given free trials to people on request and I know that helps, but free trials publicly available are more along the lines of people that wouldn't have contacted you in the first place and went elsewhere that would end up trying it out. Just a thought.
Agreed. Most of the work you can do can happen with Nokogiri and Mechanize. What you're going to notice a major performance hit on compared to C# and the like is the parsing time for the text. Other than that, IO wise check out Typhoeus for the requests as well as EventMachine if you really want to get the IO flowing. EM will come with some quirks, though. Hope it helps, feel free to shoot me a PM - I'm no stranger to Ruby crawlers. Or love. 
From what I've seen, Ruby's main bottleneck in my crawling is parsing the HTML. The IO speed on fetches and the like are fine as you can push it off to async but the text parsing side makes a huge difference if you're actually using Ruby to handle the parsing.
Seems potentially reasonable, I'm not sure. I'd point out that with only one method in each class; and with each method being a class method with no actual instance state -- what you've basically done seems like a functional style, it's not really OO at all. Which is not necessarily bad. 
Yeah, what @jrochkind said. When I do small classes like this I usually define instance methods even if I'm using the default constructor. I feel like that makes them more composable; for example, if later I want to use one in a view I can instantiate it in the controller and assign it to an instance variable rather than embedding the class name in the view.
SRP doesn't mean "do only one thing"; it means "this (code unit) should have one, and only one, reason to change". Classic example, in Rails and numerous other frameworks: the User model. Authentication, authorisation, profile information, and that last hackathon might even have brought up the Fishing Tackle Personalizr&amp;trade; Feature that Lenny in Marketing thought was a *fantastic* idea — all in the same 1,200-LOC class. *That's* an SRP violation. Break that out into a collection of cooperating objects that *each* do one basic thing. I'm bringing up another recovering PHPer on our codebase and it's fascinating/disturbingly familiar watching the gears whizzing until the light turns on.
Yes, people still use shoulda-matchers. What got me to close the window in ~30 seconds was his use of *obsolete, no-longer-supported* RSpec `should` syntax. Using this will fail our CI. Using it after having been warned not to will have Repercussions&amp;trade;: page.should have_content "Don't you DARE do this!!!!1!" Instead, use expect(page).to have_content 'This is fine.' RSpec's `should` syntax was implemented by monkey-patching `Object`, which is now understood to be something that's best not done when reasonable, effective non-monkey-patch alternates are available. (There's already more than enough crap in `Object`. I've heard people making fun of Rails (if not Ruby) by saying, "If Grant Ammons can call the *use* of `ActiveRecord::Base` an [SRP violation](http://grantammons.me/architecture/where-the-logic-hides/)" (go read it; I'll wait), "doesn't that also apply to 'just plain' `Object`?" Which appears to have been part of the reasoning behind `BasicObject`.
I just realized that I forgot to update all the instance variables everywhere in the script. Doesn't make it work, though. Updated script: https://eval.in/238400 Error is void value expression.
I was surprised when you said you didn't convert any of your free trial users until I realized you have a freemium model with your open source version. With freemium, people have a complete fallback after the trial ends and don't necessarily need to upgrade. If you take away the open source version, there will be better conversions. If you had access to data about the kind of "priority support" trial users get and whether they take advantage of the "enterprise features", then you'd be able to decide whether you should offer public free trials.
Well, what you said makes sense but I'm not sure I misinterpreted the principle of SRP. The first version had two(or more?) reasons to change, the soundcloud API or gem could change out from under me or the way I decide to create the track/share pairs could change, or maybe more things I didn't see could change. Maybe we should call it the 'do as few things as possible' principle?
I'm loathe to do this but seriously, google is your friend. https://www.evernote.com/shard/s13/sh/be772955-9b5d-4f52-9e98-4c1182ede3e2/634b57f1c61058473846ab6913e2470d/deep/0/multimethods---Google-Search.png It honestly took a few minutes to read through the entire wikipedia article that explains the reason and logic behind Multimethods and gives examples of implementations in several languages and idioms with further links to more information.
don't loathe yourself -- thanks for taking the time to reply. and i did google it before asking, which is where i found the link i posted. i still wanted some practical examples of where people use them than just the canonical example of an asteroid game. cheers.
:) Yeah, I didn't loathe myself. :) I loathed posting the equivalent of RTFM of LMGTFY but the post seemed to imply that you hadn't googled it hence I posted a semi-snarky screenshot. :)
got it! i just started playing with elixir the other day and loved pattern matching (reminds me of prolog from long time ago). so this totally makes sense. now off to find the difference between multiple dispatch and pattern matching...
Firstly, thanks for sharing. I am still learning this stuff myself, so consider these as questions rather than corrections: * CreateTrackShare#create doesn't seem to take any parameters at the moment, is that a typo? * Would SoundcloudFetcher#fetch be more descriptive as SoundcloudFetcher#favorites at the current moment? * Isn't the knowledge of the Soundcloud API now spread out between two classes? The Fetcher, which knows how to make a get request, and the Importer, which knows the insides of that fetched object. * What if you changed The Fetcher into a stateful object which became a Soundcloud request class? You could then create similar classes for other services and generalize the SharesImporter to send messages to a common interface. Let me know what you think :D EDIT: I recently read this book: [Understanding the Four Rules of Simple Design](https://leanpub.com/4rulesofsimpledesign). I think you may find it really helpful, if you enjoy thinking about these things.
Interesting implementation. Thanks!
This is one of my first public releases in Ruby, and I did it specifically to learn more about the language's metaprogramming capabilities. [Here's a blog post](https://medium.com/@brunoabrantes/exploring-apis-with-metaprogramming-43f37fa809ff) I also just published about it. As stated, I'm still pretty new to Ruby so any feedback/criticism would be greatly appreciated!
A lot is wrong with your implementation. I recommend starting with either the board as a string or the board as a nested array and then finding the boxes, column, and rows for certain cells dynamically based off their x,y indexes. e.g. class SudokuSover attr_reader :board def initialize(board) @board = board.chars.each_slice(9).map do |row| row.map(&amp;:to_i) end end end solver = SudokuSolver.new('010020300004005060070000008006900070000100002030048000500006040000800106008000000') p solver.board #=&gt; [[0, 1, 0, 0, 2, 0, 3, 0, 0], [0, 0, 4, 0, 0, 5, 0, 6, 0], [0, 7, 0, 0, 0, 0, 0, 0, 8], [0, 0, 6, 9, 0, 0, 0, 7, 0], [0, 0, 0, 1, 0, 0, 0, 0, 2], [0, 3, 0, 0, 4, 8, 0, 0, 0], [5, 0, 0, 0, 0, 6, 0, 4, 0], [0, 0, 0, 8, 0, 0, 1, 0, 6], [0, 0, 8, 0, 0, 0, 0, 0, 0]] Then you can call a method solve on your solver. solver.solve Good luck. If you need a reference for some help or insight. [Here is a solve I did a few months ago.](https://gist.github.com/JohnathanWeisner/d2e09ce5a90518945fef) My solution uses the backtracking algorithm which you can find more about [here](http://en.wikipedia.org/wiki/Backtracking) and just manipulates a string. Solving sudoku is a complicated but the steps can be broken down which makes it a great for object oriented programming and recursion.
I didn't even know I could get the information from a nested array that way. Guess my try is beyond saving, so I'll have another try after looking at classes again. A quick look at yours gave me some ideas, though I want to find my own algorithm mathematically. Just using a random number for testing. Anyway, thanks.
I _do_ think what you've done is the ultimate end goal of taking "single responsibility principle" absolutely seriously.... and the SRP is meant as an OO guide.... and I think taking it absolutely seriously you wind up not doing OO at all, but just functional programming. I have had these thoughts before, if you go all the way, you wind up with classes with one method each, and possibly no state. Ie, functional programming. Certainly some people like functional programming and feel it's the one true way to program. But it's not OO. So I've always stopped before going all the way with what "SRP" seems to be. I don't agree with the other commenter here that "only one reason to change" changes things much vs "do only one thing". I just think to me, SRP is more like a principle to think about and make subjective judgements based upon (balanced with other principles), than something to follow all the way to it's ultimate conclusion. Programming is still as much art as science. But your design does not seem unreasonable. 
Sorry I chose Hashie to pick on. I appreciate your contributions and hard work :heart:. My problem is with hash subclasses in Ruby. Ruby, for better or worse does not work well when subclassing hash. I have two main complaints: 1) Performance: Subclassing hashes is slow and memory inefficient. I understand 8x slower can be a fine trade off for many parts of applications. I choose to write in Ruby instead of say C where I could get many times the speed at much lower productivity. Most people don't know that hash subclasses are slow and never benchmark their own code. It's not hashie's fault that people aren't benchmarking their code. 2) Interface: Subclassing hashes produces interfaces that are difficult to use and replace. I like some of the features of the mixins, such as `deep_merge` and `deep_fetch`. I like that they're in a single place where people don't have to re-invent the wheel. I personally try to stay away from any APIs where I need a `deep_merge`. Sometimes I inherit a codebase with nested config hashes. The problem here is choosing to use a nested hash as config rather than a problem with Hashie. An example: Active Record config internals are a huge pain to work with (top level `test`/`development`/`production` holds actual config values). In the codebase it's hard to know which level you're dealing with. This pattern of nested config hashes resists refactoring unfortunately. Even with the modules I like, you still run into the problem of being unsure if you're dealing with a `deep_merge`-able object or a regular hash due to things like confusion over which object gets returned in a `merge` etc. ActiveSupport deals with this by adding methods straight to Hash. There's problems with polluting the global namespace there. Some of the other mixins i'm not so in love with like the previously mentioned `Coercion` module. The examples are all using hash subclasses and they're encouraging the user create hash based object instead of an actual PORO. Even if this wasn't slow, once you start using hash subclasses you're pretty much stuck with the API. One example is https://github.com/rack/rack/issues/738 i linked to this in the article, but don't expect everyone to click on every link. The problem becomes that any attempts to refactor will either make the problem worse (detecting the edge case to deprecate adds overhead) or they will be a breaking change. I've not used the other mixins, though i'm against sub classing hashes. The mixins unfortuantely encourage people to subclass hashes. ## I'm a giant hypocrite I've used and liked hashie::mash. I used and liked the gowalla gem https://rubygems.org/gems/gowalla and thought it was great. I even wrote a chain able custom version that I was too nervous to submit back upstream https://github.com/schneems/gowalla/commit/fdce43e3b7dbe6434c86bd746641a23429892001. Ignore code quality, that was 4 years ago. Could it be re-written in to be faster and cleaner? Probably, but that network call was SLOW, so it didn't matter much. My bigger point is that hash subclasses can cause a world of pain in Ruby. I picked on Hashie::Mash as a problem I was working with currently and I also get questions from my students who find it and ask when they should use it or open struct. This started as a post to them, and morphed a bit with my flair for the dramatic. ## The not so bad future I encourage people to read through Hashie source code. Understanding how it works is a fascinating look at Ruby and how flexible of a language we've got. I would &lt;3 if there was mention of dangers in using hash subclasses in the readme. Maybe someone could summarize some pros/cons like i've got in the article and put them into a wiki with less strong language. 
&gt; what you've basically done seems like a functional style More like a procedural style. The three \* classes do not provide any value besides code organization (they're just namespaces). So, you can take them away and you're left with 100% procedural code. For a functional style functions should be first-class citizens (which they aren't in Ruby) and there should be almost no side effects (the code changes state in at least two of the three functions). \* Even `Soundcloud` isn't used in an object-oriented way since the object is instantiated right next to its usage. Using `Soundcloud.get(token)` would be equivalent.
&gt; the soundcloud API or gem could change out from under me That's why it's usually a good idea to wrap external dependencies (gems/web APIs) in your own objects. You've done this with `SoundcloudFetcher` except it shouldn't accept a `user`, but a `token` in order to make it more reusable.
Thank's i've updated my blog to include a link https://github.com/schneems/schneems
This is amazing, thanks for your work!
The returned data would differ, but he would have to deal with that either way. He can do that through a Fetcher— which is little more than an alias of the get request— grouped with an Importer. Each additional service would require both classes, both sharing knowledge of the service's API. Or the API logic can be contained in a single class, coercing the service concepts into domain model concepts. Currently, these appear to be nothing more than a permalink, provider name, and a created_at date. Then CreateTrackShare can just send these messages to the duck typed classes. I'm not sure that's better, but it's something to consider. Object composition sure is hard.
Ruby on (a) Rails?
Whoa, whoa. Pry has been working fine for years and it's a complicated project. It's just when major events happen. Ruby 2.x has a new tracing API. Byebug is using that. So there's a transition pain. Maybe you are just asking a "I wonder ..." question. Open source devs have precious things exposed: feelings and motivation. If we want to help we can do helpful and nice things like submit bug reports and patches. At the very least, encourage. It's a motivation attrition fight. Someone made pry. Someone made pry-nav. Someone made pry-byebug. Buy them a beer with gittip if you use their gems and it has saved your butt.
By supporting different access patterns like `header["Accept-Language"]` and `header["ACCEPT_LANGUAGE"]` def [](key) super(key) || super(key.upcase.gsub('-','_')) end We're getting a performance penalty. This is one of the same things that makes Rack slow: https://github.com/rack/rack/blob/master/lib/rack/utils.rb#L493-L495 Here's the rack issue with benchmarks: https://github.com/rack/rack/issues/738 Want more proof? header = HttpResponseHeader.new("foo" =&gt; true) hash = {"foo" =&gt; true} FOO = "foo".freeze Benchmark.ips do |x| x.report("header") { header[FOO] } x.report("hash") { hash[FOO] } end Even in this happy path where the code after the `||` never gets called: Calculating ------------------------------------- header 113.609k i/100ms hash 127.329k i/100ms ------------------------------------------------- header 3.851M (±16.0%) i/s - 18.745M hash 6.633M (±13.3%) i/s - 32.469M A plain hash is 72% faster. For something that gets accessed as often as a header, speed is pretty important. Let's pretend for a moment there wasn't a speed problem, that interface you covet has some bad design consequences. ## Unclear interface The accessor methods that you like can also be confusing, for example: header = HttpResponseHeader.new header["status"] = 200 puts header.status # =&gt; 0 This is pretty unexpected, but makes sense if you read the source code. There's other gotchas here: header["Content-Length"] = "1000" header.content_length # =&gt; 1000 Okay, thats right, let's change it... header["Content-Length"] = "500" header.content_length # =&gt; 1000 Whoops, even though content-length was changed, the value was memoized and never updated. ## YAGNI This is an example of why not to subclass a hash. In this case, headers are transported to the server as key value pairs, so store them and access them as key value pairs (a hash). If we remove the custom logic from the class, we make it simpler, less prone to errors, we also make it 72% faster! For that list of "good" examples you gave me, I picked the first one on the list and I re-wrote the main portion of the logic in ~16 lines: https://gist.github.com/schneems/848a2b4f66c4cbea3884 Not only is it cleaner, it doesn't have the YAGNI methods Aaron is talking about (merge, fetch, values, size). While lot's of people do subclass hashes, i've still not encountered an overwhelmingly good case for subclassing a hash. **tl;dr** those were not good use cases, subclassing hashes is still bad 
&gt; It's only Function Overloading[1] in languages like a java. Overloading is fundamentally different because overloads are resolved at compile time. The best way to think of overloads is as methods with unique names. When you see some Java code like: class Foo { void method(String string) { ... } void method(int number) { ... } } Read it sort of like: class Foo { void method__String(String string) { ... } void method__int(int number) { ... } } That's pretty much how the compiler sees it. You don't have a single method that takes different types, you have entirely unrelated methods who happen to have names that look the same to a human.
Virtually any language can do this for you. Pick whichever one you are most comfortable with.
Sounds like a fun project! You could do this in just about any language. You could even do this in JavaScript or VBScript and execute it with Windows Script Host (I'm assuming you're running Windows since you mentioned the game was programmed in Visual Basic) but it would be more fun in Ruby. So, yes, If it were me, I'd do this in Ruby. My next choice would be Python. Both could handle this task gracefully and both would be equally easy to learn quickly and implement.
Not really, unless you don't have any programming experience. In that case, ruby mmight be easier, but I really don't know. Whatever language you choose, you'll have to learn about file IO.
I love the idea of this. It obviously won't work for every API out there, but it should cover at least 75% of them.
Or the "Do One (Logical) Thing" principle. I've forgotten who it was (either Uncle Bob or Sandi Metz) who said "You have an SRP violation if you describe a unit of code and use a *conjunction*." ("and", "or"). "The [`NewShimmer`](http://www.break.com/video/ugc/snl-new-shimmer-commercial-704661) class supports use as a floor wax and a dessert topping." — SRP violation; break it up. "The `UserCore` class encapsulates the description of an individual user. It collaborates with other classes for authentication and for persistence." No obvious SRP violation; if it's a Rails app, someone has obviously learned from *n* too many [God objects](http://en.wikipedia.org/wiki/God_object).
Nice work! I'm not too keen on treating function arguments as non-query-params. For example, I expected github.users("foo") to produce .../users?foo Is it a good idea to use arguments in the same way you would use a method call? In other words, github.users("foo") and github.users.foo would produce the same URL.
Coming soon! :)
My condolences 
It's unfortunate there aren't more Ruby shirts available on that site. However, with a domain like that, I'm happy even to see one.
Yes of course you right, Function Overloading resolves in compilation time, i said about overloading because it's a similar concept 
Interesting, thanks. 
Nope, Composer packages: https://packagist.org/
BAH! https://pbs.twimg.com/media/B6LVu1ZIAAAwehO.jpg
Thanks! Yeah, it is pretty much targeted at RESTful, JSON APIs right now. Responses could theoretically be parsed from XML as well, but for now I only implemented JSON response support. APIs with weird URL standards or that chuck a lot of functionality into query parameters would probably be more difficult to support though, and a lot of the simple expressiveness would be lost too, I guess.
Thank you for the feedback! There's actually a good reason in favour of supporting arguments. If, say, you have a videos API where each video is accessed by its numeric id, which is a pretty standard pattern in API design: api = Blanket.wrap("http://api.videos.com") api.videos(55).get # or api.videos.get(55) Another reason is that a lot of times this "resource identifier" is obtained via user input, and accepting arguments would allow for this use case: my_video_id = 55 api.videos.get(my_video_id) 
http://cmx.io - Create your own xkcd-style comics using HTML markup. Source: https://twitter.com/kodgemisi/status/550209644686475264
Could also be a way to package Shoes apps? I know I was having quite a time packaging an app I did as a .jar. Would be nice to just have it packaged with ruby and ready to go.
&gt; RSpec's should syntax was implemented by monkey-patching Object, which is now understood to be something that's best not done when reasonable, effective non-monkey-patch alternates are available. Has any one ever actually run into problems with the `should` monkeypatch? If they have, has the amount of time spent discovering and working around the monkeypatch even come close to the amount of time people who want to upgrade rspec are being asked to spend updating to `expect`? `should` was the best part of rspec. `assert expected, actual` is often clunky, because you have to remember the correct order. `expect` is even clunkier. And what does the `#to` method do, anyways? Pretty much nothing. I keep tying `expect(page) to_have_content`. Yuck! The rest of the rspec dsl is nice, but stupid "best practices" like `describe "#omg_here_is_the_method_name"` have rendered it pointless. Rspec began as a neat idea, but whatever it is now is vastly more complicated than test unit, and offering nothing valuable in return. Also, when did BDD become equated with browser testing? BDD has *nothing* to do with browser testing. Browser testing is a fast lane to a terrible, brittle, slow test suite. Okay, I need to get back on my meds, heh. I'm ranty today. 
I'm really glad to see that some of the Ruby world is rubbing off on PHP.
Is dependency management really a Ruby thing? edit: anyone care to reply instead of just joining the downvote drive-by?
Composer seems to take more from npm than rubygems.
Composer is based on Bundler.
Up vote for Sandi
I did the same thing at first for `merged_headers` but then I realized it works slightly differently. If you call `merged_headers(nil)` it will still use nil as the value, which will throw an exception in `merge`. `fetch` is a nice method too, either one works great.
It was never a PHP thing until composer took a leaf from Bundler's book. Gone are the days of installing things from pear globally and being stuffed when two applications on the same machine needed conflicting versions
I see, that makes sense. 
Composer has a lockfile at least. Unlike the near uselessness of npm shrinkwrap. 
&gt; Ruby: A scripting language with no real API for GUI work. Oh what I would do to have a GUI setup akin to what C# has.
"The MRI Developers aren't using the specs I wrote for my own project! This hurts Ruby because reasons!" There's a lot of good points in this article about the quality of the tests. Using RubySpec might be better in the end. But it's not like RubySpec was an official platform, it's someone's unofficial attempt to add to a project.
Counterpoint: Ruby-core contributor Charles Nutter has some things to say in his [twitter stream](https://twitter.com/headius).
The fact that the Ruby community is historically so testing-focused makes this all extra ironic. Nutter worked to provide a working spec, and they don't make it part of the standard? Pretty shitty if you ask me. Maybe it's because he's not Japanese
If only we had a language with Python's openness and Ruby's tooling. Ruby's insular development style stands in direct contrast to Python's transparent and open PEP process. 
What an unproductive way to end such a project. More insistence on communication between the ruby devs (Matz &amp; co.) and the leader of the project would have been beneficial I guess?
I've tried to get involved as well, but found that all the important planning documents are in Japanese.
I'm trying to migrate a legacy PHP app and basically the team that developed it pointed out that it predated anything like Composer. Add in that they don't want to start now because it'll mean changing code. So I move this code base to a new server and.. bam.. white page. So far I've identified four different Pear modules I needed to download and install, one of which apparently was never released for PHP &gt; 5.2. Package management on any old PHP app is a nightmare.
The first commit on rubyspec that gives segmentation faults (as opposed to failing tests) is dated from 19 december. The release from ruby was 5 days later. Oh, and it's not present on the branch labeled 2.2 (quite misleading in my opinion) Not saying that they couldn't have delayed the release, but that's not a lot of time for the issue to be discovered by the ruby dev team (and apparently the people submitting the spec didn't notice either, which is strange because they take the MRI results as their base for the spec which supposedly means it must have worked at some point shortly before the final release).
People frequently comment on Ruby's tooling. Are we talking about what the language allows for, or gems?
If your aim is specifically to learn about ActiveSupport then it's fine, but you might want to also try to solve it using only the standard library. http://www.ruby-doc.org/stdlib-2.0.0/libdoc/date/rdoc/Date.html http://www.ruby-doc.org/stdlib-2.0.0/libdoc/date/rdoc/Time.html
I feel like my ideal language would be a hybrid of Python and Ruby, but with no GIL. :) I like both languages, but they both have some warts.
what do you mean? I don't follow the ruby politics but the tone of this blog post struck me as acerbic.
"Ruby tooling" means: * Side-by-side versions w/ rvm or rbenv * Packaging system w/ gem * Dependency management w/ bundler * Testing frameworks w/ minitest or rspec * Deployment with capistrano and others * Standard for setting up and testing a dev environment w/ git clone; rake db:setup; rake I came up with this list off the top of my head. These are all _(1) mature, and (2) widely adopted_. Python only has incomplete, fragmented efforts at these aspects, unfortunately. The Python language and some IDE's appeal to me more in many ways. But the ultimate development experience with Ruby is much better.
Nobody is obligated to work on a project for free, especially after being repeatedly blown off.
Also notice how he noticed the segfault only on december the 23rd, and only because charles nutter pointed out that (a) a particular bug really was fixed (as the issue tracker claimed), and (b) the ruby version that brixen used was 6 months outdated. Oh, and he decided not to report this segfault for some reason.
&gt; All of these issues could have been easily avoided if MRI developers used RubySpec. They could have also been easily avoided if MRI developers didn't push a new release. Avoiding problems isn't the primary concern for a language developer. It's an important one, sure, but certainly not at the top of the list. Brixen makes it seem as if a violation of avoiding problems is a cardinal sin. But this is silly, as the MRI devs fixed that particular issue within a few days. So not only did they ship a new set of features, but they also removed the problem that "could have been avoided", all within a reasonable amount of time. Brixen's conclusion that this hurts things remains questionable.
Congratulations and a happy new year to the whole team! :)
There's an Office Open XML standard, but Office supports features that are not part of the standard and in practice interop with Office is probably more important to most people than compliance with the standard. Nevertheless, [here it is](http://www.ecma-international.org/publications/standards/Ecma-376.htm).
Yeah but it's pretty shitty if you're relying on Ruby for production software.
Capistrano, really? I've tried to use it outside of Ruby. It's heavily tied to Rails, the internals aren't documented (the only documentation is recipes from random blogs), the plugins to remove the dependency on Rails are fragile, ad-hoc and undocumented. All this gave me the impression that ruby's tooling was a bit of a cargo cult.
&gt; Oh, and he decided not to report this segfault for some reason. Probably because Ruby's a dead toy language and we all need Rubinius X to save us from obsolescence and terrible Perl-inspired decisions.
Does anyone else not care about moaning that people aren't adopting your project?
Do they even *have* a philosophy, other than "whatever feels right at the time"? The versioning on Ruby has been utterly ridiculous for the past several years, with the release manager admitting 2.0 was less of a change than 1.9, and minor and bugfix releases breaking bc. Even PHP is better than that.
Brian's whining resorting to several flagrant logical fallacies like presumed "poor" Ruby quality, unfounded correlation and generalization to discovered failing spec test (already fixed as bug #10685) or C language implementation or way core devs write their tests or missing formal "design process" (by his imagination) etc. confirming the fabricated *situation* should not be taken too seriously. I probably live in another reality but Ruby (the main reference MRI/YARV implementation) after 20 years of development still belongs to most used languages in practice, offered paid jobs and for me that's much more serious confirmation Matz &amp; team do things right then one of many *hypothesis* of unknown or less successful individuals. Most Ruby hosting companies count with and support just the Matz's implementation, some also JRuby and a very few Rubinius. That's because the most famous and important Ruby application RoR is developed with it with support to JRuby since 3.0. I'd suggest do improve your work significantly (Rubinius, RSpec) and developers of important projects would eventually start to take them more seriously and possibly adopt them if they find them advantageous including optional transition costs.
Ruby with MacRuby and with other toolkits for cross-platform I suppose. http://stackoverflow.com/questions/14193400/what-ruby-based-mobile-cross-platform-solution-to-use
Absolutely. This whole thing has just been more of the drama that reminds me why I don't like getting involved in big projects.
That really sucks, and I can see how you'd feel that way. Just know that not all projects are like this - JRuby's maintainers are super-nice people, and I've had nothing but good experiences contributing to Rails.
Yeah, Señor Nutter and Capt. Enebo, along with everyone else I've interacted with aren't just nice, they're approachable, helpful, and really friendly to new people. Unfortunately, I've been exposed to very little of brixen's good side, but if I can avoid him entirely, his projects tend to be really cool.
Very nice, it's good to see new approaches being developed for handling persistence in ruby. Also, thanks for writing up such a great tutorial. That being said, I think the validation part is a bit complicated. Is it really crucial that the domain objects ('Tasks') are immutable value objects?
ROM addresses many issues that have been causing major pain in maintaining medium-to-big-size Rails apps. That pain mostly comes from AR and its apparent simplicity. I'm pretty sure there is a big group of people like you who won't see the value. On the other hand there are many people burned by AR who are looking for solid alternatives. When it comes to comparing ROM-AR like that - ROM.env was only introduced because Rails doesn't provide a mechanism to inject dependencies into specific parts of your app. There's gotta be a global object with global access. ROM gives you an environment with separate components that you want to inject into your objects as their dependencies. This helps in establishing boundaries within your system as opposed to "simple" and convenient approach in Rails where AR models are accessible from every place of your app. This is a recipe for a disaster as you introduce a lot of internal coupling and it's very hard to reason about your own app's codebase after it reaches certain level of complexity. Command API is functional and those .try blocks are actually an implementation of Try monad and individual command functions will soon be composable allowing us to build quite complex transaction operations with really solid error handling. I understand your confusion, it's just completely different from what you are used to. Also notice that commands work against relations, not individual objects. So you're not "updating a single task" even though that's the outcome. You're updating tasks relation that's restricted to a single task id. Again, totally different from AR. There are things in ROM which will make people confused to say the least - for instance accessing query API is considered a code smell. This means we believe `Task.find(1)` which everybody loves so much *is* a code smell and should be avoided. Comparing ROM side-by-side with AR is kinda tough, they differ so much that it's just hard. But! We will do it on the website to explain better why they differ like that in the first place. So, challenge accepted ;)
No, you're in charge here. You can handle validation however you want. That Task value object is just an example of what you could do. This tutorial is mostly about showing individual ROM components in action, not a guide how to build apps with ROM and Rails. I guess we should highlight that fact more :)
Thanks for the detailed response. It really explains the "why" better than http://rom-rb.org/introduction/why/ &gt; ROM addresses many issues that have been causing major pain in maintaining medium-to-big-size Rails apps. Maybe just have that sentence (with a concrete example - "war story") in the why page instead :) 
&gt; why I don't like getting involved in big projects You don't have to be __that__ involved to help. Contribute docs, submit feature request, comment on other feature requests, subscribe on http://www.codetriage.com/. The big problem with this particular Ruby drama (IMHO), is the centralized nature of stake holders. If more people were more involved in smaller ways and more aware of the problems of the community maybe they won't hit this type of boiling point moment. Open source doesn't mean that __other__ people can contribute to it, it means that __you__ can contribute. Sometimes the small contributions are the most helpful.
The first comment is hilarious. Ruby: come for the delightful language, stay for the amusing drama.
using sinatra
The command stuff is considered the most experimental part and being discussed a lot at the moment. I'm just learning it myself, but here's a breakdown of what's happening here, so you get an idea of the concepts: rom.command(:tasks).try { update(:by_id, task_id).set(attributes) } ...you're first getting access to the commands for the tasks relation: task_commands = rom.command(:tasks) ..then using '.try' you have error handling built in. You'll be able to chain additional command applications together, and if one fails then the whole fails. task_commands.try { update(:by_id, task_id).set(attributes) } Here 'update' is the defined "Update" command and it's being restricted with the :by_id relation. Finally the "set" method is the part that actually executes. 
That Sandi Metz talk is brilliant, great examples of refactoring in small steps
I thought this point might come up, but look at it from the other side, currently MRI has NO control over JRuby or Rubinius. If they adopted/adapted RubySpec as the "gold standard", they could exert control over ALL Ruby implementations. The current methodology is, by contrast, completely haphazard.
brixen sounds pretty frustrated. I think I'd feel much the same way in his position?
Symbols represent concepts, Strings represent data.
Yeah, I think I would too, I understand why he would be upset. It looks like Ruby Core made a commitment to RubySpec for 1.9.2 and then for some reason decided not to conform or contribute to it any more. I wonder why? 
nice work kirill!
Kind of a strange, *magical* way of looking at things, which is cool I guess. As long as you remember that Ruby does not have to be a black box to be examined from the outside in - you can actually understand *why* things work the way they do by reading the docs. What makes `inject` special is that it [takes an optional symbol as an argument](http://ruby-doc.org/core-2.2.0/Enumerable.html#method-i-inject): &gt; If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo.
It's really unfortunate that parts of this community are so toxic. I enjoyed the language better when I was just learning it on my own without interacting with the community at all.
Fortunately, it's the exception rather than the rule.
Unary &amp; does: * Turns a block into a Proc * Turns a Proc into a block * Turns an object into a Proc which is then turned into a block 
Learning "when to use colon" is a bad way to learn Ruby. It's like learning "when to use quotes" without ever learning what a `String` is. Ruby has a data type called `Symbol`, and symbol literals happen to start with a colon (although not always) but that's not really important. What's important is learning what symbols are, and how they interact with other parts of the language.
Knowledge of Ruby, Python and/or other languages will help you be a better programmer even if you decide to stick with Java professionally. I think you'd have a lot more fun in Ruby or Python but I'm biased. Enjoying your work will boost your job security. Each language has a unique set of strengths, weaknesses, community, etc.... I'd recommend trying different things until you see what feels best for you.
Job security isn't necessarily in which language you know right now. In the long run all of them we be obsolete. The ability to learn new languages and libraries is more important than which ones you already know.
&gt; without interacting with the community at all. It's kindof like when your parents fight when you're a kid. You don't realize that they're human, and everyone's parents fight sometimes. Crappy things happen in all communities. In general I love the Ruby community, the people at the meetup groups are great, and at conferences people are easy to talk to. I've gone to some other language meet ups and different languages attract different types of people. For the most part Rubyists tend to be nice, accepting, and welcoming. This is far from some of the other language communities i've seen. A solution to enjoying the language more? Instead of being less involved, get more involved. Go give a talk at a meetup or volunteer to be a guide at a Intro to Rails event (like railsgirls). I agree Ruby isn't perfect, in those moments we need to step in and try to help it to be better.
The future is unwritten. If you want job security, I suggest learning Java, C# or PHP. These are mainstream languages that make up a considerably amount of legacy code which organizations cannot easily replace. However, if you do not wish to be stuck maintaining legacy spaghetti code, I suggest going with Ruby, Python, or maybe even Go or Rust.
how is it so far? do you miss php?
There is merit to your logic. I'd go further to say that it's only good if folks can produce something good out of it. (Not a sleight at Ruby or anyone specific, I'm philosophizing now).
About a month ago [a question was asked here](http://www.reddit.com/r/ruby/comments/2n122s/securing_sensitive_data_on_a_gem/) about best practices for storing sensitive configuration information, and I [referenced The Twelve Factor App](http://www.reddit.com/r/ruby/comments/2n122s/securing_sensitive_data_on_a_gem/cm9lbst)'s recommendation of using environment variables for storing secrets. This article is a counter-point to that recommendation and offers an alternative solution.
In terms of job security: Get better at Java, learn Ruby, Python *and* PHP, and then half a dozen other languages as well. A good coder can pick up any given language within 2-4 weeks and become productive, whereas a one-trick pony who only ever learned one programming language will become a liability if and when the business needs to adopt new tech. The better workplaces know this and will hire accordingly. Don't just learn the languages, but engulf yourself in their respective ecosystems, learn to code *idiomatically*, i.e., embrace the ways of the language - Python folks even have a word for it, they call it "pythonic". Interestingly, what's idiomatic in one language is sometimes considered poor practice in another, but it absolutely pays to know different ways to Rome. Also, learn some languages that subscribe to different paradigms - Ruby and Python are *extremely* similar, and even PHP is fairly close on many key aspects: all three languages have dynamic typing discipline, more or less weak types (implicit casts can and do happen in all of them, although PHP is certainly the worst), they use class-based OOP, and the execution model is conceptually interpreted (i.e., source code is run directly, with no explicit compilation step, although they all do compile behind the scenes). Even Java is still quite similar - it uses a compiler, and a static type system, but the type system isn't very strong and can be bypassed, and the OOP model is class-based. If you want to broaden your horizon, some languages to look into include: - JavaScript. You'll need this anyway, might as well learn it right now. Besides, it's probably the most gentle entry point to functional programming. - SQL. Not technically a programming language, but very useful, and thoroughly declarative, forcing you to think in terms of map/filter/sort/group operations rather than an imperative "first do this, then do that" mindset. - C. Nothing else gets you this close to the bare metal. You may not need to write any C at all in most programming jobs, but knowing how things work at the lower levels of the stack is extremely useful. - Some Lisp (Scheme, Common Lisp, Clojure, ...). Core idea here: use the same representations and tools to manipulate both code and data. A Lisp s-expression like `(foo bar baz)` is both a three-element list and a two-argument function call (i.e., it's both `[foo, bar, baz]` and `foo(bar, baz)`), and because *everything* in Lisp is expressed as s-expressions, all your list manipulation code is also code manipulation code, and the "programming" and "meta-programming" realms collapse into the same thing. - One of the statically-typed functional programming languages (Haskell, ML, OCaml, F#, ...). If you come from an imperative / OOP background, these languages will make your brain hurt, in a good way - you'll hit a series of epiphanies eventually, and each of them makes you a better programmer, in *any* given language. Oh, and a word of warning: PHP is a useful and important skill to have, but keep in mind that despite its popularity, PHP is not a good programming language at all, and IMO, never will be. By all means, use it, but please don't make it your only language, and if in doubt, prefer some other language community's approach over The PHP Way.
I've got a project in GitHub that also performs this function: https://github.com/justinwsmith/coursera-downloader I've not used it in several month, so I'm not sure whether any changes have been made to Coursera's website that might've broken it. Pull requests are welcome.
When you boil it down to the roots, it really is about being flexible. the more languages you are familiar and proficient in, the more likely you'll have job security. Single focus is what loses jobs or careers these days, not picking the wrong language to code in.
When does a symbol literal not start with a colon?
Well `%i{a b c}` is equivalent to `[:a, :b, :c]`, but what I was mainly trying to say is that you can get symbols without using a colon, such as `"hello".to_sym`
I work for a PaaS company and we use config management tools (chef) to drop a configuration file with secrets... that is then used to inject those secrets into the app environment as environment variables. I think that configuration management tools (like chef) are somewhat outside the scope of 12-factor app, or at least the piece of injecting secrets via environment variables into the application process. 12-factor doesn't really address how the platform itself manages secrets (encrypted database? manually dropped flatfiles?). 12-factor tells you how to build a portable application that has injected service dependencies. It doesn't really tell you how to build such a platform to support a 12-factor app.
It's important to understand where the Twelve Factor doc came from, and what it's for. It came from Heroku, and it's for making Heroku's life easier. They took some good ideas, some so-so ideas, and some downright bad (but required because of how Heroku works) ideas and pulled them together into a manifesto. The phrase "making a virtue out of necessity" exactly describes the process. If you're working with Heroku or similar hosting environment, well, you need to build your apps this way for them to function properly. But I hear a lot of younger devs who think these 12 factors are in some way general purpose ideals. I'd argue (strongly) that several of them are pretty damn poor decisions for non-trivial production applications. And the environment variables one is (IMNSHO) the worst of the lot. Anyone who has ever administered a production server knows how hacked up and fluid environment variables are - they're spammed all over creation in ways you'd never anticipate as sub-processes are spawned, cron jobs run, emails are handled... the attack surface can be huge and very poorly defined. As we [all just found out](https://en.wikipedia.org/wiki/Shellshock_%28software_bug%29) a few months back. Point is, take the Twelve Factor doc as a specific guide for Heroku-ness and as a general starting point for good application development, but NOT as a panacea. Read up, and remember that there is no one-size-fits-all approach to building, hosting or managing software.
Okay so when you say it returns the value to the scope, it just means it will run it through the code again? When I altered the code it showed the position in the array. It shows up in the command line, but not on nitrous.io I understand that return will return the value, I'm trying to figure out where it places it. Like, where in the program it puts **i** or **nil**. I get that when I alter the code it's placed there, but without puts, where is it? Does that makes sense?
It's case sensitive. Try this: search(locked_chest, "Chalice of Youth")
Ah whoops. It works on my text editor because it's correctly written there. I'll edit it. But that's not the problem I'm having. Thanks for the catch!
&gt; I'm trying to figure out where it places it. The method call IS the value. You need to assign it to something if you want to use it later, e.g. result = search(locked_chest, "Chalice of Youth") The method `puts` doesn't "put" anything anywhere, it's just a bit oddly worded way of saying "print" (the name `puts` comes from "put string") 
Came here to say this. He dished out more bad advice surrounding inject later in the article. "Only use colons on inject" Why? because his lambda only accepted one arg and it exploded when inject called it with two. He should have written "The differences between proc, block and lambda" first. Then maybe the advice in this article would have been different. 
Yeah, I keep getting it messed up with print. I don't like puts that much.
&gt; The emphasis should be "your application accesses secrets via environment variables" I think the point of the article is: do not do this. No matter where secrets are stored at rest, if they are injected into the environment then they are exposed to things like Airbreak reporting errors, and spawned sub-processes like ImageMagick. His recommendation is to use another method to access secrets -- not the environment.
I suppose that's a way of looking at it. Normally, methods in idiomatic ruby just return their last value implicitly: def foo(x, y) x + y end foo(42, 3) #&gt; 45 The `return` keyword is a way of saying, "stop now and return this value" def bar(x, y) if x == 42 return "Exiting NOW" end x + y end bar(42, 3) #&gt; "Exiting NOW" 
I believe return is a keyword, not a method. See this question on stackexchange for a discussion of why to use return(it exits the method immediately): http://stackoverflow.com/questions/4601498/what-is-the-point-of-return-in-ruby That said, I tend not to use return since ruby returns the results of the last statement(except as a guard): http://m.onkey.org/ruby-i-don-t-like-1-explicit-return There is also a gotcha involving return when considering the difference between a proc and a lambda: http://awaxman11.github.io/blog/2013/08/05/what-is-the-difference-between-a-block/ 
That's the thread I read on StackExchange. It still left me a little puzzled. I didn't know what else to call return. Thanks for the links!
Okay so it's like 'break' with an add-on? It stops the loop plus gives the value?
Okay I think I'm getting it. With this, the bar's value is 42 but it doesn't print it? It's just there waiting to be used?
I've edited and rewritten my response some more. hopefully it is more clear now.
You don't call it anything. return is implied. Just have the results of the last statement in the method be what you want returned. You will need to redo the logic though. Something like this maybe: def search(chest, gold) i = chest.index(gold) if i puts("This is what we were looking for!") else puts("Our search for the treasure continues.") end # You could write return(i) here but it's not required or encouraged. # Just put whatever you want to return(in this case i). i end I think a reason for all this avoiding of return statements(except for a guard statement at the beginning of a method) might help: Returning from random places in a method tends to be hard to follow and maintain by those who encounter your code later. This oftentimes includes your future self.
Since half of ruby is patterns and convention, I thought I'd clean this up for you. Let me know if you have any questions: https://gist.github.com/phene/021757255af3b9bcf4f4
&gt; it just means it will run it through the code again? No, your loop will terminate. puts() will print to the screen and will not return a value. return() will return the value of i to the console and terminate the loop. Let's try this out in the console: def search(chest, gold) i = 0 while i &lt; chest.count treasure = chest[i] if treasure == gold puts("This is what we were looking for!") return i end i += 1 end puts("Our search for the treasure continues.") end locked_chest = ["Spanish gold", "rusted scabbard", "Chalice of Youth", "jade statue"] #return_value_here will equal i since it found "Chalice of Youth" in your array return_value_here = search(locked_chest, "Chalice of Youth") #return_value_here will equal nil since it did not find "Chalice of Youth" in your array. return_value_here = search(locked_chest, "Wubalubadubdub") 
Not quite the same. You're returning the item in the chest, whereas /u/Batair_Alai is returning the index of that item.
I'll chew on this. I need to wrap my mind around this. When I do I'll be appending an update to the end of the article with any relative insights.
I wasn't concluding that because of the lambda, I meant it more as an accumulative results of previous examples. To use Colon+Method, aka a Symbol, keeps more clarity in what is being done. But this can't be the case in using a proc or lambda with inject which I now know "can" be handed to inject if they're designed for two values. So my recommendation should be to use symbol syntax in general for methods on inject, but obviously not for procs/lambdas. I'll be appending an update to the end of the article shortly. I appreciate everyone's input and insights.
IMHO, that there's a distinction between Procs and blocks reveals the design rot in Ruby. That, and the duality between lazy enumerators and Fibers.
&gt; I'm not a big fan of step by step tutorials, I tend to follow the directions on autopilot without really gleaning much information. So, I'm going to take a different approach in this series. Every post will include a Project Requirement, a high level spec and that's it. It'll be your responsibility to get the feature built and the tests to pass. At the end I'll discuss how I went about it, and you can use my repo as a reference to compare. This way you're not building my version of a pocket clone, but are getting a more hands on experience and are making your own decisions. As someone that is learning Ruby/Rails, ***thank you***!
You're correct but missing the point. It's true that /u/yourparadigm isn't returning the index in the array for the item. But, he is returning a pointer to that item (remember, everything in ruby is an object and they're always passed by reference). Given that the point of the refactor was to make the code more idiomatic Ruby, returning the item is the "right" thing to do. Also, just to be that guy, remember that an index is just a pointer. So, returning the index is the same as returning the item. You just have to do less work to dereference the pointer.
The chainable api looks great! The quick start documentation is better than httparty's and overall looks cleaner than restclient.
I've updated the article.
Okay, all that makes sense except one thing. What is the caller? Is it the method I used or is it something else?
Really cool, always great to have more options. API looks nice. It doesn't look like it supports persistent connections, which is a shame.
Some (perhaps overdue) work to do that: https://github.com/httprb/http.rb/pull/72
Instead of rolling your own waitloops, you can configure selenium to do that for you: driver = Selenium::WebDriver.for :firefox driver.manage.timeouts.implicit_wait = 3 # seconds All find_elements will retry for the defined duration. source: https://code.google.com/p/selenium/wiki/RubyBindings
Your describing a poorly managed production server. Environment variables are just that, values based on the environment. Just like programming in general it's up to the dev team to keep things sane by making good design decisions
Beefing up your Java skills will be valuable. I recommend learning Ruby and/or Python too. The big benefit to Ruby and Python is that both are excellent general purpose languages to add to your toolbox. Sure, you can learn Rails and/or Django (or Sinatra, Flask and quite a few other web frameworks) but you'll also be able to quickly and efficiently write glue code, that is, code for all the little tasks that will inevitably come up. Java is not particularly good for glue code. Trust me, I just left a Java shop where EVERYTHING was done in Java, it's just not a good language for small-ish scripts. You should also learn Javascript and SQL. It wouldn't hurt to learn how to write bash scripts (and/or batch files/Powershell if you're using Windows a lot).
I've ran into a handful of things capybara doesn't automatically wait for, and had to roll my own waitloops. The names should be pretty self explanatory. def finished_jquery_requests? evaluate_script '(typeof jQuery === "undefined") || (jQuery.active == 0)' end def finished_angular_requests? evaluate_script '(typeof angular === "undefined") || (angular.element(".ng-scope").injector().get("$http").pendingRequests.length == 0)' end def no_animations? evaluate_script('(typeof $ === "undefined") || ($(":animated").length == 0)') end def no_overlays? evaluate_script '(typeof jQuery === "undefined") || (jQuery(".blockUI").length == 0)' end I use all of these inside a wait_for_readiness method (which wraps them in a Timeout.timeout(Capybara.default_wait_time)) which is called on every page load, as well as before and after every click of an element. This is used in a Cucumber test suite of ~500 scenarios, and it has eliminated the need for any explicit sleeps anywhere in the suite.
get me a job and I'll tell you
I work in London, UK and would/have hired junior developers in the 28 - 30k (GBP) range regularly. Rough guess at conversion rate would say that 40 - 43k (USD) wouldn't be criminal to ask for, but take a look at job boards and call some recruiters for your region and ask what sort of salaries they are getting for Junior developers.
I work in Switzerland, Zurich. Our starting salary would be 30 CHF / hour (which would be [32.79 $](http://www.wolframalpha.com/input/?i=30+chf+to+%24) / hour) or roughly 60k for 50 weeks. But we only hire on a hourly based model. We're a small firm (~20 people right now). A comparison of the cost of living between [USA and Switzerland](http://www.numbeo.com/cost-of-living/compare_countries_result.jsp?country1=Switzerland&amp;country2=United+States) indicates it's roughly the same as /u/coder_ent. But I don't get how the programming language should make any difference in your salary. 
40k (figure thrown around on the other comments) seems low, but they will try to take advantage of you since you are starting out. Even when I went through a recruiter on my first Rails job (I was in the industry before that, but not programming) I got way more than that. If you know your stuff you should be able to chase multiple offers.
Um, no. I guess you can make a mental model based on empiricism like this without actually understanding what's going on, but having the same mental model as the people developing the language is going to work a lot better for you. What's described in the OP is pretty wrong, even if it works. Here's a reddit comment I wrote with I think a better explanation of what's going on with `&amp;:` http://www.reddit.com/r/ruby/comments/29tgdk/question_about_lambdasprocs_and_the_ampersand/ciqlve6 I do think the `&amp;:` construct is unfortunately confusing to many, it took me a while to wrap my head around it when people first starting using it after Symbol#to_proc was added to ruby. But, as with anything in programming, the best way to understand it is to understand what's actually going on, what each element does -- testing a bunch of things and blindly copy and pasting patterns will not serve you well. 
Yeah, I think so http://gistpages.com/2013/11/21/security_warning_no_secret_option_provided_to_rack_session_cookie
I split this gem out of a project that I did for work, http://umn-asr.github.io/liberal_education_courses/ It's not a perfect solution, but it works quite well for the sort of API endpoints that I end up writing a lot of.
Well I don't know if recruiters are always helpful. Don't worry, you don't find recruiters, they will find you once your resume is on places like Dice. There are a lot of articles on salary negotiation. http://www.kalzumeus.com/2012/01/23/salary-negotiation/ There are even companies who will give you tips on negotation and they only ask for a "tip" when they are done. I wish I could remember the name, I was looking for the company and can't find it. However since it is your first job, you may be better off not negotiating too hard, getting the experience and resume builder and then go for a better and more lucrative opportunity fast. As for me, I was lucky with my first Rails programming job. I told them I didn't know Rails and my simple programming "test" was a super simple task in Python. I learned later that others had tough tests. The first week I read a Rails book, and the next week i was committing code. It was weird, and the manager who hired me left, but it was a great start. 
nice, one more dependency of chrome 
What is your background? I didn't study comp-sci in undergrad, but taught myself after while working in a separate industry.
Studied liberal arts in college, went through a coding bootcamp in SF, went from there.
Have you looked at Sinatra? 
I definitely looked into Padrino as well, seems even simpler than Sinatra, but might even be too much for my needs, as all I need is asset compilation and super simple routing.
Try contacting a university with a coop program like The University of Waterloo. I can only really speak for UWaterloo but most of these places have job boards for four month internships and lots of talented students looking for placements. Many of these students are willing to work in places far from their home town and interview over Skype if you aren't near a suitable University. Edit: added more info.
Most likely they are running as threads, meaning there is only the one Ruby interpreter. This can have benefits such as saving memory. If memory is not an issue, and you have CPU bottlenecked workload, consider using processes instead of threads.
What are you looking for in an intern? I'm looking to do something like this
1) extension avoids unnecessary Ajax requests for every gem by placing links to redirector instead 2) I wanted to play with Elixir 3) I got another app at sla.herokuapp.com that other people could benefit too
I often read other people's code and when I see a new unknown gem, I want know what it does and how it works. Previously you'd need to google the gem, or go to rubygems and from there to it's github repository page. Plus sometimes gem's homepage isn't github page. 
I was thinking the same thing about Cuba, never heard of roda before though so thanks!
I'd like to also ask where, because I'm looking for stuff in the Boston area 
What's the difference between an intern and a regular position?
fibers are a more general concept than lazy enumerators, lazy enumerators are specifically designed for enumeration (iteration) and has a bunch of methods for that. Fibers on the other hand can be used for a bunch of stuff other than just enumeration (such as resuming after promise resolves).
If you want dynamic routing, the most basic tool you'll need is Rack. And you can think of Sinatra is a simplified DSL for Rack. It can be as simple as you want it, and its even perfect for a tiny microservice with no views, templates, or such. What part of it sounds like 'too much'? Anything simpler would be like Jekyll -- a static generator that can't do much of any dynamic routing.
Yes, and you're right there are times where using sql (or ActiveRecord or whatever) will be more performant. But I've found this code to be a fine fit in several situations: - A SQL query is extremely complex and slow, so the data has been cached in memory. In this case, I can't use SQL and the Ruby filtering is super fast. - The collection of records is small. Either because it's naturally small, or it's been filtered by a scope. Following the example of the Readme, you don't have to pass in "Movie.all", you could pass in "Movie.recent" and only search for movies that are returned by the "recent" scope. I thought about implementing sql, but at that point I'd either be re-implemeting ActiveRecord/Arel. And that seemed like a bad idea.
The fact that Railscasts hasn't been updated since June 2013 but it's still #5 really makes a statement about it.
Topics at conferences are almost always the result of a personal experience, a project a person is working on, etc. A lot of people talk about their hobby projects, others talk about problems they experienced with certain technology, a third might talk about this cool new feature they added to something. The way I do it is as following (roughly): 1. What have I been working on lately? 2. Based on that, what would I like to teach or inform the audience about? 3. With this info, is the topic interesting and unique? I personally hate giving talks if they've already been given or are too similar to other talks. Basically, is the topic/talk creative enough? As a general rule of thumb, nobody just makes up their topics at random, it's always based on some actual event/experience/etc.
I've definitely considered express as well. I'm just assuming here that it would work with gulp or grunt which would be nice for asset compilation and deployment
It does, the problem comes with when I'm refreshing the page, with push state turned on it will render a 404 if I don't have some kind of server side routing.
If it's a good tutorial, then it will be useful to people. If it's not, then it won't be. The quality of the tutorial is not neccesarily related to the interestingness of the code, you can have a good tutorial where the product is not a very interesting project -- that's in fact probably typical for beginner's tutorials, no? But the quality of the code may matter. Certainly you don't paint an optimistic picture, a tutorial on how to write code that is "kind of crappy" is probably not too useful. Perhaps individual tutorials on how to incorporate each of those technologies you mention (devise, sidekiq, cron, etc). You could also look at existing tutorials (on how to write a Rails app, or on those individual components in the context of Rails), see what you think they do well or poorly, and what you think you can do better. 
Well yeah, clearly.
There is almost always an audience for everything. Sometimes that audience is very small, but that's OK. 
I was in the same situation on Friday. It was for an autocomplete modal that was already in the DOM, but set to display: none. I used this in my step definition for my "When": page.has_css? "#autocomplete", :visible =&gt; true Took a while to figure it out to tell you the truth. Unrelated, I wish we didn't have to write explicit waits or assertions. Testing asynchronous code is hard and I've yet to find a better tool in the Ruby world besides maybe testing JS w/ JS unit testing frameworks. 
I think you'd need to have a wildcard route to return the html/javascript app.
Yep, I really just need that one route
i liked this guys approach...he didn't try to prove that you have to be a rails expert...but be proficient in one area. http://chadfowler.com/blog/2013/05/25/how-to-get-your-conference-talk-accepted/
Thanks, good tips. Yeah, I've been trying to figure out something to talk about related to recent projects. Will just have to delve deeper. 
I think it's a no brainer to do this. There are really no down sides to writing it. If nothing else, you could come back in 6 months or a year and see how much you've grown.
Yeah, gulp/grunt should integrate nicely. You might be able to save some time by using some preconfigured project that includes a gruntfile.
Here is an example of where I used it (metaprogrammed controller as a base). It is well commented so as to avoid confusion :) https://gist.github.com/jules2689/cd054f3aa9ff89bbba07 The purpose was that the duplication of authentication code (sandbox into show, edit, update, destroy and allow create/new only the one time) for a user's role (i.e. admin role, tutor role, etc) was becoming too much. AdminController, TutorController etc were essentially the same, except for the params, so I used this solution to a high degree of success.
Do it. I don't know if any of my employers read my blog or my site, but I was able to talk in detail about some of the subject I covered. That ability to show depth is amazingly crucial to getting a job, as it is a sign that the person applying for the position is intelligent and driven.
Have you thought about the licensing and copyright aspects?
Programming is something nerd too! This is very funy, two good things in one: Magic and Ruby.
Yeah, I've noticed that in many of RubyMotion gems those methods are often used. In such constraints (Apple approval) this sounds like a perfect solution!
I have looked into it and am interested. I will look at it and let you know.
Man, tanks for this advice :)
If you don't care, nobody will. If you care, then, maybe, others too. Just do it, man.
I would recommend getting a talk accepted at a local meetup first. See how well it goes, get feedback, and tweak. If it goes really well submit to a conference. For the topic, you can either pick something you know semi-well (have had recent experience with). Maybe keep a TIL journal and write one thing t you learned every day. Every month pick out the interesting ones and figure out how to put a story around them. Alternatively pick something aspirational. For example I knew very little about distance measurements when i submitted this talk, http://www.schneems.com/2014/12/27/going_the_distance.html. After it got accepted, I really dug into the subject. I still think focusing on getting experience talking in front of a group about something technical that they find interesting is the key. I've seen far too many talks about interesting things that put me to sleep. You have to keep your audience's attention before you can give them knowledge.
Just what I was looking for. Thanks.
Please elaborate. 
Good stuff. I really like the TIL journal idea. I definitely agree about practicing a lot on smaller groups and meetups to fine tune the talk. 
And what do you suggest then?
Interesting question. I did something recently for a legacy ASP.NET Forms website that I am upgrading slowly to MVC. I wrote some basic stuff about getting the two to work together which I thought I would be useful to some people. The comments were negative and I found it a bit dispiriting :-(
I think I like your first code snippet the best :( The trouble with both refactoring *and* design is that the value is seldom demonstrated on simple examples. This does a pretty good job, though one nitpick: class Something def self.blah end end I'd write that as `module Something`, since you should document that the user isn't meant to instantiate the objects. Or use `Singleton` if that is your jam.
This is a good example of why sometimes examples need to be realistic. The point of refactoring is to clean up code and to improve intent. What happens here is that people see class Raindrops def self.convert(number) factors = Prime.prime_division(number).map {|x| x[0]} ret = "" ret &lt;&lt; "Pling" if factors.include?(3) ret &lt;&lt; "Plang" if factors.include?(5) ret &lt;&lt; "Plong" if factors.include?(7) ret.empty? ? number.to_s : ret end end become class Raindrops def self.convert(drops, surface: Bucket, counter: RaindropCounts) SoundEffect.made_by(drops, surface, counter) end end .. a couple of classes, delegators, etc ... class Bucket def self.make_sound(hit_count) case hit_count when 3 "Pling" when 5 "Plang" when 7 "Plong" else "" end end end and they start thinking WTF? This cannot be the point of refactoring, even if it means that you now have more functionality. I mean, just look at the two examples. The first adheres to KISS and YAGNI and the second one is a horrible mess of indirection. If you want people to take refactoring seriously, you have to start with something that has a certain functionality and then show that after refactoring, you have the same functionality but with ~~less(!) and~~ better code. Edit: less is not always more as /u/hopwise points out.
I don't agree that refactoring = less code. Refactoring should produce better designed code. That might sometimes be shorter, might sometimes not. It my experience, it almost always produces more code since it almost always involves extracting classes/methods/etc. You're right that the unrealistic nature of this code has made the refactoring weird, though.
For whatever reason I don't use Module that often. It's something I should try. Thanks!
While not my first gem, it is my first with a command line interface. I find it useful. It builds on Erik Michaels-Ober's gems gem. Curious for your feedback. Pull requests accepted. 
Yep, I'm the author. My approach, like I mention, was to refactor until adding the new functionality was trivial. But I can see the advantage of showing the implementation before refactoring as well. 
What's the overall scope? MTGO, Cockatrice, and XMage all support multiplayer via a server component. Cockatrice and XMage allow you to run the server locally and play against yourself. XMage comes with rudimentary AI. What are you thinking of implementing? Recycling: Do you have to roll everything from scratch? As /u/Spiph said, this is a huge undertaking, and a lot of people have done similar things. Can you reuse someone else's rule engine? CardForge is even receiving updates for Fate Reforged. Integrating with an existing engine would save a _lot_ of dev time.
The information from Railscasts is often outdated. The general things have stayed the same (as of my understanding, I started with Rails 4), but a lot has changed. I get that some people learn best if they listen to people, but if they do, they should try to listen to the current information. And not go for old stuff. Some might say, that they can give a bigger picture. But if you start using Rails and start learning Rails, I think it's counter-productive to listen to old, outdated screen casts. You should first get a gimps of what Rails is like today, and where it's heading. Then maybe add some older information to your knowledge.
I like it! I'll give it a try in next week's post.
The idea is create from scratch, using only ruby. The scope on the moment is only create for multiplayer via server, later we can think on another features.
You can either do that to actually return the value, or print it using each: [1,2,3,1,3,-1,2].each { |e| puts e == -1 } 
Very interesting. I don't think it's fair to contrast this with Rails of Sinatra, though, since those set out from the beginning to be full-stack webapps. It'd more comparable to Rack, I'd say.
No.
this will return an array with one or more element that will validate the condition. i think i would use a while look and it would work but, i want more detail on why this would not work
this will output the element, imagine if i had to use it somewhere else, it would not be useful
It will not work because a block is not a proc. The return keyword always returns from the method or lambda in the current context. In blocks, it will return from the method in which the closure was defined. It cannot be made to return from the calling method or lambda. So if you REALLY REALLY want to return the first match and bail, wrap that code in a function and then the return inside the block will act as expected. Though you can get the same thing in a much cleaner manner via: [1,2,3,1,3,-1,2].select { |e| e == -1 }.first 
Basically, you can't break out/return from the main Ruby loop. Try doing: return "whatever" in a clean IRB session and you will see the same error you are getting. 
Performance is always very context-specific, never a simple yes/no. You can't know for sure without a benchmark.
Well, you certainly achieved that! :)
Okay, so I am a novice programmer, but I am always interested in the implications of problems like this. I would assume the reason the rspec team doesn't create a new rspec compliant version of Ruby is that it would be way too much work and disrespectful to Matz who made it in the first place. Is this true though? The concept of creating a language like Ruby is so beyond me that I really don't know what's at play here.
There's a second edition that covers 2.1 and yes it's definitely worth reading.
Excellent, thanks for the quick response.
You can't return from something that isn't a function and when you try to Ruby throws that `LocalJumpError` you're seeing. The thing is, you're in a function. I think Ruby must not understand that the proc is in a function unless it's passed in. Maybe it changes the binding of the function when passed. I'm not really sure.
I played with it a bit and then it became apparent it's still a work in progress. That was a few weeks ago though and I'm not a seasoned Rubyist (so I wouldn't be able to fix things as quickly as more advanced Ruby devs). The OpalRB library it uses is pretty mature and easy enough to use so it might be worth having another look soon.
According to math nerds, it's actually pronounced Pro-jekt Oil-ler. Not sure if they were trolling me though.
Not to set up and deploy, and in this case, the user isn't going to notice/care about a difference between an 80ms response and a 200ms response. 
Oy, you're right. I think I'm going to rename it Eulerplate.
The problem is the `return` in `Proc.new {|a| return method_name if a.empty? }`. That tries to return from the method in which the block from which the proc is created was defined, not return from the block, and not return from the proc. As the activation of `initialize` is no longer on the stack (the method already returned) the return fails. As the last statement in a method or block in Ruby is an explicit return anyway, you can just remove the `return` that you have there. You don't need to explicitly return anyway. An exception to this is lambdas, where I think `return` does return from the block which was used to define the lambda.
Yeah, something weird is going on. And doing some trivial examples I got the same issue even when passing the proc (ruby 2.1.2p95) def as(x, m) x.call("hello " + m) "world" end x = Proc.new {|x| return x} as x, "you" #=&gt; LocalJumpError: unexpected return def tr x = Proc.new {|x| return x} x.call("hello") "world" end tr #=&gt; "hello" I think this might be a bug, at least enough to take to SO tomorrow. But luckily passing the proc is working in my code even if I have no idea why.
It's a Manning book; therefore pricey. At least they're doing a better job of keeping their standards up than Oh-Really? of late.
You've not understood the article right :) Procs and lambdas are closures, so the context in which they were defined is important. In this case "returning from the method" means returning from the `initialize` method. As chrisgseaton points out, initialize has already returned at the point of calling the proc, so a `LocalJumpError` is raised. Your alternative code works, because `parent_method` has not yet returned. It will return as soon as the proc is called (in `child_method`) and the code after that (`#more stuff`) will never be executed. Here's an example that I hope will clarify. class Foo def initialize @proc = proc { "i would be returned from ##{__method__}, but I can't" } end def foo proc = proc { return "i'm returning from #{self.class}##{__method__}" } proc.call return "You won't see me anytime soon!" end def bar @proc.call end end foo = Foo.new foo.foo # =&gt; "i'm returning from Foo#foo" foo.bar # =&gt; "i would be returned from #initialize, but I can't" The story is different for lambdas of course.
Ruby allows you to redefine methods! There's no need to use a `Proc` here~~, you could simply redefine the method.~~ Alternatively you could define a private method which you redefine in child classes.
You're telling me I didn't understand the article. I took: &gt; closures allow a function to access non-local variables even when invoked outside of its immediate lexical scope. To mean the exact opposite of what you said. But I tested it out in another test, and got the context right. So I think I got it now, and I see why it worked in my code and not in my tests. So, as you can see what I'm trying to do is pass around that one liner, specifically that `return`. You mentioned redefining methods in your other comment, which is what I thought I was doing with `child_method` in the child classes. But maybe you mean something else. EDIT: I'm leaning towards thinking my original idea is impossible without a wild abuse of `eval`
What are you trying to accomplish by calling your gem "stupid"? If it is what I think it is, then take a break from working through code katas and watch [this video](http://confreaks.com/videos/4804-arrrrcamp2014-debugging-facades-dealing-with-imposter-syndrome-as-a-developer).
You we're redefining the `child_method` yes. What I meant was to just include the body of `@my_proc` in the method itself, but I didn't see that you wanted to use it from other methods as well. It's not a suitable solution. Using a private method still is. What I meant with using a private method is the following. class Foo &lt; ClassFromGem def parent_method # stuff child_method end def child_method grand_child_method("whatever") #more stuff end private def grand_child_method(a) return method_name if a.empty? end end There's no need for the `Proc`, you can use a private method instead. You can redefine it for subclasses if its behaviour needs to change.
I've been tinkering with it a couple of weekends. I love how easy it is to install it and get MongoDB installed. I can't wait for the 1.0 release! I'm still working the slight learning curve. Need to work with models, model/relations, and howto integrate 'components'.
Aww, there there! :)
Well, as a relative beginner to Ruby and to Rails, I've found the information in Railscasts absolutely incredible. I'm reading a few other books now and am being exposed to the newer concepts and conventions too. It's a great way to see what is really out there as I'm sure that I'll encounter both the older stuff and the newer stuff in the wild. It's certainly already true for me when I've gone exploring into the projects available on github.
Good one!
yes and its awesome
I think that for more complex concepts like relational databases, I have a much easier time understanding via video. For learning the basic language, either a book or a website (like learn ruby the hard way) seems to work fine.
It sounds like you'd benefit from an intro to computer science course or two. 
Yeah I have it too. The Second Edition is updated for Ruby 2.1 And there is a code in new books to download the ebook for free, so nice!
... or "find".
What are you trying to achieve? If you know what you are looking for you do not need to return the value. You could rather do irb(main):001:0&gt; [1,2,3,1,3,-1,2].include? -1 =&gt; true 
But that wont break out of `child_method`? EDIT: Thanks man, found a bottleneck where I can drop it. Now it's a question of "good code style" rather than "technically possible." IDK, but the phase "context matters" really made it fall into place even if /u/chrisgseaton was saying the same thing.
Why don't you just use Passenger? It can shutdown your app during times of inactivity. Passenger was exactly designed for a scenario like that.
After evaluating the options we are strongly considering on using Volt as our front end frame work on an existing app. Volt is moving fast, and in the right direction. We are working on seamless integration with Rails to help conversion. Like Meteor it uses MongoDB to persist state. However MongoDB is NOT required, and Volt can be used with an existing REST or CRUD api to preserve state if you don't need multi-user simultaneous reactive functionality. Like Meteor install and start up is easy, but if coming from a RoR perspective you may find it much easier to understand how to do advanced things in Volt
+1 for lockin' shit down.
&gt; However MongoDB is NOT required, and Volt can be used with an existing REST or CRUD api to preserve state if you don't need multi-user simultaneous reactive functionality. Is there something about MongoDB specifically that is used to provide the multi-user simultaneous reactive functionality? I would also love to hear about your seamless Rails integration. I have a side project in Rails and I'd really like to be able to add Volt's all-ruby frontend (with that multi-user simultaneous functionality) to the Rails backend in the same codebase.
O'Reilly seems more invested in conferences as of lately..
I am not familiar with the details, but MongoDB makes it much easier to track any changes to certain objects. This is used to provide the "reactivity" where if a user on browser 1, changes something it instantly appears changed on browser 2. There is no technical reason this can't be done in traditional databases, but its much easier in Mongo. But the thing is if you don't have this type of cross user reactivity then you really don't need Mongo, and the way Volt works, you don't even have to install it. There is an on going gitter.im discussion on the "Third-Rail" project to integrate volt with rails. https://gitter.im/catprintlabs/third-rail
How? Do you have an example where it is accomplished in the way we describe it? [This guy](https://news.ycombinator.com/item?id=8844531) also claims it's possible with Varnish and linked to two resources, but the resources he linked to looks nothing like what we're after. As for "bullshit marketing": the entire point of the blog post is to call for research participants who could not only test our ideas, but who could also point out anything we might have missed. The blog post does not promote a product: it very clearly states that it is research and asks for help. Furthermore, all produced code is free and open source, so I'm confused where your hostility comes from. So far, [this comment](http://blog.phusion.nl/2015/01/06/researching-http-caching-optimization/#comment-1774645899) has been the most helpful. This guy is polite, constructive, provides a counterexample in a very clearly explained manner, and we can learn a lot by conversing with him. I don't doubt that our idea isn't new. *Most* ideas in computer science are 30+ years old and somebody, somewhere, would have done it before. But that doesn't stop reimplementations from being useful. Even if Varnish can actually do it, there is still value in reimplementing it on the app server level, e.g. because it's more convenient for the user.
Let's do a systematic test: $ ruby -v ruby 2.0.0p598 (2014-11-13) [x86_64-cygwin] $ ruby proc-return.rb lambda 123 proc ERROR: unexpected return Proc.new ERROR: unexpected return The code: class X def initialize @l = lambda { return 123 } @p = proc { return 456 } @o = Proc.new { return 789 } end def l; @l.call end def p; @p.call end def o; @o.call end end x = X.new begin puts "lambda" puts x.l rescue Exception =&gt; e puts "ERROR: #{e}" end begin puts "proc" puts x.p rescue Exception =&gt; e puts "ERROR: #{e}" end begin puts "Proc.new" puts x.o rescue Exception =&gt; e puts "ERROR: #{e}" end But what is it that you want to achieve /u/Flopsey? Why do you think you need a proc / lambda with a return? Maybe there is another approach to solving that.
I just felt like writing in a self-depreciating style, and it was indeed to signal my inexperience. But it holds that this gem is my first. And it is neither powerful nor useful unless you want to do one very specific thing the exact way I do. So it is a bit stupid after all. :D However, the gem isn't the point of the post. Nonetheless, I thank you for the video. It looks interesting and I'll watch it tonight!
Thanks for providing a code sample. Your method is similar to the method that [Per Buer](http://blog.phusion.nl/2015/01/06/researching-http-caching-optimization/#comment-1774645899) suggested in the blog comments. The libvmod-cookie method seems much more reliable than using regexps to parse things. The latter looks like some kind of vulnerability waiting to happen. I presume that you are already using this method in production? What has your experience been so far? Does this method work well? Is there any room for improvement? Also, the blog article also talked about caching not based on the user ID, but on a user property with large cardinality, such as the user's access level. This way all users with the same access level can share a cache entry. Have you tried this approach using Varnish and does it work well? Finally, I have been brought to the attention that cache expiration is a problem. Suppose that the administrator downgrades a user's access level. You want to stop sending previously cached responses to that user. But clearing the cache means manual expiration, which sucks. And if you embed application logic in the cache to find out which cache key to use, then you've just returned to square one. After some thinking I've come to the conclusion that this cannot be solved at the cache level and is an inherent limitation. But if you've got other ideas, I'd be glad to hear them.
&gt; I presume that you are already using this method in production? What has your experience been so far? Does this method work well? Is there any room for improvement? Yes, and it works extremely well. Managing cookies via regexp is a little hairy, but cookies are simple, and it's fine for anything malformed to just fall through the cache. Varnish's plugin support obviates most of the annoyance. Our experience has been that caching is a complex and domain-specific task, which is why I tend to be very dubious of solutions which claim to be a silver bullet. Bad caching is at best, an annoyance and at worst a massive security hole. Consider requests with basic auth, for example; if an authed user makes a request to a basic auth-protected endpoint, the backend fulfills the request, and the cache caches it without hashing on the inbound auth header, then if the cache is in front of whatever is performing auth (which it should be!), then you're going to serve authenticated content to the next person that comes along. This same issue is present for APIs which use headers for authentication, applications which serve on both HTTP and HTTPS, and even more scarily, if you manage to cache a session cookie without properly hashing on it, you're going to start crossing sessions. There are a whole host of gotchas to be aware of. &gt; Have you tried this approach using Varnish and does it work well? Sure, we can segment on anything we want to. Varnish lets you choose both whether you want to deliver a cached copy based in the inbound request (vcl_recv) and whether (/how) you want to cache the backend-fulfilled request (vcl_fetch) on arbitrary logic. For example, we wrote a Varnish plugin which performs hmac validation of a signed cookie value, and then segments on the cookie payload. This gets us exactly what you describe - caching on a user property, but with the bonus of being actually validated. Since it's hmac, our app and Varnish have a shared secret which they can use to validate data set by one or the other without actually having to talk to each other directly. We set a lot of headers in inbound requests (for the app to consume so it's aware of what the cache thinks of the request) and on outbound responses (so Varnish knows what we think about a given response), and are able to implement extremely flexible caching. Most of our stuff is handled through cache-control headers, but we have special cased overrides in the vcl. &gt; clearing the cache means manual expiration, which sucks...I've come to the conclusion that this cannot be solved at the cache level and is an inherent limitation. Yup. And now we're back to why I tend to be dubious of silver bullet claims. Caching is a highly domain-specific problem, and it's practically impossible to roll a fully cache-level solution to it outside of everything but the most simplistic use cases. For this particular issue, Varnish supports two critical components - ACLs and PURGE requests. We have an ACL set up that permits our internal subnets to issue PURGE requests, and then we use Rails observers to track changes in models which back cached content. When a model changes (or when we manually invoke a purge), we queue a Sidekiq job which sends one or more PURGEs to our Varnish cluster to invalidate existing cached content (and to send purge requests to our upstream CDN when appropriate!). This lets us proactively expire cached content as it changes, which means that we can use far-future cache values for much of our content, which means very high cache hit rates. If you don't want to proactively expire, you have to either a) push a new cache key to the client when they make a mutative change, which means that only that client gets the new cache key, or b) tolerate stale content for a period. Both are valid approaches depending on the application, but none of the three approaches is ideal for all use cases.
I'm fairly certain that the reason they went with MongoDB initially is because of how easy it is to get it up and running. In time, they're going to provide an API so people can write their own adapters for other databases. Personally, I'm extremely excited about Volt. As soon as it's ready for other databases, I hope to contribute to a Neo4j adapter.
I'm not sure what the downvotes are for. The parent is correct that this is Varnish's wheelhouse. ESI has been around for 14 years, and Varnish provides high-performance battle-tested cache segmentation that does precisely what the blog post aims to solve. It's admirable that the Phusion guys want to make caching easier, but it's disingenuous to market it as new or novel; these are long-solved problems. It's important to understand the state of the art before aiming to fix it.
Okay, first, a bit of Reddit formatting. If you add four spaces at the beginning of a line you get some nice fixed-width code formatting. You can indent properly with this, and make your code readable to those who might not help you otherwise.
The `return` only applies to the scope that the proc closed over, it's not evaluated in the scope the proc is invoked. 
My downvote was for the rudeness. This type of "prove them wrong" aggression is toxic to our community.
Funny, I find the bold marketing claims done by both Phusion Passenger but also Joyent to be toxic to communities. Varnish is written by a FreeBSD developer, and is written in a way to utilize a UNIX-kernel just right. Yet, these people have the audacity to claim their solution is better, faster and be innovative, without even looking into the features or documentation of Varnish. The last time Phusion was out doing marketing, it was the bullshit benchmarks for Ruby-raptor. Torquebox called their bullshit with their 4.0.0 release: http://torquebox.org/news/2014/12/05/torquebox-4-0-0-alpha1-released/ Build better software, stop doing pointless benchmarks, stop the marketing bullshit, and research your claims.
You realize you replied exactly the same way again, right? Aggressive, aiming to prove me wrong. Your behavior is toxic.
Wow you are amazing for taking the time to help me. I'm going to change my code now and see if it runs!
Where am I? The HN comment section? While I appreciate your technical input here, being a dick about it hurts the community. Please continue to contribute, but being a polite about it would be appreciated!
+1 appreciate your input, but don't approve of you being a dick about it. Please keep contributing, but drop the attitude.
Pass in the IO via dependency inversion. def initialize params = {} @url = params.fetch :url, '' @dom = params.fetch :dom, '' @io = params.fetch :io, $stdout end def prompt @io.puts solicit_url if @url.empty? # etc ... end Then, in your test: it "does not solicit_url if given one" do url = "http://en.wikipedia.org/" io = StringIO.new interface = Interface.new(url: url, io: io) io.to_s.should == "????" end Honestly, I think your first mistake was thinking that there was somehow something different about how to do this in rspec. Testing something in ruby is essentially the same no matter what framework. It's all just ruby. Make your object *testable*. 
\#1 bit of advice that a friend gave me a while back: "write some code, lmfao"! You've gotta practice. Make up a project and see it through to the end! Contribute to some open source! Ask and answer some Stack Overflow questions!
Any recommendations on something specific to build that would develop fundamental skills? 
Something as simple sounding as Reddit clone app will get you pretty far in learning various aspects of Rails. - User authentication - Voting with ajax - Links &amp; comment &amp; user model associations - Writing tests - Deployment &amp; basic sysadmin 
I am not sure if you are the author, but consider `#flat_map` over using `#map` and `#flatten`. 
Cheers! and its faster as well http://gistflow.com/posts/578-use-flat_map-instead-of-map-flatten
Okay, you don't say better, but you claim it to have much better performance, which is what I would classify as better, especially in a frontend cache situation. I don't know your optimal installation of Passenger, but if it is something like: Client -&gt; Varnish -&gt; Nginx/Passenger, I have a hard time how it can be that much more performant than Varnish.
Despite the all caps, I kinda have to second this. I'm pretty much in the same boat as OP and I was struggling to find additional practice. Then, while fooling around with an old programming exercise, I started writing a game by accident. And I liked it. Working on a project that you're excited to see through will keep you warm during the dark and cold parts of coding it. 
I am a total beginner with Ruby, so I'm not sure I will help you very much but: Why have you chosen Tk? Have you looked into the alternatives such as Shoes or even making it a web-based game (which it sort of appears Shoes does)? [Learn Ruby The Hard Way](http://learnrubythehardway.org/) mentions making web games, even if you decide to stick with Tk you may find glancing at that helpful. It may be helpful to jump onto some Tk/ruby related IRCs or mailing-lists too. When working with GUIs it is a good idea to use a separate thread as it should prevent the game logic code from lagging / hanging the interface. I do not know how Tk works but I would guess there may be an event system that you could hook into, that would let you call methods without requiring a repeating loop. My final suggestion would be to look into state machines, it appears there's a few gems that could be useful and many games use state machines in some form or another. Finally: Good on you. This sounds like a really neat project to learn Ruby with and a great learning opportunity! I look forward to seeing how it progresses!
I'd like a good guide (or pointers) for starting with ncurses as well.
I've only played around with it on Linux. Never used it on Windows and I'm not sure about the support there.
The choice to use Tk was more-or-less arbitrary. I like the idea of making this web-based, it's a more relevant platform either way. Thanks for the reply.
I'm afraid with Ruby bindings for wxWidgets no longer actively maintained (AFAIK and I'd like to be proven wrong), the simple answer to the OP's question is *No, it is not possible in any sane way*.
Qt bindings still seem to be maintained: https://github.com/ryanmelt/qtbindings/
`.select { ... }.length` can be replaced with `#count { ... }`.
For some reason this test makes the terminal hang, and I have to ctrl-C out. I'll paste the fix once I figure out how to make it work.
There's no reason other than the fact that it was a technology already in the existing stack. Would one of these applications satisfy my need, and more fundamentally is it the correct way to deal with this exact premise - i.e. dormant scripts rather than sitting in a constant loop, or sleeping for that matter and waiting for input. Is there not something native to Ruby that allows for this functionality?
Could the constructor just have: @io = $stdout since it would always be instantiated with the same value?
Yeah, the important thing is to be able to pass a different value for `io` in your tests; specifically, you want to inject in that `StringIO.new` object so that you can observe what gets `puts`'ed to it. So if you want to do this: def initialize io = $stdout, params = {} @io = io # params etc. end That's fine. You'd just change the test to call `Interface.new(io, url: url)`.
Yeah that's just an rspec concern. The larger point is that you can use "inversion of control" to make the test trivially testable in any test framework. I don't use rspec, especially not that awkward `expect` 3.0 stuff, but what's great about inversion of control is that we could both write tests for this object in any test framework we want to without much trouble.
From my viewpoint based on your description of your application you have two tasks: * Get the request processed as fast as possible * Store the response until it is needed For the first one if you want to keep the Sinatra server and backend script separated code-wise then a message queue is the right way of doing it. If you don't mind putting all the code into one application AND don't expect it to need to scale horizontally then convert the backend into a library and call it natively from your Sinatra code. For the second task a database is appropriate. It doesn't need to be SQL - key/value stores may be better suited, depending on how the retrieving code identifies the response. 
here's some example code that might or might not be helpful - it uses TkText as a console to wrap an IRB session. https://github.com/martindemello/guirb check out bind("Key-Return") in tkkeys.rb - it calls out to the irb session when the user hits "enter", without blocking the tk main loop. you basically need to encapsulate your game into something that stores its state, and updates it via method calls that run, update the state, and return whatever output the tk app needs to display.
Used ruby tk recently without any problem. You need to install tcl/tk from here http://www.activestate.com/activetcl and then when you install ruby with RubyInstaller select "with tcl/tk". It's quite fast and works with ocra to create windows executables.
One way would be to compare resulting strings (i.e. use #to_html) but that is probably not very reliable.
This is a feature from a js library I like (chance.js) and I think it would go well with your library. @listOfMonsters ||= Array.new @listOfMonsters.push(Goblin.new) @listOfMonsters.push(Orc.new) //And so on and so forth //Your library @nextMonster = RpgTools::Dice.pick(@listOfMonsters) 
So I would have to create some method that takes the XML::Element object and makes an Xpath expression from it?
Probably not. JRuby is supposed to be fast, but not in all cases. For example one app that I've worked with migrated from MRI to Ruby. The app performs a lot of XML parsing. Moving to JRuby actually slowed it down. The fact is that Ruby is a much more dynamic and complicated language than Lua. The JRuby team has done a great job, but there will always be pathological edge cases. Lua is so simple that it's easy to jit. Having said this, not all hope is lost. * For certain workloads JRuby may indeed be much faster. Maybe also Rubinius, but I have few experience with it. * My favorite approach is to delegate expensive work to a C program or a C native extension. This is pretty much how the Python guys handle CPU-intensive work. Con: you have to learn C.
it doesn't. jruby is made to match up with MRI ruby, so it's always a few versions behind. Current jruby is ~MRI ruby 1.9.3 i think. Also, jruby has a substantial startup cost that MRI does not, jruby needs to spin up a JVM, MRI just runs.
Thanks for your answer ! I thought of a monster generator too but I think it will be quite a big feature. I'd like to make it full customizable so I'll take time to do this properly :) 
Seriously, is on db/ folder. If you find something wrong, create one issue please :)
I know this is not the answer your looking for but I'll post it anyway. Check out nim. It's a language that feels just like Ruby but compiles to c so it's really fast. Don't have all the good gems though...
That's really interesting. Would a message queue be written natively through Kernel select or forking, or is that too specific?
&gt; Con: you have to learn C. That's not a con. It's a long-term pro.
Ok so I've made some progress, but there is another snag. Here's what I did. * Set up wikipedia as an XML document using Nokogiri, and then turn my DOM string into an XML element (inherits from XML Node). wiki = Nokogiri::XML(open("https://www.wikipedia.org") 2.2.0 :072 &gt; wiki.class =&gt; Nokogiri::XML::Document node = "&lt;title&gt;Wikipedia&lt;/title&gt;" 2.2.0 :080 &gt; node_xml = Nokogiri::HTML::DocumentFragment.parse(node).child =&gt; #&lt;Nokogiri::XML::Element:0x46c0ac6 name="title" children=[#&lt;Nokogiri::XML::Text:0x46c08fa "Wikipedia"&gt;]&gt; 2.2.0 :081 &gt; node_xml.class =&gt; Nokogiri::XML::Element ---------------- * Search in my wiki for node_xml using xpath. **Note** - I'm not sure that this is a great method, and I need to figure out how to find the correct node if there are node with the same &lt;tag&gt; or whatever. 2.2.0 :076 &gt; my_node = wiki2.xpath("//#{node_xml.name}").first =&gt; #&lt;Nokogiri::XML::Element:0x4454468 name="title" children=[#&lt;Nokogiri::XML::Text:0x4454300 "Wikipedia"&gt;]&gt; 2.2.0 :077 &gt; my_node.class =&gt; Nokogiri::XML::Element * Here is where I think it breaks. [According to the Nokogiri docs](http://www.rubydoc.info/github/sparklemotion/nokogiri/Nokogiri/XML/Node#traverse-instance_method), I can use #traverse to recursively push all children of a node into an array. children = [] 2.2.0 :086 &gt; my_node.traverse {|node| children &lt;&lt; node } =&gt; [#&lt;Nokogiri::XML::Text:0x4342890 "Wikipedia"&gt;, #&lt;Nokogiri::XML::Element:0x434311e name="title" children=[#&lt;Nokogiri::XML::Text:0x4342890 "Wikipedia"&gt;]&gt;, #&lt;Nokogiri::XML::Text:0x4454300 "Wikipedia"&gt;, #&lt;Nokogiri::XML::Element:0x4454468 name="title" children=[#&lt;Nokogiri::XML::Text:0x4454300 "Wikipedia"&gt;]&gt;] 2.2.0 :087 &gt; children.count =&gt; 4 _________ Only problem is that I have no idea if this works, or will continue to work for any given DOM string. Any thoughts on how to do this? 
Parse the whole document: my_doc = Nokogiri::HTML(open('https://www.wikipedia.org')) then you can get the set of all title tags using either an xpath query: all_titles = my_doc.xpath("//title") or a css selector: all_titles = my_doc.css("title")
Why are Dice, Card, and Coin classes? They only have class methods, they don't store any state, none have `#initialize` defined. Modules might be a better fit. The `require` statements here are a bit unusual: https://github.com/Yinfei/rpg_tools/blob/master/lib/rpg_tools.rb Usually people use the something like: `require 'rpg_tools/card'` and use the `-Ilib` flag when loading the gem from a source directory instead of RubyGems. I use `require_relative './lib/rpg_tools/card'` in my gems but it breaks compatibility with &lt;1.9.3 . I mostly use it because I don't like dicking around with the loadpath when I want to load from source rather than RubyGems, but most people use the first variation. *You might also consider breaking up the Cards class into Cards and Deck. You can send messages to Deck (`shuffle, draw, discard`) and have Card objects as your return value. Cards could accept messages like `suit`, `value`, etc. You could even make Deck and Card agnostic to what types of cards are being used, and allow users to subclass or `include` Card to make PokemonCard, MagicCard, etc. **You could probably consolidate your various `roll` methods into one that takes an options hash and or a block.
go to codewars website and start doing basic challenges. you can then compare your solution to others. 
When you have a bottleneck you should inspect your system and use measurements to figure out what needs to be fixed. Otherwise you risk adding unnecessary complexity and not fixing the underlying issue. A message queue would be good fit for the task you described. Unfortunately it adds more moving parts to the system that need to managed properly. Monitoring, updating, error scenarios (out of disk, out of memory, interprocess operations, sudden server death, data persistence, ...). It might be worth it if you get a lot of requests. If you want to keep your tech stack as such, you can modify it a bit and get a nicely working system: * modify the poller to include a REST api to trigger a task * modify public API to save the request and call the poller API to schedule the task * for error recovery: modify the poller to check on startup if there's tasks in the db that need to be done and poll occasionally (every 10 minutes) 
Yep, I used SuckerPunch because it was the absolutely easiest option on Heroku that did what I needed; required no external database or any overhead. Most of my projects are SuckerPunch first then migrate to Sidekiq as needed. SuckerPunch to Sidekiq is a handful of changes and then it Just Works. (Thanks for the Awesome there Mr. Perham!)
Having pretty much grown up around web development with rails, a couple months ago I was reading about CGI and felt like I had missed out. I managed to write a very simple CGI script just to see how it works. I probably should have used the Ruby CGI library, but I ended just printing out the HTTP headers myself. It was a pretty cool experience, and I now have a sudden urge to play with it a bit more.
I'm writing a script that will get two inputs from a user (not known in advance).They are both provided in the command like via $stdin and $stdout - a URL and an HTML DOM string. It could be any HTML tag and any url, I cannot know in advance. * Example url = "http://www.bestbuy.com" input_dom = "&lt;ul class="utility-nav"&gt;" and then get #count for all descendant nodes (so children, children-of-children, etc). You'll be given the exact HTML DOM element that we need to find, so I need to find the unique one, or at least the first that satisfies all the attributes. I know that some combination of Node#tranverse and Array#count will work for that last part. &gt;The child text node is just that, a child node, it isn't at the same level as the title node. I don't actually need any other info from those nodes, just to count that they exist. I just want to locate the node for the user's given DOM, and then get a count of all the children, etc.
The issue is that I don't know what kind of HTML tag it will be. That is why ideally I want a way to either match the exact string as a string ("&lt;div class = "whatever"&gt;Hola&lt;/div&gt;)" or to match all the nodes selectors (which I don't know ahead of time). That's why it's tricky for an Xpath noob like myself.
Isn't there already an open-source github clone? Edit: this is what I was thinking of - https://about.gitlab.com/downloads/ 
No, but that's not the only thing you can do with Ruby, and even if, it would probably be useful once in a while. 
try gitbucket too. Deploying it is way easier.
I'd love to hear other opinions, but I generally wouldn't test the fact that the validation is run on update. That seems to fall under the "testing built-in Rails functionality" umbrella. I might, however, test the side-effects of the `#update` call that triggers it, or even the callback method itself. Testing the callback method is kinda messy because it isn't really part of the class's public interface. If it's a complex callback that can be extracted into a callback class ([Rails Guide link](http://guides.rubyonrails.org/active_record_callbacks.html#callback-classes)), then it can be more easily tested in isolation. Here's a pretty contrived example of those two types of test on a class that updates a list of usernames each time the `User` class is updated: class User &lt; ActiveRecord::Base has_many :previous_usernames after_validation :record_username, on: :update def record_username previous_usernames.create!(name: username) end end describe User do describe "#update" do it "adds a previous username to the user's list" do user = User.new(username: "johndoe") expect { user.update(username: "jdoe") }.to change{user.previous_usernames(:reload).count}.by(1) end end describe "#record_username" do it "adds a previous username to the user's list" do user = User.new(username: "johndoe") user.update_attribute(:username, "jdoe") # Skips validation expect { user.record_username }.to change{user.previous_usernames(:reload).count}.by(1) end end end Edit: Added `#it` blocks to the tests :)
+1 to this. Test the result of your callback, not whether the callback actually ran. If there's a chance that your callback can fail and roll back the transaction, test success and failure scenarios.
In my opinion it is a good skill to have. But let's face the facts: C kills are not popular in the Ruby community, or else Phusion Passenger would have gotten a lot more contributions. To most Ruby programmers, having to learn C is a con.
My Git server of choice is http://gogs.io/. It's built in Go so it's really easy to deploy and it's quick! We use Gitlab at the company I'm working at, but our sister-company has just started using Gogs (on my recommendation as I use it outside of work - and they love it).
Thanks! this really helps!
By doing this: https://github.com/NARKOZ/gh-ex/commits?author=NARKOZ
Thanks! Yes, that is how I have been developing it. If I find a failing string I add a unit test for it. If you come across any failing examples let me know or open an issue. Cheers!
Thanks! Anything to add that I've missed? 
I just read this book and did the online blog/video/podcast tour and my opinion is that while it's out of date in many ways, and sometimes poorly written, it's still the best one-stop-shop for this information. Supplementing this book with some of the other resources mentioned here, along with lots of your own trial and error, will help to keep your learnings aligned with current technology. I've also been studying this blog post, in addition to many of the others mentioned: http://www.sitepoint.com/soa-for-the-little-guys/
You should repost this with a tag - F4F - I bet people just read your headline and assumed you were male. 
I just thought I would follow up, as I read more of your post. I also bet folks might be reluctant to help you as they wouldn't want to enable someone to misrepresent their capabilities in an interview. Perhaps that isn't the case here, but that will be the default assumption. You'll need to explain that better. Also, Getting one-on-one tutoring is a big lift for most people, especially if you're a stranger to them. You might need to try to find a paid tutor. Finally, if you actually want to learn to code in ruby and in rails, maybe look into http://railsgirls.com/ 
As /u/rio517 said you should probably be offering to pay this person as a personal tutoring session is above and beyond the kind of help the community usually offers each other. You don't want to start out [as a help vampire](http://slash7.com/2006/12/22/vampires/)!!! But, that being said you probably should be figuring it out on your own anyway (that means do not copy and paste from tutorials!!!). If you feel that tic tac toe is too advanced at this stage then maybe Project Euler would be better place to begin. The important thing is that you figure it out for yourself (just brute force it if need be) and then only AFTER you've gotten something that works should you look up more elegant solutions. Programming is a way of thinking that you only really get by doing. Especially at this early stage help is actually counter productive. And again as /u/rio517 pointed out, if you do want this anyway I would repost with an f4f. I clicked assuming you were a creeper looking to face time with a female rubyist (rubyista?).
I'm not talking about a monster generator but about a method to pick things at random from a subset. Kind of like your deck but not limited to deck of cards. The monster array was an example themed to this gaming gem.
Please note that the Singleton pattern is often abused and misused. Why? Because a singleton instance's state is global. You can run into all kinds of problems when modifying global variables, see e.g. [this](http://misko.hevery.com/2008/08/25/root-cause-of-singletons/). Logging is the perfect example for when you might want to use a Singleton, but for other problems there could be better solutions.
I came here to make fun of the dude because he was picking up girls in /r/ruby but now I can't do it. I feel empty now...
`Nokogiri::XML::Node#to_s` does whitespace cleanup and adds its own newlines and indentation so `Nokogiri::XML(my_string).to_s == my_string` will be false for a lot of valid `my_string`. Parsing and then calling `#to_s` on `node_string`'s contents might get you closer: def grab_node(node_string) reformatted_node_string = Nokogiri::XML(node_string).to_s @doc.traverse do |node| return node if node.to_s == reformatted_node_string end end I'm not convinced this is a robust or unambiguous strategy though; I think you'd be far better to ask the user for the XPath query they're interested in rather than trying to both interpret an arbitrary markup fragment and specify what it matches against. Alternatively, does it actually matter what `node_string` matches against in `@doc`? If you want to know how many child nodes it has you don't need a copy of it that you've parsed from a separate document in order to count them...
Well it really all depends on what you want to build. For doing something web related you will probably need rails or another MVC framework or create your own http request handling program. If you just want to create a ruby program that would run on your machine all you need is ruby and a basic text editor. Hell you can use notepad. Personally I use notepad++ it has all the basic programming text editing options and it's free. Having RVM would be a good idea as well. It makes working with Gems (like addons or modules or libraries or whatever you want to call them) a lot easier. I can help suggest things to add to your stack if you have an idea for a project or you could just go the easy route and add something like [BitNami](https://wiki.bitnami.com/Infrastructure_Stacks/BitNami_Ruby_Stack) which will give you a full ruby stack to work with for just about anything you could want to do. Just add your gems and your good to go.
Same, my initial thought to the link was, "picking up in /r/ruby, this is the saddest thing I have ever seen". 
Not a very complicated gem, but I've found this useful in the past. Feedback welcome.
This is great. Thanks so much for supporting the community! 
Haha yea I had no intention of becoming a master of Ruby. Just, like you said, very familiar with the basics so I could move on to rails and begin building web apps. Thanks for your reply. Also, I picked up *The Well Grounded Rubyist* since that seemed to be a popular book for learning Ruby. What are your thoughts on that? Could I use it instead of *Learn to Program*? Does it even matter which book/source I use, as long as I'm learning the basics? Edit: I just checked out your Rails link, and saw that I already had it saved under my coding tab. So apparently I already bookmarked it for the future once I get there. Just thought that was funny. 
I'll check that site out. Thanks!
Hey - yes, Engine Yard is built on Ruby actually. We were the first PaaS for Ruby and Rails and have since expanded to PHP and Node.js. We offer Sinatra as well and the whole product is written in Ruby.
I'd actually suggest avoiding Rails until you have Ruby down somewhat. Every Rails guide contains a little bit of Ruby, with git, SASS, RSpec, Capistrano, Unicorn, Coffeescript, and then the whole process of learning Rails itself. You can walk through the basic "create a blog" tutorial without actually learning much Ruby, yet still feeling overwhelmed.
This is also known as the Knapsack problem, you could get an approximate solution using a greedy algorithm, basically you sort the array and start adding the numbers until adding one more number makes you go over your target, example: [1, 3, 4, 6, 10] -&gt; 10 + 6 + 4 + 3 = 23 In this case we get the correct solution but if we had for example this array: [1, 3, 4, 6, 9, 10] -&gt; 10 + 9 + 6 = 25, in this case the algo would return 10 + 9 as the solution So if you want the exact solution all the time you will need to use the dynamic programming method which I can't help you with because I don't fully understand it yet, but you can find more info on the following links: http://en.wikipedia.org/wiki/Knapsack_problem http://en.wikipedia.org/wiki/Dynamic_programming 
That's what I was planning on doing. Working on Ruby until I have it down well enough, and then move to rails.
Well some good places to start learning Ruby: Codecademy as was suggested already I see [Ruby Monk](https://rubymonk.com/) I loved learning through this. Not to complex as far as explanations and not to dumb. [Ruby Koans](http://rubykoans.com/) This can be a little complicated but there are plenty of places (*cough* stack overflow *cough*) that you can get help with it just goggling ruby koans x As far as Rails [Rails tutorial .org](https://www.railstutorial.org/book) has an online book for free that is a pretty good read Also for diving right in and learning another thing to look into is online IDE like [Cloud9](https://c9.io/) they install the stack for you you can have an unlimited amount of development boxes. Which personally I love this route. It comes with MySQL RVM rails and ruby easily. You pretty much can go from nothing to testing environment in like 30 sec. 
This is actually exactly how I started learning. Then, after I got bored with reading through it, I took the basic knowledge I learned and started learning from example code.
to reference/return the value of an element of a hash with key 'x' restaurant_menu[x] to set the value of an element of a hash with key 'x' restaurant_menu[x]= value
 A hash is collection that retrives a value using a key. So you have the following hash. restaurant_menu = { "Ramen" =&gt; 3, "Dal Makhani" =&gt; 4, "Coffee" =&gt; 2 } To access the contents of Ramen you write. restaurant_menu['Ramen'] # =&gt; 3 In the above code, the key 'Ramen' was used to get the value of 3. Now, take a look at this code. Hash[ "Ramen" =&gt; 3, "Dal Makhani" =&gt; 4, "Coffee" =&gt; 2].each do |key, value| puts key.to_s + " =&gt; " + value.to_s end It outputs Ramen =&gt; 3 Dal Makhani =&gt; 4 Coffee =&gt; 2 The method #each takes an item at a time, splits the key and value, and assigns it to variables key and value. In your example, x is the key and y is the value. The original code can be written as follows, but it's much more verbose. restaurant_menu = { "Ramen" =&gt; 3, "Dal Makhani" =&gt; 4, "Coffee" =&gt; 2 } restaurant_menu['Ramen'] = restaurant_menu['Ramen'] + (restaurant_menu['Ramen'] * 0.1) restaurant_menu['Dal Makhani'] = restaurant_menu['Dal Makhani'] + (restaurant_menu['Dal Makhani'] * 0.1) restaurant_menu['Coffee'] = restaurant_menu['Coffee'] + (restaurant_menu['Coffee'] * 0.1) 
yes, it is similar to accessing or setting an element of an array where the key is the index of the array &gt;&gt; a = ['a', 'b', 'd', 'd'] =&gt; ['a', 'b', 'd', 'd'] &gt;&gt; a[2] = 'c' =&gt; 'c' &gt;&gt; a =&gt; ['a', 'b', 'c', 'd']
Make the documentation better, and assume the reader does not know all of the JFM (Just Fucking Magic) which is happening behind the scenes. I fucking hate it when Ruby tasks such as Bundle, Rake, and Gem fail with some abstract error message that to call it cryptic is giving it credit which turns out was due to the script relying on some JFM which became deprecated 2 versions ago but is not documented yet, because... you know... JFM. Or because the end user is on RHEL or a RHEL derivative and cannot upgrade past 1.8.7 (as an example) because of internal policies.
You're going to want to override the `inspect` instance method if you want change what the return value is within a console session. class Name def initialize(name) @name = name end def to_s @name end def inspect "Time is #{self}" end end &gt; dewski = Name.new("dewski") # irb calls Name#inspect =&gt; Time is dewski &gt; p dewski # p calls Name#inspect Time is dewski =&gt; Time is dewski &gt; puts dewski # puts calls Name#to_s dewski =&gt; nil Objects interpolated within strings also have #to_s called on them. Can see an example in Name#inspect. Hope that helps.
&gt; I found a possible solution that doesn't require HTML to Xpath translation. Let me know if this looks legit. &gt; So it turns out, if I have a Nokogiri::XML::Element (which is what our node becomes), I can call #to_s on that. &gt; HTML_input = "&lt;title&gt;Wikipedia&lt;/title&gt;" &gt; &gt; 2.2.0 :114 &gt; example_node = #&lt;Nokogiri::XML::Element:0x434311e name="title" children=[#&lt;Nokogiri::XML::Text:0x4342890 "Wikipedia"&gt;]&gt; &gt; &gt; 2.2.0 :115 &gt; example_node.to_s &gt; &gt; =&gt; "&lt;title&gt;Wikipedia&lt;/title&gt;" That is the approach I suggested is unreliable [earlier](https://www.reddit.com/r/ruby/comments/2rno2p/nokogiri_how_to_find_a_node_given_the_exact_html/cnhl238). I find it more elegant to create an XPath expression because * it gives more control about what to use as matching criteria (e.g. you could ignore HTML attributes), * that does a structural compare (e.g. compares reordered HTML attributes properly), * is probably quicker for large documents because the traversal is done in C code. Did you try the code I posted?
I prefer that over Python that still maintains their old version, and can't push for the new version.
I'm really sorry, wasn't thinking. class Test def inspect "wut" end end This is what you want, as pointed out by /u/Dewski
I haven't looked at the gem yet, but I advice you to name it differently, as violated is also used to say someone has been degraded or even raped or sexually assaulted. That is not really a proper name for a gem. Edit: some other concerns: * `include Violated.new` is quite strange. Understand that you create a new instance of a class/module Violated::Violated, but it looks really weird, since you don't really instantiate modules (i.e. Violated.new). It would be better to do use `included` in the ::Violated module to instantiate a new object of the Violated::Violated class and then extend that object. I'm also not completely sure why you need a separate class in the first place. Why can't everything be put in ::Violated? * Your modules and classes are really similarly named, i.e. Violator, Violation and Violated, which makes reading these things really hard. Edit2: Thanks for the down vote. I don't understand why anyone thinks it is wrong to point out that the name of a gem is a synonym for raped. Please enlighten me.
Thank you EngineYard, that is really admirable! People can also support Bundler on Gratipay: https://gratipay.com/bundler/ 
This is great and all, but why does a big project like Bundler need funding? Are there some big features planned?
I think they did. :( This is for a program for people who DO NOT have any programming experience so they can learn programming. I am starting from level 0 here and the program is free (I can't afford a tutor). I'm just going to read the book I bought this weekend and hope to God I get into the program. The game doesn't actually have to work and I don't need the help in telling me what to do but rather why I would do this rather than that. I'll figure it out. Thanks!
The state_machine gem is my least favorite. Look at the source code for it: thousands of lines of meta magical Ruby. Transitions is good in my experience. 
*Now* you see, /u/threeifbywhiskey?
http://www.ruby-doc.org/core-2.2.0/Fixnum.html In Ruby there are two types of `Integer` classes. `Fixnum` is used for smaller values while `Bignum` handles the larger values. Ruby converts back and forth between the two depending on the value.
Already read them but still don't understand what I need them for
You should take a look at [Scrivener](https://github.com/soveran/scrivener), which does this as well and lets the UI handle the error message, based on the error keys.
What? Rails is a web framework, so just a very specific tool for a very specific type of projects. You an run ruby code in different ways. To start with there is a commandline tool named `irb`. You can open it and type any ruby code you like. So that's the most simple way. Then of course as with most other languages you can use any text editor you like (notepad, textmate, kate, sublime...) save a file like `myprog.rb` and run it with ruby myprog.rb from the commandline. Beyond this basic usage there are a few Ruby IDEs, maybe the most used being [RubyMine](http://www.jetbrains.com/ruby/index.html) from JetBrains. But some others like Aptana, Netbeans, Komodo etc have support or pluginns for Ruby code. What is the best way really depeds on what software you write and on which OS. I think most Ruby devvs are on either Mac or Linux where it is easy to make a script executable. Also they are used to running things on the command line and not necessarily care much about IDEs. Or they use some editors that integrate with the cl, so they can run code easy enough.
You can do it with any text editor or code editor; I prefer Aptana studio (mentioned by PilotPirx as well) for coding ruby on a Windows machine. Also you can pretty much drop rails and just code ruby if you want, then distribute your app as an .exe with the [OCRA](https://www.ruby-toolbox.com/categories/packaging_to_executables) gem and pretty much have no dependencies to run your programs. 
just do the prep material they provide you after your initial application is accepted. keep at it until you're confident you fully understand, then find as many practice problems as you can and do all of them, too. they give you everything you need to get in. what they're really looking for is the tenacity and self-direction it takes to become a good programmer. source: i'm a graduate of the sf november 2013 cohort and now a full time developer. feel free to ask me anything. 
From the perspective of the language user Fixnums are just (almost) immutable objects and you should not think too much as /u/tacit7 suggests. Different than in other languages in Ruby there is just one kind of variable: a reference - nothing else. C++ has references, pointers and value variables - all this does not exist in Ruby. In Ruby there are just expressions that return a reference and this can be stored in a variable - as simple as that. That is true for &lt;"foobar"&gt; as well as &lt;5&gt;. The expression &lt;5&gt; happens to return the same object all the time. This is also true for other expressions, for example &lt;false&gt;, &lt;true&gt; and &lt;nil&gt; which also return the same object every time they are evaluated. Fixnum, true, fals and nil are encoded in the reference, so there is no object on the heap (there is a Wikipedia article explaining the concept but I can't seem to find it right now). This is an optimization and it makes no difference for the usage. If you send "+" with an argument to a Fixnum instance you receive a new reference. The type could still be Fixnum or Bignum. Since they both implement the same API you can do math with them seamlessly. (See [here](http://blog.rubybestpractices.com/posts/rklemme/019-Complete_Numeric_Class.html) to see how type conversions for numbers are handled in Ruby.) Edit: found the concept and the article, it's called [tagged pointer](http://en.wikipedia.org/wiki/Tagged_pointer).
It is used to prevent (integer overflow)[http://en.wikipedia.org/wiki/Integer_overflow], so you can have integers "infinitely" large. Example: n = 0xFFFF_FFFF_FFFF_FFF # maximum value for a 63 bit integer n.class # =&gt; Fixnum (n + 1).class # =&gt; Bignum
If you have questions about things just go on the #ruby channel on [Freenode](https://freenode.net/). Only thing is you need a bit of a thick skin because people on IRC can sometimes be dicks. But if you stick around someone will eventually help you out. Just ask specific questions and post your code on [pastie](http://pastie.org/) or something. If you do need more hand holding there are classes you can take. I'd recommend one of the intensive ones like [Makersquare](http://www.makersquare.com/) or one run by your local Community College. Ultimately though programming is like 99% learning how to learn things fast from various sources online about programming.
 Thanks! Do you know any other good tutorial/practice problem websites for Ruby? 
I tend to implement state machines as POROs. class BlogPostMachine def initialize blog_post @blog_post = blog_post end def state @blog_post.state end def published ensure_state 'draft' @blog_post.update_attributes( :state =&gt; 'published', # other updates ) end def unpublish ensure_state 'published' # etc end private InvalidEventError = Class.new StandardError def ensure_state *valid_states unless valid_states.include? state raise InvalidEventError, "must be in one of the following states to receive that event: #{valid_states * ', '}" end end end I find every time I've done this I've wound up with a way simpler/more testable solution than the magic gems. Having control over updating the attributes directly also prevents out of order weirdness where you're inside an ActiveRecord callback chain and some of the attributes are changing *outside* the context of the event you're sending into the FSM, and other attributes are changing as a *consequence* of the transition caused by the event.
Everything in ruby is an object and has a class. 12.class #=&gt; Fixnum So you're already using them if you're using integers. Fixnum is really just an implementation detail -- you don't really need to know more than this until/unless you do, and you'll know. 
Your approach with `ArticleFlow` seems fine, but I wouldn't call it a "service object." I'd call it a "state machine."
Great post! Only one critique: def update_params(params) params[:foo] = 'bar' params end is superior to def update_params(params) params.tap {|p| p[:foo] = 'bar' } end The first one is much clearer. Even just squinting, there are fewer symbols like `{` and `|` with the first approach. I find I use `Object#tap` occasionally, but I've also seen it highly overused.
I agree with your reasoning, but I have a larger frustration with the common conflation of "model" with "activerecord" that's prevalent in the rails community today. In your example `ArticleFlow` models a state machine for managing an `Article` entity. They both are parts of a larger domain model. Extracting this logic out of an activerecord object is certainly a win, here. I'm in complete agreement with your approach, but the language you use reflects a mistaken-but-prevalent line of thinking that I find myself running up against: * Our "models" are these activerecord objects, because, hey, they live in `app/models`. * The only way to stick in a plain, simple ruby object in our app is to assign it some other archetype, analogous to "controller" or "model", and stick that in `app`. So let's call POROs "service objects" and put them in `app/services`.
To do math with very large numbers. They work transparently though. You don't need to do anything special to use them.
Didn't know that `bsearch` is in stdlib, thanks!
It's like underused and overused at the same time. Or I should say, somehow I went a long time without knowing about it, and now I see it everywhere. The case for which I find myself using it is memoizing things with a specific state. A real example where I ran into a site being picky about my ssl protocol: def agent @_agent ||= Mechanize.new.tap do |m| m.ssl_version = 'TLSv1' end end
&gt; So let's call POROs "service objects" and put them in app/services. Yea; I agree that this is merely just moving the problem from one place (models) to another (services). I am looking at [Trailblazer](https://github.com/apotonick/trailblazer) with interest because the way I understand it, its mostly a "more places and concepts to stick your stuff then M, V, C + lib". 
You never have to guess what `#tap` is returning; it's [one of the simplest methods](https://github.com/ruby/ruby/blob/9e256261b3d5118e547ab73ae2234e4f1d124177/object.c#L684-L689) in all of Ruby.
That's a fantastic example of a great use case for `Object#tap`. Thanks!
Yeah, when you're working with SQL, there are better ways to make the query. But `#flat_map` would be useful when you're working with objects that aren't in a DB.
Array.new with a block is sometimes useful, but you could also construct the Battleship board array like this: @board ||= [['0']*8]*8
http://guides.rubyonrails.org/ is probably your best bet
&gt; 3.No more than 5 lines per method?I like short methods, but 5 lines On one hand, Ruby lends itself to much shorter code than some other languages. I've seen C coders suggest keeping things under a page. I do think 5 is unrealistic though.
Exactly. tap is something that is very useful, but rarely used. I couldn't imagine asking a junior dev to quickly understand that code. It's a bit of a chicken and egg problem though. tap is useful, and if we use it enough it will become clear to everyone, but since so few of us are aware of it, it becomes something that is confusing.
Especially when you consider properly formatted code. Its doesn't really count as 5 lines if each line is 100+ characters long
&gt; Everything in ruby is an object and has a class. One cannot stress this enough: this is one of the major strengths of the language. Other languages (e.g. Java) have objects and value types (and there are even efforts under way to extend the set of possible value types beyond the current set of ints, char, boolean etc.) which has some advantages in the area of performance but it also makes the design of the language less clean and some implementations more complex.
Yeah I can definitely picture some unreadable contractions in the interest of fulfilling rules like this.
Thanks for taking the time to write a detailed reply, and sorry for the lateness of my response. The start of a new year always requires significant time AFK :) Regarding the Rack bug linked: I don't know enough about the internals of Rack or the specifics of that benchmark to comment, so I'll stick to the example given. ## Performance &gt; By supporting different access patterns like header["Accept-Language"] and &gt; header["ACCEPT_LANGUAGE"] ... We're getting a performance penalty. You're partially right here, but I think you are confusing two different issues. We are talking about subclassing Hash. Support for different access patterns is entirely tangential. The performance hit you have benchmarked is **not** a result of supporting different access patterns, or a result of subclassing Hash. Instead it is a result of rewriting the `#[]` accessor in Ruby (rather than relying on the C implementation). Consider the following benchmark results, based on [this code](https://gist.github.com/smlx/8950f81f6d72c61bc003): $ bundle exec ruby bench.rb Calculating ------------------------------------- encapsulate 200.244k i/100ms subclass_rw_acc 185.660k i/100ms subclass 210.084k i/100ms subclass_case_ins 190.260k i/100ms encapsulate_case_ins 200.636k i/100ms hash 214.106k i/100ms ------------------------------------------------- encapsulate 8.187M (± 3.9%) i/s - 40.850M subclass_rw_acc 6.627M (± 2.0%) i/s - 33.233M subclass 9.367M (± 0.7%) i/s - 46.849M subclass_case_ins 6.509M (± 2.1%) i/s - 32.534M encapsulate_case_ins 8.016M (± 2.0%) i/s - 40.127M hash 10.190M (± 0.9%) i/s - 50.957M As you can see, subclassing without rewriting `#[]` causes a 2% performance penalty over the vanilla Hash class, but that may be acceptable in order to provide a nice API (such as `HTTPResponseHeader.compressed?`) depending on the use-case. Regardless, it is still 5% faster than the encapsulation you advocate. You can also see that rewriting `#[]` causes a significant performance hit as you found in your benchmarks. However the penalty attributable to supporting different access patterns is only about 0.1%! (compare `encapsulate_case_ins` and `encapsulate`) However supporting different access patterns is faster in encapsulation than in subclassing, simply because encapsulation can rely on direct calls to the C implementation of `Hash#[]`. As I said earlier in the thread: &gt; Subclassing Hash is fine if you're just adding methods. if you're overriding &gt; basic methods like #[] in ways that cause memory leaks, it's just poor coding. &gt; You certainly can't generalise from that that subclassing is bad. I guess I should add that if you're overriding `#[]` in Ruby and accessor performance is critical, that's also poor coding :P ## Unclear Interface Again, you do have something of a point here, but I'd argue that this class is obviously designed to be a read-only API. At worst, this is poor encapsulation in this specific example. ## TL;DR Overriding C-implemented methods (like `Hash#[]`) with a Ruby implementation is always going to be slower. If that matters, either don't do it or do it in C. Generalising that there aren't **any** valid use-cases for subclassing Hash is just wrong. Simply adding helper methods to a Hash via Subclassing to give it a nicer interface than raw key accesses, or adding logic, is fine. ## P.S. Your benchmarking code had a bug where the initialisation of `HttpResponseHeader` wasn't doing anything. It only had a minor effect on the numbers, but it should have been like this: require 'benchmark/ips' require_relative 'http_header' header = EventMachine::HttpResponseHeader["foo" =&gt; true] hash = {"foo" =&gt; true} FOO = "foo".freeze Benchmark.ips do |x| x.report("header") { header[FOO]} x.report("hash") { hash[FOO]} end Also, thanks for introducing me to `benchmark-ips` :)
I agree with you, the levels of indentation seem more important than the raw line count. Thanks.
Sounds reasonable, bear in mind that I've been coding for a while but I'm interested in learning Ruby's specific idioms. :)
Right, but does that mean Ruby novice or programming novice?
Thank you. The advice seemed really bad to me too.
I'd say that both are just as bad on the surface: &gt; users = User.where(id: user_ids) &gt; user.posts.map { |post| &gt; post.comments.map { |comment| &gt; comment.author.username &gt; }.flatten &gt; }.flatten &gt; Author.joins(comments: :post) &gt; .where('posts.user_id' =&gt; user_ids) &gt; .pluck(:username) Both examples make your current model way to aware (and thus tightly coupled) about how posts, comments and authors are related. IMHO much better code would be: class Foo def author_names @users.collect(:author_names) end end class User def author_names @posts.collect(:author_names) end end class Post def author_names @comments.collect(:author_name) end end class Comment def author_name @author.username end end This decouples all models a lot: each only knows about its direct relation, and what message to send there. My experience is that this means keeping far from all these `joins()`, `includes()`, `has_many_throughs` and so on. A downside is that optimizing by improving the SQL, and scoping is impossible or hard with my appraoch. But testing, refactoring and understanding code is far, far easier. One real-world example to illustrate is that when you, e.g. change your code to allow a comment to have multiple authors (e.g. a Collaborator relation), you'll need to fix tests and code; even view code, all over the place: Foo has nothing to do with how a Comment and Author are related but has to be changed nonetheless. While with my much simpler solution, such a change will be isolated to Comment alone. I consider code like &gt; Author.joins(comments: :post) &gt; .where('posts.user_id' =&gt; user_ids) &gt; .pluck(:username) A codesmell; spagetti even. 
thoughtbot recently started a podcast and discussed the results of living with these rules for a bit: http://bikeshed.fm/1 Their takeaway in the end was that the rules are interesting and cause you to think about problems in different ways, but work better in some circumstances than others. I think the rules are an interesting exercise and would be good to apply to a side project just to see how they cascade through the project and affect your architecture.
1-3 lines seems extreme to me but I'm all for keeping methods small 
Agreed, 5 lines feels a little bit too restrictive. We've configured rubocop to enforce a max of 10 lines per method and it has been working great so far. We haven't run into a situation yet where a 10+ line method couldn't be logically broken apart into smaller methods or extracted into its own class.
The structure you're looking for us called a [bidirectional map](http://en.m.wikipedia.org/wiki/Bidirectional_map) or bimap. Unfortunately ruby doesn't have one in the stdlib. In your case, though, you could instead use [Hash#invert](http://www.ruby-doc.org/core-2.2.0/Hash.html#method-i-invert) to avoid having to write out the mappings twice. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bidirectional map**](https://en.wikipedia.org/wiki/Bidirectional%20map): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), a __bidirectional map__ is an [associative data structure](https://en.wikipedia.org/wiki/Associative_array) in which the pairs form a [one-to-one correspondence](https://en.wikipedia.org/wiki/One-to-one_correspondence). Thus the [binary relation](https://en.wikipedia.org/wiki/Binary_relation) is [functional](https://en.wikipedia.org/wiki/Functional_relationship) in each direction: can also act as a key to . A pair thus provides a [unique coupling](https://en.wikipedia.org/wiki/Bijection) between and so that can be found when is used as a key and can be found when is used as a key. &gt; --- ^Interesting: [^List ^of ^data ^structures](https://en.wikipedia.org/wiki/List_of_data_structures) ^| [^Associative ^array](https://en.wikipedia.org/wiki/Associative_array) ^| [^Java ^collections ^framework](https://en.wikipedia.org/wiki/Java_collections_framework) ^| [^San ^Tin ^Highway](https://en.wikipedia.org/wiki/San_Tin_Highway) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnkn34z) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnkn34z)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Can't upvote this enough. Rails for Zombies is going to help you a lot in addition to the documentation.
Ugh. What kind of cloying, insipid BS is this? I bet he wrote this silly thing with tears in his eyes just imagining all the happy comments and upvotes he'd get. Appalling.
I would love if this used rbenv and setup some basic vim configs (vim-sensible) 
10 seems like a good limit to me.
Overly clever and concise does not get you clear readability. I really doubt anyone couldn't look at that quickly and understand what's going on. If that's the case, it is bad code. 
Could you PM me how to do that? I tried looking for it myself, but I think that's not something I can do on my own.
If it's Linux you need help with, try installing [Ubuntu](http://www.ubuntu.com/). What's great is that you can install it on a usb and run it from there before you decide to install. I'm recommending Ubuntu because it's got a great support community. [Link to Project Euler](https://projecteuler.net/).
Could this be used with LXC or KVM?
[exercism.io](http://www.exercism.io) is fantastic!
That would work reliably, too. Disadvantage is that you create two copies of the whole data set where my approach only created one copy of all keys or one copy of the the total set. It may be less dramatic that it looks on first sight because only the collection data structure is created and keys and values are referenced (shallow copy) but in your case you are creating a new Array with a number of two element Arrays for all key value pairs. That can be a lot of objects depending on the data set size.
There is: you can use #rassoc on any Hash. This comes with a price though: look up is O(n) and not O(1) as for look up by key. So this is typically not what you want as it is only useful for infrequent reverse look up. For a fully synchronized bidirectional mapping you need to cook your own or look for a gem as this is not part of the standard library as /u/luckygerbils has pointed out.
Try http://nitrous.io
I work in a field where I deal with information like this. It is difficult to find this data available for free. You can get it from the Amazon 'product advertising api' (does not require hosting anything on AWS, it's just an api), but the ToS for that Amazon API say that you can only use it for products whose primary purpose is making sales via Amazon, or something like that. Some people use it anyway, but if you got big enough or they noticed you, then yeah. You can try getting it from the Internet Archive-hosted Open Library API. But their data is not super complete or reliable, and I'm not entirely sure they have the right API for you. The OL project seems to not be getting much attention from IA, it hasn't gone where it was initially envisioned. https://openlibrary.org/developers/api You could try using the ISBNDb api, but I'm not sure it allows lookup by title/author either, and it is not free beyond limited volume. http://isbndb.com/api/v2/docs The library organization OCLC has this data, but do not generally provide it for free either. Their API's keep changing, and I'm not sure which of them might provide access to non-members for the kind of data you need. In general, I know of no high-quality, reliable, and free source of this data available. 
Documentation can always be improved, I'm a big believer in documentation, and think much of rubyland could use better docs -- although docs for much of the ruby ecosystem gotten *so* much better in the past few years, there's always room for improvement. But there's a lot to learn in the ruby ecosystem, and you're going to have to know things about how ruby gems and other parts or ruby work in general, and the bundler docs aren't neccesarily the right place to teach you everything you will want to know about ruby. And, if you're stuck on ruby 1.8.7 -- I would not even bother doing a ruby project, honestly. Vast parts of the ruby eco system are no longer supported on 1.8.7. [Ruby 1.8.7 is no longer supported by ruby core team](https://www.ruby-lang.org/en/news/2014/07/01/eol-for-1-8-7-and-1-9-2/), even if RHEL is 'supporting' it as far as backporting or developing certain security patches when neccesary, the fact that it is officially EOL'd means you are going to have trouble finding supported open source (including bundler) versions that work on 1.8.7, and the problem will just keep getting worse. RHEL's 'support' might be good enough to keep running an app that was developed a long time ago under 1.8.7 and is working -- but doing new development on 1.8.7, you are in for an unpleasant time, and all the docs in the world aren't going to save you. (What you want is not docs, but for the ruby community to be more concerned with supporting old versions of ruby than it is. You can wish for it all you want, but it's not the community and ecosystem ruby has). With ruby 1.9.3 also approaching end of life, I would not do new development on anything but ruby 2.0+ at this point. 
well that's a bit disappointing, but thanks for the definitive answer. I'll check out your links and see what I can put together. Luckily I'm in a position where I could, conceivably, prompt for this information, or (more likely) allow it to be filled in later, but it would be nicer to autofill it. Oh well! Thanks again for the response!
As someone with experience ( though not as much as yours :-), let me add that 1) It's easy to review code without context, but if it's in production, it means that it met deadlines, it made money for the company, and that's why they can now afford to call in other people to clean it up. 2) Programming is an evolutionary discipline - and we have an amazing number of folks like sandi and Steve McConnell who are able to take a step back, learn from their and their colleagues mistakes, and infer meta principles from the process as a whole, and offer it back as guidelines or checklistss to the community at large. 3) Sometimes constraints like the n lines per routine don't seem intuitive to people when they start out, and can actually feel constricting. One way i found is to ask people to come out with two branches - one with rules like n lines per routine and one without, and then review both as a group, and look at it from a maintenance, enhancement/testing perspective. 4) People who are contracting themselves cheaply and who don't care about things like SRP are aplenty. The bigger problem for my perspective, are their managers and bosses, who don't let their ignorance of the craft stop them from calling the shots through arbitrary deadlines, frequent changes in requirements, no budget for testing etc. Until we grow a set of managers who are knowledgable about the whole software engineering cycle, and the importance of various activities like testing, code review, requirement management processes, estimation processes etc, it would be difficult to grow the craft of programming to adopt things like SRP on a larger scale.
This is amazing.
I don't know :P It made sense to me when I wrote it a few days ago, now I don't know what I meant. Maybe I glossed over the article and thought your anti-examples were the actual suggestions. 
I'd love to get people's feedback on: - Vagrant + Ansible - Vagrant + Chef - Vagrant + Docker I have a Vagrant VM on a Windows host that I've been using as my RoR dev box while I work my way through the Rails Tutorial. Even after trying a variety of people's chef recipes and such, I still have failed to get it to configure exactly the way I wanted with RVM, specific versions, pre-loaded gems, etc. Overall I got something halfway there and did the rest of the box's setup manually which I later realized kind of defeats the purpose. Then I just kept using it because the whole point was to give me a dev environment for the Rails Tutorial and I wanted to move on to actually doing that. Now that I'm halfway through the tutorial, I'm starting to think about what I might do differently once I finish and want to create a true dev/test environment that will make deployment as pain-free as possible for a novice. What are the various tradeoffs, strengths/weaknesses and opinions, etc. of the three combinations above? Is Chef a dated tool? Overkill for a basic Rails app? Is something "second generation" like Ansible just *better*?
I think they want you attempt it to see how you think. Its not about getting it to work or it being complete as they stated, it probably has more to do with how you are approaching the problem and your thought process.
Sure
I can't speak for the program in question, but the dev bootcamp I teach at uses a somewhat parallel process for applicants, in that we toss a few moderately difficult (for most applicants) problems at 'em and see what they come back with (we tested these problems first by giving them to some junior-level developers, who all knocked them out in 10-15 minutes for each problem, no sweat). The applicants I interviewed all reported spending a few hours (sometimes more), which is about appropriate for someone with very little experience. We do this for three reasons: 1. A preliminary gauge of technical skill (though TBH I'm not actually very concerned with whether their solutions are 100% correct or 100% functional... I just want to see what they come up with) 2. A test to see if our applicants are going to stick with it, even when things are a bit frustrating. 3. A chance for students to see if they even like programming (or, more specifically, if they really hate it). Software development (as a job) is really, really sexy right now. But it's impossible to know if you'll enjoy it until you try it out, and some people simply aren't going to enjoy it. More generally, programming is also a field where you're pretty frequently given problems whose solutions you don't yet know, so it's often a matter of breaking the problem down into simpler and simpler pieces until you get things that you can solve. Best of luck with the program. The code sample you posted here looks pretty solid.
They want to see how you break down the problem. Tic-tac -toe is probably one of the simplest games to make as it is nothing more than 9 bits pattern matching. I made one when I was 10 years old in one of those 300-in-1 electronics project kits my dad got me from Radioshack.
You *can*, of course, install an alternate ruby on a RHEL5 system. I've done it. Stick it in /opt/rubies. Yes, you will have to take responsibility for installing new releases with security fixes too. I understand it may not be allowed under certain regimes. I understand that the way software is produced in the ruby community ecosystem violates the software policies of many environments. I think you are better off not using ruby in those environments. In this case, you example gives usa particularly stark choice: ruby 1.8.7 is simply *not supported* by the people who develop ruby. It has been end of lifed. In that context, I think it's perfectly reasonable for people creating ruby open source to no longer produce new versions supporting 1.8.7. If you are writing new ruby on 1.8.7, you will simply not have access to huge swaths of open source written for ruby. In the modern software development environment, we rarely evaluate a language as simply the language, we evaluate it also in terms of what open source is available for it. As much as I like ruby, developing new ruby software in 1.8.7 would drive me to using something other than ruby. I think ruby is simply not suitable for those environments. I like ruby a lot, and personally I would try to avoid those environments so I could keep using ruby. But that's not always an option. We don't always get the choices we want, that's just how it goes. You can complain all you want, but you have a better chance of convincing your customers to allow a ruby that has not already reached EOL (as small as that chance may be) than you have of convincing the developers of the open source ruby software you want to use to support 1.8.7. 
If you want to run the risk of getting a cease and desist from Amazon, you can use the Amazon "product advertising API" and it will work fairly well. I don't know of anyone who has actually gotten such a cease and desist, but most people I know using the product advertising API are using it for fairly low profile and non-profit projects. And of course, regardless of what data/API's you have access to, from only a title and author, it's always possible you'll get *multiple* results. Either different editions of the 'same' book with different publishers and publications years, or actually different books with similar titles/authors. 
That's a really good point. I probably should have put the Troll face up sooner or made it more clear I was being hyperbolic. Thanks for the feedback!
its not bad but I'd personally use a matrix instead of an array (a double array = matrix) overall, I'm impressed by this for someone who hasn't coded before. you need to make a method that runs the game and controls the play though
There's also goodreads, which has it's own free API, and it's information quality is quite good for most authors.
Perfectly reasonable, valid viewpoints. We're still at the stage where "this is what works for me" is *the* most valuable metric — which ought to scare us all a bit. 1. Usually true. Often, you'll see situations where (the understanding of) some outside system changed, and that blew internal assumptions (on the hitherto-working, production code) to smithereens. Fixing *that* in a way that makes it easier to continue to evolve the system at less than 1 Maalox/minute for any stakeholder is an art form; 1. Spot on. One of the biggest problems we as a craft/industry have, going back *at least* to when Fred Brooks was going through the hell that led to [*The Mythical Man-Month*](http://en.wikipedia.org/wiki/The_Mythical_Man-Month), is that our ideas about "best practices" tend to be experiential, malleable, inconsistent and often contradictory. I expect that to continue unabated until an event on the order of the [New London school explosion](http://en.wikipedia.org/wiki/New_London_School_explosion) (which led directly to the professionalisation of engineering in the US) that is obviously, inarguably traceable to a software failure. Then public opinion drives the politicians to Do Something *Now*&amp;trade;, and it takes *more* decades to clean up the mess because we didn't get our act together before it (visibly, publicly, indisputably) killed people; 1. I think the value is in large part that they're *not* intuitive to apprentices or (too many) journeymen. They get browbeat by their leads into following the rule (often with a strategically-placed pre-commit hook). Only after they take over maintenance of some craptastic collection of Russian novels masquerading as methods do they begin to see, "hey, the [`sandi_meter`](https://github.com/makaroni4/sandi_meter) isn't that bad an idea after all". That this still has to be an individual, accidental discovery is symptomatic of what separates our craft from an engineering discipline; 1. And the managers and bosses, more often than not IME, *know* better but can't win the political battle against the proudly tech-illiterate people who say "growth in profits *this quarter* is all that's relevant to the discussion here". So long as we remain the province of quirky individuals seen as practicing an arcane and obscure art form, I fully expect that to continue and congeal. We've been putting it off on the managers or the bean-counters or Joe Schmoe walking in off the street willing to "build any Website for $50", and the short-term-fixated people are getting increasing quarterly bonuses in no small part due to our collective failure. We need to organise effectively; build real, enforceable standards; and agitate to the point where *other* responsible professional orgs (like, e.g, ACCA/AICPA) treat the lack of participation in and oversight of software development by demonstrably, impartially-evaluated qualified personnel as being as much of a defect begging for disaster as building a skyscraper without qualified architects or building engineers. People did that too, not all that many years ago.
you are "preaching to the choir" sir. I think you've hit the larger picture spot on ( and i also love your Maalox/minute metric :-) There needs to be work done on both the supply side and the demand side or the customer side and the engineering side. People who would never dream of hiring a building architect from ukraine or pakistan for $30 an hour for their skyscraper or a $50 an hour surgeon from the phillipines, have no problem trying to fix their short-term software requirements with cheap talent. The programmers have an incentive to do "stuff" as quickly as possible, while papering over the cracks. The managers need to show quick results to their bosses since their bonuses are tied to it etc. So, yes. I too feel there is a huge industry wide need to get programmers to go through a professional org. like ACCA etc but we should also do a better job of explaining the consequences of short-term thinking to our customers/managers/existing stake holders. NOTE: I have nothing against people from different countries. I myself am from a third-world country. It's just that i see a lot of managers consider it to be a "cost cutting" silver bullet.
I was thinking also about making container per application with its own server, nginx, database and services so that user can ssh directly into particular container. So I have a server and a bunch of projects. Instead of setup-ing a new server for every new project I want to setup docker once and then spin up a new container per each of my projects. These containers should have a separate and isolated environments from each other.
What's your opinion of doing Ruby in OS X? Would you still recommend developing in a Linux environment?
&gt;You can do this with bundler no problem. Just set ENV['BUNDLE_GEMFILE'] to whatever Gemfile you want, before calling Bundler.setup. I tried that and I could not make it work. Maybe I was not clear. I want the bundler files to be additive. I want the bundle exec to load the files in Gemfile of the app, I want to app to load additional gemfiles as it's running. &gt;Or if "at runtime" can mean in the shell you invoke your app with, it's as simple as BUNDLE_GEMFILE=path/to/Gemfile bundle exec whatever This does work but of course you are in a subshell at that point. &gt;It's true that you can only load one Gemfile per app invocation though, and can't 'unload' it somehow -- once you've set the dependency environment based on a Gemfile, you're stuck with that. Not sure if that's what you actually want, but because of what Bundler does and how ruby/rubygems works and how Bundler meant to effect your ruby environment, that's going to be a tall order. I hope I explained it a bit more clear now. I want it to be additive to the app bundle. 
&gt; I tried that and I could not make it work. Maybe I was not clear. I want the bundler files to be additive. I want the bundle exec to load the files in Gemfile of the app, I want to app to load additional gemfiles as it's running. Yeah, you can't do that. What you could do is, before you load any Gemfile, programmatically create your Gemfile by aggregating several others, and then load that. I don't think you can load a `Gemfile` from memory, you might need to actually write it out to disk as a temporary file. Although you might be able to programmatically do the same thing by making API calls to bundler, I wouldn't. This could be fixed/improved. But you can't load more than one Gemfile, or load gemfiles at different points in program execution -- because of some of the underlying ways ruby and rubygems work, this would be hard to do, and have some unclear semantics, and is probably not going to happen. 
Neat, I've never seen it used like this. I think I still prefer the first way, though!
&gt; I swear, if I ever go mad, bet that it will be because of some screwy little error involving operator precedence or missing parentheses. I mean this critique to be constructive, but maybe you should *learn* operator precedence. Seriously, take a few days out of your life and practice ruby without using parens. You'll learn you some operator precedence. Not saying you have to write code like this forever, or that you should prefer no parens style in the end, but there's nothing wrong with learning more about the language. It's offensive to tell someone that their style sucks because you don't understand it. The only reason it even sounds reasonable is because of our irrational affinity for what is popular.
I don't think of parentheses as a crutch, but I'm also not one of those who needs them everywhere. There are times when I think they cut down on the ambiguity and the amount of thought involved in reading some lines of code, but in the end, the style you use should be up to you and your team.
That would be helpful - I'd direct that toward Bundler core though.
Part of the reason is the amount of work that goes into it. The # of unpaid hours and yet all of our Ruby customers use it. We looked at it as investing in ourselves really.
According to google it's an installed application so client secrets is not really a secret in this case. ¯\_(ツ)_/¯
Line 14 does not close the stream. Better do something like doc = open('http://wiki.teamliquid.net/starcraft2/2015_Proleague/Round_1/Round_Robin')) {|io| Nokogiri::HTML(io)} Line 21: better use a proper timestamp type (Time or DateTime) than individual fields. Also I'd get rid of *printable_time* and do the conversion to something printable on demand. Redundancy is bad. Line 59: I think with XPath selection that test could be made part of the selection. I'd move line 17 to line 58 and use #map instead of #each (if you can get rid of the test in line 59 that is). Otherwise I'd still declare *matches* directly before the iteration. Line 144 and 148 become superfluous if you have the DateTime already in Match. Line 148: the addition of one hour is not robust. You better do math with DateTime (t + 1.0/24). Other than that it looks clean and well documented. Good!
We're using Reddit for code reviews now? I like it ;) Without spending too much time digging into your code, the first thing I'd recommend is not go overboard with comments. This may sound silly but Ruby is a very verbose and often (if written well) self-documenting. Take for example the function "doc.css". Given the scope of the application and the function itself, I know it's going to part a document; the comment is redundant. EDIT: Thoughts
Learn to Program by Chris Pine (https://pine.fm/LearnToProgram/) is a highly recommended, albeit pretty basic, introduction to programming with ruby. Also, lots of good advice here: http://www.quora.com/Where-can-I-find-practice-exercises-problems-for-Ruby-and-Rails Good luck!
I've worked with it a bit for our CoderDojo. The kids ate it up. It's not too tough to use if you are familiar with Ruby. 
"More than 101+" NO.
The site isn't working, but I'm interested. 
It is great for teaching but it's not that stable.
Hi, sorry with the site, having a dig now. Can you send through your details to info@52pairs.com and I'll be in touch
OMG i hope you didn't say globals .... LOL
Yeah I checked the repos and didn't see a ton of recent commits so I was concerned about it. What devices did you use?
That's good to hear! I figured it might be a fun little project to add some variety to the course. What devices did you work with?
Ruby works just as well on Windows, you can use http://rubyinstaller.org/ You can also use Pik to manage multiple versions of Ruby if you so desire... Linux is a fantastic OS, but if you're comfortable with Windows I'd stick with that. 
Is there any way to set up Sublime to use 2 spaces for Ruby instead of a full tab?
Bottom right hand side of the screen sets tab length.
&gt; and I've always had this feeling that something's wrong with my approach. I would not say there is something "wrong". In certain codebases, reaching through many "has many through" can be perfect valid. But like always: "just because something is there and can be used, does not mean it is a good idea to use it". &gt; that strictly upholding the Law of Demeter Slow down there.... "strictly upholding any Law" is a bad practice IMO. Taking the wisdom from a blockbuster movie: &gt; the code is more what you'd call "guidelines" than actual rules. Something like the Law of Demeter is a very good telltale: an indication that you are bringing trouble on yourself. But when you (and your team) erect them as rules (with things like Rubocop) you will often not see these telltales, but blindly fix code to follow some "law". Consider this: def sum_of_words books.chapters.paragraphs.words.collect(&amp;:sum) end Will fail the Law of Demeter. def sum_of_words chapters = books.chapters paragraphs = chapters.paragraphs words = paragraphs.words words.collect(&amp;:sum) end Will pass the Law of Demeter. By instating such laws in a project, you encourage code like the latter. But, what the code is telling you, is that you should re-think you message-chain: def sum_of_words books.sum_of_words end #... Book#sum_of_words will call Chapter#sum_of_words and so on. But I digress: yes, keeping a good eye on tell-tales like the Law of Demeter has helped me a lot to keep code clean and refactorable. Or, as I like to say: maintainable and fast and effortless changeable; since "clean code" is a tool, never a goal. But being able to quickly change when the market asks us to, is a goal.
Thank you! :D
Do you have some reason to not trust it? I mean, Ruby is open source, and written in C, so you can just go read the code that does the arithmetic you're concerned with if you're super paranoid.
I've used instance variables in simple classes to help visually identify "global" values in a script that exist outside of loops, methods etc. It's easier to notice places where you might have accidentally modified an instance variable when you meant to modify a loop local value. If it get's to be more than a few dozen lines of script it's probably a good idea to wrap that logic up in a simple PORO class. It makes defining the procedure a little easier even if it's relatively small. #!/bin/env ruby # something like this. class App def initialize(a_param) @a_param = a_param end def perform # important stuff p @a_param end end App.new(ARGV[0] || 'something').perform
Just increment by 1. He really meant "More than 102 blogs." 
This is really slick! I've used another tool like it called [PuPHPet](https://puphpet.com/), and while originally developed for PHP, also supports RoR. You should give it a look as it also has a ton of options. One issue I ran into with Vagrant + Ansible was that (at the time, need to check now) Ansible didn't have a windows client and as such would not work with Vagrant (Linux guest). Eventually this, and many other troubles, led me to pick up a MBP and it has been smooterh sailing ever since. Ansible certainly seems to be easiest configuration management tool to get started with. I've also written a Vagrant + Chef cookbook to do most of the heavy lifting to setup a Rubybox that works with both Ubuntu and CentOS. Although it probably is not ideal, using RVM makes it so much easier to use a current version of Ruby than using either the OS package management tool or compiling from source. CentOS 6 still uses 1.8.7 without EPEL. Vagrant + Docker works OK but since neither Windows nor OSX support Docker natively, you'll be using Boot2Docker. It has come a long way and does work well, but you might find the port "double forwarding" to be a pain. I admit that my Docker experience is very limited so there may be easier ways to deal with that issue. 
I used Tkinter many years ago. It's horrible. WxWidgets proved much better and is still very active. I wrote my 1st muti-threaded app with Ruby and WxWidgets. where i had a long running process in a thread updating a scrolling text box. It worked really nicely. A few others to look at. FXRuby. It provides a more idomatic ruby api to building gui's. Shoes 4 is looking really cool, but will require using JRuby (which rocks by the way) 
&gt; def sum_of_words &gt; chapters = books.chapters &gt; paragraphs = chapters.paragraphs &gt; words = paragraphs.words &gt; words.collect(&amp;:sum) &gt; end &gt; &gt; will pass the Law of Demeter. Okay, true enough. But then the latter fails at minimizing coupling as whatever class contains the `sum_of_words` method is coupled to chapters, books, paragraphs, and words. I guess a better way to describe using the message-chaining approach you're recommending would be following the Law of Demeter while also minimizing coupling. &gt; But when you (and your team) erect them as rules I wish I had a team! It's just me. Working on a project which is the core of a business I'm building with two other (non-coders). And I'm a self-taught rails programmer with a (not software or computer) engineering degree, using TDD in part because I watched and loved the Clean Code series by 'Uncle Bob'. I wish I'd had some more mentorship in the last year and a half -- I definitely underestimated how easy it would be to become proficient at Rails development, and so it has taken me far too long to build code which I wish was better than it is. But at least I *am* going out to my first ruby meetup soon, so that should be helpful. Thanks for your comments
Soundn like a fun thing to test a SOA app with...
is there one rss feed to rule them all? 
really nice! could you take a look at implementing this https://github.com/j-mcnally/ansible-rails but instead of each role being a separate droplet on digital ocean, perhaps make it into a docker container?
If it's not something anyone else is ever going to see or use, and you're okay with maintaining it if necessary, anything is fine.
I agree. YMMV, but I found it noticeably slow compared to implementing the same behavior with POROs. I made a Ruby port of beanstalkd (https://github.com/gemeraldbeanstalk/gemerald_beanstalk) about a year ago and saw a pretty significant performance boost when I replaced state_machine with plain old Ruby.
If your name is jason then you have no hope of learning artoo, you should just give up...
Nitrous is like a remote virtual box. You get one free basic box that you can spin up or destroy depending on what you want to develop with. They have a web IDE or you can SSH in and use the Dropbox esq. Service.
cool idea. 
The example is just copied from the Java example on the [wikipedia page](https://en.wikipedia.org/wiki/Memento_pattern). The whole article is just a shallow copy of the wikipedia article, and it has no ruby specific parts except for the code.
In the example here it is, but it could also be stored in some file (marshalled) or in the database. The important idea is that you have a reified state that can be stored and restored. Also, this state is separate from the object itself, so just marshalling the object is not an application of the memento pattern.
the only I can think is to use RPC with ruby/go :)
Nice article, but the theme is a bit strange. When viewed on my laptop the text fills the whole width of the screen and it feels like I'm viewing it on a phone that's only an inch from my face.
try https://github.com/DavidHuie/quartz
If you really have no classes, then your "instance variables" basically are just globals -- if you write `@var` at the "top level" of a script, it's an iVar on the top-level `self` object, which is effectively just a global var. I'd just use a global var, if that's what you're doing. 
What a load of nothing
If you do not write a class, why use instance variables? You can use local or global variables. Apart from that: I often find myself writing classes even for small scripts because it allows better abstraction (for example than having a nested structure of Hashes and Array on which "functions" then must operate).
Yeah, what a garbage article.
That looks a bit convoluted (but I´ve done this before calling an OCR engine as a command line tool), you could possibly do the same calling C code from Ruby or calling Java directly if you are using JRuby. And there´s also the option of running Rust code (which is much safer than C) inside your Ruby process: http://blog.skylight.io/bending-the-curve-writing-safe-fast-native-gems-with-rust/ I think it makes sense if you don´t want to call native code due to safety issues, but not much more than that.
https://www.dropbox.com/s/7s6z2cegp8k4no7/Screenshot%202015-01-13%2015.28.32.png?dl=0 It fills up the whole screen on my MBP. I'd slap a max-width somewhere on there :)
There were a few issues with the documentation and examples, but they fixed them pretty quickly once I opened an issue. It was hard for me to use the different models they had in practice, but I am of intermediate Ruby skill probably. I ended up using the ARDrone gem that they use underneath the Artoo::ArDrone functionality for my [graffiti drone project](https://github.com/chrizbo/graffiti-drone) and driving the wifi enabled Arduino via HTTP: https://github.com/hybridgroup/artoo-arduino/issues/35 I would think it would work great for simple projects though...
That does just a shallow copy of the state. If state consists of a nested structure the whole think won't work. Also, class Memento is completely superfluous as far as I can see. At least, I do not see why it would be needed here. The only use I could see is if it was made capable of extracting state from an instance (e.g. via instance variables or marshalling). Deep copying does have some issues of it's own though when it comes to restoring state.
oh yeah, hahaha, thanks for the heads up, gonna fix this :D
 @$#()*UD()IIF# That's valid Perl.
Unfortunately. Frankly, that is one of the reasons why I moved away from Perl.
Okay. I ended up installing Ubuntu. But thanks for the suggestion. 
?x means the single character string 'x' in ruby. irb(main):001:0&gt; ?a =&gt; "a" irb(main):002:0&gt; ?b =&gt; "b" irb(main):003:0&gt; ?aa SyntaxError: (irb):3: syntax error, unexpected '?' from /opt/boxen/rbenv/versions/2.1.2/bin/irb:11:in `&lt;main&gt;' because why not? Edit: more fun irb(main):001:0&gt; "beer" =&gt; "beer" irb(main):002:0&gt; "beer".inspect =&gt; "\"beer\"" irb(main):003:0&gt; :beer =&gt; :beer irb(main):004:0&gt; :beer.inspect =&gt; ":beer" irb(main):005:0&gt; :beer.inspect.inspect =&gt; "\":beer\"" irb(main):006:0&gt; :beer.inspect.inspect.inspect =&gt; "\"\\\":beer\\\"\"" irb(main):007:0&gt; :beer.inspect.inspect.inspect.inspect =&gt; "\"\\\"\\\\\\\":beer\\\\\\\"\\\"\""
It isn't uncommon to handle errors with "or die" in Perl because of the shorthand or (I think it's called shorthand, not sure). Edit: s/shorthand/short-circuit/
true but marshalling it when it keeps his own state in an array is.
* $? - Exit status of the last executed child process. * ? - Ternary operator * ?: - Literal ':' * : - Ternary else * ?$ - Literal '$'
Do you mean short-circuit? Or shorthand as in it being a concise idiom? 
I learned something today. 
I do not want to be evil. Your start your story with: 'I am an engineer.' Programming is not 100% google and stackoverflow. Is more pain, then happiness, then more pain. (joking) And, you said that you're not beginner, then will be easy for you to write in any style, and build any kind of abstract rules on top of bussiness logic Can you give a gist if some sample? Best
Good god, are they still using mysql_query?
This was almost 5 years ago, I don't think the code is still used. 
 !:'.!~!:'.!~!:'.!~!:'
I could have sworn Ruby uses OS threads now. 
Does it do identical code highlighting and fenced code blocks?
JRuby and Rubinius only.
Ruby uses OS threads since 1.9.2, from my research. Do you have a source saying it does not?
It has a gemspec dependency on pygments.rb which isn't [what Github is using anymore](http://www.greghendershott.com/2014/11/github-dropped-pygments.html), so the answer is no, probably not identical, but Pygments is fine enough.
It also depends on [github-markup](https://github.com/github/markup), which github *does* say it's using, [so...](https://github.com/ianks/octodown/blob/master/lib/octodown/support/helpers.rb#L14)
LOL! That makes it a bit hard to decipher then.
* Practical Object Oriented Design in Ruby by Sandi Metz * Confident Ruby by Avdi Grimm
I thought this issue has been around for so long that by now people would know how things work. MRI *does* use native OS threads. Source: I worked on the Ruby interpreter. What MRI doesn't provide, is the ability to use multiple cores. What's that? OS threads does not necessarily equal multiple cores? That's right, because there's this thing called the Global Interpreter Lock. MRI grabs this lock whenever it's running Ruby code, so effectively only one core can run at the same time even though native OS threads are used. That doesn't mean MRI can't do anything concurrently. MRI releases the lock when performing I/O operations, so I/O operations are performed concurrently and do not block out other threads. In short: * MRI: can't run Ruby code on multiple cores, but blocking I/O run concurrently. * JRuby/Rubinius: can run Ruby code on multiple cores.
Just to clarify my original comment here, I meant MRI Ruby doesn´t use more than one native thread to execute Ruby code, not that it doesn´t use native threads (which is impossible, you can´t do anything if you don´t have at least one native thread to execute your code).
Post your code so we can have more context, please.
 ?????:??
You are using a tad too much escaping for my taste irb(main):001:0&gt; ?? =&gt; "?" irb(main):002:0&gt; ??.inspect =&gt; "\"?\"" 
Your going to have to define what you mean by 'integer'. The mathematical definition? The C data type(which one?)? etc. etc.
Learn functional programming. Ruby is good at that, of course, but consider learning a purer functional language that forces you into a functional mindset, with few side effects. It will change the way you approach problems like this. 
What a nice wallpaper on that gif. 
Oops, misread your post :)
I am playing around with Docker right now. Hopefully will add this option soon. Thanks for the feedback.
https://puphpet.com is really nice, thanks for the link, I'll probably pick up some ideas from it :) ansible indeed does not work on Windows. There's workaround though - it can be executed within guest Linux and railsbox.io is using this workaround (shell provisioning, see https://github.com/andreychernih/railsbox/tree/master/templates/shell).
Sorry but do your own homework.
Yeah I haven't paid for it yet either but I plan to. It would be pretty easy to write a script that would do it I would think. 
This is awesome.
!?&amp;&amp;&amp;?/?$&amp;&amp;&amp;$&amp;:?%?!%w?%w:&amp;&amp;&amp;@@:@!?:!?!
I am from Bangladesh and having experience of 3 years in Ruby On Rails and also i am team lead of 6 member team working for american team as remote team. But currently i am looking for remote job. You can checkout my profile in linkedin: www.linkedin.com/in/naimrajib Also you can contact with me in skype: naimrajib07 Thank You
http://i.imgur.com/DmY8ipu.png -- the load seems to be distributed over four different cores to me!
It's tough to get over that initial feeling of awkwardness, but having other people look at your code is really helpful. As is reading code written by others.
I found that implementing my own version of Enumerable was hands down one of the best ways to understand what this whole Ruby thing was all about.
Out of curiosity, do you know if the GIL is going away anytime soon?
Oh, whoops!
Having a JSON api seems to be a good idea. It seems unix sockets are a good way to communicate with the go application, although I never tried it. Thank you for your feedback ! :-)
Obviously!
I use Sublime Text with packages for Ruby and Ruby on Rails.
thanks for the reply, i will check it out
I tried applying functional programming concepts in ruby, in real world applications it seems to always be less efficient than standard OOP. Do some benchmarking and see. You tend to get way more objects created and destroyed than necessary, and the interpreter executes more code in general to accomplish the same thing. Ruby is also slow when it comes to lazy evaluation and anything that benefits from tail call optimization. Still, depending on the application, FP might be worth it. (Maybe something that is heavily threaded? if nothing else it might remove the headache associated with programming threaded ruby apps.) I don't know much about interpreters, compilers, etc. but I think what holds Ruby back in this area is the fact that everything is an object. It would help if we had pure functions and primitive data types, but IMO this would ruin a lot of what makes Ruby beautiful. Hopefully one day Ruby will be better optimized for FP. It's becoming more popular, and languages like Scala have proven that it's awesome to mix OOP and FP. 
Of course, this post is about exploring some concepts and playing around. It should not be taken too seriously, this is not a tutorial for real production applications ;)
Actually, you already using sort of functional programming plus standard oop all the time. Ruby doesn't have instruments to provide alternative for standard oop. No monads, no type families no etc no etc - in other words no ways to irganize your code not in oop world model. So anyway, this is hybrid (but more oop-ish) behaviour. And lazy evaluation (which is damned in Ruby) is not a prerogative of functional world. So there's just HOF left.
We worked specifically with ar Parrot quadcopter drone. Luckily I had a couple on hand. Super fun!
I met [Schlomo Schapiro](http://go.schapiro.org/schlomo) from [this company](http://www.immobilienscout24.de/unternehmen/jobs-karriere.html) a few years ago on an open source conference (Ubucon IIRC) and if I had lived in Berlin at the time or could easily move I would have applied right away. Sounded like a cool workplace to be in. I do not know though whether that fits your bill of a "good job".
I posted it and someone told me to do my own homework so I deleted it. I just need help, not answers. I want to learn and because I don't know the answer, I was hoping someone who did would point me in the right direction. 
&gt; I'm trying to find elegant ruby that's clear and easy to read through, yet powerful and efficient. There's a book that perfectly fits your description, and it's even called *Elegant Ruby*. It really helped me start my transition into better code. I honestly have to say that that book helped me understand why to use Ruby. 
damnit me, I had one job -- yes that's the book!
Capybara's #drag_to method should be a start as far as simulating the action of dragging and dropping something: http://www.rubydoc.info/github/jnicklas/capybara/master/Capybara/Node/Element#drag_to-instance_method. From there you would want to test that the page has changed accordingly.
That's another part I'm having trouble testing. Normally, the position of the screen is defined by a "grid" it belongs too. With drag and drop, it's defined by where it's localted pixel wise. Is there a way to look at that?
With watir-webdriver, you use two element identifiers, dropping element1 onto element2. It is super easy. [reference](https://github.com/watir/watir-webdriver/blob/a5158fca33bf77e197f9db2530a09104c56f62f4/lib/watir-webdriver/elements/element.rb#L194)
Saying "FP isn't that good as OOP" makes me facepalm and halt reading this comment. FP and OOP aren't opposite and can't be compared.
This is fun! Nice work.
 rspec --init ?
Whenever the Ruby interpreter is running, it has a reference to *self* which is some object in the system. In the case of a simple script like the one you're talking about, *self* refers to an Object called *main* which isn't unlike any other Object. When you conjure up an instance variable, you're attaching it to *main*. You won't break anything, but it's good to understand what's happening under the covers.
 I love Eloquent Ruby + Designer patterns in Ruby + Practical Object-Oriented Design in Ruby. If you're new to programming, I suggest starting here : https://rubymonk.com/ . Then graduate to a book. Of course, books only help so much and why I also I recommend http://exercism.io/ where you get exercises, complete them, and then git nitpicked. In addition you can see other people's solution and from this find elegant and succinct Ruby idioms. It really helps to get burned, and the pain is temporary. Then naturally, there's a lot of projects out there that are very well written, get involved, it'll only make you a better programmer.
Well the only alternative I can think of would be to have `value` refer to the lambda itself, and `value()` call the lambda, but that feels too Pythonesque and goes against the whole “parentheses optional” philosophy. Given the choice, I think I'd prefer to have lambdas evaluate when they're called. Basically, treat them like lightweight, locally scoped method definitions.
&gt;Is creating a new instance for each set of parameters considered best practice or should I be doing something else? This is generally a very good practice. Modules are for when you need functionality shared between similar classes. Modules are great when two classes have a lot in common, but they're also different. An example would be a Bird class and a Pterodactyl class that each inherit from the Animal class. You'd want birds and pterodactyls to fly, but you can't put fly methods in Animal, since not all animals fly. You also don't want to copy-paste methods between Bird and Pterodactyl. So the solution is to create a Flying or Flyable Module and stick all the methods in there, and include the module into Pterodactyl and Bird. class Animal def eat puts "chomp" end end module Flying def fly puts "flap flap" end end class Bird &lt; Animal include Flying end class Pterodactyl &lt; Animal include Flying end class Dog &lt; Animal end So now, dogs, birds, and pterodactyls can eat, but only birds and pterodactyls can fly, and if the fly method has a bug, there's only one place to change it.
 Modules in ruby are for a few things : * Provides a name space for your classes and such, helps to prevent name space collisions. It's best practice to wrap your class in a module. So instead of Bar.new, you have Foo::Bar.new. Where Foo is a module and Bar is a class. * Modules provide a container for related methods, constants, etc. * Modules are used as mixins to extend an existing class with instance methods ( though you can do class methods too ). Modules can have either instance or module methods ( i.e., static methods ), that is you can have a class that either extends a module to get instance methods, or you can have a class include the module for class methods. That's the gist. Of course, the main differences between a module and a class is a module can not be instantiated and can't have sub-classes. If you're writing code and can clearly see that this is not something that needs to be instantiated ( i.e., provide state ) then a module is the way to go. Examples : module Foo def bar puts "Foo!" end def foo puts "Bar!" end end module MyNameSpace class Bar include Foo # Pull in as instance methods end class Baz extend Foo # Pull in as class methods end end MyNameSpace::Bar.new.bar MyNameSpace::Baz.foo # Can't instansiate begin Foo.new rescue =&gt; e puts "Whoops #{e}" end # Can't call an instance method from a module without mixing it into a class begin Foo.foo rescue =&gt; e puts "Whoops #{e}" end # A module that can be used directly by defining module methods module Bla def self.foo puts "Foo!" end end # And just call foo like you would a class method Bla.foo A lot of the stdlib that comes with Ruby is in the form of modules, Enumerable for example is a module, mixed into other classes like Array, Hash, etc. I'm sure there are some example of stdlib modules that are just modules, not intended to be used as mixins, but can't think of any off the top of my head. Checkout : http://www.ruby-doc.org/core-2.2.0/Module.html It seems like you might also benefit from https://rubymonk.com/
I use sublime text. I have the common ruby/rails packages with a bunch of custom snippets. ST is great IMO. Very light and highly customizable.
I would suggest starting with the Ruby track on Codecademy to establish a base. That's how I started off.
Definitely, although for me it took months of practice. This is a good starting place I think: https://rubymonk.com/
Hello Ruby Hack Night!
Codecademy for basics and a lot of Google is how I did it; you can do it.
Automation Engineer here, also using Cucumber and ruby to test an application which uses gridster. The other solutions here probably won't work for you, since you don't have a specific target that you want to drag to. You're most likely going to want to look at https://selenium.googlecode.com/svn/trunk/docs/api/rb/Selenium/WebDriver/ActionBuilder.html#drag_and_drop_by-instance_method Here's a simple helper we generally use: def drag_drop(draggable, x_offset, y_offset) driver = page.driver.browser driver.action.drag_and_drop_by(draggable.native, x_offset, y_offset).perform end 
I would recommend picking out some gems you like or use and looking through their issues to see if you could fix something. Improving a gem's test suite is usually welcome and will give you other insights into how to improve a gem. Or, checkout [Classifier](https://github.com/jekyll/classifier-reborn), which I work on from time to time. Or, come help fix [this](https://github.com/jmazzi/crypt_keeper/pull/94) issue with a sql query in Crypt Keeper that keeps it from working with Rails 4.2.
You are a life saver! Thank you!!
I am an indirect That.
I think I can actually answer your question by pointing to one of my favorite libraries: *redis-rb*, the Redis client library for Ruby. One use of a module is for namespacing. You can imagine interacting with an object in Ruby that is a Redis client. We can't just call it "Client", because if everyone did that, there would be name collisions everywhere. RedisClient seems a bit better, but it still feels like we're squishing too much into the name. After all, the library *we're* writing doesn't have any other Client-like objects, so why should we need to specify? In fact, we create a module called "Redis", and a class within that module named "Client". From the outside world (that is, outside the Redis module), this class is known as *Redis::Client*. Why a class? Well, we're talking about an object that presumably establishes a connection to the Redis server, and whose methods, when called, are transformed into interactions with the Redis data store. You might not want to maintain these connections, so you could imagine creating a new instance when you need a connection, and discarding it when you're finished. Remember that creating instances of a class- that is, creating any sort of object- is *consuming resources*- class variables and module variables hang around in memory as long as the program is running. Memory is kinda like electricity- you never realize how much you rely on having an inexhaustible supply of it until you've completely used it up. In theory, you could create a module that starts a Redis connection up when it's loaded, and only lets it go when the program ends. But then the entire rest of your program is incurring the overhead of maintaining that overhead. So, Modules obviously aren't just used for namespacing. In many cases, you may realize that some configuration variables for your objects are *always the same*. For instance, in our Redis client, it's very likely that throughout the lifetime of our program, we'll only want to connect to a single Redis server- moreover, we'll probably want to store that server's URL in a config file somewhere. It might seem reasonable to load up that config file during the instantiation of our Redis::Client, but think again! Every time we want that URL, we would need to open a file on the file system (pretty expensive system call), read the file into memory (also pretty expensive), parse it (expensive), and then finally snag the bit of data we need to Do Our Job. Note that when I say "expensive", I mean "it consumes a large amount of time relative to how long it would take to just read the value from memory". This is a good example of using a Ruby module as a singleton. When the user decides to initially configure the module (for instance, setting the Redis URL to which all Redis::Client instances will attempt to connect), they can keep the configuration in a module variable. From then on, we can access that configuration "cheaply"- during initialization of a Redis::Client, it could just check something like Redis.server_url and go from there. Finally, modules as mixins. This is a bit trickier, because there are a few different patterns used in different places. First, the idea of cross-cutting concerns. Imagine you have a Cube class and a Square class. A given square has a specific height and width, but a cube has height, width, and depth. A square could conceivably have a method called "area", and a cube could have a method called "volume". But it seems like a bit of a waste to rewrite the height and width parts of these classes. And inheritance feels too heavy- in the interest of moving fast, we don't want to start by creating an NDimensionalPolyhedron and subclassing from there, do we? :) One way to do it would be to make modules called HasHeight, HasWidth, and HasDepth. Each of these specifies the implementation of any object which has these traits. You could imagine HasHeight specifying an *attr_accessor :height*, among other things. We can then *include*, or "mix in" HasHeight and HasWidth into Square, and HasHeight, HasWidth, and HasWidth into Cube. These classes, and any instances of them, will have the methods of the modules we mixed in. This is kind of a dumb example, but in reality, it's a pattern for organizing your methods according to their concerns- in such a way that you can test them independently, which makes it less likely that a class with lots of behaviors will devolve into a mess of spaghetti code. This is getting a bit long, but I could go on longer about mixins and all that. Give "redis-rb" a read through and it might help you wrap your head around some of this stuff. Good luck! o7 
IFTT... a_blue_duck appears ?
Yes. You'll probably have to pull together material from a variety of sources, but this isn't a problem. The ruby track on Codecademy is fine for learning the basics of syntax. Go through it and take notes of the examples, but don't feel sad if you don't understand everything or if you have to skip exercises. It'll periodically be useful to come back so you can see stuff you missed. [Learn Ruby the Hard Way](http://learnrubythehardway.org/book/) is also a solid resource, and is available for free online. Exercises 1-40 will be a repeat of most of what you learned in the Codecademy Ruby track. Exercises 41 and beyond will push you towards object-oriented programming (huzzah!) and then towards using Sinatra, which is a ruby library that lets you filter through incoming web requests and respond with ruby actions. (Incidentally, you can build pretty fully-featured web applications with Sinatra, and you can do so relatively quickly.) My students make use of the resources I've listed above and also [Chris Pine's Learn to Program](https://pine.fm/LearnToProgram/), which is also available for free online (it's an older edition, but most of the content is current, or at least current enough). Once you've gotten some fundamentals down, there are lots of places to go. The most common, probably, is to branch out towards Ruby on Rails. I found [Michael Hartl's 'Rails Tutorial'](www.railstutorial.org) to be a nice resource, but I hear Treehouse has some really great video content as well. (I'm not a fan of CodeSchool's Rails track -- it feels like the videos were made for people who already know what they're doing, and their lessons seem to gloss over a lot of the underlying works, making the whole thing seem very magical instead of systematic. Their "Ruby Bits" courses are pretty solid, though, but not for novices). But those aren't the only things you can do, by any means. And the really cool thing is that once you've got a solid foundation, learning new languages and tools (especially those which follow a similar paradigm to onces you already know) isn't too bad. The coolest thing, though, is that once you've got some solid fundamentals and once you're in the habit of breaking problems down into simpler components, you can build pretty much anything you want (albeit one piece at a time). Huzzah!
Very nice! I think it's a good expression of Monads- it's been a while since I've used them. (It was my... experimental phase with Haskell in college, haha.) One thing I would suggest is choosing better examples for your README. Luckily, since your specs are so rad (kudos to that, btw- I was very impressed) you should be able to pull examples from there. In fact, I'll tell you what. I'll submit a pull request this evening to show you what I mean. Overall impression: pretty rad.
Check out the source code for the ruby standard libraries. Some of the best examples of code style and quality. Also check out the rails source code. Pick a simple area at first, and then try going further. This is, by far, one of the best and first sources to learn ruby from. This is the journey taken by almost all the top ruby and rails contributors and it all started here.
Great gem! Here have 50 bits /u/changetip
The Bitcoin tip for 50 bits has been collected by *mushishi78*. [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
Rails is a LARGE framework but if all you're being asked is to throw a CRUD application together, break it down to the component parts that you need to know in order to do so, which off the top of my head are creating migrations, models, controllers and views; all of which are handled, at the most basic level, by [scaffolding](http://guides.rubyonrails.org/v3.2.13/getting_started.html#getting-up-and-running-quickly-with-scaffolding). Rails isn't complex, it's just big; however if you were confused by Sinatra then its suggests there are some basic concepts which you have not grasped. TALK to your tutors and try to identify where you lack knowledge and they should be able to guide you through.
Wow, finally!
Cool article! One minor thing: In the example for Array#bsearch you are actually using Range#bsearch. Internally they are implemented differently so doing data.to_a before calling find or bsearch would be more accurate for the benchmark.
:), continue the great work! Keep striving for better code everytime!
I´d rather have the Python way in this case, not sure I´d want to debug these issues in Ruby as well. At least in Scala I can force the functions to require parens.
Fuck compiling libraries that already exists on the system.
define 'web platform'.
this.
You mean like GitHub enterprise? You are not being really clear. 
No. As I understood your question, the application has not yet been built. If I were to have a self-hosted option and there were specific functions that were private (that I would not want to have someone prying their eyes into) then I would create some sort of compiled backend service with these services (similar to what RubyMotion has done) or I would have a web service that the self-hosted application talked with which would make this more of a semi-hosted solution. Regardless, if I did already have the application built, I would most likely not rebuild the application in a compiled language, but rather rethink my options as far as self-hosted options. Again, it really is about what kind of data that is being hosted. In a situation like this, you may be looking to sell a Source Code license rather than a self-hosted option. With your Source Code License option, you can have a "package" where you do the installation of the software on a Production and Sandbox environment for the client.
Disagree. I am the author of Phusion Passenger. As you know, we have Passenger Enterprise which is commercial and paid. We distribute Passenger Enterprise as regular source tarballs and source gems, **unobfuscated**. There isn't even any copy protection. It's literally the open source version, plus code changes that implement the Enterprise features. But our license states that you are not allowed to distribute and modify it, and that you can only use it if you have paid. If you stop paying, you also stop receiving support and updates. In other words, protect by law, not by engineering. Piracy has not been a problem for us at all. Our customers are businesses, and no real business would want to power their web apps using a pirated torrent app server with zero updates and support. So it depends on what your product is and who your customers are. Are you making a game and are your customers kids around the age of 20? Yeah, they're going to massively pirate, and the script kiddies will happily take your code and release h4x0rz. But are you making a self-hosting *business* web app? I think you'll be okay without obfuscating your code. Businesses don't want to get into legal trouble. If you state in your license that they can't read/modify/redistribute the code, they're not going to copy paste your code in your project and risk being sued. Maybe 0.1% is crazy enough to do that, but that's a negligible number. So this leaves the question of whether you should use *Ruby*. In my opinion yes: Rails is an excellent web framework, and beats others hands-off. Ruby is a very productive language, better than Javascript in my opinion. There's the distribution problem, but that can be solved with [Traveling Ruby](http://phusion.github.io/traveling-ruby/) or with [Omnibus](https://github.com/opscode/omnibus). Go makes it even easier by allowing cross-compilation, but Ruby + Rails is easier and faster to develop in, plus Ruby's web framework ecosystem is much more mature than Go's.
Mind....blown! Thanks for writing/sharing this.
Thank you, thank you! 
Another source is the [Pragmatic Sudios ruby course](http://pragmaticstudio.com/). I went though Codeacdemy and Codeschools Ruby courses, but the above was the only one to really explain the why and what of Ruby, and have you work though a consistent, course long program that applied all of the knowledge. It does cost a pretty penny compared to these others, but consider it an investment. Working knowledge of a programming language like ruby is an easy +15k salary bump for anyone in IT, and can get you into a job starting at 60k+ if you arent. Compared to that, the price seems like a downright steal to me. 
Mix in a test suite you want to run fast by parallelizing it (but fail to do deterministically) and you now understand why I am hopping over to Elixir...
Hi. I love Passenger and really appreciate all of the work y'all have done with it. (minus Raptor which still seems to be a bit buggy atm). I work in the Payroll industry so my mind defaults to taking extra security measures, especially in self-hosted environments where non-compiled applications could violate HIPAA Compliance Laws depending on who has access to the servers.
OpenFarm! It's like a version of wikihow and wikipedia put together, but for growing food. https://github.com/openfarmcc/OpenFarm
Yep, Raptor is still in beta and is not considered production ready yet. Beta 3, due soon, will be the first beta that is more or less usable in production. Currently blocked on a high priority issue that was reported last week.
While I understand why this could be considered a gotcha, based on my other knowledge of ruby and ruby closures this is exactly how i'd expect it to work. Good that it's out there for those who don't know that, though. The proper way to handle his last example, of course, is to deep copy the variable and pass that deep copy in instead of the original. There should be a way to make a wrapper function/monkey patch futures to cause that to happen in a similar way to Thread.new's syntax but I don't feel like figuring it out ATM.
I've done a bit of multi-threaded programming. I always try to implement multi-threaded programs with immutable data passing if I can do it anyway though, so I don't tend to run into this particular problem much. I agree that since it is an easy mistake it is a gotcha.
Considering Github is (or was, but I think it still is) written in Rails I'm sure it would be fine if that's your model.
&gt; Piracy has not been a problem for us at all To play devil's advocate how do you know that? &gt; hands-off Don't you mean "hands-down"? Or is it a regional thing maybe?
Personally I would've stopped at (assuming no `Integer#multiple_of?`) def self.leap? year (divisible?(year, 4) &amp;&amp; !divisible?(year, 100)) || divisible?(year, 400) end For me, early returns require some mental gymnastics and while the `and` and `or` operators look nicer, I find the method pretty hard to read without any parenthesis.
You can add the parens if they help you understand the method. I've grown accustomed to understanding ruby's operator precedence and don't find them necessary. My opinion, and I realize it isn't a common one, is that the ruby community made a big mistake by eschewing the use of `and` and `or` -- to me, operator precedence should be a basic part of understanding the language. By leveraging precedence rules I created an implementation almost entirely free of "noise" artifacts. As a result, my brain can read the `and`/`or` implementation and "get it" right away. But, point taken, I certainly don't particularly *mind* the implementation you pasted. For teams that choose to follow common style guides, it makes a lot of sense, and it contains the general idea: the private api in the blog post was an inferior way to approach the problem.
Middleman is the best static-site generator I've used so far.
Well, did it? 
So you want to get a better understanding of Rails but without taking your time to understand things? Yeah, I think the some reason you are having a hard time is because, yeah, it is unreasonable to learn all of that in three days. I wouldn't take it personally, but good luck. 
Hm, that does work -- and I couldn't understand why at first. You are still sharing the variable `x`; How is sharing the variable `x` any different than sharing the variable `i`, how did you change the output just by `x = i`. But then I figured it out -- it's got to do with what scope the variable is defined in. Check this one out, which also does not work (printing out ten 10's), by defining the variable x outside the loop. require 'thread' queue = Queue.new threads = [] i = 0 x = nil 10.times do i += 1 x = i threads &lt;&lt; Thread.new do sleep 1 queue.enq x end end threads.each do |t| t.join end queue.size.times do puts queue.deq end So that's the key thing, referencing a variable which was first declared outside the loop block -- a variable first declared inside the loop block, like `x` in your example, doesn't stay in scope when the loop re-iterates (so the threads don't end up sharing the variable), but a variable declared above that outside the loop block does. I think this is actually super tricky and definitely a gotcha. I am finding it pretty brain-contorting to figure out when the variable will end up shared and when it won't -- although now that I'm working with it and thinking through it, maybe it will become obvious to me -- it definitely wasn't until I carefully thought through it all. (And it's definitely got nothing to do with immutability, but with variable scope). Thanks for the code! 
Sure! http://learnrubythehardway.org/book/
You may use github for versioning your markdown files, then export it in HTML using Jekyll when posting to production.
A business would need to have a strong degree of confidence in the continued function of their core services. You know that it's inevitable someone will change something in a badly conceived way that breaks everything. Then they need to pay someone to fix it. As a direct consequence of refusing to pay for ongoing updates and support the business would need to hire a team of programmers to maintain and update the code base. That's going to get expensive pretty quick. What if there's a vulnerability and you don't have the patch? What if your company VP decides to change some stuff almost at random and breaks the system? What if you get sued and have to pay millions in punitive damages? All it would take to get caught is someone breaking the system, contacting product support only to have it discovered that their use is unlicensed with a very simple check to see whether or not they're actually a customer. Good luck running a business with zero disgruntled former employees that know where the bodies are buried and zero screw-ups.
Interesting! I've just set up a jekyll blog, and was looking for something like this. I'll definitely have a look at it.
As someone who has never heard of a Monad, could someone explain (like I'm 5) when/why you would use one?
We haven't seen any copies on pirate sites. Customers regularly contact us for license upgrades, even though there are no technical measures to require this.
Not sure why myringotomy has been downvoted, but this is a sound approach in certain circumstances. I heard Github Enterprise is (was?) shipped as a war file with JRuby. If the customer is a Java shop and is comfortable with running Java stuff, then shipping a war file to them works very well. Otherwise, you'll have to write wrappers to abstract away the Java layers for them. Jenkins' Debian packages do a pretty job at this. Of course, this comes with all the usual JRuby cons. Your app will start up very slowly, both in development and in production. Some gems are not compatible. Etcetera.
These days deploying a jar is actually easier than deploying a rails app under MRI. in your procfile instead of invoking unicorn you just do a java -jar ..... that's it, you can pack all your gems and even your ruby into the same jar.
thanks ;)
This just looks like elaborate cursing. =)
Obligatory 'Forced meme is forced' comment. Anyway, it looks pretty cool.
If you want to declare a process just as chain of methods, you can pass along a monad to deal with decisions along the way. For instance, if you wanted retrieve from a deeply nested hash: v = deeply_nest_hash[:user][:orders][1][:price] This could be dangerous: if one of the #[]'s return nil, then you'll get a MethodMissing exception from trying to call #[] on nil. So you can wrap the hash in a monad and find out if its a nil afterwards. With my gem, that'd look like this: v = Something[deeply_nest_hash][:user][:orders][1][:price] v.nil?
Well, the point I was trying to make on immutability(obviously badly) is that in a language built on immutability (like Clojure) this isn't a problem. Variables are always immutable, you are never modifying an existing value, things are always essentially passed by value, so threads can't mess with other threads without doing it purposely. The problem with this example in ruby is that when you do something like i+= 1 you are overriding the memory pointed to by the pointer "i" with a new fixnum. And when you pass i in to the thread you are passing the pointer not the value. However, when you pass the variable in via a method call or (like here) by making a new "pointer" [x] and setting it to the value of i you are in fact effectively pointing x to the value of i at that moment. The problem, and why you really have to understand this well, is with a complex object (like a hash or array) that contains other objects the little trick above probably won't work. Let's test it. require 'thread' queue = Queue.new threads = [] i = [0] 10.times do i[0] += 1 x = i threads &lt;&lt; Thread.new do sleep 1 queue.enq x[0] end end threads.each do |t| t.join end queue.size.times do puts queue.deq end Prints all 10s. In this case you'd need to make a deep copy like below, to get the desired behavior. [This works essentially the same for a hash btw]: require 'thread' queue = Queue.new threads = [] i = [0] 10.times do i[0] += 1 x = [] i.each do |value| x.push(value) end threads &lt;&lt; Thread.new do sleep 1 queue.enq x[0] end end threads.each do |t| t.join end queue.size.times do puts queue.deq end The problem is if the values in the array are also complex data types (like a hash) then you still won't get the correct value. require 'thread' queue = Queue.new threads = [] i = [{count: 0}] 10.times do i.first[:count] += 1 x = [] i.each do |value| x.push(value) end threads &lt;&lt; Thread.new do sleep 1 queue.enq x.first[:count] end end threads.each do |t| t.join end queue.size.times do puts queue.deq end However, if you clone the complex data type it works. require 'thread' queue = Queue.new threads = [] i = [{count: 0}] 10.times do i.first[:count] += 1 x = [] i.each do |value| x.push(value.clone) end threads &lt;&lt; Thread.new do sleep 1 queue.enq x.first[:count] end end threads.each do |t| t.join end queue.size.times do puts queue.deq end Which is what I meant when talking about cloning. In any case, I think that's the most common problems. Generally to deal with these issues I like to make a "deep clone"(recursively clone all the way down until you get to simple values) but I haven't had to do that in ruby so not sure how you would handle it.
I dont think the kind of people who know nothing about web development would be browsing /r/ruby!
Awesome, please let me know how it goes. I need to pull out a few more configuration options out of being hard coded. I believe there are a few calls remaining which assume a certain directory structure.
This is the best introduction to monads I've seen or read, to date: [Refactoring ruby with Monads](https://www.youtube.com/watch?v=J1jYlPtkrqQ)
Trying to pass the value into the thread with thread-local storage makes you very dependent on the runtime's thread scheduling choices. Our "sleeps" are meant to duplicate _certain_ thread scheduling choices -- with your example you are forcing a thread scheduling choice that makes it work. But in general, you have a race condition. Check out this one, where half the time you'll get 'original' and half the time you'll get 'nil'. require 'thread' value = 'original' t = Thread.new do sleep 1 if rand(2) &gt; 0 puts Thread.current[:value] end sleep 0.2 t[:value] = value value = 'changed' t.join Yeah, the "sleep 0.2" was there to force production of the problem, simulate a thread scheduling choice that will reproduce the problem 50% of the time. But without any sleeps (actually a more realistic example), it just means you are counting on the runtime/VM to execute the next line in the main thread before it executes a single line from the created thread -- which is not generally a safe thing to count on, it's still a race condition. Check out this one, with no `sleeps` at all: 10000.times do value = 'original' t = Thread.new do puts 'bad' if Thread.current[:value].nil? end t[:value] = value value = 'changed' t.join end Do you think that's safe? It depends on the behavior of the runtime/VM/OS. In MRI 1.9.3, I was unable to get any `bad` printed out. But in jruby, a _ton_ of `bad` are printed out, pretty much every time. In MRI 2.0-2.2, a few `bad` are printed out in 10,000 tries, maybe 3-10 out of 10,000. It's a race condition, you're depending on the VM's thread scheduling choices. I don't think using thread-local storage is actually a useful pattern for passing values _into_ a thread -- unless you use more complicated signalling to have the thread wait until the value is confirmed passed in. I think there are simpler ways to handle this -- like `Thread.new(args) {|my_args|...` You're right, it all follows directly from ruby's simple variable scoping rules. It's not a bug or anything. These variable scoping rules make it _really easy_ to accidentally share state in local variables though. And if you haven't done some exercises/experiments with ruby scoping, it can be easy to get confused about what's going on. I am only gradually becoming unconfused thorugh these 'debates' here (so thanks!), but I think some of you still are confused. :) For instance: i = 0 10.times do i += 1 # bad shared state, because `i` was declared at an outer scope Thread.new {sleep 1; puts i} end i = 0 10.times do i += 1 x = i # safe, no shared state, because `x` was declared here, # and will go out of scope in the main thread on next loop iteration Thread.new do {sleep 1; puts x } end That was not an initially intuitive outcome for me, and I think I'm probably not alone! But yes, I'm not suggesting it's a bug or anything. I'm not suggesting anything can be done about it -- it is a natural outcome of ruby's (formally simple) scoping rules. But it does make using any local variables in Threads (or other thread-based executors) a potentially dangerous state-sharing thing to do, and I haven't seen this issue discussed much. Thanks for the discussion/debate here, it's helping me come to an understanding of exactly what the issue is. 
Bono is a jerk, don't do work supporting him.
Ruby's Thread class doesn't have a way to create a Thread in a stopped state so you your right that you can create race conditions by performing an action that will yield to the scheduler before assigning the value to TLS, more apparent on JRuby for sure since it will immediately start running the thread. A way to avoid this is to create a Mutex, lock it, hold the thread on that Mutex, do your setup work, then release the Mutex. &gt; You are not making a copy of any of the data, you are making a copy of the 'pointer' or reference, if you want to get low level about it, which we don't usually do in ruby. Correct, this is what I mean by an 'effective copy'. Figuring out when a real copy is created is actually far from trivial. Here is a fun example: a = 5 b = 2 c = b + 3 a.object_id =&gt; 11 c.object_id =&gt; 11 `a` and `c` are the same object! (this happens because MRI interns the low values of FixNum values to avoid memory allocations for them) The import part of what happens here is that when you say something like `i = 0; x = i` you have created two values that are independent references, changing one reference doesn't change the other. When you write something like `i += 1`, you aren't 'mutating the object pointed to by `i`', you are assigning a new object to the `i` reference, this has no effect on the `x` reference, which is why the example in question works. EDIT: an example: value = [] threads = 10.times.map do x = value Thread.new { x &lt;&lt; 'HI'; puts x.inspect } end threads.map(:&amp;join) Despite the scoping of x, this prints an ever increasing list of 'Hi'
That's neat., I didn't know that existed. Codewars says there's something wrong with it, but then accepts it. &gt;:( Thank you for your help.
Maybe the reason is codewars itself. I have codewars on my list of things to do. How are the challengles, easy, difficult? Have you learnt something of it?
Here are the resources that got me started and productive in using Minitest. This should take you quite far. There's also a book called something like The Minitest Cookbook that should come out in the next month or so that I'm eagerly looking out for (Google it!). ### Minitest - Minitest Introduction - [Minimalicious testing in Ruby 1.9 with MiniTest](http://blog.arvidandersson.se/2012/03/28/minimalicous-testing-in-ruby-1-9) - best guide of Minitest! - only covers specs (not tests) - [A MiniTest::Spec Tutorial: Elegant Spec-Style Testing That Comes With Ruby](http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html) - Minitest vs. Unit (older testing framework) - Minitest matchers/expectations - Using Rake to run all your specs - [Video of Minitest by its author](http://confreaks.com/videos/618-cascadiaruby2011-size-doesn-t-matter) - tests vs specs; idiomatic writing of specs - randomization of test order - [Minitest Cheat Sheet](http://danwin.com/2013/03/ruby-minitest-cheat-sheet/) ### Minitest &amp;amp; Sinatra - [Sinatra Recipes - Minitest](http://recipes.sinatrarb.com/p/testing/minitest) - [Mini MiniTest Tutorial](http://www.millwoodonline.co.uk/blog/mini-minitest-tutorial) - [Why Sinatra's Halt is Awesome](http://myronmars.to/n/dev-blog/2012/01/why-sinatras-halt-is-awesome) - [Rack::Response::Helpers](http://www.rubydoc.info/github/rack/rack/Rack/Response/Helpers) - .ok? - .not_found? - .bad_request? ### Rakefile for testing using Minitest - [rake/testtask](https://stackoverflow.com/questions/4788288/how-to-run-all-the-tests-with-minitest)
I've only tried two problems, so I'm not the best person to ask. I think it's more rage-inducing, so be familiar with Ruby documentation.
hey uh can you teach me how to ruby. 
As @iconoclaus said, The Minitest Cookbook (my project) is on its way, and that will be a practical soup-to-nuts guide about using Minitest in the wild. In the meantime, I'm reading Eric Steele's short book [What Do I Test?](https://whatdoitest.com/) and finding it to be a good resource for developers just getting started. [Minimalicious testing in Ruby 1.9 with MiniTest](http://blog.arvidandersson.se/2012/03/28/minimalicous-testing-in-ruby-1-9) which is mentioned in another comment is probably the best free resource online for getting started.
You're not using the @value variable at all; you set it, but then use the original argument ('value', without the '@') later on. Codewars may be complaining about an unused instance variable, or (perhaps more likely) may be complaining because you're trampling on an existing instance variable in whatever context it runs your answer.
`x &lt;&lt; 'HI'` is mutating object state, yes. `x += 1` is not mutating object state at all, it is only changing the reference of x. I may not have the right terminology here, but the issue is that you can create a race condition problem without modifying any object state, only by changing a reference (what a variable points to). `Thread.new(args)` is not a defense against mutating object state. It is a defense against changing the reference of a variable in a "closure scope shared by multiple frames" if I have the terminology right. In this example, there is _no_ object state being mutated anywhere: i = nil 10.times do i += 1 Thread.new { do_work i } end Note in that example the `i+=1` happens _not_ in the block we pass to the thread, but outside it. Your examples did the increment inside the thread, which changes the situation and no longer demonstrates what I mean to demonstrate. This is a simplification of a pattern that was actually in my real world code. There is no object state being mutated anywhere there. It is still dangerous. Because the value of `i` in the block you gave to the thread can change before you get to `do_work i`. If the loop in the 'main' thread iterates again before the scheduler schedules the thread, then the `i` has changed before the `do_work i` happens. You could get more than one thread executing with the same `i`, and have other `i`s skipped. This isn't about object mutation at all, no objects are mutating. I agree that it is about variable binding. The reason I say it's about scope, is if make sure `i` is used for the first time _inside_ the `10.times do` inner block, the problem goes away. More idiomatically: 10.times do |i| Thread.new {do_something i} end In this case, you no longer have a problem -- you'll get 10 threads executing, each with a different value of `i`, 0 through 9. You'll never skip a value, or get two threads executing on the same value. Because every time the iteration comes around again, it's a new `i` reference (note: This may be different in ruby 1.8! Scoping rules for block arguments changed in 1.9. I am speaking of ruby 1.9+). So the `i` reference is no longer shared between threads. But as soon as you make `i` first declared (in ruby variables are declared at first use, implicitly) at the scope above, you have a problem -- all the closures are sharing the same `i`. And every time the loop comes around and the `i` is incremented -- every single thread is referring to that same `i` that has no been incremented, if the thread hadn't yet gotten to `do_something i`, it's now going to try to do something with the incremented `i` -- and you can get multiple threads doing something with the same value of i, instead of 1..10 as you had intended. That's why I say it's about scope. And in fact, `Thread.new(args)` takes care of this problem -- it does *not* take care of any mutating object state, which is why it did nothing useful in your examples with mutating object state. It is a defense against accidentally sharing the same variable reference across closures you are giving to threads -- it does that simply by making sure the variable reference in the thread is scoped only to the thread closure, and not shared with any other frames. i = nil 10.times do i += 1 Thread.new(i) { |ti| do_work ti } end In this example, there is no race condition, you will get 10 threads, one each operating on value 1 through 10. You will never get two threads operating on the same value, or any values skipped in 1..10. Because the closure used in the thread is using the variable `ti`, which is scoped only to that closure, and not shared with any other frame. The `Thread.new(arg)` construct very simply does that. Does this make sense? Thanks! 
If you have ActiveSupport around there is already `multiple_of?` defined for `Integer`. 5000.multiple_of? 5
Yeah, in Java they have kept the anonymous inner classes behavior for closures.
You can use [Traveling Ruby](http://phusion.github.io/traveling-ruby/) to create portable packages, or you can use [Omnibus](https://github.com/opscode/omnibus) to create platform-specific packages (RPMs, DEBs). Traveling Ruby -- written by yours truly -- is easier to work with, simpler and faster, but is potentially less powerful than Omnibus. Omnibus is heavyweight and requires a fleet of VMs for building platform-specific packages, but can satisfy complex requirements. For example, VirtKick is a Digital Ocean-like cloud panel. It's a Ruby web app. They use Traveling Ruby for packaging. Gitlab is a Github clone. They use Omnibus to distribute packages for multiple Ubuntu, Debian and Red Hat versions. They cannot use Traveling Ruby because they must also bundle PostgreSQL, Redis, etc.
&gt; First, would this be the right subreddit for me to post ruby help questions? Everyone else does it, so apparently. There's also always stackoverflow. I could debug it for you, but, you know, teach a human to fish... ~~I haven't actually debugged it myself,but it does look like it should work on an initial skim~~ (Okay, I lied, I did just debug it, I know what's wrong, maybe someone else will come along and just tell you, but I'd rather teach a human to fish). What do you think, how might you debug the fact that the return value of `time_conversion(15)` does not `==` the literal string '0:15', even though the right thing appears to be printed out? What is the method time_conversion returning? What determines the return value of a method in ruby? Socratic method! 
&gt; Don't do it. Just don't capture variables into a closure. That means closures can never be parameterized, which, since you create a thread in terms of closures, means work you submit to a thread can never be parameterized. I have a list of input I am looping over. For each input, I want to submit it for some kind of processing in a thread, one thread per input unit. This is a very common thing to do want to do, is it not? How can you do it without capturing any variables into the closure you submit to the Thread (or using `Thread.new(arg)` instead, which technically lets you avoid capturing any variables into the closure, which is exactly why it's nice). &gt;Just because you can hand Thread a block that can captures variables doesn't mean you should. Of course, ALL blocks in ruby *can* capture variables, there's no way to make a block that is incapable of capturing variables, all you can do is avoid using variable names that were already in scope. But how else can you create, say, a Concurrent::Future using anything but literals in source code? The Concurrent::Future doc examples only use literals, which is not very realistic: price = Concurrent::Future.execute{ Ticker.new.get_year_end_closing('TWTR', 2013) } As soon as instead you do: symbol = whatever_symbol_you_want_to_lookup price = Concurrent::Future.execute{ Ticker.new.get_year_end_closing(symbol, 2013) } Oops. We just did it. There's no useful way to use Concurrent::Future based on input of any kind, or paramterized in any way, without capturing variables from surrounding scope. Until it introduces a `Thread.new(arg)`-like api in a subsequent version. Which you don't think should be done either. So?
Technically the closure you pass to your thread captures the reference `runner` from the enclosing scope the closure was defined in, does it not? It's safe because the scope of the `runner` reference was _only_ the loop iteration block (which ends and becomes unreachable in the main thread as soon as the created thread is created), and not a broader scope. Which is why it seems to be about scope to me! You're still capturing a variable into the closure scope, and you still need to pay attention to what scope that variable was declared at. For instance, adding a spurious `runner = nil` would totally break your code: x = 5 y = ['HEYO'] runner = nil my_list.map do |thing| runner = MyRunner.new(x,y,thing) Thread.new { runner.run } end Oops, we broke it, it's a race condition now. That's kind of fragile, no?
Thanks a lot iconoclaus, I'm going to read them.
Thanks chriskottom, When will it be ready? How much? Approximately.
craigslist or perhaps google search for non-profits in your area and get in touch with them.
Are you sure it is returning the right output? As one commenter here said, try "*p time_conversion(5)*". Here are some questions for you to ponder about: * What do you get other than "00:15"? * Do you see anything else after it after running the method? * Why is that so? * Would an explicit *return* help? * **What is *puts*?** * **Does it just print something out or does it function like *return*?** * What is *p*? I hope these questions would answer your problem. If you still don't get it, feel free to message me. I recommend you try IRB out. Try: * *puts* * *p* * *time_conversion* * *time_conversion_with_p* * *time_conversion_without_puts_or_p* Don't forget to tell us what you learnt!
More than a month but less than two given the current state and rate of progress. Pricing for the book alone will be $29-$39. In the meantime, if you have any problems or questions, you can get in touch with me directly. Email and other contact info can be found at my [website](http://chriskottom.com).
It's important to remember that JRuby9k is coming around and it looks like it will blow all the others pretty soon with all the new optimizations.
What are "all the others"? I believe you when you're comparing to other Ruby implementations. But other languages?
That's very cool, thanks!
I only read about it, and have not actually used it. In what kind of scenarios do you use it? Ship your code to staging with the binding.remote_pry instruction so that you can get a grasp of some inconsistencies/misbehaviors compared to your local env, for example?
I would use rails console on our staging servers if I needed to check inconsistencies. We used to run our local environment with foreman https://github.com/ddollar/foreman (now we use ansible to build vagrant containers). And we would have a rails server running with foreman, and everything would break if you tried to use normal pry, so we used pry-remote. 
All of my testing shows comparable speed with the original Python module on the surface, though I haven't crunched any actual numbers. The original reason I made this gem was to have the same quick PWM support in Ruby ([pi_piper](https://github.com/jwhitehorn/pi_piper) wasn't cutting it, being written in pure Ruby), and everything I've tested shows that's the case.
More specifically, the current version of JRuby is 1.7.x, so the next major would have to be either 1.8 or 2.0, both of which would have been confusing WRT MRI, so they just settled on "jruby 9000".
The C extension API. It prevents changing how objects are laid out in memory, forces the use of the GIL, etc. 
GIL plus dynamicism/metaprogramming capability.
Really cool. I am a Ruby guy and a RPI noobie. What is the pull argument on the input do? Do you have examples? Also, if I want to specify GPIO 18, which one of the layouts do I use?
I also recommend checking out [pry-rescue](https://github.com/ConradIrwin/pry-rescue) which allows you to automatically drop into a pry debugger whenever there's an unhandled exception. I have a Cucumber test suite which I use for regression testing on a web application. I monkey patched the default cucumber_run_with_backtrace_filtering to yield inside Pry.rescue so I can start debugging any time a test fails: module ObjectExtension def cucumber_run_with_backtrace_filtering(pseudo_method) begin Pry.rescue{ yield } rescue Exception =&gt; e super.raise e end end end class Object prepend ObjectExtension end
Thanks! If you want GPIO 18, you'd use `:bcm` numbering (equivalent on my Model B with `:board` numbering is pin 12). Remember that `:board` numbering refers to the physical pin numbers on the Pi, whereas `:bcm` refers to numbering applied from the Broadcom SoC, which can vary from model to model. [This diagram](http://www.raspberrypi-spy.co.uk/wp-content/uploads/2012/09/Raspberry-Pi-GPIO-Layout-Revision-1.png) illustrates the difference. See [the original documentation](http://sourceforge.net/p/raspberry-gpio-python/wiki/BasicUsage/) under "Pin numbering" for more info on this. As for the pull argument, this is from the [original module's documentation](http://sourceforge.net/p/raspberry-gpio-python/wiki/Inputs/): &gt;If you do not have the input pin connected to anything, it will 'float'. In other words, the value that is read in is undefined because it is not connected to anything until you press a button or switch. It will probably change value a lot as a result of receiving mains interference. &gt;To get round this, we use a pull up or a pull down resistor. In this way, the default value of the input can be set. It is possible to have pull up/down resistors in hardware and using software. In hardware, a 10K resistor between the input channel and 3.3V (pull-up) or 0V (pull-down) is commonly used. The RPi.GPIO module allows you to configure the Broadcom SOC to do this in software.
You might also want to take a look at [awesome_print](https://github.com/michaeldv/awesome_print), which is sort of a happy middle ground between puts and pry. It lets you print out a nicely presented, indented, and colorized version of an object.
Lets say you use something like [pow](http://pow.cx/) and wish to inject pry into rails somewhere, say, a controller action thats misbehaving. Since pow provides no interactive console, you're SOL right? **Wrong!** You can use pry-remote to debug it! --- That said, you can also make use of the excellent [better errors](https://github.com/charliesome/better_errors) gem
Great! I'd say pry (and all its plugins/add-ons) are complementary to awesome_print. Good stuff! 
that's the one, thank you!
Awesome. I'll certainly be using this on a project I'm working on at work this week!
Awesome post! As a newb rails dev who recently began using pry as opposed to sprinkling my code with puts, I totally relate to excitement you feel with it. Ruby on! 
Thank you! I bought my PI 2 days ago, so this will be perfect.
The nature of the bug here is going to make that a bit confusing, actually. This is a hint. You may want to learn to use an actual debugger to help -- someone just posted this guide to the reddit too: https://dnlserrano.github.io/2015/01/11/debugging-ruby/ Or, try `x = time_conversion(15)`. And `puts "The result is: #{x}`. 
If you want to or are willing to deploy with jruby instead of MRI, you can use warbler to package up your code, all gem dependencies, *and* the jruby runtime itself as a single Java .jar (or .war). https://github.com/jruby/warbler It's a large .jar/.war, since it includes the jruby runtime itself (which I think is in the high two digit megs). They'd still need to have java on the host machine. You say 'web app' which introduces some additional concerns -- the web server/app server. How will it be deployed? With any old ruby, the host will need to have a web server and some method for interfacing your ruby app with the web server, which is usually an 'app server' like passenger, puma, etc. I'm not sure how/if Travelling Ruby or Omnibus handle this problem, I am not familiar with them. With jruby and warbler, you can create a .war that will run on any old Java application server (tomcat, jetty, etc.), the host would need to have a java web app server, and you'd just give them the .war and tell them to install same as any other java .war in their java app server. So that's one more option. If they are comfortable with and support java web apps, it can be convenient to give them a .war package they can deploy in the ways they are already comfortable with. If they are not already comfortable with and support deploying ruby apps -- it doesn't matter with the warbler method. With other methods, it might. Note that using a warbler war, the exact version of all gems is fixed when you create the .war. If there's a security release to ruby or nokogiri or something -- the only way to update in deployment would be to create and deliver a new .war with the updated versions. 
Cool project. But I would have made pins as objects, and "pwm" a subclass of the Output class. Something like this: module RPi module GPIO class Input; end class Output; end class PWM &lt; Output; end end end input = RPi::GPIO::Input.new(NUM, :pulldown/:pullup) output = RPi::GPIO::Output.new(NUM) pwm = RPi::GPIO::PWM.new(NUM, &lt;options&gt;) input.high?/low? output.set/clear ... just my 2 cents. 
Am I the only one that absolutely loves RubyMine's built in debugger? It's what I use exclusively.
I don't have a ruby console handy, but this should work for you. You may or may not need to add a @ to the beginning of the variable name string. array.each do |name| instance_variable_set "#{name}_label", Tk::Tile::Label.new(@left_frame) instance_variable_set "#{name}_image", TkPhotoImage.new end Edit: looks like I got pipped to the post
Are you sure you really want to do that though? You might be better keeping them in two hashes, among other possible alternatives. array = %w[feet, hands, neck, head, legs, arms, chest, weapon] labels = {} images = {} array.each do |part| labels[part] = Tk::Tile::Label.new(@left_frame) arms[part] = TkPhotoImage.new end But what you're asking could be appropriate too, depending on what's up. 
the @ symbol represents an instance variable. the two methods you mention are what we would call a 'getter' and a 'setter'. def title simple echo's back the current value of the instance variable (@title). def title= allows you to have an instance of a book and set it's title variable. for example.. b = Book.new b.title ## will return nil since we haven't set it yet b.title = "The Hobbit" ## notice the 'title=', this is the name of the method b.title ## will now return "The Hobbit" b.title = "Willy Wonka and the Chocolate Factory" ## again using 'title=' method b.title ## will return "Willy Wonka and the Chocolate Factory" hopefully that makes sense edit- important to note that... b.title = "The Hobbit" b.title=("The Hobbit") are the same thing
Everytime I read about pry, it makes me feel bad that I am still using the debugger gem. I have to switch to pry, it seems to be much better.
`@title` is an instance variable. Consider this: class Book def initialize(title) @title = title end end Now in IRB: book = Book.new 'Harry Potter' book.title =&gt; NoMethodError: undefined method `title' for #&lt;Book:0x000000070818d8 @title="Harry Potter"&gt; Instance variables are available only inside the class and each instance of an object has its own instance variables. To get the @title variable outside of the class you either need to define methods to do this or use ruby's `attr_reader`, `attr_writer` and `attr_accessor` methods. The first way is what you have there. def title @title end returns @title. Remember that in ruby methods return whatever was the last thing evaluated. So that is the same as def title return @title end which is what you would see in many other languages which require the user the the `return` keyword. def title=(title) @title = title end defines a method called title= which takes one parameter, the new title. One of the cool things about ruby is that you can use more than just alphanumeric characters and underscore in methods. So instead of `book.setTitle('Well Grounded Rubyist')` as you might see in other languages, you can do `book.title= 'Well Grounded Rubyist'`. But that's not all! Ruby is even cooler because it lets you put a space between the equal sign and the rest of the method name! So you can use `book.title = 'Well Grounded Rubyist'. Doesn't that look slick? I mentioned 3 methods above. class Book attr_reader :title def initialize(title) @title = title end def title=(title) @title = format_title title end end is equivalent to what you have above. `attr_reader` replaces the `title` method. You can use `attr_writer` to replace the `title=` method, but you wouldn't want to do this since then you couldn't call `format_title`. Lastly, `attr_accesor` replaces both `title` *and* `title=`. Isn't that handy?
It may be a "regression" in the sense that it's a change to behavior, but I strongly feel that it's a bug fix. If I ask for a parsing of a date string which contains a time zone, I want the answer to tell me what time zone is in the date string.
Anybody else use byebug ?
AFAIK pry maintains syntax highlighting while byebug doesn't... That's it.
As a new Ruby and Rails Dev, pry is a godsend. Just !make sure to remove every trace of it in your production and and code pushed to github ;)
This only applies when their is no user privacy policy to take into account.
`puts` already puts "\n" in the output, so you have double "\n\n". You should use `$stdout.print "/#{ln}.html\n"` instead. Also: - do not put $stdin in sync mode, there is no need for. Only stdout should be in sync mod. - you should use `while ln = $stdin.gets` not `while true`
Yep, my first thought. PHI and HIPPA compliance :)
How about saving lives and lowering hospitalizations by bringing restaurant inspection scores to the people? We're a startup with a public benefit mission. We've been working with one of the largest restaurant review sites to get our data integrated. And we're reaching out to others and journalists. Portland, Oregon, USA is finished, and we've begun Las Vegas and London. We'd love to have contributions of scrapers and adapters for any cities, any countries. We also have a ton of interesting visualization and statistics that can be done with the data. [Here's Portland](http://eaternet.io).
Check out the [projects on Assembly](https://assembly.com/discover). It's all open source, and you can opt-in to a share of potential future earnings. My project is [Think 200, an extension to RSpec for testing web apps and apis](https://assembly.com/think-200).
This article is just fucking stupid. Programming is not some core skill everyone is scrambling to pick up, and it's not even remotely necessary for survival in modern society.
Hey, dude. You can't post links just to your website. Also content is a bit crappy and not related to /r/ruby. Please, don't do that.
How did the test go?
Here you go: https://eval.in/244264
it'd be nice if Traveling Ruby could work for Windows too, so far it can only build for Linux and OSX.. does anybody have more information on whether this will happen anytime soon? 
Check out rubocop, a tool to enforce code style consistency. It can find and remove leftover instances of "binding.pry" in your code, among other things. It fits in my workflow after tests are passing but before commit.
No. Pry has a tonne of features that byebug does not. Such as source/doc browsing, editing/modification of code in repl session, a huge plugin ecosystem (with plugins for integration with byebug), ability to change scope (i.e the `cd` command) and so on. But the two aren't directly competing really - they work great together :)
https://github.com/phusion/traveling-ruby#why-does-traveling-ruby-not-support-windows https://github.com/phusion/traveling-ruby/wiki/How-you-can-help-with-Windows-support If you want Windows support, please contribute.
It looks like your general strategy was to find each word, then search for the entire book for that word. This strategy would work (with some tweaking to your code) but would be inefficient and miss out on the constant time access of a hash. Try doing the reverse instead -- go through the book word by word and look it up in a hash that stores all of the words. If the word is in the hash, increment the counter. If a word isn't in the hash, add it to the hash with a count of 1. P.S. There's a disctinction between the `each` and `map` methods. One simply iterates through an array, and one applies a transformation to each element in the array.
So, as /u/kewldude606 mentioned, there's more efficient ways of parsing your input, which you'll be able to figure out if you just keep whacking at it. However, the life pro tip here has to do with your output. This data structure from the example: {'the' : 56, 'example' : 16, 'blue-tit' : 4, 'wings' : 75} is what's known as a JSON object. JSON stands for JavaScript Object Notation. Forget the Javascript part, it's not relevant. It's just the language this format originated from. However, it's an EXTREMELY useful way of passing structured data around a program, between programs, between clients and servers, etc, and as such, just about every programming language on earth has a library for it. Do some reading here on the format: http://en.wikipedia.org/wiki/JSON and here: http://www.ruby-doc.org/stdlib-2.0/libdoc/json/rdoc/JSON.html for Ruby's implementation of it. That may actually give you some clues as to better ways to parse your input too, if you think in terms of how you want to structure the output once you have the data you want. EDIT: You might also want to figure out what "\w" does in regards to regex. ;)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**JSON**](https://en.wikipedia.org/wiki/JSON): [](#sfw) --- &gt; &gt;__JSON__ (/ˈdʒeɪsən/ *__JAY__-sən*), or __JavaScript Object Notation__, is an [open standard](https://en.wikipedia.org/wiki/Open_standard) format that uses [human-readable](https://en.wikipedia.org/wiki/Human-readable) text to transmit data objects consisting of [attribute–value pairs](https://en.wikipedia.org/wiki/Attribute%E2%80%93value_pair). It is used primarily to transmit data between a server and web application, as an alternative to [XML](https://en.wikipedia.org/wiki/XML). &gt;Although originally derived from the [JavaScript](https://en.wikipedia.org/wiki/JavaScript) scripting language, JSON is a [language-independent](https://en.wikipedia.org/wiki/Language-independent_specification) data format. Code for [parsing](https://en.wikipedia.org/wiki/Parsing) and generating JSON data is readily available in many [programming languages](https://en.wikipedia.org/wiki/Programming_languages). &gt;The JSON format was originally specified by [Douglas Crockford](https://en.wikipedia.org/wiki/Douglas_Crockford). It is currently described by two competing standards, RFC 7159 and ECMA-404. The ECMA standard is minimal, describing only the allowed grammar syntax, whereas the RFC also provides some semantic and security considerations. The official [Internet media type](https://en.wikipedia.org/wiki/Internet_media_type) for JSON is application/json. The JSON filename extension is .json. &gt;==== &gt;[**Image**](https://i.imgur.com/4jAXSSq.png) [^(i)](https://commons.wikimedia.org/wiki/File:JSON_vector_logo.svg) --- ^Interesting: [^JSON-LD](https://en.wikipedia.org/wiki/JSON-LD) ^| [^JSON-RPC](https://en.wikipedia.org/wiki/JSON-RPC) ^| [^BSON](https://en.wikipedia.org/wiki/BSON) ^| [^Idtp](https://en.wikipedia.org/wiki/Idtp) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cnt6gmq) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cnt6gmq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
pry-rescue + pry-remote, and a dash of imagination. So many insightful debugging sessions. &lt;3 pry
`ARGV` can affect the behavior of `gets`. See [the documentation of Kernel#gets](http://www.rubydoc.info/stdlib/core/Kernel#gets-instance_method) for more information. You will probably also want to read up on [ARGF](http://www.rubydoc.info/stdlib/core/ARGF).
You can't use `gets.chomp` in a website to get user input in a website, you need forms for that. Anyway https://www.railstutorial.org/book teaches you from start through end of developing a website. It also teaches about ruby, hosting etc. You can read the book online for free. But I must warn you that it won't be that simple to finish. BTW if you just need Q&amp;A and don't care about url, go use google forms.
*cringes*
http://apidock.com/ruby/String/%25 http://apidock.com/ruby/Kernel/sprintf
Looks cool! 
I don't see how either applies to this line: `get 'docs/:article', to: redirect('/wiki/%{article}')`
I don't think thats ruby doing string formatting, it's rails doing something magical. Somewhere it's substituting the %'{article}' for the ':article' variable.
Yes, it is, especially on long-lived server-side processes.
The way this applies is like this: `'/wiki/%{article}'` is a format string, meaning that if you pass this string *and a hash with symbol keys that match those embedded in the format string* to `sprintf` (or use the `%` operator), the value that corresponds to the `:article` key in the hash will be interpolated into the string: [1] pry(main)&gt; sprintf '/wiki/%{article}', article: 'hello' =&gt; "/wiki/hello" [2] pry(main)&gt; '/wiki/%{article}' % {article: 'hello'} =&gt; "/wiki/hello" [3] pry(main)&gt; '/wiki/%{article}' % {:article =&gt; 'hello'} =&gt; "/wiki/hello" [Kernel#sprintf](http://ruby-doc.org/core-2.0/Kernel.html#method-i-sprintf) with all of its glorious options is quite handy. Edit: if you scroll all the way to the bottom of the above-linked `sprintf` documentation, you will see the last example using *named references* in format strings. I quote: &gt; For more complex formatting, Ruby supports a reference by name. %&lt;name&gt;s style uses format style, but %{name} style doesn’t. &gt; Examples: sprintf("%&lt;foo&gt;d : %&lt;bar&gt;f", { :foo =&gt; 1, :bar =&gt; 2 }) #=&gt; 1 : 2.000000 sprintf("%{foo}f", { :foo =&gt; 1 }) # =&gt; "1f" I hope you see that underneath all that rails magic is just ruby :)
you could try using http://ruby-doc.org/core-2.2.0/Object.html#method-i-dup although it makes only a shallow copy so i am not sure if it would solve your problems. There are some questions on stackoverflow that have some replies that most likely will explain variable passing etc. better then i would have http://stackoverflow.com/questions/1872110/is-ruby-pass-by-reference-or-by-value this might be better read before that stackoverflow question http://www.rootr.net/rubyfaq-4.html
What a fluff piece.
So many words and yet so little content. Tldr; \+ gems, community, readability \- slower than compiled languages, perl-like cleverness
Ohhh, these two posts help immensely! I probably spent two hours flinging around puts statements everywhere trying to figure out where the flaw in my logic was; eventually I got frustrated, made several paper copies of the grid I'm using for testing, and ran the algorithm by hand to make certain what I envisioned in my head would work correctly. It was at that point where I discovered that something may be going on with the language I don't understand. I'll definitely give the project euler problem a go once I finish this, and will check out your solution afterward to see how your algorithm differs. The way you describe your solution from five years ago is the way I feel about my solution now; ugly, hard to follow, naming sucks, and isn't very Ruby--I'm afraid to show it to people for advice haha. I've pretty much solely been in .net land (c#, c, c++) so getting down the Ruby idioms, best practices, and loops has been difficult. Apologies for grammar errors--on mobile.
Volt has other data stores in the pipeline :-)
It's an IDG brand; technical fluff is to be expected, given the hemidemisemiquasitechnical audience they typically shoot for. (Look at *PC World* now compared to any similar magazine 25 years ago.) The title is egregious click bait and a waste of time for anybody who's written more than five lines of Ruby code, but what did anyone expect?
This particular interpolation is being done by the rails framework, not ruby's built-in interpolation system. It seems like this is custom to the redirect method itself and probably can't be used anywhere else. If you look at the [rails source code for redirect](https://github.com/rails/rails/blob/092f74080c85ae343fcd97ad5f88fb019ab421c0/actionpack/lib/action_dispatch/routing/redirection.rb#L177) (which is linked to from the bottom of the docs) and scroll up a bit you'll see the OptionRedirect class does a "match" on "/%\{\w*\}/" and then does some built-in ruby interpolation using [the % method of the String class](http://apidock.com/ruby/String/%25). It also looks like there is some [URL escaping]( http://en.m.wikipedia.org/wiki/Percent-encoding) of values going on to ensure the result is a valid URL, which normal string interpolation wouldn't do. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Percent-encoding**](https://en.wikipedia.org/wiki/Percent-encoding): [](#sfw) --- &gt;__Percent-encoding__, also known as __URL encoding__, is a mechanism for [encoding](https://en.wikipedia.org/wiki/Binary-to-text_encoding) information in a [Uniform Resource Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier) (URI) under certain circumstances. Although it is known as *URL encoding* it is, in fact, used more generally within the main [Uniform Resource Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier) (URI) set, which includes both [Uniform Resource Locator](https://en.wikipedia.org/wiki/Uniform_Resource_Locator) (URL) and [Uniform Resource Name](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (URN). As such, it is also used in the preparation of data of the application/x-www-form-urlencoded [media type](https://en.wikipedia.org/wiki/Internet_media_type), as is often used in the submission of [HTML](https://en.wikipedia.org/wiki/HTML) [form](https://en.wikipedia.org/wiki/Form_(web\)) data in [HTTP](https://en.wikipedia.org/wiki/HTTP) requests. &gt; --- ^Interesting: [^Shellcode](https://en.wikipedia.org/wiki/Shellcode) ^| [^POST ^\(HTTP)](https://en.wikipedia.org/wiki/POST_\(HTTP\)) ^| [^Uniform ^resource ^locator](https://en.wikipedia.org/wiki/Uniform_resource_locator) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cntyj0c) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cntyj0c)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
You forgot to include the error description. - What did you expect would happen? - What happened instead? - Is there any error message or stack trace (if so, include those verbatim)? Oh, and if you're just editing your post, please reformat the output of `gem env` to include four spaces at the beginning of each line (this creates a code block in Markdown). KTHXBYE :-)
Hi - yes of course, I'll fix the formatting. I can try and include some more error detailing, but there's not much I can show other than the process information when running from a terminal shell vs. cron - thanks :)
Sorry for the late reply. I see the error now :) Instead of using "puts" within the method, I should've used "return". I used the code you provided below x = time_conversion(15). And puts "The result is: #{x} I tried using "puts" within the method and "return" within the method, and only the return function would show the actual result. What happens when I use "puts" within the method? The results were showing previously, but why doesn't it show within the string interpolation you used as an example?
I wanted to scrap a site that requires me to login from another site. If I go to the url in question directly it doesn't work. I have to first login to the portal site then click on the actual link I want to go to. Will Mechanize handle these situations? 
Thanks for the tip! I've actually come across \w in my travels, but I wasn't sure how to implement it while preserving spaces. However, you inspired me to do some more research on regex, and I found this to be a suitable solution: .gsub(/[^\p{Alnum}\p{Space}]/, '') Why is the syntax so different from, say, "(/\w/,'')? What do the forward slashes and the p's denote? I played around with it and removed the "^", and I see that my omitting that the gsub method took away the alphanumeric characters from my string, so I at least know what that part of the equation does...
Thanks for helping me out, and glad you were able to help out the other guy as well :)
Yeah the environment variable points at the correct display. Hmm, that's odd..
One thing that confused me while learning ruby is the difference between instance variables and `self.variable`. I used this StackOverflow article to explain it: http://stackoverflow.com/questions/1693243/instance-variable-self-vs
I like that. Nothing better than a camel-case Middle Aged Socialite example..
Yes. Of course you need to find out what kind of login that is (form based or basic auth for example) and then code towards that.
This title is TMZ worthy. The article thinks it's news. Title suggestion: 'Creator of ruby admits he used Perl for inspiration'
What would be the target audience for a piece like that?
Write some more advanced ones then.
I've been reading up on the differences between self and instance variables and am still failing to see any significant difference. Can I just assume that they are the same thing? Honestly, I prefer instance variables and can't remember ever using self, except when I'm making modules.
Neat little article, but I stopped reading when I saw require 'nokogiri' I was like.. OH, well YEAH... 
They're actually not really very similar at all, though I can see how they'd be confusing. class MyObject attr_accessor :bar def foo self.bar = "bar" woo = "baz" end end myobj = MyObject.new myobject.bar # nil myobject.foo myobject.bar # "bar" myobject.woo # NoMethodError **EDIT**: derp read the answer below, I thought you meant local variables not instance variables. 
I really really like this. There really is no reason to be writing code for large web applications in JavaScript these days when there are so many compilers out there.
Good work. `puts` prints out the value to the terminal. But your "assignment" didn't mention printing out to the terminal at all, it was about creating a method that returns a certain value. If a method doesn't have an explicit `return`, then the method's return value is the return value of the last statement executed in the method. The last statement was the puts -- but while `puts` prints out its' value, it actually returns 'nil'. When you say `x = time_conversion(15)`, then the value of `x` becomes whatever the method returns -- in this case, nil. You could easily write a method that both printed out the value to the terminal and returned that same value -- just `puts` it first then `return` it -- but your assignment didn't actually tell you to print out the value to the terminal, it told you to write a method returning a certain value. And that's what the test code was testing. 
Thanks for your input, I'm going to do that. What do you mean by missing out on constant time access of a hash, though? I tried googling it but I might need an ELI5 assists here, if you don't mind!
I don't get it. What does this example demonstrate? I only see that the first call to bar is nil because bar its still not initialised, and so it gives nil. Then it's initialised through foo, and returns "bar". Fine, would that have been different if you used @bar instead of self.bar? Then you call the method woo, which doesn't exist. What does this prove? How is self.bar different from @bar? 
In your example, `woo` is a local variable, not an instance variable, that would be `@woo`. Also, that aside, you cannot compare a variable with an accessor to one without... The point is that `@var` returns the instance variable and `self.var` passes the message `var` to the class it is being called on. I think this would be a more apt example: class MyThing def initialize @num = 4 end def num "I'm not even a number!" end def test puts @num puts self.num end end v = MyThing.new v.test #=&gt; 4 #=&gt; I'm not even a number! 
self.bar is calling MyObject#bar, whereas @bar is accessing the value directly. In this case, MyObject#bar is implemented like so: def bar @bar bar attr_accessor is simply a shorthand method to define an accessor method like that as well as a corresponding setter method: def bar=(value) @bar = value end These accessor methods aren't always defined this simply - sometimes you may have a method that does a bit of computation when a value is set. def email=(value) @email = value.downcase end In this case using self.email = "ME@EXAMPLE.COM" is different behavior from @email = "ME@EXAMPLE.COM" - the first will store "me@example.com" and the second will store "ME@EXAMPLE.COM" It's considered good practice to always use accessor methods because it allows you to extend the behavior to do other things elegantly. For example, if you extract a class out of another class and compose the two together, you may be able to make less changes to the class the new class was extracted from simply by implementing a delegate method to delegate access of an attribute to the new class. Since you're using the accessor everywhere instead of the instance variable, the only thing that has to change to delegate the behavior to the new class is the accessor. EDIT: Here's a real world example. I had a TokenAuthenticator class which found a token and gave me a user from it. I needed to implement a TokenDestroyer class, which shared some similar behavior (finding a token) so I split that out into a TokenAuthenticator and TokenFinder, then introduced a third class to destroy a token. You'll note that I didn't have to change the #user method in TokenAuthenticator after splitting the class up. This class TokenAuthenticator def initialize(opts = {}) @request = opts.fetch(:request) end def user if token.present? token.user end end private attr_reader :request def token @token ||= Token.active.find_by_key(token_key).tap do |token| break unless token.present? token.bump_timeout! end end def token_key authorization_header.split(' ').last if authorization_header.present? end def authorization_header @authorization_header ||= request.headers['Authorization'] end end turned into this class TokenAuthenticator def initialize(opts = {}) @request = opts.fetch(:request) @token_finder = opts.fetch(:token_finder) { TokenFinder.new(request: request) } end def user if token.present? token.user end end private attr_reader :request, :token_finder delegate :token, to: :token_finder end class TokenFinder def initialize(opts = {}) @request = opts.fetch(:request) end def token @token ||= Token.active.find_by_key(token_key).tap do |token| break unless token.present? token.bump_timeout! end end private attr_reader :request def token_key authorization_header.split(' ').last if authorization_header.present? end def authorization_header @authorization_header ||= request.headers['Authorization'] end end Then, I was able to use the TokenFinder in the same way in a new TokenDestroyer class, keeping duplication in terms of how to find a token out of my codebase. If I was accessing the token as @token instead of via the accessor, this change would have been a bit larger, as the user method would have had to change as well. Edit 2: For reference, delegate :token, to: :token_finder is equivalent to this: def token token_finder.token end
It means the time it takes to get/set/ add/remove from a hash doesn't depend on the number of keys in the hash. As far as why, that's diving into how the data structure works which I would tell a five year old, just because. Haha. No but its hard to condense asymptotic qualities of data structures but there's always a trade off. Here's a cheat sheet: http://bigocheatsheet.com O(1) means constant time, or irrelevant to size of data structure. O(n) means it operations grow as the data structure. Or linear as the maths people would refer to it as. O(n^2) means exponential cost of operations. So for 10 elements, it would be 100 operations worst case. For 100, 10000. Big O is the worst case. It's possible getting an element from a data structure with linear access and 10 million items takes 1 operation if it's the first element. 
Great stuff. Thanks for pointing me in the right direction, I just watched an hour's worth of ruby regexp videos on YouTube and now I understand what you're talking about!!! Thanks again. EDIT: Good call with the JSON stuff. I've used JSON before to parse URLs before, but I didn't recognize the JSON format immediately in the output. This helps immensely. 
Awesome! Thank you for your help with this and thank you for the explanation :)
Use your browser, Luke.
The term for what you're asking is a "deep copy" or "deep clone". Try searching for those, along with "ruby", and you'll find a bunch of code snippets and gems. One DIY method occurs to me: put all your variables in a Hash. For each state you want to save, serialize it, e.g., to json. Then store that json string on your history stack.
Nokogiri is a popular gem that makes parsing / searching / modifying HTML docs very easy. Reading the title I got the impression OP had built something similar to Nokogiri, but this is more or less just a tutorial on how to use it. 
Get over forwardable, its all you ever write about, and its not that interesting.
I regretted my harsh and inconsiderate words for Volt as soon as I posted. It is an ambitious project whose direction happens to be different from the types of apps *I* happen to be working on at this time, and I wish it every success it deserves. Same goes for RubyFire - I just want to see it already :)
Yeah, sad :(
ai you're right, I didn't even read the question properly!
TIL: `Forwardable::debug` That's useful.
i'm with you. 
Refinements allow you to modify someone else's code you don't own. They are not ideal for application code. They can be useful in libraries to prevent internal changes from propagating to the outside world. One example of why monkeypatching with refinements is superior to opening standard classes: Supposed you have a gem called `reddit_is_fantastic`, which exposes itself through a ruby module called `RedditIsFantastic`. Consider: Object.send :remove_const, :RedditIsFantastic If `reddit_is_fantastic` used refinements for monkeypatching, it can now be safely unloaded from memory thanks to ruby's excellent self modifying runtime. There are a lot of things like robust, safe, and fast autoloaders that aren't strictly possible when you don't have code fully isolated within namespaces. Another example of where refinements can be useful is to implement roles in a DCI scenario. I haven't tried this, but it seems pretty cool.
So true.
Hi there, I am a beginner too and I found this tutorial http://docs.railsbridge.org/intro-to-rails/ to be helpful and quick to get an app going and it might just be that you can get your Q&amp;A app going in a few hours (on Heroku) if you follow the tutorial and do a little bit more reading on how to edit your app.
Hey hope this comes across as constructive but I think you may struggle with that budget. A conservative estimate for a detailed technical blog post is perhaps 1500 - 2000 words. Assuming it's a single topic the author already has good background in, a day is probably reasonable to write the post and test sample code. Less if it's just documenting something they've already done but that's less representative here. I've spent quite a lot of time writing educational materials about Ruby aimed at beginners for my own company. Writing and testing those takes significantly longer than technical blog posts because more time goes into making it beginner friendly, e.g. there's less you can assume about what the reader knows. Once you get into beginner friendly quizzes that becomes even harder. So for 10,000 good quality words aimed at a beginner, I can't believe it's going to take less than 10 days of work. Which if you're looking to hire a ruby dev is at least $4000+. For something which is of a higher standard than the existing into to Ruby stuff - and there's a lot of really good stuff out there - I'd guess a fair bit more than that. Again hope that comes across as constructive. I've definitely underestimated how much time and effort it will take to create educational materials before and been caught out by it!
Seems like a lot of work from someone with professional expertise for $400-$600. 
This has to be sarcasm. 
There's no reason to do that. What you may sometimes see class Test &lt; SomeOtherClass def initialize; end end ...which serves to override the parent initialization code with a whole lot of nothing (making sure the superclass's init code doesn't get run), but for class that inherits from Object, it accomplishes nothing. 
Yes you can use it: irb(main):001:0&gt; class Bear irb(main):002:1&gt; def initialize irb(main):003:2&gt; @name = gets.chomp irb(main):004:2&gt; end irb(main):005:1&gt; end =&gt; :initialize irb(main):006:0&gt; b = Bear.new beer =&gt; #&lt;Bear:0x007f965a82e630 @name="beer"&gt; irb(main):007:0&gt; b.instance_variable_get(:"@name") =&gt; "beer" but it blocks, so when calling Bear.new, it just hangs there, till I enter something and press return. The web based interpreter might also block, and since nothing is entered, it doesn't continue.
I might add that this is not the best way to go about things because it dramatically limits the use cases for class Bear. I'd rather do the IO outside of the class and hand in the string obtained from stdin or wherever else.
This example only exists because someone used mokeypatching. You have a problem, then a new problem is created so the original problem can be _fixed_. People should just stop doing monkeypatching, methods that take the objects they're working on as parameters are just fine.
This is awesome, we use JRuby quite a bit and I can't wait for 9000.
`%` is actually a method of the `String` class, so what's happening here is we are calling the `%` method on the `"%d:%02d"` string and passing it an array as an argument. [Take a look at the documentation](http://www.ruby-doc.org/core-2.2.0/String.html#method-i-25) of the `%` method - it optionally accepts an array as an argument. &gt; Format—Uses str as a format specification, and returns the result of applying it to arg. If the format specification contains more than one substitution, then arg must be an Array or Hash containing the values to be substituted. See Kernel::sprintf for details of the format string. "%05d" % 123 #=&gt; "00123" "%-5s: %08x" % [ "ID", self.object_id ] #=&gt; "ID : 200e14d6" "foo = %{foo}" % { :foo =&gt; 'bar' } #=&gt; "foo = bar" 
Yeah, I agree :) The name also has to be "google-able" above all. Now that I know you are looking for a better name, I'm sure you'll come up with something better eventually, and that's not the most urgent thing anyway.
It's the scoping, I think. With refinements I can now append methods to the String-class without polluting all other Strings in existence. That means when you pull in my gem I won't touch your strings for your whole system, at least I thought that was the concept. 
Follow the link in the annoucement and find out. 
Is it trying to make fun of Python 3000? 
The next version would logically be JRuby 1.8 or 2.0, which would cause some pretty big confusion with MRI versions, hence 9000
&gt; I still don't understand how refinements are better than just having the method take a string and the other parameters and do it's thing. &gt; &gt; Syntax sugar alone? I do believe you are right about the syntactic sugar. But it's much nicer to hand a method one parameter, rather then two. With monkey patching and refinements you need one less parameter because you are working on an instance of self. If you were to have addition as just a method and not on/in an object it would look like +(1,2) and +("a","b"). Where as it's a lot nicer to implement the plus method within the Objects themselves to work with self and a paramater 1.+(2) and "a".+("b"). When you get into really long Object names then having those as added parameters for clarity is a bit excessive. So the syntactic sugar will get inherited into all Objects that are created from the monkey patched or refinement. Making things far easier on the eyes, easier to understand, and belonging to it's intended Object. Other than that it's simply a matter of perception and preference. Stand alone methods can easily get the job done without "polluting" Objects.
Doing a gets in an initializer means you can't even create an instance of the class without it pausing to get input from the terminal. Every single time you do Bear.new, it's going to pause and wait for input from the terminal (or at any rate, get input from STDIN somehow). It would be more flexible to make the actual class with logic for, say, a Bear, not be hard-coded to get input from certain places. You're still going to have to get input somehwere if you need input, and that `gets` is probably going to be in a method somewhere, cause it's ruby, everything is objects and methods -- but I wouldn't put it in an initializer. Having an object pause waiting for input every time you try to instantiate it is weird and is going to trip you up. I'd make a class to handle the terminal input maybe, and make it get input in a method called #get_name_of_bear or whatever, maybe. 
* Being able to package and deploy your app as a Jar or War or whatever. * Being able to make use of Java libraries in Ruby code. A project I recently did at work had me working with Asterisk. There aren't really any good Ruby Asterisk libraries and I don't have the time to write one, but asterisk-java is fantastic and I could make full use of it and integrate it in to a Sinatra project. It helps that we had existing Java code making use of asterisk-java and it was a piece of cake to port it over to Ruby. * Some shops won't let you install Ruby on a server or it might be a huge pain (like a Windows server or something). Using JRuby gets solves that issue. * I've heard there are performance improvements after the JVM has had time to "warm up", but our load is so low we don't notice it.
i appreciate that they went 9.0.0.0 instead of 9000. I can sell 9.0.0.0 to a suit, not 9000
Hey I can do this. Not for money but for fun. Let's do it. Teaching is the best way to learn ;) [It will take about atleast 3 weeks.]
Your suits are either stupid or insist on micro managing the version numbers of software you use. Either way quit the sinking ship.
That looks fairly useful... Shame I'm using something based on 1.9.2 to learn with. Refinements could save me a lot of headaches when I want to change program behaviors that get in the way of implementing new features.
JRuby doesn't have a GIL, so you get actual parallelism out of multiple threads.
True, this was just an example. Having blocking code in an initialize method is a bad idea. 
I agree with the sentiment, but realistically, it's ruby for the JVM. That's going to involve a lot of micromanaging suits by its very nature. 
Shoveling isn't appropriate here, you want a single hash, as that's what will serialize to the required JSON. What you want to do to the hash differs whether or not you've seen the word before. If you haven't, add key =&gt; 1 to the hash. If you have, increment the value for that key. If you haven't seen the word yet, hash[key].nil? will be true. I'll leave how to increment a value within the hash for you to do, but shoveling isn't part of it.
I can't think of any suit anywhere in the world coming up to the developers and saying "you can't use this piece of software because I don't like the version number". I have never heard of such a thing in my life and I have been to countless IT conferences and have talked literally thousands of developers and system administrators. The entire conjecture is absurd. 
That's what I meant. Thank you /u/jrochkind for providing the explanation! An alternative may be to provide a class method that creates a Bear from stdin, e.g. class Bear def initialize(name) @name = name end def self.create_from_input(in = $stdin) new(in.gets.chomp) end dnd
The cost savings were a big one for me. When I switched, EC2 instances with 1.7 GB RAM were the norm. A Ruby process running Rails would eat up 120 MB and a fork-based model I could realistically only push 20 concurrent requests. CoW has improved that somewhat these days. But with JRuby my incremental cost of handling a new request was substantially reduced because it's just a new thread. I saw a similar reduction switching from resque to Sidekiq. This meant I could service the same load with fewer servers. To my pleasant surprise, requests were also handled much faster a long-running JRuby process can optimize quite well. Once on the JVM, I found there was a lot to like there. The profiling and memory analysis tools are top notch. Being able to call into other JVM languages is quite nice. HotSpot can be tuned nicely for your workload. And so on. *Edit - In the interest of full disclosure, I do get paid by Oracle to work on JRuby these days, but I was a heavy JRuby use for my bootstrapped startup for years prior.*
What /u/arcticblue said, plus true parallelism on multiple cores. I have used JRuby on projects just for the parallelism, and think this is one of it's main draws for many. While I don't typically use Jruby for a Rails app, the multi-threaded concurrency, combined with Rails being perfectly comfortable with multi-threaded request dispatch in recent versions, means you can handle a lot more requests-per-second, with more even latency, deploying with JRuby on the same hardware (especially in the same RAM). My web apps typically aren't high traffic enough to require this -- the projects where I've used JRuby for it's parallelism myself typically aren't web apps. (rubinius also provides multi-core parallelism, but has the reputation of not being as mature/stable as Jruby. I don't know if thats true any longer, but many people go with JRuby because they know it's gonna work. I have no experience with rubinius myself.)
Could also be a tribute to Jim Wierich
&gt; Truffle/Graal is also so much more than a faster Ruby. We're working on new tooling such as a zero-overhead debugger, always on #set_trace_func, always on ObjectSpace, high performance interoperability with JavaScript and C, and a build of JRuby that doesn't depend on the JVM and starts in milliseconds. Very excited about the potential of all of this, that those things are among your goals. Startup time and debugging issues are two of the major annoyances with JRuby for many (including myself), that I recognize require something as major as Truffle/Graal architecture to address. Good C interoperability we mostly manage to do without, but it'd be huge in potential if it were there too. Thanks! 
Is it realistic to expect to run the same Ruby code on the MRI and JRuby (with comparable language version)?
$600 is not enough to result in a quality ruby guide. Nobody that could do a good job is going to do it for that price. There are already a bunch of ruby beginner guides available, some for free, at varying levels of quality, including some good ones. 
I would look at existing gems as a reference of how you might want your API to look. I think it's a useful learning exercise to build something from scratch - even if your doing a little copy and pasting. http_client is a nice abstraction on top of net http, so I'd definitely go with that. Good luck!
Nixed my original reply. Your comment history is just filled to the brim with intentionally abrasive asshole behavior. Please don't talk to me.
I would add that I've seen Rails apps on MRI easily hit 300-500mb per process, the amount of hardware you need for any amount of traffic is abysmal.
Yes, it is. Occasionally you run into edge cases and bugs, but in general that's a realistic expectation with the current versions of JRuby. Which is awesome! (One exception is if you have gems installed based on compiled C extensions. Avoid those for JRuby. Also, some gems provide alternate JRuby and MRI implementations, often to provide a JRuby implementation based on Java instead of a compiled C extension. In these cases, the gem itself can fail to provide identical implementations in the JRuby and C versions, but JRuby can't do much about that.). 
The trick is that with Jruby, one process is probably all you need, for quite large volumes. which is significant RAM savings over having to deploy multiple processes with GIL'd MRI, when the processes are so large. Although a JRuby process individually may actually be larger in RAM than an MRI process, it's still often huge net savings for similar performance. (And you're probably still going to get more deviation in latency with the MRI version, under heavy concurrent load, no matter how many processes you throw at it) But yeah, if that's still too much RAM for you, then Rails isn't for you. Everything's got trade offs. I'm curious how much RAM a Java app server (tomcat, jetty, whatever) typically takes for deploying a single complex heavy traffic web app using popular Java web app frameworks or patterns. Is it much smaller?
I'm a big fan of the [Her gem](https://github.com/remiprev/her) for consuming REST APIs
Looks great! So is it a [dessert wax or a floor topping](http://snltranscripts.jt.org/75/75ishimmer.phtml)?
Try RubyMotion although it doesn't allow you to skip learning actual Android development altogether. 
Again a post about caching in Rails that tightly couples your models with the cache. You should not so this. You don't want your model layer to be coupled to your caching layer. If you really want to cache you should use a edge cache (like cloudfront, for public pages/assets) or Russian Doll caching in your views. You say you don't want to compute anything twice, but you render the views each request, which is were you probably spend most time. All the touch_blah callbacks are also build into ActiveRecord by default, check the belongs_to: :touch option. This updates the parent model if a child model is updated. 
I like httparty. I wrote a gem that's an API wrapper using httparty, it's simple and straightforward. 
That was the solution until I understood what was happening. Naturally it was a less than ideal solution, however. We'd have to pay the cost of both the JVM and TorqueBox restarting. Since TorqueBox nodes were also Infinispan cache nodes, it could mean a bunch of data transferring as the container came back up. And we had to jump through some hoops in our deploy scripts to ensure live requests weren't dropped. Hot code reloading is where it's at.
Well that's vindicating. From a refactoring standpoint I run into more cases in which I need to convert singles to doubles than vice versa, so I tend to err on the side of doubles for convenience. Knowing that there isn't really a downside is a pleasant surprise. 
&gt; compiled C extensions What does it do with things like OpenSSL bindings? I can't imagine how the heck they could be implemented in Java with reasonable performance. 
I do not know the details, I'm not even sure precisely what "OpenSSL bindings" means, sorry! Surely you can do SSL in Java with reasonable performance, probably using Java stdlib? All of Java stdlib is of course available to JRuby, and I believe JRuby tends to implement the ruby stdlib with Java implementation. I have not heard anything about any SSL-related issues with JRuby, but I'm no expert there. The ordinary ruby stdlib is available in JRuby, provided by the JRuby runtime, and I haven't heard or experienced any performance complaints with it in general. 
Related: DOES it have a zero-downtime deployment option? Google points me at really old documents where people came up with their own solutions that look very hacky.
Memory use: JRuby uses more memory normally because it has a generational garbage collector. You'll see a base JRuby process using around 100MB of memory, but only about 20MB of that is actually occupied. This is the nature of generational GC...you need to give it room to perform well (and the JVM's GC is worlds better than any other Ruby impl). Performance: JRuby with or without invokedynamic is almost always faster than MRI. Usually if there's a performance issue, it's either a bug we'll fix or it's an external library that's slower than it should be. A good example is JRuby/JDBC support for ActiveRecord (activerecord-jdbc). Until recently, it had very little optimization work done, and was slower than regular ActiveRecord even though JRuby itself was much faster than MRI. InvokeDynamic hype: Granted. We were told the JVM's indy implementation would be better than it was. That's still in progress. However, we continue to support running in non-indy mode, and we're using it more effectively in JRuby 9000. It will continue to improve. Truffle/Graal hype: This is a research project being worked on largely by Oracle Labs-employed developers. It will take time to be production ready, if it ever gets there. We incorporated it in JRuby proper to provide a good playground for that research. Meanwhile, we'll work to do the same optimizations in the non-Truffle runtime and keep working with JVM authors to improve InvokeDynamic. EDIT: Startup time: Yep, it sucks. We have some possible futures here, like JVMs supporting ahead-of-time compilation, caching more of our runtime data structures to disk (compiled code, etc). It's not really our fault OR the JVM's fault...we're just living inside a world where EVERYTHING starts out interpreted: parser, compiler, core classes...EVERYTHING. Once the JVM optimizes that stuff, we can boot a new JRuby instance as fast as MRI, but until then it takes a while to get going. We are working very hard to provide the best possible Ruby implementation with the technologies available, and I think we're doing a pretty darn good job :-)
No worries, it looks like the link you've provided really answers it. Unfortunately that leaves jruby dead in the water for me.
Actually, I updated my message after you read it, after I did more research. Sorry, I have a bad habit of posting reddit messages and then continuing to edit them. There is OpenSSL for jruby. Really. Don't decide it's not going to work for you based on my misinformed comments, do some research or ask someone that actually knows what's up (not me, who is just googling). https://github.com/jruby/jruby-openssl
I think it already is stable? But cool. 
He mentioned that. &gt;(I'd also add, anecdotally, that apostrophes are more prevalent in strings than double quotes, which again means less thinking when using double-quoted strings.)
Yep, I think we're on the same page. I just meant that if I'm happy with the way my apps are running now, I'd rather not play around with testing against JRuby 1.7 if there's a new one coming shortly.
Thanks for responding, and yes I follow your entire series of blog posts on Truffle. It definitely is very exciting stuff, and you folks are doing a great job. As I said, I *really want to love JRuby*. Its architecturally far superior. I've used JRuby on two places (both Rails, very deep and cruddy, and one very recent) and it really didn't make a difference compared to MRI. Considering that Rails is quite a big part of the Ruby community, it usually is a bit disappointing after reading all the blog posts, benchmarks and everything, tweaking Rails (mostly switching gems and configuration) to run on JRuby, convincing people that this was all worth the switch, and then watching a rather flat performance graph on NewRelic even after the JVM has warmed up. And that's where some frustrations come from. I'll wait for the time when I can drop in JRuby to a normal, balanced workload and get tangible performance wins.