&gt; There probably were people worried about their career, Yes. I know a few from ruby who e. g. went into Go precisely because of job-related activities. &gt; other who actually don't know where the language is headed I consider this to be a moot point because they can GO AND GET INVOLVED. They can even suggest topics for developer meeting if they feel a need for it: https://bugs.ruby-lang.org/issues/15462 This one being the next one in a few days. And they can watch matz giving talks/presentations where he talks about the future in regards to ruby too. So, I am sorry but ... I disagree that this point is a big one. I do, however had, agree a lot that career-related requirements and goals play a huge role in decision making for many people. &gt; I doubt everyone replying to this post wanted to use a whip on ruby's dev team to &gt; make them produce more code I don't have a problem with the general thread - I commented exclusively too. I also do not necessarily disagree on all points, mind you. For example, I think due to various reasons, ruby has indeed lost a bit momentum. I have no problems myself and it does not affect me at all whatsever if random joe goes from ruby to e. g. Go or Rust or Dart. It does, however, affect a language indirectly to some extent; e. g. why you would not have them use ruby instead. And another effect may be when it comes to the influx of new people into ruby. But anyway, these are not all points made by the thread. Another one is the one to replace matz with a random committee consisting of people who were quoted by that single dude and who probably didn't want to be part of any such committee to begin with; or the fact that nobody knows IF any random committee would make ruby better. I highly doubt that anyway. Still, even with my criticism about that thread, and even though I disagree with many other statements made in general, I also can not deny that there is a little bit of inertia right now, at the least with the ecosystem. This isn't even entirely related to rails either. Before we jump to assumptions, it may well be better to systematically gather data/opinions made by real people e. g. something similar to the polls run by the nim language or so. That may be of some help here.
I don't think this is accurate. Ruby has large usage in the US across the board. The west coast and east coast are especially heavy users, and I'd worked on it in Missouri in the past as well. Making broad statements about the future of a language with "facts" that are at best anecdotal really aren't making compelling cases here. 
I am not sure it is burn out. Matz is extremely busy. There are only 24 hours in a day and so much you can do there. I also highly doubt that your comment is true. For example you write the " 3x3 but that much performance wont make Ruby what it once was." but how does that play a role for me, for example? I already was using ruby 1.8.x which then, by simple logic, was a lot slower, but I liked 1.8.x. Actually although I think ruby is great and I still use it a LOT these days, I did even like 1.8.x more than the ruby lateron. :) This is partially because 1.8.x sort of had things such as "we don't need to worry about encoding", perhaps also because I was younger and more enthusiastic in general (it's been like +15 years or so!). I have also become a lot more productive (excluding the time spent educating people on reddit of course) and systematic (to some extent; I hate writing documentation but it really has to be done ...). I just don't see how speed kicks in a lot here. Not that I am against speed-related improvements, mind you. Quite the opposite. I think it's cool. But I was already using ruby when it was slower, and it did not handicap me really. The JIT is cool though. Actually, what helps me the most are smaller improvements. Be able to write less code while achieving more, but not at the cost of readability. &gt; You wont find jobs in specific regions because Ruby already disappeared from those places. See, that is a specific requirement then. You use a language because of a job. Are you then using a language because it solves a need - or only using a language because you need to land a job and make a living? The latter group can use whatever random crap language exists. But even then I doubt that this is the case much at all, at the least not how it is commonly stated here. Because IF it were so universally true, why aren't there more COBOL hackers? People know it is a dead language and they don't want to start young, become a fossil hacker, and exit when they are old, not knowing anything really and only having wasted their life time with legacy languages. &gt; People are simply sad about losing Ruby that is the reality. What are you talking about? Who is "sad"? Are you sure that those that express being "sad" all are even using ruby? I am 100% sure that not all of them are using ruby or have been to begin with. It's just like with the folks who initially wrote "rewrite this in rust". MANY of those from the initial wave were just trolls who would not use rust (although some rust folks are also literally crazy; it's the only language where I have noticed that. Not even haskell has that problem, even though they are very elitist about Haskell).
No, you are lying here. I literally commented lots, so I remember without even having looked up. That part INCLUDED SUGGESTION A RANDOM COMMITTEE. And the whole premise was PRECISELY to replace/undermine matz. And I am sorry, when you write that this was not the case, you are simply lying. Please stop lying. &gt; I am just trying to provide more context No, you are not providing "more context". The original did not use the words "replace" as such but let's not be idiots here. When you mean a committee, you actually mean others to make decisions. We should be honest in evaluation here to admit that this is the case. By the way, even well aside from this, we have so far not seen a single example of where we can verify that a committee would be doing a better job. All I know is that "under new management" will ALWAYS change any given language. And I for sure don't have any reason to trust any random committee (and, by the way, the people who were named as examples have not even made that suggestion - I think if anyone proposes something like this, YOU SHOULD FIRST ASK THE PEOPLE YOU QUOTE WHETHER THEY ARE EVEN FINE WITH YOUR IDEA AT ALL. I find it incredibly unfair to randomly and sneakily insert random folks into a "listing" of any committee. You can well critisize ruby without proposing a committee by the way. But when I do see people sitting on the fence, not partaking much at all at the bug tracker or anywhere then ... sorry, I just lose it. It's so much easier in the peanut gallery then going to try to reason your case. It's not a lot of fun when your ideas are not met with approval by others, I get that; I've been there too. But that is one part of quality control and not every idea is as good as any other idea either. Some proposals come with trade offs. People tend to highlight only the benefits but rarely talk about the disadvantages. That's human nature too. You need to include the disadvantages too, before evaluating.)
You also suggested a committee. By the way, I should also say that I think it's perfectly fine of you to ask others about opinions. I always said that I do not necessarily disagree with all your points either. As for matz, I think you need to keep in mind that designing a language can be fun but it can be frustrating too. Guido is a good example. I don't think matz took it personal by the way but I don't know him very well and I don't know the japanese culture that well either (I still assume they have ninja and samurai running around in reallife but evidently this is not the case so).
It's a bit difficult to "clone" people. I also think different projects are hard to compare, not only because of a different personality but different scope. For example, the linux kernel has a quite different scope than does ruby as a programming language. I depend on both the linux kernel and ruby; for linux, obviously, I could omit ruby and just use the kernel. But I like ruby a lot more than the kernel, for several reasons (not that I dislike the kernel ... but the exposure I have is primarily through ruby).
No, Ruby 1.8 has an ISO spec. The RubySpec project maintainer was very abrasive and not really willing to work with the CRuby team or the JRuby team which was a loss for everyone.
You are still training your trolloll powers bro. Do also note that japanese folks often communicate via kanji in other non-english sites. It's partially a culture-phenomenon, partially struggling with the english language, and VERY MUCH a question of time. It's much more productive to work on ruby than to communicate with tracychavez. Sorry bro.
Dude, you sound as if you have some random vendetta for no apparent reason. I can't even understand it.
&gt; But these responses - if actually responses, it's not even &gt; clear - shut out any kind of openness around the process It's very clear. And ruby is very open too. Please base your claims on facts rather than fiction. If you have specific proposals for ruby, link them in at: https://bugs.ruby-lang.org/issues/15462
I don't see any of this being correct. I think you need to get back on topic rather than on your assumptions about written text. I don't see where you pick the word "ruining"?
I am not even sure he is employed at all - his comments are all so ... random. To me it seems as if he is not even using ruby. There are some people like that on reddit, also on IRC. Not real people who use a language.
do you have any numbers of how many companies are involved with ruby? also there is any ruby foundation where normal folks can contribute monthly, or even companies?
&gt; I don't see where you pick the word "ruining"? Last line of the last tweet: "Don't ruin our lives". He really needs a vacation, and to think about his processes, planning, and delegation.
It write stuff in erlang, I don’t see your point to be fair. Erlang is perfectly fine language it just doesn’t have thing like rubygems. What made ruby big was rails and rubygems. With experience in ruby, erlang and go I can say that having solid stdlib and “gems” to use is a massive advantage. Ruby without rails, Capistrano, rubygems, bundles would be just another language like lua, monkey or scheme etc... 
While that is good and deserves an upvote, I should like to point out that ultimately, there should be only one central reference for documentation. I know that things are a bit chaotic but still. Props for the effort by the way. PS: I'd think it also fit for "more than one way" to have multiple documentation, as long as they are up to date. My personal favourite is still Chris Pine "Learn to program"; I liked that more than the old _why poignant guide with the foxes, but admittedly it would have required a huge update and inclusion of more topics. 
It is not "one another reference, just because I can". It is the only one reference currently existing to cover entire language in its current state. I plan to propose it (or rather work based on it, as a prototype) as a main language reference. Neither _why's guide nor "Learn to program" couldn't be considered a "language reference" by any means. The last thing that we had close to "reference" that I aware of, was PragProg's "Programming Ruby", with the last book version is still paid and covers Ruby 1.9 with elements of 2.0, the last [publicly available](http://ruby-doc.com/docs/ProgrammingRuby/) covers version 1.6, for Kernel's sake.
&gt; installing and configuring Ruby was a bit of a PITA and managing multiple versions was just a headache No need to sugar-coat how painful that world was, especially to ops.
Oh cmon just because your tiny bubble exists in a vacuum does not mean the situation is the same everywhere in the world. The usage of Ruby is decreasing, every index under the sun shows this. An anecdotal evidence is enough if in my region there's many more jobs for the standard big 4 langs and none for Ruby. And it shows. 
"Ruby has large usage in the US" and "Ruby already disappeared from (some) places" aren't mutually exclusive, in fact :) I can confirm the _feeling_ of lessen Ruby usage at least for Ukraine (there are still a lot of -- mainly outsourcers -- using it, but much fewer juniors and generally it is super-hard to find a decent Rubyist, because there is just less of them), Israel (part of my company is there), some of Europe (more second-hand information, but those hands are reliable). If you'll check https://rubyconferences.org/ for conference discontinuing dynamics, it also seems to be a trend there (some new conferences in "cheaper" East Europe and Asia, a lot of dead ones on West/North Europe and the US). So, while not saying "we'll all die (this year)", I believe the trend is pretty visible.
&gt;I also highly doubt that your comment is true. For example you write the " 3x3 but that much performance wont make Ruby what it once was." but how does that play a role for me, for example? I already was using ruby 1.8.x which then, by simple logic, was a lot slower, but I liked 1.8.x. Actually although I think ruby is great and I still use it a LOT these days, I did even like 1.8.x more than the ruby lateron. :) So you are not the target audience ? You can write complex software in bash for all I care. &gt;I just don't see how speed kicks in a lot here. Not that I am against speed-related improvements, mind you. Quite the opposite. I think it's cool. But I was already using ruby when it was slower, and it did not handicap me really. The JIT is cool though. Because you want to do more performance intensive tasks? &gt;See, that is a specific requirement then. You use a language because of a job. Are you then using a language because it solves a need - or only using a language because you need to land a job and make a living? The latter group can use whatever random crap language exists. But even then I doubt that this is the case much at all, at the least not how it is commonly stated here. Because IF it were so universally true, why aren't there more COBOL hackers? People know it is a dead language and they don't want to start young, become a fossil hacker, and exit when they are old, not knowing anything really and only having wasted their life time with legacy languages. You are either self employed or have a say in your company. You use a language because it's the tool you like and you want to keep solving issues with that technology. &gt;What are you talking about? Who is "sad"? Are you sure that those that express being "sad" all are even using ruby? I am 100% sure that not all of them are using ruby or have been to begin with. It's just like with the folks who initially wrote "rewrite this in rust". MANY of those from the initial wave were just trolls who would not use rust (although some rust folks are also literally crazy; it's the only language where I have noticed that. Not even haskell has that problem, even though they are very elitist about Haskell). People that wrote in Ruby and had to switch to other langs unwillingly are sad. 
Ruby has more jobs than PHP in the U.S, at least that's what my linkedin is showing me. I get 31K results for Ruby and 24K for PHP. You are welcome to test this yourself and see if you get different results. And java has x4 as many jobs as Ruby. Being 4:1 with java is quite fine I think, that's definitely not the sign of a dying language (considering java is the most popular language in the world). What index are you talking about? I think we better stick to career indexes since Tiobe and friends are highly unreliable. Also we care about our ability to get a job not about how many people look for a language on google.
I agree. I think that it really should have been implemented like ActiveJob, where you could choose the backend worker, but in this case the editor. Though, looking at the source, I don't think that it would be overly difficult for this kind of extraction, so it may be something that is considered down the road.
I feel your pain, I'm based in the Netherlands and Ruby is just not that big in continental Europe (I'm mostly thinking Germany, France, Netherlands). However in London, Ireland and North America (both U.S and Canada) the amount of Ruby jobs is very solid. I see a strong correlation between the size of the startup industry in a country (amount of VC) and how likely you are to find a solid Ruby market. The US is drowning in VC money and has thousands of Ruby startups. Germany? Not so much. Netherlands? Likewise, a lot of the tech jobs there are enterprisy and enterprises never choose Ruby. They would use PHP before they used Ruby. That said, if you are a decent developer you could still find a high paying, quality job writing Europe in the Netherlands, Israel and probably Ukraine as well.
Before bundler is the key. People used rvm "gemsets" to do what they couldn't do before bundler. 
The US not the center of the world. Look at job postings for Ruby in Europe and/or in Asia. Ruby is declining in places like Singapore, was not really strong in Central Europe in the first place. It's probably okay in London. That's what I meant by regional while languages like JavaScript,Java,C#,Python are "global".
&gt; I see a strong correlation between the size of the startup industry in a country (amount of VC) and how likely you are to find a solid Ruby market. Yeah, this seems true to me too. There is a nasty side-effect, for what I know: startups are typically tough on resources (at least initially), so they can't allow themselves to hire juniors (young folk, or switchers), so in this circumstances, the market which never was THAT friendly to beginners becomes even less so. &gt; That said, if you are a decent developer you could still find a high paying, quality job writing Europe in the Netherlands, Israel and probably Ukraine as well. Yeah, there is absolutely no problem for (mid/senior) Rubyist to find a job in Ukraine currently, demand (for experienced only!) developers is pretty high. But, for example, talking about Israel, for all I know the job market for Rubyists became pretty small recently, and it was the result of the same processes: demand for professionals higher than offer, nobody wants juniors, so companies switch to another tech (unable to find enough resource) and "the next startup" is advised against Ruby because "it is hard to find them". I expect to see the same processes here in UA (after my company, like, tried for half a year to find ONE decent Rubyist in the very capital of the country, with seemingly hundreds of them around, judging by forums and meetups).
&gt;they're very condescending No, they're remarkably patient.
I happen to be from Israel, now live in the Netherlands :) . There are a few famous Ruby shops in Israel - first and foremost is Fiverr. The thing with Israel is much of the tech industry is based on tech people that finished military service in some computer unit and than ran off to start a startup, so they use whatever they used in the military for their startup. That's why .net and java are huge in Israel. Even still, a Ruby developer in Tel Aviv area should have no problems getting a job (well, I left 1.5 years ago, but how much could things have changed?). Did you consider relocating to somewhere with a bigger tech scene btw?
The US is still the most important economy and by far the most important job industry, for good and bad. Ruby seems to be doing well in Japan, which isn't surprising considering it's from Japan. Singapore is a very sucessful country but it's tiny. But anyway, should you really care what's going on in India or Indonesia? I think you should care about where you live or are planning to live. If anything, if Ruby isn't picked up by a Billion Indian programmers that's probably good for future me, not bad.
I'm glad you managed to make it working! Just being curious what changes did you had to make?
The benefit is twofold. For one, if you're paying a dev to work on Ruby core, you can influence what they work on, and ultimately the language itself. Need a feature? Get your guy on it. Are they adding a feature and you don't agree with it? You've got a respected contributor in your corner who understands where you're coming from. Also, it gets your company's name out there at industry conferences and stuff, which let's you attract more/better talent. Wouldn't you want to work for a company that supports open source?
No you can’t ! You can suggest something would be good idea but so can you. Matz and any respectable person will not agree to money push project in one or another way. 
I wasn't really comparing Ruby and Linux. They are just the first two projects that come to my mind when I think "large project run by a single person who if was hit by a bus tomorrow we would be in a world of hurt". Beyond that, I agree, any comparison is spurious at best. Happy not Monday any more!
Eh. I found compiling Ruby much easier than Perl. But generally speaking once you worked it out, it didn't change much from version to version. I was _trying_ (though not sure I succeeded) to give an unbiased recounting of events...
This isn't some nefarious thing, every open source language you use is paid for by companies. It's how the world works. Think of this scenario. You love Ruby and think it's great, but your application is being bottlenecked because Ruby isn't particularly performant. What do you do? Well, you could switch to Go but that's expensive. You could try to convince Matz but he's obviously very busy. Or you could hire someone to work on measuring and improving Ruby's performance full time. Not only does your company now benefit, but the whole community does. It's a win/win.
&gt; Did you consider relocating to somewhere with a bigger tech scene btw? Me myself in Ukraine currently (and kinda patriot of my country, however naive it could sound in 2019), and working remotely, so I am good with job offers :) But looking into future, I probably rather move from the language (Ruby), despite all my warm feelings towards it, than run around the world chasing the squeezing job market. 
I like Matz but not sure how this answers what he is referring to. To my recollection no one talked of a fork. So some guy tried by himself to fork Ruby and failed (of course with no community). Anyone rational person can see Ruby is falling behind and falling out of usage. So why not take this in a more positive manner - people love ruby and want to keep using it? They want it to thrive and take back up mindshare (which builds community resources etc). I find the response short sighted and not very deep. 
&gt;Ruby has more jobs than PHP in the U.S, at least that's what my linkedin is showing me. I think you are missing a key fact of life in using linkedin like that. If you find it hard to fill a position you run job ads and they stay up longer. Open positions can tell you more than one thing.
&gt;Matz made ruby. Matz still makes Ruby. If he wants a consortium of Ruby developers then he will build one. If you want to speed up his development of Ruby, then make him spend less time advocating for why he's doing what he's doing...and let him build Ruby. which all is just code word for - community shut up if we don't like what you are saying. Thats the kiss of death for a community and then all you have left is groupies. Matz isn't required to advocate for anything. He need not respond. this is just reddit . Its not a core dev meeting. &amp;#x200B;
&gt; Actually, I explicitly asked what people think of situation and what ideas they have. believe me theres a great many people who know where you were coming from and know this thread does NOT represent the spirit of what you said but fanboys also love being groupies so they are going to pile on for brownie points since they see matz's name (who probably got a distorted picture from one of them in the first place).
 &gt;That part INCLUDED SUGGESTION A RANDOM COMMITTEE. And the whole premise was PRECISELY to replace/undermine matz. And I am sorry, when you write that this was not the case, you are simply lying. &gt; &gt;Please stop lying. Thats a **bare faced lie**. I was in the same threads and thats not what i got from him at all. in fact he clarified himself quite well in that thread &gt; P.P.S. Oh, and by the way, I hate democracy. This is why I don't think all decisions should be made by voting or that the "group" should replace main designer (Matz). I just think that they can really help him. SO the only one lying in this thread is you. its fanboys like you that will help weaken the community further. You are emotionally hurt so fabricating all kinds of motivations that are entirely false.
I don't think it's shallow to post this in response to his reasoned response to a rather critical ruby post of him. My post had nothing to do with the language, or it's expectations. It was a reminder that his response to a somewhat whiney post (admitted to by the OP) was nice and that he sets the tone for how the ruby community should act. Dragging a simple "hey isn't this cool" post back to "yeah but what I want from the language is..." wasn't my point. 
Yes that was over the top - surely Matz knows enough English (or his translator is not so poor) he knows what that means. If a reddit post destroys lives then there can be no real independent community people in this thread are in full fanboy groupie mode so there will be no rational discourse. This is another down side to one person driven languages besides the resource issue companies give. Its not that the one person is the problem its that young ditto heads develop an almost cult like approach to those leaders. nothing sends hem into orgasms of joy more than touting the brilliance and righteousness of the leader against his enemies -even when there were no enemies.
&gt; If people are willing to invest in Elixir (which has 600ish job posting in the entire US) it's quite amazing to me people here say Ruby is dying "Language X has Y users" and "Language X has Y users (Z times less than a year ago)" are two different statements. It is acceleration, not speed, that matters. &gt; BTW lack of developers and difficulties hiring could be a good thing as well, it can push salaries up and make it easier for you to get a job. (Yeah, Fortran devs are the richest ones, everybody knows that.) We are here mostly discussing if there is a downward trend in Ruby usage (it is, and it is obvious), and if "slow" language progress is responsible for that (I doubt it, but there are different opinions). "Even if Ruby is dying, we'll be OK" is kinda orthogonal to these questions :)
Everyone plays with different ideas. I'm a senior ruby dev but I readily admit the shortfalls of the language and find others that fill that void. Currently it's erlang, Elixir, and Haskell but who knows what it will be in a year from now. It's a polyglot world. I think the more time one spends programming, the more one realizes there is no silver bullet for all the problems. 
Right, and it's worth noting that RVM also predated Bundler and provided a solution for separating gems between Ruby projects on the same machine via *gemsets*. Part of the reason rbenv was able to be slim in comparison is because by then Bundler had come out so rbenv could punt on gem management and say "just use Bundler."
I work for Heroku. While it's true we have a lot of Ruby users and we benefit from paying for continued Ruby development, I think that's a good thing. If we weren't invested in the community then our funding would likely not have lasted this long. I think of it as a mutually beneficial arrangement. Though obviously, I'm a bit biased ;) 
Hah, of course HN was involved.
&gt;at wrote in Ruby and had to switch to other langs unwillingly are sad. Plenty of us - Shevegen lives in make believe world. the web is full of developers posting their stories of why they moved on. When i found Ruby I thought I had found home for life . fast forward to present day withclients and projects that REQUIRE performance and I had to go buy another home.
There's a trade off with centralizing things. For example, if Oracle has a really bad year, the entirety of Truffle could be in jeopardy. By being somewhat de-centralized it makes that fate less likely. The other benefit is that different companies bring different goals and perspectives to the table. Cookpad sees different pains on a day-to-day basis than Treasure Data. By giving core contributors access to a breadth of development needs and pains it can lead to producing a more holistic product. There is a lot of work being done in different areas. Koichi has spent the last few years working on guilds (concurrency model). Mame is working on a proposal for pattern matching. These things are being developed and invested in, but they're largely out of sight and out of mind. I think if you know any company that has resources and wants to hire full time Ruby core, there could be room for collaboration. That being said, at one point IBM re-wrote the VM and essentially opened a PR. It was rejected because no one on Ruby core could work with it. If they had instead worked hand-in-hand with ruby core from the beginning there might have been a different outcome.
&gt; speed up the process without losing quality That's.... not how processes work. Or quality.
&gt; Anyone rational person can see Ruby is falling behind and falling out of usage. Have you been to a Ruby or RailsConf recently? Sold out every year, and usually about 50% first-time attendees. Companies lining the walls hiring devs. Just because it's not on hacker news doesn't mean it's dead or dying. FWIW stability, speed, and consistency are features. Matz did a talk about keyword args at Keep Ruby Weird and it shows how even a feature that is so fully "baked" still has some design flaws. It takes longer to get things right the first time, but if you put in that extra effort then you don't have to deal with the consequences. &gt; I like Matz but not sure how this answers what he is referring to. To my recollection no one talked of a fork. It's a parable. Basically, complaining is easy, but doing what you want is hard. There's not literally someone forking Ruby. &gt; So why not take this in a more positive manner - people love ruby and want to keep using it Or, if you love a programing language, how about you take it in a positive manner: express your love and ask how you can help instead of trashing it. &gt; ather than take it as just criticism with no use - he could have taken it as an opportunity to ask for more help and support He's asking for moral support, patience, and understanding. That was my interpretation of this thread. &gt; there may well be a time when no one "criticizes" anymore - because not enough people care anymore. I guess that will be nirvana The issue is subtle. It's the difference between a "criticism" (negative) and a critique (positive). If you're criticizing something you're tearing it down, you're not taking context into account and you're not being empathetic. If you're critiquing then you can still raise valid points, but put them in a context that is helpful to the receiver. One thing I do before giving feedback is to ask "can I give you feedback"? It's simple but effective. That's not always possible with public figures like this though. If you want to give feedback about a specific thing, make it about you and make it specific. Instead of "ruby development is too slow", share specific pain points. Maybe it's "I need pattern matching to do X" or "lots of languages have Y and my life would be better if Ruby had it too because of Z". If you're not delivering your feedback in a way that can be accepted by the person you're delivering it to, then it's not feedback...it's a no-value-add-complaint. It's not Ruby core's job to be a punching bag. 
I do also want to mention on /u/Nondv's suggestion of using a committee. That's exactly what Python did, and Python still lost Guido. I want to re-emphasize my main criticism to /u/Nondv which is that before we can suggest fixes, we all have to be on the same page to understand the goals and the problems. 
The thing is "ruby development is too slow" camp are complaining due to a lack of new features. Ruby has been focused on performance and stability and consistency for the past few years. It's had a good 5-10% bump with each major release year over year. It would be great if we could pour gasoline on the optimizations, but that would certainly require more resources. That's not a "ruby development moves too slow" problem, but simply a resource issue. It can be solved by hiring full time devs to help out. As an aside, the fact that MJIT was shipped by essentially one person is pretty astounding. 
2019 is the year of the patriots I think, at least in the US :) I think language, family and friends are underrated. That said, I decided to relocate...
&gt; Just because it's not on hacker news doesn't mean it's dead or dying. That's interesting (I agree with the rest of your comment, but just curious about this one). Do you believe there is no downward trend in Ruby usage? Or do you believe it is not "downward towards zero" but "downward towards some constant (healthy and rich userbase)"? Or is it downward, but so slow it can be safely ignored for years into the future? (I am asking exactly this, no hidden meaning or implied sub-questions, just curiosity.)
I don't think it's orthogonal, people don't care about language popularity contests but about whether their career is safe. Anyway I agree there is a downward trend, but how bad? Is it really affecting jobs? I think we better be more factual about the whole thing.
&gt; I find your claim hilarious considering there is an ISO spec. Uhhh, did you try google? From the https://www.iso.org/standard/59579.html: &gt; ISO/IEC 30170:2012 specifies the syntax and semantics of the computer programming language Ruby, and the requirements for conforming Ruby processors, strictly conforming Ruby programs, and conforming Ruby programs. &gt; We have to keep in mind that e. g. prior to rubinius being started, there just was no real need to any spec since Didn't JRuby pre-date rubinius? Also the rubinius "spec" was really the test suite for rubinius. While it could have been a generally good thing, it was used as a political tool to try to get MRI to change behavior. 
The tone and vibe of Ruby adoption have changed significantly but it's still there. I think the community is still growing, at a slower rate than before for sure, but still growing. I would say that it's upward, but no longer hockey-stick shaped. 
Honestly, as a long-term language lover, I don't care that much for jobs as for "something interesting happening". Less usage, less users, less "I am not a Rubyist, but interested to try" users, more "seasoned", "we-saw-everything-let's-just-build-another-web-app" devs =&gt; less interesting stuff. Though from my perspective, it is a long-lost battle, Ruby IS already stuck comfortably in a "PHP of 2010th" niche. So...
I care
The OP that Matz was replying to explicitly proposed replacing Matz with a committee or with someone else. Since Matz would never voluntarily step down (left unsaid here, but it's a corollary), that's a de facto fork.
Wrong and quite obvious wrong because you never read the thread before starting this reactionary hit back thread.. If that was how it was represented to Matz its no wonder he responded like that. Was that you? with that lie? Read what the Op of that thread wrote &gt; P.P.S. Oh, and by the way, I hate democracy. This is why I don't think all decisions should be made by voting or that the "group" should replace main designer (Matz). I just think that they can really help him. This is why fanboyism is so poisoning to a community. It demonizes any contructive criticism in favor of groupie think.
No i did not. Good to know!
&gt; I think we need some Ruby Consortium that will include some people with some authority in ruby community (for example, Bozhidar Batsov (disclaimer: this is just an example from my head. I don't even think that he'd agree with me on the topic)) and they can take some design decisions off Matz' shoulders. Just via voting. ?
Funny. From my understanding and talks with others + what you are saying, it is either of two: * It is shrinking everywhere but US (and maybe Japan) * It is shrinking everywhere, but US's huge market still masks it Thinking about where my feelings are coming from, I probably don't have this much "data points" (not much, but): * fewer conferences/meetups (well, I am aware that I am talking with one of the most prominent conferences organizer... and IIRC, the last year was the last?..) * fewer junior mentees (I mentor people from the very beginning as a side-job) * wast deficit on a job market for experienced Rubyists (because "pragmatic" ones, mostly middles with not much skin in a game, switch) * very narrow "outside" reputation -- "Ruby is like PHP, but nicer, you can quickly build a modern site/prototype/service in it" -- which is a thick membrane for ideas and people movement IDK, most of it could be read as "subjective" (but considering number of people in this thread with this feeling...) And I myself was denying any "dying" for as long as I could, hoping for some new and shiny grounds.
&gt;The thing is "ruby development is too slow" camp are complaining due to a lack of new features. Read closer. they are talking about all the issues. features and performance. Honestly that thread would not have existed if Jit had come out with solid improvements (which again is why I would have been happy to skip the meaningless christmas tradition and have the update in march - not me saying what should happen - jsut stating my preference). Like I said though the christmas release tradition and what came out was just a catalyst not the whole issue. &gt;Ruby has been focused on performance and stability and consistency for the past few years. It's had a good 5-10% bump with each major release year over year. Good night. You must be working on legacy software or your own software in your bedroom . You are actually citing 5% increase as noteworthy? &gt;It would be great if we could pour gasoline on the optimizations, but that would certainly require more resources. That's not a "ruby development moves too slow" problem, but simply a resource issue. It can be solved by hiring full time devs to help out. and that won't happen by people such as yourself that say it should stay as it is . Its the people pushing for ruby to be more tht would be the people to inspire investment.
I've used Arbre in active admin before, and looking through it this seems a little more lightweight. 
I'm just going to key in on one subject as we have covered all the others before. &gt;If you want to give feedback about a specific thing, make it about you and make it specific. Instead of "ruby development is too slow", share specific pain points. Maybe it's "I need pattern matching to do X" or "lots of languages have Y and my life would be better if Ruby had it too because of Z". &gt;If you're not delivering your feedback in a way that can be accepted by the person you're delivering it to, then it's not feedback...it's a no-value-add-complaint. It's not Ruby core's job to be a punching bag. all of that is just begging for censorship . this is reddit. You don't get to tell people what they can say or write and if the mods here try to enforce that then it will lead to no good. The point is just dumb. it violates the nature of open source. if you want Open source where people are not allowed to write their criticisms even on third party community sites without labelling it as complaints and trying to sensor it or bully people not to speak then it would be time to get out of the open source game and if ruby core really were to think that a constructive criticism (Not defined by whether its accepted or not because thats not the criteria) is making them a punching bag then it would be sadder than I thought. Seriously on their own suport sites or github one thing - but post a criticism on reddit and you feel beat up on and a punching bag and life is destroyed thats not grown up stuff.
what part of the clarification wen over your head? &gt; P.P.S. Oh, and by the way, I hate democracy. This is why I don't think all decisions should be made by voting or that the "group" should replace main designer (Matz). I just think that they can really help him. meanwhile - take some decisions does not in any dictionary equal replace or a call for Matz to step down. Get over it. You lied about what the Op stated. You probably don't care but you did he Op of that thread a great disservice in lying about what he was suggesting.
&gt; TL;DR people criticize RVM, Wayne Seguin quits Ruby(creator of RVM). Quits RVM, you mean.
I've heard it both ways. 
Does it _not_ make a Gemfile.lock when you do it this way? So no repeatable dependency tree?
Side note: You guys should buy Nanobox and offer it as an open source alternative with some tie-ins back to Heroku. It's been great as it has a lot less cost overhead and we've been using it with Linode with some great success. We'd used Heroku for some time, but just was never happy with the pricing.
All polls or data points have some subjectivity to it but I don't recall people objecting to tiobe when Ruby was up there [https://www.tiobe.com/tiobe-index/](https://www.tiobe.com/tiobe-index/)
Oh, well, by chance I know how TIOBE works (well, it is public information, but some time ago I've been and journalist and talked with maintainer to make sure it is really that naive, and yes it is), so it is just too easy target to fight. Yes, most of programming language communities are (moderately) happy going up, and (somewhat) unhappy going down, but this is mostly "number of angels on a tip of a pin" (just look at the rest of index, and try to interpret positions of Delphi, VB.Net, olde VB, Perl and so on). 
It should be noted that Ruby 2.2 is no longer maintained, which is why Bundler dropped support.
In my imagination matz should be above such committee. However, you made a right point. Thank you
yes but theres no measure I can think of that indicates ruby is going up so I don't doubt the slide ruby is showing on tiobe.
Don't pretend that you don't see a tendency of ruby losing popularity. Even in stupidest comparison Go vs Ruby go is getting more and more people. Partially it's because interpreted language performance is not enough now days but it is still a tendency. Time will show if it is just a hype or not. Python is winning more and more with every year. Just think about ruby jobs/python jobs relation in last couple of years. I am happy for you if ruby is still enough for you. Same goes for me. It is still enough. But I want ruby to be my language in the next 5 years. I don't want to switch (at least completely). This is what I am afraid of. It's not about your personal needs, it's about business (sadly)
No it doesn't, it uses whatever version is installed at the system level unless it's incompatible with the version spec. This isn't something you should use if you're terribly concerned with transient dependency versions and you should pretty much also specify an exact version for top level dependencies. Its primary use is in one off single file scripts that may need some gems, e.g. shell script replacement scenarios. 
I really can't tell if this is a serious post or a troll... you oscillate wildly between cogent and wildly inaccurate points in the same sentence. I'm going to give you the benefit of the doubt and go with the former... hopefully you won't make me regret it... :) &gt; &gt; It was truly revolutionary because at the time installing and configuring Ruby was a bit of a PITA and managing multiple versions was just a headache. &gt; No, sorry. &gt; Managing multiple versions is TRIVIAL. This is a rather bold statement. There are two things to point out here. First, the comment that you quoted was made in the context of the 2011 Ruby ecosystem when it was less about "compiling Ruby" (which as I also pointed out was a bit of a pain since there are quite a few options) and more about managing the environment. Again, as jrochkind points out, back in 2011 there was no `bundler` so everything was done with Gemsets which were... better than trying to compile Perl modules, but not by much. Second, as you seem to be responding to my comment about 2011 in the context of the Ruby ecosystem in 2019, and while I would agree that things have gotten much better overall, it's still hardly "trivial", especially at scale. Anyway, moving on... &gt; I understand that GoboLinux isn't known by many people these days, also due to loss of momentum, but I use a similar variant on my system. GoboLinux is really kind of irrelevant to this discussion... Gobo was interesting because it turned the idea of the Filesystem Hierarchy Standard on its head, but, as with anything there are tradeoffs. The _reason_ Gobo has largely been abandoned is that developers and admins realized that if you just stick anything anywhere, it's really easy to cause breakage. If you like Gobo, you should check out [Habitat](https://www.habitat.sh/), Habitat is (among other things) a new way to package and distribute software such that you always get the same dependencies as the package was built against. It stores everything under the `/hab` directory, and runs almost platform independently. &gt; I just change a single symlink and have that version work just fine. Linux can work this way. But again, back in 2011, we didn't have `bundler`, so there was more to it than that (e.g.: environment variables) &gt; I think RVM but also rbenv are just pointless. You are certainly entitled to and alone in your opinion. I could pound in a nail with my forehead... does that make make hammers pointless? (ok, a ball peen hammer is _point_ less, because the pointy end is rounded...) &gt; I understand that if you are locked down in using a specific distribution then indeed, you are a prisoner of this system and have to adhere to it. Huh? (It's statements like this that make me thing this is a troll comment BTW) &gt; But that is the beauty with linux + ruby - you can literally change EVERYTHING. And manage the whole system having any version you want to. Right? And `RVM` and `rbenv` help automate this process. Yes, I _CAN_ do everything by hand. But why would I? I'd _much_ rather spend my time writing Ruby than configuring and compiling a new Ruby... We have Chef recipes that we tell "install version Ruby 2.5.2 and my very special app", I kick off the job, walk away for 10 minutes and come back to a fully functioning app. Sure, I _could_ spend hours doing it all by hand, likely make mistakes, and have literally no bragging rights because my colleague was able to do 10x the work... &gt; I will never understand why people are stuck in their box and thinking that rvm or rbenv are important. Just because something isn't important to you or you fail to see the importance to others, does not make a tool unimportant. That is a very narrow world view. &gt; Both should not exist. It's a similar battle between vim and emacs. Ok, so Ruby tools shouldn't exist. Text editors shouldn't exist. Anything else? Shells, should shells not exist? Fuck Bash, fuck ZSH, fuck Fish, you should be making changes with a magnet and a needle you plebs! I mean, linux is completely pointless, people are going to do things _DIFFERENTLY_! &gt; I could never go back to use a FHS-limited system as such that does not give me easy control over all programs It's not the filesystem that's the problem... this is a spurious argument. &gt; at all times, Linux gives you this... (as does UNIX) &gt; without depending on crippled package managers Ok? So don't use the package manager. Quoting _YOU_: &gt; But that is the beauty with linux ... you can literally change EVERYTHING &gt; see debian modifying packages, like removing mkmf from ruby by default There's actually some fairly valid reasoning around this... &gt; yes you can uncripple it but remember that you have to uncripple the whole system, in order to use it Ah yes, because `yum install ruby-2.5-devel` or `apt install ruby-2.5-dev` is so hard... that will probably take me whole minutes to uncripple my system. I'd much rather spend hours building packages from source. (Although, I really do like the ports system in FreeBSD) &gt; Debian is such a heavily overrated distribution. Ok? I mean, if you were to say that about Ubuntu, I _might_ agree with you... literally no one is talking about Debian these days as Ubuntu is stealing all the spotlight. I'm a Fedora/CentOS/RHEL fan personally, but that's largely because I have 10+ years working in the RedHat ecosystem. &gt; If people want to REALLY learn something they should learn from LFS/BLFS because that project is really a wonderful one. And they could need more maintainers too. This is probably the only thing I agree with you on in your post. LFS really is an awesome project. Generally I have my new guys/interns build Arch and depending on how they do there, have them build LFS. That said, what does that have to do with any of the rest of your post? My initial comment was about the drama that happened around RVM almost a decade ago (I even came across a comment from svargo when he was still teaching at Carnegie Mellon). So there you have it. There was a lot to unpack there and after typing all this out I'm fairly certain I just got trolled, but perhaps someone else will find my comment useful.
&gt; You must be working on legacy software or your own software in your bedroom . You are actually citing 5% increase as noteworthy? Do you even know who are talking to? u/schneems has done more for the ruby and rails community than 99% of the people on this sub combined. Including and especially for performance and stability. I literally pulled out my phone to look up my login credentials and logged in to reddit just to respond to your comment. Thank you u/schneems for all you have done for our community and the language we love. Please ignore the keyboard warriors.
&gt; no measure I can think of that indicates ruby is going up Now THAT's a measure :)
I'm pretty confused by your post, what does not liking the Java language have to with not _using_ Truffle? I guess I could understand not wanting to work on Truffle because of Java but I can't understand not using it because of Java. 
&gt; You don't get to tell people what they can say or write and if the mods here try to enforce that then it will lead to no good. I'm a mod 😘 &gt; thats not grown up stuff. If communicating effectively and working together as a community towards common goals isn't "grown up" then 🤷‍♀️ 
Thanks for the assist. I did want to respond to something /u/Mike_Enders said &gt; Good night. You must be working on legacy software or your own software in your bedroom . You are actually citing 5% increase as noteworthy? If you've made your program 10% faster where 100% faster means that it was instantaneous then it's only spending 90% of the time executing. If you shave off 10% year-over-year for 6 years then it got 53% faster. Another way to say 50% faster, is 2x. I know it doesn't sound sexy, but that's a 2x performance increase meaningful improvement. 
\&gt; I'm a mod 😘 don't give a rip or your levelof being impressed with that. The purpose of being a mod on reddit is not to censor according to your personal preference. You are free to abuse the position if you wish but like I said that only hurts the community. You'll only hurt ruby with that approach. &gt; If communicating effectively and working together as a community towards common goals isn't "grown up" then Censorship is not communicating effectively. Its just trying to control speech.
It doesn't matter to the point so you are free to login and comment. I am not one of those people that think because of what I have done that I get to make points that don't stand up. given the present speed of Ruby 5% is a joke when looking at the context of all the other languages out there. Logic does not bow to lick boots. &amp;#x200B;
\&gt; I know it doesn't sound sexy, but that's a 2x performance increase meaningful improvement. considering the present speed a 2X increase in 6 years? Seriously that would be pathetic. if the goal is for Ruby to always have performance issues I guess thats a good goal. 
makes sense!
In fairness schneem When you stepped in after shevegen I did not catch the poster had changed (pretty similar arguments as well) so this part did not refer to you \&gt; and that won't happen by people such as yourself that say it should stay as it is . Its the people pushing for ruby to be more that would be the people to inspire investment. Sorry for that point that did not apply to you
Cool with Rails 4 support, then I guess they will support Rails 5 sometime this year, just before I upgrade my application to Rails 6.
&gt; considering the present speed a 2X increase in 6 years? What have you done to make Ruby in the last 6 years? strike that. What have you done to make your APP faster? I'm guessing nothing. &gt; Seriously that would be pathetic. I think the words you're looking for are "Wow, a free 2x performance improvement provided mostly by volunteers and a handful of full-time devs. Thanks! Oh, and it's going to get WAYY faster than that, likely due to MJIT in the next year or two? That's amazing. I could easilly switch to writing in another language such as C - which integrates extremely well in Ruby - but the truth is that I just get too much value from writing in Ruby that it's worth the time tradeoff to me. In fact, I care so little about the CPU performance characteristics that I likely have no idea WHY my app is slow." If you're a grown-up developer, then go learn how to make Ruby faster yourself and send some patches. That or go convince your company to hire a full-time core member. If you're not going to do either of those things then I suggest you find another free language to go complain about. 
yup. it wasn't meant to go quite like that. https://bundler.io/blog/2019/01/04/an-update-on-the-bundler-2-release.html You can still use bundler 1.x on travis, but you gotta put some things in in your .travis.xml to make it so. If you can't figure out how, someone else or I can maybe find it/figure it out if you ask here. It really oughta be in travis's docs. The bundler 2.0 thing is a pain. 
Rails 5 was supported before 4. The backwards compatibility with Rails 4 was implemented later. &amp;#x200B; Are you having issues using it with Rails 5?
&gt; I realize I'm confused about what bundler in "normal" mode does here on bundle install. I thought bundler in normal mode would download a more recent version from rubygems on bundle install even if there's an already installed version on the system that meets specs. It does, when using `bundler/inline` there is an option to invoke this behavior: ``` gemfile true do ... end ```
&gt; The bundler 2.0 thing is a pain. Ufff, really! Anyway, as /u/gibberishmuch said, Ruby 2.2 isn't supported, so I prefer to drop support for that version and lower.
Interesting! Also really oughta be mentioned in the [doc page](https://bundler.io/v1.17/guides/bundler_in_a_single_file_ruby_script.html)...
[removed]
Just do this in your travis file: before_install: - gem install bundler || gem install bundler --version '&lt; 2'
Probably, the easy way to think of it is that `gemfile { ... }` acts like `bundle exec my_file.rb` would without a lock file except that if it can't find a needed gem installed in the system it will go get it for you. `gemfile true { ... }` act like running `bundle install &amp;&amp; bundle exec my_file.rb` which would go get the latest version, assuming you aren't constraining the version in the `gemfile` block. 
/u/schneems Just as a heads-up before you go down the rabbit hole with Mike_Enders. I've had the 'opportunity' (if you can call it that) to interact with him in another sub-reddit (crystal_programming) and I've seen him being quite abrasive when the discussion starts to being argumentative and not going his way. Also, I tried once to see how far a discussion could go with him and if there is any way to help him deliver its message in a respectful way and it appears I failed to do so (it went as far as to the point where the moderator of the sub-reddit locked the post). So, I just wanted to say that you might be losing your energy interacting with him, he is actively looking for confrontation.
I see, the readme doesn't seem to specify compatibility, but from the title it sounded like Rails 4 was the newest supported version.
&gt;What have you done to make Ruby in the last 6 years? strike that. What have you done to make your APP faster? I'm guessing nothing. and your guess is based on what? Your great knowledge of my apps? Where did you inform yourself of that information. a seance? &gt;I think the words you're looking for are "Wow, a free 2x performance improvement provided mostly by volunteers and a handful of full-time devs. Thanks! it 2019 why would anyone say wow? Thats what open source is. its the choice of every developer and project what license they choose. Don't cry that its free when you made the choice. No one held a gun to anyone's head. Welcome to the modern software landscape. The problem with this is open source so shut up argument is that its self serving. When you start an open source project you do so with the full knowledge that you will always have more users than you have developers. You are fine with that because theres something you want out of it. You want the project to grow. You want us to advocate, suggest and grow market share. If only core developers used it you'd be dead in the water - so stop spitting in the pool made up not just of developer but the general community. If The OP of that other thread did anything but voice frustration and then you would have a point but you can't grow a project with the help of a community and then when anyone expresses themselves you say shut up because its free. He never commanded anything. good night ! all he did was express a frustration on reddit - not even to the core team directly and lets be flat out obvious and straightforward (since we are being so direct and umm friendly). Many core developers in OSS get some coin from it in consultancy and jobs (and its jolly well earned too no slight there ). So lets not pretend there isn't a symbiotic relationship between core developers and the user out there that promotes Ruby. Ever community that succeeds needs a large base of users thats way beyond core developers to be fair ruby adherents are not the only ones to use that argument ( but fewer use it as an excuse for the censorship you are advocating even on reddit) but you won't like this - its not used by the booming projects. they don't just spit at the community when a portion of it has some concerns - cause like it or not - anger you or not - non developer community makes the project vibrant. &gt;If you're a grown-up developer, then go learn how to make Ruby faster yourself and send some patches. why would I do that now that you espouse censorship? what Red blooded american rewards communities where censorship is promoted. Nope until that is disavowed my time and my companies dollars feel snug at home. You convinced me of that. &gt;In fact, I care so little about the CPU performance characteristics that I likely have no idea WHY my app is slow." I know why it was slow. Rewrote that sucker in nodejs and if flew like lightning. problem solved and client happy :) &gt;but the truth is that I just get too much value from writing in Ruby that it's worth the time tradeoff to me. you want a list of urls of former ruby users who say "not anymore"? keep your ideas about censorhsip and spitting at some of the non core community members that marketed ruby. No one needs that or you to take your suggestions on censorship or anything else. its 2019.. the alternatives are endless and people are already taking a walk not because of matz but maybe also because of a very smug portion of the community. I hadn't realized that before so thanks!!! &gt; 
perhaps your combative comment was unnecessary then? think about how your comments affect people who make tools for you to use for free.
have you actually tried that? I do not believe that will work for a couple reasons. But if you say you've done it and you have I believe you!
That is what the ImageOptim project is doing: https://github.com/toy/image_optim/blob/d2fc5d3523151e5d1df9b577a4f813dac0117068/.travis.yml#L24
As the [commit says](https://github.com/toy/image_optim/commit/d2fc5d3523151e5d1df9b577a4f813dac0117068), it will indeed install bundler 1.x if installation of just `gem install bundler` fails. I don't understand why you'd want to do that, I don't understand what problem it solves, and I don't understand how it's the solution to the OP's problem. But can you confirm you've used it to solve the OP's problem? It might be! What's going on with bundler right now is very confusing me. 
Time for you to stop being lazy and use recent ruby versions!
We have to be realistic - if people could, they would never want to change what works. Which is fine - they just can not expect to have other people fix problems that arise out of that situation. Older bundler should work fine for older ruby versions; people with ancient ruby could always maintain their old legacy things, but I guess in most cases they are already so inactive that they won't really change much at all anywhere in this regard - they are like zombies. 
 html = H { div { p 'hello' } } Yay! \o/ I also used something similar to this many years ago. It's quite ok but I eventually came to realize that one would need something new, something unified that keeps applications consistent, without having the mish mash that is "modern" HTML/CSS/JavaScript.
Hmmmm one thing though: H { p "foobar", class: 'important' }.render #=&gt; "&lt;p class=\"important\"&gt;foobar&lt;/p&gt;" I think when the end result, the HTML, ends up being SHORTER than the ruby code, then something is fundamentally going wrong ... :\ :/
Wrong supposition! I maintain some gems for statistical use and I want to provide the longer backward compatibility as I could for my user. I don't like to break userspace, but I'm not obliged to maintain BC forever....
no you were which is why the mod locked the thread after you refused to abide by his request Yo have been stalking ever since.
Even if that were true, this is not the point. The point was that you have an abrasive personality and interacting with you is not worth it.
&gt;I've just answered to you which I already regret since you will most likely reply. But, since I've just said that, you might not, because it would prove me right in some way from your point of view... :) reverse psychology only works on fools. You ought to know your link well because it was you who were abrasive swinging in just as you have here with empty objections. of course I won't follow your link as I am not interested.
yeah it breaks 2.3 too if you haven't updated rubygems so not really a EOL ruby issue either
has nothing to do with ruby version. it's not suporting rubygems &lt; 3... 2.3 default installs still have that version. 
Lol, nevermind, (yeah, google knows the link) I've shared it just in case that could help (didn't think you would take the time to look at it, the read is a bit lengthy and it wouldn't be coherent with the way you respond). Regardless of how you act, I actually find your behavior quite interesting, but I'm hoping other people could just not be affected by it. /u/nateberkopec and /u/schneems are actually huge contributors to the community and you effectively manage to insult them without any remorse or being aware of it: this is the part that saddens me and why I jumped into the discussion.
&gt; /u/schneems are actually huge contributors to the community and you effectively manage to insult them without any remorse or being aware of it: this is the part that saddens me and why I jumped into the discussion. No its not . You have jumped into discussion since where the team members in Crystal were in agreement and had no issue. However Sorry I don't kiss boots for anyone but God. No one attacked schneems. In fact I even apologized for misidentifying him in something I said. He attacked people just for voicing concerns. I don't care what anyone brings to a community I will never support censorship. You like fanboyism that takes offense at any suggestion or tries to lock down any criticism. You will feel right at home in this thread and be supported for it but I have no reason to feel the slightest remorse for opposing censorship on reddit. I am entirely aware and it doesn't sadden me you support it. Its to be fully expected.
You have intuited what is going on. str is just set to the same object as word. There isn’t 2 string objects just one, so the chances you make will be seen in both variables. To get a new string that’s a copy you can do something like str = word.dup
I'll say it again more thoroughly this time, but the interaction we add in the sub-reddit crystal_programming was about me trying to see if it's possible to make you realize some stuff. What I said in that thread was meant to make you react, not win an argument which would have shown me nothing that I already know. I purposely said controversial statements which brought me to try to de-escalate, nothing more, nothing less (so yes, you are right on that matter, that my objections were unwarranted).
&gt; when I change "str" I'm also changing "word" Remember you can always use .dup to copy a string. x = 'abc' y = x.dup Will be different to the variant without .dup I think this may be common in quite some other programming languages as well, so it should not be anything uniquely pertaining to ruby alone as such.
&gt; Rails 4 ??
I added the .dup and everything works great! Thank you for your help -- I'm glad I somewhat understood what was happening.
&gt;nothing more, nothing less (so yes, you are right on that matter, that my objections were unwarranted). Great so with that in mind heres a thought then...how about something on the subject of this thread that isn't just a personal attack on me as you have been doing? Heres the post this all started from https://www.reddit.com/r/ruby/comments/ad46f9/whining_ruby_evolution_is_taking_too_long/ You will notice it presently has 65 upvotes and it was NOT written by me. I can tell you based on that number going up and down theres been a whole lot of downvotes so the total upvotes have to be within the 100 upvotes range probably more . So Who really believes there have been a hundred people in this section wandering in here just to dump on Ruby with no interest in supporting it? I get now why Matz responded in that way since its been COMPLETELY mischaracterized as a call for him to step down. Since that appears to be how it was pitched to him his response was MILD. but people like nateberkopec have seen the evidence of the OP stating POINT BLANK in the same thread that was not what he called for and still persists. I get entirely how matz could consider that poorly and upsetting his life. You create something no one should be calling for you to step down from it. it would take a lot more than slow development to justify that nonsense. But if you are telling me the ruby community is now at the point where someone expressing some concerns (and NOT calling for Matz to step down ) which at least a hundred other members here see value in upvoting is a horrible sin then ruby has issues down to the community level. Because this isn't github or some letters being fired off to the core team to disturb them . this is just people expressing themselves in a reddit community and if it really is as /u/schneems imploies part of his moderation duties include censoring out what a hundred or more redittors see as a upvotable post then ruby has SERIOUS community problems. 
Thank you for your help -- the code works with the .dup in there. Do I have to do this every time I'm copying values from one variable to another?
&gt; Edit: this isn't about kissing boots, this is about being grateful. Also, he was simply telling you that he was a mod and wasn't censoring (I think you misinterpretted that one), but helping you communicate effectively your concerns (which is what I'm trying to do as well). T You are free to spin your hero's posts as anything you wish but I need not buy it. I don't have heroes in programming. I reserve that for people who save lives.He has clearly expressed an issue with people saying certain things NOT how they are saying them and he has not just objected to me as you are pretending due to your imbalance.. Ever since that time in Crystal which you admit now was unwarranted you have had a stalker focus on me. So much so now you can't even be bothered to address the issue. i am not interested in your point. stalking is creepy and on the basis of psychological issues disqualifying whatever you have to say on evaluating anyone else. \&gt; free speech doesn't say how to be civilized with it and just arguing that you can say anything however you see fit because of free speech doesn't make it right. Take your own words to heart. You obsession with me because you are allowed to post such obsession is no indication its right. Tim to get on the topic. I don't see people saying they have the right to say anything the way they want. I see people saying the content of what they other s have to say is nor right. Thats just a censorship play.
Now you've figured out what's going on, and how to fix it using two variables (with dup), if you're interested there's a way to reverse the string in place, without storing a second word. Hint: &gt;!in the same way that str[0] gives you the first letter in str, str[-1] gives you the last letter.!&lt;
That's a neat trick! I had no idea.
Look, you're attacking constantly other people in your posts on some of the sub-reddits I read and you're pretty much the only one that does it constantly. So, when I see your name, I'm almost 100% sure that the discussion will escalate and I wanted to make sure that my conclusion was right (that's what I explained to you). If you associate remembering names and behaviors with stalking, I suggest you check the definition of stalking.
&gt; it's effectively going nowhere. pretty much. its obvious you have nothing to offer this thread but your obsession and stalking and yes stalking - of your last twenty comments over half have been about me. get psych help. 
&gt; I find your claim hilarious considering there is an ISO historical artefact. ISO/IEC 30170:2012 was published in April 2012; gestated for quite some time prior; and has not been updated since. Any resemblance it has to modern Ruby is purely a historical coincidence. If you're going to cite standards, make sure they're *applicable* standards.
Well, I wouldn't say almost nothing: I diverted your attacks to me (and tried to de-escalate this thread which I'm pretty sure I failed at). Sure, first thing in the morning. Do you have any other insightful health diagnostic I could use or life advice?
Alright, that's enough, I'm out.
Alright, that's enough, I'm out.
&gt;and tried to de-escalate this thread uh-huh sure because making snide asides about people in a thread and never addressing the subject of the thread is how everybody tries to de-escalate tension. &gt; Sure, first thing in the morning. Do you have any other insightful health diagnostic I could use or life advice? Sure fixate on wife and children. it will take your mind of of fixating on a person on reddit. Great free life advice.
While it _may_ have been a bit of a dick move on the part of u/gibberishmuch, it's probably still worth addressing the confusion. I pretty much thought the same thing - that Rails 4 is the latest supported version. Ditto it seems for u/tracychavez. Unfortunately the explanation is now buried under the downvoted comment, so there may be some value for u/ViniStock adding a top-level comment to clarify that Rails 5 is already supported. The OP asked for some feedback, so here goes. Probably the original post title should have made it a bit clearer that Rails 4 isn't the latest Rails supported, _e.g._ "Sail 2.0.0: Style updates, backwards compatibility for Rails 4 and many new features. Feedback welcome!" The README and gemspec don't give any clues on what versions of Rails are supported. It might be worth setting max/min versions in the gemspec that Sail is known to work with, as well as mentioning it in the README. I'm guessing people will be more likely to give it a run if they know it's likely to work with their apps. Other than that, the code looks pretty solid. The `config/sail.yml` puzzles me a little - only in that I can't see a way to use i18n for `description:` values. I might be being a bit clueless. Lambda for authorization is a nice touch. Easy enough to restrict based on other models if you're using Pundit, _etc_. Can I suggest returning a "401 Unauthorized" HTTP code instead of the "302" I assume the `redirect_to` returns? Overall it's quite a neat tool for the problem it solves. Lot of good code coming out of Brazil these days. Good luck with the project. Hope some of this helps.
This was so great. Everything I consume from Sandy is just higher level and I'm quietly ashamed that as long as I've been using ruby now, I still feel like I'm never quite getting the perfect heavenly OO-style composition and ethos of code I see that I really admire. sigh, one day...
The term that describes this situation is called [aliasing](https://en.wikipedia.org/wiki/Aliasing_(computing\)).
OK and why do you want usage, users and interest? You want more people to build web apps so you could pay them bills, no?
Don't you still need a variable for swapping "symmetric" characters?
It is, actually. It depends on the way you speed the process up
``` s = "abc" s[-1],s[0] = s[0],s[-1] puts s ``` but regarding op's task, I just would use `s.reverse`
Rails 4 backwards compatibility. Rails 5 is already supported.
Oh yeah.. I forget that double assignment... And for longer string something like that `1.upto(s.length/2) {|i| s[-i], s[i-1] = s[i-1], s[-i]}`n' Indeed about `s.reverse` but I think it was part of the exercise to do it manually..
Build an action in a controller that responds with a 1x1 transparent image, and where you also count +1 in a database, it's very straight-forward to build given your explanation. Could you be a little bit more specific on the problematic areas?
Thanks for all the thoughtful comments! &amp;#x200B; Like any other templating engine, Rubyoshka has its limitations and quirks. It might not be the most terse or most performant way to write HTML, but I think the value of Rubyoshka lies in being able to compose HTML out of multiple reusable view components, as well as it being just plain Ruby code, which is easy to grok and extend.
OK. So whenever the controller is called I increment the a value and save it to the database, right? That's it? Thank you!
Yes, just make sure that you use idempotent database functions. increment! can help you with that: https://apidock.com/rails/v4.2.7/ActiveRecord/Persistence/increment%21 @pixel.increment!(:view_count)
I love everything Sandi Metz does. She's wonderful!
I agree, perhaps the title should have included backwards compatibility for Rails 4. My line of thought was: "it didn't work with Rails 4 before, so I will highlight that for people who haven't migrated to Rails 5 just yet", but the choice of words might have not made it that clear. &amp;#x200B; Concerning the configuration file, it is only used to create settings, but it does not support localization. Localization is supported for general strings (like the "SAVE" in the save button), but is not implemented for database values such as the setting's name or description. &amp;#x200B; About the authorization lambda, you can do pretty much whatever you wish. Redirect was just an example. If you wish to return unauthorized (with no body), you could simply do `Sail.configure do |config|` `config.dashboard_auth_lambda = -&gt; { head(:unauthorized) unless current_user.admin? }` `end` &amp;#x200B; Thanks a lot for the feedback and the kind words about Brazil.
To answer your question literally, no. The problem (as I see it) wasn't related to copying values from one variable to another. Instead, the issue is that one variable contains a reference to the *same object* as the other. That's the aliasing that u/rubyrt referred to, so maybe you have already figured out the answer to your own question. I just saw no one had replied here, so just in case... If the variables refer to two different string objects in the first place (like if you use `#dup`), then copying characters from one to the other works as you'd probably expect. irb(main):001:0&gt; word = "programmers" =&gt; "programmers" irb(main):002:0&gt; str = "lumberjacks" =&gt; "lumberjacks" irb(main):003:0&gt; str[0] = word[0] =&gt; "p" irb(main):004:0&gt; str =&gt; "pumberjacks" irb(main):005:0&gt; word =&gt; "programmers"
I used the exact steps that are presented in the referenced article. Apparently the dockerfile made the difference.
You should respond with an image though. Create a transparent 1px image and then do `puts File.read(filename.png)` in irb for a string representation that you can respond with in the controller. 
The cool thing about ruby, is often these sorts of problems have already been solved for you: [https://devdocs.io/ruby\~2.5/string#method-i-reverse](https://devdocs.io/ruby~2.5/string#method-i-reverse) &amp;#x200B; Another cool thing about ruby, is you rarely need to do for or while loops with explicit indexes like you do in other languages. Your code ends up shorter and more concise. For example, Strings in ruby offer the [each\_char](https://devdocs.io/ruby~2.5/string#method-i-each_char) enumerator, allowing you to iterate through each character. &amp;#x200B; Another possibility is to use a for loop, so instead of declaring, testing, and incrementing `i` and `j`, you can say `reversed = ""` `for i in 1..word.length` `reversed &lt;&lt; word[-i]` `end` `reversed` Disclaimer: I'm not sure what the requirements of your lessons are. They may be avoiding the easy, obvious answers in order to teach you something.
I think it should be send_file 'public/image.png', type: 'image/png', disposition: 'inline'
Having gone through App Academy myself, your assumption at the end is correct. They don’t want you to use String::reverse — when I went through they had us make our own array’s, hash, linkedlist, some other ADT, as well as make an enumerable module and make our own reverse / each / map / etc methods. 
I find it's way easier in something that _isn't_ a web app. Which also means taking as many parts of your web app as you can and making them components that don't know they are in a HTTP app!
Wow, you sound like a dinosaur. Why the hell would I spend my time fidgeting around with symlinks when there is a tool (rvm) to take care of these things for me? Not to mention the fact that RVM provides **reproducibility** so everyone using/working on your stuff ends up with a consistent environment. There is a reason tools exist. 
irb(main):001:0&gt; def reverse(word) irb(main):002:1&gt; word.reverse irb(main):003:1&gt; end =&gt; :reverse irb(main):004:0&gt; reverse("hello") =&gt; "olleh" &amp;#x200B;
Having the image as a constant saves you disk access etc, it can matter a lot on a tracking pixel that sees a lot of traffic. 
Maybe a thing for legacy projects that have fairly many records (or huge throughput of records): int(11) id and _id columns. They are bigint by default since.. rails 5? but it reminded me that I have yet to migrate all old id columns to bigint.
I'm a bit confused. I should use 'puts' in a controller? I thought puts only works for Terminal output, not in Rails. Can you spell it out for me please? Thank you so much.
Run it in irb, then copy paste to a suitable place in your code. 
[removed]
&gt; most language developers write C instead of working in the language itself. I'm not sure this is actually true—or at least, it's only partially true. For example, most JVM implementations are written in C or C++, but javac (the compiler) is written in Java. Scala's compiler is written in Scala. The Rust compiler is written in Rust. GHC, the most common Haskell compiler, is mostly written in Haskell, though I believe C is used for the runtime. So while dynamic, interpreted languages are usually written in a lower-level (or at least, compiled) language for performance reasons, the story in other languages is mixed.
it would be a good exercise, IMO, to do this via recursion 
There's no need to do that. You can read the file in an app initializer and store the value in a constant.
True! 
It obviously has been quite an effort by the site maintainer and it is good that the ruby toolbox exists. Despite that I feel that it should be rubygems.org + rubygems that should integrate this functionality by default. We already can search for gems; searching for tags is limited at best. (E. g. how can you search for multimedia-related tags at rubygems.org?)
It's one thing to say "Use a newer Ruby, you lazy app devs!" but some of us are gem maintainers. Rails 5 supports Ruby 2.2.2, my gem supports Rails 5, boom, broken test matrix. In practice, this just means I'll remove 2.2 from the test matrix.
That's a good call, Mikey boy is not worth it. Set all your comments to "disable response". No one else is reading this comment thread anymore at this point, so he'll just be shouting into the wind. It's funny that the ones that complain the most about the "community" are the ones who do the least to help it and are actually making it a worse place. 
In that case why not do it as a linked list?
&gt; Examples of these include image recognition software where you can find being &gt; used in your favorite photos application as well as in social networks for &gt; facial recognition and image classification. Now I don't understand what image recognition software has to do with machine learning, but let's ignore this for the moment: - Is this REALLY where people get "excited" about? Because your own use cases include that you must recognize facial features? In like 20 years, I never had any need (neither an interest) in wanting to sniff-recognize people.
He has a point. Not necessarily in regards here, but more general. I hate writing documentation myself but documentation IS important. If an author shows a lack of interest in writing documentation then this signals a lack of interest in having other people use the code. In that case it is almost completely pointless to even WANT to distribute it. Documentation IS important. That includes style too, although style comes secondary indeed. I do not think it is a "high horse" statement at all though - I think it is a perfectly valid statement that he made. Absolutely no clue why he is being downvoted.
&gt; If you were genuinely interested in this project you would actually contribute &gt; by making a PR If the original author was too lazy or too incompetent to write good documentation to begin with, then why should OTHERS go and invest time fixing the problems by that author if that author showed a lack of interest to begin with - by having inferior or no documentation at all? I refer to this in general, mind you; not specifically to the gem named here.
That's the recommended way at first, actually. Later they teach you .reverse when they teach you about arrays.
They teach you that way later, when they teach you more about arrays. I think the point of the exercise was using loops to do it, to get you more comfortable thinking in that way.
On the contrary, it's a good thing per se, but I want to be a nice developer not just a nice.. boy-scout. And being a nice developer implies actively caring about the tools we use as a community and being able to objectively judge whether they're in shape or not and discuss how to fix them, or their manufacturing process.
Will do. The less funny thing is that they think the world revolves around them, so it's likely that they think that voicing in is a meaningful contribution. Even though it might be, it's worthless if the discussion becomes toxic and, at this point, it's a negative contribution. In other contexts (outside reddit), I just keep these kind of person at arm's length if possible: sometimes, it's not possible (or the least bad option) and I wanted to see if there is any way I could help someone like that realize that it's wrong to act this way. It goes without saying that if there is a way, it's not the one I tried. Sorry to have use this thread for this, it might have worsen the atmosphere.
In that case, the gem-maintainers should include "topics", or "keywords" or so in their gemspec. Which would not be that hard. There's a lot wrong with npm, but they have [this "tagging" built in](https://docs.npmjs.com/creating-a-package-json-file) That said, I do think there is a difference between better, more topic-based search and discovery on rubygems.org and a curated list of "good stuff". There's always need for the latter. Especially, since rubygems can only measure popularity based on metrics that are self-fulfilling and therefore inherently stale. There are much better alternatives for the abandoned cancan, yet its still a popular gem. And because it is popular, it is downloaded a used a lot: making it more popular, ad infinitum. Ruby-toolbox, or any curated list, can break that circle by putting humans inbetween the listings.
This is a great recommendation in a deceptively simple package! Thank you!
And this fully resonates with the original Reddit post title: "Ruby evolution is taking too long".
No it doesn't.
Using a static base64 string or something similar would likely be more performant than hitting the disk e.g. `data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7`
I hope you have your answer by this time; here is another one: str = "asd hsdfh" input = str.split("") ret = [] while input.length &gt; 0 ret &lt;&lt; input.pop end puts ret.join 
&gt;The original poster did not ask "what can we do to make Ruby development faster?" &amp;#x200B; Let me clear up one point. Criticizing, suggesting features or a even new growing model, should not be restricted only to those who actively contribute to the development of an open source project. I know and respect your work for the Ruby language, but this whole "Hey, I did this (or we did this), show me what are doing which entitles you to have your say" is a completely wrong attitude flawed by emotional bias. &amp;#x200B; &gt;"What does Matz want/need?" or even "does the core team want to speed up Ruby development, and if so, what would they prioritize?". Instead, they came in guns a-blazing with solutions to THEIR biggest problems. &amp;#x200B; Of course OP didn't ask "what does Matz want/need" because OP's complain was exactly on Ruby's evolution pace/model, and the by extension about the people behind it failing to become fully aware about how that model might no longer be good enough, compared with other modern programming languages realities. For example, V8 parsing speed improved roughly 30% on desktop in just 2 months (since v7.0, source: [https://v8.dev/blog/v8-release-72](https://v8.dev/blog/v8-release-72)). So in a world where V8 could theoretically become 3 times faster in just one year, do you think it's good enough for Ruby to get 3 times faster in 10 years time span, to remain alive? Of course V8 is not open source. But as I am sure you know, it doesn't matter: when you have an incredibly acclaimed open source project (what Ruby was when it became popular), the only thing that will decide for its faith is its governance model. If the people behind a project fail to realize they need to gather more attention, more people, or to build a better growing model while the project is still in a competitive stage, then a time will come when this will be no longer worth it, and people will start focusing on building something new from scratch. For Ruby this is already been happening for a while (see Elixir, Crystal, ...) so I think now we are right on the border line. If Ruby's evolution has to be discussed and taken to the next stage, it needs to happen NOW. &amp;#x200B;
The basics are in the [top level OpenSSL documentation](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html#module-OpenSSL-label-SSL+and+TLS+Connections), above are the steps for [creating or loading a key](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html#module-OpenSSL-label-Keys) and [certificate](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html#module-OpenSSL-label-X509+Certificates). There is a sample echo server and client in the [ruby openssl samples directory](https://github.com/ruby/ruby/tree/trunk/sample/openssl)
I was just trying to give you a different perspective from which to look at it. I forgot to add "IMHO", I apologize.
There is [RubyTogether](https://rubytogether.org/) which is set up for companies/individuals to contribute funds. There is also [Ruby Central](http://rubycentral.org/), though it is not as easy to contribute to. Both orgs support Ruby infrastructure and community, but not the development of Ruby itself, as far as I know.
I’d chime in with the alternative I’m responsible for http://ruby.libhunt.com . It’s not as pretty but could be quite helpful too.
I could have expounded upon other use cases but that example was the one that came on the top of my head as that is where a lot of people, I believe, have come into contact with ML technology.
Strange that no one has updated or even commented in the Rubymine bug, even when the fix has been merged and accepted.
&gt;If an author shows a lack of interest in writing documentation then this signals a lack of interest in having other people use the code. In that case it is almost completely pointless to even WANT to distribute it. Not sure how to make of your statement, I am certain people distribute software, especially free and opensource software, because they want people to use the code and not the other way around. If a gem or any opensource software meets their use case and there is no better alternative then they will use it even if documentation could be better. I for one wished somebody else could have written what my library does for me but it's just too bad isn't it. This **"You don't deserved to be helped because you write bad documentation"** mentally is not something the ruby community should be going for in my honest opinion.
RVM is still king - had too many problems with `rbenv`. Still loving me some `rvm`!
&gt;If the original author was too lazy or too incompetent to write good documentation to begin with, then why should OTHERS go and invest time fixing the problems by that author if that author showed a lack of interest to begin with - by having inferior or no documentation at all? People invest their time on an opensource project because it meets their use case and it meets their needs regardless of the authors motivation. And they spend time to fix problems because they want to contribute and help the next person as well as themselves (so that they don't need to keep a fork) for the library they just got for free?
&gt; I am sure there are many less strict/direct ways to explain the impact of basic neglect, but I also believe such ways do not work most of the time. If someone ignored that in the first place he/she must believe its not important at all. And if that’s the case, indirect polite hints about the issue do not usually have any impact. While I appreciate your intent. It saddens me that is the general conclusion you had to come to.
Wow this went unnoticed everywhere!! And just as I was about to migrate to 2.6 in a rails app that is completely dependent on elasticsearch SDK (under the hood depending on Faraday) where I use bulk indexing of hundreds of documents!!!!
I am "the OP". Maybe it ia just my poor English skills. Does "consortium" somehow mean that it has an ultimate power over the project? I didn't write it explicitly in the post, but I don't want Matz to be replaced. And I actually wrote something like "take off some weight from his shoulders".
hey - i'm curious about where you get the "popular articles" from - is it programmatically gathered, from user submissions, or just Hard Work?
It's both. I go over all of them every week. I've automated it to the point that it takes around 1-1.5 hours. 
You can change the Faraday adapter to use [Typheous](https://github.com/typhoeus/typhoeus), just add it to the Gemfile and require the following files: require 'typhoeus' require 'typhoeus/adapters/faraday' I recommend you do that either way, because Typhoeus gives you persistent HTTP connections, which generally means less overhead on your Elasticsearch requests.
Uh yes of course! Thank you!
Thanks for your feedback! To keep things DRY I'd like to refer to my previous response on this topic: https://www.reddit.com/r/ruby/comments/a6dizh/new_project_health_indicators_on_the_ruby_toolbox/ebz10xv/
Has it been merged and accepted? I am really asking, I have no clue. I think there are people involved, not superhumans. The most likely explanation may have been that it was forgotten which can happen. People seem to be shy to comment on the official bug tracker or perhaps they just want to write content for their blogs, like in this case (otherwise it could have happened all at the bugtracker only, and linked to it from here and other sites instead).
yes, it's in trunk
won’t the OS just cache it after a few hits? granted that a 1x1 image doesn’t take memory to store. 
&gt;I am completely new to encryption It's unlikely you want to use OpenSSL directly. Depending exactly what you are doing, you could: - Let an application like nginx handle SSL for you, and leave it out of Ruby - Use a modern library like libsodium I can almost guarantee that if you read those OpenSSL docs and try to write some encryption code.. you'll write something I could find issues with.
It was also reported here: https://github.com/ruby/ruby/pull/2058 (which links to the bug tracker) but the actual commit is here: https://github.com/ruby/ruby/commit/1680a13a926b17661329beec1ded6b32aad16c1b In the issue it seems like there was an issue on understanding Rubymine (or lack of permissions?): &gt; EDIT: I'd like to leave a comment on https://bugs.ruby-lang.org/issues/15468 but I don't seem to see how to do that. I'll open a separate issue for this symptom if that is helpful.
Cool timing: I am currently introducing Rails to a coworker who does a lot of node and frontend, and I think he might like Rails APIs in particular. FYI: The link to the viewable version of the book (example: http://apionrails.icalialabs.com/book/chapter_three) doesn't seem to show content (for me, right now, at least). 
I'm surprised this hasn't been asked yet, so ..... Why would you want to do this? What are you trying to achieve? There's probably a better way of doing it.
I want to measure the number of times a specific ad was served. The ruby engine will only serve the transparent gif pixel, not the ad. The ad is served separately.
This is one reason I almost always wait for the first patch release of a new version of MRI. Of course, if everyone did that, nobody would ever find the problems. Tragedy of the commons. 
How many pages does it have?
I wait a few months with all software, but with Ruby I hope someone like /u/schneems notices something strange at his job at Heroku and assembles everyone to get stuff fixed.
schneems is indeed a huge asset to our community!
While people may have fun with it, and I am not to want to discourage those who have fun, my main rule when approaching ruby is this - code has to be simple, at all times, whenever possible. Whenever I have to think, it's where I lose already. I sometimes wonder whether ruby in itself attracts in particular people who prefer to tinker rather than get things done.
&gt; One particular case of ActiveRecord misuse that I find is common amongst my clients is that ActiveRecord is executing SQL queries that **aren’t really unnecessary** Double negatives are fun. I suppose they meant &gt; aren’t really necessary or &gt; are really unnecessary
Yeah, all pages are blank
bad day at work huh ? 
Whoops, thanks. Fixed.
Whoops, fixed. Thank you.
First one has a magic whitespace which is a unicode character that is invisible. Second one is just spaces, and that fails.
There is a missing word too (**emphasis** is where there is a missing word): &gt; Another rule of thumb is that most queries should **happen** during the first half of a controller action’s response, and almost never during partials. 
Nice ! Yes you are right :) First one is defined with different UTF-8 whitespace character [http://jkorpela.fi/chars/spaces.html](http://jkorpela.fi/chars/spaces.html) . Second example is defined with normal regular space &amp;#x200B; There are different "white space" characters in UTF-8 world (e.g. Tab, no-brake spaces etc) defined in UTF-8 char set, Ruby supports UTF-8 code. &amp;#x200B; Good job mate ! :) 
The console suggests the blank page might be due to https://www.mathjax.org/cdn-shutting-down/
I only know this because back in the 1.9 days I spent way too long trying to figure out why some code wouldn't load correctly, and it turned out to be a rogue UTF-8 whitespace character that was left somewhere in our codebase.
:D yeah I bet it was someone who was leaving the company and this was his final "I hate you all" statement.
I've lost count of the length of times I should've used `#size`. I always prefer it now. It's a cardinal rule.
your english was fine and do not sell yourself short. You did state explicitly in the thread that you did not want Matz to be replaced. Even in the OP it said nothing but " they can take some design decisions off Matz' shoulders ". Thats not a call for Matz to step down. Some people jumped to that conclusion and apparently framed it that way to Matz. 
Great article!! Thank you! _I've also played with C extensions (mostly to compare it with crystal, planning to make an article).._ _NB: seeing that *box parcel* logo gave me so much nostalgia... I worked some months as a car driver, it'd really helped me when I was in a critical financial situation when during an unemployment period between two jobs.._
The true link is https://github.com/madeindjs/api_on_rails. 
Average 160 for the PDF version on A4 format
I thought I knew all this, then realized upon reading I had just written a bad `present?` this morning. Doh! really there's no way to completely avoid this stuff, you just gotta do analysis to make sure there aren't any sneaky n+1's mistakenly going on, and then fix them. But you do have to understand how to fix them!
double negatives? No, it's a different part of the article about `!!`! Kidding. 
Fixed that too now. Grazie.
\`count\` always does a calculation, even on Ruby's STD, so I think it makes sense it also does the calculation in AR. Great post BTW! I learnt something :) It makes me wonder, why doesn't AR cache things when using things like \`.present?\`. Sure, the query itself is different so you can't simply cache it, but if it was smart enough to know things like: items.present? items.each { ... } # here `items` would already be loaded It would be pretty awesome. I guess that's hard to do though.
ActiveRecord?
Never understand why not to query everything in a controller's action before rendering a view? I have taught myself to always do that the first after have been tired to move a *tone* of queries from views in a huge project to implement page caching.
I upvoted because it’s a true statement, but filterific solves the front end problem, which can be hard to get right.
Not sure I understand you... what's the front-end problem you're trying to solve? And are you sure you're not making the mistake of putting business logic in the View?
The gem provides an interface for users to select filters and whatnot. And again, I don’t use this gem. 
Hi, &gt; Especially, that the people with control over Ruby's further development aren't actually Ruby developers. I don't believe that any of them have notable Ruby projects, or do professional Ruby development. I am on the Ruby core team. I also develop Ruby apps and work on some popular Ruby libraries. I'm not going to dig up resumes for every core team member, but I don't think this statement is accurate. &gt; The important notes are in Japanese I don't think this is true. I read both English and Japanese. Anything important is written in English. The conversation may start in Japanese (community members may file bugs in Japanese), but any decisions are discussed in English.
Check out [ransack](https://github.com/activerecord-hackery/ransack).
When you call present? on an unloaded relation, it does an EXISTS SQL query which just returns a boolean, so none of the data is loaded. It could just load all the objects into memory anyway, but that's potentially a huge waste if you don't actually need them. Ruby is interpreted, so there's no way for ActiveRecord to know that second line is coming and optimize for it. :/
Yeah, I'm not sure it's possible, unfortunately. I think the most they can do is change the API, but I guess that would require some massive design changes, which is not gonna happen :P All we can do is know the limitations and use it accordingly. It's not that bad to be honest. I've always thought AR does a bit too much though, for example, validation could be in another layer, like Form objects. I think [Hanami](https://hanamirb.org/) does a lot of things right, although I have never tried it myself yet, checking out the documentation, it looks promising :)
Yea it definitely does do a lot of stuff. I'll ha E to check out Hanami later. 
Why is this NSFW ?
Single-character literals don't belong in production code.
Are you talking about [Why's (Poignant) Guide to Ruby](https://poignant.guide/)?
Thanks but not this one. It was teaching with online ruby editor and was designed like a book. 
It is definitely NSFW
what is something like ruby katas? I don't think this is the old one I remember but it does the same thing &amp;#x200B; [https://www.codewars.com/](https://www.codewars.com/)
Thanks not this one too but it seems nice also. I will try.
This site is unusable on mobile.
here you go [http://www.rubyinside.com/media/poignant-guide.pdf](http://www.rubyinside.com/media/poignant-guide.pdf)
Maybe just codeacademy? or perhaps rails for zombies?
No :(
Sorry, it’s an online IDE I have to use while at work
It could be smart if you could lock your ActiveRecord instances from the controller, so that no sneaky n+1s or further queries could be made in the views.
Good luck with that! I have python on my bucket list as a Ruby developer too. Would be great if you can share some advanced python material, that would quicken python learning curve.
I learned python too, due to various reasons. Ruby is vastly superior to python (I can explain why, too, from a design point of view; and because it is more fun as well) - however had, python has the power of momentum right now, which can act as a catalyst. I guess we'll have to make some serious suggestions for making ruby significantly better than python, in the sense that when people face the choice of which language to pick, they may pick ruby rather than python, for specific reasons. The other area of improvement is to, of course, improve the ruby gem ecosystem as a whole. Python actually does not have that many more pypi packages than there are rubygems, so that is not a huge difference.
Once you "understand" a bit that python is different, adjusting to it is not that hard. It's a strange language, with OOP bolted on it rather than a primary functionality (e. g. the requirement that you must pass self explicitely at all times shows that the language has serious shortcomings in this regard; or the mandatory indent, where you must use "pass" as otherwise python assumes that the indent indicates python code), but once you sort of "adjust" to that strange mindset, python is somewhat acceptable. It's concise in its own and past that point not that hugely different from ruby in many ways. It's still massively inferior in design compared to ruby though - acceptable but inferior. The primary reason for people to flock to it is mostly momentum right now (and in the last ~3 years).
While this may be understandable, I think you could put the whole code into a single "file" and just put that on display anywhere, be it a pastie site or gist.github and so forth. The easier it is to access just the raw text (code), the better, IMO. Not even syntax highlighting is a must, although it can help; having to load up a strange online editor is not always great, not even limited to mobile only - I have had weird behaviours just due to JavaScript use there and people to then say "hey just use chrome" ... and I can not use Google's monopoly browser.
Hmmm I thought I was the only one finding it strange to pass the self always!! Thank you.
+1 here I ran into some roadblocks with Filterrific a while back (can't really recall on what exactly) and went to check ransack afterwards. Never looked back...
Yeah it's a huge problem with ActiveRecord's design IMO. The bigger my code gets, the more I want to just say "**no queries in views!**"
I guess it was Try Ruby by \_why but original version is no longer available. There is however remake [https://ruby.github.io/TryRuby/](https://ruby.github.io/TryRuby/).
Rubymonk? [https://rubymonk.com](https://rubymonk.com) 
Python feels like a dumber version of Ruby. It seems to be a strong philosophy of one right way to do things in Python, even if there are good reasons for there to be multiple ways to do that thing. Ruby simply allows more flexibility to solve the problem the way the programmer needs to solve it. If we were to assemble a big matrix of features and we were checking off things python would check off just about everything Ruby does. That is only because it's hard to write down the intangible things make a programming language ergonomic. Why are lambdas so stupid in Python? Why is it so convoluted to make read only constructs in Python? Both Ruby and python can do both of these things. Lambdas in Ruby are super simple and used everywhere while in Python they are painful and limited and syntax. In Ruby any objects can be frozen, but in Python you have to put items you don't want to change into a certain kind of container.
When was that added to ruby? And why? that seems very un-ruby 
Are you talking about the one with the cute little illustrations and it taught you hashes and such with a library catalogue as a use case? If so I'll try to remember the name of it.
@sanjibukai Thank you for reading - I'm glad you enjoyed it! And amazing to hear you were once a Stuwie! We're hiring on the backend team for remote (and colocated) developers if you're interested in applying: [https://stuart.com/jobs/](https://stuart.com/jobs/)
Yes I guess so 
Did you look at my comment?
Front end is totally different than this one I’m not sure
There are cases where language X is preferable over Y for purely pragmatic reasons. Rails is my go-to tool for building web apps. However, in one of my side projects I needed a large does of symbolic maths. Python has SymPy but Ruby has nothing. I didn't want to use Django so I ended up extracting a simple RPC service that exposed SymPy to my Rails app. My advice would be to broaden your horizons and learn other technologies and then be pragmatic about your choices.
For anyone wondering, the code is equivalent to: !!!"?" "?" + "?" == "??"
Did you look at this http://web.archive.org/web/20170204010109/http://tryruby.org/levels/1/challenges/0?
Wow, just found out something odd: I'm running `rails c` using Ruby 2.5.3 and Rails 5.2.1.1. If you run the code `!!!` (the code on this post except for the character literal), the console just exits without any warning or anything. What's going on here? This doesn't happen on `irb` btw.
My memory is hazy but: the character literal `?x` has been there for a very long time, at least 1.6.x. It used to return x.ord though, it was changed to return a "char" sometimes in the 1.9-2.0 time frame. I think it feels un-ruby like a lot of old ruby syntax i.e. `$!`, `if /x/../y/` etc :)
Omg yes it’s it. So sad that it’s dead 
It is a widely disliked feature. There is a rubocop rule to flag it. https://github.com/rubocop-hq/ruby-style-guide#no-character-literals
It's a pry command. Type "help" to see all of them. !!! Alias for `exit-program` Code at https://github.com/pry/pry/blob/master/lib/pry/commands/exit_program.rb
Why, just why? 
Yes, it does an EXISTS query since Rails 5.1. Rails 5.0 and earlier used to load all the objects in memory and check for existence. Check out: https://www.ombulabs.com/blog/benchmark/performance/rails/present-vs-any-vs-exists.html to see benchmarks on the subject for a Rails 4.2 application.
Check out the cycle method https://ruby-doc.org/core-2.5.1/Enumerable.html#method-i-cycle
I actually have a working single file version commented out at the bottom of the main.rb that I used before I wanted to mess with methods from different classes and classes in different files! If I decide to share again I think I’ll just put it on pastebin or something 
Wow, Pluralsight seems to have acquired all the domains to the awesome beginner friendly (and free) tutorials and leads them to paid courses now ...
Oh, huh, I assumed it was that way for longer. Our projects have only recently gotten to the point where N+1s are becoming a problem, so I haven't looked into it too deeply before. 
Oh my goodness I had no idea about this and now the OP is hilarious. And kind of disturbing. 
I think this is a great work.
A couple of comments * returns in ruby are implicit. The last thing evaluated is returned so you don't need to explicitly type return or assign to a local variable * you can parallel assign in ruby, e.g. a,b = thing1, thing2 * utilize the benchmark library to do benchmarking, there is no need to do time in time out stuff in ruby. keep in mind that when benchmarking things with large startup costs you might need to utilize Benchmark#bmbm * \*while\* loops in ruby are usually better done via \*each\* (iterations performed but nothing returned), \*map\* (iterates over collection and returns an array of each iteration's return), \*reduce\* (performs iterations with an seed accumulator variable, performs operations, passes accumulator to next iteration, returns accumulator) 
Views should be as dumb as possible imo. They should be reflecting data fetched in the controller, not fetching and then doing logical operations.
`objects.map.with_index {|o, i| o.user_id = arr_user_ids[i % arr_user_ids.length]}` 
Ruby really does have everything! 😁 Probably doesn't matter for the OP, but I'm personally curious: I'm guessing that method isn't thread-safe? Again, probably not relevant, but round-robin comes up frequently when allocating resources in distributed systems, where thread-safety is often a concern.
Can you elaborate? I don't see how choosing a consumer for allocation of resources is related to thread safety. This cycle method simply returns a new Enumerable object you can cycle through. It does not mutate so it should be safe.
I find myself asking that question pretty often when using pry.
Ruby is a cross between Perl and Smalltalk. It’s a wonder that the result is beautiful and not an abomination. Still, sometimes the less glamorous historical traits leak through. 
The best online tutorial with several links etc. Definitely worth checking it out: https://www.theodinproject.com/courses/ruby-programming Besides that ( it's not a tutorial but it really helps), check out the book : Learn Ruby The Hard Way
[_Whyyyyyyyyy_](https://i.gifer.com/SVrH.gif)
Check out the gem "goldiloader" as an automatic alternative to manuel optimization through bullet :-)
Whenever I write python (which is not very often) I always feel that python is backwards of how I think. I'm not saying I'm right or wrong I just think differently. Like: `", ".join(list)` vs `array.join(", ")` `from foo import bar` vs `import Foo from bar` (not ruby) `for x in list if x in bar:` (this is just awkward) One thing that I do miss in Ruby though is decorators. (Yes it's possible to get that behaviour, but it would be as clean as in python)
Well with any language, the only way to read and understand code, is to write code. Especially with ruby. Some obfuscations only become clear after using them. 
Are you a developer in other language? I'd rather recommend skipping through the language reference: https://rubyreferences.github.io/rubyref/ You can try to skip through "official" [Ruby in 20 minutes](https://www.ruby-lang.org/en/documentation/quickstart/), but I am afraid "some things that escape" is exactly NOT what it would cover. Or you could just ask here, we are friendly (most of the time).
Zed possibly doesn't get enough love from the Ruby community, but his [Learn Ruby The Hard Way](https://learnrubythehardway.org/book/) is a good reference. If you're already competent in another language you can probably skip over a number of chapters. 
I haven't noticed anything like that on my own gems but haven't been looking that hard. How frequently is this counter updated? I've just installed `split` and can only say it's definitely not real-time (or is broken).
skim, not skip
this assumes you have some index to use % with which can be a database index as well
I'm not affilated with [launchschool.com](https://launchschool.com) , but the prep course is really good and it's free. 
I'm not sure if get this right
Really appreciate the feed back. I’ll work on it and update with suggestions
Learn x in y minutes. There’s a website called that and it’s got tonnes of languages including ruby. Google it.
That's generally good advice that is absolutely unrelated to the situation, if I understand correctly. OP wants to **read** particular (not very complex) Ruby code, it is not like "how should I learn enough Ruby to read through all the Rails codebase". What they (probably) need is quickly deal with Ruby's "deviations" from obvious (pure syntactical and conceptual) like `def self.method` and our beloved blocks. I frequently have the same need for different languages (just to understand some interesting article/library "just now") and "...then write a lot of code in our language" is typically not an advice I am seeking at those moments :)
I would hope OP is a developer given they chose a Markdown compiler tutorial ;)
Well... As a Ruby mentor, I met people with attitude like "I never programmed, bought my first computer month ago, I am very motivated and have programming assignment (for some other courses, or, in the worst case, job interview) next week, will you teach me enough programming to handle it?" :) (I am not wanting to offend OP in any way! Just sharing funny stories)
I agree that would be a nice feature. I wonder if it can be patched in as a third party gem. 
🤣 ty this made my day
🤣 ty this made my day because of this response
&gt; I don't see how choosing a consumer for allocation of resources is related to thread safety. For example, in load balancing, you may want to pick from a series of hosts and distribute traffic to them in a round-robin fashion. Multiple requests may be made to the load balancer on multiple threads, each one being rounded to a different downstream service. &gt; This cycle method simply returns a new Enumerable object you can cycle through. It does not mutate the original array so it should be safe. No, but I'd guess there's some state internal to the returned enumerator that tracks what element to offer up next. That state needs to be accessed and updated in a thread-safe way.
Anyone knows if Balkan Ruby talks are un english (or have translation?) I should take the chance to know Sofia...
A certain person made an experiment of registering 1000 versions of Gem named download_this_gem at the same time. This caused RubyGem to become unstable. Perhaps this may be the cause of your case.
Is \_why's poignant guide to ruby still around? Yep! [http://www.rubyinside.com/media/poignant-guide.pdf](http://www.rubyinside.com/media/poignant-guide.pdf)
&gt;*while* loops in ruby are usually better done via *each* (iterations performed but nothing returned), So because I'm really just trying to test the performance of my own sort, and don't really need to retain a return value, should I just adjust the logic to an each to save time on it?
I was looking at this, but it seems like Bullet gem but it only gives you this (both in controllers and views): # Each of these settings defaults to true # ------------------------------------------ # Detect N+1 queries Bullet.n_plus_one_query_enable = false # Detect eager-loaded associations which are not used Bullet.unused_eager_loading_enable = false # Detect unnecessary COUNT queries which could be avoided # with a counter_cache Bullet.counter_cache_enable = false I haven't been able to find a gem that notifies of view-layer db calls.
Last year all talks were in English. I think, this year will be, too. 
yeah if you don't need a return each would be the normal one to use
Actually, there are other pure Ruby DeepLearning frameworks that work with GPU (CUDA). For example red-chainer. https://github.com/red-data-tools/red-chainer I want to promote the red-chainer. but I do not think documentation of red-chainer is good. Developers are Japanese. We are not good at English. I think Readme of TensorStream is far attractive than red-chainer. Author is not lazy.
I re-wrote my testing and benchmarking, and it looks/works tons better. thanks. When it comes to using array.each vs while, I'm have troubles figuring out what to do when I have an array such as &gt;|2|3|5|2|6| because .each wouldn't be recursive. So maybe ill take a peak at reduce
What is “doing good”? Does it include MAGA? Building a wall? Supporting the 1st and 2nd Amendments? 
Is there an estimate for how much tickets will cost?
“I don’t understand Ruby, please help me understand how to write a compiler in Ruby.” Snark aside, perhaps you could be more specific about what you don’t understand here? I read the article and the code is pretty simple and straightforward. Then again, I’ve been coding Ruby for about 10 years now so “simple” is relative. The one thing to understand about Ruby is that it’s a very idiomatic language, i.e. while it has many concepts that are borrowed (and similar to) other OO languages such as Java or Python, Ruby emphasizes certain design patterns and a certain way of thinking in order to get the most out of it. My guess is that it’s more the patterns that are giving you grief than the concepts themselves. That said, the canonical reference to Ruby is the “Pickaxe Book”, i.e. [Programming Ruby by Dave Thomas et al](https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0). Yes, it costs money, but if you’re serious about learning Ruby it will be well worth the investment. Cheers!
That's a very cool location.
Good points! Indeed at the very least you need to keep the counter so every thread/process cannot access it. But for that you don't need cycle, simple modulo will do.
&gt; I don’t understand Ruby, please help me understand how to **write a compiler in Ruby**. It was never stated by the OP. They wanted just to _read_ some (pretty basic) compiler tutorial -- we can assume that it is just to understand principles or to reproduce an approach in another language.
If you're just trying to put them in order you can use .sort on Array [https://ruby-doc.org/core-2.2.0/Array.html#method-i-sort](https://ruby-doc.org/core-2.2.0/Array.html#method-i-sort)
&gt;Vladimir Makarov is paid by Red Hat to work on GCC and now CRuby. I thought he was working on Ruby in his own free time and outside of Redhat capacity?
[https://www.ruby.or.jp/en/](https://www.ruby.or.jp/en/) &amp;#x200B;
`LD_LIBRARY_PATH` ?
I haven't changed that environment variable. So the path to the libraries I created needs to be set in LD_LIBRARY_PATH variable?
&gt; I see a strong correlation between the size of the startup industry in a country (amount of VC) and how likely you are to find a solid Ruby market. Actually I see a strong correlation between the median Web Developers Salary in a country and how solid the Ruby Market is. There are lots of VC money in Germany too, the point is once Developer Salary becomes high enough the cost of using Ruby Rails, even thought as of today it may only bring 20-30% productivity gains while using 2x the server cost, would still make sense as the saving of time / salary is worth it.
Mostly got tired of typing out similar hostnames while playing with servers, or doing a ton of nested map / flatmap shenanigans.
yes, pretty sure. `*.so` files are shared objects and when you want to link against them or run your executable against it, the `LD_LIBRARY_PATH` environment variable should be set. There could stillt be other problems, but I think that one is the most promising if you didn't set it yet.
Thank you so much. It worked!! 
Thanks mate, I should be going to this one :)
I created a layer with some common gems including pg and native libs. [https://github.com/BranLiang/aws-ruby-lambda-layer](https://github.com/BranLiang/aws-ruby-lambda-layer) Hope this will help you.
For these kind of puzzling errors it's a good idea to run the code through Ripper. Ripper.sexp fails on this as it's not parsable, but stepping back to Ripper.lex reveals the difference between the two defs.
West coast is just too expensive for everything at this point.
I think going a tutorial-only approach is a bit hard. Best results will be if you write code on your own, IMO. Some of the code is not great or necessary: class Token attr_reader :type, :value def initialize(type:, value:) @type = type @value = value raise InvalidTokenError if value.nil? || type.nil? end def self.null @@null_token ||= NullToken.new end def self.end_of_file Token.new(type: 'EOF', value: '') end For example, there is absolutely zero reason to need a @@ there. 
Agreed.
It is related to the situation still, because Federico used semi-advanced concepts in his code, e. g. "def self.method" or @@ variables. I do not think it is easily possible to just selectively pick any tutorial and assume that it can explain all parts equally well for any random ruby code out there. The only real way to grasp it is to write code on your own. Even quite nice tutorials such as https://pine.fm/LearnToProgram won't easily cover all parts of ruby equally well. &gt; I frequently have the same need for different languages Yeah but you also most likely wrote a LOT more code in ruby past this point so it is not a fair comparison. There are a tons of deviations possible - a lot of the ruby code out in the wild feels totally alien to me, in particular a lot of the "functional" style to write stuff or rails code in general. It's very hard to fully understand how people write code, in particular as ruby keeps on changing. I was confused about the keyword syntax for example; and I am still not sure to have fully understood the difference between &amp;block use and yield if block_given use since they seem to, at the least, partially overlap. Ruby is not necessarily the simplest language possible.
There is a reason why people do not recommend it - and it has NOTHING to do with his rants. I find his rants quite amusing, but the tutorial is awful. Why? Because it is hugely unidiomatic code. He wrote it a lot like C; a bit like python. And I have heard the same from python folks who stated that his python tutorial isn't idiomatic python either. As long as people keep it in mind this is ok, but many people who go there don't even know that and assume this to be idiomatic code in either language, which it is clearly not.
&gt; I miss _why. Well. He was very creative and productive. I think it is bad to want to disappear because your reallife name is known. Also a shitty move by the dude who did so too, by the way.
&gt; Ruby emphasizes certain design patterns and a certain way of thinking in order to get the most out of it. This is utterly wrong. Precisely because there is MORE THAN ONE WAY to do something, the ruby syntax is very flexible. And while I think lots of the syntax is wrong, in particular most recent additions in the last 3 years, it follows from this philosophy, including the fact that ruby is multi-paradigm. So, no - there are no "patterns". No nothing. You adapt ruby to what you need. And no, ruby has not borrowed from java or python. You clearly have not used ruby before.
There is a link on the site but registration is $300, all inclusive! Meaning your room, meals, swag, and everything else is included!
Isn't your book a copy of an existing tutorial ? [http://apionrails.icalialabs.com/book/chapter\_one](http://apionrails.icalialabs.com/book/chapter_one)
What's the end goal? Moving files? Interacting by command line?
Wrong sub buddy
What's the sponsorship commitment? I'm interested but need a bit more concrete detail to bring it to my CTO.
You can find sponsorship info on our site! [This link](https://rubybythebay.org/sponsors.html) details the different levels and feel free to DM me if you have any specific questions.
Sorry I thought doing good was inclusive. 
Very nice. I wonder if it makes sense to add `Globs.puts` to output each result to stdout? 
FYI: Added Ruby by the Bay to the [Ruby Conferences in 2019 Calendar](https://planetruby.github.io/calendar/2019) @ Planet Ruby. Cheers. Prost.
controlling a script or program 
We sort of agree; more VC money usually equals higher salaries, the two generally go together. BTW Germany came a long way in VC but it is still peanuts compared to the US and only about half what UK is getting (with UK having a smaller population). I hope it grows more because it will take the entire European market up with it.
Looks interesting
I think the intent is clearer without the metaprogramming. 
never. I would like to see other people opinions if there is any apps on google store
I'd personally argue against a `Globs.puts` simply due to separation of concerns. This library is doing one thing and doing that thing well, as is the Unix way 😀 the method would be a replacing something simple like `puts Globs.expand('some_{1..3}_glob'). join ('\n')`
Theres also [ruby motion](http://www.rubymotion.com/) for cross-platform apps.
Wouldn’t even run on my system, and they rejected giving me support. Had to refund it
I think the project is cool and interesting but I would love to see the performance tests.
It hasn't been updated since 2017, so I'd be a bit weary that the project isn't supported any more.
I agree - while it is cool that you can, it is clearer without.
`TCPSocket` can do that without any security. If you want security, you get to use some of the OpenSSLsocket stuff, which is a huge pain. The lazy but safe way is probably making the server listen on localhost, setting up port forwarding with ssh, and connecting over that. 
Looks like the sponsorship information is missing from the English site. Corporate sponsorship: [https://www.ruby.or.jp/ja/sponsors/](https://www.ruby.or.jp/ja/sponsors/) Personal sponsorship: [https://www.ruby.or.jp/ja/sponsors/donation/](https://www.ruby.or.jp/ja/sponsors/donation/)
To be fair, puts is variadic, it'd output an array with newlines anyways :) In any case I'm not against adding new features to the library, even if somewhat redundant. To be fair all code ever written is technically redundant binary, just in a prettier package.
This is a great ledger, enjoyed reading it! I hope to steal this idea for 2019 :)
This is pretty neat! Nice to see a simple, easy to understand article on how OCR can be used in Ruby. Any information on how fast this process was for all these future dank memes?
If the common case (which, arguably remains to be seen, but from my experience is this) is to output each expansion to stdout, why force everyone to `join`?
OPs example mentioned hostnames, which tells me that it probably wasn't created with stdout in mind but for networking tools or something similar. It's not a bad thing if it's there, I just think it's an unnecessary feature. That being said, I'm not the maintainer and won't be bothered if it's added. Just a dude with an opinion 
I think is working on ruby on his free time also. 
RubyMotion has come a long ways. They have a starter edition now which you can get for free. Pay to remove the splash screen.
Thanks a lot for your feedback! Unfortunately, the script is a bit slow. I just ran it against a sample folder of 600 screenshots and it took around 19 minutes to finish. 1139.43s user 104.85s system 139% cpu 14:52.19 total I wanted to use threads to run the script in parallel, however; it turned out to be a huge overhead. It hogged my CPU to a 100% and took more time than the linear version.
Is there a significant performance difference between the Ruby implementation vs your earlier Python script? I figure the cpu load comes mostly from image magick, no?
Also you never mentioned what the average image dimensions were, have you tried downsampling to see if that could improve the OCR speed? I'm not super familiar with tradeoffs for OCR accuracy is performance but I'm curious if you need those full-res screenshots all the way through the whole process. Another cool idea would be to slice off all but the bottom 1/3 of the image where the subtitles will be, that should reduce overhead too if all the images have captions in the same relative location.
As a Ruby dev, I found learning Xcode and swift to be easier than I expected. Everything has a learning curve, and I don’t see the point of dealing with the rubymotion learning curve when you can learn Swift for a tad more effort. Rubymotion may be a little easier to pick up, but being able to do things “the real way” will always work out better plus you have another high-value language in your skillset for future jobs. 
I have not, mostly as I don't use android. I also don't want to because of Evil (aka Google). Having that said, I'd wish there would be a lot more folks driving ruby's GUI/WWW use (well aside from rails too). GUI components are usable in ruby e. g. ruby-gtk but it could need a lot more momentum.
Ugh ... swift ... How can you manage downgrading the code you write? :)
&gt; doing that thing well, as is the Unix way There is absolutely nothing wrong with Globs.puts. Not that I would need it, but your comment does not make a whole lot of sense to me.
I don't think it is needed really. People already get the Array - they can play with it on their own; don't need one. Although one could also reason that Glob could support commandline-output directly, but this seems such a minor thing to even want to argue about either way ...
Great, I searched a small project to rewrite as C extension with Ruby. Maybe I'll take a look at this. This can be pretty simple
It's just an Array. I mean, come on folks ... ruby array's are simple to work with: array.each {|entry| puts entry }
Eh, but that's closed source.
For anyone else: [this is the full script](https://gist.github.com/aonemd/7bb3c4760d9e47a9ce8e270198cb40a0) (I had trouble finding it) For OP: why have a link to "the full code" that doesn't link to the full code? You went through the trouble of putting it into a gist, creating a link to the code, then hide the link to the gist before the "Results" section. Personally, I find it easier to look at all of the code while reading the section-by-section breakdown, I like to be able to look at a smaller block in context. This is pretty neat. Thanks for sharing!
I use Tesseract OCR library to pull the text from the top 50 memes on a few meme subreddits every 5 minutes, and then make the memes searchable by text on https://memebay.io/ Each meme is processed in less than a second. 
you are posting to let us know you're going to write something in a month? 
Veery interesting article. Thank you very much.
so this is not using ML, but plain old OCR, correct?
I love Python syntax but I hate PIP, the dependency manager. By default, you just write a requirement.txt file with pip librairies needed without their version... seriously...
Because of a case like this "Hello, world! Yes?".gsub(/[[[:punct:]] ]/, '-') # =&gt; "Hello--world--Yes-" vs. "Hello, world! Yes?".gsub(/[[:punct:]]/, ' ').split.join('-') # =&gt; "Hello-world-Yes" 
The Python version takes only ~4 minutes vs. 14 minutes for the Ruby script on a sample of 525 image files. Here's a time comparison between the two scripts: python3 ocr.py 277.92s user 31.38s system 141% cpu 3:37.85 total vs. ruby ocr.rb 864.69s user 62.12s system 136% cpu 11:19.01 total Here's the [Python script](https://gist.github.com/aonemd/7bb3c4760d9e47a9ce8e270198cb40a0#file-subtitle_extractor-py) by the way. Yes, I believe that most of the overhead comes from the image processing with ImageMagick. For the Python script, I used [Pillow](https://github.com/python-pillow/Pillow) to load the images and process them. It seems to be amazingly fast compared to ImageMaigck.
All the images are 1920x1080. I believe this would improve the text recognition yet again, it will worsen the time taken to process the images. It would be great if I could replace ImageMagick with something lighter and faster. Great ideas by the way.
That's a very cool project you have.
Sigh, Another Area which needs improving. I wonder how much are people willing to spend, just to hire a person and get all these together, Social Media, updating pages, International Sponsorship. 
You're welcome! Glad you enjoyed it.
[RubyConf AU 2019](https://rubyconf.org.au/2019) is coming up in early February. Tickets are closing this Friday.
Good article - I don't think I would have had the energy to research on my own and then write an article so props for this.
Old means bad?
Thanks!
Ahhh, you know the other thing that I've seen take a bunch of time is using open3, iirc it added like 100-400ms to some shell stuff I had to call in another project. Damn, Ruby needs better image processing. That pillow library is sweet. In JavaScript I've used [sharp](https://github.com/lovell/sharp) and it's been pretty darn fast for my purposes.
Could you link from the main article to just the raw .rb file? I saw a link here but it is a link to a .py file. It's nice that the blog article explains what the .rb script is doing but it is hard to see it all in one place with the various "..." placeholders on the main article.
[The Ruby script](https://gist.github.com/aonemd/7bb3c4760d9e47a9ce8e270198cb40a0#file-subtitle_extractor-rb) is in the same gist. I added the Python script to compare between both scripts.
What have you tried this far! Are you getting an error message?
I can post from database into forms and store into database. I cant seem to figure how to store what is inside the textarea. almost no documentation on sinatra. and with the login I dont know where to start
How are you debugging? Try using the pry gem and throwing a binding.pry right before you store your input in the database. You can make sure it's being sent and examine what is in the params. Are you sure your text area has a name attribute? 
do u mind if I pm you. to make this a bit faster?
Do you have the code available to view, GitHub perhaps?
is a team project and the code is all messed up I can show you my code if u add me on discord. if is not to big of an issue
Is this for a job interview? 
no is for a project i am working on
We have [ruby-vips](https://github.com/libvips/ruby-vips), a wrapper around [libvips](https://github.com/libvips/libvips). Libvips is blazing-fast compared to ImageMagick, and unlike MiniMagick, ruby-vips doesn’t shell out, it calls libvips’ C functions directly.
Ah. I don't use discord nor am I on your team. Maybe sync up with your teammates this weekend to work on it?
If money is an issue you should definitely apply for a scholarship! You can find the link to apply on our main page about 3/4 of the way down :)
The Well-Grounded Rubyist is a good book that covers language features in a way that is useful for newcomers and not dumbed down.
Just like with Rails, or indeed any other programming language/framework, I find the best way to learn something is to use it in your next project. What's the next thing you would build in Java? Build it in Ruby this time! If you're looking for good tutorials, I've found [Pragmatic Studio](https://pragmaticstudio.com/) really good. Textbook-wise, [Eloquent Ruby](https://www.amazon.co.uk/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104/ref=mp_s_a_1_1?ie=UTF8&amp;qid=1547402874&amp;sr=8-1&amp;pi=AC_SX236_SY340_FMwebp_QL65&amp;keywords=eloquent+ruby&amp;dpPl=1&amp;dpID=414gR4dCXiL&amp;ref=plSrch) helped me no end. [Build Awesome Command Line Apps With Ruby](https://books.google.co.uk/books/about/Build_Awesome_Command_Line_Applications.html?id=WT0dngEACAAJ&amp;source=kp_book_description&amp;redir_esc=y) gave me a whole load of apps that I've used to baseline my own solutions. If you're looking for something that might melt your head, coming from a Java background, try [Metaprogramming Ruby](https://www.amazon.co.uk/Metaprogramming-Ruby-Program-Like-Facets/dp/1941222129/ref=mp_s_a_1_1?ie=UTF8&amp;qid=1547403128&amp;sr=8-1&amp;pi=AC_SX236_SY340_FMwebp_QL65&amp;keywords=metaprogramming+ruby&amp;dpPl=1&amp;dpID=51sqZ5BY7iL&amp;ref=plSrch).
[POODR](https://www.poodr.com/) is good. It's lessons aren't really Ruby specific, but it's a good way to explore the OO side of Ruby, which is my favorite part. I think you'll think about OO differently after reading POODR and using Ruby for a while.
fpm is pretty neat. "One package to rule them all". It slowed down a little but hopefully people can still remain interested so that fpm can remain relevant. We also recently had machomebrew support linux - it's a bit rough (I had problems installing it for example) but again I hope they can keep momentum. Homebrew actually has quite a lot of momentum right now - hopefully several linux folks will jump on board now that linux support has also been elevated along with mac support (which was how the project was started anyway). As for learning ruby, well. I don't know MHartl so I can not recommend that (or not recommend it). If you already know java then the OOP part of ruby should be simple for you - just keep in mind that ruby does not use the same model and is in many ways much simpler at all times. Focus on what you wish to do, then just write the ruby code and don't worry whether it is good or not. Practice will help a LOT. I recommend the old chris pine tutorial learn to program. While this is for newcomers, it will also help you grasp the basic parts of ruby; then build from there. The pickaxe is also fine, but I think the best, and only real way, is to just dive in and keep on writing ruby code. Ideally when you already know what you want to do. If fpm is your fancy then work on that if you want to. I also recommend to start writing gems as soon as possible - you will learn a LOT. And if you are interested in fpm, you could always see to extend it - perhaps even with homebrew, then we could have a huge unified package manager under ruby to RULE ALL THE PACKAGES. I think playing with ruby may be easy too, via irb or pry if you want to. In ruby you can write really concise code while still having it readable (but avoid syntax you dislike or that you "feel" is at odds with the rest of the code).
I would recommend to also add some date to the list; while links are fine (the dates will appear there), it may be simpler for people to just look at when suggestions were made, e. g. the year, and perhaps also the month. &gt; to see what it takes to contribute I think it should be mentioned that you aren't a newcomer really; it will probably be somewhat harder for newcomers, who are probably the primary target audience, to suggest changes and have these changes approved eventually.
Forget everything you know. Just kidding. My java experience is quite dated, but this is ruby in a nutshell... Ruby is a duc-typed language, meaning any variable can be replaced with a value of any type. In ruby, there are essentially no primitives. Array, Integer, String, TrueClass, FalseClass, and Nil are all Classes. Private, Protected and super exist, but because classes are open, anything can be replaced or mutated at runtime. Threading exists, but the ruby interpreter you use will dictate if real threading is used. Memory management is a crapshoot. Ruby will allocate more memory as is required, and garbage collect as required, but it never frees allocations. Last but not least, the most common object youll encounter will either be a Hash or an OpenStruct. In PHP these would be akin to stdClass, and in java, an object with a public attributes map. Exceptions are confusing not because they exist, but the language doesnt do a great job of describing when an exception is raised or a StandardError is raised. (Basically Exception is the ruby vm throwing an error, and StandardClass is the root of most runtime errors). Namespaces are open, too. Its easy to replicate existing java namespacing patterns, with the tradeoff that linting and code inspection tools like rubocop will complain. (once your namespace depth makes the code indentation far, you will quickly sacrifice the LineLength lint metric). One of ruby's strengths is the ability to provide lambdas to other methods for flexible means of common processing. As far as I am aware in java, youre stuck creating an interface, defining an property which accepts said interface and replacing the implementation where required. In java, beans represent precompiled sets of code, whereas in ruby, gems represent the same. Hope this helps
This book + for begginers learn ruby the hard way are the most influential/ commonly proposed solutions :)
You might enjoy the classic - 10 Things Every Java Programmer Should Know About Ruby by the (late) legendary Jim Weirich - &lt;http://slideshow-s9.github.io/demos/10things&gt; Source: &lt;https://github.com/slideshow-s9/samples/blob/master/10things.md&gt;
The big alienating change is that Ruby has no type safety. So a big feature you've leaned on for safety and correctness is just not there anymore. at least for me this was quite disorienting. What I learned was to fill that safety hole with good tests, which is ultimately a better solution in every way. Aside from that, Ruby is a lot like Java, just much simpler and better. Have fun :)
Thank you for pointing that out. I actually replaced ImageMagick with libvips and the runtime decreased by 3 times.
I think the biggest thing for me to wrap my head around coming from C# is that in Rails your models don't have as..."concrete" a file as you do in more statically typed languages? So if I wanted to know the properties of my models I had to look at the DB schema file or start up a Rails console to know what was available to me. I think it's cool that Rails can generate a lot for you, but at the same time I feel as though "magic" is less enthralling than it would seem to be.
Java has functional interfaces now that can be implemented and passed around. It’s still statically typed and there’s quite a few functional types so it’s nowhere near as nice as passing a block, proc or lambda to a method in Ruby. 
Look up Learn Ruby the Hard way. I came from a c# background and that book got me up to speed.
I was looking to contribute to fpm actually, I reported a few issues that if I was proficient in Ruby I would have contributed directly to solving it. I remember using a gem to if I recall correctly install fpm but I'm not sure what they are. What's the closes thing to a Ruby gem in Java?
Eloquent Ruby seems like a good book to jump into Ruby coming from another OOP language. I'm also a command line advocate so I appreciate the link. Can you give me examples of any command line apps you've built with Ruby?
Wow that's really cool! Thanks for pointing that out /u/janko-m
\o/ One of the few gems I used almost all of the time (I have a template file, which I convert into markdown, through kramdown, after pre-processing it; the markdown is then the one that will also be shown on rubygems.org).
i forgot to describe traits. these can be accomplished in ruby by declaring methods in the same module as another class is declared, and leveraging the "include" keyword. 
No.
It's going to be tough. Stanley Kubrick, speaking shortly before his death in 1999, revealed that the portrayal of aversion therapy in his film _A Clockwork Orange_ was directly inspired by footage of Java programmers being taught Ruby. There are some tough habits to break, my droogs. https://www.quora.com/Why-did-Alan-Kay-dislike-Java 
You want to do ``` x = MyNumber.new(1) ``` And have x be 1? Well why not just write `x = 1` directly? What are you trying to achieve? Do you instead mean that you want it to be printed as the value it got in the constructor? Use `to_s` to override how the object is converted to a string, which is what printing does. ``` class MyNumber attr_reader :value def initialize(args) @value = args end def to_s value.to_s end end puts MyNumber.new(1) ``` But this is not the same thing as 'being' the value. If you don't see the difference say so.
Once again, and with gusto: *PLEASE* put some kind of summary about what the F kramdown is IN YOUR POST. This post is entirely devoid of information unless you're already using the damn gem. I do not for the life of me understand why posters continue to do this.
You must be fun to work with.
Go through the short, CS-puzzle based exercises at https://github.com/JoshCheek/ruby-kickstart Gradually Cover all aspects of the language while refreshing your CS-fu. Short, addicting and extremely fun. 
Nit: I think IRB/Pry use `#inspect` instead of `#to_s`, but your comment holds for both
I'm learning testing (RSpec), and in sample test decided (to better get OOP) that object should act like object, not like module. I tried to abstract example. OK I want to make class "NumberFromRoman". Being initiated it should get what passed (Roman number "V"), convert it to number 5 and be that 5: `expect(NumberFromRoman``.new``("V")).to eq(5)` But found that I don't know how to do it (so was the purpose) Where should I start?) I feel like I'm missing some very deep OOP (Ruby?) concept &amp;#x200B; And about indent, yep, I just used tab and felt that it's ugly, but thought it would be more consistent here (on Reddit)
&gt; that object should act like object, not like module Sorry I don't understand what you mean here. What what object should act like an object how? And how is it different from acting like a module? I don't know what you mean? &gt; Being initiated it should get what passed (Roman number "V"), convert it to number 5 and be that 5
&gt; I want to make class "NumberFromRoman". Being initiated it should get what passed (Roman number "V"), convert it to number 5 and be that 5 It sounds like you want a function, not an object. `number_from_roman` would return the value of the conversion, not an object which wrapped the value from the conversion. ``` expect(number_from_roman("V")).to eq(5) ```
I think it's naming issue, but I just want it to be objet. Lets say ArabicNumber ArabicNumber.new("V") + ArabicNumber.new("3") == 8 &amp;#x200B;
But you want the `ArabicNumber` to _be_ the number? This isn't a concept that Ruby has, so I'd recommend stop trying to achieve it. What is possible to override equality and other operations. You'll have to override both `+` and `==` to achieve what you want. ``` class MyNumber attr_reader :value def initialize(args) @value = args end def to_s value.to_s end def +(other) MyNumber.new(value + other.value) end def ==(other) value == MyNumber.new(other).value end end puts MyNumber.new(1) + MyNumber.new(2) == 3 ``` I've done just enough to make your demo work there. In reality you need to do a lot more work to make both these override operators work as expected in all cases. However, defining your own numeric type like this is going to be an _advanced_ topic. It's interesting to talk about how to do it, but it's not something I would recommend for someone of your level of knowledge of Ruby. Here's an example of where Ruby's standard library is doing what you are attempting to do, and how complex it gets. https://github.com/ruby/ruby/blob/edb65a6254a1e06bb2155678676d6798acd7a51e/lib/matrix.rb#L1018-L1043
I think I start getting the idea. Thank you. Yes, I want it to act like number. So actually I want to make a subclass of Numeric, right? And you just did some part of what I want. And the name to it will be SomeCustomNumericType. So isn't it usual thing to do in programming? Like: &gt; c1 = Cost.new(100, "USD") &gt; c2 = Cost.new(20, "USD") &gt; puts c1 + c2 =&gt; $120 Is not it made often? Or when it happens it is that custom numeric type?
Yes a subclass of `Numeric`, with operations and coercion. There are lots of examples I could give you in Ruby, but compared to how much code gets written I wouldn't say it was really a common thing for most application programmers to do. Unless you are very careful, even an expert programmer is likely to not do this very well, and I'm not aware of any documentation of how to do it well.
I see now. Thank you very much for your time. I think I'll digest it all and get properly.
You were downvoted but I agree with you.
Probably because it sounds like it should end with "... and get OFF MY LAWN!" :-) But thanks for the support.
I started off as a Ruby programmer and moved to Java, you're going to love arrays and hashes my friend! As with most OOP langs, its all syntax as far as learning. Learn the method signatures, data types, class syntax, then just go make some stuff... The toy robot challenge is always a good way to test your newfound knowledge and to have a look at people solving the same problem and learning from it.
If you're into it, the trick to make that work is to specify "one or more" of these with `+`. ``` .gsub(/[[[:punct:]] ]+/, '-') ``` That would do the deed you seek.
You'd use it for shared examples and around filters. rspec-rails uses described_class to figure out if you're testing a controller and do controller setup. 
&gt; What's the closes thing to a Ruby gem in Java? Maven dependency, I suppose? A better analogue would probably be a deb/rpm package. With `gem install foo` command, you install the `foo` gem and all dependent gems, just like you’d install a Debian package and all dependents with `apt jnstall foo` (or `yum install foo` on Redhat; sorry, not familiar with fpm). Just like a Debian package can install libraries or executables, so can a gem, too. For example, `rails` gem will install the libraries you need for Rails app development, and also the `rails` script you can run. And just like deb packages come in `.deb` files, gems are also tar files with extension `.gem`. A close relative to `gem` executable is `bundler`, which reads `Gemfile` (basically `pom.xml`) and installs all gems your app needs. As an example, see [`Gemfile` of the `rails` gem](https://github.com/rails/rails/blob/master/Gemfile).
I just use it as a matter of course. Makes it very easy to change a class name later, sure, yes. Also makes it trivial to copy and paste something to somewhere else.
Maybe. Can't get past them being completely uninterested in the software being literally unusable for a new customer. They decided it wasn't worth their time to have a workable out of the box experience so it's not worth my time to give them another shot, improved or not
We use it a lot where i work, it makes it easier to change class names (happens in quite a few cases - particularly when we extract base classes from something), and namespaces. It also makes it easier to refactor to shared context and examples if need be. 
RSpec Rubocop tells me not to use it, so I don't. Not because I am opposed to it, but it's nice to have consistent standards you won't have to think about.
I don't always agree with Rubocop defaults. This is a good example. 
I see it is a way to keep your tests DRY &amp;#x200B;
I see it is a way to keep your tests DRY &amp;#x200B;
Definitely use it all the time, very useful when you think a class or module name might change. Also: allows you potentially to re-use spec code from one class' specs to another (or in shared examples, as mentioned).
(Not taking sides here, just explaining) You are probably right, but TBH it never appeared to me before your comment (so it could've been never appeared to author, too) -- in my head, kramdown is pretty much everywhere and "everybody knows it", so your requirement at first sounds like "you are announcing new version of Rails, but what is this thing?.." :) But it is just my cognitive distortion.
I use it a lot for the same reason most of the comments here already pointed out but i want to add a new one: - If you are TDDing is very common to start the tests without knowing the exact final names or class structure so described_class just make it a lot easy to refactor. 
I don't always agree either and you can change the rules, but when I don't have a strong opinion about it I just go with it. It's just not worth arguing about imo.
Isn't it telling you the opposite? https://github.com/rubocop-hq/rubocop-rspec/blob/master/lib/rubocop/cop/rspec/described_class.rb 
Hm, the default looks to be to use it: https://www.rubydoc.info/gems/rubocop-rspec/RuboCop/Cop/RSpec/DescribedClass https://github.com/rubocop-hq/rubocop-rspec/blob/master/config/default.yml#L80
It might be a false positive, have you contacted any of the nice people from the rubyinstaller.org project? You can open an issue here: https://github.com/oneclick/rubyinstaller2
We stopped using it because it makes the tests a bit harder to read. Same with the subject thingy.
Chris Pine?
Can you provide the checksum of your installer? The file I downloaded (SHA1: 15e457a23fcd4386c06fefff50a86c7395150186) is perfectly clean.
Have you tried `subject)(:foo) { described_class } `? It keeps `subject` semantic but lets you refer to `subject` by descriptive name.
Reasons I use: 1. Shared examples. 2. Sometimes class names get long or have name scoping, described_class is always consistent. 3. Takes a few less thought cycles when I'm writing tests. If I'm always writing described_class I never have to go back and check my spelling, capitalization, etc... If the actual class name.
Yeah you can definitely achieve the same result without it. I like it particularly because it segments scopes based on the table they modify, but I can see an argument either way.
rspec-rubocop has gone off the rails with their default rules. There are a number of examples of this, such as the rule that there should be only one assertion per example. I wouldn’t trust that project’s defaults if I were you. 
It’s very common for examples of even whole contexts to be copied and pasted into specs for other classes many times I’ve found specs that were testing the wrong class, which would have been easily fixed by the original using `described_class`. 
There's also standard.rb now which could resolve a lot of these things.
i agree, i find they both make tests harder to read/understand/change later. 
That's also more like what the docs suggest: https://relishapp.com/rspec/rspec-core/docs/subject/explicit-subject &gt; A named subject improves on the explicit subject by assigning it a contextually semantic name. Since a named subject is an explicit subject, it still defines the value that is returned by the subject method in the example scope. However, it defines an additional helper method with the provided name.
I have had a similar feeling and still do. A lot of this has to do with the fact that python is quite different. I'd call it a ... function-first OOP language, meaning that some ways are different - or outright retarded. Explicit self is by far my biggest complaint. After working through two python university courses that helped quite a bit, once you adjust to that and realize that it's just very different from a conceptual/philosophical point of view. E. g. when you use list comprehensions. Syntax-wise the differences are not that massive IMO and ruby and python are in a similar boat. PS: I have to use my other account again because reddit thinks there is "suspicious activity" with my other account, whatever that even means. Not very logical if I can just log in into another account and use that just fine ...
I've been there myself, only for me it was Python, JavaScript, PHP, C++ and C#. I'd put semicolons in Python code dollar signs in JS, you name it. IME it fades with a few decades of experience.
That might have been how it started, but in a conference talk he said that they are giving him time to work on Ruby now. I don't remember if it's full time or part-time. 
Looks like things get a bit messy dealing with Lambda cold starts http://rubyonjets.com/docs/prewarming/
Hardest part for me is not having a clear way to tell what functions are mutating the data and which are pure, all the way through the standard library.
No joke, I nearly went crazy dealing with this at first. I don't think I'll ever forget that *list.sort* doesn't return the sorted list.
Can you elaborate on how the tests are harder to read because of that?
Exactly this. In a big app lots of very similar objects and specs tend to exists. It’s. Just way easier to create new objects by copying with little to no modification. 
Looks cool, bookmarked.
\+1 for comfy mexican sofa
I used to love Ruby. Now, I like Python. Unfortunately: &gt;“There are only two kinds of languages: the ones people complain about and the ones nobody uses.” &amp;#x200B; The idioms are really different, It takes time to become pythonic. Even more if you come from a gorgeous language such as Ruby, I believe. &amp;#x200B;
I was writing some ruby code recently and accidentally put down a "for v in variable" and then smacked myself.
I still forget about some methods even after many years of using Ruby, especially when I'm trying to remember if something has a side-effect or not This is a small gem that I wrote up after watching some videos on Smalltalk's Pharo where you can find methods by example. This gem will run through methods and find which ones give you the output you want. You can search for methods with side-effects or without (default). You can match return values. You can pass in a list of args as well as a block Don't install it in production of course
You are right but as /u/zverok_kha said I also didn't think that this was necessary for \`kramdown\`. &amp;#x200B; So: kramdown is a Markdown-superset parser and converter, written in pure Ruby. It is used, for example, as default engine for parsing Markdown with Jekyll and Github Pages.
Shared examples accept parameters: [https://relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples](https://relishapp.com/rspec/rspec-core/docs/example-groups/shared-examples). It is also fine to namespace RSpec.describe block like the unit under test.
This is a minor thing, but the builtin methods in Python seem "backwards" to me. It interrupts your reasoning when chaining together methods. For example, `''.join(map(chr, [102, 111, 111]))` Compared to the same thing in Ruby: `[102, 111, 111].map(&amp;:chr).join` To me, the Ruby version is more natural to think about and to write in one go, because it's left-to-right, like shell piping. Python's feels inside out. I actually think the "Pythonic" way to write this would be in two or three steps, in the interest of being explicit -- but I'll defer to the Python experts on that.
Agreed about parameters. However, once you go that route, you have to go look up that shared examples and see what it expects. It's much easier in practice to let shared examples leverage provided told like subject and described_class to handle their business. Regarding scoping, etc ... Yeah, lots of ways to skin cats, still doesn't address long class names.
You can hardly have more than a few 
This is very cool. Great idea and cool implementation. I have similar problems all the time.
I'm there with you. I've used both for a while now and prefer Python
I second Olivier, this looks awesome.
Lol. Same for me, except it was`shuffle`. I'm glad to see this sentiment elsewhere. 
Usually "remote work" means US only.
i got that sense. i’m in the us. more was wondering if quality of life for some companies that have frequently posted on these job boards 
Why?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/rubylang] [suggest\_rb - tells you which method does the thing you want to do (x-post \/r\/ruby)](https://www.reddit.com/r/RubyLang/comments/ag6a12/suggest_rb_tells_you_which_method_does_the_thing/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Someone is that much retarded that he followed this bot link to downvote the thread in that subreddit that he does not even read.
FWIW I was [recently told by a member of the RSpec team](https://github.com/rspec/rspec-rails/pull/2042#discussion_r234690312) that "betterspecs.org are not recommended by us and contain many antipatterns."
Nifty implementation idea with the ruleset. Kinda tempted to riff off of that idea a bit later and play a bit. You might consider trying to add line numbers if you want to mention them in the article though, it can be a bit jarring.
Yeah same here. I do not like writing Python. It's a boring tool that does not really convey how I want to write software. I have to admit though that reading python code is much simpler than reading Ruby code for obvious reasons.
Proof? 
https://www.reddit.com/r/RubyLang/comments/ag6a12/suggest_rb_tells_you_which_method_does_the_thing/
That's not proof of anything. That post has zero points. So what? Maybe the community in that subreddit is different enough that they don't like this. Hell, under a hundred votes, everything is just noise. 
You could check the subreddit to see that all previous posts have 1 points because there is almost no audience there yet. But instead of checking you are just flaming because you are the part of the toxic Ruby community I mentioned above.
I'm not flaming anyone. I'm calling out the person who leapt to "someone is retarded" when he didn't get an upvote on his weddit post. Poor baby. 
Wow. Pot, meet kettle. Want a community to not be toxic? Don't be toxic yourself. Set an example.
That’s a pattern I’ve been using in JS for years and I’m really happy it’s now available in Ruby. 
Awful. I don't want to use stronger words so I'll stay with the word awful. &gt; You can find the original request (from 2012!) here. No, this is NOT true. Please separate who wrote what. Pablo Herrero, at the least not initially, did NOT suggest &gt;&gt;. Neither did he suggest yield_self. Now the only good thing is that we can avoid this, and focus on things that really improve ruby rather than this nonsense. I am also glad to have seen that I was not the only one with a similar opinion here - the "functional" crowd is just TERRIBLY at API/syntax design.
This is an interesting idea. I find the API a bit clumsy, but the idea itself is quite nice so I upvote on the idea (not necessarily the implementation but I understand that one has to use some syntax in order to express the idea).
It's a good idea. To me the API is a bit too clumsy but that does not diminish the idea itself.
For what do I need CoC links? Do people go to conferences because of CoCs? The plural form is also problematic ... :\
Yeah, I'm not in love with it. Any thoughts on what you might do differently?
Please elaborate on your point. The only thing I get from your comment is that you do not like this change, but you did not provide any reasons why you do.
You would think that almost 100% of the CoCs are just plain common sense, but if you take a look at some subreddits like /r/insanepeoplefacebook and others, and also trends like anti vaxxers, flat earthers, etc, you'll see that there are increasingly loads of fucked up people around who probably should read these. At least that's what I think this is about... Also, most seem to highlight the integration and diversification aspects of conferences, and again, these should be common sense, but it's good to have it said out loud like that.
People don’t go to conferences because of a lack of them. For many folk it is important. 
I'm not toxic, you are.
‘then’ will be dope. Lambda composition is YAGNI. At least looking at my current app, cannot find a single place where I’m deriving a value from an array of lambdas.
&gt;If you set null: false in your migration, Active Record will rewrite the whole table, locking it whilst doing so. Afaik setting \`null: false\` is a non-blocking operation but setting a default value is. It blocks it because it must update the whole table in a single transaction. But \`update\_all\` does the same thing and is also going to lock the table for few seconds (or minutes?). Here is what I usually do when I have to add not null column to a large table: class AddComposerToSongs &lt; ActiveRecord::Migration[5.2] def up add_column :songs, :composer, :string Song.find_in_batches do |batch| batch.update_all(composer: 'Lin-Manuel Miranda') end change_column_null :songs, :composer, false end def down drop_column :songs, :composer end end By updating records in batches it won't lock the whole table, just 1000 of rows at a time and just for few ms.
&gt; This all led me to think: Isn't there a way to turn an enumerable into an IO duck type Read can accept anything with a `to_io` check out the docs I wrote for puma. &gt; # An instance of `Puma::Client` can be used as if it were an IO object # for example it is passed into `IO.select` inside of the `Puma::Reactor`. # This is accomplished by the `to_io` method which gets called on any # non-IO objects being used with the IO api such as `IO.select. https://github.com/puma/puma/pull/1576/files Though it sounds like you already know that. I'm not sure what a generic `to_io` would look like on enumerable. I'm honestly not even what interface exactly the return type of `to_io` needs to be. 
Lambda composition is much more general than “I have an array of lambdas”. It’s also just a very thin layer of sugar, which ruby already has lots of. Why is this sugar undesirable, compared to all the other magic ruby provides? It’s purely a library change. 
I'm imagining smth like this: &gt; io = %w[a b c].each.to_io #=&gt; &lt;#EnumerableIO #read&gt; &gt; IO.copy_stream(io, "/tmp/example.txt") caveats being, I don't know exactly what the IO API lowest common denominator is. For this particular case, it must respond to `#read`. For other cases, you must implement `#write`. For some cases, the IO must be rewindable. Should be openable/closeable? IDK. Asking for low-level ideas/use-cases. 
I think this sugar will increase the number of inline lambdas that are written throughout the ecosystem, and I think inline lambdas are a common cause of confusion in ruby. The example submitted in the original PR is freaking stupid. Why would you want something that promotes less explicit and more confusing code? I’m sure there are better examples of code becoming significantly more clear and readable but I’ve yet to see it.
I implemented exactly this component as part of the [Down](https://github.com/janko-m/down) gem: require "down/chunked_io" Down::ChunkedIO.new(chunks: enumerator) The `Down::ChunkedIO` object implements `IO#read`, which fetches content on-demand from the given enumerator, so it can be passed to `IO.copy_stream` and should allocate virtually no additional memory (I carefully optimized the string allocation). Some other IO methods like `#rewind` and `#close` are also implemented. For uploading files of unknown size you can use `Aws::S3::Object#upload_stream` (which uses multipart upload): require "aws-sdk-s3" resource = Aws::S3::Resource.new(**options) bucket = resource.bucket("my-bucket") object = bucket.object("my-key") io = Down::ChunkedIO.new(chunks: enumerator) object.upload_stream do |write_stream| IO.copy_stream(io, write_stream) end By default, `Down::ChunkedIO` will cache content it retrieves from the enumerator to disk, in order to make itself rewindable. If you want to disable that, you can pass `rewindable: true`. Note that you'll also need to disable aws-sdk-s3's checksum functionality, as it relies on rewindability: require "aws-sdk-s3" resource = Aws::S3::Resource.new(compute_checkums: false, **options) bucket = resource.bucket("my-bucket") object = bucket.object("my-key") io = Down::ChunkedIO.new( chunks: enumerator, rewindable: false, ) object.upload_stream do |write_stream| IO.copy_stream(io, write_stream) end
I just noticed that ruby 2.6 now has something that could almost come close to implementing such an idiom. Or, at least, perhaps jut make it easier. https://drivy.engineering/ruby-lambda-composition/
[Ruby Warrior](https://www.bloc.io/ruby-warrior#/)?
Try to do something like: ``` class OccupancyGenerator def initialize(start_date, end_date) &lt;define instance variables here&gt; end def occupancy [@start_date..@end_date].map { |d| { date: d, occupancy: occupancy_by_date(d) } end private def occupancy_by_date(date) # make sure that start_date and end_date are indexed in the DB Booking.where(‘start_date &lt; ? AND end_date &gt; ?’, date).count/total_number_rooms end end @occupancy = OccupancyGenerator.new(date1, date2).occupancy ``` I don’t think you can easily avoid having to run one query for each date. You can always optimize later 
You could totally do this with just Rails/SQL. In my super experienced opinion, reporting shouldn't be built into Rails applications. I've seen so many startups build reporting and analytics logic into their core rails application and end up building all the same things that BI platforms provide. &amp;#x200B; In pure rails, I might do this by generating a series in SQL. [https://www.citusdata.com/blog/2018/03/14/fun-with-sql-generate-sql/](https://www.citusdata.com/blog/2018/03/14/fun-with-sql-generate-sql/) &amp;#x200B; If it were me, I'd probably be putting together this report outside of rails, using pure SQL, and either using the same series generation from above, or using a date/time dimension table as part of a star-schema denormalized analytics store: [http://radacad.com/do-you-need-a-date-dimension](http://radacad.com/do-you-need-a-date-dimension). I would query against the series/dimension table and for each date calculate the occupancy rate. &amp;#x200B; \`\`\`sql SELECT date\_day, count([b.id](https://b.id)) as bookings, count([b.id](https://b.id))/100.0 as occupancy\_rate FROM dates d join bookings b on [d.date](https://d.date) \&gt;= b.start\_date and d.date&lt;=b.end\_date \`\`\` &amp;#x200B; Or if there was no date dimension table, and just pure postgres, I would check out [https://stackoverflow.com/questions/14113469/generating-time-series-between-two-dates-in-postgresql](https://stackoverflow.com/questions/14113469/generating-time-series-between-two-dates-in-postgresql) &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
That's cool! I also implemented "Reader"-like interfaces in projects of mine, so I guess that there's already spread knowledge of this domain, that could be worthy of a (maybe ruby?) feature. I see that your ChunkedIO implements a lot more API than I was willing to have, like `eof?`, `readpartial`, or `pos`. Does any third-party require you to implement those? To sum it up, I am (for now) converging into a reader API. So: * There would be a `Enumerable#to_reader` * Outcome must **only** respond to `read` And an example of a spec could be: `%IO.copy_stream(%w(a b c).to_reader, $stdout)`.
The methods `#read`/`#eof?`/`#rewind`/`#close`/`#size` were implemented mainly to conform to Shrine's IO-like interface. The reason why Shrine requires them is because various SDKs require various methods (e.g. aws-sdk-s3 requires `#read`, `#rewind`, and `#size`). `#readpartial` was added for memory optimization; `#read` requires splitting chunks yielded by the enumerator in order to return chunk of specified length, but `#readpartial` does not (if specified length is larger than the enumerator chunk size). It was also natural to implement `#read` in terms of `#readpartial`. `#gets` and `#pos` were added for integration with ruby's `csv` standard library. E.g. that you can parse CSV as you're downloading data from the Internet. There are also additional features like rewindability (which you already saw), result encoding (binary by default), optional "on close" callback (called when `#close` is called), specifying size if it's known (returned by `#size`). I'm open to extracting this functionality into a gem, but if you would rather have a reader that implements only `#read`, maybe it makes more sense to continue using your implementation.
This is all subjective of course, but our team just do not feel it adds any value over just referring to the class directly. Sure it is repetitive, but it is how the code is actually used, and it makes for easier grepping. It also does not require you to keep context and bounce up and down in a large file to understand what is called where.
Yes we have, and we do not use that either. For the same reason as I replied above.
Nicely done! Keep up the good work
I don't think you can meet "the" community but there are places where you could get in contact with some ruby hackers. The IRC channel on freenode is an example. I am not sure of other community-centric places here - mailing list, official bug tracker ... perhaps there are some rails-related areas. You ultimately don't need a community though. I was not part of "the" php community when I was using php either, for example.
&gt; an explicit call by a class: MyClass.my_method &gt; an explicit call by an object: my_object.my_method But if a class is an object, as already pointed out correctly before on the article, then how would these two variants be different?
Surprised nobody mentioned Codecademy. Got me going. &amp;#x200B; [https://www.codecademy.com/learn/learn-ruby](https://www.codecademy.com/learn/learn-ruby)
I guess there's some IRC channels and such. "The community" exists primarily in open source software. So ... GitHub? Get out there, start writing code and using gems, finding bugs and contributing patches! 
Over the years I found it very valuable if specs share the common structure. This also includes things like name of variables. For example - if testing a service object, there reference variable if always named \`service\`. Using \`described\_class\` is a part of this idea in general. I don't really understand how it makes things easier for grepping if class name is mentioned several times in the file, instead of just one time in the main describe block. What would be example of this? If I would need to find a reference to the tested object in the context of current file it would be way easier just to know that in 99% cases its actually \`described\_class\`. This way also helps me to easily separate if the current name refers to actually tested object or an external object. If I see just two class names it might take me longer to actually distinguish which is which, don't you agree? :-) As for the context - this one I don't understand either. The fact that you actually have large specs files can be a sign of other problems. We really try to break things into smaller parts, so we rarely run into this problem. The reason for this might simply mean that there is just too much logic encapsulated into one class (and thus the spec). System/Feature/E2E (whatever current name is most popular) are often kind of exception, but often the name itself doesn't not refer an object at all in such cases. As you said, this is all subjective, so I am not trying to convince you. :-) The reason I wrote all this is for undecided people, who might stumble upon this thread and try to form their own opinion based on given arguments. :-) &amp;#x200B;
This only serves to demonstrate how so much of OOP is self-inflicted solipsism. 
Thank you for your question. Indeed. But here, I describe the different ways to call a method at the highest layer of the language. &amp;#x200B;
&gt;This only serves to demonstrate how so much of OOP is self-inflicted solipsism. what a quote ! 👍
Have you tried testing it with various problems? You can try to input it with the boards listed here: https://github.com/kaspergrubbe/sudokusolver_ng/tree/master/spec/boards Norvig has a nice writeup on the algorithms involved here: http://www.norvig.com/sudoku.html Norvigs code has been re-implemented into Ruby by someone, and I have then taken it upon me to make it run in newer rubies, you can see it here: https://github.com/kaspergrubbe/sudokusolver_ng The code isn't pretty, and the interface isn't great either, but it does solve Sudokus :) puzzle = "4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......" s = SudokuSolverNg.new s.print_grid(s.search(s.parse_grid(puzzle)))
I see, you already covered quite a few important and useful cases! I see this in terms of the Go interfaces: `Reader` must only implement `#read`. All the other cases seem like a subset that should be covered by another interface: * `RewindableReader` should implement `#rewind`, for example; * I don't know what to make of `#size`, that seems to be an AWS requirement for the signature v4 API; * `LineReader` should implement `gets`, although maybe the `csv` library could just read chunks and parse strings itself (?); and I don't know what to make of `#pos`, but guess it should be easy to implement even for the basic `Reader` case; Now, I guess that Enumerable could just implement a simple `to_reader` method, and the rest could be figured out from there?
I need a dictionary for that.... _Going to googling.._
Again.. Great article Mehdi!
Or maybe self.inflicted.solipsism
Yea, subjective is the thing here. I've been working with more or less the same team for like 12 years and this is one of the many small design decisions we have made collaboratively. Maybe its influenced by the tools we use (we all work in terminal based vim, and rely on keywords a lot for navigating the code). We are all also heavily influenced by making everything explicit and non-ambiguous as much as possible - why is the word "described_class" and not the actual class? Grepping tools often don't show a lot of context so it is more apparent where you are, and what the code is doing if you are browsing hits. I agree it is not ideal to have large files, but having a test file span more than one screenful is still pretty common in our test suites. Maybe not perfect, but what codebase is?
Becoming a part of [Ruby Together](http://rubytogether.org) would likely help
Awesome! thanks!
I still don't buy into the premise how refactoring solves all problems. There have been too many projects where the only real way to keep on moving forward was to just throw away the old parts and start anew. This is obviously not as good as being able to do refactoring, but there are code bases out there that are just HORRIBLE and AWFUL. You can't refactor much here when it is all crap. &gt; It’s code that someone else wrote and you inherit it for further work In 90% of the cases, when you see code that is not commented/documented then you know it will be total crap. A few of the other percents are brilliant, but they are still very often hard to understand and complex (or uses a lot of "meta"-features which are just terrible to want to maintain). Ruby is great but it is really really better to write simple code and document it properly. &gt; More often than not, your predecessors didn’t have enough time for &gt; proper maintenance, like keeping documentation up-to-date I hate writing documentation but it is necessary, for many reasons. However had, predecessors using any of the above are just finding excuses for why they could not comment/document their efforts. When the code is really simple and straightforward then it is not so important to document it properly, but often it is not simple at all. &gt; In a situation like this, everyone has to decide whether to build a &gt; new version of the app from scratch or refactor it. We went with &gt; refactoring because it’s our preferred approach. Nope - I don't buy it. The application was probably small and well written. This is most definitely not representative of real code out there in the wild. &gt; Best case scenario, we’ll save you some time thinking about the right solution No, you don't. Thinking has to be done by whoever will be (re)writing code anyway. &gt; help you avoid some mistakes It's still time investment, which often also is a primary reason why code is underdocumented (aside from lack of motivation). &gt; and maybe even convince you to give refactoring a shot if you’re not exactly a believer No, I am still not a "believer". I don't actually HAVE to believe anything at all when I simply see the results. In literally about 95% of projects that I rewrote, while I also have abandoned a few when I lost motivation, the new code base was significantly better, clearer, better documented too (since I used the time to rewrite to ALSO improve documentation) and in many cases simpler (or at the least more straightforward+documented). &gt; For example, a feature that a website user perceives as a Spaceship &gt; can be called TinCan on the backend side, while our client would &gt; refer to it as Rocket. What the actual ... ? &gt; The next thing that we struggled with was almost no &gt; up-to-date documentation—because of the type of project it &gt; was That's bad, every time. I don't feel like investing a lot of time digging into code that is not documented/commented since it takes more time away. Even if the documentation is not up to date either, it often helps immensely if you can start with something that you can correct on your own, rather than have to dig to find out what this obscure code may be doing. &gt; It was a struggling startup that wanted to deliver a lot of &gt; features in a short period of time. These are just excuses. &gt; Maintaining documentation was always put on the backburner &gt; despite the fact that the business logic was quite complicated &gt; with a number of specific cases. Excuses too. Documentation takes away time and isn't a lot of fun - I get why people don't like it. You don't get new features through documentation either; here code wins. Often spaghetti code. &gt; You can also imagine, that when you have non-existent documentation &gt; and you’re new to the project, the onboarding process is much longer. &gt; You need to figure it all out by yourself. Yes and that just wastes time. Even if you are going to rewrite anyway, it is so much better to start from well-documented projects. class IntoTheSpaceISay attr_reader :money_limit def self.call(money_limit) new(money_limit).perform end def initialize(money_limit) @money_limit = money_limit end You can tell that noobs are at work here because noone in his sane mind would want to have a toplevel method called .call() here. Not only does the name get some people to confuse with a proc, but it is also absolutely non-descript. What is it doing? What does that name convey? That you can ... uhm ... call the class or object at hand ? Call it with what? And who names the class IntoTheSpaceISay - what is the meaning of that. Sure, example code ... but so fake. And then code blocks such as: validate_parts_presence(parts) unpacked_parts = unpack_parts(parts) read_instructions(unpacked_parts) build_spaceship(unpacked_parts) I mean, seriously - you would use methods that require explicit parameters from a local variable, rather than seek to store this in an instance variable? I doubt this. It is a lot more common to see the data stored in an instance variable if you feel a need to have to pass it explicitely into methods (which is fine as such; just the part that you require a local variable rather than an instance variable). &gt; On first glance, we don’t know what is or what should be happening. Because it is convoluted and made-up. And written by a noob who also did not document/comment anything at all there. &gt; We may get an inkling, however, after stumbling onto the buy_parts &gt; method and the build_spaceship method. I don't trust the names alone of methods. If you have a method like: buy_flowers What if you may forget that buying something may deduct from cash, due to a typo? And you may end up with more money after buying flowers - does that make sense? Giving proper names is good but just from the name alone I don't automatically assume much that may be wrong. &gt; Now, it’s rather easy to say what the responsibilities of &gt; the IntoTheSpaceISay class are. I still don't see that much at all. It reminds me of typical rails code though - rails code is extremely alien. &gt; The call method calls two use cases, one for buying &gt; parts and one for building the ship from those parts. So ... why is it called .call? It sounds like some aggregate meta method rather than more straightforward ones, like, I don't know ... purchase_components or whatever. &gt; User stories was the type of documentation that met our expectations; Wow - I HATE stories. I see them used for tests and I absolutely loathe them. Please just document code properly without fairy tale story telling. The best way is also one of the simplest - provide high quality, working examples, starting from simple use cases to somewhat more advanced ones. I understand why refactoring may sometimes have to be done, e.g. when you have some code that you need to change but you can not rewrite everything since that may take too long. But it's not realistic to assume that refactor is at 100% and everything else at 0%. &gt; IF YOU HAVE TESTS and a CI tool in your workflow, then &gt; better architecture and properly adjusted tests could speed &gt; up the automated testing process. This is another problem I have. The assumption that tests lead to better code. I have seen terribly written, completely artificial non-idiomatic ruby code that was designed around the tests, and looked like utter garbage. There are many reasons as to why testing is important - to ensure that a certain specification works reliably and reproducibly. To avoid certain bugs. But to assume that more tests lead to better code by their own virtue ... nope. 
This all sounds very reasonable. In the end its not something I would argue much for with other team members. 
&gt;Give a string s, you will need to find the first instance of repeating character. Conditions of solving this challenge are that you can only iterate once and/or uses O(1) additional memory. If no unique character found, return “\_”. I don't want to take away from the rest of the post, but this first bit is bugging me a little bit. Either this is a misrepresentation of the problem, or the solution is a bit wrong, because the solution iterates over the given input more than once and uses more than O(1) additional memory. Here is the code with my comments instead of the original ones: def firstNotRepeatingCharacter(s) # O(n) memory use, not O(1)! # Also hash lookups are amortized O(1) but I'm okay with assuming O(1) for lookups hashmap = {} # String#chars creates a new array of characters, for another O(n) of memory use and # it iterates through the string to do so. # Could use `s.each_char` instead to avoid allocating the array. # Then it does a second O(n) iteration through the array. s.chars.each do |c| unless hashmap.has_key? c hashmap[c] = true else hashmap[c] = false end end # Another O(n) iteration through the input string and # Another O(n) hash table created find = hashmap.select{ |k,v | v == true} unless find.empty? # Another O(n) array created return find.keys.first end '_' end I see O(4n) memory use (disregarding any copy-on-write optimizations) and three passes through the input string (O(3n) time). The other solution is actually worse for time/space complexity. I added line breaks so I could add comments: def firstNotRepeatingCharacter(s) s.chars.uniq.each {|c| return c if s.chars. # O(n) array and O(n) iteration per loop count(c) == 1 # Another O(n) hash table and O(n) iteration per loop } return "_" end Calling `s.chars` inside the loop means O(n^(2)) time and space, plus calling `count` on it adds at least another O(n^(2)) time and space. That's O(2(n^(2))) just looking at the inner loop. On top of that, there is the first call to `s.chars` which iterates over the string and creates an array and the call to `uniq`, which creates a hash table and iterates over the array much like the first solution, but in C. This isn't to pick on either of the solutions! Just wanted to point out they are not meeting the solution description given and there is some hidden complexity.
what is the advantage of this to selenium-chrome-headless, which is built into recent capybara's? Mainly expected to be faster running tests?
I know it's already well formatted on the gist, but formatting the content for readability here: Rehearsal ------------------------------------------------ as_json 0.122644 0.000508 0.123152 ( 0.123823) fast_jsonapi 0.184139 0.000829 0.184968 ( 0.186195) grape_entity 0.709880 0.003083 0.712963 ( 0.714929) blueprinter 0.220149 0.004481 0.224630 ( 0.225596) ams 0.880767 0.027975 0.908742 ( 0.912454) roar 0.733756 0.006674 0.740430 ( 0.743307) panko 0.142707 0.000671 0.143378 ( 0.145400) --------------------------------------- total: 3.038263sec user system total real as_json 0.120163 0.000531 0.120694 ( 0.121254) fast_jsonapi 0.178100 0.001448 0.179548 ( 0.182374) grape_entity 0.714065 0.001980 0.716045 ( 0.718069) blueprinter 0.178831 0.001490 0.180321 ( 0.181874) ams 0.885708 0.007647 0.893355 ( 0.901771) roar 0.658007 0.004593 0.662600 ( 0.666706) panko 0.125161 0.001391 0.126552 ( 0.127679) Warming up -------------------------------------- as_json 1.000 i/100ms fast_jsonapi 1.000 i/100ms grape_entity 1.000 i/100ms blueprinter 1.000 i/100ms ams 1.000 i/100ms roar 1.000 i/100ms panko 1.000 i/100ms Calculating ------------------------------------- as_json 6.697 (± 2.7%) i/s - 67.000 in 10.154134s fast_jsonapi 4.492 (± 6.8%) i/s - 42.000 in 10.202085s grape_entity 1.421 (± 3.0%) i/s - 15.000 in 10.595573s blueprinter 5.239 (± 1.8%) i/s - 53.000 in 10.162482s ams 1.152 (± 2.3%) i/s - 12.000 in 10.448728s roar 1.428 (± 2.4%) i/s - 15.000 in 10.554087s panko 7.278 (± 2.5%) i/s - 72.000 in 10.016180s with 95.0% confidence Comparison: panko: 7.3 i/s as_json: 6.7 i/s - 1.09x (± 0.04) slower blueprinter: 5.2 i/s - 1.39x (± 0.04) slower fast_jsonapi: 4.5 i/s - 1.62x (± 0.12) slower roar: 1.4 i/s - 5.10x (± 0.19) slower grape_entity: 1.4 i/s - 5.12x (± 0.20) slower ams: 1.2 i/s - 6.32x (± 0.22) slower with 95.0% confidence Calculating ------------------------------------- as_json 55.358M memsize ( 0.000 retained) 839.569k objects ( 0.000 retained) 8.000 strings ( 0.000 retained) fast_jsonapi 37.181M memsize ( 0.000 retained) 489.944k objects ( 0.000 retained) 50.000 strings ( 0.000 retained) grape_entity 113.684M memsize ( 0.000 retained) 939.629k objects ( 0.000 retained) 4.000 strings ( 0.000 retained) blueprinter 36.730M memsize ( 0.000 retained) 319.867k objects ( 0.000 retained) 0.000 strings ( 0.000 retained) ams 167.435M memsize ( 0.000 retained) 1.649M objects ( 0.000 retained) 6.000 strings ( 0.000 retained) roar 130.565M memsize ( 0.000 retained) 859.561k objects ( 0.000 retained) 1.000 strings ( 0.000 retained) panko 55.365M memsize ( 0.000 retained) 839.642k objects ( 0.000 retained) 13.000 strings ( 0.000 retained) Comparison: blueprinter: 36729880 allocated fast_jsonapi: 37180800 allocated - 1.01x more as_json: 55357768 allocated - 1.51x more panko: 55364912 allocated - 1.51x more grape_entity: 113683920 allocated - 3.10x more roar: 130565336 allocated - 3.55x more ams: 167434632 allocated - 4.56x more
\&gt; The design of the driver will be as close to [Poltergeist](https://github.com/teampoltergeist/poltergeist) as possible but it's not a goal. It's meant to overlap with a different driver's api.
Thanks so much for the link! My work tried to move off of Poltergeist a short while ago to headless Chrome via Selenium and all sorts of errors cropped up. We'll be sure to give this a look/try.
Cool! How is Cuprite so much faster than Poltergeist/Selenium?
the main reason of writing cuprite was that we needed all additional features poltergeist had for example (headers, cookies, proxy, blacklist/whitelist url, injecting scripts and so on) they are mostly all supported now by cuprite in one form or another and will eventually be fully supported. btw full control of chrome by devtools protocol gives us the slight speed improvement you see, the speed is not the goal but it can be faster a little bit at least I hope so.
SortedSet is a wonderful example of a bad name. I also doubt many will need a Set. &gt; Asking yourself some questions helps as well: &gt; How many elements will the data structure hold? And you already get that via Array. Including unique members, via .uniq. To be honest, I feel that in almost all cases where some strange name data structure exists such as SortedSet or HashWithIndifferentName, it shows that people don't have a clear vision for picking a good name. That is why things such as Array or Hash are hugely superior, almost all of the time. And although it is not always straightforward, you can subclass from Array and Hash too (though people rarely do that due to some problems).
From the most recent benchmark it turns out that cuprite and selenium are quite at the same place, but in comparison with Poltergeist both are faster!
One of the main reasons to choose the correct class is that the underlying data structures have different performance characteristics for different operations. For example, array.include? has O(n) complexity, while set.include? has O(1).
Well, 0.upto(10) {|n| puts n} passes the block into the initialization method of an Enumerator class 0.upto(10).each {|n| puts n} Initializes an enumerator and then passes a block into the #each method. Take a look at the [docs](https://docs.ruby-lang.org/en/2.6.0/Enumerator.html) If you are asking for some kind of performance comparison, i'd say there isn't enough of one to care.
The docs refer users to the Capybara docs about transactional tests. The Capybara docs state that in Rails 5.1+ the database connection should be shared between app and test threads. This doesn't seem to be working. Any thoughts? 
Thanks for the link, and yes, I was talking about what was happening under the hood. Like... is there a situation where I should use one instead of the other(?
I'd suspect that by the time this hits YARV bytecode, it'd be nearly indistinguishable from each other. You might use the latter as part of an implementation in which you intended to instantiate the Enumerator and reuse it.
&gt; By the way full control of chrome by devtools protocol gives us the slight speed improvement you see A *little* speed improvement? The benchmarks in README show it executing a test suite **twice** as fast as Capybara's built-in selenium driver! Well done :)
A lot of cities have informal local ruby dev groups. meetup is one place to check for one. 
Can we get something to match [cypress](https://www.cypress.io/)'s featureset?
With puts: ``` Comparison: each: 3063.4 i/s block: 3013.3 i/s - same-ish: difference falls within error ``` Without puts: ``` Comparison: block: 1496597.0 i/s each: 904961.5 i/s - 1.65x slower ``` Take it with a grain of salt, I guess.
This should be top comment!
Thanks for sharing. I will try the spec and updates if works.
Thanks for sharing your insight in the complexity analysis. Then original question is as such *"Write a solution that only iterates over the string once and uses O(1) additional memory, since this is what you would be asked to do during a real interview."*. I'm not sure if I'm interpreting this wrongly, but my understanding is 0(1) memory should refer to hash tables, because writing or reading each is 0(1) operation. As you said "amortized O(1)" The first solution I didn't really bother about the complexity, it just came to my mind and written within minutes. So I do know in terms of efficiency it could be bad. But again thanks for sharing your insight again. What I'm more interested in is if you have any solutions to provide/share. 
That's what make a language best, you become most comfortable with it.
That is such a generic thing to ask. Chris pines book is awesome. I too went to a boot camp about 5 years ago. If ruby is your flavor. Udemy is great. 9.99 courses. Hours upon hours of coding tutorials. What i like about these isnthat you can do a few “full stack ruby” courses and not only do you learn how to code, but you see how they debug code. One day i will make my own. I would also learn JS, Jquery, and my personal favorite React. Stephen Grider is an excellent teacher, and after a few courses you’ll have a lot under your belt. Learn the command line. Mark Bates, conquering the command line. Learn Git. 1000s of YouTube videos on that subject. Hope this helps. 
I can't give you a list, but I can definitely tell you to check out www.launchschool.com. Do their boot camp prep - its free of course - and try 1 month and if you like it, continue, but if not, its only $200 a month and not much loss for trying it out a month. If you are studying full-time (say 30 or 30+ hours a week) or even half time (20 some hours), its very good. Feel free to join their slack for free and ask questions. 
In addition to the other user's remark, here's a general rule for deciding between two pieces of equivalent code: Use the one that you think is clearer -- optimize for readability -- even if it's shown to be slower by some (probably) insignificant amount. If it turns out to be too slow and you can explain to yourself exactly why you need that performance boost, then go back and optimize for speed.
Can you try my book [https://i-love-ruby.gitlab.io/](https://i-love-ruby.gitlab.io/) , I would love to hear feedback.
That does help. Thanks! Mostly, I just don’t know what I don’t know. So, hearing the suggestion of somebody 5 years down the path that I want to be on is great. 
Thanks. I’ll check it out. 
I will go against the grain and recommend two things. One, learn some basic CS, networking and Linux admin, coding is only a piece of the puzzle. Two, build something for yourself. A simple project you can iterate on. To get an idea, look at what you do every day and solve an issue you face. 
I have been a pro developer for 20 years now. The things that always got me hired were my side projects. I taught myself Photoshop, I taught myself PHP, I taught myself Rails, I taught myself Ember. The way I taught myself all of those things was because I wanted to make stuff. I wanted to make a web site about a video game, so I did. I wanted to have a blog so I installed Wordpress and learned how to edit Wordpress themes. I wanted to build a web-based IDE and Heroku used Ruby to build theirs, so I learned Ruby and tried to build one. Many of these projects failed. I was often reaching beyond my grasp. But it didn't matter. Trying any failing taught me just as much as succeeding ever did. And early on I took jobs that gave me access to resources. Back in the day it was hard to even get access to a web server, so I volunteered to run a student site with a company so I could get space to put PHP scripts and database tables. In other words, think about what you could do with your skills, and do those things. It will immediately make you qualified to do other things for money.
I think that the best way to land a job - is to show your future boss that you can do real applications. Try to build a portfolio project, that covers some topics that you can meet in real life. I'm teaching beginners Ruby devs sometimes, last time we build something like Instagram (only for web), cause it covers a lot of topics, such as Authentication, image uploading and storage, social network, etc. The guy spent about 5 months (from the very beginning, he didn't know Ruby/programming before that), and after the app was finished he wrote a resume and found the job in 2 weeks. So my advice it find a good mentor, that will help you to build an app, that will do code review, etc. 
Let's work it out, open an issue in the project and we can discuss it there
that seems like a cool framework, I hope once we make 1.0 we can work on something like that
Nice thing to keep in mind, thanks!
There is a quite big Slack community: [https://www.rubyonrails.link/](https://www.rubyonrails.link/) 
Sound advice. I'd add to it by suggesting you starting on your portfolio - have things you can point to when you go to interviews, as well as practising your programming chops. There are many open source projects in Ruby land that you can potentially help out with too - as well as connect with folks in the industry that may be able to point you to opportunities as they come up. Check out: https://www.codetriage.com/?language=Ruby
&gt; For example, array.include? has O(n) complexity, while set.include? has O(1). I always forget this because Arrays are so easy to use, it's at my second or third time around at optimizing something that I start optimizing this.
That's an interesting proposal. I think I would see the benefit more if the individual functionalities were more complex, but at the moment I don't mind that they're all together in one class. &gt; I don't know what to make of #size, that seems to be an AWS requirement for the signature v4 API It's more that AWS S3 doesn't support `Transfer-Encoding: chunked` requests, which would allow omitting the `Content-Length` request header. But the way to get around it is via multipart uploads, which `Aws::S3::Object#upload_stream` nicely encapsulates.
Matey, people have been giving you feedback for ages and you seem to be blithely ignoring it. At the risk of sounding mean, it really needs an edit. I realise English isn't your first language, but if it is the language of your audience it's going to alienate people. I'm sure your heart's in the right place, but you absolutely have to get someone with a firm grasp of English to clean this up. Ditto for the formatting. I'm also not sure who you are pitching this book at. New devs? Intermediate? You need to take people on a journey that's appropriate for the target audience. Look at Chris Pines “Learn to Program” - he knows who he's talking go (people new to Ruby), and steps them through all the things they'll need to get themselves going. You might need to honestly ask yourself, who are you writing for? And maybe more importantly, why are you writing this book? Some good points - it's quite comprehensive in scope, but the downside there is that if feels like a scattered general reference, and there are better books out there in the same space (the "pickaxe" book as an example). Plus there's a lot of stuff in there without any kind of meaningful context. _E.g._ the "patterns" section - the preamble doesn't make any sense, nor does it actually explain what a "pattern" is. Maybe your overreaching here, I can't say... but there's nothing useful in that section for a developer at any level. Maybe you need to scale back the scale back the scope of the book. Rather than make it a "grab bag" of all kinds of stuff, focus on one aspect of coding in Ruby and do that really well. Or at least get what's there under control before you start adding more material. I wish you luck - I really do. This is obviously am important project for you. I'm not sure what feedback is going to be useful to you, but I hope there's something here that you can take to heart. That's me done. Cheers mate.
It's actually really wonderful to see someone getting into coding and being excited about it. Some other books you might enjoy: Sandi Metz's [ Practical Object-Oriented Design](https://www.poodr.com/), and Russ Olsen's [Design Patterns in Ruby](http://designpatternsinruby.com/). The former will clue you on technique and the latter will introduce you to software patterns (an important concept). Neither will get you a job _per se_, but they'll help prepare you for things that'll come your way. Even as an older coder I found these a delight to read. And welcome to the Ruby community - and the larger programming community as well. Keep up your enthusiasm matey - and your willingness to learn. Because if anything is going to help you get your foot in the door, those two things will. 
I understand your two reasons behind having languages defined in multiple lines in alphabetical order, but I think I missed a point of keeping them stored as sorted data in memory. 
What an awesome article!
In deed. I was just going to submit it here myself :)
This article on HackerNews https://news.ycombinator.com/item?id=18930014
Nice thoughts, the article needs some proofreading and a paragraph was accidentally duplicated there though
You can certainly move fast with Rails, and if you're on a team of experienced, disciplined engineers then the Rails monolith is an excellent way to keep your team focused on work that matters On the other hand, Rails (used in the context of a monolith) is really difficult to maintain and optimize if your team is not disciplined (lacking tests, lack of separation of concern, team churn). While I'm not here to knock a monolithic architecture (and this has really been talked to death), splitting up your monolith gives you strong guarantees with regards to how things are decoupled. In Ruby it's very much on you to ensure those lines are properly drawn In my opinion Erlang/Elixir gets the monolith right as it gives you a strong framework for building and composing self-contained applications into a single runtime. I've unfortunately yet to see a Ruby app that is large but feels like many encapsulated, self-contained components. It seems like a nice goal to shoot for though
&gt; On the other hand, Rails (used in the context of a monolith) is really difficult to maintain and optimize if your team is not disciplined (lacking tests, lack of separation of concern, team churn). If your team is not disciplined, no architecture or framework is going to protect you from maintenance issues. &gt; splitting up your monolith gives you strong guarantees with regards to how things are decoupled. In Ruby it's very much on you to ensure those lines are properly drawn If you know where to draw the lines, then you're strong enough of developer to get it right regardless of the language or architecture. Tooling is not the cause of cohesive, decoupled apps.
&gt; Tooling is not the cause of cohesive, decoupled apps You're right - it's not the cause. I do think tooling can help apps stay decoupled. I believe it can be good to have referential boundaries (e.g. "you can't call the database here because this part of the code doesn't even compile with a database client"). It's more difficult to maintain those (for lack of a better term) invariants when they can be broken by a single line of code being checked in. _You_ may be a strong enough developer to get things right regardless of the language or architecture, but is your entire team? How do you push them in the right direction? I think this story could be better Mind you, I mostly use Ruby in the context of job pipelines so my view of things is highly weighted towards the concerns of that realm. I understand the context of the post is a fresh web project in which I totally agree - for the love of god, stick with monolith
`Dir["/*"].what_returns?([])`
Its like everyone thinks its a great idea to add in network latency just to create a boundary between components.
I think the title for this post is a bit off, but it was chosen by the author of the article. &amp;#x200B; The big factor is that in a number of cases, we are just doing design wrong. The big words are SPA, JS, etc. And while they can be cool, they are not necessarily the correct tool for the job. I wish there was more stress in the article about optimizing for performance before you have a single customer. And I wish he pointed out more the amount of time spent working on that simple crud app that took 400+ hours in a JS framework. DHH, put out an article recently that talked about building an app and customer base slowly. The problem is that everyone wants to be a disrupter. What happened to taking time and growing something bit by bit. Instead, it is all about the hockey stick curve, or you are doing it wrong. For the majority of businesses out there, it is beyond what they need. There are a number of very profitable business that exist with slow and crappy websites, but they have a good product. We need to get back to building apps and getting them out the door, not spending 2 years rebuilding the API layer and Frontend layer. &amp;#x200B; Thanks for the article. 
If only it was just latency. It's also unreliability etc. https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing#The_fallacies
Whether or not you distribute services among multiple nodes seems tangential to creating boundaries. There's no reason you should need to do one to have the other
Thanks a lot. :) &amp;#x200B;
Did you try ruby 2.6?
You essentially need to figure out how to get the HTML out of ruby and into the Wordpress database. Then recreate the file structure for the images in Wordpress install and everything should work. &amp;#x200B; &amp;#x200B;
I'm presuming (hoping) that the posts in the ruby app saved to a database (usually mysql or postgres) so they can be accessed from a WP install. That should include relative paths to images. &amp;#x200B; Personally I'd explore some admin packages for rails (assuming it was rails). 9 times out of ten the only reason people want to switch over is because of the intuitive admin panel of WP. IMO going to WP after ruby is a step backwards...too restrictive a system.
I agree. There’s just this idea that a monolith is spaghetti code and that microservices are here to sort things out. Spoiler, your monolith should have had the same decoupling and API boundaries in the 1st place.
How exactly is it zero config?
Yes. I'm using Ruby 2.6 to run my the script.
Part of the confusion is that Rails keeps changing it's mind about things. _Rails_ defines [Integration Tests](https://api.rubyonrails.org/v5.2.2/classes/ActionDispatch/IntegrationTest.html) _and_ [System Tests](https://api.rubyonrails.org/v5.2.2/classes/ActionDispatch/SystemTestCase.html). I think one is newer than the other, and the newer one is recommended by rails? I can't keep track honestly. Then Rails has controller tests, which have been replaced by "functional tests". What? rspec-rails provides some wrappers over the rails tests, but has struggled to keep up with rails changes -- which are not just to terminology, but to _how_ Rails wants you to test and what features are available in each test. (And Rspec originally provided built-in ways to test with capybara that Rails didn' have at all; but then Rails did... differently). I'm very confused about the whole thing too. Especially when dealing with old projects that have unholy mixtures of various eras of rails and rspec suggested practices. 
I love the idea of working on a real-world project with some mentoring! That seems like something that would work for me. Can we schedule a call? I’ll PM you. 
Good advice! I’ve also been teaching myself some of the same stuff. I use Photoshop and Illustrator all the time. I learned HTML and CSS, and then started learning the marketing side of things. So, now i work in digital marketing. But, I surprised myself with how much I loved to program. I didn’t really realize it until recently. Now, i want to fast track learning it. 
I recently migrated my blog from Jekyll back to WordPress. If the site exposes an RSS feed, you _might_ be able to use the [RSS Importer](https://wordpress.org/plugins/rss-importer/). One caveat with this approach is that it doesn't import the images, but instead keeps the existing paths to the pictures. A way to work with this, if you don't mind a "impure" WP folder structure is to bring the folder of images over to the new WP site and put it in the same path it was in Ruby-side. Of course, that assumes all the photos are in one location on the Ruby site. 😅 All that said, if you can get the posts into a feed of XML or JSON, you might be able to find a WordPress plugin to handle the rest for you. That's one nice thing about WordPress is the abundance of plugins to help with edge-cases like this.​ I hope this helps. I also hope you're able to find a solution, so you're not stuck copying and pasting. 🤞
I’ve heard this advice before, and one of my problems is finding the right projects to start on (with my beginner skills). What kinds of projects would be impressive as a part of a beginner’s portfolio? 
I fell for the SPA meme in the beginning but quickly switched to Rails + Vue when I need it.
I use Rails for exactly it’s insanely productive approach to the majestic monolith. I can crank out an mvp in two months of my spare time. I will worry about the SPA approach once I start paying more than $200 on dynos or have more than 200 paying customers. I love Sam Stephensons talk on turbolinks vs SPA for the comparison between the two architectures. The incredible comparative complexity of using SPA approach just does offer the ROI it should early in the process. https://m.youtube.com/watch?v=-h9UQoTttz4
I was confused at first, but the OP does not seem to be against SPA, and covers writing SPA's in the article -- he just puts all the code in one repo, and manages the JS with webpacker, either way. 
&gt; I'm not sure if I'm interpreting this wrongly, but my understanding is 0(1) memory should refer to hash tables, because writing or reading each is 0(1) operation. As you said "amortized O(1)" The question seems to be asking for a constant memory use, not constant write/access time. Hash tables use O(n) space. The only way I can see getting constant memory use would be if the string had a limited set of possible characters. For example, if limited to ASCII characters, you could use the hash table approach because you know the max size of the hash table will be O(256). &gt;*Write a solution that only iterates over the string once* This is a bit confusing to me. Does iterating over the hash table count as iterating over the string? It seems like maybe it doesn't count. It certainly doesn't count if the set of characters is limited. &gt;What I'm more interested in is if you have any solutions to provide/share. Here's a modified version of yours that avoids the creation of additional hashes/arrays: def first_not_repeating_character(s) h = Hash.new s.each_char do |c| if h.has_key? c h[c] = true else h[c] = false end end h.each do |k, v| if v == false return k end end '_' end If the length of the string is *n* and the size of the set of characters is *m*, then this is O(*n*\+*m*) time and O(*m*) space. I really don't know how you get around storing and iterating over the set of characters.
It might sound trollish but WHY!? Rails gives you many more options across the board. WP is a nightmare when you need to do things like caching or load balancing. We're doing everything we can to get off WP. We're utilizing the WP API to render the content in Rails and providing the CMS to the admins. It's less than optimal but the lesser of evils. Also you may want to highlight the WYSIWIG stuff (Trix) coming with action\_text in rails 6 might be what they're really trying to achieve. 
I've had success with the following. It's a Vagrant VM with VirtualBoxHeadless as the provider. In the project Gemfile I added: gem 'debase' # "bundle exec rake db:create" fails without it gem 'byebug' # debugger gem for ruby 2.0+ gem 'ruby-debug-ide' # allows attaching vscode debugger to remote server In the Vagrant file, I added the following lines: config.vm.network "forwarded_port", guest: 1234, host: 1234 config.vm.network "forwarded_port", guest: 3000, host: 3000 config.vm.network "forwarded_port", guest: 26162, host: 26162 The vs launch.json is as follows "version": "0.2.0", "configurations": [ { "name": "Debug Rails Local", "type": "Ruby", "request": "launch", "cwd": "${workspaceRoot}", "showDebuggerOutput": true, "debuggerPort": "1234", "program": "${workspaceRoot}/bin/rails", "args": [ "s", "-b", "0.0.0.0" ] }, { "name": "Attach Rails Remote", "type": "Ruby", "request": "attach", "remoteHost": "localhost", "remotePort": "1234", "remoteWorkspaceRoot": "/", "cwd": "${workspaceRoot}", "showDebuggerOutput": true } ] } Then when I want to debug the server, I start the server app by entering into the terminal: vagrant up # start the VM vagrant ssh # ssh into the VM # start the server app bundle exec rdebug-ide --host 0.0.0.0 --port 1234 --dispatcher-port 26162 -- /vagrant/bin/rails s -b 0.0.0.0 # it will now wait for VSCode to attach before starting the server app 
I've had success with the following. I'm on a Windows machine, but for remote it's a Vagrant VM running ubuntu 16.04 with VirtualBoxHeadless as the provider. In the project Gemfile I added: gem 'debase' # "bundle exec rake db:create" fails without it gem 'byebug' # debugger gem for ruby 2.0+ gem 'ruby-debug-ide' # allows attaching vscode debugger to remote server In the Vagrant file, I added the following lines: config.vm.network "forwarded_port", guest: 1234, host: 1234 config.vm.network "forwarded_port", guest: 3000, host: 3000 config.vm.network "forwarded_port", guest: 26162, host: 26162 The vs launch.json is as follows "version": "0.2.0", "configurations": [ { "name": "Debug Rails Local", "type": "Ruby", "request": "launch", "cwd": "${workspaceRoot}", "showDebuggerOutput": true, "debuggerPort": "1234", "program": "${workspaceRoot}/bin/rails", "args": [ "s", "-b", "0.0.0.0" ] }, { "name": "Attach Rails Remote", "type": "Ruby", "request": "attach", "remoteHost": "localhost", "remotePort": "1234", "remoteWorkspaceRoot": "/", "cwd": "${workspaceRoot}", "showDebuggerOutput": true } ] } Then when I want to debug the server, I start the server app by entering into the terminal: vagrant up # start the VM vagrant ssh # ssh into the VM # start the debugger bundle exec rdebug-ide --host 0.0.0.0 --port 1234 --dispatcher-port 26162 -- bin//rails s -b 0.0.0.0 # The debugger will now wait for VSCode to attach before starting rails I'm not sure why i have to do the double slash `bin//rails`, but it won't work otherwise. I discovered it by accident because I was out of ideas and thought maybe the string needs to be escaped (even though the slash is the wrong way)? 
It's an interesting problem. [Mastodon](https://github.com/tootsuite/mastodon/issues) has a large number of issues, requiring a range different skill levels to address. Plus it's a fun project. But if you want to start smaller, I recommend steering clear doing one the generic projects you see from folks coming out of boot camps. I can't recall exactly the sort of stuff (pre-coffee, give me a bit) but you know the stuff when you see it. It's not the stuff that would impress me if I was hiring. I'd say scratch your own itch. Find a problem that affects or interests you personally and use code to solve that problem. Something unique - or at least particular to you - may help to motivate you as well as make you stand out from the crowd when you are going for an interview. And keep your eye out for opportunities - be bold. I got my start in the industry when I heard about someone with an old DOS system that was failing. I convinced them to move to Windows, went out and bought Delphi and sat down and learned out to use it, as I'd never seen it before. A few weeks later they had the first cut of their new system, which gradually evolved into a complete product - a concrete thing I could then point to when it came to looking for work. A risk, but decades later here I am... still coding. Things were simpler back then, but I'd argue there are more opportunities now that ever - more problems needing software solutions. Keep your ears open, look for openings. I'm sure you'll do well.
Thanks for writing all the tests! I've watched the Sandi talk so it will be hard to stay original...
Man... an easy to use dataframe data type....
*Zero* isn't perhaps entirely true, but one of Rails' biggest draws on the early days was how easy it was too get up and running compared to other stacks. In those days, 2005/2006ish, wrestling with thousands of lines of XML config was a thing. A bad thing.
Not needing developers for any little change that isn't content is a good argument I think.
but you'll still need devs/tech staff for non content things. You may be able to install add-ons but IME WP requires significantly more tech resources than an Rails application. 
As far as the 3 ways to call things, you should note that the third (implicit calling) is because the object that self evaluates to is Kernel, or a subclass of Kernel https://ruby-doc.org/core-2.6/Kernel.html#method-i-puts
Get it hosted somewhere, and let the techs integrate it.
You know I hear this a lot about Wordpress, and then every single minor change someone wants ends up escalated to myself.
What do you mean by "Ruby site". I don't tend to hear of blogs running Ruby unless it's Jekyll- in which case what you actually have is a tonne of Markdown to work with. Or is this something custom?
It works fine in my organisation.
I agree with this. Monolith still works 90% of the time. I have a long running monolith app for 5 years now. It's now rolling 5.2 under the hood with react but is not a spa thanks to webpack and sprockets. We just use react on some sections od the app that require crazu data handling. But for simple stuff, request response works and is easier to maintain. Heck we still have jquery in there and its a breeze to maintain for simple tasks.
That you don't need to configure anything to start with it: everything is prepared for you. It goes in the direction convention over configuration. This still leaves space to customizations
Hi Mehdi.. Again great article! Thanks.
It would really help if you mentioned which ruby app it was on. Blog apps usually have an export feature of some sort; and I’m sure someone here is familiar with the specific app being used?
I don't like autoload.
It's cleaving!!!
Thanks ! :-)
Isn't there a Ruby core thread talking about where autoload was discouraged? Still worth knowing about and has even been handy every now and then
Yup, there is: https://bugs.ruby-lang.org/issues/5653
I created a gist of a draft proposal: https://gist.github.com/HoneyryderChuck/625c7b873a00a18d12b1a08695551510 I was rambling on those interfaces as a higher level proposal; since we don't have any way to enforce it in ruby, it's more like an agreed upon contract. For instance, your `ChunkedIO` wouldn't benefit of any enumerable extension, as it already fulfills the `Reader` requirement in a specialized way. This proposal is for random enumerable string generators that could benefit of this routine sharing, like, say, you're working in a project that has to generate tons of csv files and upload them to S3. &gt; The way to get around it is via multipart uploads, In the project I'm work with, they're using `fog-aws`, which doesn't seem to work with the `aws-sdk` suite underneath... and they don't seem to support multipart uploads :/ sucks for my case.
Indeed. Just notice that there is a significant amount of projects that still includes a bunch of \`autoload\` statements. This said: don't use \`autoload\` for your future projects. :-) &amp;#x200B; &amp;#x200B;
Get familiar with git and the git comand line. Get a github (or alternative) account and do some coding challenges and small projects and put them up on github. No code challenge is to small. Example [how to write an armstrong number checker](http://www.devslife.com/how-to-write-an-armstrong-number-checker/) Get a blog (if you can) and document your challenges and progress. Remember to also read for pleasure. Those who do not read for pleasure (sf, novels etc) cannot read for esucation effectively. Remember to have fun doing it. If you can’t have fun doing it, you will not survive. Good luck!
Yay! I have something fun to do at work today :)
I love the `autoload` feature. Hope the Ruby Core Team doesn't remove it unless they provide a better alternative.
In this post we discuss ways to reduce the amount of data you’re selecting from the database by using dynamic column names
"alternative" to achieve what exactly?
FWIW, my understanding is that system tests are different from integration tests in that system tests actually spin up a browser and therefore can be used to test features that use JavaScript whereas integration tests can't. But on the whole I agree that it's a long convoluted story that's hard to keep track of!
*"alternative" to the (removed) autoload feature* My original comment could be re-phrased as: *"Hope the Ruby Core Team doesn't remove (autoload functionality) without providing a better replacement."*
nice post. I've found Arel documentation to be terrible so I end up with meta programming and scopes and query objects which a ton of comments too. I wish Arel was as familiar to Rails developers as ActiveRecord, but its API is just not as simple (or intuitive) as AR. 
I got my start in the digital world learning graphic design and the visual side of it. So, when somebody says, work on something simple, i think of something simple, and then think “but I don’t know how to bridge the gap between writing some code and making something visual that somebody can look at”. All I can do right now is right code, and run it in the terminal to show an end result. For example, I’ve always wanted to test out gambling strategies without spending money (I’m not a gambler... I’m just curious). And so, I thought about creating a program that emulates roulette and allows me to test out a strategy with as many spins as I want (100... 1,000... 1,000,000). But, like I said, I just know how to do that by writing code in a text editor and then running it in the terminal. Based on that example, how far off the mark am I in terms of doing a beginner project that is worth showing to an employer? Is the code enough? Do they want to see it run on a web page (which I currently don’t know how to do)?
&gt;No code challenge is too small Really? In the book that I used to get my intro to Ruby, there were challenges at the end of every chapter (which I've saved). I thought of them as being too simplistic to show people. They are the following: * **99 Bottles of Beer on the Wall** \- Write a program that prints out the lyrics to that beloved classic, “99 Bottles of Beer on the Wall.” * **Deaf Grandma** \- Whatever you say to Grandma (whatever you type in), she should respond with this: "HUH?! SPEAK UP, SONNY!" * **Leap Years** \- Write a program that asks for a starting year and an ending year and then puts all the leap years between them (and including them, if they are also leap years). Leap years are years divisible by 4 (like 1984 and 2004). However, years divisible by 100 are not leap years (such as 1800 and 1900) unless they are also divisible by 400 (such as 1600 and 2000, which were in fact leap years). What a mess! * **Building and Sorting an Array** \- Write the program we talked about at the beginning of this chapter, one that asks us to type as many words as we want (one word per line, continuing until we just press Enter on an empty line) and then repeats the words back to us in alphabetical order. Make sure to test your program thoroughly; for example, does hitting Enter on an empty line always exit your program? Even on the first line? And the second? Hint: There’s a lovely array method that will give you a sorted version of an array: sort. Use it! * **Table of Contents** \- Write a table of contents program. Start the program with an array holding all of the information for your table of contents (chapter names, page numbers, and so on). Then print out the information from the array in a beautifully formatted table of contents. * **Old-school Roman Numerals** \- Write a method that when passed an integer between 1 and 3000 (or so) returns a string containing the proper old-school Roman numeral. In other words, old\_roman\_numeral 4 should return 'IIII'. Make sure to test your method on a bunch of different numbers. * **“Modern” Roman Numerals** \- Rewrite your previous method to return the new-style Roman numerals so when someone calls roman\_numeral 4, it should return 'IV' * **Shuffle** \- Write a shuffle method that takes an array and returns a totally shuffled version. As always, you’ll want to test it, but testing this one is trickier: How can you test to make sure you are getting a perfect shuffle? What would you even say a perfect shuffle would be? Now test for it. * **Dictionary Sort** \- Make a new method to sort words (something like dictionary\_sort). Remember, though, that if I give your program words starting with capital letters, it should return words with those same capital letters, just ordered as you’d find in a dictionary. * **Safer Picture Downloading** \- Adapt the picture-downloading/filerenaming program to your computer by adding some safety features to make sure you never overwrite a file. A few methods you might find useful are File.exist? (pass it a filename, and it will return true or false) and exit (like if return and Napoleon had a baby—it kills your program right where it stands; this is good for spitting out an error message and then quitting). * **One Billion Seconds!** \- Find out the exact second you were born (if you can). Figure out when you will turn (or perhaps when you did turn) one billion seconds old. * **Grandfather clock** \- Write a method that takes a block and calls it once for each hour that has passed today. * **Program Logger** \- Write a method called log that takes a string description of a block (and, of course, a block). Similar to the method do\_self\_importantly, it should puts a string telling you it started the block and another string at the end telling you it finished and also telling you what the block returned. Test your method by sending it a code block. Inside the block, put another call to log, passing a block to it. So, are these coding challenges too small?
I understand that, but maybe I made my question not clear. What is the exact functionality you want to be preserved? "Some code loading automatically on a first time some constant is mentioned"? I am curious to know what's the value of that concept to you. 
No, they are not. All these challenges hold keys to basic but very important programing practices. If you find them to easy, after finishing the minimum requrement to make them pass, refactor them. Think how you can inprove them ir even add multiple solutions, from fast and hacky to long but buletproof. Never be ashamed by the work you do. No challenge is too small so long as it’s clear, easy to understand and fun to apply. ProTip: use these small challenges to work on your “naming”. If you can master the art of naming objects (variables, classes, methods, modules, constants etc) in a clear cut and easy to understand manner, you’ll have won half the batlle in programming. Learn how to implement abstractions, and get used to adding tests (rspec or other) to get used to doing TDD. If you never ever did TDD, then these small, simple and clear challenges are perfect for you to practice doing TDD Good luck! 
You just described the value. Not loading a file until it’s contents are needed. 
Problem is that it is not 100% up to date. Matz sort of discourages the use of autoload but it has not yet been removed and will probably stay in. It also provides a feature that people can not easily get with vanilla load/require, which is to load components only when the "namespace" is tapped (first used). One can still do some partial work around e. g. I tried to use require via Threads, but this is even uglier than autoload.
Yeah I can see that. It definitely didn’t get as much attention as AR documentation in the past. Hopefully that will change now that it’s officially in the rails repo and owned by rails.
That's just a descriptio of "what it does". I am curious (honestly curious, not trolling) about the _value_ of the concept to people. Is it memory economy, or ...?
An example that thousands of developers take advantage every day: Rails development mode makes heavy use of lazy auto loading. Applications boot much faster by not eagerly loading all rails features at once. 
Not entirely true. 0.upto(10) {|n| puts n} calls https://ruby-doc.org/core-2.6/Integer.html#method-i-upto method on Integer 0. This method takes a block. If no block is given to this method it would return an Enumerator. This time a block is given, and internally it iterates from 0 to 10 and yields the number to the block given. No Enumerator is allocated. ( You can click the toggle source on that link to see this happening ). 0.upto(10).each {|n| puts n} This one calls upto on 0. This time there is no block given, an Enumerator is returned. (first line of upto implementation). This enumerator receives the each method that has a block given. the block is not passed or seen by upto in this case, I'm not sure if that's what you meant by : &gt;&gt; Initializes an enumerator and then passes a block 
Arel is still private API though (in Rails)? 
Unfortunately I think it is the other way around. The core team (in what I regard is one of the most community-hostile positions they could possibly hold) seem fixated on the idea that Arel is a private API. Bringing it into the main repo seems to have been an attempt to signal to the community that you shouldn't even be looking at it, and has made the task of accessing doco for it even harder. This is despite the fact there are things you can *only* do in Arel, that there are entire code paths in Arel that are never tapped by ActiveRecord, that the chance of Arel ever being ripped out and replaced with something else is basically nil, the community routinely suggests it for more sophisticated expressions, and that at least one ActiveRecord deprecation message even recommends using Arel. It's an absurd situtation. I think that going down a level from AR to Arel is omakase, and should be fully embraced and documented. 
Production apps don't. They use it locally for that but in production the entire app is loaded at runtime. In general for dev even it probably wouldn't be that rough since you usually run the dev server which watches and reloads files on the fly
Obviously production apps don't use this feature, that's why I said Rails in development mode. I don't understand why you're being so nitpicky. I described a usecase for autoloading. Rails development mode uses it extensively. What's confusing? 
Sorry. I misread at first and didn't see development mode. 
IRC - freenode #ruby
Any particular reason you use Java? It's not a bad language but it makes so much emphasis on stability, it takes years to make a simple change. The syntax is just verbose and while the JVM is great, there is really little reason to use Java when you can use something like Kotlin, Groovy, Clojure or Scala.
Thanks!!
My tip is to learn Spring Framework. It’s such a vast body of work, and solves so many problems. This is the power of Java: The almost endless expanse of plugins and modules. Also, take the compile and build process seriously, it’s way more involved than ruby. Learn Maven and Gradle, at least the basics.
Lovely!!
Excited about multiple databases support.
Parallel testing will be nice
God yes. I have it jerryrigged in my production but it turns out that breaks concerns. Made me forget how great it was refactor and lose 200 LOC when I had to copy and paste them all back in. 
I'm pumped.
wow, sounds cool, I might be getting into that, but will see. thank you!
thank you for elaborating! that's a better way of putting it, yes the syntax is more verbose. 
I appreciate and am impressed that you wrote such a thorough comment about the article which is great validation around getting a conversation started on the topic, but it would be nice if you were a bit more considerate with the article and the author. You bring out good points, that I actually have experienced and agree with you on some, and I appreciate you share, but in my opinion you came across way too harsh with the author... Makes you seem you have an issue with the person not experiencing your exact situation or feeling about it.
I've built a number of different apps along the years and have never had the need of what "Action Mailbox" will be. It seems cool, but I'm not sure why that is part of Rails ¯\_(ツ)_/¯
How did you set it up? The times I’ve done multiple databases it was a single root model with few lines of code to pull in a different configuration file for the connection. I only did a read-only FB import off these models, but I thought it was pretty simple. 
I'm excited about transactional emails becoming "conversations" but agree that this would probably be better off as a gem.
To my knowledge, `autoload` is just one monolithic feature: *Load a certain file only when the associated constant is first looked-up.* The value of the concept to me is in memory management entirely. Proper memory management translates to better performance. ## For those who don't know, consider the following example: main script file: ./script.rb require_relative 'addons/translator' module FooBar autoload :Generator, 'foobar/generator' def self.run puts 'Hello World' end end FooBar.run file: './addons/translator.rb' # load 3rd-party gems require 'library_1' require 'library_1/addons' module FooBar module Addons class Translator # 35 lines of code initializing 50 Ruby objects end end end file: './foobar/generator.rb' # load 3rd-party gems require 'library_2' require 'library_2/addons' module FooBar class Generator # 35 lines of code initializing 50 Ruby objects end end For the main script file, both `FooBar::Addons::Translator` and `FooBar::Generator` are not required for successful execution. Yet, the entire `library_1` code and its `addon` module along with the `Translator` code are loaded into the memory (because of the `require_relative` call) Fortunately, **because of** ***autoloading***, `library_2`, its `addon` module and `Generator` code are not loaded into memory.
You dropped this: \\
Connecting to Multiple DB was never a problem. 
For those who don't know, consider reading my article hehe !
I wonder if rspec will support it out of the box
LOL True. My comment shouldn't hijack the very reason for this discussion :D 
&gt;This is a bit confusing to me. Does iterating over the hash table count as iterating over the &gt;string? It seems like maybe it doesn't count. It certainly doesn't count if the set of &gt;characters is limited. What I think is the requirements ask to iterate the string once and O(1) is memory access. But didn't rules how the memory access can but implement. which got me into the following solution. In which, I've only iterate once over the string with each iteration access to memory at O(1) in return the solution, either O(1) if there are no match or O(1) + O(1) for returning the first match character. ''' def firstNotRepeatingCharacter(s) hasht = { 1 =&gt; {}, 2 =&gt; {} } (0...s.length).each do |i| if hasht[2].has_key? s[i] next elsif hasht[1].has_key? s[i] hasht[2][s[i]] = hasht[1].delete(s[i]) else hasht[1][s[i]] = true end end return hasht[1].first[0] if not hasht[1].empty? '_' end ''' Anyway, that is not my point in my article about efficiency. But simplifying code with Ruby. Especially the second solution, although you have hi-lighted although the code is shorter but bad efficiency. I guess is quite stringent, to comply with all the rules and make the code as efficient as possible. But how often do we need this efficiency? the following code is what I've found in other people's solutions in codesignal and was voted to be the top. I was originally written in Java, but I translate exactly to Ruby. I believe this can be easily translated to other languages as well Why it is voted to be the top? I believe the main reasons are: - this is a ridiculously simple solution to understand (clean and neat) - as I've said, it can be implemented in any language quite easily But, when comes to complexity - iterating the string is O(n) - doing either .index or .rindex gives an at worst complexity of O(n) - which makes up to O(n^2) ''' def firstNotRepeatingCharacter(s) (0...s.length).each do |i| if s.index(s[i]) == s.rindex(s[i]) return s[i] end end '_' end ''' Also, I can't think any solution that can solve within O(n) time and space. I don't think it is quite possible. 
If not, they probably will soon! 
Multiple databases will increase the popularity of rails 
It is if you want all the magic of ActiveRecord. 
Yeah this makes a lot of sense. I’m still hopeful but we’ll have to see. Maybe the way forward is wrapping more and more ARel APIs I’m equivalent AR methods so that’s it’s still hidden but you can get the same functionality. They did that with “or” and “left_joins” relatively recently which was nice. 
Not private, you can access all the APIs and the methods are documented. It’s just in a bit of a confusing place in the community.
As far as I know it’s always been considered private/internal by the rails team. 
If you're using the `iodine` Ruby webserver, than you can use the bundled WebSocket client at no extra cost. The example from the README obviously requires threads (and OpenSSL &gt;= 1.1.0, since it uses `wss://`), but if iodine is already running as a server, than it's a non-issue: require 'iodine' # The client class class EchoClient def on_open(connection) @messages = [ "Hello World!", "I'm alive and sending messages", "I also receive messages", "now that we all know this...", "I can stop.", "Goodbye." ] send_one_message(connection) end def on_message(connection, message) puts "Received: #{message}" send_one_message(connection) end def on_close(connection) # in this example, we stop iodine once the client is closed puts "* Client closed." Iodine.stop end # We use this method to pop messages from the queue and send them # # When the queue is empty, we disconnect the client. def send_one_message(connection) msg = @messages.shift if(msg) connection.write msg else connection.close end end end Iodine.threads = 1 Iodine.connect url: "wss://echo.websocket.org", handler: EchoClient.new, ping: 40 Iodine.start 
After your comment I've checked what that change actually is about. It is not what I was thinking. I though about the case, when you might want to back one model by data from one database, then other model with data from different one. Support for different databases (with different data) was trivial in Rails ages ago. Now this change allows for one model to use multiple databases, for example one for writing and a replica for reading. 
&gt; The thing is this will be called from c code ... I just saw this after mentioning the Ruby iodine WebSerevr. Iodine runs on [facil.io](http://facil.io), so you could probably use the C library. (P.S. I'm biased) 
Ah! You’re right. My apologies I didn’t go all the way to the PR last night. Damn... concerns still break. Though I wonder if you could use this to just easily point a model at a different dB without having to do multiple levels of subclassing... 
So if you did mean support for many databases with different data backing separate models, then I don't get what is so hard about that? You just point out which connection use in given model and then you get all the magic of ActiveRecord you want. What do you mean about required levels of subclassing or broken concerns?
Id say follow the odin project... https://www.theodinproject.com/ I feel it doesn't get recommended enough her! Its an amazing resource that covers a ton of important topics beyond just rails or ruby, to get you well prepared to land a jr job and or start to build some fun toy apps. Let us know how it goes!
Have you had any success with this JIT image processing? Seems very out of place. It's one of the reasons I've stuck with Carrierwave.
I'm not sure if there is something to do about it. A while ago when I was playing with poltergeist it seems to run tests faster but we had other problems with it so we kept using capybara-webkit. This problem with long-running features tests pushed me to actually not run the whole test suite on my machine but on CI with parallelization. If finding a workaround to speed up tests is too time and developer consuming maybe it's better to run more parallel nodes on CI and speed up build. I've developed knapsack ruby gem to automatically split tests on parallel nodes. Later developed a more advanced way for dynamic test files allocation across parallel CI nodes. Here is an example for Travis CI [https://docs.knapsackpro.com/2018/how-to-run-travis-ci-parallel-jobs-with-build-matrix-feature-fast](https://docs.knapsackpro.com/2018/how-to-run-travis-ci-parallel-jobs-with-build-matrix-feature-fast) 
Didn't someone just release a pure Ruby implementation of Chromedriver?
Are you looking for a more detailed tutorial for specific topics or just better overview what's possible in RSpec or Cucumber? &amp;#x200B; Maybe you will find something here for the start about RSpec [https://www.rubyguides.com/2018/07/rspec-tutorial/](https://www.rubyguides.com/2018/07/rspec-tutorial/) &amp;#x200B; Probably you will have to integrate tests with some popular gems. I've shared common configs for popular gems and RSpec. [https://docs.knapsackpro.com/2018/clean-rspec-configuration-directory-structure-for-ruby-on-rails-gems-needed-in-testing](https://docs.knapsackpro.com/2018/clean-rspec-configuration-directory-structure-for-ruby-on-rails-gems-needed-in-testing) &amp;#x200B;
Are you running all your feature tests with a browser or only those that need JS?
Only those that need js, of course.
I think you'll need to profile your tests to see what the issue is. Anything driven through selenium is going to inherently have more latency but I wouldn't expect as large a difference as you're seeing. I switching a few projects off phantomjs to selenium driven firefox several years ago (and more recently headless chrome) and I haven't noticed much difference in test time. One thing I do find odd is that you mentioned you needed to fix a lot of specs, if you were using just common capybara methods I wouldn't have expected you would need to change anything. I don't recall changing much when I was switching over, and what I did change was mostly removing nasty hacks that were needed for phantomjs. What types of things did you find broken? Another possibly related thing to look at with old test suites: poke around for anything that was monkey patched / workaround for phantomjs, you may find someone years ago monkey patched some core part of capybara with some screwy polling system that is causing the selenium latency to have a compounding affect (or something like that). 
&gt; Basecamp is already running Rails 6.0.0.beta1 in production, and both Shopify and GitHub and surely others will follow close thereafter. Is there a tutorial to upgrade 5.2 to 6.0 now?
This seems like pretty massive overkill for a simple query. I do agree that this is better done in pure SQL though, for things like this I generally create a view via scenic (https://github.com/scenic-views/scenic) which can then be easily queried by the app. 
good stuff . Congrats to the team
Does 6.0 make use of the new jit compiler?
Most of the specs fixed were simple things, like for example filling `input[type="date"]`: poltergeist accepted the '2019-01-19' format but chromedriver needed it according to the locale, like '01/19/2019'.. or thing related to visibility where chromedriver was "more real", as far as I can remember. But nothing that makes me suspect. I had profiled the code and updated the post, and I've found that the chromedriver version is spending a considerable amount of time at `TCPSocket#initialize`, where the poltergeist one is not. But not sure if that is expected or not! 
Thanks for your suggestion, we used to run the specs on our machines when we finished a branch (most of the time you just run relevant specs) and were ready to send a merge request. No need for a CI deploy until now because 20min was acceptable, but 40min is too much.
You don’t need to do anything special for the JIT to be used; it’s dependent on MRI, not on the Ruby code being run 
For profiling I would probably just start with the `--profile` option to rspec. In other words are all tests slower or just some? `TCPSocket#initialize` taking that much time is weird, I assume everything is running on localhost in your setup? If so it should connect instantly, It's also kinda strange that many connections are made.
You do need to enable it via command line flags though right? I don’t think the JIT is enabled by default in Ruby.
The more slow specs are the same when I run them with `--profile` comparing both (there are some differences when I run them multiple times but I believe GC is the culprit). So is not a specific test slowing down everything. Yes, I'mrunning on localhost.. this is the output of `stackprof output.dump --method 'TCPSocket#initialize'`: ``` TCPSocket#initialize (/Users/pablo/.rbenv/versions/2.3.3/lib/ruby/gems/2.3.0/gems/socksify-1.7.1/lib/socksify.rb:154) samples: 1649 self (15.5%) / 1659 total (15.6%) callers: 1659 ( 100.0%) Net::HTTP#connect callees (10 total): 7 ( 70.0%) block (2 levels) in &lt;class:Numeric&gt; 1 ( 10.0%) #&lt;Module:0x007fb459ee8f58&gt;.debug_notice 1 ( 10.0%) TCPSocket.socks_ignores 1 ( 10.0%) TCPSocket.socks_port code: | 154 | def initialize(host=nil, port=0, local_host=nil, local_port=nil) | 155 | if host.is_a?(SOCKSConnectionPeerAddress) | 156 | socks_peer = host | 157 | socks_server = socks_peer.socks_server | 158 | socks_port = socks_peer.socks_port | 159 | socks_ignores = [] | 160 | host = socks_peer.peer_host | 161 | else | 162 | socks_server = self.class.socks_server 1 (0.0%) | 163 | socks_port = self.class.socks_port 1 (0.0%) | 164 | socks_ignores = self.class.socks_ignores | 165 | end | 166 | | 167 | if socks_server and socks_port and not socks_ignores.include?(host) | 168 | Socksify::debug_notice "Connecting to SOCKS server #{socks_server}:#{socks_port}" | 169 | initialize_tcp socks_server, socks_port | 170 | | 171 | socks_authenticate unless @@socks_version =~ /^4/ | 172 | | 173 | if host | 174 | socks_connect(host, port) | 175 | end | 176 | else 1 (0.0%) | 177 | Socksify::debug_notice "Connecting directly to #{host}:#{port}" 1649 (15.5%) / 1649 (15.5%) | 178 | initialize_tcp host, port, local_host, local_port 7 (0.1%) | 179 | Socksify::debug_debug "Connected to #{host}:#{port}" | 180 | end ```
Again, that’s not related to the ruby code being ran (and therefore rails version), it’s entirely an MRI thing 
Your profile trace indicates a lot of calls through 'Socksify' which seems to be some gem that handles routes all network requests through a socks proxy. I don't seem to have this gem in any of my apps so I would figure out where this is coming from. 
Well you are right..! and 15% is quite a lot of time, the strange thing is that exactly the same method is never called even once when I run the specs through poltergeist: \`\`\` $ stackprof tmp/profile\_poltergeist.dump --method 'TCPSocket#initialize' $ \`\`\`\` [https://github.com/astro/socksify-ruby](https://github.com/astro/socksify-ruby) is a dependency of [https://github.com/savonrb/httpi/](https://github.com/savonrb/httpi/) that is also a dependency of [https://github.com/savonrb/savon/](https://github.com/savonrb/savon/) that is a gem we use to make SOAP requests. Looks like someone is monkey-patching stuff in a careless way, I will check if updating those gems help.
&gt; Socksify This thing is monkey patching the shit out of the Ruby network stack: https://github.com/astro/socksify-ruby First thing I'd do is figure out how to disable it, at least temporarily and see if it solves your issue. 
&gt; the strange thing is that exactly the same method is never called even once when I run the specs through poltergeist When you run tests in a 'real browser' it's going through selenium which is a network protocol. Basically capybara starts up then connects to a selenium server via a network connection which then connects to the browser driver (chromedriver in this case). I'm not sure how poltergeist works under the hood but it may not be via a network connection. Sorry you have the unfortunate problem of dealing with SOAP :( 
Yes, maybe that is the case because I remember reading somewhere that poltergeist had a better comunication protocol. Yes we deal with SOAP, because our app hits the government services for electronic invoices. And they will not switch to REST anytime soon!
You'll probably have to learn both ruby AND rspec fairly well BUT if you're adding code coverage to an established code base will rely on integration testing, ie. does putting X into the front of the thing yield Y on the back end of the thing. This is less desirable then isolated methods and unit type of testing but will be the only sane way to check an existing code base. One caveat with rspec mocks. They usually work best when the thing your mocking is a method call, i.e. don't mock within a method but instead mock the return from the whole method. This may cause you to have to decompose some of your code out into a method that you can mock but it usually makes for much cleaner code. Also remember method scopes of public, protected, and private have subtle differences to testers. Protected and private methods shouldn't require tests themselves, they should be obvious and simple and their scope constrained to the class. There is a reason rspec makes you explicitly call \*send\* on an object in order to call them in tests. YMMV on this one but because they're scoped to the class, testing the class public methods that use them should be sufficient. Be aware the feature specs are fickle beasts though because they usually rely on the DOM being rendered. You'll want to learn how to make the test suite headless with something like phantom.js. But TBH I'm not sure they're even worth writing most of the time as they tend to be more complex and front ends tend to change a lot so entropy will be an issue. Having said that, down the road if you can get your front end code into something like react or similar it will become much more testable as it will essentially be an isolated component. Good luck! 
&gt; Yes, maybe that is the case because I remember reading somewhere that poltergeist had a "better comunication protocol". Yea it's a trade off. Selenium functions as a 'standard' that all the browsers provide implementations for (chromedriver, safaridriver, etc). It's certainly clunky but the best thing around for cross browser testing support. The network request architecture is what I meant in a previous post about increased latency. However I personally haven't found the increased network latency to offset the (generally) better performance of the real browsers. It's possible if you are performing tons of actions in your tests this latency will hurt your performance more than I've experienced but it seems unlikely with a local testing setup. It usually only adds up if you using remote browsers (testing against a selenium grid on browserstack or saucelabs or something like that). On the soap thing: If you have a subset of tests you could run that don't use that library, and you aren't eager loading classes in test, then you may just be able to remove that gem and compare the performance difference. It would at least let you know if you've found the problem before digging deeper. 
Well bad news.. doesn't looks like the culprit, of course the monkeypatching exists, but after commenting out the gem because it wasn't needed for those specs this is the result: ``` ================================== Mode: cpu(1000) Samples: 10241 (1.77% miss rate) GC: 837 (8.17%) ================================== TOTAL (pct) SAMPLES (pct) FRAME 2165 (21.1%) 2165 (21.1%) SQLite3::Statement#each 1705 (16.6%) 1703 (16.6%) Logger::LogDevice#write 1611 (15.7%) 1589 (15.5%) Net::HTTP#connect ``` So `Net::HTTP#connect` is where the time is spent now and the running time is the same. Digging depper: ``` $ stackprof tmp/profile.dump --method 'Net::HTTP#connect' Net::HTTP#connect (/Users/pablo/.rbenv/versions/2.3.3/lib/ruby/2.3.0/net/http.rb:868) samples: 1589 self (15.5%) / 1611 total (15.7%) callers: 1611 ( 100.0%) Net::HTTP#do_start 1589 ( 98.6%) #&lt;Module:0x007f9a8d2aa268&gt;.timeout ``` I was suspecting about `&lt;Module:0x007f9a8d2aa268&gt;.timeout` but is from ruby stdlib: ``` $ stackprof tmp/profile.dump --method '&lt;Module:0x007f9a8d2aa268&gt;.timeout' #&lt;Module:0x007f9a8d2aa268&gt;.timeout (/Users/pablo/.rbenv/versions/2.3.3/lib/ruby/2.3.0/timeout.rb:73) samples: 3 self (0.0%) / 1598 total (15.6%) callers: 1589 ( 99.4%) Net::HTTP#connect ``` So I am where I've started :( 
I've followed the stack trace back to: \`\`\` $ stackprof tmp/profile.dump --method 'Net::HTTP#request' Net::HTTP#request (/Users/pablo/.rbenv/versions/2.3.3/lib/ruby/gems/2.3.0/gems/webmock-3.4.2/lib/webmock/http\_lib\_adapters/net\_http.rb:74) samples: 2 self (0.0%) / 2317 total (22.6%) callers: 2311 ( 99.7%) Selenium::WebDriver::Remote::Http::Default#response\_for \`\`\` So looks like that 15% is just Selenium protocol penalty.. but where is the other time spent then.
Did you time a test run? I'm curious what impact it had on the time ignoring the profile data. 
You mean how much overhead adds profiling?
Could be. I'd compare the test timing still tho (without the profiler active). A CPU profile will only tell you where the CPU time was spent but won't necessarily show a change in IO wait time. 
Sorry - replying in two places now. But I mean that you're doing a CPU profile which will only show you samples of the process when it's active on the CPU, it doesn't tell you how long it's spending waiting on IO (like waiting for some command to execute in the browser). In other words the shift in your stackprof may or may not represent the shift in the time it took your tests to run. 
From a fellow Java programmer its good to know the jump won't be too challenging. What's this toy robot challenge, do you mind summarising what's it about and may be a link too?
I've updated the post with the "wall" or total time profile.. most of the time is spent waiting for I/O it looks (which is factible I believe).
I know these are contrived examples of things one can do but I feel like they can be solved in some other more straight forward manners. For the the count example rails has this https://guides.rubyonrails.org/association_basics.html#options-for-belongs-to-counter-cache already built in For the first name/last name example one can skip even creating the active record objects with pluck by doing something like. User.pluck(:first_name, :last_name).map{ |n| "#{n[0]} #{n[1]}" } You get the advantage of using select on the columns as well as skipping the allocation of AR objects. Of course there's lots of down sides you can't chain and you don't get all the niceties that come with AR.
Oh sure 😁 I usually commit this as: PROBLEM.md Toy Robot Simulator Description The application is a simulation of a toy robot moving on a square tabletop, of dimensions 5 units x 5 units. There are no other obstructions on the table surface. The robot is free to roam around the surface of the table, but must be prevented from falling to destruction. Any movement that would result in the robot falling from the table must be prevented, however further valid movement commands must still be allowed. Create an application that can read in commands of the following (textual) form: PLACE X,Y,F MOVE LEFT RIGHT REPORT PLACE will put the toy robot on the table in position X,Y and facing NORTH, SOUTH, EAST or WEST. The origin (0,0) can be considered to be the SOUTH WEST most corner. The first valid command to the robot is a PLACE command, after that, any sequence of commands may be issued, in any order, including another PLACE command. The application should discard all commands in the sequence until a valid PLACE command has been executed. MOVE will move the toy robot one unit forward in the direction it is currently facing. LEFT and RIGHT will rotate the robot 90 degrees in the specified direction without changing the position of the robot. REPORT will announce the X,Y and F of the robot. This can be in any form, but standard output is sufficient. A robot that is not on the table can choose the ignore the MOVE, LEFT, RIGHT and REPORT commands. Input can be from a file, or from standard input, as the developer chooses. Provide test data to exercise the application. The application must be a command line application. Constraints The toy robot must not fall off the table during movement. This also includes the initial placement of the toy robot. Any move that would cause the robot to fall must be ignored. Example Input and Output Example a PLACE 0,0,NORTH MOVE REPORT Expected output: 0,1,NORTH Example b PLACE 0,0,NORTH LEFT REPORT Expected output: 0,0,WEST Example c PLACE 1,2,EAST MOVE MOVE LEFT MOVE REPORT Expected output 3,3,NORTH Deliverables Please provide your source code, and any test code/data you using in developing your solution. Please engineer your solution to a standard you consider suitable for production. It is not required to provide any graphical output showing the movement of the toy robot. 
Did you read the whole post? I talk about exactly these things in the section on caveats and why those examples were chosen. 
 Enumerator#+ This looks fun
 case 'bb' when 'a'..'c' then 'matched' else 'not matched' end #=&gt; 2.5: 'not matched' #=&gt; 2.6: 'matched' Surprisingly, this is wrong :) While the language, in general, have switched to `cover?`, there is a special case for `String` to still use `include?` See in source: [1](https://github.com/ruby/ruby/blob/trunk/range.c#L1351) and [2](https://github.com/ruby/ruby/blob/trunk/range.c#L1392). So... ('a'..'c') === 'matched' # =&gt; false I believe that is done to satisfy the Holy Cow Of Backwards Compatibility.
There's no server, it's just client application..
Thanks for the link, will check it out :)
Big thank you from me to people working on Rails and towards this release!
Being able to turn off exceptions in kernel methods looks like a two-edged sword.
It is not anything new, but it is nice to get out of the box.
I cannot replicate your 2.6 behaviour. What's happening? 2.5.3: https://carc.in/#/r/61yg 2.6: https://carc.in/#/r/61yh btw I couldn't reproduce it locally either. 
The behavior described (with `"matched"`) is from original article. My comment explicitly explains why it is NOT this way. I'll edit the comment to clarify this.
Not really - it only gives you more flexibility. Which is good. It's no free pass to disable thinking of course. People should only use it when they really need it. And now they can, if they need it, which is good.
I consider it terrible. There are too many people making awful suggestions in the last ~3 years and unfortunately matz approves too many of these, in my opinion. While matz is obviously in charge of ruby, I think if the ideas that flow into ruby are garbage to begin with, we'll end up with changes that are bad too. Not all changes are terrible of course; #+ is not as bad as the &gt;&gt; syntax s***.
&gt; to satisfy the Holy Cow Of Backwards Compatibility. The alternative would be people complain to matz how terrible changes are that kill their code. I am not in charge of ruby but I can understand matz point of view very well.
I see, probably I just didn't read your comment carefully enough, that's why I misunderstood what you said. Thanks for clarifying 
Some of the changes are ok. - Bundler integration may help rubygems + the ecosystem in the long run since they could focus on unified code (not duplicate what they do etc...), and it may help people who use bundler, in particular rails folks. I don't use bundler myself but I think this change was a good one. - Other changes about introspection were fine too; AST. Binding.source_location and so forth. - The jit is still the most interesting one (to me). May take a while not only for it to become faster, but for people to understand it. I still don't fully understand it. - cover? is ok and % operator syntax shortcut is also somewhat ok as is Enumerable#to_h. Now let's go to the worse or really terrible parts: - Enumerable#chain - terrible name. I already chain methods when I do foo.bar.bla so why do I get an additional name that does sound as if it were to do the same thing, but does something else? The one who proposed this is also active here on reddit. :P I don't have a very strong feeling against #chain though. Who ever writes code like this: (1..3).chain((5..7), [9, 10]).to_a That's just madness. From the behaviour it more sounds like .merge() or .update() rather than a chain. - Kernel#then is an improved name over the clumsy yield_self, but I don't even think yield_self was needed to begin with. Look at the contrived example: isbn = '978-1-93778-549-9' isbn.gsub('-', '') .then { |isbn| URI("#{API_URL}?q=isbn:#{isbn}") } .then { |uri| Net:HTTP.get(uri) } .then { |json_response| JSON.parse(json_response) } .then { |response| response.dig('items', 'volumeInfo') } Again - WHO writes code like this??? I'd never. It has way too much information density for it to be simple to understand on a first glance. Totally contrived. Endless ranges: when 100.. then 'Three or more' I don't have a huge con opinion against endless range as such; and omission of syntax is always shorter than any other syntax. But to my mind, it makes no sense that when we OMIT something, it now means ... infinity? Does this make any sense to anyone else? I understand the practical aspect of it and I don't disagree with the practical argument. I reason against this being anything logical. Do note that Float::INFINITY is also clumsy; people should not need to have to scope towads Float:: (because I also don't think infinity as a concept should be tied to Float per se or require of users to know where infinity hides in ruby). It's also that matz may agree to one or the other alternative thought here since he appears to have stated in that developer meeting that ruby may need a concept (or have an expression of) for infinity. I preferred the oldschool behaviour of having a START and an END for ruby ranges. I am not entirely against the feature though as the practical side means that you can simply omit the end part, which is ok. Less code can be more, even if I disagree with the "logic" behind the argument or proposal by mame here. Ok - and now to the by far shittiest utter garbage: Composing procs, lambdas and methods I already realized a while ago that the "functional" crowd is up to 90% insane; or clueless; or both; or does not even use ruby to begin with. Of course you can say that ruby is a multi-paradigm language, which is true. Has been since many many years, even though the primary focus is still, in my opinion, OOP. But what garbage comes out of the functional crowd is beyond belief ... It already begins with this: square = -&gt; (n) { n * n } I never liked -&gt; and never use it in my code. This, in fairness, is an old change, so not a recent one. I have several complaints about it but the primary one is one of aesthetics - whenever I use -&gt; or would want to use it, it feels at odds with the rest of the ruby code written in an OOP style. It's also clumsy IMO. Yes it is shorter than lambda, but come on ... 3 or 4 characters used sparingly, is enough to use terrible syntax? Anyway ... (square &gt;&gt; add_2).call(5) #=&gt; 27 (square &lt;&lt; add_2).call(5) #=&gt; 49 This is clarity of intent? It looks like terrible garbage. I don't even know what &lt;&lt; means, yet alone &gt;&gt; which is the by far most awful addition in a very long time. With the #&gt;&gt; operation, the number gets squared first and then add_2 is performed on the result of the first proc call. And people should assume this? And why is this terrible syntax even used? You have other ways to express the above. In case of #&lt;&lt;, the order in which the procs are called is reversed. AND WHO CAN REMEMBER THIS WITHOUT HAVING TO LOOK UP? And why do we have to pay so close attention to &gt;&gt; or &lt;&lt; now? &gt; I wish we didn’t have two different ways of composing procs Yeah. I wish we wouldn't have either &gt;&gt; or &lt;&lt; here. &gt; and only had #&gt;&gt;. But composition is an important addition to Ruby that will &gt; allow us to write in a more functional style. I read the same propaganda here on reddit. I wonder if the dude is the same who wrote this with an account here. I don't see what is more "functional" here. What I see is ad-hoc syntax that is terribly ugly. Of course the "functional" clowns do not understand why syntax matters. The problem is whenever you try to assimilate concepts from other languages but keep on thinking how a 1:1 mapping works. No it does not. Elixir's pipe syntax does not work in ruby; and haskell's syntax does not work in ruby either. You can't please everyone and it is a terrible mistake to want to try to remodel a language to cater to whatever random average joe wants to have in the language. Years ago I thought that haskell is very snobbish; they also openly stated that they do not want to have everyone use haskell either. Which I thought was mean. But now, years later, I realize how random clowns making random, terrible suggestions, can make a language worse. So I have to agree with the haskell folks - not everyone should use a good language such as ruby. Please stay away, stick to php, javascript, or if you want "functional", whatever that means, go focus on Haskell and leave the rest of us alone. It's the same with ideas, too - garbage in? Garbage out. We don't get great ideas when the ideas begin on terrible grounds. And the "functional" sub-crowd in ruby is by far the worst at "designing" a language. Perhaps that is why TIOBE does not show any functional language in top ten, since nobody can use these languages anyway. 
&gt; Right now I noticed that I find Java to be a bit redundant relative to Ruby Java is terribly verbose. If you can make the code short, I'd try it (or use kotlin which is better). Java is less dynamic and thus more strict. It's a different philosophy of OOP. Personally I don't like the Java OOP model but it is a fairly simple one nonetheless. &gt; Ruby seems to just be so elegant and aesthetic in comparison so far. Yeah. Ruby is the better designed language. It is a bit unfair to compare typed languages to non-typed ones - you add a lot of syntax garbage when you have to denote the types you use. That is always the case by the way; look at the python type proposal. It also makes python syntax-wise heavier. Same problem with crystal. Type systems destroy language aesthetics a lot. The only promised gain is more speed since you spend time helping the compiler upfront. 
&gt; the language feels like it stayed in the 90's That's an interesting remark and I agree with it. Even C++ changed quite a bit syntax wise, e. g. auto, and other changes. Java does not seem to have changed much at all from the 1990s era, indeed.
What do you think about context in Phoenix? I think context definition should be optional. For an app like this, contexts do not make any sense. Project structure is confusing as well.
&gt; I don't use bundler myself So you don't code with dependencies? Bundler is very much a "Ruby thing" as it is a Rails thing. I guess you can make gems without Bundler but it makes development a version nightmare. Well except you are still using something ungodly like rvm.
Ya, I did back up my system and reinstalled to fresh Mojave. Than installed rbenv and all the configurations needed. And seems like everything works fine now.
Wow. This makes me sad. There is way too much “clever” going on here, to the detriment of clarity and readability. What a shame.
Pretty solid list. There’s a lot more detail in several of those layers that should be learned depending on your infrastructure. Networking especially is a scary beast. Hardly a mention of SSL or packet encapsulation etc.
I'd probably add Prometheus/Grafana to Application/Infrastructure monitoring. 
Agreed!
As this is /r/ruby I should point out that this roadmap is very Ops-centric. That's not a bad thing per se, but developers often find this daunting at first. So what I'd suggest is that you do the following: * Install Docker and learn how to use it (including making Dockerfiles and using Docker-compose) * Install Virtualbox and Vagrant. Learn the basics. This puts you in a good position for learning more. Hell, with just Virtualbox and Vagrant you have a base for learning Linux, plus config management tools like Ansible and Chef, plus any of the Linux-based toolset.
yeah, I really appreciate the aesthetic nature of Ruby now, its a beautiful language really. So what does 'type systems', and/or typed language vs non-typed language mean exactly? meaning always/often having to specify data type? I do notice that a _lot_ in java and coming from Ruby it seems superfluous. Ah, and that helps with speed and helps the compiler upfront, interesting. I have a lot to learn. 
I kinda like it for the methods they implemented it in. I mean these two are functionally the same except that exceptions are rather expensive so it's way slower. This shouldn't be a performance problem generally but I don't see the inherit problem with this on things like Integer, Float, etc. since you could achieve the same before, just way slower... [4] pry(main)&gt; RUBY_VERSION 31µs =&gt; "2.6.0" [5] pry(main)&gt; Benchmark.ips do |x| [5] pry(main)* x.iterations = 3 [5] pry(main)* x.report("with exceptions") { Integer("foo") rescue nil } [5] pry(main)* x.report("without exceptions") { Integer("foo", exception: false) } [5] pry(main)* end Warming up -------------------------------------- with exceptions 40.455k i/100ms without exceptions 206.706k i/100ms with exceptions 40.456k i/100ms without exceptions 207.047k i/100ms with exceptions 41.132k i/100ms without exceptions 205.813k i/100ms Calculating ------------------------------------- with exceptions 456.502k (± 3.5%) i/s - 2.303M in 5.051980s without exceptions 3.342M (± 4.6%) i/s - 16.671M in 5.001409s with exceptions 452.534k (± 3.8%) i/s - 2.262M in 5.006540s without exceptions 3.358M (± 2.9%) i/s - 16.877M in 5.030043s with exceptions 446.824k (± 3.8%) i/s - 2.262M in 5.070464s without exceptions 3.374M (± 2.5%) i/s - 16.877M in 5.005078s 
Do you know which stack of the existing code base are they using? I think you can just ask them. If you don't know, focus on Ruby, page object stuff, you can learn to use automation frameworks later, it's not a big deal, Cucumber, Gherkin, Watir, page object gem,... &amp;#x200B;
Context definitions are actually very optional. They are a part of the suggested architecture using the generators, but just as a convention. You can deviate from this, because everything is explicit, instead of implied or inferred by the framework. In the end, you need modules to put functions into. What would you recommend as an alternative?
There is no way to "become a DevOps" -- there is no such job, ffs.
We have a department called dev ops.. company size: &gt;10,000 I'd you're in the bay it's probably "something-something [evangelist/rockstar/ninja]" 
This is an excellent diagram. Even if you’re not trying to get a job as a devops engineer, this is a great overview of many things that you, as a developer who may one day need to build and manage a professional production environment, might want or need to explore to make your life easier or more reliable or safer or some combination of those.
Don't forget the culture aspect. Read books like "The Goal", "The Phoenix Project", "It's not luck" and "Beyond the Phoenix Project." That last has a volume of footnotes that could be it's own book, and points to great further reading.
Man this is daunting. 
Thank you! I should've run all the code examples through both versions first. I've updated the article to correct this. Also, awesome work with the changelog! That's an fantastic resource. :)
I don't know. Part of me is a big fan of saying that DevOps isn't a role, it's a culture. That if you have a DevOps department you might as well call it the Collaboration Department. Everyone has to collaborate, not just one department. But there's 100% a "too far" in all that. Do you want developers writing their own Dockerfiles? Likely: that's a part of communication as code. But going to far down that road you have developers writing their own build scripts, Cloudformation, worrying about DNS, the ELB, oh we need to prewarm the ELB before load testing for that many hits, oh wait what size of NICs are in the EC2 instances, what's the VPC structure, how does the direct connect back to on-prem work, how are we provisioning the instances that run the Docker scheduler? The last thing a developer want to do is to find themselves deep in Chef land because they need to change a config file to support the larger network card they provisioned so they can throw 100,000 rps during peak load testing at their microservice in the container hosted on the the ECS cluster, but oh wait turns out the AMI for Fargate ECS instances can't be the corporation's custom AMI, and wait to get this to build at all I have to modify half the Jenkins Groovy pipelines because we need to add this new native library but it doesn't compile or run too well on Amazon Linux so we have to.... ... and there's the point where you either break engineers (Hi! Going too far down this path broke me!) or you just can't buy engineers that are skilled enough to fit your needs. Oh, because your engineers also need 5+ years Rails experience and a proficiency in writing Cucumber test cases that interact with Selenium. Yes: certainly: you build it you run it. And sometimes you do want to or need to know the network path used because during a critical incident it might be important. But given my choice I'd much rather have "developers who can SRE good enough.. and can write a Docker file and understand the memory profile and scaling of their microservices and know enough to deploy it to a known good target" than "developers who also write Chef/CloudFormation/Kubernetes deploy yaml/manage AWS resources/get dragged into unix management and can figure out how to write a Jenkins pipeline for that one dude who decided to write their app in Scala because idiot, and..." So: was initially on the "we all are devops" train... but given a choice between "we are all devops" and developers supported (properly and in a timely manner) by people who actually know all this stuff... well keeping up with two ever changing fields (plus front-end-land, if you're fullstack!) starts to stress anyone but your best of your best engineers after a while.
See my other comment in this thread. Start it off easy, work your way up. 
You clearly don't have a clue what you talking about.
The name of the department does not mean people there are called the same word. DevOps is just what that department does and it can consist of sys admins and software engineers of different sorts. It can even have QA engineers to work around their internal stuff.
This is on mobile so forgive me for any typos. &gt; But to my mind, it makes no sense that when we OMIT something, it now means ... infinity? Does this make any sense to anyone else? I dunno, this makes sense to me. What would a range bounded on one side use as the other bound if not infinity? &gt; I don’t even know what &lt;&lt; means, yet alone &gt;&gt; which is the by far most awful addition in a very long time. They point along the flow of execution. This is also a syntax in other languages. Overall, I don’t really understand the anger. If you don’t like these features, don’t use them. Would you use the language in your comment in a code review at work? MINASWAN :) Have a nice day!
Devops engineering is a thing.. I have a degree in computer science, but have had various titles, software engineer, web developer, system administrator, software architect.. I've worn various devops hats, and if I wanted I could be a devops engineer. You're getting downvotes because you're nitpicking.. and are generally wrong.
As someone who has worked in Devops for several years, I despair every time I see these extreme focus on tools and detail knowledge, forgetting about the cultural aspects and soft skills that Devops is based on. Devops is an exercise in removing silos and fences, and bringing teams and different disciplines closer together. The job description of Devops engineer is going to disappear in the next five to ten years, at least in companies that practice the above. Learn the concepts and internalise the ideas. The tools and detail knowledge are going to follow by themselves. 
The hell is this comment doing here. Someone explain this. 
I much prefer InfluxDB and the Tick Stack with Grafana over Prometheus. Prometheus' pull method of metrics gathering is outdated.
&gt;medium.com/@meraj... Generators should assume contexts optional. I was looking at your code. You have \`Minitwitter.Microposts.Post\`. Wouldn't it be more DIRY if it was just \`Minitwitter.Post\`? My point here is contexts should be optional even if while using generators.
I'm not the post author, but yes I agree with you. Recently, I have just been defining my schemas at `MyApp.Data.MySchema` and then have root-level modules like `MyApp.MyContext`. I found too often that schemas were shared across context boundaries, and that artificially trying to draw lines in the sand about how a context could interact with a schema was just an exercise in futility. As far as generators… yeah I will run the schema generator and then move the schema file and rename the module. For everything else, I literally don't use generators.
DevOps isn't just about technology, but also about how you go about solving problems and how you form and interact with colleagues.
1. You need to enable it with command line option or env var See example at https://blog.heroku.com/ruby-just-in-time-compilation 2. JIT is still unoptimized for complex framework like Rails or Sinatra and enabling it might cause a performance drop Found an article with benchmark on Sinatra: https://www.rubyguides.com/2018/11/ruby-mjit/ I remember I saw an article with rails benchmark but I can't find it again.
DevOps is first and foremost the culture of collaboration and team work. It's how you break down the department silos. It's why DevOps became a thing in the first place. 
Waiting for videos on Youtube.
hmm where is everybody? matz no likey empty room!
Haha. Don't worry. It was lunch break, I came early. :)
Hi please include me 
Where is the conf?
It was in Goa.
Is Ruby happening in India? I thought India was all about ASP.NET.
A lot of people here likes ruby, including me, but the old hags just won't let go off .net and java bullshit. Hence they were lacking a lot, after digital india moment, a lot of govt. Websites and newer websites got refurbished and more secure, we are replacing the previous architecture . Hope this opens up a lot of jobs too, amd private companies accept ror and ruby.
11am PST happens when this comment is 8 hours and 11 minutes old. You can find the live countdown here: https://countle.com/saj068LUE --- I'm a bot, if you want to send feedback, please comment below or send a PM.
Yes. As a matter of fact, this is the 10th Ruby conf in India.
I am in this photo too!
From the look of the chairs I thought maybe it was a dental conference 😂
&gt; Rescue is the alternative to Sidekiq. It is used to handle Ruby exceptions. I think you mean Resque and you are linking to a wrong page.
Does Matz flirting with those two girls? &gt;! I'm joking
Dental or matrimonial?
I don't think so. Those two girls helped him reach the conference location, as he was kind of lost at the airport. 😅
Matz's humble..
I think _all_ of ActiveStorage's image processing is "JIT", no? I ended up not using ActiveStorage, because it didn't appear to be flexible enough for my needs. But JIT is what it does I think. 
Perhaps it is indeed *all* like that. I turned away in disgust to be honest and went back to my background image processors.
Looking at using named functions with arel, I wonder whether I wouldn't be better off just writing it myself. 
You certainly could! It depends on if you care about being able to change databases later on. 
I consider the "switching databases" argument very weak, specially considering db functions. However, I'd be totally down for a DSL that abstracts and simplifies calling a db function. Sadly, ARel is overly verbose. Consider the 4 lines of code from your example just so that you could text `CONCAT("users"."first_name", ' ', "users"."last_name")`...
I've been using shrine. Which doesn't do exactly what I need, but gives me the tools to recombine into what I need, after some time spent code diving. I'm working on an app in which file handling/management is central to the business domain, though, so I really need full control over what's up. 
Nice! Simple examples that made your point come across easily while conveying lots of information.
ME TOO
Could be both. :&gt;
Nah - matz is always smiling no matter who it is.
They lost matz on the way!!!
thank you :) 
&gt; Zeitwerk started out of the desire to build an autoloader for Rails 6 &gt; Integration not there yet. The classic autoloader is not going anywhere by now though, the plan is to have the option to opt-in and use Zeitwerk. Wow, I would love a new code loader in Rails. If it's thread-safe as claimed, I wonder if this would allow disabling the fairly complicated thread-safety "executor" stuff that showed up in Rails 5... and makes auto-loading thread-safe finally, but at the cost of making it impossible to use generic thread-based concurrency in a Rails app without making the code aware of the "executor" API. 
Very good refactoring tip..
Example project using it: https://github.com/Roman2K/alerterr
Is _that_ what refinements are for?
This is great! Thanks for this and the extremely detailed description :)
This is a wonderful addition to the library, and looks like it was implemented with great care. I'm excited to try Shrine in new projects this year. My only suggestion would be to consider a different name, because "derivative" is often an insult or an expression of disapproval, like "clichéd" or "imitative". Some possible alternatives: - computed_endpoint - dynamic_endpoint - on_demand_endpoint Actually even "derived_endpoint" would work, as I don't think "derived" gets used as an insult like "derivative" does. 
The downside to me is the control flow is not apparent from the code. If I see some code that does 1234.to_isbn, there's no indication where that method is implemented. And even if I find the definition of to_isbn, that itself relies on these other methods that aren't obvious where THOSE are implemented. I would prefer to see ISBN.from_integer(1234), ISBN.from_string("1234"), etc. It's obvious who is responsible for the transformation, it's obvious what you're getting back. It's not "elegant" so I'm sure people will hate it, but that's why I don't write much Ruby anymore I guess.
Thanks a lot for the feedback! I agree the name should be changed; I looked at the first definition as an adjective, and that's really not what I wanted to communicate :P Thank you for the suggestions. I've actually considered "dynamic_endpoint" originally, but I discarded it because it doesn't really describe what it does. If you would call `photo.image.dynamic_url(:thumbnail)`, it's not really clear what exactly is the "dynamic" component. Similar for other options; "on_demand" has the closest association, though, but I would prefer to use a single word if it's possible. What do you think about calling it "derive_endpoint" instead? I feel like it fits nicely with other "endpoint" Shrine plugins (upload_endpoint, download_endpoint, presign_endpoint), which also use verbs. And it says what it does – it "derives".
I've been tempted by shrine. I'll take another look. 
I know it's not the point of the post, but I just wanted to point out a handy alternate way to write code from the first example. Instead of a list of `elsif thing.is_a? Thing`, you can use `case` which tests with `===`. Modules (and therefore classes) define `===` similar to `is_a` [doc](https://ruby-doc.org/core-2.2.0/Module.html#method-i-3D-3D-3D) which makes for nice case statements with type checking. ``` module ISBN # or class and initialize, or whatever def self.parse(value) case value when String value.gsub(/[^[:digit:]]/,"") when Integer value.to_s else "" end end end ``` Personal preference, but I thought it was a cool opportunity to show the case type checking trick for anyone not aware. 
Interesting. I'm the other way around. Python was my first scripting language, then I learned Ruby. Now I feel icky whenever I write Python code.
I get where you are coming from, but with 'using blabla' in the top, control flow isn't that unclear, and searching the project for 'Def to_isbn' isn't too complicated either. Rails already does this(but with monkey patching) , so it's not like it's very far outside the box for most people. As for what you get, I'd say that the method should be kept at 'to_isbn_string' and another method 'to_isbn' should be defined as 'Isbn.new(self.to_isbn_string)' so that, just like previous to_x, you get the object type you expect. 
That's fair. If you only work in one project it's probably not too bad of a search. I like to fairly regularly break larger projects into smaller ones, spin things out into modules etc. That's part of why I place a premium on making things understandable at-a-glance.
I get the feeling you did more than "find" this.
Haha could be, Matz may be a pickup artist disguised as a humble computer programmer!
I'm always happy to see Matz \^\_\^ &amp;#x200B; But am I only one freaked out about those chairs ? 
So based on the diagram above: an Order belongs\_to a Product? Meaning you can only have one Product per Order?
There's probably a more efficient solution, but here's a quick try: product_ids = Orders.where(customer_id: params[:id]).pluck(:product_id).uniq Customer.joins(:orders).where(orders: { product_id: product_ids }).where.not(customers: { id: params[:id] })
Yes. Only one product per order. Thanks for looking!
Thank you! Worked.
Use 'ffaker' instead of faker. It's way quicker and you'll feel the impact if you create large datasets.
In my experience it definitely takes a bit of investment to figure out how all the pieces work and what to do with them, but the reward is you can do exactly what you want with them, without having to write everything from scratch yourself too. I think the net result is positive. I'm not scared to customize, or not use a shrine feature that doesn't do quite what I want in favor of a custom one I write -- I think it's still a lot quicker and a lot better maintenance story than writing everything from scratch, if you need full control/flexibility, and still much more flexible than AS or carrierwave. 
Rather POROs by themselves it's rather design patterns that guides this kind of refactoring (here the Factory design pattern, but there are many other like Form Builde etc.) which are often implemented by POROs. Nice reading btw..
Is it impossible for somebody to order two products at the same time?
Awesome. I've said it before and I'll say it again, Action Text should not be included in Rails core.
Use distinct before pluck to eliminate the extra Array looping step triggered by uniq. product_ids = Orders.where(customer_id: params[:id]).distinct.pluck(:product_id) 
`product_ids = Orders.where(customer_id:params[:id]).pluck('DISTINCT product_id')` so you avoid to make the uniq in ruby :)
I would guess that it's because you don't have your calc method taking any variables. Change 'def calc', to 'def calc(num1, num2, op)', and then when you call it, instead of just 'calc', run 'calc(num1, num2, op)'.
Well I'm sold! I started to run into major issues with carrierwave when I started building a UI cropper. It was unnecessarily complicated to work around the DSL to get references to the model where I needed it. I'll definitely consider replacing it as I need to overhaul the current image management, anyway.
Hi /u/racarete Welcome to Ruby! So, a great deal of what's going wrong is in the error message, and I understand when coming to a language, understanding the errors is often difficult, they're sometimes cryptic, etc. Let's take a look at the error you're getting though. calc.rb:2:in \`calc': undefined local variable or method \`op' for main:Object (NameError) from calc.rb:24:in \`&lt;main&gt;' That's the error I get because I named my file calc.rb. It's telling me that in line 2. if op == "+" That there's an undefined local variable or method op for main:Object (NameError) and that this method was called from line 24 calc So, what's going wrong? I'm willing to bet this is the process going on in your brain, is that you've defined the method, then later, you've defined your variables, num1, op, and num2, before calling the method, so they should be there. There's an issue with scope though, those variables aren't accessible inside of the method, so you either have to pass them in, or ask for them inside of the method. Let's pass them in, instead. def calc(num1, op, num2) if op == "+" puts num1 + num2 elsif op == "-" puts num1 - num2 elsif op == "\*" puts num1 \* num2 elsif op == "/" puts num1 / num2 elsif op == "\*\*" puts num1 \*\* num2 else puts "invalid operator" end end &amp;#x200B; puts "enter first number" num1 = gets.chomp() puts "enter operator" op = gets.chomp() puts "enter second number" num2 = gets.chomp() &amp;#x200B; calc(num1, op, num2) So, what I did is i added parameters to the method definition, num1, op, and num2. These are just names, and I could have used a, b, c, or number1, operation, number2, and I would have just had to change what I was invoking inside the method. In the method call, I added in the variables we wanted to pass in, in order they'd be received by the method. Just as an example, let's say I had called the variables 'a, b, c' in the method definition, num1 would become a, op would become b, and num2 would become c. This is a little bit of a simplification, as what's really happening is we're passing the value of the original variable in and it's anew object inside of the method. So, what's the result of that code? enter first number 8 enter operator \+ enter second number 5 85 Well, that's not right, so what went wrong? In this case, we've entered in strings, and in Ruby you can add strings together. So it needs to know that we're really wanting to treat these as numbers. Let's solve that by changing line 24 to calc(num1.to\_i, op, num2.to\_i) Now what happens? enter first number 8 enter operator \+ enter second number 4 12 Awesome, that looks correct &amp;#x200B; There's still some more problems here, but, I think that covers a bit, gets you going a little further, and you can ask questions as you discover some of the other issues. :) Have fun, and welcome to Ruby! Let me know if you need more help.
yes! nice one.
I'm just wondering.. how is on-the-fly image processing a good idea? I still can't wrap my head around a call in my view kicking off an image processing job.
Currently you're calling calc, and calc is trying to access those variables, but calc has no knowledge of those variables because you aren't passing them to calc as arguments. Defining calc like such: def calc(num1, num2, op) Then calling it likewise: calc(num1, num2, op) Should give you the desired result. You'll also want to add .to_i after the chomp on your numbers. This will cast them to integers as opposed to strings.
The ruby community rocks because of people like you.
I'm not sure what you mean by an "image processing job", what happens is that the thumbnail will be generated on initial request (and cached on subsequent by your HTTP cache). But yeah, on-the-fly processing is not for everyone. That's why I prefer a file upload library to offer both options (on-the-fly processing &amp; processing on upload), so that the developer can choose what they want. Shrine will be the first library to offer both.
Just wanted to say: what an outstanding response.
Thanks the for the detailed explanation, it really helps me out!
Correct. Only one because of the nature of the product. Kind of like a subscription. There is no point buying two or different products at the same time, however once the purchase runs out at another time, the same customer may buy the same or another product again.
Short yet informative! I like it! I would've never thought `ensure` returns the result of the expression before it. So, why does `ensure` work that way? I couldn't find the answer to that in your article.
&gt;ffaker Thanks for the tip. I will give it a shot.
 # customer.rb class Customer &lt; ApplicationRecord has_many :orders has_many :products, through: :orders end # Controller @customers = Customer.joins(:products).where(products: { id: @customer.products }).where.not(id: @customer) This uses has\_many through and subqueries.
I think `derivation_endpoint` is a great name. I did think of an API suggestion, but I think it might be a paint to implement, and I'm not sure it'd be worth the trouble. I'll try to explain it in a comment on the PR.
I believe, the idea of `ensure` is "necessary cleanup", not "definitely last statement". So, imagine you have this: def my_method # main logic, including probably acquiring some resources, # like opening files and ports # last_statement # that's what you've calculated, in fact rescue =&gt; e # execution have NOT reached the last_statement, so you need to return something else value_when_error end No, you notice that you need to free some resources (like files) in any flow, so, now you have def my_method # main logic, including probably acquiring some resources, # like opening files and ports # last_statement # that's what you've calculated, in fact rescue =&gt; e # execution have NOT reached the last_statement, so you need to return something else value_when_error ensure # if there were no errors, execution HAD reached last_statement, # and the "main" return value was calculated properly # so here you can just do some file.close without thinking of what to calculate # # ...or there was error, and execution have reached value_when_error, and again, # you already have "what you wanted to return", and don't want to think about it here end 
If you are curious what an advanced form of this might look like, I implemented your problem as I would do it. (I'm 15+ years as a software professional, much of it in ruby) VALID_OPERATORS = %i[+ - * / **] def calc(num1, op, num2) raise(ArgumentError, "#{op} is not a valid operator") unless VALID_OPERATORS.include?(op) num1.send(op, num2) end puts "enter first number" num1 = gets.chomp.to_i puts "enter operator" op = gets.chomp.to_sym puts "enter second number" num2 = gets.chomp.to_i puts calc(num1, op, num2) A couple notable things I did that make it different. 1) if an invalid operator is given, I throw an exception, not simply put a message to stdout 2) I keep all the user interface out of the calc method (gets and puts) 3) In the user interface code (the gets and puts) I coerce the data into the types I want it to be in, symbols and ints, rather than strings 3) You don't really need the "if tree", as the thing you check for is the thing you use; you 'send' * when the operator is '*', I used ruby's features to simplify that. (You probably shouldn't do this yet, but I wanted to show what was possible) Ignore if you think its too much, or ask questions if you are interested.
This is the most optimised answer out of the ones in this thread, as it will generate a single query with a nested select in it, instead of running 2 or more queries and making Rails iterate through the intermediate data. Doing a single query is good as it makes the DB do all the work, which is usually the correct approach, as it is literally made for this.
Thanks a lot!
In short, `ensure` is called only if the evaluation of the main code doesn't reach the last statement. Thanks :)
Just to add on for the uninitiated - #send can be a very dangerous method and shouldn’t be used with user input unless you’re sure it is processed and safe. You’ve gone the method argument check and raised an exception, so you’re good. But, gone unchecked, someone could theoretically wipe your hard drive or database, or gain access to it. It might be even better to use #public_send if this were a production app, though that’s arguably not a lot better.
Thanks guys, Sorry for the late response. It is a Ruby on Rails app. They are wanting to take it to WP because they don't need the robustness of it anymore. The main reason they had the site on ruby is no longer a reason to keep it on ruby. With the securities and types of file transfers needed to publish anything new to the site took 20 min at least, where WP would allow it to be done in 10 min tops for the same job. Hope that helps some.
Damn that was so much more detailed than "pass in op it is undefined." Very nice!
Useful: http://ruby-for-beginners.rubymonstas.org/writing_methods/scopes.html
No-no, that's not the point! `ensure` is called _always_, but its goal is "final necessary actions", not "finally calculation of the result". On some imaginary example (kinda pseudocode): def read_data file = File.open('data.txt') last_line = file.read.split("\n").last # that's what we want to calculate Integer(last_line) end Now, we want to process some errors: def read_data file = File.open('data.txt') last_line = file.read.split("\n").last Integer(last_line) rescue ArgumentError # when last_line is unconvertible to integer 0 end Now, we want to always close file, irregardless to whether the reading is successful or not def read_data file = File.open('data.txt') last_line = file.read.split("\n").last Integer(last_line) # this is still the "success return value" rescue ArgumentError 0 # this is still an "error return value" ensure file.close # this will be performed always at the end, but it is NOT the result end 
I'm lost, why would one use this?
`ensure` is *always* called but because it's for cleanup purposes you don't want your `ensure` block to implicitly override the return value of the method.
Sam reason why Rails have an autoloader. If you code base is past a certain size, loading it entirely can be quite slow. So in development, it's useful to load the code just in time, and reload the code that you just edited instead of reloading everything from scratch everytime. 
This is the range operator. [https://ruby-doc.org/core-2.1.5/Range.html](https://ruby-doc.org/core-2.1.5/Range.html)
(-1..-5).to_a #=&gt; [] (-5..-1).to_a #=&gt; [-5, -4, -3, -2, -1] ('a'..'e').to_a #=&gt; ["a", "b", "c", "d", "e"] ('a'...'e').to_a #=&gt; ["a", "b", "c", "d"] can you tell me why the -1..-5 array is empty? does it only do low to high?
It uses the succ method to determine the next item. The succ method of a number returns the number + 1. Since that isn't in the range, the range is empty. This is covered in the documentation if you want more info. 
Yes. The range has to be from beginning to end (low to high). That is because the &lt;=&gt; (spaceship) operator is used to see if the iteration needs to continue. Since -1 is greater than -2, there's nothing to do. If you need to go backwards, you can use #downto. \-1.downto(-5).to\_a \#=&gt; \[-1, -2, -3, -4, -5\]
Yea he did. [1](https://hub.docker.com/r/wallarm/fast) He just pulled it off docker.
For my part (I'm more of a c#, python guy), I would use a hash/dict with either full functions or lambdas. And if the operator isn't a key of the hash, that's the exception.
This makes sense as for *why* it acts this way. I posted [this comment](https://www.reddit.com/r/programming/comments/ains3m/3_unexpected_behaviors_using_ruby/eepxxcd) as an illustration of *how* it works, sort of (it's not implemented like that, of course) 
Why wouldn't you just use the backtrace cleaner from ActiveSupport? It's not just having ActiveSupport in your gemfile causes all of it to be activated. 
Hey! Great blog post. The tips mentioned are definitely ones that can help get a new coder into that gray "intermediate" category and better understand usages that he or she might see in a codebase. Two pieces of feedback: 1) I noticed a lot of typos and misspellings that a spellchecker would have caught and 2) your teaching style could benefit from some front-loading. On the second point, as someone who needs a mental "box" to exist before something can go into it, I find that my comprehension (and studies have proven this) increases dramatically when I can see what you're talking about in use before you explain the situation it gets used in. In this article, you set up each example by first "setting the scene" of when X or Y tip could be used, then show the downside of one approach, then show how X can solve that situation. I found myself scrolling down to see where you used the thing (like, scrolling down to see where `||=` or `&amp;:` show up), then scrolling back up to read about the situation it's remedying. Seeing something in use before it gets explained--even if you don't understand why it's being used there--creates the mental box that can then contain the information that is going to be provided. http://www.effectiveteachingpd.com/blog/2012/10/4/frontloading-increasing-critical-thinking-focus.html
I think a more idiomatic approach would be: ``` def ISBN(value, exception: true) &lt;... do conversion, raising ArgumentError if a strict conversion can't be done and "exception" is true&gt; end Strict conversion would imply if it can't consume the whole String if given a String (or if it contains junk characters), or if the object does not implement `to_isbn`, and Integer() fails. Then provide `to_isbn` or similar only on classes that genuinely represents ISBN values. That way it is explicit that when you call `ISBN()` you want a flexible conversion, but if you call `to_isbn` the source is genuinely a representation of an ISBN in another format. This reflects `to_int` vs. `Integer()` I really don't like using refinements to do this; it makes the code unnecessarily convoluted. (I've yet to see a good use of refinements)
`ISBN.from_integer()`, `ISBN.from_string()` would not be idiomatic, but `ISBN(string_or_integer_or_object_that_implements_to_isbn)` would be. If implementing that, the expectation would be that if a string is passed, it either needs to reasonably strictly match an ISBN format, or trigger an exception, unless `exception: false` is passed as the last argument. If one really wants to be stricter, then providing an `ISBN.parse()` would be reasonable, and require input to `ISBN()` to be numeric or implement `to_isbn` I don't think `from_integer()` or `from_string()` would be totally awful, but the above ismore ruby-ish. I agree with you regarding the use of refinements. It's messy, and it doesn't really buy anything given that you have to explicitly pull them in. 
Right on. Do be prepared to have to dive into the shrine implementation code and spend some time with it to figure out how to do what you want though. Once you do, it can usually be done in very few lines of code, but it can be a lot to figure out. :)
I'd guess because code loading issues in Rails are near impossible to debug currently.
It's quite rare for people to use Integer(). I see like most uses in ruby code out there where people are fine with .to_i alone.
I found it useful to simplify to case/when menus instead. case op when "+" puts num1 + num2 when "-" puts num1 - num2 when "*" puts num1 * num2 when "/" puts num1 / num2 when "**" puts num1 ** num2 else puts "invalid operator" end
You might run through the scenario of how that second purchase will be stored and how the models will be related. Database relationships are for the life of the database, not for the lifecycle of an object. The situation that you described sure sounds like a customer can have many products... Just not at the same time.
Thanks a lot, this is brilliant! Can you explain a little bit more on what the 'send' does? 
In addition to the other fixes in these comments, you may want to put a `.limit(&lt;some limit&gt;)` on some of those queries. Otherwise, you're exposed to unbounded numbers of records being loaded.
 class Customer &lt; ApplicationRecord has_many :orders has_many :products, -&gt; { distinct }, through: :orders has_many :related_customers, -&gt;(this) { where.not(id: this.id).distinct }, through: :products, source: :customers end class Order &lt; ApplicationRecord belongs_to :customer belongs_to :product end class Product &lt; ApplicationRecord has_many :orders has_many :customers, -&gt; { distinct }, through: :orders end 
&gt; Neither private methods nor protected ones can be **called directly by instances of the class** in which the method is defined. For an instance to access these methods they must be called within a public method defined in the class. Someone please correct me if I'm wrong, but I don't think this isn't quite the Ruby way of saying it. Rather than thinking about objects calling methods, think instead in terms of _objects receiving messages_ (and then acting on them). Moreover, it's not about _who's calling these methods,_ but rather (mostly) _in what context the messages were received._ &gt; animal.define_activity In other words, this line isn't saying "make `animal` call `#define_activity`." Rather, it's saying "Send the `:define_activity` message to `animal`, and let `animal` decide what to do with it." If `#define_activity` is a public method, then it calls it; if not, it raises a `NoMethodError`. So the more accurate way to describe how private and protected methods work is this: &gt; Private methods cannot be sent to an explicit receiver (_e.g.,_ `obj.private_method`); instead, they must be sent implicitly to `self` (_i.e.,_ in the context of the same class), like so: &gt; &gt; class Animal &gt; def current_activity &gt; puts "I am #{define_activity}" # sends the :define_activity message to the implicit receiver `self` &gt; end &gt; &gt; private &gt; &gt; def define_activity &gt; ... &gt; end &gt; end &gt; &gt; Protected methods _can_ be sent to an explicit receiver, but also must be in the context of the same class as the receiver: &gt; &gt; class Animal &gt; def foo &gt; other_animal.protected_method # works here &gt; end &gt; end &gt; &gt; other_animal.protected_method # doesn't work here
I love it! As a front-end developer who is now learning ruby but doesn't know all the quirks of the language, this is really valuable. Does anyone have more articles like this? I have a pretty good background in front-end developer but not so much in RoR.
to_i is more popular, agreed. It can easily be a source of bugs, and I think Integer() is usually what you want though. 
That's what I mean. I process images in a background job. I can't imagine why a call in my views would be kicking of image processing of any sort. Should be noted, it's not just thumbnail. On-the-fly is being used to produce all manner of different versions for images, so instead of a central location, we have these version references dotted around in views or helpers. Ew. Not knocking Shrine by any means. I'm going to be converting my carreriwave stuff to shrine as it appears to offer much more flexibility (had big problems accessing models when building custom user-defined crops in carrierwave). I was just trying to understand why developers started doing this (was it following in the footsteps of AS?), when the whole point of background jobs is to remove this kind of processing from the request/response cycle.
`derivation_endpoint` doesn't say anything descriptive about what's going on. I'd much prefer `on_demand`. I don't want to have to work out what you mean by `derive`. I know `on_demand` or something along those lines is doing immediate processing. Even `process_now_url` is better. Please make it obvious; derive is not obvious.
Best bet is Ruby docs and Rails docs, perhaps some screencast websites. Build lots of things in RoR. There is no shortcut.
I understand better now. Thank you very much. :)
&gt; Someone please correct me if I'm wrong, but this isn't quite the Ruby way to say it. Rather than thinking about objects calling methods, think instead in terms of objects receiving messages (and then acting on them). Holy shit. That's the perfect way to think about it. And suddenly several concepts make much more sense... (and I'm no ruby newby)
Check out _The Well-Grounded Rubyist_—that's where I picked up the idea from, and there's more where it came from.
I'm no junior developer but some of the points were new and useful, thanks for sharing :) 
This is true for someone who's entirely new to programming, but not true at all for intermediate programmers. If /u/ALL_HAIL_LEBOWSKI is looking for tips, I don't have any in particular, but I'd venture a guess that articles from medium (or hackernoon) on this subreddit would be a great place to start. If, on the other hand, you're looking for foundational knowledge, please check out _The Well-Grounded Rubyist,_ as I suggest in another comment above, and also definitely _Principles of Object-Oriented Design_ by Sandi Metz (a crowd favorite on /r/ruby).
+1, though I'd say this absolutely can be true for intermediate programmers moving into technology they've not worked with. The focus on "tips" and "tricks" is misguided, anyway. Everything you could need to pick up is the documentation. The article touches on working with hashes and some shorthand syntax. In the documentation.
Yep, much better! Please put your queries in your models and expose through scopes/filters/relationships in your controllers.
This is very positive to see, thanks for sharing!
This looks very elegant! Where can I learn more about this level of sophistication? I don't mind going back to foundational stuff if necessary.
Great article, thank you :)
The words like "on-demand" or "on-the-fly" processing is for me a high level way to describe the behaviour of the feature, it doesn't really fit into Ruby method names and classes. You won't have to work out why do I mean by "derive" (I wouldn't figure it out myself either looking just at the name of the plugin), the Shrine documentation will state loud and clear that this plugin does "on-the-fly processing". 
What is that graph supposed to show?
Just to be clear, generating an "on-demand" URL in the view doesn't kick of any image processing. It's only when the user/browser accesses the URL will the processing be performed (if it hasn't already been cached by the CDN). &gt; so instead of a central location, we have these version references dotted around in views or helpers. Note that Shrine does better here compared to other solutions like Active Storage or Dragonfly. With these solutions you're listing the processing steps that map directly to your processor (e.g. ImageMagick) as you're generating the URL. For me this is a serious SRP violation. In contrast, with Shrine you just give that derivation a name (e.g. "thumbnail"), and you decide all the processing logic in the derivation block. &gt; I was just trying to understand why developers started doing this (was it following in the footsteps of AS?), when the whole point of background jobs is to remove this kind of processing from the request/response cycle. Active Storage wasn't the first one to do it. [Dragonfly](http://markevans.github.io/dragonfly/) was the first, then [Refile](https://github.com/refile/refile) (by the author of CarrierWave), and now Active Storage. I think it's not a reason for concern when you have small to medium amount of traffic. If you have a lot of traffic, you should separate on-the-fly processing into a separate microservice, so that if it gets overloaded only the thumbnails won't be working correctly, but your main app would. But if you're processing larger files (larger images, video screenshots), you should almost certainly use background jobs. That's why a library that only supports on-the-fly processing is not universal, because you cannot use it to handle all types of files.
Well guys, you should really learn what content marketing is in real life
&gt; Just to be clear, generating an "on-demand" URL in the view doesn't kick of any image processing. It's only when the user/browser accesses the URL will the processing be performed (if it hasn't already been cached by the CDN). Could you not pre-process those images when the url is generated (as it shows intention to use it), instead of deferring onto the user request? What is the reasoning for that? Just interested. Is it to save storage or defer execution? What kind of processing does it do? Could it be extended with expensive image optimisations or modifications? That's my concern here. That the user should not be in control of when that happens. &gt; I think it's not a reason for concern when you have small to medium amount of traffic. If you have a lot of traffic, you should separate on-the-fly processing into a separate microservice, so that if it gets overloaded only the thumbnails won't be working correctly, but your main app would. This seems like an unnecessary complication because background workers were not used in the first place. It's not difficult to fire up Resque or Sidekiq, and you'll likely be using them for other things, anyway. I think your initial post and another comment helped to clarify the benefits. It would be great if you could expand the documentation with more use-cases, where to use it, where probably not to use it, etc, I'm saying this because I'm so entrenched in the backend (8 years), that this just looks like a pointless frontend-focused change which only adds more complexity and a worse user experience. 
You're totally right, this would work for most use-cases. Didn't think about it. Thanks for the input!
What comes to mind: Chef, Puppet, Omnibus, Metasploit, RubyGems, Rake, Most things by hashicorp (Vagrant, Consul). There's also this really cool TUI app for displaying Guitar tabs and music notation that I wish I could remember, but of course I can't at this time. Probably one of the prettiest ruby interactive command line 'apps'. Also 'thor' is a great framework for building CLI apps, but it doesn't provide any kind of TUI; it's just a great solution for abstracting away repetitive tasks when building cli apps.
Where in the f did they get that graph from? Ruby *might be* [slower](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/yarv-php.html) than PHP but it's most certainly not orders of magnitude slower like the graph shows. &amp;#x200B; I guess if they used a graph that showed real world numbers, it wouldn't look nearly as good as a thumbnail huh?
I couldn’t stop laughing after reading line “RoR uses Nginx as a load balancer, ...................”
I think this is the music notation app you're referring to: [Coltrane](https://github.com/pedrozath/coltrane)
&gt; Could you not pre-process those images when the url is generated (as it shows intention to use it), instead of deferring onto the user request? What is the reasoning for that? Just interested. Is it to save storage or defer execution? You could definitely do that, just then you have to do it yourself. But it's real easy: def on_demand_url(uploaded_file, *url_args) url = uploaded_file.derivation_url(*url_args) PreloaderJob.perform_async(url) end class PreloaderJob include Sidekiq::Worker def perform(url) HTTP.get(url) end end However, that can really overload your Redis instance! Because you have no way of knowing whether you need to preload the URL or not (unless you store that information in the DB), you'd need to spawn a background job for each URL. Even if the jobs are sufficiently fast, that's a lot of Redis calls (N+1 Redis calls are also a thing, I experienced it first hand). Note that you can have a similar background job preload the thumbnail URLs when a new image is attached. That's a much better option. That's also not something the plugin can do, because it doesn't know when or whether you want it or which background job/library you're using. But I'll definitely suggest that as a possibility in the docs.
Is the `derivation_url` indempotent? In that if I send the same arguments it will return the same url? If so, I could just cache that and not queue the processing. Appreciate the breakdown. I think I'll have to dive in and start using it to really understand the different uses, where it's welcome and where not, or how to modify to my tastes.
yeaaah that, gorgeous
&gt; Is the derivation_url indempotent? In that if I send the same arguments it will return the same url? If so, I could just cache that and not queue the processing. Yes, it is. So yes, you can cache it. You just need to make sure you expire that cache when a new file is attached to the record. &gt; I think I'll have to dive in and start using it to really understand the different uses, where it's welcome and where not, or how to modify to my tastes. I can very much relate to that. When I switched to Refile after being disappointed with Paperclip and CarrierWave, I really liked its simplicity, but I just wasn't on board on the whole on-the-fly processing. That's one of the reasons why I decided to create Shrine, processing on upload just suited me better and I found it safer. However, after Active Storage was released, I realized that it's a trend and that it can work for big companies like Basecamp, so eventually I realized there is no harm in Shrine supporting that as well, as long as you still have the option to process on upload via a background job.
&gt; Yes, it is. So yes, you can cache it. You just need to make sure you expire that cache when a new file is attached to the record. Great! &gt; However, after Active Storage was released, I realized that it's a trend and that it can work for big companies like Basecamp, so eventually I realized there is no harm in Shrine supporting that as well, as long as you still have the option to process on upload via a background job. Exactly. I can't see the problem so long as background processing still has first-class support. The only issue I will say with this option is that [lazy] developers start using it everywhere because they can't be bothered with background workers. I took on a project a while ago where AS had been abused and it was very painful to change. I gave up the project because of it.
You can have a base Gemfile with all the common gems. Then add `eval_gemfile("Gemfile")` in the other Gemfiles. 
Ok and I once I end up with Gemfile.lock I just each process from the root directory (the one with the lock file)?
You need to have a lock file for each file. That why you should lock the version of the gems to specific version to not have different version . You can generate the lock by setting the BUNDLE_GEMFILE env var to point to the other Gemfiles.
One of the tools that I use mostly is Metasploit
For one lockfile, you want one Gemfile. Why do you have more than one?
Actually thinking of studying thor. 
Unfortunately, as far as I know, there isn’t, as this has also been an annoyance to me for a while now. At work, I’m the main developer for two of our largest Rails apps, and the whole huge monolith codebase thing does actually become a real pain in the ass, but I actually really like Ruby (and Rails — mostly), and rewriting these as microservices or whatever would actually fucking suck. So, I’ve taken to, instead of the micro service meme, building one (and slowly refactoring the other) as discrete modules with clear domain boundaries. I’ve been doing this by extracting out shared/non db/stateful gems which are stored in a sub directory of the main project, and then in another sub directory I have a bunch of Rails engines *(or gems with extra steps)* for the specific/stateful modules. And, while this has been wonderful for keep the code clean and modular, managing common dependency versions has been annoying given each gem/engine has their own gemspec, Gemfile, and lock file. Initially micromanaging the dependency versions for each module wasn’t that bad, but after they grew past 3-4, it got old. The most tolerable way to deal with this I’ve found is not pinning any of the dependency’s versions in any of the individual gems/engines, but just keeping the root project’s Gemfile tightly pinned (pessamize gem makes this easy). This way when bundle is run on the root project, non the of child gems ask for a specific version, so bundler resolves each child’s deps version to the one pinned in the root project. This has the one annoying caveat where if you were to just want to work on one of the child modules, running bundle on the child module wouldn’t necessarily install the versions pinned in the root Gemfile. So far, this hasn’t been a real issue for me, as I’ll just blow away the lock file, if I get a version I don’t want, pin the version on the modules gemspec, run bundle again so the lock file is generated with that version, and then removing the pin afterwords. There were a few tools I came across meant to tackle this issue, but they were all either adding entirely too much extra complexity/config or long since abandoned. But, I would really love if someone could come in here and tell me I’m an idiot and there’s a better way to do this, and it would get rid of my like one annoyance with this project structure.
&gt; Rather than thinking about objects calling methods, think instead in terms of objects receiving messages (and then acting on them). People often say this, but I don't think it holds any water. In the semantics and implementation it's a method call via a simple lookup in a table of methods, with caching on top as an optimisation. Talking about sending and receiving messages makes it sound like the object itself is able to decide how to dispatch the method, but really it's the sender that resolves which method to call. It also makes it sound like it's asynchronous or remote or something like that. I don't agree with the Well Grounded Rubyist's terminology there. I think it's just a holdover from how people used to think about object theory decades ago which just isn't really reflected in semantics or implementation any more.
If I was going to do that (not totally sure if it's a good idea or not), I'd just make an async HTTP request using in-process multi-threaded concurrency, perhaps with concurrent-ruby futures. You don't even need to wait for the response, or handle failure really, just make the GET request and don't even wait around for an answer. Rather than actually kick off a sidekiq job via redis. I'm not totally sure if this would change the performance characteristics enough not to scare me, but it'd be better. For either of these to work, it assumes that accessing the URL lazily creates the derivative and _stores_ it so it won't have to be created on next request, in a concurrency-safe manner. Is that true, it's storing it (ActiveStorage-style), rather than just counting on a cache in front (dragonfly style)? If the latter, I'm not sure this approach would work at all. 
Homebrew
CocoaPods
Thanks! You're right that in this case the PORO to which I refactored happens to be an instance of the Factory pattern. I'd posit that the methodology/benefits are the same though whether or not the resulting PORO happens to align with any particular design pattern.
Sure. Ok, so, where to start... In Ruby everything is an object. Every object in Ruby inherits from the [Object class](https://ruby-doc.org/core-2.6/Object.html). Going with that every single method call is a call to send with the method name as an argument. So when you call gets.chomp you are actually, under the hood, calling gets.send(:chomp) (this may not be 100% literally true, it may be more accurate that gets.send(:chomp) and gets.chomp become the same thing as it passes through the interpreter and becomes byte-code. It's been a while since i've actually descended below the porcelain on this stuff.
You clearly know more than I do about the implementation details here, but even in my ignorance I would contend that abstractions work precisely because they obscure what's going on under the hood (to the extent that they obviate the need to understand it). To wit, Sandi Metz is, in my observation, one of the most beloved teachers of OOP in this sub, and this is how she describes OOP, in a nutshell (emphasis mine): &gt; I believe that OO affords building applications of anthropomorphic, polymorphic, loosely-coupled, role-playing, factory-created objects **that communicate by sending messages**. In fact, her latest talk is titled, "Polly Want a Message." If I have lost my way, please point me to resources that I can use to educate myself in your way of thinking (or better yet, examples of how this thinking produces better software).
&gt; I'd say this absolutely can be true for intermediate programmers moving into technology they've not worked with. 110% concede this point. Django-to-Rails requires much less ground-up education than frontend-to-Rails, which is the case we're dealing with here. FWIW though, some people are too busy to make their second language a priority and really drink from the firehose, even if that's the best way to learn. Sometimes snacks are a good stepping stone to the real stuff, sort of like a one-minute workout.
How is this a roadmap? Did the author got fat-fingered when typing "mind map"? There's no way anyone can study all this in a lifetime. Study the concepts, master some of the tools – sure, of course. But inviting to learn all these tools just doesn't make any sense nor does it seem practical. I'm afraid a picture like this would simply scare people off. My non-comprehensive suggestion: 1. start shy! 2. run nginx to render "hello world" page, 3. learn to see logs, learn to find **nginx** process using **ps**, **htop** and **pstree**, 4. learn to see what process is doing **strace** and **ftrace**, 5. pick one scripting programming language apart from **bash**, learn some bits of it, 6. put **nginx** in a container – learn how to build &amp; publish an image, 7. learn to grab logs from container, 8. learn to monitor process CPU consumption in the container using \`ps\` and \`htop\`, 9. learn how to send metrics somewhere, 10. etc., 11. etc.,
I think you can use gemfile groups and then just use one gemfile with groups for each process you want to run.
Fastlane is amazing for app developers to speed up automated deployments and code signings. 
I know that's the metaphor Metz uses, and it's a common one so it's not unusual that she does so. But I think it just doesn't really hold up to any scrutiny. You can ignore the implementation argument if you want - that's why I mentioned semantics as well. To me the idea of a message passing system is that the receiver gets the message and then decides what to do with it - what method to call in the case of Ruby. There just isn't any place in Ruby where this happens. It's just not there as a language feature. An object defines its methods, and then at the point of someone calling a method on the object it has no other control over how the call is handled at all. It never gets to receive a message and then decides what to do. Instead the method is called, and that's the first that the object knows about it. In what sense do you think this is sending a message over calling a method? You may mention `method_missing` but again the decision to call that method is out of the control of the object. An object cannot interdict a call that would have gone to a method and so something else with that 'message' via some kind of `method_missing`. There is no `method_found_but_ill_let_you_decide_anyway`. Overriding `send` does not impact normal method calls. If it did, I'd say Ruby had message passing. To sum up my objection to Ruby as 'message passing' I would say that semantically (not nit-picking about implementation) the response to a message is fixed before the call is made, and the object has no control over that response to the message after it has been sent.
I use **fpm** to build custom debian packages for puppet deployment. [https://github.com/jordansissel/fpm](https://github.com/jordansissel/fpm) Really cool.
Probably not what you were looking for, but I've been using ruby itself as a command line tool recently by piping stuff into it: `some_command_here | ruby -e "puts ARGV.strip"`
It would seem most logical to separate and package each of these processes AS gems.
&gt; Is that true, it's storing it (ActiveStorage-style), rather than just counting on a cache in front (dragonfly style)? By default the `derivation_endpoint` doesn't upload processed derivatives, in order to make the first request faster (just processing is faster than processing + upload). It can be configured to upload by passing `upload: true`. &gt; I guess the URL being accessed would have to be through the cache? It starts making my head spin to work this all out. If you're using a CDN, then you'll likely set the `:host` option on the plugin level, in which case all derivation URLs will include the CDN host, so you don't have to worry about it when preloading.
&gt; By default the derivation_endpoint doesn't upload processed derivatives, in order to make the first request faster (just processing is faster than processing + upload). It can be configured to upload by passing upload: true. Hypothetically one could imagine it delivering the image immediately on first request, but also uploading it to storage _in the background_ for subsequent requests. But that has some complicated concurrency issues. What does ActiveStorage do, i guess it just does the simple upload on first request, even the first requester has got to wait for it to be uploaded before getting a response. 
Active Storage also redirects to the variant after it uploads it to the storage. For S3 it redirects to the private expiring URL, so the CDNs cannot cache it. That would be a no-go for me, because it would mean the browser needs to make two HTTP requests to retrieve the variant. Shrine also offers additional redirection, but allows you to configure public non-expiring URLs. But yeah, all of these decisions (no upload, upload, upload + redirect) have trade-offs, so I left developers the option to choose which behaviour they want. The "no upload" variant is the simplest one to comprehend, so I made it the default behaviour. &gt; Hypothetically one could imagine it delivering the image immediately on first request, but also uploading it to storage in the background for subsequent requests. But that has some complicated concurrency issues. Yeah, I've been considering that as well. So that request would still perform the processing and return the derivative, but it would also kick off the background job. The background job would then need to perform the processing again, and upload the derivative. Then because with `upload: true` each endpoint request checks whether the derivative has been uploaded, at some point all subsequent requests will retrieve the derivative the background job has uploaded. I think that's a valid 4th option! It would still cache the derivative on the storage, but the initial request wouldn't suffer the upload overhead. I think I'll add it!
hopefully this will help saving several hours debugging to someone. It was a long day :( &amp;#x200B; 
[removed]
can you use different groups in 1 Gemfile? I think you're trading an annoying problem (multiple repos) for a difficult problem (consistency between multiple Gemfiles). I'd cut the knot and just go with separate repos for each thing that needs its own Gemfile.
if this helps : [https://skillsmatter.com/skillscasts/11594-lrug-march](https://skillsmatter.com/skillscasts/11594-lrug-march) , [https://devchat.tv/ruby-rogues/rr-371-the-modular-monolith-rails-architecture-with-dan-manges/](https://devchat.tv/ruby-rogues/rr-371-the-modular-monolith-rails-architecture-with-dan-manges/) , [https://medium.com/@dan\_manges/the-modular-monolith-rails-architecture-fb1023826fc4](https://medium.com/@dan_manges/the-modular-monolith-rails-architecture-fb1023826fc4) &amp;#x200B; if you really want to go that rabit hole what you want to achive is "bounded contexts" [https://martinfowler.com/bliki/BoundedContext.html](https://martinfowler.com/bliki/BoundedContext.html), either via Rails engines, microservices, or via interface obejcts (unfortunately I didn't finish article on that yet) 
I think you're doing the work to make micro services possible. Once you have clear boundaries between elements of your monolith (i.e. the work you're doing), then it makes sense to stand up a separate sinatra app (or whatever) to just do that one thing and communicate over the wire. Anyway, you sound like you have a good handle on it. I'd much rather work on a project like yours with reasonable goals than some jr dev architected monster that has a million unfinished micro-services and spaghetti code in the monolith.
Thank you. 
Apart from what the other folks have mentioned, Capistrano is really good command line tool for deploying web apps. 
I agree, although I'll point out that another option is for the different processes to share one Gemfile. In fact, I'm not sure what problem separate Gemfiles could be solving other than shaving off a little bit of disk space.
&gt; Then because with upload: true each endpoint request checks whether the derivative has been uploaded, at some point all subsequent requests will retrieve the derivative the background job has uploaded. You have to try to avoid many many different requests all simultaneously trying to make the derivative because none of them have finished yet so it hasn't been uploaded yet. On a high-traffic server and/or a slow derivative creation, you could have dozens+ all trying to do it at once. Which could be disastrous. 
So, not active storage thing then? https://github.com/rails/rails/issues/35028#issuecomment-456869539
Oh yeah. That's the best solution of all. I assumed there was some feature that was incompatible between them. If there isn't, just use 1 Gemfile. Disk space is way cheaper than your time.
I asked permission for the author. Dont say what you dont know.
Did you know Ruby has built pretty print with `pp`?, which in my humble opinion is just enough
Yup. it's also not quite as good. \`ap\` has been around for quite a while now. this is a big rewrite :)
In addition to debugging orientation metadata... do you WANT all the EXIF metadata from the originals to persist in variants? Do you want the EXIF metadata to actually be stripped from even the originals before storing them? I'm not sure if there's a good way to strip metadata with AS. It's func and flexibility are quite limited. To me, AS and some other thing we're getting these days, are a really different philosophy than I am used to Rails being. Instead of some tools I can use to build whatever I want, they are much higher levels of abstraction, with much less ability to customize. 
They might like the dry-rb project. 
&gt; Once you have clear boundaries between elements of your monolith (i.e. the work you're doing), then it makes sense to stand up a separate sinatra app (or whatever) to just do that one thing and communicate over the wire Exactly my thought process when I began toying with the concept. The first app I mentioned, the one I’m currently refactoring to this architecture rather than the one than I started with the architecture, was already large monolith, with several mostly independent features where the only common dependency between them all was the user model. One of my first tasks was then to rip out one of the features that wasn’t used by anyone, which unfortunately turned into a really deep dive into the entire code base as when I started ripping things out, I was finding random other shit breaking because for some bizarre reason they relied on one or two bits of that code for seemingly no good reason. And, that’s when I started trying to find ways to not construct code like that, because that was the fucking most infuriating deletion of *unused* code I’ve ever experienced. I initially played around with engines soon after when adding a new feature, that I thought was pretty generic/reusable. It wasn’t until I came across the book Component Based Rails though, that I realized how potentially awesome they are for creating a modular architecture. However, due to constraints at the time I never really had the time to go all out refactor. Then when I got tasked with this new app, with yet again, largely independent set of features, I started considering several independent small Sinatra/Ruby apps, but at that point they’re more or less actual microservices, which almost never should be the route for a new app. Coincidentally though, around that time was when this article came out: [The Modular Monolith](https://medium.com/@dan_manges/the-modular-monolith-rails-architecture-fb1023826fc4), and I stumbled across it while looking for ways to still be able to have most of the benefits of a monolith, rapid iteration, ease of testing/deployment, etc. while not shooting myself (or a future dev in the foot with a messy intertwined monolith). And, that’s when it clicked, and I went for that architecture, and have been very happy working with it. The actual Rails app only has one model, the user, no controllers, no views, nothing else inside app. The routes file only contains `mount Foo::Engine`’s. If *(when)* the day comes that a feature is deemed useless, I just have remove the mount, and delete the engine directory. If some feature were to become so popular/resource intensive, it wouldn’t take long to rip it out into a Sinatra app, and scale just the feature, a la microservices. It’s not perfect, there are some pain points, like the above mentioned dependency version pinning, and I wouldn’t architect every Rails app like this, but for my apps, it’s been much more pleasant to come back to and work on than a huge monolith, with none of the headaches that come with microservices **(when you don’t need them)**. You don’t actually need a network layer in between your code enforce modularity, just don’t be lazy (even though microservices are even more work).
huh well one of my projects uses awesome_print already and didnt realize it! its leagues ahead of `pp` i switched the versions but i get this: ``` NameError: uninitialized constant AwesomePrint::Formatters from /Users/ryantulino/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/awesome_print-2.0.0.pre/lib/awesome_print/formatter.rb:58:in `format'```
Thanks - can you hook me up with a longer back trace? Or what you were doing when this happened?
Definitely agree with you. [https://medium.com/rubycademy/private-protected-a-matter-of-message-1a88b10acbf2](https://medium.com/rubycademy/private-protected-a-matter-of-message-1a88b10acbf2)
i called `ap` on an initialized mongoid model hope this helps: ```/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/awesome_print-2.0.0.pre/lib/awesome_print/formatter.rb:58:in `format'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/awesome_print-2.0.0.pre/lib/awesome_print/inspector.rb:118:in `unnested'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/awesome_print-2.0.0.pre/lib/awesome_print/inspector.rb:76:in `awesome'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/awesome_print-2.0.0.pre/lib/awesome_print/core_ext/kernel.rb:5:in `ai'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/awesome_print-2.0.0.pre/lib/awesome_print/core_ext/kernel.rb:15:in `ap'", "(pry):7:in `&lt;main&gt;'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:355:in `eval'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:355:in `evaluate_ruby'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:323:in `handle_line'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:243:in `block (2 levels) in eval'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:242:in `catch'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:242:in `block in eval'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:241:in `catch'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_instance.rb:241:in `eval'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/repl.rb:77:in `block in repl'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/repl.rb:67:in `loop'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/repl.rb:67:in `repl'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/repl.rb:38:in `block in start'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/input_lock.rb:61:in `__with_ownership'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/input_lock.rb:79:in `with_ownership'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/repl.rb:38:in `start'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/repl.rb:13:in `start'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-0.11.3/lib/pry/pry_class.rb:192:in `start'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/pry-byebug-3.6.0/lib/pry-byebug/pry_ext.rb:11:in `start_with_pry_byebug'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/railties-5.1.6.1/lib/rails/commands/console/console_command.rb:62:in `start'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/railties-5.1.6.1/lib/rails/commands/console/console_command.rb:17:in `start'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/railties-5.1.6.1/lib/rails/commands/console/console_command.rb:97:in `perform'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/thor-0.20.3/lib/thor/command.rb:27:in `run'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/thor-0.20.3/lib/thor/invocation.rb:126:in `invoke_command'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/thor-0.20.3/lib/thor.rb:387:in `dispatch'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/railties-5.1.6.1/lib/rails/command/base.rb:63:in `perform'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/railties-5.1.6.1/lib/rails/command.rb:44:in `invoke'", "/.rbenv/versions/2.4.2/lib/ruby/gems/2.4.0/gems/railties-5.1.6.1/lib/rails/commands.rb:16:in `&lt;top (required)&gt;'", "bin/rails:6:in `require'", "bin/rails:6:in `&lt;main&gt;'" ```
That sounds awesome. I really love the simplicity of the main app. 
I use Pry for almost all development purposes. It prints beautifully and allows me to `ls` objects and classes to see a breakdown of methods and attributes.
I don't believe you. 
love ap and will upgrade it. But know I use it in very simple context... just to print arrays &amp; complex structures. Is there anything else it is particularly good at?
Hope this helps :) [1] pry(main)&gt; a = [1,2,3,4,5,6] =&gt; [1, 2, 3, 4, 5, 6] [2] pry(main)&gt; ap a NoMethodError: undefined method `ap' for main:Object from (pry):2:in `__pry__' [3] pry(main)&gt; require 'awesome_print' =&gt; true [4] pry(main)&gt; ap a NameError: uninitialized constant AwesomePrint::Formatters Did you mean? AwesomePrint::Formatter from /Users/me/.rvm/gems/ruby-2.5.3/gems/awesome_print-2.0.0.pre/lib/awesome_print/formatter.rb:58:in `format' [5] pry(main)&gt;
Will try it tomorrow! Just a question, are you one of the gem devs or just a happy contributor? What I mean is, this looks to be a fairly large rewrite, so do you have support from the author(s) to make sure your work won't go to waste? 
good question. I'm the maintainer. AMA :)
Ah hello! Sorry, I was on my phone and didn't see your name on the CONTRIBUTING file haha
hey @olddang45 -- this should be fixed in \`pre2\` - if you update that in your gemfile you should be golden. lemme know!
thanks dude, this is awesome. two things: is this pry outside of rails or similar? if so, i think it's gonna still require you to require it-- i know that awesome\_print has some hack-into-library features, but i'm not super keen on extending them (after all, that's what .pryrc etc are for). &amp;#x200B; secondly, re the NameError this should be fixed in \`pre2\` - if you update that in your gemfile you should be golden. lemme know!
I LOVE ap. It's probably the biggest factor in me learning programming/Ruby. I found it in an awesome list when I was trying to learn how to code for my job. It's my go-to tool for debugging. Recently my skills have matured to the point where Pry is more valuable, but I still use ap 90% of the time. Thank you so much for your work! I'll definitely check out the new versions!
it mostly just does that. i've rebuilt it in such a way that it's possible to build more complex introspectors. So you could build a formatter/introspector for, say, `ActiveModel::Relation` that would dig in and pull out very specific elements so you can debug/inspect it. Think of it like `object.inspect` but on epic steroids. Not sure how far to take it -- ideally, tool owners would create their own introspectors, as they own their APIs; so there'd be a awesome\_print module inside of ActiveModel, etc. need to figure out how to do that efficiently.
yeah! pry is pretty cool, but not quite as portable, imho. using `ls` is fine, but one of the ways I think `ap` is different is that it's more inline, so you can follow along a bit better.
Awesome Print is very nice. Thanks for maintaining! 