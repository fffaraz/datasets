[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mruby/mruby/.../**examples** (master → 75c1fcc)](https://github.com/mruby/mruby/tree/75c1fccd08a7cc529bcac5031ebc52176c6fd267/examples) * [mruby/mruby/.../**guides** (master → 75c1fcc)](https://github.com/mruby/mruby/tree/75c1fccd08a7cc529bcac5031ebc52176c6fd267/doc/guides) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply ducabeu.)
The good news - the improvements from the 3x3 initiative get added year by year. Expect more goodies shipping 2018 and 2019 and 2020. The (benchmark) baseline is the Ruby 2.0 version from 2014.
I thought AMP actually routed people to their pages and not yours?
AMP is hosted on Google's CDN, but there is a default link to your website and you can add your own backlinks.
Ah! Good suggestion. I forgot that Rebmine was Ruby. Thanks
Thanks, will take a look...
original: oh my goodness, this made me laugh out loud. DRYer: omg lol 
I've always had luck with [ruby-prof](https://github.com/ruby-prof/ruby-prof).
I second that. Ruby-prof is amazing when you want to see what percentage of execution time was spent on each method. My favourite way to view this is via the "call stack printer": result = RubyProf.profile do # your code end RubyProf::CallStackPrinter.new(result).print(File.open("ruby-prof.html", "w")) For memory I recommend [MemoryProfiler](https://github.com/samsaffron/memory_profiler).
I shared my experience with Helix here: https://blog.dnsimple.com/2017/05/writing-ruby-gems-with-rust-and-helix/
How is this different than reposting the last week's /r/ruby content? There are a lot of Ruby link aggregators. I feel like if we keep allowing this one to publish, we should allow all of them, or do some kind of a meta aggregator aggregation post once a week etc. Other ones like http://wwwrubyweekly.com add content and context instead of just having the links. 
Why is argv 0 necessary?
Shouldn't be next major version rather *9 times* faster ? You know, 3x3 means 3-times-3 in our region and that's 9.
If it's a webapp, and you're looking for some general profiling of how all parts of your app work, I'd take a look at [New Relic](https://newrelic.com/).
In my country the x operator means exponentiation so in fact our Ruby will be *twenty-seven* times faster. 
there's no secret. 
obviously there should be three different rubies, and they should each be three times faster. 
How about robotcop?
Sinatra's session variables are themselves encrypted, so the catch here is that the JWT is put in a session variable and encrypted out of view. You should have a cookie on the page, but the name won't be "access token" (I don't know what Sinatra defaults to). This makes for an short piece of demo code, but it's also fairly useless. You would be far better served just storing the user id in the session variable itself. &gt;Can one have an application running on y.domain.com that reads a token made on another application on x.notherdomain.tld? That's really down to your frontend. If you stored the JWT token in a raw cookie (using Rack::Cookie instead of session) you could send that JWT token to other domains. Cookies aren't sent by default in cross domain requests, but you could force this with the right frontend, or sent the token as a POST request. That said, JWT has a number of security issues. [The JWT Gem README](https://github.com/jwt/ruby-jwt) warns you to set the algorithm yourself, and provides an example of doing so. The example code you found does not, and ergo, is vulnerable.
Looking forward to Ruby 3↑↑3
speaking of pry did you check out that new pry feature (on the front page) ? looks amazing, seems pry can show Ruby internal code now?? mfg
&gt; JWT has a number of security issues Can you clarify what you mean by this? Are you just pointing out that some libraries don't do a good job? I just don't see how your statement can be true given that a JWT is just a signed (and optionally encrypted) string which encodes a JSON object. Done right, it's just as secure as anything else. I mean sure...don't write your own encryption/hashing algorithms.
Word. What a legend. 
The example does set the algorthm @token = JWT.encode({user_id: 123456}, settings.signing_key, "RS256", headers) RS256 = RSA It's also using version 1.0 of the jwt gem, when I used a newer version I believe they changed it a bit.
Do you mean this link(https://www.reddit.com/r/ruby/comments/7xmj51/dig_deeper_with_pry_introducing_cruby_source/) from front page? i haven't tried it but it looks very cool and useful.
Shrine works with sequel: https://github.com/janko-m/shrine
ruby weekly needs to fix their cert
Never used either. But shrine should be good.
&gt; Based upon your past reddit/github activity I don't think that you're part of the target audience for mruby. Thanks for saying I am incompetent in a kind way. :) And thanks for the other explanations... I know the concept of embedding a scripting language... but I am just saying that in the repository and website the whole process is not explained in a way that someone not familiar with those concepts will enjoy learning... just that... I think a lot of people would benefit from that, and in the end mruby itself.
byebug and pry have saved me countless hours of debugging., but I also sometimes use pry for somethinng a bit more uncovnentional - command line applications. If you think about setting up a i/o loop and exposing your commands through a case statement - that's way more work than simply creating your lib as a standard ruby class and calling IRB or Pry .start 
From briefly looking at the PetaPoco page, it seems to be a very similar idea. So I'll tentatively say, yes. First, using Sequel you can build SQL queries using a friendlier domain-specific language. But you can also define complex relationships between your models that makes it easy to drill down without SQL (something like doing `comment.author.followers` to jump between related models). I'd play with Sequel first and only move to ROM for making a full fledged enterprise application, and only then if the benefits are very obvious to you. Feel free to ask anything more you have in mind.
See what matters, line 75.
*whims and ducks under the table* Yes, I am scared, big daddy, please save me! *suddenly remembers he is old grumpy Ukranian* Nah, I am not. I wonder who is your intended target audience. Rails novices who are really scared, in fact, and need comfort and explanations? I don't think "this is bullshit, you suck" article will be really good at those. Experienced Rubyists who still aren't too excited about Rails and its ways? But we know that the problem with Rails is NOT "implicit return values and metaprogramming", which you conveniently limit your counter-attack to. So, it is probably some, IDK, Pythonists who made you angry by criticizing your favorite framework, and you want to swear at them back? Then probably you should post that in their subreddits, not this one. (Checks) Ah, you did. OK then.
Rack already does the parsing for you, you just have to call `Rack::Request#params` (or in your case `Roda::RodaRequest#params`): r.params
Cool! *Firre* would also be a good acronym for *Friendly and Interactive Ruby REPL*, as that is a diminuitive of sorts for ”fish” (”fisk”) in Swedish :-)
The way I define magic in programming, rails is the most magical framework out there. I'm not scared of it, I just don't like it. 
TL;DR for lazy: you need to specify algorithm also when decoding.
If you haven't already, also check out the [Roda](http://roda.jeremyevans.net) web framework, made by Sequel's creator Jeremy Evans. Its replaced Sinatra for me. His projects are so well respected, their core elements get adopted into new frameworks. Roda is part of the direction of the dry-web project, and Sequel finds itself heavily used in ROM-rb.
&gt; Thanks for saying I am incompetent in a kind way. :) Yeah, I was worried it would come off that way. Think of it like an artist who works with charcoal looking at oil paints. They're both used for creating art, but they have different associated techniques and have different types of results.
This seems extremely interesting from a technical perspective. What are the advantages over doing it manually, like this: raw_order = { 'items' =&gt; { '#1' =&gt; {'title' =&gt; 'Beef', 'price' =&gt; '18.00'}, '#2' =&gt; {'title' =&gt; 'Potato', 'price' =&gt; '8.20'} } } order = { :total =&gt; 0, :items =&gt; [] } raw_order['items'].each { |raw_item| title = raw_item['title'] price = raw_item['price'] price = Decimal(price) order[:items] &lt;&lt; { :title =&gt; title, :price =&gt; price } order[:total] += price } order It seems like the "old-fashioned" way is easier to read to someone who only knows ruby, and hasn't memorized how `hm` works.
Well, the idea is for "my" version to be short, DRY and declarative, without (hopefully) losing the readability. It is meant to be really effective (as in developer effectiveness) for data processing scripts and other environments where there are a lot of Hash transformations. 
Thanks, that clarifies things for me. Next time I'm doing something similar I'll try and remember to give it a try. Cheers!
The Ruby Pigeon blog by Tom Dalling has great articles on programming ruby functional-style e.g. [Avoid Mutation – Functional Style In Ruby](https://www.rubypigeon.com/posts/avoid-mutation-functional-style-in-ruby) and many more. In the next days I will add an Awesome Functional page to the Planet Ruby Awesome Series to collect all things functional about Ruby - check back [/awesome-functional](https://github.com/planetruby/awesome-functional) in a couple of days.
Great article on MJIT from the master himself. Add the [Awesome Ruby 3x3 Articles Collection](https://planetruby.github.io/calendar/ruby3x3) @ Planet Ruby. Cheers. Prost.
I saw a really good video about functional programming in ruby not too long ago, I'll look again as I can't seem to find it....but in the meantime here is a start: https://www.youtube.com/watch?v=9TBvWRgll64 https://www.youtube.com/watch?v=7qnsRejCyEQ https://www.youtube.com/watch?v=jZ0Xf47P6oo https://www.youtube.com/watch?v=3b1YhdP2fis https://www.youtube.com/watch?v=V-6Rv5I9iPM https://www.youtube.com/watch?v=6ecNAjVWqaI I love functional programming, a few years back I wouldn't have said that. It has been a long road mostly due to my resistance. But there are clear rewards for using the paradigm, and now I thoroughly enjoy it. I have to admit I have not put it into practice in Ruby (I use Elixir and Clojure for that), but have in Java and hope to soon in my next Ruby project.
!RemindMe 4 days "All things functional about Ruby"
I will be messaging you on [**2018-02-21 17:05:32 UTC**](http://www.wolframalpha.com/input/?i=2018-02-21 17:05:32 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/ruby/comments/7y7gvw/functional_programming_in_ruby/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/ruby/comments/7y7gvw/functional_programming_in_ruby/]%0A%0ARemindMe! 4 days ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
&gt; Inheritance. I wanted the ability to use different configuration for different types of files. For example, I want to extract different metadata for images than for videos. But there is no concept of inheritance in Refile. I hadn't realized there was a good intended way to use shrine like this, can you point me to any docs or example of this? Thanks! 
You might enjoy this talk by Gary Bernardt, https://www.destroyallsoftware.com/talks/boundaries, and his screencast “functional core imperative shell” which costs money. Will try to add thoughts when I have time!
Shrine is awesome, super modular and framework agnostic. http://shrinerb.com/
Binding of caller AND method missing? Way too much magic and I bet it's slow af. Interesting, but I'd never ever use this in production 
Thanks for sharing! The Avoid Mutation article is a helpful guide
I love that you are presenting this as experimental for now, and committing to developing in response to actual use cases, not over-engineering. Zverok, you do development right, I appreciate it! Have you spent any time investigating performance and possible optimization?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [zverok/hm/.../**benchmark.rb** (master → 31ac698)](https://github.com/zverok/hm/blob/31ac698e40d064cb969b1ef1a73557b745e22b49/examples/benchmark.rb) ---- 
Is this an issue with `gem` itself or is it affecting released gems?
The issues in here might lead to possible "evil" gems being created that when running `sudo gem install evil_gem` might take over your computer in some way. Installing gems as root is not a good idea, so you should never do it, and when you are installing gems it is a good idea to check on ruby-toolbox or github to make sure the makers of the gem are acting in good faith. Also if you are not running `gem` as root, these vulnerabilities might be used to steal information from your account, but the damage might be a little more restricted.
Functional programming works great for me given I also write Erlang and Clojure. But much like the other "functional language x" discussions, using it with Ruby is an attempt to take a popular pattern and shoehorn it where it doesn't work. Languages that properly support immutability gain major performance advantages when the compiler can assume a variable won't change. Instead, we've got an article on this thread discussing how the performance "hit" of immutability isn't very bad. Why is that? It's because all that article actually does is decide not to declare new variables rather than reusing existing, the compiler has no magic in that. There's no way of enforcing it. You go and use a .each enumerator and it's "not functional" but the best you have is a promise to yourself you won't do that. That's not what functional looks like.
I appreciate your response and I may follow up at a later point if you're still open to it. We're all pretty comfortable with SQL so it can be frustrating having to learn a DSL to, effectively, write SQL. The CTO is partial to the approach and it does feel like it makes it very easy to generate a ViewModel that's nicely tailored to the use case rather than pulling in a lot of stuff you don't have any real need for. I suppose your comment about an enterprise application speaks to the fact that it's really not a necessary step for smaller applications and it might be an example of over-engineering a system that doesn't benefit from it at the cost of development speed? If so, that's actually been one of my thoughts about the way we structure our systems, but we also build both small proof-of-concept apps and enterprise applications and I imagine the thinking is that it's better to have a paradigm that suits the more complex use case.
Uploader classes (`Shrine` subclasses) are where you configure how files will be uploaded. Those classes can subclass each other, and the inheritance is actually respected, [unlike with CarrierWave](https://jbhannah.net/articles/carrierwave-concerns/). In the Shrine README you can see examples of an `ImageUploader`, a `DocumentUploader` or a `VideoUploader.`
Ah, that makes sense. What if I only have one model class involved, but in it's attachment field it might take an image OR a video OR an audio file, with different transformations needed. How would you suggest handling this? Different sub-classes, somehow chosen dynamically based on file type? Or one sub-class with different conditional logic inside it? Or other?
I would create three attachment fields class MyModel include ImageUploader::Attachment.new(:image) include VideoUploader::Attachment.new(:video) include AudioUploader::Attachment.new(:audio) end and assign the appropriate one dynamically based on the type of the uploaded file. I haven't personally had this use case so I don't know what would be the pitfalls, but this approach would be what I'd go with.
I would modify this... practice, makes permanent. If you practice something incorrectly, you will do it incorrectly from then on out. PERFECT practice makes you better. Doing something slowly ... looking up the correct ways to do it.. like reading the docs for Enumerable, Array, Hash over and over while you code.. THAT is how you get really good at something. Also, I cannot recommend enough, watch others do it... and find a mentor if possible.
Love that book. also POODR and Design Patterns in Ruby.
Can't recommend this enough.
Video doesn’t seem to work
I wonder though, can't any malicious gem do that _when you `require`_ it, always, without needing these flaws in rubygems?
I mix FP and OOP styles together a lot. A few things to keep in mind: - any time you're relying on a data structure to be immutable, it must be immutable _all the way down_ - data structures don't have to be hashes and arrays; they can be anything, including your own `Enumerable`s (or instances of `Enumerator`) to stand in for either one - keep public interfaces for objects down to a single method (`call` is a great name so you can use procs in their place) - garbage collection of a handful of objects is cheaper than wrapping your mind around all of the weird states your objects can get into with mutation - passing literal functions (procs) in Ruby is unnecessary; use blocks or even `call`-able objects A big part of what I've been doing FP-style Ruby with is on the front end using [Clearwater](https://github.com/clearwater-rb/clearwater) (a front-end framework where your code is written in Ruby). An FP style meshes really well with a virtual-DOM-based framework since the UI just becomes a function of application state. It still uses objects to compute that UI, but they're mostly immutable. The state for my front-end Ruby apps is managed by another FP-style (despite using objects) library called [GrandCentral](https://github.com/clearwater-rb/grand_central). It's like Elm or Redux, but with more of a Ruby flavor. Your app state and the actions you invoke are objects, but they're all immutable — you update your app state by returning a new copy of it. You can see how some of this works with my [video about `GrandCentral::DevTools`](https://www.youtube.com/watch?v=imBRi1jV_vk). All the code for that example app, including the WebSocket stuff, was written in Ruby. I'd be happy to chat about it more. 
Awesome idea, but I have a feeling by forcing manual 'malloc' calls you will lose a large amount of support from the Ruby community as the mantra is generally 'simplicity over speed' (just looking @ https://github.com/prasunanand/rbcuda/blob/c5e2d7c185b7d45162174a6dcf6de052e78d462c/examples/elementwise.rb). That said, I think a LOT of this could be implemented by some sort of `EfficientArray` class which attempts to better wrap the malloc/free. Good luck with this project though! Excited to see where it ends up :) 
There is no difference between a good abstraction and 'magic'. Rails just has a bunch of good abstractions.
MODS: please add these links to the side at least. postmodern even did great security tools which could be there too :) This is one of paths for ruby for the next years.
&gt; I suppose your comment about an enterprise application speaks to the fact that it's really not a necessary step for smaller applications and it might be an example of over-engineering a system that doesn't benefit from it at the cost of development speed? ROM can work very well in small applications too. Starting from v 4.0 we have model-inference which works in a similar way as in ActiveRecord, and speed of development is very fast because of this. Given that you have much more flexibility (when you need it), without any extra cost like slower developoment or over-engineered system design (you can keep things lightweight), I'd say ROM is already a great fit for ALL applications - small, medium or big. 
Could you please make it so the visited links change color? I keep circling back to your 3x3 collection, which is awesome, but can’t readily tell what I’ve already read. Thanks. 
I just sort of "re-discovered" Ruby, and I wanted to create something with it. I'd appreciate it if anyone could take a look at the code :-)
Odd. Are you on mobile by any chance?
&gt; ie people often think it's about using procs for everything, which is silly, The main obstacle of functional programming in ruby is the lack of first class functions. There are lambdas, but they're ungainly. And on top of that, there isn't a great module system to namespace and import individual functions; it's bring everything into scope or use the fully-qualified name. So we grab the hammer that ruby provides - objects! &gt; Embrace #call as the primary interface for most objects The pattern that I use a lot is a class with a static `call` method that acts as a function, and encapsulates any helper functions it needs. class F def self.call(x, y) new(x, y).call end def call ... end private def helper ... end end This also allows some rudimentary currying, by initializing the object with the curried arguments, and then calling `call` later with the rest of the arguments: class Prefixer def initialize(prefix) @prefix = prefix end def call(str) "#{prefix}{str}" end private attr_reader :prefix end This way we have the illusion of functions, we can preserve namespacing, and we get partial application/currying. Wins all around. Another major aspect of functional programming is immutable data structures. Here we're in luck - ruby has decent built in support. User-defined objects you have to be careful with because you can mutate at will, but builtins like arrays, hashes, and strings have large sets of methods that return a new version of the collection. Basically, as long as it doesn't end in `!` and isn't `[]`, then it's likely to be immutable. Finally types - particulary sum types like `Option`. You can define basic ruby classes for the common ones like `Option` and `Either`, with methods to fulfill the contracts - `map`, `bind`, `return`. You don't get type checking and it's a matter of discipline to not simply reach in and grab the data. I built an `Either` in python that we've used quite successfuly for a long multi-step computation. A basic implementation of `Option` looks something like: class Option def self.return(x) new(x) end def self.none new(nil) end def initialize(x) @x = x end def map(f) if some? Option.return(f.call(x)) else self end end def bind(f) if some? f.call(x) else self end end def some? x.present? end def none? !some? end private attr_reader :x end 
Thanks, I'll take a look. Sorry about that!
Is the example usage correct? $ ./repl git &gt; git init &gt; git add repl &gt; usage: ./repl PREFIX &gt; This creates a REPL that executes your PREFIX + the string read from STDIN in each iteration. If that's true, shouldn't the usage be something like: $ ./repl git &gt; init &gt; add repl 
It might have been a bit unclear, but `&gt; git` is part of the prompt. You don’t have to type it :-)
This is resolved, thanks for reporting it!
Yes exactly, that is why it is mainly an issue with gems being installed as root, as generally they would not be `require`'d as root. 
Defunkt wrote this exact same thing (with the same name) a long time ago, you can compare yours versus his: https://github.com/defunkt/repl
This is really cool! Keep doing the good work!
Thanks for your kind words. Will try to change / update the style with the next update.
How is `RbCUDA::Runtime.cudaMalloc([10,10])` any worse than `Matrix.build(10, 10)`? Is it just the name `malloc` you don't like?
Thanks. I liked the vid. As a newb I like seeing how people use tools and shortcuts. I noticed that it’s part of a series for building an app. Is the larger series paid or free?
I rerun it a bunch of times on two servers with fixed CPUs: [updated doc](https://github.com/vfeskov/link-too-big/blob/master/benchmark/README.md) . Still even-machine wins all over the place, but huge difference makes me think there's something wrong with wrk benchmark
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [vfeskov/link-too-big/.../**README.md** (master → 5314fc2)](https://github.com/vfeskov/link-too-big/blob/5314fc269df918138402641efc5f9017a84d0ab5/benchmark/README.md) ---- 
I'm pretty sure when you call making in a linked c file without a free that's a memory leak. But this library is still a WIP so I was trying to make a suggestion to make it more ruby-ish
But in what way is it not Ruby-ish? `RbCUDA::Runtime.cudaMalloc([10,10])` looks exactly like `Matrix.build(10, 10)` to me. What's the important difference?
I have VERY little understanding of what is going on here (Not sure why we have normal and RbCUDA arrays) but doesn't it seem like arr = Array.new(100) { 2 } gpu_ary1 = RbCUDA::Runtime.cudaMalloc([10,10]); RbCUDA::Runtime.cudaMemcpy(gpu_ary1, arr, 100, :cudaMemcpyHostToDevice) Could be more rubified with something like class EfficientArray def initialize(size) self.gpu = RbCUDA::Runtime.cudaMalloc([10,10]); end end arr = EfficientArray.new(100) {2} (Not actually sure how that malloc call would work) which wraps all the RbCuda allocations stuff underneath. The arithmatic stuff would be hidden by defining our own "normal" ruby operators which would call the RbCuda stuff underneath. Basically hide all the CUDA stuff. 
Right the rest of the API could be simplified, but the original point was that 'forcing manual 'malloc' calls' was a problem, and I'm saying why is calling your method `malloc` any worse than calling it `build`? There's literally no difference except in the name.
What would be really cool is if the REPL allowed for executing arbitrary ruby code and interpolating it into shell commands. As it stands, I don't see a big benefit to this versus calling the program from shell.
Ah, that makes sense. Seems like one good reason to avoid installing gems as root in production; some systems/processes for setting up production do, some don't. 
You are probably being downvoted because you are largely going against the flow here, as personified by http://david.heinemeierhansson.com/2012/dependency-injection-is-not-a-virtue.html which mentions Timecop specifically.
How didn't you know this sub is not for IT specialists? Mostly subscribers are ex PHP coders switched to Rails. You should not hope for technical discussions here.
Thanks. I haven’t looked at it in awhile. I’ll check the broken links. Suggestions for other content?
The difference is in whether you need to do an explicit 'free' at the right point, I guess? 
But you don’t need to do an explicit free.
Uh, not for data in C-land being accessed via FFI or similar. 
interesting, watching this thread and repo... 
Ha, thanks! I couldn't understand what was going on until you suggested this.
That's so awesome. We need more of this.
I like dependency injection, but not in this particular case. By having default value for `time` actually you create to conditional branches in your code: * When time argument is passed * When default value is used. This test covers only the first case. It's possible to introduce an error end the test will not catch it. Let's say one mistypes `now` and writes `noow`. ``` def current_year(time = Time.noow) time.year end ``` This code passes the test, but will break it no argument is given.
personally, i have probably a dozen or more shell aliases for git commands... gs (git status), gb (git branch), gc (git checkout), you get the idea.
The naming is the root of the problem and the source of confusion. "malloc" has a very defined meaning in traditional programming. this is memory that is manually allocated and then needs to be freed. This is not that "malloc". It has different semantics but calling it malloc will instantly trigger the "Malloc/free" thinking of devs. Basically, while it may be accurate "It allocates memory" it doesn't do it the way most people think it does (since you dont have to free). 
It doesn't need free - the Ruby GC will free it. Look at the source code! `cudaFree` is a no-op - it doesn't do anything. https://github.com/prasunanand/rbcuda/blob/f6c47359ddc906e1815cb55aafcc38666f67650f/ext/rbcuda/internals/cuda_runtime_api.c#L1120 And `cudaMalloc` sets up the GC to free it automatically. `rbcu_free` is a callback that the GC will call to free it for you. https://github.com/prasunanand/rbcuda/blob/f6c47359ddc906e1815cb55aafcc38666f67650f/ext/rbcuda/internals/cuda_runtime_api.c#L1049 I can agree the name is wrong, but the how you use it is exactly the same as `Array#new`.
&gt; Has anyone else experienced something like this and can &gt; offer some advice, or should I just say fuck this, fuck &gt; the stock options, and move on? I had to take a python course in university some time ago. It was ok ... ruby is better but python is alright. My biggest problem with python is still explicit self. I can not forgive this choice. It really boggled my mind why I got errors in python, until I realized I forgot to pass (self) into a method ... it's annoying. The rest, well. To be honest, I think the net differences between ruby and python are not that huge. They have similar niches and they are similar in many ways. The biggest difference by far is still the philosophy. Here, I also like ruby's philosophy a lot more. Python has a few strong points that have nothing to do with ruby per se. More users - that in itself is a pretty strong advantage, simply because you will have more resources available. I know of various C++ apps in bioinformatics where only one scripting language is used. This is these days almost always python, sometimes lua and almost never ruby. I know several university courses in python but none in ruby. :( I do not think that it has anything to do with python being so much better than ruby (I would not know why), but simply because python is better than perl and php, and easier than C/C++/Java, so it is used, in particular for technical curricula without a major in informatics (so guys who study process engineering are more likely to use python than C/C++; only exception are micro electronics people, who actually use C/C++ in their courses; pretty interesting). Some of the problems you describe appear to have more to do with your editor. Perhaps you need another one. :P &gt; I used to be able to be able to try out all sorts of code in irb &gt; writing all manner of gobbledygook to work with my data and &gt; then move it over to the editor, clean it up, and call it a day. I do this too quite a bit in ruby. Perhaps you need an editor like geany with "embedded" vte terminals on the bottom (tab). Then you can write the code above, and have irb on the bottom and switch easily in the same window/pane. (Geany is just one example; I guess there are more editors or lightweight IDEs with similar functionality). I tend to use a lot of aliases and ruby scripts to help me add/change code, and use terminals with tabs. (Usually I use KDE Konsole but since I am also using mate, I use mate-terminal these days, which is essentially a fancified vte; it's quite nice, not as nice as KDE konsole but I am getting tired of the KDE ecosystem getting more and more useless apps and more and more bloat and qt getting bigger and bigger without really giving me anything in return other than more bloat). Anyway to conclude - I think it is possible to use both ruby and python. They are not that different in my opinion. OOP in ruby is much nicer and better though IMO.
&gt; Don’t limit yourself to one language even if it feels like &gt; you are crawling instead of running. I don't agree with this sentiment because it means that all languages are equal (can't be) and using an inferior language is ok (which makes little sense if there are BETTER languages out there). Case in point: - Using PHP. Why should we do so? I could not tell you. I can not think of anything PHP does that ruby could not do. Ruby replaced all my web-needs that I used to fulfil with PHP.
I don't use mass one liners myself. I use aliases + lots of ruby classes that do the job that I need them to do. Sometimes via some --commandline option, sometimes just a simple class that does what is needed. I have classes such as RemoveEmptyDirectories. Pretty bad name ya? But I have it aliased and whenever I need to kill all empty directories, I just invoke the alias. I am sure there are a billion other ways, including shell scripts, but the ruby code is simple and clean and it works fine. (That was one example of many more examples.)
&gt; It has its own idioms that are much more consistent &gt; within themselves than across language boundaries. Ok. How is explicit self consistent? To me it feels as if python is too dumb to know what self is, so we have to specifically pinpoint python to it FOR INVOKING METHODS. That feels backwards OOP design. 
I guess the problem is that he has to write python code because the team uses/needs it. Not because of solving this or that task. It's like an amplifier why python gets more coverage, more and more python jobs will lead to more and more python code and more and more people who get hired to write python rather than ruby. A bad trend for ruby folks. As the examples here show - many ruby people can relate to it, since ruby is the better language. :)
&gt; All the special underscore naming crap feels very legacy. &gt; (Not that Ruby doesn't have similar cruft, so that's kind &gt; of nitpicking.) It's still different. In python it is more than just a convention. E. g. private attributes. Ruby uses @ instead. As for gem versus bundle - since bundler is merged into ruby this year (successfully), these differences will probably disappear in the long run.
Yeah I am well aware, but there are also a large number \_\_builtin_methods\_\_ in Python. It's pretty ugly.
`—order defined` is the wrong approach. Look into `—seed`. Otherwise you’ll still miss the B then A failure. 
No that's not, and did you bother reading it? Do you understand it? It's a general description of SQLAlchemy. That or go read the AoSA chapter on SQLAlchemy.
Grampa perl can do that too: rename 's/(.*)inline\.svg/$1.svg/' *.inline.svg
Before I talk about the rest, rest assured that I'm not talking about Demeter's law or the like. I don't personally give a hoot since I abuse it, though some of my coworkers had a hard time, and so will some of yours. Yes, Ruby has `#map`, `#select`, etc. in the right order, like a pipeline, rather than a mess of nested function calls to read from the inside out. However, when you have to pass blocks to those because your transformations, filters, etc. are non-trivial, it seems a significant part of the community starts to complain about _style_ and _comprehensibility_. I mean on the threshold of 7-8 lines, a few `do`-`end`. Go figure. Antipatterns are just convention anyway.
Oh.. Thanks for pointing to this. It's something I haven't known about, I often missed something like this :)
well Ruby is not the most optimized language for functional programming (e.g. compared to Go or Elixir are much faster) but you can benefit with from all the aspects of functional programming as a design tool (http://www.eq8.eu/blogs/46-lesson-learned-after-trying-functional-programming-as-a-ruby-developer) . So immutability of state and clear definition of interfaces are great practices to avoid future errors. I've never tried to write "fully" functional project with Ruby (As Ruby is designed with OOP love &lt;3 ) but there is no harm (just gain) from using sprinkles of functional in Ruby 
You don't specify `--seed` in CI. When using RSpec's `--order rand`, it tells you the seed it used. You then pass `--seed xxxx` to RSpec when attempting to recreate the failure locally. Much like manually bisecting instead of passing `--bisect`, using `--order defined` is more effort than the built-in tool meant to address this. Does Solano CI randomize the tests for you instead of using RSpec's randomization? If so, that's weird (and atypical -- neither Travis nor Circle do that). For parallelization, I use `parallel_tests` to parallelize, both inter- and intra-node, and it still uses RSpec's randomization under the hood (and helpfully provides the exact command, seed included, to recreate a failure).
rspec bisect is great, but intermittent failures are not always order dependent.
Certainly interesting. I'd love to give TruffleRuby a try (my current experience is only MRI &amp; JRuby). I looked around a bit and I saw that RVM integration is being worked on; that'd be nice.
Having a background in automatic and manual memory management, if I see Thing#new I expect the GC to have my back, and if I see malloc() I don't. Principle of least surprise. He's not the only one. There will be plenty of folks that come in not expecting that, and even if you see it as a nervous hangup we have, then expect plenty of users will have the same hangup. At the very least it will have to have a big colorful warning in your documentation.
FYI: The Dr Jekyll's website is built with ... Jekyll (and Ruby) - https://github.com/drjekyllthemes/drjekyllthemes.github.io
I think this proves that every form of magic is domain-specific. Domain-specificity is the greatest thing in the world until you need to switch domains or talk to a different domain. Now you're back to where you started...
It means exactly opposite of that. Languages are not equal which is why you shouldn’t limit yourself to one. There are simply better tools for certain jobs. Using your example, if php was better for that use case and could not be improved with another language then that would certainly be a case to learn and use it. However, like you pointed out, ruby mostly fulfills everything you would use php for and then some which makes it the better language. I can also concede that there are times when you might be forced to use an inferior language because the company has invested so much into it and ripping it out to replace would be a huge resource sink. However that would be an example of NOT using the right tool for the job, wasting time learning an antiquated language and simply dealing with technical debt. 
It already has: https://github.com/oracle/truffleruby/blob/master/doc/user/ruby-managers.md You still need to manually install the graalvm (at least to my knowledge) due to the license. But for trying it out that's a quick initial and one-time step.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**ruby-managers.md** (master → 326623f)](https://github.com/oracle/truffleruby/blob/326623f4179a2e362c4a1c4db4cdd3e66fc81fcb/doc/user/ruby-managers.md) ---- 
Yep, "do it yourself" is the pattern I've followed. In many cases I can just remove the JS from a theme and it works exactly the same. There are actually themes with "minimal" in the name that still bundle this stuff. I guess they mean it looks minimal.
Do you know how restrictive the licence is?
cool
Why should someone get downvoted for offering a different view point? That seems unfair.
Not a fan of that refactoring. It makes the code bigger and more complex with little tangible benefit. If you are worried about forgetting to update a case..when, I always do this: else raise ArgumentError, "Unknown value #{value}" end 
I absolutely hate these blogs that wait until you've scrolled a page or two and then pop up a newsletter signup modal. 
Nick will be speaking in english
the second presentation (in around 20-25 minutes) will be fully in english
Even better when somehow the CSS is broken. https://i.imgur.com/bfxP1Lo.jpg
... Maybeeee there needs to be ___reactions.com ... and you could write it in Ruby. You already have some sort of market validation right? :))
Made me question whether I had accidentally clicked something at first... o_o
We will remove popup tomorrow, thanks for response.
From my experience, ruby just kinda falls flat here. Only suggestions I can point towards are * https://github.com/SamSaffron/message_bus * https://github.com/anycable/anycable Message bus keeps chugging along. I find myself using it all the time as the API is clean and it remains fairly active in terms of development. Anycable is a good place to look if you want to actually scale sockets with ruby. It's rails agnostic if you want it to be. Built on litecable, which is ActionCable separated from rails. Please post if you find anything compelling. 
This is interesting. I love the Attributes API. Not sure if it's needed here or not, but is giving me some ideas for a place I DO need it. 
I like this article. If you'd like the blog to be included on http://rubyland.news, make an RSS or Atom feed for it, and let me know. (Bonus points for making a feed of just articles with some kind of 'ruby' tag, so it doesn't include non-ruby content). 
Is it just me that finds a reddit link to the rubyflow entry with little information annoying, instead of just a link to the thing being blogged there? https://github.com/palkan/isolator
is dev.to like a shitty version of medium but for developer blog posts?
This problem was identified early in the article: _If we change values in CALCULATION_METHODS there is a big chance that we will simply forget to update them in a case-when operators_ but this code smell is still present by the end, because `Commission::Calculator`'s factory method is still using a multi-way conditional to decide what type to build and `Commission::Calculator::SlidingScale` is changing its behaviour on what is, ultimately, a string match against the calculation_method column data.
Note: I didn't upvote or downvote. Most of it is covered in the link I posted. Basically it is considered bad advice and therefore should be downvoted to protect newbies from accidentally following it. It is also a slightly cultural thing. Dependency Injection is EVERYWHERE in Java and there have been instances I can remember in this subreddit where a Java dev has basically come in and posted a blog article that boils down to "Here is why you should use dependency injection in ruby because this is why we do it in Java" to which most ruby devs respond "This isn't java. The same arguments don't hold sway, GTFO with that advice". I highly recommend reading the link I posted to get a better understanding of what I am talking about. It sums up the attitudes quite nicely. 
I used to have one of these on https://www.schneems.com when I switched to a static form at the end of each article and a picture of my face signups went up.
No, I don't think you're justifying it. The first sentence of my reply was just stating that I understand the argument about dependency injection, the next sentence was explaining why I chimed in originally, not an attempt to rebut you. And, actually, I think I am giving critique to reddit as a medium more than I am at this subreddit's community. It's all too common for people to use the downvote button to silence ideas they don't like. But, you did say this: &gt; Basically it is considered bad advice and therefore should be downvoted to protect newbies from accidentally following it. I did take this as a tacit endorsement for hushing people whose ideas contradict conventional wisdom. At least a little bit. Anyways, I just wish there was more room here for people to actually disagree peacefully. Cheers!
Ah I see &gt; Basically it is considered bad advice and therefore should be downvoted to protect newbies from accidentally following it. Is what I believe the prevailing opinion is (without any endorsement of said opinion) and in general this could be considered a perfectly logical view. For instance: Post: "How do I lose weight?" Comment: "Drink lots of soda and and eat junk food" -1420 points Seems like perfectly legitimate situation. It all depends on what is considered bad advice by the majority and as we have seen here (in a very small subset. It was only -2 points) that appears to be the case.
thanks!: actually found the solution here: https://stackoverflow.com/questions/31972968/cant-install-gems-on-os-x-el-capitan sudo gem install pry -n/usr/local/bin did the trick i believe
[iodine](https://github.com/boazsegev/iodine) - HTTP / Websocket Server with Pub/Sub support, optimized for Ruby MRI on Linux / BSD
We will add rss feed with only ruby articles today. General feed is located here: http://jetrockets.pro/blog.rss
I think that will let you run the pry executable, but I'm not sure that the library will be setup properly. The error you running into is likely because you haven't enabled the root password on your mac. Instead of 'su'ing, you can preface your admin commands with 'sudo' to get them to exec as root (there's some caveats around this, but it's not important for this). So, `sudo gem install pry` will install the pry gem system wide. /u/sshaw_'s suggestions are the real world answers that you'll see most ruby devs use, usually with a versions manager so you can hack on different projects more easily.
I love to hear Matz talk, his ideas seem to be so good! What you people think?
With this approach nothing will ever restrain you from putting logic inside Value Objects (in fact this is main reason for refactoring sessions like this I had recently), leaving you options to manage ever-increasing complexity of application.
Looks like it detects side effects\* inside of a database transaction. E.g. if you make an HTTP request during a transaction and the transaction is rolled back the HTTP request was sent anyway which is often not what you want. \* Mutating variables which live outside the transaction block is a side effect as well, but I don't think it's detected.
As far as I can tell, neither of those are clients. Thanks though. I do agree, Ruby does tend to fall sort of flat here in the sense that I just wish there was something that offered a similar interface to Socket.IO for normal polling.
"a rudimentary web-application framework" :( y u gotta be like this man
ah ok, thank you both. I was not able to even do `sudo gem install pry` because it was saying i do not have write permissions on /usr/bin which is where it was trying to install. i did a ls -l and it appears i had full permissions even as my regular default 'z' user. the solution from stackoverflow pointed to SIP on macs Do you guys think i should uninstall pry as I had done with `sudo gem install pry -n/usr/local/bin` and do what sshaw mentioned?
I don't really have the time to write something like that. Tumblr is pretty good for this IMO.
That's what I quoted and posted a "wtf am I reading" gif as a reaction.
http://jetrockets.pro/blog.rss?tagged=ruby
It made me laugh. I was referring to the big meanie who wrote that in the first place. 
added to rubyland, thanks! I didn't realize you already had an RSS feed, because there was no auto-discover link in the html version. `&lt;link rel="alternate" type="application/rss+xml" href="whatever"&gt;`. Most blogs that have feeds do have this (I can say in my experience of looking for feeds to add to rubyland), perhaps because most blog software (including jekyll i believe) adds it for you. (RSS/atom is for me a nostalgic memory of when we thought the web would be based on open APIs...)
Well, there's actual science behind weight loss, so it can be actually identified when someone is talking out of their behind. Dependency inversion is also settled science, and it's not exactly in DHH's favor -- although I must agree that passing in an optional time argument to a method is pretty abnormal, normally one would invert the `Time` class, not the current time itself, and not via an instance method. Anyways, the moderation seemed to work out fine, but your original comment left me with a sense that this might be the kind of community that doesn't welcome challenging ideas. Perhaps I overreacted.
Ah, right. It's possible "non-atomic interactions" is technically correct (I'm honestly not sure and get confused thinking about it), but I would find "non-reversible side-effects" more clear. A disclaimer on non-reversible side-effects it _can't_ detect (like mutation of in-memory data structures) would probably also be a good idea. 
uh, isn't everything "recorded live" ?
Great news. Great speakers. FYI: I collect [ruby conferences &amp; camps (around the world) in 2018](https://planetruby.github.io/calendar/2018) @ Planet Ruby.
Is it just text? Than convert the html to markdown and than convert the markdown to pdf. For markdown to pdf, see &lt;https://github.com/gettalong/kramdown/blob/master/lib/kramdown/converter/pdf.rb&gt; for example. Cheers.
I usually use [DocRaptor](https://docraptor.com) for my html to pdf needs. It’s not free, but it is super easy. 
not only text, also pictures and css styles.
Why have you ruled out those options?
FWIW, JRuby running on Graal (no modifications) is another 3-4x faster on this benchmark, putting it well ahead of MJIT.
A free super easy option is puppeteer with google chrome (using javascript) &lt;https://github.com/GoogleChrome/puppeteer&gt;. Official supported (and built) by Google. 
If your styles don't change you can "hard-code" the styles in ruby - adding pictures if you don't want a text reflow or something should work too. PS: If you use the Java version of ruby you might use the old classic Flying Saucer.
Great article, though honestly I found that the example had a big bunch of namespacing so it was sort of hard to sift through. Maybe next time, shorter words in the code example? But yeah I have the same idea re: extracting primitives to their own object types. Easier to add methods when you need to. When do you extract it strings to value objects? Just like /u/mperham said, it makes the code bigger. I'm guessing you don't do this for all the strings you have (or do you? hehe) 
pry and rubocop Although they seem to be sworn enemies as rubocop wants to remove all your pry entry points.
Honestly.. I'd learn Python. 
I learned ruby in 1.8 days with the Pickaxe book, and I'd do it over like that again! 
Read the commit history of the language.
I learned the basics through the fun and addictive puzzles in josh cheek’s ruby kickstart. Wouldn’t change a thing. 
Can you elaborate on why? 
Well, the increased speed with GN particles is a pretty good jump on [current Gundam tech](https://en.m.wikipedia.org/wiki/Mobile_Suit_Gundam_00). 
I would start by forcing myself to create lots of objects. I learned Ruby by writing super procedural scripts that all operated on global state. Which has its benefits - I focused on learning the standard library APIs and solving problems simply. But where I really feel like I'm harnessing Ruby's power recently is by writing lots of little objects and taking advantage of duck / dynamic typing. So I wish that were more ingrained in the way I think in Ruby. 
&gt; It’s a very nice feeling to be completely up-to-date and to reward that... Upgrading for the sake of, upgrading? Security aside, always being up-to-date makes me a bit nervous. Stability feels a lot better. 
Avoiding rails. I love rails actually, but I'd rather prefer a more "pure" approach to Ruby and OOP.
Sandi rejuvenated, or possibly created my love of OO. It sounds blasphemous to speak positively of OO in 2018, but I have a rekindled relationship with it. Lots of problems that people have with OO is from failing to make lots of small objects, and not having this clear-sighted goal that Sandi outlines in this article: push all conditionals to only decide on which objects should be created, and thus to the boundaries of your system. Vary behavior with polymorphism. Couple loosely with dependency injection. If these principles have failed you, I believe it's an implementation error and no fault of the paradigm. The worst object oriented code is when a class becomes gigantic, and simply wraps a procedural chunk of stateful code. Instead of sharing the benefit of simplicity with the procedural counterpart, that object turns into a weird Frankenstein monster that totally fails on the promise of OO. But when focusing on lots of little objects and limiting conditionals to outer layers of the system, code can become beautiful and most importantly easy to change. The most interesting part about this is I don't think it's at odds with the surge in functional programming stock. Objects can operate on immutable data. The implementation of messages can use functional transformations. As Ruby proves, you can mix objects and closures. Where functional programming ceases to work though, I think objects come in and provide a framework to scale up a codebase to another level of cohesion.
When you see him, tell him that his ruby course based on classic CS puzzles is very much appreciated. 
Sadly I moved away from his area, but if I do go back and run into him I'll be sure to tell him!
It doesn't redirect though. You need 301 redirect to non www domain.
There's a variety of paths that can work for someone. If you don't know OOP - I always suggestion the simon allardice course on OOP principles that is agnostic. Learn Ruby the Hard Way, PIck Axe Book, Well Grounded Rubyist, are all great foundational books. I'm starting to think the 'ape my code' things like code academy are not as helpful as they should be. The model doesn't reinforce learning as much. 
Use TDD and understand why you should be doing it. Learn OO by studying and applying this book http://www.poodr.com/ and watch lots of talks on youtube by the author. This will teach you about the SOLID Principles in the context of Ruby. Use the code quality tools Rubocop &amp; Reek Learn how to use a debugger. The Rubymine debugger is awesome. Get a job using Ruby to solve problems everyday 
Some folks might not realize their functional language is operating these OO principles under the hood.
1. Learn Ruby Coarse from codeacademy.com 2. Read the book "The Well grounded Rubyist 2nd Edition" to build a deeper understanding. 3. Read the book "Practical Object-Oriented Design in Ruby" 4. Then spend a lot of time building small things, for example http://rubyquiz.com or http://exercism.io/languages/ruby/about 5. Find an Open Source ruby project that interests you and study the code base and even try to contact the developers and try to fix bugs and contribute. 6. Maybe start work on a major project of your own. 
Different people have different idea's about what OO is. In Ruby, as far as i can tell, OO is a way to achieve polymorphism, which allows you to dynamical dispatch based on the type of the object. To contrast that approach, consider that Clojure also lets you dynamically dispatch on Type without coupling the dispatch functions directly on objects. Doing so lets you add new types and new functions easily thus solving [Expression problem](https://eli.thegreenplace.net/2016/the-expression-problem-and-its-solutions/) &gt; Where functional programming ceases to work though, I think objects come in and provide a framework to scale up a codebase to another level of cohesion. This confuses me, why do you think its hard to scale up a codebase in Clojure (or any other FP langauge?) Or put another way, How does OO enable this? I really enjoyed my time using Ruby, i think if people give clojure a try they will find the language has everything they loved about ruby + some things they didn't know they wanted until they had them. 
Indeed, FP and OOP are not _competing_ paradigms.
2.5
&gt; "hard-code" the styles in ruby what do you mean? how can I replicate CSS and ruby?
Hehe, nice
I thought it was funny, but oh well :) 
Pdfkit lets you directly generate the PDF file, like writing the binary content of the PDF file. Wkhtmltopdf lets you write an HTML file that it then turn in to PDF. 
OOP isn't easy. The haters have only ever experienced procedural code in an OO dress. 
I would learn java and spring at the same time. 
Eh, there are insane style defaults. The linter stuff is barebones. 
I don't understand what I am supposed to get from this article. 
same here. rails made me hate ruby for a full year because it hid all the great ruby things from me. it took me moving off of rails and back to sinatra (and to roda since then) for me to fall in love with ruby.
which is faster and lighter?
My first post ever was about [learning Ruby](https://iridakos.com/ruby/2013/11/08/dont-give-up-on-ruby). Happy birthday Ruby
&gt; not everything is an object (writing len(foo) reminds me of PHP) In terms of global functions, which are no object's methods: Function len(x) is global function (no object's one) because it doesn't change objects state. It doesn't return this object. It returns int. What I mean - python is object oriented but some functions are not connected strictly with objects. The better example is sorting function. You can use x.sort() or sorted(x). What is the difference? The first one returns the same object but with sorted values. The second one returns new object with sorted values. So the first function is object;s method because it operates on objects state, the second is global function because it doesn't change object. That's the easiest way to understand such functions like len() sum() max() min() etc. Despite this distinction all of them return values of object's method __len__() __sum__() etc. You can ask why not to use x.len() then? Because you can have your own class that inherits list type (to have default list behaviour and methods) but you want to have your own implementation of calculating length (ie. only odd values for some reason). You can write sum() method and still can use default sum(x). It's not that bad as it looks. &gt; you have to import everything python is explicit language. If you use some function or class you just import it first. I don't see anything bad and strange here. &gt; the fact that Python is multiline whitespace is a full-frontal lobotomy compared to multiple ways of writing blocks I think you also intend your code for readibility. What's the problem here? That's the funniest plea to python language. Everyone intends code. Dot. In python it's part of language syntax tah saves from using END's and braces. &gt; sugar like foo = 42 if .... Man, that;s the beauty of python. List comprehensions, maps, reduces, lamdas. It's so much simple to read and write. Sorry but list comprehension in ruby?: some_array.map {|x| x % 2 == 0 ? x * 3 : nil}.compact eee... :| &gt; especially when it's a few levels of indentation in If you have to much indentation levels it means your code is bad despite the language you use.
From my experience wkhtmltopdf works fine as long as your input is small (reasonably). We had some troubles generating 500+ pdfs with it. Development speed will be higher with wkhtmltopdf, since you can just make html page with erb template or whatever. Runtime performance (memory, cpu) will probably be better with pdfkit (never used it though, so take it as an assumption).
hooray!
&gt; you need to come up with abstractions that are lurking in your tangled code when you can't have more than 100 lines in a single class. This is exactly why I'm not a huge fan of rubocop. You should never have to force anything. I see awkward abstractions all the time because someone was trying to follow a rubocop rule.
That's a common argument - my view is, community agreed upon smells outweigh the desire for your freedom as a programmer. The fact that an awkward abstraction was made is a fault of the programmer - design is not easy. There's many ways to make software. I think this argument is sad and actually arrogant, so agree to disagree. 
This really rings true to me. I suspect there's a LOT of code out there that is nominally OO but is actually procedural. 
&gt; Or are there any inherent issues with OO which have shown in the course of history? If you wanted an actual discussion around the topic you would have to start by defining what OO was. If we go by the wiki definition &gt; Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of "this" or "self"). Then yes. I believe its possible to have real technical issues with this way of modeling things. The argument is simple. Coupling behavior (functions) to data is unnecessary and so leads to incidental complexity. If PL advocates want to justify the OOP part of there language, they're doing a poor job, because most advice on how to write better OOP programs is to minimize this coupling and so working against what the model _affords_. Case and point, some of the [champions](https://twitter.com/unclebobmartin?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor) of[ good OOP practice](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod) of have [adopted languages](http://blog.cleancoder.com/uncle-bob/2017/07/11/PragmaticFunctionalProgramming.html) which arent OOP, because they embody the best practices they were teaching. Does this make Ruby a 'bad' language? No, *Ruby is awesome sauce*. but I think the best parts of ruby don't come from it being object-oriented. 
I've been flirting with Ruby here and there for the last year or so, but at this moment I'm reading Eloquent Ruby by Russ Olsen and the relationship is getting serious.
Yes, the startup is slow on JVM. But once warmed up it should be pretty fast.
FWIW I use the [wicked_pdf](https://github.com/mileszs/wicked_pdf) wrapper gem around wkhtmltopdf. It does a nice job of encapsulating all the options.
&gt; I think this argument is sad and actually arrogant, so agree to disagree. Try and back up your statement with facts, otherwise you're just trolling.
Looks interesting. Is it for general-purpose programming algorithms too or must they fit into a specific domain?
I applied for Ruby jobs and if my cover letter+resume/CV passes their initial check, and I pass the casual interview that’s usually over the phone, they’ll give a Ruby online test or small project. The test will give you a good idea of what concepts to study. The project is good in providing feedback on your code and design, especially if they encourage communication in the project requirements. I find projects the best to learn from as online tests usually advise you to not use a search engine to aid you in finding the answer. And that’s stupid because realistically most programmers don’t remember the boilerplate code snippet or exact syntax of a method off the top of their head; they look it up on a search engine or an app like [Dash](https://kapeli.com/dash) or [Velocity](velocity.silverlakesoftware.com) on a daily basis.
Your opinion is totally valid, and fairly popular I'll add. I talk about this with people a lot. What I said or meant to say was that that line of thinking is arrogant - which is a bit harsh but I stand by it. I trust the tool to tell me what is and isn't good. It makes for more consistent code, and to think that I could make the code better by ignoring rules that are agreed upon by an entire community would place a bit too much faith in myself in my opinion.
I am quite proficient in Ruby. I can code a rails app in my sleep. But, for where things seem to be heading these days, I could cover a lot more ground with python. Data science, machine learning, code a web app backend, etc. can all be done in Python. I would love to be able to do it in ruby, but the tools are not there. And in my career now, being able to do stuff is pay dirt. Anyone can build a simple crud app. But you get paid a lot more to deeply integrate Ai tech into your work. So if I were investing now, I would invest where I thought I could get the biggest return. And, right now, that is python. 
https://github.com/DevDungeon/Cookbook/tree/master/ruby
Have you taken a look at this? https://www.reddit.com/r/ruby/wiki/datasci
&gt; ignoring rules that are agreed upon by an entire community would place a bit too much faith in myself in my opinion. In my one job where I used ruby on rails, the rubocop settings were a great source of debate among the team. Always remember that other people don't have the same experiences as yourself; calling the opposing viewpoint arrogant just because you disagree is a bit lazy.
Expecting to find a blog post. Sorry but this is blatant advertising
Sorry didn’t mean to offend. I’ve been working very hard on this book for the past year and wanted to share. I am posting free blog posts at http://cleanforrubyists.com if your interested.
Ok, we will try to make examples more accurate.
Than share your ideas with us :)
Thank you! You can submit anything, really. No specific domains. You have an idea?
Thank you for your comment! Absolutely, let's integrate your service (which is very useful). I will send you a PM 👍
C
I am using wicked on an application to which generating PDF is the core of the app, and so far I have not encountered a feature I could not implement within a short span of time. It is really flexible and reliable. I have not tried others though, because I simply didn't have to.
There absolutely is. And despite all of the reading and practice and professional experience and POODNYC and retreats, and on and on, i'm still guilty of doing it. I caught myself just today, in fact, writing something in a PROD Rails app that was grossly procedural. I mean, I did catch myself, and so I was able to refactor it, but I can look through code that I wrote in the last month, for instance, and find plenty more examples. Sometimes you're just a little too close to the code to see it, I guess.
 can wicked_pdf be used to generate pdf from html?
Yes!
Yes, it uses the asset pipeline, so it uses templates in the views folder. Wicked has pretty good documentation, definitely read up on it before using the gem.
I have a Rack app, not Rails. In the documentation of the gem wicked_pdf it relies on Rails. Can it work with a Rack app too?
I am afraid I don’t know, but I would trust the documentation.
I would suggest using [PDFMake](pdfmake.org)
It is possible to save html with watir/capybara in capybara you can do this: `page.save_page html_file_path` in watir `html_text = @browser.html` `File.open(html_file_path, 'w') { |file| file.write html_text }` however both only save html file, it lacks css with styles for that I look for every .css in html, download it, save it locally next to html and gsub their paths in html file so path is local final result is really nice, helps to check for changed ids on frontend without restarting scenario and debugging it 
It's not a gem, but probably way better than any gem you're going to find: https://pandoc.org/
Great write-up. FYI: Find a complete [ruby conferences &amp; camps in 2018](https://planetruby.github.io/calendar/2018) (in a single-page) with web feed (for updates) @ Planet Ruby. Open source (on github). Auto-built with Jekyll (and GitHub Pages).
Maybe arrogant is too aggressive of a word? How about unwise? I'm not saying these things because I disagree with the viewpoint - I believe the viewpoint is unwise. I believe in not changing rubocop rules. No exceptions. It's not always easy, and it requires discipline. It's way too easy to say, "wellll I think it's fine in this one case. I'm just gonna ignore this rule just this one time." Ignoring the rule one time goes against a crowdsourced principle that many more people than a single team at a single company have agreed on. Once you break the rule, you've undermined the rule's value. The rules are there for exceptionless, sociopathic consistency. Going against that principle is unwise. 
In that case just use PdfKit, it was designed to work with any Rack apps. WickedPdf was built to be used with Rails, even if you make it work with Rack app, it might break easily when something in the repo is updated.
We use wicked_pdf and wkhtmltopdf-binary-edge to get the binary installed. wicked_pdf has worked pretty well for us. The only issue we're having is, since we're generating PDFs from a URL, it has to make another request to the same server (so single threaded dev servers lock up and can't generate PDFs). Once we have time, we're going to migrate to wicked_pdf's [pdf_from_string method](https://github.com/mileszs/wicked_pdf#super-advanced-usage) and that should solve that issue.
&gt; Going against that principle is unwise. And I believe that following rules blindly is unwise. To each their own.
Or just ensure you are running dev with multiple threads. I believe the current defaults do this for quite a while.
Just pick the one you like and use it consistently. Without seeing the code its tough to say, but I think you should be using modules in here, and letting the module dictate the file structures.
Reference links?
Sometimes I just start with everything in one file (gasp!) and then when it works I say, “this sucks, let’s break it up now”. Write tests because trying to implement your own code gives you all kinds of clues why it sucks.
Try this in IRB: a = 1 a + 1 puts a a = a + 1 puts a a += 1 puts a
`.each` is an iterator that does not mutate the state. You’re looking for `.map`, which will mutate the state. Another thing to note for `.map`, is that it will return the modified array. If you want to change the original array, use `.map!` which changes the array it is passed.
So, a couple things. For one, think of the block (everything from "do" to "end") as a special function. In this case, that function takes one parameter, "a", and returns a+1. The "each" function can be thought of as a _function that takes a function as a parameter_. Now a block isn't _technically a function, but it's close enough for this explanation. The each function takes the block function you pass it, and calls the block once for every item in the array. However, "each" doesn't do anything with the return value of the block; so the example you've written adds one to each element of the array, but then throws away the result. To get the result you're expecting, you need the "map" function. Map takes a block function, applies it to each item in an array, and then _replaces that item with the result of the block_. With me so far?
Using JSON over HTTP is likely the simplest to work with and test. As an alternative, look into Redis Pub/Sub commands: https://redis.io/topics/pubsub &gt; Rails send to node, then node respond, after some validation node should give info to Rails again, but it won't respond 2nd time. Using HTTP, you could return a status code that indicates the request is processing, or redirect to the next path, and the client would long-poll waiting for the processing to finish. &gt; In my project Rails and Node are equivalent. I just want to exchange data between their - not to create infrastucture for pub/sub app. One quote I heard is that software architecture is "drawing arrows between objects, and making sure the arrows all go in the same direction". If you have A relying on B, and B relying on A, then neither can work on it's own and that should be a red flag for you in designing your system. If you introduce Redis or another service bus, you create an infrastructure dependency all going in the same direction, and then create a publisher/subscriber dependency each way between the 2 systems. Sorry if this is vague, without knowing more about your project it's hard to give you a concrete example. I hope this helps!
1) HTTP connections can be long lived so I'm not quite sure what you mean by 'send lot of data' (using chunking protocols it can be an infinitely long stream as long as the connection doesn't timeout). Only issue I see with this connection is that it's one way. 2) (disclaimer NOT familiar with Faye) Base on searching, Faye looks to be generally client side JS so I agree with your analysis but could be a library worth exploring. 3) This would work if you need a two way connection (which it kinda sounds like you want since it's server &lt;-&gt; server). As for configuration of ActionCable for supporting websocket communication I would checkout https://github.com/rails/rails/blob/master/actioncable/README.md. But in the past the only really annoying thing I've run into is setting action_cable.allowed_request_origins. Also if rails is behind a proxy it can be a huge headache to get websocket traffic to proxy correctly. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rails/rails/.../**README.md** (master → 5ecbeda)](https://github.com/rails/rails/blob/5ecbeda0e225e4961977b5c516088cf12d92319f/actioncable/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dupxas3.)
It's a totally valid opinion, agree to disagree.
This is a bit tricky to get at first. each is a method or function and everything from the do to the end, the block, is an argument you are passing into that function. Everything in Ruby returns something and the RETURN value of each, which is what you see in irb, is whatever each is called on, your x array in this case. If you want to see the result of your block then you have to assign the values to a new array inside the block or use a different function like map. Internally map creates a new array and files it with the return value of the block. 
Make this change in OPs code and you’ll see this isn’t OPs problem. 
looking forward to viewing this when i have time!
ahhh I have many memories of creating an empty array and then shoveling into it within an each block instead of using map lol
Do you understand javascript callbacks? Basically what's happening here. For each element in the Enumerable object, `.each(&amp;block)` calls the given block with each element individually. The most confusing thing here for beginners is the syntactic sugar of representing the block with the implicit do/end block. It may be clearer to read this as: `[1,2].each {|a| puts a}` where you can see the block `{|a| puts a}` as a single entity being passed into the each function.
While I agree a += 1 wont actually SOLVE the program's issue, it's another way of providing insight that the correct data isn't being modified.
Wow thanks everyone! Im not looking to modify the array just trying to understand what was given to me as a problem. But knowing .map is useful. Away from my computer right now but hope to tinker later, hopefully tonight. I understand now that .each does not modify. I guess I was expecting the code block to do the modification but it doesn’t, but again I plan to tinker later! Thanks everyone!
There's nothing preventing you from modifying whatever object you're enumerating (.each works with Hashes and other objects). You can even use each_with_index to pass an index along with the value. In general though, you'd want to look into the actual enumerable methods that can accomplish these behaviors more directly (e.g map, select, reduce, inject and so on)
http://weblog.rubyonrails.org/2015/12/18/Rails-5-0-beta1/ &gt; In development, Action Cable runs in-process with the rest of your app. To do this, we’ve switched the default development server from Webrick to Puma. And when you load up such a dev environment you see some tell tale signs that its not single threaded anymore: [7336] Puma starting in cluster mode... [7336] * Version 3.4.0 (ruby 2.2.2-p95), codename: Owl Bowl Brawl [7336] * Min threads: 5, max threads: 5 [7336] * Environment: development [7336] * Process workers: 2 [7336] * Preloading application [7336] * Listening on tcp://localhost:3000 [7336] Use Ctrl-C to stop [7336] - Worker 0 (pid: 7350) booted, phase: 0 [7336] - Worker 1 (pid: 7360) booted, phase: 0 
I think that depends on the context. Linux package managers like apt offer a much better approach to deploying software to production environments. On a development machine, though, chruby/ruby-install or rbenv are incredibly useful.
`Array#map` does not mutate, it returns a *new* array with the result of invoking the block with each element. The original array is unmodified. The elements within it may be mutated by the block, although that isn't possible in this case because integers are immutable. 
`.each` is for when you want to create side effects. In your code, however, you don't create any. You have the expression, `a + 1`, which Ruby evaluates, but then does nothing with. An example side effect is printing something to output. For example, `puts a+1` instead of `a+1`. That's a common use of `.each`.
&gt; it returns a new array 100%
Modifying is generally bad. Think instead about transforming your data. Like a pipeline.
Not sure about rbenv, but I always found [writing scripts and cron jobs under RVM](https://rvm.io/integration/cron) to bit a slight nuisance. For teams that have dedicated system admins or DevOps, using familiar package managers like `apt`, `yum`, etc... can be better for them as they're using it (or have experience using it) for most everything already. 
While I appreciate how light weight your solution is, for anything beyond the scope of a one-off script I prefer to separate validations from object instantiation/persistence completely. That being said stricter typing is definitely appealing. If you're into that sort of thing and haven't yet checked out [the dry-types gem](http://dry-rb.org/gems/dry-types/) you should give it a look. I find the ability to easily roll your own [custom types](http://dry-rb.org/gems/dry-types/custom-types/) pretty nifty. 
I learned ruby through the lens of Rails, which left me with a lot of bad habits that I had to unlearn. If I had a fresh start I would focus much more on object oriented principles. Concepts like single responsibility, open/closed, and inversion of control aren't really common in most rails focused books or at least the ones I was reading. It probably wouldn't be as much fun as creating a twitter clone or whatever the intro rails stuff is today. But grasping those concepts is key to being able to solve more complex problems. As a bonus, conceptual knowledge is portable and will stick with you moving beyond ruby. 
Thanks!
This gem basically adds type enforcement to ActiveModel validations. However Rails 5.2 adds the attributes API to ActiveModel, which for me achieves similar outcome by different and more general means (attribute casting rather than type checking) 
just got on my computer. so, we enumerated with `.each`, I guess I'm just wondering why the block of code after it did not modify. ah, I have a lot of comments to go through. its so simple it appears, I know, but my expectation is of no use here and I have to be sure I understand.
"Everything in Ruby returns something and the RETURN value of each, which is what you see in irb, is whatever each is called on, your x array in this case." ah, major key to remember. thank you.
thank you! not familiar with or recalling JS callback, but many mentions of `.map` here if I wanted to change it. note: i'm not actually trying to change it, just trying to understand an example that was given to me.
`=&gt; [1, 2, 3, 4, 5]` `irb(main):008:0&gt; x.each {|a| puts a + 1}` `2 3 4 5 6` `=&gt; [1, 2, 3, 4, 5]` now I think i understand better. `.each` does not manipulate or change any of the object here, the array x. the `puts` i did was a "side effect", but then I see the =&gt; return value is still the same original array value for `x`. making more sense. ugh, gotta think like Ruby, not how it appears at first i guess!
I am Curious why you are using single threaded Dev servers. Puma is basically a brain-dead drop in replacement for webrick and will solve this problem.
Yes, I have. Let me give you an example... look at sentiment detection. The only library listed is a German language sentiment gem. Note that today, I do all my ai/ml in ruby. But, I had to write a lot of stuff that would have come off the shelf in python. And he quality of my results are slightly worse than the off he shelf in python. Not saying it can’t be done. But, it’s harder, slower, and as a net more expensive.
&gt; While I appreciate how light weight your solution is... Can anything that depends on ActiveModel and ActiveSupport really be considered lightweight? 
Oh no I meant the wrapper not its dependencies. I could do without all that "utility".
I hear what you're saying, but can I ask: Have you contributed any of your code back to the community to try to make the situation better for others who use Ruby? The reason Python has better "off the shelf" support isn't because Python has magical shelves, it's because people like you who were in the Python community suffered just like you are suffering, but then they decided to try to write software to put on those shelves so that others could have nice "off the shelf" solutions. If you were to help and put your effort towards improving the Ruby situation just think of the good that you'd be doing for others. Over time this would help Ruby to become a more vibrant community where more/better "off the shelf" Ruby solutions exist for everyone. 
It's been six days! Did you mean "a couple days" in dog years? I'm only kidding, but seriously.. y'all got any more of that functional ruby?
thanks for your answer... but... what if you're applying for first time and they go like "how much experience do you have with Ruby in a working context?". What you gonna say (or did you say)? "Well, zero" ? And thanks for mentioning Dash and Velocity, didn't know about them!
Better use `#map` for this example.
While I get what you're trying to say, it is put slightly confusing. It sounds like you're saying map replaces the original array (i.e. replaces it), but instead it modifies a copy of it (i.e. returns a new array and leaves the old one unmodified).
Ah, that is indeed more correct. Since he was talking about the return value in IRB I glossed over the difference between map and "map!" thoughtlessly. Thanks for clarifying!
Thanks for adding some meat to the "downsides of OO" discussion! &gt; I believe its possible to have real technical issues with this way of modeling things. The argument is simple. Coupling behavior (functions) to data is unnecessary and so leads to incidental complexity. I always found the concept of Abstract Data Types very compelling because it allows to reason about and define semantic of a part of the overall logic of an application. The point of ADT is that it restricts the valid state and the number of state transitions that can occur on that state. OO very conveniently lends itself to implementing this via encapsulation. Simple example: a typical class for a linked list that contains the chain of list elements as well as an integer for current list size. By only allowing manipulation of encapsulated state consistency can be guaranteed much easier than if every user of that list would have to make sure list size and the actual list contents are consistent. So you either have to drop the redundant information of size and accept that performance of `size(list)` has changed from O(1) to O(n) or you face higher risk of inconsistency because everybody can manipulate list content and the size independently. The story with increased or reduced complexity through OO is not that simple as your sentence makes it appear. On the local level complexity and errors can be reduced. At the same time OO introduces at least one additional way of structuring of programming artifacts. Where procedural code just has procedures or functions that invoke other procedures and functions in OO you also get composition of objects and - depending on programming language - also inheritance of behavior and state. Inheritance has its own set of issues and is sometimes overused. But composition of state via objects is a very powerful concept which also nicely represents real world phenomena. &gt; If PL advocates want to justify the OOP part of there language, they're doing a poor job, because most advice on how to write better OOP programs is to minimize this coupling and so working against what the model *affords*. I would also argue that composition and coupling are orthogonal concepts: composition does not necessarily introduce high coupling and you can have high coupling of procedures and functions as well. The level of coupling actually indicates how well modularized an application is. If programming artifacts can only be used with few or even one other artifact because they rely on knowledge about specific behavior or structure of that other artifact then those designing or programming that system have done a bad job modularizing it. Regarding the "champions" who have turned away from OO I think there are, again, several aspects: the increasing amount of memory available to applications, the similarly increasing number of CPU cores that can work in parallel and the availability of sophisticated GC have encouraged a trend to immutable state which is one of the cornerstones of many functional languages. But immutability and OO are not mutually exclusive. An object oriented language where all objects are immutable is possible as much as a functional language with that property. (Note that some variables with changing state are usually needed to have a reference to an application's state and to do I/O.) And, these heroes of the programming community make a living on books, presentations and lessons. That would not work if they would keep repeating themselves so they naturally look for improvements and new (business) opportunities. In the end, we all have to think for ourselves and make our decisions - that is what professional software engineers are paid for and why, I hope, hobby programmers have chosen their hobby. And yes: of course Ruby is wonderful! Matz did a great job at designing and implementing the language. And even if the best parts of this language would not come from OO, that would not say anything about the value of OO. :-) Thanks for hanging on and reading through that large text.
Hey all. I managed to gather and describe some projects and project ideas I personally want to see done, but have no time to do myself. I am willing to mentor Ruby novices/juniors with a good attitude if some of them will find those projects interesting. Ready to answer any questions here on the effort in total or about particular projects/ideas.
Yup, I said “zero experience with Ruby in the commercial setting. However I have experience with another language in the commercial setting where I had zero experience to begin with, and I improved so much under that setting that I was mentoring incoming interns and junior programmers after a year in so I believe I can do something similar with Ruby.” And they’ll see how your ’attributes’ (I.e. attitude to learn and work with others, which is a big plus) can crossover. Of course, give your own example to prove you have the mentioned attributes if you can. No worries about the Dash and Velocity mention! They’re great to look up built-in methods whilst offline. For solutions, the website Stackoverflow helps a lot.
This looks like a perfect application for Crystal
`FROM ruby:2.5.0` Why would you install Ruby manually (with a package manager) in a Dockerfile?
Yes, I have contributed code back, where appropriate. Most of the time, this is patches to existing gems, versus a new gem to do some core AI/ML thing. Why not? An "advantage" of having to roll your own, is that you can optimize your code to the specific situation. So, much of it is not appropriate to release as a gem. if it were, I would. So, the net of my comment (which I was downvoted for), was simply to evaluate whether for the OP, and their career, the best course is to learn Ruby. A lot of Ruby's ecosystem tricks have been picked up by other languages, and Ruby really hasn't picked up (maybe yet) the tricks of other languages, specifically in the very much emerging field of AI/ML. Maybe with v3 we will start to get there.. and I certainly hope so. But, as I said before, having now spent 10 years writing Ruby, IF I were going to learn a language now, I'd learn Python. 
https://www.ruby-lang.org/en/news/2018/02/24/ruby-2-6-0-preview1-released/ and it's the end of February. Told ya ;)
Fair enough.... In my defence, I *did* have good reason to believe otherwise :)
This is great news. How big of a performance improvement could it be approximately? Given the full implementation of course. 
Magnitude. Not yet not now but 2-3 times can be achieved easily. Just look at the truffle ruby.
3.0 in 2023? 😜
Here's a more thorough explanation of the new JIT compiler. https://medium.com/square-corner-blog/rubys-new-jit-91a5c864dd10 I'm optimizing a bunch of old Ruby at the moment. I'm very interested in seeing how a simple version bump will speed up load times even more. It's nice to see that Ruby is not stalling as it matures. It's directly addressing the common complaints that you hear from developers. I was also surprised and happy to hear that this new JIT compiler is being benchmarked in an NES emulator written in pure Ruby! https://github.com/mame/optcarrot
&gt; Unlike ordinary JIT compilers for other languages, Ruby’s JIT compiler does JIT compilation in a unique way, which prints C code to a disk and spawns common C compiler process to generate native code. Is that optimal? Sounds a bit inefficient
This is likely done just once, so the small initial performance hit is probably worth the subsequent runtime gains.
Ruby only - or rails as well? I myself have a variety of projects I'd like to build but I have this issue of not thinking small
I totally get it ;) I had some insight this time as I speak with Ruby core members from time to time
It's JIT, so isn't it happening constantly? So it's like printing and piping through a C compiler?
FYI: I collect articles about all things 3x3 at Planet Ruby (incl. the new jit (mjit), of course), see &lt;https://planetruby.github.io/calendar/ruby3x3&gt;. Cheers.
I admit that JS and Python seem to have been advancing faster than Ruby over the past 5 or 10 years, but part of the reason for that is because Ruby was already pretty good 5 to 10 years ago. And a lot of major tech companies threw a lot of money at JS and Python. But even still, I'd much rather write something in the more expressive Ruby than in Python, and I'm pretty sure Ruby2.5 is faster than Python, and when the JIT arrives the distance between Ruby and Python will be even greater. As far as your comment about "rolling your own" vs "off the shelf", I hear what you're saying but keep in mind, that a lot of times shortcuts that you take when rolling your own are really just poor design decisions, if you spend more time designing something so that it is generic and usable for various situations rather than just tailored to your immediate situation the software may turn out to be more robust and useful in the long run, and in turn if you make that code available to others in the community they will find it more useful too. The reason why the Python "off the shelf" solutions work so well is because the developers thought about design up front, and not just about a single immediate purpose, then they released the code so that others could take advantage of it and improve it, rather than just throwing it away when they were done. 
&gt; The big idea is 'messaging'. Honestly, i have never understood Alans idea of messaging. Alan and Rich (creator of clojure) had a healthy discussion on pl design a while back and i'm afraid to say i didn't follow there arguments. For what i recall, Rich seemed unable to get Alan to agree on a set of common terms from which to discuss things and so the conversation fell off. Alan's world seems very far from richs. * https://news.ycombinator.com/item?id=11945722 But if i can trust this explanation then i think there actually easily compatible. In fact nothing about clojure prevents this notification model. * https://softwareengineering.stackexchange.com/questions/264697/alan-kay-the-big-idea-is-messaging Once the object gets "the message" however, its somewhat vague what your supposed to do. I assume take some action, update some state, fire some side effects. I'm currently modeling my system as a FSM in clojure and triggering side effects as edges are crossed. So you could say, i'm sending a msg to the state and its being notified via an event bus that something has happened. So maybe i'm doing alan keys OO in Clojure. I wouldn't always do things this way, it think its good for modeling your system at a high level. &gt; are referring to multimethods? yes &gt; There are many ways of doing this one example being the command object pattern I would argue many of these "patterns" exist because of oversights in language design. Nothing is universally true though. &gt; Now back to the expression problem. Most modern languages borrow concepts from both programming paradigms (Ruby has procs and lambdas) so I don't really see this as that big of an issue. How big of a problem you view it is, somewhat subjective. Personally, after i understood the the problem i see it everywhere. The loss of flexibility makes design choices brittle and stressful because you have to choose one form of evolution over another. If you haven't yet, read the post i linked to as i think understanding it has made me a better programmer regardless of the pl. Your right that Ruby is far better off then say ... Java, though. &gt; While I'm not entirely sure what you mean by it being hard to "scale up" a codebase in FP so feel free to clarify in a follow up. The parent comment claimed OO was easier to scale up then FP, which given how vague those notions are, seems somewhat of a lackluster comment. I asked him to clarify. 
I do not think Ruby being slow/non-performant is actually a common complaint from developers. That's one of those things non-ruby-developers complain about it, and this is a solution to quiet them. I think Ruby devs such as myself would like to see a lot more innovation in language features, real static typing, more consistent standard library api, better concurrency, etc. I recommend watching Batsov's [Ruby 4.0 and beyond](https://www.youtube.com/watch?v=7TAjLWX_eEs). I didn't watch this particular youtube video, but I've seen the presentation live at a Ruby conference. That being said, I'm very excited about this, and I'm very happy to get such a great performance boost. I just wanted to point out that there is so much more to look forward to that are core language related features :)
&gt; By only allowing manipulation of encapsulated state consistency can be guaranteed much easier than if every user of that list would have to make sure list size and the actual list contents are consistent. So you either have to drop the redundant information of size and accept that performance of size(list) has changed from O(1) to O(n) or you face higher risk of inconsistency because everybody can manipulate list content and the size independently. There is another option, a collection is a fairly universal abstraction. It's well within the pl design capabilities to define a size function that can operate efficiently on all default collection types that provides. In most OOP languages the pl designers have coupled polymorphism to types. This isn't necessary, or at least its not always done this way. Once you lift that coupling one must really consider how their "person" class with a name and age is any different than a hashmap. = &gt; The point of ADT is that it restricts the valid state and the number of state transitions that can occur on that state. OO very conveniently lends itself to implementing this via encapsulation. I think having a number of valid states and state transitions is a great idea. That's not the issue, again issue is that most of the types I see in applications created in ruby, java, python are really just collections (set, vectors, hashmaps) with functions coupled to them that don't need to be. These functions aren't re-usable. In fact, you end up unable to re-use your programs across the program and projects because abstractions are tightly coupled to these userland type. Which you suggest is bad design. &gt; If programming artifacts can only be used with few or even one other artifact because they rely on knowledge about specific behavior or structure of that other artifact then those designing or programming that system have done a bad job modularizing it. But what else can a user do? They need dynamic dispatch, so they need classes. I have tried and failed to simply have my classes simply inherit from the collection types in ruby. I can't recall why that doesn't work out atm. Also, Most OO models i have seen don't really help you manage system-wide state, which is why we have so much leakage across these pl users defined types. FP doesn't solve that issue for you either, but it at least doesn't lock you into managing these redundant types. &gt; Regarding the "champions" who have turned away from OO I think there are, again, several aspects: the increasing amount of memory available to applications, the similarly increasing number of CPU cores that can work in parallel and the availability of sophisticated GC have encouraged a trend to immutable state which is one of the cornerstones of many functional languages. But immutability and OO are not mutually exclusive. An object oriented language where all objects are immutable is possible as much as a functional language with that property. (Note that some variables with changing state are usually needed to have a reference to an application's state and to do I/O.) Agree with all of this &gt; And, these heroes of the programming community make a living on books, presentations and lessons. That would not work if they would keep repeating themselves so they naturally look for improvements and new (business) opportunities. In the end, we all have to think for ourselves and make our decisions - that is what professional software engineers are paid for and why, I hope, hobby programmers have chosen their hobby. Truth! &gt; And yes: of course Ruby is wonderful! Matz did a great job at designing and implementing the language. And even if the best parts of this language would not come from OO, that would not say anything about the value of OO. :-) Yea. Ruby is probably still one of the most welcoming languages out there. No other language is so willing to just give someone what they wanted. Even if i think what they wanted was sometimes a bad idea lol. Thanks for hanging on and reading through that large text. &gt; same to you
Ive read his previous article a few weeks ago (https://blog.sourcerer.io/building-a-website-with-c-db942c801aee ) and had a good laugh. Same with this one.
&gt; We’re going to implement method inlining in JIT compiler, which is expected to increase Ruby’s performance significantly. Even more improvements to the speed, this is pretty awesome.
I've seen real-world web services written as a FreeBSD kernel module for performance. 
Ruby's future seems so bright.
&gt; That's one of those things non-ruby-developers complain about it Regrettably, that's enough to sway management towards hiring non-ruby developers, and has to me been a bigger hindrance to Ruby than any actual Ruby problem.
I tend to want to validate user input, not objects.
As a counter point, my number one complaint about Ruby is performance both in terms of concurrency and single threaded throughput. Performance is the primary reason I can't use Ruby for more applications. I have no interest in static typing at all and frankly have no clue how that could even (sanely) work in Ruby outside static analysis. 
Same. 
create a pdf out of an html file? with css?
With CSS yes, from markdown not html. But markdown to html is pretty simple. I guess it depends on your use case.
Dang. As someone who has loved the last few years of learning Ruby... That was sad to watch :(
You could just look at what other Ruby web frameworks are using, and that is [Tilt](https://github.com/rtomayko/tilt).
Not enough information for beginners! What if novice also doesn't know what is Ruby and what's name of Ruby's creator? What if they can't edit files on their OS, shouldn't we teach them that? And, maybe, just maybe, a few tips on how to use their keyboard could also be helpful. On a more serious note, I just wonder what's the mental model of the reader you had while writing this. Exactly in which situations it could be helpful exactly how?..
Intro to IO Steams
Thank you @zverok_kha for your very helpful suggestions. I will try to improve my upcoming articles. I will expect more suggestions so that I can improve my writing skills. 
why is perfect for crystal and not for ruby?
There aren't unit tests. These are integration tests.
Explicit self is a conscious language design decision. See [this](http://neopythonic.blogspot.co.uk/2008/10/why-explicit-self-has-to-stay.html?m=1) for example, from Guido.
been curious about doing this for a little bit and these both (gimli and pdfkit) look great. Will be looking into these, thanks for the recommendations!
I didn't spot any new docs specifically for it, but if https://github.com/rails/rails/blob/5-2-stable/activemodel/test/cases/attributes_test.rb is anything to go by it's practically the same as the ActiveRecord attributes API. I've been subclassing `ActiveModel::Type::Value` for serialization &amp; casting and although I haven't tried it yet, I'll starting with the expectation of using those type classes unmodified.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rails/rails/.../**attributes_test.rb** (5-2-stable → 3abd3ea)](https://github.com/rails/rails/blob/3abd3eaacae5200d13893f96026948644a68530d/activemodel/test/cases/attributes_test.rb) ---- 
Someone else found a likely commit: https://github.com/rails/rails/commit/c3675f50d2e59b7fc173d7b332860c4b1a24a726 I played around with the ActiveModel::Type stuff in my experiment with AR attributes serialized to a json hash, supporting nested models. May be able to simplify the implementation for that nested stuff, hmm. https://github.com/jrochkind/json_attribute
I recently came up with the strategy of serializing an entire component model as a jsonb column using a custom type class. https://gist.github.com/inopinatus/f1c3a06b319adf80ed4f9aeee65db220 for the experimental code. Not battle proven. Might be useful for aggregate-style models. 
yep, I've been doing the same stuff! Check out my gem there if you want, still just something i'm playing with, but it seems to be working well, feedback or collaboration welcome. i added in some querying support for generating the SQL for postgres `@&gt;` operator. 
As a semi-beginner in Ruby, what are gems? I hear them mentioned a lot but when I try to google them I have a hard time understanding what they are
Cloudflare will gzip contents for you on the fly. Free to use too. I’m pretty happy with them so far. 
This is true, and has actually been a part of further things I’ve investigated along this path. Cloudflare make requests for gzipped content from your origin server, which was one of the reasons I wanted to serve smaller gzipped files. They also support brotli compression on the fly, but won’t ever ask the origin for that. CDNs, gzip and brotli are a twisty tale of wanting the best, but some things being out of your control. I will be writing more about that in the future.
Ruby J O K LANGUAGE
Basically, it is a way of packaging some library you want to use. Imagine you've found some library, for example for work with images, and want to use it with your code. **Without gems**: * you download its source code; * unpack the code and place it somewhere near your code (and try not to make a mess with folders and filenames); * now you can use the library; * if author have updated the library, you repeat the process (and try not to make a mess with old library files and new library files). **With gems**: * there is central repositories of libraries, named rubygems.org (NB: that's not the only possible source of gems, but let's not complicate things here); * making some library available for your code is as simple as running in console the command `gem install &lt;library name&gt;`: it downloads library from rubygems.org, unpacks it and places in some place that your ruby knows, so in your code you can now just `require "&lt;library name&gt;"`, without thinking where in filesystem the code actually is; * updating the library, when there is new version available, is as easy as `gem install &lt;library name&gt;` again; * if you want to make **your** code available for other Rubyists, it is pretty easy to pack it and publish on rubygems.org, too.
why not trying in c for even better performance, or rust, build your own FS... 
Thanks! Not completely sure what are you referring to but will look into it.
Well, it was on the news: https://www.ruby-lang.org/en/news/2017/12/25/ruby-2-5-0-released/ ... But probably not the thing people'd love to write blog posts about (in fact, I believe I've seen neither of "Performance improvements" section news covered elsewhere).
Oh awesome, thanks. That sounds really convenient. Is it unique to Ruby?
"rubygems" is Ruby's package manager, but concept of package manager is pretty standard for programming languages nowadays. JS has `yarn` and `npm`, PHP has `Composer`, Python has `pip` and [so on](https://en.wikipedia.org/wiki/List_of_software_package_management_systems#Application-level_Dependency_managers)
Ah ok, thank you very much for all the info :)
Same, it’s good to use because it has the fixed init.
when using wicked_pdf, you need to add the stylesheet references in your template's HTML/ERB file. e.g: &lt;head&gt; &lt;%= wicked_pdf_stylesheet_link_tag "application" -%&gt; &lt;%= wicked_pdf_stylesheet_link_tag "your_css_filename_here" -%&gt; &lt;/head&gt; 
This is brilliant! I was wondering how to use the graphql gem without Rails. 
1) my app isn't a Rails one 2) I'm using inline CSS 
Awesome! This was a great introduction to the graphql-ruby gem.
 H RUBY M O R
First of all thanks for taking some to read my ideas, process them and try to help me =).. And now I will try to explain a little more what I was trying to accomplish with this post... **Why I am writing this?** I have notice that some people, including some direct friends and people in my team, have a problem trying to identify what to test... And this problem arise mostly when they are trying to identify "the units"... The thing is that they have no problem in conceptualize how to write "feature tests" or "sytem tests"... and with this terms I am referring as the kind of tests where you test the behavior of the complete web application, through the browser... The problem is that as you said, this turns very complicated when the feature is a little more complex or have more edge cases that you want to cover with test examples... And also then the test suite ends been very slow and brittle =( **So then what I am proposing here?** Well, here I am trying to say... 1 - That is not very hard to visualize an "intermediate representation" that you can test without the database, the web server, the browser, and no Rails at all... and that what you need to visualize is not very different from those "feature tests" that do include the database, web server, and all that stuff... 2 - That if they break this entire feature a little and write at least this two functions, `CRM.new_company_form` and `CRM.create_company`... they will be able to test a little more inputs/outputs... 3 - In an implicit way I am propoising them to write this to functions as two "module functions" instead of two objects (maybe `NewCompanyForm` and `CreateCompany`) because I think is a good way to protect them from changes in the API (more less like a Facade)... and also I prefer to let the implementation to them becuase this people I am trying to help, do know how to write code, the are just struggling to find how to write tests in a more granular way. 4 - I am also propossing here that is possible to test this two functions in the same file, because they are part of the same feature... and I think that this will also help them to visualize what to test. **Some considerations...** Maybe this example is very simple and thats why is possible to break them in just these two functions... Is just that at least in my expirience, in a "real application", you will have some cases that are much more complex... but also you will have some cases where this is all that you need. Actually this code is a simple case from a real app with different names, that I changed just because I think that is a more common example... but this is the "real test code"... require_relative "../developers_spec" module Developers RSpec.describe "Create developer" do def new_developer_form Developers.new_developer_form end def create_developer(params, store) Developers.create_developer(params, store) end attr_reader :store, :params, :logo before do @store = DummyStore @params = { "name" =&gt; "D1", "logo" =&gt; @logo = Object.new } end it "has a form" do form = new_developer_form expect(form.name).to eq nil expect(form.logo).to eq nil end describe "creates a record adding the slug" do example do expect(store).to receive(:create).with(name: "D1", logo: logo, slug: "d1") create_developer(params, store) end example do name = "uno Dos trEs" slug = "uno-dos-tres" expect(store).to receive(:create).with(name: name, logo: logo, slug: slug) create_developer(params.merge("name" =&gt; name), store) end end it "returns success" do status = create_developer(params, store) expect(status).to be_success end describe "without name" do it "does not returns success" do status = create_developer({}, store) expect(status).not_to be_success end it "does not creates the record" do expect(store).not_to receive(:create) create_developer({}, store) end it "returns a blank error" do status = create_developer({}, store) expect(status.form.errors[:name]).to eq ["no puede estar en blanco"] end end end end And this is the implementation... module Developers def self.new_developer_form DeveloperForm.new end def self.create_developer(params, store) ProcessForm.(DeveloperForm, params) do |form| store.create(form.to_h.merge(slug: form.name.parameterize)) end end ProcessForm = -&gt;(form_class, params, &amp;block) do if form = form_class.new(params) and form.valid? block.(form) SuccessStatus else ErrorStatus.new(form) end end class DeveloperForm &lt; Form ATTRS = [:name, :logo] attr_accessor(*ATTRS) validates_presence_of :name end class SuccessStatus def self.success? true end end class ErrorStatus attr_reader :form def initialize(form) @form = form end def success? false end end end The implementation is not very important here... but is implemented this way because we are using the `SuccessStatus`, `ErrorStatus` and `ProcessForm` in other functions inside this module... **Is this a unit?** Well... as you said (maybe in a sarcastic way) we can consider the entire app as a unit, here I am proposing that they can take as a unit each of this two functions, and just consider the storage as a boundary... Maybe some people will prefer to write unit test for each internal part/class/function like the `SuccessStatus` and `ErrorStatus` clases or the `ProcessForm` function... but I consider that at least for this people that I am trying to help, is not that helpful... and also I don't think that is necesary in this example, but well that is just my opinion =) **Will this post help them?** Well, I don't know... but I can try =) **Does this method works?** Well... at least in my team, it is working =) (at least for now jeje)... we have more than 1600 tests running running in less than 6 seconds =)... And it have been relatively easy for us to refactor when is needed. **Is this the only way to be happy with you code?** Nop =) 
Isn't this an old feature? How is it experimental? 
yeah it's old feature, but surprisingly not many Ruby dudes know about it , Re Experimental: I should fraze it differently, what I've meant: it's slow-er
I’m about to add markdown to my app. Why would I choose Kramdown over the alternatives? 
Ah yes, I meant that `.map!` will mutate the state. My next sentence clarified it though: &gt; Another thing to note for .map, is that it will return the modified array. If you want to change the original array, use .map! which changes the array it is passed.
How is this different than including the modules? Does it simply allow you to use differing methods defined with the same name?
Hey, this is awesome! I will definitely be looking to contribute. Great work
Wow. Just started writing more functional style, there's a lot of cool tools for Ruby to add to collection
Crystal is rubylike but compiles. The idea is to get most of the benefits of faster development of Ruby but better performance.
Sounds like an awesome effort, I've written a couple scrappers to grab data (used by a nonprofit for diapers) but I was writing a general one as well. How niche can we get with our scripts?
I wonder if it’s still advisable to use rbenv vs chruby?
Use ERB? 
Perhaps you need xvfb?
 brew update &amp;&amp; brew upgrade ruby-build #=&gt; zsh: command not found: brew
As niche as you like. I have no problem hosting scripts, and if you want to make them no-public (available with link only) that’s your call too.
http://lmgtfy.com/?q=ruby+erb
once you include a module to an object class its there to stay. With this approach you can bind method, do some logic with the state and you are back to original object, then you bind other method and do some other logic. So yes you can use different methods with the same name, but that is just one benefit :) 
Tip: When sharing code like this, *always* copy+paste (or share a link to) TEXT, not an image. It makes things much, much easier for anyone trying to help you. 
Fix your $PATH. 
Wild guess: pdfkit is using the wkhtmltopdf binary which is not built properly on your system. Is wkhtmltopdf working as intended without pdfkit (on the CLI)? On a sidenote: do you really need html-&gt;pdf? I had a really good experience with prawn for pure ruby pdf creation.
kramdown is an all ruby-library with no dependencies and c-extensions (and fast and easy-to-install). For "real-world" writing you will likely need some markdown extensions e.g. footnotes, tables, definition lists, fenced code blocks, and much more - all incl. "out-of-the-box" in kramdown. Happy writing in text. Cheers.
Thanks for your kind words. Contributions to the awesome functional page more than welcome. Cheers.
The page is just a start - can you tell us more about the cool tools (for functional style programming) that you have in mind?
Do you believe that an approach with only one job that checks an specific user flag and include that user in the job is better?
Performance-wise, it might be better. But I would recommend against it. I have been troubleshooting batchjobs before, where one record is broken/invalid/incorrect and this causes the code to fail, which in turn means the entire job won't finish. And sometimes, it has had nasty side-effects. For instance, consider a job that runs daily and updates user profiles and sends an e-mail to each user with updates and recommendations. Now consider that you have 1000 users and your job fails at user 700. Then sidekiq will retry the job for some times. And every time, the first 700 users get an e-mail.
I have never done this before, but my thoughts are: 1. I think you are right about that. 2. You could perhaps have one job (sidekiq or just plain cron) whose responsibility is just going through the users and queing up one job for each user. 3. In any kind of queue system, it's going to be potentially hard to ensure exactly twice a day, or at what time of day. It depends on how many workers you have and how quickly they can process the queue. You'll have to keep an eye on it to make sure you are ready to scale up the workers if neccessary to have enough workers to process the jobs quickly enough for your specs. 
&gt; This library changes the behavior or String#!, Exception#! and Exception::! to the exact opposite of their default implementations! So, I'd say NO!!!! What... I expected it to define raise!, raise!! etc methods but it seems while raise! is allowed as "normal" method name, raise!! is not. https://www.dropbox.com/s/uve9in1v54ob7js/Screenshot%202018-02-27%2015.41.18.png?dl=0 ;)
I just did some of those lessons at Codecademy, a few in that section are very buggy. Such as never taking my input or when I clicked Run, it would just spin forever and SCT would be printed to the terminal. I just kept clicking till it gave me the option to Get Code and let it fill in. Report the bug to Codecademy and learn what you can as you go onto the next lesson. It stops getting buggy after that. 
The second example uses a test double, the first does not. There is no reason you couldn't use a test double in the second case, and not actually save to db, and have equivalent test speed. no?
Thanks for the reply and the article update. Some good food for thought there.
You're so close. With this chunk: sword = -2 magic = -3 computer_offense = [:sword, :magic].sample if computer_offense == sword user_hp -= 2 puts "Your HP remaining: #{user_hp}" elsif computer_offense == magic user_hp -= 3 puts "your HP remaining: #{user_hp} " end `:sword` is not equal to `-2`, right? One is a symbol, the other is an integer. maybe... `['sword', 'magic'].sample`, and compare the string to `== 'sword'`? :)
thx for pointing this out, it's good to have feedback like this so I can expand on it ;) 
I appreciate the help! I changed the code up with some of your input; however, when I run the code after the user inputs its method of attack for the second time it just keeps on looping on the computer attack. So the user can't attack a third time... Any hints as to what I can do to have the program loop back around to the user input portion? Thanks!!! https://repl.it/repls/DampScrawnyCron
Couple of things going on. First) computer_offence = [:sword, :magic].sample the colons in front of the actions makes each word a symbol. So your computer_offence oject is getting a symbol assigned to its value. Then you are checking if computer_offence == sword but this checks if a :symbol == Integer since you have designated the sword object to be sword = -2 if you look at offense you are checking if offense == "sword" which compares a string (user input) to a string. You could change to computer_offence = ["sword", "magic"].sample or change your if statement to if computer_offence == :sword try messing with .class to see what class types you are using. 123.class =&gt; Integer "string".class =&gt; String :symbol.class =&gt; Symbol [1,2,3].class =&gt; Array Second) Your while loops are operating independent of each other and also rendering your previous if/elsif statements somewhat redundant. There is practice called DRY (don't repeat yourself) So lets try some of that next. You can change group the player turn and the computer turn into functions and then call those functions till one of them is dead. Then use a while loop to call the functions till someone dies. $comp_hp = 6 $user_hp = 6 $sword = 2 $magic = 3 def player_turn puts "player's turn, choose your weapon!" offense = gets.chop if offense == "sword" $comp_hp -= $sword puts "Opponent's HP remaining: #{$comp_hp}" elsif offense == "magic" $comp_hp -= $magic puts "Opponent's HP remaining: #{$comp_hp} " end end def computer_turn computer_offense = ["sword" ,"magic"].sample puts "Oponent uses #{computer_offense}" if computer_offense == "sword" $user_hp -= $sword puts "Your HP remaining: #{$user_hp}" elsif computer_offense == "magic" $user_hp -= $magic puts "your HP remaining: #{$user_hp} " end end while true player_turn if $comp_hp &lt;=0 puts "You Won!" break end computer_turn if $user_hp &lt;= 0 puts "you lost! :(" break end end I am using global variables ( $sword ) with a $ so they can be accessed from inside the functions (def) but this is considered bad practice in larger applications. You might consider refactoring this so the functions take an input (current health) and return the updated health so you could get away from global variables. def take_turn(current_health) # do something here return current_health - damage_taken end I replaced the 2 and 3 from the damage parts with variables $sword and $magic so that you can change those values later without having to replace every instance of that damage. This makes it easier to do things like increasing damage done when changin lvl. Though you might want to break it into user_sword_dmg and comp_sword_dmg ect. Anyways, back to work I guess. 
&gt; What... I expected it to define raise!, raise!! etc methods but it seems while raise! is allowed as "normal" method name, raise!! Yes, that's where the fun comes in. 
&gt; What... I expected it to define raise!, raise!! etc methods but it seems while raise! is allowed as "normal" method name, raise!! is not Yes, that's where the fun comes in. 
Wow, if I was not a broke college student I'd give you gold. I appreciate this in-depth analysis of my code and how to better it. At first, I wanted to make everything into functions, but I was not too sure how to do that. Thank you so much! Quick question, if you create functions do you not have to call on them to make them work? I am not sure if that makes sense.
Also what happens if your health is 2 and you take magic damage? you are asking until hp == 0 but what if you skip 0 and go straight to -1?
I see, how come when defining a function you can put something in parenthesis. For example: def social_media(reddit). Whereas in some instances you dont need to put anything inside?
This does horrific things to performance, and likely worse things once a JIT is in place. 
ruby will handle a lot of implied notation so the parenthesis are not always required. def foo input puts input end I can assign and call the function with or without them foo("potato") =&gt; "potato" foo "bar" =&gt; "bar" the =&gt; is used to denote an output. it works with multiple inputs as well. def sum x, y, z return x + y + z end sum(3, 4, 5) =&gt; 12 sum 5, 6, 7 =&gt; 18 Personally, I prefer the parenthesis because of how you can string things together. To reference the .class method from before. sum(1, 2, 3).class =&gt; Fixnum because the sum function will return an integer (in this case 6) and then the .class method will operate on the output of sum. Its exactly how we can use things like .each and .map on arrays. Those are class methods that were calling. However, sum 1, 2, 3.class will result in an error which is why I prefer using parenthesis in most cases. 
Oh no, not more `perform` methods on classes that aren't chain part of the command or chain of responsibility patterns. &gt; Table::Load.perform(file) IMHO this should be `Table.load(file)` as *load* is the verb that's relevant to the domain; *perform* is an unnecessary by product of this design. When one uses `call`, Ruby syntax sugar does a good job of showing us how superfluous these methods are: Table::Load.call(file) Can be written as Table::Load.(file) Which really is Table::Load(file) # Same as Tale.Load(file) And, using common Ruby conventions: Table.load(file) 
Very nicely done! 
One of the dependencies, `faraday` doesn’t seem to have loaded correctly. You may need to manually install it. You can see that’s the problem by looking at the first few lines of your stack trace and see that there is a Load Error up there. Try checking the documentation for the gem and looking for any dependencies or prerequisites that must be run prior to hooking up the gem. 
I would recommend using a single integer to store the total value in cents and then you can just use the lovely money gem https://github.com/RubyMoney/money
First, are you using floats, like just writing `120.67` in your ruby code? If so, don't, and that could be the cause of your issues. Use BigDecimal. [Google "don't use floats for currency"](https://www.google.com/search?q=don%27t+use+floats+for+currency)
what I'm doing is taking the input fixnum and breaking it into pieces that i save into variables. so something like cents = ((self % 1).round(2) * 100).to_i so the cents are saved as an integer. This worked great for me up until a few minutes ago, when I got up to testing for 29.29, my cents is rounded to 28.
if you're using a system that lets you put these jobs in their own queue and look at it's size, I might want to have the (eg) hourly scheduled worker make sure the queue is empty every time it runs, or warn you if it's not. That would be one way to make sure the queue isn't being filled faster than the workers can process it, which would be disastrous. 
Hmmm I see....this assignment was to do this on the fixnum class though...I'll have to ask my prof about this. Thank you very much for your help.
Yes, very good call!
The whole of the assignment is to be able to modify the fixnum class so that you could write any number less than 1 million and it would write it out in english like a check book. (10.0).to_check_string would come out as Ten dollars and Zero Cents. In my program this I concatenated 2 strings. the whole dollars and the cents. Ill have to play around with maybe converting my cents into this BigDecimal thing...
I should have put this in the description, but I've tried that. I looked up 'faraday' at rubygems.org and found that its dependency is 'multipart-post.' I installed that. So then I went to see that one in rubygems.org and there weren't any dependency issues 
maybe your teacher just messed up. 
Can you try running "gem install hashie" or add "hashie" to your Gemfile? Then run "gem list" to make sure it is installed. It should be hashie (3.5.7) The gem reddit-base includes the following gem 'faraday_middleware-reddit' as a dependency. The current released faraday_middleware-reddit gem is missing the dependency hashie. See if this helps. 
Multiply by 100 and then round to get the value in cents so that you're not dealing with the floating point issues.
Looks like the reddit-base (or one of its dependencies) is configuring faraday to use the Mashify middleware, which has a dependency on the hashie gem. Try adding to your Gemfile: gem 'hashie'
Hi and thanks for sharing. You measure the time diff using Time.now, which isn't monotonic. That means it suffer from CPU time "adjustments", with the risk of returning wrong measurements. Since 2.4, Ruby introduced monotonic clock: Process.clock_gettime(Process::CLOCK_MONOTONIC), which guarantees accurate results. Enjoy!
Maybe this library will help? https://github.com/ruby/zlib
Don't. It will happen over time with practice. Trying to force at the beginning and you risk to write non maintanable code.
If you are using rvm, then all the gem should be installed under /Users/&lt;username&gt;/.rvm/gems/ruby-&lt;version&gt;. What happens when you type "echo $GEM_HOME" &lt;- this is where all your gem live and it should be under the ./rvm folder and separate from the system ruby. Also run "gem environment" to make sure there are no conflicts. 
I agree, about the speed of the tests OP is comparing apples to oranges, in the fat model test he accesses the DB but in other he uses a double, it's also possible to mock the employees call in the fat model.
I would use a verifying double, not just a double to verify that the mocked method exists in the class, and also try to write the test in a more concise way: RSpec.describe CompanySizeStandard do subject { CompanySizeStandard.new(company) } context 'when a company has less than 500 employees' do let(:company) { instance_double(Company, employee_count: 500) } it { is_expected.to be_small } end context 'when a company has more than 500 employees' do let(:company) { instance_double(Company, employee_count: 501) } it { is_expected.not_to be_small } end end
For me, `Table::Load.(file)` is somehow looks like an "imitation syntax", like "Well, I meant it to look just like a method, but that's maximum of what I can achieve with current syntax". Then, it raises the questions (the same fact that you praised: "it indicates that `Load` is a namespace"): **what** does it mean that it is also a namespace? Maybe it is because of some global state gimmicks, like Table::Load.settings = {separator: ';'} Table::Load.(...) # =&gt; works one way Table::Load.settings = {separator: "\t"} Table::Load.(...) # =&gt; works another way ...or maybe this namespace has other useful methods? Then, how `.()` is superior to them, why does it looks like "call the whole namespace to work"?.. The one reason `Table::Load.(file)` could be preferred I can think of, is, if it underneath does `Table::Load.new(file).call` (command object pattern), and there are WHOLE LOT of them, and `&lt;SomeCommand&gt;.call()` shorthand is defined by some `BaseCommand`, and `Table::Load` defines only `#call`, or even `Table::Load#privat_implement_call`, with `BaseCommand` providing the boilerplate. Even in this situation `Table.load` syntax can be achieved with some metaprogramming (`inherited` or something), but this maybe "too much meta" for some.
Reading through the conversation, I’m curious about the class and the teacher?.. is this high school, college, or a boot camp-like school? I’m asking because I run a non-profit in Loudoun County, VA where I work with a high school teacher to teach programming. The official curriculum is in Java (due to the AP exam) but I teach concepts in Ruby and have several students that have learned it in-depth. I’d be interested in knowing more about your curriculum 
How are you running the Ruby file? When you're working with Gemfiles, you usually have to run your code with `bundle exec`. For example, if you are running your code with `ruby mycode.rb` you should instead use `bundle exec ruby mycode.rb`.
How are you running the Ruby file? When you're working with Gemfiles, you usually have to run your code with `bundle exec`. For example, if you are running your code with `ruby mycode.rb` you should instead use `bundle exec ruby mycode.rb`.
When you're dealing with fractions or values with decimals, there are a lot of cases where don't need to be _absolutely_ accurate with your results. From scientific calculations (e.g. calculate how long it takes for light from the sun to hit earth) to the maths done by your graphics card, there is usually a margin of acceptable error in these calculations. As mentioned, there are also historical reasons - in older hardware/software floating point was better in some cases: they can require less memory, you can combine very large numbers and very small numbers in your calculations, etc. For people in scientific computing, many of them still hold true today. But for your typical programmer nowadays, you can get by just using fixed-point numbers like `BigDecimal` as the overhead can be negligible.
This is basically the plot of Superman III.
The namespace signifies something important, though. The peers of `Table::Load` might be `Table::Store` and, say, `Table::Foo`, which, as namespaces, can accumulate their own inner namespaces later on, too. Namespacing forms a structural map of the software. It's one of the most crucial aspects of making source code navigable and understandable. The fact that `Table::Load` is a namespace matters _more_ than the fact that there may be global attributes by virtue of the fact that modules can have global attributes. When I see `Table::Load` I know that there's a concept called "Load" within the concept of "Table," and that "Load" has its own implementation that stands on its own.
If you're dealing with _measurements_ of the real world, like calculations about scientific observations, then exact accuracy isn't really important, because no measurements are "exact" in the first place. Also I think back in the day when RAM was much more expensive and scarcer, the efficiency of floats for being able to represent many digits in little memory was more significant. 
After several years, with several attempts with different apps (from large and established enterprise one to rapidly growing quick startup prototype), I believe that solid model will at least include: * business operations/actions/commands, as `Some::Operation.new(params).call`, and probably some other closely related objects (validation schemas or form objects), so that all _modifying_ controller methods would look just like `Users::Create.new(current_user, **params).call` or something like that, and all model-level validations would be only for data sanity, UI-level validations should be in those operations; * Lot of decorators and view models (and maybe some form objects) for logic-less views: * decorator is "all formatting-related methods needed for some particular model (in some context)"; * view model is "all formatting-related methods needed for some bunch of data (in some context)" * form objects is more or less "list of input fields, their formatting, validations and names, needed for some particular business action"; * separate query objects are introduced only when queries become really fancy, otherwise, view models can serve this role, too; * `app/services/` is kinda last resort for POROs that do... "something generally important" (and probably not very related to data or view per se, but not too generic for moving to `lib/`). Something like that.
This isn't upvoted enough, the whole problem is right here. All this floating point arithmetic talk, while the best kind of right, is extraneous.
+1, absolutely. Some really cool videos that are worth paying for from this guy, https://www.destroyallsoftware.com/screencasts/catalog/collapsing-services-into-values My rule of thumb is to imagine code as human beings. If you could give a single person a job, like, "process this credit card from this customer" how would you model that class? You can call them operations, you can call them services, it's really up to you. I tend to consider a service as a singleton, where it exists and does lots of work. Whereas I consider an operation to be a single purpose thing, where it is created and dies when it is done doing what it needs to do. There are no hard and fast rules but I dig what zverok_kha has said and do recommend checking out the destroy all software videos. 
Oh I haven't checked out DAS in a while but I movie marathoned it when I was still starting out with Rails. Didn't understand it that much but I think I'll watch some episodes again... Sorry I didn't understand "I tend to consider a service as a singleton, where it exists and does lots of work. Whereas I consider an operation to be a single purpose thing, where it is created and dies when it is done doing what it needs to do.", can you give an example?
What if... `Table::Load` would need a dependency in the future? 
Thank-you. That got rid of the dependency error. It's still not working for me now but it says "the server responded with status 404" so maybe Reddit changed something and so the gem doesn't work But anyway.. I thought that adding gems to a Gemfile then running `bundle install` takes care of the dependencies. Is that not the case? 
You probably want `size` instead of `count` in that implementation. `size` will return the length of the in-memory array if the association is loaded, or issue a db query if it is not, `count` will always issue a DB query. With `size`, you both get correct results prior to additions to the association being saved and in tests you can more easily either mock the association or `build` the association records in place of `create` them, saving the DB inserts. 
The interactors gem has some pluses. At my job, we use it with a decently large codebase, and it keeps things from getting too hairy. But I find it a little loose and primitive, and mapping your understanding of the app to the file hierarchy is virtually impossible. It’s just a grab-bag you have to search.
&gt; Some::Operation.new(params).call Why `.new(params)` instead of `.call(params)`? The last one would imply a stateless object which has many benefits. Moving the params to `.call` would also enable a middleware-like infrastructure: LoggingOperation.new(BenchmarkingOperation.new(Users::Create.new)).call(params) You can make that architecture even more general (and extendable) by separating the handler and the command: https://cuttingedge.it/blogs/steven/pivot/entry.php?id=91
Does it make sense for a form object to be the _same_ object as a decorator/view model, or should they always be separated? If separated... do you end up with a decorator wrapping a form model wrapping a true model?
FYI, `String.new` does *not* do the same thing as `''` or `''.dup`. It will always have binary encoding, which can cause subtle and hard to track down bugs. You should use `+'some string'` if you need a mutable string.
This gem is missing the dependency, so it is a bug on their side, you can report it on their issue tracker if you feel so inclined. I have not encountered this in other gems, so it is probably bad luck.
&gt; Ruby has a reputation for being slow and, while that impression is a decade out of date It’s improved for sure but ruby still is very slow (see common perf metrics across languages).
Congrats, y'all!
When you are comparing real business applications talking to I/O sources, language speed is almost never an issue anymore. Committing a transaction or sending an email is always going to dominate.
If runtime speed is not important to you that’s fine. I’ve seen many ruby apps that work well for their purpose. Then again, not caring about runtime speed is very different than claiming that ruby isn’t slow :)
FYI, `String.new` takes an `encoding` keyword arg since Ruby 2.3 (I think). So, while awkward, you could also do `String.new(encoding: Encoding::UTF_8)`.
Aside from being unwieldily, it's also an order of magnitude slower. Warming up -------------------------------------- String.new(encoding: Encoding::UTF_8) 83.599k i/100ms +'' 317.969k i/100ms Calculating ------------------------------------- String.new(encoding: Encoding::UTF_8) 1.041M (± 3.8%) i/s - 5.267M in 5.069008s +'' 9.592M (± 4.5%) i/s - 48.013M in 5.016592s Comparison: +'': 9592204.3 i/s String.new(encoding: Encoding::UTF_8): 1040684.9 i/s - 9.22x slower
I believe the pick axe book has a section on gems https://pragprog.com/book/ruby4/programming-ruby-1-9-2-0
Well, I was working with large codebase using the syntax I show, and I think of it this way: "Command object" is a method on steroids, e.g. it is useful for splitting method into "check &amp; convert input, do some processing, prepare output". It worked this way (pseudo-code): class SomeOperation &lt; BaseOperation param :user, SomeTypeDef param :job, SomeTypeDef param :comment, SomeTypeDef validate_presence :user validate { job.owner == user } ... # no initialize: it is drawn from params private # "implementation" part of #call def perform SomeOtherModel.create(some_params) end def some_params # All operation params available as local variables/private attr_accessors inside operation { user: user, job: job, company: user.company, comment: "#{comment} for #{user.name}" } end end With call sequence SomeOperation.call(job: job, user: current_user, comment: "That's the comment").call This way `#initialize` is for set and validate params, and `perform` only called when all set and valid. So, it is like embracing OO approach for functional style, which feels pretty natural for Ruby.
In one large and well-established codebase I've worked once, the form object was the same parameter as _operation_, e.g. operation defined "what params it has and what's their expected types", and often even some view for this form (in `app/operations/operation_name/views/modal.slim` or ``app/operations/operation_name/views/inline.slim` and so on). I had mixed feelings about this approach yet should acknowledge it worked and allowed to keep things pretty clean and understandable in a really huge app.
Thank you!
I get it, and it makes sense. But why not use symbols instead?
I gotta admit I don't really even understand what that means or how I'd do it, heh. I keep leaning to want to make the form object and the decorator the same object. I'm curious if anyone has done that. And the straightforward alternative to that I see, if you have both a form object and a separate decorator, is a decorator that wraps a form object that wraps the orginal model. I'm curious if anyone has done _that_. 
For some reason my previous comment does not show up. Did someone downvote me off the page? I am being serious! I'm going to rewrite it here, with /u/zverok_kha's reply and my reply. Does it make sense for a form object to be the same object as a decorator/view model, or should they always be separated? If separated... do you end up with a decorator wrapping a form model wrapping a true model? zverok_kha replies: &gt; In one large and well-established codebase I've worked once, the form object was the same parameter as operation, e.g. operation defined "what params it has and what's their expected types", and often even some view for this form (in app/operations/operation_name/views/modal.slim or `app/operations/operation_name/views/inline.slim and so on). &gt; I had mixed feelings about this approach yet should acknowledge it worked and allowed to keep things pretty clean and understandable in a really huge app. To which I reply again: I gotta admit I don't really even understand what that means or how I'd do it, heh. I keep leaning to want to make the form object and the decorator the same object. I'm curious if anyone has done that. And the straightforward alternative to that I see, if you have both a form object and a separate decorator, is a decorator that wraps a form object that wraps the orginal model. I'm curious if anyone has done that. And wait, why does this sub-thread not show up on the main page anymore? arghhh. did someone downvote me off the page? GAH. This really is something I have been trying to figure out.
Link?
Hmm. It's not always neccesarily one form object per model, but my form objects _are_ things that I pass to the Rails view "in lieu of" the actual model (so the view can access validation errors on it), as well as construct in the controller to handle validation and saving (thus why it goes to the view to access the validation errors). Which is in line with how I've seen "form models" or "form objects" described in Rails-land. (Realize that may not be the only way). So if I'm passing it to at least the edit "form" view (if not neccesarily the ordinary show view) in lieu of the underlying model, and the edit view needs decoration.... either I put decoration in the form model, or I wrap the form model in _another_ decorator. Even if I don't ever pass the form model to the ordinary non-edit "show" view, it is common that I need some of the same decoration in both places, and I don't want to just non-dry copy it to two different presenter-type objects. So... any thoughts /u/zverok_kha? really appreciate the dialog. 
I think though that in that sense Ruby is still slow but in a different way, as it's not set up for asynchronous programming like JavaScript, parallel programming like Rust or both for Clojure. Although this is a different problem that is to do with the language design and how the programmer programs rather than the implementation of that language.
it's supposed to, but the gem is broken. 
OK, thank-you. It was just extra confusing since this is the first gem I've used
In Sidekiqs case it is serializing to redis and back so I assume that is why
Even without `frozen_string_literal`, certain operations involving literals skip the needless allocation, and aref is one of them: `HASH["mike"]` does not allocate. def sink(value); end n = GC.stat(:total_allocated_objects) 500.times { sink("hello") } puts GC.stat(:total_allocated_objects) - n # =&gt; 500 h = { "hello" =&gt; "world" } n = GC.stat(:total_allocated_objects) 500.times { h["hello"] } puts GC.stat(:total_allocated_objects) - n # =&gt; 0 n = GC.stat(:total_allocated_objects) 500.times { h.fetch("hello") } puts GC.stat(:total_allocated_objects) - n # =&gt; 500
You have to define "slow". C++ is "slow" compared to hand-optimized assembly but "fast" compared to ruby or python. Ruby runtime speed might also be "fast" or "slow" compared to *itself* depending on what you are doing with it (e.g., number crunching vs metaprogramming). It's really not very useful to talk about fast or slow without a specific context. And even with a specific context it's really only useful to talk about "fast" or "slow" *enough* given the contextual constraints and the benefits one gets from the language.
&gt; Why is Table.load(file) superior to Table::Load.(file)? Simplicity. `Table::Load.(file)` is needlessly complex way of saying`Table::Load(file)`. It forces a single method call on a class into a namespace with another class/module with a single method name that serves no purpose. Code like this is why people left technologies like J2EE (even though Sun did make some improvements eventually) for Spring and Struts and eventually Rails. &gt; They seem to signify the same thing... Exactly, the concept is the same but the `Table::Load.call` implementation adds unnecessary code. Imagine if the `JSON.load` was `JSON::Load.call` or `JSON::Load.process`, or if `File.read` was `File::Read.process`. You'd have more wrapper methods than a POSIX network call. This is not an acceptable interface. &gt; Namespacing forms a structural map of the software. It's one of the most crucial aspects of making source code navigable and understandable. Good design is more crucial... &gt; The fact that Table::Load is a namespace matters more than the fact that there may be global attributes by virtue of the fact that modules can have global attributes. Simplicity and usability matter most. As the code is written, the namespace has no value. It's artificial. &gt; When I see Table::Load I know that there's a concept called "Load" within the concept of "Table," and that "Load" has its own implementation that stands on its own. `Table.load` doesn't indicate this? 
Example? Otherwise, what if it accepts a URL in the future? What if it needed to accept a character encoding in the in the future? What if in the future our domain had no concept of "table"? Should we design the method as `Table.load(URI, Hash = {})`? 
&gt; Simplicity. Huh? We're literally talking about `.`. Every software system I've seen in the real world would love for a `.` to be the most complex thing in the system. &gt; Table::Load.(file) is needlessly complex way of saying Table::Load(file). It forces a single method call on a class into a namespace with another class/module with a single method name that serves no purpose. It serves the purpose of separating that method from the class, i.e. loading data into a table is separate from the table itself. In my experience, in pretty much every case I've come across, `Table` is something that has more concerns than just "loading," i.e. piling up methods on `Table` will result in low cohesion. &gt; Code like this is why people left technologies like J2EE (even though Sun did make some improvements eventually) for Spring and Struts and eventually Rails. There is nothing about this `.` we're talking about that has anything to do with why people "left" J2EE. That's not really something I feel compelled to consider. &gt; Exactly, the concept is the same but the Table::Load.call implementation adds unnecessary code. What unnecessary code, specifically? &gt; Imagine if the JSON.load was JSON::Load.call or JSON::Load.process, or if File.read was File::Read.process. You'd have more wrapper methods than a POSIX network call. This is not an acceptable interface. Yeah, actually, it would be acceptable. I don't even think you'd end up with more methods than when you started. &gt; Good design is more crucial... That's what we're talking about. This _is_ design. &gt; Simplicity and usability matter most. As the code is written, the namespace has no value. It's artificial. The namespace has value if it provides clearer insight into the structural design. What do you mean by "as the code is written?" What code? &gt; Table.load doesn't indicate this? It doesn't indicate that "loading" is a distinct concept from tables. It's in the part of the namespace where factory methods, for instance, might belong. It might be a method that returns a `Table` instance, for all I know at first glance. Look, you can say you like one more than the other, and I'll be fine with that I guess. But I don't see how yours is categorically superior.
&gt; We're literally talking about . Does that mean we're talking about adding a module and a method called process just so we don't have to call `Table.load`? Either way I give up. &gt; What do you mean by "as the code is written?" What code? The code in [the blog post that gave birth to this conversation](https://medium.com/@victorarias/use-static-facades-when-you-dont-care-about-the-instance-9eee3b72910).
``` HASH = { "mike": 123 } def getmike HASH["mike"] # unnecessary garbage here! end ``` That has not allocated a new String for `"mike"` on each call to `getmike`since Ruby 2.1 (or maybe it was 2.2?). String literals for hash definition / access are automatically frozen by the interpreter. 
I think there is a big open in Ruby to fix this. Not sure what the state of it is. Using + or dup has come up in RuboCop. There is also a performance improvement using +'string' instead of String.new('string').
Oh, yeah, I agree about the code in the blog post. Any time I see `Foo.new(args).method` there's a problem. I was just arguing in favor of the call method on classes or modules, since your comment appeared to discourage their use, as well.
It is still technically an experimental feature which is why it has to be enabled manually for each file. They may add a run flag to the executable. The goal is to have frozen strings be the default in Ruby 3.
``` find directory -name '*.rb' -exec ruby -i -lpe'print "# frozen_string_literal: true" if $. == 1' {} \; ```
You are correct, `size` would be more efficient than `count`
Thanks for the great tip
yeah I agree. That's why I there is a note in place that says: &gt; Note! This is still quite slow feature in Ruby. I personally wouldn’t use it in a production code. But it’s cool that something like this exist I was just demonstrating this to a junior colleague just to show some potential of Ruby 
What are your thoughts on where validation should go? In the controller? In the form object? In the operation? On the one hand, I don't want to deal with HTTP param string coercion inside the operations, because operations should be decoupled from HTTP. On the other hand, HTML forms and operation params are usually a 1-to-1 mapping, so it's easier to combine the two.
Just because you can do something doesn't mean you should. And obviously that has to be continuously run as new files are added.
That would be better.
I guess there's a truth about that statement. But after making a framework that do sanitizing, validating, writing to log, inserting to db and rendering template in nanoseconds, rails erb rendering in milliseconds just feels not the same again.
Nope. Nothing is generated. You created a ruby script that creates a new html-document in a folder. Having an html-template in your editor and rsync the stuff to the server would do the same job. Your "generator" can't even rebuild the site if you decide to change the layout.
I know. I just created it for personal use and I'm planning to make it better and extract it over time as a gem.
Don't listen to that other guy. This is a fun little project and if it makes your life easier/you had a good time making it, then that's great.
I can just tell you how it worked on that large codebase (at Toptal): the form object was part of `BusinessAction`, and it worked like this (pseudocode): `Users::Create.new(company: company).form`. Inside view related to this form, `company` parameter was exposed, being _decorated with default decorator_ for `Company` model. IIRC, there were even DSL to say "when you expose company as a part of form object, decorate it with this, not that". The idea is, in complex and flexible system, typicall each form could deal with several models, or with only part of some object/model, or with concept not represented by particular model... Therefore "define form object and its params" and "decorate models to show them in views (even inside those forms)" are separated concepts.
Thanks. I just wanted something a little more than a static site with links ending with .html extensions &amp; me not having to hyphenate the links for being url friendly &amp; also make the folder and files needed for it by hand. So that's exactly what I did. I use that little site everyday to post a blog &amp; one other guy forked it saying he likes the design and he's gonna use it for himself on github. 
Cool! you should check out https://github.com/socketry/rackula
Bananas are also suitable 
i see your point. it makes me nervous about mocking _at all_, frankly. but i see how it could be worse in one situation than the other. 
Hmm, so the view did not access the form object directly, but instead accessed `company`, provided by the form? Except it was actually a decorated `company`, with the decoration provided by the form? Sorry, I'm having trouble understanding you, just want to make sure I have it right, i am genuinely curious what you have done, cause I'm trying to figure out what to do, and want examples from people who have found it working well! That seems like kind of a violation of 'law of demeter', no? Did this app use Rails model validations, to provide error messages to user? Was it the "form" object responsible for enforcing validations, as I'd expect? How did the view get the validation errors to report, from where? 
&gt; Hmm, so the view did not access the form object directly It has. In view, we have something like (pseudocode), for example -form.fields.each do |field| label= field.name input default=field.default value=field.value.decorated_for_form But also can have, if we need... h2 | Data for = form.company.pretty_name
ah, interesting, I think I get it. The view accesses the form directly for fields (and validation errors), but if wants decorated methods, it accesses `form.company.method` where `form.company` is actually a decorated company. I can think of some pro's and con's of this approach, and also some ideas for possible improvement (which I woudln't have had without seeing the starting point) -- but do you think it worked out okay?
I usually go for a recursive sidekiq job in these situations. In your case, initializing it on the create action and calling RecursiveWorker.perform_in(12.hours) at the end of the method could work. There are a few things you need to watch out for if you decide to take this approach: First, you probably want to rescue all errors and decide whether you want to retry, reschedule, or cancel the job on failure. If you’re calling a 3rd party API you could consider turning off retries (retry: false) and rescheduling in 5 to 10 seconds after rescuing e.g. RecursiveWorker.perform_in(10.seconds). Also, I usually setup a loud way to receive these errors (which will happen). I really like Twilio for this type of error since I tend to ignore emails. In addition, remember to follow the typical guidelines for jobs: don’t pass record params (ids instead), idempotence, atomic transactions, etc. This, together with the advice in the other comments about checking queue sizes is probably a good start.
&gt; but do you think it worked out okay in that case? Yeah, as I've said already in the thread, it was used on a huge codebase and turned out to be really readable and flexible. Maybe not the nicest concern separation every, yet pragmatically awesome.
Hahaha... Thanks man. You guys seem to be doing great work with socketry. I also want to contribute to your codebases.
I'm pretty sure jekyll can be configured to generate friendly URLs.
Probably, but I don't like writing my blog in markdown, I like writing in HTML &amp; also I wanted to write something in ruby from scratch.
Also, after several years of attempts... I have found something that has worked for me and my team =) ... We don't have objects or folders for objects that are explicitly called Services, Operations, Values, Queries, Presenters or any other pattern... Although we actually use them we don't have to use them... Hmmm maybe I am not being very clear =(... What we do is have "modules" (plain ruby modules) with functions as a "facade" to our business logic and we use TDD to determine what we need inside those functions... sometimes is an object that will represent a form, some times a kind of service object that will take data from different records to do something, some times are several chained decorators... it depends... but the main "rule" is that... **A function on a module**... For example we have in an app this functionality for registering "tax entities", because a "client" can have many of this "tax entities"... So we have exposed two functions to use in the controller... class ClientTaxEntitiesController &lt; ApplicationController # ... def new render layout: "modal", locals: { client_id: client_id, form: Clients.add_tax_entity_form } end def create status = Clients.add_tax_entity(client_id, params[:tax_entity], STORE, invoicing_service: InvoicingService) if status.success? render_index layout: false else render :new, status: 422, layout: "modal", locals: { form: status.form, client_id: client_id, invoicing_service_error: status.invoicing_service_error } end end # ... end And inside that "Clients" module, we have something like... module Clients # ... def self.add_tax_entity_form TaxEntities.add_tax_entity_form end def self.add_tax_entity(*args) TaxEntities.add_tax_entity(*args) end # ... end module Clients module TaxEntities # ... def self.add_tax_entity_form TaxEntityForm.new end def self.add_tax_entity(client_id, params, store, invoicing_service:) AddTaxEntity.(client_id, params, store, invoicing_service: invoicing_service) end class AddTaxEntity def self.call(client_id, params, store, invoicing_service:) form = TaxEntityForm.new(params) form.validate!(store) return ErrorStatus.new(form) unless form.errors.empty? response = create_client(invoicing_service, form) return ErrorStatus.new(form, response.error_message) unless response.success? store.create(form.to_h.merge(client_id: client_id, remote_client_id: response.get(:id))) SuccessStatus end def self.create_client(invoicing_service, form) InvoicingServiceResponse.new(invoicing_service.create_client(form.to_h)) end end end end So as you see, we are using a kind of "form object" and a kind of "service object" but that was not because we were following a "pattern" that was because we got in to that solution through TDD =) ... most of all following the pattern that I am trying to describe in this post http://bhserna.com/2018/writing-unit-tests-as-feature-tests.html I hope it helps =)
Nearby NoVa? I do a conference talk and talk for my high school classes called ‘Doubles, Floats, Pizzas, and Pennyshavings’... I’ve never recorded it, but I could... it’s very relevant... I just need to give it again in a conference ornckassroom setting. The short answer here you’ve seen in several responses already... in memory you want to store the value of money as an integer type (of appropriate size) as if you are always dealing with pennies. Onlynconvert it to dollars and cents at display time. 
This would be a fun project to get started with Ruby. I've been thinking about starting to learn it. Thanks for the post.
Thanks for all the feedback, since this is a side project, I will try some approaches and see which one fits best with my needs. Thank you!
13 conferences we can’t miss! When are we supposed to live the rest of our lives? Ridiculous.
Interesting, I wonder if it’s possible to make it work work Google ReCAPTCHA. 
Markdown is (mostly) a superset of HTML. HTML tags are passed through unaffected and you can use Markdown just for the little conveniences like basic paragraphs and strong/em. I have a couple sites that use a mix between the two, which is quite nice. Not criticizing your decision to make a tool, just pointing out that existing tools might have more to offer than you thought.
Anyone have any details as to when registration for RubyConf 2018 will open up (in the USA)?
404s, correct URL is http://smallcity.ca/2018/03/01/bare-bones-rails-action-cable-tutorial.html
Any idea why the first step is "remove coffeescript"? 
You’re welcome and contributions are welcome :)
I believe they're linked at compile time, so it would depend on the version of OpenSSL you had when you installed Ruby. They can't accurately know that. I agree that brown-outs in advance of the final cutoff would always be nicer way to do this.
How can there possibly be 13 conferences I _can't miss_ in 2018? What time does that leave for doing my actual work?
No one gives a shit what error reporting tool you use, there's literally *hundreds* of these stupid things and they're all basically copies of one another with all the same boring features. Wake me up when one of these shitty reporters does something interesting and original, otherwise don't fucking advertise one over the other.
He probably holds the opinion that you should just write JavaScript. I would tend to agree. I could never understand why rails defaulted to a transpiler. Though it could be said that, when in rails, just do it the rails way.
Ruby is a ton of fun. I started with Learn To Program by Chris Pineand then moved on to Beginning Ruby by Peter Cooper. From there you have a bunch of other options (if you want to do web development you can get the Rails book by Sam Ruby, Sandi Metz’s practical Object Oriented Design With Ruby). I use Ruby for a lot of scripting and I even do a lot in windows. Mostly using it to interface with weird ODBC connections to pull reports from separate systems. I prefer to work with Ruby in a VM running something like Ubuntu. Most tutorials assume OSX or Ubuntu. 
Ruby Koans Then build a gem that solves a problem you face.
&gt; I have only worked with Visual studio, so not being able to just start a ruby project is a little offsetting. this is funny, beause i feel the complete opposite. i'm used to sublime/terminal so to evenn set up and understand somethinng like Rubymine challennges my attention span. It's actually a lot simpler without a whole IDE, you just write a text file with an rb extension and run it with ruby from shell. I can understand how you'd miss thinngs like static checking and autocomplete but i would recommend trying atom or sublime, and, as another commenter mentioned, WSL if you're using Windows. 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://rvm.io/) - Previous text "RVM" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
My broad advice, and this is super vague, is to be explicit over implicit. There is sort of a trade off between "convention over configuration" and KISS. One tangible piece of this puzzle is how to deal with lifecycle events. I would be vary cautious about spreading things too thin. In my current application we have concerns calling model callbacks calling background jobs creating more records, more model callbacks, and so on. It's a black hell, and the rails version of "callback hell" so well-known in the Javascript work. So, in terms of avoiding this, I advise making _plain ruby_ classes/modules that aren't tightly coupled to a some particular part of Rails' request lifecycle. It's tempting to try and get clever and set instance variables in the models, call controller actions from other conntroller actions, and other metaprogramming things, but in terms of keeping things comprehendable it's not a good idea. This is kind of genenral-purpose rails advice though, because the thign is, rails is kind of a glutton for "business logic". It's intentionally designed to support large applications, and it feels natural to put all the businness logic inn model/view/controllers. The second piece of advice is to practice functional programming concepts, because it will make you better at working with data. Specifically, focus on Enumerable and avoiding side effects. 
If you look at the form objects as being a kind of view model, then yeah, I think it should act like a decorator. It's part of the view layer, so put as much view logic as you want on it. If you look at form objects as part of the domain layer, maybe being passed around between operations, then it gets a bit sketchy. Personally, I think form objects belong in the view layer. They're supposed to help with building the HTML form, and doing simple validation/coercion on the HTTP params. But I don't think they should be passed into operations — I'd rather that they spit out sanitised params which are _then_ passed into operations. Having said that, there are advantages to combining all of these elements into a single "component" kind of object, like Victor was talking about.
&gt; operations become like self-containing "business components" That's an interesting architecture. Thanks for sharing.
I can 2nd The Odin Project. It's really good stuff. I'm doing a part time bootcamp, they teach ruby in rails. The definitely shortcut the Ruby Language as a whole and have you start building web apps. I have been using Odin on the side as a way to grasp the language outside of Rails so I can have a better understanding of everything. 
"behind the scene" i thought was going to be about implementation details, not just some bland summary that's covered in every textbook.
The reason visual studio doesn't have an option for ruby is because you don't have all the boilerplate and overhead that makes an IDE useful. You don't have to compile. Just code. I prefer VS Code but Atom, Sublime, etc are all fine.
Random fun fact: the in-house framework baking it all was literally called Monolith.
It is? That's exactly what I'm using to deploy a desktop app on a bunch of Windows PCs at work; seems to be perfectly fine.
You can use `var.nil?` on most objects, and `var.empty?` on strings, arrays and hashes
Isn't ruby downloading and compiling a specific version of openssl at build time? I checked with chruby, and from 2.2 to 2.5 all versions are different, and they don't seem to match my system openssl.
The more I live the more disappointed I get with a conference in a whole. My personal experience is that I never learn anything there that worth to pay hundreds bucks for a ticket. I often had that it's also beneficial for establishing new bounds within community but that never clicked for me as well.
You should be able to use the activesupport gem to get a lot of Rails goodness without importing the rest of Rails.
With that in mind maybe 'the safe navigation operator' `&amp;.` can come in handy: http://mitrev.net/ruby/2015/11/13/the-operator-in-ruby/
What you framework did you go for?
Yes please get involved. This language desperately needs people to contribute on the scientific computing libs. So far behind Python it is threatening the language as a whole, imo.
kudos for reaching out. you can depend on us for any language specific questions.
There are two approaches: 1. `var &amp;&amp; var.strip.empty?` or `var.to_s.strip.empty?` [`#empty?`](https://ruby-doc.org/core-2.5.0/String.html#method-i-empty-3F) looks for empty strings, e.g., `#length` of `0`. It returns `false` for `" "` as it's not empty. It contains whitespace characters. The problem with this approach is **it only strips ASCII whitespace**. (Though I feel like this is filed as a bug or feature request somewhere): irb [2.4.0] (tmp)$ "\xc2\xa0" =&gt; " " irb [2.4.0] (tmp)$ "\xc2\xa0".strip.empty? =&gt; false irb [2.4.0] (tmp)$ "\xE2\x80\x89" =&gt; " " irb [2.4.0] (tmp)$ "\xE2\x80\x89".strip =&gt; " " irb [2.4.0] (tmp)$ "\xE2\x80\x89".strip.empty? =&gt; false 2. Use a regular expression irb [2.4.0] (tmp)$ "\xc2\xa0" =~ /\A[[:space:]]*\Z/ =&gt; 0 irb [2.4.0] (tmp)$ "\xE2\x80\x89" =~ /\A[[:space:]]*\Z/ =&gt; 0 Note that due to regex semantics one cannot use `\s`. Also note that `*` is used so that empty strings can match. 
`var.empty?` will not work for strings. See [my comment here](https://www.reddit.com/r/ruby/comments/81cmc6/var1present_for_nonrails_app/dv2ibrt/)
Thanks for your enthusiasm. Happy, that this post helped you !
I would probably get a linux VM going, and use that for my ruby learning. &gt; not being able to just start a ruby project is a little offsetting This implies to me that you aren't familiar with bash. If there are three things I wish I knew going into Uni it would be: git, bash, and how to write tests. All three of these are particularly meaningful when developing ruby on linux (or MacOS).
The `.present?` function isn't part of Rails so to speak, it's part of [ActiveSupport](https://github.com/rails/rails/tree/master/activesupport). Which is a group of utility functions and core extensions separate from the web framework. Depending on the nature of your project, you can just include the ActiveSupport gem. It's not tiny, but I tend to use it as it is worth having the many conveniences and not continuously reimplementing them myself.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [rails/rails/.../**activesupport** (master → b1a9cee)](https://github.com/rails/rails/tree/b1a9cee83082d6c7a58d87d06055c86fcdbc7644/activesupport) ---- 
Sorry for the misunderstanding ! I've created this gist, which shows you the Ruby VM Instructions generated from a ruby case statement: https://gist.github.com/mehdi-farsi/e1f09c7c92591cb48e3e44028744fe96 I'll make a concise post to explain the meaning of each line ASAP.
You can learn all python in two weeks, if you need. To use it easily you need to spend years! All you need is to understand what for you need it, if you want it just for you and you don`t will use it in work, than don`t learn it. If you have a reason, than you should learn it. All that you ask is not a reason. Check this to know what is the main difference to know what you should learn: https://www.cleveroad.com/blog/python-vs-other-programming-languages
Thank you for the reply:)
Read the docs and it will display the source of that method. Open the gem, have a look around. That's how you learn. https://github.com/rails/rails/blob/v5.1.5/activesupport/lib/active_support/core_ext/object/blank.rb
Ironically, it makes EngineYard as a company look _worse_ to developers, when they post this stuff. Presumably the opposite of what they intended with their blog. 
I'd probably just write my own `present?`, cause it is so useful. To avoid monkey-patching everything, it'd have to be a static utility method. (Has anyone else actually done this and put it in a gem?) Something like: class Util def present?(obj) case obj # thanks sshaw_ for the tip... when String; ! (obj.nil? || obj =~ /\A[[:space:]]*\Z/) when Array, Hash; ! obj.empty? else; ! obj.nil? end end Util.present?(whatever) 
If you are planning to deploy to heroku start googling solutions now before it becomes a hellscape 
Ruby/Git, bash are all top priorities for my personal projects. I just built a PC beast of a PC so its time to get very serious! ty. 
yeah, you can. although sublime/atom will do a lot for you, like multiple selection, a large package library, syntax highlighting, automatic indentation, and you can itegrate them with build systems if you want.
Hmm, I'll have to look into Atom. Just took a peek. I'll download as soon as I get home. 
Maybe so, just seemed a bit odd to make that opinion part of an otherwise unrelated tutorial. I thought maybe there was some issue I didn't know about with ActionCable and Coffeescript
Thanks! I was interested in using Sinatra for a GraphQL React app and this will be very helpfull. Does anyone use it for the same purpose?
Well if the code won't be available until v1, can we at least get a patch release that adds something funny to the README? In the meantime, I'll be correcting the syntax errors in my [TrumpScript](https://github.com/samshadwell/TrumpScript) scripts. 
`n` and `self.n` and `@n` are all equivalent in this example. `@n` is the variable in question, and because you defined a method `def n` which returns `@n`, you are now able to call the `n` method to get that same value. When you are inside the class, you can call methods belonging to that class in a way that looks like a local variable. So when you say `n` in your compare method, you are actually calling `self.n` -- Ruby knows that you are calling a method since `n` doesn't mean anything otherwise. 
Yes, `attr_reader` is the same thing as defining that method. As for which to use, it's generally more commonly accepted to use the method version when one exists, unless you really do need the variable directly (because for instance your getter method does funny business.). See this thread for a bit more background: https://forum.upcase.com/t/using-instance-variables-vs-attribute-accessors/1788/5
A few pointers :) attr_reader :n is preferrable over def n @n end Default scope is pretty much always `self`, the exception being assignment `x = :foo`. If you have `attr_accessor :x`, you have to set it with `self.x = :foo`, but you can read it with `x` Try changing your code to for example `if c.n &gt; y` and you'll get an error message saying that your object `c1` does not have a method or variable `y`, clearly indicating that that's where ruby looked. &gt; is the n referring to the function called or the variable called n. You have no variable called `n`, you have one called `@n`. While the @ does have a syntactic function making it an instance variable, it is still very much part of the variable name. You can try this out with `c1.instance_variable_get(:@n)`. I hope this helps clear up a little of the confusion, just keep at it and all this will become familiar eventually. :)
What is the interface it provides? ``` preimage = Preimage.find ... commission = Commission::Calculator.calculator(preimage).new(preimage).calculate ```
Check out our gem [Gourami](https://github.com/Vydia/gourami). “Keep your Routes, Controllers and Models thin with Plain Old Ruby Objects (PORO).” At Vydia we put all our non-routing controller logic in Gourami::Form classes. class TypicalForm &lt; Gourami::Form attribute(:typical_attribute) def validate # Define your validation rules here end def perform # Perform your action rules here end end
When people are talking about code editing with Sublime, VS Code, Atom, vi, etc-- there is nothing bare bones about it. They all have syntax highlighting and plugins to help you on your way. Don't use notepad for this. These are all code editors. Notepad is just... Well, a notepad.
I can't stop giggling at the precision section. Well played. 
I think having a screenshot with a sample of data extracted will be instrumental in picking if you want something or not. Maybe rename it to betterrackdebugger it might show better your attention. 
Thank for your time checking my gem!. Do you mean on New Analysis Group view? And yes, I agree that I should change the name, but I want something that does not make you think that only works on that technology, because the idea is that you can use it to analyze any kind of script, rails, rack app, Sinatra or any kind of non-web script.
This supposed to be a link to a post, sorry for messing it up. http://www.skylup.com/autospec-for-minitest-doom-guy-edition
I'm finishing up a gem that might be just complicated enough. It's narrow in scope, in that it's just for filtering data in a web app. But it's abstract enough to work in any Rack-compatible app—Rails, Sinatra, Roda, etc—with any ORM. Here's the source: https://github.com/chrisfrank/rack-reducer I probably won't publish it to rubygems until Monday, so if you're installing it before then, you'd put this in your Gemfile: gem 'rack-reducer', git: 'https://github.com/chrisfrank/rack-reducer', require: 'rack/reducer'
Cool! I did Chris Pine's book too. It did get quite challenging. I'm also studying with an online coding school. I'm enjoying Ruby, cool stuff.
I recommend this school's exercises and also its prep Materials, they have their own book on Ruby as well as they have you do Chris Pine's book, its free too. I find the videos for the exercises portion to be great too, like check out the video here: https://launchschool.com/exercises/3a3354f4 
Well I have an extra computer, and I was thinking about setting up one just for a fun project, so now maybe this was what I needed to push me over the edge! I might dual boot linux on my actual PC though. 
Yeah, I know those IDE's aren't bare bones. I mean they're IDE's! I was just saying that if I HAD to use notepad it is possible. I can't install things at work, and to get the company to install something is like actually breaking their arms and legs! Thank you for the clarification. 
kind of odd to conflate domain objects (where business logic should reside) with service objects, which are basically transaction scripts with side-effects. this might work for simple crud apps but it seems completely at odds with domain driven development (from which both business logic isolation and service objects arise).
What are your requirements?
[yes](http://www.reactiongifs.com/r/msty.gif), also RubyMine
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://www.reactiongifs.com/r/msty.gif) - Previous text "yes" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Depends on what you want to use mruby for: IoT, CLIs, embedding, whatever. Nowadays almost all posts/talks about mruby in Japanese( One advice: follow Matz on Twitter (https://twitter.com/yukihiro_matz), he regularly posts links to useful mruby resources.
That is interesting...
Thank you
Good question
Watir!
This is terrifying. Things like this in the YAML gem lead to a RCE in Rails in 2013...
No, it isn’t. 
Given that it only does this when calling a different method it’s not nearly as scary. But I had the same thought as you initially.
The argument is getting somewhat muddied. So here is my main observation: Coupling classes to polymorphism isn't necessary and in doing so the language forces users to create custom classes where it would be better to re-use an existing type. Do you disagree? Can you give an example where the coupling is helping? 
Security. 
Not only is this extremely dangerous, but it changes the behaviour globally. So if a dependency requires one of the types then any JSON parse in the app is vulnerable to this injection.
What do you mean by “when calling a different method”? You mean JSON.load instead of JSON.parse? I wouldn’t be surprised if a lot of Ruby users picked load over parse by mistake or to avoid parse exceptions. 
Oh, yeah in my mind `parse` was the default way but I guess maybe others feel that way about `load`. Perhaps if they were familiar with YAML first or something.
Fair point :-)
I haven't read the book, but if it's like other Ruby books, it should age well. Syntax-wise everything should be relatively the same. The examples should hold practicality fine too. I think the only thing that would be out of date would be what applications the examples are applied to. But again, I haven't read the book. Just an observation after reading many Ruby books.
That's good to know, thanks. So you think the syntax for ruby won't have changed significantly over the last 10 years to the point that I wouldn't be able to learn from this book?
Correct — I don't think anything has been removed from the syntax, only added
There may be some standard library changes that will make things easier. Certainly the way that gems and ruby itself are managed is significantly different (and easier) than 10y ago. There is another book titled "Build Awesome Command-Line Applications in Ruby: Control Your Computer, Simplify Your Life" that may also be of interest and covers some of the same stuff IIRC.
Most of the changes have been supplementary (I think that's the word? sorry for my poor English), not much has been removed. The only major syntactical changes that really come to mind between 1.9 and 2.6 been using colons for hashes `{key: value}` over hash-rockets `{:key =&gt; value}` and keyword args `def cool_method(key:, value:)` - of course, that's just what comes to my mind.
I'll probably still try to write 2.0-compatible code unless I have to use methods that had breaking change. How do you deal with breaking changes? I mean, there are dozens of programs and dependencies that I run every day on my machine -- I'm gonna review a lot of code now but how do I know if I missed something? Can I specify in Gemfile that the code is confirmed to work as intended under Ruby from v2.x to v2.y?
Gem authors can require specific ruby versions / ranges of versions in their gemspec. That said breaking changes are pretty rare in Ruby and many of the breaking changes listed here either aren't really breaking changes or were extremely rarely used features. When there is actually a breaking change it is generally depreciated in the previous release and a warning printed when the feature is used.
The very first program I was going to run after my upgrade appeared to have a method that has `return` inside `lambda`. The only reason why it isn't broken is that that lambda is the only thing inside method body.
Just to ask the obvious, possibly stupid question. Do you absolutely need mruby?
Out of curiosity, are you using ruby as a primary development language, or just a little scripting on the side relying on the built-in ruby install? I ask this because ruby 2.3 was released just over 2 years ago, and while it is supported now, it won't be forever. Operating systems always wind up shipping much older than current versions - and necessarily so, but developers working primarily in ruby should really be installing a more recent version (say either the latest, release like 2.5, or the next most recent release 2.4 whenever possible. I'm referencing the official [ruby maintenance policy](https://bugs.ruby-lang.org/projects/ruby/wiki/GeneralMaintenancePolicy) and current state of [branch support](https://www.ruby-lang.org/en/downloads/branches/)
&gt; I'll probably still try to write 2.0-compatible code I'd say 2.1-compatible (that's my usual target as a gem author). One serious change you overlooked in 2.0→2.1 is allowing keyword arguments without default values, which made keyword arguments finally useful and rendered 2.0 virtually "beta" before "proper" 2.1. Another such change was related to refinements... which nobody except me seems to use. The same, though, may be said about `def` returning symbols, and return-from-lambda behavior -- all of it was substantially shaping the language. The next huge change to consider is `&amp;.` in Ruby 2.3 (so, I already allow myself to limit the lowest version to 2.3 for experimental gems). Most of the other changes can be "imitated" by using `backports` or `polyfill` gem, or (in environments where core-exting is strictly prohibited even for backports), with ugly yet usable polyfills like `Util.dig(object, *path)`,
As with [your previous post](https://www.reddit.com/r/ruby/comments/818mdw/ruby_case_statement_behind_the_scene/), the title is misleading. It does NOT explain how regexps are _implemented_, it just tells about the _interface_. Also, it just retells official docs, which is not the optimal topic for the writing, to say the least.
it's just a title. And maybe this post doesn't fit to your expectations. But it's useful for a lot of people who didn't read the impressive collection of "docs" that you've read. "which is not the optimal topic for the writing" This is just your opinion and that only engage you. I think it's the optimal topic. Have a nice day Thanks
&gt; it's useful for a lot of people who didn't read the _impressive collection of "docs"_ that you've read. What are you talking about? Everything from your "useful post" is just retelling of exactly ONE relevant document: http://ruby-doc.org/core-2.5.0/Regexp.html Which is better for the novice to read than a random Medium article, because: * it is authoritative; * it will not get outdated (all versions of Ruby's implementation details are there); * it is cross-linked to other relevant classes and modules; * it just has more information, and it is better structured. I already said elsewhere: as a Ruby mentor dealing a lot with complete novices, I really don't believe this kind of articles (repeating of official documentation, ripped out of context) is useful for novices, and, in fact, I believe in exactly opposite. If you are novice blogger just trying your wings, I suggest to try selecting new (deeper, wider, or another angle) views on topics you want to highlight.
Sorry, but I talk about whatever I want, and if you don't like it, it's your right. You can give your opinion, you can thumb down, you can comment. But that doesn't mean I'll stop to write about topics that I find useful for me and others. If you're not happy about that, just don't click on my links when you see my name. BTW, it's your right to believe this kind of blogposts are not useful. I'm a new on medium. And I enjoy writing what I write. I feel that's useful because that describes the big picture of a general topic that newbies and mid-level devs don't know well. My goal is not to talk about advanced subject as: * Ruby Object Model * how the class hierarchy is initialised in Ruby: https://github.com/ruby/ruby/blob/trunk/class.c#L546 * What are YARV and RACC * The Program Counter * The Execution Context * The CPF * etc.. I just wanna help people with basic knowledges. Thank you again for your comments even if that will not change my mind. Have a nice day
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**class.c#L546** (trunk → 4f12526)](https://github.com/ruby/ruby/blob/4f125262f442ca575415d5ff413c024ba26f6b04/class.c#L546) ---- 
You're using the system ruby then? You might check out RVM/rbenv.
Of course, given the right training. 
Wow. Fantastic. Big fan of one-liners and ruby by example. Thanks for sharing. Will try to turn it into a [Yuki &amp; Moto (Online) Book](http://yukimotopress.github.io/). Keep it up. Cheers. Prost.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [learnbyexample/Command-line-text-processing/.../**README.md** (master → d5f340a)](https://github.com/learnbyexample/Command-line-text-processing/blob/d5f340a7cd4a42989ad2274dbac795bc133f1b3a/README.md) ---- 
Thanks for making it possible and publishing with an open license ( Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License). Keep it up. Cheers. Prost.
You shoudn't change the OS's ruby version. Use rvm or rbenv and create an isolated dev env for the project you are working on. Are you aware that ruby 2.5 is in beta now right? 2.3 is itself old.
I didn't change OS's ruby version -- I've upgraded macOS and it now comes with newer Ruby. I did it because some websites stopped accepting HTTPS requests with that old OpenSSL.
heheheheh
Ah, ok, my misunderstanding.
It's awesome. I love Ruby, and I feel you have opened a whole new world. 
The readme says that Down#download retuns a Tempfile object. So I'm going to take a guess that you want to do something like File.open("filename", "wb") {|file| file.write(Down.download(url).read)} 
The streaming API should be used instead of `write(blah.read)` since the file is already stored on disk, and you're spending time copying it again. The other option is to use move the file from Tempfile#path to the local filename where you want it to live, I think `Down.download url do |tempfile| FileUtils.mv tempfile.path, "filename" end`
Yep, you're right. I stopped reading as soon as I fixed his code, he should definitely be using the streaming API.
`tempfile.path` should be removed, but not the file you've moved your download to. I think the streaming API looks like: `Download.open uri do |stream| File.open filename, "wb" do |file| file.write stream.readpartial end end` 
Sorry, I now understand you meant the Down streaming API. Yes that does work much faster. Thank you
I did File.open (filename, "wb") {file.write(Down.open(url).read)} It works well. Should i change it? Thank you to the both of you for the prompt help.
Suggestion: [update your project's homepage](https://github.com/BurdetteLamar/MarkdownHelper/blob/master/markdown_helper.gemspec#L14) to point to: https://github.com/BurdetteLamar/MarkdownHelper
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [BurdetteLamar/MarkdownHelper/.../**markdown_helper.gemspec#L14** (master → 6f1c702)](https://github.com/BurdetteLamar/MarkdownHelper/blob/6f1c70229966ed53a33533c1c7bc07824d099721/markdown_helper.gemspec#L14) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dv8s9ew.)
Not enough data for a meaningful answer.
I wrote two articles a few years ago: * https://lucaguidi.com/2014/02/26/redis-scripting-with-mruby/ * https://lucaguidi.com/2015/12/09/25000-requests-per-second-for-rack-json-api-with-mruby/
I mean, maybe its not. But im curious bc i've read good things about it but information about it in english (or any language besides japanese) is very thin so i cant tell for sure
&gt; Are the tools available in Python easily ported to Ruby? Sadly not, it would be a very large job. Even if this was done it would be difficult to attract the community from the well established languages (Python, R, etc).
[SciRuby](https://github.com/SciRuby/sciruby) is pretty good. They have [NMatrix](https://github.com/SciRuby/nmatrix) for a numerical linear algebra library, [Daru](https://github.com/SciRuby/daru) which is like Pandas, and [StatSample](https://github.com/SciRuby/statsample) for statistics. All of this works with Jupyter notebooks and comes with a few different visualization gems. 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [janko-m/down/.../**chunked_io.rb#L166-L170** (master → 71fb291)](https://github.com/janko-m/down/blob/71fb2911783fe37c6545c5f7ff8dba7e22d03bd2/lib/down/chunked_io.rb#L166-L170) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dva1sfe.)
and its brother repo, https://github.com/arbox/machine-learning-with-ruby :)
&gt; Operating systems always wind up shipping much older than current versions Not true for Fedora.
Thats a nice feature of zeus that its explicit that it is running and you can always see if something is wrong with the process.
If you hover over the bars it shows the contributor names. k0kubun is the person who committed jit. While his contributions are substantial, he isn't the largest. There was a release, with preview1 usually there's a lot more activity around a preview. 
Don't totally understand in what circumstances one might want to use this instead of [ruby-prof](https://github.com/ruby-prof/ruby-prof). There might very well be some! As they didn't mention ruby-prof though, not totally sure if the OP was aware of it. 
ruby-prof is an amazing tool! Timeasure aims to solve a similar problem, but it supplies an easy way to access the tracked measurements at the end of a transaction in order to report it to some analytical tool. You can hack this with ruby-prof in some way, but it felt to me like this is not what ruby-prof "wants" to do... Also, Timeasure allows for segmented method profiling (although this is probably a more rare usecase)
Yes, it seems to be reading it all into memory still. Let me play with it to see if i can improve it. Thanks
you could combine with modern idioms(for ex: https://franzejr.github.io/best-ruby/index.html) if you get the programming concepts from the book, it would be easy to adapt to the syntax/constructs that have been added since then...
Well, that's an interesting perspective you have, indeed. &gt; Waxing semantics of English words with non-native speakers I am not a native myself. All I intended to suggest is the author consequently selected an unfortunate "title cliche"; the expected consequence was the author just ignoring the suggestion, or taking it in mind next time (for not being downvoted for "content doesn't conform to title"). &gt; using that as an excuse to attack the rest of the post My concerns about post content were absolutely unrelated to the post title and would stay essentially the same if the post would be titled "Ruby regexp basics". And the structure of my comment suggests so: concerns about the content are expressed in a separate paragraph, starting with "Also, ". Also, being non-native, I am not sure which part of my wording can qualify as an "attack".
That's very cool! Kudos /u/philnash 🎉🎉
Well sure, but that's because fedora is intentionally closer to the frequent release spectrum than centos which is the slower/stable release end. For individual libraries, like openssl etc it's entirely feasible to wait for an official OS package to apply security updates. For applications which *you* are the developer, it's not. rvm/rbenv/chruby etc fit well to install up to date rubies and own the lifecycle yourself.
Yes of course. But it's an option to own that lifecycle and I just wish people treat it as such instead of pretending there is only one way of doing it (use RVM!). And especially in OP position for some scripts on your computer why not to match it with Ruby you already have?
Oh hi Phil, how's Melbourne treating you
I agree it's context specific - which was why I asked on my top level post :)
JRuby, Rubinius and TruffleRuby at all parallel implementations of Ruby, which is something that some people appreciate.
Been a long time sing your post, Ryan. Great write-up. I do feel that AR gets complicated in order to handle business logic when application evolves and gets more complex.
Jruby is very commonly used in places where code performance it a bottleneck. Keep in mind, most web apps are not processor bound. There's usually a lot of low fruit to optimize in a an app before thinking you need the baggage of a non-MRI Ruby.
I've used MRuby to build a graphical user interface for [a musical synthesizer](http://zynaddsubfx.sf.net). MRuby is much easier to embed than other versions, so that's why MRuby was used over other implementations.
&gt; Sidekiq handles most issues regarding handling Ruby errors and retry logic. But if a worker crashes or is killed while processing a job, that job is gone. You might want to clarify here that you are talking about the opensource version of Sidekiq, as I think the paid versions handle at least some of these things (or maybe /u/mperham can clarify)
Amazing, thank you!
&gt; While I disagree with hiding essential features (like guaranteed execution) behind a paywall I totally agree with this. &gt; a Pro license offers support and additional business oriented features which you won’t get with a self-hosted RabbitMQ instance. It would be nice if you listed which features we wouldn't get by replacing our Sidekiq Enterprise license with RabbitMQ. Do you know if there is an RabbitMQ wrapper that talks with ActiveJob?
&gt; The most common cases for job disappearance are deploys (since the application is killed at that point) I think it is fair to mention that Sidekiq have done some changes in regard to this lately, the default way is a timeout before the workers are killed. And now there is also the enterprise version that supports rolling restarts: https://github.com/mperham/sidekiq/wiki/Ent-Rolling-Restarts
I think its important to seperate logically the design pattern known as an ["Active Record"](https://en.wikipedia.org/wiki/Active_record_pattern) from the ruby gem that is active_record. The latter probably started with the goal to implement the former for ruby, but then added way too much stuff.
&gt; By default, Redis is a volatile store (all data is lost if the store restarts) You are correct, this is a failure on my part. Redis is not completely volotile. I'll update the post to reflect that. Though, please note that RDB is volotile between snapshots. Here is an outtake of the persistance guite that you liked, and which I also referenced in the talk I linked in the post: &gt; However you'll usually create an RDB snapshot every five minutes or more, so in case of Redis stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.
&gt; It would be nice if you listed which features we wouldn't get by replacing our Sidekiq Enterprise license with RabbitMQ. * Cron jobs * Unique jobs - though this can be added application side &gt; Do you know if there is an RabbitMQ wrapper that talks with ActiveJob? There is :D https://github.com/jondot/sneakers/wiki/How-To:-Rails-Background-Jobs-with-ActiveJob It uses a worker class that's[ implemented directly in ActiveJob](https://github.com/rails/rails/blob/master/activejob/lib/active_job/queue_adapters/sneakers_adapter.rb). But this adapter lacks a `perform_at` implementation, which Sneakers has through handler libraries. I'll add that to the post also.
I sometimes wonder if the ActiveRecord ruby gem has accumulated so much complexity that it's actually gained the ability to think for itself.
You are right, it's fair to mention that. I'll add it to the paywall part.
Shouldn't this be obvious? Background jobs are a relatively new invention designed to offer frontend-only architectures (i.e. self contained web apps) the capability of executing code outside of request/response cycles. That said, I wouldn't use Rabbit. Stream-based message transports are a lot lighter weight.
Shhhhh! It might hear you. 
Hey! Just wanted to let you know that your comments have been implemented into the post. Thank you for sharing your feedback.
Awesome, it is a well-written article, and I really enjoyed it, you have spent tremendous effort with the animations. I have never thought about using a message queue as a task queue, but I would have liked to see a bit more information on the difference between the two, or maybe just some clarifications on why it doesn't matter.
&gt; I would have liked to see a bit more information on the difference between the two The biggest difference I have seen is message uniqueness, I think I covered everything else in the post. I prefer working with RabbitMQ because of all the extra features it gives, which I utilize for communication between services (the thing it's intended to do). The fact that it can be utilized as a job queue is just a plus in my opinion.
Thank you, that makes sense! Would suggest adding it to blog post to explain motivation! 
It could be interesting *nudge nudge* to compare job lifecycles between different job systems, maybe compare task queues like Sidekiq and [Beanstalkd](https://github.com/kr/beanstalkd/blob/c17f5030177f689b37ddd6cd2237c96491f6c399/doc/protocol.txt#L73-L102) (which is really well-documented) with message queues like RabbitMQ with Sneakers.
I’m surprised code like that is still so slow. If you wrote the same function in C and fed it to gcc with optimization enabled it would replace the entire loop with a constant. I assume the underlying code being jitted has some barriers preventing this optimization. Does mri insert context switch checks in while loops?
I wasn't aware of this magic, but it is amazing. x.rbenv( '2.0.0::2.0.0-p0', '2.5.0', '2.6.0-preview1', '2.6.0-preview1+JIT::2.6.0-preview1,--jit', 'trunk::after', 'trunk+JIT::after,--jit', )
That is a good question, I guess they have been pretty conservative with the optimisations.
The JIT will get much faster as they do method in lining and further optimizations. With their current release schedule it’s odd to get a major release preview this early in the year. But the ramifications are massive.
Correct, but it's also pretty trivial to run redis with a read replica you can immediately flip to (seconds of downtime) or with sentinel (milliseconds of downtime but more complicated) 
Good point, I will update the post :) Thank you. Regarding the effect measurement itself has on the runtime of code, I might get into that in the next part of the series (this story became long enough alread, I'm afraid!). ruby-prof is heavy duty, it measures **a lot** of things, but on the other hand it is a C extension. Timeasure is focused on specific methods and measure only runtime (of declared methods). I ran some manual benchmarking to get an idea of your latter question, how does Timeasure and RubyProf affect the runtime of processes in which they are involved. I am not sure my demo-case is highly demonstrative of real-life situations (it is actually a pretty funny way to achieve that kind of output), but have a look at the results... https://gist.github.com/eliav-lavi/bb081bd005aa3db46be53df0c4b81f6c I think this shows that Timeasure does not slow runtime, yet not so true for RubyProf... this might echo with my feeling that RubyProf is more bound for development environment. I also got this feeling from the fact that the output of RubyProf is all meant to be printed on the console, there is no "results hash" you can hold in your hand easily and clearly at the end of the process... you can hack it, but it feels like that's not what it was intended to do. At work, I really wanted to monitor real-time production situations, so Timeasure helped me do that easily :) Let me know what you think about that little experiment!
FYI: I collect [ruby 3x3 articles &amp; posts](https://planetruby.github.io/calendar/ruby3x3) at Planet Ruby. Cheers. Prost.
yep, ruby-prof definitely effects the total runtime. Hopefully not the _proportion_ of time taken by different things, which is what you are measuring. Oh, you are using this in production? Yeah, I definitely think ruby-prof is not suitable for production use. Another thing you could mention in why you needed this instead of ruby-prof. 
True. As described in the article, you could also enable AOF to keep a transactional log (and suffer some performance fluctuations), then you wouldn't suffer data loss. (The persistence guide even mentions that RDB and AOF will be merged into one feature in the future) My point is that you can achieve equivalent functionality with a single instance of RabbitMQ. Though note that Rabbit can also be clustered in a similar fashion, to achieve similar benefits.
It's very likely these poor results are caused by a couple reasons: - hanami uses old rom-rb 3.0, in this version fetching a single entity was slower than in case of AR, we made it equally-fast-maybe-faster-in-some-cases in rom-rb 4.x. If they checked fetching more data (which is more representable anyway), results would be better - hanami entities are relatively heavy, using entities to return json in rom-rb world is an anti-pattern. If they used plain hashes without entities, results would be much better, too Also, a general advice, do not trust benchmarks unless you have a really good understanding about tools that are benchmarked. It's incredibly hard to write correct and meaningful benchmarks, and it's also hard to come up with any serious conclusions when looking at results. Something can be super fast in a benchmark, but then you try it out and in your specific use case and it turns out to be dead slow...or the other way around :)
Even if that benchmark may not reflect real-world performance, the take-away is that the **trunk version has been made 2x faster than Ruby 2.6.0-preview1** (at least for this kind of benchmark). Looking through the [commits of k0kubun](https://github.com/ruby/ruby/commits?author=k0kubun) is also very interesting, with most of them having benchmark stats in the commit message.
I've used JRuby in production, but not for a web app. I think I would be comfortable doing so if I needed to. I use JRuby when I need true parallelism. 
Right - this code should optimise to.... absolutely nothing. Anything else and there's something missing from your JIT. &gt; Does mri insert context switch checks in while loops? It shouldn't in a loop this simple - why would you need to check for a context switch in this loop? It finishes so fast that nobody would be able to tell the difference.
TBH, over the time I measured the performance of Hanami on my computer. The result of that benchmark is surprising to me. It's the first time that I see Hanami slower than Rails. Given the numbers are so bad, it could be that we did a huge mistake with some feature that dragged the perf down. Or the benchmark had a wrong setup (no assets manifest, code reloading on, non production mode). Anyway, if you're interested, try it yourself. 👍
Does anyone know if JIT works fine with code that heavily uses meta-programming?
You are totally right, I should have mentioned the production-bound nature of Timeasure in the story. I actually state that quite boldly in the demo-app I brought up: https://timeasure-demo.herokuapp.com. In fact collecting runtime measurements from production was and still is really helpful in specific contexts of our operations as a business. We are able to understand where the bottlenecks are in specifics conditional branches of specific transactions and sharp things up to ensure smoother and quicker responses. It's just really easy, you throw Timeasure in and the next thing you know you have nice graphs in NewRelic which you can query and filter with ease... I will add this to the write-up :)
I wish I could replicate this. Running the Argon2 test suite with Ruby 2.6 takes me 45 seconds, where as if I set RUBYOPT="--jit" it takes around 240.
I'll add something to his comments: even on the free version, jobs are (almost never) not lost on deploys. You can see this on the FAQ: &gt; By default, Sidekiq gives workers 8 seconds to shut down. This is carefully chosen because Heroku gives a process 10 seconds to shutdown before killing it. After 8 seconds, any remaining jobs still in progress are pushed back onto Redis so they can be immediately restarted when Sidekiq starts back up. I confirm this behavior, using the free version of sidekiq and having apps deployed on heroku.
I’ve also never had any issues woth Heroku, but this happened a lot when I was running my apps on AWS or on other hosting providers (it’s most noticable with docker containers). It happened so often that I was motivated to search for solutions to the problem. And food some for thought. What if Heroku changes it’s timeout? Will you update all your 100+ apps?
I believe there is a school of thought where "service object" is in fact name for Command object pattern. In others, what author calls "service object", is command object or action or operation, and what author calls PORO (free-form object outside any particular convention) is called "service object". 
I mean, the author says it in the article: the original object was poorly designed. They try to make a concession as if this is a trivial thing that has limited relevance to their point, but it's actually a big issue. Plus, like others said, service objects are PORO objects - this is more about the command vs service object approach.
Well, I somehow doubt they are gonna break compatibility with Rails which uses quite a bit of "magic".
Take that site with a pinch of salt. It also says Erlang's Cowboy webserver is slow, when it's anything but. The problem with it is that the test is not fair. Each server is configured differently. Some have logging, some do not, some are compiled in an optimised release mode, some are not, etc.
I have used both, but consider my self more versed in sidekiq and a rabbit novice. That being said, the Sidekiq UI is way more intuitive. I run an app that runs a few long running jobs, and being able to see what running and what in the queue is a great debugger. I tried to find similar info in my app that runs Rabbit and could not find it. It might be there and I will state that i am a rabbit novice, but the sidekiq ui is straight forward and easy to use.
*6x faster for a while loop. This is a microbenchmark, not real code. Don't get too excited.
dude, you've been milking ignorant rubyists who don't know any better for YEARS now. You need to stop over-selling your shit. There are *much* better and *far* cheaper alternatives to your stuff out there. It's just your incessant marketing and self-promotion that keeps you going. But soon people will know the emperor has no clothes. And you know it too.
I'm often critical of the service object fad, but come on now. The title of this article brazenly declares them to be an antipattern and then defends its position from the standpoint of the author's personal preferences. In Rails, you're usually not doing OO, you're doing a mix of declarative and procedural programming that's optimized for rapid application development. Nothing wrong with that in the context where it belongs. Trying to augment it with POROs/service objects to make your code more "object oriented" always goes south IME (and it's probably what went wrong with your client's code that you took over). By extension, trying to determine what practices are helpful patterns or anti patterns within a Rails project is a fool's errand, in my experience. Doing OOP within a Rails app is like trying to get sober at a bar. Models have every behavior under the sun, and most of the other APIs are designed to couple to models. Oh, and you can't initialize controllers. Your best experience with Rails will be the one where you let it do it's thing out-of-the-box, and you go write your core logic elsewhere (lib, for instance, or in separate components packaged as gems). Okay, that veered off topic. Sorry about that. Cheers!
Some of these criticisms (at least, comparing to Rails) aren't exactly telling the full story: &gt; The Active Record pattern encourages you to throw everything into the model. Think: callbacks, validations, persistence, database logic (queries) and business logic. Very few developers I know put business logic in models. The ActiveRecord pattern (it is a design pattern, after all) doesn't reference or lend ideas to this at all. I think it's otherwise fine to put your validations as close to your persistence layer as possible. I'm yet to see a better solution (obviously besides doing it within your database, which we should all be doing already.) Why would I want to copy-pasta (or otherwise include) a bunch of validations for user-provided data? Maybe on a service layer that's separate from my model layer, yeah, sure. &gt; A Rails controller is typically made messier by the addition of "helper" methods like this. It's not uncommon to have Rails controllers of multiple hundreds of lines, due to the complexity of the actions and these helper methods. Separating out each action into its own class indeed makes them easier to work with. Sure, you can do it that way. Or you can chunk everything up, just like Hanami, and use `require_dependency` to include it. &gt; Actions in Hanami also use parameter validation (with the help of dry-validation, I think). This means that each action can uniquely validate the parameters. Rather than having create_project_params and update_project_params defined within a controller -- as you might do in Rails -- you can define what constitutes valid parameters right there in the action class. It would be otherwise trivial to make the aforementioned design of using `require_dependency` to also add such functionality. &gt; In a Rails application, you define a helper in a module named after the controller. Nothing's stopping you from making a PORO or similar. Regardless, the helper is globally available to your views if it's in a helper file. The convention is just to help organize. -- Maybe OP is trying to say that they're uncomfortable doing things the "Rails way". And that's fine, the "Rails way" isn't a great way after all. If you're clobbering everything into app/models and app/controllers you're going to have a really bad time. The most successful Rails projects don't do things the Rails way because they're often not built by "Rails developers" but instead Ruby developers who just happen to spend time within Rails' conventions, libraries, and frameworks. I purposefully have quoted "Rails developers" because I've seen so many people who write Ruby that are only comfortable within Rails. I hate to generalize, but they're otherwise clueless when it comes to spinning up a Rack app unless they're hitting `rails s`. 
"Service object" is such a meaningless term in Ruby. It literally adds no meaning over just "object"
I remembered reading somewhere where PHP tried to JIT in 5.5 and the microbenchmark really shined, but somehow doesn't do much justice with Wordpress. They dropped it and went to improve the speed without JIT. PHP 8 is going to have JIT though, at least that's the plan. More reading: - https://bugs.ruby-lang.org/issues/12589#note-42 - https://bugs.ruby-lang.org/issues/14235#note-21
don't post this as a text self-post, post it as a link. 
&gt; Very few developers I know put business logic in models. lol then either you haven't been doing rails very long or keep an extremely select company. a HUGE number of rails developers put business logic in models, you see it absolutely everywhere, if you've worked at more than one place or touched a legacy code base then you have too. 
&gt; I'd first state that the issue is specific to particular classes of programming problems and I would deny that it is so ubiquitous that it warrants dismissal of OO. Polymorphism is the defining characteristic of OO, at least according to [Uncle Bob](https://www.youtube.com/watch?v=QHnLmvDxGTY). I highly recommend watching that video, It's probably one of the most influential talks on OO i have seen. That Polymorphism is done better in none OO languages is a fairly heavy blow against the idea that is OO. In might warrant a dismissal of OO, but ruby, as i said in my first post, is more then a OO language, its a whole ecosystem and community &gt; in Ruby you could solve the issue quite efficiency... And in C you can build in polymorphism. I'm not looking to judge a language by what it can do, but what it makes easy to do and what it makes hard to do. In this case, its far easier for the majority of developers to ignore the expression problem and deal with the leaking complexity it causes. If we accept the SOLID principles as truly a good idea, as Sandi Matz does, then we should also consider paradigms and languages which embrace those principles rather then make it a matter of discipline, are worth considering and learning from. 
It's still the most complete resource for the basics of Ruby—as far as I know. Metaprogramming Ruby is also a great rundown on slightly more advanced topics.
Kafka does not make a good general purpose job system; it's not what it's designed for. If you have long-running or variable-duration jobs (I'm talking more than milliseconds), you suffer head of line blocking which manifests as large spikey dequeue delays. If your messages aren't well partitioned, a large portion of your consumers will be idle while the others are drowning. Kafka's benefits (ordering, event sourcing, consumer groups) are easily lost for "jobs".
Thanks for answering. How's it been? Any problems integrating with Rails or any other libraries?
That was what I was thinking, optimize app code before changing the Ruby implementation. I've honestly been curious since I've heard about the other Rubies since I was first starting out and never got to use them yet.
I've been using Rails since Rails 2 and have 15 projects living in production with tens of millions of requests every month. I've seen a lot. Stuffing business logic into models... It's usually a knee-jerk reaction to the idea of fat models/skinny controllers. But I've also continuously preached and practiced having an adequate service layer and make use of service objects. Check out Gitlab for a good example of separating these concerns. But you didn't even attempt counter my point but instead just tried to refute it with a generalization and an assumption which didn't contribute to the discussion. 
Yep - no info yet which OS's or c compilers work / work best. Also, check out the other jit options, especially the one which makes execution wait until the jit has run. It's instructive to try to infer what it's doing.
Could you elaborate a bit further? From what you describe, if you go to a queue in the Managment UI you are able to pop messages without removing them, you can even move all messages or clone them to another queue. That has helped me a lot. There is also firehose. It's a feature that enables you to exactly see what is happening by looking out Rabbit's internal messages.
Hmm, it is certainly a possibly useful feature. But I am glad that they turn this feature on only when the output is a TTY. I'm very grateful that the Ruby developers are always mindful of backwards compatibility. Some people criticize them for it and think it holds Ruby back, but I think it does the opposite. It shows respect for users and it makes life a little more sane for some people.
We use MRI for our web stuff, anything using native extensions is tricky with JRuby, because a lot of gems don’t have a Java alternative. Our first use case that got us to start using JRuby was a process working with RabbitMQ and MongoDB, which was very tricky in MRI. The rmq driver used eventmachine, and it didn’t work well together with the mongo driver. This was some 7 years ago, and we had to write our own driver for RabbitMQ under JRuby as well, basically wrapping the Java library. 
The code can't be optimized to nothing - it should ideally be optimized down to: {{{ def script return 1_000_000 end }}} But that's assuming that you haven't redefined Fixnum#+ Optimizing down to eliminate unreferenced variables or optimize math in ruby is probably not worth the JIT effort.
&gt; Your post comes off as a little bit fundamentalist: it argues that Rabbit is better than Sidekiq. Black/white. My apologies. The point for me wasn't to bash Sidekiq, but rather show that RabbitMQ is an excellent tool that can be used for a job queue. If you got that impression, then I have failed in my goal. &gt; This might be true for you and your current project. But I would remind you: rabbit has a place, sidekiq has a place. Of course, I mention that in the conclusion. I even mentioned that in the talk I gave. &gt; This might be true for you and your current project. But I would remind you: rabbit has a place, sidekiq has a place. You choose a tool based on context: what do I need it to do, what features do I need, what budget do I have, what skills does my team have? Are they familiar with Rabbit? Do they want to run it in production? If you are running a team of 10 developers, that's over $1million/yr in salary alone. Are you going to cheap out and give them no budget for tooling? $2000/yr is peanuts. Those are my customers; not individual hobbyists. I tried to give the same conclusion. Again, my apologies if this article came off as bashing Sidekiq, that wasn't the point. The whole point of the article was to break the common (to my circles) misconception that RabbitMQ is just a Sidekick replacement. It's not. It can do so much more than be a job queue. It has helped me solve many distributed systems problems, only one of which were background jobs. &gt; As to job loss, Sidekiq does its best to shut down cleanly and push jobs back to Redis before terminating. It most definitely does not just die and lose jobs on every deploy by default. From the comments, I'm aware that the free version makes efforts to solve this issue. And if I understand correctly the solution is somewhat specific or at least tailored for Heroku. Before I continue, not that it's great that there is the support for this and that it works out-of-the-box, if I misunderstood the first part please ignore the following sentence. My question is, what if my timeout period is shorter than Heroku's, or what if Heroku shortens its timeout? Though that goes only if you terminate the process, if you kill it then the job is gone (on the free version)? Could you perhaps suggest an edit to my post, I'd gladly adopt it. &gt; You may not like the price of Sidekiq Pro but it's precisely that price which has kept me optimizing and improving Sidekiq for the last 6 years. I've pointed out in the article that there are two things that I think shouldn't be behind a paywall - guaranteed execution and the login screen. I'm nobody to tell you how to run your business, these are only my wishes. I love what you did with Sidekiq. I love the business model, I love the readmes, I love the project. I still use it and introduce it to new projects when I see that it fits my needs better than Rabbit. I don't want it to die, I'd love to see it and Faktory flourish and become even better. I haven't used your business support, but from what I heard it's worth the price tag alone. That's not something that you will get with Rabbit. While I don't like that some, in my opinion essential, features are hiddine behind a paywall I can respect what you have done with Sidekiq, and I can see that it helped you maintain the project.
*yawn* every mediocre developer is writing shitty blog posts about service objects. Big fucking deal. Yes, they make sense, but they're not new or interesting, the CLEAN architecture (as well as many other ones) mentioned them many many years ago. I don't care about that - nor do i care about any of your other points, I just think you're full of shit when you make statements pretending that putting business logic into models isn't a thing - it absolutely IS a thing, whether it's shitty programming or not, it's a thing. Also i checked out your github, you have nothing in the slightest bit remarkable or interesting there, so i don't think you're in a position to lecture or swagger around like you're a big swinging dick. You seem extremely average to me.
&gt; Very few developers I know put business logic in models. Then you probably worked with very few developers :) I can guarantee you that majority of folks who use Rails put 90% of app's logic into AR models. This is what they've been taught, that's what they know. &gt; The ActiveRecord pattern (it is a design pattern, after all) doesn't reference or lend ideas to this at all. From PoEAA about Active Record pattern: "An object that wraps a row in a database table or view, encapsulates the database access, and adds domain logic on that data." 
&gt; Explicitness in code leads to a much better understanding. I'm curious why you didn't choose Python over Ruby then?
Same. 
&gt; on only when the output is a TTY I'm not so keen on this since it means you have to read the error message differently based on if it was pasted from console or log file...
I said "yes" for a long time and even recommended the book to novice mentees... But currently, I tend to say "no". The thing is, Pickaxe is (was) in fact "The Ruby Book", language guide and reference, mostly useful for those knowing absolutely nothing, as a gentle and comprehensive introduction to Ruby. Now, being as outdated as it is, it can no more be treated as one. Relatively "small" changes were made to Ruby since 2.0, but those changes are everywhere, and they seriously reshaped the language, preferred style, common patterns, and solution. So, one being introduced to language through Pickaxe will immediately be in possession of outdated knowledge. It is a big problem, in fact, that there is no open, online, relevant, community-supported language guide. There is no "The Ruby Book" and no place where curious novice or language switcher can just feed their curiosity and learn how awesome the language is.
I have a few improvements for you to consider, do with them what you will. I would like to point out this is all in good spirits :) not really sure what the point of the welcome prompt is, since the name is not used beyond the first message, but that aside, the welcome method is defined and called without reuse. You could probably just inline the contents of that method. in feels you have a series of elsifs that are based on a single variable, I would recommend a case statement here rather than an if block. as /u/this_is_not_nil mentioned the indentation should be consistent for the final loop check out ruby's until. using until you can set the break condition and print the farewell message after the loop. the feelings array does not serve a purpose as of yet, while you push new values to it they are lost once the script completes. To record this information you are going to want to write it to a more permanent data store: file, database, etc.
I've had a number of scripts that accept prompted input, and have recently discovered the [highline gem](https://github.com/JEG2/highline). If you're looking to explore more CLI user input, I'd recommend giving it a try, it really DRYs the "get &amp; sanitize cli input" portions up. Plus I've appreciated it's simple colorization string extensions and some of its helpful little features like how easy it is to have the script accept a password, and output "*" for each character entered instead of echoing the characters to the screen. Maybe explore command line argument processing too if you'd like to have encouragement without as much interaction? So you could run your script like: ``` ruby myscript.rb --anxious ``` I've used Ruby's [OptionParse](https://docs.ruby-lang.org/en/2.1.0/OptionParser.html) found in the standard library for ARGV processing.
&gt; The code can't be optimized to nothing But when the method is called by the benchmarking loop, nothing is done with the result. Why return a result if nothing is going to be done with it? &gt; But that's assuming that you haven't redefined Fixnum#+ Yes, speculative optimisations such as assuming that numeric methods haven't been defined is an essential part of making Ruby fast. You can revert this optimisations if someone redefines a basic method through dynamic deoptimisation and on-stack replacement. &gt; Optimizing down to eliminate unreferenced variables or optimize math in ruby is probably not worth the JIT effort. All previous Ruby JITs try to do this, so you're arguing against a lot of people's long-term practical experience there.
Data processing (ETL-ish), sometimes including making lots of requests to HTTP APIs (although the latter can be handled reasonably by MRI since it's IO-bound). 
Try to be more consistent with variable names. ex: yn = an input. Stick to just input, for readability. in your `feels` def, your variable should be `feeling` since you are prompting an input for the feeling of the user. For your conditional on line 7, instead of checking for invalid input, check for *valid* input, and then utilize the else block as a catch all. The final conditional is strange, too.
why?
so it works on Heroku :)
Thank you for the suggestion! The whole mixin-style crosses more boundaries than I'd like. I would have shipped just the functional style, but I think a nontrivial part of the Rails community would find it too verbose, and I'd like to make this library useful to everyone. I agree that an ActiveRecord object shouldn't operate on a Rack::Request. In the ActiveRecord examples, though, models aren't operating on a raw Rack::Request -- they're reading from an ActionController::Parameters object that gets explicitly passed from a controller: `@artists = Artist.reduce(request.params)` Would it be better for the docs to encourage passing a raw hash, like so? `@artists = Artist.reduce(request.query_parameters)` Or does your concern about the Rack boundary come Rack::Reducer being a part of Rack's namespace? As in, would you still be concerned if Rack::Reducer were called "SomeUtilityNamespace::Reducer"? Thinking about your suggestion has made me realize that Rack::Reducer isn't actually dependent on Rack at all—it's just a utility module whose API supports being used as Rack middleware. I will update the gemspec and docs accordingly.
Since "Frameworks other than Rails" is a header, I assume you are looking mostly to a Rails userbase, however my comment can just as easily apply to non-rails ruby projects. Rails already parses yml files as ERB first. To be 12-factor compliant i simply use this feature and do: development: foo: bar: &lt;%= ENV['OMG'] || 'default becasue i am lazy' %&gt; And then in the application config: config.foo_config = config_for(:foo) This appears to do everything you need, without creating a constraint that ENV vars have a name formatted like the YML loading them. 
If you commit your YAML into git, then API keys and stuff will become public. And I am developing a project a bit like Wordpress. I want to let users to configure it as they like. So commiting the config into git is a bit nono.
&gt; Having 20 different ENV is not very practical. Why not? Have you looked at "prior work", like [chamber](https://github.com/thekompanee/chamber) and [figaro](https://github.com/laserlemon/figaro)
That's not entirely accurate — a pattern has emerged where you create objects that store little to no state and have a single method that is called to perform a task and live in a folder called "app/services". Google it...I've seen a ton of articles about this pattern and the defenses of how it makes Rails apps better. I've rarely heard the term "service object" get applied to a regular Ruby object that might contain dozens of methods and provide an advanced interface for manipulating its data state, as you would expect when people talk about putting business logic in POROs.
Rather than coming up with your own words of encouragement, you could try taking the keywords provided via input and sending them as a search query to this Quotes API: https://quotes.rest. Then, as a next step, you could throw in a sentiment analysis API to help ensure the quote being returned is what you’re going for.
naming them without some kind of namespacing is really painful. But no it's my first time knowing chamber. Thanks for introducing it!
I'm sorry for the job loss. Docker is somewhat infamous for killing off containers and losing state, like jobs, especially with naive auto-scaling systems that don't have any option for graceful shutdown. Sidekiq was designed to use the exact same algorithm to execute jobs as Resque. If that means Sidekiq is not production-worthy, then the same is true of Resque. Faktory, my new background job system, does use job acknowledgment to ensure no job loss because I had control of the data store. Redis does not have an easy way to implement acknowledgment which is why Sidekiq and Resque don't use it. I like to tell people that if you are depending on any single one thing to act completely bug-free, you are gonna have a bad time. [Reconciliation is the only solution](https://www.mikeperham.com/2014/05/27/the-reconciliation-step/) for "serious production".
Great........
&gt; I've pointed out in the article that there are two things that I think shouldn't be behind a paywall - guaranteed execution and the login screen. I don't sell either of those features. Many, many Sidekiq users have their Sidekiq web UI behind authentication without paying me a dime. Perhaps you can clarify which features you are speaking of? https://github.com/mperham/sidekiq/wiki#sidekiq-pro &gt; From the comments, I'm aware that the free version makes efforts to solve this issue. And if I understand correctly the solution is somewhat specific or at least tailored for Heroku. Before I continue, not that it's great that there is the support for this and that it works out-of-the-box, if I misunderstood the first part please ignore the following sentence. My question is, what if my timeout period is shorter than Heroku's, or what if Heroku shortens its timeout? Historically, people either ran Sidekiq on their own machines or on Heroku. Since I can't tune for custom machines, I tuned Sidekiq's defaults to work as best as I could on Heroku. Heroku will never shorten the timeout, that would break customers. If they lengthen the timeout (like they did in Jan 2017 in going from 10 seconds to 30 seconds) nothing bad will happen, it just gives Sidekiq a lot more time to push jobs back to Redis. Heroku users should use `-t 25` to take full advantage of this increased timeout. https://github.com/mperham/sidekiq/wiki/Deployment#heroku
The article is very basic, moreover there are existing solutions like https://github.com/bkeepers/dotenv - where you don't need any custom code to be added. PS: usually you don't want to have this file gitignored, because: 1. programmers will have no idea that they should create a file(unless it's in a README) and if they won't do this running the app will rise a "No such file" exception 2. programmers will have no idea what to put in the file after creation Instead you'd want to leave the file checked in the repo with keys only(and possible values for non-sensitive data)
it was in mars 2017 , look 2018
Thank you for &lt;dotenv&gt; 
I assume you are French and meant March but this made me laugh thinking about the planet Mars having a separate ranking for programming language popularity. 
You are right....thanks
&gt; I don't sell either of those features. Many, many Sidekiq users have their Sidekiq web UI behind authentication without paying me a dime. Perhaps you can clarify which features you are speaking of? https://github.com/mperham/sidekiq/wiki#sidekiq-pro I was referring to [Reliability](https://github.com/mperham/sidekiq/wiki/Reliability) and [Ent-Web-UI](https://github.com/mperham/sidekiq/wiki/Ent-Web-UI). Reliability is the feature I miss the most. The lack of just that featured has steered me away from Sidekiq lately. On a personal project of mine, I also decided to use Sneakers just because the lack that feature. For me, a $1000 is too much just to get a pet project off the ground. --- &gt; Historically, people either ran Sidekiq on their own machines or on Heroku. Since I can't tune for custom machines, I tuned Sidekiq's defaults to work as best as I could on Heroku. That's reasonable. I'll try to utilize the `-t` option the next time I use Sidekiq. &gt; Heroku will never shorten the timeout, that would break customers. I'm highly skeptical that this is set in stone and that it can't change to a lower number in the future. A few years back they set a limit on how long a free tier dino can be available after having no limit for years. That broke quite a few in-house apps of the company I was working for at the time. &gt; many Sidekiq users have their Sidekiq web UI behind authentication without paying me a dime. Are you referring to the following? authenticate :user, lambda { |user| user&amp;.admin? } do mount Sidekiq::Web =&gt; '/sidekiq' end If yes, this code is Rails and Devise specific, to achieve the same with other authentification frameworks isn't that trivial (in Rails). 
That's true, but that's not something I usually do. But yes, for some people that could be annoying.
You are confusing authentication (free, must login to access) with authorization (enterprise, e.g. must have authorization to perform write operations like clearing a queue). Not many small companies/side projects need authorization so they can open their admin UI to read-only users.
"C is love. C is literally life." -Mars Curiosity Rover, probably 
TIL `bundler/inline` 0_0
While everything you say is correct you seem to be intentionally side stepping the main point of my comment. Once we switched to Sidekiq Pro and turned on `reliable_scheduler!` the problem disappeared completely. I'm aware that even then there is a tiny chance that it happens and we later added additional safety mechanisms but it was practically no longer a problem once we switched to the Pro version. The fact that if you're going to production you almost certainly must buy the Pro version since OSS one is not production ready is not communicated clearly enough. As long as you need to read the features list carefully and conclude that yourself, Sidekiq is borderline ransomware. Once you discover the issue in production, of course your only sane choice is to buy the Pro license immediately (which we did only for that feature since we didn't need anything else). 
Thank you so much ! Oh ! sorry for the misunderstanding. It wasn't my intention. In same time, I recommend you to use [`benchmarck-ips`](https://github.com/evanphx/benchmark-ips) to easily make a performance test over a simple piece of code. It's really easy to use. 
What do you think of the "operation" pattern, as exemplified by Trailblazer? I am really struggling to get control over a complex Rails app and made the exact same kinds of service objects in your article: shitty functions that are no more understandable than the AR code was. The main benefit was getting things out of callbacks, which were becoming progressively less reliable. My best ones represented some kind of meta concept, like TaskAssignment (the only one of my own I can ever remember how to use).
Yes, I think Python as a whole is more strictly explicit than Ruby. There's always a balance between things *just working* and having enough explicitness to see what's happening. In this case, I think Ryan is talking about explicitness in the framework not the language. We can learn what to implicitly expect in our languages, but it seems more taxing to have to learn such things for each framework. I don't think you should be downvoted. It's a good question.
The last suggestion to use ENV calls throughout the application is very bad advice. These calls are vulnerable to breaking due to missing envvars. Instead, use an initializer to define constants and use ENV.fetch(key, default_value) instead of array access.
Is there anything you can recommend? 
You can also provide a `.env.sample` with instructions to `cp .env.sample .env` after checkout. &gt; Instead you'd want to leave the file checked in the repo with keys only(and possible values for non-sensitive data) This doesn't sound like a good solution. Once you modify the file it shows up under changes which is a) annoying and b) dangerous because it's way too easy to accidentally commit sensitive values.
Ignore TIOBE. Its a nonsensical ranking system and large changes are expected for little rhyme or reason. If you insist on following popularity contests, then perhaps look at [RedMonk Programming Language Rankings](http://redmonk.com/sogrady/2018/03/07/language-rankings-1-18/). They at least have some stability, though their choice of metrics also raises questions for languages that don't emphasize open-source.
Thank you.
curious, i read this, and I'm not sure this index means much... https://www.tiobe.com/tiobe-index/programming-languages-definition/
Really thankful for the feedback. One of the hardest things about getting into Ruby (and programming in general) is not having a safe space to ask dumb questions and get feedback so thank you all for responding!
That's a great idea!
Thank you for such a quality response.
The plan is add more utility around the naming later. I read on a Stack overflow when I was looking into it not to use "case" in this situation but can definitely try to figure that out. Until makes sense for sure. I'll work on it! Thank you!
Unless you have `.env` gitignored, and `.env.sample` in the repository. This is what I've done from time to time. 
Not about being honest. It's about not giving quality feedback instead of a quick critic. 
If you are not saving state don't write objects. 
&gt; In the ActiveRecord examples, though, models aren't operating on a raw Rack::Request I meant that models contain a `Reducer` which requires `Rack::Request`, which signifies that's it's not a domain model level component. &gt; they're reading from an ActionController::Parameters object that gets explicitly passed from a controller: &gt; ... &gt; Would it be better for the docs to encourage passing a raw hash, like so? No. In this case just cause it has `Controller` in the name doesn't _always_ mean it's bad to tie into a model. It's a `HashWithInfefferentAccess` subclass, which I think is ok. 
You most definitely want to have your .env in your .gitignore 
“feels” is a colloquial term for “feeling” (or feelings)
referring to the 'answer' variable. 'answer' is very ambiguous
It's the most quoted measurement that I know of. Even if it's flawed I wouldnt ignore it because in the end that's what a lot of companies and employees look at...
I added some of the adjustments you mentioned. If you have time and want to take a look, I'd super appreciate it.
It's quoted all over Reddit, on social media, on Hacker News. Big companies would rather read Gartner and couldn't care less about TIOBE. Small companies couldn't care about either of them.
Unfortunately, the closest we have to "The Ruby Book" now is rendering of the official docs: https://docs.ruby-lang.org/en/trunk/ Clicking through the first block of links at the left, you can find everything about the language, including some TOC-alike pages, for example: * https://docs.ruby-lang.org/en/trunk/syntax_rdoc.html -- quick links to all the syntax parts; * https://docs.ruby-lang.org/en/trunk/standard_library_rdoc.html -- quick links to all the standard library; Can't say that it is awfully convenient or incredibly easy to navigate, yet this is the only up-to-date option I am aware of.
Well yes, I agree, and those companies you're talking about aren't huge ruby fans anyway :) I think Ruby long missed the enterprise train and is now fighting over mind share of small-mid businesses.
Hello, yesterday's Vienna.rb talk notes titled [Build (Online) Books and Documentation w/ Octobook Themes and the Jekyll (Static) Website Compiler](https://github.com/geraldb/talks/blob/master/octobook.md). Real-world examples built with the (auto-)magic GitHub Pages build-pipeline incl.: - [The Strange Case of Dr Jekyll and Mr Hyde](http://worldclassics.github.io/dr-jekyll-and-mr-hyde) @ World Classics Case Study - Project Documentation Case Study - [Slideshow (S9)](http://slideshow-s9.github.io/), [Pluto (Planet) News (Feed) Reader](http://feedreader.github.io/) - Ruby Books @ [Yuki &amp; Moto Press Bookshelf](http://yukimotopress.github.io). Happy publishing w/ ruby and jekyll and friends. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [geraldb/talks/.../**octobook.md** (master → dc479f9)](https://github.com/geraldb/talks/blob/dc479f98f323f67126bd71c81d11a3898f3bfd79/octobook.md) ---- 
Speak with your wallets!
Thanks for the initiative. I've signed in the campaign.
thank you :) 
Yeah, I think that's a no-go on Heroku for now :D
Nice! That seems pretty consistent with my experience so far.
With my comment you can take a look at your indentation an verify what I see and fix it immediately, what more do you need? You ask people to look at your code, but you can't spend 10 seconds to ask your editor to automatically fix your indentation.
Way to contribute to /r/ruby!
Learning languages is easy. Falling in love with them (like with Ruby) is hard &lt;3 
yep yep agree, there are solutions out there: * [AWS Lambda and Ruby](https://aws.amazon.com/blogs/compute/scripting-languages-for-aws-lambda-running-php-ruby-and-go#toc_10) * [Using Ruby in AWS Lambda](http://www.adomokos.com/2016/06/using-ruby-in-aws-lambda.html) * [Traveling Ruby](https://github.com/phusion/traveling-ruby) * [2017 RubyHACK, James Thompson: "Serverless" Ruby on AWS](https://www.youtube.com/watch?v=3NdFzhIvUQA) * [Serverless framework - Ruby](https://github.com/stewartlord/serverless-ruby) * [AWS Lambda JRuby](https://github.com/plainprogrammer/aws-lambda-jruby But it's just not ideal and not productive to work that way :) 
Falling love with your tools is a *terrible* idea, [precisely because](https://en.wikipedia.org/wiki/Law_of_the_instrument) it's so easy. That said, it *is* a lot easier to love some tools than others (and Ruby is positively seductive in that regard), but that's still no excuse for doing it.
This makes me wonder *why* Ruby is so poorly-supported by FaaS providers that it needs a petition to make it happen. Is it just that it's not in the top tier of popularity for programming languages (so theyaren't prioritising it), or is it somthing about the language/interpreter(s) itself that makes it hard to integrate into a FaaS system that could be fixed with a focused effort by the community?
Or just pick the best tools for the job. 
It's just not a top pick. Even Javascript is more widely used on the backend nowadays than Ruby. 
Sooo, you're a fan and not a developer?
yeah it's a shame because dynamic languages like Ruby, PHP are ideal for FaaS. With Java there is problem with functions that are not executed too often will take some time to worm-up. With JS there is a problem that developer cannot use advantages of Event loop. So really only language that make sense is Python from the default stack. So it really is driver by demand :) They aimed for the most popular languages out there ( Py, JS, Java ). I guess next one (due popularity) will be PHP , but I really hope for Ruby :) 
disagree :) I place developer happiness on first place when it comes to my Job :) if the job requires different tools then that job position is not for me :) 
when you think about it Ruby is really the best toll for the job. The nature of FaaS is ideal for languages like Ruby ( pls read https://www.reddit.com/r/ruby/comments/835rjj/we_demand_faas_providers_to_support_ruby/dvfjl3k/ where I explained that already ;) )
AWS Lambda does support ruby, no? I haven't used it myself. https://aws.amazon.com/blogs/compute/scripting-languages-for-aws-lambda-running-php-ruby-and-go/
Thank you for taking the time to explain—I understand your concern much better now. I'm actually not sure how best to address it. Reducer only needs Rack::Request when it's being used as middleware—in all other contexts, including in the ActiveRecord examples, it could drop the dependency on Rack entirely. `Rack::Reducer.new` (line 19 of lib/rack/reducer.rb) is how Reducer gets mounted as middleware, and that method is *only* called when mounting as middleware. Neither the mixin-style nor functional-style APIs call it. So we could maybe require rack/request as part of that method, and pass it into the `Reduction`command as an injected dependency. Something like: ``` # lib/rack/reducer.rb def self.new(app, options = {}) require 'rack/request' Reduction.new(app, options.merge(parser: Rack::Request)) end ``` I could also, as you suggested in the first place, just discourage extending Rack::Reducer in models. Rails devs who want to keep their controllers tiny would need to create command objects -- e.g. `app/reducers/artists_reducer.rb` -- which would call Rack::Reducer in the functional style with the appropriate datasets. I'll think more about this over the weekend, and I welcome your opinions on the above in the meantime. Thanks again for raising this concern.
It seems you have to package ruby for lambda, compared to python or go which has native support.
Well, in fact there are two different questions: 1. how Ruby 2.0 is outdated (in my opinion) comparing to today 2. how Pickaxe 4th is outdated Those are different because Pickaxe 4th is mostly "Ruby 1.9, mention 2.0-additions" mostly, and even some of the new things from 1.9 was still not recognized as a common way of doing things. So, to name a few (related to both areas), in no particular order: * from quick scanning, it seems pickaxe never shows `&amp;:sym` syntax, which is widely popular currently, despite the fact it was introduced in 1.9; neither generic `&amp;` / `.to_proc` thing could be found * upd: grepping through book's contents, `.to_proc` and `&amp;:sym` are briefly mentioned, but not used in most of the examples (and also Ruby 1.9 hash keys syntax typically not used, although mentioned) * `prepend` is mentioned, but also briefly and as something new and never used outside small chapter that describes it * keyword arguments at that time could not be without default values (that's 2.1), and they are mentioned separately as a new "cool and experimental" feature; * bundler is never mentioned (OK, it is still not an "official" part of the language today, but ...) * "Ruby and the Web" chapter starts with "Writing CGI scripts", for God's sake, and goes mostly like this for the rest of the chapter Speaking more generally (forgetting the Pickaxe and just looking through Ruby 2.1-2.5 NEWS files), we've got (in no particular order, again): * keyword args without default values * methods returning Symbols, making things like `memoize def foo` idiomatic; * `to_h` instead of `Hash[]` (I still regularly fix student's code, who borrow `Hash[]` from older books and tutorials) * ...and lot of new methods in standard classes, like `#itself` and `#yield_self` or `#dig` or `#clamp` * frozen string literals * safe navigation * ... But what this dry list does not expose, is, I believe, that through years preferred idioms and styles have been crystallized, new tools and approaches emerged, and the "imprinting" of Ruby style and ways of solving simple tasks the book gives is slightly off on "almost each line" (it even uses `and` in a logical conditions sometimes!). PS: To be honest, haven't opened The Book for the loooong time. Probably, my first answer is a bit too strong, it is still pretty well structured, explains things calmly and in great details and overall pretty decent introduction to Ruby. So sad they ceased to update it for the new versions.
you need to create JS lambda that will call binary executable of ruby 2.2.2 (https://github.com/phusion/traveling-ruby) So basically you need to create zip package with Ruby in it (yes entire Ruby) + Gems + other dependancies and invoke it from JS or Python :) And you need to repeat that for every Lambda function :) + You are stuck with one Ruby version forever 
When billed by CPU seconds Ruby is quite plainly not the most economic choice. Depending on scale and budget it might be an obviously poor choice if performance or budget is important.
:D oh noooo ! https://www.youtube.com/watch?v=saC13RJ8CUs
where there are situations when Ruby is good, there are situations where Ruby is bad. But when you think about how Lambda works : spin up Lambda &gt; execute code &gt; spin down Lambda (die) ...languages like Ruby makes sense as they are nifty. You have languages like Java that are better on long run but are terrible at cold run =&gt; Ruby should perform better with Lambda. (Probably Python will be better ) but Ruby still pretty good So yes it depends case by case, but in most pragmatic scenarios for Web App quite good :) 
because they are not best but most popular :) Python is ideal for Lambda, JS and Java was picked mainly because of popularity.
Python is fine for FaaS. But would be nice if there was Ruby too :) ...I'm not commenting on JS and Java doh, those don't make much sense and were picked because of popularity 
Yeah.. I might just stick with teamtreehouse instead. Thank you for the resources though!
This is also possible via [Opal.](http://opalrb.com/)
It is no different from having `.env` checked in and `.env.local` gitignored which is the main approach for dotenv gem. And this is what I meant, instead in the article you have only one file and author suggests to gitignore it.
Because you said so, right?
If you check in the file it’s really easy to make a mistake and then new changes get recorded as well. Which is a security hole. The common practice I’ve seen is the .env.sample and then things are more clear.
Please copy all and paste it in a notepad, it got messed up when i paste it.
What have you tried?
my brother needs to complete this homework, i just have basic idea on how to program in Ruby, this is way too much for me :/
&gt; And this is what I meant, instead in the article you have only one file and author suggests to gitignore it. I see. That wasn't clear to me. In the context of the article it sounded like you were replacing a one-env-file solution with another. You also used the term "the file" which I interpreted as a one-env-file solution. &gt; I never said you should modify it Again, one env file + "Instead you'd want to leave the file checked in the repo with keys only" requires modifying it. My bad. &gt; merge requests and code reviews which will prevent you from committing real secrets into the main branch \* which make it _harder_ to commit real secrets into the main branch. Adding a secret to the main branch isn't the only issue, though. You should already consider a key compromised once it leaves your local development machine (which it does right before merge requests/code reviews).
&gt; Values should be equal if, and only if, all of their structural elements are equal What about `Quantity.new(1000, 'm') == Quantity.new(1, 'km')`? Or would you consider these two incomparable (raise an exceptions when trying to call `#==`) and require an explicit conversion beforehand?
&gt; &lt;=&gt; should NOT raise on attempt to compare with incompatible type, just return nil &gt; == should NOT raise on attempt to compare with incompatible type I disagree with these two. A type mismatch is almost always a bug and the earlier my program fails the better.
I wouldn't recommend adding to_json. JSON.generate(value.to_h) is a better way to serialize, as there are options you can pass to control formatting. Yes, those pass through to the instance method, but it's weird and kludgy. Most of it looks pretty good, actually.
&gt; If it is a slightest possibility the value type could be used as a key in hashes, implement #hash, returning unique number for each unique combination of structural elements. This should probably be rephrased since `hash(a) == hash(b) ==&gt; a == b` isn't a requirement for the `hash` function. It's also not possible since `hash` needs to fit into an `Integer` ([Object#hash](http://ruby-doc.org/core-2.4.1/Object.html#method-i-hash))
It's a great overview and reference! I hope my many comments don't distract from that.
It’s not popular enough to support it. 
Look at your comment compared to everyone else's. There's nothing constructive about it. 
How should I be constructive about it? You are mixing tabs and spaces, and it looks weird, fix it.
If in doubt do what Ruby does. 
I think you missed the point. You insinuated ruby wasn't the best tool for the job, but your basis seems to be the lack of popularity, which is not a technical assessment. And this movement is aimed at increasing support for ruby, which makes your comment moot.
Hey y'all. I'm glad Ruby Together exists. I think it's a good idea. I think many would like a further breakdown of these expenses: &gt; $2,174.03 on company overhead like hosting, services, software, hardware, taxes, etc &gt; $1,050 on accounting, copywriting, design, and other professional services At ~20% of total expenses reported, they are not insignificant, and it's not clear what they are for exactly. It would be more transparent if you broke down who you were paying for what results for this. 
I like this solution. (If you don't mind me pulling from python land) I have this same issue in Django rest framework, where I have to define new classes for any change between the index versus detail view, and I find it cumbersome. This abstraction would be better for many cases.
Reverse DNS lookup - convert the IP address into its domain name, if set. I just wrote this exact service in phoenix.
My solution to this (ymmv) for personal projects is to define a class method Value[] (*args) that checks a hash for a preexisting Value object with these args and retrurns that if it exists or does Value.new(*args) if not. So instead of Value.new(4)==Value.new (4) (=&gt;false) i just do Value[4]==Value [4] (=&gt;true) Of course this means you should avoid using Value.new , avalue.dup etc
&gt; Your types should be ready to be inherited, … Value objects (and entities, which are importantly not the same thing) are down-on-their-knees-screaming poster children for the good OO design dictum &gt; Prefer composition over inheritance. Every entity that I've coded in the last year where I'd have been tempted to use inheritance has, with a bit of thought, given way to a composition-based approach that was more explicitly intention-revealing. Inheritance is the tightest form of coupling in software.
For anyone considering this, I'd recommend taking a look at [Chamber](https://github.com/thekompanee/chamber), which we've been using and evangelising for at least two years now. The *reason* you want environment variables is so that you can selectively override one default without affecting others. This becomes absolutely critical during troubleshooting. As to the argument that "Passing more env vars also becomes more impractical", that's been a solved problem for some time now, not just with Chamber but also with, e.g., [`.env`](https://github.com/bkeepers/dotenv).
How does blueprint compare to grape as and grape-entities? What are the advantages / use cases that you can do with blueprint but not with grape? Background: we introduced grape about half a year ago for a single endpoint and are planning to develop more JSON endpoints in the near future. So maybe blueprint is worth a try.
How are you not tired spamming?
Yes please! My body is ready.
I always thought [h2o](https://h2o.examp1e.net) was really interesting. Via mruby, you can do Ruby things to requests and responses.
Well, that's slighgly outside of my examples scope :) Designing proper "quantities with units" system is hard, when I've needed one, all (relatively) popular gems like unitwise and rubyunits were unsuitable. But I see you point, there can be imagined units system in which two _convertible_ values should be equal. I'll update the wording there, thanks!
I tried that too and planning to replace my web server, I wonder if it could compile to cruby for better performance or just MRuby?
I dunno, but I’d imaging MRuby performs just as well, if not better, than cruby. Have you seen otherwise?
Nice catch! Thanks.
&gt; Prefer composition over inheritance. Anticipated this comment :) Yeah, maybe that section is a bit of a "personal preferences area", but my reasoning (yielded from practice) is as follows: * implementing good value object is hard: as you can see by the link, even providing idiomatic interface is a hell of work, and it doesn't even touches the internals (which in case of "measurement units" or "money" could be pretty non-trivial) * when somebody, in some domain, needs value object behaving like that you've designed, yet a bit "fixed" for their needs (convenience method, more informative `#inspect`, specialized conversions), what options do they have? * monkey-patching your class, which can lead to a lot of funny things; * wrapping (composition, right?) your class, or writing their own from scratch, and providing all the value object harness, all the comparisons, conversions, constructors and whatevr * descending from your type, change some of the "surface" behavior and use the inherited type. Yes, this approach is not in a fashion of Best Dentists Recommendations, yet it is pragmatic and working (when it really needed). And thing is, the "making it inheritance-friendly" goal on itself leads to cleaner design in lot of the points.
I can see that. You can usually argue that the OCP makes anything "inheritance-friendly"; the question that needs asking each time is, how certain are you that *using* inheritance is the best way forward? That's usually a *really* hard question, and nobody should ever disparage honest-to-`$DEITY` working code.
Having recently dealt with this in multiple projects, both professional and personal, what advantages does this have over graphql? The `graphql-ruby` gem is easy to integrate, and on the front end `apollo-client` is virtually as easy to use as `axios`.
I was going to mention grape too. 
For `using env var to selectively override config to troubleshoot` part, I haven't anticipated such a need. However if someone needs it, it can easily be done by customizing the accessor class. I tool a look at Chamber. It is indeed a complete solution. I guess Settei will be the the opposite, by being minimalistic, and only choose to use env var as a deploy mean (but again, can be customized if user so desire).
Why does everyone ask library authors to compare their libraries to others? Why not just study the library yourself and draw your own conclusion?
Mruby is for embedded development.you would need to be writing code in C and then need scripting, when you do you can use mruby. It’s a competitor to Lua. 
Are there any benchmarks to illustrate how this performs when comparing identical output of other libraries?
You're overlooking one benefit of 'extracted methods', and that's the ability to easily stub them. Take for example the code `ClientSerializer.new`. Should it be in a method or not? You're right that if you don't move it to a method, then the code is easier to follow because the eyes don't have to jump around. But other the other hand, what if `ClientSerializer.new` _did_ make some expensive database or API call? If you were writing unit tests, you would want to stub it out. If you move it to a method, you can simply stub the method. Otherwise you would have to stub `.new` on ClientSerializer. It seems like a really small difference, but splitting code into methods does help you test each of those segments of code in isolation.
Thanks for your work on this :)
Never stub the code under test.
I have had this exact discussion before! I should have included it in the article in retrospect. Rails Controllers are probably one of the most pathological cases of objects where it's unclear how to inject collaborators into since the lifecycle of that object instance is totally unclear. That results in leaning on stubbing for tests. That also makes them one of my least-favorite parts of a Rails stack to test. I would propose that it's just as unsatisfying to stub `ClientSerializer.new` as it is to stub the private method `client_serializer` - in both cases it requires knowledge of the private internals of the object. The small difference you speak of is that stubbing `ClientSerializer.new` is not stubbing the object you're testing. You have tests that cover the behavior of `ClientSerializer`, but I'm not sure you're going to have tests covering whatever it is that `client_serializer` does (if you stub it). In conclusion, I still prefer a local variable there. I am empathetic about why a person would make that choice in Rails controllers, which is the example I happened to choose, but even so.
I guess I don't have that much aversion to local variables because this seems like something I would've done anyway. For me pulling code out into methods makes sense when you're repeating the logic within the class or outside or if your initial method is getting too long and by extracting a logical code chunk you can get two smaller methods with their own tasks. Otherwise, good to get this out there if you're seeing it a lot.
I'm happy to hear that. It's totally possible that my experience is a bubble. If it is, then at least I can point people in my bubble to my written-up thoughts about it instead of having the same conversations repeatedly.
have you worked on large codebases with no stubs? How do you deal with external services? What do you do when your test cases takes hours to run? 
I’m pretty new to ruby and all I’ve created so far (aside from really simple programs) is a CLI budgeting program, and I’ve been reworking and improving it as I learn more. 
I didn’t say never stub. If you are testing the controller you should not stub methods on the controller. You can stub collaborators
ok, whatever. i don't agree with this at all but you do you. Just don't act like this is some universal advice. 
It's very good advice, here's an article about it: https://robots.thoughtbot.com/don-t-stub-the-system-under-test
i am a fantasy football player, but NFL.com fantasy doesnt have a public api. So i built a scraper that grabs results from my league and simulates league matchups to give winning %s predictions each week. My league likes them, adds to the shit talk and good way to practice scripting!
MRuby embeds more easily than other ruby variants. Using this feature I ended up building the [MRuby-Zest](https://github.com/mruby-zest) GUI toolkit/framework/etc. This was used to create a new GUI for [ZynAddSubFX](http://zynaddsubfx.sf.net) which looks like [this](http://zynaddsubfx.sourceforge.net/images/zyn-fusion-add.png)
what i'm seeing here is an example of _how_ to do this, but the explanation, to me, is lacking a _why_. It seems to kind of gloss over the reasoning: &gt; If a behavior is so complicated that we felt compelled to stub it out in a test, that behavior is its own concern that should be encapsulated in a class. Ok, I can see how that's not a _bad_ guideline, but is it important enough to be treated as dogma? You might think so, that's fine. But let's just say the design pattern doesn't vibe that well with me because I don't think there's anything wrong with stubbing the system under test. When I unit test a method, I don't so much consider it testing a "system", but testing a method. That is so say, I test methods in isolation. Whether the methods it calls share a class or don't isn't the most important thing, if the methods don't have side effects, because the namespace can just be switched out. 
I made this thing https://www.codetriage.com. A bunch of other stuff too, but that’s the most successful thing so far.
Depending on the specifics of the meta programming it may not be able to optimize, but it should still work. JIT relies on repeat invocations of the same method to optimize. If you’re dynamically building methods per class instance, and possible if you’re force including modules into a class instance, you’ll likely not see speed ups. (Unless you call that same method in a loop a lot of times) Most Rails-style meta programming magic should see a benefit. Things like AR schema-defined accessor methods are pretty stable.
I'm in awe of some of these. I am working on a podcast downloaded with yaml config file to use on my vps.
How do you scrape it? I'm only a novice programmer and I've always heard of people scraping data when there's no API (as in your case) so I'm curious what the process is. Do you read in a website of some sort and parse the HTML?
Does developing an HTTP/Websocket server count? I did it in Ruby first, but than I moved the codebase to C, added pub/sub services and general fun)... (the [iodine](https://github.com/boazsegev/iodine) gem) If it doesn't count (because of the C code), than I also wrote CombinePDF, that allowed my to combine and numerate PDF data. 🙃
Yes, exactly. You parse the HTML.
With relatively minor refactoring he could inject that dependency so it wouldn't be stubbing the code under test, it would be stubbing the serializer dependency - which is good practice and one of the benefits of dependency injection.
A few years ago I had a problem with long-running test suite in customer project so I develop knapsack gem to split RSpec tests across parallel CI servers: https://github.com/ArturT/knapsack Based on that I created the more advanced solution that allows allocating in a dynamic way the RSpec tests across CI nodes. You can see 1-minute video example here https://knapsackpro.com With time I gather feedback from users and I added support for Minitest, Test::Unit, Cucumber, Spinach and Turnip. Developing your own gem is a nice experience to learn new stuff because people have different needs than you and this gives you the opportunity to build something valuable to others and learn about new tech things.
I saw this post somewhere recently and tried ZynAddSubFX before, it’s cool
[awesome_print](https://rubygems.org/gems/awesome_print/versions/1.8.0) gem many of you are using, among other things ;-)
For me, the greatest benefit of extracting the method is that I don't need to keep all the details in my head as I read. With def show render json: client_serializer.serialize(params[:fields]) end , all I need to understand is that there is a client serializer that serializes with some fields. That's it. The `show` method uses a serializer to serialize some fields. That's pretty understandable. If I need to investigate the details of the serializer, I can go ahead and understand those in isolation. With everything left as local variables, I must understand a client and how to manipulate the params to get one, a serializer and that it takes a client, and finally that the serializer serializes with some fields. I must understand everything and how everything interacts to understand what show does. I will say that I think you do a good job pointing out the cost of these abstractions - when you want to know the details, they become harder. However, I find that often I don't need to understand the full details to move on. I don't generally read code by jumping around the methods as in the picture with arrows.
Good job.
Fixed. (In fact, I am now fascinated how loose my understanding of Hash was, my "good advise" on implementing `#eql?` as an equality of `#hash` values was just plain dumb wrong.)
Experimenting a bit more on it, it looks like implementing `#to_json` is the only (?) way to make the value behave decently in code like {foo: {bar: [{x: 1, y: our_value_object}]}}.to_json There seems to be no other way to "tell" JSON how the object should be serialized. (The same with YAML: other than implementing serialization methods in the object itself, there is no way to set this.) Of course, the whole idea "why it should be `.to_json`-able" is questionable (in web API, it is better to have dedicated serializers than `Product.all.to_json`), but at least JSON is used frequently for structured logging. For example, if you try to send to some Rollbar/NewRelic/Graylog values from prominent Money and Unitwise gem, you'll have... {m: Money.new(1, 'USD')}.to_json # =&gt; {"m":"0.01"} {u: Unitwise(1, 'm')}.to_json) # =&gt; {"u":{"value":1,"unit":{"expression":"m","terms":[{"atom":{"names":["meter"],"primary_code":"m",...(three more lines of serialization) Probably, the alternative good advise for this situation (structured logging and similar stuff) is "do what Ruby does": {t: Time.now}.to_json # =&gt; {"t":"2018-03-11 11:44:52 +0200"} It kinda preserves all the information (though loses type tag, which is acceptable for logs).
It would have been nice if refinements existed before ruby's JSON library, as this is exactly the kind of problem they are great at solving. That said, I'm not sure it's worth optimizing for serializing real objects _within_ a giant pile of primitives. Consider: {foo: {bar: [{x: 1, y: our_value_object.to_h}]}}.to_json Not really a bad experience, IMO. Explicitly converting the value object to a primitive is an improvement, IMO.
Nokigiri helps somewhat with the parsing part, so you don't have to regex HTML. 
It is universal, though. In no other engineering discipline do testers modify the thing they are testing. When you stub methods on the object you're testing, you're not actually _proving_ anything about the object. By extension, you're not actually _testing_ the object. You're checking that it's implementation hasn't changed, which is not a valuable exercise. Thought experiment: say you've got a set of tests for an object. If you can't use those same tests to write a brand spanking new implementation of that object that is correct and complete, then those tests are inadequate. By stubbing methods on the object, you'd be forced to carry over implementation details from the preceding implementation. That's proof positive that your tests are not external to the test subject. Basic software practices like depending on abstractions allow tests to control the subject from its external interface. TDD is supposed to show you when you've designed an object improperly; it can't show you anything if you start modifying the test subject just to get the "test" to pass.
I work with a large team and would say many small methods are easier to maintain when changes come along. Encapsulate the logic for what makes a client valid so when client.present? is no longer sufficient, you already have it extracted and extendable. Memorization costs nothing over direct variable assignment and there is no reason to avoid it. I would extract this into many more methods personally, not fewer. For example params[:fields] may some day need a default. Having it extracted today makes reviews and merges easy later. Again, this is from the point of view of having many people maintain the code over many years. class ClientsController &lt; ApplicationController def show raise ActiveRecord::RecordNotFound unless valid_client? render json: serialized_client end private def client @client ||= Client.find_by(id: client_id) end def client_id params[:id] end def client_serializer @client_serializer ||= ClientSerializer.new(client) end def fields params[:fields] end def serialized_client client_serializer.serialize(fields) end def valid_client? client_id.present? &amp;&amp; client.present? end end 
This is exactly the approach I am advocating against. I tried to illustrate that there IS a cost, and you should consider whether it’s worth paying. I find the code you posted much harder to understand personally, though reasonable people can disagree.
you can generally treat Mac distribution much like Linux if you like. MacOS is a unix with a command line, and generally whatever you can do on linux you can do on MacOS for these sorts of things. Windows of course is another story. 
The carnegie museum of art contracted me to build a photo-archiving and sharing website based around the history of Pittsburgh. It's [www.nowseethis.org](https://www.nowseethis.org) Basically because older people generally don't know how to digitize their photos, and the photos have a limited lifetime, they set up a huge drive to get people to come in and they'd help them scan and label them all. A lot of it is publicly available through the site. There are also other sub-projects related to photography, but the [history of pittsburgh](http://www.nowseethis.org/peopleshistory) is awesome.
Awesome! Will sign up, as soon as I get home
i commend the effort you put forth to make this point, but i see it it more simple terms. If I have a method A that calls method B and does something with the result, I will test method B in isolation and then because of the transitive property I have _no reason_ to test B again while I'm testing A. Thus I can stub B out. Like I mentioned, whether those methods are on the same class or not doesn't matter since it's trivial to move them. 
&gt; Most of it looks pretty good, actually. Agreed. If you're going to keep the `to_json` stuff you should mention that `require "json"` is necessary to call `to_h.to_json` [here](https://github.com/zverok/good-value-object/tree/3c61a9732e4363741dbe8d421030e189c7b8919d#serializationdeserialization). 
Saving time. There may be some basic differences that are nonstarters for some. 
Thanks :D
Disagree with this. The version with locals looks cluttered, and it contains information you don't need to know immediately. I don't care how `client_serializer` is created, nor do i care how `client` is created -- they're self-evident by their names. Moving these definitions into methods makes the action code a lot clearer. And if i ever want to know what these two things are, then i just have to look down a bit further in the controller, no big deal.
I see "GENERATED FILE - DO NOT EDIT" quite a lot, so that seems to be a sane default.
Well, in that kind of exchange, the library author has spent a lot of time writing their library and then released it to the world free of charge. In this case, there's even documentation that allows someone to get up to speed on what it does in a glance. It doesn't strike me as fair to approach library authors with an entitlement to a free cost/benefit analysis, too.
Your analysis is incomplete. Method A _depends on_ method B. That's why it calls it, i.e. if you can't test method A without stubbing method B, you have a concrete dependency. By extension, your test of method A can only be satisfied if method B both exists, and shares a signature with your stub. Concrete dependencies are obstructions to software development that will add maintenance costs and offer no corresponding benefit. It's waste, basically. Write your tests how you want, I guess, but if I open up a codebase and see test subjects getting stubbed, the entire test suite must be called in to question. The only recourse is to either review every single test and remove the stubbing of test subjects, or to nuke the whole test suite. If you want to write code that never regresses, you need to employ more mature practices than what you're describing.
It's definitelly good idea to have that comment in by default. 
I've created a couple of cool things with Ruby over the years. In terms of personal projects I have build a beer brewing calculator called [Brewalizer](http://brewalizer.com/), a couple of helpful scripts and blog posts for using machine learning in Ruby published on [practicalai.io](https://www.practicalai.io/) one of the best ones is [how to teach an AI to play a game in ruby](https://www.practicalai.io/teaching-ai-play-simple-game-using-q-learning/). And my latest project is a price tracking tool for Crypto hardware called [cryptominingdeals.io](https://www.cryptominingdeals.io). 
I can't think of any downsides. 
You're passing `nil` as the app in a few cases because there is none. The constructor requires an app, but [66% of the calls](https://github.com/chrisfrank/rack-reducer/blob/7a8fb6730758717bdcfe7dc7037bd96e13f28613/lib/rack/reducer.rb#L8) have no app. To me this is a sign of a design issue. `Reduction` serves as the true middleware and the reducer. I think it's just a matter of better separating middleware from reduction. For example: # Class name here is just an example class RealMiddleware def initialize(app, props = {}) @app = app @props = props @key = @props[:key] || 'rack.reduction' @reducer = Reduction.new(props) end def call(env) @params = Rack::Request.new(env).params.symbolize_keys @app.call env.merge(@key =&gt; @reducer.reduce(@params)) end end class Reduction using Refinements DEFAULTS = { dataset: [], filters: [] }.freeze def initialize(props) @props = DEFAULTS.merge(props) @params = {} end def reduce(params) @params = Parser.call(params).symbolize_keys @props[:filters].reduce(@props[:dataset], &amp;method(:apply_filter)) end private def apply_filter(data, fn) requirements = fn.required_argument_names.to_set return data unless @params.satisfies?(requirements) data.instance_exec(@params.slice(*fn.all_argument_names), &amp;fn) end end Regardless, you have created a nice library 👍👍👍 
ok after a bit of persuasion i get what you're saying. I can get kinda triggered by what I perceive as dogmatism, but at the same time of course I have my own pet peeves so I can understand your strong feelings. So if I have a method A which calls B which makes a db call, I've tested B separately and I'm testing A, I should prefer to stub the database call, instead of stubbing B, right? I can follow this logic, because if I stub everything I test nothing.
And while you're adding the warning, maybe add some brief instructions for regenerating as well.
They cannot be directly compared as they do completely different things. Grape adds routing and controller behaviors that works well with API endpoints. While Blueprinter is solely focused on managing the presentation and serialization of JSON. Therefore, it's possible with minimum effort to use Blueprinter along with Grape since their functionalities are totally different.
I think if you are already using graphql, do please keep using it. Blueprinter was not meant to replace graphql. Blueprinter is focused on the presentation and serialization of ruby objects to JSON. Many Rails apps that has RESTful APIs tend to use some sort of presenter and serialization gem to help them manage their JSON schema. These gems are Active Model Serializers, Netflix's Fast JSON API, Rabl, Jbuilder, and now Blueprinter.
https://www.libhunt.com, https://ruby.libhunt.com ;)
Nice design!
My two small side projects apart from a full time job: https://abot.apki.io/ https://wishlist.apki.io/ 
Interesting idea, @ulfruinn. That info would have to come from the input files though, b/c the includer is just a dumb assembly mechanism (like the venerable cpp). I will suggest, though, that my user should consider such a thing.
Also considering two other runtime options: * timestamp: include a comment containing the generation-timestamp. * ingredients: include comment (at each include point) containing the path to the included file and its mtime). I think these should default to false. 
I'm very fond of [Sequel](https://github.com/jeremyevans/sequel). The documentation is very complete and once you learned the API, is very easy to use. If you want to look at DSL, [Sinatra](http://sinatrarb.com/) is a very good example. You could start almost immediately, but there is a lot of deep hidden below the surface, that allows powerful manipulations of routes and features of your app.
Nice website. Do you also publish the cms?
Alternatively, I would encourage you to give [tty-prompt](https://github.com/piotrmurach/tty-prompt) a try for a bit of a modern twist on terminal input gathering ;-)
So default to true? 
A method called tells a story: "john bought mary an icecream" is the right level of abstraction, but - "john, born on 1the 3th of february in the stormy night of 1987 bought mary, the third daughter of count vonnegut an icecream" is the wrong level of abstraction, it contains more information than is necessary. Same in this situation. The story that method wants to tell is simply about rendering the json to the client -- we don't need to also tell the story of how the client is created or how the serializer is created with the client. But -- if further exposition on those parts of the story is required -- then they're eminently accessible -- in the definitions for client and for client_serializer, as separate methods.
&gt; and will afford tests the ability to vary the database access implementation with one that doesn't actually hit the database. I'm not really interested in making the tests able to access the database. We have integration tests for that. So this whole point about being able to switch out a real db with a fake one doesn't matter to me.
Since it’s literally in the same class, it seems like relevant information to me. As a rule I keep controllers super slim to avoid the situation you describe. Also I see the same benefit of labeling a thing with a variable name that you get with a method. If it’s not relevant to you, it’s easy to skip over, but if it is, it’s far harder to jump up/down/around to get the answers to your questions. 
Alright let's agree to disagree:)
That's my point. My tests almost never hit the database. Unless I'm testing something that's supposed to hit the database, like a query object, for instance. Out of curiosity, do you have much testing experience outside of web apps?
Minitest is very clean and worth reading through as a good example of a DSL that doesn't do anything crazy.
The default should be verbose, with everything on. There should be an -optimized option to make the file as small as possible, if that ever matters.
[quicktype](https://app.quicktype.io?l=ruby) infers types from JSON data, then outputs Ruby, Swift, Objective-C, and code in other languages for reading that data. You can also input JSON Schema and GraphQL queries using our CLI. We just added Ruby output support today, and we're looking for feedback on the generated code, or what we could improve. I'm aware that this generated code is almost unrecognizable to the average Rubyist, but please understand what this code actually intends to do for you. `JSON.parse` is a lovely way to quickly load a hash from JSON, but quicktype's goal is to make your models much more systematic, automatic, and guaranteed to be the types you expect. That said, I would love any tips on how to make this code less overwhelming as long as it still meets those goals.
What is Ruby Together? I couldn't find Ind an explanation on the website? Maf be I missed it.
literally none .. i actually had a onsite at gopro for a SDET position ... I'm sure you can imagine how that went ;)
How do you create browser extensions with Ruby? Opal? 
Yep. That’s what I wanted to know. What a pity. 
To name and later refer to that name you'll need to use an array of hashes. The "name" will be the key of each hash. 
Don't. As soon as you're thinking about dynamically naming variables through code, there's a 99.9% chance you're on the wrong track. What problem are you having that this will solve?
looking at it as if its a big group of people on a stag party in a city and the bars only let in groups of 4. I want to - Gather everyones names in an array. shuffle that array. Split that array into small arrays of 4 people, then give each of them a name. Eg group-1, group-2 The only part of that i need to do is name each individual nested array 
Just because you want to name groups doesn't mean you want to name variables in your program. In your program, each group already has a "name", which is its index in the array. Why do you need to prefix that with "group"? If you need to generate output, you can do something like: groups = [[1,2,3,4], [5,6,7,8], [9,10,11,12]] groups.each.with_index { |group,index| puts "Group #{index+1}: #{group.join(', ')}" } And that will work. Alternatively, if you need to work with the name more often, you can do something like: groups.map.with_index { |group,index| {name: "Group #{index+1}", people: group } } and that will give you an array of hashes, where each hash has keys "name" and "people", like this: [ {:name=&gt;"Group 1", :people=&gt;[1, 2, 3, 4]} {:name=&gt;"Group 2", :people=&gt;[5, 6, 7, 8]} {:name=&gt;"Group 3", :people=&gt;[9, 10, 11, 12]} ] Which you can reuse.
 groups = [...] groups.each_with_index do |group, i| puts "Group #{i + 1}: #{group}" end There's no need to mess with dynamic variable names.
Well said, @jawdirk. Thanks.
Ooooh, just skimmed the readme while inhaling my coffee - me likey, and will have to give it a try once my brain can wake up. Thanks!
&gt; and needed to change later What you have done here is prematurely abstracted a concept into a method. I agree that the concept of "being valid" is a singular concept that might contain many pieces. But if it's not complex or used in other actions within the controller, then I agree with the OP that it should be inlined into the calling action.
What would you recommend in such larger scale cases ? The only option could be to seed a staging env resembling production as much as possible.
Pretty good write up, I'd love to know what kind of background tasks were being run, I'm assuming a lot of image resizing? &gt; the app had a history of love affairs with too many developers who paid little regard to what they were doing! &gt; The app should upload files directly to S3 without going through our backend - but it wasn’t done like this before we took over I've picked up way to many projects which upload files via Heroku to S3. Hopefully Active Storage stop that setup for good :D 
I've had good experiences using vagrant w/ puppet or docker images to simulate a stage environment w/ multiple different connected instances but will depend on your prod configuration.
$84K is of course probably _less_ than the full cost of a full time ops/devops person. Of course, there are benefits to the in-house expertise, especially if you are going to continue to scale. Around $84k of annual heroku costs is defintiely a point where I'd certainly recommend considering/evaluating other options, but it's not neccesarily a forgone conclusion that "saving" $84K/year is really a good trade-off, if it costs you extra labor. 
Depends on definition of premature I guess. I think the proper time for this abstraction is when the class is written.
Don't forget that $84k doesn't let you pay the person $84k, there are taxes, benefits, and other costs the employer has on top of salary. Most places budget the fully burdened cost of an employee at 1.5-2x salary. Which means $42k-$56k salary ... which doesn't seem like much for a good enough devops person to trust as a one-person show.
All is proceeding as jawdirk has foreseen.
Exactly, if you need to name arrays the use a hash of arrays.
+1 for nokogiri. Works great.
Totally understand that, and cheers for contributing a well-built, useful project to the community! My point was more that I've found graphql to be hands down the easiest way to start making incremental progress without a complete rebuild. If you're living with an app that's using an old version of activemodel serializers (or maybe some custom JSON presenters, or whatever)... trying to introduce another serializer library can be painful. Even just with simple things like "I already have a `PostSerializer`... what do I call my new post serializer?" or "do we create an entire new `V2` (or v3...) namespace for our API?" With graphql, it's all disconnected enough that you kinda have a new little sandbox within your app to start building. You define a few types, add a few query fields to your schema, and you're up and running in parallel with your existing API. Additionally, graphql does a great job of hitting all the points mentioned here - it's types are declarative, it's *fast* (like, ridiculously fast, especially when paired with batch loading from `graphql-batch`), documentation can be built directly from reading the schema, and it even provides the same flexibility as the blueprinter "views" without requiring any configuration (since the client asks for the data it needs, there's no extra endpoints for various formats or needing to specify which format you'd like to render)... And of course responses are all still in JSON format. Admittedly it changes things a bit, in the sense that everything is a `POST` to a single endpoint in the new world (though you can totally change that to mimic RESTful endpoints), and you have to send the query payload along instead of url query params (again, you can go against the standard and translate query params into a graph query if you really wanted), but it's generally super easy to modify whatever frontend client you're using (axios, jquery, etc.)... or just adopt something like apollo-client alongside it. The above doesn't really even begin to cover it, and I could rave all day about how happy I've been after making the switch in a few projects recently. Blueprinter looks great! If I'd found it a year or two ago it would have 100% replaced activemodel serializers for me... but after my recent experiences I'm pretty confident that GraphQL is going to "replace" JSON APIs the same way JSON "replaced" XML... so we might as well jump on board now :)
Method names don't tell stories. They either summarize what the method does, in the case of command methods, or they summarize the data returned, in the case of query methods. Local variable names also summarize data that is returned, but they have a tremendous advantage over private query methods -- they stay within the method they're used. This brings two tangible benefits. First, as the article mentions, my eyes don't have to move down to the bottom of the file, and second, they don't leave me with any question as to whether they're used anywhere else within the file. When I look at a private method, on the other hand, I have to search the whole file to determine everywhere it's used, simply because it _could_ be used anywhere. Private query methods offer little in return for their additional cognitive burden.
BTW.... I wish EVERYONE would click the "Sign" button at the top of this... I have been wanting this for 10 years...
PS... we used to have this at some vendor, but then they went all enterprise n stuff...
Some example gems: https://github.com/strzibny/invoice_printer https://github.com/fedora-ruby/gem-compare Example web app: https://www.gettandem.com/ Bonus: I didn't create this one but I think it's interesting. The company I work for has developed a Windows scanning client (supporting WIA). It runs in the background, communicate with scanners and expose an API fro the main app.
I have developed a web based tool using Rails primarily for Emergency Response Agencies called www.memberhub.com.au pretty much all of my users are volunteer based.
Didn't, it's literally first thing in Opal I made so it's probably completely wrong, but here you go: https://data.wolfsden.cz/stroke_order.tar.bz2 Let me know what you think :)
https://hostingweb.pe/
As many have mentioned ruby is lagging behind Python but there is a growing community and tool set. Daru and statsample are great examples. I recently started a machine learning gem similar to scikit-learn as well: https://github.com/dansbits/lurn 
Replicate your production database to a slave node, disconnect it from replication and play around with queries there.
I didn't say a method name tells a story i said a *method*, i.e the method body tells the story. And i disagree with you. I want to know what a method does, not how it does it. If it uses a client, good, i see it's using a client -- unless i'm rewriting the method i don't need to know how it constructs the client, i just need to know that it's using a client. I don't find it a burden to look down in the class to find how a client or client serializer is defined -- if you're making small classes (which you should) then this is minimal effort. I'm sure you're not the kind of person who has a method with 5 local assignments in it either, i bet you would extract some of those out to different methods. So we just have different thresholds for extraction, that's all. I can tolerate 1 local assignment in a method before i extract something, you can probably tolerate 2 or 3. Let's not argue any further, it's actually not a very interesting thing to argue about in the scheme of OOD :) 
so sick of creepy polish rubyists. Wish they would just stop and go annoy another community. 
Spinning up 3 ec2 instances and getting your app "cloud ready" so it behaves well on EC2 are two different things. The latter can be a multi-year process depending on the state of your code, it's not necessarily a trivial thing.
No, but have you ever met a polish guy in real life? they're dickheads. Admittedly i'm also a dickhead, but they're really typically slavic, that kind of blunt oblivious semi-autism. Unfortunately polish people are all over europe since their own country is so crappy.
You have to be at pretty large scale for it to be a problem. Even if you're database is 1TB it's not a major problem to restore a backup locally. If you don't have enough space on your laptop just grab 2TB SSD + USB 3 or thunderbolt enclosure off amazon, unless your running on bare metal it'll likely still be faster than your production box's disk.
Oh, it supports TLSv1.2 _after_ applying a patch... boy do I feel cheated. 
I get why people do this ... and not to diminish the work ... but I hate that this goes on and gets shared. It seems like the more workarounds like this get posted, the more packages keep compatibility with old rubies or old dependencies, etc .... the easier it is to justify not upgrading. And then it becomes impossible to upgrade, and then it becomes "mandatory" to keep everything compatible forever. And then we're the python 2 to python 3 transition ... and I don't want Ruby to become that.
Hi everyone, want to show you the meta_commit gem. Meta_commit is command line utility, which was built to experiment with the idea of generating commit messages. It all started as a try to build the tool which should reduce the time spent on the code review by summarizing the commit diff (So the user can perform fast high-level code check and don't have to read through raw git diffs). Why I posted it here : I think that it may be interesting to one of /r/ruby readers from development or even user perspective (and we can collaborate together) also, honestly, I'm interested in any feedback (opinions, contributions, issues, use cases). Especially this project may be interesting for people who want to : - get experience with gem developing - practice with cli ruby utilities - try different testing approach - rspec - cucumber (+ aruba) - get experience with refactoring methods (Actually, I would be very grateful for help with refactoring [of this parts](https://codeclimate.com/github/usernam3/meta_commit/issues?category=complexity&amp;engine_name%5B%5D=structure&amp;engine_name%5B%5D=duplication)) If you want to share opinion or add a feature and don’t know how or feel uncomfortable by opening pull request, please write DM to me or add a comment and we will discuss it and prepare the issue or PR together. Thank you for your time and reading up to this point, have a great day! To get more information please visit : - [github page](https://usernam3.github.io/meta_commit/) - [github repository](https://github.com/usernam3/meta_commit) - [asciinema demonstration](https://asciinema.org/a/P6kWCq2S4eOpMzEjOAKSHYmyv)
Ehh, generally I'd agree. However, I've seen a lot of insecurely configured EC2 instances.
As have I, but I haven't noticed any correlation between the insanity of an EC2 setup and wether the person whom committed said crimes came from an ops background or an developer background.
Head, do you mean the beginning of the file? I think most Markdown implementations allow for code-comments like: &lt;!-- GENERATED FILE - DO NOT EDIT --&gt; But I am actually not sure whether or not that would actually be rendered as output in the generated file.
Seems pretty useful. Thanks!
Why the use of the term "dynamic" instead of "primitive"?
At that point I would imagine downloading the snapshots becomes the pain point...
It could be depending on your internet connection. But @ 300mbit/s you can download 1TB in 8-9 hours. Set it up with the restore command to run when it's done and leave it overnight. If you're stuck on a slow internet connection, you can always just restore a snapshot to a one off EC2 node (or whatever you happen to be running on) and use that for testing. Everyone _should_ have restoring a database snapshot to a new machine automated anyway as it's a pretty critical thing to have in your pocket when shit hits the fan.
This is so cool!
I feel like I'm watching one of the Eve Super Battle recaps.
does fast-json-api internally using AMS(active model serialize)? I saw gemspec file, so are we adding some enhancement over AMS here?
Why do people still prefer to run old Rubies? The upgrade path is very easy and can be performed by anybody on the team.
I'm going to go against the sentiment here and say this is a great thing. Not every deployment scenario is using a Ruby version manager and is allowed to migrate easily. If your server is stuck with Cent OS 6 and you can't migrate and you must use distro Ruby, then you're stuck with 1.8.7 . And this TLS discontinuation will affect you. Glad there's a workaround.
&gt; handlers can be run synchronous and asynchronous, that is cool, do I need a custom server process to process the handlers? Or is it compatible with ActiveJob, Sidekiq and Resque? What type of setup do you require to get started? http://railseventstore.org/docs/subscribe/ mentions "Async handlers are just background jobs implemented with ActiveJob" and shows an example. &gt; If I publish an event, when is it run? Where is it run? What does is an event life look like? Hhmm, event is not run. Event is persisted and published to subscribers. &gt; I guess most people that checks out the project for the first time thinks: "What can it do for me?" and it needs to handle that. I think we try to list potential usecases on the 1st page http://railseventstore.org . Thanks for the feedback. I will copy-paste it into a github issue and see what we can do about it :)
You can try to combine `tk` and `ocra`. At least for me it works reasonably well.
FXRuby and ocra works for me.
Always been a fan of Shoes. http://shoesrb.com/
Official documentation. What else?
You may be interested in comparing this with https://github.com/chad/turbulence
But if you're doing this - you're no longer running the CentOS package'd ruby - you're running one you built. And if you're not actually running the distro-packaged ruby, why not upgrade while you're at it?
A few resources that I like: http://rubykoans.com/ https://rubymonk.com/learning/books/1-ruby-primer https://learnrubythehardway.org/book/ http://tryruby.org/levels/1/challenges/0 https://www.bloc.io/ruby-warrior#/ You should start with a MOOC from someone like Codecademy or Udemy, go into the resources above and the last (essential) step is that you need to build stuff with Ruby. The official doc is goos for reference, but I find it a bit dry.
On [Buhos](https://github.com/clbustos/buhos), I use a local web server and works very fine on Windows.
What is this in reference to?
Hah, probably should have clarified that. When I used the tool, it generated code with method names like `from_dynamic` that take raw hash/primitives and returned JSON, for instance.
Nice! Thanks for sharing that one :)
The upgrade path can be very easy or very difficult, depending on the size and complexity of the app you're working on. It is definitely not accurate to say it's easy and can be performed by anybody on the team.
It may not be easy, but it's easier than for any other mainstream language I can imagine. Ruby doesn't have too many breaking changes despite the major version bump. As long as you upgrade your Ruby every couple years, it should be easy peasy. Of course, if you are lazy it's going to be a pain in the ass, but by that time it's your own fault and you shouldn't be expecting gem authors supporting your ancient installation. P.S. Why can't banks upgrade? They are especially interested in that because they want latest security patches. Running old software may lead to trouble.
Cool
This. Understanding what a commit does is pretty obvious when looking at a diff but understanding why it was done in the first place and sometimes why this way instead of a less obvious way should be in the commit message. Pulling out a one year old git blame just to see as commit message what you can understand in the diff will make u hate that committer at that given moment.
https://apidock.com/ruby/Hash https://apidock.com/ruby/Enumerable/map https://apidock.com/ruby/Enumerable/max
Thank you! 
Pardon my snark, but ... A really good answer is in the right column →
Pardon my snark, but ... A really good answer is in the right column →
I wasn't advocating necessarily this patch (I do mention distro ruby), but I am in principle for work arounds which allow me to keep stable software surviving senseless discontinuations like the rubygems tls1.0 and tls1.1 support drop. Doing it while having to live with rbenv is a better compromise than upgrading to ruby 2.x just because.
Does anything rule out a simple Rack / Sinatra (or even Rails) app running locally? Is the "Native UI" a strict requirement?
Honestly I'd take some problem you want to fix and do it with ruby. use the books &amp; blogs &amp; docs to figure out how to do what you want to do, then rinse &amp; repeat for larger projects. Write something to verify backups you're doing, or perform them, or a simple reddit bot that edits all the links you've posted people to instead rickroll them. Or a script that checks your various streaming services APIs for a film so you don't have to fire up 4 tabs to check *every time*.
Thanks a lot, I'll try these! 😃
The best online courses I've taken for both Ruby and Ruby On Rails are offered by Pragmatic Studio (https://pragmaticstudio.com/courses/ruby). They're not cheap by any means, but their methodology worked best for me. Other than that, once I have a basic understanding of a tool or language, the best way for me to learn further is to solve a practical problem with it. [](/GNU Terry Pratchett)
lol your english is weird even in a blog post. You make a typical slavic mistake of leaving out articles. I'm not going to pay for a book written in messed up english. Also your tests look whack, so much noise in each test. Your "story" is babbling in a noisy room.
I've used RubyShip in the past. Worked fine.
The first "badly designed test" is the correct way to structure rspec. If you had the same expectations in both versions and more than one context you would see that the first version is more concise and easier to understand. Your story version is the test unit way of writing tests.
I recommend using threads. That way you can learn concurrently! 
&gt; Meta_commit is command line utility No. Please, you are forgetting the article 'a', rewrite your sentence as: &gt; Meta_commit is **a** command line utility
https://poignant.guide/ Or the Pragmatig Programmer’s book Though to learn the real thing, the best is that you start to work on project and learn by doing
There are multiple ways to solve the problem using the objects and methods suggested above. Here's one: 1. Store the name and value for each response in a hash. 2. Add each hash to an array. 3. Create a new array with the multiplied totals by calling `map` on the array and adjusting the value of each hash. 4. Find the maximum value by calling `max` on the new array with a block that contains the test to compare hashes to determine which is 'bigger'. 
We just use the adjective 'dynamic' in other quicktype-generated code to refer to untyped data. I'm open to renaming this in the Ruby output if something else is better for Ruby!
We just use the adjective 'dynamic' in other quicktype-generated code to refer to untyped data. I'm open to renaming this in the Ruby output if something else is better for Ruby!
Pain
C-x M-c M-butterfly 
thanks for the answer , I'll check it out shopify tomorrow.
would you recommend spree , or have you seen any drawback? Its easy to customize for you needs?
We use spree. It's fine. If you can do shopofy, do that. One point of warning about solidus, it's primary sponsor, bonobos (who did the original fork and still do the primary development ) were recently acquired by Walmart - leaving is future some what in doubt. 
A simple Rails app, sure. You don't migrate a complicated app with heavy traffic in an afternoon or even in a single week of a single engineer's time, though. In the best-case scenario, you're only copying over dynos, but realistically you're probably also moving various data stores — as they did in this example. For every server type, you have to have a reasonable estimate of how much horsepower to put behind it. You can make rough comparisons for a lot of things (X PL dynos ~~ Y m4.larges or whatever), but the accuracy of your estimate for how much computing power you need won't be apparent until your app is under load (possibly several hours _after_ the new fleet has been in production), at which point it's not just a matter of seconds to spin up more web juice. Provisioning another EC2 instance, loading dependencies and your app, and connecting it to the load balancer could take several minutes _if_ proper automation is in place. If this is for your Sidekiq consumers, this could result in a backlog of millions of extra jobs — and hopefully you have prioritized queues for this case. If it's for your app servers, how this plays out in production depends on so many factors _that you must prepare for up front_. For example, how will you kill long-running requests that are now blocking new ones? Your load balancer can kill the request itself but it may still be running at the app layer due to long-running SQL queries. Even if you don't underestimate required compute power for app servers, Sidekiq consumers, databases, etc, you need to run scenarios for the migration to ensure that, after the operation, everything still works as it did. You also need to ensure that making changes to the infrastructure — adding a new app server, decommissioning underpowered ones, adding DB replicas, DB failover, etc — are working. You have to overprepare when a few minutes of unexpected downtime can cost your company or client 6 figures instead of saving them 5. If they're not willing to pay for that kind of preparation, you get an indemnity clause added to the contract, but to quote a week to a potential client you can migrate their entire infrastructure because they tell you they need 3 EC2 boxes is at best naive and at worst irresponsible.
I love it!
I don't think ruby has true threading?
I'm not exactly sure what it is your arguing against here. We're not talking about some complex architecture, nor did I claim they such things don't exist. Nor is this a scenario where some random client has told a contractor their shit will fit in 3 EC2 boxes, nor is it a scenario where a few minutes of down times cost them 6 figures. Most of what you've said is fine, but has no bearing what-so-ever on the article, are we even talking about the same article? 
Only one thread will be running at a time with MRI, even on systems with multiple cores, because of MRI's global interpreter lock. However, the standard Ruby [Thread](http://ruby-doc.org/core-2.5.0/Thread.html) class gives true threads when run run on [the JVM](http://jruby.org/).
I'd recommend it, I can't say I'd recommend it _over_ Solidus as I haven't used it. While I'm only using the API and backed portion of Spree, I've experienced no real issues other than the docs being a bit spotty. Overriding stuff is a bit ghetto with `class_eval` (supposedly fixing this is one of Solidus' goals) but it works. Oh, one or complaint would be the metric ton of DB queries it does to process things, but if you sufficient hardware is shouldn't be an issue.
Thank you for the fix, unfortunately, I can't edit it now
Hello, yesterday's Hyperledger talk notes titled [Blockchain vs (Hyper) Ledger -- Inside (Hyper) Ledger Lite - Add Transactions One Block at a Time and Balance the Accounts (Books) with Ruby](https://github.com/geraldb/talks/blob/master/hyperledger.md). Cheers. Prost. PS: What's your (favorite) way or (what libraries/gems to use) to build / design / write blockchains / transactions in Ruby?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [geraldb/talks/.../**hyperledger.md** (master → 5413d40)](https://github.com/geraldb/talks/blob/5413d4017559ebb898eb3f95eba5198214713973/hyperledger.md) ---- 
Hey thanks for pinging me. Yeah Traveling Ruby can be used for lots of use cases. But not knowing whether enough people are interested in Traveling Ruby is just one of the reason I'm not currently maintaining it. The other reason is that I don't believe it is profitable enough (even if there is user interest). I need to pay the bills after all.