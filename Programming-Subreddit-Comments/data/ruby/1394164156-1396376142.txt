You have a great time limiting your tool chain for whatever arbitrary reason you like. I'll continue using and recommending tools that are effective and make life easier. Corporate tool or not.
Yeah, I buy that. If someone doesn't eventually show *any* interest in how the system underneath works, they're probably not going to really be able to drive software/engineering decisions. I think my disagreement was around the need to *start* with something like sinatra.
I prefer sublime text. Personally I think that people shouldn't use IDEs until they know how to use a command line first. I have seen quite a few junior devs freeze up when asked to ssh to a box because they depended wholly on point and click interfaces. Down voting does not make this point any less valid. 
Upvoted. Love it.
Thanks a ton! And I am an idiot. Can't believe that I missed that.
Wouldn't run on my OS X Mavericks find app -type f -name *.rb -print0 | xargs -L1 sed -i '' -e "s/old_method/new_method/" This worked, also added global to the pattern find app -type f -name "*.rb" | xargs -L1 sed -i '' -e "s/old_method/new_method/g" Seriously, piping to xargs? Also, the `find` tool sucks for this kind of search and replace because EVERY FILE GETS OVERWRITTEN. Git sees that each file has been updated and they all get their permissions and descriptors f'ed up. grep -Rl def app/**/*.rb -Z | xargs -L1 sed -i '' 's/old_method/new_method/g' All of this ignores the simple fact of trying to rename a method named "find" is impossible using this technique. Unless you want to go and troll the the 1,000,000 files that have been modified because of the vague search pattern. Seriously, saying that you won't use RubyMine because it's a corporate tool or whatever is ridiculous. It has context-aware code refactoring tools. Use them, it's like $75 bucks or free if you do F/OSS. Seriously. [Why not Zoidberg?](http://i.imgur.com/AmLbcim.jpg) Oh, and edited just for this.... :args app/**/*.rb :argdo s/old_method/new_method/g VIM! 
Thanks. That syntax seemed like the obvious thing to do. When I started I was surprised that no one else had thought of it. Although recently I've changed it to allow 3.meters.inch because I got tired of writing to_ everywhere and the intent seemed clear enough. I suspect I haven't pushed those changes yet...I'll have to look. I like the idea of letting someone else handle maintaining the units database. That was one of the things that was discouraging me from working on the gem more. Well, that and other priorities. Maybe I'll 'borrow' that from you :) It looks like you perform unit conversions right away when doing arithmetic with unlike units (although I didn't look closely). Have you looked into using some sort of futures object for the result instead of doing the conversion right away? I'm toying with implementing that because my use cases don't always immediately know which unit is the desired unit. 
THAT'S A GIANT FUKKEN HASSLE. Y U DO SO MUCH WORK?!
Thanks for the link. Rubygems lists a lot more of them if you want to make your post really long. But you got the two most important ones, so why bother? :)
Now that's just being mean. [EDIT] Really? Downvotes. WTF? Or do I need to spell out... SARCASM. It was a joke. They were joking and I played off that. Lame.
Forget JavaScript, how about pure C Ruby? http://crystal-lang.org/
rake has a thread pool! require 'rake' pool = Rake::ThreadPool.new 2 4.times do |i| pool.future do sleep rand puts "Job #{i} finished by thread #{Thread.current.object_id}" end end at_exit { pool.join } Job 0 finished by thread 22218620 Job 2 finished by thread 22218620 Job 3 finished by thread 22218620 Job 1 finished by thread 22218200
Sequel
Don't worry about missing some "simple" things like this from time to time. Sometimes a few simple things can catch some programmers who have been doing it for years. Though... you do get much better with practice!
So I did a basic Sinatra tutorial, and it helped me grok controllers much better than when I was just throw into it with Rails tutorials. That said, can you give any more insight into the limitations of Sinatra? Are you able to create basic apps with database components easily enough? I am a novice at this stuff, so just trying to find examples of projects that would be a great fit for Sinatra vs. Rails.
The flip argument is that people will leave if enough posts are questions and not something of interest to normal ruby dev. To be honest, it's shy I subscribe to r/ruby and not r/rails. 
/r/rails ***** ^This ^is ^an [^automated ^bot](http://github.com/WinneonSword/LFB)^. ^For ^reporting ^**problems**, ^contact ^/u/WinneonSword.
It is dead easy - I had used DataMapper and had 0 problems making everything work, even though it is kinda outdated and inactive project. Furthermore, ActiveRecord is just a gem, so you may just use it in sinatra projects. The only thing I had issues with is, coming from rails, there are no strict conventions or architectural decisions already defined, so it is easy to make a mess out of architecture - that is not something I blame sinatra, but rather myself. Actually, that kinda is the point of using sinatra. On the other hand, I wish there were more comprehensive resources available on how to make modular sinatra apps.
This is helpful, thanks. What do you mean by architecture? What are some things you've messed up?
A blog post about this script http://patrickperey.com/find-anyones-email-a-ruby-script/
I use it and am a huge fan, but I must point out that if you don't use the application their way, you're going to run into all kinds of weird-ass edge cases. For instance, if you're using ActiveRecord in a non-rails project, their integration with AR models does not work correctly unless you trick the IDE into thinking you're on a rails project. (By creating a couple of empty files). There's an open bug to this day about bogus inspection messages being thrown when you load in a YML file (and being a bit obsessive about warnings, this is downright infuriating since the same inspection responsible for the bogus message is the same one that tells you when you've referenced something that doesn't exist) #It looks like this require 'yaml' conf = YAML.load(File.read('./somefile.yml')) &lt;--- Warning highlighted Don't get me wrong, RM is still awesome, but JetBrains could use better support. You pay them the $60 for a personal license and this gets you the same ticket/forum setup that every FOSS project ever has.
Good, but dog slow compared to a text editor, quelle surprise. Obviously, as a full-on IDE it indexes and monitors your project for changes, is busy running your code in the background, checking constantly for syntax errors, etc. I don't like anywhere near as much as Vim + Tmux for being able to have my code split screen and guard running next to it, plus a shell, and the fact that it uses so much energy when not in power-save mode, but it does integrate with Teamcity and issue trackers. I've found some things can be a real ballache to setup, like Spork or Guard, but it's all possible. There's a lot more time wasted fiddling with things than writing code, but if you like procrastinating, it's all good. Eclipse is a horror compared to Jetbrains products.
There are business licences as well. The first guy in our office to get it the company didn't realise this and he got a personal licence which he took with him when he left. With me they got a company licence, which I am allowed to use but is not tied to me in any way. Then I started doing Java dev as well and bought myself a copy of IntelliJ anyway. I just use the ruby plugin for that instead of RubyMine directly.
Indents are inconsistent in some places. Should use 2 or 4 spaces. For YAML, you currently have key-value pairs like this: "a": "b" "c": "d" YAML is really relaxed since it's designed to be human writable and readable, so you can just do this instead: a: b c: d 
Subscribed. Whether people are asking questions here or there, I hope to try answering some of them.
How does Opal protect against JavaScript's [odd semantics](https://www.destroyallsoftware.com/talks/wat)?
What you are describing is not what an NDA does.
So I can run out an buy a license anyway when I change employers? It's not terribly expensive and it's something I use for my own projects.
**do you know how I could do that?**
Install discourse :) http://www.discourse.org/
Also, refrain from copy-pasting tutorial code. You're doing yourself a disservice. Try to type out every line and at least give a second of time to make sense of that line. If you weren't copy-pasting, then all's well! Keep up the good work, and enjoy learning Ruby :)
Would YOU be willing to write something about your sinatra project organisation? I believe it would be a very helpful resource. I'd do it myself, but unfortunately still haven't got much beyond "OK, this is bad".
I can certainly try to put something together this weekend. If I'm successful I'll post a link here.
Why migrating to RubyMine instead of keeping IntelliJ with the ruby plugin? In the latter case you don't need to buy a new software, and can also work with other languages (Python, PHP, etc.). The only exception is ObjC, where you need to buy the separate app.
I moved jobs, and didn't own a personal IntelliJ licence.
I've never done that, I've to admit. Here are the [docs about submitting](https://sublime.wbond.net/docs/submitting_a_package). Thank you :)
rvm is one of the most overengineered pieces of software I've ever came across, even rbenv is not doing it for me these days - right now I'm just using system ruby. As per gemsets: you should try [gst](https://github.com/tonchis/gst), much simpler, works like a charm.
Yes, its not that easy. E.g. / at the end means: directory. And / in between is path separation, which is system dependant. 
Cool. Okay, I ran find app -type f -name "*.rb" -print0 | xargs -0 -L1 sed -i '' -e "s/def/new_method/" It still causes every file to be seen as modified in Git and all of the files get their modified timestamps reset. You are correct though about the permissions, they stayed the same so that was an incorrect assumption on my part. I stand by my assertion that one should have a variety of tools in their box. From industrial grade tools to fundament system tools and everything in-between. Being able to discern when the appropriate tool is going to work the best is what separates us professionals from the plebes. Using a refactoring capable tool like Eclipse, IntelliJ (base of RubyMine), Visual Studio, etc. still has a place in my toolbox because they are capable of very advanced operations that given a sufficiently large codebase become essential to me. They provide a large suite of functionality that's not just limited to the one case of changing a word, which is why I still think that RubyMine is something every Rubyist should have ready at their disposal. It does a lot of things and it does a lot better job of even this one simple example as well.
He says his consultancy agreement includes a confidentiality clause. So why does he need to sign *your* NDA? He's going to need to read it and make sure it doesn't cause him problem down the road. He doesn't want to do that. So, if you insist, that'll be $3k, most of which will go to the lawyer he'll get to read it.
That would be awesome and I'd love to read it.
Weird, for me, I can use `sed -i` on files and unless they actually change, git doesn't recognize any change whatsoever. And I'm not saying that RubyMine isn't a fine tool; I am personally big into refactoring and was curious about what the tool was. It turns it in this case it didn't feel like a tremendous win, but it was good education for me.
I've looked at it but it messes with my `$GEM_HOME` and other env variables that I'd rather be left to my other tools, but I heard it's pretty good if you don't mind that. Thanks for the heads-up :) 
....but why?
I'll second what one other commenter has said so far: why? I did find it kind of entertaining, though.
Your second sentence answers your first.
I rather like [this](https://github.com/vanruby/canada) from the same guys.
You have 400GB of data and you were not sure what over 300GB of it was? Jesus.
Because Enterpriseâ„¢
Did you use gemsets? Because every time you use a gemset (and install i.e. a rails project) all gems get installed there. So for each normal sized project you'd have duplicate gems all over the place due to gemsets.
first the canada gem, now this. I love the direction vanruby is going.
Say a user is generating some geometry and does something like '3.meters + 4.inches'. Should the result be in meters or inches? Most of the time it's probably ok to default to one or the other and the user won't know the difference. But, if the user is going to output the results somewhere, say to a DXF file, all of the values will need to be converted to common units (typically either inches or millimeters for DXF). In that case, defaulting to one unit or the other might be premature. Why bother converting it right away if it's going to be converted again on output? To deal with that situation, I've been thinking about wrapping the output of operations-on-unlike-units in something akin to a [future](http://en.wikipedia.org/wiki/Futures_and_promises) object. Later, when the values are to be written out, the object converts everything to the desired unit and returns the result of the original operation. Granted, that's not really what futures are generally used for, but it seemed like the easiest way to describe what I'm getting at.
 $ du -hs ~/.gem 2,2G /home/yorickpeterse/.gem $ du -hs ~/.rubies/ 1,4G /home/yorickpeterse/.rubies/ 300 GB of Gems seems rather unlikely to me, but it could be the case. 
Maybe they aim to implement it in jruby?
No, it's more like, I have 600 GB of data, 300 GB of apps...and after the system overhaul, 300GB from somewhere... Actually, now that I think about it, it *might* have been from the clearing of RVM. I did a rm -rf ~/.rvm and it was taking a very long time...but as it was progressing, the OSX Finder memory displayer was only showing it clearing up at a rate of a few hundred MB at slow intervals, so I figured there were a lot of (small) files. I even stopped the `rm` process because it was taking so long -- after about 10 minutes, only about 2GB had freed up. So I then restarted the `rm` and went out for the day. I didn't think to look at how much memory cleared up right afterwards, though, and only noticed my free space amount a couple days later. But maybe Finder was just taking awhile to count the freed up GB?
Search for "glob to regexp". There are many custom parsers that convert from path glob to regular expression. Could probably roll your own using [Parslet](http://kschiess.github.io/parslet/).
Nothing wrong with system Ruby. OSX users developed this phobia towards system ruby due to Apple shipping 1.8.7 for years. They turned to RVM as a solution to install a modern default version of Ruby. Now that almost every OS has updated their version of Ruby, system Ruby is quite nice. For example on Fedora, ruby is 2.0.0-p353 and `gem install` does not require `sudo`. If you need to upgrade system Ruby, just install into `/usr/local`. If you need to switch between multiple Ruby versions, then [RVM](http://rvm.io/), [rbenv](https://github.com/sstephenson/rbenv#readme), [chruby](https://github.com/postmodern/chruby#readme) make sense.
Note: chruby will override `GEM_HOME`, but will only prepend to `PATH` and `GEM_PATH`.
Sounds like you didn't actually install it. Your program was told to USE it, but you never installed it. Join us over at /r/askruby for questions like this! 
Ah, thanks for the search terms! I found this gem (har): https://rubygems.org/gems/stringglob No README, but hopefully this is exactly what I needed.
Thanks!
Thanks!
I agree. I come to /r/ruby to find something that interests me about my favorite language, not answer basic questions about programming.
I assume your data structure is parsed from the XML. According to what I'm seeing [here](http://thetvdb.com/wiki/index.php?title=Programmers_API), you should be using friends['Data']['Episode'].each ...
Thanks for the suggestions. Added! 
I was always really interested in the prawn gem. Its a PDF generator, got abandoned then recently revived.
Is their Ruby/Rails stuff up to date?
Article looks interesting, but on Ubuntu 12.04 LTS and using Firefox the formatting is all out of whack
https://github.com/calabash ? I've been looking to contribute to this project.
For a while I used a local fork which patched that out, but I stopped using it because it just didn't get in the way.
I have ~75 projects checked out. Multiple ruby versions and many gem sets. du -hs ~/.rvm 13G /Users/dvito/.rvm
Thanks! I've actually shelved this project for a while and I'm thinking of just open sourcing what I have so far. Would you be interested in taking a look?
IUseRhetoric's answer is totally correct, but lemme interject an opinion: wrap the api response in an object and do all of your data processing within the object or other collaborator objects, e.g. SeriesResponse and other relevant objects It's much cleaner to do something like series.each_episode do |episode| print "TITLE: #{episode.title}" print "AIRED DATE: #{episode.aired_date}" end 
I use vim on osx. Ubuntu might be a good idea, and vim isn't very friendly to newcomers but you might like sublime text
Definitely, I've been typing everything manually. Although this time was the worst (in terms of doing absurd stuff like imploding rvm), it's huge in me being aware of a mistake I'll make on my own.
Speed. Ease of deploy. Efficient use of memory. Flexibility. The community needs to ask itself this question. Why isn't there a market leading cms, erp, document management system, etc in rails. Hell why isn't there a market leading blog platform? There is a reason why all the rails projects are anemic and simple. 
I also discovered the thread gem, which also gives thread pools, as well as some other stuff (simple to use pipes, promises, etc)
That is an excellent editor. I picked ST for two reasons: Lots of plugins, and cross platform.
Cool. So I'm downloading Ubuntu now. From what I've been reading IDEs are the easy way out and a beginner should skip them. I am a completely new to programming.
On one hand, I love the abstractions and conventions that Rails provides. On another hand, I really hate it sometimes. It's not always obvious what you've got to do to get really customized functionality out of a Rails app, such as setting up the asset pipeline to work with an AngularJS based SPA, or setting up more modular stylesheets when your scss starts getting huge. Also the speed of the framework is, well, slow. I've experimented with a hello world written in Vibe.d and Rails, and typically the Vibe.d is an order of magnitude faster just to get a response to the browser (we're talking 1ms in Vibe.d vs 10ms or so minimum for a Rails app). Part of this is just because Ruby is a very flexible dynamic language, and part of it is the many layers of abstraction that Rails puts a request through. 
Sublime Text 2 or 3, with Vintage Mode I've tried IDEs for Ruby, but I find they get in the way rather than help most of the time (this applies to any scripting language that I use)
Did you mean redmine? Rubymine is an IDE for Ruby/Rails, and redmine is an open source project management tool written in rails, no? Good list though.
You probably don't need a full blown IDE when you're starting out learning or working on small projects. IDE's themselves have a learning curve. Honestly just find a simple editor and use that, run the program from the command line. It's probably going to be messy enough juggling windows and ruby version managers together. I use vim and OSX/Ubuntu even on large projects.
Yeah I did, thanks for catching that. There are some others out there, like Gitorius, and some that are slipping my mind. I'll update the list as I think of them
Sounds goofy, yes, but when I'm doing code reviews for any school projects if I'm using rails -- It's hard to explain some things because of all the magic going on, so I guess understanding the rails magic can be frustrating sometimes.
On Windows, RubyMine is a great option. Sublime Text is great as a straight editor.
vim is not an IDE though.
Great list, btw. If Github doesn't make the case for Ruby/Rails, I don't know what would.
Thanks! 
Cool. Appreciate the help.
Thanks!
fwiw, Vintageous seems to be a better vim-style for ST3, imho. More key bindings out of the box, still doing updates for deeper vim features, etc.
Do you have access to the component that did the searches that these logs are from? Then it would make most sense to feed each of those search strings into that component once, and if there is a confident match, use the title from that match to retrieve the canonical title for each search term.
Unfortunately, I don't. I only have a CSV file with the search entries.
Do you know what kind of search system it is?
I don't know that either. I'm just working with the CSV that I was able to export through the "Search Terms" user behavior section of Google Analytics. The "Search Terms" tool in GA tells me what users put into the search box by by parsing out each entry of my-site.com/search?q= with whatever is after the "search?q=" portion.
* Discourse 
I have use Netbeans a little I haven't done much more then take a class in ROR though. There is a bundle install for windows that installs Ruby in one DL http://www.techotopia.com/index.php/Getting_and_Installing_Ruby#Ruby_on_Microsoft_Windows
This. If you take the time to look through all the middleware bundled in stock rails plus everything the router does, it's not hard to understand why Rails is slow at "hello, world."
Here's how I would do something like that. class FooStruct def initialize(attrs) # Create a Singleton Class (Anonymous Class) inheriting from FooStruct klass = ( class &lt;&lt; self; self; end ) # Loop through the attributes attrs.each do |attr| # Within the context of the anonymous class... klass.class_eval do # Define accessors for each of the attributes attr_accessor attr.to_sym end end end end
First things first: yes, it is possible. Pretty much all programming languages are turing complete which means that they can all do the same stuff. The difference is just that some languages make some tasks easier to solve than others. An implementation for the Levenshtein Distance can be found at http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Ruby For grouping, there are several methods you might have to try multiple ones to see what fits your needs. Something with K-Means clustering might work if you use the Levenshtein Distance as a distance function.
you have to require 'gemname' with quotes. Can you post the code of quit.rb?
I just played around with your data and noticed something you should keep in mind: when you deal with reordered words, the levenshtein distance will not work as expected. My first idea was to just sort the word alphabetically but that obviously creates even more problems when you have misspellings.
You can also make a rails app that doesn't have all the middleware and everything else. [Single-file rails apps, for example](http://rkistner.github.io/ruby/2013/05/03/single-file-rails/)
Which one of those is in the same league as word press or drupal?
Github is built with much more than rails. They also make heavy use of Erlang and other languages.
I don't think you understand what rails is for. Drupal and Wordpress are what you use to make mostly insignificant websites, that mostly look the same and do the same things. Ruby on Rails, and most other frameworks, are what you use to make large complex sites, designed to do very specific things, with a minimum of bullshit. Things like Groupon, Urban Dictionay, Twitter, New York Times, Github, and so forth. They expect you to know a lot more about web technology, and make doing more complex things easier. Wordpress and Drupal let you quickly put up a fairly simple website, with a moderate amount of customization. Rails lets you build a complex website simply. Wordpress is a set of legos. Rails is raw construction materials. You can build a house out of either, but the rails one can get bigger much easier, at much lower costs. ---- Tl:dr; github, refinerycms, or gitlab
Writing modular, service oriented stuff in rails isn't against the rules, which makes getting to write parts of your app in Erlang another plus for rails.
This has nothing to do with editors, but imho Ruby is the wrong introductory language.
Somethings just don't work on Windows. Some gems for instance, like Zeus server, won't work out of the box because Windows doesn't support pseudo terminals. There's a gem that provides a workaround but it only works with ruby 2.0+. Lots of things like this. Sometimes there's a fix. Sometimes there isn't. It's not really that big of a deal if you ALSO have a Linux box. With Ubuntu look for the LTS releases and stay away from Wubi as it has performance issues. You can run Ubuntu within Windows using VirtualBox. I have a laptop and a server that both dual-boot Win7/Ubuntu. Both have Sublime Text and RubyMine. I mostly use Sublime Text and RubyMine but if I'm at a command line or editing a file outside of the project I'll use Vim or Notepad++. Sometimes I'm working in Sublime Text and want to use RubyMine's code intelligence tools. I might switch right then or wait for the next time I get up and return. Sometimes I'm in Ubuntu and try to install something cool and break everything because of my stupid video drivers. I might use Windows for a week just out of irritation. I would note though, I think it's easier to learn with an editor like Sublime Text and a terminal. RubyMine is really nice but if you're clicking buttons that run rake tasks and migrations, and you don't know how to do this without the IDE, you're missing a bunch. For the record, Sublime Text is sort of a pseudo-IDE. It looks and acts for the most part like an editor but is extensible and has a huge selection of massively powerful (and open source) plugins that let it act like an IDE in many ways. I would miss anything you took from me. But I would miss Ubuntu/RubyMine the most. Like I said though, I wouldn't advise anyone new to use RubyMine exclusively.
I have to disagree. I use sublime + pry + rials c + etc. They work amazingly. The IDE is all integrated. Making it a touch easier to start. That being said, using an editor + pry + rails c is better than an IDE for develoent IMO. If you are looking for an IDE, Ruby Mine is the best I have found for ruby/rails. 
I don't think I follow your comment, are you saying that `sublime + pry + rails c + etc` is an IDE? And that's why you disagree with my comment? If not you seem to disagree with my comment and then go on to agree with it.
Thanks! I'm going to try this out and get back to you with my results / if I have any questions!
&gt;Drupal and Wordpress are what you use to make mostly insignificant websites, that mostly look the same and do the same things. They are applications written in PHP. Why aren't there applications written in Rails which are as functional or useful? &gt;Tl:dr; github, refinerycms, or gitlab Have you used any of those apps? Have you downloaded github and used it to create a multi tenant blogging platform? Have you downloaded and used refinery for something useful? I have. Trust me drupal is ten thousand times better than refinery. 
&gt; Why aren't there applications written in Rails which are as functional or useful? Because rails isn't for idiots. Its for people who know how a web stack works, and want to assemble a bespoke application or product that serves a specific purpose. Not for people who want to stick bits of brick-a-brack together and reach something that resembles a cohesive website. &gt; used it to create a multi tenant blogging platform? No, I've built Multi-tenant blogging platforms in plain old rails. No need to download anything, apart from a few gems, that I could honestly do without, should I have to. And this question is as disingenuous as asking "DID YOU DOWNLOAD IntelliJ TO PAINT A HOUSE?" If Wordpress/Drupal are so fucking bloody great, why isn't everything built with them? Why isn't Google built with Drupal? Why doesn't reddit use wordpress?
Rails != Ruby Ruby is to Rails as PHP is to Laravel/Symfony/etc.
Kind of what I meant by service oriented, but hey.
real time
Interesting, especially rulog. I've just started a coursera mooc on [discrete optimization](https://class.coursera.org/optimization-002) and need a constraint engine - any comments on how suitable rulog might be per chance?
The best way to decide is to break your code to pieces which each piece represent a functionality. for example , If you want to create a web application that contains a blog section, an authentication section, an admin interface and a real-time chat system (there are lots of useful gem for these, but suppose there are not). You can implement each of these feature as an engine and keep your application related structure in your application. with this approach you can easily upgrade and develop each subsystem without others. tell me what exactly you want to do so I can be more useful
Re Ubuntu I would suggest using that instead of Windows. Most tutorials and lessons out there on Ruby/Rails assume that you are on OS X or Linux. Maybe a few months down the road you will learn how to set up your own servers, and those are usually Linux-based. So at least you get up to speed. The beauty of learning a new OS (at least for me when I switched from Windows 7 to OS X) was that since everything was new I had no bad habits and I have pretty much used OS X with the command line open in another window. Since I've been using Windows since I was a kid it was hard to let go of the whole GUI thing, but in OS X I was able to learn the command line faster than if I stayed in Windows. Re editor I started with Netbeans of all things. That's a full-fledged IDE. It was really slow. I transferred to Sublime Text because it was more "Rubyish" (only in the sense that there were tutorials for it). Now I'm learning Vim, which is unintuitive at first but after one pass through it's tutorial everything will make sense. It's excruciating at first but you'll get the hang of it, welcome to Ruby! :)
I really don't want to troll; i'm just as [serious] as the OP :) I've been using the Yesod[1] framework for some time now and the things I miss most when coming back to Rails are: 1. a proper type-system (like the HM-system[2] Haskell employs) 2. the performance and reduced complexity of a binary app To elaborate on point 2. I find that performance is becoming a stronger requirement, both to reduce resources (hosting costs) and to push out that response 100ms faster. With Rails this is possible to by adding more services (ie.: memcached or varnishd), which is often not needed when the app is fast in the first place. Just my 2ct. [1]: http://yesodweb.com [2]: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system 
My vote goes to the linux version of homebrew: https://github.com/Homebrew/linuxbrew It's especially awesome if you have a shell account without root.
&gt;Because rails isn't for idiots. Its for people who know how a web stack works, and want to assemble a bespoke application or product that serves a specific purpose. Or maybe, just maybe it's not possible to do it in rails. There have been attempts after all and they have all fallen by the wayside. &gt;Not for people who want to stick bits of brick-a-brack together and reach something that resembles a cohesive website. You don't get it. There is nothing like wordpress or drupal which is written in rails. &gt;If Wordpress/Drupal are so fucking bloody great, why isn't everything built with them? Do you have any idea how many sites are built with them? 
Not possible and not done aren't the same thing. Yes, ruby, and rails, aren't as idiot friendly as plop on a $5 shared host and go. That's by design. Requiring some design and forethought aren't flaws. Children build forts and houses out of Lego, yet the construction industry doesn't seem to build houses out of Lego You're also right, there is nothing like Drupal. It's not fucking needed. I'll use the metaphor again. Drupal is to rails as a model airplane is to a C17. Yes, both fly, but good luck carrying a tank with the model airplane Millions of web pages are flash only. Millions are html only. Doesn't there no place for dynamic content
&gt;Not possible and not done aren't the same thing. Yes, ruby, and rails, aren't as idiot friendly as plop on a $5 shared host and go You are still not getting it and frankly I am getting tired of trying to explain it to you. The fact is there are dozens of very complex, very powerful, very popular projects written in all kinds of frameworks and all kinds of languages but not ruby and rails. You think Erlang is idiot friendly? And yet they have zotonic which is far superior to any content management system written in rails. 
Ok your plan is good, you have to implement Students, Teacher and api in your application but you can implement reald-time chat, blog, payment section as an external engine
Thank you :)
On any OS, RubyMine is a great option. Jetbrains (the company) is by far superior to sulbime, textmate, vim, nano, whatever hipster editor you want to argue is best. RubyMine gives you all the ideal benefits of an intuitive IDE right out of the box (or after first launch in this case). Im not a fan of the default color scheme, but thats all stuff that you can change easily. Your best bet as a new ruby dev is to get off windows. Allocate some time to learn a new OS. It won't be easy and you might get frustrated thinking, "Why should I learn this OS, when all I want is ruby!". Ask anyone who ruby's for a living, you will thank yourself. OSX is a great OS. Ubuntu is a great OS. Ruby was never meant to run on Windows and the port is lacking (mysql database server connection just being one example that will have you pulling your hair out). 
Ruby doesn't really need a full blown IDE, sublime is great. 
Sublime is not a full blown IDE like RubyMine or Eclipse
I disagree with your comment. Especially for someone just learning ruby on windows. Vim and other OS's have a learning curve just like an IDE. My personal favorite being RubyMine, caters to a new user. Here is why. RubyMine allows people to command click through methods, modules, classes without having to know hipster/custom search commands required by vim/nano. It gives you a project/file explorer pane right in the IDE, eliminating the need to combine vim/nano with some external explorer/custom searches. While I don't personally like the built in compiler (with the lack of debug options compared to console/terminal), it allows new users to run there hello world app/script all from the same place it was developed. IDE's make things convenient. While advanced users will find ease in a custom setup, this new rubyist was asking advice for getting started.
How did I miss that? Thanks for the link!
It's great for really simple things, and teaching people how rails works, without gobs of code to wade through
There are couple of great pieces from Pivotal Labs concerning Rails Engines that really inspired my team to move towards them. It provides a clear separation of behaviour (or not sometimes when you have cycle dependencies!). http://pivotallabs.com/migrating-from-a-single-rails-app-to-a-suite-of-rails-engines/ (That links to a lot of ones worth reading as well.) My opinion is that using Engines is the "right" way to use Rails at the moment for Apps with enough separated behaviour to make it Monolithic otherwise.
An editor that requires you to learn keyboard shortcuts is not "hipster." Any programmer that works fast uses keyboard shortcuts to do it, and working fast is not hipster.
I dont recall in my last comment where I said working fast was hipster. I was saying custom editors/commands don't blend well with a new rubyist learning on windows. 
Not ruby, but consider openrefine.
Ramble warning: I mostly agree with you: I think it makes sense to lessen system shock by learning only one major workflow-upsetting technology at a time. The hardest thing to get programmers to adopt is to prefer keyboard shortcuts, and once you've got that religion I don't see how vim is any harder than anything else. Anyway - my suggestion is usually to use whatever editor you're comfortable with, preferring sublime if there's no strong preference. The short term should involve a switch to a POSIX-compatible OS, then the next thing would be to prefer a shell and either get good with sublime or switch to a fast, customizable editor like vim or emacs. If you need a mouse to edit code, you've failed - I don't really care what editor gets you there. Where we disagree: I don't think using vim is hipster, nor that it's all that harder to learn than rubymine. I also think the skills you learn when you treat your POSIX-compatible OS as your IDE are more useful long-term, rather than leaning on a big complex IDE to handle stuff you could do yourself faster and better from a shell.
Alternatively you have a blank top level application and contain all your code in Engines, allowing you to remove and add as you wish. http://tech.taskrabbit.com/blog/2014/02/11/rails-4-engines/
 &gt;For the record, Sublime Text is sort of a pseudo-IDE. It looks and acts for the most part like an editor but is extensible and has a huge selection of massively powerful (and open source) plugins that let it act like an IDE in many ways. The same argument applies to pretty much any editor that supports community created plugins.
Thanks! I will try this out also!
I'm a little torn on this. I've used engines, but only in cases where common functionality was needed to be used in multiple shell apps. Think of cases where we have a product several clients want, but also want it reskinned and possibly tweaked slightly. It works well for that though in this case coordinating numerous host applications with versions of a core engine can get a bit complex. Currently our architecture is building out based on the many apps strategy. I'm not a huge fan of it, but it wasn't really my call and honestly there are downsides to each method. The plus of the many apps strategy is that development is quicker and simpler, and each app is free to manage it's own structure. On top of that, each component can be deployed without impacting the others (in theory) and each test suite is faster and simpler. It also gives the ability to handle load balancing, failover and spinning up instances on a per app basis. There are, however, a lot of downsides. First, you end up with a lot of apps. Honestly at this point I don't think anyone could tell you how many apps make up our architecture currently. And if you gave anyone a list of them all, I'm doubtful any one person could even tell you what they do. Because different developers start different apps, they're all slightly different. Developers love being able to use their favorite tools, but this means things like App 1 uses cucumber whereas App 2 uses rspec features, or even different design patterns in different apps. There is little standardization between apps essentially, unless it's enforced at the process level. Another big issue is code re-use. We've got duplicated models and logic in several apps. A great way to work around this is to implement a service oriented architecture which is what we're working towards, however this is a big task. While it's great in theory, the issues of having a new app handle legacy business logic created by long gone developers is a tricky one, not to mention figuring out how to scale and support the load of having all database access and domain logic going through a single API. And finally there is testing. Integration tests require you to set up a large number of applications locally and get them all running under POW. This leads to a test environment that's tricky to set up and time consuming to run. The alternative is getting everything set up in vagrant or docker, which is still a complex process. I do like the engines idea and I think it could solve some problems. By having engines in a shell app, you can more easily keep all functionality on the same page (in terms of testing tools, design patterns, shared models, etc). You can also update bits of functionality without impacting the whole more easily. Testing setup becomes much easier, with fewer dependencies. The downside is that you still essentially have one app. This means a fatal bug in one bit could still take down the whole. You lose the ability to scale individual apps and have to focus on the whole. You lose the loose coupling of service components from a many app design (for example, with our current architecture if one bit needed to do processor intensive computations we could swap it out with an app written in Go or Scala or Node or whatever and no other app functionality would know or care). I think a lot of this is going to boil down to project size. A single app with engines is likely a good fit where you need an architecture that does more than a single rails app should, but not enough that you really need a service oriented architecture. I think once you get to a certain amount of functionality / traffic / users / whatever it's unavoidable that you're going to have to split things up into a many app service oriented architecture. Case in point, I think it's completely unrealistic to imagine something on the scale of Amazon or Google or Facebook being implemented as a single app with engines (performance and scaling of rails aside).
I have to agree for this. For most of my work stuff, I'm using Rubymine (as is the rest of my team) for getting shit done in the work environment, but on a few test machines, I have some custom vim environments/plugs setup, and that seems to work well. I've mostly been using sublime for one-off editing of local chef/Vagrant files, and it fits that need quite well. I just got access to Atom, so we'll see how that works out and where.
Working off of what others have said, I think it of paramount importance to verify your changes against a 'master set' of results. "Time wrinkle" doesn't sound like an illegitimate title, even though you may think it was "meant" to be "Wrinkle in Time".
If you read my original comment you will find that I suggest starting with just any simple editor and running it from the command line. With this you eliminate the learning curve of an IDE and the setup time of an IDE. I think you misunderstood my original comment. I never suggested the new developer should use VIM, merely, I gave an example of what I use. 
Exactly. First, assume sorted is false. Then loop assuming first it is sorted. If the IF turns out to be true, then it's not sorted, so, fix the pair and set it to false. Nothing will turn sorted to true in the loop. Any single pass inside the IF, will set the whole thing false. If it ever passes the loop without getting in the IF, then we can say it is sorted, and sorted will exit de loop as true, and thus, exit the UNTIL.
Windows + Rails is a bad idea, solely on the merit of how many things tend to break and misbehave in the process of forcing it to work. As far as editing environment for me: Vim, TMux, ZSH, Powerline, Guard, Pry (with vslime plugin for vim repl goodness) and very very large dot files and custom functions. Now as to why Vim and command line (I hardly ever touch my mouse) I like to customize anything and everything, IDEs are too restrictive and get in my way more often than they help. They also have too much screen cruft and wasted space. Vim I get an entire screen for my editor and multiple tabs in TMux for anything else I need. It's visually liberating not to have 20 toolbars and windows sticking everywhere. On terms of speed, a good vim user will destroy most any other editor in terms of speed, no contest. All that time you waste moving a mouse adds up fast, and I have to partially agree with Theo De Raadt when he says buttons are partially idiotic at least in the context of development. Heck, I even use a vim plugin for chrome so I don't have to bother with a mouse. If I have to type more than 5 characters to do something, it's getting automated or macro'd away. This allows me to get even faster, make less mistakes, and get right to the point of things.
Then you don't get the point of Vim.
Try it without the sudo
The point of Vim is to edit text efficiently. That's *far* from the point of an IDE.
You're right, IDEs are slow and cumbersome and get in the way of actually getting work done. 
That's a very good tip. You get a lot for this really tiny bit of refactoring, too. You can test the each_episode code in isolation from everything else, which is huge, and on top of that you obviously get to reuse the method anywhere else that you want to cycle through all the episodes of a series. (You might not think you'll need to do that again, but odds are you will some day.)
Two bits of data you might find useful: I'm 52, and 1 June will be the 35th anniversary of receiving my first payment for coding; I'm currently Chief Engineer and lead developer for a startup. So yeah, I feel your pain there. We *will* use Ruby for product.*next*. We *could* choose Sinatra, but more likely one of the lighter-weight stacks built on top of it like [Padrino](http://www.padrinorb.com), talking to smaller services (that themselves might be pure Sinatra). More likely still would be an evolution along the *"Rails Way" app* to *app that uses Rails* to *app that uses some Rails components but doesn't much look like a Rails Way app* continuum. I've long been a fan of "Uncle" Bob Martin; if you haven't seen his Ruby Midwest 2011 keynote on "Architecture: The Lost Years", watch it on YouTube. In the same vein, Alistair Cockburn's and Matt Wynne's (separate) work on "hexagonal architecture" and "ports and adapters" looks very much like the direction I'd want to go in whether based on Rails or anything else that I'm going to have to maintain for a timeframe exceeding a few days. Getting back to your second question, yes, Ruby, but we're also starting work on evolving our *client-side* code from the current CoffeeScript ("JavaScript, greatly improved") to [Opal](http://opalrb.org). Being able to reduce the number of languages we work in while both keeping the language we're *best* in and eliminating what has given us more grief than any dozen other things, will be an *ineffable* win.
I do notice my machine chugging along when RubyMine starts indexing, but it's worth the functionality.
I used Rails Engines to great success at a previous client. We used 35+ Rails Engines to form a framework to build sports betting sites. It's enabled them to build sites for major clients with well tested functionality while abstracting the common functionality from the bespoke functionality. It was called the Apollo Framework - http://www.lvs.co.uk/products/website-mobile/
RubyMine is also a great IDE, once you get more serious with Rails... 
Also, it's important to note that Ruby itself is a general-purpose programing language, whereas PHP is specifically designed for web development. 
It could literally be done in [10 minutes](www.youtube.com/watch?v=JaL9ul17kx0) 
You also have [cie/rubylog](https://github.com/cie/rubylog) which is a native Ruby kind of Prolog implementation. I used it a bit, it works like a charm.
If 3.meters.inch is 3.meters.to_inches then how would you write 3m^2? 3.meters.meters wouldn't work and the intent of that seems clear too. Or would 3.meters.inches be area but 3.meters.inch lenght? Can't say that that's very intuitive
Git + dropbox?
Nice little experiment
I have ambivelent feeling about engines, but from my own experience actually disagree (sometimes quite strongly) with some of the recommendations made in that taskrabbit blog post. I guess it probably depends on what you are using them for, they are quite flexible and can be used for various things, good and evil. What are you thinking of using them for, what are you hoping to get out of them?
Well, ordinarily engines are _gems_, it's quite easy to re-use engines accross multiple apps, that was their original purpose. The taskrabbit blog post suggests 'innovating' by sticking engines directly in a single app, for use only by that app. But that's actually the extra thing, standard engines are gems, easily reusable accross multiple apps. 
&gt; Not sure how exactly you split a group of engines across multiple apps. We run a local gem server called geminabox. You can source it in your gemfile and include your own engine based gems. Alternatively for development you can just point to a local copy gem 'chemist', path: '/Users/ccunningham/Projects/chemist' &gt; I am also curious on the "figuring out how to scale and support the load of having all database access and domain logic going through a single API". Have you hit that point yet? Not quite there yet... We're slowly moving functionality to service oriented API apps and building up the load as we go. Though scaling a rails app is pretty straightforward, there are a lot of bits to consider and we're not rushing into it. &gt; BTW, what is POW? http://pow.cx/ For integration tests you essentially need a way for apps to talk to each other, which is hard to do by firing up rails server and giving each a different port (possible, but a pain to set up when you have a half dozen apps). So we rely on pow to serve up each app on an appname.dev domain and all the integration tests expect to find other apps at their .dev domain name. 
I haven't had a single issue with 2.1.1 - or 2.1.0 for that matter. Maybe these people were running Rails?
I've encountered one severe bug in Ruby &lt; 2.1.0p6 where a Struct setter like struct.send :foo=, 42 returned not the value set, but the whole struct object. I'm not 100% sure which gem had problems with this new behavior, but it surly kept me from deploying a Rails 4 app on 2.1.0. With 2.1.1 I haven't had any problems so far.
You could even do `3.m2`. I see what you are getting at though. All of the named methods like 'foot', 'to_inch', etc. are all conversion methods. They won't do any compounding for you. If you want to convert to compound units, you can use the `convert_to("foot/second")` type of syntax, or do it through multiplication/division like this `1.meter * 1.meter == 1.m2`.
Question, by looking at the sample data he posted it looks like the return data doesn't close hashes? That might have been what was confusing in the first place - it looks like 'Episode' is nested within 'Series', but it's actually on the same level. There seems to be a missing (or omitted - is that XML syntax?) close brace before 'Episode': {"Data"=&gt; {"Series"=&gt; {"id"=&gt;"79168", "Actors"=&gt; "|Jennifer Aniston|Lisa Kudrow|Matt LeBlanc|", "Airs_DayOfWeek"=&gt;"Thursday", &lt;- close 'Series' hash here? "Episode"=&gt; ... 
And that distinction is more of a handicap nowadays. PHP really isn't meant for long-running processes, threads and asynchronous programming, and WebSocket stuff, which tools like Ruby and Node handle much better. PHP's weird process model is a part of that. Instead of having an application run constantly, the expectation is that the PHP interpreter load and run an entire script with each page request, do little in the way of garbage collection, and then strike everything at the end. Not the most efficient strategy with larger and more complex apps.
Yes, there were quite a few bugs in 2.1.0 (although they were mostly in corners out of the way of most applications) because it was a big release. But 2.1.1 is not like 2.0-&gt;2.1. You can think of 2.1.1 as 2.1.0 with bugfixes. "Teeny" version increments are basically like patch level releases used to be ([info](https://www.ruby-lang.org/en/news/2013/12/21/semantic-versioning-after-2-1-0/)). So there should be very few issues with 2.1.0-&gt;2.1.1-&gt;2.1.2-&gt;2.1.3, etc. It's not like 1.8.5-&gt;1.8.6-&gt;1.8.7 or even 1.9.0-&gt;1.9.1-&gt;1.9.2-&gt;1.9.3.
Float division accuracy in 2.1.1 is inconsistent with 1.9.*, but usually it's not an issue. Memory consumption has grown a lot, but it's also a lot faster. Other than that we get sporadic segfaults running tests on jenkins (archlinux), but no issues on osx or heroku platforms. More about memory consumption and how to control it using ENV vars: https://bugs.ruby-lang.org/issues/9607 All in all: no major issues that should stop you from upgrading.
I don't agree with your original comment. What I'm getting at, is the IDE has less of a learning curve (than vim, pry, etc) since it is an Integrated Development Environment. No need to learn things like pry, rails c, etc right away. You can focus more on the language, while still having access to great things like step-through debugging. I personally don't use an IDE, but for starting out I don't think it is a bad idea, and I think RubyMine is the best IDE for Rails development.
If there is no possibility for confusion then that makes sense.
What are you trying to do? Do you want to install the fbo gem? If you just want to install the fbo gem you shouldn't have to care about any gemspec files. To do that you type `gem install fbo` after you have installed ruby on your machine.
Maybe. I know I am, I will indeed be running Rails. 
Hi guys, it is like our search engine! great to see that. Try it out at http://www.weirdoo.net Edit: It is also ruby :-)
Hmm. I hadn't thought of that. But, as joshwlewis pointed out, the unit methods only do conversions, so it shouldn't be confusing. FWIW, if you want 3 square meters, you can do 3.meters(2). Although I'll admit that it's not terribly discoverable. I just realized that 3.m**2 would yield 9.m(2). I'm not sure if that's good or bad.
Well don't I feel silly now: https://www.ruby-lang.org/en/news/2014/03/10/regression-of-hash-reject-in-ruby-2-1-1/
I think I'm more and more convinced that having #unit only as a conversion method is a good idea. However a #per_{unit} method would be nice: e.g. `9.8.meters(2).per_second` is quite readable
https://www.ruby-lang.org/en/news/2014/03/10/regression-of-hash-reject-in-ruby-2-1-1/ Which leads to: https://github.com/rails/rails/issues/14188 So YMMV [EDIT] Updated URL, thanks to /u/yorickpeterse
https://www.ruby-lang.org/en/news/2014/03/10/regression-of-hash-reject-in-ruby-2-1-1/ English version of the article.
fbo is a library, not something you can run on its own. You'll need to write some code to get it to do anything useful.
yeah, you know what, I think I'll stick to ruby 2.0 for now. Upgrading my apps from 1.9.3, I think I'll go to 2.0, and wait a while for 2.1. (Also, I think this change to Hash#reject is a _terrible_ idea and don't understand why they are intentionally making it for 2.2.0, but anyways.)
Incorrect title, since Engine Yard is simply funding other developers, and not really doing the work themselves.
All the questions I see on /r/ruby are downvoted to hell. 
I second that motion. Don't make work for yourself. Find a *problem* before you go off looking for a solution. Or like h1ghl4nd4r said, find an existing tool and contribute there. 
Hmmm ok good point. Any blog ideas? :D
You could look around for gems in need of maintainers. There are always a few abandoned or soon-to-be-abandoned gems.
lol. Are you asking about blogging software or a topic to blog about? Beware that you are not getting in your own way. I should know, I do it all the time. It usually goes like this... I need to do something I'll write a blog! Which blog engine should I use? There's too many to choose. I'll write it from scratch. Which language should I use? I want to learn more javascript. Let's go with that. --- much hacking --- Which framework should I use? Oh, what is this? Bower? Grunt? How interesting... --- much more hacking --- Well it's not as good as any other solution and it has lots of flaws but it's mine! But what should I write about? ad infinitum... ------------ Notice how you can easily set up a moving finish line when *you don't know what you are trying to accomplish.* If you wanted to blog, all you needed was wordpress and some content. But content is hard so you spend all your time building a broken, unwanted thing that isn't as nice or well-tested as the bazillions of other blog engines out there. My advice: If you want to write content, write content. If you want to build a thing, build a thing. But please, figure out what you want and need first. Otherwise, you are just chasing your tail and wasting your valuable time. 
I have a blog engine setup. Just looking for topics :)
I admire your eagerness. However, not unlike the suggestions above for open source/community contributions, the logical answer here is to wait to write something until you have something to write about. In my opinion, you shouldn't write just because you want to talk, you should write because you've got something of value you want to communicate and contribute - you've solved an interesting problem, developed an efficient method for managing your company engineering team's infrastructure, or maybe deployed a fleet of auto-scaled AWS EC2 instances and want to share the suite of tools you used to bootstrap your boxes and deploy your application. It's also extremely important that you be knowledgeable about your topic and have some experience or expertise. I don't know that soliciting for ideas is going to yield your best posts. And if you're really itching to contribute to the community (which I think is great), start looking at some of your favorite gems and projects. Browse github issues for those projects, look for a feature someone is requesting or a bug someone has filed and see if you can't fork, fix it and submit a PR. Edit: a word
Sponsoring community activity is a form of work, I think. In the same way that organising an event or facilitating relationships can be a useful form of work. However, even if we focus on direct contributions to OSS projects, one of the things I discovered in my research was that Engine Yard (or rather Engine Yard's staff) have contributed a surprising amount of actual OSS code. Yehuda Katz is a great example of this.
Here's a good place to start for technology blogging: http://sachachua.com/blog/2014/02/excuses-guide-blogging-pdf-epub-mobi-free-also-notes-publishing/ The strategy has worked for the author and you'll see navigation at the bottom to a series of related articles.
Projects are much easier when they're something you use. Like others have said, find an open source gem/project that you use and start contributing. Good luck!
Do you have any idea the direction you want to go? It could be web (Rails, Sinatra, mobile apps) or desktop (Shoes?, Tk? good luck) or server administration (Puppet, Chef, roll your own)
Best way to learn is to take all the knowledge you have ingested and use it to build something of your own!
You pretty much described me about 7 months ago. I don't really use skype, but I am on reddit at some point every day, shoot me a message if you are interested in sharing some code and maybe talking about learning/career trajectories.
I successfully set up a Ruby / Rails environment on my win7 laptop. It is not perfect like everyone has said, but you can get something running (I have a few basic apps hosted on heroku, my laptop env is Postgres, Ruby 2.0.0, Rails 4.0.0, and Git). One option like mentioned before is to use a VM to run a Unix system, and have it talk to your windows laptop. For this I would suggest Vagrant.
In the seven month span have you learned a great deal? Have you worked on your own program? Could you recommend any material that you feel helped you the most with programming? 
Sure, send me a PM, i'm sure we could bounce ideas off each other.
The ammount that I know now is astronomical compared to what I knew a month into it. There seems to be an endless supply of rabbit holes to fall down, and no shortage of new things to learn. Right now I'm working on building an ecommerce site for a friend's small business, along with a couple of other small side-projects. The hope is that once I get these things finished, I will have a robust enough resume and enough knowledge to land a solid job in the industry. The alternative is somewhere along the line I learn how to sell myself to launch a feelance consulting career, either way I'm pretty excited about the possibilities. I've gotten more information from http://guides.rubyonrails.org and http://railscasts.com/ than anything, thought I have spent a lot of time doing courses on www.codeschool.com. I think the subscription fee is a little steep, so I'm constantly canceling and resubscribing when I get some time to plow through a few courses. They vary in quality, and I've found I get the most out of the more advanced ones when I have given some time to let really understand the basics by doing some minor projects on my own. For iOS, the [big nerd ranch](https://www.bignerdranch.com/book/ios_programming_the_big_nerd_ranch_guide) book was the thing that made me break through and really understand the concepts.
Yeah that would be the best thing, my uncle is a data analyst for Fidelity so we talk here and there, but he doesn't really have knowledge in the path I'm choosing (ruby, objective c) he mostly works with HTML Java and JavaScript. I posted on craigslist but to no avail lol. I live in little old Rhode Island. Hell if anyone here is close I'm down to network and meet up for sessions.
Amen to this, following tutorials will only get you so far. Becoming a good programmer is little to do with knowing the syntax and moreso about problem solving and systems thinking. Having a mentor will help massively, especially when you hit snags and your motivation is waning, they will get you over the hurdle and you can continue enjoying what you're building.
If you're feeling fairly comfortable with the basic concepts of Ruby, a really cool Rails tutorial is [this one](http://ruby.railstutorial.org/) by Michael Hartl. Even if you might not want to do web stuff, it's really neat in an instant gratification sort of way. You can have your own version of his example app up and running in a few days. Plus, it looks kind of good in an interview if you have something like this to point to.
Damn that's really good, good for you man that's pretty motivating. At this point it's pretty damn overwhelming for me so to hear that you were like me at first and now you know a lot and are working on projects of your own is good to hear. In still learning the basic concepts of programming (variables, if/else, loops, Boolean logic), I'm just learning with ruby and planning on sticking with ruby to get a job. 
That's not a bad idea. Mind if I steal it?
Definitely, absolutely start building projects on your own. Pick something you think is ambitious for you, and build it from start to finish. Do that a few times, and you'll be employable. 
I really do mean this in the nicest way but what do you consider "pure ruby". Rails IS pure ruby. 
Sure, PM me whenever you feel like it. I've spend the last few months learning RoR and I think I'm sort of understanding how things work. 
Nah none of that, rhode island has nothing. There's http://www.newhorizons.com which I'm looking into but idk, I like to invest my free time wisely so I want to make sure whatever resources I'm using to learn are very good.
Personally, I would start with a statically typed language to get the fundamentals of OOP and then learn C to understand memory management. After that you can pick up a dynamic language like Ruby or Python. P.S. Stay away from Rails for a long, long time.
I've only been programming for a year, and I asked my boss this same question about 5 or 6 months ago. One of my biggest concerns was that I wasn't sure whether I was just doing something wrong/could do something differently with an api/gem/etc..., or it was an actual problem with the api/gem/etc... So I asked him, and his answer was something along the lines of, "It's most likely that you just don't have enough experience/time programming to notice the subtle differences. My advice to contributing to open source is not to go out and look for some project you can contribute to, but work on your own projects using other gems/etc... and after enough time running into the same problem, a lightbulb will go off in your head saying, 'HEY!!!! this is a bug, or HEY!!! this could be a useful feature for that gem. It's so much easier to diagnose/understand the problem when you've directly run into it 3 or 5 or more times. Trying to jump into an open source feature and solve a problem you've never encountered is a fools errand, because you haven't even properly assessed the use case of said feature." In essence, keep working on your own stuff, and if you run into the same problem a couple times, consider whether its specific to your business logic, or it could be a really benefit in almost all use cases. 
I want to but I don't have any ideas and don't even really know enough to start. I'm literally learning the basics of ruby in command prompt and the basics of programming in general. I do know I would like to work on apps and web apps though 
meetup.com yo
Excellent advice. Just one thing I'd change: &gt;When you run into problems, **Google it, then if you can't work it out** ask for help. Be as specific as you can **and be sure to mention what you've already tried**. It's a small thing, but for new programmers developing the habits of self-education (and trying to solve problems themselves instead of relying on others to tell them the answers) are *hugely* important (but often overlooked) soft skills. And also, from a purely pragmatic point of view, developers and geeks generally are almost always more willing to help someone who makes it clear they've already tried and failed to solve their problem, as opposed to someone who runs into a problem and immediately runs straight to a forum or mailing list for someone else to tell them the answer. Other than that subtle detail, agree 100%.
Not at all, if I wanted to keep it for myself I wouldn't have suggested it.
http://www.meetup.com/Rhode-Island-Ruby-Group/ http://www.meetup.com/MoDevRI/ Not sure if these are anywhere close to where you live, but might be worth a look.
Find an idea. Make a website for your biking club. Or parent association. Or RPG group - you have hobby, pick one as an objective. Hell, even create a blog using Rails (you'll find a zillion tutorial about that) and use it yourself to talk about your learning (improving it along the way). In a nutshell: it is not about books. It is about practicing. Start now! Don't worry about your level, if you're stuck, you'll find help.
I assume you mean jruby vs mri, because you can run jruby with nginx Advantages I find with Jruby * Java ecosystem * Stability for long running processes. I have an nginx server for another app and the memory requirements are unpredictable. No idea how much memory it needs, when it will garbage collect. * Multiple threads with low memory. MRI means a process per cpu core which is just lame. * Cross platform compatibility. You can just package a war and deploy on windows as long as your code has no system calls. * Similar to above but there are no system requirements beyond just having Java and Tomcat even if you deploy on Linux
Learning to program is a lot like learning how to play music. you can pick up some chords and string them together into a recognizable song on your first day, but you probably won't have any idea why it sounds good (or doesn't). That's okay, and expected. There will be periods where you'll get better really fast, and there will be periods where it feels like you're not getting better at all. That's also okay, and expected. To really get good, you're looking at an investment of years. After you've been playing for 10 years, it's much more trivial to pick up a new instrument and know how to really play it within a much shorter time frame than it took you at first. You probably understand the theory at this point and the bigger picture and past experience guides you. Playing music at a professional level is supposed to be hard or else everyone would be doing it. Same is true for programming. It's seriously rewarding when you start seeing the progress though. And as far as "not having any ideas to build", they'll come or they won't. Some players are songwriters, and some are sidemen. The world absolutely needs both - people who have ideas and can kinda get them out of their head and people who know how to expertly execute them and make them into something that changes people's lives. The most important thing is just to work at it every chance that you get, and don't get discouraged when it's hard.
Obligatory link: [How To Ask Questions the Smart Way](http://www.catb.org/esr/faqs/smart-questions.html).
Try to build something every week. If you get stuck trying to think of a good way to do it ... do it a bad way. If you can't even think of a bad way to do it, find a workaround or do *something.* You're going to learn by doing. Oh, and use version control so you can make these changes fearlessly and erase you worst mistakes when necessary. I'd also recommend [this book, Practical Object-Oriented Design in Ruby](http://www.poodr.com/). It's the type of thing that's more useful as you gain more experience, but it lays a great foundation for quality design, and I wish I'd found it earlier in my career.
By the way, I'm open to feedback from more experienced developers. Did I do a good job of explaining the TDA concept?
In $big_business, a lot of places are running the JVM as their standard application server, and if it can't be deployed to the JVM, it can be nearly impossible to get buy-in or approval from the people paying the bills. Once the application is in a WAR container, it can be deployed on: * Any server that can host Tomcat, Glass Fish, Jetty, etc.; which, these days, is almost all of them. Yes, I have run into scenarios where my clients insist on running Java application servers on Windows hosts in their enterprise environment. Fine. I have no interest in playing SysAdmin to a snow-flake server in their environment because that means I have to then support the server and the Rails app, etc. From a technical perspective, it opens the doors to interop with the extensive Java ecosystem from inside our Rails apps.
Getting the fundamentals of OOP from a statically typed language is pretty difficult IMO. OOP was originally designed for dynamically typed languages, and Ruby is a pretty faithful to the concepts of OOP in a way that most statically typed are not. 
As someone who is starting on Clojure, I am well aware and VERY interested in Datomic. Actually, I will be using Datomic as my data-store for an upcoming project. Have you seen this: https://www.youtube.com/watch?v=-6BsiVyC1kM It's a beautiful keynote speech from Rich Hickey about "The Value of Values" and the need for temporal measurement in our data stores.
Yes, precisely. I would also add: "as long as your Gems are well-tested against JRuby;" though, with Travis, a lot of Gems seem to be taking JRuby seriously as a platform, and that is a very good thing from my perspective.
&gt; problem solving and systems thinking Bingo
Do you use warbler or your build.sh to build the war? I never had any problems with warbler except for some Ruby 1.8 issues which they don't feel like wasting time with.
Yeah it's something I wouldn't mind testing with some of our apps at work, It's just a bit outside my wheelhouse on how to compare performance :). I've done a bit with JRuby in the past, mainly trying to figure out torquebox deploys, as that has a pretty good reputation.
As someone who's built and deployed a Rails app in a Big Corporate Datacenter the biggest thing is that all you really need to deploy is a JVM and those are already everywhere. Perhaps it's gotten better but when I tried doing an MRI deploy two or three years ago the corporate firewall and all that made it more of a hassle than it was worth. Had I gotten it deployed it might also have caused problems with our platform support team if I ever had issues. Besides that there are the points others have mentioned about performance and such.
 .container { margin-left: 6px } .content { width: 90% }
I tried torquebox but it was complicated. I think you only need that if you really need some of the advanced features. I have scheduled tasks working in a Jruby War with rack-worker and you don't need an extra daemon. Tomcat just creates another thread to deal with delayed_job or another library.
I, too, have using Yesod. What I miss from Rails, and the Ruby ecosystem, is the EASY of package management with RVM + Bundler. With Haskell, I can do cabal-dev, but it still feels a bit messy. I really notice it when I fire up a Vagrant box to work on a new app and I have to cabal update (or possibly install the Haskell Platform and Yesod). These days, I have been using the Vagrant box from FMComplete.
Yes, that lecture was my introduction to Datomic. I'd be interested in swapping notes on good practices for using Datomic. I'm just a hobbyist, but I'm interested in building up utilities and perhaps tutorials to get more people using Datomic. I've been using [Diametric](https://github.com/relevance/diametric) to talk to Datomic as a peer through JRuby. I couldn't get it working in Rails. I don't know the internals of Rails at all, so it was easiest for me to switch over to Sinatra and build a little more of the app by hand. So far, things are really smooth with Sinatra.
While this is the path I went, I don't think starting with dynamic is wrong necessarily. Sure, the bottom up approach is nice and worked for me but I don't think it is for everyone. I was going to downvote to disagree but remembered downvotes are supposed to be used for things that don't contribute to discussion so I refrained -.-
&gt; because you can run jruby with nginx I know, and that's exactly why I was wondering why I *wouldn't* use nginx with jruby
You do sound motivated. You can self-teach yourself these things. I have taught myself Java and now Ruby/Rails outside of class (I am doing atmospheric science undergrad). Like everyone is saying, build stuff on your own. Start really simple. Basic command line prompt simple. Once you get the basics down (variables, loops, if statements) you can do a surprising amount of things. My first large(ish) programming project was a vending machine. There was no GUI or anything it was all via the command line. This was a pretty simple project and it was very eye opening and satisfactory when I completed it. The key to doing any software development is to take the large scale problem and break it down into small pieces. The vending machine for example consists of a few different things (objects) interacting with each other. There is the change machine where you input and output money. There is an inventory where items are kept, given out, and restocked. Finally there is the user interface where people can select items and whatnot. 
There are a good amount of options in providence. I haven't looked at any openings as I'm more concentrated on learning programming right now to get a job in the field. I definitely plan on moving though in the future when I have experience to move up
Best solution. Use nitrous.io - Its a web IDE so you don't have to worry about setting up ruby on your PC. You can program in a browser and if you want you can sync your code to your PC/MAC to do the editing. I've built an entire Padrino app in Nitrous and then deployed to heroku without installing any ruby on my mac. I highly recommend it and as a newbie you can probably get away with the free tier.
OK well that is a good question. I guess the ability to deploy Wars is a big one. Tomcat is cross platform. Plus tomcat lets you have delayed jobs running. With Warbler you can also run rake tasks and console from a WAR file which is pretty cool too.
Looks reasonable to me.
You prayer have been answered! If you use the sandbox feature in the (iirc) 1.20+ versions of cabal, you have basically the bundler/gemsets workflow. I dont know how to use several versions of GHC besides each other a-la RVM; but I dont really need that feature so much when using Haskell. I would not be surprised if that is also already solved though. Good luck!
cabal sandbox + https://github.com/benarmston/cabal-constraints is a game changer. I've finally started doing serious, non toy Haskell work because I can now trust cabal to build a package as well as maven and friends can.
Thanks!
Awesome. I will spin up a clean VM and give this a try. I REALLY want to use Haskell and/or Clojure full time for all of my work because (and I know this sounds cliche) learning them has been enlightening. I get it. I see the appeal. I feel (barely!) mature enough as an Engineer and Artist to appreciate the pure functions of Haskell and the LISP of Clojure.
Yeah, I don't mind get stuck with programming problems, or something about a language I don't understand, but I refuse to use ecosystems with build issues any more, when that problem is solved. I keep every single different haskell project/ library/ app in a separate sandbox. It takes more time on the first build since it rebuilds every dep from scratch (some hash based de duplication would be nice), but I no longer experience any cabal hell (except the diamond dependency problem, but almost all build solutions including bundler have that right now).
Sounds like what I've been looking for. Hit me up
Post your github link. Get a github account if you don't have one.
Am I the only one that prefer the terser #should-variant? Sure, monkey patching should be kept to a reasonably small amount for sanity, but avoiding it altogether seems a bit too much in this case, imo. 
I prefer it a great deal as well and will keep using it for personal projects.
Thanks for the feedback. Some of what you said is still over my head but I'll re-visit this as I continue to study.
&gt; diamond dependency problem Yes, it is infuriating. I don't mind the slow initial builds if I can program in Haskell with all of its delicious type safety.
Wow, they've finally achieved what test unit has had for more than a decade. Congrats.
The ERP point is a bit ridiculous at first glance - anyone working in ERP knows who the big players are, and should also be aware of the opportunity costs involved in ripping out an ERP (combined with the existing development costs that you'd be throwing away to replace a working system). However, there is some serious ongoing work in the ERP space by: https://github.com/portablemind/compass_agile_enterprise
The outcome is definitely the better way to structure the code, for this simple example. But the motto "Tell, Don't Ask" has _always_ confused me (not just in your example), because the 'right' way sounds like 'asking' to me too -- you are asking the Character class if it's healthy or not, right? This is better than the caller asking it for something else and then deciding on it's own whether that counts as 'healthy', but both seem like asking to me. Maybe it's really more like "Ask for what you really want, don't ask for something else." I dunno. Like I said, my confusion over "Tell, Don't Ask" is not limited to your example. In fact, for a while, after i heard "Tell, Don't Ask", I was trying to do it, and _thought_ I was doing it... but realized eventually I had been doing the _opposite_ of what was intended, because I thought I was "Tell, Don't Ask"ing, but was doing it totally wrong, misunderstanding the sorts of 'tells' and 'asks' that were actually recommended. 
Kind of related, but sometimes I (unjustifiably) will be reluctant to use a gem based on Github stars and followers of the committer. But while most great libraries have a lot of stars, some of the most canonical ones don't have much Github buzz...either because they're so stalwart and do their small task so well, or because they reached ubiquity efore Github was big. Kind of related to that: after Jim Weirich died, I saw the link to his final commit...which was [classily memorialized by Github](https://github.com/jimweirich/wyriki/commit/d28fac7f18aeacb00d8ad3460a0a5a901617c2d4)...and was surprised to see how few stars Rake had (&lt; 1,000). 1,000 stars is not trivial, but many popular, optional gems have that many. I guess it's more that Rake was big before Github, and like most projects ported over, had received such canonical status that "starring" it would be redundant. 
The main difference I see is change management. When and how bugs get fixed are not under your control. Of course you can choose not to upgrade your dependency but sometimes that is unavoidable, particularly when you are upgrading across ruby versions. With that being considered though, you are right, particularly with very small gems. If the source is small you can quickly gain a deeper understanding of it when you really need to and decide to fork it or upgrade it at that point.
While there's real value in checking if it's alive, if people are actually using it and all that, I think we sometimes overvalue the "github numbers". These older gems we use everyday are a good example of that.
Yeah, people should be less afraid of using and changing other people's code. My code is other people's code for me 6 months from now anyway.
Yes, as should chruby
gemspec is used to build a gem. The information in the gemspec will be used to your gem file. This is usually done by doing "gem install [gemname]"
If your service is hitting the network, I would strongly recommend using something like [webmock](https://github.com/bblimke/webmock) to drive service mocking. It's much better suited than any of the mocking libraries. With Minitest, I find that dependency inversion is a much better approach to clean stubbing. So, in this case, class MyThing def initialize(some_service) @some_service = some_service end def some_method res = external_call some_service.another_call(res) end def external_call # some other call here end end Now you just need to *pass in* a double for your service.
I suppose most people use stars to remember gems that are interesting. It is pretty hard to forget a stdlib gem that is used in Rails and many other projects in one form or another.
It's not ideal, but I think there are some good tools out there to build smart doubles that do things like check to make sure the object they're doubling would `#respond_to` the same method. I prefer explicitly building a double to stubbing an existing service object. But it's a matter of preference.
 http://timelessrepo.com/making-ruby-gems http://guides.rubygems.org/what-is-a-gem/ http://guides.rubygems.org/
This should be a big improvement for apps that pass `String#to_sym` to user input.
I like to think of Minitest's mock and stub implementation as syntactic vinegar. When I want to do something in my tests and it's difficult to do with Minitest then it tells me that I should rethink what I'm trying to do. Minitest's stub implementation is the way it is not because of an oversight, but by design. It's another way to get feedback about your design quickly.
Are you suggesting that it is never appropriate to stub multiple calls? Because I find that quite narrow-minded, especially in big systems, when using a micro-service architecture, etc. It might not be ideal, but sometimes it is clearly the *best available* option.
There's one thing to consider here with a maintainer stop working on the gem in question. One can simply fork the gem and continue to build on it, if it's a tool you like. A nice small tool that you like but dont have to write is a good start. Need to add features but the repo is dead? Fork it and continue the project. If you can't get in touch to simply get access to cutting a new gem version, push to another gem instead.
I really needed a ;) emoji there. That being said, this patch may reduce the scope of that attack vector.
Well, let's look at how you can test your current code without using so many stubs and _without_ changing the design. First, you could use the Liskov substitution principle and create a new Thing class that behaves the way you want. Then you can use this new class in your tests without creating any new stubs. class MyThing def some_method res = external_call SomeService.another_call(res) end def external_call # some other external call here end # ... end class TestableMyThing &lt; MyThing def external_call true end end SomeService.stub :another_call, true do object = TestableMyThing.new object.some_method.must_equal true end This would certainly work, and the test code looks nice and clean. However, if you decide that you are a friend of the environment and want to avoid scary things like "namespace pollution", you could always stub that `external_call` method using Ruby instead of Minitest's stub implementation. This is easier to do because we are dealing with an instance of a class, and not a method on a class. class MyThing def some_method res = external_call SomeService.another_call(res) end def external_call # some other external call here end # ... end object = MyThing.new def object.external_call true end SomeService.stub :another_call, true do object.some_method.must_equal true end But, I look at both examples, and I don't really understand what it is you are trying to show in this test. Perhaps it's my narrow mind, but I don't find them particularilly clear. Perhaps if the design of MyThing was to change this might be a bit easier to demonstrate what you are trying to verify with these stubs? But that's a subject different reply I suppose. Anyway, I hope this helps.
Hmm, well yes I have given a terrible example - I was trying not to paste in production code :) I will see if I can come up with a more compelling argument, although I'll say that you've at least somewhat convinced me that refactoring is needed here. I still think, in general, more than one stub call can be fine... but I have yet to prove it I suppose. Thanks for the posts!
Details?
Happy cake day.
If you are confused by converting between `unless` and `if !`, checkout [De Morgan's law](http://en.wikipedia.org/wiki/De_Morgan%27s_laws).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**De Morgan's laws**](http://en.wikipedia.org/wiki/De%20Morgan%27s%20laws): [](#sfw) --- &gt; &gt;In [propositional logic](http://en.wikipedia.org/wiki/Propositional_calculus) and [boolean algebra](http://en.wikipedia.org/wiki/Boolean_algebra), __De Morgan's laws__ are a pair of transformation rules that are both [valid](http://en.wikipedia.org/wiki/Validity) [rules of inference](http://en.wikipedia.org/wiki/Rule_of_inference). The rules allow the expression of [conjunctions](http://en.wikipedia.org/wiki/Logical_conjunction) and [disjunctions](http://en.wikipedia.org/wiki/Logical_disjunction) purely in terms of each other via [negation](http://en.wikipedia.org/wiki/Logical_negation). &gt;The rules can be expressed in English as: &gt;&gt; &gt;The negation of a conjunction is the disjunction of the negations. The negation of a disjunction is the conjunction of the negations. &gt;or informally as: &gt;&gt; &gt;"___not (A and B)___" is the same as "___(not A) or (not B)___" &gt; and also, &gt;The rules can be expressed in [formal language](http://en.wikipedia.org/wiki/Formal_language) with two propositions *P* and *Q* as: &gt;where: &gt; &gt;* Â¬ is the negation operator (NOT) &gt;* is the conjunction operator (AND) &gt;* is the disjunction operator (OR) &gt;* â‡” is a [metalogical](http://en.wikipedia.org/wiki/Metalogic) symbol meaning "can be replaced in a [logical proof](http://en.wikipedia.org/wiki/Formal_proof) with" &gt;Applications of the rules include simplification of logical [expressions](http://en.wikipedia.org/wiki/Expression_(computer_science\)) in [computer programs](http://en.wikipedia.org/wiki/Computer_program) and digital circuit designs. De Morgan's laws are an example of a more general concept of [mathematical duality](http://en.wikipedia.org/wiki/Duality_(mathematics\)). &gt; --- ^Interesting: [^Boolean ^algebra](http://en.wikipedia.org/wiki/Boolean_algebra) ^| [^Augustus ^De ^Morgan](http://en.wikipedia.org/wiki/Augustus_De_Morgan) ^| [^De ^Morgan](http://en.wikipedia.org/wiki/De_Morgan) ^| [^De ^Morgan ^algebra](http://en.wikipedia.org/wiki/De_Morgan_algebra) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cg1xlv4) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cg1xlv4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yes. The WARs are a huge deal for :my_day_job. The rapid development of Rails plus the ability to deploy on Tomcat gives the opportunity to score big wins early on in the life-cycle by delivering features early and often.
LOL thats the difference an computer scientist (Informatiker) must and a programmer should know it 
_Unless_ is confusing for people not fluent in English. It makes code much harder to read in other languages.
Umm. Why?
Thank you. Why do we automatically hold the person writing the `unless` responsible for confusion it causes? Maybe you folks need to learn you some boolean logic and GET OFF MY LAWN.
While on this topic, I think `pry` should most definitely be on the list. A seriously wonderful piece of software that is the first thing I type into Gemfiles and speaking of the sidebar...I just noticed that at least two of the mods are well known and productive Rubyists (at least to me, since I use their gems)...So...cool! (not going to start a new sidebar thread for that observation)
 I've been doing this for 18 years. When I jumped over to Ruby I had to break a shit ton of bad habits and throw out a lot of things that I "knew". I prefer "unless" over "!" any day of the week... it just reads better... 
Finally made an account because i noticed something. Why is there only one female speaker and she's white?
It would be great if there was a switch to disable this -- some of us are not under memory pressure and just want better performance. Looking at the benchmark ratios, there were more 0.x results than 1.x results, meaning most benchmarks got slower.
I love rbenv! I am thankful for it, not just for Ruby, but because [it has spread to Perl and Python as well](http://oylenshpeegul.typepad.com/blog/2013/08/acme-envy.html)! This isn't just an improvement for each of the three of them, but having them all work alike is extra good! Hooray for {pl|py|rb}env!
+1 here.
Wha? I don't even...&lt;face palm&gt; So are all event speaker panels supposed to represent every race in America? It's pretty clear to me you have a massive chip on your shoulder and feel like the world owes you a collective apology, and I'm not even white. If you believe more women or people of color should speak at a technical event, how about tackling the core of the problem by teaching development to these groups, rather than enforcing some ridiculous quota system from the top, regardless of qualifications or expertise.
Why stub or mock at all? Test the full stack.
rvm belongs in the garbage
Why do you say that? I use rvm and it works well for me.
+1 for rbenv &amp; ruby-build The learning curve is a bit steeper than rvm, but the end result is a lot cleaner and more in tune with the way that other ruby tools (like bundler) and the *nix system tools work.
+1 for pry
OMG so many problems with that thing. Let's see, off the top of my head: * nagging me that it should be at the beginning of my $PATH * barfing instructions every time I launch a shell, yelling how my shell should be configured for it to work properly * confusing rules on when it's active or not in a given directory and/or shell * documentation from hell * trying to do way too much * getting in my way when its job is to be a silent partner in my development, not be like a high maintenance girlfriend who expects me to spend all my time with her * being a super-bloated pile of shit and thinking it's the best 
&gt;So are all event speaker panels supposed to represent every race in **America**? There's your problem. &gt; If you believe more women or people of color should speak at a technical event, how about tackling the core of the problem by teaching development to these groups, rather than enforcing some ridiculous quota system from the top, regardless of qualifications or expertise. We already have more than enough women experts of different races **inside and outside America** that are qualified to speak. The organizers should take the initiative to reach to ensure that events have diverse panel/speaker pool.
Before forking, always ask the maintainer first, they may be happy to give you commit rights to the repo, even let you take over as main maintainer if that is what you want. I have a gem, which at the time might have been "dead", where someone forked it, renamed it, and started doing their own thing (But not really going down a different road worthy of forking IMHO) without even making a single issue or PR on github or contacting me via email. I would have been very happy to give them commit rights to the repository. Fork is the last resort, not the first option.
But are they more qualified than the current speakers? I don't care about quotas. I don't care about race or gender. I just want to see the most qualified and interesting global speakers.
Maybe the sidebar should link to various Getting Started tutorials? The sidebar already links to [The Ruby Toolbox](https://www.ruby-toolbox.com/) which already lists everything/anything.
Awesome link! Another one that resonated with me was Aaron Patterson's talk on [how to dip your toe into open source.](http://www.confreaks.com/videos/1137-scrc2012-open-source-how-to-give-back)
Do you mean in the whole programme or doing keynotes? That might be accurate for the keynotes but it definitely isn't for the whole programme, e.g. see &lt;https://twitter.com/TalkingQuickly/railsconf-2014-speakers/members&gt;. It's just that only the keynotes get photo bio's on the programme page...
&gt; I don't care about race or gender. With that mentality, you are in danger of not caring about people being given equal opportunities &gt;I just want to see the most qualified and interesting global speakers. well good luck with that.
If I can be of any help Hit me an IM, http://kapilrajnakhwa.com .
As somebody who uses RVM, but considered switching to rbenv + bundler, I'd really like to have a more in-depth discussion. So: &gt; nagging me that it should be at the beginning of my $PATH &gt; barfing instructions every time I launch a shell, yelling how my shell should be configured for it to work properly Doesn't rbenv require shims directory on beginning of $PATH? Isn't it _good_ to have tool warn you if its own requirements might not be fulfilled? &gt; confusing rules on when it's active or not in a given directory and/or shell Can you please elaborate what is so confusing? I guess I don't see it, as I got used to RVM... &gt; documentation from hell Could be better, but I've definitely seen worse &gt; trying to do way too much I have to disagree, simply because "too much" is personal opinion (IMO). I like having a single tool for everything relating to project-specific environment (ruby and gems). Hooray for options! :) &gt; getting in my way when its job is to be a silent partner in my development, not be like a high maintenance girlfriend who expects me to spend all my time with her Now, this COMPLETELY differs from my expirience, please elaborate &gt; being a super-bloated pile of shit and thinking it's the best Attitude aside, I agree with bloat point (20k lines SHELL SCRIPT - I died a little when I saw that) - but I guess 2.0 rewrite will save us all :)
Hey man I get what you are saying but as less experienced dev too I think it's easier to internalize examples that are Rails-related. This is thoughtbot's article on the same subject. http://robots.thoughtbot.com/tell-dont-ask 
In same vein as my reply to parent: &gt; you have to update rvm if you want a recent ruby (other version manager alternatives don't require this) TouchÃ© &gt; rvm is not particularly stable, or backwards compatible if you have to do the above Had 0 issues with stability or backwards compatibility - FOWARD compatibility can be an issue though (e.g. a .ruby-version/.rvmrc you get from somewhere specifies 2.1.1, but current RVM version doesn't know about it, then you need to both update RVM and install new ruby) Actually, the problems of backwards compatibility MAY arise if your .ruby-version specifies ruby without patch version - e.g. 2.0, which is/was an alias for "2.0.0-pXXX", then you update RVM, and 2.0 becomes alias for "2.0.0-pYYY", which is not installed. Quite solvable if you create .ruby-version with "rvm use 2.0; rvm current &gt; .ruby-version" - which DEFINITELY SHOULD BE MORE CLEARLY DOCUMENTED. &gt; frequently breaks zsh integration Again, had 0 issues (using zsh + OMZ), care to elaborate? &gt; redefining the cd shell function to work is slightly messy at best, and can cause many more problems in scenarios where things don't always go to plan Not really *nix expert, so I'll just accept that it is a bad thing because of *nix reasons. However, to repeat once again, didn't have any bad experiences... &gt; I've also had other issues in the past such as a bug where launching a cron task that should use the rvmrc specified would fork bomb if the rvm system default wasn't set. I guess if something like that had happened to me, I'd never want to touch that tool again. In the meantime, I'm a happy RVM user :)
Although I always liked the should - kinda reads nicer - expect IMO sounds stricter, closer to assert. Also, there's the matter of cryptic errors when things blow up...
rvm is a very useful tool for beginners, has much better support in IDEs (I'm looking at you RubyMine), and has everything integrated that's needed. That said the main issue with it, that it is shell and directory change dependent. That means if you have a ruby script lying around saying #/usr/bin/env ruby in the shebang, and having an accompanying .ruby-version file, this is what will happen: RVM: runs it with the ruby version of your current directory (which might be completely different) rbenv: runs it with the ruby version specified in the scripts' directory At the moment this is my main concern about rvm on a development machine.
&gt; Doesn't rbenv require shims directory on beginning of $PATH? &gt; Isn't it good to have tool warn you if its own requirements might not be fulfilled? What's so special about the first place in the $PATH? What happens if I use RVM and another tool that *needs* to be in front of every other path directory (say a PythonVersionManager)? Then at least one of them will complain for no good reason at all, because neither actually needs to be in front of the other. The only thing you don't want is the global ruby installation to be in front, but it really shouldn't care that I have /opt/kde-53/bin/ and /opt/postgresql/bin/ before the rbenv shims path, unless there are conflicting binaries in those folders. In the case there is an actual conflict (like with the ack tool on ubuntu, which becomes ack-grep because there is another ack tool) the only solution is to rename one of the executables. That's not really a common problem though. And no tool should feel so special that it feels it necessary to loudly complain each time I open a shell. There is always the option of an rvm doctor tool (or indeed rbenv-doctor which has recently been proposed) which can show where the problem is *if* there is an actual problem.
Thanks for that. I guess that's never really bit me because I'm usually writing my own stuff when working with ruby. One of these days I'll give rbenv a shot.
Seriously, if there should be any tool for this in the sidebar, it should be the ruby-install/chruby combo. They are very very far ahead of the competition when it comes to not being troublesome or doing funky shit.
This is a tough question to answer without knowing your experience level. In production code, be pragmatic. Split up classes when they're too big, not when some arbitrary guideline tells you to. The books &amp; blogs you're reading are giving you a big bag of tools, but they're not always appropriate. Unfortunately, "too big" is an arbitrary standard. If your user class has one instance method, "full_name" - just leave it in User. If you have five different ways of formatting the user's name, maybe it's time for a decorator. Most people let their classes get too big, before realizing that they do too much, but it's easier to split up a large class than deal with a lot of useless abstractions. If you're a beginner, I'll toss out this arbitrary standard for ActiveRecord classes: - 100 lines or less, leave it - 100-500 lines - consider refactoring, if you see a good opportunity. - 500 lines or more, refactor 
Sorry, but no. This is an example of general programming concept, and giving examples in "pure ruby" birngs it closer to all programmers (specifically all ruby programmers, but thanks to ruby's nice syntax it should be understandable to any programmer). Giving a Rails-related example adds a requirement of knowing Rails. Ruby is a great language in itself, and really is a shame it is so often treated as a subset of Rails, rather than other way around...
&gt; What's so special about the first place in the $PATH? &gt; What happens if I use RVM and another tool that needs to be in front of every other path directory (say a PythonVersionManager)? Then at least one of them will complain for no good reason at all, because neither actually needs to be in front of the other. &gt; The only thing you don't want is the global ruby installation to be in front, but it really shouldn't care that I have /opt/kde-53/bin/ and /opt/postgresql/bin/ before the rbenv shims path, unless there are conflicting binaries in those folders. Well, partially true. You want to have rbenv/rvm in front of _any other ruby installation path_, which can in theory be found also in /opt/something/bin - SHOULD NOT but CAN. How can rvm know that anything before it does not point to ruby? The point about having 2 tools which require being first is valid, but I'm not sure what is the preferred solution here. Maybe checking if `which ruby` matches expected path? Or adding a rvm config option "allowed_PATH_prefix" or something? While annoying, I still prefer to get warnings that something might not work as intended, even if it is a false alarm. If rbenv (or any other tool for that matter) solves this in a better way, I'd love to hear about it. 
Well at least you replied before you hit the down arrow. I guess people here are pretty sensitive to criticism. Oh well. Pretend all is well then I guess. 
Did not know about this. I'll give it a spin on Heroku at some point then...
Did not know about this. I'll give it a spin on Heroku at some point then...
What happens if passenger reaps the worker that spawned off the thread running the background job?
Don't be so cynical - I up-voted you. =)
Good post. I'll amend that by saying, I think of "too big" as an alias for "hard to change." If making important changes on your domain model becomes a challenge, consider looking for application or presentation logic in the model that you can move out.
Say I'm making an app that manages the contents of a library. I also retrieve summaries of the books through Amazon's API. Now I am adding a new mechanism by which to add books, and adding a book involves a hook that retrieves its summary from Amazon. I don't want a unit test hitting Amazon, and I don't particularly care about the result of that call. I want to stub the API call, and test my new functionality. If you're making a system which has little or no external dependencies, sure - write every test as an integration test I guess (even though they'll be horribly slow compared to unit tests), but mocking and stubbing are entirely appropriate, well-established testing practices for dealing with external dependencies. 
Those are some excellent specimens of ruby code right there.
I usually don't bother trying to talk people out of using it (on their desktop) if they're happy with it. I will absolutely talk people out of using it in a server environment though (that fork-bomb was on a production server) &gt; backwards compatibility: Just a few months ago, while upgrading to the 1.9.3-p484 security patch release, I tested it on some UAT servers (which are configured using an outdated chef rvm recipe) - worked perfectly. Rolled it out to production, complete failure to run the recipes to install ruby, the problem was rvm 1.25 was released 30 minutes prior to my production deploy. It behaved different enough that my recipe wasn't compatible (and current stable rvm master still has whatever issue). &gt; zsh On zsh, It's been quite a while, at least a year since I've switched to rbenv on my desktop, but when I was using rvm (with zsh+oh-my-zsh), I had multiple instances of updating rvm to get the latest ruby patch, and it just being broken again, like a very simple .rvmrc with a fully qualified valid patch level version of ruby, and cd'ing into the directory would just throw an error. I've seen way too many issues to trust the stability of rvm, and the fact that you have to upgrade it to get recent rubies, just makes that issue far far worse. with rbenv, and chruby, you can keep those at a known stable version (though the fact that they're much smaller and simpler vastly increases their stability), and just update ruby-build to get a recent list of rubies, since ruby-build is installing your rubies.
That paints you in a corner where any nontrivial refactoring becomes unbelievably painful.
Why, exactly, is it easier to read as an if statement? You'll still have to figure out both conditions, then the negation of each. Or is it just that you disapprove of logical AND statements? Would you rewrite the same if statement as unless to avoid using &amp;&amp;? The bias just seems odd to me. 
thx!
Thank you for the insight, that DOES sound scary. I'll definitely reprioritize checking rbenv out.
not so much zoom scale handling but just a responsive design, no?
&gt; Had 0 issues with stability or backwards compatibility - FOWARD compatibility can be an issue though (e.g. a .ruby-version/.rvmrc you get from somewhere specifies 2.1.1, but current RVM version doesn't know about it, then you need to both update RVM and install new ruby) I had an issue once when deploying to a server with an older RVM installed. I guess you could argue that the real mistake was to use RVM in production, it was still the main reason to switch to another solution for me.
If you're into this kind of thing, i've got a thread based queue backend called Threaded https://github.com/schneems/threaded It also comes with a promise implementation and doesn't depend on celluloid. Thanks for sharing, Ruby has such a beautiful interface, i'm glad to see others playing around with making the threading experience as beautiful and easy.
False. Formal equality only exists in pure mathematics. I want substantive equality, which takes into account the past for a whole picture of what would create equality. And yes, that includes using positive discrimination as a tool to achieve substantive equality. 
Then you're hosed. It would be best to use this in development, or in non-critical areas. One potential example, lets say you are using the facebook API which can be slow from time to time. You want to pre-store a list of all their friends but don't want the user to wait while Facebook returns a response. If the cached data doesn't exist you can write the value to memcache in the background. This works because 1 the data isn't critical to have (only nice to have) and if the thread dies, another request will queue the task again. This is the best example I could think of. For thread work, the promise pattern works well as I can tell my task that I need a return result and use it within the same request. This is a bit easier to work with since if the worker gets killed the request would be toast regardless. With the facebook example, let's say you actually needed it in the same request. Early you would detect if the data was in the cache and if not enqueue a promise. It works in the background as you continue to render the page. At the very last minute that you need the data you force the promise to block until it returns and the page continues to render. You're guaranteed to get a result and the behavior isn't __that__ different from the way you normally write code.
Jew? Huh? Anyways... classes = [['Warrior', { strength: 8, intelligence: 2 }], ['Mage', { strength: 1, intelligence: 9 }] classes.each do |class_name, properties| # Create a new class klass = Class.new(class_name) # Inject the information from our properties hash into the class by exposing instance methods. properties.each do |name, value| # define_method works like def, only we can specify the name of the method at run time klass.define_method name do value end end # Expose the class we just created to the outside world by sticking it in the global namespace. Object is the container for all top level constants. Object.send :const_set, class_name, klass end There's your rope, go hang yourself :)
&gt; There's your rope, go hang yourself :) +5 Rope of "Why Doesn't My Game Work?" ;)
Yep. I thought about saying, "you will hate yourself if you try solving this problem the way you're wanting to solve it." However, I think I'm a better rubyist today because of all the messes I've made, and the knowledge I've gained about metaprogramming comes in very handy from time to time. There's no substitute from learning from one's mistakes. Metaprogramming is like Dave's insanity hot sauce: one drop will spice up your whole dish. Too much and you will feel intense pain.
Thanks. I'm about 6 months in. Yeah a few classes are in the 100-200 line number range already. On one hand I might just be super excited about reading this stuff. On the other hand I think "I'll probably do this someday so might as well do it now", if that makes sense.
And your opinion can only ever come from a place of privilege. But this isn't going to go anywhere, because you don't believe it's the responsibility to correct for unaddressed legacies of discrimination. 
Thanks very much. &gt;Jew? Huh? Anyways... It's an actual character class from the [South Park Game](http://www.justpushstart.com/2014/03/south-park-stick-truth-class-guide/). :)
I just don't believe your method is the right one. There are better ways than forcing the numbers. What happens to the people who work hard and are left behind because they're one number past the quota? Sorry, you don't fit, we'll be taking this less qualified person instead. All it generates is bitterness. Half the things I've done are probably due to disability. Nice little +1 on the charts. Ludicrous. It should always be the best person for the job, regardless of background or attributes.
And mostly used in Ruby, a language predominantly developed by Japanese-first speaking people.
That's what I've figured out &gt;.&lt; It gave some example code, but it's not the easiest thing in the world to decipher.
I was trying to use the gem as it states, and it came with some examples, but as I've never used Ruby it's all Chinese to me. I've got it to run, used FBO::Dump::.constants and it told me all the things I could supposedly do, but figuring out how to use them is my problem.
Its this way because hashes were never ordered (pre 1.9) and I guess nobody has found it important enough to break backward compatibility after. The documentation (post 1.9) notes that "Hashes enumerate their values in the order that the corresponding keys were inserted." So you could write a method like "sort_by" which returns a hash however I don't think you could write one which changes the original hash ("sort_by!").
I usually post to /r/ruby so pretty surprised this had any traction over there. Here's the discussion http://www.reddit.com/r/programming/comments/20enqe/why_we_should_absolutely_never_build_software/
&gt; Metaprogramming is like Dave's insanity hot sauce: one drop will spice up your whole dish. Too much and you will feel intense pain. Interestingly, people who know how to apply it heavily can still end up with pleasing dishes, though...there's so much metaprogramming under the hood of our favorite frameworks...
Yes, frameworks are a different beast. You're writing a bunch of ugly code to help people write beautiful apps.
Or you could use puffing-billy and never have to think about it again.
I'd say the opposite is true. See my [most recent post](http://www.reddit.com/r/ruby/comments/20flvy/never_mock_types_you_own/).
What a lovely description =)
Its just a flag for me, like I investigate further based on that rule. Also, I tend not to use small gems unless they're really compelling, otherwise I try to roll my own.
Thank You.
It bares mentioning that although Hashes are great interim data structures, that you avoid [primitive obsession](http://c2.com/cgi/wiki?PrimitiveObsession) consider instantiating them into class instances that better describe and enforce the data they contain.
Thats what happens when you do responsive design properly and use `em` for breakpoints instead of `px` If you use some SASS library like Bourbon, you have a handy mixin `em`, which lets you specify a pixel value, and it spits out the em value. You can also pass it a second param that changes the baseline when you run it
May not be directly relevant, but you asked for resources and mentioned POODR, this talk was given by Sandi Metz at Railsconf 2013 called the Magic Tricks of Testing, it gives her perspective on what to test and what to leave alone: https://www.youtube.com/watch?v=URSWYvyc42M Slidedeck: https://speakerdeck.com/skmetz/magic-tricks-of-testing-railsconf
This looks like a homework problem, but I'll give you the benefit of the doubt. See: http://www.ruby-doc.org/stdlib-1.9.3/libdoc/ipaddr/rdoc/IPAddr.html Regardless your experience level, it would be good for you to become familiar with public api and documentation.
`require "ipaddr"` `IPAddr.new(IPAddr.new("192.168.1.100").to_i - 99, Socket::AF_INET).to_s` =&gt; "192.168.1.1"
&gt; If I change even a single line of code, the tests will fail. The problem is that this attitude permiates deeply into the code base. You can literally find any line of code, and be assured that you will find a test that verifies that the code is exactly what the code is. And the problem with this is? That's what TDD is there for. If there is a line of code that you can comment out that a test wasn't written for, then you should be able to theoretically remove that line, because the tests still pass, so therefore the product should still work, right? (Again, theoretical, obviously we miss stuff or certain things may not be 100% worth testing...also legacy code, of course) &gt; Even worse, we have situations where our tests pass fine, and the developer assumes all is well and pushes it to production where it then often fails due to an assumption about the result of some stubbed out method. rspec-fire helps a lot with this, I'd recommend using it. If you're against that, check out this talk by Gary Bernhardt: https://www.destroyallsoftware.com/talks/boundaries Also, since you might not have the time right now or the bandwidth to implement rspec-fire or look at Gary Bernhardt's boundaries talk, I don't know if you were just trying to make a simple example, but the way you wrote those tests suggests to me that you aren't leveraging all of the tools rspec has available to you. Have you used lets? Here's an example of how I would refactor your tests to be more clear: describe Singer do let(:singer) { described_class.new } describe "#sing" do let(:song) { double(get_lyrics: lyrics) } let(:lyrics) { double } before do lyrics.stub(:contains_profanity?).and_return(contains_profanity?) end context "when a song does not contain profanity" do let(:contains_profanity?) { false } it "adds the lyrics to the tts_engine" do tts_engine.should_receive(:store_lyrics).with(lyrics) singer.sing(song) end end context "when a song contains profanity" do let(:contains_profanity?) { true } it "raises an error" do expect { singer.sing(song) }.to raise_error(StandardError, "I cannot sing songs that contain profanity") end end end end Note that I changed your &lt;&lt; to some other method that you would make available to the tts_engine, since as you said, the test makes sure that the code knows what to do, but the tts_engine is really the one that knows how to store the lyrics. 
yes and that is reflected in its lugubrious, inchoate syntax (lol jk)
Hi synt4x, OP here, I totally agree with you. To illustrate each case simply, I tried to find example where you deal with raw data, and as you said it's either an intermediary step before transforming in ad hoc instances, or it's just simple manipulation that doesn't need more. But for instance, for the 3rd case, it would be better to have a class Contact. The default value would be a new instance of it. Moreover, IMHO, Hash is a specific kind of collection offering a specific contract. Rather directly working with it, wrapping it in a class is a good way to enforce the kind of collection, the domain, you need to manipulate.
That doesn't help me as I want to be able to do it without knowing what the D block is ahead of time.
I read the documentation. I'm sure you can point me to the documentation that explains how to extract the D block out of an IPV4 address and then manipulate said D block. Honestly, I've found Ruby's documentation to be kind of crap. I've gotten way too used to PHP's documentation I suppose. Even MSDN has more complete documentation for both C#, VB.Net, and C++ imo. I guess what I'm saying is that RTFM isn't really all that valid unless said manual actually describes how to do a thing.
I've seen similar tests and feel the same way you do. I started writing a gem to generate these style tests to show how coupled they are to the implementation they really are. Code: https://github.com/danfinnie/code-driven-development Play with it on Heroku (give it a sec to boot up): http://safe-garden-3756.herokuapp.com/
I'm new to Ruby. Could someone explain the line song = double(lyrics: "Mary had a little lamb") Evaluating this in irb gives an error.
use: require_relative 'classone' require_relative 'classtwo' # and here comes the rest of your code
Try writing a test for this without using a mock at all. You can send in anything that responds to :contain_profanity? What I mean is that you don't need to verify that :contain_profanity? gets called, just that the Singer behaves in the correct way depending on what :contain_profanity? returns. class Singer def sing(lyrics) if lyrics.contain_profanity? raise "I cannot sing songs that contain profanity" end tts_engine &lt;&lt; lyrics end def singing? !tts_engine.empty? end end
ah... ty - it looked like a typo akin to float(lyrics: "Mary had a little lamb")
&gt; Fine-grained unit tests often need to be white-box tests because it's easier to stub things out than to put the system into the desired state. That's really what it comes down to. Sometimes, you run into a situation where you can either write a five-line before/let block or you can just define a double on a single line. I know I'll do the latter every time, especially if the alternative involves ActiveRecord objects or something else particularly heavyweight.
Neat! I love Sidekiq, and am glad to see more community contributions towards it
I agree there, there are already many. I was simply making a point that if that was the concern, there are other ways to tackle the problem. Not that it was my concern. 
Know any other (open source) Ruby projects for the World Cup in Brazil? Or any open data sets or services? 
Thanks. Hope you find it useful.
We wrote a gem to do this last year: https://github.com/sittercity/breaker_box Basically has all the same principles.
Can you explain more about what you're wanting to do? Classful networks haven't been used since the introduction of classless subnets (CIDR) and a class D network referred to reserved IPs for IPv4 multicast. If you want to determine the first usable IP in a /24 subnet (class C network), you can do so with: &gt;&gt; IPAddr.new("192.168.0.100/24").succ.to_s =&gt; "192.168.0.1" 
The 4th octet can be found with `IPAddr.new(str).to_i % (2**8)`
You could also try the `ipaddress` or `ip` gems.
Thanks! This might come in handy at work. 
This is what I have decided on at this point. The book I'm learning from is "Learn Ruby the Hard Way" and the author says the same thing. There is a "bootcamp" in my area that only use text editor also- may as well emulate since I may enroll at some point. 
really? That lets me pull out the 4th octet? Because I'm pretty sure that's a string.
UBUNTU!!! I'm digging it. I wiped out windows and am now a full convert. :)
does 'ls' list the file in the current working directory? It looks like you're in ~ (home). 
Yup. I find that working with constraints makes me hate the thing for the first few days/weeks but ultimately makes me faster. I was slow as hell on OS X as first but now I don't see myself using Windows as a dev machine in the future. I uninstalled Netbeans when I got to Sublime and I was slow at first. Now I have to uninstall Sublime and get frustrated every single time I mess up a command in Vim... it's the most irritating thing ever but it has to be done. Regarding tools check this out: https://learn.thoughtbot.com/trails. I found out tmux there, it's almost as important to dev as a text editor. I hope you find that link useful :)
I am in home. It is not listed there. 
When you type "ex1.rb", ruby assumes you're referencing a relative file location. You can either: A) Make sure the file is in the directory you run the ruby command from B) Use full path names
I think I'm seeing where the error is- I need to be in the correct directory? What is best practice in this, create a new directory somewhere or just use the one with the folder I created?
Got ya. I moved the file to my "home" directory and no issues. What confuses me is that the folder I had in home did not show up when I used "ls". How would I get into the directory of a folder in home? 
Nevermind- I used cd filename. Thanks for the help. Ubuntu is new as is using terminal. I appreciate the help. lol
The host range is entirely in the fourth octet for a /24 (32-24=8), but it wouldn't be for larger subnets. What are you trying to do?
Maybe you should learn how to use an OS before a programming language... Edit: How is this getting downvoted? He/she didn't even know how to use cd, ls, or that you had to navigate to a file to open it, rather than just typing run the file and praying. Surely they should understand basic OS usage before trying to write programs?
`cd -` - change to the last directory you were in `cd ~` - change to your home directory To change to a directory in a home folder you can either explicitly address it from wherever you are: `cd /home/shinylid/folder`. If you are in your home folder (you can see where you are by running `pwd` which stands for *present working directory*) you can change to `/home/shinylid/folder`: `cd ./folder` or `cd folder` The `.` means "current folder", which is the same as whatever `pwd` returns. You can use `..` as well which means, "go up one directory". If you run `cd ..` from `/home/shinylid/folder` you will be back in your home folder.
It probably installed the gems in the system-wide location. If you want to wipe it and start over, you could do "rvm implode", then "gem list" to see what's left behind, then "sudo gem uninstall" all of those, then re-install rvm. 
Hey John, I'm really interested in a jekyll gui, especially open source! Did you still plan on releasing what you have?
I used to get myself into trouble with this sort of thing until I learned about creating project specific gemsets, which is very useful when you are juggling different versions of Ruby and Rails. As an example, here are the steps I used to create gemset for a recent project using Ruby 2.0.0 and Rails 3.2.14: $ ruby -v $ rails -v $ mkdir projectname $ cd projectname $ rvm use ruby-2.0.0@projectname --create $ rvm gemset list $ rvm gemset empty projectname $ gem install rails --version=3.2.14 $ echo "ruby-2.0.0" &gt; .ruby-version $ echo â€œprojectnameâ€ &gt; .ruby-gemset $ rails new . Now, if I update my default gemset, my older projects are safe. Get more info over at rvm.io 
Why not just use Bundler and let it be rvm-agnostic?
Holy cow, strawbatman! 
It's probably because you sounded like an ass saying that. That said, I agree... OP needs to learn some basic command line tools first.
If you just want fourth_octet_value, you can use the built-in String::split method: &gt;&gt; "192.168.0.100".split('.')[3] =&gt; "100" If you want to manipulate the IP based on subnet, you should use the ipaddr module.
I generally keep a folder called code or workspace or something similar in my home dir, and within that I make separate folders for the different things I work on. Stashing many fiels in your home dir is gonna come back and bite you in the ass eventually.
Yeah of course, but there has to be some basis to it. I mean, you should be able to navigate a file structure.
This
Actually, I did understand cd and those commands, but I was not aware I had to be in the specific directory and folder to run the file. I am learning a new OS while learning Ruby. Coming from windows I didn't need to run terminal ever. Now, who asked you come out from under your bridge? Maybe try being constructive with your posts- if your ego allows it. 
Character attacks are always easy if you can't come back with something intelligent, I suppose. You'd be better off understanding how to use the OS or you're just creating problems for yourself. Not knowing something as basic as needing either a full file path or being in the right directory is just going to give you a lot of hassle down the line. Its tough enough learning a language, without having to deal with everything around it at the same time.
The '$' isn't part of the command. It represents the prompt. Try just ruby --version When you open the terminal. If your on OS X that should get you going. 
From your shell: \curl -sSL https://get.rvm.io | bash -s stable --ruby=2.1.0 Log out then log back in or source your .profile/.bashrc/.zshrc/whatever configuration file for your chosen shell. Then you should be able to do ruby -v and it should tell you the version. You can then test gem installation by installing this great gem gem install irbtools Now add it to your .irbrc echo "require 'irbtools'" &gt;&gt; ~/.irbrc Now when you run .irb you get a lot of cool new features to make your programming/learning easier. Good luck.
Yes thank you 
So now that I can use textmate and just run my apps from terminal correct? 
yep, that should work :)
last question. If i want to implement 'shoes' to create a GUI. I DL and then what?
Try _gem install shoes_ in your Terminal.
Don't downvote honest questions, guys, come on. It sounds like you're starting way at the beginning if you're confused about prompts. That's ok! Everyone starts somewhere, and the beginning is a good place to start. Are you downloading shoes to play with Hackety Hack, by any chance? If not, I'd say starting out with GUI programming in a scripting language without knowing the language itself first is a bit backwards and might lead to some frustration. I certainly wouldn't want you to be turned off to a great language too soon! So for Ruby itself, there's no better starting point (IMO) than [_why's (Poignant) Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/). Read it. Love it. TextMate is a good text editor (though a lot of people are using [Sublime Text](http://www.sublimetext.com/) or [atom](http://atom.io) nowadays), and will really help you if you learn some of the key bindings. The easiest one to remember is `âŒ˜T`, which will open a little pane for you to search for files in. As far as bash goes (bash is the program that runs in your terminal that you type commands into), look around [here](http://www.tldp.org/LDP/abs/html/basic.html) for a bit. Some of those commands are kind of unnecessary at first (like `rev`), but it will give you a good jumping off point for getting around in the command line.
OP: http://gph.is/1fKujFf Not being sarcastic... you can do it! One step at a time!
On top of what SimonGray said, you may need to `require` it in your script somewhere.
exactly lol
I want to write apps for phones and/or get a job coding for ruby. I want to learn it all but I really don't have any idea how to even begin. I have a very small background in VB program from like 13 years ago. I understand only the basics. What would be a good program for me to learn on? what type of program should i learn to understand things like intregrating a DB and website, or a DBase and an app? 
And since it's the system ruby, probably `sudo gem install shoes`.
Rails is a framework which makes it (somewhat) easier to create websites with Ruby (ie: Ruby on Rails). Ruby is the programming language, Rails is a package of functions which automates most common tasks (like adding a database to the website).
No offense, but how is your example any better? In two places you have background code like `lyrics.stub(:contains_profanity?).and_return(contains_profanity?)` reference values that future nested contexts further in the file implement. My eyes have to jump up and down as if I were watching a giant dribble a basketball just to follow along. I have tried to work with rspec tests that look like this, and after about 70 lines of code I start feeling like I'd prefer to grab a baseball bat and start wailing on my own kneecaps. You appear to have reduced the amount of change required in order to support refactoring, but that's ultimately trivial, and it came at a hefty readability price. The explicit coupling of the messages being passed between objects *is* a problem when refactoring. Objects shouldn't need that much state management to test. Nesting more than one layer deep in tests is a smell. I've gone back to test unit over this issue and I've never looked back. When I need to break up a test into a few parts, I just break my test class into a few separate test classes, each telling a different part of the object's story... that combined with dependency inversion and smart doubles for service objects that do things like hit the network. Way easier.
https://github.com/rapid7/metasploit-framework
Here's a really good beginner's tutorial for getting started on Ruby: http://ruby.learncodethehardway.org/book/ Exercise 0 should be what you need for getting set up running ruby programs from the command line, and will walk you through all of the `$` nomenclature. Ruby is currently very popular for creating websites with, because it has a very good framework (a collection of useful Ruby programs) called Rails that makes website writing easy (you write Ruby code with Rails that will in turn automatically generate files in HTML and CSS). Jobs doing this can earn $50-$150/hour.
If you want to just play around with Ruby and learn, you should try out the Ruby [REPL](https://en.wikipedia.org/wiki/Read-eval-print_loop). Its built in to ruby, and is included with the ruby installed by default with OSX. All you have to do is type `irb` at a prompt in terminal. [Check this out for details on Terminal, IRB and some Ruby basics](https://www.ruby-lang.org/en/documentation/quickstart/) From there, try out some Ruby operations like `1 + 1` `puts 'Hello Reddit'`
Agree to disagree, I suppose. I think my example is much more readable. I believe the contexts should speak for themselves instead of you having to read back and forth up and down the page. If you have 70 lines worth of contexts, that's probably an indication you are trying to test too much and the code needs to be broken up into separate objects. (As you said with nesting more than one layer deep) Not quite sure what you mean by the explicit messaging part. Are you against the should receive because if you refactor that code to use a different method that may do the same thing it suddenly breaks the test? In that case I'd argue that the test then knows how it works and that should've been encapsulated in the actual object's method test and not here. If you're arguing from a rename standpoint then just change the test and who cares because it's tested. I'm on my phone so I didn't give this a ton of thought, but wanted to reply and give you my opinion. No offense taken, always good to hear more sides of the story and explain why I choose to do what I did :)
* [Ruby for Pentesters](https://www.blackhat.com/presentations/bh-usa-09/TRACY/BHUSA09-Tracy-RubyPentesters-PAPER.pdf) * [Greyhat Ruby](http://dontstuffbeansupyournose.com/2011/04/27/greyhat-ruby-source-boston/) * [Ronin](http://ronin-ruby.github.com/), [librex](https://github.com/hammackj/rex#readme), [rbkb](https://github.com/emonti/rbkb). There are many many other Ruby libraries that are useful for specific tasks. If you just need to try a bunch of known exploits against a server and write up a report, there's also [metasploit](http://www.metasploit.com/).
A savvy, experienced engineer can write great contexts in rspec. I won't doubt that. But over the years of rspec being the de facto standard of testing, I've come to realize that those same savvy, experienced engineers will do just as good a job with any tool, and rspec's syntactic sugar is just that, and nothing more. Aside from my rant about how I hate how indirect rspec example groups are vs. test unit (a windmill that I find distracts me from many useful conversations, so I apologize), I was really trying to convey that unit tests that rely on *mocks* to decouple the test subject from the environment often get in the way of refactoring. Mocks force you to reimplement your interface twice; it's a huge pain to me. For complex services, sometimes you invest in building smart doubles, using ruby's metaprogramming behind the scenes to hide the coupling from your code. fakefs and webmock are great examples of doing just that. I prefer that approach to testing over heavy mocks.
ill look at this as well 
We were all just like that giraffe/OP once. Even the most hardened neckbeard was once a noob.
http://imgur.com/eDtFMQd Thanks all I finally got it too do something.
Hey, still a bit of a junior-intermediate here, you might want to start with [Rails for Zombies](http://railsforzombies.org/levels/1) and [TryRuby] (http://tryruby.org/) first if you're starting from super scratch to get an appreciation for what exactly Ruby and Rails does. I, too, did not know what the heck "$" was when I was starting out. :)
It doesn't check to make sure a move is legal before adding square, nor does it check to make sure there aren't legal moves left ([img](http://i.imgur.com/Wmu9ntr.png))... Also, thanks for totally ignoring [XDG_CONFIG_HOME](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html) and polluting my `~` more.
&gt; What do you mean it doesn't check to make sure a move is legal before adding a square? So, in the original game, if I attempt to make a move that isn't legal, then nothing happens. In your version, if I attempt to make a move that isn't legal a new square gets added to the board. So [this is the starting position](http://i.imgur.com/b6mdW3i.png), then after issuing right (a non-legal move) I get [this](http://i.imgur.com/YmOz26H.png)
At least not in the original version of the game. You're ruining my button mashing method ;-)
You know you won the argument when the other person starts acting like a child. Way to respond with logic there. Ofcourse you will say something about how your calling me strawbatman was some sort of logical reference. But you neither responded to my logic, nor presented anything in contrary.
&gt; Jobs doing this can earn $50-$150/hour* *After you have a few months/years of experience and/or a good deal of domain knowledge and you live in one of the web-heavy tech hubs like SF or NYC. Just thought I'd add that little explanation for people new to the field. 
yeah as others pointed out you need to add the source command to your.bashrc (assuming you're using bash). rvm installs its files, including the ruby executable inside the. rvm directory in you home - it's not changing the system-wide ruby installation by default. try running 'which ruby' to see which executable is used at the moment. should be different before and after "sourcing" rvm. 
Run rvm get stable --auto-dotfiles And then restart your terminal. This should put everything you need in it's place.
i'm still very early in ruby, wanted to learn more about ruby and ror. I'm moving to SF bayarea, livermore or fremont by august. Any suggestions on where to learn, not free looking for kind like a bootcamp or school, or even like animationmentor.com all online.
What do you guys think of this pattern?
I've used it before to select lambdas based on vertical/horizontal aspect ratios in a test: expect { portrait: -&gt;(w,h) {w &lt; h}, landscape: -&gt;(w,h) {w &gt; h}, square: -&gt;(w,h) {w == h}}[aspect.to_sym] .call(w,h).to be_true Something like that, I've since switched to separate tests for each aspect so other people can follow the test more easily.
I think table makes sense.
I still think that the if...elsif and the case...when scenarios when you are calling methods make more sense to me. However, I'd implement this patter in the flash case scenario.
The one I know about is railsbridge.org. There is plenty more, but you can google them just as well as I can.
After watching the video i was also wondering about what benchmarks would look like. Maybe later this week if i have time i'll throw together some tests.
I'd expect _if_ to be about twice the speed of _case_, and _hash_ to trail by a small margin (if using symbols). Not that it really matters; while this could be used to tidy-up some really convoluted logic I'd suspect fundamental design problems if I came across this "in the wild".
Thanks for the reply, right after I asked was what did. Thanks anyways 
Is the data tabular? Use a table. No? Don't use a table. Never used Shoes before but in web development, there is an eternal fight over tables. You want your code to be semantically correct. That means, if you are displaying tabular data, you can use a table but you should not use it just to get your content looking right. Of course, you *can* use table in that way but hardliners will give you grief for it. edit: What does tabular mean? Tabular data means, roughly, that there are rows and columns and that those rows and columns *mean* something. In this case, we want things arranged in a grid but the data is NOT tabular. Take a look at any calculator. The first column is [7,4,1]. 7, 4, and 1 share nothing in common. This is just an convenient arrangement of buttons- the rows and columns mean nothing. Each row and column isn't sorted (or sortable) and each row and column signify nothing of importance. Consider that you *could* re-arrange the buttons in any way you want and it wouldn't change the data at all, other than surprising the user. (Protip: Never surprise the user!) So no, this is NOT tabular and you should NOT use a table. But you COULD if you wanted to without much consequence. Even I might use a table, to save time. 
This is desktop, not web dev :)
In general when asking for help it is also important that you not only list the steps that you took but also the output from each step. As it is we can't help you because we don't know at which step things break down.
Same concept probably applies though, right?
Far too much here to process. Narrow your focus and come back with a more specific question. Where are you stuck in this process? Are there any error messages? Did you READ THE MANUAL? (This is an important one!)
Intelligent? I guess there are two methods of thinking about intelligence. There is the play it by the books learning method, or the one I use which is learn by doing and by necessity. While I could have limited myself to learning my new OS, instead I choose to learn what I needed as I came to it. I'm glad I did too, because I learned what I needed to in less than an hour and I'm back to learning Ruby. Thanks to all of you for your help! :)
Thank you!
It's been a while since I played with it, but I don't think shoes supports tables, per se. I think it does support rows, but you need to emulate columns though manual specifying the width. 
Personally, I've used devise in a similar situation and it was a pretty good fit. For the collaboration, though, I used a custom authorization (not authentication) based on database relationships. Once you have some code started, post and I'll take a look at it
Sorry! I admit that I am ignorant of best practices. Most of the problem so far is that "ruby script/plugin install auto_complete" returns with an indication that no such file exists. Further, the rake command seems to be outdated, and so I am unable to set up the database. 
Sorry, but I really think the first example is the only one where it's appropriate to use this pattern. If you're choosing between a bunch of procedural options, a case statement is much more idiomatic and easy to read. If it is slower than a hashmap creation and lookup, then that's a fault of the interpreter, and even so the performance penalty isn't worth the confusion for future maintainers. 
I completely agree with this sentiment. Hashes are idiomatically used to store data, and barring particular exceptional situations, should be used as such. Also, why even use the "hash selector pattern" when the standard syntax is only one more line: values_by_case = { :case_a =&gt; 1, :case_b =&gt; 2, :case_c =&gt; 3, } value = values_by_case[case_param] I would like to add that there's no reason to use this "hash selector pattern" for speed if you're having the interpreter to re-create the whole hash just to select one value from it. If the number of cases in the hash or number of reuses of this hash gets large, then it should be stored in a persistent constant or instance variable.
For recurring jobs, have you looked at sidetiq?
I think everyone could learn from this http://betterspecs.org/
Thanks. Going to try it out first thing in the morning ! 
Then look in script folder and make sure that plugin file is there. If the file is not there then there's nothing you can do with that instruction.
At the terminal, what does `ruby -v` give you?
No Just because the "table" (or any other arbitrary name) construct in HTML is meant for tabular data does not mean that a "table" (or any other arbitrary name) contruct in another paradigm has the same goal, semantics and limitations. You cannot assume that.
Jew? WTF? 
If we're talking about HTML \&lt;table\&gt; element, then yes, DO NOT use it for layout - use it for data. However, a "table-like" structure for layout is really not an issue, BOTH on web and desktop. See for example: www.w3.org/TR/css-grid-1/ Now, I don't know about Shoes, but have (some) expirience in swing and flex, and they do have a "grid layout container", where you specify number of columns and rows, and as you add items they arrange themselves - I'd expect Shoes to offer something similar. In any case: table-like layouts are not the devil himself, but rather a VERY useful, and correct, tool for the right situation.
Some people just want to watch the world burn.
I can't understand how this can be valid Ruby code.
Please explain this code. It looks like a perfect brainfuck by itself already. 
If you're interested in the grittier details, I've written [a blog post](http://threeifbywhiskey.github.io/2014/03/05/non-alphanumeric-ruby-for-fun-and-not-much-else/) in which I give FizzBuzz the same treatment. Essentially, though, it boils down to the fact that Ruby is pretty symbol-heavy. To get numbers, for instance, you start by retrieving a 1 with `$$ / $$`, then you use underscores as local, global (prefixed with `$`), and class (`@`) variables to hold your data. Building strings is just a matter of pushing these numbers into empty strings with the shovel operator (`&lt;&lt;`). That's most of the symbols right there, but of course there are more. To loop, we have to use recursion. We can't define methods with `def`, though, so we have to resort to "named lambdas" which call themselves unless, for example, an index variable has reached the desired limit, at which point the lambda returns the value you were looking for. We define these lambdas with `-&gt; { }`, call them with `[]`, and pass them to other functions with `&amp;`, the `to_proc` prefix. I didn't want to reveal the trick so soon, but [here](https://gist.github.com/threeifbywhiskey/9619262) is a much more legible version of the same code, just before I started removing all the alphanumerics; it should shed some light on how this can in fact be valid Ruby code that, more than that, does precisely what we intend it to do.
I'm considering writing up a blog post to follow up on [this one](http://threeifbywhiskey.github.io/2014/03/05/non-alphanumeric-ruby-for-fun-and-not-much-else/). There are certainly many more interesting tricks this time around.
It's really a great deal more than just symbolic obfuscation. Without alphanumerics, all of Ruby's keywords are off-limits, and you're restricted, in essence, to the lambda calculus with easier numbers and "object" manipulation. Before the translation, it [looks](https://gist.github.com/threeifbywhiskey/9619262) and feels so much like writing Lisp.
Please let me know if you reached a solution. This question has been nagging at my brain, and I'm currently feeling too lazy to install Shoes and test it. :P
Thanks for the info. I've looked into custom authorization a bit, and I think it could work. I am going to start working on this soon, so I'll post once I get something together. Thanks!
I keep getting errors. Dont quite know how to structure the code to make a table. The try again when I get out of bed
Ruby is a rather complex language with a lot of small pitfalls like that. I think they really only speak in general terms here, so new programmers are aware of this. If you look at library methods, especially in Rails you will find that it is extremely common in Ruby land to have methods take a wide selection of argument types and then resolve inside the method what exactly should be done by examining the attributes types. Of course there is often a "Ruby" way to do a lot of things. For example if you say you check an array for nil, then it would be typical to either remove them with Array#compact. But such pieces of information are mostly spread all over the internet. Or found in some of the better books. Though once you get a feeling for the language you will soon enough know what to look for.
"As long as you wrote tests, it doesn't matter what your code looks like."
Often, when checking types, there is a better way, like checking `respond_to?` or explicitly casting. E.g. if your function takes either a single item or an array, you can use `Kernel#Array`, like so: def find(ids) ids = Array(ids).compact ids.each do |id| ...find item by id... end end This way, any of `find(2)`, `find([2,4,6])`, `find(nil)` or `find([1,nil,5])` will do something sane. (*Note, however, that this method fails if the argument is a Hash*) Another example: if arg.is_a Hash arg.each |key, value| do ...something with the key and value... end end might be replaced with: if arg.respond_to? :key arg.each |key, value| do ...something with the key and value... end end This, of course, is basic duck typing. Maybe we don't actually care that the argument is a Hash, we just want to know that it acts like a key/value store. So really what they're saying is that explicit type checking is not wrong per se, but it is a common indication that there might be a better way.
When you run the specs locally and in staging you are testing. When you run them from an external host you are monitoring ... think pingdom++
Shoes arranges elements using 'flow' and 'stack'. Flow is a horizontal grouping, and stack is a vertical grouping. stack do flow { button '1'; button '2'; button '3'; } flow { button '4'; button '5'; button '6'; } flow { button '7'; button '8'; button '9'; } end 
Alas, the culprit is something so much less interesting, and its name is `brainfuck_p`; this inner lambda is being called recursively to do looping, and even though I tried my damnedest to put all my loops into tail position, Ruby does not perform tail-call optimization without being compiled specially or being told to do so [using lots of words](https://gist.github.com/rogerleite/5101751). I would really like to find a way around this hurdle as it's currently preventing non-alphanumeric Ruby from being truly Turing-complete, so any insight you might be able to provide would be greatly appreciated.
This is an interesting idea, not sure I'd pay for it as we have extremely high code-coverage, but I could see people doing so. Good luck, I hope you can make some money off of it.
The example character classes I cited are actually the ones available in the South Park Stick of Truth game.
I have. It's neat, but scheduling jobs throughout different source files strikes me as poor seperation of concerns. (And as a practical matter, it's hard to view them all at once, though I could probably come up with a clever workaround.) Also it's not clear how it behaves when running multiple instances - are jobs duplicated across N sidekiq workers? So far good ol' cron always comes out on top for me.
Nice, I did exactly the same road as you did, some time ago: http://blog.8thcolor.com/en/2012/07/from-java-to-ruby-what-i-love-what-i-miss/
I've realized, after looking at your unobfuscated code, that the problem wasn't what I first thought it was (that is your logic for finding matching brackets looks correct to me), but I don't think it's just a matter of limited stack size either: Even if I reduce the BF code to just `[[]]` and nothing else, I get a stack overflow. That program should run with a much lower stack depth than your hello world program, so the only way I see how it could blow the stack would be if it loops (i.e. recurses) infinitely, which would indicate some kind of mistake in your looping logic. Oh I found the problem: `nil != 0`, so you treat memory not-yet-written-to as true when it should be false. So you need to `||= 0` (or just `|| 0`) when checking your loop conditions.
That's one way to think of it. Another would be: /u/sepp2k, QA hero. He'll help you find the bugs in your code free of charge.
I posted this several months back, I finally got around to adding some more things that I really wanted in this library. * **Nested Resources** Now you can pass a class in the resource block to parse nested resources of data * **Arrays** Spigot parses an array of data now, which makes consuming feeds SO Much easier. You guys provided great feedback last time I was here, I really appreciate anything you guys have to say!
fine ;) and welcome but first you should learn, that Ruby is a programming language and Rails is a framework written in Ruby.
Leave comedy to the professionals. Seriously. 
So, I like this comment: &gt; The key is to start with just a couple of extra layers and keep those layers decoupled so that more can be added, allowing you application to scale in complexity with ease. ...but it doesn't seem to be reflected in anything else. Specifically, "the rules" that immediately follow it make it pretty difficult to scale up in complexity from "fat model, skinny controller" into what is being advocated.
The idea and architecture are awesome, but this article leaves much to be desired. How exactly does this rails adapter look like? How do I pass in the params of a form? Who's responsible for validating forms? A much better article (actually a series of articles) about this kind of architecture is the following one: http://hawkins.io/2014/01/rediscovering-the-joy-of-design/ He's using Sinatra instead of Rails and IMO that's the better choice for this kind of architecture. In a Rails application the framework dictates the folder structure, but you actually want your application to be at the core of the system and not the delivery mechanism (the web/console/...). Sinatra allows you to do this. There's also the following quote which struck me as odd: &gt; My advice is to write your own data mapper without making it general purpose or feature rich. Well, that's easier said than done. Just a simple example when using a RDBMS: Someone updates the `Task` and has removed two tags and added one. You now need to update the join table accordingly. It gets even more complicated if you have some deeply nested object graph. You can take the easy route and create SQL SELECT queries for each entity of your domain, but this will not scale at all, you better eager load the relationships. But since the data mapper pattern is essential to the hexagonal architecture, I see two possible solutions: * Use some database which allows you to save and fetch your object graph without much pain (most NoSQL databases will be fine). However, this won't work if your data is mostly relational. * Use ActiveRecord (or any other mature ORM) under the hood as a thin layer around your database.
&gt; "No inheritance or mixins" + "Prefer composition over inheritance" - What? Using mixins is how ruby does composition Using mixins is a form of inheritance. In fact: It's multiple inheritance. In order to see this: Call `#methods` on any object whose class has included a mixin.
&gt; "Repository Pattern" - Isn't that what ActiveRecord is supposed to do? ActiveRecord mixes your domain logic and the persistence layer. The repository pattern (or data mapper - the definitions are kind of muddy) tries to separate the two. /edit: According to [Martin Fowler](http://martinfowler.com/eaaCatalog/repository.html) I was wrong: The repository is another layer on top of the data mapper. The point stands: ActiveRecord doesn't separate business logic from persistence, data mapper does.
&gt; "The skinniest of controllers" + "The application has no knowledge of the framework" - How can the application have no knowledge of the framework if it has to implement framework-specific logic in the controller (render, redirect_to, etc) Obviously the blog post doesn't help understanding the architecture at all. Decoupling the delivery mechanism (the web with all these things like `render`, routes, HTML, ...) from the application is one of the keys of the hexagonal architecture. The application has in fact no knowledge of the framework. Try to read http://hawkins.io/2014/01/rediscovering-the-joy-of-design/ and watch https://www.youtube.com/watch?v=WpkDN78P884 to understand what the blog author has in mind.
The killer for me is a mobile app I made (for trademark searches) along with a json api that does most of the work. My api in turn gets its data from a government api which can change w/out notice. And every time that happened, I'd find out only when my customers complained that the mobile app stopped working. So I built this to continuously run my specs against my production api server. And I figured there are probably other people who could use something like this.
::edit:: ah, I didn't understand what Composition really meant
Thanks, I'll check up on these.
&gt; (which then may be implemented with ActiveRecord or something else, like in-memory values or fixtures when in testing?) Yes, you can replace the repository pattern with in-memory stores which makes for very fast test suites. &gt; It sounds like while this may be useful when many queries get complex I'm not sure it helps with complex queries, ActiveRecord's scopes already do a pretty decent job. The big benefits I encountered are: * Everyone who's tried to switch databases (e.g. PostgreSQL -&gt; MongoDB) in a Rails application will notice how many parts of the application are actually dependent on the persistence layer. Providing a clear boundary between your application and the database makes switching databases much easier. * The public interface of this boundary (combined with your tests) tells you exactly what database requirements your application has. You can look at it and see stuff like `fetch_tasks_for_user_ordered_by_created_at(user_id)` and `count_tasks_for_user(user_id)`. So you better not embed your user into the task collection if you're using MongoDB. IMO the additional overhead (which isn't much to begin with) is worth it.
 def equals?(object) return unless object.is_a? Gallery !((self.gid.nil? &amp;&amp; object.gid.present?) || (self.gid.present? &amp;&amp; self.gid.equals(object.gid))) end this \^. this is horrible. there's major structural coupling, there's type checking, and there's nil checking, and there's deeply nested nil checking. and what this is representative of, is that Ruby has not been embraced for Ruby's sake and its powers and limitations. It has been merely used to change the syntax. Embrace the lack of static types, embrace the duck typing. going to repost the comment i left on one of the gists: --- def equals?(object) return false unless object.gid return false unless gid # the self here is redundant gid.equals(object.gid) end embrace the duck typing instead of type checking. and even the [guard clauses](http://sourcemaking.com/refactoring/replace-nested-conditional-with-guard-clauses) should be pushed further up the stack or done away with in some way. this should look like def equals?(object) gid.equals(object.gid) end --- also &gt; You will miss your refactoring tools. no. RubyMine has great refactoring tools for Ruby. the rest of this post is pretty innocuous.
Thats what I was looking for
Interesting read. Thanks for sharing. I'd also read a post on your brainfuck interpreter.
Recent convert here, within the last several months. My first programming job was a Ruby/Rails job. I left for a .Net job while I was in college, with the attitude "Forget Ruby, I'll stick with REAL programming"... oh, to be young, naive, and cocky again... Now I'm wishing I'd stuck with Ruby all along. It's (IMO) more fun to program in, cleaner code, and all-around easier to use. I used to think that was a bad thing, but after working with C#/.Net for the last 6 years, I'm absolutely loving how much more productive I am with Ruby. Welcome!
I feel like the respond_to? is a part of what i could feel missing. I don't really care what the thing is, just can I do what I need to with it.
...nested ternaries... the horror...
That gave me mind cancer.
Everything is not an object. Fucntions/methods are not objects which is the thing that I dislike about Ruby the most.
Hey. Yes I was moved up to a full time position. I dont think my exact salary is important but I will tell you I may literally be the lowest paid rails dev in America but It doesnt really bother me much. I'm getting paid more in experience than I could in money.
This line made me cringe. 4 booleans and 2 sets of nested parens, aaaaaahhhhhh! My rule of thumb is no more than one boolean at a time. If you absolutely can't get rid of some booleans, at least doing it in multiple steps over multiple lines will make someone much happier in the future when they try to understand it.
I wouldn't call that passive "watching". His work is way up there with pouring on fuel, waving a blow torch around, and fanning vigorously.
I think learning the rules of statically typed OOP so you can break them is an extremely useful tool.
I installed both 1.8.7 and 1.9.2 using rvm. I believe that the app was developed using 1.8.7; however the gem rubyzip apparently requires 1.9.2
To be fair, she did say: &gt;Now letâ€™s try to do something **similar** in Ruby on Rails *(now, this isn't the Rails-way, it's more like a literal translation here, folks!)* It would be nice if she followed up the first two attempts with something closer to your example, though.
So, the issue is that you need to send back the authentication cookie that gets sent to you by the login call. This is how you *persist* the authentication across requests. You do this with curl by manually parsing the "set-cookie" header and then sending back the relevant data with a "cookie" header. [Here's how](http://en.wikipedia.org/wiki/HTTP_cookie#Implementation) the headers look. 
Indeed. It's something I find pretty weird in the language, coming from years of Python development. Passing a function or method simply by its name is extremely common. Even Java 8 just added support for it (`doSomething(System::println)`). I know it can't be implemented very naturally in Ruby due to the fact that parentheses on method calls are optional, but methods (not procs or lambdas, but actual methods) could still use a full OO interface.
You said what I came to say. Thanks!
(1..5).map { |i| i % 2 ? (i % 2).zero? ? :even : :odd : :doubtful } just because i can.
That's a good question, and I was kind of surprised that the main http gems I'm aware of (httparty and faraday) don't come with cookie support. With the caveat that I haven't used it, [httpclient](https://github.com/nahi/httpclient) seems to fit the bill. Really, though, they aren't too difficult to implement yourself. Something like `request.headers['Cookie'] = response.headers['Set-Cookie']` will usually fit the bill in a pinch.
That's more of a "recommendation engine" and IMO you should look into python for that if you want public libraries. This is the same sort of algorithm that amazon/yelp/etc. uses. 
the java implementation doesn't look so hot either.
This is also true
Sure, it's really easy to do...but do you want to have to add that line every single time the server sends a response and you want to send another request? Makes for a big hassle.
I'm thinking this is an early (pre 3.x) Rails application, and pre bundler (gem). Getting all the right gem versions in order to make this app work is *going* to be a headache. I wish I had some good advice for you, but if you don't have a Gemfile in this apps root directory, you will be stuck in gem-hell. Gem-hell: the nightmare that existed before bundler. Essentially, before bundler, rails apps would just use the most recent version of a gem that is installed. Back in the old days, this usually worked. But by now, many of the gems this app may need have either died or have progressed beyond the point of usability. The only way you know which gems to install was, hopefully, in the README. If the above is the case (you have no Gemfile), all you can do is install gems, one by one, regressing to earlier versions until you hit the right combination that works.
She.
Recommendation engines (machine learning (math)) is hard, I'd go shopping (googling) for a ["recommendation engine as a service"](https://encrypted.google.com/search?hl=en&amp;q=recommendation%20engine%20as%20a%20service). 
Thanks for writing it! It cleared up some pain points I had using the hexagonal architecture in the web. I especially liked the form objects. They seem to be the perfect place to do type coercion. &gt; It's surprisingly easy to create a domain specific data layer using low level drivers such like Sequel/Moped/Redis. I'm currently doing exactly this using Redis but still struggle from time to time with relationships. But it's not too bad. :)
Some friends were half-jokingly talking about forking ROM and calling it *Godot*. I told them that yeah, that would have been a more-appropriate-in-hindsight name, but their time would be much better used by pitching in with ROM as it is. I find [Data Mapper](http://martinfowler.com/eaaCatalog/dataMapper.html) much more use-friendly than Fowler's original [Active Record](http://martinfowler.com/eaaCatalog/activeRecord.html) pattern, let alone Rails' variation on the pattern.
&gt; Rails folk have a much harder time with it Just yesterday I suggested pulling out the business logic into concrete classes (basically the first step to a proper hexagonal architecture) and I got a look of horror from my co-worker and the following chat message: "WHAAAT???? NOT USING RAILS???? :â€™(" What is wrong with Rails developers and their fear of software design/architecture?
I now believe that the root problem is that Ruby on Railsâ„¢ is a marketing platform cleverly disguised as a software stack. It was initially developed by someone who, after writing a series of very similar, basic applications, decided to do "the proper thing" and extract a set of commonly-reused classes and techniques. This succeeded brilliantly â€” for applications that are very much like [Basecamp](https://basecamp.com). Clean architecture â€” proper boundaries and layers and the contracts involved in traversing them â€” appeared to be unimportant because all applications of the framework were using very similar design, which has been "proven to work" *in Basecamp*. The creator of Rails is joyously celebrated by his acolytes/victims for such illuminating comments as ["Fuck. That. Shit."](http://www.smashingboxes.com/domain-logic-in-rails/) instead of being called on the carpet like he would *in any sort of professional environment anywhere in the known omniverse*. Rails is held hostage to the initial competence and current ego of its primary developer, and is wasting developer-*centuries* due to some egregiously bad design decisions that can only be remedied so much by nibbling around the edges. Exhibit A: ActiveRecord. Exhibit B: Views as templates running inside a black box, immune to what the rest of the industry considers "normal software engineering-style practices". Exhibits C through ZZZZZ are left as exercises for the beginning Rails inmate; you'll almost certainly encounter each of them within your first year or two of exposure to Rails *if* you've shipped at least three applications on other frameworks or languages previously. Have you noticed that *every single article and blog post* on how to do non-trivial apps using Rails in a survivable manner basically boils down to "here's how you can subvert Rails' 'normal' 'opinionated' Rube Goldbergism to do survivable development"? Are you aware of any other purportedly industrial-strength application platform, in any language, that both promises "development that doesn't hurt" and inflicts such pain on its knowledgeable usees?
It makes debugging a lot easier, too, regardless of which programming-language environment you're working in.
I'm being serious here, what is so terrible about needing a database in order to test business logic? More than most people I know, I'm a "fast test" fiend. ActiveRecord tests often don't need to hit the database, and when they do, mine aren't all that slow. Transactional fixtures are incredibly fast.
This is a straw man. I frequently extract objects out of activerecord models. In cases where activerecord isn't an ideal fit, I immediately reach for other tools. When I jump off of Rails to solve a problem, software design/architecture is priority #1 to make sure my code is maintainable. But the framework saves you time when you use it to help you solve problems it knows about. If you don't like how your framework makes sausages, then use a different one.
Your code example has further persuaded me of my position. Who knows what `database` is? You've got to inject it in. Suddenly you either need some kind of registry object or an IoC container to manage all this plumbing you extracted from your rails objects. Those tools serve a purpose, and have value, but not when your use case lines up with e.g. activerecord's intended use case. What does that `UseCases` namespace win you, exactly? Where's you're domain model now? `UseCases::CreateTodo` drives creating a `Todo` and hitting the db. What logic goes on a `Todo` after persistence has been taken away? A `Todo` will likely have little to do, and you're at risk for building an anemic domain model. When your domain models and your data models jive with eachother, mixing persistence and domain modeling is *fine*. This is the case for a hell of a lot of web apps, and ActiveRecord is generally a great choice in those cases. I'm working on an app on the side that's using ES/CQRS patterns because I need the ability to e.g. roll back actions taken by the user (think Undo). In this case, my persistence model and my domain model are very different, and ActiveRecord is a terrible choice. Many of the "rabble rabble Uncle Bob midwest keynote rabble Hexagonal" folks are really overestimating the friction rails introduces against maintainable code with fast tests. They're also blaming the OO design flaws they perceive in for the messes that a lot of rails projects have turned into. "If only we would have used DCI" -- no, seriously, if only you knew how to write a good rails app. Rails isn't for beginners. It's for smart people who are building database driven web apps. Folks frustrated with bad rails apps shouldn't be so quick to assume it's the framework's fault. Otherwise, you'll just replace bad PHP written in ruby with bad Java written in ruby.
Methods are indeed objects, but optional parentheses make them harder to get to. (obj.method :foo)
Your one line methods seem to defy common Ruby style. Any reason why you decided to write them like this?
One of the troubles with learning a new language is bringing over all the baggage from your previous language. Python makes it easy to pass functions around because it's descended from functional languages (Haskell mostly), and was designed to encourage a functional style: map(foo, [1,2,3]) Ruby is not descended from functional languages, and is designed to encourage OOP: [1,2,3].map { |n| n.foo() } The key difference is that in the Python snippet we apply a function to integers, while in the Ruby case, we call methods on (or send messages to) the integers. Python isn't really a functional language because you can do all sorts of non-functional things inside a function (like "print()"). It all boils down to this: if your big problem with Ruby is that it doesn't support Python/Haskell-style programming, that's great! Ruby isn't Python or Haskell and you should design your classes and algorithms with that in mind. def doSomething(someObj) someObj.do_the_thing! end I had a much easier time in Ruby once I stopped worrying about the lack of list comprehensions (and functional style) and just learned to do things the Ruby way. Ruby is object oriented and duck typed, and given those two features, there's not much need for passing methods around. That's why Ruby makes it very easy to call methods on objects: [1,2,3].map(&amp;:zero?) But harder to pass instance methods around. Passing instance methods just isn't how Rubyists write Ruby code.
i'm surprised you're not bothered more by zero's boolean truthiness. puts "hello there madame C programmer!" if 0
Thanks for sharing!
I would guess it was to keep the code under 50 lines
I have a disdain for patterns like this, can we please, please stop putting configuration into the global scope. Look guys, I know we love Ruby for the ability to eliminate verbosity and boilerplate, but gems should be configured at the use site, if you want to make your own global variable to store an instance of your pre-configured MegaLotto::Drawing then that's fine, but it should be up to the application to decide on how to handle and not the gem.
I am not the original author of the snippet, i just shared one that I found interesting. I believe the purpose of that is to keep the code under 50 lines of code.
Just curious, what cms / blog is used for that site?
it sounds only hard ... see this (older) article for inspiration, its much easier as you think [recommadation](http://www.igvita.com/2007/01/15/svd-recommendation-system-in-ruby/)
That's an acceptable middle ground, I still prefer NOT having global scope without me explicitly requesting it, but it's a much better solution.
You are incorrect. The method function returns a Method object, but that is not the same thing as an actual method. http://stackoverflow.com/questions/2602340/methods-in-ruby-objects-or-not http://www.ruby-doc.org/core-2.1.1/Method.html
When a gem only allows global configuration like this it prevents you from having multiple instances of objects in your application with different behavior. For example, you run three lotteries with different parameters, but MegaLotto only has global configuration so you have to have three entirely different applications to manage your three lottos. MegaLotto::Drawing shouldn't depend on this global configuration, it should allow you to set its configuration independently or pass a configuration to the constructor. The example /u/sluukkonen has below is a great middle ground, allowing global configuration for the simple use case and per-instance configuration when you need multiple behaviors.
Thanks for explaining. I have some refactoring to do :)
Is there an easy way to see if there is a Gemfile? I have a feeling that it is not there based on how many hours I have futilely worked on this. Is there any possibility that you could look in the DropBox files I uploaded to make sure that this is the case? 
Apologies for posting too much. I am just such a newbie that I am not even sure where to start in identifying the problem. I guess my optimal was that someone would be bored/generous enough to go through the files and follow the directions to see if they can't get it to run. I have read through all of the directions and the manual, and all of the ReadMe's included in the file; however, I can't seem to get anything to work. I think it has to do with how old the app is (written in the early 2000s I think and last utilized in 2009). 
"Best practices" is a useless term, so I wouldn't worry about whether you're following them. Instead, think conceptually about volatility. Will changes to `LineItem` impact `User`? Will changes to `User` impact `LineItem`? Ideally, the fallout caused by changing an object is confined to its' direct collaborators; this is the principle behind Demeter. I think where you're at is a good start. Make sure you have a comprehensive, fast test suite that can help you refactor your way to more strict decoupling if you start noticing volatility. Do not preemptively optimize your design. At least, that's my recommendation.
One place that you want to sniff at a bit is the _initialize_ method in your _LineItem_ class. A good general principle is that your methods should do just one thing. Are you doing more than one thing here? Perhaps, rather than calculating the profit here, you could move that calculation out to its own method (and remove the instance var). In this simple case, it's probably not a big deal, but if the calculation were more complicated or likely to change, putting it in its own method might be a better way to go: class LineItem attr_reader :begin_balance, :end_balance def initialize(begin_bal = 0, end_bal = 0) @begin_balance, @end_balance = begin_bal, end_bal end def profit @end_bal - @begin_balance end end 
&gt; This is a straw man. I frequently extract objects out of activerecord models. In cases where activerecord isn't an ideal fit, I immediately reach for other tools. I'm glad people like you exist in the Rails world, but the average Rails developer I had to work with so far just puts everything into either controllers, models or views, tests it by either a bazillion of feature tests (requiring several lines of setup code of course) or not at all and calls it a day. &gt; But the framework saves you time when you use it to help you solve problems it knows about. Sure it does and I wouldn't use anything else than Rails for simple projects. The productivity is just unbeatable.
Although -- I think the biggest problem I am having is figuring out how to patch the rake file to get it work. 
I don't think we should shape our framework around average developers. Most apps are doomed to suck. This is the age old Joel on Software "Big Mac" vs. "Naked Chef" debate. I'm a fan of hexagonal architecture when appropriate, but many people advocating it as a general solution are forgetting that you can't take a 5 star chef's recipe and give it to a McDonald's employee expecting them to prepare a 5 star meal. "Average" developers will make a mess of any approach you take. Rails scales really well for some problem sets, it is perilous for others. If you're working with "average" developers who are scared of anything living outside the Rails ecosystem, that's a social problem. Organizations without courage are equally as toxic as organizations without wisdom.
It's based on octopress, but styles hand-written for the most part.
Here in lies the problem with examples...thanks for the feedback. 
&gt; It's not as complicated as you make it sound like. class ApplicationController private def app @app ||= Todo.new(InMemoryDatabase.new) end end &gt; is all it takes and there's no overhead when using app.create_todo from your controller. What if I use an `InMemoryDatabase` for tests, and a `PostgresDatabase` for production? That's one of the things you should be expecting to win with a hexagonal approach. Now my application code has to resolve the exact repository that I'm mapping my domain model to. When you've got more than one externality that you're injecting into your application, you need tools to manage those dependencies. &gt; You have a valid point here and a Todo application is probably not complex enough for that architecture. That being said: Having a domain model even if every class is just a simple container for attributes helps communicating domain knowledge. I think it's not so much about complexity, but about the nature of the domain. Basecamp is *way* more complex than a todo app, but it scaled great with activerecord *precisely* because the data models and domain models were so congruent. Many web apps fall into this category. When your domain model and data model diverge, DCI is one way to encapsulate the growing disconnect between the features you expose and modeling underneath. I'd have to have more experience using DCI to know when Use Cases are the right layer to be abstracting. I lean more on the side of building a rich domain model. &gt; You could theoretically save the use case instances (consisting of parameters, current_user_id and the name of the use case) to your database and automatically have a list of transactions for each user. You could then write a method undo (analog to call) for each use case and trigger that if the user wants to rollback that interaction. I've never tried this, but it sounds like it could work. The use cases are just the command pattern with a fancy name anyway. All of these things are true. Though ES/CQRS is a more suitable pattern in my case; it *is* my domain framework, instead of being an application interface layer.
Thanks for the feedback. Shoot over a gist, I'd love to get your take on it. Sounds like you have some other ideas than what was suggested below.
Why not just module MegaLotto class Drawing def draw(times = 6) times.map { single_draw } end end end
That would definitely work, no doubt. I'm writing the book and examples are hard. The book is 20 chapters, this being one of them. If this was a post all by itself, then yeah, makes no sense to drag configuration in to it. But over the long haul, not every system is simple enough for this. I wish it were :/
This right here. Seriously, give yourself the freedom to write code that might be awful and learn from that if it is.
All these answers are correct. Just learn, scre smells. If you still wanna check your styling, You might want to try a stylecop to assist you, like rubocop. https://github.com/bbatsov/rubocop
Both OPs and yours are equally reasonable. In OPs, the profit is precalculated, which is optimized for reads. In yours, profit is lazily evaluated, which is optimized for writes. You can sort of get the best of both worlds by doing this: def profit @profit ||= @end_balance - @begin_balance end 
Don't forget pry-debugger!
All programmers, even great ones, will often look back to even their recent code and be like, "wow, that is embarrassing."
you should mediate access to your state objects whenever possible. You should also think of the various "layers of context" in your application. At the highest level of context where you are creating a user and adding line items, what does it make sense for this layer of your application to know? Is it reasonable to know about the idea of a LineItem? I would rewrite it as such: class User attr_reader :name, def initialize(name, ledger = Ledger.new) @name = name @ledger = ledger end def add_to_ledger(line_item) ledger.add_line_item(line_item) end private attr_reader :ledger end class Ledger def initialize(existing_items = []) @line_items = Array(existing_items) end def add_line_item(line_item) @line_items &lt;&lt; line_item end private attr_reader :line_items end class LineItem def initialize(begin_balance = 0, end_balance = 0) @begin_balance = begin_balance @end_balance = end_balance end def profit begin_balance - end_balance end private attr_reader :begin_balance, :end_balance end user = User.new("John") user.add_to_ledger(LineItem.new(20, 80)) user.add_to_ledger(LineItem.new(20, 120)) edit: moved all internal state to private accessor methods. this *really* brings home the idea that internal state should be hidden and have access mediated. 
It's so refreshing to hear someone admit they don't know something (i.e. elasticsearch). I've been dealing with too many people recently who spend months digging into a technology and then expecting everyone to have the same knowledge. It's annoying.
Everyone's saying pretty much the same thing, but this deserves emphasis. Write unit tests. If the unit tests are painful to set up, then chances are your objects might not be organized appropriately.
Yes!
Thanks! It was on the tip of my tongue before, but I couldn't recall the specific way Shoes handled it.
You need to learn [SOLID](http://en.wikipedia.org/wiki/SOLID_\(object-oriented_design\)) - it will help you develop better habits. The thing where people are telling you to pass in new objects rather than hard coding their instantiation is the "D" in SOLID (Dependency Inversion).
There's OOP best practices and then there's Ruby. require 'forwardable' User = Struct.new(:name, :ledger) do extend Forwardable def_delegators :ledger, :add_line_item end Ledger = Struct.new(:line_items) do def add_line_item(line_item) line_items &lt;&lt; line_item; end end LineItem = Struct.new(:begin_balance, :end_balance) do def profit() begin_balance - end_balance; end end user = User.new("John", Ledger.new([])) user.add_line_item(LineItem.new(20, 80)) user.add_line_item(LineItem.new(20, 120)) forwardable is just a simple way of delegating a method and you should generally delegate whenever you find yourself just passing arguments along. Struct is an alternative to class. There's pros and cons of struct vs class as you can see, but for trivial classes a struct is a good alternative. My general rule of thumb with Ruby is don't write 10 lines when one will do. Point being don't try and write good OOP code, try and write good Ruby code. 
They can be if you use reflection... :)
Posted above, but: Array.instance_method(:&lt;&lt;) That will return an object representation of the function.
What do you need `Method` to do that it can't?
You are such a masochist I love it
I think this is somehow simultaneously the stupidest and smartest program I've ever written.
Is there any way to deal with that "self"?
There are five instances of `self` and I've been wracking my brain for some way to get rid of them.
Nice. Reminds me a bit of http://codon.com/programming-with-nothing - maybe it is just the name!
Tom was the catalyst behind my starting this weird journey.
 class User attr_reader :name, :ledger def initialize(args = {}) @name = args[:name] @ledger = args[:ledger] end def ledger @ledger || Legder.new end end * the `attr_reader :ledger` here is completely useless as it then ends up getting overwritten with your method * your Ledger.new memoization is never persisted, meaning you'll generate a new Ledger every time you ask for ledger * You are now instantantiating a collaborator object in an *internal method* of your class. Your initialize method is your highest level object boundary, this is the point where *it makes sense* to instantiate collaborator objects, not in your internals. * Use `#fetch` for hash references, which guides your design once again to realizing that `Ledger.new` is a *default* value for `@ledger`, meaning it should be `@ledger = args.fetch(:ledger, Ledger.new)` * If you're using Ruby 2.0+ you should be using named parameters instead of a hash, anyways. --- leads to class User attr_reader :name, :ledger def initialize(name:, ledger: Ledger.new) @name = name @ledger = ledger end end 
1. ) I added attr_reader :ledger for readability. 2. ) "@ledger ||= Ledger.new" and problem solved. 3,4,5) Using the hash and instantiating Ledger in it's own method gives me greater flexibility and makes the class more reusable (think inheritance). 
I updated the post and mentioned this as an alternative. Still would love to see your solution. 
Wow, Sweet! Thank you!
1 and 3,4,5 make no sense. 1 is literally nonsense and there is absolutely nothing that makes a hash or memoization that add to reusability. Want to use a different kind of ledger? Pass it in in the constructor. How would you use a different kind of ledger in your case? You'd have to inherit and override the ledger method. 
Do you have a real example?
I will second the _hell_ out of "Eloquent Ruby", and raise you a "POODR" (Principles of Object Oriented Design in Ruby) by Sandy Metz.
Still no find-as-you-type? Still not using it. These guys have the right idea, but still not executed that well. The search results are not stellar: http://docs.rubydocs.org/ruby-2-0-0-p247-rails-4-0-2/ 
Your code looks fine to me.
Then what exactly is the file that doesn't exist. If plugin exists it must be complaining about some other file that doesn't exist. It might be easier to get in touch with the person that gave you this and solve the problem that way. Remote debugging can only go so far.
Flexibility, mainly. Most of the code we had to write was not for running Bundler, but for the stuff that happens afterwards -- dealing with missing gems, things in private repos, versions we might not have indexed, etc. The marginal cost of being able to reprocess a Gemfile (essentially do a bundle update) was small. But...I think we should add support for uploading a lockfile. We've had more than one request, and it obviously fits into the pipeline, so...it should be easy! :-)
Gotcha. My other main concern is that there are multiple ways to resolve dependencies even using the same Gemfile, depending on how loose your dependencies are. I want to be assured the versions I'm seeing correspond to my specific project instance, and imo the only way to ensure this is to use my specific Gemfile.lock
Yeah, that's a good point. I honestly don't think it'll be that hard to add support for a lockfile - most of the process is identical after the file is parsed (and parsing a lockfile with the code from bundler is actually one of the easier things). We're adding it to the feature shortlist. Thanks!
I had no idea such a thing existed, thanks for bringing me onto something like that!
Recommendation engine was what I was looking for rather than decision engine!! Thank you! I actually found one that's fairly recently maintained https://github.com/davidcelis/recommendable It says it uses likes and dislikes, which is kind of a step away from what I have in mind, but if I determine it's not suitable for what I'm trying to do, I'll look into Python! 
This is great! Thanks for the article!
They weren't checking tickets and hardly anyone was wearing badges. If you asked really nicely, I'll bet they would let you in for the last day. 
Alright, I'll see if I can find some time to go over tomorrow. Gotta take my cat to the vet first Also, if anyone is in town and wants to go to the bars or play carcasonne or other things to pass the time, hit me up.
I'm surprised no-one has criticized that having add_line_item as a method on User is just ugly. Violates SRP pretty well.
Thank you..
How can I get the book: Everyday Scripting with Ruby by Brian Marick
Let's see if I get this right, reddit. I point out that catcradle5 wrote he, when the article is by a woman. catcradle5 edit's their comment to say she instead of he, but doesn't show it's an edited comment. I get downvoted. More evidence that the downvote button is a bad idea. Thanks.
I wish the author would point out the anti patterns he's demoing so people who don't know any better don't use them. Otherwise, nice post. 
I'd caution against going hog wild with this practice. 9 times out of 10 when I see some important data structure or calculation being lazy loaded via memoization, there's toxic design wrapped around the object. I want to be clear; in this case, memoization is fine. As a rule, objects that do something either slow (like a blocking network call) or smart (like a tree sort algorithm), should have short lifespans. The data they produce should live in *other* objects that forget about their more complicated birthing process. Memoization leads to complex objects that hang around a long time. This is bad design because you're forced to wrestle with that complexity every time you debug the object. Suddenly you're debugging an exception in your view, and an empty node in the tree sort algorithm, or a network timeout error, blow up the template rendering process.
Excellent. Thanks for the recommendation.
I mainly posted to get resources on OOP design patterns, but I'm so glad I threw my code in there. There are so many "Aha!" moments in your short rewrite. Thank you!
No problem :) 
Aye, I'd looked at this myself after posting and thought that I should have advised: user = User.new("John", (ledger = Ledger.new([]))) ledger.add_line_item(LineItem.new(20, 80)) ledger.add_line_item(LineItem.new(20, 120)) Swings and round abouts with delegates.
How is this question even relevant to the thread? First class functions are useful.
Hello, FYI: The worlddb gem also includes [free open public domain plain text fixtures](https://github.com/openmundi) for all countries and territories in the world plus some regions/states/provinces and some cities/towns/hamlets. Cheers.
 class Automobile def horn puts "beep beep" end end class Car &lt; Automobile; end class Truck &lt; Automobile; end 
If that was the main problem...
I think this gem is a very neat example to look at if you're wondering how you can make a gem that provides an executable. 
How about Paintable ? 
Thanks, that's a helpful way of thinking about it. It's also a different take than I've come across via the Pragmatic Studio Ruby course.
Thanks!
This doesn't do a very good job of explaining what exactly it does. I gather it scans your codebase for common mistakes like missing readmes?
http://i.imgur.com/NfFnKpf.jpg 
Don't you mean adjectives? Edit: ugh, I took one look at this and realized how grammar-nazi-ish it seems. I would like to take a moment to note that I am expressly not trying to be a dick and I get the point you were trying to make, and it works well.
What if I did this? specify "#sing" do song = build :song Singer.new.sing(song) end specify "#sing refuses to sing profane songs" do song = build :song, :with_profanity expect { Singer.new.sing(song) }.to raise_error end --- My reasoning is that I don't really care how it sings the song. Simply by ensuring that sing(song) with a valid song doesn't raise an exception is a good enough test for me. I don't want to bind my implementation by setting strict expectations around tts_engine, which isn't under test in this case. EDIT: Additionally, I use a factory with a trait, so I have a single point to reference what a "song with profanity" is. EDIT: If tts_engine (text to speech in case anybody missed that) had side effects, like actually singing the song. I'd be inclined to sandbox over stubbing. I might create a spec/support/audio_sandbox.rb that configures a /dev/null audio driver. Or use [FakeFS](https://github.com/defunkt/fakefs)/[FakeS3](https://github.com/jubos/fake-s3)/[puffing-billy](https://github.com/oesmith/puffing-billy), etc.
Yes. More specifically for a missing `README`, `LICENSE`, `CONTRIBUTING` guide, bootstrap script, test script, and `.gitignore` (for Git repositories only). For example: âžœ badger git:(master) ls README.md app.rb static âžœ badger git:(master) friction [ERROR] CONTRIBUTING guide not found. [ERROR] LICENSE not found. [ERROR] Bootstrap script not found. [ERROR] Test script not found. [ERROR] .gitignore not found.
just to throw out the third type of object relationship (Mixins, Inheritance, and *Composition*) class AutomobileSoundMaker def horn puts "beep beep" end end class Car def horn AutomobileSoundMaker.new.horn end end class Truck def horn AutomobileSoundMaker.new.horn end end 
I have your app running on my machine. Most of these instructions are not necessary for what you have in the zip file. I've sent you a PM.
It's not Nazi to correct that which is wrong. It's Nazi to force that which you *prefer* over that which someone else prefers. That being said, would adjective be the right word? "Comparable" belies the *ability* to compare (i.e., the act of comparing or not comparing), not necessarily an attribute about comparison itself.
&gt;MRI is the most common, no doubt. I was hoping that this would be the case :-) &gt;you're unlikely to miss any of the 2.0 features You're probably right... I hope that Rubinius catches on soon... Thanks for the answer 
I use Rbx in production. 
MRI is by far the most commonly used today with JRuby following on the second place and Rubinius on the 3rd. Which one you use depends on your use cases. At `$WORK` we use mainly MRI and recently moved a bunch of things that use Java libraries over to JRuby (way faster than booting up a Java process on each call). We're also investigating Rubinius but have sadly not yet been able to use it properly due to various serious [Nokogiri issues][1]. Hopefully soon we have a stack of MRI, Rbx *and* JRuby but only time will tell. At some point we can hopefully get MRI out of the picture but that will take a while. [1]: https://github.com/sparklemotion/nokogiri/issues/1047
Http://Artoo.io and it's history with rubinius is an interesting case study. 
Instead of explicitly passing nil, you can do something like this: def something(param1:, param2:) Personally, I like to explicitly pass nil anyway.
JRuby is fantastic for long-running programs and scenarios where you have lots of heavyweight garbage collection requirements. It definitely seems to be a lot faster where you've got large numbers of complex object structures that you need to interact with. The memory differential with MRI closes a bit once you consider that you're able to use real parallelism rather than having to spawn loads of processes. Plus, being able to use the huge Java ecosystem as if it were Ruby is a huge boon. Like Java, it is definitely (presently) weaker for short-lived stuff that just performs traditional script-y work or pure algorithm benchmarks that don't involve much in the way of objects. Anyway, I found some cool bits that may helpful in making JRuby faster: https://github.com/jruby/jruby/wiki/Improving-startup-time#try-using-drip Drip effectively keeps a warmed-up JVM ready for you, so while you're running thingA, a new JVM is spun up and will be ready to go immediately when you want to run thingB. I haven't tried it myself, but I've heard very positive things.
Good post. I didn't know this existed because I usually only found the /r/learnprogramming page. 
Yup - as of ruby 2.1.
Cross-posted from [HN](https://news.ycombinator.com/item?id=7455587). I'm the author of this. I'm an undergrad who just built something I wanted to use, especially to mimic some of the functionality in a tool I really like: [Hammer for Mac](http://hammerformac.com). I'm totally self-taught with Ruby so don't expect any ground-breaking code here, but thought it was something that might interest HN-ers and I'd love to see community contributions to the codebase. Right now the functionality is pretty basic. It works very well for compiling includes in a flat file structure, but doesn't copy your stylesheets or JS into the build folder (and flattens your structure if you have nested files). These are things I plan to implement soon (or you can now!). I also plan to implement support for the Listen gem so that it'll automatically compile on detecting file changes, rather than requiring manually running it.
Not much has changed? Maybe from a syntax perspective but given that MRI Ruby 2.0 introduces some sensible garbage collection I think can be a big deal depending on your use case. At least its getting closer to the main benefits of JRuby without having to monkey around with the JVM.
Is Rubinius better for production? Why?
Can't find it :/ Do you have the link to the story?
I mean, does it have any advantage? I'm noob (crearly).
Ah, ok! Well it is Ruby written in (mostly) Ruby, so there is a large point of pride there. Rubinius (rbx for short) also has rid itself of the global interpreter lock (GIL), so multithreading can be done more efficiently. Rubinius has a lot of benefits over MRI; the only thing it needs to catch up on is general speed, where it is lagging behind by just a touch (but it'll catch up soon!). If you've ever wondered how things are implemented in Ruby, you can just look at the rbx source code and see for yourself â€” in plain ruby. http://rubini.us/2011/02/25/why-use-rubinius/
Thank you :)
You can now do Steps 1â€“3 without downloading Xcode if you have a Apple ID. Go to the [Apple Developer site](https://developer.apple.com/downloads/index.action) and sign in with your credentials. You'll be prompted to register as a developer. Then you'll be able to download the Command Line Tools for Lion or Mavericks.
I should have been more clear - this was in response to the "JRuby is still on Ruby 1.9 version). The internal improvements in MRI do nothing for you when you use JRuby, which is why I did not mention them.
it's a bit of a simplified version of middleman. the partials functionality of middleman is what's similar here.
It's a great feature, no doubt, but if I had to pick between keyword arguments and JRuby, I would pick JRuby. Luckily, I don't have to pick, because JRuby supports keyword arguments!
Cool, thanks a lot. I really appreciate this. Really really appreciate it. I had a few questions though. I get to step 6 but I am not sure what you mean about adding commands. What does this mean? I don't develop ruby (maybe someday) and I just need to create pods in vim and save those pods to my xcode ios project. Step 7 - could you clarify? Does this mean any project (like my ios projects?) or does it have to be a ruby project? Thanks again for your kind help. I am extremely grateful. 
Newest RVM will do step 6 for you automatically in most cases. 
After you did step 6 what did you see in the terminal? 
I second this. The system Ruby can get in the way. It's better to use RVM to install Ruby versions and manage gemsets for different environments / applications, and use Homebrew to install / manage other things (Git, MySQL, PostgreSQL, Redis, etc).
Rvm does all this by default and the commands are much easier to remember.
Well I don't know what adding commands to bash_profile means exactly so I haven't done that. I downloaded RVM, got the welcome messages and it went back to my regular user command prompt.
The easiest way I've found (at least on Mavericks) to install the command line tools for Xcode is to run `xcode-select --install` in a terminal window. It will open a GUI prompt and download and install the tools all in one go. 
So, I followed this http://nsscreencast.com/episodes/5-cocoapods it's locked behind paywall. Gem update to ruby was needed sudo gem update --system. Made pod in vim, then tried to pod install - for some reason this didn't work. Learned about not messing with system Ruby. I found the following on SO and did them to effect a fix cd /System/Library/Frameworks/Ruby.framework/Versions sudo rm Current sudo ln -s 1.8 Current When I do ruby -v, I get version ruby 1.8.7 (2012-02-08 patchlevel 358) [universal-darwin13.0] but I believe with Mavericks I should be at 2.0. I time machined about 10 days ago and tried a restore but for some reason until I did the above code, ruby -v or irb commands returned "command not found". EDIT: I've been struggling with this for a couple of days. I thank you all from bottom of my heart for helping!
&gt; sudo gem update --system This updates the Rubygems system not the system ruby. &gt; I believe with Mavericks I should be at 2.0 Yes. Mavericks comes with 2.0 What does `where ruby` say? 
you mean which ruby for the file location? for that I get /usr/bin/ruby
Read this book first "Metaprogramming Ruby Program Like Pros" (the first part) then you can go with Programming Ruby 1.9 book. 
Then what is?
Eh? You can run JRuby in Ruby 2 mode. $ jruby -e 'puts RUBY_VERSION' 1.9.3 $ jruby --2.0 -e 'puts RUBY_VERSION' 2.0.0 Seems pretty stable.
A rather formal overview of Ruby for someone with previous programming experience is [The Well Grounded Rubyist 2nd Edition] ( http://www.manning.com/black3/) It's in preview right now, but it's mostly complete and provides a very good overview of Ruby... 
Several points. 1. You're not doing file manipulation, you're doing string manipulation and listing of directory contents. 2. The Java virtual machine takes time to warm up and JIT generated code. Your benchmark above likely is not running anywhere near long enough for the JIT compiler to start its optimisations. 3. You are likely running under the default JVM memory configuration, which could be causing a lot of paging to swap files due to a limited initial heap size. basically, you're drawing flawed conclusions from an artificial benchmark. JRuby does not excel at short, script-like tasks. It excels at IO-heavy, long-lived, server-like processes (e.g. webservers) which live long enough for the various JVM optimisations to become active.
I agree, this is not file manipulation, the title is misleading. But there's at least a read of the directory tree in the fs I guess. You say that there is not enough time to warm up the JVM but the following is showing JRuby way faster than ruby in few seconds (for instance this is actually only string and array manipulation): n = 5000000 Benchmark.bm do |x| x.report { for i in 1..n; a = "1"; end } x.report { n.times do ; a = "1"; end } x.report { 1.upto(n) do ; a = "1"; end } end JRuby is 30% faster than MRI on this one. I'll try to tweak the memory of the JVM to find a way to improve it.
Yes, and in this instance you're running the code many, many more times than in your first example. The JVM hotspot compilation threshold is roughly 1.5k executions of a method; after that the JVM will optimize the method or block of code to native, with the result that subsequent executions will be much faster. In fact, in your second example it's quite possible the JIT compiler will optimize away your loops given that they essentially do nothing; but you'd have to inspect the java bytecode to confirm this.
Ok ... ok, I'll do some real benchmarks next time :D JRuby is actually way slower again with n=50 in the second example. Thanks for the explanation.
It's a bit difficult to write a (good) book that formalizes every aspect of Ruby. IMO, it's better to learn the general stuff and from there move onto more specific subjects. Personal experience, if you only know a bit of Ruby syntax, RubyMonk is a great free interactive source. _why's (poignant) Guide To Ruby would be the perfect book to learn from. However, if you already did that and want to learn more "under the hood", I'd go with Eloquent Ruby and Metaprogramming Ruby. They pretty much teach you (or give you a good idea of) every aspect of the language. Then I'd go with more specific books. If you want to go with Rails, I'd recommend Michael Hartl's Ruby on Rails Tutorial and Agile Web Development With Rails. With those two books, you get the idea behind Rails. From there on, you can continue to specialize yourself. E.g, the general consensus in the Ruby Community is TDD. That being, I'd suggest Everyday Rails Testing With RSpec. Either way, Rails aside, I'd also recommend RubyTapas. Avdi's pretty much a great teacher and an awesome Rubyist. Also, those screencasts teach you a lot of Ruby-specific tricks (and how they work and why).
Holy crap, RubyMonk looks great! Thanks.
Also check out ruby koans http://rubykoans.com/
RubyMonk was were I started learning Ruby and it gave me strong basis to hold more Ruby knowledge. I'd also strongly recommend _why's (poignant) guide. Besides laughing your pants off with _why (as you go deeper into the Ruby community, you'll see how important he was), it teaches you in a way you thought wasn't possible.
If you don't use mri, you might be in for some pain if you want to use any gem that depends on c libs, like nokogiri.
RubyKoans is really great, too. However, when I started, I enjoyed RubyMonk more because, since it was in-browser, there was no need for file download and I could continue the tutorials in any computer without copying files around. It was on-the-go. But RubyKoans is also a good recommendation.
Not a stupid question. I guess the point was to make it easy for the end user and not require any ruby knowledge. Additionally, the DSL is the same one used in Hammer but I could probably make it support more than one syntax.
Thank you for this! I am taking ruby this semester and I have been forced to ssh to my schools server because I couldn't get the latest version of Xcode on my MacBook running lion.
Cool. I wasn't familiar with the Hammer syntax so didn't realize it was the same as that one. Thanks for the answer!
Ok, so this is just a misunderstanding, I was thinking the other way. c = Class.new m = Module.new c.extend m This clearly works, I thought you mean it this way. Maybe it would help to reword the option to something like "A class can extend another class".
True parallellism is a saver. Combined with Puma it's a blast. One can argue that JRuby also supports true treads and they would be right. Though, in my case I found rbx being a bit easier on resources (starts faster and uses a bit less memory than JRuby). Also it's JIT is fantastic. I found it to be in many cases better than JRuby.
Rubinius currently actually targets 2.1.
Waddle waddle!
In your case you extend the object of the class, which is different from the condition in the quiz
Awesome!
Amazing:)
Is this where we fall over ourselves to offer praise because they're women in tech, and don't bother to offer any sort of criticism whatsoever because you'd be instantly labelled a misogynist?
Can't you look past any prejudice you have? They actually built a piece of open source software and developed a business around it, can't you at least consider that aspect?
I think his point is that the software should be able to stand on its own without going out of your way to bring gender in to it.
or you can [read the code](https://github.com/punchgirls/job_board) and submit issues like any other project.
Thanks!
Eloquent ruby singlehandedly changed my approach to programming in ruby. It is a masterpiece imo. It's not so much the culture, but it really delves into the power that ruby provides you(metaprogramming is quite fun, albeit can be dificult).
I've really only been knee deep in ruby for about a week now, so I imagine there is plenty of room for improvement. I'd love to hear feedback or ideas for how to make this better! **Note:** I'm still working on getting some documentation up to help make getting started a bit easier. Should be up there in the next couple of days.
DO you have your blog series of "Elixir for Rubyists"?
A gender neutral field where I, as a woman have _rarely_ worked with other women. I work in web operations, and systems automation, you can call it systems administration or 'devops' (even though thats incorrect). The number of times where I have been the _only_ woman programmer on the entire dev team is far greater than the reverse. When you have a diverse team you have diverse ideas, diverse personalities, and diverse opinions. We have to create safe spaces where people can learn without fear of criticism and being told they are stupid. I grew up on BBS's and IRC so I'm used to the completely bad attitudes most people put on when online. Not everybody has earned that experience though, and nobody should have to. I think my position isn't entirely fair either as I am also transgender. So I was granted a typical male socialization experience as a child and teenager. I worked my way through IT for several years before making my transition. Even during that experience the number of women I worked with was too few. Thats not to say it was zero, but it was certainly a single digit percentage compared to men. I think the reason I observed slightly higher was my proximity to MIT and working in bioinformatics. Living again now in San Francisco, and having worked at several local startups. I can see its a sad state of affairs. I am thankful for groups like [Women Who Code](http://www.meetup.com/Women-Who-Code-SF/), [Trans*H4CK](http://www.transhack.org/), [Girls Who Code](http://girlswhocode.com/), [Railsgirls](http://railsgirls.com/), [Ada Initiative](http://adainitiative.org/), [Black Girls Code](http://www.blackgirlscode.com/). Because they are helping bring diversity into a field that greatly lacks it and could greatly benefit from it.
&gt; The number of times where I have been the only woman programmer on the entire dev team is far greater than the reverse. This doesn't point specifically to there being a problem with women entering those positions. I mean, you're there after all. &gt; When you have a diverse team you have diverse ideas, diverse personalities, and diverse opinions. There is absolutely no evidence to support the idea that having women on your team improves or degrades idea generation. &gt;Living again now in San Francisco, and having worked at several local startups. I can see its a sad state of affairs. I am thankful for groups like Women Who Code[1] , Trans*H4CK[2] , Girls Who Code[3] , Railsgirls[4] , Ada Initiative[5] , Black Girls Code[6] . Because they are helping bring diversity into a field that greatly lacks it and could greatly benefit from it. By creating women-only (or minority-only) institutions? I fail to see how trading in an all-male group for an all-female group promotes diversity. What it does tend to promote is a walking-on-eggshells atmosphere where everyone is super careful about what they say so they're not labeled a woman-hater, racist, etc.
So maybe he should critique it objectively as a project instead of focusing on the gender of the participants. Talk the talk, walk the walk.
&gt;This doesn't point specifically to there being a problem with women entering those positions. I mean, you're there after all. You're assuming there were no complications faced to her entering her role because she is a woman. Such as academic bias in IT and hiring biases to name two. &gt;There is absolutely no evidence to support the idea that having women on your team improves or degrades idea generation. Only if you assume women in general think exactly the same as men in general about all problems or don't have problems specific to women that they can contribute. &gt;By creating women-only (or minority-only) institutions? I fail to see how trading in an all-male group for an all-female group promotes diversity. What it does tend to promote is a walking-on-eggshells atmosphere where everyone is super careful about what they say so they're not labeled a woman-hater, racist, etc. The women only groups aren't silos. They encourage women to enter the field but they don't keep them within their walls so they encourage growth in the broader community.
Except... that's exactly what it is.
&gt;Only if you assume women in general think exactly the same as men in general about all problems or don't have problems specific to women that they can contribute. Please point me to the scientifically conducted, peer reviewed research that proves conclusively that adding a woman (or an african, or a chinese, or a hispanic, or whatever) to your team automatically improves idea generation. I'm not saying that a woman can't have good ideas, what I'm saying is that women are not some magical ingredient you add to fix a problem. Whether or not a woman is a solution to a problem depends on their skill set, just the same as a man. Gender doesn't, and shouldn't have anything to do with it. &gt;The women only groups aren't silos. They encourage women to enter the field but they don't keep them within their walls so they encourage growth in the broader community. By creating a situation where you make a big point of trying to say there's a problem where there isn't one. Careers are not gender biased. Programming is not gender bias. Gender bias is something invented by people, and it's only an issue with some people. It is something that should be handled on a case by case basis, and not made out to be like every male programmer is a woman-hating sexist.
I don't know what to think. There's no example usage. If you mean code then take a look at this [style guide](https://github.com/styleguide/ruby) At a glance it seems pretty cool, nice of you do document the code like this.
Charging extra for the code is pretty lame. Otherwise I'm optimistic the content will be worth the cost for those looking for a new resource.
http://www2.nau.edu/~bio372-c/class/behavior/sexdif1.htm https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;ved=0CC0QFjAB&amp;url=http%3A%2F%2Fwww.asee.org%2Fpublic%2Fconferences%2F8%2Fpapers%2F3132%2Fdownload&amp;ei=j5owU6vKDMiGyAGb54GADA&amp;usg=AFQjCNHxshWfQtUBepyd3_OFNQ0Ot204qg&amp;sig2=OGzXI0cF_L7r0tkUKuk-3Q&amp;bvm=bv.62922401,d.aWc&amp;cad=rja Seriously just good gender differences in problem solving and gender differences in idea generation. Solving problems has a lot to do with personal experience as well as skill set. It's the former that is differentiated with gender. I'm not making out every male programmer to be a woman-hating sexist. It seems like you have your own issues there. I'm saying that there is a bias in the industry that exists and these programs give ways to combat that. For other examples look at Law. Most of which is very much like programming(writing a very specific set of rules to be followed which lead to certain outcomes). It use to be a very heavily male dominated profession. It still is but through programs like this the gap is closing rapidly.
From the paper: &gt; Overall, we found few significant differences in ideas generated. However, female students championed one approachâ€”encourage conservationâ€”that male students tended to ignore. A small number of male students, in turn, suggested a solution approachâ€”economicsâ€”that no female student considered, though it represented an invalid solution to the given problem. **These results do not suggest that female students are â€œbetterâ€ at idea generation; in fact, male students, on average, considered 5.7 solutions compared to the female student average of 5.1**. Instead, these results suggest that male and female students will identify only partially overlapping design solutions and thus mixed gender teams may be able to consider a broader range of design ideas during idea generation. The team-level analysis supports this assertion, as the four mixed-gender teams slightly outperformed the all-male teams. **These results relied on small sample sizes, and pooled ideas rather than the output of an actual team idea generation exercise, and thus should be considered preliminary**. In reality, social factors and individual differences have been observed to both hinder and improve team outcomes. **Future studies should be conducted to further explore if similar results will be observed for different design problems and team settings (e.g. team projects, joint idea generation), and with a larger number of diverse teams/individuals.** This doesn't prove much, and they even go so far as to tell you directly that the study has flaws. What it does do, is suggest that it's not a waste of effort to study it further. So again, show me the research which proves this **conclusively**. 
I didn't say they were better. I said their methods and results were different and I linked to two. It's clear you'll find a reason to dismiss anything I find for you. I gave you a method to find further results use it.
No, you gave me a paper that you felt would confirm your own thoughts on the problem, except it's preliminary and far from conclusive. The other article I didn't bother to comment on doesn't even discuss idea generation in mixed groups. Nobody is debating that women are different, nobody is saying that women are incapable. What I'm debating is that including women automatically generates more and/or better ideas. I'm willing to say there's a chance you may be right in your assertions, but this paper does not prove your point. it raises more questions which the paper fails to answer. It uses a sample so small that it can't be taken as statistically relevant and most importantly it doesn't attempt to reproduce the results with other groups. It doesn't touch on the idea of academic performance of individuals and how it relates to the results. &gt;It's clear you'll find a reason to dismiss anything I find for you. How is anyone supposed to arrive at the truth if argument is not allowed?
Ignore the performance aspect and focus on the problem solving aspect. Both the paper and the article I link to discuss that. It's not a contest and it's not about one gender being better than the other it's about them being different in methods and approaches and that is where the improvement comes from when combining them. If you're really interested in finding out the truth then Google those two keywords I gave you. There are a lot of papers on the subject I just picked the first two after them a quick read to ensure they weren't specific to skills. I never said argument wasn't allowed. I gave you 3 resources. You ignored two and dismissed the third as needed more research. If that's your response then I'm wasting my time trying to convince you.
Was there three? I don't see three. You gave me two resources and one wasn't relevant. I pointed out flaws in the one that was relevant and you decided to immediately dismiss them. Even if we were to completely ignore this and consider your one relevant article as 100% factual, the benefit seems marginal at best. The noted increase in performance is slight, and likely negligible. Women perform pretty much just as well as men do in that regard. &gt;Ignore the performance aspect and focus on the problem solving aspect. This is specifically about *idea generation*, so when I use the term "performance" I'm specifically speaking about how well the groups generate ideas. This is at the heart of the original assertion which you are trying so hard to defend - that diverse groups are superior with regards to idea generation than non-diverse groups. Diversity in this case defined as gender-mixed. &gt; There are a lot of papers on the subject I just picked the first two after them a quick read to ensure they weren't specific to skills. What this says to me is "I picked the first two articles that appeared to agree with my point, and didn't read them very carefully.". If it's so easy to find a definitive answer, why were the articles you linked not relevant and conclusive?
In ruby, all variables, methods, and other sorts are snake case - constants are screaming snake case, and classes/modules are camelcase. In ruby, it's also looked down upon in using class variables (your `@@variable`). Another thing to note is that having more classes/modules isn't a bad thing - I've [written a ruby library](https://github.com/redjazz96/packed_struct) that does a very basic thing, but still requires 2-3 classes. Another thing, at first glance: the `"#@variable"` syntax isn't that great. Use `"#{@variable}"` syntax instead. Line 106, line = "#@cacheLine" should be formatted as line = @cache_line Indents should be 2 spaces. Another thing to note: your function on line 474 to 481 is not needed. `nil?` is a method all objects respond to (see [Object#nil?](http://ruby-doc.org/core-2.1.1/Object.html#method-i-nil-3F)), and an object is considered false-y if it is nil or false. Otherwise, seems interesting! Could use some usage docs, though. 
Also, rake will be moving to a new "rake" organization soon. Jim's family and coworkers are working together with github to make this happen.
I agree that the question is poorly worded which makes the answer ambiguous. Your version is much clearer.
Go ahead and criticize. I met these two at RubyConf Argentina this year and I can assure you they are up for the challenge and willing (and able) to make improvements.
This is a gender neutral project. The blog post doesn't mention feminism (not that it would make it any less neutral if it did), and it's open to everyone as far as I can tell. It's as gender neutral as it can get. 
&gt; *After you have a few months/years of experience and/or a good deal of domain knowledge and you live in one of the web-heavy tech hubs like SF or NYC. I'll give you experience and domain knowledge, but every major city has an enormous demand for web developers. Even if you're rural, you can get jobs in the city (or anywhere in the world) working remotely.
Please *try* and keep the comments about ruby. (And not the social issues within the industry.) At worst, keep the conversation friendly.
This looks like more of a "HTML to Markdown converter..."
Awesome, thanks for all the feedback! Naturally I've got a lot of baggage from other languages manifesting itself in this code, so this is helping me catch things that aren't particularly obvious to me. I need to revisit that unassigned() method (the block from 474 to 481), I remember deciding to implement it for a specific reason but I'm not remembering why that was. I think there was a case where .nil? wasn't going to return the result I needed in certain cases, but I need to revisit this to make sure it's actually necessary (obviously I don't need the .respond_to call for .nil).
I think I broke it.
There's a reason people usually advocate spaces over tabs. It's this: http://cl.ly/image/0O2D111l3g1v Also, some usage examples and a screenshot or two explaining what this is would be useful, and drive adoption a bit better. Reading through the code, I am rather unclear what a proposed use case for this gem would be. I was under the impression that this is designed to format output in the shell with colors and such, but I'm finding prompt-related things, and stuff that's asking for input. Okay, some code-specific stuff: Line 425, method #passthru, you check if something is an array (you shouldn't do this. Don't ask what a class is, ask what it *responds to*: if this_thing.respond_to?(:[]) # it's an array # EDIT: This is called 'duck typing'. If it looks like a duck and quacks like one, it's a duck. , then your code is easier to refactor). Instead you can just type Array(the_thing_in_question) and if it's an array, it will still be an array, but if it's not, it will become one. Second, you have a lot of class methods with no benefit. In fact, it makes your life *less* convenient because you have to type ```self.class.method``` in order to access these methods. Class methods should be reserved for very special cases. The only one I can think of off the top of my head is perhaps if you want to create an alternative to ::new that has slightly different behavior (think factories). Let these methods be instance methods, because it doesn't appear that you're accessing them from outside an instance of the class anyway. As you begin working on a gem, you want your public API (the ways people can interact with your code) to be as small as possible. This way it's easier for people to reason about how to use your gem. For example, you currently have a ```LipsTTYck::unassigned``` that can be accessed from anywhere, but really only exists to support other methods in the class. Make this private and define it on instances of the class: private def unassigned ... end This will help your code be more understandable. Same with the escape method. You can make them both private by defining the methods after the ```private``` keyword. Or call private on the method names like so: private :unassigned, :escape Furthermore, I strongly suggest you find ways to split this into separate classes. Think of the responsibilities your big class has, and break up the code accordingly. I see some stuff in here for defining a template, some stuff in here for adding colors to characters, lots of stuff trying to decide whether things should be printed. Break these things out into smaller classes, and try to keep them as loosely coupled as possible. By that I mean that maybe your templating class should know how to *use* the class that colors output, but it doesn't have to, or want to, know how it works. I see a lot of methods with very similar code. For instance #in and #confirm. They both seem to do very much the same thing, up until a point. How can you avoid repeating yourself? Finally, you have a lot of class variables (the ```@@``` ones). To be honest, I've never seen a good use case for these. Especially since your class has an ```initialize``` method, and most of the methods are instance methods, which implies that pretty much any interaction one would have with this gem would be with instances of it. Let these variables be instance variables too, unless you plan on never changing them. If you don't ever plan on letting these attributes be writeable, do this: class Foo ATTRIBUTE = "bar" OTHER_ATTRIBUTE = :bar end Ruby constantizes things that are capitalized, so anybody reading your code will know what to expect. TL;DR: Think DRY (Don't Repeat Yourself) and SRP (Single Responsibility Principle). Don't write the same code twice, and each class should be responsible for *one* thing. Good luck, I'm always glad to see people learning :)
Re: the note-- I strongly suggest documentation much earlier in the process. Better yet, familiarize yourself with Test Driven Development. A brief description of it is this: You write a failing test for a public method *first*, then you run it, then you write the code for that method to make the test (and only this test) pass. Then write another test that describes what happens when you put something *else* into the same method, rerun your test suite and watch that test fail. Then fix the method such that both tests pass. Wash, rinse, repeat, until the behavior of your method is well defined. Meaning you know what happens with a few different use cases, and any options you want the method to know about have tests describing what they do *to the output*. The benefits of developing in this way are many. First, you always know what you're working on and what you still need to do. Second, bugs can be easier to catch. Third, you only write the code that your project needs to work. I suggest you look into Minitest or RSpec. Both are fairly simple and quick to familiarize yourself with. 
I like it! I like this a lot.... Hope to see more....
Could you explain a bit more?
Howdy, First thing I see: x=6,000,000,000 creates an array [6,0,0,0] instead of the number 6000000000. I re-wrote it a little differently, does this example make sense? array = [] x = 6000000000 (1...x).each do |y| array &lt;&lt; y if x%y == 0 end puts array[-2] If I understand you're looping from 1 to x. You check to see if 6000000000 modulo this number is equal to zero, and if it is you add it to the array. I'm not sure this gives you prime numbers. I ran it on an output of 600 just to check, and at the end the content of array was: [1,2,3,4,5,6,8,10,12,15,20,24,25,30,40,50,60,75,100,120,150,200,300] I think before you enter a new number into the array you need to check to make sure there is already not a factor of that number inside the array. Let me know if I explained something poorly or understood what you are doing wrong and I'll try to fix it.
Its identifying prime factors not prime numbers. I tested it for x=100 and got the intended result. I think it just may be taking too long to process. Is there a faster way to process this or am I doomed to wait 100+minutes?
It's not actually finding prime factors, just factors. Prime factors are the prime numbered factors.
&gt; Its identifying prime factors not prime numbers. I tested it for x=100 and got the intended result. I think it just may be taking too long to process. &gt; Doh sorry, I really misunderstood. I think that there are methods faster than this, but I think they'd all be more difficult from a mathematics point of view. You could try to implement something like this https://github.com/kwando/quadratic-sieve
oh damn, so I need to add another step too then? is there a way to sort arrays in ruby by prime numbers? Like could I do something like: array.each do |x| x.is_a? prime new_array.push x end
No, you also need to know how many of each prime. Just as a for-instance, the prime factorization of 600 is 2 * 2 * 2 * 3 * 5 * 5 aka 2^3 * 3 * 5^2 You're not going to get that just by checking to see if a number is prime. 
For what it's worth, if you had actually been looking for all the factors (and not the prime factors), you could have gone from (2..(x / 2)) and added 1 and x to the beginning and ends of the array manually to cut the number of loops in half.
Here it is in code. Take a look, and ping me direct if you have questions. :) def fib_sum_if_even() a = 1 b = 2 sum = 0 while b &lt; 4000000 sum += b if b.even? a = b b = a + b end return sum end 
#3 doesn't seem to be working properly. I select false and nil and it marks it wrong. 
If you're doing this as an exercise, there are a few more tricks off the top of my head that can speed this up. For example: * Divisors of a number come in pairs of `a` and `b`, e.g. 12 -&gt; (1, 12), (2, 6), (3,4), so you only need to find one to get the other. You only need to search from 1 to when `a == b`, which is a lower bound than `x/2` * You don't need to check 1 * you can check 2 just once and then skip the rest of the even numbers, cutting the work in half * In addition, you can check 3 just once, and in combination with the above, eliminates another 1/6th of the work * You can add 5 to to the same technique above in a similar way, but only for another 1/30th(?) of the work If you're actually putting this into use, you should just use the Math/Primes library that Ruby already has.
1.9 only? A major version bump would have been nice.
Adding onto point #1 of this: The upper bound of what you need to check is actually sqrt(x).
I am really sorry about that, fixed. It is one more confirmation that one should not release an app with poor test coverage. Thank you very much for bug report!
shouldnt the while loop be: while b &lt; 4000000 sum += b if b.even? b += a a = b - a end
They were using Rubinius for the concurrency but as of the last few months (I suppose Ruby 2+ and especially 2.1+) there was enough speed and concurrency that rbx wasn't required. Latest source in master points to vanilla 2.1 which is pretty cool if you ask me!
As germans would say, 'Jain'. You're not extending object of the class, you're extending object's eigenclass, which is different from extending the class itself - see a few eigenclass examples [here](https://gist.github.com/isokcevic/9757822/c28ef2efa7a93af73c6993ba624edf3728e3942c). So 'extending object of the class', i.e. using extend keyword on an object, vs. using it within class definition, are quite different beasts. Basically, extending an object puts the method in the object and instance method in its eigenclass, while extending a class puts the method in class (and eigenclass, as it inherits automatically) - but not as instance method. In other words, 'object of the class is', well, just an object (instance), but there IS such thing as "'something of the class' that is different from the class itself". However, ruby tires to hide it from you, so if you don't explicitly tamper with eigenclass, it will behave 100% same like the base class, and will never warn you of its presence. Kinda mindbending, and most of the time not needed, but Eigenclasses are a REALLY powerful concept which, in the end, enables ruby to be what it is :) However, the issue here is I guess the ambiguity of statement "Class could be extended", which can mean a) A class can be extended (with unspecified thing) b) An unspecified thing can extend a Class which stems from ambiguity of 'be extended' - is extending being done on something or with something - I'd have to say it means 'you can extend a class with something' rather than 'you can use a class to extend something'. Baah, low sleep, much rambling, hope somebody finds any of this useful XD 
Silly me. Yes, it should! Thank you. &gt; while b &lt; 4000000 &gt; sum += b if b.even? &gt; b += a &gt; a = b - a &gt; end 
What you're saying is insightful and true, but note that I haven't extended an _instance_ of `c` - I extended `c` itself. /u/Ruby-HeeL meant that when I call `c.extend`, I'm doing something different than what happens when I simply call `extend` in an open class, which is not true.
All this time I never realized a Rails 'engine' was a proper noun with a class and everything! I just thought it was a programming pattern or something.
Hi, yes, we know this job board won't be suitable for all developers, just for developers who publish some or all of their work on GitHub. One of the main purposes of this project is to encourage developers to share their work and even improve how their code is written. There're thousands of developers out there sharing their code, making contributions and even writing new tools for everyone to use and improve. These developers will be the ones who might benefit from using this job board. Also, it's very common to read job posts where one of the first thing the companies ask for is the GitHub username. About the character limit for the post descriptions, we like the idea of being able to read a post in just a few seconds, avoiding long texts and being able to apply for that job just by clicking the Apply button. We encourage companies to be brief, more specific and describe which project/s the developer will be working on. Thanks for the feedback! :-)
Hopefully! One thing we would like to point out is that we don't think that showing your GitHub public repositories should be enough for companies to decide if a developer is the perfect match or not. But we do think it's a very good starting point. Thanks for the feedback! :-)
I don't get it :&lt;
Ah yes, sloppy reading - not the best kind of reading...
like a Rails Engine is actually a thing you create, that has a structure like a rails app, with specifically defined `class Engine &lt; ::Rails::Engine` It's not just a way of architecting your application.
I recommend hiring a copy editor before releasing your book.
Form objects are great, but this one is missing one important aspect: Type coercion. Everything which comes from the web is represented as strings. But you want to perform your validations (and further processing) on attributes with the correct data types. In this example `user_ids` wouldn't be `[1, 2]` when coming from the web, but `["1", "2"]`. In this case this doesn't matter, because `ActiveRecord` does the conversion for you, but there are other cases where you want to operate on the data directly. Therefore I use libraries like `virtus` for my form objects. A couple of other points I dislike: * Why does he mention the `Organization` constant in the tests? It's not necessary for testing his form. * `get_employees` should actually be called `employees`. * Speaking of employees: If we want to follow the tell-don't-ask principle we should ask the organization if all the employees belong to this organization. * He's stubbing `valid?` of the object under test which feels awkward. That's probably because he's mixing two concerns: form validation and the interaction with the system (sending emails). The interaction should be separated into `MassEmailEmployees.new(request).perform` where request is an instance of `EmployeeMassMailerForm`.
You're not going to learn from codecademy what you need to start using an api. I don't know about this coinbase, although I looked at the readme and it seems straight forward enough. Answer A: I'll tell you what. Use the Oath gem and write something to use the google api, and look at stack overflow a lot. Once you have that figured out take a gander at this one. Answer B: I'd be very wary of this. I would only use trusted 3rd party solutions, and I would do a lot of homework on this gem and this api before I did anything that involved money transfers. And that's only if you're planning on handling your own money, don't do this if you're thinking of handling other people's money.
I'll look into that, thank you!
For sure they haven't heard that evaluating a person by their github activity is racist and sexist. 
You can always use sqlite, it doesn't require a database server running.
I think a server-less database such as sqlite or [Hammerspace](https://github.com/airbnb/hammerspace) would be a natural progression. If you end up using the former, you can use ActiveRecord outside of Rails to make interacting with the DB a lot easier.
Yeah, the punchgirls are totally gender-neutral. There's nothing about them that has anything to do with gender. At all.
For the Array thing, I tend to do `[*test]` or `[test].flatten(1)`, which has lead to a lot of weird crap for some reason. I'm gonna check out that `Array(test)` thing though, I kind of like it - except for the fact that it looks weird to me...
Sorry, is there something specific about the project you'd like to point out that isn't gender neutral, or are you going to make retarded statements about their branding? Not PC enough for you? 
Nope, I love the whole "let's fix gender in tech" thing personally, but claiming that the punchgirls are gender neutral is willful ignorance. This article title: "Women in tech: ..." The group's name. The github organization. 
Replace all the instances of "girls" in their organization, the link from their readme to the Rails Girls summer of code with "men" and then tell me women wouldn't be hesitant to join / contribute.
They might be hesitant. Which would be exactly as sexist as men being hesitant to join or contribute to this.
Thanks, exactly this.
Agree to disagree then, thanks for the downvotes!
I didn't downvote a thing. 
Not much to go on here, can you post a gist detailing how you're making the query and how you're displaying the results?
&gt; There's a reason people usually advocate spaces over tabs. Heh, I haven't yet responded to the draft for that holy war. :-D But I usually let convention trump personal preferences, and 2-space indentation seems to be what the Ruby community has settled upon (by quite a large margin), so point well taken. &gt; Also, some usage examples and a screenshot or two explaining what this is would be useful Agreed, I'm actually working on that as we speak. After reading through feedback here, I've decided to make that a bigger priority and get something up there before I resume adding/refactoring anything else. &gt; Line 425, method #passthru, you check if something is an array (you shouldn't do this. Don't ask what a class is, ask what it responds to Good point, makes a lot of sense especially since that's all my code really cares about in order to function properly. &gt; Class methods should be reserved for very special cases. So I'm a little on the fence about this. My interpretation of class methods was that they were more or less the equivalent to static methods in other languages. Unit testing aside, does it not make sense to prefer that type of context for methods that are autonomous and don't depend on the state of a particular instance? Granted, the syntax is definitely ugly and verbose, which usually means the language is trying to tell me I'm doing something strange/unexpected and not recommended. &gt; As you begin working on a gem, you want your public API Totally agree, this is next on my list now that I have something that is more or less functional. &gt; You can make them both private by defining the methods after the private keyword. I think what you are suggesting is already there (making them private), at least that was my intent. Did you miss the "private" declaration on line 465 or am I just not defining private methods correctly? &gt; Furthermore, I strongly suggest you find ways to split this into separate classes. Makes sense. I think I was hesitant to do that right away only because I was still getting my bearings with how OO works in Ruby and didn't want to add to much structural complexity. The fact that it's a rather long file is telling me you're right, this class is definitely trying to do too many things. &gt; I see a lot of methods with very similar code. I actually noticed this as well and felt dirty while writing it. I haven't yet figured out how to reduce the duplication further, but it's definitely on my punch list. &gt; If you don't ever plan on letting these attributes be writeable Actually, I was considering this for most of those "template" strings. Ideally I was hoping to separate out the formatting so that it could be interchanged with alternate formats (a rudimentary equivalent to a stylesheet perhaps). But for now, they probably could be constants since they would likely not be independent class variables like that if they were externalized. &gt; Good luck, I'm always glad to see people learning :) Indeed! Thanks for your thoughtful comments, it takes a lot of time and patience to read someone else's code and it's reflecting well on my impression of the Ruby community thus far. Thanks!
Aye, no kidding. You gotta at least post some example code. OP, I take it you've verified that the DB actually contains 5 different users?
It sounds like you have a few problems: 1. You don't know how you want to model your data. 2. You don't know what your complete requirements are. 3. You're expanding your requirements without having a modularized configuration. 4. You don't know the technical options available to store and interface with your data. 5. You have no persistence mechanism right now. Let's catalog what we know: * You've got inventory. I'm assuming you mean inventory of machines? * You've got IP addresses. I'm assuming those are assigned to machines. * You've got limited records -- let's say &lt;2000, for now. That's a very limited data set (in DB terms). Here's what I would recommend: 1. Figure out what the use cases you want to embrace are. 2. Figure out what data you really need to support ALL of your conceivable use cases. 3. Make a reasonable model of that data; what's logically connected? 4. Decide on a persistence model. If you're just looking to persist data, use YAML. If you're looking to socialize that data and send it to others, I would actually use the Ruby CSV library: http://ruby-doc.org/stdlib-1.9.2/libdoc/csv/rdoc/CSV.html -- that way you can edit it manually, send it to others if you need, etc. If you're going to be adding a lot more data or want to enhance lookup performance, I'd use a database, but with an Object-Relational Mapping system. Personally, I like Sequel: https://github.com/jeremyevans/sequel -- and you can use SQLite to get started. This also sets you up to potentially create a tiny web application with something like Sinatra or Padrino; you will be able to use your DB configuration as is, and focus on just building the web app around it. I wouldn't recommend Rails, except for insofar as it's a great learning experience. It sounds like you're not building a real webapp, so don't use a real webapp framework. Just use what you need, and start from the beginning (which you're already doing). I'm happy to provide further help if you want to send over the code you have. I'd bet you could modularize it really quickly using any of the technologies mentioned above. \-\- Edit: it's worth noting that you can probably do whatever you're thinking about very easily with hashes. It won't be super optimized, but with only a couple thousand rows, you won't be able to tell the difference. You can just use code something like this: irb(main):001:0&gt; {a: 'x'}.select{|key,val| val == 'x'} =&gt; {:a=&gt;"x"} Then you just have the key as IP address, then named attributes in a hash as the value. Take this example code: hsh = {} alphabet = ('a'..'z').to_a 2000.times do |x| hsh[x] = { :a =&gt; alphabet.sample(20).join, :b =&gt; alphabet.sample(20).join } end timer = Time.new result = hsh.select{|key,val| val[:a][-1] == 'c' &amp;&amp; val[:b][0] == 'x' } time_to_execute = Time.new - timer result.each {|k,v| puts "#{k}: #{v}"} puts time_to_execute And the results for said code: 447: {:a=&gt;"mwbvyutdfgpzoanjiskc", :b=&gt;"xjqdsekrofaunwhpmztg"} 994: {:a=&gt;"qdpisfjvwboelxtgknhc", :b=&gt;"xkjqsnaelrmbychoupwg"} 1583: {:a=&gt;"egtvzxlpaqydjshrnwfc", :b=&gt;"xcnfyhzklugiwjvamqep"} 1892: {:a=&gt;"luefhirowjpykvtmsgnc", :b=&gt;"xshlpgrfezqniaumjdtw"} 0.001001 Using this method, your lookup will always be O(N) + efficiency of whatever select statement you write, since hash lookups are constant and you're just iterating over the hash. And since your N is &lt;2000, as you can see, the time to execute was about a thousandth of a second.
Let me second Flopsey's comment about not programming something financial-related until you REALLY know what you're doing. If you code something poorly and it has the ability to impoverish you... you're going to (probably) have a very bad time. Why are you looking to programmatically buy and sell bitcoin?
I don't want to enable your downfall, but if you're set on it, someone already made a simple library to connect to coinbase: https://github.com/coinbase/coinbase-ruby All you need to have is an API key. Follow the examples to get started.
thank you!
Agreed, either this or just use Marshal. Both YAML and Marshal should be able to serialize arrays and hashes of IP address objects.
&gt; I can understand your concern for not seeing a lot of example code, but do take into account that **95% of these frameworks** have very detailed documentations built for them, explaining everything in baby-steps. 11.4 of those 12 frameworks have documentation. 
SQLite
It's not really big data, but to directly answer your question: you want too look up perceptual hashing (p-hash) to start. But to give you general advice: if you don't already have experience with the algorithm, I'd recommend you start with "random" (use a seed based on the user_id or something so it's reproducible) and do it as "secret sauce" until you have enough users and content for corpus large enough to actually process (and validate that people are interested in your concept in the first-place). Pull out some color data and histograms (easily done with imagemagick) and make it seem like you're the smartest guy in the room, but otherwise fake it til you make it. From my experience in building social and dating apps, it's way better (and much more common) to have a crap algorithm and lots of users than the other way around. Edit: sounds like a cool idea though. best of luck!
These are not that interesting. pakyow and hayabusa are though. Google them. 
Thank you.
Clearly the wedding reception was reserved with copious gratuities to *overlook* the double booking. Did you guys check if they held similar conferences without incident?
Here's what you do when someone breaks your contract. As they set things up, you throw it out. Tell them to DEAL with it and to read the contract. Assuming if as you say your were in the clear according to your contract. In addition to breaking the contract for the venue you also have claims that they double charged for internet access. Advise everyone to run charge backs. This will hit them in the wallet hard time because not only will they have to refund that but another $40+ USD. EACH. So call them up again and let them know, you know how to tango.
...and that's what you get for bothering with the shit stain that is india. It's a big world, there are plenty of other places that would love to have you.
I don't understand why they wouldn't have picked a different location after the original problems over 6 months before the conference. That hotel seems inept from the start.
The O'Reilly book co-authored by Matz himself is the best "formal" introduction, IMHO. It's not quite at spec level but it's the closest. The Pickaxe probably edges it in terms of "reference" however.
Funny you mention that... that's exactly what tripped me up last time I dove into trying to learn Ember. Seeing a proper unauthenticated redirect handler would be awesome.
This would be perfect for me to catalog my magic cards ;)
(author here) So far, we are manually doing type coercion, and in most of the cases, as you have already pointed out, AR takes care of it. Regarding the points that you have mentioned: * I just mentioned `Organization` for code brevity. I tried to strip as much code as possible. * `Organization` model has `has_many :employees`, so it already provides a method called employees. I agree with tell-don't-ask principle, but in most of the cases, it didn't fit my needs properly. Say, in this example, if i have to validate employees based on their status, ie. whether they are suspended or not, then i have to add another method to Organization model. That would bloat Organization model interface. * Im not much concerned about *interaction with the system*. Even if we separate this concern into a separate class, code will look as shown below: [EDIT: I can't get reddit to format this section properly :(] def perform return false unless valid? MassEmailEmployees.new(self).perform end Here, we have to test whether `EmployeeMassMailerForm#perform` is delegating to `MassEmailEmployee` or not. In order to test `perform`, i would suggest to stub `valid?`, since we have already ensured that form is properly validating all the parameters passed to it.
I think I'll use mechanize to scrape a database of magic cards for said catalog!
Forget about fundamentals - Meteor makes making apps fun. Making a web app requires thousands of small components and trying to find libraries that work together could take you all of your life. Meteor can be seen as a collection of packages that work together and make creating web apps easy.
You're definitely off to a good start. I made some changes on the gist below, cutting down on a few lines of code and making use of another method for your repeated code. Remember DRY ( Don't repeat yourself ) :).. There may be some errors as I didn't spend much time writing it and didn't test it but it should give you an idea of how to move forward in the future. If you have any questions let me know! [Gist](https://gist.github.com/bloot/9805909)
I did this because only in your answers 1 and 2 are you making a call to RedditKit.user. In the other cases you are running two different pieces of code. The reason I did this beyond that is because it saves you one line of code. If the answer is 1 OR the answer is 2 then RedditKit.user @redditor. Also I noticed that I'm making a call to the local var instead of the instance var so there is a bug in what I wrote :) just add an "@" to redditor and that line should be fine.
why one should buy it? what's the difference to [gem guides](http://guides.rubygems.org), there you have all you need for creating a gem ... 
Why are you charging for the code? I've literally never seen that. Your book is already on the expensive end, especially for an e-book with so few pages. Charging double to get the illustrative code samples is just an insult frankly.
OSX only :-(
Cool. So i tried out your code, and it wasnt Quite workng, so i kind of adaped a DRY Principle to it. # # A Reddit script using Ruby and the API Wrapper 'RedditKit' # By Sam Detnon 'Phantomofthesoup' # require 'redditkit' # Method for retreving user data (karma etc...) def Usdat puts "Username?" @redditor = gets.chomp @user = RedditKit.user @redditor end # Method for retrieving comments from a user def Contdat puts "Username?" @redditor = gets.chomp @user = RedditKit.user_content @redditor , options = {category: 'comments'} end # # Start of script # def General puts %q( What would you like to do? See someones link karma? - 1 See someones Comment Karma - 2 See someones Comments? - 3 Check to see if a username is avaliable? - 4) ansr = gets.chomp case ansr when '1' Usdat() puts "User '#{@user.username}' has #{@user.link_karma} link karma!" when '2' Usdat() puts "User '#{@user.username}' has #{@user.comment_karma} link karma!" when '3' Contdat() # Parse through each comment @user.each do |x| puts "#{x.body}" puts "#{x.author}" puts "" end when '4' puts "Username?" redditor = gets.chomp # .username_available? returns a boolean client = RedditKit.username_available? redditor # Checks if Boolean is true or false. if client == true puts "Username is avaliable!" else puts "Username Taken :(" end end end General() Thoughts now? Cheers 
Because he wants to make money. Luckily there are a lot of **free** resources out there... and that's kind of what this subreddit is all about.
Yeah, but marginal cost of producing more copies of the ebook and code is effectively nil, and there's a pretty broad potential audience for the book. He could easily make up the cost in volume of sales if he was charging a reasonable price and including the code. You can't price your shorter book higher than all the competition, charge $40 for something every other ruby book makes freely available on github and expect to make as much money as if you didn't just insult your entire market. I was considering buying it, but I'm not spending $40 (on sale) for a 100 page book that doesn't even come with code samples that I can look at in case something goes wrong and I need to check my work against the sample.
Hey brandon, regular reader of your journeys in MMO(making money online) and your experiences in jdfi. How did you come with the $39,$79, $129 price points? I'm seeing a lot of ruby developers who churning out info products and using a similar sales model, a pdf book, book + source code + screencasts. Hope you share some of your learning's in future blog posts.
An educational post, to be sure, but the conclusion "As you can see we need to pull the string for 77.09Hz" leaves me hanging. Can you elaborate on specifically what that sentence means, and how you concluded that based on the chart shown? Commenting here because I can't comment anonymously on your blog post.
ran into same thing here; maybe it's because of the soundcloud widget?
The frequency of the first open string as read by the program is: 252.54Hz. That string, when in tune is suppose to be: 329.63Hz. So the difference between the two is: 77.09Hz. Thus for the first open to be in tune, he would have to tighten the string enough to raise it that difference. Hope that helps =D 
I've used [httparty](https://github.com/jnunemaker/httparty) for this in the past.
Thanks for your reply. There was a specific builder though that let you give the format via a DSL since some of the other wrapping is generic.
Hm, was it [spigot](https://github.com/mwerner/spigot)?
I think you're looking for [Grape](https://github.com/intridea/grape) edit: My mistake, this is not what you're looking for.
Maybe I misunderstood amalagg, but Grape is more on the API creation side, and I think amalagg's looking for a consumption side wrapper.
You're right, still a nice gem though 
Thank you, that is the one! Starting a new project and this could be very useful!
I noticed a few things: * Style: it's a convention to write method names lowercase and in snake_case * Style: try to make a method name understandable (example: `ask_action`, `retrieve_user`, `retrieve_user_comments`) * Style: you don't need to add the parentheses to the method when calling a method without parameters * Code: if you're using a `case` statement, add an `else` * Code: try to make methods as short as possible, this keeps them readable, less complex and easier to test * Code: when only outputting a object, you don't need to interpolate it in a String * Code: when using a `if` statement, when the condition is not `nil` or `false` it's always true. (example: `if boolean == true` can be written as `if boolean`) I've updated your script: [gist](https://gist.github.com/JanDintel/02b4671c6ec70fa5942a) Learn more about the Ruby style with the [Ruby style guide](https://github.com/bbatsov/ruby-style-guide) Let me know if this helps! 
I used to work with Jim at Neo (then EdgeCase). Such a great guy in general, and super humble. You'll be missed!
Active Resource is good if you're consuming a REST API.
That is a good point, thank you.
What exactly do you mean by "use a class like a module"? A module can not be instantiated, and typically isn't used to store store state. A module's primary use is to include a certain set of functionality where its included. A module provides functions. A class, since it is a subclass of module, also provides functions, but has the additional property of state (hence the difference between class and instance methods). Maybe if you could provide a use case of "using a class like a module" it would be a little more clear what you are asking.
Maybe it's not clear enough this way, but I did include my concrete use case in the title: Module#include is the method that doesn't accept a Class. I really dislike this behavior and want to know what's behind it. Even the error it raises is kinda telling: `TypeError: wrong argument type Class (expected Module)`. Well, it's great that it expects a Module, except that it can't be anything else but a Module.
I guess what I'm getting at is *why* would you want to include a class like a module? What functionality are you trying to achieve by doing so?
Why not? A class can do everything a module can, and then some. It seems arbitrary to limit include to pure modules, and as I already mentioned, contrary to the L in SOLID. But to answer your question with the bona fide that you're only asking out of curiosity and not trying to prove me that there's a better way, here's my actual scenario. I have a couple classes that are each subclassed from a new Struct instance like this: class A &lt; Struct.new(:a, :b, :c) end And right now I'm exploring my options to autoreload some code files. But the problem is that when I reload the file that contains A, because I'm reopening the class with a different superclass than before (Struct.new creates a new StructClass each time), the reloading fails. So I was wondering why I couldn't just do it like this: class A include Struct.new(:a, :b, :c) end That led me here, to see if someone has any insight on why include is not working with classes, or if it's even intentional in the first place.
You probably don't want to instantiate `A` that way. consider: A = Struct.new(:a, :b, :c) This will not create an intermediate class, which could be your problem.
Honest question, not trying to be rude, but have you ever written an object oriented programming language? While I certainly expect my cowokers and I to commit to Liskov, I'll give matz a pass here. `Class` and `Module` share a lot of core behavior, and they form the underpinnings of the language.
I'd gladly give a pass, but first I'd like to understand the reasons that led to this - that's why I asked here to see if someone knows something about that.
Bona fide was mistakenly granted from my part. I'm not asking for code review, and believe me that I probably know better what I'm trying to do. I really don't like downvoting, but after my explicit appeal to avoid bikeshedding over my code sample you still did just that so there goes.
I think you misunderstood me. I think it's worth trying what I suggested because your approach, `class A &lt; Struct.new` is actually creating *two* `StructClass` instances. Are you using ruby's built in `autoload` method, or are you using e.g. active support's autoloader? I'm not bikeshedding at all, this could be your problem, as I stated. It shouldn't be too hard to try this out.
It's not hard, but not my problem is not this. My problem is solely that I don't see any justification behind not being able to include a class. The file reloading issue was just the spark that made me question this behavior, and is neither a difficult or a particularly interesting challenge to solve. Please stop derailing this thread if you don't have anything to contribute on topic.
Does this gem really need to be built with TDD? I'm not sure I would have liked ruby if I tried TDD my first week. What I do recommend to the author is to provide some kind of "test drive" script that lets me `git clone` the repo and take it for a spin.
You probably meant `def self.bar` instead of `def bar`. &gt; What would you expect B#foo to do? I'd expect `B#foo` to send the message `:bar` to the class of the instance, in this case B, because that's what it is supposed to do. From then on, it's up to that object if it responds to that message or not. This is in no way a Liskov violation because including something else is not inheritance, only behaviorally. You never declared that 'every B is also an A', you just used some methods A defined. &gt;Contrast that to a Module, where instance methods that you'd mix in to a class have no ability to reference the module via self. And `foo` has no way of referencing A when used in B, so I see no difference here. On the other hand, a method defined on a module can simply access its including class through `self.class`, just as it could when defined on a class. Of course if you just simply instantiate A, you can reference A, but not because the method was originally defined there, only because it's now on an instance of A. &gt; Ruby would have to handle including a Class very differently, copying class methods to the target as well. I disagree, see my previous explanation. &gt; Also, remember that Modules can also be #extend'ed. How would you handle #extend on a Class? Extending is simply copying all instance methods from the module to the object's eigenclass. I don't see how that would cause the slightest problem with a class, classes have instance methods just like modules do (as they should, because they ARE modules on paper). &gt; a Module cannot inherit from another Module, but a Class can. You'd have full on multi inheritance if you could include a Class. I guess you mean include instead of inherit. Well, I can't see any theoretical problems with multiple inheritance anyway, so I'm still at square one, wondering why it's not made possible by the language.
I think the fact that Class inherits from Module is simply an implementation detail because they share functionality. The Liskov substitution principle is meant to be a guideline for good OO app design; it doesn't necessarily make sense in the domain of the programming language's own object model.
&gt; I'd expect B#foo to send the message :bar to the class of the instance, in this case B, because that's what it is supposed to do. From then on, it's up to that object if it responds to that message or not. This is in no way a Liskov violation because including something else is not inheritance, only behaviorally. You never declared that 'every B is also an A', you just used some methods A defined. Fine. So you're saying that *only* instance methods should be copied from the class to the included module? That means you (the programmer) must ensure your class has no reference to `self.class`. &gt; And foo has no way of referencing A when used in B, so I see no difference here. On the other hand, a method defined on a module can simply access its including class through self.class, just as it could when defined on a class. Of course if you just simply instantiate A, you can reference A, but not because the method was originally defined there, only because it's now on an instance of A. Wait, huh? module Foo def foo self.class.bar end def self.bar "hi" end end o = Object.new o.extend Foo o.foo Doesn't work for me. If you're saying that a method included by a Module can pass the `class` message to `self` and get the class, that's fine, but *not* what I was talking about. &gt; Extending is simply copying all instance methods from the module to the object's eigenclass. I don't see how that would cause the slightest problem with a class, classes have instance methods just like modules do (as they should, because they ARE modules on paper). Based on your qualification that you'd only support copying instance methods, this would be fine. I think it would be problematic for programmers, but that's beside the point. &gt; I guess you mean include instead of inherit. Well, I can't see any theoretical problems with multiple inheritance anyway, so I'm still at square one, wondering why it's not made possible by the language. Huh? You are welcome to find a language in 2014 that embraces the idea of multiple inheritance (eifel? C++?). Ruby has single inheritance plus mixins. I'd open to examples of how multiple inheritance could make me a more productive rubyist.
&gt; That means you (the programmer) must ensure your class has no reference to self.class. Nope. That means self.class will be a different object when the instance method is included in another class. Which is perfectly in line with my intuition, and also the duck typing paradigm. Is there a `self`, does it have a `class`, does that respond to `bar`? If so, great. Also you keep talking about 'my specification' that only instance methods should get copied. You are aware though that this is how it currently works with modules, aren't you? The point of modules is to contain method definitions, which classes also do. Classes only have the added responsibility to create instances of themselves, binding the stored methods to them. Including a module means adding its stored method definitions to those that the invoker is storing. Oh, and you didn't read carefully what I wrote, because you keep demonstrating how included module methods can't reference the original contaning module and its eigenclass methods. I said that just like methods you included from a module can't reference that module, methods you could include from a class couldn't reference that class any more. So if the `Foo` module in your latest example was a class and it could be used in the way I'm arguing for, it would raise the exact same error: there's no `bar` method on the object `o`'s class. Just a short aside on multiple inheritance: you basically already have multiple inheritance, you just need to put everything in modules and include them in the classes you want to instantiate.
I like httparty, but prefer faraday in that you can use middleware like JSON parsing, OAuth, etc, but you can also write your own. That and the outer API is as clean/simple as httparty.
Possibly [hendrix](https://rubygems.org/gems/hendrix): &gt; A DSL for constructing flat API clients that follow Ruby conventions and require little knowledge of REST.
Check out https://github.com/remiprev/her
Thanks. Do you have a github account that I can point to in the commit message?
The pricing structure is coming from Nathan Barry's Authority book I guess.
I'm using typhoeus instead of httparty, that's awesome : https://github.com/typhoeus/typhoeus
It's just a design decision. You can actually do it. /u/banister wrote a C extension that allows you to include methods from objects or classes: https://github.com/banister/object2module Sadly, it doesn't seem to work on recent rubies due to changes in ruby's C API. I just wrote a little hack that makes including/extending Classes work on ruby 2.0.0 using a trick /u/charliesome shared for finding ruby's hidden FrozenCore class: https://gist.github.com/benolee/4e2e78eaf20d01542457 Sadly, the FrozenCore trick seems to have stopped working in ruby 2.1.x :( The point is, it's technically possible. It's just an implementation detail.
Thanks for these links, really interesting!
I don't think "Why would you want to" is the important question here - I think the important question is why is there an arbitrary limitation on how classes can be used, since, technically, they are a Module. &gt; Class.superclass =&gt; Module I don't have an answer for this, but I do think it is an interesting question, and even more so, when you have arbitrary limitations in the language, it makes sense to question them, since arbitrary limitations are pretty much the anti-thesis of consistency, and consistency is a very nice property in any well designed system.
I'm really excited to watch this later when I'm home. I'm a bit bummed that no one else has commented, and the video hasn't gotten more up votes. I see questions about creating gems all the time.
&gt; Nope. That means self.class will be a different object when the instance method is included in another class. Which is perfectly in line with my intuition, and also the duck typing paradigm. Is there a self, does it have a class, does that respond to bar? If so, great. You're not seeing the problem I was highlighting. I understand why, my explanation wasn't good. I'm saying that if you don't also "graft" the ancestry chain of the class methods onto the included object, you're going to get surprising behavior: 1. Within instance methods the `class`, `self.class` refers to the `class`. 2. When included in, say, a `Module`, `self.class` isn't anything, really. 3. When included inside another `class`, `self.class` points to a totally different bank of class methods. Inevitably, people would just stop using class methods altogether if they wanted to mix in their classes, I'd suspect. &gt; Also you keep talking about 'my specification' that only instance methods should get copied. You are aware though that this is how it currently works with modules, aren't you? The point of modules is to contain method definitions, which classes also do. Classes only have the added responsibility to create instances of themselves, binding the stored methods to them. Including a module means adding its stored method definitions to those that the invoker is storing. Yes, you're talking to someone who knows the language very well. A module "instance" method can't really reference the module methods without a hard reference to the module itself. Also, class methods need to inherit from their superclass' class methods. With a module, you're injecting a single point in the ancestry chain, with a class, you're injecting an arbitrarily long sequence of methods. &gt; Oh, and you didn't read carefully what I wrote The hell I didn't. &gt; Just a short aside on multiple inheritance: you basically already have multiple inheritance, you just need to put everything in modules and include them in the classes you want to instantiate. No, including a Module isn't really inheritance. You can't do this: module Bar &lt; Foo ; end There's no ancestry chain behind it. That's a hugely important difference between multiple inheritance and mixins.
This is actually a great chance to use Rails' build in command line documentation. If you run `rails generate` without any arguments, you'll get a list of available generators back: Rails: assets controller generator helper integration_test jbuilder mailer migration model resource scaffold scaffold_controller task As you can see, they're centred around the core elements of rails: models, controllers, assets, etc. You can also add the `--help` flag when running any generator to get more info: rails generate controller --help Will spew out a lot of useful info (too much to be worth posting here) Gems you install can add their own custom generators too. There isn't a `photo_viewer` generator in Rails by default, but there might be one out there that you can install. For more info on the Rails command line tool, read the official guide: http://guides.rubyonrails.org/command_line.html
If you just type `rails generate` in the console, it will give you a list of what gems are able to generate what templates. In general, `rails generate` is a way for gems to generate often used files or templates. If there was gem that gives you the basics for a photo viewer web app, it might allow you to generate something. But in general, you'd start with a basic template and customize it. Personally, I don't use the generate functionality for views and controllers, I just write what's needed. Only time I use it is to generate config files that are needed for gems I use.
lists of known rails generator: assets generator mailer observer resource session_migration controller helper migration performance_test scaffold stylesheets decorator integration_test model plugin scaffold_controller task "photo_view" might be a controller... for user to view photos... photos could be a resource...
Thanks for this! I was reading the documentation before and must have missed it, http://guides.rubyonrails.org/command_line.html is what I read. Your list is helpful though thanks. I'm not looking at building a photo viewer it was more just an example that popped into my head. So in terms of knowing which generate command to use based on what you're building is it just a case of read about each one I guess?
Read about each one so that you know what's available, but remember that these commands are just shortcuts for things that you can do manually. They won't help you choose how to implement things. If you're already thinking 'I need a controller for this' then a generator is going to come in handy. I commonly user the controller, model, and migration generators. That's about it. Scaffold is useful when you're getting started but you'll quickly find that you don't need all the files it generates and it's often more appropriate to generate the separate pieces as you need them.
Half of those are solved by actually *learning* regular expressions.
You can get pull that version and then build it with gem build *. Gemspec After that, you must point your path to that newly built gem in your Gmail. The official tutorial on building a gem has a lot of good info (as well as stack overflow (:) I'm on my phone now, if you need more help or direction, just let me know and I'll get back to this later! 
Well, Ruby was written by a Japanese programmer, "Matz" ([Yukihiro Matsumoto](http://en.wikipedia.org/wiki/Yukihiro_Matsumoto). Guido van Rossum (creator of Python) is Dutch and grew up in the Netherlands, but he has worked for a significant part of his life in America, and almost all Dutch primary school students are taught bi-lingually. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Yukihiro Matsumoto**](http://en.wikipedia.org/wiki/Yukihiro%20Matsumoto): [](#sfw) --- &gt; &gt;__Yukihiro Matsumoto__ (æ¾æœ¬è¡Œå¼˜ (ã¾ã¤ã‚‚ã¨ã‚†ãã²ã‚), *Matsumoto Yukihiro* ?, a.k.a. __Matz__, born 14 April 1965) is a Japanese computer scientist and [software programmer](http://en.wikipedia.org/wiki/Software_programmer) best known as the chief designer of the [Ruby](http://en.wikipedia.org/wiki/Ruby_(programming_language\)) [programming language](http://en.wikipedia.org/wiki/Programming_language) and its reference implementation, [Matz's Ruby Interpreter (MRI)](http://en.wikipedia.org/wiki/Ruby_MRI). &gt;As of 2011 [update], Matsumoto is the Chief Architect of Ruby at [Heroku](http://en.wikipedia.org/wiki/Heroku), an online cloud [platform-as-a-service](http://en.wikipedia.org/wiki/Platform-as-a-service) in San Francisco. He is a fellow of [Rakuten Institute of Technology](http://en.wikipedia.org/wiki/Rakuten_Institute_of_Technology), a research and development organisation in [Rakuten](http://en.wikipedia.org/wiki/Rakuten) Inc. &gt;Matsumoto's name can be written using [kanji](http://en.wikipedia.org/wiki/Kanji): æ¾æœ¬è¡Œå¼˜, but is normally written using [hiragana](http://en.wikipedia.org/wiki/Hiragana): ã¾ã¤ã‚‚ã¨ã‚†ãã²ã‚. &gt;==== &gt;[**Image from article**](http://i.imgur.com/nzgrJFv.jpg) [^(i)](http://commons.wikimedia.org/wiki/File:Yukihiro_Matsumoto.JPG) --- ^Interesting: [^Ruby ^\(programming ^language)](http://en.wikipedia.org/wiki/Ruby_\(programming_language\)) ^| [^Mruby](http://en.wikipedia.org/wiki/Mruby) ^| [^Rakuten ^Institute ^of ^Technology](http://en.wikipedia.org/wiki/Rakuten_Institute_of_Technology) ^| [^Ruby ^MRI](http://en.wikipedia.org/wiki/Ruby_MRI) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cge8fum) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cge8fum)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I guess it's about time I learned to make a gem. Thanks
&gt; for a language trying to get more popular... this is a very bad practice... How is this bad practice? Because its a standard for japanese based developers to be required to speak and write english? (â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»
you do not need to do that. what are these people smoking? in your gemfile you just need to include `gem 'blah', :git =&gt; 'git://github.com/blah-creator/blah.git'` [Documentation is here](http://bundler.io/v1.5/git.html)
or you can just [include it directly from github](http://bundler.io/v1.5/git.html)
OP here. Think the point is **Catch more than half of these by testing, auditing, code reviews** The article is there to encourage * to learn them before actually using them. * to learn them before actually learning them the "hard" way in production * to take a look at alternative to implement the feature without regular expressions (or the one used by your stdlib, language) * if you use regex, understand the risks * if you use regex, please write tests for you and your coworkers * if you use regex, please audit your code (automatically and by human code review) 
The joke around my office is that regex is a write-only language.
[Old article](http://significantbits.wordpress.com/2008/01/29/yaml-vs-marshal-performance/), but unless YAML has significantly changed their querying process, Marshal could be exponentially faster.
Yes. And it's a huge reason why I don't do this: class MyClass def results @results ||= ImportantBehavior.do! end end That `@results` instance variable lives on as long someone needs their instance of `MyClass`, regardless of whether their use of `#results` is over. Object lifecycle management is *too* important to lazy load all your biznass.
so you dont cache the result, and you run the expensive calculation each time?
Absolutely not! Removing memoization here has design effects that ripple outside the class; I find they almost always make the code better, as well.
didn't you just say you don't do that though?
Not sure I follow. What I said I don't do is stick operations that go out and grab a bunch of data behind memoization. In practice, I fetch those results once, and pass the results to the objects who need them. On a micro level, the difference is small. On a larger level, I tend to have objects that only live as long as they're needed.
Thanks for the feedback. It's not for everyone. 
Good question...I think having everything in one place honestly. When I got started writing gems, the gem guides weren't enough to be me through without feeling frustrated. So I this could be helpful for those had/have similar frustrations.
Nathan's definitely had a large influence on it. And just drawing a quick conclusion from the sales, the book was very right. Sales were spread out and the highest tier brought in the most revenue, despite having a lower number of sales. 
I posted this in the other thread but I'm unlikely to get an answer there. Interesting. I haven't played...and it's obviously not ideal, but wouldn't wrapping the string with WeakRef solve this?
The divide in your questions is the difference between ruby and perl. 
If it's too expensive for you, perhaps the you might find the free email course helpful: http://brandonhilkert.com/courses/build-a-ruby-gem/
I just played, it seems not.
People would much rather sit around and complain about how bad they think it is instead of attempting to understand it. You see the same attitudes when it comes to any other thing that passes a given threshold of complexity.
Granted, it's engineering because there are always tradeoffs, but it seems like habitually not memoizing could very easily lead to duplicate copies of results being passed around from different original calls. That seems like it could be very painful in terms of bugs and memory consumption. 
Certainly worth reading, and knowing.
It's not that I can't afford it, it's that I won't buy it at that price point, and certainly not given that it's pdf-only and doesn't include code samples. Best of luck with your sales, regardless.
Cool project! well done.
down voting for misleading title
Well, this is a broader discussion, but, from my example above, if you go from: def results @results ||= ImportantBehavior.do! end To def results ImportantBehavior.do! end You're definitely going to have problems. But what if you do this: attr :results def initialize(results) @results = results end Now that class will still hold a reference to the result set, but the fetching was done by someone else. I've reshuffled *responsibilities* around, and what I've noticed in practice is that I've usually aligned objects' life cycles with their responsibilities better. I don't really know exactly how to articulate why, but I decided to stop memoizing for a few weeks just to see what it would do to the way I thought about code design, and the results have been pretty positive for me.
Got it. I do have versions for kindle and iPad that I haven't bundled because I have less control over how the code snippets are rendered. However, for those that requested it, I've send them over. I have a feeling that doesn't change your mind at all. Although, if you have a genuine interest in any of the content, I'd love to chat more. Feel free to shoot me an email at the address on the site.
What does "played" mean in this context? I'm not a native english speaker so pardon me if it's a silly question :)
I might be a bit confused here but I don't see how this has any effect on whether or not the object that `ImportantBehavior.do!` returns gets garbage collected faster. The `@results` variable still holds a reference to it, just like in the memoization example before, until the instance that holds the `@results` var gets GC'd. Maybe I'm wrong though?
And you were expecting what exactly?
Because in the memoized case, any time you need to hang on to the objects for reasons *other* than needing access to e.g. `results`, you're keeping `@results` in memory. In my experience, avoiding memoization leads to a design where all the objects in the system don't last longer than necessary. There's not a direct benefit that I can point to in this case, it's more a "try it and see if you like it" thing. What I'll say is that ditching memoization forced me to start consider how to tightly manage object life cycles. Now, when I run across memoization, it's almost always a hindrance to getting that right.
This was posted a long time ago (2+ years) but this is now updated for Rails 4.0 libraries. I was using Mocha to unit test controller actions. I wanted to assert my controller's update method was calling #save on my ActiveRecord object and it came to my attention that #save was being called by update_attributes and by my controller. I tried digging through ActiveRecord docs but this blog post was exactly what I needed to get save down to 1 call. (hint: you want #attributes= and #save if you have validation handling).
I'm disappointed by the limited scope of the tests (Ruby is not Rails). For anyone who doesn't know, this is inspired by &lt;http://arewefastyet.com&gt;.
Excellent work, and excellent timing. This will be getting implemented on Monday!
You missed the issue. Generational GC marked each tempestuous doc as old and didn't reclaim it infill full GC (which is rare). Storing in an instance variable allow reuse of same doc many times, instead of filling memory with many "temporary" copies. 
My apologies for my terrible abuse of the English language :)
Hmm, interesting. I had written up a very long comment because I just couldn't understand what you meant but after re-reading your comments a few times I think I understand you now. What you are saying is that instead of letting the object instantiate it's own @results object you do it for it and pass it to it through the initializer. That way you feel like you have more control over the lifecycle of the @results object. I think you might actually be confusing memoization a little with dependency injection. Memoization is a very useful technique for caching expensive operations and I don't think you should disregard it like you are doing. But that is of course just my opinion and feel free to do things your way :) You've definitely given me something to think about though. Edit: Thought I should clarify, I'm definitely not saying you're wrong at all, just saying that I don't think it's actually memoization you have a problem with, it's the dependency issue. I might be very wrong though :)
I love it; it looks way more like `test/unit` which is more natural to me :) It solves all the problems I've had with rspec over the years. I still prefer `test/unit`, because I think writing tests that look like this is a lot easier and more natural outside of a DSL.
&gt; We make get some ugly results if some knuckle-head passes it stupid shit. But what it WONT do is barf all over you. It is also as the great Jim Weirich would say, "Polite Ruby". *may? Anyway, I don't like your approach. By passing in `nil` as a `suit` you're violating the invariant of a `Card` and your code should blow up with an `ArgumentError` on construction (e.g. when calling `Card.new(3, nil)`). Trying to guess the user's intention or returning some arbitrary string (`naked`) to prevent crashing is IMO even worse than crashing with a `NoMethodError` on `nil`. In a complex system it's very hard to tell where this string got introduced. A `NoMethodError` usually crashes earlier and you have a stack trace which might help you find the bug. Have a look at `DateTime` for how to properly enforce object invariants (`DateTime.new(2014, 13, 1)`). I think that's the correct way to handle this situation. Especially since a `Card` has very strict requirements for it being a playing card. 
You could get rid of the duplication in `mul`, `add` and `sub` by extracting something like `execute_binary_operation`: def execute_binary_operation @x1 = @stack.pop @x2 = @stack.pop if @x1.nil? @x1 = 0 end if @x2.nil? @x2 = 0 end @stack.push yield(@x1, @x2) end def mul execute_binary_operation do |x1, x2| x1 * x2 end end You could also simplify this further (and not use instance variables): def execute_binary_operation x1 = @stack.pop || 0 x2 = @stack.pop || 0 @stack.push yield(x1, x2) end
That sounds like an incredibly good idea! Thanks.
Am I the only one bothered by the navbar that only goes so far along the screen?
I see. Very interesting, thanks for your response. I'll definitely keep this in mind the next time I use memoization :)
I agree. A card should blow up if it's initialized without one of the four suits. There doesn't exist a playing card in the real world that isn't a spade, club, heart, or diamond, so don't model something that doesn't exist. If you physically scratch off the suit from a card and make it "naked," it's not a playing card anymore :) Code that tries to initialize a Card without a suit is in Error; make sure it pays the price. *That* is confident ruby, imo.
Yeah, that's an excellent attitude to have! :)
Good article. In the same vein, I've found [http://betterspecs.org](http://betterspecs.org) to be invaluable. 
"Let" is great when using context. It is possible to show what have changed.
don't forget the jokers. they are playable in many games
I can't even read the title without my eyes hurting. What the fuck is wrong with you?
The class_eval vs. define_method is more complicated. Yes, define_method creates the method faster. However, after creation a method created with class_eval is faster than one created with define_method. So, it's worthwhile to chose based on your use case. Also, surprised it left out the most common question if/ else vs case.
Congrats! You are right. Unfortunately the current version of the library I use for quizzes does not allow to show tips after passing test. But in any case I will probably add explanations to the end of the article.
Thank you for mention this. @tenderlove has a great post on this subject - Dynamic Method Definitions http://tenderlovemaking.com/2013/03/03/dynamic_method_definitions.html
Nice idea, I'm guilty of doing similar things with puts myself. :D I feel like putsing in the logs is an anti-pattern of debugging, and this is just a small band-aid on that. If you need to inspect something a better approach is to use something like Pry (`binding.pry`). Or look into setting up a separate debug.log file without the clutter of all the other things happening in the log stream.
are you seriously comparing REAL time, benchmarking only 9 invocations?
try to meditate on something like that https://gist.github.com/codesnik/df9055127127e81fc1cf it will give you much more insights on where are real costs hiding.
I find it strange that an /o modifier exists because its use case can arise in any other variable's evaluation. If I discover that `"outputting #{computes_same_string()}"`is a sort of a bottleneck, I don't use any special syntax to cache the value - I just assign it to a variable outside of the loop (or some alternative, like `computed_string ||= compute_string()` or whatever). 
It's pretty much just the equivalent of having frozen strings.
This can be annoying, but I totally understand the want to avoid the repetition of: include ActsAsSomething acts_as_something extend HasSomethingElse has_something_else :foo DRY flags start going off. Because `include` and `extend` don't make it natural to pass parameters, if one has to go, it won't be the method call. And if it weren't for the pollution issue, doubling up in this fairly common case doesn't really add to the clarity. I've seen a gem (which I can't recall at the moment) allow: include Awesomeable(because: "no object pollution") Which seems like the best of both words, but the library-side implementation required to make this work isn't exactly clear or natural. *edit: The gem in question is Textacular: [example here](https://gist.github.com/jswanner/5054142#file-searchable_example-rb).*
My bad, I thought OP was wanting to modify the branched code base (which, even in that scenario, keeping it all on github like you show is probably easiest anyway)
This is less a security "issue" and more a bug in their provisioning system.
not even a bug. They have an option to recover from deleted droplets with in I think one day. So they aren't actually deleting them till a certain time has passed
Do not feed the trolls, people. OP: you're a dick.
Thanks for the great reply! Been having a look over your code, and realised I need to write more like that! As a beginner i need to get these practices down! Thanks for the link :) 
The fun thing with gems that don't include themselves is that it doesn't prevent you from doing it. You can make it happen automatically with very few lines of code! :) My 2 cents
Calling super without arguments passes any arguments along that were passed through to the calling method. So it deals with arguments anyways. That's how I thought about it.
The trick with regexes that it usually takes a couple of painful lessons (like the DoS mentioned in the article) to sink in is that you don't just want to match what you want, you also need to go out of your way to *not* match what you *don't* want.
I don't want to be a dick, but apparently you never took High School English class? http://www.grammar-monster.com/lessons/capital_letters_title_case.htm
No, we don't get that kind of English in Spanish high school. Then again, the lack of punctuation to separate multiple sentences is a bigger problem than the title case.
in linux you would get an error like that if the lib gtk headers are missing.. i don't know on windows. Ruby in any platform is more tested with a webserver and a web ui
If I, theoretically, would have the same problem as one would have on Linux, how do I go by fixing it? Thank you for responding.
Ruby and Windows tend not to play well TBH. Save yourself some frustration and run a virtual image (e.g. virtualbox) with Linux. To fix your problem would normally just require installing the gem e.g. gem install gtk2 But you'll also need gtk2 installed since the gem is just a set of bindings....on Linux again it would be done with: sudo apt get install gtk2 I'm sure google will suggest how to install it under Windows though.
Damn, if I had seen the tickets at Â£95 I would have jumped at this. Sad panda :(
On Linux I'd try to fix it with: sudo apt-get install libgtk-ruby but on Windows is different because gtk and ruby may be bundled differently. I think you should check the needed paths in your ENV variables
Did you install the gtk2 gem? Didn't get it to work out of the box under ruby 2.0.0, so I installed 1.9.3 instead and got it working there: * Installed rubyinstaller-1.9.3-p545.exe to C:\ruby193 * Installed DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe to C:\ruby193devkit * Installed ruby-gnome2-0.16.0-1-i386-mswin32.exe to c:\ruby193 * CD to C:\ruby193devkit and ran "ruby dk.rb init" * Checked that C:\ruby193devkit\config.yml included my ruby folder (- C:\ruby193) * Ran "ruby dk.rb install" * CD to \ruby193, ran "gem install gkt2" * Ran "ruby -e "require 'gtk2'" with no error messages. Edit: I forgot to write down one step, added it now, but also made one mistake - I used the wrong (2.0.0) devkit, and not the 1.9.3 specific DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe - probably better to use the correct one. Edit2: Got the calculator (http://assets.jaspr.net/files/calculator.zip) running :)
Exercises: go through the exercises in the ruby-kickstart repository. These cover most major aspects of the language in a way that actually makes you think. https://github.com/JoshCheek/ruby-kickstart Books: Eloquent Ruby (in the sidebar). The language docs are online and well-written. Start with the exercises, use the docs and in no time you will know your way around Ruby, for free. Nothing helped me learn it better than using it.
http://visualruby.net/site/Download.html
I have GTK running on my windows laptop. Where is the calculator script?
I'm about to dive in to Learn Ruby the Hard way. Can't vouch for it at all, so hopefully someone else can chime in.
Hi there, fellow Rubyist here. I speak from personal experience. When I started with Ruby, I had experience with C and C++, knew my way around Haskell but was trying to get into scripting. I tried the same as you, no basics, pretty much just syntax. However, it was very hard to find something like this. What I can tell is go with RubyMonk.com It starts with basic exercises but after the first basic courses, it really begins to push you into real Ruby stuff. You may feel the need to skip some exercises. Don't. I know learning about ifs and loops is boring, but they have to cover that to explain the diference between for(int i = 0; i &lt; ary_size; i++) do_something(ary[i]); and ary.each { | elem | elem.do_something } It really teaches you the Ruby Way. And far more importantly, it teaches you how it works. Also, I'd recommend going through _why's (poignant) Guide To Ruby. _why is one of the most important Rubyists and the legacy he left us is priceless. Read the book and I guarantee you'll laugh a lot and learn (even though you won't notice this). If you want to learn more advanced Ruby (I'd recommend only after RubyMonk), I'd go with Eloquent Ruby and then Metaprogramming Ruby. But these are a bit more advance, especially the second one. Besides RubyMonk there is also RubyKoans, however those are downloadable content and RubyMonk is in-browser, so you can learn on the go. I prefer RubyMonk for that reason, but RubyKoans are pretty awesome too! Have fun! Cheers.
Hey, I started using ruby as my main scripting language about a year ago and this is what I used to get started: [Programming Ruby](http://pragprog.com/book/ruby/programming-ruby) Often just called the pickaxe book, it is probably the most popular Ruby book out there but it is pretty big (~800 pages). Doesn't really have any projects/exercises but lots of little examples that covers the language. It's not really geared towards scripting though, so an alternative might be : [Scripting with Ruby](http://pragprog.com/book/bmsft/everyday-scripting-with-ruby). I haven't read it, but I have heard great things about it and it's about ~400 pages shorter. Also, as /u/obviousoctopus mentioned: https://github.com/JoshCheek/ruby-kickstart This repository is great for getting comfortable with the language, but I don't think they really highlight the advantages of using Ruby.
That's one additional line. Saving this line doesn't justify monkey patching core classes (or classes of other gems) at all.
For a while, rightly or not, saving that line was considered justified in the minds of gem authors, given the trade-off. The mindshare seems to be leaning toward your perspective in the last few years, however. When those two lines are required to be paired to be functional, one of them are just noise. It's saying "I'd like to use your functionality step one, I'd like to use your functionality step two". This is common in most small "feature" gems. Multiplied by n gems. This is not the aesthetic ideal. This isn't really a trade-off that has to happen. I'd really like to live in a world where include-with-params doesn't look so alien to my eyes for these simple, repetitive cases. It says "I want to include this functionality, with these options". When no configuration is required, it's just a regular `include`. And if you don't explicitly opt-in, there's no magic monkey-patching or fucking with the module list.
I managed to work it out with this, since it had the same calculator built in, pretty much. Thank you for helping me out, and thank you for your time.
Can't recommend this enough
as a c person, maybe you will find ruby under a microscope interesting, as it translates what is going on under the hood in MRI. http://shop.oreilly.com/product/9781593275273.do
You... uhh... don't really know what this subreddit is about.
I'm reading that book right now. Its a swell read if you want to get a good look at the internals of Ruby.
hey neato... a bot!
I'll second the Ruby Koans. I go through them every now and then to keep the basics sharp while I learn bigger and badder things. I'll also second everything by _why. It's . . . truly delightful. And not the "lol we use cheese shop examples to explain for loops! look, we're fun!" kind of delightful you might find elsewhere.
Are your conditionals using = or ==? 
Ruby has a lot of "kitchen sink" features like this; there are tons of utterly unnecessary features (methods, arguments, etc.). Some would even argue that it bloats the language a bit. It can be really useful in some cases and really annoying in other cases.
OP, your original question cited two versions of the pickaxe book. Did you intend instead for the second reference to be [Everyday Scripting with Ruby](http://pragprog.com/book/bmsft/everyday-scripting-with-ruby) by Brian Marick? We formed a Ruby discussion group at work. After a lot of deliberation we picked _The Well-Grounded Rubyist_ mentioned in the sidebar. It's a very carefully-written tutorial. It's also being rewritten as a 2nd edition. We all bought the 2nd edition's early-access version, which gives you a free PDF of the 1st edition while you wait. None of the five or six books we considered had exercises, though. Looking forward to checking out the Ruby Kickstart by Josh Cheek.
There is a ruby library out there called ZOOM that interfaces with Z39.50 servers: http://zoom.z3950.org/bind/ruby/
Hey - sorry! Talks for Day 1 will be available for free on our website - And we'll be opening registrations for next year on Friday at a similar rate. 
If he doesn't jump on this thread, I'd suggest PM to /u/jrochkind. He's an expert on libraries.
I prefer using the more verbose but understandable, expect(time_1).to be_within(1.second).of(time_2)
https://github.com/travisjeffery/timecop is a good solution for this.
Please let us know how your experience with the solution you chose goes. Was looking at both Mirah and Ruboto for sometime, but both doesn't seem to have an active community..
Honestly, skip the books entirely and just get http://rubykoans.com/ - I've never found a better way to learn a (second or third or fourth etc) programming language.
Agreed. Putting in a week's work on a usefully quirky hack == *awesome*sauce!
Good post, I agree with it entirely. It looks like you drew inspiration from some comments made by /u/blowmage in a [recent thread](http://www.reddit.com/r/ruby/comments/20c1k6/stubbing_with_minitestmock_seems_terrible_am_i/) here in /r/ruby: http://www.reddit.com/r/ruby/comments/20c1k6/stubbing_with_minitestmock_seems_terrible_am_i/cg1u97n and subsequently: http://www.reddit.com/r/ruby/comments/20c1k6/stubbing_with_minitestmock_seems_terrible_am_i/cg1vc1i
That doesn't work. If the first fires at 1395955158.999999 then the second is going to fire in the next integer. A lot of people use fixed times in tests to avoid this.
This seems fragile to me (just like the author's solution). Will your specs break if your app randomly takes longer than a second?
I'm looking for something similar - not so much a 'learn ruby' book as a more technical 'best practices' type of book - something more in line with [Effective Java](http://www.amazon.com/Effective-Java-2nd-Joshua-Bloch/dp/0321356683) or the [Effective C++](http://www.amazon.com/Effective-Specific-Improve-Programs-Designs/dp/0321334876) series.
Yep :-) I love the idea of syntactic vinegar and code smells. It's one of the things that turned me onto Rails in the first place, and the minitest/mock thread had a great real-world example. The 'stuff it in a test helper' part comes from when I first started using minitest/mock: https://github.com/justinweiss/dgs_push_server/blob/master/test/test_helper.rb#L60. It works, but it's clearly starting to get a little complicated. Glad you liked it! I've I wish I could find some other good examples of libraries with syntactic vinegar. I'd like to take better advantage of it in my day-to-day codebase.
Not really related to the content of this post, just a general design question: Why did you chose to put the `credit_cart` on the `Cart`*? And why is the cart responsible for buying things? This doesn't really fit with my mental model of what a cart is (it's a box full of shopping goods). Couldn't you keep the checkout process external? I think this would be less confusing and easier to test. \* My guess would be: form validations
can you show some benchmarks supporting that? from what i see in tenderlovemaking class_eval is always going to be slower, and it makes sense why.
i agree, though pry can have its issues when you are debugging within a loop. (hard to escape the binding without a server restart.) i've also seen it have some issues playing nice with jruby. :x
And, notably: &gt; As a Ruby benchmark, the Rails version is locked to 3.1.3 and the server is WEBrick. Don't worry about all the performance enhancements in 3.2, 4.0, and 4.1, or the non-performance of WEBrick. Nope. *Ruby's* performance is best benchmarked by a nearly-3-year-old version of Rails and an unusually slow web server.
I agree with fixed times and will update summary of article. Thx btw, the main thought of article is: ruby compares Time with fractions. Tests were one of the examples where it can cause some issues 