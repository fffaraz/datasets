Find a command you like that has interesting output. Write a wrapper to run the command and parse the output into a Ruby object. Make a polished gem out of it.
are you actually calling the method? How are you trying to broadcast it?
It was super odd. So in my channel, in the `subscribe`method, i put a bunch of logger statements in there to make sure i subscribed properly and i did (the puts statements were printed). I ended up shoving a `ActionCable.server.broadcast 'channelName', { somestuff: 1 }` into that method and it actually worked. I got a response on the client. However, when I put that exact code into a worker where it actually belongs, nothing happened. So I put some more logging trying to see if i even had a connection with `ActionCable.server.connections`. It actually returned an object when i put it into my channel method `subscribe`. However doing the exact same thing in a worker (sidekiq) , returned `[]`. In rails console it always returned `[]`. I dont know why. I remember in one of the actioncable files, one of the comments said `ActionCable.server.connections` might not work properly because you might have separate connections located in different places, so use `remote_connections`, however no luck with that either. Also this is development mode so i don't have various websocket servers. its kinda late, not sure if this made sense. 
I guess I'd have to see the channel. In the subscribe method it's only going to do something on 'arrival' or when you've subscribed. You should be calling another method that should also be in your channel that you can call app.room.speak or whatever the method is called. When you generated the channel you should have created a way to broadcast similar to giving columns to a model. If not you can just make your own. I spent a few weeks studying how action cable works but it's hard when i dont see the code
It looks like the site has an api: Is this the content you need? https://eha2016.my.conferences.cc/api/data/preview/84/56a108a95bcb43101639f2cc/search/oncology 
[removed]
Google for on delete cascade
If you make the assumption the developer doesn't know what they're doing then there's an infinite number of terrible things that can happen, an errant `dependent: :destroy`would be the least of their worries.
File.dirname(fname).split(File::SEPARATOR).last
Its great news! The biggest risk for a developer going into this project is making sure all the data is available and consistent.
Huh? it just means "the name of the current method" it's plenty clear enough. Do you avoid using `__FILE__` and just type out the name of the current file too? :) Using `__method__` also means you don't have to update that piece of code if you ever rename the method.
*ECMA
That's hardly a sensible comparison. `rm -rf /` is blatantly very dangerous, to anyone who's worked on a unix system before. Writing `dependant: destroy`, on the other hand, is only "obviously" dangerous if you're familiar with the framework. I consider it an erroneous assumption that all "competent" developers should immediately realise the danger. My co-workers are far from incompetent, but none of them *really* know much about the Ruby language/Rails framework. (No one else really touches the Ruby systems; most of our code-bases are in PHP.) If I go on holiday and they desperately need to change something simple, then someone could easily mess something up such as a misplaced `dependant: destroy`. Unless, of course, there's clear 1-line **warning** message clearly displayed somewhere; then, they have much less of an excuse. I strongly favour over-documentation, rather than under-documentation. For example, some of my co-workers are recent graduates. So of course I do need to "point out stuff like that" - and not in a condescending way.
&gt; https://eha2016.my.conferences.cc/api/data/preview/84/56a108a95bcb43101639f2cc/search/oncology That's the kind of post which deserves an up vote :)
since the Trailblazer framework basically goes off the Rails so to speak, I'm guessing there is some documents there explaining these choices?
My favorite Ruby-heavy Rails textbook is "Ruby for Rails" by David Black. It's old (nearly 10 years in fact, I can't believe it!) but really, really good. It shows how Ruby's specific features - particularly metaprogramming - are used to implement the core Rails features that we know and love. Don't sweat that it shows (a way) older version of Rails. The main ideas and implementation techniques in Rails haven't changed that much, believe it or not. And the point the book makes is how Ruby as a language is particularly well suited to produce something like Rails.
right right. on subscribe, i specifically printed out `ActionCable.server.connections` and it gave me a legit connection. I was calling another method `stream_from`. everything was fine inside of that method. however, calling broadcast from anywhere else in the app caused it to do absolutely squat. i'm fairly certain i was doing everything right. the only difference being was that i wasn't using the actioncable's built in client code, and was making regular vanilla websocket calls in the frontend. i think that might have had something to do with it. 
She has 10 talks on confreaks, maybe you should watch them if you seriously want to understand why she got an award.
Different website, unfortunately! otherwise I'd be there in a heartbeat. It looks from this thread though that the situation is not as dire as it could be-- there's some behind-the-scenes code that will be easier to pull out the information we need
This has just made my life 2,000,000x easier
oh PS, how did you figure out it has an api? I can see elements of that URL if you just open the frame after an oncology search: https://eha2016.my.conferences.cc/program/56a108a95bcb43101639f2cc#/detail/56b1f97d5b91b1a631a08063 and if I view source, I can see the number 84 in there... or are you just a wizard?
&gt; A programming community is made of people. She's working to make the community, the sum of all people, She was never a part of the community until she saw an open door spout her agenda. She literally registered her account at the members forum just to start a debacle.
Can you share the one?
Ignoring the speaker's identity, talks are accepted based on the abstract, so the decision to accept or reject isn't really based on the quality of the talk to begin with. I went to RubyConf in San Antonio last year and some of my favorite talks were given by women. I'm sorry to hear things aren't going as well in Argentina.
Coraline is a mentally ill man who contributes nothing but poison. Ruby and Rails is dying - formerly great ecosystem now led by communists who only care about gender politics.
Here's a technical one I like: http://confreaks.tv/videos/mwrc2015-data-driven-refactoring
Why are you referring to a woman with "man"? About Ruby and Rails dying, it's equally great to interact with the Ruby community before Coraline's contributions and after. But I'm pretty sure that for some women and transgender people it improved.
Anyone who signs on for this project on a FFP (Firm Fixed Price) rather than T&amp;M (Time and Materials) will be by definition an idiot. Do you want to hire an idiot? Because this is how you hire idiots. 1. You don't have any formal requirements and can't even give access to the site. They would be promising to do something that could take unbounded time for a bounded price. 2. You have no experience working with software contractors which means you likely will be a nightmare to work with... all new clients are, it isn't your fault. New clients do stuff like ask for FFP, and say silly things like "my friend said it would take a few hours" -- by the way, both of those things are "fire the client" things among even semi-decent contractors. 3. You are planning a "rushed" project with a hard deadline for an external client. Likely this project will be a spectacular failure and in rage and anger you will withhold payment and the contractor will sue you -- more fun will ensue. **Most** software projects are late. This is **not** where you want to start using software contractors, this is a fustercluck of a project **by your design**. I have been a contractor for 20+ years -- and I specifically have worked in the scrapping / OCR space on multiple projects, I would not touch this horrific project regardless of budget unless it was paid in advance, because its chance of failure is super-high. If you want to work on a project on an insane hard deadline with no wiggle -- you need to hire freaking top-tier experts and brace yourself for failure.
Because the person is a man. Did you not do your research? He is a man-to-woman monstrosity
Go fuck yourself. 
I don't have time for bigots. Mentally sick with multiple personality disorder? Come on, that's so 1960. Come up with a better justification for your bigotry, please. It's tired.
There is a big difference between being part of the Ruby community and having an account on bugs.ruby-lang.org.
I don't care what she/he/it is. I just care about Ruby.
Then this discussion is not for you - we're debating why he deserves a ruby award because he has contributed nothing but poison
Literally a red-pill neo-nazi. Move along, folks.
Guess you can't dispute my facts - just resort to name calling. Anti-fact commisars are killing Ruby.
also deprecated.
*reads edit* We have answered your question, we can't fix all your opinions and biases that prevent you from understanding the answer. If you really want to understand you have a lot of reading and introspection ahead of you.
I agree Rails intends to do exactly this, but it is always nice to notify developers about the change (As everyone might not think it through no matter how competent one is).
Was upgrading libv8 and just happened to see this issue: https://github.com/cowboyd/libv8/issues/213#issuecomment-216717296
for what purpose though?
I think the frequency and payment_day is the important bits.
Yesssssssssss we have been doing server side rendering and have been hitting some weak ref issues thank you so much!
This smells like fighting technical debt with a payday loan.
Don't worry, transgender people are still pretty much unaccepted. It's just amazing to me how you think that a man would dress up like a woman for the fun of it. The judgement around is horrible, which proves that they only do it because they absolutely need to.
&gt; how many Ruby devs know what it means? If they don't know what it means they can ask or look it up and guess what -- they'll have learned something, and a useful feature at that! You shouldn't code to the lowest common denominator, you should use the best possible code to solve a certain problem. If people don't know what it means, they can learn it, and most of them will be grateful. If you are going to argue that `__method__` is somehow cryptic or complicated, you are wrong in my opinion, it's no more cryptic or magic than `__FILE__` or `__dir__` or double splats, or `yield`. Arguing that we should avoid a feature just because joe average coder doesn't know it yet, is silly, joe average coder only becomes joe-better-than-average-coder by encountering unfamiliar things and then, guess what, learning about them so they're not unfamiliar anymore. Also, there are some situations where you **have** to use `__method__` as nothing else will provide you that sort of introspection. 
Well the example in the use-cae already makes use of activerecord callbacks to send a notification after a save. Since I think this is already an anti-pattern (Which has been documented all over the net regarding sending notifications during testing, tool use etc. and is mentioned in this blog) I don't think the arguments hold up. "Use this feature to work-around a bad design in the first place" is not really compelling for me. Get rid of the callback and you do not have the issue in the first place.
&gt; Don't worry, transgender people are still pretty much unaccepted. Thank god. Don't care what Corey does behind closed doors - actually have sympathy for his distress. But those who promote sickness, who proselytize for degeneracy, who crybully - I do not accept. 
+ confident ruby
Yeah, that could happen, but some beginner making a todo list or blog won't be hurting too bad if their database gets deleted. It's not like you'd be able to build a complex site and run it in production and actually get users, and have not noticed anything wrong the whole time.
As much as I wish the mods would delete this circle jerk, and as much as I rolled my eyes during the Opal scandal, if Coraline is the same Coraline from IRC she is very responsive and very generous with her knowledge and advice.
It needs no *externally visible* state. It may be convenient to have internal state that "lives" just for the duration of a single call, simply to avoid passing the same arguments from method to method to method (which will get you called out by RuboCop and/or Reek). Check out Tim Riley's [*Functional command objects in Ruby*](http://icelab.com.au/articles/functional-command-objects-in-ruby/) blog post for a similar take.
You're a decent individual. You've argued your case without resorting to name-calling unlike the other animals in this thread. I acknowledge your point.
Moved from Rails to Golang + React a few years back. Not so "batteries included" but ultra performant and very straight forward. I no longer feel like I'm fighting the framework.
I do. I think that Rails is very good at what it does and after all these years there's pretty much no way you can improve it. Some of the stuff they add seems really unnecessary, like ActiveJob. Some stuff looks like it will never take off like ActionCable. 
Both. When an object doesn't need state, don't use an object, just expose a module or class method instead.
The pattern we use is a bit different. "Service" objects or as I call them "functional objects" have function semantics, we don't set data-as-state on these objects, instead we may only inject dependencies and/or configuration. Data is always encapsulated by separate objects, and we don't have much logic there, one rule of thumb is that objects encapsulating data never-ever have side-effects, that's why we make a clear separation between objects carrying state and "command" objects that may have side-effects (in terms of external systems, like a database etc.) and they never-ever mutate their inputs or change their internal state because there's no need for that.
And here I was, hoping to find an article that tells us how Rails is finally getting rid of the ActiveRecord nonsense altogether...
"We have a serious arch design issue with AR, its interface is too big and causes issues" "Oh I know, let's add another method" ActiveRecord is over folks. Stop using it if you still can. Look at alternatives. There's nothing that can be done to save this library other than a complete rewrite with huge backward incompatible changes (like removing 80% of its interface), which will not happen for legacy reasons. You're down the rabbit hole the moment you start using this library. As I'm working on rom-rb and in general I'm no longer interested in using or working on ORMs, I'm obviously biased as hell, and I know that lots of people will think what I'm saying makes no sense but at least try to think about it for a second with an open mind. It's *alarming* that we've been discussing serious issues with ActiveRecord since ~2010 and this library is still THE Ruby ORM despite all the criticism and frustration. For me this has been a sad proof that Rails isn't going anywhere in terms of improving their architecture. The fact this absolutely ridiculous method was added is alarming. Who's making these decisions? Global, mutable configuration suppressing some local behavior? Seriously? That's how things are done in Rails in 2016?
The problem with doing so is that lots of people don't have enough experience to pick up the pieces they need and provide their own abstractions on top. That's why frameworks are so popular - the cost of "getting started" is very low. Our problem, specifically in the ruby world, is that apart from Rails there's no strong competitor that would provide similar initial experience as Rails so that less experienced devs can benefit. Hanami is getting there so there's hope, but it's a ridiculous amount of work and it needs help from many people. That's why I'm encouraging people to look around and see that there's a world outside of Rails and a lot is happening right now, so jump on board and help if you care about Ruby's future and you no longer like working with Rails.
C.A.E. is one of the hosts for Ruby Rogues, has given presentations at conferences, and has been good at keeping to whatever topic is on hand and hasn't pushed any views outside of the appropriate conversations context. In other words C.A.E. has presented oneself as a decent individual and been a more positive contributor to community. Regardless of views there are many who have fears and aren't bold enough to be publicly active. So I can easily see that as a hero figure for such people.
If you want to run a Rails project without ActiveRecord, it's not too difficult to switch to another ORM - e.g. [`Sequel`](https://github.com/jeremyevans/sequel)
And because these random things are part of the main framework, beginners think they should be used for everything. A couple of days ago, I was asked how to repeat an ActiveJob task every second. After a few specific questions, it turned out the person wanted to automatically update content on a page every second, and somehow thought ActiveJob was necessary for that. It's getting to be pretty bad.
&gt; I'd argue that many did it not to be seen as old bigots. Does it promote better code? I don't think so. What about promoting better people?
spot on :)
Hi, Gemnasium founder here. There was no change in the prices, the plans are still available for the exact same amount. I bet you haven't at least click on the link to read the article. A while ago, we introduced the notion of "slots" to allow users to access some of the extra features (autoupdate, reports, etc.). These slots were used also to add private projects. It was confusing for our users, so we decided to remove them. So before this change, one could use the 2 slots included in the free plan to add either private projects or extended features. That's what we removed. The new pricing is simplified because Free plans gets all for free, as soon as it's opensource, and now with unlimited collaborators. To add private projects, you now need a paid plan. Simple as that.
Thanks for the answer. That's what I wanted to know.
Yeah, this is a terrible feature. I'm imagining debugging code that isn't saving something I expect, when the answer is a `suppress` that occurred 10 levels up in the callstack. Spooky action at a distance. 
His third point really shocked me.
 /r/machinelearning rubyists will be pleased
Also note that therubyracer is not thread-safe. Use it in a multithreaded system like Sidekiq and it can lock up your entire process so you have to `kill -9` the entire thing. I hope mini_racer is better in this regard.
Zero is not a placeholder, it's zero. Think of it in terms of how many apples you have - you can have 42 apples, 0 apples, or an unknown quantity of apples. Nil represents a currently unknown value. If you're counting things, start with zero. Otherwise you should probably be using nil.
I think I'd need a bit more specifics about the two kinds of problems you're trying to solve. As such, I can only give you fairly general advice. Any in-scope variable is initialized to `nil`before a value is set, so you should rarely have to manually set something to `nil` (One case I can think of is unsetting a value). In terms of placeholders, the example I can think of needing to set a placeholder of 0 is before doing a calculation: &gt; sum = 0 &gt; [1,2,3].each { |num| sum += num } but I'd probably do something more like &gt; (1..3).inject(0, :+)
Oh my yes
&gt; Last year we did it by hand (literally copy and pasting from the website to Excel) and billed over 200 hours to do it. Lol you dramatically overcharged someone just because you're incompetent and lack the technical skills to do it in an intelligent way? 
I liked your piece of code until you started to argue that you shouldn't use `__method__`.. I had to reread the code to understand that you were calling enum_for on the current method, where it would be perfectly clear if you would have used `__method__`...
Also after running your tests you could open rails console and run Dictum.document or Dictum.save_to_file If that doesn't work let me know
Nah, man, I said upthread that we ate the cost. There was a severe misunderstanding of the scope of the work all around. My company is filled with very smart people, but we're all writers. To put it in perspective, I'm the most technologically proficient person in the office and you can see from this thread that I hardly know shit. The awful thing is we had this task again a few months ago, when I was on maternity leave, and we STILL did it the same way. It has taken way too much convincing from me to the bosses that we should either have a computer person permanently on staff, or at least build a rolodex of reputable coders. Drives me crazy. Anyway have a great day!
&gt; `nil` is the value defined as "no value at all". So really only nil is a "placeholder for a variable until you give it a value later" The term "placeholder for a variable" does not really make sense. There are no placeholders for variables. There are just values variables refer to. &gt; -- really it's not even a placeholder, it's just "no value", it's the thing that represents no value at all. I guess you could call it a 'placeholder', okay. What you say fits Java's `null`. Ruby's `nil` has actually a bunch of methods that can be invoked on it without producing something like Java's `NullPointerException`. `nil` just happens to be the default value on various situations, e.g. instance variables that have not been assigned to, empty Array and Hash elements etc. It is very convenient. :-)
Then you should object to this award.
Assuming you're using Rails 4: http://theflyingdeveloper.com/controller-specific-assets-with-rails-4/ The google term you're looking for is `controller specific rails assets` if you want to dive deeper.
It bundles it together so with one request you get all the JS for the site. It doesn't load all of it each time. It isn't worth it to try to make it work differently.
In `app/assets/javascripts` I'll have both an `application.js` file and an `application/` directory which contains my custom *.js files and a `z.init.js` file that sets everything up. I treat my `application.js` as a dependency manifest and use `require_tree ./application` at the bottom. # application.js //= require jquery //= require jquery_ujs //= require bootstrap-sprockets //= require_tree ./application # contents of application directory app/assets/javascripts/application ├── featureOne.js ├── featureTwo.js ├── featureThree.js └── z.init.js 
So Rails asset pipeline is intentionally designed with the assumption that all of your JS _does_ get included in one big JS file, included in the layout on every page, as you notice. This is actually intentional, the architecture isn't really designed to support what you're trying to do -- put controller or view-specific JS into separate files included on each page. (_yes_ it's flexible enough that you _can_ do it, but it's not the easy path that Rails guides, tutorials, plugin installation instructions, etc., will assume you are doing). The thinking is (or was, when it was designed) that it's better for the user to download all the JS once, on the first request, and then cache it. It won't have to be downloaded again during that session, or until the browser cache expires or is purged -- it's in the browser cache. In almost any user session, their browser will download the big aggregated file once, and never have to download it again. And the thinking is this is is ultimately better for browser performance than having to download different JS files on every page -- because the latency in requesting another file over HTTP(S) is expensive and effects actual browser experience significantly, even for small files. Some people have challenged this design goal, especially as aggregated JS files have gotten truly enormous with large JS front-end frameworks. And HTTP 2.0 is designed to make the aggregation entirely unneccesary -- it's still not entirely clear how the Rails asset pipeline will end up playing in an HTTP 2.0 world. So. You _can_ do what you are asking. But for your "first time", unless you really have a reason to be _sure_ it'll give your users increased performance and you need that performance -- I wouldn't. You'd have to be kind of inventing some architecture, without the experience to know how to do it maintainably, and dealing with edge cases in Rails etc. I'd stick to the use case the Rails asset pipeline was designed for, and let it aggregate all your JS into one big file. And worry about other things. For instance, when it comes to assets, you probably _do_ want to make sure that your JS assets are being served (from wherever they are served from however you are deploying) with appropriate cache headers, and gzip'd. You can learn more about the Rails asset pipeline here: http://guides.rubyonrails.org/asset_pipeline.html
Layout of the app (example): &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; ... &lt;%= content_for :stylesheets %&gt; &lt;/head&gt; &lt;body&gt; ... &lt;main&gt; &lt;%= yield %&gt; &lt;/main&gt; &lt;%= content_for :javascripts %&gt; &lt;/body&gt; &lt;/html&gt; Then, a typical page begins like so: &lt;% content_for :stylesheets do %&gt; &lt;%= stylesheet_link_tag 'pages/homepage', media: 'all' %&gt; &lt;% end %&gt; &lt;% content_for :javascripts do %&gt; &lt;%= javascript_include_tag 'pages/homepage' %&gt; &lt;% end %&gt; &lt;div class="... This way you have a unique CSS and/or JS on a per page basis. This approach is quite flexible, and there is no global JS or CSS: they are tailored for a given page. To make it work with the asset pipeline, you will probably want to have something like this in `config/initializers/assets.rb`: Rails.application.config.assets.precompile += %w( *.js *.css ) This has worked pretty well in my 2 previous jobs with a team of developers. The tiny bit of overhead is worth it. If you are doing a quick one-off tiny website as a hobby, you probably don't want this overhead and I would stick with Rails' defaults i.e. having globally shared JS+CSS files.
THANK YOU THANK YOU this is exactly the answer to the question!
In rails 4 you need to adjust your thinking a bit. Turbolinks is enabled by default and the js is requested only for the first page of your site. For all subsequent page loads, only the body for that page is loaded sans any css, js, etc requests. $(document).ready won't work as per usual. You should look at jQuery.turbolinks and related docs on how to configure on('page:load'). You could write some code that adds a specific class to the body tag based in the current controller and action e.g. class="#{controller.controller_name.downcase}# $(controller.action_name)" Then you can maintain separate js files which all check the body class before executing their respective code, handlers, etc. There are plenty of other approaches, this is just one I thought up before falling asleep. 
Most useful is that nil.to_f gives zero. Super useful when digging into hashes like foo.try(:[], :price).to_f 
``` 0 || 1 # =&gt; 0 ``` ```nil || 1 # =&gt; 1 ```
Ahhhh, cool. I dig your meta-programming solution. 
I've opened a pull request on the Rails Style Guide to discourage the use of this feature: https://github.com/bbatsov/rails-style-guide/pull/180
Be sure to tell us how it turns out. I don't see anything genius about this, and I'm curious about what the advertiser wants.
Yes, it's ActiveCoupling, boundaries are blurred, http concerns are constantly leaking into app's domain, "rails is your application" at the end of the day, and that's one of the reasons why complexity grows exponentially in rails apps. Glad to hear you're giving dry-* gems a try. They are unstable so yeah, things are changing, but we're deprecating things rather than breaking APIs, so it's not *that* unstable :) Hanami and Trailblazer are adopting dry-validation (and Reform dry-types too), so we have a really nice ecosystem growing. As far as rom-rb goes, we're gonna have a huge release in June, with rom-repository supporting commands, which means that you'll be able to use rom-rb to quickly build CRUD functionality as persisting data can be as simple as `user_repo.create(name: "Jane")`. This should help with the adoption, as defining commands manually has been a PITA for many people :)
Not sure why you're being downvoted, you're absolutely correct.
The given answers so far are wrong. They're rehashing the bytes of the hex representation of the digest, not the digest itself, and they aren't continually updating the digest; they're performing a new digest per round. require 'digest/sha2' digest = Digest::SHA256.new digest.update "hello" 999.times { digest.update digest.digest } digest.hexdigest Or if you want a one-liner: 1000.times.reduce([Digest::SHA256.new, "hello"]) {|(d, s)| d.update(s || d.digest) }.hexdigest # =&gt; "b470914ae6184936c079b4e3c080111a99dfefa8aa2ffca0d7592989b1b9bd4c" By comparison, the result from the currently-top answer: 1000.times.reduce("hello"){|r| Digest::SHA256.hexdigest r} # =&gt; "9c9dae0965814a30aa242290e32e74e0e6f0058b8a8498d35535ef65b0f45cb5"
Reads like they want cheap/free labour :/
&gt;Separate conduct from "speech and thought", and you've dehumanised the conduct. Separate speech and thought from conduct and you have embraced reality and committed to facing the facts. &gt;Your point says more about your fears and your own internal programming than about any defensible principle. Your point is so typical of SJWs whose primary weapon is to attack everybody for wrongspeak and wrongthought by redefining words. To you guys everything is rape and everything is violence. The simple act of disagreeing with you guys causes you to lash out with accusations of rape and violence. You are a prime example of why all sane and rational human beings must fight the SJW ideology with every ounce of energy we can muster. Your side stands on the side of censorship and thought policing. 
That seems wrong also, digest.update adds a new chunk to the existing hash calculation, so it's now a digest of `"#{originalstring}#{hash_of_original_string}"` and then becomes a digest of `"#{original}#{hash_of_original}#{hash_of_original_and_hash_of_original}"` and so on
Coraline is very hateful and bigoted against white people and cishet males. 
What's wrong with functions? A function by nature is simpler than a class, and in many cases will make your come easier to test, reason about an maintain.
 floats is bad practice in the database for things like prices, but casting big decimals to floats to use in views is not dangerous if properly formatted with something like a money helper. I guess this is possible: my_hash.fetch(:price, Hash.new).fetch(:whatever, 0), but then creating hash objects for the sole reason of them being able to respond to fetch. Seems kinda messy IMO. Also, if my_hash doesn't respond to fetch, the bad data crashes my code rather than giving me a zero as it does with try. Depending on the criticality of what you are doing, crashing might be preferable, but most of the things I use deep hashes for in rails are things I don't want crashing the main functionality - like metadata associated with a model and things like change notes. I program defensively on these types of things because they are nice to have but not important enough to prevent loading of a view if they get some bad data somewhere.
See the `ffi` gem, and directly aftwards, the `ffi-libc` gem.
I am really curious whether one could rewrite parts of MRI in plain Rust or Go (sans it's runtime dependencies of course). Starting with C extensions are a good place to test this out. C is not a particularly safe language (memory mapped, implicit type conversion, etc), so writing native extensions in anything besides C is a bonus.
If MRI is sufficiently modular with well-defined interfaces between modules (i.e. doesn't lean on mutable global state), then it would be possible to incrementally port bits to Rust with minimal disruption. This is what Firefox is doing, though it requires to project to adopt a new dependency and integrate a second compiler into its build system, which is too much to swallow for some.
I'd be very interested in hearing more about this topic from you if you'd care to share. Or if you have a link or three that explain or demonstrate using data objects and commands objects in Ruby. I've been following what you're doing with dry-rb but seeing an example would really help me understand your comment on using a different pattern. Thanks in advance.
I actually have a branch of MRI where I've taken the first steps towards implementing Array in Rust, for fun. It's to the point where I have all the signatures defined, so it compiles, but then crashes since they're not implemented. It's been a long-term "I should do this it sounds fun" project of mine.
This is amazing. I presume, we'll see a lot of speed improvements of the Rails core APIs during the foreseeable future.
That open source somewhere? Could be interesting and fun to hack on :)
I assume you're using Rails or at least ActiveSupport given the description of the behavior. `to_json` from the `JSON` module in stdlib acts differently. The ActiveSupport implementation is here: https://github.com/rails/rails/blob/87c2c070c4cf1b62ac364c53496a2da000fbf9d6/activesupport/lib/active_support/core_ext/object/json.rb#L48 
The advantage is nil becomes zero and big decimal doesn't change to something unexpected. Certainly possible to do the nil check in the helper though, but then you need the same nil checking in each type of helper- percent, money etc. If the helper takes a float, the nil -&gt; zero coersion is just part of how the hash is displayed 
Yeah, so that's kind of what I'm doing, but since I couldn't figure out the makefile stuff, I had committed the generated one and added in the rust rule. I said it was hacky! 
&gt; each You can just use `#to_enum` and also just pass the block to `#each`, i.e. class Collection def initialize(items) @items = items end def each(&amp;block) return to_enum unless block_given? items.each(&amp;block) end private attr_reader :items end
While I really like that you can do this with rust and I'm really excited about rust for ruby extensions and so on, I'd even more love to see some rails'ish stuff implemented in rust itself. I know there is diesel and iron, but we are not web yet, are we? *smile*
Go check out either of Russ Olsen's excellent books on the subject. Both "Design Patterns in Ruby" and "Eloquent Ruby" should get you what you're looking for.
How about [Ruby Deep Dive](https://blackbytes.info/ruby-course/)? It has a whole chapter dedicated to explain how Ruby works &amp; why it works that way. The rest of the book explains other important features that make Ruby what it's is, like metaprogramming, the Enumerable module, Procs &amp; lambdas... (Note: I wrote it, so if you have any questions I will be happy to answer them.)
[Seven Languages in Seven Weeks](https://books.google.com.ar/books/about/Seven_Languages_in_Seven_Weeks.html?id=zCP9RAAACAAJ&amp;redir_esc=y&amp;hl=en) is a book that starts every language from simple syntax but quickly dives into what makes them special, what principles they were built on, and even has some interviews with the creators about their design choices and such. One of the covered languages is Ruby, so you might want to check that one out!
Maybe try to contribute to a Ruby implementation? I learned Ruby by implementing it. Some of the features in Ruby make more sense when you look at how they are implemented.
If you want to learn Ruby the real hard way; step 1, download Ruby source and compile manually. Step 2, reimplement rails in all C extensions. Step 3..., and step 4 profit? Or, I like what one of the others said, just help commit to an open source implementation of Ruby like jruby, or rubinius or even Crystal (Ruby ish language). 
yup.
Would you be willing to go over what each of these points mean exactly?
&gt; I like to learn programming languages by understanding what is the core idea of the language. Ruby: object-oriented with macroless metaprogramming I found [The Pragmatic Bookshelf's *Metaprogramming Ruby*](https://pragprog.com/book/ppmetr/metaprogramming-ruby) to be invaluable here. By understanding the metaprogramming techniques in Ruby, you can get a much better idea of what makes Ruby tick, which seems to be what you're going for.
Hint; this call is expecting a Hash Movie.new( title = self.title, hotness = self.hotness, image_url = self.image_url, synopsis = self.synopsis, rating = self.rating, genre = self.genre, director = self.director, release_date = self.release_date, runtime = self.runtime ) 
Ruby is a strongly OO language with extreme access for meta programming. If you really understand OO and find Ruby syntax easy then focus on metaprogramming topics because that is where the most interesting parts of Ruby are though please learn not to abuse it...a lot of good projects go from good to WTF when people do. 
But your thoughts and speech *are* wrong.
[removed]
Ruby is Smalltalk that wants everything to be an Iterable. I have saved you thousands of hours and dollars. You may now gild me.
&gt; Rapel (ruh-PELL) Uh, no it's not pronounced that way.
&gt; what is the core idea of the language From the coding point of view, I'd say it's: 1. everything is an object 2. everything is mutable (freedom!! - at your own peril) 3. elegant, concise syntax &gt; I would like to learn Ruby the really hard way. Read the Ruby source code
Matz had a ton of reasons for making it. This page ["about ruby"](https://www.ruby-lang.org/en/about/) is a pretty good overview. Personally, it feels less boxed in than other languages I use.
Here is an idea. Write a Clojure application every night. Don't miss even one day. For a whole year. This I think, is probably the hardest way to learn Ruby. 
For now I'd suggest following the blog series from Tim where he's explaining how we're using dry-rb/rom-rb gems. It starts [right here](http://icelab.com.au/articles/my-past-and-future-ruby/). You can also sign up for my [upcoming book](https://leanpub.com/web-development-with-rom-and-roda) which I will open pretty early once some chapters are ready.
I'm reading Eloquent Ruby at the moment
i like checking gitter.im rooms of up and coming gems or projects. there's more cutting edge buzz going on in there.
Where I find most rubyists online: * Twitter * FreeNode IRC #Ruby * MetaRuby.com * Blog posts (most relevant interactions) and aggregators * Ruby issue tracker &amp; Github * Facebook group (mostly newbies or not-so-frequent devs) * Oh, and many hang out on Elixir, Elm, and Rust forums too I recommend checking out the aggregate feeds as they are always showing the latest in Ruby * RubyFlow * GreenRuby * RubyWeekly
freenode is so fucking awful nowadays. so much sjw-ism in there, can hardly stand it
What is Smalltalk then?
thanks nazi mods 
A little tangent from the subject, but are there any (largish) opensource projects currently using hanami, particularly for api usage? I'd like to see the structure of a working project. Are there microbenchmarks comparing hanami with rails, sinatra, etc? 
Good.
Yeah, apart from Reddit I agree that the most relevant interactions are from aggregated blog posts. RubyWeekly (which aggregates RubyFlow) is the go-to resource in that matter. Also, http://afreshcup.com 's "Double Shot" posts are pretty good and have been going every day or couple days since 2007 (!). 
_Worse_ than a weak user and password? I don't know. One thing that makes it bad is that since the API key is stored in the database, if anyone gets access to the db they get the API keys. Also, if anyone can sniff the API keys in transit, they get the API key. Having the API key gives you access to the same things as it's authorized owner has. For the "right" way to do API keys you can look at what AWS does, involving a public and private key, and some HMAC authentication and timestamping. You have a private key which I think isn't even stored on AWS servers (but then, the 'forgotten password need to regenerate my key' problem is back), and you cryptographically authenticate your requests in transit, such that even if someone sniffs the traffic in transit and sees exactly what you sent -- they don't have a key they can re-use to do other things, and they can't even replay your same request a few minutes later. I don't know if anyone has produced a rails plugin to make AWS-style API keys. I haven't seen one, but haven't looked very hard. It would be a pretty interesting and useful project to do. Ah, but this still does require someone having an account with an ordinary login, so they can generate an API key. You don't want them to have an account at all. And you want the "api keys" to be shared amongst users who have access to the same invite-only forums? I mean, yeah, there are all sorts of things that could go wrong there. Try thinking through them yourself, that's how security is done. Also, on the idea of "the topic is a random id string so you can't really guess it" -- as soon as a URL to a topic ends up on Google once, which is surprisingly easy to happen, so much for that. 
Be a developer first and rubyist second. Ruby should not be used for tasks for which it is not suited. Also I'm pretty sure this guy mixed up grep and grok.
#caboose
Argon2's very new, as evidenced by its recent breaking change due to an attack on it. I'd give it a couple more years to mature, personally. I use, in order of preference: scrypt, bcrypt, and PBKDF2. Which, funnily enough, matches Thomas H. Ptacek's [(Updated) Cryptographic Right Answers](https://gist.github.com/tqbf/be58d2d39690c3b366ad). scrypt is mature, both CPU and memory-hard, and quite well supported these days. You have two options with Ruby - [rbnacl](https://github.com/cryptosphere/rbnacl) and [scrypt](https://github.com/pbhogan/scrypt). bcrypt is more mature, but has some silly limitations (72 byte hard limit, 55 byte soft limit, not null-byte safe), and is considerably weaker. I don't see much reason to use it in new apps. PBKDF2 is similarly mature, FIPS compliant, and [available in the Ruby standard library](http://ruby-doc.org/stdlib-2.0.0/libdoc/openssl/rdoc/OpenSSL/PKCS5.html), but is the weakest of the three. Only use it if you have to.
just use bcrypt, like the article recommends. Yes it says that argon2 is better if your platform has support for it. It also says bcrypt is just fine too, and supported everywhere, if you need compatibility between languages. Just use bcrypt. I don't know why you're going to believe us on reddit more than you believe that article, but, yes, that article represents my understanding based on lots of other articles. Do what it says. Which includes bcrypt, which is very easy to use in ruby, as well as some other options if you want to try to use them in ruby. It's unclear what 'the best' way is, but there are acceptable ways and unacceptable ways. The article lists the acceptable ways quite clearly. bcrypt is the most well-supported in ruby (and many other languages) of the acceptable ways. That's how you replace your functionality. With bcrypt. Or one of the other methods listed in the article. Sure, scrypt might be better, as the article says, you can use that too. It's a fine article. 
Thanks for the answer and your time!
`has_secure_password` looks predictably buggy, helpfully illustrating BCrypt's limitations: * Password must be present on creation Bypassed by prefixing the password with a null byte, which bcrypt silently truncates. I see nothing checking for that. * Password length should be less than or equal to 72 characters 72 *bytes*. Bcrypt knows nothing of your newfangled variable-width encodings, it only knows `char *`. LengthValidator only calls `#length`, which returns number of codepoints - you need `#bytesize`. I'd suggest `hexdigest`ing the password to avoid both of these, but it's probably a bit late for that.
Just use bcrypt.
Since you're making a single-page site, meaning that you're building an API, you cannot use Devise because it doesn't have support for authentication and account management in terms of JSON APIs (\cc /u/jemminger /u/bftcs). Luckily, [Rodauth](https://github.com/jeremyevans/rodauth) has support for JSON APIs. I would really recommend using it since it will take care of all the difficult stuff for you, leaving you only with minimum decisions (mostly just choice of features that you want).
i take it then that those who contribute nothing must spend time dangling their jimmies in /r/mensrights?
&gt; In this case it feels just as secure to generate a random key for each user on each forum topic and attach a permission to it. Sure it won't win a prize, but I keep wondering how much worse than a weak user and password it is. What do you guys think? How stupid is this idea? :) So all I need to do is get that key from someone, and I will have access to their account ? Be very careful with this :) it is in their browser history as a token in a url, or a cookie or something. 
Say this is Angular, then Angular is serving pages via HTML templates, which can be plain old ERB/Haml etc, you can then use Devise just to handle authentication. There is no duplication of logic, as it is just HTML at the end of the day. 
I'm not a fan of that syntax. I think Avdi did a pretty good job summarizing why, too: http://devblog.avdi.org/2016/04/21/some-quick-thoughts-on-input-validation/
Start building things. Doesn't really matter what. Stay away from rails for now if you can. Learn how to build some command line tools or scripts that do interesting things. Do your best to get a really good foundation of Ruby as a language, as well as some more widely applicable programming concepts. It really helps to have things to show people, so just build lots of little things. Also, once you understand basic concepts and are ready to start showing potential employers what you have made, take a look at https://github.com/bbatsov/rubocop and clean up your code to community standards, that can go a long way. Feel free to PM if you want some more personalised advice, and best of luck :)
I'm self-taught, but I'm not a Ruby dev, though I imagine that the particular language doesn't matter that much when comparing these experiences. I am many things, mostly a frontend web developer (html, css, js etc.) but I'm also a fairly competent programmer (mainly PHP because reasons ( :( ) but I'm familiar with some others, including som familiarity with Ruby), along with some datbase experience and a bunch of other things. My journey has been fairly long - I got my first real job in december 2015, at age 24, and I begun doing HTML ten years ago. My path went from HTML to CSS, then some ActionScript in, essentially, high school, then some PHP shortly after. Did that for a few years while studying at a university, got an internship, learned JS well and from then on kept studying and looking for jobs. I've stydied three years at a university, with two of those years being IT studies, including programming and similar things, and while I've learned some things, the curriculum hasn't taught me that much, however, it gave me a place and a purpose to practice programming, which is essential. It also exposed me to IT-companies, allowing me to get an internship, and to get an insight into the real world. Getting a job wasn't trivial, I was actively looking for about six months before I struck luck. After that it was easier to land a second job, with a lot mor ejob offers as well. Most companies want someone who's been somewhere so to speak. To tie this together with some sort of point - You absolutely can teach yourself programming and get a job, but I'd say that you need some discipline and focus to get good results relatively fast. Learn a lot of things including the more abstract things, like some CS, some data structures, some algorithms, design patterns etc. Not like-the-back-of-your-hand, but at least some familiarity. I'd also advise you to pick up complementary skills, like VCS, some testing, perhaps containering, setting up simple web servers. The last thing I'd advise you to do is to try and get contact with real companies, try to get anything like an internship, a guided tour, a mentor, something to give you a taste of the real life. That's something school can't teach you anyway, and it's a big step up imo. 
Read textbooks. Pick something you are interested in and Google "x textbook free pdf". I have found textbooks to be a great resource for learning and they typically contain examples and projects. Do your own stuff, pick something that seems like it would be somewhat simple to make and make it. You will encounter lots of problems but by working through them is how you learn. Finally try and find online lecture slides from a class at a university. Once again Google will come in handy. Pick a school you know of and look through their catalog, than start Googling the class numbers until you find one you like/has all their lecture slides online. I am currently studying Computer Science (and I am currently employed as an engineer) but prior to starting in the program I was self taught. There is a reason people pay lots of money for a college education. Professors are paid quite well to make sure you learn the material required, and as such I find that they have the best resources for self-taught people too. I like to study a lot outside of my normal school work (I know, I'm weird) and I have picked up and read many textbooks and watched a lot of random programming project tutorials. You never know when something you watched may come in handy later. I'm not sure where you live, but I would say without a "degree" projects are going to be the best way to get a job. I'm also not sure where you are located, but if you are fortunate to live somewhere with a good market for people who can program (Austin TX, Seattle, Bay Area, ect) after making a few projects start applying to every job you can find. Call places and chat up the receptionist with the goal of finding out if the hiring managers prefer LinkedIn or a resume or some other form of application. LinkedIn is a must. Take a good photo (no selfie) and present yourself well. If you did well in high-school, maybe put your GPA, if you didn't leave it out. Don't include jobs like "McDonalds" or "Target" and if you don't have any formal relevant experience (Office jobs, internships, IT jobs, ect) leave work experience blank. List interests and any volunteer work you have done. This is where the projects come in. Without a formal education these are what is going to separate you from recent college graduates and other candidates. Make sure you put some good projects on your LinkedIn/Resume and explain the technical side of it in addition to explaining what it does. (i.e. Implemented &lt;insert_api_here&gt; API OAuth tokens to validate users prior to their &lt;insert_program_purpose_here&gt;) I would also say unless you get really specific early on (like you fall in love with authentication security) show that you have a broad range of topics covered. So if you make 3 rails apps, 2 api apps and an Arduino interface, list 3, but I would recommend one from each category. Not sure your situation but talk to people you know who are in the industry. Maybe you have a friend who is a programmer or someone who's parent is a programmer. Go and talk to them, chances are if they like you and think you have a good head on your shoulders they will keep an open ear in the job market. The saying "Its not what you know, its who you know" applies as much to Computer Science as any other industry. Last, don't be discouraged by the amount of places that will turn you down or not call back. There is always a better applicant, but for some company out there YOU will be that better applicant. The great thing about the industry is the demand is so high for the supply of engineers and programmers that chances are if you apply to enough places someone will hire you! This is a great field to get into! I hope you can get rolling and make some cool stuff. Let me know if you have any other questions. I kinda wrote this quickly so I might have missed some stuff.
I don't know of any Ruby jobs that don't involve Rails. OOP design patterns and best practices, HTTP/web concepts, and Rails/JS familiarity are all needed.
Social issues are viewed as more or less important depending on your region and culture. I imagine the Ruby community as a bunch of nests filled with different species of birds ruffling their feathers. All beautiful in their own ways. You just gotta find the right nest. 
Well, fast is a relative concept - you could say a bicycle is fast when you like it and it does the job, but without any proper argument or evidence to throw that statement into the wild would be a bit of a hit-and-miss. Programming is all about *compromise* - and when it comes to infrastructure/toolchain/language it's the ability to allow the user to choose that compromise for their own myriad of use cases (and instead of dictating that compromise themselves). A faster language allows you work with more complex designs and spend more computing power on abstraction layers - that's not to say a simpler design would *not* still work wonder with a slower language, and not to say a slower language can automatically disregard its slowness when it comes to making design decisions. tl;dr: it's always better to fully understand one's own weakness than to pretend it doesn't exist until it becomes a problem.
Yeah I still enjoy working in rails, except when I'm doing a javascript heavy project. A lot of modern app design asks for a lot of javascript interactivity, and sprockets is really not the best for it. It serves the standard web app quite well, no doubt about it. But for doing parts of your site as a single page app, or using bits of react in a site for whatever reason, it can become a burden. This kind of thing has been making me want to try nodejs, so I can try out things like server rendering and that. Regardless, I hope to keep seeing both ruby &amp; rails improve :)
Nice video! But you need to be careful: I think you need to set the integer types for ffi to :uint32! see here: https://github.com/ffi/ffi/wiki/Types#types anyway, when I tried Rust+Ruby I would have needed a video like yours, so I really appreciate your effort!! :)
I moved from C# to Ruby about two years ago. This weird defensive attitude from Rubyists about it being fast enough it really strange. Why is fast a bad thing? Why make excuses? Doing a single page application that uses Rails as a JSON API is quite a bit slower than other languages I have used in the past. Rails 5 with its API only mode and Ruby 3 with its performance increases are very exciting from a developer happiness perspective. I enjoy building fast and efficient things!
&gt; This weird defensive attitude from Rubyists about it being fast enough it really strange. Why is fast a bad thing? Why make excuses? I'd guess it's largely a kneejerk reaction to all the dismissive OMG SO SLOW.
excellent feature. And this is a great blog series, thanks! 
I believe in that Python concept of Fast Enough. A lot of the optimization tricks that work in one, work in the other. I used to have a writeup on a personal blog about this, but I used to use this small Perl script for a job. At the time, I didn't grok Perl at all, I had a vague concept of how the script worked, but it made me antsy that I relied on something I didn't understand and was based on a fairly stagnant language. So I naively rewrote it in Ruby, and it sucked. That script ended up being a lesson in writing Ruby scripts, because by the time I was done with it, it was roughly as fast as the Perl version. It came up with identical results, and behind the scenes basically did the same thing, but the code was completely different.
I am 26 years old, coming from a STEM background (EE). I discovered programming almost 2 years ago after I realized the job I was doing wasnt something I wanted to do. After taking 6 months off traveling (this is after I quit my job), I am back to reality and currently I am in the bootcamp. The reason why I did, as you pointed out, is to build portfolio. Unfortunately I may be dismissed from it. It's a bit rude awakening that I will have nothing lined up but I guess if it comes the point where I'm on my own, I'd just have to really cramp up and start building. Sorry, this is more a rant than a comment but thanks your input :)
Well, that's kind of circular. Ruby meets 99% of its use cases because people know it's fairly slow so whole classes of problems become "not Ruby's use cases."
&gt;Are you comparing a framework with a language? How would this hold up when you replace Rails with a set of Ruby classes using a basic http handler (such as Rack or directly on top of Puma). Or when you replace C# with an application in .NET framework or even in Mono? In the C#/.NET world the equivalent of Rails is essentially a first class citizen of the ecosystem. It isn't an easy comparison to make. You'd end up using something like ASP.NET Web API. &gt;I might be misunderstand you, but you call Rails slow(er) then some alternative, but don't give actual details on when, how and with what load it is slow. And you appear to be comparing apples and oranges. This is because Rubyist try very hard to say the issue is with Rails and not Ruby. From a developer or product owners perspective it doesn't matter. Rails isn't known for speed. If you try to use something besides Rails (rack, grape, etc..) you are segmenting yourself into a smaller and potentially less supported part of the ecosystem. You will likely end up implementing many components of Rails with other gems or code you have to write internally. It is fortunate that Rails 5 has some support for websockets and a slimmed down API only mode. &gt;I am merely trying to defend the notion that in a real-world stack, in the actual mess and spagetti of delivering complex software, the slowness of Ruby as compared to, say, Erlang, is reallly not ever the thing that makes your app slow. (that one poorly built query is. And that callback in Devise-whateverable. And that serializer in PunDoratorJsonifier trying to resolve the AR-relations and compile them to deeply nested JSON is) My point is that in other languages/frameworks the speed of the language and/or database can make up for the issues of complicated or poorly optimized software and queries. I'll take savings wherever we can get them especially if it doesn't require additional development effort. Elixir/Erlang does have the benefit of a better concurrency argument for scaling and performance when compared to Ruby though. &gt;Unless it is. And in that case I congratulate you with a big success and a good piece of software: when Ruby -the interpreter- is the thing causing your performance-problems you have solved a great deal of business and performance issues that nearly none of us will ever have to face in the first place. I'm not attacking Ruby. Ruby can improve and Ruby is a beautiful language. The constant defense of it as "fast enough" is baffling. Why wouldn't we want it to be faster without additional effort on our part? Let's accept that the language isn't the faster and work to improve it when we can and without sacrificing what makes it a good language. 
It's pretty good, but it's hard to integrate stuff like flux &amp; redux with. I've more recently used react_on_rails gem, which has a crazy amount of stuff to work with. Managed to get a front end &amp; admin built on two separate webpack bundles, using react router and redux. I couldn't figure out server rendering for the client/public facing side though, got kinda stuck. Have a post on their forums, but haven't heard back :( A friend of mine linked me an article of having a nodejs server as a middleman/routing stack of sorts, and using whatever API back end you wish. So the nodejs server would do any server rendering needed, or forward the request to the rails/java/django/go backend. It's a neat idea, I just feel like it would be easy to get out of sync with the routing.
Let me clarify. Ruby meets 99% of business use cases. You aren't the 1%, you won't need it, don't believe your own hype.
It's written in Ruby. But more importantly, Rackspace is a popular cloud service provider for Ruby (on Rails) applications.
&gt; Why wouldn't we want it to be faster without additional effort on our part? "without additional effort on our part" is crucial here. &gt; Let's accept that the language isn't the faster and work to improve it when we can and without sacrificing what makes it a good language. Scratch your own itch, means someone will poor effort in this, when he, she or its organisation really need it. I am not trying to defend Ruby for being slow. It might very well be. I am arguing -again- that Ruby -the interpreter- is hardly ever the culprit. Why spend €100K on improving the performance of an interpreter, when: 1. Your performance problems are not solved after finishing that, simply because your performance problems lie elsewhere? 2. Your performance problems are solved by cleaning up your domain code. 3. Your performance problems are solved by implementing caching (which comes by default with Rails). 4. Your performance problems are solved by swapping out some piece of software with another (e.g. replacing actioncable with erlang sockets, or some Rmagick toolchain with a dedicated piece of image-manipulation softwaer). 5. Your performance problems are solved by spending €3k a year on extra CPU power? You seem to miss my point: ASP.net Web APi might very well be faster in serializing data from MySQL to JSON[1]. Erlang or Elixir is very certainly faster in delevering actual content over sockets to hundreds of thousands of connected clients. But: your performance problems do not lie there! Wether you use Erlang, C# or Ruby, a poorly indexed super-join with N+1 over a 50K-row event-log in MySQL is your problem. Yyour application checking against the current user against some ACL wether you are allowed to view the Phone-Number-Attribute is. Serving different languages to different users based on a setting in some CRM is. Yes, having a faster language is nice. In fact, e.g. jRuby is a lot faster. But it is hardly ever the solution to your performance problems, and only very occasionally anything more than "nice". [1] This is a good example of how many of these "Rails is slow", "Ruby is slow"-callers are ignorant and don't deserve the platform they so often get: The default JSON serializer in Rails/Jbuilder is increadibly slow. Yet there are alternatives that are merely a `MultiJson.use :yajl` away. And when you ask the person lamenting that "Rails is slow" whether they read the README and configured the faster renderer instead they either answer with "*blank stare" or start ranting that Rails should have implemented that faster backend in the first place.
I'm, self taught, left school having studied music to degree level but I dropped out at that point. I joined an office as a temp and was so bored I started to automate EVERYTHING in Excel VBA. That led to a job on one of their IT teams and the rest is history. I am now CTO of my third start up having worked for all manner of tech, finance and banking companies. I have worked with .Net, Ruby, Python and all manner of other tools and languages (Pascal anyone?) I suggest learning not only your language of choice, Ruby, but core programming concepts and principles. I look at people that have that more than language experience. 
Well, sure, the reasons are about your app architecture/design for maintenability/debugability/development, not about performance. Like most decisions you make architecting code. 
You can usually get a working app with less code using Ruby (and Rails) and often in a shorter time than with a high performance language A typical API implementation will have 20% of endpoints getting 80% of the traffic, there is a lot around the Rack middleware you can do to speed those up to begin with - and if that's not enough you can look at using Rust, Go or similar to replace them (a great architecture advantage of APIs is the ability to loadbalance to a mix of service apps) The 80% of the app getting little traffic remains elegant and maintainable
I wrote [a dead simple boolean gem](https://github.com/yez/ruby-boolean) if you'd like to either use it or copy the pattern.
I work in Silicon Valley, the amount of startups I've consulted with that think they are the next Twitter and that RoR isn't fast enough is sad :(
Perf/scaling is only one use-case which Go etc. are fantastic at (I warm more to Rust right now for that - but I can't explain why yet) There are a lot of use-cases where perf is secondary, or for 90%+ of the app perf is secondary - but convention, reflection and heavy metaprog etc. are the biggest considerations (making the primary part of the app more elegant, accessible and maintainable) Scaling is one of those good problems to have - if you need to scale something is going right - langs like Ruby will allow you to prototype fast to find out if scaling is going to be an issue It's a great time to be alive with so many language choices and low friction ways of mixing those choices in to a solution
This applies to all server-side programming languages, not just Ruby/Rails. In my experience any server-side programming language will have more than good enough performance for 99% of the websites out there. Developer productivity (which is a function of things like language simplicity, library availability, etc.) is much more important that language performance unless you truly are one of the 1%. On a side note, in my experience 99% of the performance problems I have seen occur at the database layer rather than the server-side code layer.
Seems like a big change, unless backwards compatibility can be retained, shouldn't this be put off until 3.0.0?
&gt; Your performance problems are solved by spending €3k a year on extra CPU power? It is when you are small. When cost is about €50k an year for CPU, then speeding up interpreter/changing platform at whole is valuable. But one should grow up this volume before.
Yep, originally Rails 
None of the languages mentioned on this thread put programmer efficiency ahead of all other concerns, except Ruby. Or to put it another way: no one is even trying to replace Ruby, and I don't think you can achieve something like that accidentally.
For me it comes down to whether or not it is necessary for that method to be exposed to external callers, as the definition suggests. For me I typically start out by always initially creating a method as a private method and only making it public if the need arises. Edit: I just saw your post body -- If the logic exceeds some level of complexity (I base this complexity off of intuition), or there is a situation where code elsewhere needs to make calls to the encapsulated logic, then I will break it out. I will say that 99% of the time I break this logic out into its own classes etc. and make the calls from the rake task, but this is based on the sort of codebases I am typically working in. 
hooray!
I was gonna show you how you can do this in 3 lines, but I see /r/yez beat me to it and released it as a gem. :) But yeah, I agree it would be sensible for that to be in stdlib. 
Does not seem like a big change at all, I can't think of any code I've ever written that it would break (esp with the addition of Fixnum==Bignum==Integer for backwards compat, mentioned in the ticket). But still, sure, in a perfect world I agree ruby would be using semver and reserve any backwards-breaking changes for a major version (I don't think it is), and this would apply to even very minor and unlikely to effect much backwards-breaking changes, like this one. But this is far smaller than other potentially backwards breaking changes ruby has released in 2.x's. I believe ruby finds it acceptable to release backwards breaking changes in minor versions, although tries to minimize them lately (thankfully). 
See, that's what I mean. Given your numbers, I'm guessing it never dawned on you that many of us would like to use ruby for non-web-applications.
Ruby has been fast enough for Web Apps that are usually built with RoR. But, if we consider any non-RoR ruby projects... wait a minute, but where are all those non-RoR projects?
Ruby also doesn't have the same community and attention as Python. I will always love both dearly however.
&gt; I never mark methods as private. I invite coupling to any method that seems useful to the user -- and by "user" I mean, "code that uses the object in question." That's all fine until the code starts evolving, and there's no method that can be touched without risk of breaking any other class anywhere that might be using it. So, one reason i mark methods private is when I want to be able to refactor them at will with little to no possibility of breaking anything external to the class at hand. 
Congratulations I guess. I suppose you showed the right amount of deference to her. 
Thanks for posting this. It's interesting to read a strong argument against the conventional wisdom. I can't say I fully agree with it, but you make some good points.
As a counterpoint, I've been evolving code this way for a while, and I don't find it painful (and coworkers don't, either). If I'm working in a library, I notate breaking changes in the library version via semver. If I'm working on a project, and the user is also in the project, then I use the test suite of the project to correct the breaking changes I just caused.
How often do you explicitly reference `Fixnum` or `Bignum` in your code?? I don't think I *ever* have. Even for some genuine use case, you'd need to be very careful since the maximum value of a `Fixnum` (before it gets converted into a `Bignum`) varies between machines: &gt; Holds Integer values that can be represented in a native machine word (minus 1 bit). If any operation on a Fixnum exceeds this range, the value is automatically converted to a Bignum. (www.ruby-doc.org/core/Fixnum.html)
&gt; tries to minimize them lately (thankfully) Ruby has officially been following a semantic versioning policy since `v2.1.0`: https://www.ruby-lang.org/en/news/2013/12/21/ruby-version-policy-changes-with-2-1-0/ I can still remember the pain of migrating old systems from `v1.8.6` --&gt; `v1.8.7`... You'd think that should be easy, but there were *so many* obscure breaking changes!
It would surely make sense to insert a constant, like MAXFIXNUM, in Integer class.
A couple years ago I was participating in a programming tournament, and Ruby solutions were generally about 10% slower than Python solutions.
I actually wonder if Ruby can replace R in the context of data processing. Because R (according to an O'Reilly book) isn't really "to scale" either, but it has lots of built-in niceties.
&gt; Blocks and methods are not objects Wrong. Otherwise, good article.
I know very very little about R but my guess would be it is much faster than ruby despite not being "to scale" either.
Thanks for the feedback. Blocks and methods are not objects. If you have a different opinion, please explain. If you can prove it, I'll update the post.
Try this: String.instance_method(:to_i).class =&gt; UnboundMethod or "Hello".method(:to_i).class =&gt; Method And to get the class of a Block (a block is a proc) def test(&amp;block) puts block.class end test { "hello" } =&gt; Proc Blocks and methods are objects. Check out this (terrible) fanciness: String.instance_method(:to_i).bind("123").call I'm calling the `bind` method on the `#&lt;UnboundMethod&gt;` object (I told you it was an object), which converts it to a `Method` and then I invoke `call` it.
if it works out well for you, great! That's all that matters in the end. So if all methods are public, then pretty much any change to the signature or semantics of any existing method at all requires a major version bump under semver? Or do you consider a subset of public methods to be 'the API'? 
Thanks for explaining what you meant. When you do method(:to_i) you are creating a method object. However, the original method was not an object. In his book The Ruby Programming Language, Yukihiro Matsumoto (the creator of Ruby, AKA Matz) explains that "Methods are a fundamental part of Ruby’s syntax, but they are not values that Ruby programs can operate on. That is, Ruby’s methods are not objects in the way that strings, numbers, and arrays are. It is possible, however, to obtain a Method object that represents a given method, and we can invoke methods indirectly through Method objects." This is explained here: http://www.zenruby.info/2016/05/methods-in-ruby.html I think it's more a semantics issue... About the block example. When you pass a block as an argument to a method through a parameter prefixed with &amp;, the block is converted to a proc, which is an object. However, the original block was not an object. This is discussed here: http://www.zenruby.info/2016/04/introduction-to-blocks-in-ruby.html 
Can you please provide links to official sources? Regardless, methods and blocks (procs) are objects in Ruby (hence the Method class) so your statement in your article is completely wrong. Them being created or converted on the fly is an implementation detail (and not mentioned), and otherwise is not what you communicated in your post. Sourcing from your own blog to defend your own blog is circular reasoning and not at all convincing. Neither is your holier-than-thou attitude.
no difference in the cases you wrote.
Well I've used ruby for robot experiments, server scripting, log analysis, lots of things really. But in my professional experience, if you aren't already connected to the net, you soon will be/should be.
This is a good article! I think you missed a line of code in def meditate puts "Adjusting posture…" p = Proc.new do puts "Ringing bell…" next puts "Throwing up zafus" end puts "Sitting still…" # This line *is* executed end meditate You need to add a p.call to illustrate your point in this section. This affects the output too. Should be this instead: &gt; Adjusting posture… &gt; Ringing bell… &gt; Sitting still… &gt; 
I think we're already there with elixir. Phoenix is simpler than rails and elixir simpler than Ruby. There is just this level of resistance to not being able to just call simple methods on everything and get the expected result. Ruby might be easier, but elixir is simple, with no quirks, unexpected things, etc. Ruby and rails have made people unable to solve programming problems, and this practice of a gem for every simple thing and a method for each way you might phrase something has made it complex. 
Not the only reason. A lot of people like using node, and it doesn't hurt to try the different options out there :)
Yeah honestly I don't know if it is an answer or not. This was the article that inspired the discussion: https://www.nczonline.net/blog/2013/10/07/node-js-and-the-new-web-front-end/, a bit older, but not exactly irrelevant. You're quite right about the flash of loading initial content, that's where server rendering comes in handy. It's neat to see where the basecamp team have taken things like caching, turbolinks, and a lot of the built in rails stuff to make a snappy website. Have been able to even use the turbolinks pipeline for their native apps as well, which is crazy. The js.erb thing with remote forms/links to replace content has always felt a bit odd to me, sending html strings across the wire instead of just data. But it does have its merits. Like I said in one of my other comments, I tried to drop sprockets for webpack in a small project. Succeeded quite well, but couldn't get server rendering figured out. Next time I work on a rails project like that, I might try to mostly use the standard rails stack, and drop in things like react_rails where it's clearly needed. Generally speaking I like javascript, but it definitely needs a lot of tooling to make it less frustrating. ESlint, babel, writing solid tests. People have been using typescript and that. We still have a ways to go, but being so dynamic does make it a fairly flexible language to work with.
&gt;just use bcrypt, like the article recommends What the article says is: *Beware that, as of this writing, this library is not following cryptography coding best practices. * &gt; Yes it says that argon2 is better if your platform has support for it https://github.com/technion/ruby-argon2 
I've never seen a Rails app that wasn't littered with N+1 queries. Sometimes simplicity makes development faster at the detriment of other things. It's always a balance of simplicity vs. people having to understand what they're doing. 
Domain drive design https://en.wikipedia.org/wiki/Domain-driven_design
`create` does call `new`: https://github.com/rails/rails/blob/master/activerecord/lib/active_record/persistence.rb#L50 Are you overriding `initialize` in an ActiveRecord model? That is almost always a bad idea.
But does it shard
&gt; Why is fast a bad thing? Why make excuses? Nobody said that. It's you who have to answer: Why is 'fast enough' a bad thing? &gt; Doing a single page application that uses Rails as a JSON API is quite a bit slower than other languages I have used in the past. But is it fast enough? Then it's not "bad". No body is claiming that being slower is better, all they are claiming is that fast enough is not bad.
why commenters mention rails or sinatra anyway? I make plenty of personal apps using plain ruby and stdlib. it is still incredibly satisfying to write code in plain ruby and is indeed fast enough.
everything should be private unless that breaks the functionality. also you should only test public methods. if a private method is complicated enough that you want to test it, extract it to a class.
Yes, I agree. I like what Capybara did. They create a static object call 'Capybara' you can access as an API. Non neeed to include any of the DSL to use it.
First of all, your result is wrong. There are 36 characters (26 letters, plus 10 digits), and you're collecting all possible 3-character strings. Therefore, the number of results should equal `36 ** 3 == 46656`, not `22444`. Why is this happening? There is a subtle difference between [Array#repeated_combination](http://ruby-doc.org/core-2.3.1/Array.html#method-i-repeated_combination) and [Array#repeated_permutation](http://ruby-doc.org/core-2.3.1/Array.html#method-i-repeated_permutation) -- You should have used the latter. The difference is that `repeated_permutation` does not consider re-ordered arrays as "duplicates" -- So for example, it will include both `["a", "b", "c"]` AND `["a", "c", "b"]`. Your code is also horribly inefficient, due to its creation of and multiple iterations through *huge* arrays, for no good reason. (This all relates back to your mis-use of `_combination` vs `_permutation`). Without changing your method signature, and fixing the buggy output, here is an improved version: def make_possibilities(from_char, to_char, from_num, to_num, comb) ([*from_char..to_char] | [*from_num.to_s..to_num.to_s]) .repeated_permutation(comb) .map(&amp;:join) .sort end As a very rough benchmark, on my machine, running the following: puts make_possibilities( "a", "z", 0, 9, 3).count ...is now **1500 times** faster!!!!! (*And*, it returns more than double the results.)
When you are at a point that the interpreter or language *actually* matter for performance, you are doing very well.
And still are for lots of frontend-related parts in the stack IIRC.
Yes. And for some this is the "proof" that Rails is the bad choice for their product. However, one could just as easily say that this is the proof that rails is the perfect tool for their product. After all: Twitter would probably not be there had they built their first iterations not in Rails. If they had spend 8+ years on building their huge Java, C, redis and whatnot infra in the firs tplace; they would have had a very performant "twitter" eight years too late.
this is awesome!
Even better. It has instantaneous Peer To Peer synchronisation: The moment you store data in this storage, you'll find the exact same data on each and every node in the cluster.
&gt; If a language platform executes a stament in .1 ms and another language of relative equivalence executes the same statement in .01 ms then there is validity in the clams that the first language is "slow." When you put Ruby next to, say, C# in such irrelevant benchmarks, it most certainly is slow. However, when you make your benchmarks relevant, you'll see that the language matters very little. And that many mature frameworks will give similar results too. That it is the implementation that matters. A relevant benchmark is not running `10_000.times do { puts 13.37.to_s }` in many languages. A relevant benchmark is creating 40 accounts then uploading 20 avatars, causing you to receive 30 push notifications and 10 mails, and then running 20 concurrent websockets delivering the data of a 50 chat channels. 
There's plenty of DDD code out there. Some example repos in different languages: https://github.com/pawelkaczor/ddd-leaven-akka-v2 … https://github.com/VaughnVernon/IDDD_Samples … https://github.com/BottegaIT/ddd-leaven-v2 … (this one is Ruby) https://github.com/mpraglowski/cqrs-es-sample-with-res/ … https://github.com/dddinphp If you go to our Arkency blog, you'll find dozens of DDD blogposts, most of them with Ruby/Rails code: http://blog.arkency.com
You might be interested in taking a look at [this ruby gem](https://github.com/tom-lord/regexp-examples) I wrote a while ago: require 'regexp-examples' /[a-zA-Z0-9!@#$%^&amp;*()]{3}/ .examples(max_group_results: 100, max_results_limit: 1000000).count # =&gt; 373248 Note that this gem is not really intended for generating *huge* lists of results, as it does not process things in batches. So for larger lists, you'll unfortunately just run out of RAM. On the other hand, look how flexible it is -- You can generate "all possible strings" that match (almost) *any* regular expression.
Systems engineer here. Chef cookbooks are Ruby and most of my automation infrastructure is written in Ruby. Technically I do have a web frontend/api to it using Sinatra, but still not lately doing "web" development per se. 
Well, I am a system administrator and we build everything with ruby. * Automated installation and configuration of hostings, together with puppet * Inventory collection for our backup systems * Whole DNS administration with a Rails frontend * Whole Odin Virtuozzo management with a Rails frontend * Ordering SSL certificates based on a config file via API. * Collecting runtime statistics from every vServer and push the in our intranet for our PM's We try to replace ALL bash script with ruby/perl/python scripts. IMHO: The best part is puppet. When we create a vServer we install puppet and run it automated. Puppet configures everything and deploys our scripts, based on the ruby version. The virtuozzo management server uses those scripts to configure the server. Works :-) edit: repaird listing
If you mean native mobile, I don't think ruby is a good choice. If you mean web apps, that's of course what rails is for and you can certainly build a mobile web app with rails or other ruby technologies. It's still a bit tricky and confusing integrating a react front-end with rails (probably true of most java frameworks too). If you're going to build a native mobile app in React Native (no idea if that's a good idea or not, I have no experience with it) as an independent thing, but need a back-end API for it to communicate with, Rails or Sinatra will work fine.
I saw many ruby developers working on scripts to manipulate cloud hosting, like: - setup a new server - setup a staging server just to homologate something - to download some dump of database - to check the amount of connections
&gt; Does anyone have any tips for finding out stuff like this? Learn Japanese? Not helpful, I know. 
Absolutely agree- rails is just so flexible- and that's why it's almost universally the right choice for a lean startup with 1-2 developers needing to push out new features almost daily. You can do that. Not efficiently, not fast code, but there is no easier way to pump out new features for your first ~1000 users and proof of concept. Few startups have the luxury of being able to properly build the app that will take them to 50000 or 100k users until they have built the app that will get them to 1000.
I typically work on Rails at my day job, but this current project is plain Ruby and I couldn't be happier! It's a bit of a hybrid in the context of your question because while it's not a website, is a hosted application and interacts with APIs - we're building some automation to work with and around Twitter. In my personal projects I often lean towards Sinatra because of its simplicity, but this full departure from frameworks is glorious. It allows me to focus fully on my OO design and testing without any other code's decisions in my way. You can get close to this in Rails (using lib/ or whatever other directory you want, not having every class inherent from AR, not always loading the Rails stack for tests, etc.) but working frameworkless you don't even have to give it a thought. I'm really very thoroughly enjoying it and it's forcing me to learn a bunch of stuff I thought I knew but it turns out was being handled for me magically by frameworks (load path stuff, little dependency things, writing isolated tests, handling processes and logging). And the deployment is far simpler too. I'm writing a few gems to include in the main project for things like API wrappers, and the main project itself adheres to a gem-like structure so if one day I wanted to package it all up and figure out a way to include it in a Rails app or something it's still entirely possible. I highly recommend giving this a shot in a project where it's relevant for you! I'd be happy to answer any other specific questions you have. Glad to see a question like this in this sub!!
&gt; Save data to a db: What database should be suitable for this? You are creating strings, any DB could do this. &gt; What about dynamically create tables in a tree arrangement You can use a graph DB like Neo4j. But don't use the word tables. That is a specific data structure that is no where near the right fit for your use case. Nodes and Edges, that is your vernacular.
If you're focusing on web dev, ruby/rails. If you're focusing on mobile dev, swift for iOS or learn angular for a combination of web with something like Ionic that creates native mobile apps with Angular. I'm sure React Native is good as well, but haven't tried it myself. If you're interested in web, Java is not the way to go. It can be useful for Android development though. But personally I haven't used Java since college and hope not to.
I do a lot of web development, but I also developed some software for windows in Ruby to process MSOffice documents, and parse and extract this data to other formats (XML, relational databases etc).
Cloudformation is JSON not ruby. Do you mean you have ruby scripts that output the cloudformation JSON?
Database work (ETLs, reporting, etc.); general automation stuff; lots of data munging; sysadmin stuff (not entirely Ruby but it's my primary "proper" language).
Aren't these three all similar in function? What do you use each of them for?
I also do ETL with Ruby. I needed to build an enterprise data warehouse (EDW) for analysis, CRM, and marketing automation. I'm a Rubyist, so I used Ruby for as much of that as possible. I ended up licensing Pentaho PDI (aka Kettle) for some of the ETL heavy lifting. But our solution uses Rake tasks to trigger ETL jobs, I built a Ruby-based unit test framework around our Kettle transformations, and our master data management (MDM) process is handled entirely in Ruby. I don't qualify as a Rubyist who doesn't do web development because I'm also responsible for a web team that uses a lot of Rails and Sinatra. (And Node.js.) But the data warehouse director who works for me does.
Well, the "manifests" themselves are a custom descriptive language that roughly follows Ruby-like syntax. But the providers and types that you interact with via the descriptive language are all written in plain Ruby.
I wonder if you work at a former employer of mine, or someone who's built something very, very similar, since we did a network security product that also used ruby extensively.
It is a real shame that Ruby is only really used for command line and web apps. No UI kit really limits the application.
No, what he means is that you can write a ruby script that will create, update, and delete CloudFormation stacks in AWS, even though the stacks themselves are in JSON. There's also a Python SDK. I don't know if it's completely one to one, but if you can do something using the AWS command line interface, you can probably write a script in Python or Ruby to do the same thing. 
I used to write Ruby for use in satellite collection planning. There were a lot of other Ruby-only applications throughout the aerospace engineering side of the organization.
Could you provide some examples of this? I would love to see this in action.
No Rails or Sinatra, but we develop and maintain a web based medical records system in ruby. The reason it doesn't use a well known web framework is that the project is older than any of them. So the HTML/CGI handling is done by libraries that were written into the project long ago. It has been easier to update and extend those libraries than to contemplate moving the whole thing into a newer framework.
I used to work with Ruby and Python building a web scraping engine. To be fair most of it was within the context of Sinatra building an API, but the server part was basically a facade on top of a Resque queue that fed jobs to a Python scraping engine. Then the Ruby code would wait for callbacks from Postgres to figure out what happened with the job. Most of my time was spent figuring out the tools to get all the plumbing working between my Resque job code and the database and back to the API.
It would be nice to see a major release focused on **removing** features which have proven to be bad ideas.
I would like _less_ rails, not more, personally. I don't need or want automocking containers or a deepening of the utterly broken "resource" idiom.
I'm writing a decentralized instant-messaging/chat network in ruby. :-) wanted to learn how to use encryption, web sockets, and mesh networking (I still have to implement the mesh networking, but my whole setup works for small numbers of people on the network)
For what it's worth, Java and frameworks/libraries like Spring, Hibernate, Hazelcast, Ehcache, Freemarker, etc and servlet containers like Tomcat and Jetty are what you'll find in enterprise web -- generally not startup world.
I agree with u/BrunoJFS and u/bitwad66, methods are not objects. 
I build tons of APIs in Sinatra. It's so easy to just toss something together. Now I've begun to write some in golang for fun, but when I need something quick I often default to Ruby/Sinatra. 
Can you show me where the OP says that `Method` instances are not objects? I've read the post, and cannot see it. He appears to be talking about `methods` not `Method` instances.
QtRuby is still stuck on Qt 4, sadly.
sort of. the json is static. the script takes in vars from the command line and retrieves any missing ones from the other cloudformation stacks and then creates the stack with those parameters
Good question. I don't necessarily see it as being evil (in most cases it is not), but architecturally make it clearer to other developers (and myself in the future) that the concern of that method is only to be used to affect state or behavior of the encapsulating object. Say for example I have a car class which exposes start and accelerate as public methods. Now as things are moving along I need to understand the fuel to oxygen ratio, when to pull fuel from the tank, etc. in most cases and external caller should have no need to affect the methods wrapping that logic. The public methods exposed are what they are worried about, and those public methods are callers that need to be worried about those internals. It's very similar to how an actual car is. I have a public method, allowing me to depress the throttle to accelerate. Whatever happens in the middle is not my concern, all I'm worried about (as an external caller) is that the car goes. 
Another ETL here. I work in a library, and the quality of metadata we get is...suspect. So lots of cleanup and then indexing into solr.
this! yes!
I guess you typed 'rspec' and not ./bin/rspec which means the system rspec is used regardless of what testing framework (mini test by default) is configured. Since you don't have a spec folder it says there's no tests. I don't see the issue here. 
I'm a build and release engineer, and one of the build scripts I wrote is a managed script in Jenkins that looks at the Github contexts set by another buildscript and makes a special status comment when everything is ok. It's written in straight ruby using Net::HTTP--no gems. 
in my last job, our codebase was a mix of c, python and bash, with a mess of distributed code, networking, etc. we set up an integration testing framework using ruby - started by writing ruby wrappers to run various workflows and capture their output, and then wrote a lot of test cases (using test::unit) that made sure everything was running as expected. saved us a lot of time, especially when we pushed out a new release.
So I'm not alone :)
Information Security. I ended up writing a DSL that defines a policy suite that runs various security tests. Spend most of my time writing gems to query various things or integrate other tools/services. It's refreshing to be able to write well designed OOP APIs, then have to fight with Rails all day (we heavily use [Padrino](http://padrinorb.com/)).
agree on the 'resource' idiom. 
Without a use case, how you store the data is largely irrelevant. Store it to a file. A DB of any more sophistication than that is not needed. If your use case is to store not the results, but the structure of the input in a way that facilitates rapidly reproducing the dataset, then a graphDB will let you do that. It will also let you expand that dataset, as well as create subsets fairly easily.
what the hell are you talking about? That's not analogous at all. The assertion is that methods are not objects, that they are not 'instances' of the `Method` class and that the `Method` instance you get back when you go `method(foo)` is created-on-the-fly as a wrapper object which contains useful meta-data about the method, but is not *the* method. The OP and the other guy presented evidence for this by demonstrating that ivars do not persist and the `object_id` is different each time. You assert that these are just "implementation details", but if they were simply implementation details then they would not 'leak' out to the user level, unless you're arguing that it's a leaky abstraction? In Python for example, where methods really *are* objects you can persist state inside the method object, this can be useful in a number of situations. But in Ruby, where it is asserted (by OP and co) that methods are **not** objects, you cannot do this. If you were correct in saying that a method is an object then it would have a consistent identity. So, we have two possibilities. 1. Methods are NOT objects and the `Method` object you get back every time you go `method(foo)` is just a created-on-the-fly wrapper object that contains useful meta-data (such as `source_location`) about the method. 2. Methods ARE objects but a very leaky abstraction. The object has no consistent identity (changes its `object_id` each time you request it) and it's impossible to store any state (ivars) on it. Both are, i guess, arguable, but 1. is IMO a better mental model as you don't have to account for the lack of persistent identity. However, since both are viable mental models (though one is slightly messier) we can look to the creator of Ruby to see which mental he had in mind when he created Ruby. Matz has said, in print, as OP quoted, that methods are **not** objects. It's in the 'sparrow' book published by o'reilly that he co-authored. I can give you the exact page number if you request it. So, given that both mental models are arguable, but that Matz had in mind the first (that methods are not objects) and that the first is conceptually less messy (no leaky abstractions), i think it's the most fruitful mental model to hold.
Last time I looked the Python SDK was missing a lot of what I needed so it wouldn't surprise me if you had a lot of Ruby people around you would just roll your own. 
oh gross
How about this? nums = (1..10).to_enum Array.new(3) { Array.new(3) { nums.next } } Relevant documentation: http://ruby-doc.org/core-2.2.0/Enumerator.html#method-i-next
Checkout stack_master. Also sparkleformation provides a nice wrapper dsl for the json
:( We do both Ruby and Python for scripting - honestly, our main language is Erlang, we don't really have a choice - but it's usually suggested that any AWS related scripts are written in Python.
You don't have to load all the features.
I've found that Chef is Ruby but it's not Ruby. You can't read a Ruby book about software design and expect it to make your cookbooks better. Maybe the same is true for Puppet. It's more like this DSL and if you do know Ruby it actually is super confusing and annoying to try to write clean Chef code. I don't want to sound like "real Ruby programmers" "are better" than Chef code ... I've had the same experience with other Ruby DSLs that are maybe trying too hard. It's just that DSLs don't get the benefits from modules/mixins and class-based problem breakdowns. You have some magical context being passed around and you just can't write code the same way. I'm was playing with testing tools around Chef just to bring that habit into the mix but that was sort of a hit/miss. I blogged about it here: http://squarism.com/2016/03/15/serverspec-and-packer/
Or call it what it is called in every other language including ruby (sprintf) instead of using one of the aliases for it -- especially considering it is generally considered bad style to use the % alias. https://github.com/bbatsov/ruby-style-guide Favor the use of sprintf and its alias format over the fairly cryptic String#% method. 
Interesting! FFI does have a small performance hit when calling into C compared to C extensions, but that's due to FFI handling copying/converting data and thread safety for you. Plus FFI has the additional benefit of not having to write boilerplate C code to bridge Ruby to C. Also, FFI works on JRuby, where C extensions are not supported.
Video cms scripting. While it is web related. I use Ruby for content and meta data bulk updating. I use groovy and node as well but I like Ruby for a lot of things. Also I think rails is trash, just my opinion though. 
Yeah, but he said Puppet modules. Modules are written in Ruby, manifests in a DSL.
Method instances just contain metadata? Matz is the only person who ever contributed to Ruby, therefore God? Ugh. So wrong. So how come I can bind it to a completely different object of a different class and/or invoke it, if it is just "metadata". Do you consider the complete usable tokenized executable code as metadata? What isn't metadata then? The object_id? Don't answer that, I'm obviously being rhetorical. I'd bother responding more but you are just as arrogant and toxic as your fellows. You aren't even talking about anything remotely related to what I brought up. Implementation details can't leak? What the hell? It pretty clear you are just spouting words that you heard others say. You don't seem to know what they mean because you are mixing and matching disparate concepts without abandon in an attempt to sound smart. Read my second comment in this thread. I have lost interest, I respond only to acknowledge your effort writing this response, and that I appreciate your time and attention. I'm sorry that you wasted it arguing semantics.
&gt; This is a very valid criticism. If the core framework of a language doesn't use the most efficient way to do something that seems like a problem. We use the oj gem for serialization. That's an incredibly nearsighted viewpoint. The core framework should *work* period. It should be accessible and functional. Improving speed for the sake of readability is meaningless if the code *itself* becomes the speed issue at that point. Poorly written code happens more often when the difficulty of the language outpaces the current skillset of the development team writing the application. Poor readability dramatically increases the difficulty of the language *even in situations where syntax is easier* because it becomes much more difficult to determine exactly what is being performed by the code.
Why does that command work at all without the gem? Also should I change all to rspec and _rspec, is there a way to automatically have rails g resource use that instead of _test which I guess is what mini test uses? Lastly, should I just learn mini test and not deal with it?
Because gems are shared between projects for each Ruby version on your machine. Type `bundle exec rspec` instead and you should see the error you're expecting.
Could you educate me on some of the issues with Oj? Just looking between the [flori/json](https://github.com/flori/json) repo and [ohler55/oj](https://github.com/ohler55/oj) repo I see that the Json repo has far far more open issues and less stars overall. I've never run into issues with Oj on default settings. What are some of these edge cases?
I hack on the AWS SDK for Ruby (aws-sdk gem) for Amazon. 
**yawn**
right, agreed. And the escape hatch of `send` means you don't even need to make things public "just in case" -- design your API, make public things public. If someone needed a private method, redesign the API so they won't (by making that method public, or by something else). 
You're missing a general point chasing a specific one. Could the builtins be better? Sure. Commit the code with an understanding of all the impacts. The point is that your view is *wrong*. The goal of a framework isn't speed. It's usability. If the framework is fast but difficult then prototyping to find out the speed difference is going to trash any gain that you'd get. Rails is popular because it's usable. The fact that it can be fast with some work is icing, but not relevant to the quality of the framework.
100% agree! See my other comment in this thread, if the subject interests you.
Another way: Array.new(3) {|x| Array.new(3) {|y| 3*x + y + 1} }
I think it would be fairly easy to subclass [FFI::AbstractMemory](http://www.rubydoc.info/gems/ffi/FFI/AbstractMemory) and create a proxy class that allowed for `[0][1][2]` style syntax and just calculated the index and called `:"get_#{type}"`.
&gt;I was talking about JSON from the stdlib: https://github.com/ruby/ruby/tree/trunk/ext/json No gem to install. https://github.com/ruby/ruby/blob/trunk/ext/json/json.gemspec Isn't this just the JSON gem from here https://rubygems.org/gems/json/versions/1.8.3 ? Following links for that I arrived at the flori/json repo, but its unclear if thats the actual repo. I admit it was a little confusing to figure out what Rails actually used. 
I'm actually rewriting an old project that is basically a "School information system". Back then, it used a local database and now it will connect to an online server were the database will be stored (alongside a web system written in PHP and Javascript, so you can use it in your browser or mobile phone). Altough there is a web connection, the Ruby system will be in Ruby and not Rails (I'm using Qt for the GUI and Mysql2 for DB connection).
I think Rails5 should be end of the line. Community talent has eroded to the point where it is possible to maintain, but not innovate.
React is awesome, I've developed in Angular and React, definitely prefer react, especially with redux.
You are right it's bundled from flori/json: https://github.com/ruby/ruby/commit/1f1e3d12979fa385353b034c25d52a36e87b2ad6
Production Engineer @ Shopify. We obviously use Ruby for Rails, but we also use Chef/Cookbooks (like others mentioned here). We use ruby for our internal developer environment tooling, our CI system tooling, our X, Y, and Z. Ruby is typically our go to for everything unless there's a reason not to use it.
Curious where you don't use Ruby (and why).
You still have rspec installed somewhere so the command is still valid. Gems are installed globally on machines.
In general its not a good idea to use rails generators for production grade apps. It Creates a lot of default files and functionality that you will probably never use (looking at you, .coffee files). There are ways to change this I'm sure, but it's just not worth it. Plus, you'll never learn as much about rails using generators.
Totally not my primary task at work, but I've used Ruby (without Rails, though one script does use activerecord) to write a ton of scripts of varying complexity at a book store. We need to do various kinds of data processing and/or conversion there both for analysis purposes and in order to simply get data out of our antiquated POS system for various purposes. When I started there, people were either painstakingly doing a ton of manual work in Excel or they were using some pretty complex and poorly set up Access databases. I remember one daily Access database I personally had to use daily took 15-20 minutes to do the import-into-one-table-then-export-a-query cycle. Eventually, I replaced it with a Ruby script, and the whole data conversion process took 3-4 seconds. Soon enough, people wanted me to write scripts for a few other processes, and I also wanted to replace some of the other tedious stuff that computers should be doing efficiently but weren't. As I said, it's not my primary task there, so I'm not working on it everyday. Now it's just a little maintenance when we need to change something, or when we want to try to interface something else with our POS system.
I was gonna say the same thing, puppet modules. I actually implement puppet to interface with third party hardware but its pretty much the same thing.
Doing it with a single 500 character long string and replacing the characters to generate the permutations may be faster. If I were to dream up the fastest way to do this I would probably use C and allocate a single 500 byte hunk of memory and exploit the fact that the alphabet characters and numeral ASCII codes are sequential such that creating a new permutation just involves incrementing an 8bit value (with the occasional reset). 
This is more about the awesome introspection capabilities of ruby.
I believe the take away from this article is not the specific solutions/changes it suggests but the general issue with future rails' direction. Where is it going? Will it finally address problems that the community has been discussing for roughly ~6 years? FWIW I don't think it will, it's not reasonable to think it will. Why? Because if all these years were not enough then why would anybody think that something will finally change. There are many rails devs completely happy with Rails, then Rails Core team members with decision-making authority and lots of influence on others are also happy with Rails. This framework is settled, it is what it is, don't like it? Move on.
It's not happening, in fact - the opposite is happening. See [this](https://github.com/rails/rails/pull/20350) or [that](https://github.com/rails/rails/pull/18910) and probably way more, both are bug-prone anti-features, happily accepted and added by Rails Core team members.
I tried plenty. I've not found one that makes the job easier than writing raw JSON. I see the benefit for very large and complex stacks but for less than 50 or so instances it's just extra complexity.
Autonomous robots (http://rock-robotics.org). The data processing and control parts are mostly in C++, but the autonomy and the development framework are in Ruby.
What boundaries are there? You have clear boundaries already drawn by MVC. You don't need any more boundaries! Your response literally had no content but defensiveness and commits multiple fallacies. What HTTP details are going into your model with User.create(params) - are params not a special type of object that provides an abstraction with the same API as the familiar Hash? Could it be that the problem never was Rails? Wow right? The problem is that people get BORED and invent stupid crap like "Service Objects" or "Decorators" hoping desperately to be validated and people follow hoping that following the next cool pattern ideology that will make their code suddenly readable. When in reality, the answer is ALWAYS to get rid of things, including patterns, abstractions and barriers. Don't worry though, once we clean the place up, it will be ripe and ready for some pattern obsessed nut to muck it all up again implementing everything as stateless containers, functional command objects or doing everything through GraphQL HTTP service calls or some crap that slows it all down again.
What are the boundaries in MVC? Where do you put your domain logic? Everything in the controller? Two years later your application has grown rapidly and you figure out that you rather use a NoSQL database f.e.. Are you going through every controller and change the code so you're storing your data somewhere else? I think /u/solnic has a really good point, especially with the repository example. Whenever he wants to change datastores, he just changes the implementation of his repo and he is good to go again. Abstracting your code and creating smaller components makes your code easy to reuse, maintain and even replace whenever necessary. I'm not saying you should use all patterns all over the place, but they can definitely be useful.
Normally when you chain enumerable methods together like `map`, `repeated_permutation`, `each_with_index`, etc. when the chain finally 'resolves' the entire result is calculated at each stage of the chain. In this case it would attempt to calculate the entire result set of `repeated_permutation(500)` which I'm sure would require more memory than my machine has, then try to calculate the full result of `map(&amp;:join)`, etc. When you use `lazy` you are converting the chain into a lazy enumerable (http://ruby-doc.org/core-2.0.0/Enumerator/Lazy.html). Instead of calculating the entire result at each stage, it calculates one result at a time for the entire chain each iteration. Basically instead of asking `repeated_permutation` for all it's results before looping over them it just asks it for it's next result each loop, think of it as stream processing. For iterating large sets this is massively more memory efficient since each result falls out of scope each loop through and can be garbage collected. So why isn't it the default? Primarily because you can't perform all operations on a lazy enumerable, e.g. you can't call `sort` because sorting requires having access to all values in the result set. You can't perform any operation that is reliant on the length of the result in anyway, since you can't know it with this stream processing like model. Also, there is more bookkeeping needed so it's a bit slower than non-lazy enumerable method. 
Ruby is fine when it comes to speed, for the most part (protip disabling ruby gems increasing speed a TON). However when it comes to exceptionally fast requirements, Ruby won't cut it - so Go or C is used, for example. Swift and Java are used in mobile development. Python and Java in Dataland. We have some bash/zsh stuff to integrate into our terminals. So stuff where ruby is just not appropriate. So it comes down to - what is the standard/requirement for the function. Does it need to be stupidly fast? That said you have some stuff for deploys in [Ruby (Rails Engine)](https://github.com/Shopify/shipit-engine), [Mobile Buy SDKs](https://github.com/Shopify/mobile-buy-sdk-android) in Java/Objc/Swift, some [GraphQL stuff in Ruby](https://github.com/Shopify/graphql-batch), [ejson (encrypted json) stuff in Go](https://github.com/Shopify/ejson), etc. So you can see it wildly depends on the circumstances and we simply make a decision on a project basis. You can see lots of examples [here](https://github.com/Shopify?query=+only%3Apublic)
&gt; threads That's a very broad topic... The first issue you'd need to overcome if performing this calculation for *big* lists is not running out of RAM. The main bottleneck here will be in the `Array#repeated_permutation` method. Given a larger input, e.g. `make_possibilities "a", "z", 0, 9, 6)`, your computer will simply freeze. (The example above would be trying to generate `36 ** 6 == 2,176,782,336` strings!! If you save all results in a file, it will be approximately 13Gb.) The trick is to somehow run the calculation in batches. Yes, you *could* run each batch in in its own thread, but focus on how to process it in batches first. Hint: Read about [lazy enumerators](http://ruby-doc.org/core-2.3.1/Enumerator/Lazy.html) in ruby. Use them to solve this problem. Write results to disk, in batches, as you process the answer.
I am self taught as well. In my market I was able to get my first Ruby job for automated testing due to an extreme shortage of talent. I am in the Midwest and I had some SQL and VBA experience but the desperation for people who can write automated tests led to them allowing me to learn on the job. After serving in a junior role for just a year I received a an offer making better money. Then a year after that got an offer as lead automation engineer. It is all about getting in the door. Once that happened my now 5 years experience leads to me getting more offers each week than I can fathom.
We actually agree - like you staying that splitting a class in two makes two bad classes. Yes, and we call that exact thing both the presenter and adapter patterns. Making an abstraction layer is worse because now you have two classes where the second one doesn't even do anything but rename a bunch of methods causing confusion on both sides whenever they have to dip a toe into the other - so we do it rarely. You seem to be a big fan or repository pattern, which is just an another abstraction over a database - which out of the gate you are misusing your database which comes complete with a huge array of mathematical, statistical and aggregation functions. Your database is the core of your business intelligence - it isn't just some stash of data. As I have said to others, I love Ruby, but if I had to chose between Ruby and SQL - SQL wins by a landslide. Learn some serious SQL and you will find that nearly all of your Rails layers are mostly unnecessary and that SQL's declarative language is more than just functional, it's optimized separated functional code, all too often discounted as 'just a persistence layer' which is an ignorant insult. BeanFactoryFactory
Can you define what you mean by component? (Components containing logic are models) Why are you using a controller to be anything other than an interface to a browser? That's all that controllers are for. They control the browser. There is more than enough complexity in doing just than than for you to be burdening it with additional business logic. It seems the problem is that way too many people here don't realize that a model does NOT mean ActiveRecord.
Actually, the browser controls the controller.
An interface to the browser? Are you for real? For someone that claims to have been "building and maintaining large web projects for 15 years" you sure don't have a clue what you're talking about. How did you manage to get an ISP to run a line under that rock? You continue building and maintaining large, static, web projects that you've been working on, once you've implemented a few feature requests come back and read these articles, or Google open-closed principle or SOLID, that might help you untangle the spaghetti.
It's a give and take relationship. True, sometimes they bicker, but that's why we have couples proxy counseling. (Har har / #badComputerJokes)
May I ask what materials/resources did you use to teach yourself? 
When was the last time any of us actually wrote a single line of Java? I'd wager most Rails devs have never even touched Java, let alone [Jetty](https://wiki.eclipse.org/Jetty/Tutorial/Embedding_Jetty), [Spring](https://spring.io/), [Struts](https://struts.apache.org/), or [Play!](https://www.playframework.com/documentation/1.3.0-RC1/firstapp) (closest to Rails/Django). Java is the long forgotten boogieman Rails programmers tell stories about around the camp fire at night.
Except when you do Scala or Clojure and you're pretty close to JVM :)
I set it to 500 just as a demonstration that the process memory didn't depend on the size of the result space, it's just an extreme case. For smaller strings it may be more optimal to buffer some number of results before writing to the file. The OS should buffer the write anyway but buffering in user space would cut down on context switches.
Assuming that all your action does is `Model.create(params[:model_name])` yes, if that's the case, then you're either developing an extremely simple CRUD application or using `after_create` callbacks for everything. If it's the former, good for you (all be it there's still far too many concerns in a standard AR model), if it's the latter, you'd be better served by adopting some of these patterns.
I don't see how Rails is to blame for sad code bases? Isn't it always possible to write things in a way that keeps everything de-coupled? the question I always ask myself is 'how would this be easier to unit test' and then I figure that out, and it usually leads to good places.
I'm using [colored](https://rubygems.org/gems/colored/versions/1.2) . Here's the code for the display: &gt;puts "#{item['title']} | href=#{item['originId']}".red It's a plugin for [BitBar](http://getbitbar.com) displaying in my menu bar. 
Ich believe you're looking for [Fuubar](https://github.com/thekompanee/fuubar), a formatter for rspec that provides instafailing specs and a progress bar. Since we use parallel_test in our project which isn't entirely compatible with Fuubar, I like to override the formatter locally by creating a .rspec file with --format Fuubar
Damn, I wasn't insinuating any of that. Though the Rails Doctrine itself disagrees with what you've said as the last two components are progress over stability and big tent. I've found DHH pretty easy to work with any time I've wanted to see a change made to Rails.
Yes but there will be some limitations 1. Windows is only at 2.2.4 unless you compile 2.3.0 yourself on the platform. I would not recommend this, it's akin to pulling teeth. 2. You can package ruby as a Windows app, but you might not have the same luxury with Linux and Apple. You can use ORCA or RELEASY for Windows -&gt; (https://www.ruby-toolbox.com/categories/packaging_to_executables). Linux and Apple OSes you are better staying in script format. 3. How you want too read the mouse/keyboard input in is determinate of your OS. I don't think Ruby for Windows has good support for reading raw/blocking keyboard/mouse or inserting keyboard and mouse clicks/movements. You may be able to do this with a gem, I'm just not familiar with the gem you would want for doing this. If you are not looking to capture all input per say but just want the active window to capture mouse clicks/keyboard presses inside of it you will be golden. 4. Now from your description you might want to invest some time looking into Gosu -&gt; https://www.libgosu.org/. It's very good, cross platform, albiet a bit slow. However speed does not seem to be an issue with what you are trying to accomplish. 5. Phaser-opal might be right up your alley as well if you don't want to bullshit through creating a "true" cross-platform application, you can always write a webapp and webgame to remove that complexity. Phaser-opal looks very promising. (https://github.com/orbitalimpact/opal-phaser) EDIT: I was wrong about #1 RubyInstaller now supports 2.3.0!
nice! thanks. 
&gt; Rails isn't to blame for bad code. That's partially true, think about these features and how they affect codebases, esp when less experienced devs are building them: * auto-loading of constants (read: everything is available everywhere) * Rails' version of ActiveRecord with a gigantic interface * implicit (mutable) state sharing between controllers and views These have huge impact on how people structure their apps and teach bad habits right from the start.
1. What are the major issues or problems that one may encounter if trying to compile 2.3.0 on my platform. 2. Is there any other, more basic / crude, way to package my ruby project, ideally as a folder with a launcher that would run a bundled interpreter and the scripts to interpret, within the directory or sub-directories? 3. All I want is a full-screen window, the truer and less "windowed (borderless)" the better. This window upon launch can capture key presses, key releases, mouse button presses, mouse button releases and mouse movements at a milli-second scale. Ideally, I would have a directory containing .rb scripts, any other format files that might be used to interact with the OS as part of gems or whatever, assets and the ruby interpreter. Then all I'd need to do is create a .bat, .exe or other executable-format files for other platforms that would run the interpreter given an entry script, this script would initialize a window frame "require" the other scripts and load assets for content in this window. This is probably quite difficult, but I'm sure this is possible and wouldn't mind spending a lot of time learning on how to achieve this approach. Additionally, whilst it's practically taboo to write your own frameworks when others exist, offering you everything you need, I wouldn't mind learning how to write and then write my own. Thanks, Augustas
1. Windows has a lack of building tools support (like gcc and make) and so all of those need to be installed and configured as well as all the dependencies. ALTHOUGH JUST FOUND OUT YOU ARE IN LUCK! http://rubyinstaller.org/downloads/ RubyInstaller just updated to 2.3.0! Great news as I have a cross-platform project I am working on that I'd like to move to 2.3.0 but couldn't because of the reasons I talked about earlier. 2. I spent a little time looking it up and found this guy -&gt; https://github.com/phusion/traveling-ruby very fresh and active development. Might work a but better for what you want. This will also make packages for Linux and Apple. 3. Gosu would work for this 100%. Anyways, keep us all updated on what you get done! We love to see what people can get done in this language!
Sure, blame the axe for not being a hammer (tools analogy, he he). Rails isn't optimized for teaching less experienced devs how to write "good" code. If it would be, nobody would be using it because there are better frameworks written in better languages (Java most likely) that are more suited for that use case (e.g. big teams, big complicated apps). It's strange that people expect Rails to always provide for everyone's use case and preferences and be easy to use at the same time. If Rails wouldn't have auto-loading constants, a very fat/rich ActiveRecord implementation and other crap, it wouldn't be as nice to use or popular. At least that's why I use Rails, not because I'm a fan of active record.
Chef is ruby with a dsl that provides the built in patterns. You can do anything you want with ruby using class and module namespacing and just as easily call it from your recipes and other prescribed structures/patterns. 
That suppress feature is a disaster. The very definition of non-local magic.
Am I missing the concept of the platform? Why monetise an algorithm? That seems like a bad path to go down and a slippery slope. At the end of the day, the industry has moved forward because of open source code. If I come up with a great algorithm, it is in my best interest to share it with others, have it improved upon, and contribute to the community. 
I've been using ruby for 6 years to build a mobile application with Rhomobile framework. It has some similarities to rails, like MVC framework, database, but it runs directly on the device, offline, and could be packaged to many operational systems, like Android, iOS, Windows Desktop, Windows Phone, and others. My application is an order collector, with data synced with the ERP, that is our company's lead product, used by hundreds of low and mid size companies. This framework is not broadly used to build mobile applications, but I recommend it.
Our platform allows for making your code open source, sharing with others and not monetizing if you choose to do so. We run the algorithms as a service so no matter in what language you implemented it anybody can access it. This is a way to democratize access to all sorts of algorithms (without needing to reimplement them).
Yeah I don't get it. Anyone designing an algorithm tends to either use it in house, open source it, or keep the whole implementation (which is where the real work usually is) closed source.
This is pretty retarded. Instead of engaging an a real conversation, which you wouldn't learn from anyway, here are the quotes that made me giggle the most: &gt; Your criticisms or Rails MVC falls off the map. &gt; Databases already provide validation &gt; the models is where your app lives. Just like your mental models are where you do all your thinking. &gt; You shouldn't be thinking with your optic nerves or validating beliefs with your motor functions. &gt; Neither should you be inventing organs that serve no function but to create leaky abstractions &gt; If I have to open more than 3 files [...] you are wasting everybody's time.
&gt; like repeating characters, like "aaaaaaab" or "c8c8c8c8" that I have no clue yet how are they going to be generated. `Array#repeated_permutation` does generate those cases, that is the difference from `Array#permutation`. `aaaaaaab` is the second result from the code I posted above with 8 characters, I didn't run the full result but `c8c8c8c8` should be in there too. 
That sounds a lot like they are replacing the controller with a Model. I suppose for a FE framework that doesn't have transactional operations that's okay, but as soon as you need a transaction or a step-by-step flow - you need a controller.
Awesome! I love reading stuff like this!
are you trying to find X and Y for top left and bottom right to enclose all points (knowing that you can easily figure out top right and bottom left points from those two)?
Is it me, or was there no real explanation why nginx was a SPOF, just that it was a component required for delivery?
If postgres goes down, we couldn't install gems, even though we were downloading from fastly. Now, we download directly from fastly and it doesn't matter if postgres is up. 
Bro.... sideqik?
Do the [fastly stats](https://docs.fastly.com/api/stats) not provide enough detail? Would mean that the S3 and SQS instances could be removed and the DelayedJob just pulls from there.
Fixed, I don't know where that came from, I was never dyslexic before! 
ActiveRecord Callbacks are up there with RJS for "worst ideas ever introduced to rails". Both solve(d) real problems in horribly lazy ways. 
bundle update --source gemname 
That's a great idea for an open source project. There should always be FOSS alternatives 
My impression is that ALL the stats were stored in redis, forever. Yes, this is obviously not using redis in a helpful way, that's what the OP says and why they changed it! 
When you say `todos.delete(:id)` you are literaly saying that you want to delete `:id` (a symbol) from the array. I think what you meant is `params[:id]`, but that still won't work because of the way your array is setup. So what I would do is this: todos = { 1 =&gt; { text: "Hello, world!" }, 2 =&gt; { text: "Pick up groceries", status: :complete } } This will allow you to do `todos.delete(params[:id])`. The reason this works is that I made the ids [hash keys](http://ruby-doc.org/core-2.3.1/Hash.html). 
It's one way, and it might be the right way, but it's kind of like saying a gas station attendant "works with metal".
Seems to me like the best way to remove a SPOF, if it didn't need to be a POF at all! I guess it would be more clear if you said that, sure. Removed a point of failure that had been a single point of failure, and didn't need to be a point of failure at all. Sure. (Clearly, postgres going down will still make _some_ things fail, likely pushing new gem versions for instance? Just not gem downloads, so long as they are cached in the CDN. At least in some cases a POF has been removed although exactly what cases is perhaps not as well specified and controlled as it should be. But clearly an improvement. It's not news that the rubygems infrastruture is a bit messy in some places.)
I wasn't really looking to modify the array. Doing the above actually breaks other functionality. Basically when the user clicks on a task the server gets an id (ex. 1,2,3). www.okay.com/1 I want to simply get that id and delete the corresponding item in the array. 
Well in that case, how about this? todos.delete_if { |todo| todo[:id] == params[:id] } 
 NoMethodError at /todos/2 undefined method `bytesize' for {:id=&gt;1, :text=&gt;"Hello, world!"}:Hash I am so new to this lol . edit* also I really appreciate the help
Try this: `todos.delete_if { |todo| todo[:id] == params[:id].to_i }` I added `to_i` because `params[:id]` is a string &amp; `todo[:id]` a number.
Hmm never had a problem with `--source` but I'll keep this in mind
I read the first couple of paragraphs but can't be arsed any more, you're just twisting my words to change the meaning of what I'm saying for the sake of arguing with me, if that isn't trolling I don't know what is. Basically, we agree for the most part, we're just spouting different jargon. Have a nice life
If it's a simple utility, check out shoes.
I don't understand how `--source` does anything useful with regard to this. Oh, on gems that you have in your Gemfile with a `github` source? Wait, are you doing that for most/all gems?
Does this include the 'new' generator to get it setup in the first place?
There are like 8.5m rubygems published, and counters should just be Redis string objects (or hash objects if you have multiple counters per gem). That shouldn't be taxing at all. I run redis nodes that use many gigabytes of RAM and they recover in seconds, not minutes. 45m for Redis recovery sounds *super* off to me.
And also no generation for migrations?
For some reason if I call Examplemodel.create as a before(:all) do action, it is not cleaned at the end of running RSpec. I'll have to look into database_cleaner
before(:all) is weird. It's also a pain in the butt to create data that you _want_ to be there for your whole test suite. Most of the solutions are geared towards making sure your database is empty at the beginning of _each_ test, because that's considered good testing practice to ensure you're avoiding any shared state. But it does slow things down a lot if you have some rows that really are just needed as seed data for the app to function properly. I guess best practice would be avoiding that, or at least avoiding dependency on it for most unit functionality. But if you really do want it to be there for the entire run without getting deleted, and you're only concerned that it's not deleted _after_ the run... I wouldn't worry about it. Who cares what's left there after the whole suite run? You can use database_cleaner just to make sure your database is emptied at the beginning of a suite run if you want. 
Here's the gem i wrote for mirroring a Jekyll site to S3: https://git.mblum.me/mblum/deploy_jekyll_s3
right, but you realize the article was not written by the researchers, right? It was written by a 'journalist'. 
This -- I can't even imagine a config that could accomplish this. I mean even with a 100M objects and a high latency bridge between your redis servers if you have saves setup properly the rollback and resync will be minutes. 
My workflow for updating a single gem is general `bundle update --source my_gem`. That sometimes fails due to another dependency being locked and I'll have to do something like `bundle update --source my_gem my_other_gem`. I don't know why this is called "source"; my guess is that it refers to "the thing that can be updated". Regardless, I've never run into any issues with this approach aside from having to do a chain of slowly adding other gems to my `--source` list
Disabling RubyGems increases speed a ton ... do you mean general execution speed? If so, why is that?
Now that Google Firebase is free and has support for SSL, there's really no reason to use Amazon S3. And S3 isn't a CDN by any means. And Firebase already ships toolkit for pushing sites. Go check it out. 
The style guide is nice and all, and I generally agree with it, but it's a guide only. I'd like you to look at the 5 line ugliness that is the "preferred" method, and the one line clarity that I wrote, and tell me with a straight face, that *in this instance*, where the clear intent is to get back a JSON result or nil anyways, that rescuing edge case exceptions as nil makes the code less comprehensible or clear. If this were part of a networking library, where each exception should be handled or re-raised, with wrapping into a common library exception class, to allow library users to do the right thing in all cases, then sure. Do the verbose thing, make it clear. Document how each exception is handled, have test cases. 99% of the time, this type of code is in some nightly cron task or whatever, or is an internal tool, and you just want a result and not to have to futz with a dozen lines of code to just get that result. If it fails in any way, you're going to fail out with "Unable to download or parse JSON, please contact support". In that case, the verbose, handle-each-exception-manually approach is a huge waste of time and makes the code *less* clear. Ruby is about brevity and elegance. Inline nil rescues for uninteresting edge cases is, in my (not so) humble opinion, a really nice feature.
I picked it up in a Github issue awhile ago https://github.com/bundler/bundler/issues/2016. Suppose I'm using Rails and Rack in my project and neither is version constrained in my Gemfile. `bundle update rails` will generally try to update Rails and all of its dependencies by default, so my Rack version is at risk of changing (not good in a large system where you want to make small changes and then test between them to easily identify breaking changes). `bundle update --source rails` is different because it doesn't let the Rack version change. To allow Rack to change as well (and say not Sprockets or something) I could do `bundle update --source rails rack`
I generally agree. But I suggest you think it over whether you really want to return nil immediately and choke the exception no matter what. I'd rather do something like `open(...) rescue handle nil` and make `def handle ret` report the error to Bugsnag, then return the value.
Thanks for sharing! Looks like a nice library; I like that it has Hanami and Sequel support. 
Thanks! Sequel is my ORM of choice, so support for it was a must :). Hanami support needs to be updated, though, I have it on the TODO list. Although Shrine is designed to be hackable, it's a bit strange to use it with a repository pattern like Hanami::Model.
In this case `rescue nil` won't let you easily do something else only in the event of an exception.
&gt; enum: 25847.6 i/s - 23.04x slower Interesting to see that the enum solution is that much slower than the other ones. 
&gt; It has been easier to update and extend those libraries than to contemplate moving the whole thing into a newer framework. Ten-year-old code that's been easy to update? Well done, how admirable!
What would an ELI5 of rescue be like? I'm having trouble Googling one since the resources tend not to start at the basics with this.
`rescue` is Ruby's exception handling construct, similar to try/catch in Java or JS. http://rubylearning.com/satishtalim/ruby_exceptions.html
Ruby tries to execute each line from *begin* to *rescue*. If they finish, then execution skips to the *end*. If there is an exception raised, the code between *rescue* and *end* are run. The *Net::ReadTimeout* is an optional argument, and means that ONLY the exception *Net::ReadTimeout* will be caught. If any other kind of exception is thrown, the code between *rescue* and *end* will not be run, and you will encounter an error as usual. /u/jemminger 's link is a good one. This one also details using *catch*: http://phrogz.net/programmingruby/tut_exceptions.html
Thanks! Last question. How can I test this scenario in RSpec?
Thanks!
You could try using the built in Benchmark utility and do some benchmarks yourself. 
They are small files and do no harm. But they can provide benefit. Some semver specs don't specify an actual number, but a range. So there is a point where committing you lock file gives you greater insight into the state of a project at any point in its lifetime. It _should_ be the case that you don't need this file, but I find in larger projects with no incentive of policing issues creep into version numbers or gems without version numbers specified and that tends to break fresh builds. So, all in all, it's not required but it does no harm and can help in certain situations. 
Sure, a connection pool probably makes sense. 
I guess the harm it could do is keep other developers and/or CI from testing with latest versions that satisfy your gemspec requirements. I'd at least re-bundle without it for CI (travis etc). If Gemfile.lock isn't in the repo to begin with, that'll happen anyway; if it is, I'd add a CI step that deletes it before bundle install'ing. That way you know tests are always running with the latest versions available that satisfy your gemspec -- the same situation someone doing a fresh install will have. If there's a failure with later versions of your dependencies you didn't have with your checked-in Gemfile.lock, you can change your code to fix/workaround, or you can change your gemspec to not allow the problematic version, and in either case re-release. 
"easy" -- always a relative term.
`while` and `until` perform the same, but `loop` can be slower than `while true`. [Benchmark here.](https://github.com/JuanitoFatas/fast-ruby#loop-vs-while-true-code) 
All `until` does is negate the predicate. It's analogous to `if` vs `unless`.
`while` and `until` are more or less identical performance wise, one generates `branchif`, one generates `branchunless` which differ only by an inverted conditional: https://github.com/ruby/ruby/blob/trunk/insns.def#L1193
&gt; Also, no need to commit your Gemfile.lock for libraries. There is no reason not to commit the lock file. Just as you don't want your dependencies (especially test) randomly shifting around in your application, you don't want them randomly shifting in a library. If your concern is to maintain testing against bleeding edge deps, you need to do more than just remove the lock file. Generally I use Gemnasium to automatically test dependency upgrades. 
If I remember correctly, the creator of [YARDoc](http://yardoc.org/) (lsegal) also worked on the Ruby AWS SDK.
If it's chrome only try turning off extensions or running it in incognito (assuming you don't have chrome extensions enable in incognito mode)
Wait for a CI failure email notification (say from a PR or a random small change you push), run `bundle update`, run tests, debug. If the `Gemfile.lock` was committed you'd never notice the regression, until a user reports it.
&gt; Wait for a CI failure email notification (say from a PR or a random small change you push) So you're depending on random luck of timing to locate regressions. That sucks. &gt; If the Gemfile.lock was committed you'd never notice the regression, until a user reports it. Or you could actually do proper regression testing, there are several services to do this for you, I use Gemnasium's auto-update feature run nightly.
It sounds like Turbolinks. The `page:load` event doesn't fire the first time a page is loaded, but fires when you click links on the page. Conversely, the jQuery document ready event fires the first time a page is loaded, but not on subsequent pages thanks to Turbolinks. 
&gt; So you're depending on random luck of timing to locate regressions. That sucks. I could probably setup recurring CI testing. I'll look into Gemnasium, but I'd rather not pay for yet-another-service.
Hi DerNalia, what packages you are using for ruby development in Atom.
disable turbolinks. 
https://www.reddit.com/r/ruby/comments/4j308b/mini_racer_a_lightweight_alternative_to/
When I read articles like this, I always try to keep an open mind hoping that I'll learn something new about rails or it will change my point of view ultimately changing how I program. My first version of rails was 1.1.6, and still today I love it just as much. I work on massive apps that become a mess in the code base, but that's what I get paid to do. I come in to work, work on my stuff then go home. 
I like but don't love Rails. I think that trying to make things just work simply is the right goal (disagreeing with solnic). It's a goal that comes with certain pitfalls and dangers though. I think that the directions solnic recommends will lead to different pitfalls with different complaints. Software design is hard. There are also some problems you only notice with mature software. There are _definitely_ decisions Rails has made that in retrospect seem like bad ones. It's hard to avoid these. When you have new software you might think you have, but when it becomes mature, like Rails, you'll still have some. A more diverse ecosystem is great. I wish solnic luck. Personally, I suspect that not doing any work to make your stuff compatible with Rails (while not dependent on it), will harm adoption, and ultimately harm efforts to develop more of an ecosystem/community not dependent on Rails -- using something as a dependency in Rails can be a gateway to moving away from Rails. On the other hand, that hasn't worked out with Sequel so much, it's still kind of a niche, not being used as much as it could be within Rails, let alone moving people away from Rails. (On the other hand, it helped move solnic away from Rails!). So I dunno. Software is hard. I've got no real problems with ActiveSupport, and think ActiveRecord these days is actually pretty decent, after moving to Arel, although Sequel is definitely great. Post-arel ActiveRecord is much more similar to Sequel and eliminates many (but _def_ not all) of it's major pain points vs Sequel. I do increasingly have increasing concerns about the choices dhh in particular makes for Rails. ActiveRecord `suppress` is a really terrible idea. So I just won't use it, sure, but if/as my dependencies start using it, very unpleasant. I do like (but not love) Rails, but I'm not super optimistic about the directions it's heading. We will see. I am also not super optimistic about the directions solnic is heading, they seem likely to be much harder to work with than I'd like, they're kind of approaching Java-levels of architectural complexity -- which _can_ make things less coupled, solving some problems, but causing other ease-of-use and complexity problems. 
The ease of use will be provided by Hanami. I'm just not interested in building frameworks so I'm putting more effort into lower-level stuff. We're quite aware of what kind of convenience people expect from libs/frameworks in Ruby, but we want to provide that on top of really solid foundations.
&gt; We're quite aware of what kind of convenience people expect from libs/frameworks in Ruby And that's great! Many that advocate for "moar OO" in Ruby projects don't have that awareness, which instantly relegates their projects to obscurity. 
&gt; You are an idealist, in a community of pragmatists If you ever worked with me, you would know how pragmatic I am. &gt; I'm sorry if you think that people who are wrong shouldn't be told that they are (TDD is dead, etc) What is "wrong" is up for a debate, and saying absolute statements like "TDD is dead" only results in cargo-culting by less experienced devs. &gt; Convenience doesn't waste man hours The way it's done in Rails actually does waste man hours. See my other comment about the ease of use in this thread. I understand the value of the ease of use. &gt; don't forget the social aspects of coding, and the benefits of building something that is teachable over something that is purist. Thanks but I'm aware of that, being involved with OSS teaches you a lot about the social aspects of coding.
I agree completely with the above comment. I think that many rails contributors have in fact been trying to do that for years (especially rails 3.0 and post)... it's just really hard, and they've sometimes failed, and in other cases other rails contributors have had different aims. (And I share the skepticism over whether dhh's leadership has always been helpful). If a project is trying to make nice DSL's on top of smaller decoupled pieces, two extremes ends of architectural failure might be: 1. Successfully made some nice small decoupled pieces which are great considered in-and-of-themselves, but the nice DSL didn't emerge, it's not nice at all, it requires too much tinkering and connecting to actually build something, and too much contextual knowledge of how all the many many individual pieces work. 2. Succesfully made a really nice easy to use top-level API (I don't really like the term 'DSL', in ruby all we mean by "DSL" is a high-level API) which serves a lot of use cases very flexibly, letting you write just the right amount of code for the unique things you are trying to do without boilerplate -- but under-the-hood it's a big mess, the individual pieces are too tightly coupled and not flexible enough. These are exagerated extremes, most things will fall somewhere in the middle on both axes (plus there are more axes!). Of course the holy grail is both at once -- but it's hard, and harder the more expansive and complex the domain. It's easier to write special purpose tools that suceed architecturally in this way, than it is with general purpose ones. But anyway, project developers could, I guess decide for any given project, knowing that of course we want the 'holy grail' but might not succeed -- what to prioritize? Better to risk less good "DSL" for better under-the-hood organization, or better to risk mess under the hood for optimal DSL? It's clear what Rails has overall chosen. Although I think Rails _is also_ trying, by and large, to achieve both (esp post 3.0, that's what the 3.0 eating-of-merb was really about, Rails devs deciding, of _course_ we want to try to do that too!) -- it hasn't always succeeded, which is not a surprise, this stuff is _hard_, it can be attractive to hubristically think "if _I_ was just responsible and could write it from scratch, I'd know how to do it better" -- I've gone down that path a couple times in my own career, only to wind up creating my own mess (in the best case, a _different sort_ of mess, whose differences are educational :) ). In Rails, when it has to choose something to sacrifice, Rails generally chooses under the hood to be sacrificed -- some of this is also just the result of legacy, I think _any_ very mature software will start having some of these challenges. There are design and architectural lessons we can learn only from mature/robust libraries/frameworks, which is why while it's good to have a diverse ecosystem, it's also good for everyone not to be constantly deserting the mature/robust/creaky thing for the new shiny -- they're missing out on learning the lessons you can only learn from the _failures_ as well as successes of a mature codebase, and the new shiny will eventually need those lessons too. Anyway, choosing to prioritize under the hood architecture even at the expense of a good high-level API when necessary is legit -- but the risk is, if the top level API isn't _good enough_ for common use cases, nobody will want to use the thing, even if it's a joy to develop. We could talk about the current state of Javasript -- an ecosystem developed that has by and large prioritized above all else de-coupled components that make no assumptions about anything else -- it has not resulted in an environment that most people are finding joyful to use, as people are starting to realize, cf 'javascript fatigue'. On the other hand, javascript efforts to make an all-in-one great top-level integrated API instead of focusing on decoupled components (Ember?) have _also_ not succeeded (at least as far as popularity). And definitely nobody's succeeded at accomplishing both... yet? As a _consumer_ of a library, which would I prefer? Definitely a great high-level API even if under the hood is a mess -- _until_ I need something it doesn't do, or need to re-use one of the parts in a different context then the monolith was written for, and then I want a small decoupled component that just does one thing well, haha. Of course we'd all like to have all the unicorns and ponies at once! To accomplish it just takes a lot of developer-hours, from highly skilled and experienced developers, who share a vision, and also understand the domain very very well -- and still have a chance of failure. On balance, I think Rails has done pretty well, it's success/popularity is not just a coincidence -- although I continue to really not like some of the decisions being made (again, AR suppress, wth are you thinking? spring, a not-ready-for-primetime workaround to slow starts, out of a surrender to actually solving the real problem, slow starts. dev-mode auto-reloading has never worked simply or reliably and messes up code in mysterious ways-- but on the other hand does make dev more efficient when it's not screwing things up, i do always miss it when i turn it off. turbolinks, should not be in rails by default and should never have been. etc etc. )
The code-schools and inclusiveness drives flooded the market with sub-par developers, driving down salaries. In turn, the talent has left for greener pastures. Now the Ruby community doesn't have the skills and/or dedication to fix the Rails design issues, and the ecosystem will become less competitive month-by-month.
Is it ironic that [solnic decided Virtus was not a good approach after all](https://www.reddit.com/r/ruby/comments/3sjb24/virtus_to_be_abandoned_by_its_creator/)?
 array.sort(&amp;:date) ?
I don't know what the heck that page is doing, but it is slow as hell to scroll. 
&gt; It's Ruby's loss that he'll be moving on. Rails' loss right? He said he's done with Rails not with Ruby.
&gt; Truth is, leaving Rails is also the beginning of my next journey - leaving Ruby as my primary language. I’ve been inspired by functional programming for the last couple of years. &gt; &gt; [...] &gt; &gt; Anyhow, I’m leaving Ruby. I’ve already started the process. It’s gonna take years, but that’s my direction. I will continue working on and supporting rom-rb, dry-rb, helping with hanami and trailblazer, so don’t worry, these projects are very important for me and it makes me very happy seeing the communities growing. Alas, no.
Ah, damn, I guess I glossed over that.
&gt; There are also some problems you only notice with mature software. There are definitely decisions Rails has made that in retrospect seem like bad ones. It's hard to avoid these. The biggest problem with Rails is that they **keep** making bad decisions. You've pointed out one later in your comment. Evaluating past decisions is fraught with hindsight bias, but that does not excuse the new nonsense.
I treat ruby/rails as psuedocode that somehow works in production, yeah its not great fit for large projects but it is a good platform when you are still in the unknown/unknown and unknown/known stages. Once your api is solidified and properly decoupled, it's not the best fit and other statically typed languages will offer superior performance.
You're right but I don't really think performance is the big problem. Maintainability is. And yes, that's why it's perfect if you're actually going to throw it away.
Because Rails won't let you make a headless app. Right.
The problem is, as /u/THeShinyHObbiest pointed, the alternative is lots and lots of boilerplate. Any and all frameworks contain their own set of magic. Heck, you think Rails is bad in that regard? Django has the whole user auth system automated, choke full of that magic. And I'm not even touching the whole low-level glue dedicated to making big web apps actually writeable.
I suppose you would rather live in a world where basic security mechanisms aren't included for juniors, things like injection, XSS and CSRF? So juniors can learn the hard way, by exposing people's personal information - or you can give them some "magic" and avoid a long drawn out conversation about cookie stealing, and cross site request forgery. Sure you could give a toddler a chainsaw and have him cut his arms off to teach him, if you want. We will disagree wholeheartedly that things work that way at all. In order for you to learn to drive, did you need to know how fuel injection systems work? Or did you learn by doing? As far as a teaching tool, it doesn't get better than Rails. Convenience DOESN'T waste man hours, by the very definition of it. Convention avoids having to spend hours architecting nuanced and unnecessary details, planning and speccing things out. You want waterfall! Enjoy repeating history. Working on teams adds complexity, so is Rails to blame for your inability to coordinate complexity amongst a team? Rails grows large applications just fine, as I can personally attest to having done just that multiple times, as well as the many, many successful large applications. Your statements are *factually* and *evidentially* wrong. I can bet you money that your scapegoating a language/framework/etc on the completely wrong thing. Have you really bothered to think it through, or do you just open a bad project and blame DHH instead of doing a git blame? TBH it sounds like there is loads of learning that should be done on all sides of this argument.
As someone who worked in Ruby/Rails for about five years, mainly because that's where the jobs were, I couldn't agree more. The biggest problem with Rails is that it's turned Ruby into a monoculture. Why can argue all the other points and come up with reasons for or against, but the monoculture is the real killer. I like Ruby, but Rails always became painful once a project got to any significant size and had requirements that didn't perfectly fit Rails' sweet spot. I can definitely understand why people like it though. It does have a very nice sweet spot. But once you're out of it, you're really fighting the framework. I would have loved to keep working with Ruby, because I love the language, but the Rails monoculture chokes out all other options. 
If want to be super awesome for your future self: let CI shout a warning about trying locally without that Gemfile.lock if the tests fail. 
No, because then rails really doesn't have any advantage. 
Sort of. Django rest framework makes it OK for those sort of tasks. It's less opinionated and magical, and for that reason it might well survive longer. 
You also have jekyll, is a lot bigger than Sinatra.
There's always [padrino](http://padrinorb.com/)... :) You don't have to leave Ruby to leave Rails.
Do UTC. As you noted it's it's mildly more complicated up-front. But in the long term, as requirements evolve, that small investment will quickly pay off.
Sorry to break it to you: but every project eventually 'outgrows' the framework, regardless of language/framework. Rails offers you a damn good start that none else offers you and Ruby is just beautiful. Go try php or java or c# land and you'll see the grass isn't greener. In fact it's usually mud.
You talked about frameworks, for me is a framework and the number 1 of any language: https://www.staticgen.com/
I'm talking about outgrowing it within six months, and some being a completely wrong fit for Rails completely. I have seen other stacks: Java, Scala, Node. (PHP? No argument here.) All had their issues, but none of them were nearly as monolithic as Rails, so when we hit problems, we could always adjust and bend the code to our will. Again, I am not shitting on Rails. If it works for you, more power to you. I take issue with the monoculture that the Ruby world has become. I'd love it if there were more options in the Ruby world other than Rails. I don't see why it's even controversial to say that. For all the churn in nodeland, I'll take a growing, changing, overwhelmingly diverse ecosystem built around an inferior language over the Ruby monoculture any day. Edit: Downvoted. Zed Shaw was right.
It also perplexes me how Python is so similar in language design and ecosystem, yet isn't criticized as heavily as Ruby.
And you can use the [tzinfo](https://github.com/tzinfo/tzinfo) library, this is what ActiveSupport delegates to internally.
After trying out different Ruby frameworks, I've found that [Roda](https://github.com/jeremyevans/roda) is perfect for me. It's super-advanced and simple at the same time, I even [wrote](http://twin.github.io/introduction-to-roda/) about it. For me Roda has many features that Rails doesn't have, due to its flexible design.
Misrepresentation! It took me about 12 minutes!
/u/solnic [would appear to agree](https://github.com/dry-rb/dry-web).
Why has turbolinks done this to me? Would you disable it or use some of the [Railscast](http://railscasts.com/episodes/390-turbolinks) tricks? His refactor which I added up to the original post works for me great. Which at first seems really cool. But then [this](http://staal.io/blog/2013/01/18/dangers-of-turbolinks/) keeps me weary.
&gt; I work on massive apps that become a mess in the code base, but that's what I get paid to do. Is this what "Optimize for programmer happiness" means? Build garbage, get paid? How low Ruby has sunk, that this is the top comment. You know, it's possible to care about your work and still go home at 5 o'clock.
There is also Ramaze. http://ramaze.net/
And Roda by the creator of Sequel
Why use a named function? $(document).on('ready page:load', function() { // Whatever setListeners does here });
Then how would I organize across the files within app/assets/javascripts?
Yes, you split it into multiple files for better organization and rails automatically concatenates them when serving application.js. In my example button1 and button2 blocks are in separate files but when loaded in browser, it is a single file with both blocks. You use .ready() in each file. Edit: with this approach you don't reuse names and selectors.
Thanks for the link, I'll definitely check it out.
&gt; 30,000 frequent users Performance is not the problem here. Maintainability is. Complex and therefore increasingly harder to maintain software is a problem in Rails land. It is certainly possible to grow a rails application and have it follow the market for years without it becoming one giant clusterfuck of tightly coupled spagetti. But that requires a lot of proper design decisions and a lot of discipline. You know, the stuff that is required to keep any software project in any language or any framework from growing into a bowl of spaggetti.
&gt; flooded the market with sub-par developers, driving down salaries. Sara: "We need a senior developer." Jim: "No way! We can get two juniors for the price of a senior." Sara: "But we don't have any seniors with enough time to train them?" Jim: "We'll just hire another senior developer for that." Sara: "..."
If your @current_player object is always of a different class, then yes this is going to fail on a few SOLID principles. As /u/notorious1212 has stated, needs bit more context. If both computer and player are both of the same inheritted base class, i don't see a problem with using is_a?. To me that sorts of satisfy inversion dependency by using code by convention. And i think that's a neat way of handling rather than creating a canHandle method. 
Generally I understand where the author is coming from. Even medium sized Rails projects are difficult to handle and the Rails community seems immune to change regarding more 'enterprisy' architectural patterns. I like how the [ActiveRecord pattern](http://www.martinfowler.com/eaaCatalog/activeRecord.html) says it's putting data access logic into the domain object, yet the authors criticizes: &gt; For a Rails developer, it’s not a problem that data coming from a web form are being sent to the depths of ActiveRecord where God knows what will happen. Which is exactly the point of ActiveRecord. He continues to criticize the coupling of framework components. I'm under the impression you can actually replace parts of Rails, but it's not very well documented and you are on your own. I agree Rails has a problem with simplicity: Rails was a new kind of framework, back then it made developing web applications so much easier. Because it solved a lot of the problems in a very opinionated way. You no longer had to decide on all the components, you just followed the Rails way. But this simplicity comes at a cost, you no longer control all aspects and straying from the way not only leads back to the old, slow and expensive way of developing software, you also inherited the complete Rails stack as a costly dependency. I think this is kind of normal, but the ease and simplicity of Rails may have made a lot of web devs forget how complex their problem domain actually is. Edit: Maybe it's not the devs, maybe it's the Rails shops which are not contributing back to the eco system, because they are used to get their web apps quick and dirty?
You're violating the "open for extension" part of OCP. Say, for example, you want to add different kinds of Computer opponents: `AgressiveComputer`, `CautiousComputer`, etc. Now your check breaks, because while these are computer players, their class name is no longer "Computer". i.e. That conditional has locked you in to always using one class for the Computer player. Whether or not you resolve the issue by adding an instance variable or not is immaterial. That is, after all, the point of encapsulation. The rest of your code shouldn't care *how* a player knows whether it's a computer or not, but it *should* be able to interrogate: `@current_player.is_computer?`. You could implement that using the exact same `if ...` you had before, if you want (though I wouldn't advise it), so long as the implementation is hidden, because now you can write: class AgressiveComputer ... def is_computer? true end end ...and everything will still work.
Yes, I loved Roda and despite its learning curve I really recommend checking it out. It shares a lot of the same values as my projects, in example a roda app is frozen at run-time, so I don't have to worry about any silly global mutable state floating around. I also like its plugin system, even though it may feel awkward initially, due to the way routing tree works, but it's super powerful and I dig it.
I really screwed up this section of my article as I see how many people got confused. I did not mean to complain about convenient interfaces, my criticism was about handling all these concerns **in the same layer**. Processing input from a web form does not belong to an ORM. But that's how it works in Rails. Furthermore, lack of decoupled validation makes that ORM much more complex and **less flexible**. You can, and often should, cover common scenarios with convenient interfaces or DSLs in order to avoid boilerplate. The problem is that **when you can't break things down into smaller steps** you will find yourself searching for workarounds and end up writing a ton of custom code that you really shouldn't be writting, as simpler, dedicated tools should exist already to provide you with the needed functionality. **This is not how Rails works** though, it misses a lot of abstractions, that's all. That's why I wrote rom-rb using decoupled components so that you can break things down into pieces when you need it. You have complete control over query logic and it doesn't even require you to do any tricks because the system provides you with all the APIs you need. That's why I wrote dry-validation because I think a standalone, pure data validation library, is much more flexible than a solution that's tied to an ORM. That's why I wrote dry-types because I think that complex coercion logic should be completely isolated. These tools are sort-of low-level, you can hide them behind simpler APIs and achieve your one-line-that-does-it-all, but the benefit is that **you have the underlying components available** when you need them.
Agreed, your shopping app example from the article reminded me of a legacy project I knew which should not have been done as a Rails monolith. I guess Rails makes this kind of mis-engineering really simple and my point would be most Rails shops don't know any better.
It seems a have a deja vu. Weren't there several articles about people leaving Rails? In general, Rails is suitable for some projects, but clearly not for all web applications. Developers are free to pick suitable tools. The article does a good job marketing solnic's new book ;)
&gt; I suppose you would rather live in a world where basic security mechanisms aren't included for juniors, things like injection, XSS and CSRF? Rails as a delivery mechanism is great. XSS protection is also something that basically every web project shares, and the code won't change. Rails as a container of business logic, when the domain complexity is high, can easily spin out of control.
See "Common Feedback/Questions" - I don't care about this book's potential financial profits, I don't even have time to write it, I want to do it because that's the only sensible way of explaining new concepts we're introducing. Writing this book is a huge effort that will suck my energy, take my personal time from my family and definitely burn me out. I'm doing this to help but obviously I need to read snarky comments with bullshit assumptions.
You might consider Jruby (jruby-complete.x.x.x.jar) if your clients have Java installed. Jruby is cross-platform and I'm sure you can find some java-tricks to make a setup-wizard for multiple platforms Jruby advantage is its "cross-platform" nature. The disadvantage is that requires Java installed - its a tradeoff
That's exactly how I feel. I love Ruby. Ruby is nice. But the Rails monoculture felt stifling. There are alternatives where I don't have to feel that way.
This is very disturbing, you know that right? I hope you'll figure this out somehow because that's not a healthy situation to be in.
Jruby + Java-swing - you need to at least understand java, to get your way with swing ("head first java" is enjoyable and enough - 1 week) - you need to be aware of how to use java from jruby (read chapter 1 and 2 and appendix B of "Using Jruby" - this is a morning) - finally you use jruby to drive the swing-java-classes and make your ui. You can use a Java-gui-editor like Netbeans to build a java-class containing the ui-components already in place, and then in ruby just subclass that java-swing-class and implement the callbacks. It gets really easy this way: java-gui-editor to "draw" controls, and ruby to implement the callbacks) As an added bonus of learning Java&amp;Jruby, you can use all java libraries you want from the huge java ecosystem, and keep your code in ruby! (And there is promissing work being done in jruby to make it much faster than MRI ruby... its a bold claim but seems solid - check out jruby + Graal + Truffle...) 
Out of uninvolved interest - how did it pass code review and get merged into the trunk then? If there are N core devs and N-1 believe something is bullshit, why was it shipped?
I never understood the point of concerns -- it's absolutely trivial to do the same thing just using regular modules and the `included` hook...
The rails architecture can hardly do anything else but beget a monolith. Sure, you can build small "microservices" that all appear to be smaller projects, but that does not actually inhibit the kind of coupling that monoliths are made of.
I think he brings up a lot of good points, and makes me feel like the recent posts we've had about people "leaving rails" is due to their own lack of understanding.
For me, string interpolations and trailing conditionals along with dot notation make code concise, readable and fun.
I agree, I think the Opal project and the Crystal-lang project are the future... Opal I think is already getting mindshare from the coffeescript crowd... Crystal is going thru some growing pains, but I can see it moving past Go in the next 5 years... &amp;nbsp; I look forward to something like the Volt framework based on Crystal and Opal... ( hint hint to anyone with at the Volt project? ) 
Ruby Web Framework: https://pakyow.org
Good ideas. Then why not just use Java, Kotlin or Groovy?
&gt;Processing input from a web form does not belong to an ORM. I do agree with this, but if you have a form with a list of parameters, and you want to make a record, there's really no need to introduce another layer. If you need to transform those parameters than sure, use something else to do so, but if you need to take a has of `album_name: "Q: Are we not men? A: We are DEVO!", artist_id: 1209, genre_id: 901, explicit: false` and turn it into an `Album` object, you might as well just use `Album.create(album_params)`. &gt;Furthermore, lack of decoupled validation makes that ORM much more complex and less flexible. I think that validation should be tied into the ORM's `create` routine so I don't ever accidentally make invalid objects. Really, I think that most of your validation should be in the database, and I wish Rails had a way to let you do that more easily. I haven't looked at `dry-validation`, but if it doesn't force you to validate before making a record, I think that's a problem. &gt;I think that complex coercion logic should be completely isolated. Complex logic should be isolated, yes, but I don't really think I need to use a separate object to turn the string `true` into the sql `'t'`. I tend to think that complex coercion in general should be avoided, and do so whenever possible. &gt;you can hide them behind simpler APIs and achieve your one-line-that-does-it-all, Okay, that's great, but do I have to write that API? Because, if I do, you've still generated a mountain of boilerplate for me to write. Yes, it will make certain things easier, but you're still increasing the time for me to get apps into production. Ideally, that simple API would be the default, and I'd have an easy escape hatch to get to the lower-level stuff if I need it. Rails doesn't quite accomplish that (trust me, I know that very well from all the raw `Arel` we have to use), but I think it's slightly better than being forced to do the boilerplate song-and-dance again. 
gotta play with this over the weekend. out of ignorant curiosity, does pakyow borrow ideas or lessons from volt, or is it entirely unrelated? also, thanks for the very well documented site to your framework. 
If we're going to talk about trust, maybe trust the community when they all shout in a chorus, "This is a terrible API that's rife with abuse"? If we're going to talk about trust, maybe we should all be using C++ since they too trust their developers with lots of sharp knives? Part of running a project is taking feedback and removing or redesigning things which have proven to be a constant source of pain.
Run away!
But Mike, David found this "pattern" to be very useful. He's chopping his carrots like a boss now.
People didn't move away from C++ because it provide sharp knife. But because it does provide spoon, so you are require to eat soup with a sharp knife. 
But they are *so awesome man*. I really liked when it [broke Virtus](https://github.com/solnic/virtus/issues/203) for others and made me debug it for hours.
I'm not sure if this can be solved on GitHub's side. I think unstaring is already effectively "down-voting". Also people can already make "deprecation" disclaimers in the README and GitHub description. I made one for [paperclip-dropbox](https://github.com/janko-m/paperclip-dropbox), although it doesn't always work because people are still staring it. So my way of helping is just trying to raise awareness :)
&gt; Yet it’d be hard even for people who would give up such freedom for some security that the power to change core classes and methods has doomed Ruby as a language. Wut
That's a great trick for easily making sure selector names are unique! And then for function names you just have to be careful?
A few things... First - you're calling `User.carts` with a capital "U", which is attempting to call a class method on the `User` model, not an instance method on your `user` object. Second, you'll probably need to call `save` in order to save the association and update the database after pushing your new cart record onto the user's carts. You'll likely also need to `cart.reload` after you save the user in order for it to pick up it's new association and have `cart.user` respond properly. Alternately, you can do `user.carts.create()` which will create the cart and associate it to the user in one shot.
Can confirm: RubyTapas kicks ass. Makes me a better programmer in general and Rubyist in particular. in before nice try avdi 
&gt; Ruby was a language with an incredibly small community. If it wasn't for Rails there really wouldn't be much Ruby. *Was* an incredibly small community. But now, why is Rails the only game in town? It's not perfect. It's not the be-all and end-all for web application architectures. &gt; it borrowed Perls 'there is more than one way to do it' approach So why is Rails considered the only way to build web apps with Ruby? Why not encourage other ways of approaching the problem? Maybe some ideas will suck, others will be good. Why the defensiveness about trying something different? Less people will leave Ruby. New ideas might provide inspiration for improving Rails. I remember when Ruby was the most exciting thing in web development. So much innovation was coming out of the community. Sass, Haml, Rspec, etc. All were completely fresh ways of approaching problems. I don't see that kind of innovation anymore.
I feel your pain a bit, because there is are a lot of new concepts. If you run into a problem - I suggest to come over to the official gitter channel - there about 300 of people there, and Nick Sutterer (creator of TRB) often hangs out there . We'd be glad to help you out - provide some advice. Also keep in mind that gems while at stable versions at the time of the book release, are moving ahead fast, and new improvements changes are introduced weekly. https://gitter.im/trailblazer/chat And the website - has the very nice docs as well : http://trailblazer.to/gems/cells/trailblazer.html Also Nick just wrote this guide 2 days ago - that could help you as well: http://trailblazer.to/guides/trailblazer-in-20-minutes.html 
That sounds condescending. DHH has always been... opinionated. As far as I can remember, he has always come off as if he and rails can do no wrong. It's always someone else's fault for not realizing his/rails genius. It's tiresome to say the least. People leave rails (aside from the magpie programmers) for a lot of good reasons. It's not the right answer for a lot of problems or people. 
Agreed. It should have been promoted to core a long time ago. Crystal has e.g. `5.minutes` built into Int.
&gt; [project name] is a modern [main function] library for Ruby applications. It is simple, yet powerful. This passes the boilerplate one-line project summary test.
&gt; The problem here is the same old rhetorical defense of Rails mistakes. Yup. I can't say this with 100% certainty but I'm pretty sure what prompted this new DHH post was [the recent criticism](https://medium.com/spritle-software/rails-5-activerecord-suppress-a-step-too-far-d7ec2e4ed027) of Rails' next awesome feature Suppress. [GitHub issue](https://github.com/rails/rails/issues/18847) [Reddit discussion](https://www.reddit.com/r/ruby/comments/4j3097/rails_5_activerecord_suppress_a_step_too_far/)
I like his content. I somewhat disagree that Ruby is dwindling. I think there's more content from larger players like pluralsite etc. that have marketing budgets and staff. The pie is getting bigger, but there are more players on the field (why are they playing on a pie field)? At the company I work for we have Ruby users as customers. We continue to grow and every year is the biggest and best. I think you should sign up for tapas as the content is great. Ruby, still not dying since last week. 
I really like Avdi's ruby tapas. I just wish he had a better site with streaming videos, search, and tagging like railscasts. I don't want to deal with downloading and maintaining files. I also found it to get really difficult to find the right video for reference as the number of videos went up. I'm considering re-subbing but a modern Ul with a video player would go a long way toward selling me on it. 
&gt; Seems like a lot of Rubyists eject to other languages at that point in their Ruby learning (self included) I've said this before on this subreddit, I don't think that's the case. You're only hearing from the squeaky wheels. There's also people leaving jobs at .NET or Java shops coming over to Ruby companies, but they don't make grand blog posts and huge statements about it, because why would they? It will always be in vouge to language bash and it will always be in vouge to "leave language X". The popularity of these posts does not always correlate directly to numbers. I don't believe Ruby is a language to be graduated from. It is wise to learn and use lots of languages. The number one reason I see people say they leave is due to performance, yet the amount of effort I see from these people around learning to make Ruby performant is pretty minimal. DHH recently had a great post "ruby is fast enough" which I think hit the nail on the head. Besides if you really __need__ speed, you should go straight to bare C. Even better, you can write C code and interface with your Ruby application through C extensions. Now not only are you using a new (super fast) language, you're still writing Ruby code. I've been using Rails since 2007, almost 9.5 years. I still wake up amazed at all the stuff there is to learn and do. Maybe people who __have__ to find another language to grow are either way smarter than me and already know everything, or they're not looking hard enough at Ruby.
Why do you care if someone broadcasts their financial situation to the world? Honestly curious. I don't find it compelling, myself, but I don't see a reason why it would bother someone.
I think it's fine. I believe he's being open an honest. Reading between the lines, it sounds like he's saying "hey this thing is kinda on the verge of being no longer financially interesting/viable to me, maybe we should do something about it". It's also fine for you to not like it, and not sign up as a result. I think far too many people in our community suffer for want of something without admitting it than the other way around. Even if it's not a hard need, it's nice that it is communicated. I would rather this scenario than a RailsCasts, where there's a very sudden sabbatical, then a year of silence, then we hear they're okay but no more content. As a developer I expect to earn more year over year, my output may remain constant but my quality goes up (I like to think). If Avdi worked for a regular company he could expect regular raises. I think it's fair as a small business owner to compare your earning potential currently to that of having a regular job. If moving back to a regular job makes sense, that's always an option. 
I've been using Ruby to do mostly non-web work since around when version 1.6 came out--that would be 1999 or so. # The dot-com My first job using Ruby was in a C++ shop that was going to make us all rich by optimizing BPG routing. I introduced Ruby where it was used to drive unit tests, create reports, and do other scripty things. There was a fellow who wrote a lot of Perl scripts; I showed him Ruby he started using it instead. Then the dot-com bubble burst, and that job with it, but the seed I had planted grew. # Utility billing I know you don't want to hear about Ruby web sites, but this ties in: The next Ruby job was creating a web site for managing billing for small utilities. This was with some of the guys I had worked with at the dot-com. Rails was not a thing then; we wrote Ruby cgi scripts. The web site we wrote was for managing billing for small utilites. One of its products was a data file that was sent to another company; that company turned the data into bills and mailed them. That matters because: # Document processing warehouse Remember the Perl guy at the dot-com, the one who started using Ruby instead? He landed a job at a "document processing warehouse." This is a place that took data files--spreadsheets, accounting data files, etc., turned them into printed statements, and mailed them out. Most of it was written in Python, but the Python guy was leaving. Instead of doing the sensible thing and hiring another Python guy, he hired me. We started writing tests (the system had _no_ tests), and then converting the system to Ruby. Most of the programmers I had infected with Ruby at the dot-com ended up working with us. There _was_ a web site, but it was CGI scripts again. Rails wasn't a thing when I started this job. As soon as the alpha version of Rails was released, we converted our CGI scripts to a Rails site. I worked on the web site from time to time, but it wasn't my main job. My main job was an enormous body of Ruby code that: * Did workflow management for uploaded customer data files, from the moment the customer uploaded them, through printing and mailing, and finally invoicing the customer. * Converted customer data files to our internal format * Converted that internal format to each customer's PostScript print image. * Glued it all together with cron jobs, FTP server scripts, inetd scripts, and so on. * Unit and integration tests for the whole thing * Ran the web site * Distributed the processing over a cluster There were about 700k lines of Ruby code, including unit tests. Unit tests were a bit less than 10% of the total; the application was covered mostly by integration tests. That 700k lines broke down into: * 50k - Rails web site * 400k - Customer specific parsing, image generation, etc. * 250k - Workflow engine, PostScript library, etc. I spent almost all my 10 years at this job in that 250k of infrastructure code, all of it Ruby (but not Rails). One of my new workplace's customers was the very same utility billing company that I had helped write a Ruby web site for in a previous gig. How cool is that? # I'm still not doing Rails In my current job, I am writing Ruby command-line programs that fetch data from one place--a database, or a RESTful service--transform it, and store it someplace else. These programs are nowhere near the scale of the previous job, but they are much too large and complex to be called "scripts." My boss is the same Perl programmer that I turned onto Ruby 15 years ago, and he's still a huge Ruby fan. Life is good. 
I'm unclear why `5.minutes` is worse than `5 * 60`. I use Ruby because it can be elegant to read and write. Agreed, top-level `select` sounds like a terrible addition but that doesn't mean there isn't room for human-oriented helper methods. I guess I'm not an AS hater like many here and find many of its additions useful.
Why does he have to support so many people? Are they ill? Can't you get private insurance that covers all your medical costs in the US? I wanted to buy his book, but it seems there's no paper version.
A zillion blog articles. Some misguided. Some not. Personally I prefer simpler tools. I don't like bloat. I disagree with some of the decisions made by rails team. I don't like dependencies with dependencies with dependencies with dependencies with dependencies with dependencies with dependencies; while not 100% unavoidable, you can mitigate it. Rails is fine for shitting out a CRUD for a new client every 2 months. For anything I actually care about and will live in for **many years**, I'll sacrifice the niceties. Rails started to lose me a few years back when there felt like a nonstop flurry of vulnerabilities. I still use many things I learned in Rails in my sinatra and python projects but I wont be reaching for it again when starting a new project. 
what is it with people saying communities are dying? The starcraft community does this all the time. And, like with ruby, the community is actually _growing_.
I'm not sure I'm following you. You can easily break down your application across domain boundaries and link the services together via http, amq or whatnot. But yes, chances are you're duplicating data across services, you have to deal with state a lot and you still got no real database because of ActiveRecord.
Thanks! I started as a Refile maintainer, because I really loved a lot of its ideas: ability to upload any IO-like objects, "storages" being simple POROs, direct/presigned uploads, a lot of the internal design. However, I realized that Refile is too opinionated for me. For example, I realized that having *my app* deal with on-the-fly processing doesn't suit me, but Refile wasn't designed for services Cloudinary, because it would have to generate Cloudinary URLs. And I also wanted to have the ability to process on upload. Support for background jobs was also what I wanted (and was [requested](https://github.com/refile/refile/issues/167)), but doesn't fit into Refile's current design. So I created [Shrine](https://github.com/janko-m/shrine), borrowing all the good parts from Refile, but making it really flexible so that it's suitable for everyone.
Please help /u/a_blue_ducks to not go broke. I play guitar for friends and family but it doesn't pay the bills. I could play pop music and make money, but I'd prefer to stick to obscure avant-garde music instead. Thanks!
RubyTapas is the best ruby-related video series out there now that Destroy All Software is gone. Highly recommended.
&gt; Curious why Haskel over Erlang or Elixir? I did some Erlang back in 2011, and I liked it quite a bit, but I didn't find Erlang to be a good general-purpose programming language. It is extremely good when you have a problem that fits the message-passing model (the typical example being chat), but it was hard for me to mentally map lots of other problems that way. I'm sure it was just my inexperience at that point, because people have built flight sims in Erlang in spite of its poor math performance. I also recall there being a dearth of web development frameworks at that time; now that Elixir has Phoenix (and Erlang has Chicago Boss and Cowboy), I think either would be an excellent choice for Web development since websites fit into the message-passing model pretty well. But why Haskell? Because although I think it's perfectly possible to write good software in Erlang/Elixir/Ruby/Clojure/C, I think Haskell has a good thrust-to-weight ratio of helping you write correct software without a lot of the baggage by letting the compiler do work (e.g. the types mean writing less code, including less test necessity), while also not getting in your way (e.g. by not making you write formal proofs). In addition, programming language (PL) research (which is backed up by real math, not the abstract art that is OO pattern evangelism), has a big focus on types, meaning advances there will trickle down into better tools for us programmers. To my knowledge PL research doesn't take OO seriously. &gt; I really like new features to Ruby, like the named arguments, it doesn't give us type checking or static code verification that you might get with something like types, however it's a step in the right direction. It could be. I've tried incorporating a sort-of gradual typing into my Ruby programs using [contracts.rb](https://egonschiele.github.io/contracts.ruby/), but I've found it to not be any better than a code comment above the method definition annotating what the expected input/output should be. I'm still getting runtime exceptions (albeit catching them early and failing fast instead of propagating bad data) instead of compile-time errors, and the error messages I get are very unhelpful when I have a semi-complicated contract compared to something the Elm or even Haskell compiler would give you for example. Perhaps Matz's implementation of gradual typing will be better though. I **have** found it useful to change my validation methods to return Right and Left-wrapped values (using the [kleisli](https://github.com/txus/kleisli) gem implementation; other people may prefer [dry-monads](http://dry-rb.org/gems/dry-monads/) or similar libs) rather than raising exceptions. But maybe that's just because I've been learning Haskell for a bit now. &gt; facebook still runs on PHP Perhaps, but I think there's a reason they're adding static typing in various ways, a la [Hack](http://hacklang.org/) and [Reason](https://facebook.github.io/reason/). I'll check out the linked talk, and look for the Gary Bernhardt one too. Thanks!
It has been [moved back under edgecase](https://github.com/edgecase/ruby_koans/pull/2). The latest .zip is [here](https://github.com/edgecase/ruby_koans/archive/master.zip). I imagine the site will be updated shortly.
It moved back a while ago, it just hasn't really been updated to reflect any changes because there's no need. A couple of days ago the `neo` account on GitHub was deleted and recreated, so it might spur an update on the website.
Part of the issue with Ruby in particular is a lot of the movers and shakers when it was experiencing a huge surge in popularity have moved on to other languages like Elixir and are vocal about them now. The other part of the issue is that Ruby isn't JavaScript/Elixir/Go/Rust, and is therefore not the new hotness and therefore is dead/dying/gasping for breath, pinned to a rock by a car in a ditch with the car being the only thing holding Ruby's intestines inside its body.
It's generally bad form to embed magic numbers in code. Constants are preferred, and because of that, if you use `Integer#minutes` from ActiveSupport, you will probably end up with code like this: class Foo MINUTES = 5 def bar MINUTES.minutes.ago end end Notice the redundancy that shows up the _moment_ I have assigned the actual value to a variable. This means that the benefit of `Integer#minutes` is only apparent when the primitive value is embedded directly in the code -- which is actually the least desirable place to put the primitive value. The other drawback of `Integer#minutes` (and, of course, the days/weeks counterparts) is that they are generally used when dealing with a time duration relative to another point in time -- usually "now." In those cases, you are going to want to be able specify the time source so that the behavior can be controlled properly for testing. Without the ability to control time, you'll need a timecop style gem to control time correctly. Now everything about what you're working on has grown vastly more elaborate and implicit. That's predictable: *implicit code always creates problems and then invites more implicit code to band-aid those problems.* And the cost inherent to this approach only goes up from there, unfortunately. In my experience, it often attracts picking arbitrary time values. An example might go something like this: "Okay, so I need to check to see if this background job has already been performed. I can do that by querying for recent jobs with the same ID. That could be slow... I know, I'll look for only recent jobs... say... _five minutes ago_." Why five minutes? Should it be longer? Shorter? Now, by the time enough thought has been put into exactly what the time window _ought_ to be, any time savings that `5.minutes.ago` might offer are insignificant. Yet the programmer probably _didn't_ put much thought into it. They threw `5.minutes.ago` in the code and moved on with their day.
This really reminds me of this article that [nearly half of Americans would have trouble finding $400 to pay for an emergency](http://www.theatlantic.com/magazine/archive/2016/05/my-secret-shame/476415/).
yeah, no...
I guess Rails just reached it's peak. It's pretty good at what it does but it can't change because of all the legacy code. One could argue that it would be better for Ruby community if Rails wasn't that dominant but maybe without Rails being what it is there wouldn't be any Ruby community at all.
How big? How do you quantify a rails app size? 40 or more background workers if that gives you any indication. Perhaps 25 models? 4 years on my longest running rails app. My legacy rails apps are all 3. I left before 4 was viable for production. (These are internal apps being replaced with SOA sinatra services) I use Datamapper in my ruby apps. I find myself having to explain the magic a lot to junior devs. There's stuff that's nice like model method delegation but getting hung up on random errors because of a dependency and being forced to do everything the rails way has worn on me. I think I starting using Rails around 2009/10? Again, I'm not saying it's bad. Just not my preference anymore. I don't mind writing slightly more boilerplate if everything is very explicit. I structure my sinatra and python web apps like a rails app, there's a lot of best practices baked in. There's a lot of other stuff too though. 
You could read his post. He goes into detail regarding his sources of income. The gist is he has his videos, books, and he teaches occasionally. 
Yep, I was self-employed for a while and was paying similar to what Avdi paid. Good news is the premiums are fully deductible, unless you're taxed as an S-corp with more than one employee (which I assume he isn't). He's definitely not a fan of the impact of the ACA: https://twitter.com/search?f=tweets&amp;vertical=default&amp;q=from%3Aavdi%20aca&amp;src=typd
&gt; Why does he have to support so many people? I believe he has six kids, plus his wife, plus himself. So that is the "eight people" he refers to I think.
What about it in particular seems bothersome to you? My final example shows both a GET and POST being handled in just a few lines of code. Granted, it'll get slightly longer when I start to demonstrate error handling, but it still feels like this is something anyone should be able to understand at a glance, especially when we keep the habit of having all the business logic executed by the command objects. The result is a set of routes that are both declarative and concerned with the HTTP consequences only. If setting up the container et al feels onerous to you, remember that this only needs to be done once for an application that scales to hundreds of routes and operations. In such an app, the routes would also be split up across multiple files, too, so no one file gets too big to comprehend individually.
That complacency might be worse news than any misfeature in Rails. If Dhh comes uo with a dumb idea, we need to tell him and we need to win. 
He's asking you to buy his book because of his financial situation, not because of the merits of the book. I would definitely consider that begging.
To get streaming I just inline HTML5 video tag inside episode's page. Looks like [this](http://i.imgur.com/UvDjHB7.png). Probably you could make some chrome extension for this. 
Also make sure to thank havenwood. He helped with [ruby-install](https://github.com/postmodern/ruby-install/commits/master?author=havenwood) in the early days and now maintains [ruby-versions](https://github.com/postmodern/ruby-versions).
1. put ruby tapas on patreon 2. get a job
I'm excited about the birth of dry-container, because in my opinion it allows any non-Rails app to achieve that sweet spot where it conveniently boots your whole app, but also allows you in tests to boot only parts of the app that you need, and that part of the app only requires the gems that it needs. With Rails this is simply not possible, of course. I think containers are a perfect place to put gem configuration, because that allows you to require the container, but only require gem/execute configuration that the component you're testing needs (e.g. models only require PostgreSQL connection, so it's not needed to connect to Redis, for example). However, registering *operations* (service objects) to containers is for me a weird thing to do, and adds a level of complexity. Why not just call the operation class directly? r.post do Operations::CreateArticle.call(params[:post]) # or Operations::CreateArticle.(params[:post]) r.redirect "/articles" end
Monkey-patching is about "reopening" a class to change its behavior at the runtime. Rails uses this technique via ActiveSupport which adds almost 70 methods to String.
&gt; Curious why Haskel over Erlang or Elixir? Didn't he answer this in his first paragraph? &gt; I find it difficult to write correct software in it. Tracing out all possible execution paths using tests is both difficult and not satisfactory for preventing bugs.
&gt; However, registering operations (service objects) to containers is for me a weird thing to do, and adds a level of complexity. Why not just call the operation class directly? Depends on your preferred level of decoupling. If you're OK that your router knows about your application constants, then just go ahead and use them directly. I find that such decoupling is really nice, as it allows you to re-arrange classes/modules w/o touching router at all. It happened to me many times already, both in Rails and in dry-web stack, so that's not a theory.
That's what gets me about this blog post. He is well known in the community, and he is talented with RoR. He would have no problem picking up some well paying freelance stuff, but he doesn't want to. I sincerely doubt that his two 2-4 min episodes take him 40+ hours a week. I read this as: "Hey guys, I have a pretty coushy job, I dont have to work too much, but sadly I dont get paid enough for the houses and shit I'm buying, so instead of working a bit harder, it would be great if you guys could give me some more money. Thanks."
I am, but my motivation behind dry-web is completely different. I'm not interested in building a framework. My explorations so far were mostly focused on code organization, object dependency resolution, code loading and isolation. We're using stuff like dry-container/auto-inject for DI and dry-component for code loading via good old `require` and simple LOAD_PATH management. dry-web supports roda already for a good start, but I already made it work with hanami in like 30 minutes, it's gonna be officially supported very soon too.
There is so much I learned from Avdi, and still so much to learn. For me it would be a terrible loss if he took some freelancing job and stopped producing RubyTapas. And he also feels this way, because he sees that people really like his content, and he also *feels* that what he's producing is special.
Do you think it was easy for him to come out like that? Have you ever worked on producing professional content for programmers? Did you record a screencast? Write an article? I worked with Avdi in the same consultancy for over a year. He's an honest, genuinely good person, insanely smart and talented. He took a huge risk of leaving consulting to focus on books and screencasts because that's what he felt he should do instead of fixing yet another Rails app. Think twice before making stupid assumptions.
&gt; Think twice before making stupid assumptions. I understand that you like the guy, and that his content is high quality. I dont want him to stop either, but the only assumption that I'm making, is that it doesn't take more than 40 hours a week to create two 2-4 minutes screencasts. Do you believe this is wrong? How long do you think it would take to create a 2-4 minute screencast? I also don't believe that it's an assumption. I did in fact, create screencasts to help my brother learn to program his arduino. I make 4 10 minutes screen casts a week for 4 weeks. I would say each one took me 1.5 hours. So about 10 minutes for each minute of final product. Mine were not the quality of Advi's, I freely admin that, but I would say that my "assumption" was grounded in some experience.
I subscribed to rubytapas two weeks ago, and I am binge-watching ever since. Awesome and entertaining. I want him to be able to continue doing these. That's why I am thankful for his openness, which gives me an opportunity to help before it's too late. 
That's true for all programming tho. It has nothing to do with Rails. Modeling complex domains requires domain knowledge, if you don't have that - then your gonna need to get used to tearing out the code you wrote as you learn that domain knowledge.
So, instead of having an ORM unpack those parameters, you want everybody (including juniors) to do it by hand?! Potentially/inevitably irresponsibly, and you think that will save time? Are you legitimately insane? But it gets better, "ActiveRecord doesn't provide an API over the entire SQL query language, therefore Rails sucks?", while we are talking about the *convenience* of "*secure by default*" that is only possible if you have "magic" functions that do it, and **I** am the one attacking a straw man? You can't be *that* blind and hypocritical. Oh, you are talking about other things in Rails? I was foolishly thinking we were talking about the things you said instead of the things you didn't. You must be right, I must have attacked a straw man, why else would you respond to a comment about secure-by-default with a bunch of whining about completely unrelated things, like ActiveRecord not duplicating all of SQL and Turbolinks. Speaking of that though, I am going to say ActiveRecord should NEVER even attempt to do that, especially when it already makes it as easy as passing a string. Turbolinks is far better than the bullshit front end frameworks that I actively disable whenever they are present because how crappy *they* have been designed (Angular), I don't need 2MB of boilerplate JS just so you can have some nifty APIs/DSLs that drain your customers batteries and and make scraping damn near impossible, thereby closing off a huge amount of openness and stifling innovations. "I like JSON so I'm going to render JSON just so I can then convert it into HTML, doing twice as much computation (escaping JS strings AND HTML entities), for literally no benefit what so ever!" - there's your straw man. Let me start by reminding you that having only one DOMContentLoaded event is how a SPA freaking works across the board, regardless of using Rails. Poor you will have to use delegate events. $(window).on('click', '#button1', fn), but your in luck because that is best practice and prevents complexity managing event handlers by centralizing them and binding them to selectors so they can be managed alongside CSS, where you otherwise would be spreading event handlers around like the plague. I would love a real conversation, but I simply don't see that happening with your attitude.
Sigh. I have been following all the fuss from the past week. The criticisms about Ruby/Rails are sound, but I think the fundamental issue is that there is no objective metric for what is considered good. Whether something is good is an opinion. All right, Rails' conventions and mechanisms may cause problems in the long term. But I think any solutions introduce their own problems that will piss off other people or that will piss you off in another context. I firmly believe that everything is about trade offs. I am in the camp that likes activesupport. I don't see anything wrong with 5.minutes. When I read the discussions between mperham and solnic et al I think it boils down more to taste than anything else. Can't argue with taste. All right, extending core classes can cause problems. But not extending core classes give me a different set of problems. Which set of problems you prefer is a matter of taste, and maybe circumstances too. There is no silver bullet. What I don't understand is why people are flocking to Node instead of, say, Python, which is much stricter than Ruby. It seems fashion is also a factor here. 
I'm only just looking into this so forgive me if I'm wrong, but does not dry-component ruin this idea? the actions are named based on the constants and so any reorganisation will lead to automatic renaming of the actions. you will then have to manually change the router and thus the situation is no different? this seems particularly relevant since the example does use dry-container
Take a look at [Ruby's keyword arguments](https://robots.thoughtbot.com/ruby-2-keyword-arguments) that were introduced in 2.0 and 2.1. They work almost identically to passing a hash, but provide an easier way to handle required and optional parameters. It is also easier to figure out what parameters the method takes.
no he didn't. he's just passing a hash, look at the way he defined `my_method`. I assume what u/symbioticremnant is talking about is this style of method definition: def my_method(b:, a:)
Changing a unique object identifier is simpler than changing object-building logic and wondering if you updated all the places where it affects the code. Our naming convention is a convenience, as otherwise we'd need a lot of boilerplate.
Back in the old days of ruby version `1.8.x` and `1.9.x`, a very common pattern you'd see in people's code was: def my_method(arg1, arg2, options={}) # .... end my_method("hello", "world", option1: 'woohoo!') ...With the idea that `arg1` and `arg2` were the "core" parameters for the method, whereas `options` were typically always optional (perhaps with some default value). Following this pattern would be an immediate improvement to your style, since this makes it clear (from the method signature) what parameters must be supplied. However, the technique is still somewhat flawed since you can't easily see what `options` are available/default to. Then along cam ruby version `2.0.0`, with its introduction of [keyword arguments](http://brainspec.com/blog/2012/10/08/keyword-arguments-ruby-2-0/). This was a real game-changer, because you could now write code like: def my_method(arg1, arg2, option1: 'default1', option2: 'default2') # .... end my_method("hello", "world", option2: 'awesome!') ... And as of ruby version `2.1.0`, [this was improved further](http://dev.venntro.com/2014/05/ruby-2-1-in-detail/) by incorporating **required** keyword arguments (i.e. *without* default values): def my_method(arg1, arg2, option1:, option2: 'default2') # .... end my_method("hello", "world", option2: 'will this work?') # NOPE. #=&gt; #&lt;ArgumentError: missing keyword: option1&gt; my_method("hello", "world", option1: 'will this work?') # YES. And then there's the [splat/double splat operators](https://dev.firmafon.dk/blog/drat-ruby-has-a-double-splat/), which take things even further... For the sake of brevity, I'll leave this as extended reading. TL;DR: Assuming you're using a modern ruby version (and you should be!), you should take advantage of its flexible syntax. Choose the right tool for each job; there is no strict "right way" to do things. I primarily use regular parameters and named parameters, as these provide the best clarity in the method definition. The old style of writing `options={}` (or as you can now do it, `**options`) is generally only a good idea if you have a *long* list of possible options which must be documented elsewhere.
Ah, you're right, I mistook the method call for a method signature. Ah, ruby. 
Wait, so he wants you to buy his book, so that he gets money? And that constitutes begging? Well shit, that's every advertisement ever.
I think they keywords arguments as others have pointed out cover a lot of use cases. No idea what their performance is like though. Typically I've used hashes as optional stuff, named parameters as required data. The nice thing about hashes/keyword arguments is that when you call the method, it's easy to know what each value you pass is for. Sometimes with named parameters that becomes more obscure. I still tend to use named a fair bit, but if you find a method becomes convoluted, but still needs to stay together, it's a nice tool to have.
`book_path(id: book.id)` is exactly how Rails used to work. Then they figured that 9 out of 10 times people use it to pass a model ID. Do you enjoy typing the same thing over and over again, knowing that the computer should be able to tell what you mean with less typing? I don't. There are sound arguments for not making `book_path` too smart. But there are equally sound arguments *for* making `book_path` smart. It is a choice, and each choice has its own set of pros and cons. Which choice is the better one depends on personal taste and circumstances. There is no silver bullet. You and solnic obviously fall in the camp that think `book_path` should be dumb. Let's agree to disagree. And I don't mean this in the useless-political-statement kind of way; I mean that there is no golden bullet, there is no pleasing everyone, and each choice is equally valid but you cannot satisfy everyone.
&gt; "Let's not learn SQL unless we learn how the database engine works"? No. The difference is abstraction versus using an API. I can `cp` a file just fine without *needing* to know how a File System works. I can store stuff in PostgreSQL just fine without a *needing* to know about the internals of its transaction locking. That does not mean that at some points it can be handy to know how `cp` differs from `mv` and why one can be a magnitude faster then the other. Or that I will never have to learn about transaction locking to fix a race-condition. SQL is an API. `create` an abstraction. I am not arguing against learning your framework. On contrary: I advise everyone to place some `debugger` breakpoints in their Rails stack and watch their messages propagate through the mazes of ActiveRecord. And learn a thing or two. I am saying that approaching `create` as an abstraction is fine. For most cases.
Your comments pretty much nailed it. I get the feeling that a lot of people want to see things in a very black-and-white manner. $X_APPROACH is bad, don't do it, $Y_APPROACH is obviously better. But "better" is subjective, and each choice has its own set of pros and cons. I don't know why people insist of viewing things in a black-and-white manner.
Discussion on hackernews: https://news.ycombinator.com/item?id=11757993
Also worth noting that the container key doesn't have to correspond to the constant name of the object that it resolves, it can be more abstract, i.e. `operations.comments.create`could resolve a ROM command, or a proc, or anything you want really. It's all about coding to the interface, rather than the implementation.
This is also something that I've been aware of for a while, I just forgot to create an issue. I think we should address this, just not sure of the best way to go about it at the moment and what is there fits the 95% use case.
&gt; my language is the best language Which is why i'm recommending you to use a different language? People skip over C when they talk about using different languages. It's a very valid and performant language. &gt; That doesn't mean there aren't perfectly viable use cases in the middle Yes, i'm arguing against the straw man of leaving Ruby due to looking for a faster language. 
I agree with this so much that I'm adding this comment in addition to +1'ing. DOUBLE WHAMMY
Ditto! We're under a heavily downvoted parent comment so I doubt many will notice.
Do you maintain a library? Do you use libraries? What are your deprecation questions?
I currently use this: rescue Errno::EINVAL, Errno::ECONNRESET, EOFError, Net::HTTPBadResponse, Net::HTTPHeaderSyntaxError, Net::ProtocolError, Net::OpenTimeout, Net::HTTPServerException, Net::HTTPFatalError, Mechanize::ResponseCodeError, OpenSSL::SSL::SSLError, Errno::EHOSTUNREACH, Mechanize::Error, Net::HTTP::Persistent::Error, Net::HTTPRetriableError It works at least. Would be glad to find something more shiny.
JRuby has extended the usefulness of Ruby beyond just Rails.
The capital was a typo. I will try the rest! Thanks!
Gods forgive me for this recommendation, but: I subscribe to Tapas via iTunes, and it does most of that for me (though you're right that there isn't any tagging, so the search is limited to episode titles).
The Python ecosystem is so much cleaner than the Ruby ecosystem, imo. And Python is used for so many cool things, as opposed to Ruby, which is mostly used for one really really really opinionated app development framework. 
That totally did the trick. And also I wasn't adding attributes to the created instances in the spec so they weren't actually saving since they had no IDs etc. One thing, now that it's time for user_carts to have some of it's own attributes, like checkout_progress and the like, do you know any good tips or resources for the specific practice of working with attributes on join tables? For instance, do I have to search a user's user_carts everytime to work with the correct one?
&gt; Second, you'll probably need to call save in order to save the association and update the database after pushing your new cart record onto the user's carts. This is not automatic behavior? Adding an association to a model is not automatically persisted to the database?
All programming? I have to disagree. Pure functional languages and/or statically typed languages tend to keep the complexity a lot more in check. Can you do a mess of you domain in Go? Sure can do. Is it going to be easier to sort out than a Rails monolith? On average my money is on "yes".
The title of the post is "Please help me to not go broke". Are you getting it yet? 
performance ought not to be an issue in this choice, except perhaps for the very most performance sensitive areas of code, and possibly not even there, I wouldn't even worry about it. And I think you're calling 'ordinary' arguments/parameters 'named parameters'? Most people would use 'named arguments'/parameters as a synonym for 'keyword arguments'/parameters. The 'ordinary' ones are positional, rather than named/keyword, because they are supplied based on position in the method call, rather than with a named keyword. 
that was shocking: http://www.codewars.com/kata/546d1328bed2e1e07a000f89
Hello fellow ex-coworker :wave:
I completely agree with you. It happens with everything. No different than with sports and people shitting on other teams. Or companies. Apple had a foot in the grave for years. Now it's Rails. I don't think anything could change this. Say Rails 6 is the fastest thing around. Ruby 3 is 3x faster, Rails 3x faster on top of that. Benchmarks show it's faster/easier/whatever than xyz. You'll still have the same people that have nothing better to do than discuss how shitty it is. Use whatever you want and be happy. Why try to convince the world that what you like is best? It's like when Aaron Patterson mentioned he uses puts for debugging. Lots of negative reactions with people going so far as to say he doesn't know what he's doing. All because he does things differently. Who the fuck cares? I don't use puts myself but more power to him if that's what works for him. I'll debate the merits of a language or framework but debating which is better as a whole is pointless. The best framework is the one that you are comfortable with and you're able to get work done. That's it. 
I don't know about turbolinks (haven't used them), but for organizing mountains of CoffeeScript/JavaScript code, I came up with a namespace function (since JavaScript has no native support for that kind of thing). Since then I have come across similar approaches in other projects. You can find the function here: https://github.com/nielsbuus/namespace Anyway, this deals with have to structure all your functions and variables into a tree structure. The next stuff is, how to load the right stuff on the right pages. I define an init function that I have the template to call explicitly, so basically I will have something like ns = namespace("admin.news.index") ns.init = -&gt; here goes all my ready code and in my template, I have this: $.ready( function() { admin.news.index.init(); } );
I use it for ETL stuff (millions of library records) because it has both faster straight-line performance and real threading. I also have used java libs (POI, for example) with much success and pleasure.
Yeah was a poor choice of words :)
Complexity != Domain Knowledge. This are two different things. Static languages do not adapt to change, so it's a trade off - not better/worse. Functional languages cannot handle state (monads), another trade off. Domain knowledge - understanding a domain, such as real estate, or retail. Complex domains - ex nuclear physics, quantum mechanics. I don't think we are communicating clearly. If you try to build a real estate website without knowing anything about real estate, be prepared to rewrite everything when you realize you don't understand escrow. This is why 'naming things' is the hardest part of software engineering. Obviously this has nothing to do with code complexity, which is either the fault of the developers creating inaccurate metaphors indirection or good ol' lazy hackety-hacks or your fault for not knowing enough about the domain (real estate) - in both cases Ruby and Rails have nothing to do with it, unless you are prone to scape goats or believe that it is the frameworks responsibility to *limit* the ways people can make use of it and treating their developers like infants who need rubber sheets in case they make a mess... I have had no problem at all sorting out complex messes in Rails. I'm sorry you haven't had success. Only two things have ever stopped me in my tracks. HTML/Code in the database and coworkers fears of invalidation. My comment stated simply, "it doesn't matter what language you write in, if you don't understand the thing you are trying to do with it". I find silly that you would disagree.
So here is why I unsubscribed: I really like rubytapas, but the episodes were coming out much faster than I could watch them and I just stopped after a while. I got overwhelmed and found I was forgetting most of content immediately anyway, unless it was something I could use that day. I also lost interest any time it was covering a large ongoing project, because I could barely keep it in my head from episode to episode. So great content, but not for me.
Perhaps, except I'm sure time is a substantially more common requirement in programs than distance or volume. I understand SRP and all that but `2.days.ago` and etc have done nothing but made programming Rails apps easier for me.
Heh, doesn't that describe most HN comment threads?
Ruby itself has also extended the usefulness of Ruby beyond just Rails
The pro is that you have one central definition of what a Location is that is consistent throughout your application. Improvements you make to the Location class are felt throughout the system, and you'll likely only have to write one adapter if you interact with third-party utilities or other objects where you need an abstraction layer. The con is that you increase the coupling of your system and risk complicating things if you need many different use-case-specific fields on the Location class. Changes to the Location class affect more parts of your system than it would if you used separate classes, so your system is more susceptible to errors occurring because of those changes. Both approaches can have some small performance implications depending on the use-case, but it's probably better not to worry about that at this point
I'm developing a JavaFX application with it. The why is somewhat more complicated.
I agree that was a slightly poor choice of words. I meant that Down is a thin wrapper around something that's already part of Ruby, so that it's not a full-blown dependency like e.g. rest-client which implements its own downloading (and much more). I guess what I wanted to say that compared to rest-client which adds 7 dependencies (and I don't know any other solution), a gem that is a wrapper around open-uri is a much more lightweight alternative for downloading.
That or people getting offended over benign things and writing bloviated missives to show everyone how smart they are. Stopped reading HN years ago, sad that it's still awful.
i've found this has a lot of good thoughts if you haven't read it -&gt; http://exceptionalruby.com/
lol. I ordered this yesterday to help out avdi. Thanks.
I'm using it to write worker/Unix daemon apps for enterprises that only allow java on their appservers by policy. It's nice just to deploy a jar file which includes everything needed to run the program. 
I always say languages are easy. Frameworks are hard (and take years to become earnestly fluent/idiomatic in). A lot of this is personal preference for me. 
&gt; All this while avoiding a few key things that I found ugly in Python and Perl ('self' parameters in instance methods, unreadable one-liners). To be clear, unreadable one-liners are still quite possible in Ruby, in part due to its Perl heritage (and in other part due to the tendency for code in any language to be unreadable at the hands of a sufficiently-"skilled" programmer). But yeah. I've effectively switched from Perl to Ruby for the vast majority of my "write simple scripts to do things" tasks.
I'm currently evaluating it as one option for some personal projects (read: games) I'd like to evolve from "floating around in my head" to "written out as code"; it'd be nice to be able to implement as much of the high-level logic as possible in a language like Ruby, and JRuby seems to be a decent combination of performance and portability. Julia, Chicken Scheme, and mruby are some other options I'm mulling over as well. Elixir is another language I'm considering (since it's what I'm using for my day job), but I'm not sure how well suited the Erlang ecosystem would be to that sort of use-case (I know it's great for game servers, but maybe not for the client).
I checked and you are right. Ruby is faster solving collatz on 1 to 100,000 than perl 5.22.2, python 2.7.11 and python 3.5.1. It's about 45 times faster than zsh and about a hundred times faster than bash. Both golang and C were an order of magnitude faster than ruby. So yes, ruby does appear to be the fastest scripting language. It's an open question how well my test reflects real life. I'm sure people have done better tests.
Thanks for the links. The website seems to be closer to what I wanted than the book, other than requiring an internet connection. :)
A database foreign key (an ID) is pretty much the only way to do it. I'm not sure what's going wrong with your tests. Are your pk ID's auto-generated integers from the database, or something else? 
This is a good example, thanks!
This is a good recap. Thank you :) 
&gt; It doesn't have the speed of python. not again. can we please put this misinformation to rest? &gt; There are only two reasons to use Ruby. Third reason to use Ruby: it's a joy to write code in. 
It's probably related, but it _ought_ not to cause a problem, typically. Plenty of people use factorygirl, foreign keys (that's what storing an ID to another row in the db record for a first row is called) and pg auto-increment keys together without a problem. Do you have any code that 'remembers' IDs in memory, not in a db row? FactoryGirl will clean out the db, but you still have that ID stored in a global/class variable somewhere, which now refers to the wrong id? I wrote [this gem](https://github.com/friendsoftheweb/lazy_global_record) to deal with a situation that your description reminds me of a bit. I _do not actually recommend that gem_ that I wrote and just linked to. It's better to figure out an architecture/pattern that makes it not neccesary, that gem is a last resort, I definitely don't recommend throwing it in without understanding exactly what's going on in your app first, and why what's going on is problematic. 
Do keep in mind you can mix and match. def some_method(positional1, positional2, required_keyword:, required_keyword2:, optional_keyword: default_value) All just rules of thumb, keyword arguments are there to make your API clearer and less confusing to use, do whatever results in that end. You've been using ruby/rails enough that you know what API's you've found easy to use and what you've found a pain to use right? Try to create ones that are easy, like the ones created by others you've used. 
I really wish that Crystal get more adoption. For sure, big web applications will continue to be written in Ruby, but there are a lot of tools that can get benefits from Crystal features.
Is this the appropriate sub?
I'm curious. Did anyone know who the 3 Martians were without having to look it up?
Did anyone not? Do I watch too many cartoons?
There's still a lot of work to be done but I'm really encouraged by what I have so far. Working with static types and generics has been easy, the compiler gives useful error messages and guarantees you'll never get a nil in your codebase, etc.
I'm pretty much just waiting for Crystal to support real parallellization before jumping over. The idea of code with a Ruby-syntax that can run cross multiple cores, yes please!
They're following the Go model of concurrency: expose Fibers (aka goroutines) to the end user today, possibly allow multiple threads to run those Fibers in the future. Right now only one thread will execute Fibers but that could change.
Will it be possible to operate some crystal workers alongside ruby workers?
I disagree with your example. I much prefer something like distance(origin: a, destination: b) Now I don't have to go to the method definition to find what each parameter should be - it's made explicit by the keyword arguments.
Hey solnic. I actually agreed with most of your rants in your post, but `IO.select` is a bad stone to grind your knife on. `IO` deals with file descriptors and `select` is a system call which queries for changes in file descriptors. It makes perfect sense for `IO` to have a `select` method. Whether or not 99% of developers have heard of it does not matter. Its the 1% who use it that matter because they dont have to delegate parts of their programs to system calls.
If rbenv is setup correctly, you shouldn't ever need to type prefix `gem install` with `sudo`. What's the output of `which ruby`? What's the output of `which rails`?
Super interesting. Anyone know if there is a subset of Ruby and Crystal that is common (and documented)? I wonder if it's practical to just compile to both until you can port
 Which ruby /Users/me/.rbenv/shims/ruby Which rails /usr/bin/rails
Uninstall using sudo, reinstall without sudo
How did you install rails? I'm surprised to see `/usr/bin/rails` for `which rails`. You may want to just `rm /usr/bin/rails`, and everything may work again. Not sure how that got there. Similar issue at https://github.com/rbenv/rbenv/issues/73
Right, you might have to `sudo rm /usr/bin/rails`, because permissions. But you may or may not want to go randomly deleting things on your system without understanding where they came from or if you really want them. I dunno. But I don't think that should be there, is my thought. 
Okay I shall wait for some more opinions before deleting things! 
That's pretty awesome, is there somewhere that I can look to see if I can be of any help as a developer to make this happen? 
This is the best I know of: https://github.com/crystal-lang/crystal/issues
Curious if you found the Gary Bernhardt talk. Sounds interesting but I cannot seem to find the recording.
Nope, couldn't find it because apparently he requested it not be posted (yet) https://twitter.com/strangeloop_stl/status/651940249761787904 https://twitter.com/rubyconf/status/671744684172034048 https://twitter.com/garybernhardt/status/669053935382958081
That was kind of the way I was going too, the only difference being it would be a mapping of the inferred keys to the keys you actually want to register as, i.e. it would register under `mapping.fetch(inferred_key, inferred_key)`, I think there is value in that as changing a dependency registered with the container means you only have to change it in one place, whereas if you used hard-coded class names, you'd have to change it everywhere you used it. Of course you "have to do some programming", it's not about making it all about configuration, it's just there to make life easier.
This question seems similar to "when do you need `each_with_index`?" 
Should've used Momar, Kimar, Girmar and Bomar.
Maybe so. But I'm curious to see what other people think. 
Nice work Mike.. again :)
Would it be possible for Shrine to support resumable uploads? The HTML5 File API allows you to split files and join them back up on the server but I've never seen a Ruby library that supports it well.
I went through the ruby koans and I really like tutorials point as a base documentation resource. I read http://ruby-doc.com/docs/ProgrammingRuby/ then also read the Cucumber book as well as the Meta programming Ruby book. 
Are you doing machine learning in Crystal?
It depends, I think. If the Notifier instance requires bits of information which the User instance has no business keeping track of, then pass it into the User during initialization. If its behavior is completely dependent on the User, then it's probably fine to initialize an instance within the User class. Java folks might be a bit aghast at this (muh dependency injection!), but in Ruby land, classes are much more malleable- instantiating an object is easier to hook into when testing.
A general rule I follow is: If it's a value object (e.g. `Money`) instantiate it in place, otherwise pass it in. In this case you'd pass in a `Notifier` instance as a dependency because it's not a value object but has behavior (with side-effects) associated with it.
I've been running crystal in production for almost a year now. It requires some extra work maintaining the code and I'd only recommend it if you know the risks and have acceptable solutions for it, but for me it worked out really well. I got over 6x performance increase on the response times.
I'd do `def notify(notifier = Notifier.new)` to allow for dependency injection while keeping the interface simple in the Base case. 
One thing to consider specifically tho is that you now have an implicit dependency on the class 'Notifier' existing in the first place... easy when it's just your project, but harder on a team or a larger, longer codebase. Think of this in terms of ruby's duck typing - when 'user.notify' is called, there should be some object that can be notified, no?. There's no rule that says it has to be an instance of the Notifier class. For maintenance purposes, it would be easier to inject as a param, than to ensure the Notifier class always satisfies User's needs (and classes can be passed as params too!). def notify(klass) notifier = klass.new #... end
`each_with_index`, or `with_index` can be useful for lots of situations where you need to keep a counter whilst looping. For example, only the other day I was writing something to generate an excel spreadsheet which included code like: data.each_with_index { |data, i| sheet[3, i] = data } Or as another example, suppose you only want to map *every other* element of an array in a different way: data.map.with_index { |data, i| i%2 == 0 ? do_something(data) : do_something_else(data) }
Honestly if you want to wrap your head around OOP-&gt;RDBMS, check out ActiveRecord. It's perfectly usable outside of rails as its own data layer. Also, it's a pretty thoroughly solved problem for most cases... Here's some code I used for a sqlite db in a single table app. Adding relations w/ active_record in a case like this would be trivial... require 'active_record' class Database class &lt;&lt; self def connect ActiveRecord::Base.establish_connection adapter: :sqlite3, database: "#{ File.expand_path '../db/somedata.db', __FILE__ }" end end end class Somedata &lt; ActiveRecord::Base end 
Why?
Pretty much this. It depends on the API you want though. If I'm doing some refactoring of existing code and want to break the code into a service object then I might not allow for injection
Cool. If your input data is already sorted then no big deal. I just wanted to outline the broad strokes one would take in solving this problem with few assumptions about the cleanliness of the inputs. Ruby's `each_cons` is a great construct for this kind of work.
Finally, awesome! That config option has been super-confusingly named forever. 
There is no change (that I'm aware of) to the functionality, just renamed a confusingly-named config parameter. If you needed DatabaseCleaner before, you probably still do, for whatever reasons you needed it before. No change. Except hopefully the less confusingly named config parameter will aid people in understanding what's actually going on -- maybe you never needed DC cleaner? I dunno! 
Obvious answer: they want to use Windows - not everyone is a Windows hater. I use OSX and Linux but Windows is a perfectly decent OS and the hate towards it by some is irrational.
I don't hate Windows, but it's the same argument when people say "Why are you trying to game on OS X? All *real* gamers play on Windows" There's something to be said for using the right tool for the job. Windows is a fine OS, but if you're going to be doing development outside of .NET, it seems like you'll find a stronger set of programming tools that are compatible with *NIX systems. It's the same reasoning behind why I'd ask someone "Why are you trying to paddle with a ping-pong paddle instead of an oar?"
I didn't come away with the actual answer to the title: how did they track down the corruption? Sounds like the answer was "we looked hard at a bunch of core dumps" but I'm not sure.
I didn't write the article but I know who did. If you ask a question I can probably pester them to either get an account and respond or I can respond.
It looks like they just noticed that a new Nokogiri release had a bug fix for something that could be their bug. This solved at least part of their issue, I guess looking at the core dumps might have helped for the final solution that they provided. But that's just as much guessing as you did.
What are the benefits of Ratpack over something like [Vert.x](http://vertx.io/)? Is the code in Ratpack less of callback hell?
I've already installed [libpcap (which should also be in the core ropository)[https://www.archlinux.org/packages/core/i686/libpcap/] but i can't seem to find libpcap-dev for Arch.
I wish the author would have brought his solution full circle and explain how his patch resolved the undefined method errors and why that issue with libxml-ruby only manifested itself in the production environment. Regardless, this is a good story of how you sometimes have to dig very deep into your dependencies to fix bugs. 
I don't need and probably wouldn't want the +/- additions/deletions, they'd probably be way too much for me. Although I suppose it could be an option -- press 'd' to see the diff. That'd be pretty sweet actually. And parallel to how other built-in git tools work, like `git rebase -i` and such. But the things I mention are absolutely vital, the tool is of no use to me without em! In fact, what I've often _really_ wanted is just a way to script "delete all remote tracking branches that no longer exist on the remote". You can do this with a bash pipe and some confusing git invocations I always have to google and am never sure if I got right -- that'd be a sweet thing to be built-into this tool too. 
Another good idea! I'll work on those this weekend. Maybe this could become just a general purpose git cleanup tool.
You will not get an answer because your question is far too vague
I don't know if this is symptom of your example but this code: notifier = Notifier.new notifier.send Would be my first point of question, why are you instantiating an object to call a single method on it? This may be for example reasons but it's worthwhile giving a more realistic example as it tends to shed light on where it should be constructed. e.g. What parameters are passed to `Notifier.new`, who should know about those parameters, etc. If there are no parameters passed and you're not constructing the object in some other way then I'd go back and ask 'why isn't this a class or module method instead of an instance method?'. 
I think there is sometimes a need for DatabaseCleaner, when you can't use transactional tests but still want to clear the database out after each run. I don't think that's built into Rails? DatabaseCleaner gives you more fine-grained control over exactly what's going on, which you can need when tests become a royal mess (oh, capybara). But yeah, lots of people are probably using DC who don't need it. 
Which part?
Did you verify that /usr/bin/env exists? It's fairly common, but by no means universal. Also, make sure that /usr/bin is in your path - "/usr/bin/env ruby" is the scripting equivalent of "which ruby" - so if /usr/bin isn't in your path for some reason you'll get errors like that. Also make sure that the symlink (/usr/bin/ruby) is valid (run /usr/bin/ruby $myscript)
Thanks for explaining. 90% of content on Reddit is either reposts or self posted. It's nice when other people care enough to share your content, but it rarely happens these days. That's the beauty of Reddit though if it's bad content downvote it, if it's good content who cares who wrote and who posted. I usually let people know that i'm monitoring comments so they can have a nice discussion like the 1 other comment left at the top level. Maybe someone else had a similar question and having Joe around to post a meaningful answer added to the conversation. Half the fun is having nice discussions with people about things you care about. 
good chat
yup
In case you're wondering, Python is virtualenv
Did you originally create your file in a windows environment? You can get that error if you've got dos file-endings.
And rubocop is a great tool for checking against that style guide.
also, Eloquent Ruby is a great book. http://eloquentruby.com/
same way as each other language ;)
I think it would be possible for Shrine to support resumable uploads, however I'm curious whether for files which are that large it's a better idea, instead of uploading them to the local filesystem (which I presume is what you want), to instead upload them directly to a 3rd-party storage which already supports resumable uploads. I'm not sure which 3rd-party services provide this, though, just thinking if it's worthwhile to reimplement this in Shrine's upload endpoint. If it turns out it has good use cases, I would need to first study [TUS](http://tus.io/), as this is probably the protocol we want to use. As far as I know, the only library that currently supports resumable uploads is [Attache](https://github.com/choonkeat/attache/blob/master/lib/attache.rb) ([middleware](https://github.com/choonkeat/attache/blob/master/lib/attache/tus/upload.rb)).
What about it?
thanks, I was pretty sure it wasn't pyenv but I couldn't remember and didn't feel like looking it up :) 
If you test with RSpec there is: http://betterspecs.org Not sure if there's a way to include that in an editor like what RuboCop does for Ruby syntax. 
I think this alternative is a _lot_ clearer, cleaner, and more straightforward, and the syntax for use is still plenty fine. module Slug def self.create(field: :name) Module.new do define_method :to_param do public_send(field).downcase.gsub /\W+/, '-' end end end end class Cat include Slug.create(field: 'hello') end I have occasionally done things like that. You can of course call the `create` method whatever you want. Perhaps `customize` is better. 
The problem with that is that `Slug` doesn't show up in `Cat`'s ancestry chain, iirc.
Okay then: module Slug def self.customize(field: :name) Module.new do include Slug define_method :to_param do public_send(field).downcase.gsub /\W+/, '-' end end end end class Cat include Slug.customize(field: 'hello') end Cat.ancestors # =&gt; [Cat, #&lt;Module:0x007fabf28fb3a8&gt;, Slug, Object, Kernel, BasicObject]
It's really strange to include `Slug` in the anonymous module just because of ancestry chain. I think it's still much nicer to include a `Slug` as a module, rather than creating an anonymous one, primarily because then there is no unreadable anonymous modules in the ancestry chain. Also, `Slug.customize` to me indicates that an instance of Slug or something related to it will come out. It's just my preference of reducing the amount of objects.
http://poignant.guide/ by "why the lucky stiff", just make sure to wear goggles before opening this book, that onion stings
Great post/analysis! I love this pattern in Ruby, and I've used it both in MiniMagick and Shrine. In Shrine it allowed me a lot of flexibility, It made it possible to include the same module in a Sequel model and in a Reform model, and it would generate different methods/behaviour depending on what it was included to. In this case I generated some method both on `#initialize` (static) and in `#included` (dynamic, depending on what it was included to).
[removed]
* If you actually care about the ancestry chain, then I don't think it's strange to include it just for the ancestry chain -- it's the most straightforward way to get something in your ancestry chain, including it! If you want something in your ancestry chain even though it has no methods, so it's not doing anything but serving as a token in the ancestry chain -- well, there are times you do want to do that, and you'd almost always use an `include` to do it, no? Isn't that the standard way? * You could also put methods in the actual `Slug` class, not just it's generated anonymous sub-class, if you had methods that didn't need to be parameterized, and then you wouldn't be including it "just" for the ancestry chain. But mainly, I find my version very clear as to what's going on, both on definition and when it's being called. * If I saw in someone's code `include Slug.create(:foo)`, then I'd know, "ah, there's a Slug.create method that returns a module, okay, I know where to go to look for it." Unusual but straightforward. It's just ordinary ruby, call one method `include` with an argument that's the return value of another method `Slug.customize`. And if I wasn't sure where to go to look for it, the old standard `Slug.method(:create).source_location` will tell me. * If I saw in someone's code `include Slug foo: bar`, I'd think "Wait, how the heck is that even legal ruby, what does it mean, how is it implemented, where do I look to see the implementation, what the heck is that?" I find the OP implementation needlessly abstruse for no gain, because I think `include Slug.customize(:param)` is a fine, and arguably even preferable, API, and I think my version of the implementation code is additionally more straightforward to understand what's going on -- it's just a module-method that returns an anonymous module, it's all right there in the code, if you'e seen anonymous modules before there's nothing whatsoever confusing about it; if you haven't, you have exactly one new device to learn, anonymous modules with `Module.new`. I find the OP version pretty confusing. These things are subjective of course, but that's my case! 
And if you need to do some Rails: https://github.com/bbatsov/rails-style-guide. Smaller but still worth checking out.
I thought The Well Grounded Rubyist was a good read.
&gt; If you would have non-parameterized methods in Slug, and parameterized methods in the anonymous module, then you would have included two modules which belong to the same feature. To me, that would be the _appropriate_ result. They are indeed two modules, one standard one shared across anyone using this module, and one dynamically created one special-purpose just for the point of use based on parameters. The second one will always be unique to the class that did the parameterized `include Slug.customize(name: 'foo')` -- because that's exactly what happened, an anonymous module was created per the specifications of the caller. I think that actually represents what's going on appropriately, I consider both those modules being in ancestors to be a desirable _upside_ as far as introspection, not a downside. It's not clear to me if either method is more flexible than the other, they seem equally flexible. 
wat
As a former PHP developer (for about 10 years), I agree. Not to break with my own peacemaking maxim of "different apps for different chaps," but I'm glad I'm not using it anymore. https://pbs.twimg.com/media/ArXcPfoCIAE1r0G.jpg
What you seem to think: Codes of conduct are nothing but drama Actuality: Following a Code of Conduct can prevent a career from mirroring that of Mel Gibson. A Code of Conduct actually helps people like you the most. A code of conduct gives you the chance to respond to accusations; a ladder, so you can get out of the hole you're digging right now. The old method was that any female/trans/gay person you offended would simply spread the word that you're transphobic behind your back; you might have no idea just how trashed your reputation has become.
Of course, that's what I meant. In fact, I use DatabaseCleaner when I need non-transactional tests.
I'm now a program developer for a very large e-commerce site. I build inyernal tools for use in our fulfillment process. A lot of this work is in rails development and database management. I originally started at a lower supervisory position that relied heavily on excel use. I started writing VBA scripts for various functions for my department, then later started getting requests from other departments as well. I became the go-to guy for excel in our building. I then started learning about html, css, and javascript for a project i wanted to work on. Than introduced me to rails. My primary tools for learning were online. Lynda.com is a great service with unlimited access for a monthly fee. Udemy has some great courses as well. The Complete Ruby on Rails Developer course by Mashrur Hosain is the one i took and would highly recommend. 
If your code snippet is exactly as you pasted it, you're missing a " redirect("index.erb) You're missing the closing quote. 
The onion in it is legit?
Check out [Practical Object-Oriented Design in Ruby](http://www.poodr.com/). It's a great read and many of the concepts Metz covers are applicable outside of Ruby.
How did you get the content type to nil? If no content type is given, it defaults to text/html. http://www.rubydoc.info/github/rack/rack/Rack/ContentType `use Rack::ContentType, "text/plain"`
You're brave to ask here. I consider Reddit the Mortal Kombat of feedback so it helps to have tough skin. It looks like you're doing a lot of good things with your code. One thing I need to say though is you've got all your objects pretty heavily coupled together. They're intermingled pretty heavily and know too much about each other. These go against all of the SOLID principles http://wall-skills.com/2013/solid-principles-for-maintainable-oo-code/ But I totally feel your pain on this one. I'm on my fourth rewrite of a card game because it's very hard to determine what objects should be responsible for what and how they should work together. I believe your best bet is to abstract away each category of control. For example the "Game" itself has two responsibilities 1) the state, and 2) the rules and logic. The Players are the only thing within the code that can initiate change. So what I propose is to separate the Game state out as just a state machine (like a database) and the Rules and Logic like an API. Then the players will be simple requests through the API abstraction which will be responsible for either a success or failure response and from their the API writes the new state to the game. As I said I'm on my fourth rewrite of a game because of too much code coupling. I believe following SOLID will require you to do a lot more decoupling. The easiest thing I found in game design is to separate the STATE/LOGIC/USER-ACTIONS as three separate entities. This is my big picture help from my experience. I'd go for dirt simple interactions between the User and API. They don't need to know what they don't need to know.
Hmm, in my eyes it's prettier if it's all in the same module, because it's all behaviour related to "Slug", be it static or dynamic. Making `Shrine::Attachment` a subclass of `Module` made it a first-class citizen, so I could add it to Shrine's plugin system by [including/extending it with modules](https://github.com/janko-m/shrine/blob/86e268b8b893db8ec68e7c2720b34cf948cc148d/lib/shrine.rb#L134-L135). Shrine::Attachment.include Shrine::Plugins::Sequel::AttachmentMethods module Shrine::Plugins::Sequel::AttachmentMethods def included(model) super # define Sequel callbacks end end class Photo &lt; Sequel::Model include Shrine::Attachment.new(:image) end If I was creating an anonymous module instead, I would have to do boilerplate work in each plugin that wants to extend `Shrine::Attachment`: Shrine::Attachment.extend Shrine::Plugins::Sequel::AttachmentClassMethods module Shrine::Plugins::Sequel::AttachmentClassMethods def create(options) module = super module.extend Shrine::Plugins::Sequel::AttachmentMethods module end end Of course, this *is* an advanced use case, but I just wanted to illustrate how in these cases it really does make things more flexible.
I think you were trying to make this ¯\\\_(ツ)\_/¯! Type it like this ¯\\\\\\\_(ツ)\_/¯ ^^I ^^am ^^a ^^bot, ^^visit ^^/r/ArmFixerBot ^^for ^^more ^^info!
Yes! Let us know how it goes. Specifically: Was the instruction clear? Did the videos engage the students? Did they watch the whole time? What did they really enjoy about the course? What did they think could be better about the course? Those questions are both for you and the students. Also let us know if you run into any problems! Thank you!
Thank you for the suggestions. We'll start with /r/learnruby!
This just seems like a terrible way to solve this problem. I guess I don't really get the Rails way of doing things.
This website is not mobile responsive. R u really expecting me to be coding at my desktop?
You sort of could access your models from javascript. If you have something like `@user = User.first` and in your view, had something where you convert the model over to a whitelisted of attributes, you could add them do a data element. `&lt;%= content_tag :div, @user.first_name, data: { user_data: @user.as_json(only: [:id, :username]) } %&gt;` From here, you could access the div's data elements values. In this case, careful with underscores in the data elements as it will be converted to a dash.
This seems needlessly complicated. http://rscss.io/ is pretty close to how I handle modular styling on Rails. 
This is the initial public release and I haven't had the opportunity to cross-check it actually works as-advertised on various OSes. I would strongly appreciate if people could use strace or equivalent tooling to verify the expected system calls are being used to generate random numbers.
You could also do something like &lt;script&gt; window.myuser = @user.to_json &lt;/script&gt; instead of having to pull things out of a display element. Thats a trite/simplified example but there are more complete solutions like https://github.com/gazay/gon. I haven't done any rails for a year or so undoubtable there are hot new trendy ways to do it. Most of my time I was only writing an API with rails then having the JS call to that for data. I'd also more often embed some values as `data-first-name="@user.first_name"`^1 attributes attached to relevant elements in the page. That way things are at bit more localised instead of just dumping everything into some global js var. Most front end frameworks integrate well with data-attributes too. 1. Possibly it was something like `data-first-name="@user.first_name.to_json"` to avoid any encoding issues. 
what's the age range you are targeting? I'd like to recommend this to friends who are also teaching at the middle-school and high-school levels.
Haven't seen the `gon` gem before. Personally, if I want my js to interact with model data or some other sort of structured data provided by rails, I will usually have a data attribute with a url that contains the data. This allows for easier caching of retrieved data and keeps most of the logic where it belongs. I've used this for stuff like gathering initial data for charts and calendars.
Great question! We're targeting ages 10 - 18 so middle school to high school would be perfect. Thanks in advance for recommending us! If they have any specific questions shoot us an email at info@techrocket.com!
Thank you for your feedback! Haha I guess I need the best constructive criticism I can get! Anyway, I can't stress how frustrated I am with myself because I cannot get a grasp on understanding the SOLID principles... Your post helped me understand a bit more on what I need to do in terms of separating concerns. Besides my objects being coupled, do you have any other feedback to give?
This is so great to hear. Thank you for the kind words! We still have a long way to go, but we're excited for the journey!
I'd like to use this opportunity to thank you for it. I know you've had some negative responses to promoting Roda on reddit and think it's important to hear some positive feedback, too :) I hope you continue writing about it. I am considering Roda+Sequel for my next side project. 
Basic question here. I only use libsodium for crypto and I make an effort to only use higher level security-related gems that rely on libsodium (e.g., JOSE for JWTs). Is there any way for me to check if SecureRandom is still being used somewhere in my stack without me realizing?
But you can. Just add a file.js.erb in your views. Fill it with javascript and use ruby variables like Var foo = "&lt;% @bar.to_s %&gt;"
You could monkey patch common SecureRandom functions to just throw an exception?
Can confirm, correctly calls getrandom() on Arch Linux, 4.4.0 kernel.
Have you considered using refinements instead of monkey patching for the CoreExt part?
I was so happy to see this. Definitely trying this out in my projects. We need more libraries like this, nice, concise, monkey-patch-free abstraction (yes, I know it has an opt-in core-ext but it's clearly described that it's not *the* way of using this lib).
you didn't get the memo, ember isn't cool anymore. It's all react, nig.
Why is react any better? Imo, it serves a different purpose. To enhance server side rendered pages. 
react + flux replaces ember, it's a better approach -- faster, more agile design, more 'modern' in nearly every way. Ember is a monolithic, hulking, slow, over-engineered piece of shit.
Of course, but from my experience: people love to copy code from internet without trying to understand it, unfortunately.
Do you know of any good articles comparing the two approaches?
It's important to note that **any?** checks ***EVERY*** element in the collection, while **include?** shall check the elements until find the first ocurrence. That's said, I prefer to use **include?** to check the existence of an element or **detect** if the comparison isn't straightforward between objects.
Why not use Open3?
sqlite3 and pg both refer to databases. pg refers to PostgreSQL, and sqlite3 refers to SQLite. You're better off working with PostgreSQL because that's preferred for Rails and it's good to practice. Can you show your actual Gemfile with all its code so that it's easier to debug?
I don't know if the author had that in mind, but I recently found out in MiniMagick that `Open3.capture3` surprisingly [can cause deadlocks](https://github.com/minimagick/minimagick/issues/347#issuecomment-219306789). Maybe tty-command has a better implementation, although I do agree that aside from that Open3 could be used internally for tty-command.
The pickaxe book. If you truly want to learn Ruby the language and not some framework flavor of it (*cough* rails *cough*) then you can't go wrong with the pickaxe book.
Thank you for putting this together. It's seriously sad that this is necessary.
Sorry you were downvoted. The CSS on the blog was accidentally broken but it should now render properly on mobile devices.
Looks like a copy/paste problem. Instead of a "normal" single quotation mark for the strings `'pg'` and `'sqlite'`, you've got "smart quotes" `’pg’` and `’sqlite’`, and Ruby only interprets the basic `'` and `"` characters as quotation marks. If you just delete the quotation marks and type your own with your keyboard (and you're not using a word processor like Microsoft Word to do it), you'll be fine.
ehh? I think we have different meanings of "hack". It is a pretty basic rails feature, and not uncommon any many other languages/web frameworks.
Thanks for the clarification, I'll update the show notes with that information. It's not very clear in the API docs. Appreciate the feedback.
Nice effort, I like seeing small focused libraries like this! One tiny suggestion, maybe consider removing the 'attempting' from your headline to make it sound more confident :)
Not a huge fan of using `.es6` as a file extension, mostly because it's a rarity and definitely not the standard extension for ES2016 files used with Babel. Similar guide over at http://collectiveidea.com/blog/archives/2016/03/09/modern-javascript-and-rails/ as well for those interested in the various ways to use Babel with the asset pipepline.
I cannot recommend strongly enough leaving the asset pipeline behind and using webpack instead.
Could it be possible that bootcamps and such aren't helping the Ruby community by only teaching how to work with Rails? Bootcamps tend to teach you "type 'do' and 'end'" instead of "include a block in the method call". What can more experienced people do to help these newcomers to shift focus to something like this article is proposing?
Can I get an eli5 on that recommendation?
That's not true. `any?` also early-exits as soon as the predicate is satisfied. [see here](https://github.com/ruby/ruby/blob/trunk/enum.c#L1171-L1177) Where did you read that it wasn't the case?
I'm writing on a tablet, so can only give a few pointers. (I'm also unclear on how you want suites sorted) 1. You already expressed concern that the ranks were 'just an array of strings'. It might actually be easier to address this issue first, although it isn't essential. 2. The sort by block should probably be kept pretty simple. Ideally I'd probably look to just sort cards by #value and let them handle the complexity. 3. You could always look at Array#index_of, although personally I'd suggest storing the card value more directly. This might tie in with solving option 1, such as modeling ranks as a struct with their name and symbol. (Edit: Sorry for the mess earlier, the aforementioned tablet meant an incomplete message got sent three times)
no worries I just saw this. I think im gonna mess around with it and then see if I can come up with a solution given your advice.
Ark_tane do you mind showing me some code based on my fiddle? Im still not sure what to do with the block and I dont currently have value assigned to the cards. Ideally I would like it sorted so all the hearts from 2-A are on one line, then all the diamonds 2-A on the next etc etc 
maybe ill just do the hash workaround described above, but Im curious how you'd implement what I was trying to do with sort_by. Do I need to add a value to each card to make it work, or can I be clever and do some weird sort conditional thing?
I am gathering my opinionated best practices here http://rwdtow.stdout.in (for the whole stack of Ruby web app), it could be useful
ah brilliant, i dont know why i was struggling doing this, maybe just absent minded. Thanks for your help
No problem. Good luck
What are you talking about? You're wrong. I even showed you source code (implementation) that proves you're wrong. `any?` will return as soon as the block returns true, simple as that. You're simply reading too much into the statement: "Passes each element of the collection to the given block". It only does this in the *worst* case ;) 
Bootcamp instructor here. We teach a wide array of things aside from rails like Sinatra, and using front-end frameworks as well. The issue is cramming a lot of knowledge in ~12 weeks to a person that comes from a wrestling, pharmacist, banker, realtor, etc... background. We get people that barely know how to surf the web, and pay lots of money with the expectation that they will be able to build a website by the end. The challenge is to not cheat them by teaching only shortcuts, but also give them confidence by being able to complete a task that they couldn't do a few months prior. 
Not sure if the sprockets pre-release has these features or not, but Webpack has some great dev features like hot loading and source maps, and that's why I and many others love Webpack. These features speed up my productivity in a huge way.
You could try making two Hashes, one that maps Suit to order (Spades before Hearts before Clubs before Diamonds or whatever idk) and one that maps Rank to order (A2345678910JQK, or A after K, up to you fam) You would then make a Card class that has two accessible properties, suit and rank. Card class' sort methods would take two cards and compare their suit properties and sort by that. If equal, it then examines their rank properties and sorts by *that* instead. On phone, so, no code example from me. To sum up: Suit order hash maps the four suit symbols to four numbers for ordering. Rank order hash maps the thirteen rank symbols to thirteen numbers for ordering. Card class has two instance variables, one for suit holding a Suit symbol and one for rank holding a Rank symbol. Card class also defines a sort method that takes two args (both Cards) and compares their suit props. If suits differ, you're done. If suits are equal, compare their rank props. suit_order[a.suit] gives a number, as does suit_order[b.suit]. Compare. If equal, compare rank_order[a.rank] and rank_order[b.rank] You return -1 if a is of lower suit, or same suit and lower rank, than b. You return 1 if b is below a by that logic. On a single deck, you should never have two instances of a suit/rank pair, so you should never return 0.
&gt;nuances that come with maintaining a mature platform Yeah, it's certainly not an enviable task to maintain backwards compatibility for such a large number of features. I think this is about trade-offs in a lot of ways. Good underlying abstractions are important in the long run, but not always immediately beneficial. 
Totally hear you. I taught part time Rails classes at General Assembly and made a point to tell them "this will NOT get you a job." Instead I tried using rails as a vehicle to teach debugging, learning to ask the right questions, etc. It's (in my opinion) impossible to become an effective developer in 12 weeks. You have to work outside of class, make something, make it again, and keep doing that in every part of downtime you have to be a full time dev. It is, in ways, a lifestyle.
&gt; I just wanted to point out that people like to ignore the nuances that come with maintaining a mature platform. What is "best" isn't always the right call for us. I don't really see these "better lower-level abstractions" being proposed by the Rails team, and that the collective decision is that it would unfortunately bring too much backwards incompatibility. I more got the idea that the Rails team either doesn't know or doesn't agree that something would be a good change. Not related to "abstractions", but I was surprised that it took the Rails team so long to agree that `ActiveRecord::Relation#or` is a good idea (that using OR is not "[a code smell](https://github.com/rails/rails/pull/9052#issuecomment-12649365)"). The fact is that for many of us Rails' design simply isn't improving enough. The reason doesn't matter. Rails contributors throughout the past have made a series of decisions which led to this present state, and the current Rails team might be doing the best it can to bring new features while preserving backwards compatibility, but that still doesn't produce good enough results. And it is completely fine to turn to the many other Ruby web frameworks and libraries which have done a better job than Rails at certain key things. We don't have to push Rails just because it was always there. One thing that would *tremendously* help Rails development is deprecating ActiveRecord over Sequel. The Rails team doesn't consciously develop ActiveRecord because it has some advantages over Sequel (I bet many of them have never even tried it), they do it just because it's part of Rails. Sequel also implements the Active Record pattern, but objectively has much better design and lower abstractions, which makes ActiveRecord a redundant library. And half of Rails issues are about ActiveRecord, so imagine how much time would be saved not developing it. What would help Rails is to note somewhere that ActiveRecord is being developed only for backwards compatibility, and that they would still accept bug fixes, but that people should slowly start migrating to Sequel. But of course Rails team can't do that, they can't even *think* about this option, because it's too late now, too many companies rely on ActiveRecord. And that's a problem, these past decisions, which slow down development of Rails. More precisely, development of *important* parts of Rails.
True. And Rails in the early years *defined* the value it brought to the table as "immediately beneficial". Understandable, even laudable in the context of the time…but experience is a b!tch of a teacher, and backward compatibility is a paranoid, jealous god. (Just ask anybody who was at Microsoft in the mid- to late-1990s.)
What is funny is that I heard that for the dozens of webpacks predecessors (grunt, gulp, lineman, browserify, etc). Every six month the previous one is actually crap, but wait for it the new one is the best thing ever. What is interesting though, is that until now, all the ones I've checked were basically task runners (make / rake style). Seeing your comment I decided to check webpack, and to my surprise it's trait for trait a JS implementation of Sprockets, 5 years later. The API is slightly different (adapted to JS I guess), but all the concepts and architecture are there (processors, digests, dependency graph, development server, etc). I honestly mean no snark, in the end I'm quite happy that the latest JS asset pipeline is designed after Sprockets which I do believe is a brilliant yet misunderstood piece of software. I'm just sad it received so much shit during all those years. Maybe it's integration in Rails made it seem magical and prevented people from understanding it. Not sure.
Search for books on Financial Modelling. I remember some python based ones. Try porting the example source into ruby. That should give you a good headstart. 
&gt; This is my first time with postgres with rails, though. I don't even know how to start it without the app. The easiest way is `brew services start postgresql` - also `stop`, `restart` and others are available, see `brew services help`. This also automatically starts postgres when you login in the future. Most of the time you'll get helpful info on how to use a service installed via homebrew via `brew info &lt;package_name&gt;` and the same info is also displayed after you first install a package. 
the book itself is indeed a bit old. it's rather about common principles and practices for developers transitioning to Ruby from another language. it's slightly out of date, but still ok in my opinion.
An article about that, AGAIN ?
&gt; I think many of the things that people think "aren't considered to be a problem by the core team" are actually things that would require more breakage than we're comfortable with to change, or take a lot of time to fix. Yes, that's why Rails is now a mature framework that people can safely rely on. And it's a good thing. &gt; I'm not implying that there aren't legitimate things that you care about that we don't think are a problem I would really recommend communicating team's position more clearly to the community. Maybe through blog posts on the official website, dunno. People are confused about the direction of Rails. DHH's opinions are pretty clear, but the rest of the team is rather quiet about what they would like Rails to become in the future. This really frustrates people, then you guys get frustrated too, this makes no sense. I understand that writing code is already hard enough, but communication with the community is equally important (and hard too). Honest, open communication would really help here, this is OSS project after all. I know you're giving talks, and probably chat a lot with people through various media, but it doesn't reach everybody. Then people come to conclusions that might be completely wrong, so let's maybe fix this. &gt; I feel like a lot of this post, as with many things I've been reading lately, completely ignore all the progress and work that's been done on Rails lately Exactly this. Why does it happen? This is a communication problem. Just like nobody ever communicated all Rails 3 improvements well enough, and I'm pretty sure there are APIs that are hardly in use even though they can be helpful to many people. I really don't understand why this happened, there were books, conf talks, blog posts, and somehow many people are still unaware of what's possible in Rails. Maybe the scale of Rails is so big that it's no longer easy to discover what's there. &gt; Nobody is arguing that we don't need better lower level abstractions. It's what we've been almost entirely focused on for 2 versions, and the story has been significantly better. So many of the examples in this article are things that are literally being phased out. Again, you need to communicate this to the community, make this information stand out. If you don't have the time/energy for this, find somebody who does. It's important for people to understand what Rails is and accept it and use it efficiently. I've seen people doing all kinds of weird stuff, going completely against the grain, just because they tried to have a better architecture for their apps (myself included). This has to stop. That's what I'm trying to communicate too, amongst other things.
&gt; One thing that would tremendously help Rails development is deprecating ActiveRecord over Sequel They had this opportunity in 2008. Either Sequel or DataMapper could've replaced AR. It didn't happen and it won't happen, it's way too late for that due to backward compatibility issues.
I've been waiting for this feature for *years*... While it's true that OR queries are unusual, they're still quite often very helpful. Up until now, I've had to use tools like [this gem](https://github.com/oelmekki/activerecord_any_of) to emulate the behaviour easily.
&gt; https://ruby.libhunt.com/categories/242-web-frameworks Thank you for sharing - I will have a look :) 
`or` is super helpful, but I'm confused about the semantics. What happens if I do: Post.where(id: 1).or(Post.where(title: 'Learn Rails')).where(date: something) Guess I'll install a copy of 5 beta/rc, and find out....
 (id = 1 OR title = 'Learn Rails') AND date = something
Using where we with strings made it trivial. ¯\_(ツ)_/¯
It's not so trivial if you want a more object-oriented approach, e.g. implementing a query object pattern.
I guess this is kind of the point -- to effectively give you a "discount" for remaining a loyal customer, and charge new customers more. However, I don't think it makes sense to keep charging an increased monthly fee - for the above reason. Perhaps a more sensible approach would be: * Everyone pays $9/month. * All new customers are given the option to unlock old seasons for $xx, with discounts for unlocking more, as a one-time payment. Charging more *per month* only makes sense to me if there's access to something additional - e.g. live chat, early access, prioritised episode suggestions, forum perks, whatever.
&gt; (1) choose the "ravenous" plan for one month, download the full archive, then downgrade to the "peckish" plan &gt; &gt; (2) subscribing for a month, downloading the entire catalogue, unsubscribing, then doing the same a few months down the road &gt; &gt; (3) sharing them with your entire team &gt; &gt; (4) sharing them with the internet at large &gt; &gt; ..... However, these are total dick moves These actions are not equally bad, by any means. I honestly wouldn't feel too guilty in doing (1), *especially* after I've finished watching the archive videos. (Why continue to pay to "rent" something that you no longer watch?) I also wouldn't feel too guilty doing (3), **within reason**. Sharing a *few* videos with a *few* colleagues is fine I think; sharing the entire history with the whole company is obviously not; it's a grey area. Doing (2) is very dishonest, and especially shouldn't be done when the victim is an individual. And finally (4) is obviously just a criminal offence. Basically, I think that (1) &lt; (3) &lt; (2) &lt; (4) in terms of "dick moves".
I don't want to celebrate this, as the syntax is ugly ... Gosh I love Sequel !
Why is it every time features like these are brought up flip-flops are always on the list. I love flip flops and I find them very useful for IO operations. 
My guess is that with the new site it won't be as easy to download all of them. You'll probably have to write a script to scrape the website(not difficult, but still), I doubt he's offering an easy download option with the new site. I imagine with the new site the only officially blessed way to watch the videos will be on the site. This is pure conjecture though, I don't have anymore information than the blog post. Edit: The FAQ mentions there will be downloads, so I revise my opinion. Perhaps just relying on people to be honest like before?
If you saw the confreaks video before, it was missing intro audio. This copy has full audio as well as closed captions. The blog post has a full transcript of the talk if you're more of a reader than a watcher. 
&gt;Less Features, More Fun *Fewer Features, More Fun
If I left this duplicate setup in place, would I have databases stored in two separate locations on my computer and run into problems, or is there a centralized location for that? EDIT: I'm still curious about where the database lives (the question above, is it in here /usr/local/var/postgres, but how do my programs know which is which?) although I ended up removing the app. Question on that, sort of related, the last step on their [uninstall instruction](http://postgresapp.com/documentation/install.html) is: &gt;Delete the data directory (default location: ~/Library/Application Support/Postgres) That will have no affect on my Homebrew installation right? Everything I need for that is in the Cellar right? I'm almost sure not but I want to double check. Thanks! Also: &gt; Did my Mac pack with a third postgres somewhere? &gt; Not sure what you're asking here. I was curious if I might have added confusion of a third postgres since I read that some macs [ship with them](http://apple.stackexchange.com/questions/97953/what-is-postgres-and-why-is-it-running-on-my-system). 
Since they both probably use the same default configuration you'd only be able to start one at a time, the other would fail with a 'port 5432 already in use' error on launch. 
And so 'rake db:setup' automatically does the equivalent of a 'postgres -D /usr/local/var/&lt;whateverYouPutAsYourDBName*&gt;' *from your database.yml file? Also the question you answered just before, I edited after the fact, so you probably didn't get the whole thing in your inbox. Sorry about that. Also thank you profusely, this is coming into clarity now!
Hopefully you stuck through it :D
I'm not opposed to going in that direction. If you have details of how those integrations work, I would love to hear more. 
&gt; your blog is ridiculous Thanks!
Rails escapes html in templates by default. You can do &lt;div id="content"&gt;&lt;%= @poem.html_safe %&gt;&lt;/div&gt; or &lt;div id="content"&gt;&lt;%= raw @poem %&gt;&lt;/div&gt; 
Thank you! I had been using TextEdit, so when I typed those quotes using Sublime Text 2, it worked!
oh yeah i was going to ask, is there a way to configure the dyno manager in heroku to impose resource limits on worker dynos? specifically i wanna put cpu and memory restrictions on worker dynos, but i want the restrictions to be strictly imposed (i.e via `cgroups` or whatever) rather than just monitoring the work and killing it if it goes over..
Be careful with this though. If you output user supplied information this way you will be vulnerable to XSS attacks on your site.
Yes, and same goes for the jQuery version too
One of the best features of the Mutex class is that it actually throws an exception when a deadlock has occurred. Now knowing about the GIL, I suspect the GIL might be how that is implemented. Or I suppose it could be in the Mutex instance itself. The visibility bug is really interesting – I did not know about that. It's just rare enough that you'd probably never track it down. That being said, you should probably be throwing a mutex around ANY shared resource when you're reading it.
[removed]
From [http://learnrubythehardway.org/book/ex35.html](http://learnrubythehardway.org/book/ex35.html), lines 68 - 71: def dead(why) puts why, "Good job!" exit(0) end
I'm asking if there is an alternative method to listening for fired events from the specific device. Or possibly a tutorial for ruby developers to hack this device.
Fair enough... Thanks for the heads up. I've been seeing more and more about webpack, but I'm pretty deep in the rails universe. Doesn't seem to be a drop in plugin for support, correct?
Asking questions is the first step to learning something new. :) Good for you for taking the time to learn to code. PM me if you want anymore tips/help in the near future, I'm willing to take some time and help you a bit.
For reasons like that our test database is peppered with XSS code such as `&lt;script&gt;alert('User McUserface');&lt;/script&gt;`
after avid's [last blog post](http://devblog.avdi.org/2016/05/23/please-help-me-to-not-go-broke/)... i think it might be time to get a job, dude. ravenous? heh.
Do not put HTML in your database. This is a mistake that will bite you hard. Markdown is okay, but not HTML. You will inevitably need to restructure the content/styling and you will be unable to. I have quit jobs because they did this and ended up in a business-killing hopelessness to fix it. If all you need is &amp;amp;lt;br&gt; tags at the moment, use simple_format Also, read about XSS right away, because you are venturing into something that could make your customers vulnerable to security/identity theft. Rails is protecting you from yourself. It's a good guy like that.
You can use reflection to see where a method is defined in ruby. Anywhere you can succesfully call `dead`, you can do: method(:dead).source_location And it'll tell you where that method is defined. It has to be a method, that's all it can be. (for the most part, with few exceptions, all ruby has got is objects and methods). It's not part of the ruby standard library though, so it must be defined locally or in a gem. 
Codeschool has two great courses focused on ruby and not rails which I think you might enjoy :)
Not sure if it is kept up to date, but I did https://rubymonk.com/ a while back and it worked well for me. 
Rubytapas is all about Ruby, I can't really think of Rails ever being mentioned. With 400+ episodes. I don't know your background but it will likely even make you a better programmer. http://www.rubytapas.com/ If you really want to learn Ruby, this is an incredible (and affordable) solution. Also, https://www.destroyallsoftware.com/screencasts is one of the best resources for programming I have ever seen. It probably leveled me up multiple times. Most of it is Ruby based. 
So sprockets already uses a node runtime, that's where execjs comes in. It never tried to "do it all". I think sprockets should be made a place where these other tools can be easily integrated, instead of re-writing them all by yourself. I would caution being overzealous in the desire to totally throw away sprockets, it wasn't too long ago that EVERYONE wanted Rails to have Bower integration and they saw it as inevitable, now no one even uses bower. That churn may be fine for node devs working on new projects but Sprockets is old enough that it's primary API and feature set needs to be stable.
Basically everything. But it's complete dismissal of convention over configuration, for starters. It's a pain in the ass to work with and configure. It does so little on its own, relying on plugins and nonsense that you end up better off just doing it yourself. [CJSC](https://github.com/dsheiko/cjsc/blob/master/README.md) does everything you could possibly need JS to do by itself and much more simply. There's nothing more fun that spending 3 hours configuring it, just to find out that it needs a plugin to actually do anything. It's not sustainable in any sense of the word.
Custom plugins for fluentd seems to be pure ruby. So I would say your better off sticking with pure ruby for your task. Within Rails courses you learn to know many extensions and methods from rails which you will not have availalble within fluentd and nobody will say "this is a rails only method". Maybe a good book can help you for example the pickaxe book (http://ruby-doc.com/docs/ProgrammingRuby/)
The guy puts forth time and a great deal of effort to give back to the community and this is your response. I'm sorry. I didn't realize your superiority when you walked in. Please share how you're giving back and making a difference so that we might all benefit from your awesomeness. 
.erb is Embedded RuBy you can embed ruby in almost anything. Html, js, css if you have a need for it. You should even be able to do image moshing with .png.erb
*nods firmly* Concurrent infrastructure is one of the hardest things to build. When making the "build vs buy" decision, it's extremely hard to justify building your own code with threads/mutexes when there's tons of projects that are likely more stable. I'm still finding and fixing leaks in code I wrote years ago and I'm supposedly an expert in this area!
I think it was easier to justify build before concurrent-ruby existed and was mature. It's got things at the right level of abstraction to give you what you need. I don't know if there really 'tons' of projects that do. The only one I can even think of in the running is Celluloid, but unless the actor model is _really_ what you want/need, I think it's overly complex for most use cases. But yeah, with ruby-concurrent, just use it. 
[Pragmatic Studio](https://pragmaticstudio.com/) Ruby courses are excellent and well worth the money.
And THEN, after insulting him, he asks schneems for advice on a problem he's having. And scheems gives it! Either this is all a joke and they're actually friends, or that guy, oh, that guy. 
My advice for your stated goals is to completely ignore anything related to teaching you rails and stick with things that teach ruby. 
I tried to use it. I had unoffical work permission to build a new project with it. I gave up and just learned ReactJS directly. It was less work. One of the things that put me off on Reactrb was the 50k line js script file that it transpiled to when I made a hello world application. Granted, by the time I include React into JS, I've probably got 50k lines as well, but it was still off putting for something so simple to take so much code.
For a great introduction to multi-threaded code bugs check out https://deadlockempire.github.io/ It's language agnostic as all the same bugs can apply regardless of the language you are using. Understanding how to manipulate shared state the correct way goes a long way to writing bug-free multi-threaded code. Using a mutex directly is almost never the way to go. If you use higher level constructs such as condition variables and locking/signaling you can consistently write bug-free code if you follow some simple rules. [Here is a great guide to writing MT code](https://www.cs.utexas.edu/~dahlin/professional/programming-with-threads.pdf)
&gt; Rails / Sprockets already depends on Node Not true for the default Rails v4.x app, but agreed with your other points. I think CJSC for JS management and something similar for SCSS/Less (maybe just the standard `sass` gem) would work well.
For anyone looking for a decent and worth-the-price IMAP-as-a-service, I've had good success (admittedly with a few hiccups) with [context.io](https://context.io/). Their [gem](https://github.com/contextio/contextio-ruby) is more than adequate for the majority of use cases as well.
I just don't see the appeal of Opal. You're just adding a dependency using it IMO. Why not use straight JS or something established like CoffeScript or ES6 transpiled? We have an internal project that was using a V8 instance to allow users to write callbacks in JS. The thing was just way too complicated, and I feel the same way about Opal and can only really see a use in adapting a build pipeline to be Rubyish. But again, is it worth it?
No front end dev I know wants to learn sprockets. Sprockets is fine in a Rails full stack mentality, but the world has been moving towards decoupling the front end and back end and I haven't seen Rails in general follow those same steps. It's frustrating to have to play middle man trying to work with front end folks on integration problems. Many Rails devs don't care about the front end, and many front end devs don't want to learn Sprockets. That just stresses Rails devs like myself who want our front end to keep pace. The better solution in my opinion is decoupling Rails from the front end build process altogether
it's not trivial if you're scoping from a previous query using AR "hash" syntax, which aliases and quotes identifiers, and you're bitten in the foot because your string SQL doesn't respect it, leading to ambiguous column usage and general code smell. 
I used: &lt;%= sanitize @poem, tags: %w(br) %&gt; and it did the trick. THANKS!
With ES6 I have not found JS, which I am almost completely new to, to be all that bad.
As someone who recently completed it, I would highly recommend [RubyMonk](https://rubymonk.com/). The material is very informative and they provide challenging exercises as you go. I'm contemplating doing [Pragmatic Studio](https://pragmaticstudio.com/) too because I've heard nothing but good things about it. Either of these are your best bet. On a side note though, I would recommend [Michael Hartl's Rails Tutorial](https://www.railstutorial.org/) if you do ever decide to learn Rails.
Just say you have some exposure and are confident that given some time and effort you think you could come up to speed quickly on the subject. That's my blanket answer for any tech I've never touched before. In my limited experience that seems to go ever better than lying about skills you don't actually have.
That'll be where your github repositories will help out!
show your tests
&gt; It's hard to show rails because it is backend. Rails combines routing (what you type into your URL bar), models (what data you store in the database), and templates (what HTML you render to the screen). 2/3rd of that list is what one would consider "frontend", so...
Did you restart the app?
i enjoy seeing people experimenting with them :) javascript is pretty much the de facto "assembly language" of the browser, so the explosion of compile-to-js languages is no weirder than the explosion of compile-to-native ones.
I heard there's Perl -&gt; Javascript interpreter 
"now you have two problems"
So if there are things I really wish sprockets did differently, should I let you know? By filing an issue? Even if I don't have a PR, and don't understand enough about the code to have any idea how feasible it is? That's what I pick up from the presentation, saying you can't know what's problematic about sprockets unless people tell you.... but it violates like every guard I've built up in my brain to keep from annoying maintainers, heh. 
"Adding a dependency" only applies if you assume that javascript is an inevitable base dependency. Increasingly, this will not be the case. WebAssembly will even eliminate the need to transpile into Javascript. Never having to work in Javascript is very appealing to me. If it isn't for you, then you are all set. For others, it is totally worth it.
We're shifting gears to React.rb right now and have been really happy with Opal itself over the last year+. We're very interested also in how Reactive Record + React.rb will work out with a base Rails app we have and for which we need to revamp the UI. We'll also be looking into React Native with Opal here as well.
It's a fine line. I want you to start thinking about how Sprockets could be better. If every time you walk through a friends house you stub your toe accidentally on a piece of furniture in an awkward spot, you should let your friend know. However if every time you visit you run around randomly kicking things then it's your fault if your toe gets hurt. The hardest part of sprocket for me right now and the reason I don't think people report that many issues is they can't tell when they're using it wrong, or when it's a weird sharp piece that is awkwardly place (where you might stub your toe). If you're genuinely trying to provide feedback about an experience you think could be better then I want to hear about it. I know what you're saying though, maintainers don't want to be your personal stack overflow. They don't want to be responsible for your mistakes or misuse of their libraries. That being said they do want people talking to them, they want people who might get involved or eventually might submit a PR. Most maintainers and projects suffer from a complete lack of involvement. Even if you make a mistake of opening an issue that really isn't the fault of that library, it's a good experience to interact with the maintainer. You can always tell them "thank you" for their library in the issue. Be straight forward, if you're not sure if it's a valid issue you can tell them "I don't know if this is a valid issue and I want your opinion". When maintainers complain about people opening issues, it's because that person should have gone to stack overflow instead. I actually wrote this on one of my READMEs https://github.com/schneems/wicked#support. Usually the same people will DEMAND you respond and fix the "problem" with your library. It's not a happy place. In this case I think if we are nice and sympathetic of a maintainers time and effort they will usually be happy to talk.
One of the projects I did for work was to write a real-time delivery tracker (as in, watch your delivery driver in real time on a Google map) using [Clearwater](https://github.com/clearwater-rb/clearwater). Even though I had to wrap the Google Maps API (which I keep forgetting to publish as open-source, I'll do it soon), it still only took me a few hours to write. The same app in Backbone took two of us several days just on the client-side stuff. Wrapping an existing JS API is quite simple, so even if you have to do it it's not a big deal. The entirety of the [`opal-pusher` gem](https://github.com/jgaskins/opal-pusher) is [26 LoC including whitespace](https://github.com/jgaskins/opal-pusher/blob/master/opal/pusher.rb). JS numbers, strings, and arrays work just fine in your Ruby code. JS objects and Ruby hashes need to be converted back and forth, but that's a single method call in either direction.
@transientBug and @GDP10 did the above at age 15... :) Sure, he's brighter than your avg teen, but it helps illustrate that we're in good company and it's not as scary / worrisome as one might think.
Why would a typical Rack app use JWT over plain old encrypted session cookies?
I'm really surprised to see down-votes on such a well composed remark with such information that has no reason to be voted down. Thanks for chiming in and sharing your experience here @mitchatcatprint!
Would like to understand why you think it looks more complex, our goal is make reactrb simpler, so any advice would be appreciated! Reactrb just wraps react.js, and has the same semantics, plus instead of dealing with 2 languages (jsx + javascript) you deal with just one. Also I would add that I think volt is very cool, and we started with that, however for us with a preexisting, large rails app, we needed something that just addressed the front end without requiring us to rethink our entire app, as volt would have done.
Indeed.
If the rack app serves browser requests, there's little reason to not use cookies
Reactrb can play well w/webpack, I've been meaning to document it for a while but haven't gotten to it. But you can use webpack to import existing react components from npm and use them from Reactrb
Same language on server side and client side is pretty substantial, no context shifting, shared domain logic, as is views written once and used on both sides. It's as good as the node guys say it is, except that it's in Ruby instead of Javascript
I just interviewed for a Sales Engineer role where they were looking for Software experience, and asked for a JSON backend implementation. I made my demo presentation a walk through of the app working, and sent the actual code for them to review the morning before the interview so that interested parties could review it on their one time prior to the presentation. This format works very well for SE interviews.
Way easier to skip sessions when you have multiple servers behind a load balancer 
they might, i think it is possible (if maybe not a good idea). but where do you see rack depending on thin? rack [1.6.4's gemspec](https://github.com/rack/rack/blob/1.6.4/rack.gemspec) has _zero_ runtime dependencies, and two development dependencies neither of which are thin. [rack 2.0.0.rc1's gemspec](https://github.com/rack/rack/blob/2.0.0.rc1/rack.gemspec) has one true dependency (`json` with no version requirements, thought that was in stdlib, don't know why it's a dependency), and four development dependencies still none of which are thin. I would be surprised to see rack using memcache-client either. So... where were you looking to determine rack depends on these things?
secrets.yml shouldn't be in .gitignore Inside the file, you should have: production: secret_key: ENV['SECRET_KEY'] And another for the other one. Check in the file, commit and push. It'll work.
Again, if they are cookie-based sessions like is the default for Rails sessions (and I would guess is available through some gem to any rack app, although I haven't looked into it), should not be an issue whatsoever. The entire session is stored in a cookie. There's nothing server-side that needs to be 'restored', or that lives on a certain web server in memory or in a certain rdbms instance. There is no server-side state related to the session at all. Same same. (there ARE race conditions with cookie-based no-server-side-state sessions, but they are there whether you have multiple servers behind a load balancer or not. If you don't put anything more in the session than you would in the JWT, it shouldn't be an issue, and is unlikely to be an issue for API use). Ah! So one reason you might not want to use a cookie-based solution for an API is it can be a pain to deal with for non-browser user-agents, not all of which support cookies nicely or at all, which you probably want your API to be easy to use with. 
Ah, I see. So, a gem actually declares it's dependencies in it's gemspec file. That's the one that matters for downstream installations of the gem. Anything added to the `Gemfile` that's not in the `gemspec` is there when a developer actually working on the gem itself (in this case rack) is using it, perhaps to run tests. But isn't actually a dependency that rack will require when others install it to use it. (For that matter, that's also kind of true of things declared as `development_dependency` in the gemspec -- but if it's not even in the gemspec at all but just the gemfile, rubygems doesn't really even _know_ about it, when the gem is actually installed the Gemfile in it's source has no effect whatsoever). Why is thin in the Gemfile as a development dependency, what's rack doing with thin? Well, we can [search the source](https://github.com/rack/rack/search?utf8=%E2%9C%93&amp;q=thin) to get a clue. It looks like rack includes a "handler" for thin. &gt; # *Handlers* connect web servers with Rack. &gt; # &gt; # Rack includes Handlers for Thin, WEBrick, FastCGI, CGI, SCGI thin isn't strictly a dependency -- you don't have to have thin installed to use rack. But there is a thin handler in there, that will be used with thin if thin is being used. I'm not super familiar with how rack handlers work. One would expect a "rack thin handler" might be included in the thin gem, but here it is in the rack gem. Probably for historical reasons, because maybe thin already existed when rack was invented? Not sure about that, but thin was the most popular app server back in the day. I'd guess more recent app servers (puma?) either don't need a "rack handler" at all, or have it in the (eg) puma source, not expecting rack to provide it. It's probably more or less an accident of history. rack could come with a thin handler (which might have a `require 'thin'` at the top), even if thin wasn't listed in the Gemfile. If you tried to load the thin handler without thin available, it would raise -- which makes sense, why would you be trying to load the thin handler without thin? It would also make developing/testing of the thin handler hard if thin weren't available. And rack has some automated tests that prove it works with thin, which it might want to do even if it didn't include a "thin handler", and would also be a reason developers developing rack would need thin available (so it's listed in the `Gemfile`), even though it's not really a dependency of rack. So I don't know if that really answers your question, but it's what I've got. :)
That is such a great idea. I hope you got the job:)
Makes sense, that's a helpful way to think about it, thanks. You can choose to have your `ActionDispatch::Session::CookieStore` signed but not encrypted, with configuration in Rails. But you ordinarily don't want to for typical things you store in sessions. 
Thanks mate, I'm in a similar boat (you before RubyMonk).
Volt looks like abandonware, the project owner was trying to get someone else to take over and there's been no update for six months.
I played with it for the first time upon reading your recommendation and have to agree that it jumps to the heart of what is Ruby from the get-go. It should delight seasoned coders who are new to Ruby. I hope there is enough renewed interest in Rubymonk to encourage its developers to keep working on it. I notice that development/refinement seems to have ceased over the last couple of years. I just donated a small amount in the hopes that they see that the Ruby community still cares :)
derailed_benchmarks, i wrote it.
But the goal of Hanami is to be modular that means not to force you use something that you won't :) And I like it, I always can use only some part of Hanami and replace every thing that I don't like.
Heroku does this automatically when you set variables.
Ok, thanks for responses
No problem! How many students are you looking to use Tech Rocket with?
I did this recently, lowering the memory overhead and reducing the number of allocated objects using [memory_profiler](https://github.com/SamSaffron/memory_profiler). I found it to be great. In fact, we ended up with a ~36% improvement in memory usage and ~52% less allocated objects. The Github PR with the results is here: https://github.com/appneta/ruby-traceview/pull/168 Edit: BTW there are profiler output files attached to that PR if you want to get an idea of what the gem output looks like and what visibility it provides.
No there's a "special" iTunes rss feed and - of course - a regular "plain vanilla" rss podcast feed (with enclosure). PS: You can alway add more "special" feeds if needed - it's just another Liquid template. Cheers.
Probably about 10-15 to begin with.
I was going to recommend heapy, but I'm guessing it's been rolled into this. 
Scheems tools are definitely the place to start but when shit gets real you can't beat IMO rbtrace and ObjectSpace. Here's a post about how to start using them. http://blog.skylight.io/hunting-for-leaks-in-ruby/ Once you have identified your hot spot you can use ObjectSpace to dump counts of specific objects to figure what you code is doing wrong. I recently used this setup to fix an app that had unbounded memory use and got it down to a stable 170Mb. 
The last time I tried to use the node runtime with execjs there was a horrible penalty for first load, like 10s sometimes. What happened to using V8 w/ execjs?
Is the Beginning Ruby book you're getting the one by Peter Cooper? I'm trying to expand my reading list and will take any good material.
Servers need to respond with the latest part received so that uploads can resume from the correct place. They also need to join the uploaded files on the server.
That's the one. There's a newer version coming out in August but I didn't want to wait and they wanted $40 for a pre-order. 
I know, that's why I mentioned it :)
Still more rubyish would to be use something from Enumerable to build the symbols array that to build and loop over it separately. I'm thinking something like symbols = strings.select{|string| string.include? 's'}.map(&amp;:to_sym)
can u pls not use the expression 'shifting gears' ? you sound like a faggot
I wrote a pretty popular tutorial on this and it walks through all the pieces you'll need: https://gorails.com/setup/ubuntu/16.04 One of the main reasons to use a ruby version manager like rbenv is that you can easily upgrade ruby versions. It's much easier than waiting for the official ruby package to get updated (which might not happen at all sometimes for older distros).
I find it hilarious that you can't understand why people say that you are generally a negative person.
I've been trying to come up with a good response to this. But really my thoughts can be best summed up as: You seem to be implying that a framework is going to be able to solve the problems that come from maintaining a large application at scale. They aren't. Some of the patterns people use in Rails (which Rails doesn't necessarily encourage) don't work well at that scale, but that doesn't mean Rails is a poor choice at that level. I am not attempting to say that we don't have a lot of places that we can improve, but again, it's all a balancing act with backward compatibility at this point. But I think people like to place more blame on the framework for architectural problems in large apps than is justified.
What you've done is exactly correct. You should rely on the system interpreter on linux. This means you get timely security updates and support from the distro (e.g. you can file bug reports if something breaks). By installing whatever version of ruby happened to be in there when you git-cloned the rbenv repository, you'll end up with outdated ruby (and maybe openssl) packages with no central way of keeping everything updated. Distribution packages exist to keep the software maintenance burden off end-users. You should leverage this.
I'd use rvm or rbenv so I could easily switch versions / flavors. 
Thanks! :D Great bash script there, very straightforward and simple. 👍
&gt; These usually aren't very timely and are notoriously outdated. The current version in Ubuntu is 2.3. That's the latest stable version. &gt; Also installing an updated version of ruby is as simple as rbenv install &lt;new.version&gt; &amp;&amp; rbenv global &lt;new.version&gt; Nope. You also have to remember to install the latest version of the ruby-build plugin because that is where versions of ruby and openssl are specified. e.g. if I had installed the ruby-build plugin on May 1, before [this update](https://github.com/rbenv/ruby-build/pull/944) was merged, then today I ran `rbenv install 2.3.1`, I'd be installing a version of openssl with known vulnerabilities. Edit: Please note that I'm not saying that rbenv is *never* the answer, just that it should not be the go-to solution. Usually the packaged version is fine. In some rare cases you may need a feature which requires a newer version, but I'd argue that this is not very common. e.g. Rails 5 will only require [2.2.2+](http://edgeguides.rubyonrails.org/upgrading_ruby_on_rails.html#ruby-2-2-2). See also [this Debian wiki page](https://wiki.debian.org/Ruby#Installing_Ruby_versions_not_packaged_in_Debian) which says basically the same thing. 
This is my goto, which includes descriptions for different versions, rvm or rbenv. https://gorails.com/setup/ubuntu/16.04
FYI: I've added the [Octopod User's Guide](http://hydepress.github.io/octopod) by Stefan Haslinger et al to the [Hyde Press Bookshelf](http://hydepress.github.io). Happy podcasting with Octopod (and Ruby). Cheers.
Good idea, I should've done that but I will make sure to use it in my next video. Definitely helps to break apart the method with binding. Thanks for the feedback!
There are several great resources for learning Ruby. You can checkout tryruby.org which is a great interactive tutorial on Ruby. If you are looking for more advanced stuff once you get a grasp on Ruby check out RubyTapas by Avdi Grimm. I also do weekly Ruby and Rails videos on my channel here, https://youtube.com/shakycode sorry for the self-promotion but I like making easy to follow tutorials for beginners. Because the world needs more tutorials :) 
How's the result of of @address_1.split(' ') going to contain whitespace?
Thanks for the feedback, this was not actual production grade code, but something I dug up and found hard to read and confusing so I did a simple refactor it. It's definitely not robust and could use things such as error handling and normalization, but this was just a simple tutorial. I appreciate your comments and will take them into consideration when I do my next video. I'm really trying to find relevance that will help people learn and sometimes it's tough coming up with ideas on my own that isn't work code.
 $ ruby -e "puts '518 8th st '.split(' ').inspect" ["518", "8th", "st"]
I stand corrected. The strip is unnecessary. Thanks for the feedback and help!
&gt; Do you have other suggestions on how I could improve this? If backwards compatibility doesn't matter (and it doesn't since you renamed the method) then you might as well lose the class variables and take them as parameters to the compare method. There's no reason to require a new instance for every 2 addresses you're going to compare.
This is really good, thanks! I honestly rushed through this and really didn't think about my design well enough. I'll put more effort and thought into my next refactoring video. I'm hit or miss when it comes to refactoring, like all of us looks like I have a bit more to learn :)
Please understand I am trying to be nice here, if you look at the video with fresh eyes I hope you will find that it does not impart any useful information (to any skill level). I would suggest some things that would be useful but are missing. Talk about why you refactor. Why is this code a candidate for refactor? What do you look for when you think about if code should be refactored. Walk over what the starting code actually does. Use example code that does something that is concrete and concise -- maybe something that is easy to parse but ugly or not generalized well. What are your goals for the refactor? Show testing. If your target is newbie developers (or even if it is not) take the last issue into ensuring test coverage exists for the code before you start to refactor it. Showing two or three irb runs on a 40 line extremely poorly coded class does not show the reality of what any level of a developer should be doing to refactor code and ensure it works properly. It goes without saying that your refactor is materially different output than the original code (except for maybe your A/B irb runs). ... Don't get me wrong I appreciate that you are making videos and I understand they take time to create but at some level without a little more thought or reinforcing best practices it seems like you are maybe doing more harm than good to new developers when I don't think that is your intention. As someone who hires and manages developers what is shown on that video is almost exactly a "what not to do when refactoring" hitlist for any skill level. 
Thank you for the feedback, this gives me a lot to think about. I will take your feedback and others and work on making videos that are more relevant and demonstrate best practices. If I could do this all over again, I would do it much better and follow your advice. I'll do another video with another example and post it next week. Thanks so much!
Does Hanami have a sub-reddit?
Just make sure you use a fairly recent version of ruby, preferably 2.3, otherwise it will be confusing because it does not support everything you might hear about. Ubuntu xenial for example has 2.3 as package: http://packages.ubuntu.com/xenial/ruby/ruby2.3 . If you can use that, I don't see a compelling reason to go through the extra complexity of going through a ruby version manager (rvm, rbenv, chruby) up front, contrary to what the majority here suggests. You can set one up later once you need it (if ever), and use the energy instead to discover some cool features of ruby.
Not sure Ubuntu has something similar but I set up all the Ruby info regarding Fedora here: https://developer.fedoraproject.org/tech/languages/ruby/ruby-installation.html Also I want to elaborate. You did perfectly fine, never understood suggestions for version managers where the included Ruby is sufficient. Don't introduce another complexity (a version manager) just to use Ruby especially at the beginning. Chances are you will never need one.
Thanks for making this video. However, I have to say that the title is misleading. This video is a *rewriting* rather than a refactoring. I would expect a refactoring to first start by writing tests on what we expect (or know) the class does. Then we start with all the raw code, make small changes and test every step of the way. As it currently stands, we have no idea whether or not your new method does something completely different from what the original author intended. Actually, even a rewrite should definitely start with a tests. Not only would this give some confidence to your eventual code, but it would very clearly help us understand what your 'compare' method does to check simmilarity [sic].
You're right, this is indeed more of a rewrite and I will definitely back my next one with tests. I probably rushed this, it won't happen again. Appreciate the constructive feedback.
The link for that one: http://ryanbigg.com/2014/10/ubuntu-ruby-ruby-install-chruby-and-you/ It's a little bit old, but it should still be almost identical.
This is the best I've seen so far and it just works. I setup an Ubuntu VM in VirtualBox on Windows 10 and this tutorial worked beautifully, including getting rbenv up and running.
https://www.youtube.com/watch?v=JAgS_Pm5Bno This will help installing Ruby in a non-dong kind of way, by using a version manager.
Love this tutorial. Like /u/dchess I did a little automation based on it myself for a vagrant box I'm using for a personal project: https://github.com/snkinard/bon-voyage-vagrant/ Still a WIP but could be helpful for others trying to do something similar.
I think the mantra to use a ruby version manager that so many here repeat comes from a time when the packages really were very much outdated compared to the latest release. But at least on Ubuntu this seems to not be the case. Even if you are on an older Ubuntu version, you could install from the Brighbox repository: https://www.brightbox.com/docs/ruby/ubuntu/ 
I would recommend against doing this if it is possible. Can you explain a bit more about your situation that would require you to change Rails config variables in production?
Ouch. Is that meant to be used in production? I'd rather point a shotgun at my own head.
I am using https://github.com/huacnlee/rails-settings-cached it allows for updates to the values while running but will keep it cached / in the DB for runtime lookups.
This is the right answer. If your app is slow/painful to reboot (I've been there) that's your problem. 
I'm not the poster, but... I rotate my database passwords regularly to meet regulatory requirements. Currently I do zero downtime restarts with Puma, but it's slightly painful and doesn't apply if you are running other services. I can see how a restart-free solution would be helpful.
I am going to interperet your problem a lot different than the other answers here... I take it you essentially want to attach to the running process and modify the memory? Would this help? https://github.com/ileitch/hijack 
I actually had no idea this was a thing, was just making a joke. Thanks though heh May that mean C++ in the browser? LoL
This is IMO the only real answer to the question. Whether you want to do that or not is a different subject. :-)
You probably want to put [the methods](https://github.com/mscavnicky/csvp/blob/master/lib/csvp.rb) inside of a Module, that way you don't infect the global namespace by default.
isn't he referring to web workers? There (usually) isn't just one app instance fielding web requests, there's a few, you'd have to perform your update on all the web workers.
I wrote [a book on rails deployment](http://railsdeploymentbook.com). Getting to zero-downtime app restarts is fairly simple if that's what you're after.
Shotgun for production is not the best idea really.
No elevation?
Nope, for now it is not, I mentioned it in the README. Currently, I want the idea of separate common class to be validated and polished, use cases discovered and so on.
&gt; you should take the advice given to you and release a gem, then try to get every popular Geo gem to use it. That's what I am doing currently, no? &gt; casting to/from array is so easy... Yes, and you can represent string as an array of bytes, Hash as an array of pairs, time as an integer and so on. But for that's not how OOP works?.. You have a concept, you have a class for it.
You're welcome and thanks so much for the kind words! :D
Thanks very much for looking into it! I actually posted this to the SD Rails Google Group as well and someone submitted [a pretty dope PR](https://github.com/vcolavin/forest/pull/1) that solves most of the issues. I don't have access to a Location#objects method (which I had already written myself), but Wolf#location works, and I can reference locations directly when creating objects, rather than having to reference the join table. The fix was basically to correcting some pluralization typos and to add inverse_of to the relations. ActiveRecord was able to figure it out from there!
Did you just move everything from secrets.yml into application.yml and then call them as environmental variables? Then did you send those to Heroku like I have? Even the development and test environment secret key bases?
Dev and test don't matter. Just put them directly in the file. The keys don't work for actual production things like your database, so who cares if someone gets them via github or whatever? Now if you have a sandbox AWS environment - DO NOT put those credentials into secrets.yml I just have a file called 'keys' that is gitignored and I put all my credentials in there. I source this file before I run my rails server locally. This way for dev and test I can use secrets.yml with the same setup as production as everything is an environment variable. But specifically for production just load everything into Heroku or whatever you use and put ENV['KEY'] in secrets.yml for everything you need a key for. 
&gt; That's what I am doing currently, no? You're right, sorry. I was reading the discussion you linked where you said something about keeping it as a bare repo, but things have progressed since then. &gt; But for that's not how OOP works?.. You have a concept, you have a class for it. No... I don't think it's necessary to wrap every single concept in a class. There's often overhead (like, in this case, making every other library conform) that costs more than you'd gain. Why not implement and inherit from a more general, globalized "coordinate" type object? Surely there are even more people using regular old 2D arrays for regular old coordinate pairs and they're all rewriting the distance formula all the time... Why not push your solution up the stack a bit? (Because using primitives in a conventional way is faster, cheaper, and safer than incurring a dependency if you're comfortable with the operations.)
I was just wishing for this earlier today. I need to learn to procrastinate better.
I have always followed this guide without no hassle whatsoever: http://railsapps.github.io/installrubyonrails-ubuntu.html
Hey guys, I had a project for school to create a Ruby gem that used scraping and APIs. I ended up creating a gem that takes in a user's zip code or address and finds Fireside Gatherings near them, you can select a single event to view more info about it. Let me know what you guys think!
That would be nice. I've created an issue https://github.com/jhawthorn/curl-to-ruby/issues/2
Too bad you cannot add comments to his post. Anyway, it would have been neat to see how wrapping a bunch of AR calls in a parent transaction would have compared to the other options. In cases like his, I'd often run batches of 1k to 5k in a single transaction, usually giving me a 10x to 20x performance improvement.
Yeah, exactly, thanks.
That would make sense only if we agree with the premise that ActiveSupport monkeypatching is comparable to binge drinking. I don't agree with that comparison. It has simply not been my experience that ActiveSupport monkeypatching causes a lot of problems. I've never run into any debugging problems caused by ActiveSupport. Ok, I've seen a couple of cases where monkeypatching (outside ActiveSupport) causes problems. I'm not advocating using monkeypatching everywhere. But I get the feeling that you and other ActiveSupport opposers think that monkeypatching is a deeply fundamental evil. I simply cannot agree with that. To me it's a knife, it can be used to do good and to do bad. In my opinion, monkeypatching is good when used sparingly and to make common cases easier. String and date manipulation is very common in web apps. I think ActiveSupport has found the right balance, for the most part. I think declaring all monkeypatching fundamentally evil is throwing the baby out with the bath water.
Tips: 1. If you're going to create a gem that has dependencies, declare them inside the .gemspec file so that devs don't have to install them manually besides your gem. 2. Based on the prompts and menus, I'd say you can also move the cli class to a binary inside ```/bin``` and keep the ```lib```folder clean(er). 3. You should also document how to interact with your gem from within a project (i.e: how to include it, what's returned as events? hashes, jsons, etc...). 4. In the same fashion you could show some examples of both CLI and Class interactions. Nice job anyway.... I'm not really into this type of CLI interfaces, but I'm guessing you learned a shitload from doing it... 
Hi, Author here - adding comments to the blog is on my short list :) Regarding transactions I expect it would help in the simple approach but it would still be considerably slower than activerecord-import and for sure it won't beat the copy-then-upsert method.
&gt;I've never run into any debugging problems caused by ActiveSupport. Because Ruby is Rails, and library authors take a great deal of care to not break that stuff. Rails gets away with most of the damage because it's so well-known and popular. Part of what grates on people is this almost-equivalence of Ruby to Rails.
heroku scheduler is free to a limit. But should essentially be free for your case.
Thanks! This is exactly what I need.
Fine. But even so, I don't think there is anything wrong with Rails being so prominent. I too am a library author. I've never felt bothered by the fact that I need to be careful about compatibility with ActiveSupport and Rails. I don't feel your gripe.
yeah.
ImageMagick continues to be supported in AWS Lambda runtime; however, certain coders have been disabled. You can see more details at https://forums.aws.amazon.com/ann.jspa?annID=3804. You can also package any version of the imageMagick library as part of your function ZIP.
Is this is a thing where sales engineers are actually supposed to have coding knowledge? In my experience even the product managers don't have coding knowledge, what to speak of sales engineers.
I agree. Plus: This is neither new nor in any way surprising.
That is a silly example to make a point in favor of the introduction of the interfaces over soft typing in Ruby. In the story I mention that the developer don't have control over the implementation of `Bird`, which come from the fictional `acts_as_a_bird` gem. &gt; This will force every sub-class to make a concrete implementation of the method. This constraint will be applied at the runtime, only if the method in the abstract class is hit. One of the goals of soft typing is to enforce it before your program runs. In a dyn-lang like Ruby, instead of introduce check for types, we should check for interfaces. This is what we do today: def start(engine) return unless engine.respond_to?(:run) engine.run end This is with with soft typing: def start(engine: Engine) engine.run end This is with interfaces: interface Runnable def run end end def start(engine: Runnable) engine.run end What have #1 and #3 in common? They still allow duck-typing, aka they are focused on the behavior that you're gonna use in that method. You can use a class like this: class TestRunnable def run end end If we only check for types, we have a more rigid system which would change a lot the way that Ruby works.
I think that's the whole point of a sales engineer is that you have technical knowledge that a product manager doesn't have. I am in hardware, but was hired specifically for my software expertise. I think it really depends on what kinds of products you are working with, specialist vs. broad focus, etc.
I'd be careful of heroku scheduler if you need this to run reliably. Heroku scheduler is free but also comes with no guarantees it will actually run, it's a 'best effort' service. I've had quite a few scheduled tasks over the last year simply not run without any error or warning with it. 
You may be right. I was being sarcastic when making the suggestion, my point is that when you say &gt; In my head, there is very hard to say what "general coordinate type object" is. that's exactly what I'm thinking about the Geo type. That may be one reason there are already so many solutions out there. 
I didn't mean "safety" in the sense of types. I meant it's always a risk to incorporate third party code, and that there's a category of solutions that are so simple that you're safer writing them yourself. Also, are you saying that it ought to not be an Enumerable? (Especially given your username... heh) So I shouldn't be able to say `coord.first` and `coord.last`? I'd be pissed it if it made it into the stdlib and I was forbidden to treat it like a regular pair. Not to mention all the existing code that people would refuse to port. Another reason it's not a great idea in the first place. Edit: you're probably not saying that, you were giving a "in a language that handles it better" example.
Write a script that interfaces with the Digital Ocean API to create a droplet every 24 hours to run your script. You can save your machine state using a backup on Digital Ocean. Put this script into a daily cronjob
The same as w/ any language, you need to know the nuances of ruby syntax enough to be able to read code written in ruby. good books are the [pick axe](http://ruby-doc.com/docs/ProgrammingRuby/) guide and [eloquent ruby](http://www.r-5.org/files/books/computers/languages/ruby/main/Russ_Olsen-Eloquent_Ruby-EN.pdf). The pick axe guide is your reference manual and the eloquent is a little bit of the how and why. It touches on the topic of Domain Specific Languages (DSLs) which is why ruby is so freaking cool. Cucumber is an example of a DSL for behavior driven testing so if you want to understand some of the magic there you should understand a bit about DSL's. [calabash](http://calaba.sh/) is an automated testing tool for mobile devices and it plays nicely w/ [cucumber](https://cucumber.io/) meaning you can write your acceptance tests in cucumber and run them in calabash. that means you should focus your learning on cucumber and then see how that fits into calabash. so my suggestions would be to skim the pick axe book. Then read the eloquent ruby book referring back to the pick axe book if you need help understanding something. When you feel like you understand what's going on w/ DSLs then read up on and write some cucumber tests until you're comfortable. make a stupid ruby class and test some things on it w/ cucumber. after you have a firm grasp on cucumber then dig into calabash to understand how cucumber works w/ it. good luck
Have you seen [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby)? I suspect there's stuff in there that you're re-implementing -- or maybe even everything you need is already in there. concurrent-ruby is pretty good code, intends to be the base concurrency primitive gem for ruby. It's included as a dependency in Rails 5 (and recent Sprockets!), so I think it will become that. And deserves to, it's good code, performance optimized on both JRuby (using Java stdlib where appropriate) and MRI (using optional C extensions). Definitely worth checking out to make sure you're not re-inventing something it has already done (and had lots of person hours in testing and optimizing). 
Fair enough. 
I wonder how the same idea would be modeled in Elixir?
For learning Ruby I always recommend Ruby Koans and the Ruby course on Codecademy. I'm more of a hands on learner though--books don't really do it for me when it comes to learning a language. Not sure if you'll be using the RubyMine IDE, but for what it's worth Jetbrains has a student option that gives you access to that and other tools for free.
And you sound like a backwoods six-year-old. EDIT: After browsing your comment history (not for the faint of heart), I realise the above statement is grossly unfair to self-respecting backwoods six-year-olds.
If you really need to, creating a new account with an alternate legit email every year works. :-)
rubymonk.com
im already on it haha 
I'll have a look if you'll maybe publish the repo on GitHub? Then I can pull and debug locally. (Sent from 🚽)
I've been learning Ruby for about eight months so I can recommend a few resources that have helped a noob like me. As mentioned below, I like RubyMonk. Knowing what I know now, this would have been my starting point. Chris Pine's book is excellent, I've gone through it twice (this was my very first introduction to the language). I also suspect the Pragmatic Studio's Ruby course is excellent (though a bit pricey). I have not taken that course personally but I did take their Rails I and Rails II courses and both of them were great. I have no doubts their Ruby course is very good too.
&gt; “In a dynamically typed language like Ruby, what you really care about is behavior. You want to be able to send messages to objects, which is the essence of OOP.” &gt; “The difference is subtle: you’re speculating that Bird responds to #fly, but that isn’t always true. Instead, the language should provide a tool to check if a given object implements a method (or a set of methods)”. Um, right ruby provides this tool for a given method, `bird.respond_to?(:fly)`, you don't need interfaces for that. This effectively means the 'interface'/type is one method, `fly`. That is the example in the OP, and ruby handles that pretty well, just with `respond_to` It is true sometimes the interface/type really needs to be more than one method, a set of methods. I have sometimes wished there were interfaces in ruby. There are ways to implement something very like an interface in ruby (you can implement almost anything in ruby, it's so flexible), but they are so un-idiomatic for ruby that they tend to be more trouble than it's worth. There are patterns more idiomatic in ruby for solving this problem. For this particular example, if `respond_to?(:fly)` wasn't sufficient, I'd consider giving birds a `can_fly?` method, maybe defaulting to returning true, overridden in some sub-classes to return false. If it was a sub-class relation at all. Indeed, the OP is exactly right that it's critical to understand the difference between inheritance (of implementation) and typing (interfaces, with or without a formal decleration: what methods and behaviors the object can respond to and do). I'm not saying I still don't occasionally wish there was a notion of Interface built into ruby. Everything is trade-offs. But it's pretty occasional, and I can usually find something fairly clean as an alternative when the wish does enter my mind. And maybe once or twice I've actually implemented something resembling interfaces on top of ruby for using in a key place, it's not entirely unreasonable. (Hint module mix-ins, which are really just multiple inheritance, are a good place to hang your hat. `object.is_a?(SomeModule)` works when the class (or individual object!) includes SomeModule. The module could provide a bunch of methods that each just raise as abstract and need to be overridden by the concrete class to do something. The module could even use fancy methods to check to make sure the includer implements all required methods upon `include`, instead of waiting for the missing methods to be called)
**Disclaimer:** I haven't actually verified that the following works So if you have: **/data/projects.json** { "projects": { "project 1": [ {"title": "project_1", "intro": "project one intro", "description": "description of project one" } ], "project 2": [ {"title": "project_2", "intro": "project two intro", "description": "description of project two" } ] } } **source/projects/template.html.erb** ... &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;&lt;%= intro %&gt;&lt;/p&gt; &lt;p&gt;&lt;%= description %&gt;&lt;/p&gt; ... **config.rb** data.projects.projects.each do |project_data| proxy "/projects/#{project_data['title']}.html", "/projects/template.html", locals: { title: project_data['title'], intro: project_data['intro'], description: project_data['description'] } end Which should generate: * /projects/project_1.html * /projects/project_2.html * /projects/template.html You'll probably want to either ensure your titles in the JSON never have spaces (because its used to generate the html file name) or `gsub` spaces for underscores in the `proxy` call. Unless you want underscores in your generated page titles you'll have to `gsub` in one place or the other. I believe something like that should work, but I'm just basing this off the following doc pages: * https://middlemanapp.com/advanced/data_files/ * https://middlemanapp.com/advanced/dynamic_pages/ * https://middlemanapp.com/basics/partials/
The advice might be more specific/applied to Rails app development. Honestly, I've seen a lot of those things happen in Rails startups only because it's so easy to build something that sometimes people barely think about it. That said, it's really not Ruby related.
Ummm, ok.
That is a good idea, and sounds like a great way to implement a "soft" shutdown, since you'd then be at the mercy of any engaged callbacks to finish before the thread pool could complete, and then the corresponding stop call would return... perhaps an optional parameter like Service#stop(type=:soft) with an option for :force/:hard. Also an opportunity to tinker with thread variables. Out of curiosity (I'm not an advanced thread or ruby programmer), what type of inconsistencies would you worry about? I appreciate the feedback! Rob edit -- something like this? (not yet tested). Wouldn't be hard to extend with a timeout value, too. def service_thread Thread.new do begin run_service @run_queue.shift until Thread.current.key?(:stop) rescue Exception =&gt; exc puts "Service [#{@name}] =&gt; #{exc.inspect}" unless @suppress_exception abort if exc.is_a? SystemExit retry unless Thread.current.key?(:stop) end end end def stop(when=nil) @threads.each do |thread| when == :now ? thread.kill : thread[:stop] = true end @threads.each_index do |index| @threads[index].join @threads.delete index end end def stop! stop :now end
https://rubygems.org/gems/packetfu
To really understand a Ruby DSL it would really help to understand Ruby. A coworker recommended Russ Olsen's Eloquent Ruby book, and it was an awesome recommendation. I was coming into Ruby with a Perl (and not heavy OOP) background. The book is very readable yet concise enough to cover a lot of ground. If you don't want to or feel you need to understand the building blocks, it may be overkill. Personally my learning style kind of requires me to understand things from ground up to really grok something to my comfort point, otherwise I just frustrate myself. YMMV. Rob
I made the soft shutdown the default - that (I think?) should be a good compromise of keeping it simple yet reasonably reliable. You make a good point in that if a service fails, there is no concept of a message being in an on-hold/revert-able stage. If that level of reliability is needed for ShortBus, that could be added into the Service object by using an interim FIFO that tracks the message state and allows for optional retries in case a service raises an Exception. Hrmm..... OTOH, I think in a "true" asynchronous service oriented paradigm, if A &amp; B are different services, you would not call them synchronously from inside of W. Instead W would publish a message, which A would subscribe to. When A finishes it's processing, it then publishes a new message, which B subscribes to. But ShortBus really is a compromised approximation of that. Rob 
Try installing https://www.winpcap.org/install/default.htm and try again afterwards, otherwise switch to Linux/OSX.
Hi! Sure! Just uploaded it to [github] (https://github.com/throgow/middlemantest). Thanks!
Huge thanks for the reply, will definitely try this out! I'm still in the phase of learning both ruby and middleman and had no idea I could get that info from the docs (sometimes the answer is right in front of your eyes, but you don't really know what to look for!) My gut feeling told me it had to be something with the config.rb file, but I had no idea how to do it... I'll try this out and let you know if I succeed.. :-)
&gt; You probably want to use bigserial instead of serial, because of the larger amount of serial values (uuids are another option) Be careful using UUIDs as the primary key, it does nasty things to data locality (massively hurts insert performance). For read heavy applications that don't scan sequentially much it isn't a big deal but if you insert a lot of new records it can cause major performance issues. If you do need a UUID it's often a good idea to use version 1 since the time component will get you roughly sequential IDs (in terms of index ordering). 
&gt; For instance, constraining only the tran_details that have a mrp gte 70, but in the results returned only include the prate field (or any subset of the fields). `$elemMatch` can be used in the query as well: test.find({ "trans_details" =&gt; { "$elemMatch" =&gt; { "mrp" =&gt; { "$gte" =&gt; 70 } } } }).projection({ "tran_details.prate" =&gt; 1 }).to_a `find` determines which documents match, `projection` determines which parts of the documents are returned. Also - stop using mongo, there is nothing but demons and dragons there. 
I tried using the above command but it didn't work for me. If you look at the (elemmatch docs)[https://docs.mongodb.com/manual/reference/operator/query/elemMatch/] and the 'Array of Embedded Documents' example you'll see that the entirety of id 3 gets returned, not just the element in the array that matches the conditions given. I understand the mongodb concern; wasn't my decision. *Edit because I mistakenly thought it worked at first
Could you give an example of what you're trying to query? i.e. what is the result you are actually expecting to come back? 
If you only want the first transaction in each batch with prate &gt; 56 then this should work: test.find({ 'tran_details.prate' =&gt; { '$gt' =&gt; 56 } }).projection({ tran_details: { '$elemMatch' =&gt; { prate: { '$gt' =&gt; 56 } } }, 'tran_details.qty' =&gt; 1, 'tran_details.mrp' =&gt; 1, batch: 1, _id: 0 }).to_a If you want every transaction in each batch that matches some predicate, you'll need to use the aggregation or mapreduce frameworks. `$elemMatch` and the positional projection `$` only return the first match.
As a rails dev, all those code related problems are up to you to fix. If you were working for me and came to me with your hand out complaining the codebase was rails 3, I would wonder why I hired a dev that wants someone else do do the development. Part of being a programmer is upgrading and refactoring code, actually, that is most of it. You are basically complaining your job is not easy enough. So instead of posting on forums, why don't you fork the project and upgrade it to rails 4 or refactor those huge methods. A question for you: If you don't want to upgrade the project or refactor old code or write tests, what did you think your job would be? 
Thanks for the answer I actually do want to ('I was told it was going to be upgraded' =&gt; 'I was told updating it would be one of my first tasks'), but I'm told not to waste time with this (I had to clearly disobey my boss to implement the first unit tests)
Be sure to tell your boss(and maybe go over their head if necessary) that rails 3 has lost primary security support and soon will not be supported at all. I think ruby 1.9.3 is in a similar situation. At this point, not upgrading is a serious security issue.
http://thebuild.com/blog/2015/10/08/uuid-vs-bigserial-for-primary-keys/ Difference seems negligible on this small test. Do you have better numbers you can share?
- Don't treat it like the worst project ever, treat it like a fantastic opportunity to test your skills and learn new stuff. There can be great joy in improving a horrible codebase. - If there are no tests, it's your duty to tell your employer that making any changes to the codebase comes with a huge risk of breaking things by an accident, thus the very first thing you need to do is to add missing tests for every single piece of functionality that you need to touch - From now on, start writing tests every time you add new functionality and make it clear that this is how it should be done - Refactor only when you have good tests in place, the bare minimum is to have 100% test cov for the parts of code that you need to change. Start with high-level integration/feature tests, move to lower-level tests once you have a better understanding of the code - Don't try to upgrade Rails without having tests You're gonna do fine, and learn a lot, good luck (:
If they are telling you not to spend time refactoring or upgrading, do it while you're working on features or bugs. If you're working on a bug, write a spec for it first and make sure that passes, then start fixing the bug and refactoring small pieces as you go. You'll get very familiar with the code base by writing tests, and you'll be safe to do the refactor. As others have said, working on legacy code bases will be a large part of your job, and getting this practice in now will make you awesome down the road. Tackling adversity and working through it will almost always make you stronger. 
doesn't sound easy. https://youtu.be/3LbcdEe-xsY?t=1m54s
I have it installed already. I think this will just have to be a Linux project.
What you're describing is the bread and butter of a great developer in any language. It's easy to work with the latest technologies, but more people will pay you to work with the stuff that isn't as sexy.
So, welcome to your career as a software engineer! It's always a little bit frustrating to have to deal with legacy code, but, it's not the worst thing in the world. You will often be asked about experience working on legacy code like the project you mention. Take it slow, do what you need to do, and do one piece at a time. No documentation? Every time you touch the codebase, document what you're doing, and the surrounding methods. It might be slightly time consuming, but, the profit to the company will be evident the next time a developer needs to touch that code. If you get pushback, I would simply point out that if it took you 'X' amount of time to decypher that method, it will take the next developer near that amount of time to figure it out as well. If they do not understand how documentation improves productivity, you should start searching. You can probably continue to work there, but, any company that is actively resistant to improving their own bottom line is not healthy. Test coverage, is there something preventing you from adding tests? Again, start one place at a time, make sure you write tests for your own code, and if you can manage, test other portions as you get time and/or touch those portions of code. Large methods? Refactor them, as you refactor, add tests and documentation. Only do this as required by a feature implementation or bug fix. Don't take it on as 'I'M GONNA REFACTOR THE ENTIRE THING'. Take your time, make sure you test your code, make sure it operates as intended. Yes, as a rails developer you will have to touch HTML, templating languages, and JavaScript, this feels fairly normal. I don't have to do it often because my company has dedicated front end developers, but, I'm not expected to be completely ignorant of how to edit and maintain the front end. You're only hurting your career if you don't learn from the mistakes this company is making. Bad habits are a hard thing to avoid, because you're never really going to know if it's a bad habit or not. Focus less on defining 'bad' and more on writing code that is reliable and works. If you're writing tests, you're already backing your code with proof that it works. If someone finds a case where your code breaks, you write a new test for that scenario and improve your code. Would I recommend you to read books about good practices? Yes? But, more of a general you should always be reading books. Practical Object Oriented Design in Ruby is often recommended. Make sure to have a copy of the pickaxe book, also the Rails ? Way, where ? is = to the version of rails you need a guide for, is also useful. Always be learning, always be improving.
Thanks a lot for your answer
It would really help if you tell us the process you wish to follow (think in java/python if you have to) and ask us for help on specific steps.