On my system: [1] pry(main)&gt; "hey dude, axd 9001 upvotes for you" =~ /hey dude, [abcd]{,10} \d+ upvotes for you/ =&gt; nil [2] pry(main)&gt; "hey dude, axd 9001 upvotes for you" =~ /hey dude, [abcdx]{,10} \d+ upvotes for you/ =&gt; 0 Seems to be working?
Great idea. It's surprising how helpful reading code can be. Thanks. 
Awesome. This list should keep me occupied for quite some time. I really appreciate it. 
Anything form thought it is gold. I'll check it out. Thanks. 
I had confident ruby on my list because I had heard it was good, but looking at the table of contents quickly I got the wrong impression that is be rehashing stuff I knew. I'm going to give it another go. Thanks for you recommendations. 
I gotta say this is what I love about the ruby community: the culture of learning and collaboration, everyone so willing to help people get better at what they do. Thanks everyone.
Nice site. I bookmarked it. 
&gt; Good luck on that chapter. My wife did this series and this chapter resulted in the most confusion and frustration. Now you know why it's called "Learn Ruby the Hard Way". ;-)
&gt; It is passing because the a and the b match. In the particular example only "a" matches. The match operator returns once the first match is found. You can see this easily: irb(main):002:0&gt; str[/[abcd]{,4}/] =&gt; "a" 
I'd start with Sinatra, it's easy and fairly straight forward. Once you start making more complicated apps you'll understand why more involved frameworks like Rails do most of what they do. http://www.sinatrarb.com/intro.html Also, I'd just bookmark this for later: https://www.railstutorial.org/book It's *the* Rails book, and will get you going from zero to capable better than any other resource I've read. 
What's "rad rails"?
As /u/IUseRhetoric stated, ARGV is an array containing all the arguments passed to your script, you use this so you do not need to take input interactively during execution so you can easily script the execution of your program, also because that's just the standard UI for command line applications. However, /u/IUseRhetoric was wrong about the use of `gets`. `Kernel#gets`, the 'default' gets actually has some [interesting behavior](http://ruby-doc.org/core-2.2.0/Kernel.html#method-i-gets): &gt;Returns (and assigns to $_) the next line from the list of files in ARGV (or $*), or from standard input if no files are present on the command line. So, if a string you passed to your application is a valid filename or list of filenames then ruby will go ahead and open them behind the scene for you and start feeding you data every time you call `gets` until all of them have been read. If you are explicitly wanting to read data from STDIN instead of arbitrary files passed as program arguments, you should always use `$stdin.gets`. This is one of the fun perl-isms you'll find in ruby that most of us loathe to admit exist, but here it is for better or for worse :) 
Maybe it's [this IDE](http://www.aptana.com/products/radrails.html)? I haven't used it... interesting that it has EngineYard integration though.
Absolutely. However, the title makes me think the article will be focused on the various ways you can merge a hash. This might include diving into something like giving `merge` a block to resolve conflicts or mentioning `reverse_merge` from Rails. Instead the focus is largely on the performance differences between `merge` and `merge!`. I'm suggesting that a title like "Performance Differences Between Merge and Merge!" would have been a better fit. If people expect one thing and get another it can damage their opinion of the work.
It's not really radrails anymore. It's just Aptana studio. Decent editor based on Eclipse. You might want to try RubyMine as an alternative. Still heavy on the ruby/rails integration but more actively developed and includes some additional features that make it feel more nimble. 
It's really a matter of preference. I personally use parens as soon as we get past a single parameter, or if there's a block involved. There are some excellent style guides that cover this and many other situations: http://stackoverflow.com/questions/616037/ruby-coding-style-guidelines
There is a [Ruby edition of Refactoring](http://www.amazon.com/Refactoring-Ruby-Addison-Wesley-Professional/dp/0321984137).
I use them only when required. This forces me to adjust how I call methods to avoid parentheses and makes my ruby more clear. If I need to call a method for a second method's arguments I put that on a separate line. The only place I use them is when supplying a block or splitting an array.
I only use them to clarify any ambiguity for the interpreter.
you might even provide some controller support so this can be accomplished with a simple after_filter, something like after_filter :mark_models_as_viewed which could take care of the pipelining logic
**Trip** Although you're intending to store trip data in trip: t = Trip.new(["bike 01", "bike 02"], ["bob", "mary"]) in the `Trip` constructor, the storage of the bicycles and customers are once again delegated to the `Mechanic` and `TripCoordinator` classes: def initialize(bicycles, customers) @bicycles = Mechanic.new(bicycles) @customers = TripCoordinator.new(customers) end At this point, there's no need to involve `Mechanic` and `TripCoordinator`. The `Trip` can just store the data on its own. *Try to make it so that a `Trip` operates like so*: t = Trip.new(["bike 01", "bike 02"], ["bob", "mary"]) # you can now "ask" the trip t for its associated bicycles and customers: t.bicycles # =&gt; ["bike 01", "bike 02"] t.customers # =&gt; ["bob", "mary"] **Mechanic** and **TripCoordinator** If these two classes are not to store trip data, it shouldn't require trip data (bicycles and customers) to instantiate them: m = Mechanic.new # no knowledge of what bicycles exist tc = TripCoordinator.new # no knowledge of what customers exist *Update `Mechanic` and `TripCoordinator` constructors to not store bicycles and customers.* **Testing Expectations** Let's break down the full problem into smaller, testable chunks. As you work along, test the following snippets. Even though `Mechanic` `m` stores no bicycles, `m` should still be able to prepare them: m = Mechanic.new m.prepare_bicycle("test bike") I would expect that `m` could prepare a bike stored in a different place as well: t = Trip.new(["bike 01", "bike 02"], ["bob", "mary"]) first_bike_in_t = t.bicycles[0] # get a bike m.prepare_bicycle(first_bike_in_t) # pass it to m But remember, `m` also responds to the method, `prepare_trip`. It should be able to get the bicycles own its own, given the trip: t = Trip.new(["bike 01", "bike 02"], ["bob", "mary"]) m.prepare_trip(t) # pass t to m.prepare_trip These above tests can be done in a similar way with `TripCoordinator`. Of course, the last test to make is: t.prepare(trip_preparers) I've not revealed what trip_preparers is here, but going by the method definition of `Trip#prepare`, every one of the `trip_preparers` should be able to respond to the request to `prepare_trip` on the `Trip` `t` itself. **Object-oriented** Thinking about `m` and `t` like objects, `m.prepare_trip(t)` means, "`Mechanic` `m`, I want you to `prepare_trip` the `Trip` `t`". In the past, you've been doing `m.prepare_trip(m)`, which means, "`Mechanic` `m`, I want you to `prepare_trip` the `Mechanic` `m`, i.e. yourself", which doesn't really make sense.
True rubyist omits them whenever it is possible. 
I've been burned by not having parens in a view when we upgraded from ruby 1.8 to 1.9 (rails 3.2 IIRC). That made me want to always use parens but I think it's cleaner not to in a lot of cases so I settled on testing that the views render (note: just that they render. I don't test view logic). I usually try to format method calls like this: method arg1, arg2, param1: param1 param2: param2 I think it's nice and readable.
I use parentheses when I use the return value, and omit them when I the method performs an action. In other words, to communicate [command-query separation](http://en.wikipedia.org/wiki/Command%E2%80%93query_separation). This also tends to work well in terms of precedence, for example when using a return value as an argument. I also omit parentheses for parameter-less queries, because Ruby doesn't make a distinction between attributes and methods.
&gt; How to save time by understanding of semantic versioning? 13 is higher than 8, I don't even understand how the confusion happened in the first place.
Haha, his confusion confused me!
It depends. When I'm creating methods with arguments, I always use a parenthesis, otherwise it looks like it's part of the method's name. Basically if it improves the ease of reading code then I'll use it.
I omit them whenever I can, however "can" does not include when it would make the code more ambiguous or harder to read. Most of the time they aren't necessary. 
Hi, You must open Integer class, and define number_of_days inside it. class Integer def number_of_days #operations end end then you will be able to use it. otherwise you'll have to use number_of_days like this: number_of_days(2015)
 require 'date' Date.new(2015,12,31).yday
yes, because ruby doesn't care about whitespace that follows binary operators like that. It will just look for it on the next line. Not sure if you know this but you can also insert a linefeed after the dot in a method call and put the actual method call on the next line, too. So for example grid. transpose would work too. And while I'm on tips, Ruby also ignores the last comma in an array list, so for example: &gt;&gt; [1,2,3,4,] =&gt; [1, 2, 3, 4] which is convenient because that means you can break out an array into lines like this, and not have to worry about missing a comma if you move the last element or add something after it: [ 1, 2, 3, 4, ] 
OP is asking for the method, not the implementation.
I use them: * if it is a method definition and there are parameters * if it is a method call and there is more than one parameter, but it is not a class method like `validates` * if it is a method call and it would be ambiguous without them. Rails form helpers often have a bunch of parameters ([`grouped_collection_select` can take up to 9 by my count](http://api.rubyonrails.org/classes/ActionView/Helpers/FormOptionsHelper.html#method-i-grouped_collection_select)), but they are almost always unambiguous
Yep, that works: 2.2.0 :001 &gt; def maybe?(param_1: 'We shall see', param_2: 'young Skywalker') 2.2.0 :002?&gt; "#{param_1}, #{param_2}" 2.2.0 :003?&gt; end =&gt; :maybe? 2.2.0 :004 &gt; maybe? =&gt; "We shall see, young Skywalker" 2.2.0 :005 &gt; maybe? param_1: 'Eat a dick' =&gt; "Eat a dick, young Skywalker" 2.2.0 :006 &gt; maybe? param_2: 'but tonight, no dinner for you' =&gt; "We shall see, but tonight, no dinner for you" 2.2.0 :007 &gt; maybe? param_1: 'Obviously', param_2: 'this is a pretty contrived example' =&gt; "Obviously, this is a pretty contrived example" 
Nice! I mean, I really doubt I'll ever use it, but nice.
If I'm not mistaken, isn't it better form to do something like grid .transpose .some_other_method if you really need to break things down to multiple lines (for style's sake or whatever)? This helps you to see that the new line is a method call on the previous line and the indent illustrates where the chain starts. 
Why would you return the exception? Either handle it or throw it higher
I have a long history in C, C++, and Java. Discerning what's a variable vs what's a method helps tremendously.
yeah, see a normal year has 365 and a leap year has 366 I know that stored in the dates must include the variance in month length, because if it didn't it would screw up on a leap year. so I wanna know how to count the number of days in a year so I can save that number in a variable to check if it's 366 or 365. and I am aware of the other ways, but I would want to use this methodology instead. 
Thanks, I forgot I can throw it. That makes much much more sense TY :) 
Yes
a) 'trow' is a typo b) 'throw' isn't right either, that's different little-used functionality. c) you want raise. It ought to work. I do it all the time. 
Sorry, you must have a typo or other bug somewhere. You can definitely re-raise from within a rescue, it works fine. Your problem is elsewhere. Again, it can be useful to create a little test script to test out your assumptions and make sure they are working how you think. Why not try it? def test_it begin raise "Raised" return "never get here" rescue Exception =&gt; e puts "we rescued #{e} and are going to re-raise it" raise e end end test_it results in: we rescued Raised and are going to re-raise it /Users/jrochkind/code/test.rb:3:in `test_it': Raised (RuntimeError) from /Users/jrochkind/code/test.rb:11:in `&lt;main&gt;' The exception was definitely raised again, and caught by the ruby interpreter console, as indicated by the stack trace printed out. You could make a more complicated example too. Another useful tool for debugging is a debugger. If you are using ruby 2.x, try byebug. 
Note that you very seldom want to rescue `Exception`. You normally should us StandardError as your catch all. Exception includes some deeper system level errors that are normally smarter to bubble up. - https://robots.thoughtbot.com/rescue-standarderror-not-exception - http://stackoverflow.com/questions/10048173/why-is-it-bad-style-to-rescue-exception-e-in-ruby
It won't work to put the dots like that - they need to be trailing to give the parser enough context. But the indentation is indeed good practice. It would need to be: grid. transpose. some_other_method
Hear hear. There are literally dozens of us.
Thanks for the suggestion, but that's not what I was looking for. I was looking for combinations, which would produce every possible set of three elements without regard to position. In the usual way I would do it with C, the output would be something like: (1,2,3) (1,2,4) (1,2,5) (1,2,6) ... (8,9,10)
Nope, combinations. I think I've got it, but now I need to know how to display the combinations together rather than each element on a line.
I'm mobile, so I can't test this ATM. I think this should print each combination in its own line. arr.combination(3). map { |a| a.join(' ') }. each { |s| puts s}
Thank you, I'll check it out. edit: that produced the same thing as combos = list.combinations(3).to_a combos.each { |i| p i} which is ok, but still not the format I'm going for. /u/ramonmaruko's solution of: arr.combination(3).map { |a| a.join(' ') }.each { |s| puts s} seemed to work, and I think I understand what is going on with that. I'm not sure what .map(&amp;:to_s) is doing, nor why it produces the same results as the code I tried earlier.
For your outputting question, just use `Array#join` and choose your formatting: arr.each { |a| p a.join(" ") }
Huh, you're totally right, and it even worked in 1.9.3 in /u/seriouslyawesome 's style when I tried it just now. But I could swear I've had trouble with this before!
 [1, 2, 3].map(&amp;:to_s) is equivalent to: [1, 2, 3].map { |i| i.to_s } Which calls the #to_s method of each element in the array. [These](http://stackoverflow.com/a/1961118/159177) [links](http://stackoverflow.com/a/14881476/159177) will explain it better than I could.
From your other comment, what you expect is this, right? (1,2,3) (1,2,4) (1,2,5) (1,2,6) ... (8,9,10) In that case, I think this improvement might work. arr.combination(3) .each { |combination| puts "(#{combination.join ',' })" }
It returns an [Enumerator](http://ruby-doc.org/core-2.0.0/Enumerator.html). Enumerator is basically an iterator; you can call next on it to get the next value. It is commonly used for external iteration. Source: [RubyDocs: Array#combination](http://ruby-doc.org/core-2.0.0/Array.html#method-i-combination)
OH! I understand the confusion, thanks!
Having inherited too many code bases I'd ask if you might reconsider dropping the params for single param methods. The 'def foo(param)' pattern is a handy visual pattern when scanning a large code base and makes the code more visually consistent.
Ah, to clarify, I personally always include the parens in method _definitions_, but omit them only in method calls. `def foo(param)` but sometimes `foo param`. I was going to write `x = foo param` but realize I'd probably include the parens there too in an assignment. I guess I don't really know what my 'rules' are. But i always include the parens in method definitions. 
I try to always use them on rvalue expressions, and I kinda don't have a choice with nested expressions. Otherwise I omit them. E.g. here are the three most common cases where I encounter them and how I use them: result = method(param) method(method(param), param) method param
That works too.
cause windows is made for excel junkies and not for developers
I posted the method I made
 require 'time' # Necessary for Date.today # Generate some "People". Adapt this to your actual data people = (1..20).map do |i| {name: "Person #{i}", birthday: Date.today + i} end # Make a new array of People only with odd birthday months people_with_odd_birthday_months = people.select do |person| person[:birthday].month.odd? end # Make a new array of the first 10 people with odd birthday months first_ten_people_with_odd_birthday_months = people_with_odd_birthday_months.first(10) # Loop over the final list and print their name first_ten_people_with_odd_birthday_months.each do |person| puts person[:name] end This can also be done as a one liner like: (1..20).map { |i| {name: "Person #{i}", birthday: Date.today + i} }.select { |person| person[:birthday].month.odd? }.first(10).each { |person| puts person[:name] } When dealing with subsets of data, take full advantage of ruby's map/reduce functionality such as #select, #reject, #map, #find, #first, etc. They are really useful and concise.
`people_array.lazy.select { |p| p.birthmonth.odd? }.first(10).each { |p| puts p }` ---- `lazy` isn't strictly needed, and is more of an optimization for a very large sets of data, that could be bigger than your memory. [See here for more info about lazy](http://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy) The rest is pretty simple ruby. `select` passes values through its block and returns any for which the block is true. In this case, the block has `odd?`, which is a method of Fixnum, and returns true/false if a method is odd/even. Then its just up to the `first(10)` to say we only want the first 10 results, then stop. It, like most other things, returns another Array, which we then enumerate over with `each`, printing the results.
is not? [1] pry(main)&gt; 10.0 == 10.000000000001 =&gt; false 
&gt; 10.000000000001 You did too few digits. Seems to happen at 16+ decimal places.
I believe it's a fairly new feature so you haven't really been out of the loop for too long.
Stupid reason. Same float calculations go for most programming languages. That's the reason you don't do money calculations, science calculations or anything where loosing some precision matters using floats! Learn your data types THEN start doing science. 
Middleman is a static site generator. The output of middleman is simple html/js/css, which inherently cannot do special things. You should attack the problem the same way you would password protect a simple html file, without considering middleman... which means you would need something to go in front of your html, which if your webserver can utilize htaccess, that would be the solution.
Fired up python and tested it... well turns out python also says its true. Well I did expect it, because of the floating point precision
lol true
except that's an until block that's explicitly decrementing it manually. That only works on block functions mate.
You're going about ruby wrong mate, look into Enumerable: def find_product(n) (0..n).select { |i| i % 3 == 0 }.reduce(0) { |accumulator, i| accumulator + i } end Though reduce takes a shorthand. I just write it out in full form for people likely seeing it for the first time: (1..10).reduce(0, :+)
There's something called the hallway test where you grab a couple of mates and get them to sanity check you. If I were you I would seriously take down this article, as it really does paint you as painfully incompetent. I don't say that to be rude, but it's not doing you any favors.
That's silly, IEEE 754 double precision floats are default type of floating point numbers in pretty much every programming language out there. The only exceptions I can think of are SQL, Cobol, and Excel, and all are just fucking insane in what they're trying to do instead.
Okay, maybe not comprehensible if you're 5, but an excellent explanation all the same. What Every Computer Scientist Should Know About Floating-Point Arithmetic http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
Typo in the byebug area, 'balled'. Most people know of these tools, it would be more constructive to explain in some more detail what each of them do and perhaps show a workflow. I'd done a presentation on pry a while back that might be useful for building on: http://slides.com/brandonweaver/unleashing-pry-1#/
From behind. Always from behind.
I have been using Ruby on Windows for years, feel free to ask me anything. Go to http://rubyinstaller.org and install Ruby. Then, before you do anything else, install http://rubyinstaller.org/add-ons/devkit so you can build gems with native extensions. Then use the `gem` command to install everything else as you would on Linux. So, what's the problem?
Ruby or Rails?
It might be too late in your dev process, and I know that this does not answer your question, but is there any reason not to use Postgres? https://twitter.com/tonymillion/status/417213069572714496
O I did not know that. I read that mysql2 doesn't support prepared statements. I don't know how else I would cover sql injection without it. mysqlplus appears to only allow query. if i read it right? Is there another way to handle injection that i do not know about ? 
I develop on a windows machine. Ignore the haters, it's fine. I use Uru for ruby environment manager: https://bitbucket.org/jonforums/uru And Sublime for text editor: http://www.sublimetext.com/ I hope this helps.
It does, thanks! 
Better yet, install Vagrant, vagrant box add ubuntu/precise32, vagrant up, vagrant ssh, sudo apt-get install emacs git, then download RVM or your Ruby manager of choice, gem install rails and you're ready to rock. Put it all in your Vagrantfile so you can rinse and repeat the same process on any host machine.
I second this.
I tried this out in Erlang, although its comparison operators are interesting because they already consider: 6&gt; 10 =:= 10.0. false Anyway, code: -module(check). -export([check/1]). check(N) when N == 10.0 -&gt; io:fwrite("Ten~n"); check(N) -&gt; io:fwrite("Not ten~n"). Output was consistent with Ruby: 5&gt; check:check(10.0000000000000001). Ten ok Meanwhile, let's try C: int main() { if (10.0 == 10.0000000000000001) { printf("Floats are equal"); } } ./cfloat Floats are equal 
I can't watch it on Twitch for some reason - but would love to see this. If you get it on YouTube or similar please let us know!
Nope. I don't want a CMS. If that would be the case I would be using Rails or something similar. Due to client constraints (pricing of the server) I cannot use any server-side language. No database on their part. No ruby, no php, no python, etc. Using a CMS would be a huge overkill. This is a simple web site, having a password protected area. Ergo middleman. 
Step back and look at the sums you're generating; I think you can avoid loops/accumulations/reductions completely. Assuming you want the sum at the end (i.e. **b** in your example), here is a short/fast/portable solution: def findprod(n) (n+3)/3*1.5*(n/3) end EDIT: Wrap it all in a *( ... ).to_i* if that's desired.
I like to think about the API first. After this is done I layout the basic classes, helpers and whatnot. Without using too many classes, but after a while, when I have the feeling that I should separate this feature from another one I refactor my code - and adapt my tests if necessary. The hardest part for me is always to find the golden ratio between abstractedness and usefulness. Starting from the API helps, as you don't do unnecessary generalizations. For instance: You have a simple Rails class, called entry. Each entry could have a commentary. Do you make a relationship between the class entry and commentary? Or do you append the commentary field into the entry class and leave it NULL by default? This is hard to decide from outside. If my app is big already I would just append it. If it is rather small I would go with the relationship. (Leaving out other constraints.)
Yes. "Print" is just a method. http://ruby-doc.org//core-2.2.0/Kernel.html#method-i-print Also, you normally use "puts" instead of print, because this will automatically add a newline ("\n") to the end of the string. 
Ah OK.. I get it now, you want to restrict access to certain parts. Sorry.. I have teh dumz, as that was obvious from your post. Honestly, I can't think of any other way to do it other than via .htaccess, though you can build up reasonable sophisticated auth models around it. I'd not recommend leaving credentials in the text file on the server (ala _AuthBasicProvider_) and looking at something like _mod_authn_dbd_. You can have a bit more control, and credentials are stored elsewhere. Hope that's useful - and apologies for the confusion.
Also, will its code be in Github?
Ohh, very nice! Thanks for sharing your wisdom!
Yep, the code is already available here: https://github.com/tomdalling/fruity_bat
I'm not sure why this post is focusing on the now-deprecated `should` monkeypatch... Although the feature is unlikely to be removed from RSpec for a long time (if ever), you should always write tests with: expect(something).to whatever rather than: something.should whatever
"Live game dev in Ruby (in about an hour)" Oh, sweet! "submitted 15 hours ago" Damn it! Let us know when you upload the video to YouTube. I'd love to watch it!
That's exactly how I handled it after looking around for a while and (like you) finding nothing more ruby-ish.
Is the `should` method simpler than `expect(...).to`? Perhaps *slightly*, but I'd hardly call it *substantially* better, or in any way "more in line with BDD"... The big issue with the `should` syntax is that is does not work on all objects (e.g. delegators), and so can (i.e. one day will) cause weird unexpected test failures. Or even worse, can cause tests to pass that should be failing! If you are using RSpec 3+, you will see a deprecation warning every time you run a test suite containing any use of `should`. The only reason it might never be removed is because there are many big old test systems using RSpec, with heavy use of the `should` method. And even though upgrading to the recommended `expect(...).to` syntax is *normally* very easy, the RSpec team are understandably hesitant to break so many test suites! Read all about it: https://github.com/rspec/rspec-expectations/blob/master/Should.md https://github.com/yujinakayama/transpec
http://www.rubydoc.info/gems/rspec-expectations/RSpec/Expectations/ExpectationTarget The `expect` method receives any object, and returns a new `RSpec::Expectations::ExpectationTarget` instance.
Mechanize is used in threaded projects all the time. I think you'll have to provide more details about how you are using it
&gt; Perhaps slightly, but I'd hardly call it substantially better, or in any way "more in line with BDD"... The word "should" is an exceedingly important part of basic BDD vocabulary. It is substantially better in my view for that reason.
Or burn out and learn to hate programming. That happens a lot. 
On the contrary, the word `should` is, if anything, wrong! Alternatives like `must`, `shall` and `required` are more accurate. http://www.ietf.org/rfc/rfc2119.txt Furthermore, you can't seriously be suggesting using an inferior test framework, for the sake of one little word, right?!... Also, one little shorthand that's been added to the RSpec language is: it { subject.should do_something } # Old style (deprecated) it { should do_something } # Old style (deprecated) shorthand it { expect(subject).to do_something } # New style it { is_expected.to do_something } # New style shorthand!
You can use youtube-dl to download from twitch. 
Callbacks and observers always sound like a great idea for sending email to new users until you want to create new users without sending an email. Once you realize that it sucks to have to override the event listener or suppress the event if you want to make a user without sending an email, you start to understand why callbacks and observers are seen by many as a code smell. I don't see why you would couple these all so tightly when you could have a user model and a UserRegistration service which uses the user model and EmailNotificator to create the user and send the email. Now instead of User.create you do UserRegistration.create. If you need to make a BulkUserRegistration service later, you can use the user model for storing the user, but not have to worry about a magical observer somewhere automatically sending out emails. 
You're still using Sequel as you would a prepared statement. Try this instead: ds = db[:User] # = select * from Users puts ds.all # will give you an array of rows from the above result ds.each { |row| puts row } ds.each { |row| puts row[:password] } Bottom line: what you get from either db[:User] or db.fetch( "select * from User" ) is a dataset, not a single row. You need to iterate over it to get each row, and then you can select the columns from said row. Now if you just want all passwords you could do either of db[:User].select( :password ).all db.select( :password ).from( :User )
Actually, that wasn't useful either - given that you've already said you can't have a database. In that case, .htaccess is still the way to go, albeit with a more standard permissions model. Funnily enough, I've had to look at a similar problem for a nanoc site. The approach I was thinking of was to use Capistrano for the deployment (as opposed to rsync or ftp) and instrumenting it to generate .htaccess files - and ensure that the permissions on the files are set correctly.
Alright, I was able to get it to work. But I am confused unfortunately. I understand that I am getting back a dataset. which appears to be an array of hashses. I am even able to get the hash I want. The part that confuses is me how does this code work ds=db.fetch("select * from User") puts ds[:affdfds] # im expecting an error but it outputs the first line puts ds.first()[:password] # works as expected Since it looks the ds is an array, why does second line do anything? Sorry for being annoying, but If I don't understand it I can be missing something can become vital at somepoint 
I just cloned and ran it once. Your copy and pasted prompts aren't right for what your asking in the rows and columns, it asks for rows twice. Its also very difficult to make a move. Ill look at the code in a bit an see what changes can make the game better. It looks interesting though but just not user friendly at the moment. edit: a few words added
what are they going to do about the JSX markup support? just wondering
Why do they need to do anything about it? Their DSL is pretty concise: https://github.com/zetachang/react.rb/blob/master/example/react-tutorial/example.rb#L18
There's a recording available on Youtube now: http://youtu.be/QtIlyU2Br3o
There's a recording available on Youtube now: http://youtu.be/QtIlyU2Br3o
It defeats the purpose of having jsx and react then. Not even sure anymore why you'd need to access react from ruby code in the first place following similar logic? it's not like you can think you could program client side behavior in ruby anyway. EDIT: I love you people, forgive my ignorance please :)
&gt; it's not like you can think you could program client side behavior in ruby anyway. Isn't that the whole *point* of Opal? You don't have to *write* JS to *run* JS anymore, and haven't for a fair length of time now. Opal just rubs that in nicely.
okay, you guys are right. i got my Ruby think-cap back on now :P
What do you mean the copy and pasted prompts? Like where you input a move?
The game set up ones
 or rows and cols. it asks for rows twice edit sorry about the bold, that was an accident i was on mobile
http://imgur.com/fQQETPA works for me?
did you run the shell script in the repo after cloning the repo?
&gt; Please enter the amount of rows that you would like to play with, anything more than 20 will be truncated This line appears twice. It does not ask for cols. It asks for rows twice. Your screenshot shows the exact same thing. Edit: I just fixed this in a pull request.
The ruby DSL is just perfect as a replacement. Otherwise, a haml/erb transpiler could be a nice addition.
What's with this hacky installation process? Make it a gem, and add an executable that way! http://guides.rubygems.org/make-your-own-gem/#adding-an-executable
now it makes sense, with my Ruby think-cap. I think I had um.. another one on.. I actually never used Opal before cause I'm comfortable with javascript, but if I weren't then I think at some point you'd wanna understand what the Opal compiled javascript does. that's another discussion though. That's just my opinion... I love you all :)
I see what you mean. I guess my point was that most of these are problems with the eco-system, which is to say *us*. E.g. Rails requiring V8 for LESS had me tearing my hair out on one project because the rubyracer gem is impossible to get to work on Windows. Then LESS was replaced with SASS on that project and the need for rubyracer went away. How hard was that? :) Just don't do stupid sh*t, and everything works just fine. Of course Unix scripting, fork and such, will not work on Windows, but that is to be expected. There are Windows-specific solutions for those problems. My objection to your original comment largely boils down to this: when we tell people that in order to use Ruby they must to switch to Mac/Linux or use a VM, we are not pushing Ruby people away from Windows, we are pushing Windows people away from Ruby. And that's not good for Ruby.
You are in for a culture shock :) Most rubyists do not use any IDE, opting for a plain text editor and a command line and a REPL ([pry](http://pryrepl.org/)) to execute the code. This culture change may be a much bigger hurdle for a .Net developer to overcome than the whole Windows vs Unix thing.
i want to see a remote_object that you can called from the frontend without the need for wiring routes and controllers. that way an opal app can call a model directly.
Don't forget Chocolatey! https://chocolatey.org/packages?q=ruby C:\&gt; choco install ruby 
nothing
What tooling? (seriously curious) 
i think volt (maybe) does too much. i just need to call a model from the frontend using existing frontend libs :)
I love you too
Merged. Thanks. Also, I've never done a gem but I can make it one when I get the time!
mmm, i apologize for the mistake. But you are totally right. I will rectify this as soon as i get the time. And maybe read about Ruby syntaxic sugar and blog about it :). Thank you for your feedback
I am somewhat confused on inheritance in ruby. I am creating a subclass and I am trying to reference instance variables that are initialized in the constructor of the parent class. What am I doing incorrectly?
It looks to me like there's no @mutex defined for a brand-new Queue (or PeekQueue) instance. 2.1.2 :001 &gt; class PeekQueue &lt; Queue 2.1.2 :002?&gt; def add_variable 2.1.2 :003?&gt; @test = "test" 2.1.2 :004?&gt; end 2.1.2 :005?&gt; end =&gt; :add_variable 2.1.2 :006 &gt; pq = PeekQueue.new =&gt; #&lt;PeekQueue:0x007f8c33863230&gt; 2.1.2 :007 &gt; pq.instance_variables =&gt; [] 2.1.2 :008 &gt; pq.add_variable =&gt; "test" 2.1.2 :009 &gt; pq.instance_variables =&gt; [:@test] 
For those who haven't used 2.x before, here's a [very important discussion](http://stackoverflow.com/questions/27102565/memory-usage-increase-with-ruby-2-1-versus-ruby-2-0-or-1-9) about GC issues still present in 2.1.5. One of the main reasons you may want to use 2.0 (or look further at 2.2).
Definitely- especially in the areas of packaging/containing projects in multiple files.
Conservative Linux distro repositories, maybe? Like CentOS 6.5 can't get anything above 1.8 from an official yum repo. So if you're in an environment where policy restricts you to a certain distro and locks down the repos you can install from, 1.8 is all you'll ever have.
[This stack overflow thread may be relevant to your issue](http://stackoverflow.com/questions/21735401/using-class-instance-variable-for-mutex-in-ruby)
How can I get my vim to look as beautiful as yours? I would switch from sublime for that.
You don't say. Java (or jruby) for the server code, with the assets being written in Ruby via opal.rb and transpiled to Javascript.
You can also implement a protected method, `def &lt;=&gt;(other)` in the class of the object you're sorting to accomplish the same thing. If you don't envision this being the only way this object will always be sorted, you could build a wrapper class around your object using SimpleDelegator for this domain concept. Interesting tidbit: this situation is actually one of the only things protected methods are good for, so take advantage of it!
You can find an overview over [here](https://www.ruby-lang.org/en/news/2014/12/25/ruby-2-2-0-released/).
Do you have a sense of whether those GC issues are resolved in 2.2, and whether 2.2 is generally stable and reliable? I'd rather jump all the way to 2.2, if only to postpone the next time I have to do this! 
This is me :(
It seems to be elementary for everyone, but it's just going right over my head. I'm trying to grab the name of my database in this case, but I don't know what the code is supposed to look like. I think I'm supposed to use: JSON.parse(ENV['VCAP_SERVICES']) Then I have an array, but I don't know how grab the database name as it's in an array within an array.
Redhat is pushing "software collections" (SCL) as a solution to this. it's basically an additional repo with a sandboxed runtime that is updated more frequently than the base OS.
&gt; this Using the data from the example: my_json = JSON.parse ENV['VCAP_SERVICES'] my_json['mysql-5.1'][0]['name'] # =&gt; mysql-4f700 Once parsed, you're simply accessing regular Array and Hash objects.
I'm only speaking for myself, but phone calls should be a last resort. Try to personalize messages you send out. I get messages on LinkedIn all the time saying "Your resume is awesome!", but I don't have a resume on LinkedIn. And keep the emails short and concise, no buzzwords. I look for: 1. What the job entails 2. Who I'll be working for 3. Salary &amp; benefits I know 2 &amp; 3 aren't always able to be discussed up front, though. That's just my $0.02!
Recruiters in the UK are very protective of revealing where a position is at or sending a job spec. They always want to get me on the phone and 'present' the opportunity when an email would suffice.
I still don't see the problem. Rails.cache.fetch("cache-key-name-#{object_id}",.... Okay, so if object_id is nill, the cache key turns into "cache-key-name-". So? Shouldn't that still be cached? Is the problem that: SomeInternalApi.getCoolObject(nil) Was _raising_, and the raised exception prevented the cache? Hard to say. If so, that's not really about nil so much as raises inside your `cache.fetch` block preventing caching. Or am I just totally missing it?
I thought of rehl as being secure though.
Humble pie; served up from the command line. Great stuff.
Sorry to be late to the party. I'm working on a gem to simplify all the openssl stuff... here's the one-liner I am using in it to do exactly that. OpenSSL::SSL::SSLSocket.new(TCPSocket.new('my.servercom', 443)).tap{|e| e.connect}.peer_cert_chain
It doesn't work on windows, as windows doesn't have support for pty
This was my material for a http://turing.io/ elective. Sadly I packed too much into day 3 and we only covered about half :( But I got to talk about the stuff I care about: testing and design, and had a decent finale by fetching the gem one of them published and then opening it up so they could see all the files inside. Topics: * environment (permissions, shebangs, commandline arguments, stdout, stderr, file globbing, executing other programs) * testing (how to keep your tests useful and flexible, what to look for saying to test at a lower level or higher level, why testing is hard and how to use that feedback to improve your design) * Gem structure (file hierarchy, readme, Bundler, gemspec, tests, lib, executables, license, what a version communicates, naming patterns, namespacing in the file path and the object hierarchy)
First, for reference, I probably get 3-4 messages a day. I'm an Intermediate to Senior Level in Frontend Dev and DevOps. I work at a major Bay Area company. My LinkedIn is here for reference: https://www.linkedin.com/in/keystonelemur Let's go for my personal strikeout list: * You fail to mention the name of the company - Have the decency to name your client, or we can't do our due diligence on it. * You fail to read our profile - If I get a message about a Java job, I will reject it instantly, period. * I've only been at a job for under a year - Chances are I don't intend to move that fast * You send anything that looks like a generated email - We're people too, we don't like being treated as cattle to be pushed for profit. * You say a single business buzzword- Synergy, hip market, trendy product, done. * You send a job that's way above or below my current level - definitely not a CTO level, but sending a junior level position will get an equal ignore. Now how to get my attention: Let's reference by LinkedIn here. I have an entire section that lists advice in contacting me, including things I love, like, dislike, and loathe. It's also worth a note that I list as not looking. You send an email that states clearly in the subject what you're doing (Big Data Startup seeking Clojure Devs) and a good description of what the company is doing, you're at least getting a reply for effort. Bonus points for relevant job descriptions, company details, and any publications / open source projects I can dig through. It's like a gold mine to me if I can see what type of code a company churns out, because normally it's a mystery bag potentially loaded with legacy code and the stuff of nightmares. I show you my code you show me yours, a fair arrangement to me at least. Quite simply the more transparent you are with me the more likely you are to get feedback. Also, agreed on phone calls, I'll flat out blacklist the number and never think twice about it.
Don't push to get me on a call. If I say I'm free next week, just schedule a call next week and be done. I've had several recruiters come back with "how about tonight at 6 or first thing tomorrow?" - did I fucking say tonight or tomorrow? No. I said next week, and I mean next week. Push my timetable and I push delete. On the flip side, you're clearly trying to be polite and not pushy, and that's a very positive thing. I only work with recruiters who understand I'm a person and not a product; it sounds like you're that kind of recruiter, so thanks for being decent! 
All right. Many thanks. If I have time, I'll try to come up with a gem.
If you're single and male, try online dating. It's about the same. :) If you're single and female, try online dating. You'll quickly understand how it feels to be a high demand IT pro. :) I'm in IT rather than development, but most of the same guidelines apply. General hints: 1. If I'm already employed, check my linkedin profile. The job you are offering me needs to be significantly better than the one I'm already doing. 2. Know your shit. Know what's hot in the industry. Learn enough of the lingo so that you don't sound like an idiot when we talk. You don't have to be a SME; you do need to know how to use the terms correctly. 3. Be familiar with the industry. Like language above, knowing the industry means you'll know if a job is good for me or not. Convincing me that you're not wasting my time. 4. If your job opportunity doesn't have at least 2 hot skills that aren't already on my resume, I'm not going to be interested. I expect to learn something new on a job. This tends to be more important for Systems people than developers though, I think. 5. Try to know a little bit about the client. I know the signs of a high stress job. I don't want one. 6. When you contact me, make sure you've read my resume. 7. Most people like a challenge, but don't want to learn to swim in the deep end. Don't offer a job that doesn't match my resume at all. 8. If the job offers good pay or benefits, be willing to talk about them. You might consider glass-dooring my current employer to get an idea of what I'm already being paid. If you find my resume online, make sure you know the best way to contact me. Don't try to dig up contact methods that I didn't explicitly list on my resume or profile. I'm personally cool with a call. I prefer talking to people who are polite. It's good to ask if now is a good time before talking too much.
Sick. If this is made compatible with syntastic that would be huge.
Oh man you beat me to it! I built out a ton of Traveling Ruby in https://github.com/ianks/octodown I was going to gem it, but I guess now it may just sit in the tasks folder forever haha. 
Is this a recipe or an anecdote? The thing about recipes is that other people can use them to yield an equivalent result...
Would love to see how this develops over time. Question: are all these optimizations guaranteed to be true for future versions of ruby? My guess is that many of these might even out over time?
What annoys me most is messages where the sender obviously has not read and understood my CV. Sometimes keywords are ambiguous and if the person did not go through the effort to do the reality check then why should I care to reply or even consider the offer?
My perspective is very similar to /u/keyslemur below. I don't give out my phone number, precisely because I'm sick of getting spam calls. I use a filtered gmail inbox to trim down mails from recruiters and recruiting sites that have outdated copies of my CV from when I first moved to the UK. Realistically, the best chance you'd have of getting hold of me is via Linked In. A well considered message, mentioning the name of the company you're recruiting for, the salary range, the perks, the technologies and maybe some other items like the team sizes etc will go a long way to making me at least read the contact. If you're the sort of recruiter who feels the need to hide the name of the company you're working for, you're not the sort of recruiter I'm going to deal with. I don't want to go work for a 'Telecoms company that's rolling out new Video on demand software' - I want to know it's fucking Sky Broadcasting because I do not want to waste my time and effort on a phone call only to tell you 'Oh, sorry, nope.' Developers pick technology by reading the available data and making a decision based on their informed opinion. This is our personality type. We are data driven. Give us the data, and let us make up our minds. I, personally, hate sales pitches. I hate people who prevaricate or who don't answer questions. I REALLY hate people who don't listen to what I say. Be polite. Be brief. Be succinct. Don't waste our time or yours trying to sell ice to Innuit. Examples: &gt; Hi Codeduck. &gt; &gt; I'm recruiting on behalf of GoCardless for their London Office. They are looking for a skilled middle-tier &gt; senior developer / team lead specialising with an interest in performance tuning and analysis. &gt; &gt; GoCardless is based near Old Street, they have a development staff of approximately 40 mixed Java and Ruby developers, and use a mix of Java, Ruby and NodeJS applications to drive their payments system. They are expecting to grow by at least 50% revenue wise this year, and are trying to scale up to support this. Salary ranges between £70k and £80k, excluding benefits and perks, and they pay a signing bonus. &gt; &gt;Would this role be of interest to you? This is an example of a brief I'd at least respond to with a polite 'Thanks, but I'm really happy where I am right now - I'll contact you in person if that changes': Meanwhile, I get ten to twenty of these a day: &gt; Dear Mr Codeduck &gt; &gt; Our records indicate that this position may be a match for your skills. &gt; PHP developer, Aberdeen, Salary £35k to £40k, Oil industry. Yeah, no thanks. I'll block you and everything from your domain. Basically, don't be a car salesman. 
I only talk to recruiters that specialise in fulfilling Ruby jobs, I only ever get spam from generalists. It might only be a UK problem, but they never even hint at who the employer is, let alone the salary. Without that, what's going to pique my interest? Some don't even mention what the employer does, or their industry!
Good advice right here. Name of the employer and salary range is a deal breaker for me
Well then i've got a problem, because I dont know how to write C extensions...
Can someone please explain: Hash#merge! with one argument is slower than Hash#[]. Do they mean that assigning a single item and modifying in place is faster than merge! with a single item? x = {} x[:foo] = :bar # vs x.merge!(:foo =&gt; :bar)
Hi there, and here is the second post announced by Ania :) Krzysztof Knapik introduces a different approach. He suggests to make model fully isolated from validations and keep the data representation as its only job. The approach is even more OO and closer to Single Responsibility Principle: http://blog.lunarlogic.io/2015/models-on-a-diet-part-ii/ Beata
The link I provided has a more recent comment showing some anecdotal evidence that the issue is resolved, but I haven't seen conclusive facts about it yet.
Yes, because `merge!` with one argument creates a new hash then immediately discards it.
good stuff, Josh!
Yup, it looks like he might've just forgotten to add the hash as an argument to that method in the example (`my_hash` in his example, `hash_name` in your example).
There's a solution with much less overhead though: Hash === my_hash No need to define a method or type ".instance_of? class".
It's shorter to type, but it's no less overhead. It does the same thing. There is "no need to define a method" in either case. 
I've been using this and it's great, but do you find the start up time incredibly long? Or is it just me. 
pry-debugger and pry-byebug have had these features for a long time.
Hmm in my rspec Sinatra tests it's taking up to 30 seconds before the first test runs. Something's fishy
Since you posted this on the ruby subreddit... Learn what "ruby" is, and what "rails" is. Understand that they do not mean the same thing. Advertise jobs accordingly. Even better (and i may be asking too much here), learn what technologies are closely linked; what skills are more easily transferable? For example, switching from ruby to python would be relatively easy but switching to embedded C code would be a much bigger leap, that fewer ruby developers would be happy to make. If you can do this, you'll be (in one regard, at least) better than 95% of recruiters! 
I made a small change to the Testo class below to make things slightly easier to examine: class Testo attr_accessor :root def method @root = Node.new(4) current = @root puts "Here is current: #{current.inspect}" puts "Here is @root: #{@root.inspect}" current.value = 5 end end If you run your example again, you will notice that `current` and `@root` reference the same **instance** of Node (the memory address will be the same). When you call `Node.new(4)`, you are creating an instance of Node with a #value of 4. That instance is an object; it can be passed around and assigned to variables and even mutated if you wish. When you say `current = @root`, you are telling ruby to set the `current` variable to be a reference to the **instance** of node you created and assigned to `@root`. Thus, when you call `testing.method` followed by `testing.root.value`, during the call in `#method` that sets `current.value = 5`, you are actually changing the value of the underlying Node instance you originally created (at `@root = Node.new(4)`). The above Testo class could be rewritten: class Testo attr_accessor :root def method @root = Node.new(4) @root.value = 5 end end to the same effect. If you DON'T want to mutate the underlying Node instance, you might want to look into creating a second instance, or investigating [#dup](http://ruby-doc.org/core-2.2.0/Object.html#method-i-dup).
Ah okay! I see your point.. thank you for being so kind enough to respond. Would you be able to explain to me why this following code does not follow the same convention? one = "one" =&gt; "one" irb(main):002:0&gt; two = one =&gt; "one" irb(main):003:0&gt; two =&gt; "one" irb(main):004:0&gt; two = "two" =&gt; "two" irb(main):005:0&gt; one =&gt; "one"
I think you might be confusing the hash syntax a bit. For reference, `#=&gt;` represents the output of the command entered: one = { "one" =&gt; "one" } one.class #=&gt; Hash one #=&gt; { "one" =&gt; "one" } Here, you've set `one` to be a hash. two = { one =&gt; "one" } two #=&gt; {{"one"=&gt;"one"}=&gt;"one"} Above, you've set `two` to be a hash that has, as a key, a hash. This is unusual. two = { "two" =&gt; "two" } two #=&gt; { "two" =&gt; "two" } Note that here, you have re-assigned `two` to be a hash. There is no reference to the above assignments. { one =&gt; "one" } one #=&gt; {{"one"=&gt;"one"}=&gt;"one"} Note that this has also reset `one` to be a hash that has a hash as its key. Each time you type "one" or "two" it makes a separate instance of a String. You can verify this by trying: "two".object_id #=&gt; 70306673280060 "two".object_id #=&gt; 70306672842560 Those numbers will be different each time. In the case where: x = {{ "one" =&gt; "one" } =&gt; "one"} y = {{ "one" =&gt; "one" } =&gt; "one"} While you can do `x == y #=&gt; true`, note that they are NOT referencing the same objects. If you then do `x = 2`, the following happens: x #=&gt; 2 y #=&gt; {{"one"=&gt;"one"}=&gt;"one"}
Thanks, man!
Ah gotcha. So when you do: one = "one" one.object_id #=&gt; 70306677130900 two = one two.object_id #=&gt; 70306677130900 (Note, they are the same). Now, `two` is a reference to the **object underneath** `one`, but it's only a reference to that object, not the variable `one`. When you do `two = "two"` at this point, you are re-assigning `two` to be an entirely different object. Ruby still recognizes `one` as the old object (you can check the object_id to confirm), but `two` is now referencing a completely different object. 
I also have used byebug a lot which, when inserted, will cause a break allowing you to inject your own ruby code to see behaviours/check variable values/etc. https://rubygems.org/gems/byebug
Rspec instantiates a zillion objects on startup. Conventional advice is to consider switching to minitest/minispec.
I'm being pedantic but I'm not sure what's going on at [here](https://github.com/usmanbashir/haikunator/blob/master/lib/haikunator.rb#L25). At present, it's generating a random number between 0 and 1.0, and multiplying it by 2 ** 12. Is there a reason the 12 is special, or would 4096 lead to simpler code? At that point, it's a magic number and I'd suggest defining a constant for it. You could avoid the multiplication and just call: SecureRandom.random_number(4096) If the goal is actually to get an integer in 0 - 4096. As I said, that's being pedantic, because I can't see anything that's significantly wrong. 
Turn the `adjectives` and `nouns` methods into constants, or if you want to let the user edit them, use variables with an `attr_accessor`. Use `module_function` instead of `class &lt;&lt; self`, you can keep the other methods private by using`private_class_method %i[build random_seed token]` or similar. You don't need SecureRandom for what you're doing, just use the normal `rand` method. Edit: Is there a reason you're creating a random seed? You could just `Array#sample` the words you need. I would say you're probably doing too much here, it's easy to follow but a lot of it may be unnecessary. Also I may have been over thinking it earlier with private methods, if I were you I'd just put this all in one method since it's very readable as ~10 lines.
The reason I'm using SecureRandom instead of `rand` or `Array#sample` is because `rand` is a pretty bad pseudorandom number generator. And, I wanted to avoid collisions from the get-go, in the project I extracted this gem from. I have to disagree about using `module_function`. As `class &lt;&lt; self` lets me use private methods with simple, clean and easy to understand code. Though, you are right, this can be a lot more compact. But, it was written to be extensible, so when we needed more options and control in our app, we could just replace the individual methods. For example, the `adjectives` and `nouns` methods could be changed to load their data from a file, if needed without affecting anything else at all. Thanks for taking a look and sharing your review. It's greatly appreciated! :)
Well you shouldn't have to redefine methods, using a setter or variable is a much better interface if this is to be used as a gem. If you monkeypatch it to load data from a file it'll be reloading the file each time it's called, maybe okay for a class but not as a module IMO. I agree that `class &lt;&lt; self` is better for private methods, but you shouldn't need them with this. :S
This is better than last weeks version. I have two questions though: Is it ideal to be delegating errors to the model? Should you're validator really mutating what it's validating? (This might be ActiveModel::Validations fault) Is there a way of implementing without using method missing? Do you not know the fieldnames ahead of time?
In this case, though, isn't the "Handler" class just re-implementing everything that ActiveRecord::Base would have done? Assign attributes, validate, save, run call backs.
Don't forget [pry-stack_explorer](https://github.com/pry/pry-stack_explorer).
What does this give me, the average ruby dev currently running (puma|unicorn)?
The console in development mode already spits the SQL queries it does. However, this is very useful if you log in to the production console and want to see the queries.
Using it will make you 8.7% hipper, and your latte extra sparkly?
How is `rand` a pretty bad pseudorandom number generator? I just generated 1 million random numbers between 0 and 4096 and got this distribution: http://imgur.com/eTK83pg 
I know the writer tries to be _cute_, but please go easy on the puns - skin a cat (or shave a yak) - Try these benchmarks at home (or work) - Duck typing in Ruby is great, but you should always check that your Object quacks before poking a bear - Practice safe #send. - Random is the zeitgeist for teenage girls - so please don’t take a lead from LMFAO and go easy on the shufflin’ Every other fucking sentence.
This looks fantastic, josh. Shall go over it thoroughly when i find more time.
You're the best.. thank you very much for taking the time and explaining that to me. Very kind, if theres a way to pay back the favor let me know
404
 class Prison def initialize(cells) @cells = Array.new(cells) { Cell.new } @lock = true end def guard_runs(count) count.times do |time| toggle_lock # Note: There's probably a nicer way of writing this line, # but it's all I could come up with in 30 seconds :P @cells.each_slice(time+1) { |cells| cells.last.locked = @lock if cells.length == time+1 } end end def unlocked_cells @cells.count { |cell| !cell.locked } end private def toggle_lock @lock = !@lock end end class Cell attr_accessor :locked def initialize @locked = true end end p "10 cells, 2 run" prison = Prison.new(10) prison.guard_runs(2) p prison.unlocked_cells p "*********************" p "30 cells, 5 runs" prison = Prison.new(30) prison.guard_runs(5) p prison.unlocked_cells I'm sure I could make it a bit cleaner, given more than 5 minutes ;) Edit: I just realised I misread the question slightly - the cell lock should be toggle every time, not "always lock, then always unlock, then always lock, ...". I'll let you fix my code, it shouldn't be too hard :) [hint: move the `toggle_lock` method into the Cell class] Also, this sounds like something that could be solved much more efficiently by some other algorithm. But assuming you don't want to know the answer for "100000 cells, 4000 shots of whisky" or whatever, performance won't exactly be an issue!
Here's the git repo: https://github.com/JuanitoFatas/fast-ruby
I'm just looking at this on my mobile, so haven't even run it, but i think your bug is because the `count` variable does not get reset to zero, after each loop of the `while round... `. But rather than trying to "fix" this code, try writing it in a more object - oriented way, and you'll find it a million times easier to debug! 
Thanks very much for the input everyone really appreciate it and will certainly take everything said into account moving forward. I generally like to adhere to the principals everyone stated in the context of avoiding calls and being as specific as possible. One thing I can however admit to being guilty of is not disclosing the name of the company in the original outreach message. Most recruiters are trained to avoid disclosing client in the initial message as candidates can sometimes be uncertain of the arrangement between the company and recruiter and end up applying internally on their own. Also for what it's worth, I realized right away that I should have posted questions alluding to Rails in /Rails I understand Ruby is the language and Rails is the framework as Python is to Django. This is also my first ever reddit post so appreciate the help and will hopefully be reaching out to you guys more constructively (and less intrusively) moving forward!
 def drunk_run n 1.upto(n).with_object Hash.new true do |shots, cells| 1.step by: shots, to: n do |cell| cells[cell] ^= true end end end This ^ just returns a Hash with cells as keys and whether they're locked as values. So for example a drunk run with five cells: cells = drunk_run 5 #=&gt; {1=&gt;false, 2=&gt;false, 3=&gt;true, 4=&gt;true, 5=&gt;false} cells.select { |_, locked| locked }.keys #=&gt; [3, 4] cells.reject { |_, locked| locked }.keys #=&gt; [1, 2, 5] 
There' a gem to produce source maps from coffeescript. Any other problems with asset pipeline? Looks like a lot of boilerplate.
Lol. Yes, now I can officially tell my consulting customers they must upgrade. I still encounter 1.8.7 in the wild (on actively maintained product sites.)
Thank you for your help and explanation on this. The bonus was a very good bonus indeed :D
This could be considerably condensed into "use the right tool (method) for the job, here's a bunch of methods you may not know". Add a quick note about the idiom of clean vs clean! and you're done. &gt; GitHub currently disable the rendering of emoji in large document, that's why you see these strange :: stuff. Yay.
Sorta? Why spend time and/or money on an education if you're going to ask other people to do the work for you?
I prefer to use rescue `NoMethodError` over using `#respond_to?` in cases where it's highly unlikely to receive an object that can't be handled. Internal classes for a library are a good example of this. It saves a call to `#respond_to?` (which can be expensive) almost *every time* the method is invoked. Which, overall, is much faster.
See also: [Business Time](https://github.com/bokmann/business_time)
I'd prefer to do this in the rare cases it needed to, but ultimately both are indicative of something being wrong. It's the sender's responsibility to make sure they're passing in the correct arguments, you don't write your methods second guessing everything that's passed in.
Yup! It's a lot easier to sell when couched as a security issue. A somewhat distant second is "using old Ruby versions is a recruiting and retention issue". 
That's what the holidays gem is useful for!! It has regional lists and can also be customized.
I'm sure they will both find out about it eventually.
Good list, but no `with_options`?
2.1.5 is available on Windows. No idea about stability. 
Do enlighten us.
Actually I found really important issue with my solution (last week solution) which is present in this solution too, but it's easier to fix it here. Validations for fields that are cast uses the special field where before cast value is stored, so in both solutions it won't work as all the validations are working on the already cast fields. Example: I have price which is decimal. I wanted to add numericality validation. But when I assign lets say 'Ania' to the price field, it's cast right away so validator already has cast value, which is 0, so validation doesn't make sense. But in this solution it's really easy to fix it - you just need to populate validator with params not the record itself. My BaseValidator looks like that now: https://gist.github.com/bfd6b65f661bced7b394.git And I don't have method_missing ;]
1.8.7 is what you get by default if you use Centos 6.x. The amount of packaging work needed to replace it can be nontrivial.
Unlike the 1.8.7 sunsetting, I managed to migrate everything off of 1.9.3 before today. This is pretty much my biggest achievement in life so far.
don't forget [the usual warning not to use active_support in gems](http://hayesdavis.net/2010/07/26/activesupport-considered-harmful/) (last posted to /r/ruby 4 years ago!)
Just updated our main app to Ruby 2.2.0 yesterday. We had been putting this off, because we thought we had several things that might not work. Turns out that we had already fixed the problems and that updating it was just a matter of updating the installed Ruby. \o/
lol
The version I got from the repos on 14.10 is 2.1.2.
You've got your odd/even test a bit out. Go into `irb` and you'll see this: &gt;&gt; 21 % 1 =&gt; 0 &gt;&gt; 22 % 1 =&gt; 0 You need to `n % 2` to find out if it's even, or even better: &gt;&gt; 21.odd? =&gt; true
&gt; I am currently learning rails and I use many gems to make my life easier; and I wondered if this is a good practice? No. Especially shy away from gems which tightly integrate into rails (e.g. devise). Using small isolated gems which do one thing is fine, though. See http://www.reddit.com/r/programming/comments/2x343u/invented_here_syndrome/ for a recent discussion about that issue.
I use gems, and before I start work on any new feature, I see what gems are available first. If my managers started insisting that I write ALL functionality myself, I would shout mean things at them. Rails is a framework, it's good because it abstracts away all the underlying functionality, and lets the devs work in the pieces that really count. Using gems instead of pure custom code continues that ideal. With that said though, lately I've been a bit overwhelmed by the massive amount of gems out there. My latest project even started with the [Rails Composer](https://github.com/RailsApps/rails-composer), which built so much of the project it's nearly ready for it's initial release!
I think this is because most gems carry across quite well.
I used a lot of gems for small things that make my life easier but I'm paying the price when running my tests
Hmm, that's an interesting idea and I'm up for it. Though, can you share a use case? It will help with shaping the Gem's API.
The first thing that I do is check the license. If it is not a MIT (or similar license) I move onto the next gem or consider building in house. There are some gems out there where they will want a service agreement or one-time payment. I will consider the service agreement or one-time payment of the gem if accomplishes a vital task that I otherwise would take too long to develop. (There is a Material Design gem that is free for non-profit but is relatively expensive for commercial applications.) It is better to know what you're using before getting in too deep and have the pay the consequences. Whenever using a gem, I always study the gem to get to know the ins and outs of it to see where its limitations are. By knowing where a gem is limited, I can fork it and make the necessary changes. For example, there is a Video Transcoding gem which would transcode uploaded videos. However, it did not apply qtfaststart to the transcoded video which caused the whole video to load before it would play to the end user. I modified my fork of the gem to run this command on successfully transcoded videos.
It depends on the life-cycle of the app. If it's a quick weekend hack that i'm not going to maintain again, I might use some higher-level gems, like Devise or OmniAuth. If it's a project that's expected to last, I tend to keep to a much smaller set, as I've been burned too many times by gems that never get maintained or have to be ripped out to color a bit outside their lines.
Hey there! Nice to see you here and well, thanks for making Coveralls. :)
I got bored at work, doing "real" code, and felt like giving you a better solution :P class Prison def initialize(cells:, runs:) @cells = Array.new(cells) { Cell.new } perform_runs(runs) end def unlocked_cells @cells.count { |cell| !cell.locked } end private def perform_runs(runs) 1.upto(runs) do |run_number| @cells.each_with_index { |cell, i| cell.toggle_lock if (i+1) % run_number == 0 } end unlocked_cells end end class Cell attr_reader :locked def initialize @locked = true end def toggle_lock @locked = !@locked end end p "10 cells, 2 runs" p Prison.new(cells: 10, runs: 2).unlocked_cells p "*********************" p "30 cells, 5 runs" p Prison.new(cells: 30, runs: 5).unlocked_cells You could still easily improve this further by, for example, recording *which* cells are unlocked! - Just assign each cell an ID (counter), and add a method to list all the unlocked cell IDs. This is a great example of why clean code, such as what I've given above, is so valuable: It makes it *so much easier* to change bits of your code, without one little tweak causing bugs to appear all over the place! 
Happy to be a part of it all :)
Wow thanks for the quick replies, all of you were helpful; and what you are saying makes plenty of sense. I will wean myself off of using unneeded resources. 
I think a corollary to this is that occasionally you should make a pass through the Gemfile and see if there's anything that can be removed. Sometimes gems are entirely unused due to past refactorings and whatnot and you can just drop them. And sometimes there's only residual use - if you only have one model that uses acts_as_list and you don't use move_higher / move_lower, maybe think about removing it and inlining what little functionality you are using from it.
I use gems like a carpenter uses 2x4s and wood screws. Carpenters don't cut down the trees, mill the wood, find the ore, and smelt the screws. They are paid because of their expertise in knowledge in how to build things out of these materials.
Its also worth noting that certain gems and software might look for a specific minimum ruby version. As such you should probably look at updating if you can.
&gt; In order to be used as keys for a Hash (make it “hashable”), Ruby requires objects to implement “#eql?” and “#hash?” methods. In irb: &gt; a = Object.new &gt; a.hash? NoMethodError: undefined method `hash?' for #&lt;Object:0x2d38ee0&gt; &gt; {a =&gt; 3} =&gt; {#&lt;Object:0x2d38ee0&gt;=&gt;3} Looks like he meant `#hash` instead of `#hash?`: &gt; a = BasicObject.new &gt; {a =&gt; 3} NoMethodError: undefined method `hash' for #&lt;BasicObject:0x2d86178&gt;
Yeah, if you need to pass around blocks, your only option is to pass them explicitly. But it might be faster (depending on the code; I'd have to really think about it) to explicitly create Proc instances. I /think/ that would go through the Ruby stack, which would avoid the malloc calls (again, would have to dig into it to know for sure). The "danger" with this is that the allocation is implicit, so you just use the syntax thinking it'll be like any other, and you never really know about the cost until someone writes a blog post. Heh.
Oh cool...didn't know that! I'll have to benchmark that...
Agreed, I have been in environments where upgrading Ruby was not an option, thus leading to one viable choice, no Ruby apps.
A good chunk of that is just the creation/garbage collection of the proc object (which happens to be one of the slowest objects to create due to details of generational GC in MRI that I don't fully understand). For delegation, at least, I'm hoping to remove that overhead in 2.3. This is already [done in JRuby](https://github.com/jruby/jruby/pull/2562) and I'm working on it in MRI. It's also worth nothing that this almost *never* creates a measurable performance difference (which is true of any method &gt; 1M IPS or so). For example, the only place I've found it making a notable performance difference in Rails is in `ActiveRecord::Base#read_attribute`, which is a code path that will be hit more than any other method in the entire damn code base (except maybe `.present?`) https://github.com/rails/rails/blob/master/activerecord/lib/active_record/attribute_methods/read.rb#L72-L82 I just want to kill that if statement. T_T Edit: Ah, I see there's a part two which does conclude that basically 100% of the cost is the block allocation and garbage collection. Anyway, the reverse of this suggestion is faster on JRuby, and hopefully the same will be the case in MRI 2.3 -- Which also makes the point against VM specific micro-optimizations. They change frequently.
Yeah the main issue I've seen is gems that don't have native Windows builds that need it. Nokogiri used to be a big one with this issue, which I think they've resolved. Although that might have been specific to 64-bit binaries.
Definitely interesting and worth considering, but I can't help but feel that the percentage given is misleading, because the methods don't actually do anything. What I mean is, it's a performance hit, but when compared to the actual work it will become a much smaller, and I'd wager in many situations negligible percentage.
I'm not quite sure what you are asking. &gt; especially that part the checks if the number is divisible by those prime numbers. I was wondering if i could store those prime numbers in an array to be checked before hand and if not then go into the odd number feeding loop. I don't actually see any loops at all in your code, I'm not sure which part you are calling "the odd number feeding loop". There are all sorts of suggestions we could give you, of course. Your code is weird in a bunch of ways, as you know. I'd start with proper indentation, and giving methods meaningful names, not "this" (means nothing at all) or "check" (check for what). Among other things, proper indentation and meaningful names will make it easier for you to get advice on your code, because it'll be easier for readers to read, and there will be method names to refer to. You could also add line numbers, and then you could tell us "the part on line X" or something. 
Because Java
There are gems people recommend which haven't had an update in two years. If such a gem is simple (which most gems are once you factor our the components you aren't using), I'd rather write it myself than find myself at the mercy of an unsupported product that won't work on the next version of Ruby.
I measured a significant slowdown using redis-rb. The gem uses a few levels of nested blocks. I initially thought we had just maxed out our redis server or network link since this would all be I/O bound, but eliminating the blocks doubled throughput. This was rather significant since it impacted potential changes to the cluster topology. I/O might not be quite as bad as you think.
I'm a big fan of exercism.io They give you an assignment that contains a reademe and some unit tests. You write code that passes the unit tests and upload it to your account and others that have completed the exercise make comments and give you pointers. The exercises are structured to sort of lead you into using different features of the language as you go. 
So basically I tried to go ahead and apply everything I learned thus far instead of going the easy route to meet the requirement and I made the coding required to do what I wanted not within my current knowledge of the language? Edit more questions; But if the user inputs 2 and my code says if user_input =&gt; 2 That is me comparing the value of a number is it not?
&gt; So basically I tried to go ahead and apply everything I learned thus far instead of going the easy route to meet the requirement and I made the coding required to do what I wanted not within my current knowledge of the language? ... what?
Sorry if that was confusing
You should make use of the interactive ruby console, called irb for short. It'll interpret a line of code you type in and evaluate it back to you, e.g.: &gt;&gt; gets whoa =&gt; "whoa\n" &gt;&gt; gets 25 =&gt; "25\n" &gt;&gt; a = gets 10 =&gt; "10\n" &gt;&gt; b = a.to_i =&gt; 10 &gt;&gt; puts a 10 =&gt; nil &gt;&gt; puts b 10 =&gt; nil &gt;&gt; puts a.inspect "10\n" =&gt; nil &gt;&gt; puts b.inspect 10
http://apidock.com/ruby/Enumerable/any%3F is probably what you want. 
How does not passing it as a proc but simply pass it by wrapping the yield in a new block fare in the performance game? Also, my app have an action that today take almost a minute that will create thousands upon thousands of records (basically, the idea is to move configuration from one installation to another), so everything like this is deeply appreciated. I've managed to gain 15 seconds simply by caching validation results for values certain values..
On 14.10 I still have 1.9.3 as the latest. Any idea why?
Two things: The NoMethodError is in line `elsif arr[idx+count] &gt; arr[idx] &amp;&amp; idx+count &lt; arr.length` You know about the order of evaluation? Check `idx+count &lt; arr.length` first The same for the other condtion (`if arr[idx-count] &gt; arr[idx] &amp;&amp; idx-count &gt;= 0`) And the while condition causes an infinite loop. ;) Edit: Format
I think it still does but it basically only depends on PATH,GEM_HOME and GEM_PATH, I found running cron tasks (rake) through a script like #!/bin/bash export RAILS_ENV=myenv source /whatever/.rvm/environments/ruby-2.1.5@global rake $@ works okay
I just finished the codecademy.com Ruby course and I'm thoroughly happy with it. I've tried so often to learn a programming language with books, videos, etc. and always dropped it sooner than later. With the way you had to do tasks directly in codecademy.com, I was able to not only finish the Ruby course but the Python course before it. Next up Rails. Or maybe jQuery.
Just finished their primer, and so far I am a big fan of it. Moving onto other things now, but it gave me a solid understand of some basics of the language. I will probably revisit other areas at a later date
Yeah alright, that'll do. Sorry if it was a stupid question, I'm not exactly a wizard in terms of programming as you might tell :-)
Ok, I misread some of the things in your question, but nevertheless, here is another implementation, that finds the nearest value greater than the input: &gt; def nearest_larger(ys, x) &gt; ys.inject(Float::INFINITY) { |m, y| x &lt; y &amp;&amp; y &lt; m ? y : m } &gt; end &gt; nearest_larger([1, 2, 3, 4, 5], 3) =&gt; 4 Also made one for the index: &gt; def nearest_larger_idx(ys, x) &gt; _, idx = ys.each_with_index.inject([Float::INFINITY, nil]) { |(m, i), (y, j)| x &lt; y &amp;&amp; y &lt; m ? [y, j] : [m, i] } &gt; idx &gt; end &gt; nearest_larger_idx([1, 2, 3, 4, 5], 3) =&gt; 3 Edit: Ow well, still misread. It is kind of a silly exercise...
Is there a reason why people on 2.0 won't upgrade to &gt; 2.1.0? Genuinely curious.
He hasn't been taught how to convert from Strings to Integers and was given this problem without the knowledge to solve it. tl;dr - His tutor or course is stupid for asking to complete a challenge before explaining how it can be done.
It depends! Devise might be a bad example, since it's in widespread use, will probably be maintained indefinitely, and rolling your own authentication isn't particularly labor intensive (ActiveModel ships with `has_secure_password`). If you are required by your employer to do work that would make Devise unwieldy, it's absolutely *required* for your employer to let you have the time to make a working solution.
I'm on Windows and use the installer and Devkit provided by http://rubyinstaller.org/. Currently, the latest version of Ruby offered at the site is 2.1.5. I chose to install version 2.0.0 of Ruby, because I know that I will have a future need to turn my scripts into exe's using OCRA. The information from the OCRA site stated that while 1.8.7, 1.9.3, 2.0.0, and 2.1.5 are supported. They perform tests using versions 1.8.7-p374, 1.9.3-p545, and 2.0.0-p481. Based upon that, I decided 2.0.0 was likely the best version of Ruby for me given the options available. 
Thanks for sharing! Loved that movie and it's cool to see it broken down in Ruby. 
I mean checking index to see if it is in the expected range. like `if left_idx &gt;=0` and `right_idx &lt; max` in the example above
Passing a block isn't a problem, and no we can't change the API of `read_attribute` without a better reason than that.
no need to change the api, I meant changing the `ReaderMethodCache#method_body` to use an alternate method which skips the creation of an extra closure, i.e. def method_body(method_name, const_name) &lt;&lt;-EOMETHOD def #{method_name} name = ::ActiveRecord::AttributeMethods::AttrNames::ATTR_#{const_name} _read_attribute_or_missing(name) end EOMETHOD end def _read_attribute_or_missing(attr_name) @attributes.fetch_value(attr_name.to_s) { |n| missing_attribute(n, caller(1)) } end 
Although, to be fair, rails engines don't really isolate your routes (or application) either.
thanks a lot, I'll see what I can come up with.
I for one didn't know about the pipe execution. That's pretty bad. I'd recommend getting used to [Faraday.](https://github.com/lostisland/faraday)
Faraday is not one line of code afaik. open-uri is really handy for small tasks and that's why people love it.
Try googling "how to read a URL in Ruby" and you will see most answers suggest open-uri. Also check paperclip or carrierwave. It's fairly popular approach.
That's a far distance from passing unsanitized user input into it. If you don't understand to never trust user input, this is the least of your worries. 
Learn ruby! The Well Grounded Rubyist and Metaprogramming Ruby are NY two favorite books for new people to read.
"Sinatra: Up and Running" is a great book to read after you've played with Sinatra a bit and want to know how it ticks underneath. Oh, and just dive into Sinatra immediately. It's a simple framework with surprising depth. 
I've always used HTTParty. You can do really quick one-liners, even specifying the request type. 
&gt; This is the last ordinal release of Ruby 2.0.0. Do they mean 'ordinary'? I'm not sure what they mean, but I don't think it's 'ordinal'. Especially because they go on to say that future releases _are_ possible, for "critical regressions or security issues." ordinal. adjective. of or relating to a thing's position in a series.
Sorry. Reddit never notified me about this. Yes, I'm totally open to a PR. 
*Yuck!!*... 112 characters on one line, with a jumble of mysteriously named variables (`ys`, `x`, `m`, `i`, `y`, `j`), a cryptic one-line if statement and a dummy variable (`_`) mixed in with the main logic? You should **never** be writing methods this confusing! Someone else (especially if inexperienced) looking at this for the first time could probably write their own code faster than understanding yours! Break down the logic into simpler sections, possibly with other helper methods, use meaningful variable names, and don't try to cram everything into one line.
Fairly pointless, but quite a cool little challenge to write code like this! The only part I don't really like is the hacky `max` method at the end (which is non-obvious why it works, hence you added a comment!). How about this, instead? applicators = {3 =&gt; "fizz", 5 =&gt; "buzz"} fizzbuzz = (1..100).map do |n| fb = applicators. select{|a| n % a == 0}. values.join('') [fb, n].find { |answer| answer != '' } end puts fizzbuzz
That's what jekyll is for. 
Why is it broad? Its literally one word and then a sentence answer?
You're asking "How do I write a Rails app". There are entire books devoted to the subject.
I've found Middleman to be easier to use and a lot more powerful than Jeckyll. There are definitely a lot of static site generators in every language but I've come to really like Middleman. http://gohugo.io is another good one written in Go.
No i am not :/ Just a general guidelines as to what do i read and stuff Like read cout if you want to display stuff on the screen
since it sounds like you're a beginner I'd refer to https://github.com/himanshukela/facemash but the app's rails version may need updating, or obtain some skills from https://www.youtube.com/user/mackenziechild
Just use RubyMotion
Ya for sure. Jekyll is definitely a good option. 
I did a purely functional version without conditionals a year ago or so. I posted the link to it there. Basically I built up a fizzbuzz function composition from a bunch of simpler functions. I love little exercises like this. (And conversations about them.) There's many ways to skin a cat like this.
Wow, that's a lot of currying! And yes, while ultimately pointless, FizzBuzz captures a very interesting problem. This [paper](https://themonadreader.files.wordpress.com/2014/04/fizzbuzz.pdf) phrases it well: &gt; The conundrum lies in a peculiar but not unusual control flow scenario: the default action is executed only if some previous actions were not executed. The great variety of possible approaches is fascinating as well. 
Oh wow. This paper looks awesome. And it uses Haskell which I like. Although I think I may settle on Elixir for a while. Check it out if you haven't. ;) It's awesome having true (and cheap) concurrency with Rubyish syntax, in a functional pattern-matching language, with actual macros in a non-homoiconic syntax. Thanks!
1. When a method takes a splat (`*args`) it's turning all the arguments into an array called `args`. But, if you consider passing a hash like so `Temperature.new(a: 1, b: 2, c: 3)` it's not calling the method with three arguments, it's called the method with a single argument. It's equivalent to `Temperature.new({a: 1, b: 2, c: 3})`. I'm not sure why it's checking for nil. 2. In the [docs for Ruby 2.2.0](http://ruby-doc.org/core-2.2.0/Object.html#method-i-instance_variable_set) it says the first argument to `instance_variable_set` can be either a string or a symbol, and it works just the same. 3. There are probably other ways to implement this, but this implementation seems pretty simple and straight-forward. 4. The `Temperature#initialize` method can take other arguments, but if you want to use the syntax without the curly braces (`Temperature.new(a: 1, b: 2, c: 3)`) then the hash needs to be the final argument. If you include the curly braces, then the hash can be at any position in the arguments (e.g. `Temperature.new({a: 1, b:2}, second_arg_here)`) 
He's checking for nil in cases like: :key =&gt; nil 
You're right that i haven't spent *much* time with functional languages (but they're not completely alien to me). My point was more about doing things "the ruby way". Like you said: ruby is not a functional language. As such, writing methods like this makes them look much more ugly and confusing than they need to be. 
Yeah, but I don't see why it matters if the value is `nil`.
because @f can't be nil or the code will fail. I think it's an extreme case. I would let the code raise an exception or catch it and show an informative message.
Check out http://camping.io/ as well. The DSL of sinatra annoys me.
Here: def in_celsius @c == nil ? @c = (@f - 32)*(5.0/9.0) : @c # HERE &lt;- "nil - Integer" @c.round(1) end 
That's true, but what I was trying to say is that whether you check for `nil` in `initialize` or not, the outcome is literally identical, so I'm not sure why the check is there.
I agree the second method looks like shite, the first method is reasonable, but could be improved. If you're using blocks, you are already using pseudo anonymous functions, which come from functional programming. Using `inject`, `map`, `filter` and cohorts puts you in functional territory, and is very much part of the ruby way.
You could do both. Publish it on Github for people that want to run their own, and you could offer a hosted version for pay (optionally with premium features). Sidekiq is like this.
Select is a conditional. You can't do this without a conditional, you can just hide the conditional away in a method.
What's the name of the project?
You know how is the user authorization and authentication is built, so you can find ways to exploit this. I might be thinking wrong, but it's like showing how the key lock to your house works to the public. 
Not really possible if you're doing it right. Doing it right means using properly hashed passwords (e.g. the Devise gem) and [not committing your secret keys](http://blog.firsthand.ca/2014/06/dont-commit-your-secrets.html)
I've build a custom user bundle based on Hartl's tutorial, but I could easily with some effort and time to convert it to devise. Thanks for the link. 
You didn't chose the wrong setup at all. There is plenty of information on how to do this, but you won't be spoonfed. Just persevere. 
Not if you wrote it correctly: https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle
Yup, let's see some screenshots.
That is true. I guess "declarative Fizzbuzz without hard-coded if statements" would've been better. Conceptually though, I believe `select` can be implemented without a conditional, in Haskell at least the equivalent(`filter`) is done with pattern matching(or does that count as a conditional?).
I mean, eventually some comparison will be made at a machine code level. How is that different? It seems like your solution isn't really fully solving the problem programmatically if you define 15 different cases instead of just the original 4.
Not disagreeing at all, I also tend towards Rails over Node having used both. But out of interest since you mention the callbacks issue, did/ does sail.js have promises support? I've found that using promises pretty much eliminates the "callback hell" that tends to go with larger JS apps?
I would argue there is less of a chance of being hacked as anyone can fix a vulnerability instead of having to rely on you!
Unless you have some major differentiating feature from the other ticketing systems out there, I doubt you will have something that would be more valuable in closed source form than it would be in open source form. That is to say, the marketing value for you as a software professional by open sourcing it is probably greater than the financial value of your code as a potential product. With that said, regardless of the route you go I would recommend making a sleek github.io page with screenshots and whatnot explaining the product and its features for potential employers to stumble upon.
I don't disagree, rails is my goto for a lot of things, but sometimes rails is not the answer. There are times when a service written in golang is much more performant and better to use. Additionally highly transactional, very fast, and concurrent, data processing is better suited to java or maybe scala these days. Sometimes these languages take longer to make a working product but they can yield a better scalable result. The point is basically when all you know is how to use is a hammer, everything looks like a nail. When you learn to use a screwdriver sometimes things look like nails other times they look like screws. So it is far better for a programmer to know multiple tools and languages so you can reach for the right tool at the right time.
You can use loops, and pretty much any other ruby code, wherever you want. Why would you have thought you were restricted in an initialize method? Anyway, you are not. 
do you have scientific computing, machine learning, natural language processing, desktop, game development and education libraries in Ruby? I'd like some examples.
It gives you a lot of flexibility in what you want to create
From the quick bride I had there it does seem quite cool. Will be giving it A more I depth look tomorrow 
Great article. Thanks for posting.
That's fair enough reasoning. I wouldn't begrudge that of anyone who is very green. There is nothing wrong with knowing you have enough on your plate to learn already, but you should still be open to other languages being the right choice and answer for a particular problem. 
Yes. On the other hand, this: &gt; I am not afraid of a person who knows 10000 kicks. But I am afraid of a person who knows one kick but practices it for 10000 times. ― Bruce Lee
Ah ok, so if I'm putting in a hash argument, I can type something like: `Temperature.new([1,2,3,'array'], a: 1, b: 2, c: 3)` and it will recognize this as 2 arguments? The first an array, and the second 3 key/value pairs of a hash? Also, if I gave 2 separate type arguments like above (an array and a hash), I'm guessing within the method, I would first have to identify the type, and then do what I want with them?
Yep, that's it.
Yeah, don't get me wrong, I'm excited to check out go and python. But, I have my hands full.
He also said this. "Don't get set into one form, adapt it and build your own, and let it grow, be like water. Empty your mind, be formless, shapeless — like water. Now you put water in a cup, it becomes the cup; You put water into a bottle it becomes the bottle; You put it in a teapot it becomes the teapot. Now water can flow or it can crash. Be water, my friend." Advocating that you be adaptable.
I really like this! Its much more simple. But in this case, since the test only provides one key/value `:f =&gt; 32`, is @c == nil?
Absolutely. I would only recommend you learn one language per year, unless you have more mental bandwidth, or are presented with an opportunity around learning a new language.
You'd have to check that either `@c` or `@f` was provided in `initialize`.
Touché :)
Most frameworks work great. I really like the bootstrap gem. Also, check out rails-assets gems. They package a lot of frameworks for you. 
Depends on what your goal is. I agree bootstrap is far more mainstream and yes you do get a lot for free out of the box, but it has quite a bit of bloat along with it. Plus quite a lot of bootstrap sites end up looking very bootstrap-ish. Bourbon allows for more control over the design and keeping your html a little cleaner and less cluttered with stacking classes. So if you do not have designers to work with or you just want to throw something together and have it look half decent then bootstrap and foundation are for sure the way to go.
Weird, and I can easily imagine it taking "a few hours to debug". I've never hit that problem, and I've been using [Wisper](https://github.com/krisleech/wisper) for quite some time now. What's saved me is that I've *always* written Wisper listeners as *methods on a class*, which sidesteps the block/Proc switcheroo entirely. Rephrasing his controller: class MyController &lt; ApplicationController class SomeWisperThing include Wisper::Publisher def execute publish :foo end end def create command = SomeWisperThing.new command.subscribe(self) command.execute end def foo # An explicit return here should cause no problems # with the Wisper loop. return respond_with(@whatever) end end The one gotcha with Wisper is that the listener method has to be public, as discussed in [this Wisper GitHub issue](https://github.com/krisleech/wisper/issues/75). **tl;dr** Yan wasn't throwing stones at Wisper *per se*; his "Further Proof" section and [code example](https://gist.github.com/skwp/ef9e06c28899f6006e68#file-blocks_are_procs-rb) detail a common *Ruby* gotcha. Procs are very much like blocks, and both differ *importantly* from lambdas. Lose sight of which is which, and you'll find yourself, too, entertained for hours by Ruby code that you'd *swear* "should" work. But it doesn't.
Sure. And you are free to define them on your own classes as well to do anything at all :)
Would anyone be interested in reading a detailed blog post about how this gem works? There's a *lot* going on behind-the-scenes here, but the basic principle of how examples are being generated is quite simple to explain. Or if you have any quick questions, ask away!
Everybody who can write some html and ruby can easily learn Volt. With Volt you can add input fields to your html form, and it's content is automatically stored on the server. Controllers are written in ruby and runs both on the server and in the webbrowser. It only takes a few seconds to try out the todo example: $ git clone https://github.com/voltrb/todos3 $ cd todos3 $ mongod &amp; $ bundle install $ volt server When volt gets support for authentication, it would be absolutely brilliant as a tool to create MVP's.
The react.rb is probably not for beginners, but it looks cool. https://github.com/zetachang/react.rb
I realised that searching for a job lately as a Software Developer where everyone asks for a github profile. I don't have much stuff there, except some python scripts and I couldn't show them my work because it works locally in my laptop. All I did was to say "I have many bitbucket repos and a case management system which can be presented upon request". Of course, noone was interested by came out that they checked my github profile and asked me about it. 
well, that's very good to know and of course I didn't.
I love it. You're getting a tweet from me! 
Hope you don't take my criticism the wrong way - it's an excellent and well-researched article, and I enjoyed it :) It just kept rubbing me the wrong way that you were referring to them as operators, until I got to the section where you revealed their true nature. Good read!
+1 for a detailed blog post
Joining the hash values will fail if the hash is not ordered by insertion order.
Thank you, I will give these a look
We discuss best practices and present an automated solution in a recent blog post: https://bearmetal.eu/theden/rails-garbage-collection-tuning-approaches/
This is pretty cool, but did you see [randexp](https://github.com/benburkert/randexp) - i think it does something pretty similar :)
Actually no, I didn't - that's pretty nice. However, I'd like to point out: my gem handles **much** more of the regexp language correctly! Honestly, just download my gem and try it out - it will generate correct examples for almost *anything*! This gem you've linked to doesn't even handle some basic stuff, like: /[a-z]/.gen # =&gt; "[a-z]" /(?:test)/.gen # =&gt; NoMethodError: undefined method `first' for nil:NilClass /\n/.gen # =&gt; "n" ...Now try these with my gem. Try the most obscure syntax you can think of. I'd be impressed if you found a single unsupported bit of syntax ;)
nice, a useful gem! But i do recommend you come up with a slightly catchier/easier to type name ! :)
What are the differences between this and sequel?
"As to my knowledge it is not best practice to save images within databases" You are right here, you only need the "path" column in the SQL table.
It actually uses Sequel for db connection. The difference is that it's a ROM adapter, so you can use relations and mappers and it's possible to extend it further with more ROM-specific features like combining relations in memory. It also comes with conventions for setting it up so you don't have to handle loading queries from sql files yourself.
All I can say is, it's probably way more complicated than it seems. If I were a consultant and someone wanted to hire me to build an app to "send automated appointment reminders to my clients", I'd say "I don't have enough information yet to know how long it will take or how much I'll charge you. Let's talk more about your business and your needs." The fact that you are not a particular company hiring a consultant, but trying to build software to meet the needs of a variety of business customers, will make it even more complex. I don't know what field of business your customers operate in, but if you (or your customers) expect this product to somehow integrate with their already existing scheduling systems, and send email reminders automatically to people already in those systems... that's going to be the hardest part, especially since all your potential customers will have different systems they expect it to magically work with. I hadn't seen setmore.com before, but looking at it.... it's a full scheduling/appointment solution, not just a 'reminders' thing. It looks pretty good, at least their website makes it seem pretty good! If setmore.com doing the same thing, one question is: Why would anyone use yours instead of just using theirs? But my guess is that there is definitely more than one developer-month that went into theirs, let alone a "never written a web app" developer-month. So if the question is "Can I build a setmore.com clone in a month, not being a 'technical person' and never having written a webapp before" -- the answer is almost certainly 'no'. I don't think you'll have much luck "hiring someone on Odesk to do it for" you either. 
Maybe it's the idea that restricting the use of the word 'operator' to things implemented separately by the compiler... that is a hold-over from a lesser language. `+` is an operator, in plain language meaning of "operator". Why restrict the word "operator" to things that can't be over-ridden, or things that aren't implemented parsimoniously through the ordinary method dispatch system? Where is that definition of 'operator' from, if not a holdover from lesser languages? It's got nothing to do with the plain language or mathematical meaning of "operator". Heck, there's "operator overloading" even in C++... where I think you overload operators by doing something that look an awful lot like a function definition! (But I could be wrong?). It's going to be challenging to tell C++ developers not to call the thing an "operator" when C++ calls redefining it "operator overloading" -- even though you define a function to enact "operator overloading". But, I guess at least you're being consistent, if you expand your "don't call it an operator" campaign to `+` too! Good luck telling everyone not call `+` an "operator" in ruby! 
My first jump into Rails was several months worth of "OK, so how do I &lt;do this thing&gt;?" while trying to build a discussion-board like app and the resulting code was so abysmal in the end that I threw it away and started all over. One thing I can see you running into trouble with from the get-go is *time*. And by time, I mean the scheduling aspect of the application. Time can be sneaky/tricky, e.g. relative time zones, DST, addition and subtraction, converting units. For example, how many seconds are in a month? One cannot answer this question because months have varying lengths. Does February this year have 29 or 28 days? If I schedule something "3 hours from now", what happens if the clocks jump forward or backward an hour in that 3 hours, and more importantly what does the user expect in this case? There's probably open source libraries that can help you -- in fact you probably really want use them rather than trying to solve the problems I'm describing yourself -- but you'd be surprised how tricky it can be just to think design around time from even just a UI/UX point of view. Even now, depending on the requirements, I don't know if I could build a scheduling app beyond a basic prototype in a month. The app you linked to was very likely developed by a team of people and over a longer course of time than a month. I can't tell you with certainty what *you* can or can't do. I'm just going to say I don't think I could do it if I were in your shoes, even though I've been using Rails since 2006. Not in a month.
&gt; So, we know that class methods are a good place to put all the behavior and functionality of all instances of that class. If you want all instances of your Book objects to have a title and an author, you’d want that behavior to be put into the Book class, since all instances of Book will inherit from their parent class. Um, I don't think so. `title` and `author` accessors would generally be instance methods, not class methods. This is confusing. 
I'm going to say it is technically possible that one month from now you could have a functional app that can send appointment reminders. There's a 99% chance it will not be professional quality, and a 100% chance you could better use that month researching &amp; evaluating options others have built. Or hiring someone else to build it for you. There's a good chance that someone has built an open-source app that does this already. Even if it's something you have to pay for, your clients will probably be much more willing to pay for a proven solution over something you built in Ruby as you were still being introduced to the language.
[Sample](http://i.imgur.com/Jmu3rr4.png), yup it works great
This book is more rails focused than pure Ruby but the online version is free, it may help: https://www.railstutorial.org/book/beginning
Is it possible to build a house with a hammer, a drill, maybe some other tools, and some wood? And then live in the house? If yes, can I get some directions on how to start? Assume I know how to hammer and drill, but not how to waterproof. Thanks! 
I saw this - How the hell do I actually run it?
What kind of business? Stay away if it involves PHI.
Hehe, I see your point :) At the end of the day what matters is understanding how these things work in Ruby, and in that sense, the mission has been accomplished in this thread! In fact, I think we beat it to death here :)
As a followup, the difference between those two functions are what some people call a "setter" and a "getter". Assuming you have a book instance, "b", you could set the book title using the first function. That would look like this: b.title=("Learning to Code for Fun and Profit") Then later you use the second function to get the title. what_is_the_title = b.title puts what_is_the_title "Learning to Code for Fun and Profit" The shorthand for these kind of functions, assuming you don't need to do anything fancy like capitalize the input, is: class Book attr_reader :title attr_writer :title end or if you want both in a single line of code: class Book attr_accessor :title end 
The sample provided doesn't work and the distinction between class and instance methods are wrong. Also the lookup chain diagram is a really simplified version but is listed as "intricate". The full article that the image was lifted from is here: http://madebydna.com/all/code/2011/06/24/eigenclasses-demystified.html Also see, https://practicingruby.com/articles/method-lookup-1, and https://practicingruby.com/articles/method-lookup-2
Once you've read the intro books, POODR (Practical Object Oriented Design in Ruby) is a great book to help you write good code. Learn the language/syntax, and then learn how to use it well! 
what does "a gaming site that uses bitcoin" even mean? :) just curious~
No problem... it just means users play for bitcoin :)
Ah I see, thank you for the in-depth response! I guess there are some downsides with using the each loop and manipulating the array you loop with. Good to know for the future though!
&gt; I would go to codecademy first and learn the basics there. I'd stay away from codecademy until you have the programming basics under control. Codecademy is very good for learning a languages syntax but pretty poor at explaining OOP, how to break down a problem, and all the other good things one must know in order to be anything beyond a hack. Try looking into one of the intro CS MOOCs (massive open online courses). The Stanford and Harvard (CS50) ones were my favorite. Edit: typo.
I've been teaching myself as well and I would say get a solid understanding of Ruby before moving on to Rails. I worked on Learn Ruby the Hard Way and then the Rails tutorial. I can say doing it in that order made Rails very clear to me from my own experience
Thanks for the feedback, that's the plan more or less. Would you say after doing both you feel confident enough to work on your own sites, projects or even entry role? 
This is excellent news. I'm going to spend some time and contribute to this.
In other words gambling. Is it a website or a desktop app? 
It's a website. The front end is HTML5, the back end is php/apache and Maria db. What I want to do is do a re write in Ruby on rails and couch db and transfer the data to couch db. I have been told by the ruby guys this is feasible but it's still a scary step. 
Valuables should always be behind a lock and key. So the map should be useless if it's properly protected. 
Am I missing something? class Book class &lt;&lt; self def type "paperback" end end end charlottes_web = Book.new charlottes_web.type This last call returns an error not "paperback". 
Of course, thats what I meant by "security through obscurity is no security at all". Still, I spose if you've published the source of your application, someone can always just go find the routes there
There's a hundred lists of low hanging fruit , find one, crack it open and start working.
here's to beating things to death (metaphorically only please) on reddit! 
It's a tough row to hoe, I think. I think it's important to ask the rest of your team if they _want_ to switch - or, at the least, are completely willing. Forcing a language on a team can be a morale-killer. On top of that, you risk [second system syndrome](https://en.wikipedia.org/wiki/Second-system_effect), another morale (and business) killer. I don't think it's a technical issue at all. It's a people issue. (Most things are.) If you can get everyone on board and excited, and manage expectations reasonably, it could be great! I don't know that anyone in this subreddit is in a good position to assess your risk/reward, and give you the answer.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Second-system effect**](https://en.wikipedia.org/wiki/Second-system%20effect): [](#sfw) --- &gt; &gt;The __second-system effect__ (also known as *second-system syndrome*) is the tendency of small, [elegant](https://en.wikipedia.org/wiki/Elegant), and successful systems to have elephantine, feature-laden monstrosities as their successors due to inflated expectations. &gt;The phrase was first used by [Fred Brooks](https://en.wikipedia.org/wiki/Fred_Brooks) in his classic *[The Mythical Man-Month](https://en.wikipedia.org/wiki/The_Mythical_Man-Month)*. It described the jump from a set of simple operating systems on the [IBM 700/7000 series](https://en.wikipedia.org/wiki/IBM_700/7000_series) to [OS/360](https://en.wikipedia.org/wiki/OS/360) on the 360 series. &gt; --- ^Interesting: [^The ^Mythical ^Man-Month](https://en.wikipedia.org/wiki/The_Mythical_Man-Month) ^| [^Sophomore](https://en.wikipedia.org/wiki/Sophomore) ^| [^Publish ^and ^Subscribe ^\(Mac ^OS)](https://en.wikipedia.org/wiki/Publish_and_Subscribe_\(Mac_OS\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cp2wqum) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cp2wqum)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Read the docs
Before contributing to a project, read the project's guidelines for submitting enhancements. While most of them follow the same guideline, it is still best to make sure that you follow their particular rules. Be knowledgable. Understand the codebase that you will be working with. Become familiar with the overall construction of the project so that the features or fixes that you're building will fit nicely into the ecosystem. Do not blindly create patches or features where it will break or limit other functionality. For example, with the Devise gem, any pull request where you are explicitly referring to a `main_app` method or referring to a Model explicitly will not get your code merged. Be understanding. What you may think as a needed feature may not be seen as necessary by the maintainers of the project. They may consider your feature as bloat. This is okay. Fork the project and add the feature in your repository so that you can use your feature with the project. Be confident. Sometimes maintainers are rather sensitive with their projects. While they welcome constructive criticism, they do not want people touching their code. I've ran into this a few times where I submitted a pull request and it was declined. A few months down the road, I found the same code from my pull request in one of their own. This is okay. Continue to support their project by submitting Issues as they come up or suggestions as you see fit, but do not get discouraged by those who want to be the only ones touching their project. Be diverse. Diversity is a great thing. Do not limit yourself to one aspect of a project or types of projects. For example, do not find yourself only submitting pull requests for small CSS changes. While this is okay if necessary, do not simply hunt these out. Find a project that shares the same passion as you and help build it into something more.
Haha this is cool. I wrote something similar just the other day for a project I'm working on: https://gist.github.com/pachacamac/3356440fdb14acb0e497 Doesn't have all those features but it's a single file with seven lines of code :)
What kind of tasks would you like to automate?
Neat! I think there isn't as much discussion as there could be about how powerful, well-designed, flexible, and consistent the Rails routing system is. People instead sometimes complain about the poor performance. But you get a lot for what you pay. (I still hate resourceful routing though, ha)
I am interested in what you have going. Do you have a GitHub/GitLab link? 
check out https://www.lita.io/
I'll get right on it.
&gt; Think of learning programming or a language like learning an instrument, you can read all the books and how-tos to play the instrument but you're not actually going to make progress until you start practicing by yourself. This is an excellent comparison! If you have some toy project, some kind of program that you always wanted to write - try to do that. You'll be much more motivated if you build something for yourself and not for the sake of some tutorial. :-) What I find useful in the process is to use IRB to try out things and inspect objects. If you find a bit of code somewhere that you do not immediately understand, paste it or parts of it into IRB and see what individual method calls do. Also experiment with variations of input arguments or blocks passed.
http://blog.honeybadger.io/ruby-security-tutorial-and-rails-security-guide/ Scroll down to "A recent exploit" Erlang/Elixir has a similar issue with atoms (which are like symbols) EXCEPT that it has functions which only convert strings to atoms IF the atom already exists i.e. has been "seen" by the compiler (see [binary_to_existing_atom](http://stackoverflow.com/questions/15809229/use-of-binary-to-existing-atombinary-encoding)), otherwise fail. Never forget that things like symbols/atoms are a kind of global state, and global state is bad... or at the very least, must be utilized very carefully. [2.2 has Symbol GC](http://www.sitepoint.com/symbol-gc-ruby-2-2/) but it will be a long while before all the crufty slow code that did String conversion to avoid DDoS is refactored back out. And as you can see from that article, that code caused things to be 2-5 times slower.
The book I learned from was by Peter Cooper (can't remember the name at the moment) and it served me well.
Wow. Couldn't hope a better answer.
No actually I am in the position of deciding what to do and I am thinking to go for open source. I need to prepare some screenshots, remove my keys, write a readme file and search a bit about licenses (I know a complete nothing about them). 
If anyone wants to meet up and have dinner/drinks on Wednesday night, please let me know! And because I know Ruby devs love their coffee: [Palate](http://palatecoffeebar.com/) is my absolute favorite coffee shop in town, these guys nerd out on coffee [Thump](http://www.thumpcoffee.com/) would be my second favorite. That or [Loony Bean](http://www.looneybean.com/) Looking forward to meeting some other developers in Beautiful Bend!
Risks aside, I feel this could be a very good decision if you can hire a couple of expert Ruby developers to architect the system. For the following advantages: 1. Ruby is better suited for quick iterations and feature additions. 2. Has a great set of tools and culture for testing and deployment cycles. 3. Being OO language, the system could be much well designed. 4. Starting from scratch sounds cool for such a successful system as you make the transition much smoothly, only risk being financial loss in developing the system in case its a failure not business readily. At the end of the day, I feel the success of such system is in architecture than what language its being built on. So, I would suggest to hire a top notch Ruby guy to design the system and another intermediate guy to work on his directions. Then slowly transition your team to work on it steps and try to not touch during the core development. As someone mentioned, it may be better to start with small parts implemented in Ruby to see if your team will stick to the plan. Think of micro service architecture to have both PHP and Ruby solutions in containerized systems and then proceed from there.
That is an awesome response, thanks for checking out the video! (I'm Chris) And yeah, I guess I say a lot of things weirdly ;)
I lol'd. You got some fresh updates there.
Hey! I'm pretty new to programming and Ruby as well. I started a few months ago, and the path has honestly been tough. My goal is to try and get into a programming bootcamp and focus on a career down this path as a front or back end dev. Resources I've used include Codeacademy, RubyMonk, Chris Pine's Learn to Program, App Academy practice problems, and Coderbyte problems. Resources I've recently started using include codewars (for problems), theodinproject (which I wish I found out about earlier since they have an organized outline to follow), and jumpstartlabs tutorials. From my experience, and with the long-term goal I have set for myself, I wish I would have started with theodinproject. I just didn't find out about it until recently, but am enjoying reading the articles. RubyMonk was a little too fast-paced and difficult for me to grasp every lesson, so I finished the Codeacademy Ruby section first and went back and finished RubyMonk (Ruby Primer only). Since my goal is to get into a programming bootcamp to expedite my learning process, I've been constantly working on practice problems. I've been working on coderbyte Easy problems. I've completed them once already, but struggled on many of them. So I'm going back through them again, trying to increase the speed of working on problems since the interview for these bootcamps have a time-limit. I'm focusing on problems and speed at this point. Trying to refactor when I can and remember the syntax. I believe the path I'm taking may be different from yours. My main focus at this point is problem solving and speed. But, like I mentioned, I believe theodinproject has a good outline in place. Also, RubyMonk offers more advanced lessons. I recommend also working on problems (either on coderbyte, project euler, codewars, or maybe even the app academy practice problems). Sorry, I rambled on here, but I hope you enjoy the learning process as much as I do and hope you found some useful resources from this thread. :)
Thanks for that was a fantastic article about ruby's symbols and security concerns.
&gt;Try the most obscure syntax you can think of. I'd be impressed if you found a single unsupported bit of syntax ;) err.. RegexpExamples::IllegalSyntaxError: Subexpression calls (g) are not yet supported at least it was handled somehow :) EDIT: ah it was in fact mentioned in the README, sorry! EDIT 2: Ah found one =&gt; /\P{Word}/ &gt;&gt; r.match "x" =&gt; nil &gt;&gt; r.match "." =&gt; #&lt;MatchData "."&gt; &gt;&gt; r.examples NoMethodError: undefined method `[]' for nil:NilClass 
Hey there. Would you be willing to give a few examples, or even open issues in the projects' issues trackers? Since we require students to submit patches in order to be considered for GSoC, this is a great time to suggest those types of changes.
 Transaction performed with: Installed rpm-4.8.0-38.el6_6.x86_64 @updates Installed yum-3.2.29-60.el6.centos.noarch @base Installed yum-plugin-fastestmirror-1.1.30-30.el6.noarch @base Packages Altered: Updated cyrus-imapd-2.3.16-6.el6_2.5.x86_64 @base Update 2.3.16-13.el6_6.x86_64 @updates Updated cyrus-imapd-utils-2.3.16-6.el6_2.5.x86_64 @base Update 2.3.16-13.el6_6.x86_64 @updates Updated ruby-libs-1.8.7.374-3.el6_6.x86_64 @updates Update 1.8.7.374-4.el6_6.x86_64 @updates history info 
They increment the minor version every christmas. It's "Matz gift to the OSS community". Everything from now till christmas will be bugfixes on 2.2
Most importantly, commit code and submit pull requests. Everything else is secondary, you'll learn along the way. 
Thank you for the well thought out response elaborating on your learnings. Our end game is the same in that I also want to make a career out of it and eventually attend a boot camp. I want to apply to the flatiron school here in nyc they have a fellowship program that low income individuals such as myself can attend to little to no cost. I just haven't built the confidence to apply yet but hopefully I'll be able to attend this upcoming fall. The odinproject looks really good you're not the first to recommend it. After I finish my Udemy course I'll check it out. Also thanks for the tip of the coding challenges I'll also look into it. -- It's been a fun journey so far, I hope you continue to find success :)
Same feeling.
usually you would do `bundle install`, `rake db:migrate`, then `rails s` but this project is no longer supported. I'd recommend building your own but by the looks of it, it seems that you have no experience with rails. In conclusion, before you go asking around how to produce a project I'd recommend actually learning the framework first, https://railstutorial.org is a great resource.
Nice, its like a 2 or 3 minute walk from the conference area. If you like dark beers, may I suggest [The Abyss](http://www.deschutesbrewery.com/brew/the-abyss)
If you really want to build for all three platforms, without going native for each, you are probably better off with Cordova http://cordova.apache.org If your set on ruby you can cover iOS and Android with Ruby Motion http://www.rubymotion.com 
Using procs in case statement is extremely weird I think.
Here you are, I took some really quick ones https://flic.kr/p/rsGz1L
Check the link on the top please and let me know what do you think.
I thought it over and over and your reply inspired me. I really owe you! 
Looks similar to something that I've been working on: https://github.com/tomdalling/rschema
Nice job Phusion team! I know that this has been a ton of work and a long time coming. 
Thanks. :) It has taken a lot of time indeed. I can finally take a vacation now.
There's also [RhoMobile](http://rhomobile.com) which is similar to Cordova but focused on ruby. Can't say much about its quality because last time I worked with it, it had just been acquired by Motorola so the website was in a pretty chaotic transitioning state.
There is RhoMobile, and I have actually used it, RhoMobile works differently than RubyMotion in that it actually embeds a ruby runtime onto the device, you have the option of calling ruby code as well as pure HTML JS/CSS. In our application RhoMobile added a lot of extra overhead and ran very slow on iOS, since it is single thread. That and the combination of high price point to get usable features and the relatively small community offering support. Cordova fit our needs better.
Nice! Been waiting for this
Thanks for posting!
So basically, if I wanted to get ruby on any of these platforms, I would have have to have a sandwich of layers in between ruby and the actual compilation code? I get that not every language can be supported on every platform, but wouldn't all this extra stuff only slow things down? 
Awesome! Thanks.
I agree with your example as a good use for case... but not most of the examples in the OP. Some of those weird acrobatics with procs just seems confusing, and I don't understand the benefit, to expression of intent, or anything else. 
Basically ORM are false friends: they make fetching and saving data in an object way easy hiding away all complexity which encourages doing everything via OO manner. This creates problems like: User.find_by_id(5).best_friend.mother.name This will query DB for User, then perform another query to find hist best friend, then perform 3 query to fetch all data about mother and finally return mother's name - 3 queries fetching complete set of data when all you needed was one string and that could be done in one query. More extreme example would be something of sort: User.find_by_id(1).friends.first.friends.last.id Now image that User 1 has 10000 friends and each of them has 10000 more friends... Can you see the amount of time wasted on sending data that in most part won't be used? To a degree you can eliminate this by using some ActiveRecords tricks but more serious application sooner or later will have bottlenecks which can be fixed only by oldschool SQL... Other reasons I can think of: * all ORM I can think of rely on mutiability of state and these days mutability is passé, * ORM uses lowest common denominator, so speed/security tweaks that can be done only using dialect specific things cannot be used, * no views, no triggers, or other "low level" tweaks, * tendency to bend DB schema to match class definition which harms flexibility and makes using already existing DB more tricky, * some people have tendency to think that ORM queries are automagically optimized, * at some point you might find yourself in situation when modifying SQL (or some SQL builder) would be easier than configuring whole project to do one particular but performance critical thing other than ORM-default way - at this point ORM will only increase accidental complexity instead of limiting it.
woah. I can't decide if this is actually a good idea to ever do or not, but it's definitely neat. 
From what you describe, I wouldn't. You have something that works, and makes you money; it's written in php; you have a staff that knows php; you have no staff that knows ruby and you don't know ruby either; but you want to rewrite a large component in ruby? That sounds like it sounds, doesn't it? Before deciding, consider Joel Spolsky's famous "Never Rewrite" rant: http://www.joelonsoftware.com/articles/fog0000000069.html You could experimentally start the ruby rewrite as a side project, while continuing to maintain/develop the PHP. You or some sub-portion of your staff could devote some portion of their time (not all of it) to it. See how far you get in a month, and re-evaluate based on what you've learned. 
Right, that describes well one of problems with ORMs.
Correct. Any build once. Deploy anywhere framework adds overhead and performance impacts. Just like ruby isn't as fast as C programs on a server or desktop. The difference is. PCs have way more power than a mobile device. 
Hey /u/solnic ! Great post. Would you be so kind as to elaborate on point #5? &gt; Reminder: a Class is a globally accessible object that you can use without the need to inject it as a dependency. It feels like this thought has a lot more to it that you've internalized. ELI5?
I'm not aware of any books/articles, but I found the best way to get into the "immutable" mindset was to use a language which is entirely built around immutability (e.g. Haskell) and try to solve common problems within that language or look through code of existing libraries.
Alright! Thanks for that. I read and re-read it a few times, but the closest I could come to parsing it was this idea: class Burrito # A bad class interface def self.send_to_all_hungry_children # A process to gather up a ton of burritos and send to # hungry children the world over. end # A good class interface def self.lovingly_craft(filling) # Basically a factory method that takes `filling` and # makes a Burrito object. end end 
&gt;Pretty much every argument against mutability ends with this. What's so bad about it especially in web apps? I think SICP does a good job of explaining the costs associated with introducing mutable state. Here's a snippet &gt;A language that supports the concept that "equals can be substituted for equals'' in an expresssion without changing the value of the expression is said to be referentially transparent. Referential transparency is violated when we include `set!` in our computer language. This makes it tricky to determine when we can simplify expressions by substituting equivalent expressions. Consequently, reasoning about programs that use assignment becomes drastically more difficult. &gt;Once we forgo referential transparency, the notion of what it means for computational objects to be "the same'' becomes difficult to capture in a formal way. Indeed, the meaning of "same'' in the real world that our programs model is hardly clear in itself. In general, we can determine that two apparently identical objects are indeed "the same one'' only by modifying one object and then observing whether the other object has changed in the same way. But how can we tell if an object has "changed'' other than by observing the "same'' object twice and seeing whether some property of the object differs from one observation to the next? Thus, we cannot determine "change'' without some a priori notion of "sameness,'' and we cannot determine sameness without observing the effects of change. Later on: &gt;In general, programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed. This issue simply does not arise in functional programs. The complexity of imperative programs becomes even worse if we consider applications in which several processes execute concurrently. https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_sec_3.1.3
IronRuby seems to be an abandoned project (last work was done 4 years ago). I'm not surprised there is no contemporary documentation or help online. Why try to use it now?
I wanted to use something that gave me easy access to making frames and panels. I first chose JRuby, but it appears the compiler in the latest version is broken, and I read that downgrading it still doesn't work.
Whoa, mutation testing. That's really neat. I don't feel like I've ever gotten an app to the point where I had sufficient test coverage where mutation testing wouldn't immediately find a ton of problems... but it would be a great way of smoking out a few more edge cases. Now that I'm thinking about it maybe I'll give it a shot though; could run it on some of the more critical code and see what comes up.
If you're not using the ORM, you're still going to have to construct the joins to fetch things efficiently. How is it worse to do it in ActiveRecord instead? Just because ActiveRecord lulls you into false security and you forget to do it? (which may be legit; me, I like a well-designed ORM, which I think AR is despite some rough spots, but I've never thought you could avoid understanding SQL when you use an ORM). 
This is talked about in the article's "Builtin web server" section
I am waiting for the first app where a user can type in a url that the app will access and the user types in localhost:port/restart_the_server.url
I have no idea what I just read.
One big problem with mutable objects is that that any part you use to compute a hash value can't be mutable, or you'll get really nasty bugs. For DB objects this is easily solved - if you're aware of it - by using the DB id.
What's wrong with JRuby? The next version of shoes is even being written in it. 
Phusion, with built-in caching included and all, has been disingenuous about the performance of their server. You'll find that your usual main-stays outperform it by quite a bit. Additionally, if you end up using Torquebox, you'll see 200%+ performance improvements in many situations. I have used the full gambit of Ruby servers, and have been using Puma or Torquebox exclusively for the last couple of years. For more info, check out http://torquebox.org/news/2014/12/05/torquebox-4-0-0-alpha1-released/
So basically the argument is that because caching works, showing that caching works on a static request (what was the expiry on that cache, btw?) is valid? The same argument you used is similar to saying, "well most pages should be cached until they're changed, so we'll benchmark with the assumption that pages never change! We won't even need to communicate with the app after the first request!" In fact, that's *exactly* what the Phusion benchmark set out to do. This quote from the Torquebox article is relevant: &gt; The merits of "hello world" benchmarks are debatable, but they do provide some valuable insight into the maximum throughput any server can possibly achieve with the simplest of Rack applications. With turbocaching enabled, Raptor serves cached responses to the benchmark client, bypassing the Rack layer entirely, even though the Rack application never indicates that the response should be cached. This invalidates any usefulness of the benchmark except to prove that caching can improve performance, which is already well-known. Further, I'd love to see a benchmark that pits Phusion 5 against Puma and Unicorn on MRI with "turbocache" disabled, and configured with processes to processes and workers to workers in a conventional set up (for unicorn that's about 4-8, Puma would be 4procs, 8-16workers each).
Show me a Non-TODO GUI (J)Ruby app with a Windows .msi / .exe, OSX .app (and preferably Debian .deb ) installer. If you find one, I will be shocked. If you don't find one, there is a reason for it, packaging GUI (J)Ruby apps for cross-platform distribution is a nightmare. Non Gem packaging and distribution is Ruby's red-headed stepchild although some things are being done with shooes and travelling ruby.
&gt; I like a well-designed ORM, which I think AR is despite some rough spots, but I've never thought you could avoid understanding SQL when you use an ORM I've seen arguments that in enterprise environment you often meet people who use ORMs because they are *afraid of SQL*. So they transfer as much as possible outside of database. Transactions, checks, assertions, etc - they move everything outside of DB because they want to avoid any direct contact with database in the name of *portability* and *having business logic in business logic layer*. While those two factors are important some people abuse those arguments similarly to how some people use *premature optimization is the root of all evil* as excuse to create slow code that is impossible to optimize at all. IMHO using DB as if it was CSV file with search options is retarded. If you have perfectly safe ACID solution why wrap it with another layer of abstraction which will have to reinvent transactions? Worst of all if you too long hang around enterprisey guys you start to think that this is *good*. That validation of internal data integrity should be checked within ORM (what happens with existing data when you add new check? will it be removed? will you have to remember about upgrading it to fit new constraints? if you used DB engine to do the job would knew right away that some existing data need to be changed to have consistent data with new constraints. With ORM I'm not o sure). Eventually you end up with *every* kind of logic in business logic layer - be it checking whether parsing input JSON succeed or whether username is unique.
Yes I'm going to write a separate post about #5 as many people are asking me about it.
Where can I read more about what parameters are required in which cases?
concurrent requests! thanks!!!
You can use environment variables in a Ruby program via Hash ENV. Your original problem can be tackled with [IO.popen](http://ruby-doc.org/core-2.2.0/IO.html#method-c-popen) and [relatives](http://ruby-doc.org/stdlib-2.2.0/libdoc/open3/rdoc/index.html). Edit: spelling
At the risk of my friends reading this and laughing at my predictability: have you tried elixir? I went down a bit of this path, but re mutable state, ruby encourages you to shoot yourself in the foot. I still love Ruby and will continue writing it, but writing immutable code in it versus elixir is night and day. Plus lots of rubyists you know and love have been making their way over at least to visit 😀
This is your friend, chuckling at your predictability, but /u/solnic is gonna love Elixir.
Key points: &gt;reasoning about programs that use assignment becomes drastically more difficult. &gt;Once we forgo referential transparency, the notion of what it means for computational objects to be "the same'' becomes difficult to capture in a formal way. &gt;programming with assignment forces us to carefully consider the relative orders of the assignments to make sure that each statement is using the correct version of the variables that have been changed.
Implement them!
One of the best ways to get better at language (once you've learned it fairly well, obviously) is to study a completely different language. I haven't got round to it myself yet, but I hear studying [Haskell](http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Maybe.html) or [Lisp](http://landoflisp.com/wizards_game.lisp) can help you see the strengths and weaknesses of your "main" language (such as Ruby/C++/Java) in a whole new light.
In that one sentence you have summarized all the reasons why we are still using mutable OO languages today.
Glad to hear it!
Step 1: don't. But if you must VB.net and VB6 GUIs are generally created with a GUI creator in Visual Studio. With VB.net I know there is a way to do it with XML files but a quick google search could not get me a reference to provide for you.
They're probably already Implemented, c++ have an enormous number of libraries. 
Run towards Elixir then ;)
I just realized now that it was an article and not a question.
You mean, like, std::for_each( x.begin(), x.end(), [](i &amp;int) { ... } ) ? :) C++11/14 is a bit amazing for that sort of thing.
Will learning a language such as Rust/Go have the same benefits? These newer languages are still quite low-level but build upon the downsides of C++
``` class Thing &lt; ActiveRecord::Base end ``` ...is far easier and more powerful than writing raw SQL and performing actions against a raw result set. Not to mention all the value add of validations, associations, query composition, analyses for n+1, pluggable caching and familiarity. I recommend **knowing both**. I take advantage of my SQL knowledge all the time when using active record. I usually find that I can express my SQL query easier using AR constructs including grouping, having, aggs.... I don't think Active Record is bad other than that it may encourage people to only learn half the story. If you dive into SQL and relational data modeling after learning ActiveRecord, you're doing it right. I don't mean to be aggressive but I do get a little peeved when people assume ORM is the reason people don't understand SQL. Not using AR is won't teach you anything about proper data modeling or how to write good SQL. Let's flip the statement: AR is extremely powerful, so why not take advantage of it?
That's good advice. Only thing I'd add is if you have any other kind of meta-structure (aka models vs. controllers, etc.) you might want to include those as top-level folders and then further namespace as needed (inside `./lib` I guess).
examples on #3 would be nice. 
Coming from Django, annotate is in the gemfile of every project I work on. I don't like looking in schema.rb for what columns are available in a model.
I'll be giving a talk on exactly this (with, yes, a few jabs at the Active Record pattern) at RailsConf 2015. My [2014/2015 blog posts](https://push.cx) have my fumblings towards it and reading lists.
For future reference, the official c++ documentation is pretty good, though don't use the cplusplus.com site since it's just, well, bad. http://en.cppreference.com/w/ Keep in mind that C++ and Ruby are very very different, don't try to do things in C++ the ruby way and don't try to do things in ruby the C++ way. The language was not designed with those very different styles in mind, so attempting to work against that is like trying to work against an opinionated framework such as Rails, or in other words a monstrous amount of headaches and suffering. Regardless of the hate C++ gets, I feel it is a very good language when you take into consideration the recent C++11 and upcoming C++14 changes. Also, keep in mind that C++11 is rather different than the previous C++, for example it adds the iterators /u/comrad just said as well as the auto type. The language is a very good thing to have under your belt.
This is not amazing... This is ugly as fuck.
How different is 1.9.3 to the current stable version? We just upgraded to Rails 4 and already faced several deprecation errors (let alone those from gems).
Great setup advice. Took me an hour to find the public key so I could import my bitbucket repo. Is it possible to hold multiple repositories in one Box? I do not want to pay for Nitrous, but would like to work on a small personal project (from a tutorial), and a closed source app. How trusting is Nitrous for closed source apps? Besides Cloud9, any other semi free services with a cloud IDE and terminal? I am so lazy I haven't installed Linux as a dual boot yet at home.
Not exactly clear what the advantages over JRuby aside from having a compiler perform type checks. Is that it or are there other benefits? (speed? etc) The site should be singing those advantages on the front-page in easy to see bullet pointed red flashing test
I tried it for a week or so and didn't like how every migration caused a bunch of changes in my git repo. Just something to consider.
Coming from physics, I much prefer eigenclass instead of metaclass. To each their own. 
For any particular concern?
I use [forman](https://github.com/ddollar/foreman) to manage all our ruby processes running on EC2. It can export configs for the majority of init systems (systemd, upstart, supervisord, etc). It provides environment management and you can plug in a custom exporter in case you need something special. It also uses the same Profile format as heroku. 
 def wrapper(*args) hash = args.pop hash.merge!(some_flag: true) if hash.is_a? Hash original(*(args &lt;&lt; hash)) end 
InfraRuby code runs in Ruby interpreters without modification. You're not trusting your app to InfraRuby, because you can always go back to using a Ruby interpreter and take your code with you! This is feature #1 for InfraRuby. InfraRuby itself depends on this feature: the InfraRuby compiler is written in InfraRuby and is bootstraped using JRuby. &gt; I can think of a dozen reasons that branch off of that, from support to stability to security to community and more. Support: for the compiler and runtime, free: support@infraruby.com Stability: the InfraRuby language has had no backwards incompatible changes in two years, and no such changes are anticipated. Security: advisories (none yet) will be published at infraruby.com and also emailed to you if you ask at security@infraruby.com Community: working on it! &gt; That said, I love the idea of what you're doing and I'd love to play with it sometime. Thanks! 
&gt; don't use the cplusplus.com site since it's just, well, bad. I know we're drifting OT here but I am curios: what is the criticism? I used the site occasionally for doc of library classes and methods and found what I needed.
Do you want an example of mutability or an explanation of why mutability is bad? In Ruby, an example of mutability would be `Array`s: &gt; a = [1, 2, 3] &gt; b = a &gt; b &lt;&lt; 4 &gt; puts a.inspect [1, 2, 3, 4] =&gt; nil As you can see, changing `b` changed `a`, since they both point to the same, mutable thing. If you check the `object_id`, you'll see it never changed: &gt; a = [1,2,3] &gt; b = a &gt; a.object_id =&gt; 22545120 &gt; b.object_id =&gt; 22545120 &gt; b &lt;&lt; 4 &gt; puts a.inspect [1, 2, 3, 4] =&gt; nil &gt; a.object_id =&gt; 22545120 &gt; b.object_id =&gt; 22545120 But if you're using something immutable like a `Symbol`, the `object_id` will change and the original reference will be left alone &gt; a = :hello &gt; b = a &gt; a.object_id =&gt; 395528 &gt; b.object_id =&gt; 395528 &gt; b = (b.to_s &lt;&lt; "world").to_sym # I'm cheating a little here, but this is just an example &gt; puts a :hello =&gt; nil &gt; a.object_id =&gt; 395528 &gt; b.object_id =&gt; 395912 # this is different now &gt; puts b :helloworld =&gt; nil So whatever `a` was referring to originally remains untouched, no matter what you do to `b`, even in the same scope. This becomes important in mutli-threaded applications where multiple references to the same object all have the authority to alter the object, also known as "shared mutable state". 
&gt; I frequently gain substantial benefit from being able to look at (and contribute to) implementation internals. You could also benefit from having the direct support of the language implementor! Every question you have about using InfraRuby (sent to support@infraruby.com) will be answered promptly. (Also: only the compiler and runtime are closed source; the surrounding tools, compatibility gems, etc. are all under the MIT license.) &gt; My past experience tells me that building a product on a closed-source spec-incomplete Ruby implementation is a quick path to pain. InfraRuby is (intentionally) incomplete, but the runtime suffices to implement a compiler and a framework. (The site at infraruby.com runs on a framework written in InfraRuby.) These methods are provided by the InfraRuby runtime: http://infraruby.com/reference The test suite for the runtime is also run against MRI and JRuby, to check compatibility. &gt; I contribute to JRuby Thank you! The InfraRuby compiler is bootstrapped using JRuby. Your work is very useful! I hope InfraRuby will also be useful to people. 
I have the direct support of the language implementors in open-source implementations, too, plus the ability to evaluate problems and potentially fix them myself. I get that you're selling support here, but being in the position of needing to buy consulting for a closed-source product because I can't put in the work myself makes selection of InfraRuby a difficult decision to justify from a business perspective. If your team stops supporting it, or doesn't support it quickly or well enough, or goes evil and decides to break things in opaque ways, I (along with my stakeholders and customers, not to mention credibility and potentially job) am left dangling in the wind. The risk is substantial; I couldn't sell it to my boss because of the risk exposure. I get that it's intentionally spec-incomplete, but this effectively means that a *lot* of Ruby code won't be runnable under it; reflection and metaprogramming is big time in Ruby code, and if its presence means that it doesn't run under InfraRuby, I'm left reimplementing stuff. At that point, I'd just as soon be writing Scala or Elixir or whatever. Strong typing is awesome, and I honestly do commend your effort to bring it to Ruby, but a closed-source intentionally spec-incomplete implementation is a minefield from a business perspective.
This looks like a handy gem to have for deployments. Cleaner logging is always a plus.
what framework are you using?
Learning any new language will of course help you progress - it's impossible for me to say exactly which one you should choose! However, I think the most important thing is to mainly focus on *what you want to build* with the language. If you want to create some high-performance multi-threaded tool, such as a data analysis tool or network monitoring system, then perhaps Go sounds like a good choice. Or if you're more interested in creating smaller, more "mathematical" tools then maybe consider Lisp, or [Julia](http://en.wikipedia.org/wiki/Julia_%28programming_language%29), or [R](http://en.wikipedia.org/wiki/R_%28programming_language%29), or whatever else best solves the sort of project(s) you have in mind. I feel the most important thing to keep in mind is personal interest and motivation. Find something you'd really like to have a go creating, and *then* learn a suitable new language.
Yeah, foreman and Procfiles are the way to go. Cloud66 supports Procfiles now, too, and I use foreman for development.
I wrote that I avoid mutable state *in my code*. Rails is full of mutability. There are new frameworks that avoid mutability, like Roda for example.
Just register your email after installing this gem! So this 'article' has nothing about actually tuning your GC beyond installing their gem. Is it open source? I don't know. Is it a Saas? It looks like it. How much does it cost? Who knows?
Super cool idea - why not write workers in a language that can handle concurrency better than ruby? Sidekiq can be a bit of a black box, and this has made it finally click for me. I think a batch implementation like Sidekiq Pro has wouldn't be too hard to do either in Elixir.
Great implementation. This is one of my favourite interview questions. I'm not sure if it's an algorithm that every programmer should know, but still, great little gem.
Elixir (or should I say, Erlang) is about 5-10x faster in my informal tests As a Ruby guy, learning Elixir has been largely awesome. Letting go of object instance state was a little painful at first but just passing state around (hint: if there's a lot of it, you can probably redesign something because it's kind of a smell) now makes much more sense to me (and is also far easier to unit test).
Nice, I didn't realize you could use `next` and `break` from a Proc (as well as a lambda) to get "return from block" behavior -- wait, I'm still not entirely sure you can, I need to play with it, the examples are leaving me confused. 
Do you want a list? There a literally hundreds of reasons.
The main reason is that imperative languages closely model the CPU.
We just moved to rails 4, so I think Ruby 2.0 is fine for now
Here's a similar lib for Golang. Pretty cool idea to use Sidekiq as the middleman to help distribute or improve processor performance.
&gt; afraid of SQL That means they are incompetent and ORMs have nothing to do with it. Anyone who uses RDBMS have to deal not only with "logical layer" i.e. SQL but with "physical layer" i.e. indices, query plans, server settings etc.
I don't think that this style is weird. I actually prefer it. I would be happy to see more people writing Ruby this way.
Okay, I have to get some bikeshedding out of my system.. I find it's better to use the `#&lt;&lt;` method to append events to an event store. This way you can pass in an empty array as the event store for testing purposes. Also, it looks like you have a hard reference to the `OrderEvents::OrderCompleted` class. This is not ideal with event publishing. Why not just pass `:order_completed` with the params, and expect the event store to tell you when your data transfer object doesn't match the schema? This allows you to avoid propagating the implementation of `OrderEvents::OrderCompleted` to other services that will inevitably have their own repository. Finally, I think `#execute` might be a more appropriate method name than `#call` here. Even better than that would be to rename your class to `Order` and rename `#call` to `#complete`. This whole `#call` convention is kinda silly. If you want to make your object behave like a `Proc`, it's better to implement `#to_proc`. But that doesn't win you anything here, so better to simply use more meaningful names. Now that I have gotten this out of my system, I'm extremely happy to see that someone took the time to go out and blog about event stores and task oriented interfaces. Not enough rubyists understand DDD, IMO. Thanks for writing this! Final note, ruby's built in `Observable` provides a good duck type for shaping the public api of your event store. Though the `#changed` method always ends up being a noop for me.
Good idea. Sadly it crashed when I tried it.
My point was they seem to mirror the primate brain, but hey, sure, the CPU just as well :)
this may help.. https://github.com/grosser/maxitest
JRuby AOT produces similar bytecode to JRuby JIT (so after warmup it has about the same performance), and that bytecode is not ordinary! All method calls go through JRuby's dynamic method dispatch code. ProGuard can't do much with that. For comparison, see the bytecode produced by InfraRuby: http://infraruby.com/blog/how-to-compile-hello-world http://infraruby.com/blog/how-to-compile-ruby-case-statements 
&gt; not as a data structure that isn't private. Do you mean the class/struct itself which should be private or are you talking about the attributes?
I thought it is /r/ruby, not /r/learnprogramming
Thanks. Sorry it didn't work for you. I have been stumbling onto gemfiles that break it and writing fixes and thought it was mostly good. Can you tell me which github repo or paste the gemfile in a comment to me so I can resolve that one too?
A good version of this where there's more than 3 jobs and not all of them are mainly JavaScript with a "basic knowledge of Ruby" sprinkled in, yes. I would like to see that to be honest. 
I see where you are coming from. What rails teams often call the "service object layer" I find is actually what you want your domain model layer to look like :) My advice around `:order_completed` was to win you the ability to publish events out to other services -- in the SOA sense, not "service object" -- as soon as possible. This was you can start separating concerns in a distributed fashion. At my last job we started with redis to store the events, which is not ideal but it gets you going and is likely already in your Gemfile. I've seen a demo of [EventStore](http://geteventstore.com) and it looks pretty cool, though you will only be using it's ATOM API, as it only has native bindings for C# and javascript, iirc.
If you just want colors, check out `minitest-rg`
[Practical Object-Oriented Design in Ruby](http://www.poodr.com/) is a popular book in the Ruby community, and I personally found it to be really helpful. Here's what's covered, straight from the website: * Decide what belongs in a single class * Avoid entangling objects that should be kept separate * Define flexible interfaces among objects * Reduce programming overhead costs with duck typing * Successfully apply inheritance * Build objects via composition * Design cost-effective tests * Craft simple, straightforward, understandable code If I understand your questions it seems like POODR (as it's commonly abbreviated) is the resource that you're looking for! As a personal anecdote, I found it really helpful that Metz describes not only how to decide what goes where, but *when* to decide what goes where. So it's not just "here's what a finished class should look like" but also a "here's what this class will look like over time, as we become more aware of what's required of it. Also, here's how we'll keep it from becoming a nightmare to change/maintain." **tl;dr:** Does building an application feel like playing a game of Jenga, with each successive change filling you with an exponential dread? Wondering how to avoid this? Metz's [Practical Object-Oriented Design in Ruby](http://www.poodr.com/) will help.
Thanks. I am a brand new rails dev and had to go through the code and figure out what was going on, so I thought this might help others. I posted in sinatra, rails, and ruby, because I thought it was ok, but I am new to sharing things on reddit and can pull down those others. My next plan is to create my first gem with this so individual gems can be looked up in command line as well as generating a gem-info.md file. Thanks again for the feedback. It's intimidating to put yourself out there as a new developer. 
I've started to realize this... Is there a way to make an order? Seems hard to follow TDD if everything is randomized. Edit: been using your site for several examples and guidelines, and have signed up for your book!
I agree with you. I don't usually post minor releases. I posted 5.0.2 here today because it's a major bug that can take sites down.
You should check out rails to learn about REST database backed apis. It's very opiniinated so it will give you one good way to do this. It might not be the best long term solution but working through a tutorial or two should get you going. Hartle's tutorial is great.
I agree it's intimidating. You seem to pushing through it well. I didn't notice this was a cross post and I honestly have no idea if that's cool here or not. Anyway, keep up the good work.
Might wanna take a look at some of the frameworks out there like Grape, Padrino (even Rails) to see how they organize a project and get some ideas.
Thnak you for the replay. I agree with 100% to what you are saying. Since I do not write that much but work in a code orientated department I am fully aware of the cost of bad code, but I have not yet had the time to sit down an learn good code. I realized how little I know and I do not want to create that hairy mess I need in order to improve it. Maybe I know too much for my own good. 
That was my plan, but I rather have some model to build my understanding around before I go out and look in the wild. It feels much better to have learned the fundamentals and the go out in the wild and find project that follow rather than just going out and trying to figure it out the structure from scratch.
I would say it's hard to follow TDD *without* test randomization. Your tests must not interact with one another.
no. that would have no bearing on OP's issue.
_Usually_ when you're doing TDD, you're doing one failure at a time unless something catastrophic hits, or you have test order dependencies. Randomization helps ferret out the latter, and nothing can help with a catastrophe. If you have lots of failures at one time, maybe we should focus on that and help you with your workflow so it is less of an issue.
It's great! Keeps you from making stupid mistakes, and if you're on a team it keeps a consistent style.
I think this probably happened with me the other day too. It was running great for about 24 hours and then I got a slew of 500s coming in but didn't have the time to debug it all so I reverted back to Puma.
&gt;double quotes dumbass! That's a more controversial request though. There is absolutely no gain in using single quotes, and personally I find it far simpler to just say "double quotes everywhere" than sit there going "ok, I'm about to write a string. Is there a variable to interpret in there? I better get this right.."
And the good part is, you can tell rubocop via the project or global `.rubocop.yml` file that you prefer to use double quotes or not to nag you about it at all :) Style/StringLiterals: EnforcedStyle: double_quotes or Style/StringLiterals: Enabled: false
&gt; Is it worth it to go in there and configure all of it? That's entirely up to you. Since it's a tool for a wide audience, it makes sense to expect people to tweak the settings to their preferences. You could autogenerate a config file that disables most of what you'd consider a false positive (anything that already shows up in your code), and then selectively re-enable anything you think is worth it. Rubocop has opinionated defaults (much like Rails), but it's not hard to make changes or disable large swaths at a time.
I agree that this is a fairly pointless warning... However, when I *do* want to toggle between single/double quotes, a nice tool to use is [vim surround](https://github.com/tpope/vim-surround) (and maybe an even shorter shortcut for this case, in your .vimrc).
Nope ;) # from test.rb dummy = 1 dummy -= 1 p dumy # typo *ruby -cw test.rb* *Syntax OK*
How do typos like that happen when people practice testing?
No idea what your version of ruby is, but: $ ruby -v ruby 2.1.5p273 (2014-11-13 revision 48405) [x86_64-darwin14.0] $ cat foo.rb #!/usr/bin/env ruby dummy = 1 puts dumy $ ruby -cw foo.rb foo.rb:3: warning: assigned but unused variable - dummy Syntax OK $ ruby foo.rb foo.rb:4:in `&lt;main&gt;': undefined local variable or method `dumy' for main:Object (NameError)
Likewise! Prefer it so much that a gem was born from it! https://github.com/shuber/eigenclass
Cool, I'd never heard of Read Ruby and I Love Ruby.
*cough* https://github.com/YorickPeterse/ruby-lint *cough*
Izzy is fairly straightforward: https://github.com/baweaver/izzy Streamable might be a more interesting read: https://github.com/baweaver/streamable
Just an FYI, this is built into shoulda-matchers which is a more comprehensive rails/rspec matchers library so is somewhat redundant. 
https://weworkremotely.com/ although companies may not appreciate reposting in reddit
So obvious *in hindsight* that I can't believe nobody wrote this 3-5 years ago.
Hello LongElm, glad you like micromachine :-) Many of my libraries have less than 100 lines of code, but that's mostly the result of the design decision of distilling a solution to one particular problem. I use [mote](https://github.com/soveran/mote) for templating. It's a good read (in my opinion) because it lets you see how to build a basic templating engine (33 LOC). As you already know micromachine, you may want to take a look at [finist](https://github.com/soveran/finist), which implements the same concept but using Redis for storing the available events and the possible transitions. The fact that everything happens in Redis means you can't run into race conditions when using the finite state machine (37 LOC). The library [totp](https://github.com/soveran/totp) implements "Time-based One-Time Passwords". I'm not sure it makes a good read, maybe it's not that interesting, but it showcases a common security related algorithm (34 LOC). [Clap](https://github.com/soveran/clap) provides command line parsing. It doesn't ship with lots of features, but it's handy and easy to understand. It makes an interesting use of `arity` to determine how to parse the flags (28 LOC). The tool [mt](https://github.com/soveran/mt) simulates an SMTP server and lets you visualize the emails you send to it. It is handy for development and the code uses sockets, so it may be interesting to read (31 LOC). For managing gemsets I use [gs](https://github.com/soveran/gs), worth reading as it operates on a very basic principle with powerful consequences. Because the name of the executable (`gs`) conflicts with GhostScript, I also released it as a gem under the name [gemset](https://rubygems.org/gems/gemset) (42 LOC). There are some others, and if you liked the ones I mentioned then take a look at the rest. There are also small libraries in other languages, including some ports (mt -&gt; mt.c, finist -&gt; finist.lua). By the way, there's an IRC channel on freenode called #lesscode, for people that are also looking for small, simple tools. You are more than welcome to join us.
Linked to this thread from here: http://www.reddit.com/r/tinycode/comments/2yfocr/favorite_ruby_libraries_under_100_lines/ You might like this subreddit :)
That's pretty trivial if you think about it for a second: method arguments are evaluated *before* the call, so passing $1 to the call can never work because it won't change during the call - especially if used inside a String interpolation. Note, yes in theory $1 *could* change but that is obviously a bad idea because code that would store the object somewhere would result in a collection of multiple references to the same instance.
Thanks for the link! I'm just curious, could all of these be used to learn/brush up on the 2.1 way of Ruby programming? A little background: I haven't touched the language in a long time and was going through some refresher material, but I noticed a lot of it is for 1.8/1.9 and not 2.0 or 2.1. My concern is that I'll be learning "old" methods instead of the newer and better stuff that's out there. Sorry if this is a little long for a comment, if it would help I can make a separate post about this. 
I was at this talk and while it was pretty impressive, I still think there are a lot more negatives to doing it this way than he let on. After each step the answer was basically 'so we built something in house to do it'. Capistrano doesn't work with this beast? We built our own deployer. Active Record can't handle talking to so many databases? We built our own adapter. Rspec takes way too long to run? We built our own test runner. etc etc. Listen to the talk when it pops up on confreaks, kind of funny how many times he says 'so we built our own'. A microservices architecture would have avoided the need for all that custom, in house supporting architecture. It's impressive how well it works, of course, but I can't help but think how much easier it would be if it wasn't like this. Not to say that services are a panacea, they have their own issues (don't even ask me about how easy it is for a new dev to get our stack up and running...), but I think those issues are easier to deal with than the monolith issues. 
Rails (as distinct from the Rails community) has always valued pragmatic leadership over following "trendy internet conventional wisdom." It's almost like clever people can apply principled thought to come up with solutions that work rather than caring about what is fashionable.
Why did you omitted the assignment `dummy -= 1` ? By this you've lost the whole point of my comment and even Ruby 2.1.5 won't throw a warning.
Exactly.
Nope, you've not demonstrated finding typo in a dynamic language is *pretty easy*. Rather your plain misunderstanding. Finding typo in Ruby is extremely difficult as identifier and its binding is resolved until during a runtime. How would you decide for example myobj = Klass.new include ExtraModule suffix = get_some_string() # ExtraModule::get_some_string myobj.send('klass_instance_method' + suffix) I'm not against BDD/TDD, these are very useful techniques, but in a language like Ruby you are **forced** to write tests to check even just typos in your code. For Python, a conceptually similar language to Ruby, there are serious attempts to perform statical code analysis *including* identifier names check. See projects like [pyflakes](https://launchpad.net/pyflakes) and [pylint](http://www.pylint.org/) f.E. Even with some false warnings it can greatly help reduce annoying type errors in advance before testing (if any).
For anyone looking to disable certain options: Make a top-level file called `.rubocop.yml` and put yaml like the following in it: StringLiterals: Enabled: false VariableInterpolation: Enabled: false Documentation: Enabled: false See a list of available cops at https://github.com/bbatsov/rubocop/blob/master/config/enabled.yml 
I love Ruby is a nice beginners book. Kind of like a For Dummies book.
`String#scrub` will remove any invalid bytes from the string regardless of encoding format, and it doesn't require the 900-lb gorilla that is ActiveSupport (useful for us non-Rails programmers). And if you're getting invalid bytes from a file you're reading from disk, reading with `IO.binread` (instead of `IO.read`) will read the file contents as ASCII-8BIT, preventing the issue entirely.
IO.binread, well, preventing it until you try to DO something with the text, anyway, when it's likely to come back. But String#scrub is invaluable, for sure. If you need it in JRuby or MRI less than 2.1, I've got a pure-ruby 'polyfill' at [scrub_rb](https://github.com/jrochkind/scrub_rb) It rubs me the wrong way to do what tidy_bytes does and assume that 'bad' bytes must be ISO-8859-1 or CP1252, and I worry about what it will do for a byte sequence that might be legal in both UTF-8 and ISO-8859-1/CP1252 (or is that impossible?) -- but I recognize this sloppy approach might still be practical in some cases. 
&gt; Well, preventing it until you try to DO something with the text, anyway, when it's likely to come back. Depends on what you're trying to do. If you're expecting the string to actually be UTF-8, and operating on it based as such, then yeah, you might have a problem—but in that case, your problem is that you really do have invalid UTF-8 data, and you should address that problem. But if your data *isn't* really UTF-8, using `read` will cause Ruby to incorrectly interpret it as such (this is only true since 1.9, so it may be a source of confusion for anyone used to the behavior in 1.8). Most of the time, it doesn't really matter, since UTF-8 and ASCII are mostly compatible, but every now and then it'll cause a problem with something like `String#scan` failing because of an invalid UTF-8 byte sequence (also, if you read binary data as UTF-8 instead of ASCII, it will usually corrupt it, so be careful not to do that).
When I'm working on a big refactoring or otherwise wrecking havoc, I'll run my tests via autotest, and just fix whatever test winds up at the bottom of my output. Repeat until green. If I know there are a lot of failing related tests, I'll have them similarly named and I'll be able to use `-n /test_regexp/` to focus on them until they're green.
Why not do this: class DalekCreator attr :validator_class, :model_class, :presenter_class def initialize validator_class: DalekValidator, model_class: Dalek, presenter_class: DalekPresenter @validator_class = validator_class @model_class = model_class @presenter_class = presenter_class end def create params return unless validator_class.valid?(params) dalek = model_class.create(params) presenter_class.decorate(dalek) end end I find that it's less of an imposition on the reader of your code if you *don't* throw in some class annotations that write code for you.
I have some log parsing code and I use -E ascii-8bit. Seems to work well.
Text encodings are a complex beast all their own. This gives a bit of insight: http://kunststube.net/encoding/ 
Better to specify the encoding as part of your code rather than an interpreter switch. Use `IO.binread`to slurp in the file using ASCII-8BIT, or `File.open( filename, "r:ascii-8bit" )` if you want a file handle for some reason.
Does it really make sense to treat before_filters as "other objects being called" ? They are just syntactic sugar to reduce typing out a private method call.. and I would test it through it's public method? 
There are tradeoffs to each approach. In a microservices architecture you have to worry about all of the parts having an agreed upon communication scheme, when and if they need to communicate, as well as backups and failures of subservices. Whereas with this, like you said, they have the added complexity of some of their tools not scaling as well as Rails does, so they have to hack on parts to get things to continue working, or throw more servers at the problem.
Who is not using ruby 2.0? But other than that, I don't mind your approach, though I would just have `#create` reference the ivars directly if I was truly scared about public api.
great idea, maybe throw in some bootstrap? If you don't want to do it all by yourself you can always check out [bootsnipp.com](http://bootsnipp.com/)
Yes is FRENCH, but it's very important ?
Yes, because this subreddit is english.
Yeah, it's light on details on purpose. We've decided to share more thoughts on the topics of event-driven Ruby applications. Some of the blog posts will be directed to people without any knowledge about this architecture (like this post). Other posts (very soon) will be more heavy on details and more advanced concepts. It's great that you've used events in your app - care to share more details? How did it improve the app? Anything to be careful while implementing your own event store?
If it's idempotent though you shouldn't need transactions, insert new records as needed (multiple tries won't hurt anything either). Perhaps my thinking on that is flawed, but I've used that methodology before for very simple data sets and it worked great even when the client was offli,e for periods of time (mobile).
Yep. One more proof: http://i.imgur.com/DFWvWig.png
That has generally been my reviews of most of his posts. If it was just 'obvious' information, that might be okay -- what's obvious to you and me might not be to everyone, there's an audience for obvious tips. Worse though, is that they are generally confusing, occasionally wrong, and frequently make odd suggestions that I don't think will serve beginners well, especially since beginners seem to have an inclination to believe anything they read on a blog is a 'best practice', if the blog is written with the voice of authority. 
You should check out www.builtwith.com http://i.imgur.com/SLvSh1Z.png
&gt; just make it invalid if only one goes in How exactly would you do this?
You could always switch to a version manager like RBENV or RVM instead of relying on the system ruby. This will allow you to work on different projects that require a specific Ruby version.
This is the right way to go @krieder. Rbenv &gt; RVM
If you use rvm or rbenv, system ruby shouldn't ever cause a problem. it never has for me.
I'm downloading the game from Steam as we type! Can't wait to spend a couple hundred hours on this baby.
At work, we've slowly been implementing RabbitMQ as the center of our ES workflow. It works especially well with a microservices approach, since each service only has to watch a specific queue and act when an event has occurred that applies to it. As long as RMQ and our public APIs stay online, we can take down backend services any time and when they come back up, things pickup where they left off.
Use vagrant with virtual machines for your dev environments. Your life will be infinitely easier. 
I tend to use [Wappalyzer](https://wappalyzer.com/).
emacs &gt; rvm
The pattern he implemented is called [Template Method](http://en.wikipedia.org/wiki/Template_method_pattern). There are valid use cases for using it. Without context it's pretty hard to know whether he has one or not.
Yum!
Check the output of `gem env`. That should show you where your gems are located.
Come to the darkside, run Ubuntu into a VM.
If you don't like this template pattern, you could change the design to use the strategy pattern. class Foo def do_stuff(strategy) strategy.bar end end This would change `do_stuff` to explicitly require the strategy in the calling code.
Interesting. I'm not sure if this would really help the issue I had with the code (i.e. the semantics of the sub-classes weren't readily apparent). If you read the base-class, everything makes sense; `do_stuff` is pretty straight-forward. It's when you're looking at the sub-classes that things look disjoint. You have a few methods but no context for how they are used.
Awful website. Bad idea to promote the game here. At /r/cpp it would be the same *ontopic*.
They tell me to download their shit and do not even have complete HTTPS?
I think that's why it smells to me. Is there a more idiomatic way to accomplish this in ruby?
F# is also a great language. And like C# it's also supported by Xamarin.
I hope you realize that as worded, this is a stupidly complex question/problem in that it can range from "return associated images when you find a matching substring" to "implement Google image search".
I didn't realise. Worded badly. I should have left out mention of images entirely I suppose, unnecessary extra information. I'm not searching image data; the way it's set up now is that each database row has one numeric field, one text field, and one link to an image. If the search is a sub string match on the text field for a given row I select/return the image and number on that row. 
So what's wrong with it? How fast does one search need to be? 100 secs? 10 secs? 1 sec? 100ms? What's the text field like? parsed/clean? dirty/typo'd? Like a list of tag words? Like random internet comment? Who's using this? What kind of overall tool/application is this? All of this shit matters. If your constraints are loose enough, then what you have now is sufficient.
Have a look at search_cop as it doesn't rely on external services and doesn't break ORM. You do have other simple options like Ransack which is kind of a all-in-one and more full text engines like elastic search/search kick and sunspot/solr. I've used all of them and would suggest checking them out.
I think this is the Ruby answer to this problem. A Rubyist trying to decipher the uses of `#bar` should be cued in to look at the `Foo` module by the `include Foo` line. That having been said, if you have a shop that is a little more traditionalist in their notion of OO design patterns, I actually don't think there's anything wrong with what's written. It's about the shop having a common frame of reference is all. But yeah, one should expect any competent Rubyist to understand using the mixin technique.
I really, really like C# and with the way its moving right now is a great time to be a .NET developer.
Having spent a decent amount of time with both C# and Ruby, I agree with the author. A big thing I fundamentally love about Ruby is the amazing enumerators: being able to do things like `[1,2,3,50].select{ |x| x &gt; 10 }` instead of manually iterating through the array. You can do it in C#/VB.NET with LINQ but for whatever reason I never gelled with it. Probably because LINQ is sort of a bolted on thing and not "truly" part of those languages. Or maybe it was the lack (at the time) of a good REPL. One thing that helped, at least, was Resharper. If you manually iterate through a collection it will offer to convert that code to LINQ for you. That is helpful for learning purposes.
I'm interested in taking the Microsoft C# course on edx. Besides HTML/CSS, Ruby is the only language I know pretty well. I've had exposure to Java and Python. Is anyone else planning to take that course? How do you think the transition between languages will be?
Here you go https://github.com/remore/burn
As someone not well versed in Ruby, it looks ok to me... Just the template design pattern. But like others have said, maybe a module would be better. Although I'm not sure how to do that myself.
You want Thinking Sphinx http://pat.github.io/thinking-sphinx/
http://make8bitart.com
I think you are correct. I know you are trying to hide the major details of the classes... but using Foo, Baz and Fizz does not help. Lets consider a simple example: Let's have an Animal base class and implement two subclasses that would inherit from Animal; Dog and Cat. Now... lets implement a "speak" method for Dog and Cat. Dog would speak by printing out "bark" and Cat would "meow". We have our speak method implemented, inside of Animal, with a custom raise message to signal that stuff will go very bad if the inherited classes don't implement the "speak" method. Now if we just have objects that are Animals, or inherited from Animal, we can ask them to speak and we don't need to worry about it. The objects will "speak". But like other people have mentioned... this is just a programming pattern. It might look and feel weird but there are places where it's very practical. Some data structures look and feel weird but they have their place in the programming ecosystems! :) Sometimes these practical patterns don't always fit into the "ruby way". Try not to get overly wrapped up in the "ruby way" all the time. I would just write code, read code, and learn from code.
There are several ways you can approach this - If you are okay to use LIKE query and it is sufficiently fast enough for your needs, then by all means go for it. If you can switch to Postgres http://www.postgresql.org/, they have full text search available out of the box. I have used it and it is good enough for the most cases. Another thing you can do is to add a full blown full text search engine like Elastic Search https://www.elastic.co/. The problem here is that you would need to adjust your infrastructure to use it (maintaining another service on your sever). Third option is to write tokeniser yourself like Ryan did in Railscasts some while ago http://railscasts.com/episodes/399-autocomplete-search-terms I have to mention that Elastic has been one of the least painful to setup compared to other full text search engines. 
The only thing I'd caution is that you generally want to use Modules to model "behaviors", as opposed to just grouping methods that seem to go together. So you'd be including pre-defined behavior, instead of starting with a blank slate and going from there using inheritance ... which as most have mentioned is the Template pattern. So say the classes where Animal, Human and Lion. I could have a Module ActsLikeDog Module ActsLikeDog def bark puts "woof" end end but something that is more general like this Module Excitable def act_excited raise NotImplementedError end end while technically correct, isn't really idiomatic Ruby. 
Message queues are not a new thing, sidekiq is not the best, the fastest, the most efficient message queue either. Most message queues have native clients for almost all popular languages so pick one and go with it.
Not sure what you mean by 'global function' here. Where did you define my_method? Inside or outside MyModule?
I'm using RSpec for unit testing and it is wonderful. Capybara is needed to test web-pages (for example, Rails-generated). Cucumber, based on the GERKIN language can be useful when you need to create feature (end-up) tests, readable by business users. MiniTest is another option insead of RSpec, but I can say nothing here, 'cause never used it. Though, as far, as I see in public repos, RSpec becames de facto standard in Ruby community, so I'd prefer it to MiniTest. 
If you like the BDD syntax, go with RSpec otherwise go with MiniTest (although MiniTest can also be used with a spec-style syntax too). I've been a test engineer for years so I'll give you this caveat about browser based testing - it's very slow and extremely difficult to do in a robust way (false positives are common). Testing that your JSON responses are valid is much easier to do and you can use any http library for that (net/http, mechanize, etc.). In fact, I would use that approach to cover as much functionality as possible, outside of your code level tests (unit, integration, etc). To clarify a bit further, use the direct JSON/http approach (or unit test scaffolding) to generate scenarios you want to verify in the UI, DON'T try to build up everything in the UI with Selenium or Watir. Oh, also I recommend Watir over Selenium, both offer Ruby bindings but Watir has a nicer API - Watir is basically an alternative front end to WebDriver. I've never used Capybara but I hear good things about it too. EDIT: you may want to cross post this to r/QualityAssurance or r/SoftwareTesting as well.
You're missing some information in your question; check out http://www.mikeash.com/getting_answers on how to ask good questions and get good answers. Is @students an array? If so, why are you treating it like a Hash? Include the *actual* value of @students in your description.
&gt; I've tried to turn it into a while loop but i keep getting a type error for not converting symbol to integer! any help? Yes. You think you're doing my_hash[:name], but you're actually giving :name to a different type of object, not a hash. This object also has a #[] function. But this object's brackets function expects an integer, not a symbol. What type of object do you think it is?
It should be a string from inputted data from a different function. You input NAME, YOB, HOBBY and it splits it to the different string for each key Sorry if i'm unclear, I'm really new to this
Perhaps I was unclear. I know the answers to the above questions; I'm attempting the Socratic method with you so you'll learn to think through the problem the right way. Re-read my op and give your best guess.
Am i chucking it into an Array?
I'm a fan of Minitest and I recommend you start with that. Its what I've used to test web APIs. Its understandable and simple, yet surprisingly capable. If you need more, you can move to RSpec in a jiffy. Here're some resources that helped me get started. Msg me if you have any questions: ### Minitest (Ruby) - Minitest Introduction - [Minimalicious testing in Ruby 1.9 with MiniTest](http://blog.arvidandersson.se/2012/03/28/minimalicous-testing-in-ruby-1-9) - best guide of Minitest! - only covers specs (not tests) - [A MiniTest::Spec Tutorial: Elegant Spec-Style Testing That Comes With Ruby](http://www.rubyinside.com/a-minitestspec-tutorial-elegant-spec-style-testing-that-comes-with-ruby-5354.html) - Minitest vs. Unit (an older testing framework) - Minitest matchers/expectations - Using Rake to run all your specs - [Video of Minitest by its author](http://confreaks.com/videos/618-cascadiaruby2011-size-doesn-t-matter) - tests vs specs; idiomatic writing of specs - randomization of test order - [Minitest Cheat Sheet](http://danwin.com/2013/03/ruby-minitest-cheat-sheet/) ### Minitest &amp; Sinatra - [Sinatra Recipes - Minitest](http://recipes.sinatrarb.com/p/testing/minitest) - [Mini MiniTest Tutorial](http://www.millwoodonline.co.uk/blog/mini-minitest-tutorial) - [Why Sinatra's Halt is Awesome](http://myronmars.to/n/dev-blog/2012/01/why-sinatras-halt-is-awesome) - [Rack::Response::Helpers](http://www.rubydoc.info/github/rack/rack/Rack/Response/Helpers)
letter_opener? That's [built into Rails](http://guides.rubyonrails.org/4_1_release_notes.html#action-mailer-previews) since 4.1
No it's not, letter opener intercepts the mail when it gets sent and opens it in a new tab in your browser, you don't have to write anything extra, just tell letter opener to work in development.rb
WTF did I just read?
Outside. In another module. And added this module to Cucumber's World.
Yeah it's pretty cool. Definite must-have for C# work. It's not nearly as seamless as firing up a Rails console with "$ rails console" though - the benefit of that is that it automatically loads all the models and other junk related to your application. With a little work you can more or less do that with LinqPad, of course. But it's zero work in Rails, and also costs zero dollars.
My experience with devise is that it's good at getting the job done with basic authentication workflows. I've generally had a bad time with it if what I'm doing deviates much from a very basic workflow.
Boo devise. Boo simple_form. And frankly I've been trying to move away from delayed_job. Too many silent failures by default. Everything else is legit.
Devise is just terrible, and cancancan just becomes a giant mess. For authorization write plain Ruby policy classes or use pundit. I'm also not a fan of simple_form since it's not always as flexible as it needs to be.
I definitely wouldn't use devise for simple workflows either. I know enough to know that I'd be replacing it 2 weeks in to a project, so I wouldn't even start with it. I just don't wait to be the 'project x sucks' guy. It's not really constructive. The only reason it would be a good choice for a novice is that there's lots of people using it, lots of people making the same mistakes and lots of community to support you. I still wouldn't recommend it. I think it takes less effort to learn how to build this stuff yourself than it does to figure out which options to set in devise or which methods to override in your user class to get the desired effect.
I dig formtastic. I found out that u can write normal form_for statements in a semantic_form
I'm surprised to see delayed_job. We used to use it but moved to sidekiq - never looked back. 
&gt; Goodbye solution you probably picked to appear 'hip', hello solution that actually does what you want. FTFY (in most cases).
Hey I tried but it does not seem to work for me :( i1 is input 1 So, at the prompt if you put "abc" the variable i1 should equal "abc". Now when I do: print "Write down 'abc' " i1 = gets.chomp i1.split("") puts "#{i1}" It does not split it up :( I just get: abc 
Roll your own or something like Monban or clearance.
Ok let me try and see if it pushes each individual character to the array correctly! 
Ok well it split them up, now I just gotta figure out why it doesn't like the "each" method lol 
 a = i1.split("") p a split doesn't modify the original string.
Came here to post this edit: op removed `'hello'.chars #=&gt; ['h','e','l','l','o']`
Or str.split //
to post what? I don't see it anymore 
My experience - perhaps two years ago - was that it barely simplifies what you need simplified. And then you want to do something a little different from the default and you spend more time screwing around with simple_form than you save with it in the first place. I just don't find it to be a meaningful level of abstraction over normal form helpers. For similar reasons I loathe inherited_resources, but that's just me.
A Python generator is in the works: https://github.com/google/flatbuffers/pull/112 Given that this is the first dynamically typed language to be supported, someone wanting to contribute a Ruby generator may have an easier time starting from that.
 string.chars "Cat".chars #=&gt; ['C', 'a', 't'] 
Thanks. Turns out splitting the non-original string worked out great as well. Thanks!
"hello".chars.to_a is better than "hello".split("").
Performance. https://github.com/mperham/sidekiq/wiki/FAQ I've seen other articles that compare the performance of different ruby queing libraries, and sidekiq usually outperforms by a large margin.
Are you at Makers Academy by any chance? :)
Hey cool! Thanks!
Will implement asap!
Sorry, you were doing it right, we do have to put the while loop in print_students. Look up the ruby-doc page for it or google some stackoverflow awesomeness.
https://github.com/mperham/sidekiq/wiki/Monitoring or if you like, you could connect to redis from the rails app and do your own monitoring.
It depends on the ruby version, but yes.
 def humanise(number) pre_decimal,post_decimal = number.to_s.split('.') pre_decimal.reverse.split('').each_slice(3).map(&amp;:join).join(',').reverse + (post_decimal ? ".#{post_decimal}" : '') end Which says: 1. Take the portion before the decimal point as a string (`"1234567"`); 2. Reverse it (`"7654321"`); 3. Split it, to get an array of its constituent digits (`["7","6","5","4","3","2","1"]`); 4. Join each trio of numbers together (`["765","432","1"]`); 5. Turn that array into a string by joining the elements, separating them with a comma (`"765,432,1"`); 6. Reverse it again to put it in the correct order (`"1,234,567"`); 7. Return that string plus a post-decimal portion if it exists. For currency, to keep .10 as .10 and not .1 def humanise_currency(number) pre_decimal,post_decimal = number.to_s.split('.') pre_decimal.reverse.split('').each_slice(3).map(&amp;:join).join(',').reverse + (post_decimal ? ".#{post_decimal.ljust(2,'0')}" : '') end This simply says "The post-decimal portion should be 2 digits long, if it's less than that, add a zero to the end."
As someone who's at the same learning stage as OP, thanks for the advice and enlightenment, it's helped me go through my code and understand better what stuff is doing.
I think you have nearly identified the first problem, in the original implementation using each it is iterating through each student record, but in the new one with while it is not. Ask yourself what is already in your new method that is iterating up and how could you use it as an argument to students? What did your error message tell you? That it expected an integer(number) in place of where you put a symbol(:###). 
That is clever, thanks.
Sorcery https://github.com/NoamB/sorcery 
Thank you both for the suggestions, Justin that suites my needs fairly well. Appreciate the help!
look at the upto method, it would help you out greatly here. You could also use inject. (x..y).inject(:+) http://ruby-doc.org/core-2.2.1/Enumerable.html#method-i-inject
Many people consider it bad form to monkey patch native classes.
Usually it's more a case of "solution that you better know how to do what you want in."
From an optimization standpoint, if you just need to iterate over the string's characters or do something with them other than creating an array: "hello".each_char do |c| ... end You can also use each_char_with_index do |c, i| if you need to know where you are in the string.
LOL
We've still yet to address that while-loop though. I'd be remiss if I let you walk away from here without a picture-perfect solution.
No problem, bud. I wish I'd had more help when I started. Unfortunately, I was afraid to ask questions. Don't be like I was; if you meet an instructor at Makers Academy whose explanations you really enjoy, keep going back to them. If you can find the perfect middle between a) giving up too early and b) staying up till 4am, tearing your hair out, then you'll accelerate faster than you otherwise could. Finding that middle is a valuable, valuable skill. 
Is this available as a gem? The syntax seems unfamiliar.
I made something like this for analyzing audio clips to check for ping pong balls. I made this gem which outputs some spectrum info: https://github.com/jusroberts/spectrum-analyzer and you can check out how I was using it here (or look at the tests and readme): https://github.com/jusroberts/rails-sound-spy/blob/master/pingpong.rb You'll probably just want to play with the resultant Spectrum objects though. If you have any questions or need any help, let me know. I think that the examples in the readme will work though.
Wait, we're still taking Mongo seriously? I thought that horse was way dead.
No, that wouldn't make sense, because `String#split` returns an `Array`, not a `String`.
a [3,4,5] and im guessing b would return an error cos I can't see it working?
why would you change this to while? each with index is exactly what you want. if you just don't like the each with index, why not use a regular each and keep track of the index yourself? with the while loop, you will notice there is no bit with pipes ("|something |") that is each's way of giving you a reference to the components of the list. so instead, you now attempt to access the whole list as if it turned into an individual object by magic. you need to exercise more patience when programming, and take your time to figure out what the steps do. if you reference the variable x, where does it come from? what type is it? what methods does it have? if you don't keep track of that, nothing you write will ever work. its a very common mistake for new programmers to narrow down their focus when they don't understand the code. to try to only look at the part they think they understand. that leads to things like this, when your usage of a variable is guesswork. don't do this. you will set your own learning back. instead take the time to Google code to compare with, and to look up the method definitions to see what they return. testing things out in irb is a great way to gain understanding. and as a general rule, in most programming languages... never use while. not unless there is no other way out. 
Indeed. "Usually" implies "not necessarily."
http://i.imgur.com/u7H0hch.gif One last thing: I'm guessing the problem asked you explicitly to use a while-loop, but a Rubyist just wouldn't use it there. When it comes to enumerating, #each and #map are your go-to methods. Will there be times when you want to do i=0, i+=1, while (condition) ? Yes, but only in the sense that there are exceptions to every rule. Pro-tip: Array, Hash, Set, and plenty of others are all what we call enumerables. If you want to make your own enumerable class and get sweet, useful methods like #map and #reduce and 20 others for free, all you have to do is mix in the Enumerable module and define the #each method. Keep Enumerable in mind, because even if you don't roll your own, when you want to look up Array's method documentation, half of it will be in here: http://ruby-doc.org/core/Enumerable.html
Thank you so much! We are currently doing a PoC on Passenger 5. This update was very much anticipated. 
&gt; I think it takes less effort to learn how to build this stuff yourself than it does to figure out which options to set in devise or which methods to override in your user class to get the desired effect. I couldn't agree more. As engineers, we must be intimately familiar with implemented systems to ensure proper security practices are upheld. In my experience, a fairly robust password authentication scheme can be written in 150-ish lines of code. OAuth auth schemes are even simpler. Devise is much more complex than an authentication layer demands and requires similar amounts of code to implement after config/overrides/etc.
I've never understood why people prefer a gem which shorthands "form_for" usage. The memory overhead and maintenance isn't worth the effort.
There are a couple projects already. One by the Square team. https://www.ruby-toolbox.com/projects/ETL There used to be a "ruby-etl" project but it was really out of date and apparently the RubyGem has been yanked. A quick GitHub search shows several projects. https://github.com/search?utf8=%E2%9C%93&amp;q=ruby-etl I'm not dismissing your question or idea. But just pointing out that there are people who've put in some effort on the topic who would probably love your help and insight to build a better tool for the community. :)
I am one of the main contributors on a project that I only recently realized is a sort of "ETL" -- I hadn't known the phrase "ETL" before. Our project was focused on a specific use case in our industry (libraries, the kind with books) -- taking records in a legacy library format used for bibliographic information, transforming them with rules into a hash of key/values, and then sending that as a document to index to Solr. But from the start we realized it potentially had more general-purpose uses, and tried to architect it for eventual generalization -- although maybe not to the full range of "ETL" use cases, since I'm not still not certain what those are! But as a rubyist who knows ETL, I'd be interested if you had anything to say about our project: https://github.com/traject/traject
I spell ETL with S, Q, and L. I can relate to your comment that simple Ruby is just easier that the big ETL tools. The most complicated situations I've run into benefited from a kind of workflow to start/track/restart jobs. But even then, I've never seen an ETL or BPL tool that lowered the complexity of the process. Are there specific problems you've run into that a library would solve?
It's a little bit rough around the edges, but I've been using https://github.com/activewarehouse/activewarehouse-etl 
I would much rather use that than Sterling Integrator, the tool we tried before that, or any of the other options our business has forced upon us.
It's not always SQL. Last several projects (and some that I'm currently working on) may involve writing into a SQL db but that's not where most of the data was coming from. DataSift feeds, CSV files, Analytics API's, JSON docs, etc. Last really big transform was from MongoDB docs into Postgres, and that was awful. But SQL was incidental and wouldn't have been the best place to do the transforms anyway.
Check out https://github.com/sparklemotion/mechanize
Volt Framework Ruby on the client/server side. http://voltframework.com/ 
Agreed - ETL can mean many different types of sources and destinations, some completely without SQL support. For instance, old-fashion CRM's with a proprietary database, COBOL targets (flat delimited files) etc.
I wrote ETL integration mappings for fixed format data in .NET using BizTalk just 8 years or so ago so it's not that old. The system we were integrating with was awful but... no. no "buts" for them. The system was awful.
If you don't need Javascript support, I've personally found it best to simply use Nokogiri with the http library of your choice (I like HTTPClient), writing the ruby code you need to do what you do to interact with the page. It's not hard, and I found it easier than fighting with some tool designed to do this 'for you', but which I sometimes had to fight with, and just didn't seem to be adding much value over just writing ruby using Nokogiri. If I did need Javascript I'd try Capybara, yeah. While it's intended for use in an embedded website for testing, googling you can find instructions for using it against an external website. Otherwise, yeah, there's Mechanize (I don't know if it does JS or not). 
I've worked on a ruby data warehouse project for the past several years, and used Ruby for both the schema definition / querying side of things and the ETL side. Some of this is open source: https://github.com/notonthehighstreet/chicago and https://github.com/notonthehighstreet/chicago-etl although this is OSS in the sense of License rather than having been used by lots of people. The ETL stuff especially is very rough around the edges, and has stuff missing (code that is waiting to be extracted from our inhouse tool). When I started this, there wasn't much else around in the ruby world to do this (aside from activewarehouse, which wasn't clear whether it was still under development), there may be more projects now. Architecturally, the vision is to define a model of your end facts/dimensions and then get a lot for "free" based on introspecting the model. This worked out very well for the querying / front end side of a data warehouse (all the interfaces for our DW are generated automatically) but had more mixed results for the ETL process. I'm definitely glad that I used ruby over a tool like Pentaho or some other commercial ETL tool, however if I had my time over I would probably look at implementing/using something in python instead: there is a lot more interest/activity in these sort of problems in the python world, and the languages share roughly the same advantages. Building a good ETL tool is an awful lot of effort, I'd definitely consider trying to leverage the work of others rather than building from scratch.
I was being facetious. Everything you list is exactly why ETL tools generally aren't useful. There are so many different sources and destinations that no tool will possibly cover a significant portion of them. Usually they make themselves complex trying to cover more cases than they should.
Capybara-webkit possibly? 
I love it. Its pretty straightforward. Yes, its frustrating, but its easy.
Such as?
Fantastic article. I'd up-vote 100 times if I could.
I'm getting very tired of articles stating "Gems for every project", when they in fact mean "Gems for a few rails projects". ***Rails is not Ruby***. Ruby is Ruby, Rails is a framework on top of Ruby. There are people who use Ruby for things other than Rails. I've used Ruby for years and I've only touched Rails twice in that time, and not for long. Please stop writing articles aimed at Rails and then titling it like it is for the whole Ruby community. 
I think I must have missed something, but I think the following line is wrong: https://github.com/rubygems/rubygems/pull/1188/files#diff-05477d38d75c98664b0e7dec6eb73b45R2524 I think that `traverse` should be `_traverse`. Does someone want to tell me if I'm wrong? I can't see a version of `traverse` with three parameters.
I was expecting you'd say Node.
I have used Talend and I was impressed by it. It has become a big product. Java is performant. Talend is a code generator so you can just take the jar or class files.
Devise is great if you've got a super simple authentication/registration flow. However the minute you want to introduce any kind of complexity it becomes increasingly difficult to modify. I much prefer just to use Warden, with RailsWarden if it's a Rails project. Just set up some custom strategies, for oauth/tokens/email+password.
I didn't see the two vs one parameter :( I took his last sentend (3 params) and ran with it.
This works, but is it safe ? Thread.new do while true do sleep 10 London_data = London.fetchdata end end
I don't have a problem with it. I found it easy enough to modify. However if you have authentication without email (pretty rare) I would recommend using something else.
I think you have the right ideas, you might want to read up on linked lists, you don't neccearily need a ruby-specific treatment of them to learn how they work. (A linked list is a fairly unusual thing to use in ruby, but certainly still worth knowing about and understanding to increase your understanding of programming). 
Pssht, get out of here. Rust/Dart/Elixir or bust!
net/http is all you need. Some frameworks (like gorilla) complement it
&gt; but is it safe ? Sort of. * If there's an exception, the thread will die and you won't know about it. * If you are running on MRI, then the the thread is competing with the web app for CPU time, since MRI doesn't support multi-core parallelism * You are just assigning the data to a constant/global, in a thread, and then the main thread reads it from there? That's not thread-safe, you need to protect shared data with mutual exclusion locks -- although using MRI, it _might_ work anyway even though you aren't doing it 'right' * In general, it's tricky to get multi-threaded programming right, and there's a common belief that it's better to use higher-level concurrency abstractions built on threads, instead of using the low-level threads directly. There are some higher-level concurrency abstractions for ruby [here](https://github.com/ruby-concurrency/concurrent-ruby) Me, I would not do this in the _web app_ at all, there's no reason for it. I'd have a separate process running, which fetched what you need and stored it in the db, and the web app gets the data from the db. In the simplest case, this could even just be a rake task executed by a cron job ever 10 minutes, although you can run up against some barriers and need something more complex. More complex can expand to not storing the data in a db at all, but in some other store intended for more 'real time' access, like redis. For a separate process, you may not need multi-threaded concurrency at all. If I did really want to do it in the web app process, using multi-threaded concurrency -- to keep your setup simpler, and because the volume of data/use is pretty small and you can get away with doing it a bit sloppy... I'd still want to use concurrent-ruby or similar, not use Threads directly. And I'd probably want to run on JRuby. If you insist on not only running no external processes, but also not using any additional gems -- you have significantly limited your options, to options that most experienced people would not consider suitable. But might work for you anyway. 
&gt; Do people actually find this blog useful? He's missing the fact that you do not even need groups to do this replacement. You can use the ampersand for the complete match: irb(main):007:0&gt; s = 'A sentence referring to a #method and what it does.' =&gt; "A sentence referring to a #method and what it does." irb(main):008:0&gt; s.gsub(/#\w+/, '"\\&amp;"') =&gt; "A sentence referring to a \"#method\" and what it does." If you want to get fancy and avoid hash in the middle of a word you can add some negative lookbehind: irb(main):009:0&gt; s.gsub(/(?&lt;!\w)#\w+/, '"\\&amp;"') =&gt; "A sentence referring to a \"#method\" and what it does." Example: irb(main):012:0&gt; "a#bc def #ghi".gsub(/(?&lt;!\w)#\w+/, '"\\&amp;"') =&gt; "a#bc def \"#ghi\"" 
Thanks, I've never made a crosspost before so I was unsure of what etiquette to follow. In the future I'll link the sub.
Where do you currently reside?
Kinda bored of the local surroundings and saving to move. Thanks for the linkedin tip! I'll definitely try that out. 
Okay but what benefits does this offer over Ruby/Rails other than you get to feel like a cool dude for programming in Go (which, admittedly, was a pretty big draw for Ruby back in 2004)
Static typing, static binaries (rvm and gems are a bitch), great concurrency support (goroutines, channels), better performance, integrate with C code easily, great toolchain (gofmt, etc), awesome standard library
The original code was better IMO, the `Bob` class is unnecessary though and ` &amp;&amp; statement.downcase != statement` is redundant... He ended up with this: `Bob.new.reply_to Yelling.new('HELLO')` Where each of the classes (`Question`, `Yelling` etc) validate the input. Fine. Now why does that warrant metaprogramming? He's basically made his own method_missing, lots of unnecessary classes and methods (NullStatement, StatementFactory, Statements)... multiple files would be even worse! Can it not be this simple? REPLIES = { silence: 'Fine. Be that way!', yelling: 'Woah, chill out!', question: 'Sure.', unknown: 'Whatever.' } def reply message return REPLIES[:silence] if message.strip.empty? return REPLIES[:yelling] if message.upcase == message return REPLIES[:question] if message.end_with? '?' REPLIES[:unknown] end puts reply 'HELLO' Now the reply data is separated instead of being contained in methods. The logic for the replies could be put into private methods, but for something this simple it's not needed.
:)
Thanks for the reply. I've been reading as much as I can understand but a few of the concepts haven't clicked yet. Ruby is my first language and this is my first introduction to "nodes" if you will.
I'll have to look more into what a stack and heap are. Thanks for this insight.
Interesting. I've never thought about methods being used to store data and by chaining them together you can move through that data. Need to grokk this.
The example does include weighted sampling in a subtle/elegant way. The more frequent a chain the more times that state is included in the array of possibilities, hence the more likely it is to be returned from the call to sample. 
Most of the time I'd agree with you, but I'd argue that the article title is fine in this case. It's on "rubyonrails365.com", so any article is likely to be focused on Rails, and therefore not need to say so. It's like complaining that a macrumors article is titled "slimmer laptops announced" and not specifying that they're from Apple. The trouble lies with it being in /r/ruby instead of /r/rails, and the (lack of) prominence of the domain name on the page here. That's not the website/author's fault, unless they were the one who submitted it here. The best solution would be to tag this as [Rails] because the article's title doesn't make that clear.
"Reasons why" is a redundancy.
After working for over decade in software localization... I really despise YAGNI.
this question is slightly confusing, Can you give more context to the problem you're trying to solve?
I thought the singleton pattern is an abstraction used to work around curtain language constraints (java, c#). Why does this even exist in ruby? Why not just use a module instead? **edit** Googled around, found [a good article](https://practicingruby.com/articles/ruby-and-the-singleton-pattern-dont-get-along) posing the same question and considers the pro/cons of many alternative methodologies. 
Maybe, but I'm really interested in working with a team I can learn from. Is there anywhere you can suggest for remote work, or just places like Odesk and Elance?
I know it is confusing, because I provided abstracted code. I need to inherit or share variables of specific instance with another classes. Not sure how to explain...
How would I do that with module? Thanks.
Use a delegation pattern. Read more here: http://radar.oreilly.com/2014/02/delegation-patterns-in-ruby.html
 module Planet class &lt;&lt; self attr_accessor :name, :country end @name = "Earth" @country = Country.new end This [article about ruby and the singleton pattern](https://practicingruby.com/articles/ruby-and-the-singleton-pattern-dont-get-along) goes into detail about the pro/cons of the different ways you can do "singletons" in ruby: * use the `Singleton` module * class of only class methods * module of only module methods * module with `module_function` * module with `extend_self` * using bare instance of `Object` * avoid the pattern altogether I think the last one is an interesting point. From the article: &gt;But in the end, we must not forget that the singleton pattern is essentially just a fancy way of managing global state. &gt;The question of whether to implement the singleton pattern really depends on the context, but it's safe to say that it's a bad default. &gt;However, this is a genuinely hard problem in object-oriented programming, which may explain why we've seen so many different attempts in Ruby without a real consensus on which way is best. &gt;We've also been unable to eliminate the pattern entirely, which is a sign that we can't simply write it off as one of those bad Java imports that real Rubyists freely ignore.
Aaron discovered that the rubygems has a "traverse" method that is duplicating an array when the method walks a trail of items. In that code, duplicating an array causes milliions of allocations. Aaron's pull request improves the code by using a more efficient "traverse" implementation, by changing from using arrays to using linked lists.
I've tried to use module, but I have multiple variables which are generated by methods. And each time I call variable, method has been called again...
That is very true, but I didn't notice the url until I visited the site. I know it's only like 5 seconds of my life but this happens several times a week and I'm getting very tired of people treating rails like it's the only reason to use ruby. I do usually treat the article like it was posted by the author instead of another person, so that it's another reason for my anger. 
I'm having trouble understanding you. "variables that are generated by methods" - returned by methods? "each time I call variable" - access the variable? "method has been called again" - no idea
1 Reason against it: Ever tried to deploy the bloody thing?
I don't see why deployment could be an issue. Source: I deploy Rails application for a living since 2006...
Try deploying HVVM on Redhat 6 and let me know how easy it goes.
oh thank you!
Yep! Heroku is the easy way out, but after some time fiddling with Capistrano you can do that as well.
I've used Prawn, wkhtmltopdf and iText. I started with Prawn, ran into problems and tried wkhtmltopdf but page breaks were problematic and settled on iText. iText allowed the most control and was more fully featured than Prawn. I would have preferred to do the layout in HTML and CSS though so still curious about wkhtmltopdf. Plus potential iText licensing issues.
I think that they both have their use cases... yesterday I was creating a little script to generate labels with barcodes and it was quite easy to do in Prawn, because it gave me exact placement control over everything. But, you're right... Prawn generally takes longer (sometimes much longer!) and wouldn't be easy for front-end folks to pick up.
It isn't sufficient. There might be hundreds of reasons, but _these_ are the seven reasons why [..].
You can look into using [EventMachine](https://github.com/eventmachine/eventmachine) with Sinatra there's even a [gem](https://github.com/raggi/async_sinatra) add-on for it.
Your comment adds nothing to the subreddit or the discussion.
Yup, and then you start adding gems that have system dependencies, you deal with other running dependencies (like sidekiq, redis and whatever seems to come up), putting passenger in front of it. And that's only the first deployment, once you have a long running application you need to keep track of versions, security issues, can't update gems because they change APIs willy-nilly. I mean, it's gotten easier with docker and being able to properly bundle it, but deployment does not end with`cap deploy`, it starts with that. I've got enough experience with it and that I'm happy I don't have to do it anymore. I love ruby as a language, I still use it day to day, but I'm glad I don't have to support rails anymore. Their way of doing things simply does not overlap with mine.
You can also eliminate conditionals by using flow control logic. class Bob def reply_to statement catch :response do match_question statement match_yell statement match_not_saying_anything statement "Whatever." end end def match_question statement return unless statement.end_with? "?" throw :response, "Sure." end def match_yell return unless statement.upcase == statement and not statement.downcase == statement throw :response, "Whoa, chill out!" end def match_not_saying_anything statement return unless statement.strip.empty? throw :response, "Fine. Be that way!" end end You could obviously extract an object to do this, where `statement` would be your only argument passed to the constructor.
OP, just in case you are or know the author: the cover of that book is a major distraction and sends a poor message about Ruby devs. Change it and it will get a lot more traction. I would even recommend it to a dozen or more people myself. 
Don't even get me started with Go. It is a huge step back in language design. Procedural coding with a terrible exception system. The concurrency model.... Meh.
I'm glad to hear it! Thanks so much for the PRs. I'll look over them today and tomorrow and hopefully get them merged in. Obviously since this is a in-progress beta-book there isn't any editing happening yet, but that's in the pipeline. However, contributions like this really make doing the work worth it! So a big thanks for that! I'll PM you about your other request.
You got it, man. I want this book to be awesome, because you're doing the hard work of making it happen, so the least I can do is help out... And maybe even offer suggestions on how to organize the code :)
Yes, you can do it like that, but from a large scale application point of view, you are mixing purposes. Every method detects the type of the statement and then maps it. I get it's an example, but you are just moving the long term issue somewhere else and split it into many methods so it gets harder to trace. That aside, I like the idea of using flow control for some problems similar to that.
Thanks for the kind words. The plain old ruby code gets auto-generated using an erb template, thus, if you change the erb template you can auto-generate a json or yml version, for example. FYI: The world.db itself uses plain text datasets (easier to update than yml and json). Cheers.
Using Struct / OpenStruct for simple 'data classes' is very common as is chaining enumerables, nothing weird at all. The only thing uncommon here is the static type annotations but that is as much a matter of taste as anything. 
Matching statements to replies is *one* concern. As I mentioned, it is trivial to extract that concern to a separate object. Now, if we are asked to start mapping statements to more than just responses, that's where you start needing to add to the design.
Why not? It's still an interesting story. It also provides some context on why the newer versions of ruby are faster than older ones.
Dat nasty 
Is there a preference in the community between `compact` and `reject(&amp;:nil?)`? I mean, `reject` is on `Enumerable` whereas `compact` is only on `Array`, but is that the only general consideration?
`Array#compact` is always preferred, but [lazy enumerators](http://ruby-doc.org/core-2.2.0/Enumerator/Lazy.html) have no `compact` method so he used `reject` instead.
That's not exactly how `Symbol#to_proc` works. In your example, the generated proc is equivalent to: Proc.new { |file_handle| file_handle.s_names } The file handle doesn't have a method called `s_names`, so that's why it doesn't work.
Search in /r/ruby for "blocks". There are lots of links about it.
I've only started using lambdas recently, and have gotten into the habit of making one whenever noticing too much repetitive code within a method, at least when the repetitive parts are unique to that method and not likely to be "reuseful" for other methods. What I like best about them is that they let me think differently about argument lists. When writing a separate helper method, normally I would have to pass all of the relevant information to it, except for instance variables. But a lambda already has access to everything in its caller's scope, so the argument list can often be shorter -- containing only the bits that are going to change for the different calls.
I have also never understood the "success":true in APIs.
I think it's a nice way to ensure that not only does the server think everything is dandy (by way of a 200), but that you are correctly parsing the response as well. Just a basic sanity check.
&gt; It generally can do exactly the same thing as a method, although it's not tied to a particular object instance like a method is. I'm not sure what you mean by this. When you run a Proc, it runs in the context of the object that created it, not the object that called it: class Foo attr_reader :bar def gen_proc Proc.new{ @bar = 10 } end def run_proc val val.call end end foo_1 = Foo.new my_proc = foo_1.gen_proc foo_2 = Foo.new foo_2.run_proc my_proc p foo_1.bar # prints 10 p foo_2.bar # prints nil So even though foo_2 is running the proc, it runs in the context of foo_1. So in what sense is the Proc not tied to a particular object instance?
You know, I was just trying to find this article today because I was thinking about it again after reading it on HN a couple weeks ago. Thanks! The talk at the end is also really cool, too!
i'm no expert, but big thing is scope. as keymone mentioned, closure caputures local variables, which methods do not. here's an example: # local variable a = "yo quiero taco bell" def method_print_a # do not have access to local variable within method print a end lambda_print_a = lambda { print a } lambda_print_a.call # &gt;&gt; yo quiero taco bell # method_print_a # ~&gt; NameError # ~&gt; undefined local variable or method `a' for main:Object 
In Ruby it won't immediately make sense to you. Spend a bit of time around Javascript with callbacks and it make a lot more sense. Better yet, run through Haskell a bit and get a feel for a style that thrives on first class functions. If you started in an Algol based language (C, Java, etc) this will be a difficult concept. By trying a functional language you open yourself to a whole new thought paradigm. 
it's nice sometimes to have one success marker for the http call, and another for your api action. Also, sometimes the success check might happen down the line, so having a marker in the hash can be nice. 
Yeah, the reason that jumped out at me as possibly misleading is because the way you described a Proc as being used to pass logic around would seem to imply that the logic was completely integrated into the object calling the Proc rather than the one generating it. That might well be the expected behavior, but there are good reasons why they work the way they do (for one thing, consider if a block called via `yield` operated in the context of the object calling it—it would basically render it worthless). That said, you can get a Proc to run in the context of the caller by using some trickery involving `instance_eval`, so there you go. Of course, in Ruby, you can get pretty much anything to do anything if you're clever enough, which is one reason why it's such an awesome language. :)
I'm not sure I understand why you'd want to do that. Including and extending are so fundamentally different that I don't see when you'd ever want to run the exact same code on both events. Certainly not to the point where it's worth including a gem to avoid repeating yourself in an instance where you probably shouldn't be repeating yourself anyway. At any rate, the issue has never come up for me, so I may well be mistaken. In that case, I'd be interested to see an example where it makes sense to run the same code for `include` and `extend`.
Wow... This blog is a *really* long winded way of saying "TIL about *String#gsub*"! It's also missing several opportunities to provide good coding advice, such as: * Why do you keep using \S in the regex? Whilst this might solve your problems here, it'll probably lead to some very annoying bugs in the long run! Make your regexes only match what you *need* them to - e.g. using \w is probably a much safer idea! * Vague statements about how "it didn’t work on complex results such as HTML/XML tag substitution" -- when clearly this is just a bug in your code that you don't understand, not a problem in the ruby library. And in general, the advice should be to [never use regex for HTML](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454) anyway! * There are also some really nice features of ruby regex that were completely missed by the blog post. For instance: consonants = (('b'..'z').to_a - ['e','i','o','u']).join #=&gt; "bcdfghjklmnpqrstvwxyz" /([#{consonants}])..../ # The method used in the blog post /([[a-z]&amp;&amp;[\^aeiou]]).../ # Nice!
I did see this but I'm not sure if it is compliant with the v9 API. I'll give a shot though. Thank you!
Way too outdated -- can anyone help me figure out this auth issue?
Haha No. I was outraged and that's why posted here to see what people think.
"In terms of functionality, storing just frequencies require a finalization step that freezes your model and means you can't update it any more with new data." That's not exactly true. Yes you have to normalize but this is not irreversible. But I agree with your previous point. Actually that is a good implementation, even though I don't like the divergence from the HMM formalization. With this, you can only generate sequences (and that is all what you want to do so that's ok).
Check out Pry. A REPL console replacement for IRB. Throughout your code you can place: binding.pry This will act like a breakpoint and open a console when it is executed. It also has many other interesting features too. https://github.com/pry/pry 
Just adding in for a tip, at any point in your code you can do \_\_binding\_\_.pry and it allows you to spawn an interactive console that uses the current state of the function. So its effectively an in code breakpoint
Also take a look at [byebug](https://github.com/deivid-rodriguez/pry-byebug).
Imho, I don't think that including and extending are fundamentally different. While the one adds functionality to an instance, the other one adds it to all instances it creates. What they have in common is that (in the end) they both affect instances. You are right that this might not always be the case. But there are also a lot of cases, where you just want to run some code on the instance that *actuallyy receives the functionality you are adding*: The object itself (extending) and all class instances (including). A use case I could think of if adding an instance variable to the receiving instances, which is used by the module methods (instead of relying on lazy initialization). I hope it gets clearer what my motivation was.
You can include ActiveSupport into projects that do not use Rails.
If you're used to a fully blown IDE like Visual Studio then you might want to give RubyMine a try (https://www.jetbrains.com/ruby/). I just use a text editor, but I'm pretty sure RubyMine lets you set breakpoints and step through your code (like pry-debugger / pry-byebug)
&gt; AMQP What are the advantages on AMQP in your opinion? Which implementation would you use? Would you host it by yourself?
That's a fair point. A partial rebuttal is that while you'd have to add ActiveSupport to a gemspec or Gemfile, internal to the project you can require only the portions of ActiveSupport you need. You don't have to load all of it. http://guides.rubyonrails.org/active_support_core_extensions.html &gt; How to cherry-pick just the extensions you want.
Thanks. Good points. It's all just getting started. Thanks for the ideas and suggestions. Cheers.
I'm stuck on the 0.x branch of Prawn because [transactions (and therefore groups) are broken in 1.x](https://github.com/prawnpdf/prawn/issues/678) and I need to manage what goes on each page very granularly. I keep meaning to look into wkhtmltopdf and the like, but I haven't found the time.
Well, you can always require only a part of activesupport, in this particular case only active_support/core_ext/module/delegation.rb 
You are absolutely right! Why would you cook at home, when you can go to the restaurant every day? It's nor good nor bad, somebody can afford it, somebody eats at home. It's all about choices and possibilities. But one thing which is not considered in this article, is that SQS can get expensive pretty fast. Really fast. One thing to mention: when you really need to modify something in the OSS product, you have few possibilities: do it yourself, pay someone to do it, look around for a patch, or plugin, or module, try hiring a developer\company beyond the product. When you are working with proprietary solution, especially one of Amazon, you can literally do nothing about it.
I see your point and I agree for certain cases, thanks for bringing that up. I would say there's no silver bullet solution. It's hard to judge the best solution for short/mid/long term. &gt; Using SQS from outside of EC2? Putting 1M entries to the queue will take forever. True! &gt; Multi-region clustering? Nope. We do that via SNS. &gt; Plugins? Nope. Shoryuken supports middleware. &gt; Anyways, you did a great job as a developer Thanks and thanks to Mike Perham and the Sidekiq contributors, Shoryuken wouldn't exist as it is without those contributions!
&gt; is that SQS can get expensive pretty fast. Really fast Expense is "relative" - 1 million requests cost $0.50 and these requests can be make via batches up to 10 messages. I don't think that most of the apps will send more than a million requests per day, high volume apps aren't the the majority. I work in a high volume app (which is also relative hehe) and we are happy with SQS. &gt; do it yourself, pay someone to do it Although SQS is closed source, you can do a lot of stuff in the client (Shoryuken) layer. For example: Shoryuken supports exponential backoff, which is not supported via SQS. I understand your use case, but I still believe that for most cases, Shoryuken/SQS can be the best fit solution. People can focus on the workers logic instead of the infrastructure &amp; maintenance. 
+1. The lead dev on byebug helped me sort out some Tracepoint issues once; really helpful guy and of course byebug is very nice.
You write that one adds functionality to an instance while the other adds to all instances. Extending a class adds nothing to an instance of that class and the extended functionality has no access to any instance scope. However including will always affect all future instances created. An instance has a method instance_class I believe it was, that will allow you to extend more or less a local copy of the class affecting only this particular instance. This is what you are doing when you call extend on an instance. Most rubyists talk about extending classes not instances. Maybe there we got some confusion cleared up :) As for usefulness... I cannot think of one sadly. But the code offered some inspiration and ideas, which I find more important lately.
[This](http://www.brpreiss.com/books/opus8/html/book.html) is the only resource I've found using Ruby
Check out [CodeWars](http://www.codewars.com/) and [Exercism](http://exercism.io/)
It really depends on your use case and whether you need symmetric or asymmetric encryption.
The classic crypt() function is well dead and shouldn't be used - any library associated with it exists for legacy purposes. bcrypt and scrypt are both for storing passwords, so when you say "cryptographic packages", if you're interested in encryption, these are non-starters. I'm not familiar with Kcrypt, but it doesn't seem heavily developed recently. OpenSSL is generally the most ubiquitous, but it requires to make a lot of decisions yourself (ie, great for cryptographers, pitfalls for other people). You may want to consider libsodium and its associated Ruby bindings, which along with OpenSSL can be called "well vetted", but resolve the above issue.
VM's are awesomeee
In ruby 2.0+ this is mostly built it: http://ruby-doc.org/stdlib-2.0/libdoc/forwardable/rdoc/Forwardable.html
Is this simply an alternative to bundler or gem sets? What's the use case? I'm skeptical because the Python packaging and environment options are awful. Beyond belief bad. Haven't seen anything there worth carrying over elsewhere as a design pattern. Rather, taking from the ruby ecosystem and applying to Python is much more interesting. 
Yes, for a single search, a binary tree will perform slower than a linear scan. After a certain number of searches, a binary tree will outperform a linear scan, but one is not that number. When you look at the [Big O Complexity](http://bigocheatsheet.com) for a single search over data you see: * Linear scan array: O(n) ~= O(n) * Binary Tree: (Best case): O(n * log n) + O (log n) ~= O ( n log n ) * Binary Tree: (Worst case): O(n * n) + O (n) ~= O ( n^2 ) Looking at the complexity figures, we can assume that after n searches, the binary tree would approximately match the array even in the worst case, while in the best case it would happen after log n searches. Edit: The running times relate to my idea of your implementations based on the description you provided, though there may be a different way to write the code such that the binary tree performs better. It may be that in a binary tree vs array comparison where each got a single item at a time, the binary tree would perform better. I may write up something in the morning to test this assumption.
Not too surprising. You're doing this in Ruby, and the search is implemented in C. The dereferences are expensive, the interpretation is expensive (vs C level iteration, which will be dramatically quicker. Anyway, you're in luck, because there is a `bsearch` method in core now.http://www.rubydoc.info/stdlib/core/Array:bsearch
What exactly is the problem with rvm, rbenv and chruby?
Hi ! First of all, good job with your learning. Two questions: * with the bases you have, why are you aiming specifically for "non paid internship" - did you try to apply to some junior dev position or paid internship before? * why remote? I know working remotely is possible, but I think you would learn a lot more by sitting in the same office of some other developers. Any reason to mandate remote mentoring? (I've being doing some remote mentoring, and it is difficult)
The issue you'll have unless you do stuff of your own or help on open-source work, is that your github will remain empty because you'll be working on private projects. I've been employed in a RoR based job for 3+ years and my github is still essentially blank except for maybe a few forked projects with small changes. Understandably you'd still have the experience, but you mention having something on github, that's still going to be pretty much barren.
I see... So you recommend going on the job hunt right away or doing projects open source work prior hand ?
I'm not too familiar with nitrous.io. In fact, it's the first time I heard about it. From what I read, it's basically a "configuration" in the cloud. A way for teams to all run in the same environment. Something like Vagrant, it's a solution to the "works on my machine" problem. Everyone has the same environment, whether your OS is windows, OSX or Linux. Heroku is a totally different beast. It's a platform as a service. It hosts and runs your code for you *and* handles all the updates, security patches. It also makes it dead easy to scale your app. It solves the problem of owning a web server, maintaining it, upgrading it, etc. etc. And makes it as easy as a `git push` to deploy your code in production. **TL;DR** * Heroku: hosting in the cloud + easy deploy. Solves scaling and deployment. * Nitrous.io: Development environment in the cloud. Solves the "works on my machine" problem. 
Have you considered volunteer work? http://socialcoder.org/Home/FAQ
didn't know I could do this, thanks!
Think of an app you want to make and make it! It can be a clone of something or something original. Make it open source and show off what you can do.
So the problem you're really trying to solve is your troubleshooting ability.
Yup I did, and I updated it. Once it was updated, my system uses that as the default version since I set it to, but I still get this same error. PS - I am new to Ruby, so this is a learn as you go thing
Well I am using rbenv, and I set the local version to 2.1.2. But when I do rails s, it still gives me the same error. All my gems are up to date as well. Edit: can you tel me what you mean by gemfile? like where can I find it? I'm very new to Ruby
theodinproject.com offers to build a twitter clone, I'll check it out
My time is worth more to me than spending hours learning enough about a language to troubleshoot environment problems that a simpler tool would have never allowed in the first place. Think about it from the perspective of a front-end developer, someone who doesn't spend much time in any one server-side technology. I've had to jump into apps written in Python, PHP, clojure, etc, etc. In a workflow like that I need to be able to get things running with the least amount of resistance possible, and come back to it later without having to reconfigure things.
Find some real project around you. Are you a member of a sport club? Ask them if they could use something (allow to apply to course, etc). Got a friend that just has a baby? Build their birth list. Know someone in retail? See if they could use an online presence. Have a charity you like/do work with? Check with them.
gotchu
Your bin stubs are probably screwed up and rails s is starting using a different version than the gem installed with Ruby 2.1.2... Try gem install rails and see of that changes anything
imo Twitter and Flickr are like the "hello world" of rails.
Build both, and then build a personal project
Don't know what bin is, but I tried both those commands and still the same error :(
&gt; Libsodium which is called RbNaCL for Ruby[1] for encryption, scrypt for password hashing Yes and yes to this. Just went through RbNaCl and sweet mother of god is it clean and easy! Scrypt seems to be the best password hasher out there too, but I can't quite yet fall in love with the overridden == operator that scrypt and bcrypt gems use. I think stumbling across something to the effect of `password == "my grand secret"` in my own code one day would just freak me out.
Bin is the folder where your binstubs are.
has you run the command with `bundle exec ...`
Of course, you shouldn't have secrets in your source code regardless of what method names a gem uses, #== or otherwise. 
Can anyone explain to me what this actually does? I read through the docs and still don't understand what problem it solves?
I am not exactly sure why most of those reasons are even there. The topic clearly says prototyping. Why should I care about code quality, refactoring, agile, tests or cloud services when I want a quick prototype to show to a customer or as proof of concept. If I want the prototype to evolve into production code, then I should start caring but the topic is misleading. Assuming the article is actually about a full product lifecycle I would argue like xiongchiamiov and claim it applies to most modern frameworks while some claims are just false. Rails does not increase code quality with set patterns, as you can so easily get to a point you have trouble touching a system. Best proof is the TDD discussion last year. Additionally it does not make it easier adjusting to changes. At least not easier than with any other framework. Not to mention explaining to new people on the team how your libraries work... I love ruby and I enjoy rails, but it is not the holy grail people claim it is...
right. it was the overloading that was weirding me out.
Ahhh, got it, that helped me solve the proxy issue, thanks! Didn't realise this would be available in this hook. Could you explain a bit more the second line (or 3rd), with `app.sitemap.resources.map`?
Nice, I guess this means removing timecop can be part of the upgrade to 4.1. Unless there's something else that timecop does over and above this... I've usually only done Timecop.travel and Timecop.freeze blocks.
Heroku has been pretty well covered, so here's my 2 cents on Nitrous. Nitrous.io gives you a development environment in the cloud. You get a text editor and a terminal in your browser (or the ability to sync changes to a local copy). You dev databases, gems, environment variables, etc. etc. are all on a remote box you can jump into at any time from anywhere. Other people can also login to your dev environment to help debug, review code, whatever without having to pull code, setup databases, seed data, etc. A side (but awesome) bonus is working with webhooks (other services POSTing data into your app) works in development without and tricks since your 'localhost' is actually a subdomain of nitrous.io. If you develop on multiple machines (my primary machine is a desktop, but I use a laptop when I need to be out of the office) or are stuck with Windows, nitrous.io is a great option. 
That also happened to me yesterday on 2.2.0 and I had to revert back to 2.1.5 for a pet project, was pretty annoying. I did reinstalled the bundle and set it to vendor as I usually do and it didn't fix a thing. What fixed it was rake rails:update:bin on 2.2.0, I was using latest 4.2.1.rc4 so you might want to check that as well. 
Add a `.ruby-version` file with `'2.1.2'` being its only contents to the root of the project if you don't have one. Run `rbenv rehash` from your terminal.
it's an annoying problem. I just reloaded my OS, this is the most annoying problem ever. I also had rbenv installed, but now I am going to use RVM
Did that yesterday and now have four interviews lined up for internships!
Thanks for your words. I searched all day and now have four interviews lined up, one confirmed they pay hourly even for training!
You have four interviews with a blank github? Seriously? That's awesome! I would love it if you would post these companies (and location) on this post in about a week, or after you interview and hear results. I would be interested in following up what you don't action on. Also, I would want to know if they were willing to work with you remotely? I work full time and spend the after time building things. I suppose I should spend a day "searching" and see what's out there. That would be super helpful! 
The `sitemap` contains all the pages in your site including proxy pages, it has methods for adding pages dynamically and whatnot... `resources` is an array of those objects where you can access everything from frontmatter to the url, source file path etc. I just mapped those resources to give you all the source file paths in an array. More information on the resource objects and what methods they have (`source_file` etc) is [here](http://www.rubydoc.info/gems/middleman-core/Middleman/Sitemap/Resource) and some more info on the sitemap [here](https://middlemanapp.com/advanced/sitemap/). Also for the record you may be able to use a `ready` hook instead of `after_configuration`, depends what you're doing.
Just make sure you call `travel_back`, and you should be just fine.
This is fucking awesome. We're using Cassandra in our app and I've been looking at Neo4j for a little while. Great post for getting Neo4j up and running.
Another vote for sidekiq
I think you've still got two membership records in the db, Rails is just hiding that from you by uniq'ing the players before returning them? I think. This stuff gets confusing. That may or may not be a problem. I am still astounded that Rails manages to somehow set the captain attribute to true as a result of that `where` restriction; I admit I won't fully believe it until I play with it myself and see it's true. 
It provides a dependency graph data structure (directed acyclic graph) which can be used to perform some computation necessary in order to create a valid state necessary for a root object. The fact that the graph does not contain cycles is important because you cannot have circular dependencies, because each dependency will end up recursively requiring itself and looping forever. For example, in order for a Gem to be in a valid/runnable state, it requires the presence of other Gems. It cannot run without them. Another interesting idea would be to use the dependency resolver a model for parallel computing. You can break your program into "tasks" which can be independently completed. Each task can have a number of children tasks which need to complete in order for it to start. 
My rule of thumb is "don't lock longer than half the time of your request timeout". So if you have rack-timeout set to kill requests after 20-seconds, you probably won't want to lock for more than 10 seconds (to give any requests time to complete after the lock is released). It's tough to know exactly how long, but let's say 100-rows-modified/second (your mileage may vary, so eyeball it). For example, if I'm modifying a table with more than 1k rows, I'll do it either in a non-locking manner, or I'll put my site into maintenance mode
I'm happy to help but a little confused by your question. One method can absolutely call another, or they can be called sequentially by something else. So foo("string") might do one thing, and bar("string") might do another, so foo(bar("string")) is legit. The reality is that the inner function will evaluate first and return it's result, which will then be passed into the outer function. Did that help / make sense? 
Welcome to one of the best things about Ruby. In my opinion at least. Every method will return something. Usually, the returned object is the last result of whatever the method did. So if you want to use the result of a method, just call that method. As an example: def two_plus_two 2 + 2 end def subtract_one(value) value - 1 end subtract_one(two_plus_two) # 3 You're able to do neat things with this by calling methods on the objects that are returned by the methods you've called. So if you have a method called returns_array that returns an array, and then you want to sort that array... returns_array.sort There you go.
Excellent! This cleared up a lot for me. Thank you for your help!
I am not sure you understand that AMQP service itself is dead simple, although, even if you need some maintenance or tuneup done - it's a one-time payment, not a recurring one. Once again, every product has it's customer. If infrastructure management bothers you - welcome to the heroku world!
After 6 years of development in Ruby I was kinda thinking that Ruby / RoR / related systems were dying. This article inspired me and I came to conclusion, that it's me who should learn to keep my initial enthusiasm and passion in a good shape. Thanks a lot!
Check out Shallow Nesting (2.7.2): http://guides.rubyonrails.org/routing.html#nested-resources
I don't know if it really makes sense to download all of them, just cause your computer is airgapped, but you can use the API (http://guides.rubygems.org/rubygems-org-api/) or, I beleive they store them all in S3 buckets, so you can probably use a tool to sync an s3 bucket and just pull entire buckets. 
The key is: practice, practice, practice. http://www.wisdomgroup.com/blog/10000-hours-of-practice/ Challenge yourself: http://exercism.io https://www.bloc.io/ruby-warrior#/ http://codewars.com Learn from the best: http://rubytapas.com http://www.sandimetz.com/products Read some code: https://github.com/search?o=desc&amp;q=ruby+language%3ARuby+stars%3A%22%3E+5%22+forks%3A%22%3E+3%22&amp;ref=searchresults&amp;s=updated&amp;type=Repositories&amp;utf8=%E2%9C%93 
I'm not sure one can be a "Ruby Expert", there is an element of jack-of-all trades, master of none to that sort of statement. You can develop expertise in a specific subset of ruby related tools and skills. You could be a rails expert, for example. You could be a meta-programming expert. You can be a heroku deployment expert. You could be a "can do anything in ruby in a single line" expert You could be a test framework expert I think it is unlikely to have one person who is all of these things at an expert level.
Read David A. Black's (The Well-Grounded Rubyist)[http://www.manning.com/black3/]. Then read chapters 4 &amp; 5 again. Seriously great book. No affiliation, just a happy consumer.
Wouldn't this be a place for [MRuby](https://github.com/mruby/mruby)?
It's going to be enormous. Every version of every gem ever? I can't find anything googling as to how big it would be, you could try asking on the rubygems listserv and see if anyone can easily look. I guess you'd want to do some kind of rsync-like thing to get changes. there are changes happening every second, I'm not sure how often you'd want to update, but when you did you'd want to find a way to just get modifications, not have to redownload everything there is again. You don't actually want to _install_ every version of every gem, I don't think (or do you?), you just want to mirror them in a local repo? So avoiding rdoc and ri is irrelevant, it's just the size of the source .gem files for every version of every gem ever released that matters. If you actually tried to _install_ every version of every gem ever released.... I suspect you'd start giving rubygems a problem, and it would take very long times for you to ever start up any ruby process etc, I doubt the code was meant to scale to such a size of gems installed in the ruby runtime. Either way, my guess is you will eventually decide what you are trying to do is not feasible. *update*: Or maybe I'm wrong and this is something you can do, I've never tried, but some googling for 'mirror rubygems' revealed some things with people trying to do such, it was unclear to me which approaches would actually work and were not outdated, if any. 
I'd wager there is a subject in Ruby you've been putting off because you're scared of it or you haven't had reason to use it. Dive deep into that whenever it happens! (Mine were IO and Regex, but I dove into them and feel much more comfortable). The trick is to remind yourself that it's not as complicated as you're making it in your head. Also, make flash cards for all the instance methods on the most commonly used classes like [Array](http://ruby-doc.org/core-2.2.0/Array.html), [Hash](http://ruby-doc.org/core-2.2.0/Hash.html), and [string](http://ruby-doc.org/core-2.2.0/String.html). Test yourself to know all of them like the back of your hand. And then do the same for the common modules like [Enumerable](http://ruby-doc.org/core-2.2.0/Enumerable.html), [Comparable](http://ruby-doc.org/core-2.2.0/Comparable.html), and [Kernel](http://ruby-doc.org/core-2.2.0/Kernel.html). When you come across something you don't understand, just write it down and ask someone later. And finally, find yourself a copy of Metaprogramming Ruby (there are 2 versions. get the more recent one). It's not as advanced as it sounds, and in fact, understanding metaprogramming in ruby will help you understand its true nature (with the object model, and the method lookup chain, and so on). Good luck!
Sounds similar to Dan Mayer's [flatfoot](https://github.com/livingsocial/flatfoot); it also uses ActiveSupport::Notifications.
No problem! I love Ruby &amp; love helping people with Ruby, so if you have ANY questions at all I'm more than happy to answer them. Feel free to PM me.
You can refactor the common code into a support module. Create a file in `spec/support` that looks something like: module MyThingSpecSupport def setup_the_thing ... end ...more methods end If your using a standard rspec `spec_helper.rb` it probably already includes all the files in `spec/support` so you shouldn't have to do another `require` in your specs, if not add a line like this to `spec_helper.rb`: `Dir[Rails.root.join('spec/support/**/*.rb')].each { |f| require f }` Then, in your specs: describe MyClass do include MyThingSpecSupport ...You can now directly use methods from MyThingSpecSupport end 
http://artoo.io/documentation/guides/what_is_artoo/
Keep in mind that while they are effective at deduplication, shared examples are a terrible feature. If you need to test the same behavior in two places then you have the same code living in two places and that means you need to DRY your design such that shared examples aren't needed.
I don't think they are terrible. I use them to test concerns on each model that includes the concern. More generally, you can uses them to test functionality in any place where you are using compositional patterns. However, i do agree that the OPs issue is not one that should be solved with shared examples.
Please share what you are doing currently. Restful api/frontend/etc. Also I'm about a year in and here's my first blog. Arrestedcoding.com and metrics.arrestedcoding for a body fat % calc/tracker. I feel intermediate personally. I really like building restful apis and modeling data personally. 
It has nothing do with concerns, it was just an example. Including any module in any other module or class could have the same issues. In other words, all compositional patterns in Ruby have this issue. 
When I write a mixin, I test that the mixin modifies the target class the way that I expect it to by passing in an example class. I'm curious... have you found value in testing that target classes in your project don't modify the methods implemented by the mixin?
Ah, thanks for the response. A couple areas where I differ. I don't ever allow classes to include more than one module. That's not an actual rule I've ever declared formally, but when you have more people working on a codebase, you need substantially more isolation between concerns. It's impossible to throw all that behavior behind one unit of abstraction and expect it to stay functional, simple, and easy to understand. Also, an 8 minute build is a lot slower than what I typically target. I generally want 1,000 assertions / sec or better so that I can run the full test suite rapidly enough to be able to refactor code across concerns quickly.
&gt; Also, an 8 minute build is a lot slower than what I typically target. I'd like it be faster too. Depends on what your doing. A decent chunk of the tests in that app are capybara UI tests which are clunky to make fast. Also, 8 minutes on travis with phantomjs, both are dog slow.
All modern rubies use native threads. MRI 1.8 was the only one that used green threads. However, MRI 1.9 + , while using native threads, still has the GIL. that is the issue now.
It should be worth noting that when you're simply adding two strings together: string1 + string2 will still be faster than "#{string1}#{string2}" The reason interpolation to wins over + in this instance is because each `string + string` that occurs will create a new string. So when you're adding 5 strings together, as the benchmarks are doing, the creation of a new string for every + will make it significantly slower in comparison. Another possible point of interest is that the results here can vary drastically between ruby implementations. This benchmark was run on core ruby. Here is the same benchmark run on JRuby (1.7.16) (culled some results, so it doesn't clutter the post): user system total real add: + 0.280000 0.000000 0.280000 (0.268000) append: &lt;&lt; 0.420000 0.000000 0.420000 (0.417000) interpolate: #{} 0.370000 0.000000 0.370000 (0.366000) As you can see, string addition is much faster in JRuby. Append, not so much. Anyway, many of you may already be very aware of this stuff. Just thought I'd post this for anyone that might see this and think "I should use interpolation for everything!"
Ask and ye shall receive: http://www.reddit.com/r/ruby/comments/2zoq1d/how_to_reverse_engineer_regular_expressions/
Ask and ye shall receive: http://www.reddit.com/r/ruby/comments/2zoq1d/how_to_reverse_engineer_regular_expressions/
Ah, good. Another contrived run-time benchmark, run as a standalone process in its own MRI instance. Guys, please. Performance tuning is more than just "Method X is faster than Method Y, therefore always use Method X". Method X may have vastly different memory usage patterns than Method Y. Method X may fail (spectacularly) given certain edge cases. Method X may not be faster on a different ruby version. Method X may not be faster once you've loaded Gem Y. Method X may not be faster once you're in a multithreaded environment. Performance tuning is about identifying bottlenecks in your real system by performing profiling and analysis and using these findings to address the architectural flaws that are causing slowdowns or contention. It is not about finding a single silver bullet that works everywhere without thought. Sure, you may find a block of code that's doing five million string appends in a loop... but the question then becomes, why is the loop there, not how can I make the appends faster. This is an interesting aside, nothing more. 
This looks damn cute.
It's something that should be measured. I've hit all sorts of things you would never think were a bottleneck when profiling Rails applications. Rendering is a big part of web frameworks and lots of string operations happen. The other part, as Maleckai mentions, is the number of objects created. GC can really kill performance, so not creating objects unnecessarily can help substantially.
If you can speed things up without loss of abstraction, I don't really see the problem. If your abstraction adds 100x overhead, the abstraction could probably be improved. Profiling is a fine technique and quite valuable for application development. But users of a gem are always going to have different usage patterns and thus different hot paths. It pays substantially for libraries to be fast out of the box and hide the complexity from those using them. You can choose faster alternatives that might not be as obvious (e.g., using an improved algorithm vs a naive one), while still not being spaghetti code.
If you could have any one food for the rest of your life, what would it be and why is it spaghetti?
Read the Ruby source code. 
Someone is going to inevitably append to a string variable that was passed into a method (mutating it in place) and breaking something upstream in the call stack which did not expect that string to change. You should really note that somewhere. You can't just refactor adds to appends all willy-nilly. You should only append to variables defined in the current scope IMHO. See: why I switched to Elixir
both?? If I had to choose I'd say just to be an expert
I'm currently developing a niche social media webapp in my spare time. I'm also going to build an api for it and use it as the backend for when I want to make a mobile version of the site
test
Interesting. I've had nearly the opposite experience. A lot of Ruby written naively that worked well in a low-volume Rails app, but couldn't keep up with moderate to heavy load. Oftentimes, the next tool pulled out is some form of distributed caching, which usually creates more problems than it solves. Of course, I'm not arguing to optimize everything under the sun. It's more a case of if you have two equally expressive options, knowing the performance trade-offs between each can help pick a design that will be easier to optimize down the road. I've come across too many apps that made bad assumptions carried forward that necessitate near rewrites to get performance up to snuff.
tom cruise
This is what I'm planning on doing also on my side project, body fat metrics. Restful API backend then a web client and a native android app because I want to learn java/android. I'm also slowly architecting a restful socket api with node but thats a whole other beast. 
My first official gem. It adds a macro `attr_setting` that works like `attr_accessor` with some added functionality.
I agree with the value of utilizing automated tests to ensure that features work, but I don't agree with the conclusion. I used capybara for over a year, and enjoyed it at the time, but there's a hangover at the end of it. Babysitting timing issues, false positives, an overall slow build are just the beginning of the issue. The worst problem I discovered was that browser testing hid structural design problems in my code. When your abstractions are poor, something like capybara is absolutely necessary to make sure your features work. In other words, you need capybara if you *aren't* encapsulating your features properly. The end result of relying on browser testing is often a codebase with terrible encapsulation -- because you don't need it anymore to get your green dots. These days I confidently write my features without a browser testing stack, and the code just works. It takes a lot of practice and learning, but when you've got a sub 5 second build time and thousands of valuable assertions per second, you can make even large scale changes happen quickly.
That syntax is going to be so confusing in a project that is already using AngularJS.
...or just use Ruby's heredocs with the standard #{} interpolation. 
It's called destructuring, and thank you for using it! So much easier to read destructured variables than having to sift through array accessors.
I think what you're looking for is "Destructuring Assignment". Just in case, describing your entire example, I would say that you are iterating over an enumberable object (an array) and assigning the values of each object from that array to local variables within a block.
Look at tr. There's plenty of other ways to do caesarian cypher, but this function works perfectly in this scenario.
Don't ask. I work in IT since &gt;20 years. This industry is pain crazy. We just outsourced our website to some guys in Vietnam. We had started here in Germany with some rather incompetent guys. Still, they managed to get some nice html &amp; less code running (yep, we outsourced the frontend &amp; design work for a Rails site to some PHP dudes). So when we moved the project to Vietnam (because they 'know' Rails, I think 'Rails experts' was mentioned) we asked them to migrate the LESS code to SASS, so everything is a bit more Rails like. The LESS code was rather nice, well organized and all. When I looked at github and saw they had changed LESS to SASS I was quite happy that they did it so fast. But then I looked at the result. They had just taken the generated CSS and run it through the first CSS to SASS migration script they found with Google. So we got one large SASS file with all variables replaced by constant values and all the file structure lost, also added some useless autogenerated variables that nobody needs. All in all one monster file of 4000 lines. I complained (obviously) and they reverted the commit and will talk with the 'responsible' developer. Guess there will be some discussions about that in the next meeting. That's the experts I have to expect to write Rails code in near future. Can't get such a simple task right. No idea what will happen when they actually write code. 
Btw. you do not need the round brackets.
You do realise that ruby weekly literally gets all their content off reddit, right? Posting things you find there is almost certainly going to be a repost. http://www.reddit.com/r/ruby/comments/2z7x7n/how_does_symbolto_proc_work/
http://www.reddit.com/r/ruby/comments/2zek09/ruby_together/
True, but given the simplicity of the template engine, it should be fairly easy to change the syntax to something else.
That's true, however, using heredocs won't scale in the long run :)
To add to this: you only need the brackets if you're destructuring a one-element array. [ ['Jack'], ['Kate'], ['Vincent'] ].each {|name| p name.class} ==&gt; array but each{|(name)| p name.class} ==&gt; string
Check out these for converting letters to numbers and vice versa: http://ruby-doc.org/core-2.2.1/Integer.html#method-i-chr http://ruby-doc.org/core-2.2.1/String.html#method-i-ord
It's not about testing rails. It's about to capture the behaviour/structure of your rails app so that if you apply changes your generated specs will give you feedback about your changes. Take for example namespaced models if you create an association on that namespaced model to another namespaced model you need to set the foreign key or else rails cannot easily infer the correct key. Even if your IDE suggests you this key it's necessarily not correct. So by generating a simple spec for this association you will see if your association is correctly defined. Also those generated specs are indeed not complicated because they just make a snapshot of the structure of your application. Those generated regression tests are not a substitute for real specs they just support you as a developer to keep an overview of your structure. Consider a use case where you have a lot of controllers and a lot of action methods after a certain time your rails app grows incredibly fast so it's totally normal that you maybe delete a controller action and didn't think about deleting the corresponding route. If this app then goes to production errors will start to appear in your monitoring tools and you need to do extra work by searching this error source - fixing it and deploy it back to production. All this time could be saved by generating a simple spec, which capture your routes and gives you feedback about unmatched actions or routes. Best regards
This line of code did not do what you expected it to do: &gt; integer.map! { |n| n.gsub(/[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]/, '0' =&gt; 'a', '1' =&gt; 'b', '2' =&gt; 'c', '3' =&gt; 'd', '4' =&gt; 'e', '5' =&gt; 'f', '6' =&gt; 'g', '7' =&gt; 'h', '8' =&gt; 'i', '9' =&gt; 'j', '10' =&gt; 'k', '11' =&gt; 'l', '12' =&gt; 'm', '13' =&gt; 'n', '14' =&gt; 'o', '15' =&gt; 'p', '16' =&gt; 'q', '17' =&gt; 'r', '18' =&gt; 's', '19' =&gt; 't', '20' =&gt; 'u', '21' =&gt; 'v', '22' =&gt; 'w', '23' =&gt; 'x', '24' =&gt; 'y', '25' =&gt; 'z') } Your regexp is incorrect. What Ruby sees is: /[0123456789,]/ You are using a character class (I think), and Ruby only sees the 'letters' once. Therefore, only 0 to 9 can be decrypted as the rest have repeated numbers. Also: /u/yes_or_gnome suggested `String#tr` which is perfect for this imo Edit: Silly me, `tr` will not do in this situation
There seems to be a "less2sass" gem. No idea how good it is, though. Also, see my other post in this same forum for some real-world Ruby/Rails battle stories (and possible advice for you).
I'm not really sure whats going on here. I see you're using bitwise operators, but care to eli5?
I thought the example in the README was good enough, but perhaps I should have explained it in more detail... MissyElliott.encode("Example") # =&gt; "\xAE\xF0\xBC\xA4\xF8\xE4\xAC" #"Example" #--&gt; ["E", "x", "a", "m", "p", "l", "e"] #--&gt; [69, 120, 97, 109, 112, 108, 101] #--&gt; ["01000101", "01111000", "01100001", "01101101", "01110000", "01101100", "01100101"] # Shift yo bits down #--&gt; ["10001010", "11110000", "11000010", "11011010", "11100000", "11011000", "11001010"] # Flip it #--&gt; ["01110101", "00001111", "00111101", "00100101", "00011111", "00100111", "00110101"] # And reverse it #--&gt; ["10101110", "11110000", "10111100", "10100100", "11111000", "11100100", "10101100"] #--&gt; [174, 240, 188, 164, 248, 228, 172] #--&gt; ["\xAE", "\xF0", "\xBC", "\xA4", "\xF8", "\xE4", "\xAC"] #--&gt; ["\xAE\xF0\xBC\xA4\xF8\xE4\xAC"] * Convert each character to its [ascii value](http://www.asciitable.com/), using [String#ord](http://ruby-doc.org/core-2.2.1/String.html#method-i-ord) * Convert each of these numbers to binary, basically by using [Fixnum#to_s(2)](http://ruby-doc.org/core-2.2.1/Fixnum.html#method-i-to_s) * Apply the "Missy Elliot" algorithm. This is just 3 easily reversible steps, as shown above, on each of the binary numbers, so we end up with a new array of "encrypted" numbers. * Convert each of these binary numbers back to decimal, by using [String#to_i(2)](http://ruby-doc.org/core-2.2.1/String.html#method-i-to_i). * Convert each [ascii value](http://www.asciitable.com) back to its corresponding character, using [Integer#chr](http://ruby-doc.org/core-2.2.1/Integer.html#method-i-chr). You can see the actual code for all of this (it's only a few lines!) [here](https://github.com/tom-lord/missy_elliott/blob/master/lib/missy_elliott.rb). So basically, I'm just converting each character in the string to its "encrypted" form, by messing around with its ASCII value. Because of how the algorithm works, it's easy to reverse the process and decrypt the string back again!
https://www.youtube.com/watch?v=zm28EEeyLek
Love the "contributing" part.
Well i agree that specs which are written to test a method are more useful but let me give you another example of how such generated easy specs can improve your rails applications :). Lets consider following validation: validates :attribute, presence: true, uniqueness: true, allow_blank: true So this validation seems at first correct and well syntactically it is. But the options presence and allow_blank are conflicting each other. A simple generated spec would look like this: it { is_expected.to validate_presence_of :attribute } If you run your spec you would get a failing test because those options are incorrectly used. It's not about test coverage statistics, it's about helping you as a developer to create reliable software. Hope this example is better than the namespaces :) Best regards
You should cross post this to /r/programmerhumor I enjoyed it.
As soon as you get over the first hump of "wtf this isn't like python/js/c/Perl" it becomes pretty easy to pick up. I know for me, the initial stumbling block was the way blocks and enumeration worked. As soon as I realized I'd never have to write another for loop just to iterate over an array, I was hooked. Everything else just fell into place
Thanks - I hadn't seen that subreddit before!
I don't think this example app is but the Volt framework itself is: https://github.com/voltrb/volt There is a work in progress tutorial linked there. Also more videos of other app examples.
Just looking at a high level, I do see that central is a 501c(3) and together is a 501c(6) They do look similar in goals, but rather different in approach.
Ah ok, I took a 90s pop culture course in the summer. I understood most of her references. Why did you make this a gem?
Absolutely.
Just for laughs, here's a functional implementation of this "Missy **Elliott** encryption algorithm". Encoding and decoding are similar enough operations that the algorithm can be generalized over `s` (whether or not to shift), and `a` and `b` (where to begin plucking bits from the string and how many to take, respectively). missy = -&gt; op, input do s, a, b = op == :encode ? [1, 0, 8] : [0, 1, 7] input .bytes .map { |byte| [(byte &lt;&lt; s) .to_s(2) .tr('01', '10')[a, b] ].pack('b*') }.join end encode = missy.curry[:encode] decode = missy.curry[:decode]
Let me work it.
Why *wouldn't* I make it a gem? It's clearly the best way to actually share my code, in case anyone wants to use it!
The ENV was a bit of sarcasm to explain my current state of mind. Our integration tests take approximately 2 hours to run on a retina macbook pro--every single one of them uses Capybara. The unit, javascript, and asset tests take about a half hour to run a piece. Oddly, the extensive testing was considered a benefit of the organization. 
Very clever... And also very difficult to read :) Some of the underlying code could easily be made more compact/efficient using bit shifting etc, but i wanted the code to read like the song lyrics - i figured that would be more legible, as well as funnier. The current code literally says "shift... Flip it... Reverse", which i thought was really nice. 
Timeout is insanely evil. It raises exceptions at arbitrary points in other threads, which means that it can do things like cause `ensure` blocks to not execute. This is a pretty wonderful way to, say, leak resources out of a connection pool. It's almost never the right solution.
What would make for a better solution?
O( n^2 ), fwiw.
Mine was the simple way to return a value that has been cached or calculate it if not. def value @value ||= calculate_value end Simple!
1. Big-O rarely matters in reality, particularly in Ruby. 2. It's O(m*n) and there is no faster way to do this from a time complexity standpoint. 
In ruby 2.0+ you can do this to get the same result and still avoid the intermediary array. songs.lazy.map(&amp;:duration).reduce(0, &amp;:+)
Wat! I can't believe I didn't know about Enumerable#lazy! Thanks!
 object.send(:thing) I didn't quite get it at first, until I figured out object.send(variable_name) then I realized I could form strings as variables to call different methods. at that moment, the skies parted, and the sun shined directly on me for a moment in time, while I imagined all the things I could do.
Erm... Unless I'm missing something here, that code contains 2 unnecessary parts - you should just write: songs.map(&amp;:duration).reduce(:+)
Your version has two problems: 1. It creates a full array of duration values which isn't a great idea if there are a lot of songs. The lazy version avoids this. 2. It returns nil when songs is empty, [].reduce(:+) == nil 
Okay well which is the easiest to pick up?
You need to provide way more information on the job and the person working on it before we can tell you if the tool you want to use is good for it.
iconoclaus is absolutely correct. You will be hurt *far*, *far* more by your lack of programming knowledge, not only of the language, but of best practices, design, etc, than by your choice of framework. In the end, python and ruby have very similar syntax. However, the standard library of ruby is *amazing*. Take the [Enumerable](http://ruby-doc.org/core-2.2.0/Enumerable.html) module for example. It makes working with arrays and other enumerable entities a joy. Also, blocks. Once you understand them, you don't want to live without them.
I hate it when I don't understand how things work!
Ruby and Python are strikingly similar but philosophically very different. Its really one of those choices that will alter your immediate future experience with programming considerably, yet there is no real advice anyone can give you one way or another. I'll say something about Ruby since I don't do much Python (just dabble in it for data analytic purposes). Ruby really transformed my thinking about OOP: it showed me how little I knew about it and how powerful it could be. The Ruby community and the incredible books produced by it really made me fall back in love with coding after years of apathy from doing Java/.Net. Those were fine languages but couldn't inspire me as much as they tried. To contrast it with your background, cpp coding is about telling a machine how to get things done, whereas Ruby coding is about telling other programmers what you want to get done. Probably my favorite thing about Ruby, and something that [people can't stop feeling](https://www.google.com/search?q=ruby+gateway+drug+programming), is that Ruby is a gateway drug to newer programming. It will inspire you to look deeper into a plethora of new ideas in computing, be it web dev, functional languages, and more. So don't be surprised if you take this a step into Ruby today and years later find yourself doing tutorials on Elixir or something altogether different from where you started.
Also as someone who works in a lot of more 'algorithmic' Ruby, aka not Rails apps. The best Big-O algorithm is rarely the fastest for a few reasons: 1. Ruby is very sensitive to GC pressure. Minimizing allocations is often far more important than minimizing time complexity. This one also doesn't tend to show up in simple benchmarks are you often don't do a GC collection in the benchmark, but in reality you eventually do need to cleanup after yourself. Your better off not worrying too much about individual algorithms in your system, profile the entire thing during operation to figure out the full impact on the system. 2. Big-O matters when n is 'large', what is 'large'? In my experience on modern hardware large is often _really_ large. Modern hardware is _very_ fast when doing 'dumb' things like linear searching through a string. 3. Ruby has an extreme performance boost from using standard library methods over using more Ruby but with a better complexity. e.g. say you have 10 million random Integers in an array and you need them sorted descending. Which do you think is faster: `array.sort.reverse!` or `array.sort { |x,y| y &lt;=&gt; x }`? The former is 5 times faster. I've also written O(n^2) algorithms using standard library methods that handily out perform an O(n) implementation that uses 'more Ruby' even with n = 50_000_000. 
Much love for Missy. Awesome gem.
People on here are overwhelmingly going to be most familiar with ruby and like ruby the best. if you already know python and like it, that might be a reason to stay with python. I'm not familiar enough with python or it's web app solutions to really compare them to Rails myself. I suspect most other commenters are in the same boat. You can be succesfull no matter what you pick if you know (or learn) how to program in general, and also how the web works (HTML, CSS, Javascript, HTTP and caching). If you never get your head around these things, but just try to copy and paste code from google, you will probably be less successful and have a frustrating time no matter what language/framework you pick. I think this is probably the only answer you're going to get here, even though you want us to give you an answer that will ensure success. :) It sounds like you're interested in Rails and want to give it a try. Nothing wrong with that. 
Ahh ok, well those are indeed 2 edge cases that i assumed the code wouldn't need to bother with. Perhaps you'd *want* the method to return nil in that case, and surely you'd need an (unrealistically) HUGE number of songs before hitting any performance issues! But i guess your version is technically more rigorous, so fair enough :P
+1 for Sinatra
Definitely Ruby/Rails. Python/Django is very similar, maybe not quite as easy to just pick up and use.
Whatever you are comfortable with. This guy posted similar project yesterday, he did it with Java without frameworks. http://www.reddit.com/r/learnprogramming/comments/2zs65k/ive_been_making_this_language_learningexchange/
I'm mobile, so I can't reply in depth, but I agree with you. My point is more that Rubyists in particular seem to excuse bad code with statements like "big O doesn't matter", and "Ruby is optimized for happiness, not speed". The net effect is that you get a lot of people not thinking about the performance profile of their code, and it adds up into products which run orders of magnitude more slowly than they need to. Big o is certainly not the end all of performance, but not thinking about it is a great way to get into the weeds in a hurry.
Do the additional practice. Seriously just take the time, because while there's a lot of stuff that he's teaching right now that is easier to implement with gems, you will know how more of the rails' "magic" works. I found that book to much more helpful then almost anything else I've read so far. 
Just learned about this the other day...apparently it's called Memoization
I've been told by seniors that it often doesn't matter because you'll be bottlenecked by your network speed more than your code's time complexity. But then I was denied an in-person interview recently because my algorithm for an exercise didn't solve in under 2 seconds so...maybe it does matter /shrug.
That's a bit how I felt with rails. Instead, I found I loved using Sinatra because it let me understand everything. and now I finally get why rails does what it does. 
how is that O(n^2 )? it's O(n) in the size of the data being iterated over. 
Thanks for suggesting SO...And it's not really core debugging. Vagrant is on version 2, and I'm the only one who seems to be running into this problem, so is an issue with my configuration, not that application. **Vagrant** is an application written in ruby designed to work with vbox as a wrapper for development (or production) environments. As In sure you know, sometimes, in web (or other) development you need a XAMPP or a LAMP server for development in Windows (which originally gave rise to the "WAMP" server). This application (Vagrant) is a brilliant, all-purpose, cross-platform container for reproducible environments such as those. I realize Windows isn't optimal, but I'd rather use Windows with a local nginx-PHP-Mongodb/Redis (and unlimited other options) server...than IIS, that's for sure. To the contrary, this application is an _amazing_ idea that is changing the way we do development and production/deployment.
I'm not seeing the sort. Another thing I notice is the `slice!` method, which will have to modify the array, deleting half the elements on each iteration, until the target is found. Depending on implementation details, this could also be associated with reallocations and memory freeing. I'd also assume that there is a `dup` called before invoking this method (otherwise it will fuck up the array), which, all by itself, is going to be more costly than a C level search (to dup the array, you must iterate over it, which is what the C level search does anyway, so before you even begin searching, you've already incurred more cost than the search).
You should try a few of them and see what you like. I've been doing Rails for many years now. Ruby has a really nice syntax and a decent amount of expressive power. But after getting bit by some VERY nasty bugs on a fairly large Ruby codebase with a lot of gems (none of which would have even been possible in a functional, immutable language), I've been trying to move on to Elixir, which is based on Erlang (extremely concurrent) but has a nice Ruby-flavored syntax. I think it's going to be a thing, but it's still pretty early in its lifecycle. (Then again, I got into Ruby when it was at 1.5 or so, before Rails even existed.)
Pretty sure that in practice, lazy is almost always more expensive (seem to recall someone benchmarking it a ton of different ways to see). I think its use case is actually for infinite lists, eg https://gist.github.com/JoshCheek/d02a0053c425233b7039
1 word. Eigenclass.
Big-O is meaningless until some threshold ----------------------------------------------- By its own definition, Big-O does not matter everywhere. Lower time complexity only correlates to fewer steps, as the size of input approaches infinity, and exceeds some threshold. So before that threshold of input, it is not necessarily true. This is why high performance sorting algorithms will switch from something like Merge Sort, which is O(n lg n), to something like insertion sort, which is O(n^2), once the input is sufficiently small. Example: Insertion sort faster than merge sort ---------------------------------------------------- I benchmarked the difference and plotted them. For my algorithms, insertion sort beat out merge sort until n was about 110 https://raw.githubusercontent.com/JoshCheek/Play/78a7fd77da9dc8d46cfb0dad431f18abf6a06617/sort-efficiency/results/results.jpg Big-O is worst-case, not common case ------------------------------------------- Also, Big O notation is an upper bound, so it is only somewhat useful to understand. A binary search tree, for example, would be O(lg n) if it was balanced, but in a worst case (eg the data was sorted before inserting, so it all went down the same path and became a more expensive linked list) it's O(n). But this worst case is not necessarily common, and thus is only one thing to take into consideration. Note that there are other asymptotic measurements such as big omega and big theta for other measurements which might also be relevant. Big-O describes growth rates, not actual costs ---------------------------------------------------- Additionally, time complexity is about understanding growth trends, not about actual measurements. So an algorithm that is O(1000n) has the same time complexity as one that is O(n), which is to say that they are both linear (1000 is a constant), even though one is 1000 times as expensive (if each operation took one second, In Ruby, using optimized implementation level library code (eg core methods written in C or Java) could reasonably be so much faster than a sophisticated data structure and algorithm that you spend a lot of time on, that the higher time complexity is overshadowed for any real-world use cases. Takeaway ----------- So, write it in whatever way is easiest and most straightforward, then if it turns out to be too slow, profile it to find out why (could easily be the cost of allocating memory rather than algorithmic complexity), and do the hard work of introducing custom data structures and algorithms only if you've found it's actually an issue. Don't spin your wheels on premature optimizations that don't actually matter.
Yes, `songs.inject(0){ |sum, song| sum + song.duration }` is the way to go. In practice this just adds the overhead of using a lazy enumerator for no gain... I would love to see a benchmark that proves otherwise though.
Don't instance variables always return nil if it's not defined? You don't have to explicitly check for it. 
What I mean is this: def value @value ||= calculate_value end def calculate_value do_something_expensive nil end Since `calculate_value` returns `nil` sometimes (or always in this example) then the `||=` will evaluate it as false and then fire `calculate_value` again. That's why you can't use this exact method to memoize a boolean method: def active? @active ||= expensive_active_calculation end Because if the user is not active, `@active` will be `false` and the or operator will fall through. The syntax which covers falsy values is: def value return if defined?(@value) @value = calculate_value end
https://www.reddit.com/r/ruby/comments/2zek09/ruby_together/cpimd2h
And is the source of a squillion warnings if you ever do ruby -w on a decent sized codebase
So I this sent me on a web tangent. I find eigenvalues sexy, but could not see how they related to classes in ruby. So I assumed the eigen prefix must be bigger (I always thought it was some math dude's name or something). Googly googly and here you are http://en.wikipedia.org/?title=Talk:Eigenvector#Origin_of_the_term_.22eigen.22 
You are right, the architecture which you described in the first paragraph does not provide any separation between applications. And yes, Sidekiq may be an easier way, I haven't thought about it. But I wouldn't use DelayedJob to communicate between two apps, because it saves jobs to the database and I want to avoid sharing the database.
 return @value if defined?(@value) Obviously
Sidekiq is more than enough unless you are in need of fanout or topic exchanges. Actually, your concern could have been solved with topic exchange. Also, model sharing is a worst case scenario and not only in queueing. 
One thing that bothers me about this benchmark is that it uses different ORMs for each app which probably affects results (Sequel in Sinatra app and lotus-model in Lotus app).
No, it doesn't have an impact on the performance, but for me, it says something about the code ;)
Coincidence, just published a long post on [Ruby in Production](https://medium.com/@rdsubhas/ruby-in-production-lessons-learned-36d7ab726d99) that discusses some (but not all) of the items you've mentioned...
I can't help but you're not crazy. Been doing web dev for years and was completely confused by the whole ordeal. Nobody ever mentioned that party of Ruby. However, I was able to get everything up and running in a day on a DO droplet. Lots of Google, StackExchange, and luck.
No. The projects diverged significantly so ROM is ROM. No affiliation with DM anymore. There will be an article on rom-rb.org published at some point talking about the history of ROM as it deserves more than a sentence and it goes go back to initial ideas behind DataMapper 2.0.