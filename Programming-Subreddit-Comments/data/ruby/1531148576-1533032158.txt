Somebody asked about this a few days ago and they replied with an explanation and a working mirror: https://www.reddit.com/r/ruby/comments/8we90r/what_happened_to_tryrubyorg/
The image resizing isn't running in a web request context in this example so it doesn't really have any bearing on the choice of web server. It's fairly hard to find a good reason for using Unicorn today anyway, about the only reason you'll see it in use today is legacy. 
Hit CMD-K to clear your terminal and make a single request to the page of interest. Also disable asset logging via quiet assets gem in Rails 4 or the config option in Rails 5.
Ahh OK, I assumed near real-time meant in the same process as the web request.
Depends what you're trying to do. If your goal is to write your own graphics library, you'd probably want to study GL/DirectX (and you *could* do this in Ruby, search for "opengl ruby bindings"). But if graphics programming is your only goal, there's no time like the present to diversify your language choices and widen your toolbox :). On the other hand, for learning the foundations like data structures, Ruby can really help you out - for example, being able to [drop a REPL into the middle of an algorithm](http://pryrepl.org/) and experiment, or [drawing a graph of your data structure's state](https://github.com/glejeune/Ruby-Graphviz), are both hugely valuable learning tools. 
Like most things in programming, what seems to be hard at first eventually opens itself up organically to understanding. That is, if you take the time and effort to learn, implement with a bit of rinse and repeat. Things just start clicking. Rails is beautiful but it has a lot to it. A lot of "magic", as we like to say :D 
graphics being only one aspect to my goals as a programmer. I would like to learn to do things like input analysis and probabilistic states (or forecast) and so on for things like reactive ai. maybe nothing as complex as machine learning. I want to make games, that offer simplistic graphical interfacing. Something to represent the objects in the world, a setting and so on (i.e. uis and guis). I have heard lots of people say ruby is the worst thing to program a game in, but I'm honestly not trying to pick the best thing to program a game in, or I would obviously give up and learn C++/C# and use Unity. I think for simple entertainment purposes ruby will work just fine. Also I have resource investment in learning ruby, so I don't want it wasted and have to learn a completely different language with even more resource investment.
Try gosu
Graphics programmer here, yes you should stay away from ruby if you plan to program a graphics engine. My recommendation is to choose java/c++/C#. I've used all them in my line of work before. Ruby is great at lowing dev time, but its not for optimum performance with heavy real time environments. Even if you don't care about performance you should still learn the opengl/Dx 11(not 12) api, which I assume ruby has a wrapper library instead of a direct interface.
Echoing the support for fastjson_api or Jsonapi-rb, but if you're unable to go that route for right now, [simple_serializer](https://github.com/wmakley/simple_serializer) is a better replacement for AMS, until you can work your way toward a jsonapi.org compliant serializer
the graphics libraries I have tried in the past are written in some C related language, and then used as a gem for ruby. so ya likely not direct interface. I could look into opengl or DX for sure. are there any books you recommend? I mean I don't need to do graphics right away. There is a ton of data related programming that is necessary to play around with while I learn to be a better programmer.
Thanks for sharing this, very interesting read. Has anyone played with their docker image yet? I'm curious to see if it's worth setting up.
look up "physics based rendering" for theory and the "opengl superbible" for api on amazon.
Just use [thumbor](https://github.com/thumbor/thumbor) if you need realtime image resizing.
Except image format is limited
I don't recommend adopting AMS right now. The README even says not to use it, and I encountered numerous issues with it that forced me to write an API-compatible replacement after investing heavily in it. 
You might want take a look at [imgproxy](https://github.com/DarthSim/imgproxy) for on-demand processing. It's written in Go and uses libvips under the hood. I don't know if you want on-demand processing or processing on upload via a background worker. If you want to implement it in Ruby, I also don't think that the choice of the web server would make a difference. What's important is that you use a CDN for serving the images.
I like a clear left to right reading. number &gt; 0 and do_something or this ... number &gt; 0 and region == 'west' or begin multiple_actions() without_having_to() do_an() if_end_block() end 
Ruby2d or gosu are the easiest to roll with. There's a few others that are more complex and do more things though.
This same issue just came up for trying to access Google Drive through the API. I just spent a week trying to figure out why it works in PHP and not Ruby. It'll work in Ruby, just not on my desktop. Your response here is intriguing, and provides a path to go down for debugging. My workaround, in case I haven't mentioned it before, is to simply take one of the IP addresses and hard code it in /etc/hosts. Ugly, but gets me working again.
What advantage do you see in using Cucumber over plain Capybara + RSpec?
&gt; I think cucumber / gherkin style tests (we mostly use Turnip as the runner so it's more rspec-like) make the most sense if you actually have non- or less-technical people who need to read/write them. I would agree. If it's the case where you work that non-technical people demonstrate an interest in writing Gherkin test cases and they actually do it, then Cucumber could be beneficial over just using Capybara. Having said that, I've never worked anywhere where a non-technical person (or even anyone who's not a full-fledged programmer on the engineering team) has ever touched any of the Gherkin scenarios. The actual situation I've experienced is that the test suite ends up with this unnecessary layer of complexity on top of the tests when plain Capybara would have worked just fine.
I agree that Cucumber is very often misused. But this article completely misses the point. It's wrong to think of Cucumber as a testing tool – it's a collaboration tool. The aim should be to write examples that illustrate requirements in a way that can be understood and discussed with people who aren't developers. There's very little value to a scenario which says "Then I should see those details on my profile page". That might catch a bug in a code, but it doesn't help to explain any of the domain rules. It's far too abstract. [https://cucumber.io/blog/2014/03/03/the-worlds-most-misunderstood-collaboration-tool](https://cucumber.io/blog/2014/03/03/the-worlds-most-misunderstood-collaboration-tool)
I think your point is somewhat of a fair one. If the non-developer stakeholders in an organization want to be part of the process, and the developers and stakeholders collaboratively come up with specifications in the form of Cucumber scenarios, then I can imagine a situation that makes sense. The article you link is totally right that Cucumber is very much misunderstood. I can identify with Aslak Hellesøy's disappointment with creating a tool that ended up so popular and also so misunderstood/abused. On the other hand, think of this. Let's say someone invents a new kind of chisel that looks remarkably like a screwdriver. People see it and think, "Oh, this is clearly a screwdriver. I'll use it to screw some screws." Let's say thousands of people make this mistake. Does the mistake actually lie with the thousands of people who took a screwdriver-looking thing for a screwdriver, or does the mistake lie with the designer who designed a chisel that looks every bit like a screwdriver? That's a pretty crappy and contrived analogy, of course, but you get my point.
If the manual for the chisel tells you not to use it like a screwdriver then it's probably on the people using it wrong. The cucumber docs are pretty comprehensive in explaining BDD and even include a few anti-patterns.
Indeed. It's been mis-used for so long, that I'm not sure if it will ever really recover. And that's unfortunate, because I still believe the underlying concept is really effective. If I was starting a greenfield project today, my preference would probably be a \~80/20 split between pure Capybara and well-written Cucumber.
I have never seen a single case where a non developer interacted with cucumber scenarios in any way. The level of specification that's useful to product folks and other less technical stakeholders is not a level you can write tests at, in my experience.
Yeah, but for a long time cucumber-rails automatically generated web\_steps.rb which encouraged this kind of approach. [http://aslakhellesoy.com/post/11055981222/the-training-wheels-came-off](http://aslakhellesoy.com/post/11055981222/the-training-wheels-came-off)
I would take this one step further. On-boarding developers need documentation on the application's intended functionality. Trying to sift through lengthy test suites can be overwhelming. If I were on-boarding myself onto the apps I maintain at work, I would want to see a plain english explanation on what a feature is and what it does. I use plain RSpec and Capybara at work, which is awesome, but Cucumber could still definitely supplement it. 
Don't think of it as writing tests. Think of is writing documentation that can be continually executed and verified
At the risk of making an overly simplistic argument, Cucumber is lame for the sole reason that it's too hard to explain why it's cool.
I was fine with if vs unless till now and I think the article may have confused my understanding.
I'm not sure if I prefer the Capybara versions of the proposed Cucumber specs. To me, it feels like an attempt to make Ruby look too much like English. Compare with Minitest, which seems to do a better job of actually feeling like, you know, Ruby; your expectations are just methods on the things you're testing. Maybe I just don't like Capybara, or I'm more familiar/comfortable with Minitest. Regardless, though, I agree with the gist of the article. Even when Cucumber is used as intended, I feel like one would be better off keeping the English specification and its Ruby implementation separate (see also: README-driven development).
How does the “verify” part work if you can’t write the test to verify it?
Tell me more. What do you find confusing?
`and` / `or` are dangerous. The and and or keywords are banned. The minimal added readability is just not worth the high probability of introducing subtle bugs. For boolean expressions, always use &amp;&amp; and || instead. For flow control, use if and unless; &amp;&amp; and || are also acceptable but less clear. https://github.com/rubocop-hq/ruby-style-guide#no-and-or-or
...but Cucumber isn't just used for Ruby/Rails.
Came here to say this. Cucumber was invented to solve a problem -- that of getting clear specifications out of analysts (and if you had never worked in the waterfall days, you probably can't understand how big of a problem that was -- it was a colossal pain in the neck getting *usable* requirements out of analyst back then because they were always trying to optimize themselves and not the flow of the team). Since analysts often aren't developers, it needed to be English. To smooth out the transition, it needed to be English that could easily have QA code attached to it. It accomplishes all of those things. The problem is cargo culting, not Cucumber. People who don't understand the above (and the problem that it was trying to address) just use it because "Hey, look, the world seems to be using this tool, I guess I'll use it too." Cargo culting is some weird social phenomenon that is basically inescapable, so it's not like you can blame Aslak or Cucumber.
On the examples you provided in the blog post, I would definitely agree with you that Cucumber doesn't seem like a useful layer over just using Capybara directly. However, things get different when you're testing an HTTP API. I maintain [tus-ruby-server](https://github.com/janko-m/tus-ruby-server), an implementation of the HTTP protocol for resumable uploads. The [original acceptance tests](https://github.com/janko-m/tus-ruby-server/blob/f8869faae28f8b13891d2863c1b6dc8592799ac6/test/server_test.rb) were using a library similar to rack-test for making Rack requests. It was difficult to maintain, I didn't really know which test is testing what. So, I decided to [rewrite](https://github.com/janko-m/tus-ruby-server/commit/66c9d2ed9eeefb0942fd7e54eb766fe9a9d2006c) the test suite in Cucumber. That was a clear win for me, I was able to organize my scenarios much better and could easily tell what's happening. Even though I'm a developer, English is still the easiest for me to read. The Gherkin language felt like it was made for testing HTTP APIs, see this scenario for example: Scenario: Correct Upload-Checksum Given I've created a file """ Upload-Length: 11 """ When I make a PATCH request to the created file """ Tus-Resumable: 1.0.0 Upload-Offset: 0 Content-Type: application/offset+octet-stream Upload-Checksum: sha1 Kq5sNclPz7QV2+lfQIuc6R7oRu0= hello world """ Then I should see response status "204 No Content" And I should see response headers """ Upload-Offset: 11 """ Yeah, you could argue that I could have organized my Minitest tests better, in a similar fashion than the Cucumber scenario above. But there was nothing in Minitest (or RSpec) to show me the way. Having to categorize actions into `Given`, `When` and `Then` really helped shape my acceptance tests into something nice.
Your contrived analogy isn't reflective of what happened. What happened was cargo culting. So, a closer analogy would be this: You invent a chisel that allows non-sculptors to do half of the work of a sculpting marble figures, and the master finishes each sculpture. Your sculpture throughput increases dramatically. You decide to share your chisel and how to use it with the world. A bunch of other sculptors ignore your instructions about how to use it (divide the work into "the stuff the master does and the stuff her assistant does first") and start using it like any other chisel. They don't see the massive increase in sculpture output that you did, but they keep talking about this new chisel, and the telephone game starts. Before long, people are using the chisel to pick their noses, to start their cars, to clean the toe jam out of their big toes, to break into houses, and all kinds of other things that it wasn't supposed to be used for. Eventually someone 50,000 phone-calls down the telephone game says "Hey, this masters' chisel seems to slow me down when I'm sculpting." BUT IT ISN'T A MASTER'S CHISEL. It never was!! Then, someone writes a blog post about how this chisel is a piece of crap compared to their favorite masters' chisel.
I have. A well known Fortune 100 company does this every single day. To make it work it required that developers spend a few months building out the underlying code to support the various things that the requirements and business people wanted to be able to say, but after that they just write specs nonstop, and those become the "failing tests" that developers use each and every sprint.
It's a DSL. If you're using it properly, the underlying code that supports the DSL sits at a 95% state of completion all the time (each sprint closes the gap as necessary). So you *can* verify it yourself (as a non developer), about 95% of the time.
&gt;For something that's supposed to help with semantics &amp; collaboration, it sure gets misused an awful lot. I think you had to live through the waterfall era to appreciate the problem it's trying to solve. Since we're mostly past that era, folks can't remember what a nightmare 1,000 page "randomly formatted" specification docs were like.
It seems like what you're saying the root of the problem is is that people ignore the instructions. As far as I can tell, you're right. Cucumber was meant to be used one way (a collaboration/design tool) but it was used a different way (a testing tool) because people ignored the instructions and misused the tool. I've experienced a similar problem with UI designs during usability testing. I would design a UI on paper and then give it to someone to try to use. They would mess up or get stuck, and I would think, "dumb user!" Then I would test it with another person and they would get confused in the exact same place. Same with the next three people. I would eventually realize "Oh crap, if EVERYBODY misunderstands this UI, then it's not that they're dumb, it's that the DESIGN is dumb." So I would redo the design and the problem would go away. Another parallel is the one I used in my article: a push door that looks like a pull door. Yes, the door says "PUSH" on it, and people "should" read the sign. But most people don't operate like that, and most people end up pulling the door because it looks like a pull door. Whose fault is it that the door gets misused? The people who "ignore the instructions" or the person who put up a door that looks like a pull door but is really a push door?
Cargo culting != bad user interface design Cargo culting happens for social reasons ("I want to be just like the Joneses, but I don't want to do the things the Joneses did to make that happen.") Bad UI design happens because things aren't properly prototyped and tested. There's no way to "properly design" away the tendency for people to force their kids into college (with lots of student debt and so on) even though there are perfectly good jobs in the industrial trades. THAT is an example of cargo culting. The same thing happened to Cucumber, and 1000 aspects of the agile adoption movement.
I can see your point, and I would agree with some of that stuff.
Let's make those steps look like a real test framework. Given /^I am signed in$/ do visit(SignInPage).login_from_fixture end And /^I provide my name and age details$/ do visit(EditUserPage).populate_and_save end Then /^I should see those details on my profile page$/ do visit(ProfilePage) do |page expected = data_for 'profile_page' expect(page.full_name).to eq(expected['full_name']) expect(page.age).to eq(expected['age']) end end 
I apologize if I’m out of line by saying so, but why is there such a proliferation of articles on this sub trying to convince users to go to other languages like Crystal and Elixir? I’m here for Ruby discussion, tips, and projects. I want to use Ruby, not Elixir. 
The problem described in the article is what is known as imperative versus declarative tests. Developers seem to have a tendency to make tests imperative, ie describe -how- they are achieving something, not -what- they are trying to achieve. Cucumber can be a great tool to describe your domain knowledge/business logic. These can be read, understood and even verified by your domain experts. It also helps new developers get up to speed with the domain and its complexity without being overwhelmed by the ‘accidental complexity’ of infrastructure and implementation choices. There are a lot of good heuristics for useful cucumber scenarios: when they mention stuff that deals with an api choice, or buttons, or data structures etc then you are describing implementation choices, not your domain. When your cucumbers only use domain language and describe the ‘essential complexity’ of your domain then they can be hugely beneficial, in my experience anyway
people tend to show how cool is the new toy that they are using. Is like on javascript where there is a plethora of frameworks, building tools, etc. Same with elixir or go, or kotlin, or whatever. You pack it nice and show people how nice it is. If elixir is better than ruby or not, have no idea, never try it :)
are graphics dependent on OS?
I get where you’re coming from, but frameworks, libraries, etc are all built on top of their mother language. If someone was gushing over a new Ruby framework that they fell in love with, that’s understandable. But this is advertisement for another language. Elixir may have been influenced by Ruby, but it’s not Ruby. I feel like there are better subs for this article. To put it another way — would people on a C++ sub want posts evangelizing Java?
Consider this post to be a Ruby tip if you like. It’s not trying to convince you Elixir is a better language. Learning a language like Elixir will make your Ruby code a lot better. I understand that people feel very protective of the language/framework they use, I know I did. But that’s wrong. You can learn so much from what other languages have done. 
I don't think you are out of line..this is getting annoying. And it definitely shows something about elixir lack of adoption if they have to keep doing that...
Ok why not try to get java devs write better java by introducing them to elixir? Or Haskel? Or PHP? It's always elixir fan boys trying to get ruby devs to make the switch because "one million concurrent connections"... whatever...
I too have read the cucumber book. I still haven't found a use for cucumber over well maintained rspecs.
This issue happened again to me (and a coworker which was nice for replication purposes). Killing nsurlsessiond did not help this time and so it is probably a red herring. I also tried your /etc/hosts workaround and it didn't help me. My coworker solved the problem by switching his wifi to a hotspot temporarily and then switching back. I solved it by disabling my ipv6 connection by switching "Configure IPv6" to Link-local only. Also, I noticed that both cnn.com and api.rubygems.org use Fastly as a CDN. Testing this error with other CDNs might be useful.
Yes, so far directX is only on Windows, opengl has support right now for Linux, Mac, and Windows, but Apple has depreciated opengl(ie won't plan on supporting it). Opengl versions depend on various types of graphics cards and we use loading libraries such as glew or glad to load the correct version for each computer. It isn't as complicated as it sounds, but it is something to be aware about for writing shaders. 
I am not a fan of cucumber, but it's worth learning and understanding BDD before dismissing it.
Just had a big talk with an Elixir dev about how adoption of Elixir and Phoenix in businesses and startups has already waned. Many startups are still using Ruby and Rails. There are plenty of these articles and Elixir can do a lot. What it can't do is help people get jobs.
For context - I also organize the ElixirDaze conference. Interest in the language itself has also grown cold since we first started doing it.
It was originally known as RSpec Story Runner, so much of the early adoption was in Ruby projects: [https://github.com/dchelimsky/rspec-stories](https://github.com/dchelimsky/rspec-stories)
/u/jasonswett I've condensed my counter argument here: https://www.reddit.com/r/ruby/comments/8xsbyu/the_real_value_of_cucumber/
Your problem is with how Windows manages files and reports disk space, not with Ruby. Depending on how your virtual memory is managed, it could just be that your system is using all empty space as swap space. Run disk cleanup and defragment your drive, perhaps. 
\&gt; But that’s wrong sigh ...thats the whole problem with this thread. waaaay too opinionated and fan boyish "why you SHOULD learn Elixir" and now "but thats wrong" in answer to wanting to talk about Ruby in a ruby section NO YOU are wrong. I frankly cannot stand that about the Elixir community. Just too full of themselves for an language that so far has not produced much apps. No I don't have to learn Elixir. I can dip my toe into functional languages without looking at Elixir and no I don't have to learn elixir to make my code better I can study desing principles and learn from labuages that are not merely a wrapper over Erlang so will NEVER have wide usage across all platforms. It s time for Elixir to grow on its own. Its done too much cannabilation off the Ruby communityand now needs to stand on its own two feet. Unlike Crystal its not an extension of Ruby ( I know other might disagree but given the similairties its hard for me to call Crystal an entirely different language - neither am I saying they are the same) but something entirely different. 
I totally agree with you on elixir but think Crystal is a sister to Ruby. You can copy ruby code to crystal and it works with a few tweaks (sometimes ZERO tweeks are required). I definitely feel I have left ruby when coding in elixir (for a small test app) but feel like I am just coding in another version of Ruby when I am coding in Cyrystal.
100&amp;#37; agree. Using Cucumber as a specification tool first, and a testing tool second is the best strategy I've found to being effective with Cucumber. Unfortunately, it's hard to see the benefits of this with small examples, as the benefits really come when specifying the behavior of an entire system. You can make the best case scenario in this article a more effective specification like follows: ``` Background: Given a signed in user Scenario: Profile details Given the user has provided their personal details (name and age) Then the details are visible on the user's profile ``` The example in the article was too focused on how things happen, when all that is really being specified is that a user's personal details appear on their profile. How they provided the details is another scenario and specification. Implementing specifications like this can be daunting at first because they aren't very reusable, but I've found that it actually becomes *easier* to implement steps when all pretense of "step reusability" is thrown out. Cucumber doesn't provide very ergonomic ways to reuse steps, so just skip it and do it in Ruby with objects and methods. I've found this to lead to cleaner test code.
I've already tried that. The thing is, I had exactly the same disk size right after deleting the folder, so it appears as if it hadn't been deleted at all and I had TreeSize open at the same time, so I was checking if anything else had taken up the space (nothing else increased after a refresh).
IMO the Elixir community missed a big opportunity by making Phoenix the centerpiece of their marketing efforts. It led organizations to make a Rails vs. Phoenix decision, but unfortunately, most Rails shops have invested _so much_ in their Rails monolith that a rewrite is off the table. This is a problem for _anyone_ endorsing tooling for the Rails (and by extension Ruby) community. Ultimately, Rails shops are not worth wooing, they're generally long past the point where they can consider other languages or architectural styles. I've heard the same thing from so many people at different companies: "we dabbled in Elixir, we liked it a lot, our auth service is actually written in Phoenix, but it hasn't really caught on beyond that." (substitute "auth service" for any other smallish peripheral concern)
Seems like our views have some overlap, some not-overlap. I mostly wouldn't disagree. There's something I don't think I did a great job of articulating in my article. What I wanted to refute was the following pattern: "I'm just getting started with testing. What should I learn?" "You should learn RSpec, Capybara, and Cucumber." I don't think Cucumber should be seen as part of the set of de-facto standard Ruby/Rails testing tools. But if a team truly understands and properly uses Cucumber, I certainly don't mean to say that I think they should stop using it.
It's a common wall that people hit because while doing basic tutorials like Codecademy are a great starting point, far too many people make the mistake of thinking "completed JS course" == "I know JS". These tutorials are great at teaching the basics of syntax, but they don't dive into higher level abstractions and concepts like those you listed above, which are necessary to work on serious software projects. Keep at it, ask questions, and don't be afraid of the difficulty. Everyone started from zero.
That might be true, but I've seen it used on almost everything.
oh wow thanks for the information. I'm not certain I want to make a Web-platform game, or would WebGL work for standalone application? I could look into Javascript at some point. But I have just spent a few bucks on a ruby specific OOD book to help me improve how I make code. I imagine you would need to know the drivers a bit for using OpenGL? 
Calling File.write in a loop is a bit silly. Won’t it be opening writing closing the file each iteration?
I've been asking myself the same questions for years, the same goes for many conference presentations. You don't see that same trend on the python community for instance.
Who will be the first to write a C extension for this? [class2](https://github.com/sshaw/class2) and FTW!
Why would anyone use `else` within a begin/rescue? Serious question because I've never heard of that even being a thing. 
they are dangerous, yes, but so are plenty of tools in the hands of those who do not know how to use them properly. While I use them sparingly, in my opinion you should not completely remove the tools from your arsenal just because the author of rubocop says so.
physics based rendering seems more applicable to 3d engines. I'm just aiming for 2d. is it really necessary?
&gt; Consider this post to be a Ruby tip if you like. No, it's an advertisement for another language. I just re-read the article in full, and I see no tips for Ruby development. Even if I'm generous and consider the "tip" to be "functional programming is good to learn," I see no points in your article that illustrate why functional programming helps me. You do list at the end a few reasons why functional programming is beneficial... in a language focused around functional programming. At no point do you let us Rubyists know why functional programming "can transform the code you write in your OOP language of choice." &gt; I understand that people feel very protective of the language/framework they use, I know I did. You're reading into my post what isn't there. While I primarily enjoy using Ruby, I'm also learning JavaScript and C++ on the side for various applications. My chief complaint is that this is a Ruby subreddit, and I come here for Ruby discussion. Your article does not offer Ruby discussion -- you simply offer one section where you compare Elixir code against Ruby code, and one section labeled "Elixir for Rubyists" where you extol the virtues of Elixir while only mentioning Ruby once (and only then to note the syntactical similarities).
I agree with you for the most part. When I look at Crystal articles, it's pretty clear that it's like Ruby's stricter sibling. I think I'd still be against articles that are purely evangelizing Crystal over Ruby, but there's more value in dissecting what Crystal does differently from Ruby since the two are so similar in concept and execution.
This happens at conferences too? =\\
It makes sense that they'd try to replicate the success of Rails, but you're right; I think a better strategy would be to find another niche that is underserved and cater to it.
I'm assuming the else in a begin rescue is like a try/catch? I haven't rubyd in a long while. If so they are useful when doing nested exception handling across method calls, especially when handling a base exception class and a custom exception subclass that you write (ex a runtime error and *your* custom runtime error). Haven't written many but there were a few pipeline systems written in Py2 I had to maintain a couple years back that extensively used that scheme and it worked relatively well.
Is a somewhat obscure feature, basically, the else block is activated in case no exception is raised.
&gt; I think I'd still be against articles that are purely evangelizing Crystal over Ruby, If Crystal gets to 1.0 any time soon I am afraid you are just going to have to live with that in some cases. Unlike elixir Crystal goes well beyond the web/networking and is aiming to run on multiple platforms and devices. So it would be better than traditional Ruby in those cases where Ruby is unlikely to ever be good at. This would be a boon **FOR RUBY DEVELOPERS** and unlikely to not come up in Ruby communities and discussions as the benefit of extending prexisting Ruby syntax to all manner of diverse kinds of apps is just too compelling to ignore and not incorporate into the Ruby experience. 
WebGL runs out of the box on any browser, and I've transmuted c++ and normal opengl to the web before. It wont have any internal dependences like glew, but will have similar external dependences such as a font library, but its the quickest start to create moderately fast web graphics program. You won't need to know anything about the drivers as modern opengl versions are backwards compatible down to 3.3. The reason its important to know for shaders is that as you develop the functioning version of opengl changes for the shaders so if you wrote shaders for 4.5 and it doesn't work but it works for 3.3 we know that there problems with compatibility with newer versions. 
Yes, i should of read your comments better, but opengl works for any dimension of graphics. I don't know of a 2d graphics book.
Hey, Anotheravailablecant, just a quick heads-up: **should of** is actually spelled **should have**. You can remember it by **should have sounds like should of, but it just isn't right**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Empty the recycle bin?
Thanks! That's helpful, but off the top of my head I'm having trouble thinking of a case where it would actually be useful.
Here's a use-case, in Rake https://github.com/ruby/rake/blob/124a03bf4c0db41cd80a41394a9e7c6426e44784/lib/rake/cpu_counter.rb#L17-L26 (Not of an `else` without `rescue`, but of an `else` within a `begin/rescue` block, as you asked.) It requires `etc`, and continues if that doesn't work, and if it does work it uses the required module. It could do the same thing by putting the `else` logic right after the `require`, but that's a matter of taste.
who's Marco?
See also https://github.com/dry-rb/dry-initializer
I assume I would need to know rails, and I don't. how hard is learning drivers?
I don't see it like that. I think Phoenix drew *people* in (myself included), and it showed them a new way of doing things (with Elixir). I don't really care if it made more sales for Rails shops or not. I care that it made me learn something new. It changed the way I look at programming for the better.
&gt;What it can't do is help people get jobs. Sure if that decides why you're learning a new language, fine, go with something more popular. I don't care about getting hired, I care about feeling good about the tools I'm using. You could say the same thing about Haskell, Elm, etc. but that doesn't mean you shouldn't use them.
Learn them, sure. Use them without practical reason? On what?
The more languages that you know idiomatically, the better a developer you're going to be in your language of choice. Ruby is my language of choice, and has been for almost ten years now. But I've been paid to ship code in *dozens* of languages over the last 39 years (and counting). Each of those has informed my way of thinking about any code I later write. If you're not continually learning new things (in our craft, especially including new languages), you're quite likely obsolete. That observation isn't in any way original; the earliest phrasing of the idea I've personally read was from Knuth, and he (separately) implied that it wasn't original to him, either. So that takes us back to what, the 1950s? *Never* stop learning.
I don’t disagree with your post, and I am in fact learning JavaScript and C++ as well as using Ruby as my language of choice. I’m also learning brush calligraphy, practicing my art skills, and learning how to reverse-engineer binary formats for fun. I’m definitely not trying to avoid learning. But I’m in a Ruby subreddit. There is a place to evangelize for other languages, and that place is not here. The post would be better in a more general sub; if the author’s goal is to point out how it’s similar to Ruby’s famously casual and easy-to-read syntax, why not try r/learnprogramming? That sub is also great if the author thinks new programmers should cut their teeth on functional programming. If you poke around this thread you’ll see my issue with the article is only that it does not belong here. I have no other major critiques of it, only that it should not be in this sub. In fact I am interested in trying Elixir now, the article did its job well. But it does not belong in r/ruby. 
Why would you not just put the code in the else branch before the rescue statement?
Internal projects, fun projects, SaaS products for yourself or your clients. You can choose your own tools when you're not told *how* to do your job.
Like others, I'm really exhausted with all this Elixir stuff flooding Ruby communities. But your points don't really stand up in the real world. I'll tell you why I think so: &gt; Internal projects I wouldn't let my employees write an internal app in Elixir because then I'm stuck with a language that has poor adoption, especially compared with the other developers who are _also_ ruby developers because I hire _ruby_ developers. &gt; fun projects Okay, that's fine. &gt; SaaS products for yourself or your clients. Elixir/Phoenix doesn't and won't ever have the ecosystem that Ruby/Rails does. It just won't. Ever. Yes, Phoenix is MVC, but that's not a selling point of Rails. A selling point of Rails isn't speed either or scaling (and it scales just fine); it's the mature ecosystem and community that allows people to whip up production-ready _stuff_ in a short amount of time, and it's possible because the ecosystem is just that. * Need to parse strings into time objects? Chronic. * Admin scaffolding? ActiveAdmin is great! RailsAdmin isn't bad either. * Slick API DSL? Grape. * Record versioning? PaperTrail. * Really cool form stuff? SimpleForm. And those are just the things that you end up adding sooner or later that you totally overlook when starting internals or SaaS things. They're not on your initial list but sooner or later you go "well now I need to add that" and bam, it's there, and it's battle-tested. I'm not saying Elixir/Phoenix is terrible. I realize there's chicken vs egg but a lot of us are just fine with already having our tools in place. It just feels like a pissing match.
Yeah, I'm trying very hard to think of a case where my `before` could work out, but I wouldn't want that code in the before block...
You're right, that would open and close the output file for every iteration. Updated the article to open the output file before running over the lines in the input by wrapping the loop in a `File.open` block. Thanks! irb&gt; File.open("upcased.log", "a") do |output| irb* File.foreach("production.log") { |line| output.write(line.upcase) } irb&gt; end =&gt; nil
Yes please
Very eloquent way of putting what I was thinking while reading the other article :)
Man I really enjoy Rails but this is like saying repeating yourself "everything is fine" in loop
It's not there, I also shift deleted the folder so it would've been deleted immediately.
If all that were true, no one would've adopted Rails back in 2008 :) I got onto the Rails train back then because it felt right, not because it was popular. Same thing with Elixir. I'm not saying you should do the same. But I know I am.
I use it in retry logic for specific http codes `while (retry_number &lt; max_retries) do` `yield` `rescue MyException =&gt; e` `log e` `else` `break # allows us to exit retry loop if everything is ok` `end`
Well, you're obviously right, but after all those buzz that "Ruby is dying", it's nice to a see a ray of optimism.
Agree. Moreover if there’s anyone who’s gonna say s’all good man that is the ruby creator. 
&gt;In Rails 5.x, there is no static .uniq method for ActiveRecord::Base class. You can still use the method `.distinct` though to achieve the same result in 5.x.
My Favorite: [http://api.rubyonrails.org/classes/ActiveRecord/Batches.html](http://api.rubyonrails.org/classes/ActiveRecord/Batches.html)
Do you have an explanation for why the handwritten initializer is not the fastest one?
Why wouldn't you just put it after the `yield` where it's still reasonably close to the loop condition? max_retries.times do yield break rescue MyException =&gt; e log e end That's a lot easier to follow even without letting Ruby count for us - the normal flow just *flows* instead of being obscured down below an exception handler.
The basic structure is: begin some_code rescue SomeException handle_exception else more_code end So the question is, why not: begin some_code more_code rescue SomeException handle_exception end Which feels like it should do the same thing. The answer is: We want to use the first structure if `more_code` might also raise `SomeException`, but we do not want to handle it locally. For example: begin open_file rescue IOError puts 'File not found' else read_and_parse_file_content # if and IOError occurs here, the file opened succesfully, but something went wrong reading it. # Perhaps the file is corrupted and we're trying to read past end of file? # Or perhaps the device has become unavailable? # Anyway, we might want to just allow this exception end This may be rather obscure, but it is a valid use case. 
Fair point. I think the given/when/then syntax is useful for thinking through invariants and behavior. It does force people who are new to a practice to use a 'script' to think through what they are doing. So I do think it is a good practice for people who are low on the Dreyfus Model scale to learn how to specify what they are building, before they build it. That said, like many skills, it can be tough to learn beyond the basics without a mentor.
Thank you, there is a robust discussion going on in the other article. The author, /u/jasonswett, highlighted that his piece was partly to caution against just learning Cucumber just because it is a thing and that you should look at it critically. But I do think people overlook the value of thinking through what you will build before you build it. Its not waterfall, it is just thinking first.
I should note that I was speaking from a marketing and adoption perspective. Your personal experiences are certainly well taken, and I can see how learning Elixir can be valuable to programmers who haven't otherwise been exposed to some of it's underlying ideas, but the kind of experience you're describing simply isn't sufficient to build a healthy programming language community around.
Because you only want to rescue errors from precisely the `require`, not any other logic. I know they're rescuing a fairly specific error, but it's a smaller scope this way which is generally thought of as being better.
The code in the `else` isn't in the scope of the `rescue` clause - that's why.
Yeah, was thinking you'd only get a `LoadError` from the `require`, but I see your point.
Yes. It uses keywords and my code generates an initializer that takes a Hash of options. Turns out keywords args are a bit slower then hashes. However I figure most people would use keyword args. So that’s why I benchmark it against that style.
&gt; Its not waterfall, it is just thinking first. Well stated, and broadly applicable :)
&gt; If all that were true, no one would've adopted Rails back in 2008 :) Rails was one of the first MVC frameworks that wasn't written in PHP. It was 2008. People were just starting to adopt web frameworks. People didn't really want to write PHP. I was one of them.
Hey Op, if you're the author of this, in the Sum section the article uses an Order model as an example with Client model SQL as the result. That sudden object switch might confuse people. Mostly because the Order example uses a :total column and the generated SQL uses an :id column. 
The fact the hype is gone doesn't mean it's not a living language. The improvement boost between 2.5 and 1.9 shows the ability of ruby to keep hanging.
Good article. I learnt a couple of things. 
One should note that Arel is considered private API and may change without notice.
JavaFX seems to be dead even for Java devs, I'd be surprised if this gets any responses here. 
This has been said before, but Arel interfaces are starting to crop up in the API documentation e.g. [here](http://api.rubyonrails.org/classes/ActiveRecord/UnknownAttributeReference.html). I'd question whether Arel is likely to change substantially in future. In practice, it is so stonkingly powerful and expressive (especially when building reusable or composable relations) that in the last few years I've not written a Rails app of substance without reaching for at least a little Arel, and sometimes a lot. 
Sure. I just wanted to make people aware of it. For example `arel_table` (used in the article) is set to :nodoc: since it’s considered private. https://github.com/rails/rails/blob/master/activerecord/lib/active_record/core.rb#L254
I don't consider it private. I take it out in public and no-one complains. The reasoning for the :nodoc: is pretty weak: https://twitter.com/tenderlove/status/527605594866204673. 
Or you can just use Sequel for a much more elegant API.
&gt; Rails magic, which I personally hate (hello to ROM and all dry-rb stack), begins in clear_attribute_changes, which removes changed comments_count from Dirty attributes You hate dirty-tracking until you need it, and then you're really glad it's there! If you really don't want dirty-tracking, and the ensuing overhead (performance or conceptual)... I am not sure if there's a way to disable it in AR. Would definitely make sense to let you disable it. But you're going to miss it. :)
Cheers. I think Ruby is a wonderfully expressive language. For me, that is what makes it fun to program in.
they have said that, but it's not a good idea. And apparently they're having trouble sticking to it. Give ARel examples in the docs _and_ don't worry about breaking them on a minor release, heh. You can do _so_ much more with ARel. With AR without ARel, there are things you simply can't do. Once you put Arel into the mix, there's pretty much nothing you can't do, in a nice composable db-independent way. 
Plus, you can't deny that it just looks pretty.
Quick scripting is one of Ruby's best uses. It has a lot of great useful shell'isms
I KNOW RIGHT?! I never knew I could feel love for a programming language, but here we are. 
THANK YOU. 
Ruby loves you back.
The weird thing is that ARel has predicates and nodes that aren't exposed in ActiveRecord at all, like `distinct_on`, `gt`, `matches_any`, even CTEs &amp; window functions. How many CPU cycles, how much application server RAM has been chewed up by people who pulled lots of records onto the Ruby heap for manipulation, when the database could've done it more efficiently with a nice Arel-formulated query? It's tragic, really.
I love SeeingIsBelieving. My full installed list is A File Icon, DashDoc, Git, GitGutter, Ruby Slim, SeeingIsBelieving, SidebarEnhancements, Better CoffeeScript, HTML-CSS-JS Prettify, Pug, Sass, Vue Syntax Highlight. Obviously not a Ruby specific selection, but all in use with my Rails projects. You might want to consider a different font as well. I fell in love with [Go Mono](https://blog.golang.org/go-fonts) when it came out, haven't looked back. 
If you like ruby, you should definitely try crystal. All of those benefits, plus static typing and C/C++ runtime speeds
I don't use many, currently I have the following installed: Emmet - Helper for writing HTML. Fold Comments - Collapses comments with a single key binding. TrailingSpaces - Highlights trailing whitespace.
And the community! Matz is nice, so we are nice. 
Crystal website [https://crystal-lang.org/](https://crystal-lang.org/)
Shut up
I started career as a Perl developer, and for me Ruby is like Perl, but more expressive and with OOP. I like both of them :)
Use \[sequel\]([http://sequel.jeremyevans.net/documentation.html](http://sequel.jeremyevans.net/documentation.html)). Really, if you want to have all the ORM conveniences while also having an efficient, powerful and compliant query builder, you should be using it. Since the article is only talking about the query builder capabilities, I'll only talk about those. AR's query builder DSL catches up slowly. They've only recently added the #or or #left\_outer\_joins options (rails 5 only), while sequel has had support for it for +5 years. Still waiting on "greater than" or "lower than", multi-insert or even upsert support (again, sequel supports this). For the "you have ARel for that" camp, I'll just repeat what has already been said in the thread: it's not a rails first class citizen (it's private API). Also, it's excruciatingly hard to write a complex query in ARel compared to writing it in pure SQL, with no gains in performance (too many objects to generate a SQL string). In fact, I'd argue that it's better to install sequel \*\*with\*\* AR, generate the SQL with sequel and pass it to AR's \`find\_by\_sql\` (I've done it once for multi-insert). For the "AR comes with Rails, so it's convenient", I'll leave you with a guide that helped me install sequel on rails some time ago (it was for a rails 4.2 application, but it should be fairly similar to adapt to rails 5): [https://gitlab.com/honeyryderchuck/templates/blob/master/rails/how-to-load-sequel-in-rails.md](https://gitlab.com/honeyryderchuck/templates/blob/master/rails/how-to-load-sequel-in-rails.md) hopefully it lowers the barrier for the interested. I'll also recommend you to \[read Sam Saffron's blog entry about AR\]([https://samsaffron.com/archive/2018/06/01/an-analysis-of-memory-bloat-in-active-record-5-2](https://samsaffron.com/archive/2018/06/01/an-analysis-of-memory-bloat-in-active-record-5-2)), where AR's memory bloat is discussed. The Discourse team has been solving performance bottlenecks by replacing AR's "convenience" with handmade SQL statements.
Ruby is my favourite at the moment, I mean implementations like this are just pure pornography: 0..10.each{|i| puts i if i&gt;5}
Especially in Monokai
That range needs to be in parentheses (0..10).each{|i| puts i if i&gt;5}
No it doesn't
Thanks for the lesson, but your code is going to try and create a range from 0 to the result of 10.each{|i| puts i if i&gt;5} ... however as 10 is not an Enumerator (it's an Integer), it's not even going to have an each method and the code will fail. You said yourself that you rarely need parentheses in ruby, well this is one of those times when you need parentheses.
Before you make yourself look like more of an idiot, open up irb and run my code. I assure you it will work
 irb(main):001:0&gt; 0..10.each{|i| puts i if i&gt;5} NoMethodError: undefined method `each' for 10:Integer ... 
Well shit, I hold my hands up. I confused being able to define a range with no parentheses: range=1..10 range.each{|i| puts i if i&gt;5}
Maybe you should take your own advice. .. is an operator, just like +, -, %, &amp;&amp; etc. Would you expect this to tell you whether 3 is even? 1+2.even? I assume you can see that would not work. You'd need to put (1+2).even? So for the same reason, in your example, you need parentheses. 
I apologize, see my comment below
Parenthesis in Ruby are usually optional _unless_ they are required to clarify the order of operations, which is why they are needed in this case. 
All good
&gt; What it can't do is help people get jobs. Not true in my case. I've gotten Elixir jobs because I'm one of the only people in my area who are visible writing it. But... a lot of the work I see is from Rails shops that used a client as an experiment to learn Elixir. I really don't like this trend.
I don't want to disable dirty tracking in AR. What I wanted to say is that the hole approach of AR has a lot of hidden magic. ROM.rb (and object mapper in general) is more clear and easier to understand and maintain.
Meh. When I was last using it, sure it was less than ideal, but everything else just straight up didn't work or was impossible to debug and get producing something reasonable-looking. Maybe that's changed now with that new library, that would be great. But calling it "harmful" is a drastic overstatement.
Does ROM.rb have dirty tracking? Without "hidden magic"? How does that work?
Wow - thats kinda aggressive.. Especially for something thats provided to you for free. PDF is complicated to say the least and there is a reason there are so many commercial products out there for handling PDFs. The post includes some explanation as to why the PDF format is complicated. &gt; PDF is an ancient format, as old as the Web. It was introduced in 1993, though at the time it was proprietary to Adobe and not really open or popular. It became an open standard in 2008 when Adobe relinquished control, but it took till 2017 to release a standard that does not reference any patented or proprietary technology. [..] The post recommends a library, `weasyprint`, written in Python, but barely mentions why thats better. I'd much rather read a post that explained the benefits/trade-offs of other libraries in more detail, than just bashing `wkhtmltopdf`. I've used `wkhtmltopdf`, while not perfect, it certainly got the job done. 
I wish bloggers would give up on that terrible title meme. Makes me cringe every time I see it, complete turn off
Path separators might be wrong it’s \ on windows as opposed to / on *nix
The necessary ["Considered Harmful Essays Considered Harmful"](https://meyerweb.com/eric/comment/chech.html)
Maybe `(6..10).each {|i| puts i}` ;)
That shouldn't matter.
+10 NIM u/NimiqTipbot 
I love how they admit at the end that they are using wkhtmltopdf anyway. So clearly for all the bad points it is still the best option available.
I tried both ways already :/ :/
I was once excited about Arel as well, but switching to Sequel made me realize how much it would be easier to use if AR had virtual rows ([Squeel](https://github.com/activerecord-hackery/squeel) was an attempt to bring it to AR, but was never merged). To illustrate, with virtual rows you can rewrite Country.joins(:people).where(Country.arel_table[:gdp].gt(100).or(Person.arel_table[:birth_date].gt(Time.now - 10.years))) into Country.joins(:people).where{(countries[:gdp] &gt; 100) | (people[:birth_date] &gt; Time.now - 10.years)} I now find Arel far too verbose to be considered useful, as /u/honeyryderchuck already said.
**might**
Yea it's not a great experience but it's the \_best\_ option out there as far as I know. I have heard of some people using a javascript type of library. [https://parall.ax/products/jspdf](https://parall.ax/products/jspdf) I haven't used it myself but I just know of it.
You probably don't need `self` as the first argument (this isn't python). Try this: @background_image = Gosu::Image.new("C:/Users/Staff/Documents/flappybird.png", :tileable =&gt; true)
This should totally solve OPs issue. I had the same problem when I was using gosu for the first time, since older documentation used self in front
GitGutter and GitSavvy. The second one adds UI for managing branches and commits from within Sublime, if your workflow requires a ton of branches like mine, it's pretty useful. It also has resets, reflogs, blames, diffs, stashes, whatever else. The rebase UI is a bit weird, but I don't use it anyway so whatever. Also ColorHighlighter and Indent XML (I use to have to work with random XML files sometimes so it's useful to be able to read them like a human)
Matz is nice,so we are nice!
I think you regret this comment now :D
I tried this and it wasn't working! :/ :/ It's the reason I tried it with Self
Some I can't live without: - [Git](https://packagecontrol.io/packages/Git) - [GitGutter](https://packagecontrol.io/packages/GitGutter) - [Git Conflict Resolver](https://packagecontrol.io/packages/Git%20Conflict%20Resolver) - [GitSavvy](https://packagecontrol.io/packages/GitSavvy) - [DiffView](https://packagecontrol.io/packages/DiffView) - [FileBrowser](https://packagecontrol.io/packages/FileBrowser) - [AdvancedNewFile](https://packagecontrol.io/packages/AdvancedNewFile) - [Click To Partial](https://packagecontrol.io/packages/Click%20To%20Partial) - [Rails Latest Migration](https://packagecontrol.io/packages/Rails%20Latest%20Migration) - [Rails Migration List](https://packagecontrol.io/packages/Rails%20Migrations%20List) - [RuboCop](https://packagecontrol.io/packages/RuboCop) - [SublimeLinter](https://packagecontrol.io/packages/SublimeLinter) - [TrailingSpaces](https://packagecontrol.io/packages/TrailingSpaces) - [Emmet](https://packagecontrol.io/packages/Emmet) And as a theme: - [Boxy](https://packagecontrol.io/packages/Boxy%20Theme)
Try a relative path to the file. I suggest putting the image file in the same folder as your game file. (Then later organize and put all images in a subfolder). Gosu::Image.new("flappybird.jpg", :tileable =&gt; true) should work after that. If not, make double sure the filename is spelled correctly, e.g. jpg vs jpeg.
I just downloaded the gem and the following worked for me (based on the tutorial [here](https://github.com/gosu/gosu/wiki/Ruby-Tutorial)): require 'gosu' class Tutorial &lt; Gosu::Window def initialize super 640, 480 self.caption = "Tutorial Game" # @background_image = Gosu::Image.new(self, "F:/media/background.png", :tileable =&gt; true) @background_image = Gosu::Image.new(self, "C:/Users/Staff/Documents/background.png", :tileable =&gt; true) end def update end def draw @background_image.draw(0, 0, 0) end end Tutorial.new.show Is this on a work machine? There could be some weird behavior because of that. IT departments can be pretty strict about what happens on company machines.
Is it really a png? Like did you download it from the web? Do you have show file extensions on in windows? Maybe it‘s .png.jpg. Can you scan the directory it is in using the shell (eg. the `dir` cmd command?). Since in your example your username is staff, is this the username you execute ruby with? Or does it belong to a different user (eg a Permission problem?). Does your folder or any folder in between have whitespace in it‘s name? Is your ruby script on the same drive?(eg C: not D:)?
Personal favorites include: * SideBarEnhancements * StringUtilities * GitGutter * BracketHighlighter * Alignment * AlignTab
Thanks, I'll try this soon as am back
Hmm I'll check these, thanks!
I don’t use windows but perhaps the slashes are pointing the wrong direction?
i used your solution and it return ["abce"] , how did you get the output ["abc","e"]?
The image was actually a jpg. Thanks! I really thought it was a png. Haha.
There's no delimiter with `#delete`. "abc2e".delete("abc1e") == "abc2e".delete("e1cba")
2FA?
I'll be honest, a lot of the Perl design decisions go against my sensibilities. But I don't think we'd have Ruby without Perl, so there's that!
I was never a fan of spawning a process but I'm using Prawn anyway because I use table layouts and page-to-page content flows. 
Processing tip to Username8888 for 10 NIM. [Balance &amp; Deposit](https://np.reddit.com/message/compose/?to=NimiqTipbot&amp;subject=Balance&amp;message=I%20want%20to%20check%20my%20balance%20%26%20see%20how%20to%20deposit!) | [Withdraw](https://np.reddit.com/message/compose/?to=NimiqTipbot&amp;subject=Withdraw&amp;message=I%20want%20to%20withdraw%20my%20NIM!%0Areplace_this_sentence_with_a_digit_value%0Areplace_this_sentence_with_your_NIM_address) | [Help](https://np.reddit.com/r/NimiqTipbot/comments/8mpksa/nimiqtipbot_howto_and_faq/) | [What is Nimiq?](https://www.nimiq.com) | [Get Free NIM](https://nimiq-faucet.surge.sh/)
As far as I understand, there's also a way to sign and verify gems during install. I wonder if it would prevent bad things from happening in a similar situation.
- have scripts or workflows in place, tested, to revoke keys. - make a greater effort for signed packages. E.g. start a step-by-step process to completely disallow unsigned packages in future. - require ( not allow, but require) 2fa for pushing. Be bold. Be daring. Break stuff if that makes rubygems the most secure package-manager.
Use Sidekiq batches and enqueue a new job for every few thousand rows.
We have already done that. This is still a queuing piece. 
Help a noob understand -- what exactly is involved in signing a gem? Is it like SSL certificates?
I found it interesting that some of the list was just common password/security advice. For anything important (has my credit card or bank info, or is admin of something) I always enable 2FA if that's an option.
I gotta say, lurking around this subreddit, Rubyists seem like a pretty chill lot. Even when folks are trying to correct others, it's typically polite and insightful.
Or!! `10.times.each {|i| puts i if i &gt; 5}` I love me some `#times`.
add gem 'react-rails' to your Gemfile. It'll be in the root dir of the rails project.
Hell yeah! Thanks!!!
If you are running out of memory, it seems to me that either you are loading all of the CSV into memory at one time, or you are trying to create a batch insert of too many rows, or perhaps both. You can start by streaming your CSV file and do the insert one row at a time, which is easier if you need to run your ActiveRecord validations. Track the memory that you are using, which should not go over a few MBs in this base case. Once you got that working then you can start batching them up if there is a need. You may only find that this is necessary to batch/optimize if there are many users uploading large files and your import jobs get backlogged.
Coming from Lua, I have somewhat of a love-hate relationship with ruby. Sometimes I just love how easy it is tu use, other times I hate how object oriented is. Usually it comes down to this: if the scope is large enough to do some preparations for your code, there are better choices. If, however, you just want to get down to busyness logic without having to think about anything else, Ruby is certainly the way to go.
Someone needs to create a generic library / service that can accept a universal AST to render a PDF out.
A signature is a cryptography pattern used to validate who the message came from, and that it hasn’t been modified since signing. In the context here, it would likely be a PGP signature. 
With rubytogether paying for work on rubygems, I'd really like to see a prioritized focus on security. it's just a question of "when" not "whether" we get bitten. Why not be proactive?
Sorry, I'm not quite sure what you mean. Sidekiq batches allow the child jobs to execute in parallel across multiple processes.
Yeah I have never used Ruby for anything large, so I'll defer to your experience for that. I do a lot of scripts that involve manipulating and searching for text, and networking. I used to do most of that in Python and Bash but I can do pretty much everything in Ruby more cleanly and simply. For example, here is the same dead-simple script as cleanly and elegantly as I can write in both Ruby and Python 3: #!/usr/bin/env ruby out = `echo test` puts "Output: #{out}" puts "Exit status: #{$?.exitstatus}" #!/usr/bin/env python3 import subprocess ps = subprocess.Popen(["echo", "test"],stdout = subprocess.PIPE) output = ps.communicate()[0].decode("utf-8").strip() print("Output: {output}".format_map(vars())) exit = ps.returncode print("Exit status: {exit}".format_map(vars())) Now I'm sure there are Pythonistas who can write much more elegant Python than I can, but I've been using Python on and off for years and that's the best I can do, while I've been using Ruby on and off for about 3 months (!!) and it already looks waaaaaaaaay better.
Signing is complex and not often done. Unfortunately. Basically, the way I use it, is to pin a gem to certain signature: only if it was signed by that person (by someone with access to a private key, to be precise) do I allow installing it. A hypothetic case: Mallory adds a line to his fork of the Devise gem, which sends all username+passwords to his server. In order to publish that as newest version to rubygems, he needs the publish-credentials (which is what was compromised in the hack). If, however, the Devise-developers signed their package, Mallory needs the private key of the maintainer in order to sign it as well. Without that signature, `gem` (and therefore bundle) would disallow installing it on your system. But. You need to opt-in to this: `gem install gemname -P HighSecurity`. And very few gems are properly signed. Signing and installing signed packages should be the default. IMHO. https://guides.rubygems.org/security/
It would. The attacker would need to get hold of the developers' private key as well.
Why not use and promote the security tools already in place? Gems can be signed already. And one can install only properly signed gems. But all that is far away in the tutorial on rubygems. And hardly the common practice. They could, for example, make the "install only signed gems", i.e `gem install gemname -P HighSecurity` the default. Not at once, because that would cause havoc and frustrate everyone, but phased and properly planned. No need for new tools, hiring experts. But all about the focus on security. Just commit to it, and start making best practices the default.
I disagree with the first sentence of this post: &gt; Here’s an incomplete list of things you have to be familiar with in order to be a competent Rails tester: Capybara, Cucumber, Database Cleaner, factory_bot, Faker, MiniTest, RSpec, system tests, Test::Unit, acceptance tests, end-to-end-tests, mocks, stubs, unit tests and TDD. 
Ok, how come?
Ugh. No kidding. We've moved on from the bloat and dependency hell of Rails usage. Our currrent approach to rails is as a thin Web application shell around a pure Ruby core. We use a very simple test framework called TestBench to test our core and have almost no other dependencies. We've made stubbing a nearly automatic practice in unit tests. A small helper library we write automatically substitutes dependencies of any component so it can be easily tested with minimal ceremony. Complex mocking is completed avoided largely just be limiting use of third-party dependencies with overly complex APIs or wrapping them in simple components where necessary. The result: Code is far easier to write, test and reason about with others. Additionally tests run in sends and not minutes (serious the difference is 20x, and our core tests include database queries).
Wow, that sounds awesome. I'd be interested to learn more. Have you written the details of your practices in a blog post or anything like that?
If you're going to be a "competent Rails tester" Why do you need to be familiar with a bunch of tools that you're not going to ever need to use? I don't use MiniTest or Test::Unit and I never have (in fact I've never HEARD of Test::Unit until now) and I feel like I am a pretty "competent Rails tester". The article even states that you should NEVER use Cucumber, so why would you say you need to know it to be a good tester? The body of the article seems to contradict the first sentence. It just sounds like this sentence was written to encompass everything the author could think of WRT testing in Ruby just to debunk that list immediately after.
It sounds like your concurrency situation isn't set up correctly. Either run multiple sidekiq processes (using sidekiqctl ) or mulitple threads. The latter is less memory intensive, but not thread-safe. the 'concurrency' setting in sidekiq.yml determines number of threads, if that's 1, then only one job will process at a time. Setting that to 5 will do 5 jobs at once, but use 4-5x more memory.
Fair points. I might dial that back based on what you said because what you say makes sense. In my defense, I said *familiar*, not *knowledgeable*. For example, I think people should be *familiar* enough with Cucumber to understand exactly why they shouldn't (in my opinion) use Cucumber. Or if you're going to use RSpec, you should at least be *familiar* with Test::Unit to know why you're chooseing RSpec over Test::Unit. But not knowing those things probably doesn't necessarily mean you're not competent. I need to think of a better way to put that.
Okay, I changed it: "Here's an incomplete list of tools and concepts you might encounter when first trying to learn Rails testing: Capybara, Cucumber, Database Cleaner, factory_bot, Faker, MiniTest, RSpec, system tests, Test::Unit, acceptance tests, end-to-end-tests, mocks, stubs, unit tests and TDD." I think that says it better. Thanks for the feedback.
Specially I feel I've never satisfied with the Passenger experience, it seems to a be a weak point of our infrastructure, and every-time, we need to install it again, it seems so painful.
After seeing OptCarrot running at nearly 200 FPS (170-180+) in /u/eregontp's [RubyKaigi 2018 demo (Parallel and Thread-Safe Ruby at High-Speed with TruffleRuby)](https://youtu.be/mRKjWrNJ8DI?t=2m7s), I couldn't pick my jaw off the floor for about an hour. Some people are saying "Oh I hate that warmup time", but a coworker told me the other day, "You know, hearing people complain about this warmup is like complaining that it takes my car a few seconds to get up to 300 miles per hour." That really stuck with me.
Had tons of issue with passenger. Moved to puma and never looked back. It's been simpler since then.
Any news here /u/-TURBOMAN-?
Very interesting. Do you still use Nginx as reverse proxy, or you can even serve your app as is?
Yeah, that *does* sound better and actually changes the tone of the article a bit to sound a bit more beginner friendly.
Sure, but warmup time is still a downside that you have to weight in. It means you shouldn't just say "TruffleRuby is faster I'm gonna use it everywhere". You have to think about the usage pattern. For example, for a CLI program that is short lived, MRI is probably going to perform better overall. If you got a long running web application, then it might be interesting, but then should you also use Truffle in development? Because it's going to be way less reactive then you when to run your tests for example. Etc etc. So yeah, just more tradeoffs to consider. Still impressive though.
Truffle Ruby supports AOT, so the warm up time could be about he same or even faster the MRI if you had a CLI tools. But I remember there is a slight limitation at the moment that will be fixed soon. ( I cant google it, just remembering it on top of my head from Chris Seaton ) 
Have you looked at HTTP/2 and Server Side Events? That seems like the simplest method to achieve what you are trying to do.
Repost, not even two weeks. [https://www.reddit.com/r/ruby/comments/8wa71o/writing\_ruby\_like\_its\_2018\_ruby\_programming/](https://www.reddit.com/r/ruby/comments/8wa71o/writing_ruby_like_its_2018_ruby_programming/)
Nope, this is the first time I've heard of either of those. I'll look into it and see if that helps, thanks! Just to clarify, on the ruby end, I need the ability to setup an endpoint at which to receive messages, and basically have it sit and wait till all messages have been received (while concurrently allowing other messages to be sent for different services). All it needs to be able to do with these messages is show that it received them (basically spit the message back out via logs or on screen) and send an acknowledgment reply via SOAP. 
The Substrate VM (SVM) is promising on that front, since it allows native builds that startup fast. The distribution shipped by RVM, ruby-build and ruby-install is a native build: https://github.com/oracle/truffleruby/blob/master/doc/contributor/svm.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [oracle/truffleruby/.../**svm.md** (master → d3593b3)](https://github.com/oracle/truffleruby/blob/d3593b36c5fd970f195aeabe3aa326f635354218/doc/contributor/svm.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2c41vd.)
For the case of CLI programs, in some cases TruffleRuby is already faster than MRI, see [https://eregon.me/blog/2018/02/19/truffleruby-native-fast-short-scripts.html](https://eregon.me/blog/2018/02/19/truffleruby-native-fast-short-scripts.html) So TruffleRuby's startup is very good and comparable to MRI, and compilation can be quite fast with TruffleRuby Native (what you get when installing via RVM/ruby-build/ruby-install). That said, larger programs like OptCarrot or Rails application have an observable warmup time, so there is some trade-off there. Warmup can probably be improved quite a bit too with more work on TruffleRuby.
Take a look at this gem: [https://github.com/francois2metz/em-eventsource](https://github.com/francois2metz/em-eventsource) Use thin as your rails application server. It is also built on eventmachine. You can create a new event loop in your controller action that does something (in this case listens to Server Sent Events until it receives all the data) then notifies the event loop that it is ready to respond back to the initial request.
Signing doesn't have to be complex though. The most complex thing should probably be generating the key itself, once you get over that tons of tools that use PGP handle the actual signing and verifying part themselves (for instance with git, you just need to set the signing key in the config and turn on gpg signing, then use the -S flag when you're committing. On the other side, remote repos like Github just need you to copy and paste in the public key, and then take over the job of verifying pushes).
Recently moved from nginx/passenger to nginx/puma. Not looking back. DOOOOOO ITTTT.
https://www.reddit.com/r/ruby/comments/1upzq0/nobody_cares_about_signed_gems/ https://www.reddit.com/r/ruby/comments/1a3izs/sign_your_gems_with_pgp/ https://www.reddit.com/r/ruby/comments/17pb9h/lets_figure_out_a_way_to_start_signing_rubygems/ 
What issues did you have with Passenger? How do you start and stop your Puma processes? One problem with passenger was that NGINX did not support dynamic modules. Passenger team seems to have done a pretty good job with their installers considering this. I think they now have a standalone version.
I want to do Threads mostly. I don’t have any particular issues, it’s just I have never felt Passenger, in opposition of Nginx, Apache, or Phoenix, is “fun”, most of my time with it was figure out how to make work, and how to locate its logs. 
 my_var.not_nil? my_var.true? 🙄 `[].forty_two` 
&gt;If you got a long running web application, then it might be interesting, I am not sure I understand this caveat even if the warmup time were that much of an issue anymore - isn't rails still the primary usage of Ruby?
But why?
Not yet, I just don’t have the same amount of time for blogging as I used to.
I use both on separate apps. Puma has memory leaks from time to time. I started using it back in 2013 and it was awesome then I found it was leaking memory. Later that was fixed and even later it broke again. I ended up moving to passenger 5+ and it lowered the amount of memory needed, plus I gained some speed. However, I have a really large app running puma, and it's solid. I moved it to passenger, and it all went to hell so I went back to puma. Both apps are on different versions of rails running different stacks on different hosts. On the front side though, I use caddy in place of nginx. Way faster, easier to config, and free SSL out of the box. 
Had memory leak issue or process memory just grew like crazy even with max threads in place - Production site kept going down. we moved to Puma and had no issues since. We start passenger just with nginx automatically.
You'll still need nginx for serving requests since you can't, and shouldn't, directly map puma to port 80. 
Free SSL out of the box with Caddy? I didn’t knew that. 
[Brakeman Pro Desktop](https://brakemanpro.com/features#dt) is written with JRubyFX. Unfortunately there is no good, easy, cross-platform GUI toolkit for Ruby. I'm not sure that exists for any language, actually. JRubyFX is _decent_, but largely undocumented and not well-maintained at this point. I think you will have to use Java 8 to have it work, and read lots of JavaFX documentation.
Yup! It hooks right in to LetsEncrypt. It registers the cert and auto renews. 
You're question makes no sense, elaborate...
&gt; I'm developing a SOAP webservice Thats unfortunate, lets all give through out an `F` in commiseration. 
You're not wrong.
It might be a good idea to spend some time on test based development use cases to help folks like the above. When I say spend some time, I think I really mean, write up some evident documentation on how to make this fast and enjoyable if it's not immediately accessible or takes some setup to make it happen first... or perhaps there's just more dev to do generally in this area to make it happen.
Do you use Ruby for building websites? If yes, do you use Apache's HTTP server as part of your stack? If yes, why did you choose Apache? 
(Disclosure: I didn’t know about the TruffleRuby project until I read this reddit post) Looks like it’s not completely ready for Rails yet; from the README.md: &gt; TruffleRuby runs Rails, and passes the majority of the Rails test suite. But it is missing support for Nokogiri and ActiveRecord database drivers which makes it not practical to run real Rails applications at the moment. Not sure about Sinatra or other web app frameworks, but given how many common gems rely on Nokogiri I feel like that’s a deal-killer for now. 
Yeah I know that. All of us who have followed truffle ruby for many months know that it does not reliably run Ruby yet. theres no deal kiler when a piece of software is in beta. Its just in beta. All of the work being put in is not toward skipping Rails. 
Truffle Ruby is nice, I just hope it will be fully compatible with MRI. Alas, it has yet to run any of my test suites without errors.
I'm currently running Apache/Passenger in production, and that experience is not optimal: - When changing the site's config, usually you need to restart/reload Apache, which kills all Passenger processes. This might be fine for single-app hosts, but on some machines I'm managing a dozen Rails apps, which then *all* are restarted. The life-time of app should not be coupled to that of your reverse proxy... - In the past I regularly forgot to modify the sudoers file, when setting up a new app (with a separate user). This was an issue up to the second deployment, when Capistrano issued a "passenger-status: permission denied" because the app user didn't have the rights to invoke `passenger-restart` (that might have been a problem on Ubuntu only, though). Today, I'm preparing new app deployments with Ansible. Besides that, I have no problem running Passenger - once it runs, it runs. However, I'm planning on replacing the current setup with - Caddy for SSL termination plus auto-Let's-Encrypt-certificates, and as a reverse proxy to my apps (substituting `acmetool` and unwanted server restarts) - Systemd units, because socket activation is a nice thing to have if your apps don't need to run all the time - either Puma or Unicorn as application server (I'm not decided yet) At a later point, I might place the app in a docker container and let `dockerd` instead of `systemd` manage the running state. This also would eliminate the need for a separate user, but I guess my coworkers need a lot of persuading to adapt a new workflow. So far, I have a setup a single machine/app like this (for prototyping the Ansible configuration), and albeit the app runs in a small VM, it doesn't feel sluggish. I did not run benchmarks yet, mostly because we don't deal with high volume traffic (most apps are for internal use only). Once I scale this up to production machines, I will add proper instrumentation.
It probably won't affect the usage in Rails at all. The implementation of SASS is just a detail, you don't need to worry about, because the `sass-rails` gem will abstract that detail away for you. Here's what's likely going to happen: The `sass-rails` gem will be updated and bundle either the Dart version of SASS (plus depend on a dart compiler) or the Dart-to-JS compiles version of SASS (plus depend on a JS runtime). From there, it will hook into the asset pipeline and work just as it always has.
&gt;https://eregon.me/blog/2018/02/19/truffleruby-native-fast-short-scripts.html May be you should share those results with TruffleRuby Dev.
Well, it *should* get a bit faster, doesn't that count as affecting the usage? But yeah, you probably mean that the way you use it doesn't change, which, as you said, doesn't have anything to do with the implementation.
I used apache a long time ago, and switched to nginx because openresty (and there was no easy way to write websites in lua using apache). I haven't missed apache once since then, and I really wonder if there is any good reason other than not wanting to change a running system (a perfectly valid reason, in my opinion) to use apache over nginx these days. I don't really see how that would have much to do with ruby though, it just seems like a combination of two unrelated decisions, apache vs. not apache and ruby vs. any other scripting language, I just don't see why those two decisions would influence one another.
&gt; it *should* get a bit faster Since asset blobs are cached by sprockets, I suspect the time difference for compilation is negligible. Unless Dart SASS is orders of magnitude faster, or your dev machine is a Raspberry Pi, I don't think you should worry about it :-)
Yeah, it's more of a theoretical difference than anything relevant in a real project, but I still think it's worth pointing out. Then again, you never know what kind of system a user may come up with that requires building content from templating languages on the fly that is different for eachr equest, like user-supplied code or randomized contents, so it may still be a noticeable improvement for some people.
Any specific gem you'd want to work on TruffleRuby? Please tell us what fails on [https://github.com/oracle/truffleruby/issues](https://github.com/oracle/truffleruby/issues)
I totally agree. &gt; you never know what kind of system a user may come up Wise words :-)
Yes, we're looking at this too. For instance, currently \`gem install\` and \`bundler install\` are rather slow and we need to figure out the bottlenecks there and how to fix them. In general we aim to be fast with TruffleRuby without any special configuration. We welcome bug report "this feels too slow for development", they are very useful to know what matters for users.
My short answer would be "integrity". Not the size of "bag of features" (it is easy to imagine huger "bag" with everything thrown on top of the top), but how consistent they play together, and how minimal is the core allowing it all (Lisp guys, don't look), and how "stretchable" are common idioms and ways of doing things. I don't want to follow the uncanny "X vs Y" way (or "...but have you tried Z?" way), but in most of other languages I've worked or played with, I missed either richness of feature set, or the sense of integrity and of this "huge possibilities from a small core".
You don't need `each` there, `10.times { |i| ... }` works just as well.
There are a Windows version in roadmap?
Compared to Lua? Big Number accuracy. I used to have to do a lot of number crunching and Lua was right out. When I started programming, people were wacky about Object Orientation. It wasn't just popular, it was some kind of Jonestown-style religion. "It's more object oriented" was considered a perfectly good reason to do something, even if made the code more obscure/broken/unmaintainable. I could go on about how horrible it was back then. Anyway, when I first say Ruby, it was fully and unabashedly object oriented in a way no other language was, but in a way that also encouraged concise, readable code. Using Ruby was a way of keeping the fashion cultists. at bay while still not hating programming. Generally, though, I think Ruby is really tasteful, and I find it the easiest to think through problems in Ruby.
&gt; Overall I can see a lot of the reasons why people like ruby, but I still don't fully understand why so many love the language as much as they do. Programmers tend to like two things - solving problems elegantly and building powerful, flexible tools. Ruby is not really optimised for solving any given problem so much as it's optimised for *writing your own domain-specific language to solve problems in*. That means that if you're writing Ruby idiomatically and well, the first thing you do is to create a bunch of powerful, flexible tools to model your problem space, and then you use them to solve your actual problem. This way of working tends to make programmers happy, compared to languages where you more just use core language features to define the "nouns and verbs" of your problem and then use more core language features to express your solution. Plus Ruby has a nice combination of strong but dynamic typing that gets a lot of the benefits and fewer of the drawbacks of dynamic but weakly-typed languages like Javascript and strongly-typed but static languages like Java.
I like the syntax, and it's popular enough that if I use it at work I can re reasonably sure the core and the standard libraries will be updated. Need it be the best? Should we care if there *is* such a thing as a best language? 
I can only speak for myself but when I started learning Ruby in 2005 or so it was one of the only popular languages with lambdas and lots of runtime metaprogramming features, which I knew and liked from Lisp. Now some of those features and paradigms have come over other languages so it doesn’t seem as unique or special anymore.
The other thing is it's really well thought out. I've never said to myself "man, I wish Enumerable had this function", because most of them are already there. The naming is also super consistent, which leads to very readable code.
&gt; for writing your own domain-specific language to solve problems in. * Chef * Puppet I'm sure there are others.
\#lolnogenerics
I was more taking about *within a program or framework* (like how Rails is basically a collection of DSLs for routing, defining classes, managing database updates, etc) rather than just writing configurable systems, but it's basically the same thing, yeah.
How is it procedural programming? 
What are you talking about? The point is if it wasn't an instance (I.e it was a class with class methods and class state) then there would be thread contention. The fact you're creating an instance means thread contention is now a non issue as the state is local to the object. 
Thanks - will do!
Maybe because its stupid simple and just works?
For me it's about the syntax. Ruby syntax allows me to mold and shape the code like a sculptor and that's gives me a satisfying emotional feeling. With ruby I spend more time thinking about what it is I want to do and much less time thinking about the constructs of the language. I love the philosophy of more than one way to do things (which I know is vehemently opposed my some) because it helps me write code that tells stories. It's poetic and I know it sounds like woowoo but that's how I feel about it. I know a few devs who hate ruby because they hate the syntax and when I hear people say that I think they are good developers because I think hating the syntax is a valid reason to hate ruby, it's the most interesting part of the language and for people to hate it means that at least noticed it. In the end I think it's more important that everyone has a language they prefer and I can respect and understand it if their choice if isn't ruby, what I sometimes have a hard time understanding are the vast hordes that have no preferred language and will program whatever is popular on stack overflow, what I don't like about it is that I believe there's a preferred programming language for everyone and finding it means getting over the indifference of seeing a programming language as a means to an end. I started programming ruby because I wanted freedom from types, I stayed programming ruby because I enjoy it.
Passenger is running fine for me. Why would I switch? Not trying to be an ass, just trying to find out what the advantages are.
So everything is fine for you. I used passanger a long time ago and since i switched to nginx and mongrel/puma i was never looking back.
I would usually memoize the object like so: def foo @foo ||= FooClass.new end And then invoke the methods like: foo.method_a And foo.method_b 
I think you missed the mark on ruby's disadvantages. It's slow. It's very resource intensive, and single-threaded. That's okay though, because computers are fast, and you can write efficient code. You said "the complicated object-oriented ruby", but being strongly OOPy is kind of ruby's selling point. [Everything](https://ruby-doc.org/core-2.5.1/Integer.html) [in](https://ruby-doc.org/core-2.5.1/Symbol.html) [ruby](https://ruby-doc.org/core-2.5.1/RubyVM.html) [is](https://ruby-doc.org/core-2.5.1/TrueClass.html) [an](https://ruby-doc.org/core-2.5.1/Proc.html) [object](https://ruby-doc.org/core-2.5.1/Object.html)! I think it's also an interesting disadvantage. The language exposes the [core of it's runtime](https://ruby-doc.org/core-2.5.1/Kernel.html) to you, which means you can do zaney crap like monkey-patch core methods.
Because it's mind bogglingly expressive. It is a joy to write with because there are so many ways to implement its syntax and you get to pick the best way for what's immediately relevant. This makes you a much better programmer than you would with other languages. Moreover, everything's an object and the global namespace isn't polluted with garbage. Doing what I have to do in Python feels like I'm trying to build a Technic racecar out of Duplo. Or like trying to write the great american novel with a four year old's vocabulary. 
With most other languages that you're not too familiar in, you'll write a line of code with how you think it should look, run it, and it fails. With ruby, you write code how you think it should look, run it, and it just magically works more often than not. You spend less time looking up docs when things are written intuitively vs programmatically. 
A good example for what I mean by "complicated" is how `Class` is a an `Object` of type `Class` that inherits from `Object`. And I understand that it being all OO is a major selling point, but in my opinion that's a double edged sword for reasons like the above paragraph. Comparing heavily object-oriented code to something that uses mostly functions, often shows that both can work if done correctly or fail horribly if done incorrectly (There are lots of good examples for either scenarios in the ruby world). So I guess whether you like ruby or not is strongly linked to whether or not you like object orientation? That might be one of the reasons why I am not overwhelmed with its design as a language; I am always mistrusting towards object orientation and am still not really convinced that it's the right tool for all, or even most problems. That being said, I usually do ruby in a more functional style, and other than the fact that "functions" are actually objects with a call method, which seems somewhat silly, it does work pretty well, so I wouldn't say Ruby as a language *is* object oriented. It may be a bit biased towards object orientation, but that can easily be avoided without much effort through the tools the language already provides.
Doesn't that also mean that it's hard to master though? I find that it has much more stuff going on that doesn't add much depth to the language than a language like Lua, with its one-size-fits-all table data type and first class functions. I don't want to come across as just hating on Ruby or saying Lua is the supreme language though, it's just what works for me and it's easy to compare Ruby to :)
Ruby is the only programming language where I have to use a debugger because I can't figure out what's going on. The magic drives me bonkers.
I'd argue that isn't the same for everybody though. Many things in ruby have... questionable names and behaviors. Not long ago I found out about the `.yield_self` method, and I haven't used it once, favouring my own implementation (7 lines or so, with a mixin, including the `using` statement) called `.apply` that accepts additional arguments. I also find myself having to look up stuff in references more often in ruby, simply because there is more to it. I have most of Lua memorized by now, including lots of implementation-specific things that only really matter for optimization, and I don't feel like I will ever be able to reach that point with Ruby. That being said, I wouldn't say Ruby is necessarily over-engineered, but it seems to follow a philosophy that makes it more easy to fall into that pitfall.
https://imgur.com/a/igootzZ
&gt; How do you start and stop your Puma processes? not OP, but I love runit for that. Just very long command line hooking up with RVM, changing user (`chpst`) and cleaning env (`env -i`) and at the very end, `bundle exec puma`. Then I can start/stop app with `sv [action] [myapp]` 
As a consulting/agency business owner, it is my go-to language because it is "good enough" in a multitude of ways - ecosystem, idiomatic syntax, community/support. I can build my solution using a combination of smaller solved problems in a way that emphasizes convention over configuration. In my domain of work, that approach is helpful. Of late though I've been transitioning to Elixir, which I think is fantastic
How much does that first paragraph really matter in your day to day use of the language? I think your last paragraph illustrates one of the things that makes some people love Ruby. Ruby itself is highly object oriented, but you can pretty easily write code in a functional style and doesn't look very object oriented at all. It's flexible. Whatever way you're thinking about a solution to a problem, it's not difficult to do it that way with Ruby. There aren't a lot of constraints or limitations, and it doesn't require a lot of boilerplate or convoluted code to do things the way you want. For me, of all the languages I've tried, Ruby offers the shortest path from my vision of a solution to working code, with the least compromise in the details of that vision.
I haven't had the time. Would be happy to show some examples to you directly at some point though.
The README is a bit overwhelming – have you considered it maybe has too many 'features' already?
You should check out this [ruby internals talk](https://www.youtube.com/watch?v=NlPxvRSUVQI) by Patrick Farley, it gives some insight into how the ruby object system works under the covers.
Probably the amount of gems there are
Most of those are simply shortcuts to be honest, although I do agree that the README is a bit long. Maybe I should just point out how to access the help for these shortcuts in it
I'm having the same issue. It's pretty maddening since I bump into it every couple of days. Resetting the wifi seems to fix it until the next time it happens - killing the nsurlsessionid didn't do anything. It also only seems to happen in macOS. I've never had it happen on linux
Those of us concerned about SASS/SCSS build time had already switched to sassc-rails, in my case this cut 60 seconds off build compared with the pure-ruby implementation. If you're using SASS/SCSS in webpacker-built assets (e.g. Vue component files) then it also means consistency with the underlying engine, since node-sass is also currently a binding to sassc.
Elixir requires you run beam though right? I know lots of ops teams that can support, understand, and tune MRI, even more who can do jvm (enabling jruby, scala, etc). But I feel like introducing elixir introduces a whole other runtime that would be hard to find people who can support (esp with an existing devops team)
&gt; comparing the complicated object-oriented ruby to the simplicity of Lua (My personal language of choice), I think ruby is at a disadvantage, no matter how you look at it. I'm a Rubyist, and I like Ruby a lot, but I've recently been looking to Lua as an alternative for its absolute simplicity, both of syntax and of implementation. I'll play the devil's advocate here and say: yes, Lua is *simpler* than Ruby, counter to what some have said here. But on the other hand, simplicity of implementation does not necessarily mean that the code you write in that language is going to be simpler. My biggest issue with Ruby is that I personally love simple, elegant, minimalist things, and as much as I like writing it, Ruby is not such a thing. To get the "human-like" language it supports, it has a very complex internal implementation (compared to e.g. Python or Lua).
I would dare say that unless you're dealing with (some) primitives, Java has inflexible and weak typing. Things such as automatic casting between number types, autoboxing and (god forbid) everything not primitive can also be null makes the type system weak.
You're right, I think I just saw the top example and added it subconsciously. 
Hey! Sorry I haven't been able to do it yet. I'll let you know when I get it done. 
&gt; Java has inflexible and weak typing. I don't know what languages you're regularly using, but if you think Java is "weakly typed" compared to the majority of other languages then with respect I think it's safe to assume your scale of values is a little distorted. Java could definitely be *even more* strongly typed, but to refer to its type system as "weak" leaves no word left to describe languages like JS or PHP.
Passenger author here. I am surprised that so many people here have issues with Passenger. This is not my experience based on support requests and Github issues, as well as our own infrastructures. I would appreciate it if people tell me what kind of issues they ran into or what they think should be improved in Passenger.
This generics limitation applies only to static typed languages. Ruby has duck typing, IMHO the supreme form of polymorphism.
Usually when people say Stong or Weak types, they refer to the compilation / static analysis possibility of inferring the correctness of the implementation. The correct term is "they ensure Type safety". Unfortunately, most of the time Java can't do that correctly specifically because of the Billion dollar mistake (every Object variable can also hold null) optimization. Strong Languages without such "optimization" destroying the type system usually have less compilation time hidden bugs. The only mainstream languages that I know that have strong typing (and even in some you can disable that) are Ada, Rust and Haskel.
thatsthejoke.jpg
You can use `sassc-rails` today as well [https://github.com/sass/sassc-rails] which uses `libsass` instead of the Ruby implementation of sass, it's a _lot_ faster. 
&gt; The only mainstream languages that I know that have strong typing... are Ada, Rust and Haskel. Exactly - like I said, you're using a far stricter definition of "strong typing" than 99.9% of everyone else does.
Long live SOAP. 
This guy is: https://www.reddit.com/r/ruby/comments/8pi3ja/configure_rails_app_with_apache_and_passenger_on/
Contrary to some believe Ruby is a strong type. But the type are classes. Once a variable is initiate with a value, this variable wont accept a different type without raising an error.
I think they're talking about languages with sound type systems, like OCaml. This type system is great and all, but I agree with you: calling those languages "strongly typed" would just put PHP and JS on the same category with Java, Elixir, Kotlin. I don't think such a classification would tell us anything about languages.
No intent on slamming you here, but your post would be more interesting if you gave a quick blurb about your gem along with the release announcement. For my part, I’ve never heard of the gem so my first inclination is to move on to another post. If you gave a quick description, I’d be more inclined to check out what you made. Again, I don’t mean to disrespect or discourage—kudos for sharing with the community.
I used to use vagrant-lxc https://github.com/fgrehm/vagrant-lxc which sounds quite similar. These DSLs look nice at the beginning, but when you want to tweak something you can easily find a LXC tutorial on how to achieve it, and then you need to map from low-level commands and setting names to this high-level DSL anyway. My usecase was to isolate app/services. I used vagrant to define all of them and they would communicate with each other. Nowadays I use docker-compose.
how about latex? :D
In my experience Passenger is a bit more tricky to learn, but has some great added benefits. The main thing I think is confusing is that I don't install Passenger as a gem. First time that I encountered it and worked with it was on a staging server. For example I already got to play with Puma and it's config when in development. What I do really like is passenger-status, it gives a really good insight in what's happening to the server and the request pool. This is something that I miss in app servers like Puma. I didn't really encounter issues with Passenger, it was more that it was unknown to me. Documentation helps a lot, but I still think that I don't fully grasp it, since I don't 'play' with it that often. One other thing, I can still remember the Raptor campaign, nicely done!
How did you decide to use docker-compose over the existing workflow? I feel it’s a steep learning curve for some case as in setting up Wordpress based on someone docker compose file.
I highly recommend this talk https://www.youtube.com/watch?v=tbzPeLaqp10 It goes into a lot of the story behind Ruby and why the people who use it, love it so much.
Discussions like this always remind me of this talk https://www.destroyallsoftware.com/talks/useing-youre-types-good
&gt; Using merge doesn't seem elegant to me and it forces me to use at least one additional key in the first line which again doesn't seem elegant.. I'm not sure I understand the downside. Would either def set_defaults(defaults = {}) super({position: [-1, -1], speed: 0}.merge(defaults)) end or def set_defaults(defaults = {}) super defaults.merge(position: [-1, -1], speed: 0) end do the trick? I'm guessing that you want `defaults` to be able to override hardcoded `:position` and `:speed`. Nowadays I prefer to use keyword arguments for any option management, that way you can remove `Hash#merge` and make it more readable: def set_defaults(**defaults) super(position: [-1, -1], speed: 0, **defaults) end 
Different project, different existing setup already done by another coworker :) Generally the adoption leans towards docker and kubernets (but I don't think for local setups). So this is where you can find most resources online, tutorials, tools, existing containers for common components (ie DB, elastic etc) and easiest access to help. With LXC, I feel you are on your own.
Thank for your sharing experience, I heard the Ruby inventor is developing FastContainer that probably use at GMO and Haconiwa is one of them which probably will intrigue your coworkers and you. https://dev.to/udzura/writing-a-small-bare-metal-container-aof https://speakerdeck.com/udzura/how-ruby-survives-in-the-cloud-native-world
If the parent \`set\_defaults\` method is expecting a single hash argument, you should use \`merge.\` There's no reason to play code golf, nor is there a better way to accomplish what you're talking about anyway. This: super(defaults.merge(position: \[-1, 1\], speed: 0)) is as minimal as it gets. You generally want to avoid accepting a single options has as an argument though, because it's too flexible. It's better to use keyword arguments and provide a name to all of the possible arguments that can be passed in. If you modify the parent \`set\_defaults\` method to accept keyword arguments, you can then use the \[double-splat operator\]([https://stackoverflow.com/questions/18289152/what-does-a-double-splat-operator-do](https://stackoverflow.com/questions/18289152/what-does-a-double-splat-operator-do)), i.e. super(\*\*defaults, position: \[-1, -1\], speed: 0) That does have the benefit of not needing any \`merge\` calls.
Great post, didn't know/remember that
The keyword argument version is more elegant
Is it Puma or your code (with libraries) that are leaking memory?
&gt; Specially now I am working on a project with lots of IO and slow clients. Is this a problem with Nginx in front of your app-servers? 
This is exactly how I learned to process hits from a log analyzer for a ruby class I took a few months ago.
I think the main issue is we have spawn more passenger processes to handle slow clients. (Our app can process HTTP things for up to 10 minutes.) But Passenger seems to assign new queries to busy processes on a regular basis. Nginx seems to be fine. 
Thanks for the great work on Passenger. I think the main issue is we have spawn more passenger processes to handle slow clients. Our app can process HTTP things for up to 10 minutes. But Passenger seems to assign new queries to already busy processes on a regular basis. Being able to have a lots of Threads that are allowed in Puma should alleviate our issues. Better queue management might be a fix that won’t imply to OSS threads I suppose?
Thanks for the great work on Passenger. I think the main issue is we have spawn more passenger processes to handle slow clients. Our app can process HTTP things for up to 10 minutes. But Passenger seems to assign new queries to already busy processes on a regular basis. Being able to have a lots of Threads that are allowed in Puma should alleviate our issues. Better queue management might be a fix that won’t imply to OSS threads I suppose?
This is great news but there's still a long way to go. First thing I did was run `gem install bundler` and that took about one minute, about 50x slower than MRI. Nevertheless I will try to get the Sidekiq test suite and benchmarks running to compare.
I am pretty sure that Nginx will buffer slow clients so they will not consume Ruby resources before their request has been received: https://www.brianstorti.com/the-role-of-a-reverse-proxy-to-protect-your-application-against-slow-clients/
Your certificate expired 38 days ago...
Thanks, turboladen. I'll see about building a boilerplate paragraph that I can add to a release notice. I appreciate your taking time to comment.
Hum, I meant when have only one process busy of 20. And it seems Passenger try to use the first one in priority of the others. So, it’s even worse than 20:1 odds to have a new request buffered, things we want to avoid in this situation. Either by Nginx or Passenger. E.g., a long call to our API will block our homepage loading randomly despite having almost no traffic. 
I also noticed and extremely slow run of `bundle install` on a Rails latest Gemfile with nothing else. It crashed repeatedly and never succeeded bundling some gems like nokogiri which are pretty crucial to many stacks. I'm curious what makes it so slow at installing gems or resolving Bundle dependencies.
The C extensions, such as `openssl` aren't great for performance at the moment. It's a shame that this is what most people see straight away.
The important takeaway here is that having it in `rvm`, `rbenv` and `ruby-install` was for precise situations such as this: To allow easy testing and feedback. Now that it's accessible to everyone readily, the real work, as you're discovering here, starts. They want every report like what you're finding here ASAP in the issues. So yeah, this is in reality great that you've found this problem. From what they've said, TruffleRuby (Oracle) has the most hired / payroll Ruby devs out of any company on the planet right now so this is a pretty serious and impressive commitment any which way you slice it.
Expired 39 days ago. You already seem extremely trustworthy.
Well, removing puma stopped the memory leak. This could be because of how puma runs code and how poorly my code was written. That's most likely the case. However, I saw this on more than 1 rails app, and removing puma fixed it in both. Now, I do have other apps using puma that don't leak memory. They're super stable. So really, I have no idea.
Thank you for your feedback ! Happy to see that my articles are useful :-)
No problem. Thanks for making useful things for the Ruby world!
Thanks for pointing that out, I'll get it sorted.
Sorry I missed this! I have only briefly looked at reform, so no experience there. I roll my own form objects. I have a pretty nice base class that I share between my projects now. It pretty much just includes various ActiveModel classes, defines a #save method that accepts a hash of attributes, runs validations, then calls a private #persist! method that is implemented by each form class with form-specific persistence logic. I generally disagree with the idea that form classes be thin layers between a template and a model - so thin that you can just auto-delegate to some underlying object. If the form class does so little, you probably don't need it. On a typical project, I use both form class and model backed templates, depending on each form's complexity. It's kind of verbose to assign the attributes set on the form class to the underlying model object(s), but I've learned to love it. Verbosity isn't necessarily the enemy. You'll find over time that you might want to modify the attributes as they're being set on the underlying model object(s), or conditionally assign them, etc. All of that logic has a nice home in the form class, and can be easily accomplished if you are manually assigning the attributes. If you are looking to just get your feet wet, I'd encourage you to take a complex form, extend/include the relevant AM classes (Naming, Conversion, Validations), then define accessors for every attribute. Write a #save method that does whatever it needs to do to your AR model(s) if #valid? and go from there. Basically, insert the form class as a middleman between your template and your AR model. Then watch how easy it is to touch another model, enqueue a background job, send an e-mail, etc. (maybe that's something that was in your controller or a callback). 
&gt; The whole Trailblazer ethos of "even more framework" leaves me stone cold. Totally agree. My favorite thing about form objects is that they can be simple. There's no magic. They're just the object representation of a form. Easy. 
In other words, the https fetch of various gems and metadata is really really slow due to openssl? I'd buy that.
I so badly want Rails to remove any dependency on nokogiri. It had its day but it's a gigantic pile of native code which makes Rails support on less popular platforms (like truffle, jruby, windows, etc) much harder. It's too bad that Rails can't make rails-dom-testing an optional dependency: In Gemfile: rails was resolved to 5.2.0, which depends on actioncable was resolved to 5.2.0, which depends on actionpack was resolved to 5.2.0, which depends on actionview was resolved to 5.2.0, which depends on rails-dom-testing was resolved to 2.0.3, which depends on nokogiri 
Works fine now :)
Very nice post - I've learned something new from it. :) Did you ever used `def_delegator` passing a more complicated message for it to forward than `:first` showed in the example?
Glad to read that ! :-) The `def_delegator` method is designed to handle a simple use case: Forward a message to an inner receiver with the possibility to alias the message. There is probably some edge cases but I didn't notice any weird piece of code when I read the source code.
I use it to serve static files and execute CGI scripts written in Ruby. 1. It comes with every Linux distro. 2. It's more stable than nginx (i.e. changes less). 3. Documentation is better for using CGI with Apache.
Obvious question and the elephant in the room then: why not pay for the Threads feature? If you are a business making money through your software stack, doesn't it make sense to pay for good tools and support?
Understood. :) thanks for the answer 
Understood :) thanks for the answer
I've no issues paying for OS. My main issue is I don't want to learn multiple tools for my other side projects that will need concurrency for whatever reasons. That said, for our production server, 4,608.00 / year is substantial for a bootstrapping business. 
I would love to see rubytogether-funded rubygems focus seriously on making signed gems a thing again. I think there are probably improvements to the the rubygems.org infrastructure that could make this easier/encourage it, it's not all about mandatory enforcement of policies. (can you even register your pubic key via rubygems.org?)
Thanks! I would love to see this written up as a blog post/tutorial with code examples, I haven't seen a lot of explication on this seemingly very reasonable approach. I think it needs to be written by someone who has _done_ it, from their experience, not just someone trying to write what makes sense they've never used extensively in a real project. 
I'm putting a sticky on my desk right now to do this. We're in the middle of a big project, so I won't have time for a bit - but I promise to write it eventually. Thanks for the encouragement! 
Awesome! 
Form objects make it *so* easy! Imagine you have a form where the user needs to be able to simultaneously create a forum post *and* sign up for a user account. After successfully submitting, you should have a new Post record and a new User record. You just create a form class and define all of the attributes of a Post and all of the attributes of a User on it. Add necessary validations for those attributes. Then, in your template, you create a form backed by one of these form objects. In your controller, in your #create method, where you might normally create a Post, instead of calling #save on a new Post, you'll call #save on an instance of your form class. In that #save method, you'll run validations, then open a transaction. In that transaction, you'll create the User, then create the Post, assigning the attributes from your form object to the Post and the User. Voila! This is probably much easier to understand with code examples. I'll be sure to include them in my post. 
Aside from the expired cert I don't see why this got downvoted so hard :( As a newcomer to Ruby and RSpec I learned about the `on_potential_false_positives` configuration option which happened to be useful to me. Thanks for sharing
So `club.css('a').attr("href")` is `nil`, right? Well then write: ``` href = club.css('a').attr("href") if href hash[:site] = href.value else # do something else end ``` Or you could use the safe-navigation operator, which returns `nil` for a `nil` receiver rather than calling the method, and write: ``` hash[:site] = club.css('a').attr("href")&amp;.value ```
Thank you!! However, now I get a name error for "club" saying no local variable or method, even though I have it defined. Any ideas?
Show where you have it defined and how you're trying to use it.
Try Clojure - freedom from OOP, all the benefits you listed plus repl-driven development. Nothing compares.
Elixir and Erlang are not suitable for ops due to Erlang's everything-is-a-module architecture which makes scripting not a real option. This is Elixir's weakness - whilst BEAM has decent performance and excellent concurrency primitives it limits Elixir to applications where distributed concurrency is the main requirement.
For me there are only 2 languages which feel like they have been really well designed - Ruby and Clojure. Both have a charismatic leader whose design principles had a large aesthetic component unlike, say, PHP, Python and Java where pragmatic compromises are the driving force.
Certs expire and sometimes renewals aren’t automated or something goes wrong. Doesn’t make op untrustworthy. 
Matz once said he wished he had left out the Perl special variables but, coming from Perl, I say Ruby is perfect as it is because of what it borrows from Larry Wall. Leave the wonderful scripting shortcuts in Ruby. Nobody is forcing you to use them.
So you do not use Rails nested_attributes stye attributes at all? A to-many is also even weirder than a to-one. :)
For sure. Design-by-committee basically guarantees a less cohesive and holistic design.
Perl was my first programming language back in 2002 and I loved it. Larry Wall's "Programming Perl" was my bible and we also had The Damian (Conway) on our side. Python never had anyone like The Damian and probably never will even if it succeeded in taking a lot of mindshare from Perl. Perl's problem was OOP. Well Perl 5's problem, I should say. Although the Perl community settled on Moose for OOP many considered it too heavyweight which spawned a host of variants such as Moo. Then there was the endless carping about a MOP for Perl but no-one could agree on one. Eventually a lot of the Perl leading lights who really wanted baked-in OOP discovered Ruby had everything they needed. 
When you say "freedom from OOP", what does this mean?
We're not actively working on getting Windows supported. A key requirement for us is if for Graal and the Substrate VM to support Windows first. Until then, supporting Windows isn't a pressing concern. FYI, we did have Windows support at one point. The biggest issue at the moment would be the I/O layer, where we've since switched to making POSIX calls directly. We'd either have to make Win32 calls instead like MRI does or have a Java fallback implementation.
I use nested attributes sometimes. If a form is simple enough where it works, I’ll use it. But sometimes forms become complex. Maybe there’s logic that should determine if some other record should be created, or what kind of record, or maybe there’s a third party service we need to talk to. When you start feeling like you’re fighting with OOTB Rails, a form class is often the solution. To-many’s are tough with form classes. I haven’t had to do it much, but when I have, I’ve mirrored Rails. I build two form classes - one for the parent and one for the children. Then, I expose an attribute on the parent form class to accept a Hash or Array of attributes that I use to build child form classes. Then, I can trigger validations on the children, and maybe rely on their own #save/persistence method when the time comes. Basically, do what Rails does, but with form classes instead of AR models. I validate in AR models first, then move away as needed as I introduce form classes. Once the model is being used by a form class, I try to ditch the model validations and move to form classes for any other form that deals with that model. When absolutely necessary, I’ll duplicate the validations on the model and the form class, but that’s messy and not ideal. In a typical project where I’m relying heavily on form classes, the models that are a part of the complex forms won’t have any validations defined on them. This makes life *so* much easier as the app grows. Think about data imports, special cases, etc. As apps grow, you’ll find you start needing conditional validations. A phone number is only required when a user signs up on the website but not when imported from this other system, for example. Not a problem with form classes, and you don’t have to ride the slippery slope to conditional validation hell where you’re validating the phone number only when !imported?, and then when not imported and the User’s name is Bob and it’s between the hours of 8 and 5 Martian time and whatever other insane conditions you’ll eventually have to work with. 
I am sure this is a super useful feature, but the example in this post looks more elegant without it. It also claims to be a performance optimization, by using less memory, but has no measurements. Is there a way to accomplish something like the example in the article without needing a temporary or pre-constructing the empty array?
&gt; It also claims to be a performance optimization, by using less memory, but has no measurements. It uses less memory because it doesn't allocate an array. The return value is the original string.
I'm assuming the block version reads the string into a buffer until it reaches the separator character, gives it to the block, then clears it and continues. I'd imagine it'd be more efficient if you were dealing with a huge string that had lots of segments.
I sort of get it, but it seems inelegant. If you want the bits one at a time, why not str.split(sep).lazy.select {...} That seems to be the correct Ruby way to me.
&gt;openssl What do you suggest to use as alternative?
Well I suggest I fix our slow C extensions really. We’re hoping to not have to ask people to use any alternative libraries and let them run their applications unmodified.
I like https://github.com/httprb/http
Net::HTTP will do the job.
Object Oriented Programming
I personally choose `Faraday` [Github](https://github.com/lostisland/faraday)
So the CLI will capture it as a string. Indexes take an integer. So firstly, you'll need to call `to_i` on the input. ``` index = input.to_i ``` Then, you can do as you suggested - ``` store_info = Store.all[index] ``` Since you say it returns a hash, you can then treat this like any normal hash; getting the values out by using square brackets `[]` and passing the key you want the value for. ``` puts "The hours of #{store_info[:name]} are #{store_info[:hours]}." ```
[https://github.com/httprb/http](https://github.com/httprb/http) all the way.
&gt; `str.split(sep).lazy` By the time you hit lazy it's too late, there already is an array with all the elements, doing a lazy select will only make things slower (especially if you need all elements and not just the first 3 or so).
Ah yes, you're right. So split should return an Enumeration instead. But that's not backwards compatible. Compatibility aside, would that be a good solution, or would it be slower?
I think the bigger efficiency would be if you were doing a *ton* of calls to split, to the point where taking out say a million calls to Array.new would be a significant win. 
I have used https://github.com/jnunemaker/httparty successfully since 2010
Thank you so much! However when I do this, I get back: undefined local variable or method \`store\_info' for #&lt;CLI..." def store(index) ##I already converted it to an integer in the method above it. store_info = Store.all[index] puts "The hours of #{store_info[:name]} are #{store_info[:hours]}." end Am I doing this right? Does index need to be an instance variable since I'm getting it from a different method? Can't figure it out!
Cool, I was asking if you use nested attributes _with_ form objects. It sounds like not, once you've gone to form objects, you no longer use nested attributes? (One could conceive of nested-attribute-style-param-names being used in the view, and the form object handling them... but it sounds like you haven't done that? Or do you do it in the case you talk about when you've rarely done to-many with two form objects?) I appreciate the description of your workflow -- generally starting without form objects, and changing over to them model-by-model as it seems neccesary, rather than always using form objects out of the gate. 
&gt;Does index need to be an instance variable since I'm getting it from a different method? No. Passing it as an explicit argument to the `store` method is fine. However, we don't see your Store class here. You might try giving us more information about that implementation, or you could test the lines of your method one by one to see where you're getting unexpected results. index = 5 store_info = Store.all[index] puts store_info.inspect Your interpolation looks fine, assuming that you get an appropriate hash in `store_info` variable, but your error message seems to be pointing towards an earlier error.
BTW, I wrote a simple Store class that *would* work for your method, but I have no idea if it's like yours. class Store class &lt;&lt; self def all [ { name: 'store A', hours: 'Mon-Sat, 9am-5pm' }, { name: 'store B', hours: 'Mon-Sun, 9am-5pm' }, { name: 'store C', hours: 'Mon-Fri, 8am-8pm' }, { name: 'store D', hours: 'Mon-Fri, 9am-3pm' }, { name: 'store E', hours: 'Mon-Sat, 7am-9pm' }, { name: 'store F', hours: 'Tue-Thu, 6am-8pm' }, ] end end end def store(index) ##I already converted it to an integer in the method above it. store_info = Store.all[index] puts "The hours of #{store_info[:name]} are #{store_info[:hours]}." end store('5'.to_i) And here's the output: The hours of store F are Tue-Thu, 6am-8pm.
I don't know why you are getting downvoted. Using Net::HTTP to build a class that contains the calls and responses you specifically need isn't a big deal and it's all tucked neatly away in an easy to test object.
Thanks. It seems that the issue is accessing the hash. When I throw in a binding pry, I can see that store_info equals a hash. But it's when I try to access the key that it throws an error: NoMethodError: undefined method `[]' Any ideas?
I think I'm with everyone on this. The split block doesn't seem like a place where you'd iterate through each element.
That's odd, but it's probably better to *show* your result than to describe it. Assuming that you are a beginner as stated, you might be missing something that would be visible in the literal output. Also, I mentioned above: puts store_info.inspect Another thing that can help is to explicit check the class of your object and whether it responds to the method you have in mind. puts store_info.class puts store_info.respond_to?(:[]) Your error message seems to imply that it wouldn't respond to the [] method, but when things fail like this, it's can help to break everything down to super-simple baby steps.
I really don't like httparty. It's API is very inconvenient for anything but it's happy path use cases, and it's performance is pretty terrible. It baffles me why it's been so popular. If it's working for you, that's fine, if it ain't broke no need to fix it, but I really don't reccommend people use it without a specific reason. 
Also, I noticed that your error message seems to be missing the part that denotes the object for which the method was undefined. For example, if I try to call `reverse` on a simple Hash, my error message looks like this: irb(main):003:0&gt; store_info.reverse NoMethodError: undefined method `reverse' for {}:Hash Did yours say anything after what you pasted here? Did it tell for which object the [] was undefined?
Because it’s not hip. People want to use cool frameworks, it’s just the way of the world.
I think you ask a good question. A good question because there isn't a clear answer. The built-in net-http is really too low-level API to be convenient. Although if it works for you, feel free to use it! (you say you want few features and simple and lightweight... it does technically qualify, and it _is_ very popular, if you were to count popularity by number of times it gets used in open source code, since it's included in ruby!) * *httpparty* has been quite popular, but frankly it baffles me as to _why_. I really don't it. It's API is very inconvenient for anything but it's happy path use cases, and it's performance is pretty terrible. It baffles me why it's been so popular. If it's working for you, that's fine, if it ain't broke no need to fix it, but I really don't reccommend people use it without a specific reason to. * I have been using HTTPClient for a while, it seemed to be the best option for a while (part of my requirements were pure-ruby, no C extensions) -- but I'm a bit dissapointed that it doesn't get a whole lot of maintenance, bugs and feature requests are pretty slow to be fixed. It is kind of surprising that there is no standard high-quality higher-level consensus library for HTTP client in ruby, since so many of us do so much with HTTP. faraday isn't really an HTTP library itself, it's a _wrapper_ that aims to give a consistent API on top of various other underlying "driver" HTTP libraries. It's kind of a _symptom_ of us not having a legit consensus HTTP library, heh. Personally, I don't totally understand it's draw, I think it's more abstraction without a lot of benefit (I guess it gives you the benefit of thinking you don't need to choose an HTTP library, since it'll theoretically let you write code that'll work with any of em...) Some people decided, gee, there really _should_ be a standard, just enough features, flexible API HTTP client written in pure ruby... and tried to do that with [http-rb](https://github.com/httprb/http). On the one hand, it's [XCKD 927](https://xkcd.com/927/), but on the other... they've done a pretty good job. I think it's what I will be using in the future. 
Because it's not cool anymore... ;( I upvoted it just to get it back up... because it IS a legit option... I would reach for https://github.com/httprb/http myself, but cmon Net::HTTP still is handy
&gt; store_info.respond_to?(:[]) Yes, it returns false for respnding to the [] method. And yes it says: NoMethodError: undefined method `[]' for #&lt;Mall:0x007f7f67940d48&gt;
&gt; Doesn't that also mean that it's hard to master though? Master, yes... but Ruby is kind of like regular expressions or SQL in that way... you can go an entire career knowing some very basic regular expressions or SQL syntax... and they save you MASSIVE amounts of work And then the deeper you dive into things like the , the more you realize Enumerable is unreal in it's utility... I read the core docs and the standard library once a year and have for a decade... and STILL find useful things every time... Python and other languages are sometimes like this as well, but Ruby has that "something" C (not C++) had when I started... C had very few keywords and was such a simple language... but powerful and like unix... all the tools were small and sharp... Ruby is like that much more than say Python or even Perl... Perl had some awesome parts... and with Ruby... I was able to keep those parts and get rid of the stuff I did not like... But that's just me...
TIL. Thanks for this post
Well, that's part of the problem, then. The thing that is being returned by `Store.all[index]` isn't a Hash, and also doesn't have the `[]` method defined on it. It's a Mall object, instead. I'd say the part you are showing in this post may not be where the root of your issue is. Instead, it's probably in the Store/Mall classes, but we can't see those, so it's hard to say what's wrong.
🙇
Last time I tried installing rails with `HighSecurity` it failed. -_- Maybe its better now though.
Means two factor authentication. So like the pins your bank will send you when you try to log in or a time based token is another popular way. 
Right, I was positing 2FA as a potential path for rubygems security.
Ah ignore me then :P
im sorry... but how the hell is this a solution ...
I'm now using httprb. See https://twin.github.io/httprb-is-great/ for some good reasons (including memory use).
Woah, I did know about Rake::DSL! I started out reading the article thinking "I wonder if Rake should have a way to make it behave more like the rspec example, since so many devs seem to want that." Turns out it does! I will definitely be using this. You don't want to put _too_ much stuff in private methods, and service/helper classes are great, but sometimes (with or without supplementary helping classes) a few private methods can really make things more readable and concise. 
&gt; Cool, I was asking if you use nested attributes with form objects. It sounds like not, once you've gone to form objects, you no longer use nested attributes? Gotcha. I have done this in the past, but don't have enough experience doing it where I can say "this is definitely the right path." The way I've done it is how I described above - sort of mirroring what Rails does. If I'm trying to create a Post that HM Photos or something, I might create a form class for the Post and a form class for the Photo, and then define a images_attributes accessor on the Post form, which at some point I turn into an Array of Image forms, then part of validating the Post form becomes running validations on all of the Image forms. Form classes can cause as much complexity as they solve, if used at the wrong time, which is why I always start without them. For example, the to-many problem that you highlighted can become overly complex, whereas Rails can natively handle it beautifully. There's no need for the added complexity of form classes if you can avoid them. But if you find yourself needing to add complex logic to your controller or to callbacks in your model, or if you need to define a virtual attribute on your model (that's a big signal to me), then it might be worth checking out form classes to give all of that logic a home. Another awesome use-case is multi-step forms, which I didn't really get into in this thread yet. If you want the user to incrementally build a record or records over the course of multiple forms, form classes work wonders there. You might otherwise find yourself conditionally validating attributes depending on maybe a "step" virtual attribute on the model, or something along those lines, which becomes a total nightmare if you ever need to create that record outside of that multi-step form. A scenario like that also implies that the model/models are rather complex, so being able to break it into logical chunks that align with the forms that the user actually sees and giving the surrounding validations and logic a home in those classes helps organize all of that. 
Hmm, still can't figure it out. I just sent you a message with my code!
Cool, good to know.
I think both puma and passenger will serve you well.
I find the opposite, passenger is _way_ easier to learn. But some of the primo features are behind "enterprise" pricing, that being an issue is really the only reason I'd consider puma instead. I think puma will work just fine too, but will be take _more_ effort to manage effectively. 
would you like to share your runit very long command? Or even PR it to puma docs? :)
The question is what motivated /u/knowledgebethekey to switch from passenger to puma. A totally legit question, that you are bizarrely trying to derail. 
&gt; A totally legit question, that you are bizarrely trying to derail. are you high?
Do you even know what you're asking for? 
No, I usually wait until after work. 
It was just that your wording was so "hard". I dont think I had a *real* reason when I switched. It was just available and damn easy to install and use.
[https://gitlab.com/honeyryderchuck/httpx/wikis/Make-Requests](https://gitlab.com/honeyryderchuck/httpx/wikis/Make-Requests) it does simple just fine. 
For anyone else reading these comments, I also replied privately to /u/heyhey1515113, and I think the issue is this: Store.all[index] # Does not return a Hash; returns a Store So, it's probable that this: puts "The hours of #{store_info[:name]} are #{store_info[:hours]}." should be rewritten like this: puts "The hours of #{store_info.name} are #{store_info.hours}." 
Isn’t this just a copy and paste from the ruby docs?
&gt;So split should return an Enumeration instead. But that's not backwards compatible. They could add something like `split_enum`. An important advantage of the enumeration is that you can chain other methods like `map` or `find`.
Hmm, are you not able to do that with the enumerated_type gem? I thought you could
Didn’t find that gem while searching ruby gems. It does look similar but doesn’t seem like you can have associated values or methods for each variant. However I might be mistaken. The readme is a bit confusing. 
Yeah it is. It spends more time talking about why enums are useful than how it works.
Rust's enums are what you'd call more generally algebraic data types in other typed FP languages - if you search for "ruby algebraic data types" you'll get more results. I don't quite follow what the gem is doing that you aren't getting from simple class inheritance (`module Colors; class Red; def rgb` etc.) but it's cool that it's working well for you and you're bringing back lessons from Rust
Yep I'm aware of algebraic data types. I've written lots of Haskell in the past as well. But I did not consider googling that. Will do 👍 The main advantage this brings over inheritance (which I used to use) is identical structure across all your enums, and less boilerplate of course. I work on a quite large Rails json api and it is hard to be consistent with how you define things like this. However this gem just uses inheritance under the hood, so less boilerplate is really the only difference.
Great writeup. One minor note: http.rb is pure Ruby but its dependencies are not, so in that sense, it is still a native gem.
Just to toss my own hat in the ring, a different take here: [iron-enum gem](https://github.com/irongaze/iron-enum)
oh? I hadn't noticed! For my purposes, I often really mean "works on Jruby" when I inaccurately say "pure ruby". Although pure ruby is the most reliable way to do that. http.rb works on jruby somehow... alternate implementations?
I think it is getting downvoted because it has poor exception architecture could be why. It is legit annoying to use in comparison with a rewrite like ‘http’
The example with split has more logic than the example without. So it makes it look bad, but it’s not really an apples to apples comparison. 
Any support here for a once or twice-a-month "what you published"? I'd love to see what everyone else is working on.
I've used a few enum libraries and they always turn out to be frameworks for value objects. Most often I end up factoring them out as simply redundant syntax. These days you'd have a hard time convincing me not to start with POROs. `class Color::Red &lt; Color["#ff0000"]; end`. 
Something like this: run file: #!/bin/sh cd /var/www/app chpst -u app:app env -i HOME=/var/www RACK_ENV=production /usr/local/rvm/wrappers/ruby-2.x/bundle exec puma --dir=/var/www/app -t 1:1 -w 2 --preload --pidfile=/tmp/app.pid and finish file: #!/bin/sh kill $(cat /tmp/app.pid) 
You're probably right, but I would still like measurements.
I think this is exactly the feature I was asking for
I switched to [Oga](https://gitlab.com/yorickpeterse/oga) for my XMLish parsing needs after getting sick of how often nokogiri would fail to build.
One I used to use: https://github.com/beerlington/classy_enum It hasn't really been updated, but I liked how it worked, and I think it stills works on the latest Rails.
I have need of namespaces. When I last checked, Oga seemed uninterested in handling namespaces in a reasonable way. 
I'm not 100% sure, but I believe he was asking about the entire statement "freedom from OOP" and not what OOP stands for. I assume you're saying that because Clojure is a functional programming language. 
Because copy/paste is so hard?
Why doesn't it return an array like it does when not passing a block?
This bothers me, as I feel #split should still return an array? Maybe should have named this version with block something else.
What does this do that [`git branch --merged | grep -v '\\*\\|master\\|develop' | xargs -n 1 git branch -d`](https://github.com/colindean/hejmo/blob/master/dotfiles/gitconfig#L11) mapped as an alias cannot?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [colindean/hejmo/.../**gitconfig#L11** (master → 84ca757)](https://github.com/colindean/hejmo/blob/84ca75737df1d0c24d0fc6342da07e2e024fdd8a/dotfiles/gitconfig#L11) ---- 
Do NOT pass secret tokens in params. You want ENV variables, e.g. https://github.com/bkeepers/dotenv
I believe this is the non-secret Stripe token. This is similar how it is done in their docs. https://stripe.com/docs/checkout/rails customer = Stripe::Customer.create( :email =&gt; params[:stripeEmail], :source =&gt; params[:stripeToken] )
You can use named arguments: https://robots.thoughtbot.com/ruby-2-keyword-arguments
Thanks! I'll check those out.
Hi, I am an author of Haconiwa. We use Haconiwa for web hosting, so-called PaaS: [mc.lolipop.jp](https://mc.lolipop.jp) (This site provides only Japanese content...) Haconiwa is very good at resource control and event-driven hooks, so we use it for web hosting basis that requires fine resource control. I believe Haconiwa is also suitable for general web development. I am creating a small orchestration tool [https://github.com/udzura/marfusha](https://github.com/udzura/marfusha) but it is still under development :( I want to know about demands use cases!
It enables me to interactively choose which branches to keep or delete (and see a bit of information about each branch as I go), as opposed to deleting a certain set of branches for me automatically based on their properties. I usually find myself wanting to do the former, rather than the latter. But then everyone has a different workflow. If the gem doesn't add any value for you, then that's cool.
What you're looking for is string concatenation or interpolation. Interpolation is usually the easiest to see what's going on. If you use a string with double quotes it will permit string interpolation using the `#{expression}` syntax. ``` street = doc.css('.address').children[0].text city = doc.css('.address').children[2].text address = "#{street} #{city}" ```
Yes, without something to validate what's defined in the enum's set of values (e.g., typing) this is all seems like gratuitous syntax sugar for value objects or, in the cases where an alternative value needed, a `Hash`: `COLORS = { :red =&gt; 0xFF0000, :blue =&gt; 0x0000FF }.freeze`. 
 ~/code/cti &gt;gem inst smart_enum ERROR: Error installing smart_enum: smart_enum requires Ruby version &gt;= 2.4.0. Why require 2.4? Also taking the example in the README: ~/code/cti &gt;ruby -rsmart_enum module Colors extend SmartEnum variant :Red do def rgb [255, 0, 0] end end variant :Blue do def rgb [0, 0, 255] end end end p Colors::Red.rgb # =&gt; [255, 0, 0] p Colors::Blue.rgb # =&gt; [0, 0, 255] Traceback (most recent call last): 2: from -:1:in `&lt;main&gt;' 1: from -:2:in `&lt;module:Colors&gt;' -:2:in `extend': wrong argument type Class (expected Module) (TypeError) 
Naw, it's cool. I am interested in the workflow that you have that would lead you to design and implement this tool. I guess I never really keep branches around for anything longer than it takes for them to be merged in pull requests. If I have a long-lived branch, I know that I need to rebase it after a while. I'm particularly interested on the properties of a branch that would cause you to delete it other than it being fully merged.
It seems a bit strange to get 3 values from `@certification_application` just to pass them back to `@certification_application` via its `#make_payment` method. While I would definitely not put anything related to network calls to 3rd party services in my model, this method can be reduced to `@certification_application.make_payment(token)`. Really, I would do something like this: class Payment def initialize(token) # ... end def charge(price, quantity, description) # check for not nil, &gt; 0, etc... end end payment = Payment.new(card_token) payment.charge(@certification_application.certification_level.price.to_i, ...) But I'm the type of guy that does not want my payment related code to have dependencies on things like `CertificationApplication#individuals`, `CertificationApplication#certification_level#price`, etc... 
Thanks! I was considering putting the external API calls into a wrapper of some kind. Currently, I am checking if quantity &gt; 0 in my make_payment method.
It looks like you're telling an object (`@certification_application`) to do something, based on things that object already knows. That's a classic code smell, called [Inappropriate Intimacy](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) and it's probably what you're sensing is wrong. I suggest implementing a Payment model that both models and handles the charge. The `CertificationApplication` object probably `has_many :payments`. At payment time, the CA object should build a payment object (e.g. populating it with the `amount` and `card_token` fields). Then you tell the new Payment object to make a charge attempt, and persist the result. Later on there might be questions of exception handling, duplication-charge prevention/locking, persistence certainty, wallet management, multiple payments, application of credit, management of refunds &amp; price changes and so on - all of which will be much easier to deal with when you extract conceptual entities into their own objects the moment they become interesting. 
Maybe I should have checked that the gem name isn't taken. Turns out it is https://rubygems.org/gems/smart_enum. So thats why the example code didn't run. I guess you'll have to delete the gem you installed and install my gem via `rake install`.
For various reasons, there can be branches on my local that I end up not wanting to merge. Perhaps I tried out a particular approach or feature, that I subsequently decided not to proceed with. That might not become apparent right away.
Cool, I saw that yesterday and watch your slides. There is a need for a proper site like Nodejs where we can learn. I see Envoy is popular, how does haconiwa compare to Envoy?
I don't see what's going on here. Something is off if the solution is to include \`Rake::DSL\` in a class. Better yet, "don't step on the Rake at all". Just avoid rake completely instead.
Extract `(price, quantity, description)` to a single object. What is it? Payment specification? Payment description? Transaction? Transaction description? Then you can just `stripe_adapter.charge(cerfication.transaction)`. These three attributes together probably have a name and meaning in the business domain.
I doubt it has improved. Signing is unknown and underused. Hence my point that leveraging and promoting, maybe even enforcing, this already in-place security-tool would be the first step.
This is likely point you in the right direction: https://github.com/gosu/gosu/tree/master/dependencies/msvcrt-ruby
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [gosu/gosu/.../**msvcrt-ruby** (master → bcb791e)](https://github.com/gosu/gosu/tree/bcb791e67d615dceef7cc82132d01e158ec5548e/dependencies/msvcrt-ruby) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2lj1h9.)
Actually, any method defined outside of module/class will be defined as private on Object: [https://ideone.com/qA6luO](https://ideone.com/qA6luO) on load. Rake just does \`load\` on Rafefile/\*rake
I recommend You to read about strong parameters [http://edgeguides.rubyonrails.org/action\_controller\_overview.html#strong-parameters](http://edgeguides.rubyonrails.org/action_controller_overview.html#strong-parameters)
Hot-diggity-dog, not only did you point me to a potential solution, but you showed me that mruby is a thing and that might help me even more. I can't thank you enough.
&gt; So, nil acts more like a keyword than an instance. As it is just a way to express the “not an object” notion. `nil` is very much an object instance. It's really a 'special' constant that you won't find by looking at `Object.constants`, `Kernel.constants`, etc. `nil`, along with a few others are defined here: https://github.com/ruby/ruby/blob/trunk/include/ruby/ruby.h#L410 Other than the special definition, the `nil` acts very much like a normal instance and `NilClass` as a normal class, e.g. you can add methods to `NilClass` and call them from nil: ❯ pry [1] pry(main)&gt; class NilClass [1] pry(main)* def derp [1] pry(main)* puts 'hi' [1] pry(main)* end [1] pry(main)* end =&gt; :derp [2] pry(main)&gt; nil.derp hi
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ruby/ruby/.../**ruby.h#L410** (trunk → 1adbbc3)](https://github.com/ruby/ruby/blob/1adbbc3f48e1f686729b57cb74c668085078d316/include/ruby/ruby.h#L410) ---- 
oh, sorry, its not the Rails subreddit :)
Thank you for your comment. :-) I get what you mean. I just want to say that there is no call to `rb_obj_alloc("nil", rb_CNilClass)` in the ruby source code. Furthermore, the `alloc` and `new` method are `undef` from the `NilClass`. So we cannot define it as an object instance from this point of view. Otherwise, I totally join you on the fact that `nil` acts like a singleton object. As the duck-typing motto says: "If it walks like a duck and it quacks like a duck, then it must be a duck". 
&gt; I just want to say that there is no call to rb_obj_alloc("nil", rb_CNilClass) in the ruby source code. Furthermore, the alloc and new method are undef from the NilClass. Just worth noting, that isn't unique to `nil`, e.g. `TrueClass`, `FalseClass`, `Integer`, `Symbol`, and `Float` are constructed in a similar way. The reason there is no call to `alloc` for these types of objects is due to MRI using tagged pointers as a performance optimization. 
Exactly, you can get the actual pointer value of these special objects by taking the object id, and doing a bitwise shift to the left. Thank you for your additional explanations. 
Someone thought it was a good idea, because maybe the login service could then be used by multiple apps? I think you're not wrong. 
&gt; I'm assuming the block version reads the string into a buffer until it reaches the separator character, gives it to the block, then clears it and continues Odd assumption. Clears it? Reuses it? Plenty of uses of this sort of code might end up with the String escaping the block, you couldn't assume you could mangle/reuse it after yield returns. Looking at the code, literally the [only difference](https://github.com/ruby/ruby/blob/1adbbc3f48e1f686729b57cb74c668085078d316/string.c#L7651-L7678) is it yields the split-off String instead of pushing it onto an Array.
\&gt; Yeah, looks like [https://github.com/tmm1/http\_parser.rb](https://github.com/tmm1/http_parser.rb) has C and Java implementations, and a dual release? I guess that's the right way ... Not so simple. Unfortunately the java implementation of http-parser (which is the nodeJS http parser) is officially not maintained anymore, and for quite some time already. This means that they can't upgrade the low-level lib to a current version without breaking compatibility with jruby. http\_parser.rb isn't exactly receiving steady maintenance anyway, and it's showing, as it's breaking with latest jruby (there goes the "works in jruby" out the window :) ). I also don't think that performance is the reason why no one writes it in ruby. It's very hard to write a parser which is compliant with the HTTP/1.1 specs, let alone HTTP/1.0 or 0.9. There are just too many quirks that go beyond the simple 200 OK hello world, and you'd better pick something which "just works". \&gt; Although I think HTTParty, at least in the past, was like an order of magnitude or two slower than HTTPClient (which again, is pure ruby!) Since httparty uses net-http under the hood, which is also pure ruby, I'd say that the performance difference lies somewhere else (probably in the fact that it's not intuitive how to reuse connections using httparty, and no one ever does). \&gt; If they really want http.rb to take over, they should probably provide an optional truly pure-ruby "http\_parser" swap I disagree, although they do need to change the parser. I don't see much gain in implementing "yet another" http parser in ruby. One could just use FFI, still using a battle tested library while providing support for all rubies. 
https://segment.com/blog/goodbye-microservices/ good read on the whole microservice architecture thing.
Uh oh. This makes me worried about using http.rb after all -- I do need JRuby compat. Do you think I'm making a mistake using http.rb? Maybe back to HTTPClient after all. These days, with the ruby community haven shrunken somewhat, maintenance of core gems has become a worry. I know that the intention of those who wrote http.rb was really to provide a "new standard" -- receiving regular maintenance is obviously necessary for that goal, but I guess the best of intentions can run up against reality. 
I wouldn’t say it’s dead. It’s a case by case implementation. Totally dependent on what kind of system you are implementing.
Does it let you know if the branch exists on remote or not? That's def a core piece of info I want. Right now I run something similar above that automatically deletes branches whose remotes have been deleted: alias git-prune-tracking='git branch --merged | grep -v "*" | grep -v "master" | xargs git branch -d; git remote prune origin' But it's def not always quite right, false positives and negatives. I like the idea of an interactive one with context that lets me choose whether to keep or not. But the equivalent of whether the above would delete it or not is the _main_ info I want in making that decision! 
The issue is that it may not be obvious which variable you actually want to access. There is a risk that you accidentally shadowed the outer variable. 
Shouldn’t be 5.2 now?
It's not a pointer value, it's an immediate value embedded in the VALUE itself 
Yep, that's next up. We've been doing these series for all Rails versions starting from 2.3.
Oh, really cool. Thanks for the work. 
It's confusing for someone to read, because they have to keep the context of what the variable means both inside and outside the scope. This increases chance for human error (bugs), especially when moving code between the scopes.
A bit slanted, though, of course :) I've read segment's post; to be honest their approach struck me as fairly naive. The service architecture they built obviously added piles and piles complexity and challenges, and I recognize that their pain was real, but I also wouldn't be surprised to discover that their services themselves weren't particularly discrete or autonomous. In a microservices architecture, the condition that most typically gives rise to a desire to merge repositories together is an absence of autonomy. When changes to multiple services have to be checked in, released, and ultimately coordinated together, those services are definitely _not_ autonomous. Their interdependency is demonstrated by the need to consider them together. So, I'd hate for people to generalize service architectures in general because of segment's experience. By contrast, I would never stand to gain anything by combining my services into a single repository, because they each stand on their own. I never have to run the whole service stack on my laptop, for instance. To the OP, I wouldn't use the term "services" to describe your topology. One thing to get out of the way before the rest of my explanation, the term "service" is very overloaded in software, so it leads to an incredibly confusing landscape of similar terms being used to reference entirely different ideas. The login service would be more appropriately called a _web_ service, rather than a _micro_ service. Microservices are an offshoot of service oriented architecture (SOA), which first and foremost must be discrete, autonomous programs that stand on their own. A login "service" cannot ever stand on its own because it's purpose is to log you in to something _else_, i.e. some other web service or app. And a Rails app can't be a service because it's an app. Again, for the OP, I'd strongly suggest that you are not in fact working with projects that meet the criteria of what a service actually represents. Just to show you how far off the term "microservices" has diverged in common parlance from its actual meaning, here is an article from early 2006 about the subject: http://udidahan.com/2006/01/08/autonomous-services-a-step-beyond-service-orientation/
The java lib is a non-affiliated "backport" from the nodejs parser, definitely from a different organization. The nodejs parser is in itself c++, and still maintained by joyent afaik. If you need compatibility with jruby, it probably is a bad idea. I'm maintAining httpx, linked below, and I'm also a victim of this, as httpx uses the same parser. In the end reimplementing the net-http baby parser might not be the worst solution one can come up with, at least compatibility-wise.
Hmm, yeah, even copy-paste of net-http parser to rejigger it to work how you need, assuming net-http parser is written in ruby and not C. I dunno. How dissapointing all around. :(
 bool = false bools.each do |bool| if func(bool) == 42 bool = true end end bool Ignore the stupid logic, but this illustrates what the warning is about. Line 4 makes an assignment, which will overwrite the loop local variable, when the intent (as I wrote it) would be to update the method-scoped variable. The warning in particular is simply encouraging less variable name reuse, as it helps to avoid any confusion about ambiguous situations. 
Also my go to client at this point. I read about it in some blog post here on reddit not that long ago, can't believe I haven't come across it sooner - its such a joy to use even for more complex scenarios. I used to use `httparty` which is super straight forward for the simplest use cases, but gets a bit hairy for more complex things. Here's an example from something I wrote the other day: ``` Http.cookies(cookies). follow. use(:auto_inflate). headers('Accept-Encoding' =&gt; 'gzip'). get(file_url). body. to_s ```
this is the first time i've encountered this pattern, and i've been writing ruby for a long time. i can understand why it's confusing. looks like a hacky way of early returning `self` when the method is called with no arguments. i don't understand why someone would write this over the following: ``` def clone(opts = nil) return self if opts.nil? ... end ``` there might be something i'm missing, but from messing around with it for a minute or two i can't tell a practical difference.
It looks like it was written by someone who is completely new to programming. 
It returns `self` if no argument is given for `opts`.
&gt; A good example for what I mean by "complicated" is how Class is a an Object of type Class that inherits from Object. To me, that's exactly an example of what makes ruby _simple_! 
Also see https://gitignore.io
Seems that Rspec has a bunch of flags it uses. I've been able to get the suite to actually run now by adding "require 'rspec/autorun'" to my spec_helper, as the documentation suggests, but this comes with a Deprecation warning. ```Requiring `rspec/autorun` when running RSpec via the `rspec` command is deprecated. ```
Very nice. Why Ruby (&gt;= 2.1) instead of Bash though? Thinking that the latter would allow folks to adopt more easily. 
First time I've seen that pattern as well. Can't say I'll ever use it, but I'd be interested to hear Jeremy Evan's opinion on using it in that spot ([https://github.com/jeremyevans/sequel/commit/c597dea7541ab2ed3a17cb3bfb844422f128587f](https://github.com/jeremyevans/sequel/commit/c597dea7541ab2ed3a17cb3bfb844422f128587f))
Might make it a compile-time effect instead of a runtime effect. It’s too clever for me though.
\&gt; Does it let you know if the branch exists on remote or not It does not, but I can see that would be useful. I'll consider adding it. (Feel free to create an Issue—or PR :)
Thanks :) And fair point. It was mainly because it just seemed easier to write it in Ruby. I initially just hacked it together for my own use, then once it was done, I though I might as well make it into a gem :/
So as other have said, it returns `self` when called with no args, but the way it does it is by exploiting two things. One, that default argument values can be code (so you can write things like `def whatever(thing = Thing.first)`). And two, that said code to provide a default argument only gets executed when it needs to kick in because the argument wasn't provided. The reason it's two statements is that `return self` isn't actually providing a value. The interpreter will complain unless the expression has a value. This is just way too clever in all the bad senses of the word. Who thinks putting flow control into the method definition itself is a good idea?
It's not exactly the same - it's basically a dynamic arity test guard. You'd potentially get a different result from `object.clone(nil)` than from `object.clone`, which is not the case if you test the argument for nil. Of course in this case what you actually get from `object.clone(nil)` is a TypeError, so it doesn't make any sense to me in this case. Maybe it benchmarked better? In general I'd rather see a private constant and test for it in the guard clause, viz. class Foo DEFAULT_OPTS = BasicObject.new private_constant :DEFAULT_OPTS def clone(opts = DEFAULT_OPTS) return self if DEFAULT_OPTS == opts #... end end Which is easier to comprehend and will look a lot better in any generated documentation. 
Might not be exactly what your looking for, but in those dark nights wondering rspec darkness, this has brought me some light. http://www.betterspecs.org
&gt; Maybe it benchmarked better Does seem to: nil: return self if opts.nil? 3.376M (± 1.6%) i/s - 17.015M in 5.040478s nil: return self if NOPE == opts 3.644M (± 0.2%) i/s - 18.288M in 5.018904s nil: opts = (return self; nil) 4.218M (± 0.4%) i/s - 21.210M in 5.028432s hash: return self if opts.nil? 3.057M (± 0.1%) i/s - 15.291M in 5.002680s hash: return self if NOPE == opts 3.086M (± 0.1%) i/s - 15.486M in 5.017900s hash: opts = (return self; nil) 3.421M (± 1.9%) i/s - 17.245M in 5.043837s You do tend to clone datasets a lot in Sequel since it's how queries are built, so I can't say I'm too fussed about a slightly ugly micro-optimisation in there.
If many services exist and need to share login capabilities in an SSO type of fashion... makes sense. If this is two services for the sake of micro services when they could just be one codebase... yeah it’s a bad idea. Hard for anyone here to say 100% without more info. 
&gt; ho thinks putting flow control into the method definition itself is a good idea? Someone working on a project where every nanosecond counts?
Oh wow this is neat, I wasn't familiar with this before now—thanks for sharing!
Then just add a comment to the line asking that. Just click on the + to the left of the line and github lets you write a comment that will be attached to that particular line :)
If every nanosecond counts ruby is the wrong language to be using.
That’s a very shortsighted statement. It depends how often it comes into play. If you prolong `Kernel#puts` by some nanoseconds, noone will care. But increase `Array#[]` and`Hash#[]` by the same amount, and people will start to notice. As far as I understood, this tidbit is in Sequel, one of the main ORM layers in use by Rails; it gets invoked millions of times, in thousands upon thousands of servers. It’s definitely worth optimising. 
https://brakemanpro.com/blog/jrubyfx/2015/09/05/what-is-jrubyfx
Ok. Another library. That is used for?.. According to the site, they secure Ruby on Rails applications, which is exactly #1 in the list.
I make crappy little Swing apps for or Tier 1 Operations, Management and Marketing teams! It's never anything more than a 1-3 different views, so I haven't done anything with very complex widget/view interactions. Requests for these small "single idea" style apps didn't even dawn on people until I started building them to save myself time from doing these actions for coworkers and emailing them the results. Now, I get 2-3 requests a month ranging from "I want a button that I can press that poops out an excel document based in some database/webservice query" to "I want to spam this big list of emails individually, with an attachment customized for each person". It's a nice change of pace from the normal day-to-day work for "Website #29813", "Daemon #91383" or "ETL Job #71731".
A Fair point
=-) I'm glad that you can do it.
The ecosystem around Ruby is specialized for web development and other related areas. This is just how it is. There are other uses for it of course, but it's not a general purpose language in the sense that Python is. This can make you sad or it can motivate you to learn another language. For me it has the later effect. 
Can you write an example tutorial so I can get an idea of what it's like?
I know other languages. But I never feel so... light, eloquent, when I use them. I don't feel the joy. And it makes me sad =-(
Don't fall in love with your tools my dude.
Have you checked out RubyMotion? There's an example of a popular iOS game here: [http://www.rubymotion.com/references/success-stories/a-dark-room/](http://www.rubymotion.com/references/success-stories/a-dark-room/) made in Ruby, and apparently all these companies have some sort of Ruby on iOS going on: [http://www.rubymotion.com/references/customers/](http://www.rubymotion.com/references/customers/)
Necessity really is the mother of invention 
By "backend," do you mean using ruby to build a web server? I write services in ruby that have nothing to do with web servers all the time. It's a very solid general purpose programming language.
True, but one of the awesome things about truffle ruby will be that a computer will be performing these optimizations at runtime, which as a framework author I'm really excited about.
Look at mruby. Maybe you'll have fun with that.
I know a number of companies that have used RubyMotion for their mobile apps. You really only have a few real 'realms' of applications for the most part, web, infrastructure, desktop and mobile. I see Ruby used all the time for web (rails), infrastructure (chef, puppet) and mobile (RubyMotion). I don't see it used for desktop apps very often but I honestly don't use that many desktop applications, they are kinda dying outside a few niches. A lot of them that may have been in the Gosu wheelhouse are built with electron now (slack, spotify).
&gt; I feel the same demotivation that I feel when I use an obscure or old language, like D or Pascal. I feel that my skills are useless, that if I would use, for example, C# for GUI project, my app will be more valuable for some reason - not because it will be faster, or smoother, but because other people use this technology alongside me. Well, it's pretty simple: don't get a job doing desktop app development. If you stay working in web dev then there's no reason to be programming not web dev, and you have a much better chance of it making sense for you to use this tool you love.
It's not just a tool, it's a language
Interesting coincidence! We published [https://github.com/ShippingEasy/smart\_enum](https://github.com/ShippingEasy/smart_enum) a few weeks ago which was extracted from our production codebase to tackle a similar issue.
&gt; [Add comment explaining use of control flow in default method argument](https://github.com/jeremyevans/sequel/commit/ab156c35eb0dd29c245f3c83beed229a2413e903) def clone(opts = (return self; nil)) + # return self used above because clone is called by almost all + # other query methods, and it is the fastest approach c = super(:freeze=&gt;false)
How are you running your ruby script? Here's an example of how to run it: rspec use_case_spec.rb -f documentation 
also, I use: require 'rspec' require 'rspec/expectations' 
I came here to say this. There are already way too many places in ruby/rails land that behave like this when they could just return a lazy enumerable.
Seconded. I'd love to browse an example!
I'm not very good at writing tutorials. But I can show you an example of one of the apps. We have an application that filters and processes incoming messages before forwarding them to the appropriate people (via email/text/xmpp/etc). The administration pages where you define filters and matching criteria and other rules are run on regular expressions. We have our operations team, many who are struggling with the basics of regular expressions, manage large regular expressions that are basically a|b|c whitelists/blacklists. So, I made a small app that will change a|b|(c|d)|e into a b c|d e and back again while alphabetizing and removing duplicate entries. Their UI runs on old code and will probably never get updated... :\ (I am not giving up the fight, though!). So the Swing app is not super complex and its more of a bandaid than a fix - but its enough to keep the size of these regexes down so that they can be reviewed once a month to remove stale entries or golf down some similar entries. require 'java' require 'forwardable' import javax.swing.SwingUtilities import javax.swing.JFrame import javax.swing.JEditorPane import javax.swing.JScrollPane import javax.swing.JTabbedPane import javax.swing.BoxLayout import java.awt.Dimension class Application &lt; JFrame attr_reader :window def initialize super 'Regex List Editor' @window = Main.new end def configure tap do |frame| frame.size = Dimension.new(800, 600) frame.layout = BoxLayout.new(self.content_pane, BoxLayout::Y_AXIS) frame.default_close_operation = EXIT_ON_CLOSE frame.add frame.window.configure frame.visible = true end end def wait @thread = nil SwingUtilities.invokeAndWait { @thread = java.lang.Thread.currentThread } @thread.join end class Main &lt; JTabbedPane attr_reader :list, :regex extend Forwardable def_delegators :@list, :to_regex def_delegators :@regex, :to_list def initialize @regex = Tab.new('Regex') @list = Tab.new('List') super TOP, SCROLL_TAB_LAYOUT end def regex=(value) @regex.text = value end def list=(value) @list.text = value end def configure tap do |frame| frame.add_tab frame.regex.name, frame.regex frame.add_tab frame.list.name, frame.list frame.add_change_listener do |event| case frame.selected_component when frame.regex; frame.regex = frame.to_regex when frame.list; frame.list = frame.to_list end end end end end # Application::Main class Tab &lt; JScrollPane attr_reader :name extend Forwardable def_delegators :@window, *%i[text text=] def initialize(name) @name = name @window = JEditorPane.new super @window end def to_regex text.split(?\n) # split on new lines .grep(/[^[:blank:]]/) # gather all lines that have at least one character .sort_by(&amp;:downcase) # sort lines by the lowercase version of each line .uniq # remove duplicate lines .join(?|) # join all lines by the pipe character end def to_list # ( # first capturing group # (?&gt; # open an atomic group (like a non capturing group) # [^|(\[]++ # all characters except | and ( and [ # | # OR # ( # open the second capturing group # [(\[] # ( or [ # (?&gt; # open a second atomic group # [^()\[\]]++ # all characters except parenthesis and brackets # | # OR # \g&lt;-1&gt; # the last capturing group # )* # close the second atomic group # [)\]] # ) or ] # ) # close the second capturing group # )+ # close the first atomic group and repeat it # ) # close the first capturing group text.scan(/((?&gt;[^|(\[]++|([(\[](?&gt;[^()\[\]]++|\g&lt;-1&gt;)*[)\]]))+)/) .map(&amp;:first) # map to the first capturing group .grep(/[^[:blank:]]/) # gather all lines that have at least one character .sort_by(&amp;:downcase) # sort lines by the lowercase version of each line .uniq # remove duplicate lines .join(?\n) # join all lines by the new line character end end # Application::Tab end # Application Application.new.configure.wait 
While I don't want to negate your genuine enthusiasm for your project, can you please take a moment to imagine what this subreddit would be like if every library author such as yourself promoted their gem to the same degree?
Not really sure if this counts, but we use ruby to do provisioning and monitoring on fibre networks. It's basically low level integrations through protocols like SNMP and TL1 to the network gear. We use Sinatra to provide API access, and Sidekiq for the background processing. 
I ended up blocking some user (whose name I've forgotten by now) because they just post constant spam of their gems to this sub and half a dozen others. I'm here for news, articles, and the *occasional* look-what-I-made, but not a post for every new line of code added to some random gem nobody's ever going to use. Looking at /u/westonganger's post history, they've made 3 posts about this gem and have literally 0 other activity on reddit. Looks like another one for me to block, if just on principle at this point.
If you are interested in efforts to type Ruby, there's a large number of efforts (ten papers!) on http://rubybib.org/
I dunno what's going on there, line breaks in your code would help. But I feel safe in saying that putting a `return` in an argument default value is an abomination. 
Then why the hell are they using Ruby? I love the language, but fast it is not. :P
No language is good at everything, so you shouldn't get overly attached to one language. The real job is designing and building software, the specific language you're using will change many times over the course of your career.
I'm curious what the impetus is for adding static typing to Ruby. I work on several fairly large Ruby code bases, some rails, some just plan old Ruby and the bugs I run into (and create) are only very rarely related to passing the wrong type to something. I wouldn't even put it in the top ten causes of bugs.
What would you put into the top ten causes of bugs?
Good question. Off the top of my head and taking a look over exception logs from the last couple weeks here is a list of causes in no particular order: * Lack of understand of Biz requirements * Side effects (more often interaction of several side effects, across different systems, not side effects in FP sense) * Distributed systems issues (timing issues between background jobs, sequential requirements, client server sync, etc.) * Missing or bad tests * Bad architectural designs (e.g. using mongo) * Code that runs in production not being exercised in dev/test * Caching * Error handling (Net::HTTP is a ghetto) * External services * External libraries * Performance not cutting it (75% bad architecture, 25% Ruby is too slow even after optimization passes) 
I did a workshop using the Eventide project a while back. [https://eventide-project.org/](https://eventide-project.org/) Last I checked their documentation was *extremely* lacking, though.
Thanks u/Elw00t I have that site bookmarked and love it... The issues I'm having are more to do with how to handle the file and folder aspect of testing... I'm comfortable using factories when it comes to a DB driven rails app... but have never dealt with a command line app that runs on file systems. I seem to have two options: I can create a sandbox folder with preset folders for all the test conditions I want to handle... or I can create the needed files and folders on the fly... 
To run the script, I'm typing: \`\`\`ruby bin/image\_gps.rb \[options\] \[optional/path\]\`\`\` To run the tests i have a Rakefile and just run rake \`\`\`rake spec\`\`\`
Yeah, I checked them too recently. They doesn't seem super active. On the other hand we also have https://github.com/RailsEventStore/rails_event_store and it seems promising, too.
I like using Ruby contracts for executable documentation and catching errors early and meaningfully. Contracts can be much more useful than plain types though.
&gt; executable documentation and catching errors early and meaningfully. That just sounds like a marketing pitch, what does that _mean_? I mean, if contracts is catching errors your test suite isn't, then the problem is with your test suite. If you're placing tests with contracts, I think that is a really bad approach. Static typing isn't a replacement for exorcising code paths in your tests.
Executable documentation should be easily understood. The method signature gives me, a human, a better idea what the method is intended to do, and the computer verifies this each time it's executed. Of course it doesn't mean there are no bugs in my code during development, but it makes said bugs easier to find. Catching errors early and meaningfully. How can anyone not know what this means? When I stuff up and pass the wrong thing to a method, I found out what the actual problem is rather than getting a Nil-related error three more stack frames deep. This is completely orthogonal to testing. All the tests in the world doesn't mean I don't want an enforced reminder how to use my library code. Checking prerequisites are meet before continuing. What could be controversial about that? 
&gt; Executable documentation should be easily understood. The method signature gives me, a human, a better idea what the method is intended to do, and the computer verifies this each time it's executed. I don't know what 'executable documentation' means. Are you saying that contracts injects type checking at runtime in production? If so, I'm immediately not interested, the method call overhead in Ruby is bad enough already without adding more work. Also, you can simply document your method with comments and achieve the same goal in terms of developer understanding, without a convoluted type system or runtime overhead. &gt; Of course it doesn't mean there are no bugs in my code during development, but it makes said bugs easier to find. I just have a different experience there, I don't see the time savings offsetting the work needed. &gt; This is completely orthogonal to testing. All the tests in the world doesn't mean I don't want an enforced reminder how to use my library code. I don't see how it's orthogonal? If I fuck up, my tests tell me I did so, is that not 'early and meaningful'? I also _really_ don't want someone writing a library imposing runtime overhead and limiting what I can pass to it. I've dealt that that garbage in Java a _lot_, nothing is worse than the Java library author deciding something should be `final` forcing me to fork the library to fix it. If your method needs a thing that is a string, call `to_s` on it, then I can pass you anything I want to that implements `to_s`, this is the ethos of duck typing. &gt; Checking prerequisites are meet before continuing. What could be controversial about that? Type systems are a _BIG_ topic, what is controversial is the definition of what a valid prerequisite is and how to determine that. e.g. I work in several statically typed languages as well and my opinions of them vary widely based on the capabilities and implementation of their type system. The problem today is that there tend to be only three options: dynamic typing, static typing with a simple but anemic type system that forces you into writing shitty code to fit the type system (e.g. Java, especially pre 8), and type systems that are flexible enough to write good code with, but require a huge amount of mental burden to wrap your head around and force you into weird boilerplate to achieve your goal (e.g. Scala). 
rails is a mess, please don't hurt yourself
I like it. Keep it simple. 
What's the problem you're trying to solve?
Most of my ruby applications do real work in the background like automating nmap and nessus scans. I leave the gui parts to web interfaces. Being a polyglot is where the fun is.
Nothing in particular. I am wondering for what kind of projects/problems it is suitable. Call it, learning curiosity.
For tests that use `ENV`: https://github.com/thoughtbot/climate_control
IME event sourcing makes lots of problems go away if you're dealing with large, complex data- and workflows. The comparison I draw after a couple of projects (one with Eventide, one with [Rails Event Store](https://railseventstore.org/)) is with Redux in React/JS apps: if you need it, it's absolutely lifesaving, but 85% of the time, if you don't absolutely *know and are able to prove* that you need it, you don't. These days, I'm mostly in [Hanami](https://hanamirb.org/) rather than Rails, and I find Hanami::Model and the underlying [ROM](http://rom-rb.org/) delightfully more than sufficient.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://rom-rb.org/) - Previous text "ROM" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
If static typing is what you want and you don't mind new syntax you may as well just learn Groovy. 
Or use static typing and keep the same syntax with Crystal! 
&gt; using mongo 🔥 🔥 🔥
I am currently in the final stages of migrating a Rails app off of Mongo and on to MariaDB. No one will admit to having made the original decision, but it was a poor one. I have not yet in my career encountered a use case where document stores have proven a good fit. 
I guess that's the tricky part - deciding when to jump into using event sourcing... Thanks for the shared experience!
Stripe has a fully functioning (not publicly released) static typechecker for ruby. trysorbet.com
&gt;I am sure this is a super useful feature, but the example in this post looks more elegant without it. It also claims to be a performance optimization, by using less memory, but has no measurements. We added benchmark results for \`split\` and \`split with a block\` - [https://blog.bigbinary.com/2018/07/17/ruby-2-6-adds-split-with-block.html#update](https://blog.bigbinary.com/2018/07/17/ruby-2-6-adds-split-with-block.html#update)
That's pretty cool I'm glad the theory matched the results. It does appear however you picked only the case most likely to come out in favor of this new method. That is only part of the story what would a more common case look like? What if someone doesn't know if they're going to have a large string and fears that because they'll have a large drink on occasion they should use a block. In these cases knowing whether or not the block style has some extra overhead would be useful. Sorry if this sounds demanding, I know you don't have to do this but I suspect you will get the most users if you rigorously test this in a variety of ways.
My experience totally differs because we do a lot of MVPs. Mongo has been a very good fit for use cases where the app is still evolving feature sets/ data structures. Unless the applications are likely to have relational moving parts its something I always consider
yeah he lost me there
Interesting. I’ve got a very old (pre-1.0) Rails codebase and NoMethodError (and funky factories) are try bane of my existence. To be fair, they are minor problems and quick to fix, but I wish they just never happened at all. 
Problem is static typing is conflicting with the idea of duck typing. Imho that's an anti pattern to check for a type in ruby, should check for method presence instead.
Your comment implies you didn't actually read the article. When asking for examples it is just polite to read the info provided before dismissing them.
Well, Groovy and the JVM are a wee bit more mature at this point. I'd be hesitant to write any serious app with Crystal. 
We had probably 8TB of data in mongo at one point, it was hell, I could rant for hours about how awful a database it is without even getting to schema issues. But, the bigger issue I would say is that the lack of transactions forced crazy architectural designs in code in order to maintain (at least roughly) consistency in the face of needing to atomically apply updates to multiple things at once. I've spent a decent part of the last year moving stuff out of mongo into PG, but there are a few things left. Some sync operations went from taking 36 hours, to 12 seconds due to being able to use transactions to maintain consistency and SQL views to transform data and expose it to other systems. 
Use PG and put all the fields in a single `jsonb` column, use something like https://github.com/devmynd/jsonb_accessor to expose the attributes. This is more flexible than mongo, faster, and a better base to build off since in many cases you can 'promote' a field from the `jsonb` column to a normal column with little to no code change. 
We are indeed active! As /u/creepywizard remarked, documentation has been light, and recently we've been on a big push to flesh out our docs comprehensively. If you check out our homepage, eventide-project.org, we have some documentation, and a link to join our slack community. Cheers!
As a project principal, I'm interested in hearing about your experiences with Eventide, if you're willing to take the time. Any and all criticism is welcome! &gt; if you need it, it's absolutely lifesaving, but 85% of the time, if you don't absolutely know and are able to prove that you need it, you don't. I'm also interested to hear more about this. What are your guidelines or criteria for determining whether event sourcing is necessary? And, when you decide you don't need it, what advantages are gained by not choosing it?
Thanks for the tip !
Great post. The aside on how MRI essentially inlines default argument initialization to the method body reminded me of Function::Parameters in Perl.
Can you share why you chose Maria over PG? I used MySQL for years, then Maria, then a year or so ago I moved to PG as it had become the standard for Rails. Wondering if you had a particular use case where Maria was the better choice. 
Banal reason: our organization doesn't officially support PG. I originally wanted to go that route, but the ops team only allows certain approved configurations in higher environments, and PG isn't on the list. No idea why.
Then again at this point I'd be hesitant to use any Ruby Add-On Static Typing ™️ that wasn't at least embedded in comments.
One of the myths of new app development (particularly consumer facing) is that you will build the app one time and not have to rebuild it. If the company is innovative theres always a rewrite. Mongo is fine for lots of situations. I realize people pushed it as the next big thing that would replace relational but theres no reason to go the other way and hate on it in every situation
Long live CGI! 
What happens if you just run rake? I would have to see you rake task (spec). Here's my task: task :spec do Dir.glob('*_spec.rb') do |spec_file| sh %{rspec #{spec_file} -f documentation} do |ok, res| raise "test failed" if !ok end end end
Nice one. I agree with most of it. :) ### 
Hello, I've written-up a hands-on getting started guide for the new sportdb text library / gem. Let's build the standings table for the English Premier League (EPL) for the 2017/18 season from all 380 matches in the comma-separated values (.csv) format. Full article titled "[Working with CSV Files](https://github.com/sportdb/docs/blob/master/working-with-csv-files.md)". Enjoy the beautiful game with ruby.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [sportdb/docs/.../**working-with-csv-files.md** (master → e5720bc)](https://github.com/sportdb/docs/blob/e5720bc2a99c2604cbbf27220443e745dfa7b65e/working-with-csv-files.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2qdz9p.)
&gt; but theres no reason to go the other way and hate on it in every situation I have not run into a single situation where it is a better choice than PG, I'm sure one exists somewhere I guess...
better how? faster to market? Nope better at showing a MVP? nope Thou dost protest too much. Technology is something to use not obsess or fall in love or hate with. I use Postgres all the time too but Mongo works quite fine for many people and situations. Hundreds of Good apps are created each year with Mongo particularly in the node world. No harm no foul. If you want to feel superior for something choose helping orphan kids or feeding the hungry. Feeling (and thats all it is) you are superior because you don't or wont use Mongo is child's play. 
&gt; better how? faster to market? Nope better at showing a MVP? nope I don't see mongo having any advantage here, if your measuring stick is schema flexibility, put most of your fields in a jsonb column. You _also_ get to use real columns, with referencial integrity and validation, you don't have to spend 6 hours trying to figure out how your data managed to get inconsistent. We used to have 5 mongo clusters, and were right smack in their wheel house of use cases. Some of mongo's arguments made sense in 2012, and it did have a positive influence on other databases in moving them toward better support for unstructured data, but in 2018 with the advances in PG / Maria / etc, I truly can't come up with a use case where I would use Mongo. The rest of your comment is a needless ad-hominem.
Regex `o` option, global vars, multi heredoc, ... are from Perl: /tmp &gt;perl -E'say qr/$_/ for 1..5' (?^u:1) (?^u:2) (?^u:3) (?^u:4) (?^u:5) /tmp &gt;perl -E'say qr/$_/o for 1..5' (?^u:1) (?^u:1) (?^u:1) (?^u:1) (?^u:1) /tmp &gt;perl print &lt;&lt;ARG1, &lt;&lt;ARG2; Arg 1 ARG1 Arg 2 ARG2 Arg 1 Arg 2 
&gt;you don't have to spend 6 hours trying to figure out how your data managed to get inconsistent. Never found that to be an issue in an MVP. I notice this a lot in the programming world. A lot of programmers that work more institutional jobs with long term apps don't understand the startup world. Thats fine but its not the total programming world. The point you can't rebut is that plenty of apps are built quickly , elegantly (if you understand No SQL) and successfully with Mongo. Theres a reason for that PG with json can work for that too but in many cases no deal breaker difference for an MVP &gt; The rest of your comment is a needless ad-hominem. nonsense. It addresses the whole tech world thing where my stack is better than your stack in all situations wars that go on. The fact is that plenty of people use and love mongo for all kinds of things. So you have to be a bit closed minded to declare it has no benefit. If anyone should understand the problems with such arguments it should be ruby on rails developers. We hear all the time why Rails is such a poor long term chose to build upon. I am not going to get into this further. There are some decent articles comparing the two. I particularly like the ones that don't say never choose this or that but weigh the benefits of each FOR THE SITUATION you are in. Heres one https://www.sisense.com/blog/postgres-vs-mongodb-for-storing-json-data/ There are far more by googling, I do like PG for long term growth of apps but theres nothing wrong with mongo for a small business apps and MVPs which we do constantly and helps startups to get funding to build the more long term app. 
&gt; I notice this a lot in the programming world. A lot of programmers that work more institutional jobs with long term apps don't understand the startup world. I've only worked for startups in my entire career, I've spent my entire professional life building early stage products and MVPs... &gt; The point you can't rebut is that plenty of apps are built quickly , elegantly (if you understand No SQL) and successfully with Mongo. There are millions of dollars passing through cobol and fortran every day, that doesn't make it a wise tech choice. &gt; nonsense. It addresses the whole tech world thing where my stack is better than your stack in all situations wars that go on. The fact is that plenty of people use and love mongo for all kinds of things. So you have to be a bit closed minded to declare it has no benefit. Another unfortunate reality of the tech world is people chasing shiny objects for dubious reasons, the NoSQL and SPA movements are great examples of this. To be clear, there are plenty good use cases for NoSQL datastores and we happily use several, but storing general purpose data is not one of them. Fortunately people are starting to realize this. &gt; I particularly like the ones that don't say never choose this or that but weigh the benefits of each FOR THE SITUATION you are in. I've used both systems rather extensively, I'm well aware of the pros and cons. However in the current state of things, I simply can't find a use case where mongo would be a better fit. That doesn't mean I'm ignoring the pros and cons, and doesn't mean I'm just blankly writing things off. Also your link is outdated and has several factual inaccuracies on both sides. &gt; I do like PG for long term growth of apps but theres nothing wrong with mongo for a small business apps and MVPs which we do constantly and helps startups to get funding to build the more long term app. I simply disagree, you're shooting yourself and your customers in the foot based on an outdated notion of mongo being a net boost to development velocity. If we had this discussion in 2012, then there would be plenty of cons to other databases that would make mongo an attractive alternative and I couldn't make much of an argument about development velocity benefits, but it's 2018 and things have changed.
A couple tips on `ENV`: * Access is pretty slow, most implementations do a linear search for the string so it gets slower with more env variables set. In most cases this probably doesn't matter but I have seen ENV access in a tight loop be a problem. * On MRI you are likely protected by the GIL but writing to it isn't thread safe in a lot of implementations, e.g. glibc. Take those two issues, and add in general clarity of code, and my recommendation is to never write to the ENV if you can avoid it, or at least only do so doing application startup and also only read from ENV on app startup, e.g. use it to set a value in a configuration object, then use the configuration object in your code rather than accessing ENV directly where you need it.
&gt; I simply disagree, you're shooting yourself and your customers in the foot based on an outdated notion of mongo being a net boost to development velocity See? Ridiculous nonsense I was talking about that comes just from Ego ny perferred stack is better than yours (although we use both). You don't know squat about my customers, my apps or how they perform but you are making claims based on arrogance and ignorance. &gt; but it's 2018 and things have changed Yes they have and as for outdated sources - mongo has transactions.
Your comment highly implies you didn't read the OP post. I specifically asked for applications, not libraries - and you gave me link to the library, not application. When giving an example, it is just polite to read the info provided before rushing to write a comment.
Here's another good one: /tmp &gt;ruby def foo def bar Time.now.to_i end end p foo.bar p foo p foo 1532131291 :bar :bar
All those PHP refugees who came to Ruby because "it doesn't have anything close to the same level of fail and weirdness" are going to be sad. OTOH, one of the reasons these misfeatures have lived so long has to be that someone thought it would be cool/fun to implement and nobody ever tried to use it in revenue-producing software where 'cool/fun' translates as 'expensive/career-limiting'. 😜
You may want to look at some cookbooks to get an idea, since you mentioned Chef. https://github.com/sous-chefs/mysql https://github.com/sous-chefs/apache2 https://github.com/sous-chefs/line-cookbook To do used input you'll need to make a cookbook, pulling all those in our pass in an attribute during the chef client run.
True. They are a lot more stable, and have a lot more resources available. I don't think it'll be too long before crystal is a viable option for people looking for that sort of thing. I'm running crystal in production and will soon test it's scalability. 
Oh for ... Brakeman PRO desktop is a DESKTOP GUI APPLICATION WRITTEN IN JRUBYFX.
Also `use English;`.
You may spent some time and check Capistrano. It's specifically for server deployment tasks. https://capistranorb.com/documentation/overview/what-is-capistrano/
I think we should not discourage contributions of any kind. If you see something that doesn't interest you or you deem not worthy of your time you can always downvote, scroll past it or just ignore it completely. Another option is to change the viewing options to "top" instead of hot. That way you only see the most popular stories within a specific timeframe. Let the people post.
I'm primarily a programmer and prefer to do as little devops as possible. I went down the Chef route a while back and while it was certainly an improvement over custom scripts, if you can use Docker/Kubernetes I would recommend it highly since you can cache multiple steps and avoid getting into weird states where a recipe doesn't work for some reason or another. Just my two cents, depending on your use case of course.
I agree with this post BUT would also like a “what are you working on?” post. I’m never working on something I can link to as finished but it would be cool to have a designated place to post about whatever unfinished thing I’m doing. 
Number of times you encounter those Ruby oddities while doing productive work is very close to a zero.
I think you need to spend some time reading about Chef and it's design / architecture. All of the things you've asked about doing should be done via Chef 'Resources' and should not be done via raw Ruby nor shelling out with `execute`, doing so would bypass much of the point of using Chef. For some examples: Creating a file: https://docs.chef.io/resource_file.html Note: Modifying a single line in a file is generally not something you want to do, Chef maintains a 'checksum' on the resources it modifies and uses this to detect changes and decide what to do, e.g. determine if it should send a SIGHUP to a web server after modifying it's config files. For your specific use case, Chef should manage the entire VirtualHosts file via a template: https://docs.chef.io/resource_template.html . But, for something like apache, there are already libraries out there which should give you all the things you need: https://supermarket.chef.io/cookbooks/apache2 Installing yum packages: https://docs.chef.io/resource_package.html. (though to answer your specific question, look at the CLI options `yum` provides: http://man7.org/linux/man-pages/man8/yum.8.html, note `-y`). MySQL Setup, probably easiest for you to use a library: https://supermarket.chef.io/cookbooks/mysql In general, while Chef allows you to write any Ruby code you want, you'll spend most of your time working within it's DSL and abstractions so in practice you don't write all that much 'plain ruby'. 
The two are somewhat orthogonal, i.e. we use Chef to setup the nodes that will be running docker containers. I generally agree that Chef isn't a great vehicle for doing deployment of applications, it can do it but that is better left to Kubernetes / Capistrano / etc. 
I mean you may as well mention `Fixnum`. More apps are running rubies with it than without it! 
&gt; and prefer to do as little devops as possible Chef isn't devops, it's an automation tool. Automation tooling is helpful to iterate faster, and tighten feedback loops, which is a part of "DevOps", but automation engineering isn't in itself Devops. 
Thanks for that answer. That's really helpful. I actually thought I needed to learn Ruby indepth to manage that task Will read up on these resources.
I don’t see why that can’t be a part of devops. Also this is how Chef’s website describes it: Chef is the automation platform for DevOps. Achieve speed, scale and consistency by automating configuration and systems management.
Yeah a part of, sure, but a methodology isn't a set of tools. I think your missing what devops is..
I used to use a tool called Sprinkle for this. It has similarities to rake and Capistrano, but is tailored for provisioning servers. https://github.com/sprinkle-tool/sprinkle Other tools seems to have won this battle though... Chef and Ansible being two of the biggest.
I base my articles on the most recent version of Ruby. After all, It's hard for me to precisely estimate the number of projects that use the old "numeric class hierarchy" (using `bignum` and `fixnum` classes instead of the `Integer` class). Anyway, thanks for the precision. :-)
&gt; After all, It's hard for me to precisely estimate the number of projects Some things do not require precise estimations. 
I think you're splitting hairs
I didn't want to diss you. I just tried to explain you my mindset when I write my article. I'm sorry if I hurt your feelings. 
Just focus on what you love and try to master them. No one requires you to do front and back end development, especially for ML. Ruby and Rails do not decide your career path, you do.
Ruby isn't near as popular these days for sure. But the language you code in is a lot less important than getting experience solving hard problems. Learning Rails with Ruby will teach you Struts2 with Java. Are they the same? Not by a long shot; however, the concepts for web dev are generally interchangeable between language and framework. There's a few "newer" paradigms that are very popular right now which you might want to look at. Js + Angular/React/Vue (whether coupled with Java/Ruby/Javascript on the backend) - that's all the rage with the cool kids these days. Tomorrow it'll be something else. In the meantime, just solve problems and get experience. 
Always choose the right tool for the job. It doesn’t matter if Ruby isn’t making headlines — it’s proven again and again to be the right choice for web applications and more. If you’re looking for a career building web apps (you mentioned a junior web dev full stack position, so I’m assuming here), ruby (&amp; rails) is a great language to know in that space. If you’re going for machine learning or database design, choose the tools that fit those technologies best (probably not ruby). In the end it comes down to what you’re trying to build, or where you’re trying to work, and which tool will get you there. Best of luck!
I know what your saying, and I agree with the whole, choose the tools that work and have been proven, but surely we shouldn't forget, this is programming. Everything you can do in python, I'm pretty sure you should be able to do in Ruby, in some form or another. It may not be as performant, it may not look as pretty, but if the OP is looking to begin to dabble in ML, then why should he not be able to use Ruby to write a quick and pretty basic nueral network to grasp the concepts. I get the python, c# and tensorflow etc have much better ML support, but it's a challenge, and name Mr a programmer who doesn't like a challenge!
I agree! I know nothing about machine learning or how you’d use ruby for it, but I get the feeling the ML community has its preferred languages and tools. You wouldn’t want to arbitrarily cling onto Ruby if all the great ML resources are in python. Since OP already sounds on the fence about the language, and struggles with rails, maybe using a more “standard” language for the job will suit them better. 
I see the dilemma you are having. Something similar that I had to realize occurred as well, though couple of decades back. I took CS at Uof Toronto in 98, before CS had their own building. I was really only taught C,Shell and perl for programming. That in 98 got me a job putting up dynamic webpages and perl made much of it possible. Though it was also about the time PHP and mysql became part of mainstream Linux distros From school , I was left with a curiosity of functional languages and AI! And never really got to work on such a project in the web development field. --- This is where I see you facing a similar dilemma ... You're actually interested in Machine Learning and Big Data ... and for that the languages and approach of programming is done by a variety of different languages like Python, Lua , Lisp... and Octave/Matlab etc etc ... it's more like going back to C, and Assembly to program the machine. So a new set of considerations and approaches must be considered for you to include the lucrative field of Machine learning! -good luck
Do you like it?
I think you have some misconceptions here. I have worked as a pure back-end Rails dev and using Rails as an API, which it is pretty awesome at. Our front-end devs would consume the API with angular. So, you can definitely be a back-end engineer with Ruby on Rails. I have done alot of full stack development too with Rails and Ember, Angular, and React. Pick a JavaScript framework to learn on top of any back-end framework that can create an API, and you're full stack. I am not a big fan of monolith Rails applications using .erb pages and the asset pipeline either. I have about six years experience in RoR and various JavaScript frameworks and I have zero issues getting job interviews. It may not be the hottest language out there, but there are still a ton of Ruby jobs available, and I just love writing in Ruby. I also have a decade of experience prior doing C# and .Net. I guess what I'm trying to say is that it probably doesn't matter which language you have some experience in now. If I'm hiring a junior dev, I am not expecting them to be amazing at our tech stack. I just want someone who is smart, willing to learn, and be a team player. I've worked with Python, Java, Node, and .Net devs that all picked up Ruby without much of an issue. After all, there are parallels in all of these languages and their web frameworks. I don't see using a language that you already know as hurting you. If you're doing lots of ML though, you're probably not using Ruby for that. Also, if working in ML is the goal, knowing web frameworks seems like a bonus over a core skill that you need for a career in that field. Maybe start learning Python or other more ML languages as well.
What did you think of the udacity degree? 
So, like an identity provider?
There are ml libraries in like.. every language..
Python is making headway in many areas because, I think, of its use in academic circles. All the numeric and symbolic libraries that are available for Python have made it easier (and sometime even worthwhile) switching from a closed-source product like Matlab, Mathematica and Maple. Now that Python has its footing there, many students need to learn it for their studies (e.g. mathematics or astronomy). This brings more people to using Python, some of them becoming professional academics who then go on teaching Python again. And some of those people get hired by the industry or research and promote Python there because that's what they know. * Is Python "better" or "more flexible" than Ruby? Certainly not. * Is it easier to code with? I don't think so. All the whitespace stuff and the tacked-on OO makes me nervous. Your mileage may vary. * Is it faster than Ruby? Ruby and Python are relatively equal in this regard. However, there are explicit and very visible statements for Ruby that it should get much faster in the future (e.g. Ruby 3x3, alternative implementations like TruffleRuby). * Can you do things with Python that you cannot with Ruby? No - but both have their fields where they are strongest. My recommendation: Learn Python, do some small projects with it and see how it feels. Maybe you like, maybe you don't. And finally: If you can choose your place of work, choose so that you can use the programming language that feels good for you. If not, use that programming language for open source purposes in your spare time and build up your expertise in this way; this make it easier to change jobs later.
I think it’s all personal preference. I’ve never cared much about what was making headlines. I started with Perl, moved to PHP, then eventually Ruby mainly because of Rails. I use Rails because it makes me very efficient. I recently needed to throw together a fairly simple crud app and with Rails and it was quick and painless. Had Google maps, used Selectize and Bootstrap, looked like it took me far longer than it did. Is Rails the best thing ever? Of course not. There’s no single solution to every problem. Rails is a great solution for a lot of problems though. Especially these days with so much work going into speed of both Ruby itself and Rails. It works great as an API for Vue, React, or whatever you want up front. But at the end of the day, the best advice I can give is use what you enjoy using. I dislike PHP, mainly because for years I was stuck working on shitty code bases, rather than issues with the language itself, but I kept at it. That was dumb. I would have been far happier changing jobs and I wish I had. Now I’m working with Rails and enjoy coding again. 
I was totally unaware of this. Thanks, looks great, I'm going to give it a try. 
Yeah a simple identity service .. like omniauth.. with 2 factor authentication ..
I think you should focus on core concepts, patterns, and algorithms. The language you use to implement those things is somewhat secondary to that.
Plus, it is quite normal to use multiple languages throughout one's career. Having used another language can actually be helpful in that it teaches us new concepts that we can use in our bread and butter language.
I think it’s best to get really good in at least one language. If you really master at least one language you’ll have a lot of understanding about more advanced concepts in that language, many of which would also be transferable to other similar languages. However, if you don’t stick with it and you keep starting to learn new languages, you might never reach the expert level in anything, since you’ll be focusing on the new languages basic features without exploring higher level concepts. I think at that point it will be a lot easier to learn another language, like python, so you can use it in situations where it is a better tool than ruby. Also, i think Ruby is useful to know anyway, because it take the place of Perl in many shell and devops type roles. I know one can use python for this too, but I find Ruby to be so much better suited for use alongside shell commands on the command line. While I do a lot of ML and traditional big data processing using industry tools, I will say I spend a lot of time processing data with bash one liners using parallel and Ruby.
Hi! I'd recommend starting with a site like codewars. I learned a lot about Ruby's syntax and quirks by solving little puzzles that I could also solve in other languages for comparison. What are you planning to use Ruby for?
Thank you, I started getting into Ruby because someone recommended it to me after I said I wanted to get into game development
Ruby wouldn't be my first choice for game development, but it can certainly make games. I recommend reading some blog posts on Gosu, it allows you to make 2D games with Ruby. When it comes to learning development of any kind, but especially game dev, getting something made is more important than making something perfect. Good luck!
Thanks
Lots of really cool things here!
I'm pretty satisfied with the default auto indentation of emacs when loading .rb files. Entering spaces on your own will be overwriten by emacs if you press a Ctlr-x-h and then a tab. So its a waste of time and nerves.
So you are not following amazing community-driven style guide? I feel kinda bad for you:) Anyway, question still stands
Well, I write good and elegant code that doesn't include chaining method's like a train. So no "good code styling to the rescue for me". But I'm pretty sure that editing the ruby-mode file will get you where you want with the help of some lisp editing.
Well, I hope this won't come to monkey-patching ruby-mode
`ruby-mode` can be configured to indent like you suggested: (setq ruby-align-chained-calls t) 
Wow! I didn't see it. Thank you! I guess I need to spend more time reading `defcustom`s of modes I interested in
Would be a nice new mode though, haha
Well... I didn't flat-out find this option , either :)
[Learn to Program](https://pine.fm/LearnToProgram/) by Chris Pine is an excellent starting point.
I haven't use any gems for it, but have used event sourcing as a design pattern. I think the general way to think of event sourcing is that you're moving business logic from the write side to the read side which has advantages but also pain points, mostly dealing with concurrency issues on the write side and performance issues on the read side. It works really well when used for things that match it's model, e.g. if you have an order processing system where there of tons of different 'things' that can happen to the order through it's lifecycle, tracking all the 'things' separately as events rather than mutating order state in response to each of them works _really_ well. However, I would never build an entire application this way, it adds a lot of complexity for no benefit. 
I hope you understand that the answers here will be very biased :) Honestly, there's not a lot of downside if you switch your focus to another language, such as Python. It's a more popular language today since it has better libraries built for it and the backing of the scientific community. If nothing else, it opens up new doors. You can always decide you like Ruby better. Just not until you've actually tried to broaden your experience. Have fun!
Thanks for all your comments and the attention, I value your help and will seriously consider your advice. You all agree on the same thing though, it's not the tools, it's the problem and how you choose to approach it. 
It was really informative but it was plain Ruby, without Rails and they dropped it for a full stack Nanodegree. Really solid job though
I do. I don't like that it's mainly a web programming language. 
&gt;I have about six years experience in RoR and various JavaScript frameworks and I have zero issues getting job interviews. It may not be the hottest language out there, but there are still a ton of Ruby jobs available, and I just love writing in Ruby. I mentioned those companies in OP to show that I have the choice to work on a big company if I keep using Ruby. Worst case scenario, I maintain what's there but those companies really promote the use of Ruby + Rails in a way. 
🙏
But for some reason you linked not to Brakeman features page, but to JRubyFX library page. So stop whining, please.
\[iRuby Notebooks\]([https://github.com/SciRuby/iruby](https://github.com/SciRuby/iruby)) or \[RMarkdown Notebooks\]([https://support.rstudio.com/hc/en-us/articles/233066128-Do-Notebooks-support-other-languages-](https://support.rstudio.com/hc/en-us/articles/233066128-Do-Notebooks-support-other-languages-)) might useful solutions here. I believe that submitting an R package to CRAN, for example, will require generating your working documentation on the repository side. Might be a nice practice for other repositories as well, though managing langauge versions will be challenge.
I really like this approach. I have a [gem](https://github.com/tomdalling/jekyll-include_snippet) for this purpose too, but it only works with Jekyll.
I really like this approach. I have a [gem](https://github.com/tomdalling/jekyll-include_snippet) for this purpose too, but it only works with Jekyll.
No need to be a smartass... you’re not even technically correct. The ruby style guide only says “adopt a consistent multi line method chaining strategy.” Your way is only one option. We use rubocop at work and use the default dot on the preceding line and two space indention for normal method calls. 
You're not calling `Struct#===` though, you're calling `Struct::===` here which is inherited from `Module#===` via the `Class` class and is therefore a test for instance type, not singleton ancestor chain or of identity. Hence: klass = Struct.new(:foo) #=&gt; #&lt;Class:0x00007fe7d5164120&gt; bar = klass.new #=&gt; #&lt;struct foo=nil&gt; klass === bar #=&gt; true 
For me being a smartass is suggesting "do it this way because I like it" when question is clearly "how not to do this this way?". You reap what you seed. It's just an ironic response, I didnt even want to answer this in the first place
Sorry for late reply... Yes, I guess you're saying about "API Gateway" or "Service Mesh" for haconiwa. We now use ngx\_mruby and writing small mruby scripts for service meshing. But I think envoy will work together with Envoy, so I'm trying it.
I also want to add that the reason that `Object === Object` returns true is because the `Object` class is an `Object` instance – it’s an instance of `Class`, which is a subclass of `Module`, which is a subclass of `Object.
I was just writing an edit to say exactly the same:) thanks for pointing it out. 
I was about to write the same thing. The `Object` object is an instance of `Class`, and `Class` inherits from `Object`. It takes a while to decipher, I know.
Can I just say, it would be *fabulous* if the gem maintainers who publish in this sub would give a one sentence summary of what their gem *does* in these types of release/update notes. Bonus points if that sentence pitches why their gem is better than the other gems in the space. Linking to the release tag and changelog is even worse - now I have to click *twice* to see that pundit is an authorization library, and therefor a problem I have solved, and therefor not of interest to me.
I don't disagree in general but I think pundit is fairly common knowledge among rubyists. It has almost six thousand stars on GitHub. Obviously some people won't have encountered it for one reason or another but I can't really fault the OP in this case for assuming some familiarity.
Sorry, I didn't think it was needed but I do agree with you! I'll keep that in mind :) The release link was not very useful so I edited it to link to the main repo instead. Thanks!
I think a lot of people haven't heard of Pundit still. CanCanCan still seems more popular, despite being a fork of an unmaintained project which is not nearly as well-designed. Since no one had actually said it yet: Pundit is the authorization library you should probably be using. It works nicely with Rails but uses a clean OO design that can work in any app.
Aha. So the answer is, there is nothing special about "struct subclasses" here, _most_ classes aren't `===` themselves, it's a rare special case for those who are. 
Big fan of Pundit. Would love your take on my tutorial for it: https://medium.com/@toddbaur/using-devise-and-pundit-with-rails-5-to-delegate-authorization-to-users-22f2c83d0244
I've used it, know what it is, but I'd love to know why I should be excited about 2.0 vs past versions.
No worries :) For a bunch of reasons Pundit hasn't been properly maintained for quite some time. I've taken over as a maintainer now. There were some features already in master (added a long time ago) that required a major release due to breaking changes. Since I already had to release a major version I decided to get some more features and bug fixes in the release. Also, I'm not trying to sell you Pundit :) The reason I posted here is merely to make it visible that Pundit is in active development again, something that a lot of people has been anxious about for quite some time.
If you have a `DummyClass`defined in the test like that, there's a risk of the name colliding with another 'DummyClass' declared in a different test, leading to confusing or buggy behaviour. It's safer to declare it within the example, e.g.: dummy = Class.new if you need it to inherit from something else you can write: dummy = Class.new(ParentClass)
Isn't avoiding running your whole suite a code smell?
Not really, it's not a part of your code. You should run your whole suite before committing, because you don't want your CI to call you out. But for developing, it's helpful to only run related tests while in the middle of the dev cycle.
I'm actually really liking the looks of [access_granted](https://github.com/chaps-io/access-granted)
Gotta say, pundit is maybe my favorite gem. It's simple, lightweight, very well designed, and basically just a better-structured version of the pattern I would have otherwise implemented myself. Thanks for picking up the maintenance, I'd hate to see such an elegant lib wither away.
You obviously didn't read the article and associated links.
This is very important. Sometimes I don’t need twenty errors just to find the one I know I need to work on and when I fix that it fixes the rest. Running a portion of a test suite helps isolate what you’re focusing on because you know it’s changed and then broadening scope to ensure you haven’t broken anything else once you think you’re code complete.
I'm not sure what your goal is here, is it something like this? print 'hi' a = 12 print "12" if a == 12
Yes
OK cool. One thing to keep in mind is the difference between variable assignment (a = 12) and testing equality (a == 12).
But the if statement comes before, to let it know to print, if the variable stands for something
Thanks
Okay, so another thing to keep in mind is that these are equivalent: print "12" if a == 12 and if a == 12 print "12" end 
Ok, thank you
I so much love how the tooling around Ruby is improving all the time.
Oh man... sweet flashback of days gone by with Turbo Pascal 3.2 and ensuing :) It may still very much be a perfectly viable UI for many tasks, so rock on!
Yes - but is it MVC :)
Wow. That website has a whole lot of things slapping you in the face once it loads, doesn‘t it?
Huge thanks to /u/schneems for creating the gem.
&gt; CanCan(Can) still seems more popular From my experience, CanCan(Can) - quite frustratingly - does *seem* more popular at a glance. However, it's really a terrible solution for any non-trivial authentication problems -- and every experienced developer should know this.
/u/Linupe thank you for maintaining this wonderful gem and for the new release!
was just going to say something similar to the liking of subject { Class.new { include MyModule } } ... expect(subject.number).to eq(5) or again likewise just declaring that statement in a `let(:dummy) { .. }` would work too.
Pretty much sums up what my experience is like when I use Rails. Well written.
&gt; I think the general way to think of event sourcing is that you're moving business logic from the write side to the read side which has advantages but also pain points, mostly dealing with concurrency issues on the write side and performance issues on the read side. I'm not sure I follow. Event sourcing databases offer optimistic locking for writes, just like what's possible with many SQL databases, which alone is enough to allow multiple processes to write to the same stream safely. And event sourcing by its nature offers two huge performance benefits on the read side: 1. When projected entities are cached, there is no need to ever invalidate the cache record, because out of date entities can simply be projected up to the current version. This means that reading an up-to-date event sourced entity is always going to roughly perform about the same as fetching a single row from a relational database. 2. By their very nature, event sourced databases allow pub/sub, which means materialized views can be constructed today, and can be populated with yesterday's data. That means that queries can be as fast as you want them to be. What were your read performance issues? &gt; However, I would never build an entire application this way, it adds a lot of complexity for no benefit. It doesn't seem to add much of any complexity to my projects. The most complex event sourced entities I've worked with still don't strike me as complicated as, say, the typical usage patterns of ActiveRecord. If we were to use a quantitative measurement of complexity, i.e. cyclomatic complexity, I'm pretty confident the event sourced approach would clock in at quite a bit _less_ complexity. What event sourcing *does* bring is a learning curve. Just like ORMs came with a learning curve that we climbed a long time ago (but often forget about). Frankly, I can teach someone the full set of all the event sourcing related tooling I use long before I could ever teach them everything that an ORM like ActiveRecord does. Where ORMs beat out event sourcing in this regard is that you can learn just a very small amount of an ORM and be able to cobble together a working application. This is one of the big reasons why ORMs are so fantastic for rapid prototyping.
Thank you. All credit should go to the initial creator(s) and contributors ❤️
Thanks! I had a pleasure learning my first algorithms and data structures in Turbo Pascal 6.0, I will never forget that blue glow! In general, people underestimate the kind of things that can be done in the terminal, for example, I know some people who have created their admin panels for their web apps as terminal UIs! 
I think this is the future of MVC ;)
Great point -- have empathy for your users. I create an upgrade document for each major release of Sidekiq with an overview of major changes and any incompatibilities, I wish every gem did this: [https://github.com/mperham/sidekiq/blob/master/4.0-Upgrade.md](https://github.com/mperham/sidekiq/blob/master/4.0-Upgrade.md)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [mperham/sidekiq/.../**4.0-Upgrade.md** (master → fbd6e22)](https://github.com/mperham/sidekiq/blob/fbd6e22fa9ff7d19a2946b6dcc722c3cf3966665/4.0-Upgrade.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e2ytaum.)
It seems like this is one of those guys who's always complaining in general doesn't have much experience. I might be wrong, of course. For example, he never mentions an alternative framework that would have worked. Yes, he might had some frustration, but that doesn't mean Rails is bad inherently. Neither it says in any way that he would had better experience building an MVP in a different framework. p.s. don't waste your time reading the article
Thanks to all for the detailed responses. I knew there would be a perfectly rational reason for it. Now that I understand how it works under the hood, I can see where I went wrong. But, with that said, I still find it surprising from a POLA perspective. If you're using the equal-sign for an operator (even 3 equal signs), it seems reasonable to expect said operator to embody some notion of equality. That it occasionally doesn't, can be surprising. And the fact that "comparing something to itself" is one of the times that equality isn't equality is doubly (triply?) surprising. At least, it is for me. And, I still think this should work: case klass when klass # Do the thing! end But I guess it's just me. Oh well. FWIW, I'm trying to use [Qo](https://github.com/baweaver/qo) in a project and that mechanism is rather heavily dependent on the === operator, so I can't easily switch to using == as someone recommended. Unless someone has a better idea, it looks like I'm stuck either monkeypatching Struct, or writing a custom version of Qo. Thanks for explanations.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/baweaver/qo) - Previous text "Qo" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
No problem :)
I don't really understand the point of the article, that Rails is too hard? What is simpler? I never had more ease of development in another framework for my use cases so far. Is rails hacked together? Maybe in the past, but I don't get the feeling now, in fact I get it more when using *place any node.js framework here* (which I have the feeling is where the author is comparing rails to).
&gt; expect(actual).to eq(expected) Seems absolutely insane to me. 
I'm open to suggestions. Maybe instead of 'actual' and 'expected' the variables can be named something that reflects the actual and expected values.
If you use rspec, check out http://www.betterspecs.org/
GOOS are the best :) * POODR * 99bottles of OOP * Test Driven Development in Ruby: A Practical Introduction to TDD Using Problem and Solution Domain Analysis
Pundit is a great choice for authorization in general. Regardless of the framework. I integrated it in a Rails app recently and everything was easy and clean in the end.
It’s a great resource. I included it at the bottom of the blog post.
Yeah. As I mentioned it's framework agnostic. I've only used it in Sinatra so far but I think ill make the switch in my rails app going forward. The interface feels much cleaner than cancan.
Has anyone had the time to try this out?
The RSpec authors recommend against using an implicit subject: https://relishapp.com/rspec/rspec-core/docs/subject/explicit- subject
Don’t use `text-align: justify` it makes your mobile site difficult to read. 
Be wary, it's very outdated. For example, it still refers to Zeus and Spork, but makes no mention of Spring.
I'd say it's overkill here since it's just comparing against a literal, but I do find it helpful to make a local assignment if the expected value is lengthy, e.g. an interpolated string.
I like Pundit but for being so opinionated it sure leaves policy_scope up for interpretation. 
The general concept you're describing is "taint analysis".
Anyone tried [action_policy](https://github.com/palkan/action_policy)? We are in the process of switching over from cancancan to pundit, and found a pattern or two in the pundit API that we really didn't like (eg the implementation for a headless policy seemed hacky). Action policy has a very similar approach, great docs, and actively worked on. Might give it a go instead.
You can use `caller` to find a sorta stack-trace of what calls your method. That might help?
Ruby does not track where variables are set, nor is it lazily evaluated so there are no thunks to look at. Rails is not that complicated, you have to get used a little bit to how they do things, but I definitely recommend just reading all the code. Just throw a \`raise\` in there, and then look at the files that show up in your backtrace. Also, you could also just ask here or on slack or SO if someone knows where a particular Rails value comes from, someone might know :)
Easier way would be to use a debugger to step through your application. I’m not too familiar with static analysis tools / taint tracing for ruby. 
That is kind of a crazy approach. If you break out the `bundle install` bit to a separate step and copy the Gemfile / Gemfile.lock into the container separately, then you can skip it all together most of the time as docker will use the layer cache. i.e. docker would only even run the `bundle install` if the gemfile changed. As for asset compilation, we don't serve the assets from the containers so they are pre-compiled externally, usually 'normal' CI caching mechanisms and only the manifest needs to be copied into the container (the assets themselves are copied to a CDN). Also the general ordering of this docker file makes no sense, the things that change often should at the bottom, things that don't change should be at the top. Once a step is hit that is uncachable, all steps after it will be executed. 4.5min for asset compilation is kinda crazy, I'd try to fix that as well.
Thanks, that's good to know. I wish these were standard Rails values, but they're just custom logic written across a hundred files.
This is my last resort, as I _really_ don't want to sit in front of the debugger for hours. Alas...
Blog spam in image form? That's new. Also this is like a copy-pasta from other "Top 5(10)" lists that you get by googling. And for fucks sake, Radiant is dead for years now.
Thanks for setting a good example!
In that case carry on! Thanks!
I used Locomotive and found the workflow great. My favorite is [Comfy Mexican Sofa](https://github.com/comfy/comfortable-mexican-sofa). I'm using it for the site of a SaaS. It's great, and just powerful enough to do what I want it to while reducing potential duplication.
Yeah, this is complete amateur if I'm being blunt. You shouldn't be using bundler cache or asset cache, you should be letting docker handle caching steps, so you should create you Dockerfile that docker can efficiently do that (i.e. things that change a lot -- *cough*assets &amp; code*cough* -- should be at the end). I've never had any of my rails images take more than 2 minutes to build, and the majority of that time is webpack compiling JS. My rails Dockefile's more or less look like this: # The fastest part -- first setup the base for the rails # image (i.e. this stuff won't change unless I bundle install or update) FROM my-registry/ruby:2.5 as rails RUN mkdir -p /var/www/app &amp;&amp; \ chown -R app:app /var/www/app /usr/local/bundle WORKDIR /var/www/app ENV GEM_HOME=/usr/local/bundle ENV PATH=$GEM_HOME/bin:$PATH COPY Gemfile* /var/www/app/ USER app RUN bundle install # The slowest part -- this is done here as the frontend FROM my-registry/node:alpine as node COPY package.json yarn.lock /tmp/ RUN yarn --pure-lockfile # The slowest part -- this is done here because the two # now the gems &amp; node_modules have been built and aren't # updated often so they'll stay cached and can skip those # if changes are made to the rails or JS code bases FROM node as frontend COPY --from=node node_modules . COPY webpack /tmp/webpack COPY webpack.config.js . COPY .babelrc tsconfig.json ./ RUN mkdir public &amp;&amp; yarn run compile # And now we just use first "rails" stage as the base # and then copy JUST the compiled JS from the previous stage # as well as copy over the ruby files for the rails app # this will take &lt; 5 seconds to do, so I don't care if # making changes to the frontend invalidates the cache for this stage FROM rails COPY . /var/www/app COPY --from=frontend --chown=app:app public/ ./public/ CMD bundle exec rails s -p 3000 -b '0.0.0.0' I use [multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/) to really take advantage of Docker's caching by first installing dependencies (i.e. things that aren't frequently changing and will result in the code having to be rebuilt if they do change anyway), then I compile the JS (in a completely separate stage so my final image is never contaminated with a huge `node_modules`) , then after all that is done do I finally copy over the rails files using the previously built stage that installed the gems and bring over the compiled JS bundle. That way if I change something in rails, I don't have to wait to install gems, node modules, or compiling JS. If I make a change to the JS, then the final rails stage will have to be rebuilt, but since all it's doing is copying over files and setting the `CMD` it takes &lt; 5 seconds, so I don't care if it has to get rebuilt. I don't have to worry about weird caching strategies or any of that bullshit, I just arranged things in a way that I can let Docker do that for me. If you want to use Docker with Rails, don't do what OP is doing. 
There is also `set_trace_func` which can be used to trace program execution.
Making Ruby Mine And Nobody Else's: Reducing maintainability with idiosyncrasies.
For the map-with-args example, I prefer module Enumerable def map_by(method_name, *args) map{ |x| x.public_send(method_name, *args) } end end [1.2345, 2.34567].map_by(:round, 2) # =&gt; [1.23, 2.35] 
JavaScript is the best programming language nowadays 
So this presents several options with no clear winner. That’s the good and bad of Rails. Lots of ways to do something and you’ll often spend more time testing and choosing which way you want to go then implementing what you decide on. My issue with emails is more along the lines of wanting something that looks professional, a bit like my site so it looks familiar when someone opens an email, and having no idea how to actually design an email. What I have now isn’t bad and works fine but at some point I want to spiff then up a bit. 
I think rubists call it "sugar".
Rather small optimization, but you can move the `CMD` calls all the way up, it doesn't require the the 'stuff' needed to run it is actually in the container when the `CMD` stage is reached. It'll avoid a layer being generated for the `CMD` step unless it's changed with can cut ~15s off the build.
Wow. I wish that were in stdlib. I always need that.
By what metric? No language, ever, can be the best programming language.
What does the i18n gem support that this does not?
In terms of features, I'd say: \- automatic pluralizations (one, other): I'm planning to support this as well in next releases, but maybe with different api \- swappable backends \- dates localization (the **I18n.localize** method) **mini\_i18n** focuses on translations right now, and it should work with same YAML files as **i18n** does. I think it can be useful for small apps, cli tools, ... or projects that don't already depend on **i18n** (Rails does).
It is the most used, it is the language the keep evolving, because is used in a variety of applications. JavaScript is the English of programming languages. You can choose from 2 type systems. Typescript and Flowtype. Everything will be written in JS
That doesn't make it the best language. It makes it even harder to find people that do js right. Outside of web development, js isn't that useful imo.
Nodejs is growing a lot on backend There a lot of IoT with JS as well Mobile development with React native uses JS as well
...took me a while to figure it out 
Sofa is the best.
I feel conflicted about the new encrypted credentials system. Yes it is important to encrypt credentials. But the way it is setup now means that using the \*same\* credentials between development and staging and production, is now encouraged. I used to have totally different sets of credentials (and associated resources) for each environment. For example development only has access to the foo\_dev AWS bucket, production only has access to the foo\_prod AWS bucket, etc. Suppose I want to separate credentials by environment. How do I do something as simple as making a new encrypted file config/credentials-prod.yml.enc with its own encryption password? rails credentials:edit does not allow me to specify the filename.
&gt; But the way it is setup now means that using the *same* credentials between development and staging and production, is now encouraged. I haven't used 5.2 credentials, and that's how it appears it's designed, which is odd. I'm not sure the reason for this. HOWEVER, it wouldn't be hard at all to monkeypatch so you have, say, `Rails.application.env_credentials` and have it map to your env.
you can specify the sort order by adding a block to sort!: [1, 2, 3, 4].sort { |a, z| z &lt;=&gt; a } 
Is there a reason why this way is preferred versus the reverse string method?
&gt; swappable backends Can you elaborate? I18n supports different backends. 
Yes, exactly this, different backends (term extracted from its docs). Those are features that mini_i18n does not support.
`String` method? Those are methods on `Array`. The method shown above is preferable because it's iterating through the array once rather than twice. What I mean by that is, if you call `[1,3,2].sort!.reverse!`then this will first create an intermediate value: `[1,2,3]` and then manipulate the object a second time to get `[3,2,1]`. For small variables this difference sis negligible, but for larger objects the performance difference can make the optimisation quite beneficial.
Just for comparison, how does Python compare for rough edges? It seems all languages have a few rough edges, even the better-designed languages. The question is how likely are you to meet them in production code?
Your code is correct, you're just missing a `puts` call. By calling `holiday_item` you're just inspecting the value of `holiday_item`. `puts holiday_item` will show your expected output correctly. 
Key word in the prompt you're missing looks like "print". If you throw in a "puts holiday\_item" at the end there you'll get a sense for where you're at.
Newlines aside, some review: 1. The season is being printed multiple times instead of just once. 2. You need a space after your joining comma. 3. `capitalize` is insufficient to turn :fourth_of_july into "Forth Of July". Hint: `split`, `map`, `join`. 4. `+=` makes a new object; consider appending to the existing one with `&lt;&lt;`. 5. Maybe `holiday_item` would be best as an `Array`, so you can add newlines in one place at the end; either by using `join` or just passing directly to `puts`. 6. If it's an `Array` then perhaps instead of building it up with `each` and explicitly appending to it, you might use `flat_map` and `map`.
damn and here i thought i was actually close to solving this . Sigh . Thank you for the review though , that actually did help a ton! i really appreciate it
`reverse!` operates in-place, and either way reversing is quite quick. Calling a block for each comparison is not. sort.reverse.each 3.428k (± 2.9%) i/s - 17.493k in 5.107669s sort.reverse!.each 3.509k (± 1.1%) i/s - 17.697k in 5.044007s sort {|a,b| b&lt;=&gt;a}.each 649.027 (± 0.3%) i/s - 3.250k in 5.007541s sort_by {|a| -a }.each 882.498 (± 0.6%) i/s - 4.488k in 5.085721s sort.reverse_each 3.492k (± 2.0%) i/s - 17.748k in 5.084890s
&gt; 4. `+=` makes a new object; consider appending to the existing one with `&lt;&lt;`. Aren’t we in the midst of a (long) transition to immutable strings in preparation for Ruby 3?
String literals, yes. `+""` to make a mutable literal.
Give yourself some credit! All these points are valid, but they’re mostly about readability and performance. Those are secondary concerns at your level, and they’ll come naturally as you build up your mental library of what’s in the Ruby Core API. At this stage, logic and reasoning about / manipulating complex data structures (like a nested hash) are the core skills you’re supposed to gain from exercises like this. You’ve totally got it. To return to your original question (and elaborate on /u/edendark’s point), it’s worth reflecting on the difference between **return values** and **output**. For each of the lines below, see if you can guess 1) what the resulting value of `x` is, and 2) what will be printed on the screen: x = 1 x = (puts 2) x = (p 3) Then, confirm for yourself (it may help to use pry / irb, and consult the Ruby Core API documentation).
TIL.
FWIW, the intention isn't that you use the same credentials/key in development and production: it's that you don't encrypt your development credentials.
You can also simply namespace inside the credentials file.
And if you’re displaying output with `puts`, you don’t need to manually add the newline, as `puts` will automatically append it for you. It will also work the same way if you do add the newline (i.e., it won’t duplicate a single newline at the end of a string) but manually adding a newline to a string for display isn’t considered “idiomatic” Ruby.
The way I see it/use it is that credentials are mainly about development secrets you can share to entire team. Main benefit is that when someone new joins the team you give him just one master.key file and off he goes to develop new features. I would leave the production passwords as ENV variables in prod server accessible to only handful of DevOps dudes. Maybe you can store some non destructive production credentials (like monitoring service key) in the credentials. But anything that can be used to do harm to a buseniss should not be in Rails credentials. So why not just use ENV variables all along for development? There are solutions like dotenv (Linux program) or Figaro gem for maintaining ENV. variables in non committed file but they can get out of date really quickly. Rails credentials are pragmatic tool for "sharing" secret configuration. Anything that should not be shared should go to ENV variables. 
Interesting... For what input though? 
Sorry for the late response. You're absolutely right, I just wanted to show that sometimes order in which we execute particular methods can make a big difference.
Fixed :) Sorry for the late response and thanks for catching this :)
Okay but the tooling right now makes it really awkward to have different sets of credentials per environment. I can't even make a new encrypted credentials file under a different filename.
def all\_supplies\_in\_holidays(holiday\_hash) holiday\_hash.each do|season,data| puts "#{season.capitalize}:" data.each do |holiday,item| item = item.join(", ") holiday = holiday.to\_s.split("\_").map {|w| w.capitalize}.join(" ") puts " " + " " +holiday + ":" + " " + item end end end This is the code i came up with at the end . It got the job done but i was wondering if there would be a simpler solution? 
&gt; Yeah, this is complete amateur hour if I'm being blunt That's not a nice thing to say. &gt; CMD bundle exec rails s -p 3000 -b '0.0.0.0' According to Daniel Azuma, you should prefer the exec form over the shell form: &gt; **6. Prefer exec form for CMD** &gt; Many reasons, including interoperability with ENTRYPOINT. But in particular, it’s needed for proper signal propagation and safe container shutdown. http://daniel-azuma.com/articles/talks/railsconf-2018 https://youtu.be/kG2vxYn547E?t=1598 bad sound :(
Integers 0..1000 shuffled.
why's (poignant) Guide to Ruby https://g.co/kgs/X6k6nY 
I think 80% of the cause is Google's embrace of Python.
Google has been using Python for quite a long time though.
I'm curious if [Guido resigning](https://lwn.net/Articles/759654/) will have any long term effect on Python's popularity.
Does anybody know what year Google officially adopted Python? I looked around for a while and couldn't find any reliable-looking source. The jumps in Python popularity from 1998-2003 and 2003-2008 are the most significant. The more recent decade is a significant, but modest, increase. I wonder where Google's support lies on that chart and if correlates.
In addition to Why's guide (really, such a great book!), you can try asking questions and "rubber ducking" (i.e. explain what you think you know and ask for corrections) here as everyone I've interacted with is very friendly and helpful.
Even knowing that, there's internal usage versus public libraries and APIs, so who knows?
Paywall :(
You can pipe input into Ruby &gt; echo "puts 2*2" | ruby 4 So, if the file on your server contains Ruby, this should execute that code: curl -fsSL https://blah.com/foo | ruby If you want the file to be protected, you could use basic HTTP auth on the server, and add the username/password using curl: curl -fsSL https://username:pass@blah.com/foo | ruby
I'm just skimming things at work and so far I've only found 3 pages of cartoons. Is this an actual book or a giant satirical piece?
Seems that the Python Package index is what's making Python most popular. It has a ton of packages covering a broad range. Much like CPAN did for Perl. Makes it compelling when needing to start a project. 
This was really confusing at first since Boo is a sorta dialect of Python.
In particular, its embrace by Google App Engine as well as other cloud providers has helped its growth. It had a big jump in popularity between 2003 and 2008. Python has industry leading libraries in Data Science and Machine Learning. I think there are so many searches for it with experienced developers in other languages branching out into it.
so your sayings its just the same ? ruby -e $(curl -fsSL https://myaccount:pass@myserverip/foo )
I think from the beginning. IIRC Google was originally written in python. I'm sure that Youtube was.
YouTube wasn't started by Google, they were acquired.
&gt; ruby -e $(curl -fsSL http:s/blah.com/foo) Ah I didn't realize your syntax worked as is... guess i should've checked that first
Why Boo? Python is great in some areas and Ruby is better in others.
Weird. Nothing for me. Here's [a screenshot of the graph](https://www.dropbox.com/s/h2ctkn71k6rl8aw/Screenshot%202018-07-27%2016.19.19.png?dl=0). That's basically all there is to the article.
Your syntax, which processes an entire script as a command line argument could easily be mangled by the shell in a number of ways. The likelihood goes up with the length and complexity of the script. For this type of application, I'd _always_ pipe the output of curl into ruby, as /u/fiveguy did.
Regardless of whether you originally put the file there and it has HTTP auth, it's remote code execution.
Honestly, none of this matters. The future is Javascript and Node. Browsers are in JS. The future of programming is in the browser. Because of this when they start teaching programming in elementary or high schools they will choose JS. Once there's millions of kids learning JS programming ecosystem will shift entirely to JS. JS will just get faster and faster and other scripting languages wont be able to keep up. And native to JS frameworks will get more popular and thus better to the point that super cheap JS programmers writing for native will be the norm. Yes, Real Programmers^(tm) will still know other languages (those frameworks wont write themselves). And this is still a few decades off. But that, my friends, is the future.
I know, but I think they were still Python based when they were acquired. So that would have a significant impact on Google's language choices.
This is going to be less true if web assembly takes off.
You shouldn’t do this, probably. If you have scripts you want to run, upload them to your server and run them. If you have five different scripts you want to trigger on demand, upload them to your server and have an authenticated endpoint you can call with 1-5 as part of the query string to choose a script to run. You want the absolute minimum amount of genericism, you want any parameters totally locked down. Imagine, for example, if you lost control of the domain hosting this script—someone could replace it, execute their own script, and trivially take control of your server.
&gt;Because of this when they start teaching programming in elementary or high schools they will choose JS. Boy do you need to keep up on your reading. Multiple other lanuages are making good progress on writing non JS for the browser. You might want to read up on web assembly. In maybe five years due to ecosystem build up no one will NEED to write javascript. So your whole anlysis is waaay off. I particulalry like Blazor is heading [https://github.com/aspnet/Blazor](https://github.com/aspnet/Blazor)
You and /u/fluffy_ribbit might be right. But maybe not. JS is plenty fast and serves the needs of the vast majority of sites. And I could see it becoming a fad or a bit like every time someone comes up with a splashy new thing. Like those sites where you scroll down and Mario runs across the screen and completes a Mario Bros level. A bunch of companies built branded versions of those sites but I only saw people sharing them in webdev subreddits. But long term it seems like it will have a huge place in the realm of in browser gaming. But for the other 99% of browser use it'll be overkill and more expensive to develop with. The biggest slowdown is still communicating with the server, not the JS.
i just want one file to be hosted on a server....and that it.
I actually like JS. So no knocks on Speed or anything else. Use it every day with angular and Node. My three main languages are Ruby, Js and C#. Its just not a fact anymore that the browser will force usage of JS and its definitely a fact that a ton load of programmers do NOT like JS so any projection of JS dominating for decades isn't a guess based on the reality that web assembly is now supported in all major browsers and is taking off.
Ok. Where is the ruby running? A different server? Or your own local machine? If you just want a private HTTP server to host a file (in this case a ruby file) that is simple enough. You can use basic authentication and pass the username/password as part of the curl request as the other poster suggested. Even better, you could use ssh to retrieve the file over an ssh connection without exposing your ruby file server in any way (other than exposing the ssh port).
Python is the language created for educational purposes. For noobs in programming. Software engineers and computer scientists are supposed to learn multiple languages while they learn and this one is supposed to be starting, not the ending. The fact that it gets popular just means everyone can start learning computing but not many can advance and learn further. 
awesome
This is a poorly researched article. search engine searches don't mean that one language is more popular than the other, it means the devs leveraging that language need to google stuff more. look at githubs yearly summary, that's a much better source.
I got hit by paywall, too.
Gain additional entries by spamming your friends. Nah. 
i like how this whole article is this guy realizing he’s trying to go against the rails default workings and then him crying about how he had to implement a “workaround” that is a rails standard thing in place for people that need to do those particular things. 3/5 comedy article
If I understand you right, I'm affraid what you're thinking doesn't make sense. If your file is available, anyone can read the code, instead of executing it.
Like I said, maybe you're right. But web devs are going to want to use a scripting language. What's your idea moving forward with that? I saw there's a Python that can work with WASM, although I don't know the details. So you're saying there will just be scripting langs which will work on top of WASM?
Like I said, maybe you're right. But web devs are going to want to use a scripting language. Browsers aren't going to maintain multiple scripting langs. So if you want to use a scripting lang you're going to have to use JS.
I don't necessarily disagree with you, but why do you think it would be a win for everyone?
Bad takes- bad takes everywhere.
That’s awesome. Can you tell us more about it?
&gt; If Python replaces Java as the first language people learn in school/enterprise settings, it's a win for everybody. I believe JS has a better chance of eclipsing (ahem) Java as most commonly taught, which would be a very big loss for everybody.
Also AWS Lambda.
I disagree because it is a loosely typed language. The entire reason you learn C and Java in school is because they are extremely fundamental and the concepts you learn in C or Java can be applied to any other language. Not to mention Java and C have been around for *decades* and JavaScript is a flavor-of-the-week language. I do think JavaScript is great and headed in the right direction from its jQuery days in 2012. I just think that a more enterprise and foundational language would do better in an education system than JavaScript would. Coding “boot camps” are where JavaScript will thrive. You can learn it in school but I don’t think it will be the bread winner of education systems 
Agreed, including googles ML &amp; NLP contributions in python as well 
&gt; I disagree because it is a loosely typed language. From your lips to God's ears, but I unfortunately feel like the trend is toward loosely/weakly typed languages. I mean, Stanford's CS101 uses [a "stripped-down" variant of Javascript](https://lagunita.stanford.edu/courses/Engineering/CS101/Summer2014/about) so I'm not hopeful.
I can’t imagine a language without interfaces (or one that has to hack them together) being the top dog. Though I will admit it’s been interesting to watch it rise so chaotically. The isomorphic nature of JS is my guess of why the popularity grew so quickly. None the less, we’re all on this ship together. It’s the community that ultimately decides what we learn. So hopefully as a group we can be smart individuals and pave our way to success 
it's just one of three classes for windows I made to run this simple scene with the start menu
The only people that say this are people who have never seen anything besides JS. Congrats on proving you’re a novice.
Why would you post this on this subreddit? Rubyists don’t care about popularity. We care about using a language we enjoy. 
You seem to be pretty young to programming. Buckle down and study a few languages and then you can be in a better place to talk to programmers about programming. Righth now not so much. 
So, educate me oh wise one. Where am I wrong? Web devs are going to switch to compiled languages? Browsers are going to start supporting multiple scripting languages? Or maybe you can't and switched to insults because you're one of these Very Online programmers. The kind who just likes talking shit, putting down others, and doesn't realize flame wars over disagreements in programming are the saddest thing in the world.
Data science is one of the fastest growing and most in demand professions. Also, one of the two primary languages used in it is becoming even more popular than it already was. This is truly groundbreaking journalism. 
yep it's like if you were to convert a string to HTML and then back to a string... You never know if the HTML parser drops/mucks with your original string and it could have completely different outcomes :P
100% agree that this seems super risky... at least it's not as bad as my last company which passed basicauth over http 🙃
ironically, there was a pythonlike .net language called [boo](https://github.com/boo-lang/boo). for a moment i thought the headline was about it being revived :)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/boo-lang/boo) - Previous text "boo" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Isn’t this the opposite of what they’re for? You want them encrypted on the server so if you get hacked, no harm. In dev you don’t need to encrypt them. Who else would see them? I guess if you have security issues with your dev setup, or want us use email or something to send them to other devs, then encryption would make sense. That’s a horrible idea though.
Seems interesting, I might try it for one of my smaller projects. Do you have any plans for dates localization in the near future?
Bored....your orginal post predicting that javascript will rule the world has been buried with down votes. Why? Because experiened programmers know multiple languages have good use and no programming language will make this a true statement. &gt;Honestly, none of this matters. The future is Javascript and Node. Argue for your JS will rule the world prediction (you obviously had no idea what web assembly was) in a Python thread some more but I won't be seeing it. You are on block list. I don't mind people not knowing much programming but not knowing it an arguing like they do is just too much noise to continue reading.
Everything great started out with a first step, and I think you've got a good first step here. Feel free to show off as you progress - I'm sure folks will be interested and it's (at least for me) a great motivator to reach higher. Looking forward to future developments. :)
This is exactly how I started learning Ruby. VX Ace can be a mess in some areas but overall it’s a great place to dive in. 
If you don't mind the dependency on termbox, its API is simple enough that writing an FFI wrapper for it is fairly easy. I did that for a project I'm working on, but haven't released it yet.
I really don't see a significant difference between Python and Ruby as programming languages. In my opinion it comes down two particular Library usage. Having set up a million python virtual environments, I must say I'm not a fan. I laugh every time someone replaces their system Python and bricks their server.
Could be. But where would you store private info like "sengrid API key" " mandrill API key" "aws API key" for your development environment. (Those can still be used to do harm if they are committed in git even if they are used for development env only.). So I see Your point, you could have own non committed config for every developer in the team and you would use Rails credentials for production only. (Master key would be in hands of few DevOps dudes) Don't know. It seems to me Rails provided just a tool. Rails Credentials is like a "hammer" and it's really up to teams to figure out if we want to nail a nail to a wall with that hammer or we use the hammer for smashing rocks. Both are valid uses of the hammer for different team.
Since you're talking about "educational purposes", I belive you've confused Python for Pascal. Your message actually makes *morE* sense if you replace "Python" with "Pascal". So I guess it's not about the truth. It's about your reasoning. 
Java teaches us some basics of typing. Static typing makes more sense academically. It's easier to explain behaviour of statically typed languages. That's why I don't believe Python would be a good replacement for it. If Python is to replace Java as the first language, we'll have to find another language to teach people to use types. It's a more advanced topic, so we could actully use Java for that. But I'd prefer a language with a Hindley-Milner type system, one of ML language family. I think F# would be good for that despite its ties to .NET
Hey I use monokai with ruby too :)
&gt; the concepts you learn in C or Java can be applied to any other language The concepts you learn in C or Java can be applied to other C-like languages. They won’t help you with Haskell (or other ML-type language). I am not sure they will help you with Lisps either. C is also close-to-metal; in most other languages you don’t care about pointers or memory allocation. As for JavaScript, the jQuery days of 2012 were about the browser apis, not about JavaScript as a language.
Ruby needs better data manipulation tools and some math libraries and maybe one or two more things to differentiate itself on the market. Ruby was Python's evil twin for much of its history and did not gain momentum because of lack of funding and Rails (Japan factor -&gt; lots of development for ruby happened to be in Japan). Meanwhile Python was adopted by the big companies in the US and that made it to gain the ecosystem it needed to attract millions of other people around the world. 
&gt; Browsers are in JS. Browsers aren’t written in JS to any meaningful degree.
Not OP, but when I was learning ruby, everyone was using sublime text 2 and monokai, and it's the only color scheme I ever saw ruby written in.
I use monokai for ruby, a kind of dull cardboard colour theme for python and a monocolour purple theme for C#
Right now I'm using a color scheme called Ladies Night for java and kotlin(it's an intellij theme I found somewhere), and monokai for everything else, that I write in vim. I've been changing my vim theme kind of often jumping around to find something I really like though.
C is a loosely typed language. Strings? Nah, those are just arrays of integers. The reason we teach C in degree programs is because most other languages are written in it or C++ and the abstractions leak constantly, so it's good to know what's happening under the hood.
Yea I haven’t used it yet. I have two files locally. One is my actual .env and then I have one that’s a sample file. It has all of the keys but no data. It’s in git and is a placeholder so you can move it into place and add the data if you clone the repo. In production I’m using Dokku and have the keys loaded through it. I do this manually as once it’s setup, doesn’t tend to change. This keeps all data out of git. As far as security, if the server was hacked all of the data would be viewable by anyone with root access. Switching to encrypted credentials MIGHT help with that but I’m not sure. If someone has gained root access to my server I’ve got big problems either way. So yea, it’s a tool that could work different ways. Not yet sure what the best practice is. Seems safer than just loading them into Dokku, but not by much really. 
If anything this is good for Ruby (and all dynamic languages). The more enterprisey organisations see dynamic languages can be good for their development teams the more open they will be to Rails, Ruby, Nodejs etc. Because right now the "dynamic languages can't scale to big projects" mindset is hurting us.
It's a way of saying browsers support JS exclusively. It seems like most people understood that it was a colloquial phrasing, although you are right if you read it strictly literally.
It sounds like you meant the opposite - 'JS is in browsers'. Browsers aren't in JS. That doesn't make any sense even as a colloquial phrasing.
yeah that was scummy. should have read these comments first. 
May I ask you the reason of designing it as a singleton class instead of an object? Thanks.
Try checking the box that says "I accept the License" :)
Try reading my post
I don't get it. 
It's not a joke, I physically can't accept it. The button won't work
There is no text in your post? I can only assume based on the information you have provided the issue is they greyed out 'Next' button?
Or the fact that the title says 'cant accept ruby installer lisence' suggesting that I have tried to accept it. Otherwise it would say something like 'cant get past this window when trying to install ruby installer'
Does the radio button next to “I accept...” work?
Being an asshole isn't going to get you help any faster... Take a few minutes and explain what they actual issue is here.
No
I'm not being an arsehole. It's pretty self explanatory
Then you’re fucked. Either install [ubuntu on windows](https://docs.microsoft.com/en-us/windows/wsl/install-win10) so you can do this the right way, or ditch windows altogether and use a real OS. I don’t mean to be snarky, but Ruby dev in Windows is going to suck.
Ordinarily I use mint on my laptop but im teaching someone so I need 2 PCs capable of running scripts
Try getting a different version of the installer, I have it installed so I am pretty sure that at some point in time it used to work. Hope you sort it out. 
I've tried different versions and it still doesn't work.
I second this. Some gems have issues on windows, you can use a minimal VM for development purposes, while keeping the editing on the windows side. 
Can you install from the command line?
With what command
First off, you have a lot of context we don't. We have a screenshot with a non greyed out accept and have to come to some really terse comments from you about how we should know a lot of things from a single screenshot. We didn't know you tried multiple versions or that you're unable to click the radio button. In fact, we don't know anything except that you cannot accept. Given the msi installer, we think it's windows, but it could easily be a skinned Linux with an emulator to use msi. Or virtual box, etc. So, how about some detail? OS Revision? Downloaded from...? Specific installer name would be beneficial, too. What have you tried? 
It's windows 10, version is 2.4.4-2-x64 downloaded from the website
For Windows 10, you'd be better off using Windows Subsystem for Linux and then you can use Ruby and other tools in a more standard way, using RVM for example.
I'm just gunna use Ubuntu on a vm
`choco install ruby`
Try not being a dick when you're asking for help 
Mint is a great opportunity to teach something more! 😁
If they used my mint laptop is have nothing to demonstrate on, I'm gunna use Ubuntu on a vm
It’s a self-propagating problem. People say that Ruby dev on Windows will suck, so no one does it, and Ruby dev on Windows continues to suck as a result. You can do Ruby dev on Windows just fine for the most part. If it weren’t for this odd installer hiccup, RubyInstaller would’ve done its job perfectly to enable it. 
Thanks! Yes, I'd like to add pluralizations and date/time localization in the upcoming releases.
Hi jodosha, I just wanted to represent ideas like: \- "global" point of access \- single instance in the system \- namespaced methods (**MiniI18n.t** vs** t**, to avoid global space pollution by default) It can be implemented in a more object oriented style too, but I thought the singleton pattern fit well for this case. Maybe the thing of implement a "micro" library, which basically targets small systems/apps, also pushed me on that direction. P.S. kudos for Hanami!
You should have made that clear, people are assuming you mean that you disagree with and refuse to accept the license.
Please learn to describe your problems. We can't read your mind and as far as we can tell it looks like you can't click the "I accept" button.
It might just be that Windows is a hostile environment to develop software on if you're not using Microsoft tools. I think Microsoft wants it this way is they think they can maximize profit by doing things like this. It seems to work like this for languages other than Ruby as well.
If you wanted to use a curly brace language what would be the reason to use this language and compile to Ruby or Crystal, rather than using an existing popular curly brace language such as C, Java, Javascript or Go?
I meant "let them use mint on their machines too (in VM)" but Ubuntu is fine nonetheless. 
As a science experiment, it's an interesting idea. But I'm with you, practically you'd be better served choosing a language based on something other than aesthetics. Also, you don't have to use `do` and `end` you CAN use `{ }` for multiline blocks... Finally, Ruby without `do` and `end` already exists, it's called Perl.
This is a small project i've been working on. Uses Ruby for the code and is mostly inspired by Sonic Pi and Tidal Cycles, you can try it here: http://www.negasonic.org/ reply 
This is really stretching Right Tool for the Job, though. Python and Ruby, as languages, are almost the same and target the same field of programming - dynamic scripting. The only real differentiator is the range of application where Python just happens to have dominated the AI, ML and data science fields. For routine daily work my brain can context-switch between, at most, 3 languages. I have to have Javascript for the front-end and something compiled for large apps so I only have room for 1 scripting language. That's why it pains me that the better of the 2 - Ruby - has failed to compete with Python. It's a waste of time trying to master both.
I heard the same objection on Perl Monks regularly 10 years ago and look where it landed them.
Awesome. Good luck!
Oh....uhhh ¯\\\_(ツ)\_/¯
You won’t hear any argument from me on that front. Don’t get me wrong, the only reason I want to do Windows dev is because that’s where most of my audience would be for my tools or games. But seeing as how Windows is as big as it is, it would be nice to be able to comfortably develop in Ruby on Windows. 
:) Pluralization support is almost ready: [https://github.com/markets/mini\_i18n/pull/2](https://github.com/markets/mini_i18n/pull/2) 
There was no comparison to Ruby. There was no statement that Ruby should become more popular. It’s just a post about Python. It’s off topic.
Maybe, but don't forget that Ruby has its own strengths too. It may not be the fastest scripting language of this list, but for instance at least it's a "pure" object-oriented language, as "Everything Is An Object", which can be very useful when handling scalar types in an object-oriented way. This has become quite rare nowadays...
Indeed "{}" multiline blocks have a similar purpose. Here the goal was to use a really "holistic" approach, so that all Ruby constructs can be used with curly bracket blocks (i.e. without ever needing any "end" keyword), like any a "true" C-derivative. And this is purely aesthetical, obviously...
great!!
Tight
WSfL sucks in that aspect that it completely isolates ruby from rest of the system. So if you (like me) want to use COM from ruby, it's a no-go :/
The trouble with a singleton is that it makes it impossible to have &gt;1 differing instance/configuration of mini_i18n within the same runtime. This would make it impossible if a modularised app wanted to use mini_i18n for different purposes in different places. The benefits of having an object/instance be the provider of the i18n behaviour is, well, the opposite! You can have multiple instances of the translation services, each configured as appropriate for its context. And the nice thing is that you can still preserve a "global" style of access in this way too, by assigning an instance to a constant: GlobalMiniI18n = MiniI18n.new(configuration, blah) GlobalMiniI18n.t(:hello) I feel like taking an object-oriented approach to design would increase the number of places in which mini_i18n could be helpful and used.
Make me think of those very old RPG games
Yea totally, i like to think that it sounds like gameboy/snes music on acids :)
I did it on iTerm using multiple profiles (with different background colors) and automatically switching them based on the user+hostname of each server (a feature of iTerm itself) 
There's also an `install` argument that you can pass to the `gemfile` method, when set to `true` it will install any specified gems that aren't already available on your system. https://github.com/bundler/bundler/blob/master/lib/bundler/inline.rb#L13
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bundler/bundler/.../**inline.rb#L13** (master → 42c4609)](https://github.com/bundler/bundler/blob/42c4609e01c0869f5341f658d2a345a8969fa3e2/lib/bundler/inline.rb#L13) ---- 
Oh, that's really weird, the bundler page says it'll install without specifying that. I'll have to do some testing once I get home and see which documentation is right
And then random scripts start polluting my global gem installation... at least Isolate did it right with this functionality a decade ago, installing to a local subdue.
I know is what you asked for but to get something similar in my app I use pry and this initializer: https://gist.github.com/jabawack81/1b111022f1720ae71745b7589dd315c0 it will add the rails environment to the pry prompt.
Does anyone have a link to a good bundler tutorial. I have never really learned to use it.
I'm about 95% certain you can replace every `do/end` with `{ }` and the only thing that will complain is rubocop. e.g.: these are equivalent: ``` a = [1, 10, 20] a.each { |var| puts var * 20 } a.each do |var| puts var * 20 end ``` So again, I think as a science experiment, a language that transpiles to ruby OR crystal is pretty fucking slick! (Ruby and Crystal are _REAL_ similar but not 100% compatible... there's a few syntax gotchas that you have to lookout for moving from one to the other) But practically, you're essentially adding another layer of abstraction for the sake of aesthetics... which is the literal definition of [bikeshedding](https://en.wiktionary.org/wiki/bikeshedding) So please take my criticism in the vein it is meant: what you've accomplished here is really cool! While it has no practical application in the real world because it doesn't actually solve a problem... I feel like you have to have learned something in making this project, and who knows, maybe it'll inspire you to come up with the next Google! Just to say it another way, just because it isn't practical, doesn't make it any less cool! I can't wait to see your next project!
Or use gemsets?
&gt; boo Last commit was 12 days ago - looks like it's still alive!
I am interested in hear what are the reasons you think Ruby lost to Python? At least in your domain.
Not until some day something better can replace Python in Data Science. Which is unlikely to happen in the next 10 years. Everyone are too invested into it.
If we just count the Python PEPs, and their core contributors, as well as big companies behind compared to Ruby. It wouldn't be surprised that Ruby is behind. I am hoping with the acquisition of Github, someone could invest some money into it. Since Github should no longer have as much pressure financial wise.
This tool is indeed completely pointless for an extreme majority of Ruby/Crystal users. I know it, so no problem with that... ;)
It looks as if the `install` parameter functions like a `force_install` option. Looking at [line 60](https://github.com/bundler/bundler/blob/master/lib/bundler/inline.rb#L60) it will install gems if they are missing despite the value of the `install` parameter.
This is the most useful thing I have seen this week.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [bundler/bundler/.../**inline.rb#L60** (master → 42c4609)](https://github.com/bundler/bundler/blob/42c4609e01c0869f5341f658d2a345a8969fa3e2/lib/bundler/inline.rb#L60) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e3a8db8.)
There is also a related proposal Proposal to add Array#=== - [https://bugs.ruby-lang.org/issues/14916](https://bugs.ruby-lang.org/issues/14916)
Isn't this whole problem largely solved by using bundler in the first place? I haven't really come across a scenario where I've needed to specific a gemset; I started about 4 years ago.
Why is this a problem? What would you use your 'global gem installation' for other than playing around in `pry`?
Yea, I don't think this is a good idea. One of JS's worst traits is due to its triple equal operator, causing so much confusion on when and were to use it. I don't think Ruby needs this level on confusion introduced into it.
Scala and Crystal both have that :)
The issue with `==` vs `===` in JS in entirely unrelated to Ruby's use of the operators. `==` In Javascript allows type coercion, you should basically never use it, really the only acceptable place to use it is when testing for 'null or undefined'. `===` in Javascript is general equality without type coercion, Javascript doesn't really have identity equality, it kinda does but in a really weird way. In short equality in JS is a train wreck for a lot of reasons. In Ruby: `==` is general equality that may be overridden by sub classes, but in general doesn't do any sort of type coercion. `equal?` is identity equality `eql?` is hash key equality `===` is case equality, really it's a set membership test and within this definition I think it makes sense to define it for hash and array.
Yeah, I’ve been doing bundle install —path vendor/bundle pretty much forever, it works fine. I was only arguing against the auto-installing.
It should respect your `BUNDLE_PATH` bundler config option. I always have mine set to `BUNDLE_PATH: ".bundle/gems"`
Yep !!! I'm also a great fan of Crystal, for many reasons, including this one...
Ruby doesn't have a presence in the AI, ML and data science fields. There is no reason why Python as a language should be chosen above Ruby in these fields other than the libraries available. That's the fault of the Ruby community for over-focusing on the web domain.
I understand the differences. I was only stating that having a triple operator causes confusion.
Then explain the "(Boo)" part. Lament of the Ruby community is how I read that :-). Python is frequently compared to Ruby and it's obvious why - they're both dynamic scripting languages which run at about the same speed and have competing frameworks in web development (Rails/Django) and devops (Chef/Ansible). Not off-topic.
I use Fish and on my server I have Fish for my user account but not Root. Fish shows me a bunch of environment info so I know where I am, who I am, and so on. ZSH also does this. I’m pretty sure you could set either one up so when you run the command it changes your terminal. In Fish you can create commands very easily. So set one up called heroku, then have it load a different theme and execute whatever you want to load your heroku console. Then you just change the theme to show the info that’s useful to you when running the heroku console. 
I'm not sure what your saying, Ruby already has a `===` operator, it has for a very long time. The only thing at question here is that Hash and Array don't currently implement it.
ChefDK gets weird with bundler. Gemsets kinda help. 
ooh, nifty. That would save some manual effort every time I check out a fresh repo...
I disagree, /u/joltting has a point here. `21 === 21` returns false, but `Integer === 21` returns true. That's because `===` is not about equality, it's about matching. So consider the following example: ``` { age: 21 } === user ``` In this case, according to the proposal, 21 will be compared for equality against `user.age`. This is a violation of the intent of case equality in ruby. _This_ is what the feature would look like if the case equality operator were used for the comparison: ``` { age: Integer } === user ``` I don't know whether this feature would be valuable, but IMO it's pretty clear that the actual proposed feature _does_ indeed muddy the waters between equality and case equality (i.e. matching).
First off, `21 === 21` is true, as is `21 === 21.0`. `===` is aliased to `==` for `Numeric`. The same is true of String and many other classes. &gt; `{ age: Integer } === user` &gt; In this case, according to the proposal, 21 will be compared for equality against user.age. This is a violation of the intent of case equality in ruby. Sorry but I don't see that at all. As noted above, `===` is aliased to `==` for many classes. Also you're stretching your definitions a bit. `some_hash === user_hash` would read as "Is some_hash in user_hash", which lines up quite well with how case equality is implemented in many cases. That said I do this the proposal has the argument locations backwards, it should be `user === { age: 21 }` to line up with common usage: Integer === 21 =&gt; true, 21 is in Integer (1..10) === 7 =&gt; true, 7 is in the range (1..10) { name: 'bob', age: 21 } === { age: 21 } =&gt; { age: 21} is in the hash { name: 'bob', age: 21 } 
Ah, thanks for that knowledge. I stand corrected. Still, based on that new understanding, I find my overall position reinforced. Given that === operates differently depending on the receiver class, it seems extremely surprising that for this feature, a match target embedded in a hash as a value would be compared with ==, and not ===. Essentially, I'm arguing that if this feature is valuable enough to add to the language, then Hash#=== should be implemented in terms of ===, not ==. Based on your response, I am encouraged that the behavior would satisfy the use cases I see in the proposal. Cheers! Thanks for correcting me.
&gt; it seems extremely surprising that for this feature, a match target embedded in a hash as a value would be compared with ==, and not ===. It's not? The proposal is that `{ age: Integer } === { age: 21}`, thus the values of keys are compared with `===`. 
Oh, whups! Wow, I just totally misread that page. Thanks again.
r/burstingout 
Rather than duplicating the identical tables for model 1-5, maybe have 5 sequential tables, and make expanding a Model 1 trigger the reveal the other four tables? 
This looks like a cool hack, but: 1) the 'bundle update specific_gem' might not work 2) sometimes you want to be sure you resolved dependencies before you run the program so you'll have to put some 'press any key to continue' and think how to deal with it when there is no user terminal, etc. 
Awesome! Will this provide M:N scheduling of fibers or are they bound to a single thread as with MRI?
It's M:N, and you should be able to configure N.
What is this supposed to be? Just a frontend scraper for tbp?` 
Great stuff and love playing with Truffleruby. Anyone know how close we are to rails support? Thats the big thing I and a lot of people are waiting on.
Forgive my ignorance, but is a fiber like a thread? Do you have to worry about shared data/race conditions?
You do but a fiber is like a psuedo-thread that the interpreter knows about but not the Kernel, instead of letting the system manage these the interpreter needs to keep track of them and run them against real kernel threads. This allows you to have specific control over how many are created and not be limited by the JVM/system etc which in TruffleRuby's case would throw an error after 5,000 "fibers" where the MRI was happily creating 300k. You still have to worry about race conditions and this is where Read-Write Mutexes come and help.
I'm sort of glad they did something, but ugh, this just seems like a total mess. Why not `Exception#print(io)`. Less string allocations required, automatic tty detection, etc.
Fuck, I'm only on 4.2 and that was a Herculean effort
Yes. Intended to be used for another project.
I’ve found 4.x to 5.x is easier than 3.x to 4.x, if it makes you feel any better. 