OMG, imagine if you have to fire up a browser whilst doing Ruby development!
Apache does this as well, they don't trust a third-party company to control their repositories, but mirror everything read-only to Github. I have put in Github pull requests to Apache projects, and although my patches are processed by the maintainer using git command line against Apache servers and not via Github, it does not look very different for developers.
But what if I don't want to use bogomips.org!
&gt; No, this isn't the case. GitHub requires an email address to log in and patches have been sent through email for ages. By definition, every GitHub user is also able to contribute through email. GitHub provides a valuable user interface that makes it possible for people that aren't kernel developers to build and contribute to open-source projects. Git's hard enough to learn as it is, especially once students have to learn about branching as a facility for collaboration. Pull requests are a little bit mind bending, but there's still a modern UI there, compared to "you have to use the terminal, an email client older than you are, and a bunch of commands that would take a week of teaching you history to explain." Hosting your project strictly on email ensures that nobody who cares about software usability will be able to submit issues or pull requests.
Acting on principle syndrome.
This is actually a really good point. What is the general opinion of Gitlab? They offer paid solutions to help pay the bills but everything is open source and they try to be very open. 
Jruby is the best bet. You can just ship them a jar and they can double click on it.
See? Nobody cares. Nice hat.
Or just use gitlab?
Why not? Lambda are first class functions according to the definition and Ruby supports Lambdas. Can you point me to a definition where ruby doesn't make the grade. Note:A definition, not just your own opinion. 
LOL, as a strong advocate of cryptocurrencies but a strong critic of free software, I think it's safe to say the two don't necessarily go hand-in-hand.
Wait, but I do pay for GitHub, it isn't free. I shell out for my handful of private repos and so does my work and most of my work's customers. We do it because we got used to the convenience while working on/with open source repos, which are indeed free. So my assumption is that these things are free because they are a (very effective) advertisement/product-demo for a service that isn't. 
Wait, Git (and Github as well) has hooks. Why not write a service that sole purpose is to mirror a Git repo to Github and vice versa. Trigger it on each side after any action and you should have a free mirror for OSS projects with a popular UI and yet you don't have to deal with their awful (just kidding) website. PS: Eric has a very important point though that most people just laugh off. But Github can change their ToS at any time etc. His attitude seems overkill but I guess that kinda happens when people continuously laugh off your legitimate fears even while all those things happen in the world. Pick your favorite three letter agency, pick your favorite traitor/hero, do some googling or duck duck going and you'll have some good examples.
Nahh, I remembered reading this a while ago. I think I was going through the author's tweets and emails and stumbled upon it.
Eating junk between your toes syndrome.
I think this is what the developer was talking about. I'll give it a look. Thanks for the response!
Thanks for the reply, I'll check it out! 
"Pouncing"? No, making a point, and one I believe is valid. Claiming ideological purity is a fool's game. I don't disagree with your points. Gitlab offers a good alternative.
It's a fairly competent github clone once you get it running. Not perfect though, and a complete pain in the ass to set up. It does have bugs, which means you have to upgrade it to fix them, which is effort that probably no one wants to spend for no good reason. 
This was my thought. I setup a gitlab install at my company as well as a customer....kind of ironic since gitlab uses unicorn as I'm sure github does too. While not as feature filled, gitlab is plenty sufficient.
The funniest thing is…this is coming from a guy who wrote a web server. God I hope EngineYard fixes the bugs in puma…
While thats true, I frequently will notice some typing error or minor documentation issue in some project. On GitHub-hosted projects, I can click "edit", fix, save and pull-request right in my browser. Sure, anything more and you want to be able to run the test suite. But these minor tweaks are so useful, trivial to review and will happen more often if they're easy to perform. 
True. But if they aren't doing anything malevolent and it is always possible to migrate away - I don't understand the hate.
Ruby getting better? This could be wonderful. The more Ruby can do, the less I'd have to lean on other languages. There is a wonderful Zen about having your product's core codebase be entirely in one language. 
Am I missing something? Where are the definitions for this syntax?
Agreed, would be significantly more useful with them.
haha I've been thinking of creating a website just like this one! It truly helps to know the name of certain operators when using Google since it just ignores symbols. The design is really cool, but I'd say some of the names are wrong. * `?:` - Ternary operator or Shorthand If * `||=` - Double Pipe or Equals to operator * `&lt;%=` - Embedded Ruby operator ([discussion on SO](http://stackoverflow.com/questions/1221715/whats-the-actual-name-of-tags)) I've been keeping a file with lots of names of operators, I'll contribute a few. Also, the operator ~&gt; has an interesting story: Initially some called it "the spermy operator" but people didn't like that name (for obvious reasons). Thus, it was changed to twiddle wakka ([source](https://github.com/rubygems/rubygems/pull/123)). In rubygems it's referred as "twiddle-wakka", with an hyphen ([source](http://guides.rubygems.org/patterns/#pessimistic-version-constraint)). Later, thoughtbot started referring to it as "Ruby's Pessimistic Operator", which is the term I've used since ([source](http://robots.thoughtbot.com/rubys-pessimistic-operator)).
Nope. We perform interviews where we talk about code, pair-program, and draw big things on whiteboards. An interview is half about proving the person can program, and half about making sure you like the way they think. Just asking if they've memorized the language means next to nothing.
Contribute https://github.com/anildigital/ruby-operators. Add issues, pull requests etc. Lets make it better.
These are great questions... for a trivia game at your local Ruby meetup. Using them for interviews is a terrible idea, for the most part. Although there may be a couple of exceptions. I expect someone claiming serious expertise in Ruby to be aware of the Foo:Bar scoping. And anyone claiming Ruby skills beyond beginner levels should absolutely be aware of nil and false being the only falsey values. But the Hello World proc is pure trivia. I would expect a good developer to spend time learning another language rather than spend that same time learning pointless dusty corners of Ruby like the square bracket call syntax.
Well, let's clarify. It's not the "free" in "free speech" I disagree with. I care a great deal about that particular right and certainly it can be exercised in software. However. I don't need a license to guarantee or enforce my rights. The right to free speech is inalienable and the courts should protect it regardless of what license, if any, I apply to a particular piece of software. So, that out of the way, I consider all *GPL licenses, particularly AGPL to be freedom reducing, not freedom expanding. There are legitimate cases where that is useful and desirable, but it's almost always in scenarios where normal community license behavior is detrimental to the integrity of the community as a whole. Game mods are a good example. Mods are frequently abandoned by their authors either with a binary only distribution or an non-redistributable license, particularly on graphics assets. Mods with communities that would happily take over maintenance cannot. However, even here I think there are better solutions than making the plugin framework *GPL. I'm far, far less enthusiastic about companies that make code available as GPL as a tool to force people to pay for a less restrictive license, often by additionally holding back some of the code. And even correct *GPL usage is frequently problematic for anyone who wants to write non-web-apps. (Or in the case of AGPL, just straight problematic.) Despite RMS's best efforts, the GPL business model isn't a good one, and we don't live in a utopia where open sourcing everything you write is the path to a strong economy. I'm sure there's an argument to be made that "All Rights Reserved" is the most restrictive license, but at least it doesn't tease you by saying, "Here's an awesome codebase we've built, but here's all the things you can't do with it (that you probably want to do with it)".
To be honest I don't really see the point of this website without the actual syntax
I always called the spaceship a "double-dildo", glad to know it has a real, more workplace-friendly name.
That already tells me a lot about you. What makes you tick, etc. There would be some technical stuff in there. I'd drill into it and see what got you excited, why you made the decision you did And if there really wasn't, we'd talk about another favourite that did
Ruby is a DSL for Object Oriented Programming… 
Not trying to troll, but why would you use MooseX, Moose, or related libraries?
http://www.houseabsolute.com/presentations/intro-moose-class/ is for the Perl version. Its unclear if all of the same benefits apply, at least from the examples given.
If you want static typing, use a statically typed language. What's the point of not having the compiler check types just so that you can check them manually? Especially in a wrong way - is_a? returns whatever the creator of the object wants it to return.
Sure, in another appropriately named list, but not in a list advertised as 'Ruby operators".
[We Use BobX (TDWTF)](http://thedailywtf.com/Articles/We-Use-BobX.aspx)
This feels a teensy bit redundant.
Gitlab had come a long way though. They recently switched to using Omnibus which makes the install a lot easier. Been using it at my current job and becoming a big fan (except for the random little bug here or there). 
Sinatra doesn't have any of the generators, helpers, etc. that Rails has. If you want anything that resembles MVC you'll have to create the class, etc. Unless you're trying to learn how to build a web server (in which case, good on you man!), Sinatra is as barebones as I'd go, in my opinion. Or you could try out the microframework [Cuba](https://github.com/soveran/cuba), which looks really cool.
I feel like this post is doing a terrible job of explaining why you would use this library. I'd suggest reading some bits out of [Moose::Manual](https://metacpan.org/pod/Moose::Manual). Specifically these ones are the interesting bits: [Roles](https://metacpan.org/pod/Moose::Manual::Roles) [Method Modifiers](https://metacpan.org/pod/Moose::Manual::MethodModifiers) [Meta Object](https://metacpan.org/pod/Moose::Manual::MOP) I've been using more and more Ruby and really this library is one of the things I miss most about Perl. Well that and the context is amazing in Perl, but I also know it's really odd/weird feeling compared to other languages (this is where all the hacky/wtf does that do stuff come from). Used in moderation, the context stuff is very useful but making obscure code for production is dumb.
*Disclaimer: I'm a Perl expert and a Ruby intermediate. I also don't know exactly how much of Moose is reimplemented in this Ruby MooseX, but am speaking from experience working with Moose itself.* Moose isn't *needed* in Perl, what it does is provide layers of DSL and additional features along with a documented metaprotocol for dealing with them. It definitely exists as a way of bringing people together on the same underlying sort of object system, which isn't necessary for Ruby at all, since it's core to the language, but Moose does go beyond that. You can of course build all the same things ad-hoc in Perl without a framework, just as you can build the same features in ad-hoc Ruby on top of ruby's object system. The prima facie benefit of a DSL like this is that your more complex systems are more concisely self-documenting. They show a comparison of setting up similar attributes and avoiding repetition of each one, for example. Method delegation, if this is anything like its Perl progenitor, is as simple as providing the "handles" option to the attribute setup. Ruby's Forwardable is ugly to use directly, but you can. Standardized method modifiers can be nice too, but the AOP needs of it are generally counter to what's considered good Ruby practice, so they might not feel useful as often as in Perl, which to me hasn't been all that often. (I try to design against them being necessary, I'd prefer them to be sugar around super method calls. Roles can use method modifiers, and I'm iffy on that degree of magic beyond like, logging.) I also note that they show an example of isa that isn't as useful in Ruby as it is in Perl (with multiple inheritance), and failed to show that it also supports isa validation that is duck-typing or role interface checking. I can only assume you're using some DSL convenience layers in your existing work somewhere. Same deal, right? (I'll note that some of the advantages in system-buidling are definitely weakened without good integration with documentation and coverage tools.) Plus I imagine you see this same basic project pulled over to Ruby so often (I swear I've seen four or five?) not because it's *needed* but because people who enjoyed working with Moose both saw that Ruby's core kit didn't quite match the degree of refinement they're used to, and, with a big nod to the Perl mindset, *because they can*. But notice the github project hasn't been touched in the 6 months since the blog post -- it's the "I'm used to Perl" stereotypical hobby project ;) But that's not to say such projects are always devoid of good ideas for the Ruby world. Many of them really already are found in the Ruby ecosystem somewhere, just not in as heavyweight and integrated a single layer as Moose. I see this sort of thing as neither necessary nor unnecessary, which is okay.
Well, scratch Unicorn as something I was planning on investigating in a month or two. I'm *very* pro-open source; have even contributed to a few well-known GPL- and otherwise freely-licensed projects. I tend to be to the left of most Americans and Singaporeans on social issues (think an American Green Party supporter becoming an [SDP](http://yoursdp.org) supporter), but one thing I have not been able to tolerate is zealotry in just about anything. Yes, if you look at things from a certain reasonably respectable cloud of viewpoints, corporations are evil to one degree or another — however, to participate in the global economies of commerce or of ideas, they are presently a *necessary* "evil". The passion by which you adhere to your ideas will not prevent you from losing your shirt and everything else you own in *one* lawsuit; limited liability and a competent lawyer give you a good chance in much of the world. One idea about freedom that's increasingly important to me living in Kantian-paternalistic Singapore is the freedom from others imposing their beliefs on me. I've not felt that Zach Holman, Tom Preston-Werner and crew were imposing their beliefs on me so much as providing me with great tools to make my professional life easier and more social. After reading Mr Wong's tantrum, I doubt I would feel the same way about his software or services. Isn't freedom great?
Upvotes to all three of you, redundancy notwithstanding.
Beware the poseur who pouts, "I knew it all along".
Stick it with the bacon gun (`~=`). Anybody have a more kashrut/halal name for *that* puppy?
Okay, I can give you that. I'm pretty vocally against GPL myself, but I'd at least take GPL over no code release. That said, all of my projects are MIT/BSD/ISC/Unlicense when/if released.
To illustrate ggPeti's point: 2.1.1 :001 &gt; class Anything 2.1.1 :002?&gt; def is_a?(x) 2.1.1 :003?&gt; true 2.1.1 :004?&gt; end 2.1.1 :005?&gt; end =&gt; :is_a? 2.1.1 :006 &gt; a = Anything.new =&gt; #&lt;Anything:0x00000001fe9560&gt; 2.1.1 :007 &gt; a.is_a? String =&gt; true 2.1.1 :008 &gt; a.is_a? Integer =&gt; true 2.1.1 :009 &gt; a.is_a? Array =&gt; true Though this is an extreme and contrived example, no one should ever have any illusions about the cost of Ruby's flexibility. In reality if you design your messages well then type errors won't be an issue, but if you need type checking don't use Ruby.
Depends on whether I end up having to clean-room an implementation of something or not in order to bypass the derivative work clause. Because seriously, fuck that shit.
This does not illustrate anything interesting. It shows that a hacker can bypass your type checking. Which is also true in C, C++, Java (unless you've turned on a bunch of security features) and even Haskell. Yes, it is easier in Ruby because most things are easier in Ruby. So what? Since when is type checking usually used to stop hackers? Type checking is designed to help you the programmer find and fix errors faster. That's all. If you the programmer have decided to use is_a? to work around your own type checking then it is good that Ruby gives you the flexibility to do that. If you are using a 3rd party library that lies in is_a?, I'd suggest you stop using it, because that's a really bad code smell. 
&gt; If you want static typing, use a statically typed language. He doesn't want static typing, and this isn't static typing. &gt; What's the point of not having the compiler check types just so that you can check them manually? He isn't checking them manually. That's the whole point. He's declaring them and MooseX is checking them for him. So the next question is: "why would you want to validate types at runtime" and the obvious answer is: "because it makes debugging simpler". Instead of having a type error thousands of lines from now when this non-integer integer has been passed through dozens of method calls, you get the exception immediately. There is nothing wrong with this pattern at all.
Hi guys, The video can be found here (reuploaded) https://www.youtube.com/watch?v=VOpEA9FCL9A&amp;index=1&amp;list=UUw6mUFp6_utmc1p0y30Pw1A
Hi Tigenzo, the video can be found here: https://www.youtube.com/watch?v=VOpEA9FCL9A
Hi Koravk, I believe a new video has been re-uploaded: https://www.youtube.com/watch?v=VOpEA9FCL9A (let me know if the link doesn't work)
Hi rs-485, you can watch the video here: https://www.youtube.com/watch?v=VOpEA9FCL9A if the link doesn't work, please let me know.
Hi unsignedotter, you can watch the video here: https://www.youtube.com/watch?v=VOpEA9FCL9A if the link doesn't work, please let me know.
Great article. 
Thank you!
amazing news
Link to the tweet: https://twitter.com/yukihiro_matz/status/495219763883163648
I always named some of these according to what they are rather than what they look. "&lt;=&gt;" is "compare operator", "===" is "case equality operator", "!" is "not", "?:" is "ternary operator" etc. I never understood why people need funky names for this, could someone explain? PS missing `!~`, may I suggest "superman" given the flowing cape next to the standing figure? 
thank you!!
Great thank you guys. That clears things up quite a bit actually. I'll definitely have to do a bit more reading and messing around with it, but it's a good start!
Pretty much sums up how I feel. Helpers are better than decorators for simple cases, and presenters (or view models) are better than decorators for complex cases.
can you put the sourcecode on github please. Also, is working with jruby?
Helpers are an abomination no matter what the case, i always try to avoid those horrible, evil little things..
A lot of people use rails. Would you expect a bakery subreddit to avoid talking about bread just because bread has its own subreddit?
Why not `require_relative`? It was made exactly for this, or is there some caveat?
I think that ruby is pretty straight forward. Rspec has its awkwardness. Have you seen the [better specs website](betterspecs.org) ?
Avoid forking and using df. The "sys-filesystem" is a good gem, it's using ffi underneath, with uses a c function that reads the file-system, rather than forking. The other choice is using "ffi" itself.
I would start reading some of the books listed in the sidebar; maybe start with "Eloquent Ruby". An issue you may run into is that your company's codebase may not be particularly exemplary (tech debt builds up everywhere) so you might start with learning objectively-good Ruby syntax and patterns rather than starting with some potentially weird things you find in your own company's code.
No they aren't. In most simple cases they're much lighter weight than having to lug a view model around. Aside from problems that arise from their *misuse* -- and I've seen presenters, decorators, etc., all get misused in egregious ways -- what long term maintainability problems do they present?
Their problem IMO is that they're just easier to *misuse* than the alternatives. Fundamentally, they're not object oriented, they're a bunch of disconnected 'functions' stored in a file somewhere. The real pain, is when helper modules are mixed into helper modules are mixed into helper modules, you see a naked 'function call' in your view and it's just so darn hard to find where it came from, it jump popped up out of nowhere. You could argue that this is just misuse, but it's so darn easy to misuse them that i try to avoid them altogether (except in extremely simple cases or for very small projects)
so close :P [better specs website](http://betterspecs.org) (added protocol)
The case is not a require, it's loading some generic file (in this case, a YAML file). require_relative is great if you're requiring some code, which was not the case here.
Are there some specific quirks that are bothering you? It might help to talk through some of the cases you're seeing and help you understand why someone might have made the choices they made, or how Ruby is different from the other languages you know. Obviously you might need to be careful sharing production code from your employer, but maybe there are some concrete examples we could help you through.
I would reimplement the `if delta &gt;= ARGV[0].to_f` check in terms of seconds since epoch. interval = ARGV[0].to_i command = ARGV[1] remainder = Time.now.to_i % interval while true if Time.now.to_i % interval == remainder puts `command` end sleep 0.01 end
Wrong, TDD is about driving design with tests and refactoring. Any old hacker and slasher can write unit tests. There is so much more to it. You should try writing elegant and beautiful code one day then you can talk about TDD and really love it....
Gem install birthstone isn't working for me.
A lot of stuff in Rails and Rspec is (intentionally) concealed by abstractions/DSLs/idioms, which probably doesn't help the case of someone coming from those more explicit languages.
It's overkill but maybe eventmachine? http://www.rubydoc.info/github/eventmachine/eventmachine/EventMachine.add_timer What's the use case, if I might ask?
I would avoid a polling loop, you can calculate the time you're allowed to sleep (though this doesn't avoid drift): require 'time' interval = ARGV.shift.to_f cmd = ARGV.shift wake = Time.now + interval while true now = Time.now sleep (wake - now) if wake &gt; now wake = Time.now + interval puts `#{cmd}` end If you're less concerned about maintaining the specific interval, and more concerned that T/i jobs are completed (T = total time, i = interval), you can look at implementing a [Token Bucket](http://en.wikipedia.org/wiki/Token_bucket) which is filled at your interval. This decouples the length of your command from your interval (for example, if your command sometimes runs longer than your interval, you can make up for it on average). Edit: The above implementation will accumulate small amounts of error over time (not as large as OPs, however) and is susceptible to skewing if the passed command will ever run longer than the interval. Here's an example token bucket implementation. The key is global time and understanding how many executions you should have had vs. how many you've actually had. Like the implementation above, this will never catch up if your command takes longer, but on average, will not skew for commands which are, on average, shorter than the interval. require 'time' interval = ARGV.shift.to_f cmd = ARGV.shift start = Time.now.to_f count = 0 while true now = Time.now.to_f available = ((now - start).to_f / interval) - count.to_f if (available &lt; 1) wake = start + (interval * (count + 1)) sleep(wake - now) if wake &gt; now end puts `#{cmd}` count += 1 end
This drifts *less*, but you would have to specify what your needs for drift (or lack of it) are. s = ARGV[0].to_f while true sleep s fork { puts `#{ARGV[1]}` } end 
Why not inherit from `Numeric`?
It sounds like you're taking advantage of inheritance, which is actually the way you're supposed to do it. (Reuse your code.)
Is the type you are creating really just a number? If so, why are you creating it? If not, perhaps you don't need as many arithmetic operators as you think. For example, does your type need to be able to convert to polar coordinates? Take a modulo? Convert to imaginary? Those are just some of the things you get by inheriting Numeric, and it might be detrimental to understanding the type you are creating.
**Is Stackoverflow banned in your country?** [Begin Rescue not catching error](http://stackoverflow.com/q/3168160/322020) [Unable to catch an exception in Ruby](http://stackoverflow.com/q/1257921/322020) 
Sure it would be nice to have this for a newer version. I still like things like this though, and like being able to dig in, as the author has exposed here, without having to dissect or dig too deep into the ruby vm itself. The more debugging and analysis tools we have, the better off we are :-)
Evidently not you, but considering that most open-source project leads are constantly wishing for more help, many people.
Github is fantastic with a small project because every man and his dog gets involved in that project. But with something of that scale, do you really want every "my first patch" to be a pull request against major infrastructure? Or two billion open "issues" most of which relate to config errors? The current state of Wordpress is a disaster, it wouldn't be hard to slip in a "Pull request #4353534: Call admin a loser upon logon". If I'm ever managing something this big, I wouldn't want it on Github.
You can redefine operators. Assignment operators come automatically: # a creature that can merge with another of its species, # combining their power (with 27% efficiency loss) class Foo attr_reader :power def initialize(power=1.0) @power = power end def +(other) raise ArgumentError unless other.is_a?(Foo) Foo.new((self.power + other.power) * 0.73) end end a = Foo.new b = Foo.new(3.0) puts (a + b).power # =&gt; 2.92 b += b b += b b.power # =&gt; 6.3948 
Write a Rack middleware. Use PORO "function object" pattern. Unit test everything in isolation (because you can, now... since you're not on Rails). Your unit tests will be fast as shit. Win.
Well now.. Don't you look like the fuckstick for being a jackass without reading the link? 
Thank you, thank you, thank you! 
http://patshaughnessy.net/Ruby-Under-a-Microscope-Rough-Draft-May.pdf Here is an interesting read if you want to understand exactly what a hash is, and what the implications of using hashes are.
&gt; Once you have ~~Hashs~~ **Arrays** under your wing, then next step is Hashes. That confused the shit out of me until I followed your link.
No [fetch](http://www.ruby-doc.org/core-2.1.2/Hash.html#method-i-fetch)?
Just FYI, there is a Ruby class called Set that is like an array, but is searchable much faster than an array, because it uses an algorithm that is similar to what hashes use to locate a value based on the key you give it.
Everything is an object. That is to say, even Class and Module are actually objects in the object model. http://skilldrick.co.uk/2011/08/understanding-the-ruby-object-model/
that diagram misses out singleton classes (which are an impt part of ruby's object model, particularly with regard to MRO)
This is true, perhaps you could add a link to some explanatory blog post you found helpful?
I can totally recommend the videos (for $) by Dave Thomas: http://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming I loved watching them. They so step-by-step. Perfectly explained. Nice drawings and examples. Just awesome!
Woops! Thanks for the tip, updated the text.
I find that my_hash['description'] does the job
They do similar things but `fetch` is often better. It saves you from missing or mistyped key names and allows you to easily and safely set a default.
What would the founder of Wendy's know about Ruby?
you can either: * gem install /path/to/gem/zeus.gemspec * gem install /path/to/gem/zeus.gem (if you have build it) Make sure to have a bumped version. However, I'd rather use bundler for that task: * add it as a path requirement in Gemfile (for bundler): gem 'zeus', :path =&gt; "path/to/gem/" * add it as a git repository requirement in Gemfile: gem 'zeus', :git =&gt; "some_repository"
I see your point. I have updated the article to include a section for fetch.
with eigenclasses: http://blog.mikecordell.com/2013/07/27/ruby%3A-classes,-modules,-and-mixins.html
Heh, I did something similar as part of my degree. Came out half-arsed (you try building an interpreter in 3 months!) but it's in a fairly decent state. Here's the lexer I came up with, with a bit of help from MRI: [Github Gist](https://gist.github.com/MattRyder/31b8a32c91f889de300c)
I have to agree with you. I've been using Ruby for years, and I just now learned that nonzero? doesn't return true or false, like it should.
&gt; you try building an interpreter in 3 months! I have! But I cheated and wrote it with Ruby. Good stuff though, I'll have to see if I can learn something from your gist, for instance, I haven't used %x with flex yet...
Very ambitious and interesting series. I look forward to it!
You need to set zsh as your default shell: http://superuser.com/questions/231735/how-do-i-change-my-default-shell-from-bash-to-zsh
YearMonth -&gt; SpecificMonth * SpecificDay * SpecificMonth * SpecificYear day = SpecificDay(2000,01,01) sounds pretty explicit.
That's fine, I don't know the gem.
 [year, month] &lt;=&gt; [other.year, other.month] works and reads a bit better.
It still misses out a tonne of singleton classes, for example, the singleton classes of Object/Module/Class themselves and how they're related. A few years ago i did one for ruby 1.8, it includes ALL classes and their singleton classes: [complete ruby class diagram](http://banisterfiend.wordpress.com/2008/11/25/a-complete-ruby-class-diagram/) 
I'd recommend just finding something you're interested in. Personally, that's a much higher motivator. Github has a somewhat handy explore feature, here's the one for [Ruby OS Projects](https://github.com/trending?l=ruby&amp;since=monthly)
Check out rufus-scheduler. John is a great guy and a fantastic Rubyist.
OpenHub is another good place to look: https://www.openhub.net/p?query=ruby&amp;sort=activity_level
Forgot about class instance variables. 
The problem with many of the resources I've seen to search for OS projects is that the ones listed are usually mature projects with thousands of lines of code. As a beginner that is overwhelming. I would love to find some much smaller new projects to get started with. Does anyone know a place to find something like that?
Thanks. And thanks all, the current status is that you showed me that it's not just a matter of few lines and I went on to use cron and my project works now. Just that I was not able to speed up the testing with a sub-second scheduler, but it's all forgotten now. 
While the Ruby community is slightly better about this than others, most projects can still *always* use help with documentation. Trying something new? Docs suck? Fix 'em and open a pull request.
The link above for openhub is quite useful. Found a few which might interest you: * [capistrano (3k)](https://www.openhub.net/p/capistrano) * [jekyll (11k)](https://www.openhub.net/p/jekyll) * [rake (9k)](https://www.openhub.net/p/rake) Also, try new projects on openhub: https://www.openhub.net/p?query=ruby&amp;sort=new
If you need scheduling without drift, you're going to have a tough time getting it on Unix systems, because POSIX requires drift -- its seconds aren't always a second long.
MOAR!
&gt; So, that out of the way, I consider all *GPL licenses, particularly AGPL to be freedom reducing, not freedom expanding. Legally by default you have no permission to copy someone else's code at all. GPL extends you permission to copy if you agree to certain terms. So clearly GPL cannot be *reducing* your freedom. It may increase your freedom less than other licenses, but that's a different argument.
Well, maybe I didn't express myself correctly - the interval between the two cycles does not have to be exact. We may drift in one direction for a bit, then detect it, compensate, drift in other direction and then reverse again and repeat. But I guess it all comes down to reading the RTC rather than "sleeping". That's probably what crond does and possibly some of the available timing/scheduling/daemonizing ruby libs. I'll look into it again at some point if I don't figure out another straightforward method to "fast-test" my applications that are meant to utilize cron in production. The idea was to test a minutely SNMP poller with 10 seconds intervals to have the real-life-like tests done 6 times faster. PS. Just as a side-note, I think I have an alpha-quality [poller + grapher + RRA-in-SQL] graphing tool coded now. A ton of code refactoring and feature development will follow. It's [multithreaded ruby scripts + SQLite + gnuplot], opens up quite some new automation, performance and interfacing possibilities compared to cricket/mrtg/rrdtool solutions :) 
He [does use node.js](http://gilesbowkett.blogspot.com/2012/02/rails-went-off-rails-why-im-rebuilding.html).
I don't like the page. There is no description at all about the projects, only bug tickets. You have to google the project names.
Soon! While I've already written the second post, I haven't edited it yet. I suspect I'll publish it the middle of next week. I kind of want to stay ahead of the curve on content so I can reliably publish every couple of weeks and not keep people waiting forever for updates.
Im not sure its a newbie OS project, but I think this could be really cool for shoes (not having to depend on jruby) https://github.com/wasnotrice/shoes-atom
I agree that it's weird. Although, technically it returns whatever it was fed or nil, which in practice is largely the same as true or false. I think that's probably how they feel it was ok to use a ? in the method name. But to me the whole awesomeness of ruby is the possibility to write code that nearly reads (in human english) what it does. If we wanted a write-only language, we'd just use perl =)
Yeah, my main beef is that it doesn't return true or false, always. I've adopted that for my own ? methods, but I agree that not everyone follows that. And I totally agree with you about readability. I tried to think how I would do this, without using nonzero? and maybe this is it: [year, month] &lt;=&gt; [other.year, other.month]
So, nobody has to believe this, but I just posted [this](http://www.reddit.com/r/ruby/comments/2cte7x/using_ruby_range_with_custom_classes/cjk3z45) and then read ALL the comments and saw yours.
That's a pretty elegant solution. (I think someone else suggested the same thing) I sometimes forget about the "spaceship" operator. I was thinking of something like year * 12 + month &lt;=&gt; other.year * 12 + other.month, but I like yours better - it's more ruby-ish.
Have a look at the list in http://www.codetriage.com/
any news about this?
update gem for zeromq
This is how I got started contributing to open source, and the Rails core. I was later hired for a paying job, in large part, because I had worked to improve the Rails docs.
all methods with a bang (at least for Enumerable) change the current instance and don't return anything (= nil).
But he's saying that it does return something if the instance is changed.
That's incorrect. Sometimes the do return something. For example Hash#merge! Still returns the resulting hash. Granted it does in fact modify the original object as well.
Actually it appears the behavior is not consistent [3] pry(main)&gt; x = (1..10).to_a =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [4] pry(main)&gt; x.sort! =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [5] pry(main)&gt; x.collect!{|i| i * 2 } =&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20] [6] pry(main)&gt; x.flatten! =&gt; nil [7] pry(main)&gt; x.reverse! =&gt; [20, 18, 16, 14, 12, 10, 8, 6, 4, 2] [11] pry(main)&gt; x.select!{|i| i % 2 == 0 } =&gt; nil [12] pry(main)&gt; x.slice! 2 =&gt; 16 [13] pry(main)&gt; x =&gt; [20, 18, 14, 12, 10, 8, 6, 4, 2] [15] pry(main)&gt; x.sort_by!{|i| i.to_i } =&gt; [2, 4, 6, 8, 10, 12, 14, 18, 20] [18] pry(main)&gt; [].reverse! =&gt; [] [19] pry(main)&gt; [ [1] ].flatten! =&gt; [1] Some bangs must return a result (slice!), but others return results with or without changes (sort!, sort_by!) and finally some return nil with no changes (flatten!, select!).
I know, which is why I said that code is silly. The point of this question is not about efficiency of execution. My current position is that compact! should not be used for flow control, but since it returns nil it can't be chained reliability.
I honestly don't use compact! very much, but I agree that you won't want to chain with it. And I think your first example was probably close to what was intended, given the mention in the Ruby docs that "an informative return value" is the result of evaluation. If viewed as a truth value, the return indicates whether the array was compacted. I don't know that that truth value has ever been useful to me, but then again, I use compact far more than I ever use compact!.
Gosu is what you want: http://www.libgosu.org/
It's a Rackup file.
I was just burned by this the other day at my job. I think it's freakin' stupid. First of all, why on earth would you intentionally design a function that has more than one return type? I think that's just poor design that begs for bugs.
Ah, thanks!
Think of nil as the lack of presence of the return type, not another return type. 
&gt; While the Roda code is slightly more lines, it should be apparent that it is actually much simpler. Instead of setting the @artist, @album, and/or @track variables in every route that uses them, the variables are set as soon as that branch of the tree is taken, and can be used in all routes under that branch. This is why Roda is called a routing tree web framework. In all but the smallest applications, this usually results in much DRYer and easier to maintain code. maybe. but now I have to remember where I am in the tree and what states were set before. in order to have a full understanding of a single location, I may have to view multiple routes up the tree. personally, I prefer to look at a single block of code and be able to understand it without backtracking. I would implement DRY using descriptively named classes and functions with obvious interfaces. I've also caused myself problems by trying to be clever and not repeat code, only to later need minor modifications for a specific edge case. using clever metaprogramming hacks, handling a tiny diversion can be extremely ugly and difficult.
The ! is only there to indicate to you that the object is being mutated directly and not returning a new object with the result of the method call. They aren't the same method and shouldn't be interpreted as being the same method, and as such, there should be no assumption that they return the same type of return value.
err he has a "why?" on the site.
Yes, but it just simply states, "less pollution" and "a plugin system modeled after Sequel". This isn't all that useful, in my opinion, if there aren't many plugins available, and that's the problem with people launching frameworks, traction. If it doesn't have what I need to develop, I can't be productive.
I think it is you you can do something like this: if my array.compact! # do something else # do something else end
 end end end end end end end *sniff* *sniff* Also the Sinatra example is somewhat deliberately verbose since a lot of the duplicated code can be dry'd up edit: I had a quick play and a dry sinatra version can be done in about 20 lines...heck 10 lines if you like to format things compactly.
`__method__` returns `:eigen` when inside the `eigen` method, and I didn't want it to read `eigen(__method__)` since I wanted it to look like the `super` keyword.
ExpressJS 4 in node and Angular and Ember in the browser all use nested routes like this and it is a significant step forward. 
Would be nice if he provided some benchmarks if you are claiming "fast"
Is this sarcasm or a php joke? 
wat why
Imagine the diversity we could annihilate if we put our minds to it.
If you don't like too much end, you could use "{...}" instead of "do...end".
I really love this idea, I've been following Cuba for a long time, now we have a better choice. Sinatra's routing system was great but has a performance issue, as it will have to match one by one, but a tree is better at searching.
You don't really need to have 3rd party plugins. The plugin-based architecture permeates the design. Take Rails, in contrast, where there's effectively no public API. Almost anything that purports to be a Rails plugin is a hack that hooks into internals that aren't meant to be exposed. This will rear its ugly head whenever Rails decides to change that (often in a minor release, sometimes it a patch). It also means you end up in situations where things work one way on JRuby and another way on MRI, for instance. Jeremy is adopting the same model here he uses for Sequel, where much of the core functionality is provided by means of plugins. Want to remove a behavior? Unregister the plugin. Want to override a behavior? Override that plugin. Want to hook into some place for your app? Write a local plugin. Sure, some stuff would be generally useful for all. But having used this model with Sequel, I can attest to it being much easier to maintain than a set of monkey patches.
I want to convert all HAML to HTML and leave it there.
Sounds like WordPress
I think it's funny that one of the main reasons given for this framework is that it's more DRY. Yet another ruby web framework is the definition of repeating yourself. Look I know rails is old now. It's also bloated, slow and uses massive amount of memory. As a result of this a hundred "micro" frameworks have popped up all of whom are completely inadequate for anything larger than one file apps. Why doesn't the community start trimming rails? If that's not possible why not write a full fledged framework which is faster and uses less memory?
I don't know if that's supposed to be pejorative or not. But the way Sequel does it, at least, is a breath of fresh air over what ActiveRecord does. Clearly defined public APIs, easy to override or configure and extremely easy to test plugins, and since there's very little metaprogramming going on, it's incredibly fast (by Ruby standards).
Horrible abuse? how so? 
Saying it doesn't make it so, unfortunately. Please elaborate.
Its poor style to wrap multiple lines in braces *especially* with deep nesting. 
The sinatra example could be condensed to something along the lines of : require 'sinatra/base' class MyApp &lt; Sinatra::Base ['/', '/artist/:id', '/artist/:id/album/:number', '/artist/:id/album/:number/track/:track_num'].each do | path | before path { @domain = DomainModel.get params } after path { @domain.update(params) if request.post? } get path { erb @domain.view } post path { redirect(request.path_info) } end end So personally...no, I don't *prefer* that syntax - its far more *"Railsesque"*, however, I do often find that is what I end up with given that there never seems to be enough time to refactor one project before I'm onto the next :/
Matz starts his presentation at 10 minutes in. &gt; Last presentation Last? Do you mean latest? His English has really improved. It wasn't exactly horrible before, but it's much better now.
Sure. I think the idea itself comes from modern client-side apps with sophisticated routers such as in angular or ember. In those environments, it doesn't make sense to invoke a route until it's dependencies are loaded, otherwise some parts of the app's UI update immediately, such as the nav and the URL, but the content itself renders later, once the resources are loaded. So to avoid this disjointed behaviour, Embers router and the ui-router from the angular project both decided to move resource resolution out of the controller and into the router itself. So far so good? This isn't really much different from the way my team wrote our rails apps, we typically used shared before_action filters in our controllers to load the relevant resources. Same thing, pretty much. Express 4.0 came out recently with a massively sophisticated router that kind of puts rails' router to shame. You can bind shared middleware functions - such as loading resources and injecting them into your controllers, transforming the request/response pipeline, etc., anything you would want to do in your before_action filters really, but in a much more declarative, composable fashion that encourages code reuse and skinnies up your controllers. I've done dozens of rails projects, and still do, but its design feels 10 years old because it is. If rails were written today, I'm sure they would make the router less of a crippled DSL and more of an API (something Tenderlove has been pushing for quite hard on the core maintainers list in recent years), enabling some of the beauty we're seeing in modern web development tooling. TL;DR The Rails router needs a complete rewrite
Wow amazing response. What resources do you recommend an intermediate Rails dev like myself trying to get into JavaScript frameworks? We're using Sails.js at my new shop and I'm finding it difficult to learn the JavaScript way of doing web dev. Not as intuitive as Ruby tools, I guess.
Yup, I guess that was a bit ambiguous, it should be latest.
Any remote API's url components are modelled as chained ruby method calls for a single object instance of a custom class. Query string is built from method hash arguments, and post data is modelled using a method block's return result. You could have a performance argument, but compared to a remote call over http the method chaining overhead is negligible. It seems to be a beautiful use of chaining, params and blocks, but I'd really like to hear why it might be an abuse in this implementation.
Sails is a lot to learn, you sort of have to learn their way of doing things which isn't always intuitive. Plus, sails is doing "realtime everything" over sockets which makes everything that much more complicated. It's a good project with a bright future but I don't recommend it for teams or learners. I would get into raw nodejs, which is really quite basic at its core. Use express directly to do web server stuff and REST APIs, it is what Sails is based on internally. On the client side I would recommend learning Angular. It is crazy popular and the "hello world" is stupid easy. It does get more complicated as you start building full apps, but not too much and it will change the way you think about architecture. Ember is amazing too but, like Rails and Sails, is a "do everything" framework that starts you off with a very steep learning curve. I'm just learning this stuff myself, but have done one or two production apps and it's really pushing things forward. Also, ember and angular both work quite well with rails on the backend, so you don't need to abandon everything you know. Good luck!
class instance variables are just instance variables (but the `self` is a class), not sure why it needs any separate discussion..
I highly recommend not using ruby. I understand if it's a tool you're used to or want to learn, but you really need to use the best tool for the job and that is a .net language. Don't try and make a language bend in a direction it's not meant to go. This project would be effortless in any .net language.
It's a general purpose programming language, so it's pretty good at making whatever you want to make with it. https://www.ruby-toolbox.com/categories/by_name may help though.
It's my understanding that peoples' main criticism of Ruby when it comes to making games (other than being an interpreted language and thus less suitable to highly graphical stuff that might be better served by C++ and co.) is its not-that-efficient garbage collection. Which is probably fair enough. When I'm not using Ruby for Rails, I'm usually using it to write scripts and stuff for general use on my machine. I find it much nicer to write than python, and its syntax for file handling and such is really nice. I wouldn't advise this in general, as python is installed by default on a lot more systems, but for personal use, I like using ruby as a replacement to bash/python scripting.
Ruby is strong in the sysadmin space as well. Chef, for example.
I think interfacing with C libraries is easy. And the gtk2 bindings were (are?) good.
And Puppet!
because the behavior around scope, persistence, and accessibility is unintuitive for beginners and this was specifically a beginner's guide?
Would python work for my purpose?
The spreadsheet and mechanize gems should be able to handle it. If the website requires javascript, capybara can drive a browser using selenium.
Not really. As soon as you grok classes are objects, everything else follows. They really are just instance variables for the class object, and instance variables were adequately discussed.
You talk a tremendous amount of [nonsense](http://www.reddit.com/r/ruby/comments/2cd5pj/meditations_on_a_class_method/cjers05) about Ruby so i'm not particularly fussed whether we agree.
[okay](http://i.imgur.com/seh6p.gif)
FWIW, I use it for mechanical design. I find that ruby's DSL-ability makes it easy to add support for all kinds of crazy ideas...like working with atoms instead of bytes.
[Xiki](https://www.kickstarter.com/projects/xiki/xiki-the-command-revolution) is [written in ruby.](https://github.com/trogdoro/xiki). Also [homebrew](https://github.com/Homebrew/homebrew). These are just a few projects that I'm personally interested in. I'm sure there's a lot more. Personally, I'd love to see ruby mature more into the scientific computing field and overthrow python. [SciRuby](https://github.com/sciruby/sciruby) is trying its best. And yes, ruby is bad for games, but so is any dynamic language
Vagrant!
bit watir inherently uses IE on windows. it's a tool specifically meant to support IE based web testing on windows using Ruby. now if OP needed to use other browsers, if suggest using watir-webdriver on Linux or Mac. 
What about to say this. Puppet was my introduction into Ruby and now I've converted a lot of my sys admin scripts/programs from Python to Ruby. Ruby is so much more fun to write in! 
Lua is dynamic and is what most AAA games use for scripting. I don't mean making a Ruby game from the bottom up. I mean using it to script on top of a C/C++ engine.
Lua is sort of intended to interface with C/C++ engines, and can directly manipulate the variables of a C++ code object. I'm not sure if Ruby could do this. Any time you want high performance, Ruby is probably not going to be your friend. Ruby's object system has a lot of overhead for even simple objects. That said it's probably my favorite engine. I've used it for bashing out quick games in competitions.
I see. I'll probably learn Lua then but Ruby seems to be nice for some things. Maybe I'll try it out one of my Pi like someone suggested.
I find Ruby for Sys Admin scripts are a lot easier to read and faster to write than Python. Plus Ruby's builtin libraries offer more classes and methods aimed at sys admin use than Python.
That said, binding Ruby to C++ isn't all that hard, so it's not like you can't use it as an engine. However if you're just starting out, Lua is designed for the task. A language is not just a language, it's also the tooling and documentation around it. As much as I love Ruby, Lua is inside the problem space you want, and so are the resources that will help you.
I've been writing a game using Java libraries and JRuby for a while now. JRuby even acts as the build system essentially. And I've read that if it was absolutely necessary, intensive parts of the code can be shipped out to be called directly in C.
yep, i can definitely use csv instead! thanks for the information
whoa whoa whoa whoa! who said i'm a decent programmer?!?!
Object has something like 40-50 instance methods. Do you remember them all? Does everyone in your team remember them all? Even if the code works now, adding a library might break it if it extends Object (which, unfortunately, too many Ruby libraries do). No need to add potential minefields to your API. foo.bar.baz.barf isn't any more readable than '/foo/bar/baz/barf', and it isn't as obvious to a newcomer that it is supposed to represent a path. Anyhow, the query parameters as a hash and post parameters as a block seems like a decent idea, although it might make extending it to support streaming or async responses a bit harder. Also, if I were to use it, I'd want to configure logging and proxy settings for each instance, not just globally. 
Yes, use JRuby, Rubinius, or Ruby 2+
Ruby is amazing for writing DSLs. If you need to write a DSL, use Ruby. 
RubyMotion for iOS is da bomb!
A better question would be "what are the things ruby sucks at?"
What tut did you learn from ?
0.o xiki is ruby ? SciPy &gt; SciRuby for most things machine learning.
Metasploit is Ruby.
Ruby is good for anything that isn't very computationally expensive. If your program does excessive number crunching, large data structures, simulations, etc then Ruby may not be a good choice. It's just not very fast. Unfortunately, games are all those things so writing a game in Ruby is not recommended. However, writing a game in a faster language like C++ and _scripting_ the game in Ruby would be possible. Though even then there are much better choices (Lua is easier to embed and faster, for example) so Ruby is kind of the odd man out in the gamedev world.
No single tutorial but rather I'd have a script in BASH or Python and then I would write it Ruby. To learn Ruby I would use The Book of Ruby and the Ruby Cookbook. So other than that, lots of Googleing, trail and error, and rewriting parts to work better. 
Ruby's C API is simple enough that it lends itself to offloading computationally complex tasks to C while keeping most logic in Ruby. Swap in Java for C and you've got a rising usage case in formerly Java-only shops.
It would likely have to be the other way around to be practical, embedding Ruby in a C program and calling Ruby from C. Honestly I don't know how hard that is, but I doubt it's as easy as Lua :P
I've heard that Lua is trivial to integrate to offer scripting to C programs. Having watched the development of Hydra, an OSX window manager written in Obj-C with a Lua scripting layer, I believe it. However, if most of the app was written in Ruby, then it would make sense to offload the work that Ruby different handle well to the underlying implementation language.
Codecademy is good for a shallow overview. 
FileUtils basically makes it so you never have to touch bash or even basic unix commands. Renaming a gazillion files with a regexp is trivially easy using a combination of Dir and FileUtils. AFAIK the closest python alternative is nowhere near as tidy
I've been focusing more on ruby lately than python due to its use in Puppet as well. Really easy to write scripts with, that are much more readable (and modular) than bash scripting.
Ruby's great for *anything*, and if you find you 'it lacks performance' in your specific case look for library bindings, or take that functionality out and rewrite it in something more appropriate. There is no single ring... erm language to rule'em all.
Checking against collision of method names for Object and any other ancestor's methods is something you must do during development time for each new method you add. Instead of remembering, you may use **Object**.new.methods to see the method list in irb for example. In the Esnek library, prefixing method names with double underscores (_ _) is a way to escape if the url part you're using is already an Object method (use *__freeze* to call *freeze*). Ensuring against collisions with libraries is something you may do using testing. And note that, because all objects in Ruby are finally descendants of Object, you must ensure name collisions for all the new methods you're adding and not only for this case. If you prefer '/foo/bar/baz/barf' style, rest-client gem which esnek relies on uses it, as well as some other gems. Esnek is more ruby-esque version to call remote APIs. For Proxy and logging configurations, you're right indeed, I'll check again rest-client, if it offers this. 
Ruby is good for almost everything, since it is usable in the same way as Python and was made to replace it.
Besides the C API, ruby-ffi is great for this.
Python? I always thought that Perl was Ruby's *spiritual liege*? Been trying to find the time to learn Ruby for projects for precisely this reason.
That's really good to hear! Ruby is probably my favourite language at the moment, so it's good to hear about it being used successfully in games development. What sort of game is it?
I tend to write simple one-liners to grab data in ruby like this: curl http://www.nactem.ac.uk/software/acromine/dictionary.py\?sf\=BMI | ruby -e 'require("json"); JSON.parse($stdin.read).first["lfs"].each{|row| puts row["lf"]}' 
Isn't the `shutil` Python module pretty much exactly what `FileUtils` is to Ruby, and also `glob` to `Dir`?
No worries, good luck with it :) And I'd have a look into whether you can use another browser and just fake the user agent or similar. I recently benchmarked Watir vs httpclient (I think - some gem along those lines, although can't access my server at the moment to check) and httpclient was something like 40x faster.
`mruby` is much easier to embed than plain Ruby, and is an interesting option for scripting. Ruby being a more complex language than Lua, it'll probably be difficult to match speed, but Ruby is IMHO better suited for creating an expressive DSL. It'll be interesting to see if anyone adopts `mruby` for this purpose. 
True. But we also pound into ourselves a disrespect for things done shoddily, or for preserving pristine perfection when the world has moved on to a very different way of doing things. Rails ticks both of those boxes; it's *painful* for anybody with a good, solid OO background to deal with, and it assumes the Web is still in that "magical" time between about 2005 and 2007. As I write this, we're more than halfway through 2014, some 6-7 iterations of Moore's Law later. Hell, when Rails was first extracted from Basecame, Moore's Law was still *relevant*.
What's php?
I use Ruby for most of my general scripts to automate system stuff I don't like repeating. There are libraries for mostly everything, and the language is so expressive and fun to write. I originally learned Ruby for Rails, but ended up using it mostly on it's own. 
Apologies if that came across as mean. HAML is just a pet-hate. Otherwise, great stuff adding this kind of tooling inside Vim. Inspired me to look into extending Vim - thanks.
I've done that manually and it works. The newest jekyll turns folders into categories, so you get year based category pages for free.
I'm often disappointed Ruby isn't more portable. What I mean is that generally speaking it isn't easy to take a Ruby script I write and easily give it to my mother for her to run on her Windows 7 computer. I wish there was an easier way to package and distribute ruby scripts as stand alone apps. It seems like the [shoes framework](https://github.com/shoes/shoes4) is making progress towards that, but it's got a long way to go.
Fun! Some of these are pretty straightforward when you break them down. For example, this one: 0.0.**0.0 seems a little bizarre -- how is the second period legal for a number? But it's being parsed as: &lt;number 0.0&gt; &lt;invoke method "**"&gt; &lt;argument &lt;number 0.0&gt;&gt; In other words, it's equivalent to: (0.0).raise_to_power 0.0
huah! absolutely nothing! whoops, sorry, no, that's war.
Javascript?
You don't say what the rubystone script does. The pystone repo does not really say what the pystone script does. What the fuck is going on here?
...which does not, by the way, equal 1. Just sayin.
Test engineering/automation! Ruby/cucumber is fantastic and easy to set up.
There is `ri`. `gem server` should lounge a server on localhost:8808 with the documentation for every installed gem.
[Yeah, no.](http://www.math.utah.edu/~pa/math/0to0.html)
That's not accurate; it can equal whatever we want, since it's undefined. Usually a result of "undefined" isn't very useful, because it can mean anything. However, if we adopt the convention of choosing 0^0 = 1, we get a lot of other benefits (like symmetry with all the other real numbers), so it's the most convenient choice.
Also, was it hand obfuscated? LoL
From the first body line of the README "This is the Ruby porting of the Python PYSTONE script. **It provides a rough benchmark of the Ruby interpreter via the rubystone executable.**" 
Think of another data structure, which isn't an array, you can use to transform your list of values. 
Assuming this is some kind of trick question, and that you must use an array but not uniq: Sort the array, then iterate through it while comparing the previous item with current item, if not the same, then add it to the output array.
Reason it out. You've got a list. How do you see what's in it? You iterate it. How do you tell if you've seen an element before? Remember them somewhere. What's one way to do that? Use a hash with the element names as keys. Each time you see an element, see if it's in the hash. If not, it's new. Set it in the hash with a value of "true" for the next iteration.
For future reference, `BasicObject` is the final ancestor of all Ruby values.
 Hash[array.zip].keys
No offence but it seems like the OP knows only 2 kinds of software: web apps and games. I'd ask right back: what is ruby not good for other than creating compiled binary code? Ruby is a general purpose modern interpreted language and can be used for anything that other languages in the same class: perl, python, php, etc. Personally I've written quite many network engineering solutions in ruby (config parsers, validators, nagios plugins, snmp scanners, snmp/syslog/netflow collectors, a graphing solution to replace cricket/rrdtool, etc) and I'm not even a programmer. So it must be an easy and usable language I guess. Formerly complex features like multithreading, database abstraction, timing etc are just one 'require' away. 
 a, = [1, 2] # dangling comma to get only the first array element So it's a game of "Spot the trailing comma!" when reading code? If I saw somebody do that in a code review they'd have their commit access revoked. (I'm aware the intro text calls all these useless, but this particular example almost looks like something somebody might be idiotic enough to think is a good idea.)
Help, I don't know whom to downvote!
If you really feel like you must assign a this way, at least use an underscore
No offence taken. Given the title and my that most of my replies have mostly been about games it would be fair assumption to think I only know about those. Just for some background on what I know, I've worked with software on Raspberry Pi, Arduino and other hardware similar to that. I'm currently working with MEAN stack and WebGL. Haskell is my favorite language to work in. I asked what is Ruby good for because: 1. I only hear about Rails but never anything else. I thought Ruby was only good for Rails. Just because a language is general purpose doesn't mean it used for everything. There are a lot of things in most languages you CAN do but that doesn't mean you should. 2. All I hear about is Ruby is slower than dirt and has poor garbage collection so I wanted to get an opinion from rubyist. 3. Game programming is what I'm doing right now. Instead of C++, which I absolutely detest, I'm using C an a scripting language. The most common is Lua but I wanted to explore my options.
You may have figured out way to do this by now but if not, perhaps this will help. * [data.csv](https://gist.github.com/jljohnstone/dcc215385a487ef8de4c) * [app.rb](https://gist.github.com/jljohnstone/7899bfd039b55b521d80) I haven't tested this on a Windows machine but I believe it will work. You'll have to comment/uncomment some lines as described in the app.rb file. See [this](http://watirwebdriver.com/internet-explorer/) for more details. Since the URL remains the same as you move throughout your internal website, it may be built with frames. If that's the case, you'll have to make some modifications. See [this](http://watirwebdriver.com/frames/) for dealing with frames. 
Turns out that [Array#&amp;](http://rubydoc.info/stdlib/core/Array#%26-instance_method) can be (ab)used for this: array = %w[foo foo bar bar baz baz] array &amp; array # =&gt; ["foo", "bar", "baz"] If you view source, they use a Hash to track which elements the arrays already share.
Most languages call it 'multiple assignment'. Python does it, too. Perl of course. And then there is Lua, PHP and others. It's used in C to initialize variables.
The structure that's returned is called a tuple and you pattern match on the tuple to get values out. [Here they are in python](https://docs.python.org/release/1.5.1p1/tut/tuples.html) [and here they are in haskell](https://en.wikibooks.org/wiki/Haskell/Lists_and_tuples#Tuples) they also exist in other languages. Almost all functional languages will have them.
may want to note you are talking ruby 2.1.1, as some examples fail in ruby 1.9.3, such as: [**{}]
You can't do multiple assignment in C.
 entree,main,dessert = order This is the magic, and I see it usually called destructuring. Common in functional and modern languages
still haven't figured it out, so i will have to check your suggestions out. i've been trying to use iMacros, but i'm not getting far.
Well, the interesting part has nothing to do with method return. The method is returning an array. One single "thing". Even in C, you can do this. The "magic" part is the multiple assignment (or "destructuring"). But this is **completely unrelated** to method return - you can do this with an array literal: entree, main, dessert = ['breadsticks', 'fettucine', 'ice cream'] So don't mix these two concepts up. What you're asking about is commonly called things like multiple assignment or destructuring (and probably something else in some languages that I'm less familiar with). Your example just happens to use an array returned from a method, but that's incidental to the feature.
Javascript is introducing this feature and calling it "destructuring assignment", which is a great name for it. Ruby borrows the idea from Perl.
Another alternative is [Array#reduce](http://rubydoc.info/stdlib/core/Enumerable#reduce-instance_method): names.reduce([]) { |mem, o| mem.include?(o) ? mem : mem.push(o) }
Lua does multiple return values without making an array object. function order() return 'breadsticks', 'fettucine', 'icecream' end entree, main, dessert = order() print(order()) Destructuring is very useful feature.
I think I get what you're saying, and I think it's probably bad practice to assign to a method like this since you have to know it's three things that are returned. I'm sure there's a name for it, but it's clearer to me if it's an n-to-n assignment. Return a struct or something if you want named values on the return, and call them from the variable rather than memorize how many values are returned from some random method.
Yeah, exactly. The trouble is, I can't figure out if this line of thinking is a holdover from OO principles that are going to get in the way of me adopting functional programming, or if it's a legitimate concern or not. When you spend a decade or more wrapping everything in an object, and getting your hand slapped when you didn't properly set up an object hierarchy, it's a bit of a tough curve to all of a sudden say "All that shit is bonkers. Do whatever the hell you want."
In Perl there's this wonderful "feature" that really should die-in-a-fire, called wantarray. Basically, you can set up the method to return a scalar or an array depending on how you call it. This leads to some real bite-me-in-the-ass methods that, for "convenience", do completely different things depending on how you call the sub. As a Perl developer, this is the biggest thing I hate about the language. 
That looks like a nightmare of coupled concerns and a labyrinth of figuring out what code is getting executed where and when. 
I'm not a super experienced rubyist, but this looks like a special case of [pattern matching](http://en.wikipedia.org/wiki/Pattern_matching) for lists. Haskell supports this for all data types. I'll detail the specific case for lists. In Haskell, lists are defined (roughly) as follows: data [a] = a : [a] | [] that is, an `[a]` is a value containing either an `a` and a list of `a`s, or the empty list (i.e. it's a linked list). You can pattern match on lists in functions like this: someListFunction (x : y : z : xs) = {- do something with x, y, z -} To directly translate your example, you could define: order = ["breadsticks","fettucine","ice cream"] printOrder (entree : main : dessert : _) = do print entree -- "breadsticks" print main -- "fettucine" print dessert -- "ice cream" The powerful thing about this is that you can pattern match on any (even user-defined) data types in functions. Take a binary search tree for example: data BST a = Tree (BST a) a (BST a) | Leaf a | Empty You can pattern match on BSTs like this: someTreeFunc Empty = {- do something -} someTreeFunc (Leaf x) = {- do something with x -} someTreeFunc (Tree left x right) = {- do something with left, x, or right -} ...and so on. For more information, check out [this chapter in Learn You a Haskell For Great Good!](http://learnyouahaskell.com/syntax-in-functions).
Wow I had no idea! 
yep, you're right. i wrote it.
Just turn the array into a set: set = array.to_set new_array = set.to_a
"on", "is" whaaat up with the method names? 
I suppose so. I guess python does all that but I dislike Python syntax. I tried Ruby out on Codecademy today and the syntax just makes sense lol.
Python and Ruby may be superficially similar, but they have very different approaches. Python favours simplicity and one-way-to-do-it philosophy, whereas for Ruby it's all about consistency and least-surprise philosophy. Also Ruby has a lot of ideas from Lisps, which is why it is so great for writing DSLs in.
I think Go is one of the only language that truly has multi-value returns: ``` func t() (string, string) { return "hello world", "hello mother" } func main() { world, mother := t() } ``` What you're doing is destructuring, which is supported in many languages. Perl: ``` sub t() { return ["hello world", "hello mother"]; } $world, $mother = t(); ``` PHP: ``` function t() { return ["hello world", "hello mother"]; // this syntax is valid as of 5.4 } list($world, $mother) = t(); ``` I could keep going of course, functional languages like Clojure focus a lot on structuring and destructuring data structures.
Woah.
&gt; The method is returning an array. One single "thing". Even in C, you can do this. No, you can't do that in C. Arrays are a little bit more complicated in C and you'll have to use a pointer to "return" an array (which is far from the real deal).
Is English your second language? You should have someone proofread and edit this blogpost.
My phrasing was poor. I wasn't trying to refer to arrays specifically when referencing C, merely the idea of returning some single "thing" that is a collection of values (such as a C struct) rather than just a single primitive value. 
Could you elaborate on the rails router being more DSL less API
Seriously. I don't see how having to follow the code tree up to the root to see what URL something is set on is easier than just looking at the start of the block where it says `get herp/derp`
try it in ruby irb, python, s and php.. and count.
Ah, ok. Now, that I read it again, that makes sense. Sorry.
This does not assign 0 to a, b, and c. It assigns 0 to c and leaves a and b with undefined values.
You can use Set instead of an array. Set automatically removes duplicate entries.
A better than what? Better than itself couple years ago? Well, maybe, but legacy burden isn't going anywhere, it's still growing. And after sad rubygems and bundler news, it seems that ruby's infrastructure needs a lot of love. After news on how exactly Matz is going to get rid of GIL, is's scary to think how many libraries will have to be rewritten, and how long it will take for them to become mature again. Ruby isn't becoming any simpler with years either. It's only simple when you're reading your first book or only coding web apps in Rails sandbox. Ruby's syntax is way more complicated than those of Java. Though it allows for nice DSL's, but at a cost of a swamp under the hood. One two ... And you're an all-mighty Ruby developer? Hell no. Go learn some rvm/rbenv, then pry, then learn how to use ri, and if you need to write something that is load capable, go learn eventmachine, DRb, Celluloid, Threads+Mutex et c. What next? Eigenclasses. JS's prototype model is much easier to understand. And Rails? Was there something new what became so widespread you cannot live without anymore in 4? Or even in 3 (assuming asset pipeline is an ugly workaround for bad http design)? Does Rails goes hand in hand with all those JS MV* frameworks that are becoming mainstream or it is turning into a JSON backend with almost no business logic? Roughly, bare postgres can do that too with nginx and something that is checking permissions on tables. If you need a better language, go get Julia, it's fast. Go learn OCaml, it's allmighty. Go learn strict Haskell. Check Scala. People from Rails core love Rust. Dig Erlang, and take a look at Elixir. Check Factor, it's pure fun and when programming it, you can finally understand how things work, all magic is on the table. JS, Python and Lua are getting better. Don't get stuck with Ruby.
In this context though, it's often something like this - except without the comments / documentation :-D # return results or sum of results return wantarray ? @arr : eval { join'*', grep/^\d+$/, @arr} ; ie, the difference is not something you'd expect - just something that shows you how clever the author was who could condense two sets of functionality into a single method call! ;-) 
Could you refactor that monologue? :)
Sure, in case you are planning to engrave it on a Rosetta stone.
I've never understood the attraction of 2-space indentation in common ruby style guides. I've seen it nowhere else except the ruby community. Does anyone know the history of this? And does anyone else agree that it is far less readable than 4 spaces?
CodeTriage is also a good resource.
Thanks. Will upgrade Jekyll and give it a try.
"Since we were hiring some new people we thought we should have a style guide. We just used one we found online. It was fine."
I don't know if RDiscount does, but kramdown does. http://kramdown.gettalong.org/syntax.html#abbreviations
Right, I confused C with some other syntax. C can't, that's why people write: int a, b, c; a = b = c = 0;
I've just found bugs or annoying stuff in gems I've depended on. Sometimes as easy as providing (or fixing) translations in a rails project, sometimes more involved like getting it to work on a different platform or OS than originally developed for. Knowing all the advanced concepts is nice, but far from a prerequisite in most cases. If in doubt check with the maintainer(s) of the code, or just fire off a merge request. They will tell you if you do something they don't like :) As for the last question: One does not exclude the other. Reading books gives you a good theoretical foundation, working with the code teaches you to make practical desicions and get the work done with what you got. Both are very valuable!
I'm actually a bit rusty on the details, and really am just aping some things Tenderlove has said, but in general the API exposed is very high-level and declarative, allowing you to add static route mappings and not much more. There should be a sophisticated public API over routes allowing you to traverse, modify, add and remove routes, and the high-level router interface we all know and use (sometimes referred to a DSL, but really it's just a bunch of ruby method calls) should be built on top of it.
First language I checked: [Indentation should follow the “2-space convention”. ](http://docs.scala-lang.org/style/indentation.html) Must be a hipster language thing
**Step 1:** Start using open source. **Step 2:** Everytime I ask a question, have everyone tell me "Look at the source code!" Then they link me to what I should have found myself. **Step 3:** Wish the code did X **Step 4:** Make the code do X, feel the Open Source high.
s/Ruby/Rails Also, HAML being prettier than ERB is subjective.
I started by fixing bugs in the gems I was using that were annoying me. I've also filled in a fair bit of missing documentation. Obviously more knowledge/experience will be helpful but you don't 'need' any particular level of expertise to get started. 
Rescue-Pry, Pry-rails, and Awesome Print made my life easier 
a, _ = [1, 2] Idiomatic way of expressing that you don't care about the other value.
I thought haml was cool till I used it. Then I thought about suicide. 
Me neither. Why not just use tabs? Then everyone can have them as wide or narrow as he wants. (I prefer them to be 4 spaces wide, for example.) The only reason (to my knowledge) against tabs is that when they're used for multiline-alignment-stuff. So it should be common sense to use tabs for indentation and then space for alignment. But nooooo, "2 spaces are the only correct way to indent code". 
Once I saw Haml report a syntax error on the correct line. It was a good day. 
Fibonacci without recursion? why?
agree, so weird not seeing pry in this list, this seems mainly a "rails" gems list, most of these gems would not help a programmer not using rails...
Why? I love it in the same way I love Jade. I also love CoffeeScript, so there is that too.
Are the number of return elements finite then? I suppose it should be fine, if you want to return an arbitrary number of elements you just return an actual list.
What is pattern matching, in this context? I'm only an intermediate but whenever I saw the term pattern matching I had assumed it was referring to regular expressions.
Pattern matching allows you to define variables based on the structure or content of the data you're working with. Say you're working with a piece of ruby code that will return one of these two classes: class Result attr_accessor :amount, :item, :user ... end class ErrorMessage attr_accessor :message, :status end Ignore for the moment that such a method isn't the best idea in Ruby. We're cooking up a new Ruby that makes it work. So, how would you work with this method? here's a code sample: result_or_error = some_process case result_or_error when Result result_or_error.user.notify_purchase result_or_error.user.credit_amount result_or_error.amount result_or_error.item.assign_to result_or_error.user when ErrorMessage report_error result_or_error.status, result_or_error.message end What I want to call attention to is the fact that the bulk of our code cares about *properties*, but it's all written in terms of the main object. In real Ruby code the Result class would probably provide some methods to help paper over this, but if it didn't we'd probably end up assigning some temporary variables very quickly. Pattern matching lets us do that assignment in a very succinct way. Let's make up a language extension: symbols in square brackets in the when portion of a case experssion are initialized as variables by calling that method on the matching object. That would let us rewrite the above code like this: result_or_error = some_process case result_or_error when Result [user item amount] user.notify_purchase user.credit_amount amount item.assign_to user when ErrorMessage [message status] report_error status, message end In languages that support pattern matching, this kind of return value usage is common. Mostly because they support a different language feature (algebraic data types) that make it easier to define things that way. With algebraic data types you might define a simple binary tree as: type Tree = Node Tree Tree | Leaf content Where the pipe truly does mean "or" and the definition is "a tree is either a Node (with two child Trees) or a Leaf with content of some other type". Often these languages allow you to define functions multiple times, once for each part of the type. With that you could write in-order printing as: def print_tree(Node left right): print_tree(left) print-tree(right) end def print_tree(Leaf content): puts content end Hopefully that helps. If you're interested in playing with something that supports this feature, Clojure, Erlang, and Haskell all have it. The language [Elixer](http://elixir-lang.org/) has a Ruby-like syntax and runs on top of Erlang, so it might be an ideal place to start. My last example was cribbed straight from Haskell introductory material, so if that partial function definition idea interests you it would be a good place to look.
Just be weary of recursive methods as you could run into a problem of a stack level being too deep.
&gt; terms in the Fibonacci sequence whose values do not exceed four million stack depth
Good point
&gt; Decent exposure is actually worse than just assigning instance variables Why? &gt; Rspec is a neat DSL that was way better before they deprecated #should How come? 
I like coffeescript pretty well, but I don't like HAML. I don't mind indentation-based syntax, but HAML's has enough warts to outweigh the convenience of not closing your own tags. Take slightly complicated HTML tags, for example. If you have a number of attributes you need to attach to an element, you can either let the line run on for 150 characters, or try to bend to HAML's very specific idea of how to continue a line. It's not pretty. I keep a very strict 80 character line limit. Some may argue that it's an outmoded rule, but it lets me keep a few windows open, or shrink my editor to share real estate. HAML makes it very difficult to follow this rule without subjecting your code to even uglier syntax rules.
agreed on RubyMotion. Objective-C was such a pain in the ass, and now RM is going to give us the same gift on Android :)
I actually think Rspec got *better* when they dumped `#should`. Should relied on monkey patching `Object` or `BasicObject` or some such, and was vulnerable to collisions if you actually need to name a method `should`. The `expect` syntax is a vast improvement. It doesn't rely on monkeypatching or otherwise modifying core Ruby objects to get the job done. Furthermore, it's easier to scan the tests and differentiate Rspec behavior from your code's behavior: describe 'my opinions' do @one = 1 it 'looks better when you' do expect(@one).to eq 1 end it 'instead of when you' do @one.should eq 1 end end 
Re. decent exposure. Last time I used it, decent exposure seems to expose your objects to *every* controller action that asks for them. So how do you know which controller actions/templates ultimately ask for which exposed variable? I prefer building view models, and ivars are just fine for exposing them. Decent exposure provides a better groove for exposing *more* variables, but I don't need to do that. Re. rspec. The main problem with test unit syntax is that `assert_equal` has an ordering ambiguity; does expected go first, or second? `#should` solved that problem in a fairly straightforward manner. `expect` bloats up the verbosity needlessly, imo. The pain of `#should` being monkeypatched onto `Object` is *extremely* exaggerated.
I think it's mostly a matter of taste, but I for one agree with you. The `expect` syntax makes your assertions much clearer.
This problem was designed so that recursion would not be a good way of solving the problem anyway.
I just came here to trash ActiveAdmin. It manages to munge all of your concerns into a single DSL which is miserable to extend if you're writing for anything other than pure CRUD. You'll save time writing the initial interface, yes, but it'll cost you twice as long ripping it out when you discover you were better off following the MVC pattern from the beginning.
The Fibonacci sequence is the perfect introduction to recursion, and I would strongly recommend trying to implement a recursive solution to Problem 2, just as a way to wrap your head around a simple instance of functions calling themselves; `fib(34)` is very unlikely to blow anybody's stack in 2014. That said, Ruby is awesome, and I'll present an arguably more elegant approach to the problem below. By its modern definition, `fib(0)` is 0 and `fib(1)` is 1. We can encode this information in an array: fib = [0, 1] Let's now fill that array up with the Fibonacci sequence until its last term exceeds 4 million: fib &lt;&lt; fib[-1] + fib[-2] until fib.last &gt; 4e6 Here, negative indexing is used to obtain the last two elements of the `fib` array, which are in turn summed and pushed onto the end of the array, and now we have a new term with which to continue the process. From here, we need to select all the even terms (or filter out all the odd ones): evens = fib.select(&amp;:even?) or evens = fib.filter(&amp;:odd?) The two are equivalent, but the semantics of one or the other might be clearer to some. Finally, let's sum them up and print: print evens.reduce(:+) Thus, with a sprinkling of idiomatic Ruby (to wit: the shovel operator (`&lt;&lt;`), negative array indexing, a post-conditional `until`, and the various functional offerings (`select`, `filter`)), my solution to Problem 2 was as follows: fib = [0, 1] fib &lt;&lt; fib[-1] + fib[-2] until fib.last &gt; 4e6 p fib.select(&amp;:even?).reduce(:+) &gt; I have to stick with nested loops... No, you really don't, and shouldn't. Ruby provides you with a plethora of convenient and elegant building blocks, and it's in your best interest to discover and utilize them as often as possible.
I use SLIM instead of HAML because personally I think it's cleaner.
&gt; The main problem with test unit syntax is that assert_equal has an ordering ambiguity; does expected go first, or second? Actually, it is pretty well-defined. It's *assert_equal(expected, actual, message)* - so you just need to follow the rule. Works pretty well in my company (we have A LOT of trouble with other coding standards, but none with this one).
derp 
I get such an uncanny valley feeling when reading rspec. It's just almost English, but not, and in a nauseating way.
That Python reference is very old. It is [now](http://legacy.python.org/dev/peps/pep-3132/) called iterable unpacking and can unpack any iterable for example here is a Python 3.4 example showing unpacking from a generator expression (*and* embedded list): &gt;&gt;&gt; y = (i for i in [1, 2, [3, 4]]) &gt;&gt;&gt; y &lt;generator object &lt;genexpr&gt; at 0x02EF5968&gt; &gt;&gt;&gt; a, b, (c, d) = y &gt;&gt;&gt; a, b, c, d (1, 2, 3, 4) &gt;&gt;&gt; 
SLIM is cleaner, and much much faster. I don't see why you'd use HAML. Personally I prefer ERB.
You can, but if you're not doing Rails these gems go from useful, to niche.
Yeah, I hear you. I use test unit syntax for all my projects. But, for whatever reason, a lot of rubyists have a real problem wrapping their heads around the expected/actual positioning.
I love HAML to death, but ActiveAdmin is awful. I'd rather eat a 10 year old php app that tangle with active admin.
+1 for Slim. Don't know why people would use ERB. Too much noise. Reminds me of PHP/HTML spaghetti. 
Sinatra code looks much easier and clean
Ruby does have uses other than building web apps. 
I would just browse github for Ruby bugs. Sometimes I would search for gems that used a library I had experience with. Sometimes the fix was explained in a comment on the issue, just no one bothered to implement it. 
I don't particularly care for the `expect` syntax. Monkeypatching `Object` is kind of icky in theory, but that's not enough of a reason to shy away from it for me; I've never had issues with method collisions or anything like that. `eq` in particular is kind of goofy, I much prefer hello.should == 'world' vs expect(hello).to eq 'world' Maybe that's just me not being wild about DSLs in general.
Can someone give a good reason to use decent exposure instead of instance vars? It seemed like a cool idea when I first heard about it, but after having to use it for my work it has been way more trouble than it's worth. And it does seem like it adds bloat because you're basically creating variables for every controller action even if you're only using them in one or two.
Surprised that Binding of Caller isn't mentioned along with Better Errors. They work in tandem to give pry-like functionality from within the error screen at the point of breakage. EXTREMELY helpful.
This is true. ActiveAdmin's selling point is trading the cost of a small initial investment in an actual MVC interface for the immediate ability to provide an interface for people to manipulate data, and as you observed there are very few situations where that saving's is worth it. Kaminari, Formtastic, and Ransack, all of which ActiveAdmin uses, do 90% of the lifting working anyways and if users want similar conveniences they should just roll those into their stack.
Never would have thought of using an array like this, very nice.
It's a modern open world community survival game. Feel free to take a look at the prototype on github. It's called [Last Ditch](https://github.com/kabbotta/Last-Ditch). Still in a rather early stage, but you can see how it is all setup with Ruby and Java.
I'm not 100% sure what you're trying to accomplish, but you keep calling `map`/`flat_map` without actually assigning the output of the map operation. So it seems like you're iterating over a collection with map, returning `Route.new` (implicitly because it's the last line of the block), but then not assigning the new collection that is generated by `map`. Maybe you want to modify line 52 to be `routes = routes.flat_map do |route|` ? 
Touche. Silly me. Must have thought I was on r/rails.
It is not changing your routes array. It is changing attribute `tracks` of the two `Route` objects that you have in your array. And that is being done because the `Route#initialize` presumably does not clone its argument, and shares the array with the old array. Specifically: route = Route.new(tracks: [track]) creates a new `Route`, presumably assigns the attribute `tracks` an array of value `[#&lt;Track:0x00000002461278&gt;]`. Route.new(tracks: route.tracks).add_route(new_route: track) will create a new `Route`. It will get the reference to the array above, containing one element, and add another element to it. Now you have two `Route` objects, that *both have a reference to the same array object* in their `tracks` attribute. You append an element to one `Route`'s tracks, it will show up on the other `Route` since it's the exactly same array. You print the array of original objects, but the array didn't change; the objects didn't change; but since you're using the same `tracks` array in some other object, the `tracks` array *does* change. To pull a non-programming analogy: it's like giving a cake to Barack Obama, then wondering why President of US is eating it. It's the same person (at the time of this post), with two different references. To prevent this, change the initializer. Presumably you have something like this: class Route def initialize(tracks: tracks) @tracks = tracks end end Or, if you're in old Ruby, class Route def initialize(opts) @tracks = opts[:tracks] end end Instead, do this: @tracks = tracks.clone or @tracks = opts[:tracks].clone 
This is exactly right. I ended up cloning tracks, but not in the Route initializer. The initializer is probable the better place as I just cloned tracks around line 56.
That's really cool. Are pull requests welcome? I'd love to have a tinker, but I don't want to step on any toes. Shame I'm at work, or I'd give it a proper play.
It sounds like you put the rvm initialisation code in .zprofile instead of .zshrc. If I'm correct, try moving it and firing up a non-login shell to test. 
active_link_to Kills me every time I see devs doing this shit by hand.
Actually Ruby is as fast as Lua, while using less memory and code: http://benchmarksgame.alioth.debian.org/u64/benchmark.php?test=all&amp;lang=lua&amp;lang2=yarv&amp;data=u64
Slim is very straightforward in what HTML it generates. Could you give an example of where it has thrown you off? Simple as: `li.class attribute="hello"` vs `&lt;li class="class" attribute="hello"&gt;&lt;/li&gt;`
I can't see any text on my android. Just some images and bullets
Reload. The theme I bought is using Google Fonts and it just shits the bed on mobile sometimes.
This is a very cool solution. :)
changed my text encoding from iso-8859 to utc8 and everything works.
Weird.
Interpolation of a variable into a message with a certain amount of whitespace surrounding it.
You mean like: `li.class hello, #{name}` ? Do you have an actual code example so I can understand what you mean? I do agree, though, at times it can be difficult to read. But I've found the productivity and general simplicity of the syntax to greatly offset any downsides.
This is brilliant!! Wish I could have been there again this year. Hope everyone is having fun!
Part 3: More tokens is already written and undergoing editing so I can publish it early next week. It will cover tokenizing floats (which are pretty complex in Ruby) as well as strings, identifiers, and constants. Part 4: Our first parser, I've just started drafting. There are some interesting problems to solve before we have a way of managing symbol tables. We'll probably implement a few methods naively for numbers. I haven't decided on the order for the rest but I know I'll have posts on the following: * Symbol tables * Hashes * Ruby's Object Model * Virtual Machines * Stacks and Frames * IO * GC * Threads At some point I'll likely introduce RubySpec just to see how our interpreter measures up. If there are any topics I might have missed that you'd be interested in, just let me know.
Terrific. Thanks!
Its live now. Event starts in just a few min!
I think it already started, but maybe for some reason the live stream isn't working correctly.
no just behind schedule. http://www.blog.equals6.com/wp-content/uploads/2013/08/mr_miyagi-sticks.jpg 
1. Is there any documentation? 2. How much of the reddit API is covered?
Thanks for the feedback, I know that good documentation is key to a good gem, but that escaped my mind while I was writing the gem. 1. That's what I'm working on right now. This was really meant to be a learning experience for me, so I completely forgot about the documentation. 2. I'd guess about 45%, but I need to set that up too. My objective is definitely to get as far as PRAW.
really enjoyed this, thanks.
Ironic I was just using kahn academy to learn a bit about music theory this week. It always blows my mind how much math underlies things we do/see/hear all of the time, and how well coding it can help you understand it. I wonder how ugly some dubstep in ruby could be?
1. Remove the github directory. I like the logo, but I don't think that needs to be included with the code. 2. Code looks great!
Sure, you can play around with it. It's still just a husk, but a large skeleton of the UI and basic mechanics are in place. I'm just about to start developing the battle system.
TL;DR: O(1) &lt; O(n) lookup
This might still be a little high level, but I found it to be very informative and a lot of fun: http://www.jstorimer.com/products/working-with-tcp-sockets If your interested in network coding it might be a great start.
&gt; It always blows my mind how much math underlies things we do/see/hear all of the time well that IS the originating purpose of math - a translation of physical things from life in a way we can relate them to each other. coincidence that we use a base 10 number system? I think not Or that theres 360 degrees in a circle? thats very close to the # of days it takes to orbit the sun... No, it's not surprising math is so evident in nature since it was created from *studying* nature
The only problem is, I can't really think of anything to build! And I don't just want to sit and wait for an idea to come to mind because then I will start forgetting about how to code in ruby. Are there any websites that offer practice for the fundamentals of ruby so I don't lose my knowledge? 
You seem open to feedback (based on your footer) so I hope this is well received. I think you tackled too big of a topic with this post. You're trying to introduce beginners to regular expressions and how they're used in Ruby. Regular expressions are a massive topic on their own with books detailing what they can do. It's a mini text parsing language that's made its way into the core of most languages. You could write an entire post explaining the basics of just regular expressions. Then you're also introducing Ruby's implementation of regular expressions and the various methods that use it. Again, you could write an entire post assuming people are familiar with regular expressions and just talking about them in Ruby. Alternatives would have been to do a multi-part post or directed the reader to another resource for regular expressions and simply explained their uses in Ruby. Anyway, I hope this was helpful. Best of luck.
Do something stupid. In reality, those things you think you can do that seem simple, you'll still struggle with them. Just go and find something you can understand and say, "I'm going to write this simple thing except stupid different." If that doesn't sound fun or seems to intimidating, go to the Google CodeJam and do some of those. Just throw things against the wall and find something that sticks. Just don't do it for the sake of doing something. Do it because you're having fun or you want to learn something. For me, just coding for the sake of coding is the fastest way to accomplish nothing.
Because many people still believe in 80 an 80 character width. With a few exceptions (Java), places like Google enforce this heavily. I like it because I don't have to resize the width of my terminals when they pop launch. Using tabs makes this nearly impossible.
You are on the right track, the goal should be to keep coding before you forget it. Don't try to build something that people need, just For some exercises check out Ruby Koans: http://rubykoans.com/ and Ruby Monk: https://rubymonk.com/ Here are some ideas I thought of that can help build your Ruby code muscles: * Port Scanner - Take an IP and check what ports are open. Bonus if you can then take a secondary argument of port and do a deep scan of that port. * Subnet Scanner - scan a subnet, do dns lookups, ping checks. * Build a text table display script - Build a class that can take the above scripts plain text and turn it into a ASCII table with spacing etc. * What websites do you like? Can you build a script to check their RSS feed or even the site itself, and then send you an alert on your phone, email, twitter, Facebook, Google Plus etc - great to get exposed to APIs etc. * Data analysis - Build a script to check your email sent times and average how many times you send an email, what is your most likely time to send an email? Least likely? etc Building the above will expose you to a wide variety of Ruby. 
Thanks for this, I updated the Article. Amazed at how long I have been using ^ and $ for.
&gt; I wanted to have a go because when I first started with regex, I just wanted some simple examples of what I could do. Re-reading it through that lens helps. I think that probably should have been your intro. Something like: "When I first started with regular expressions they seemed useful but I wasn't sure of what all I could accomplish with them. I wanted some simple examples to wet my feet with before diving into the deep end. I never found that but I can be your puddle to splash in. I'll explain where I use regular expressions the most and give some easy to follow examples." At this point I feel like I should say IANAL except with writer in place of lawyer. I like to blog and I'm trying to be a better writer but take everything I've said here with a grain or five of salt.
It lets you fit descriptive names (for variables/methods/etc) into an enforced maximum-length line *n* (where *n* is traditionally 80, though some wise guys insist on 79). An example taken from code I happen to have open at the moment: class UsersController &lt; ApplicationController # ... def create result = DSO::PermissiveUserCreator.run user_data: params[:user_data] @user = result.result authorize @user if result.valid? &amp;&amp; @user.save redirect_to root_url, flash: { success: 'Thank you for signing up!' } else render 'new' end end # ... end # class UsersController ``` (taking the begin- and end-class lines as not having leading spaces, ignoring Markdown-imposed leading spaces) Given that failing style checks (against [`bbatsov/ruby-style-guide`](https://github.com/bbatsov/ruby-style-guide/) as enforced by [RuboCop](https://github.com/bbatsov/rubocop) fail our CI, any indentation width larger than 2 would cause the above method to fail, forcing us to use less-descriptive names and/or excessive wrapping. **tl;dr** two-space indentation leads to easier-to-read formatting of more-descriptive code.
It all started with a belief that writing unit tests is a much more deterministic process than writing app code. And it still holds true. Do you think its possible to build writer in such a way so we don't have to write tests anymore? Running it would LOCK the class API in tests as it is. So all we would have to do is writing code, locking it, writing more code, locking it too and so on.
why so much activity from you millioncents? Are you working for ninefold? Some people will think that what are you doing is just spam :)
[I'm going to go with yes.](http://www.reddit.com/user/millioncents/submitted/)
It would be greatly appreciated here if he chose /r/rails OR /r/ruby for each post. If a post is rails only stick it in /r/rails, if it is ruby only /r/ruby - if it is both then /r/ruby (Since anyone subscribed to /r/rails is probably also on /r/ruby but not necessarily vice versa )
If this works it could be a great teaching aid for writing tests
this is cool thx
I feel kinda sorry for ninefold, they're clearly trying **so** hard to have a strong presence in the ruby community but i agree their approach feels way too contrived and spammy.
This could be useful for legacy classes that don't have much test coverage.
I recommend rewriting this part of the readme to be less sexist: &gt; I know that code analyzing is a sexy sphere to work on for many developers. So here it is - a sexy project where you can realize your wet dreams about magic in Ruby. Can this be made to generate test unit syntax? It seems like test unit syntax would be more straightforward; the rspec it generates doesn't really read well.
It was unprofessional of me to do that. When you are in that deep state mode of coding - nothing seems too strong. I already changed it to represent my emotion better Edit: I currently does not support test unit syntax, but I bet that implementing it would be pretty trivial as all RSpec logic is encapsulated in the RZpecWriter class.
I do find his code being really weird: class TrafficLight MSG = {:Red =&gt; "STOP", :Yellow =&gt; "WHOA", :Green =&gt; "GO"} def initialize state @state = MSG.values.rotate MSG.keys.index state end def state @state.first end def next @state.rotate! puts "The light has changed..." end end light = TrafficLight.new :Green
Yes, he's said in the past: &gt; Yes. I take care of the online marketing.
No, he's said that he handles their online marketing
Well shit, he needs to get his crap together.
EW. This is ugly. 1. 2 spaces over 4 in Ruby. It's the convention for the majority of ruby developers. 2. HTML.rb ? don't yell!! Also just a ruby convention, but lowercase and underscores for separating words for filenames. 3. Ruby has implicit returns. you don't have to write "return varhere" if that's the last statement of a block. 4. Was this copied from [java](https://github.com/InfraRuby/infraruby-shim/blob/master/ruby/Array.rb) ?
[I can confirm.](http://www.reddit.com/r/ruby/comments/2caf9y/yukihiro_matz_matsumoto_presenting_tonight_via/cjdpyya)
I love these types of Ruby creations! Very clever. I never knew about splatting a range. I once tried to golf a script to construct a deck of Unicode playing cards and draw a hand of 5 but couldn't manage to fit it into a tweet: r=(1..14).map{|x|x.to_s(16)};r.delete('c');("1f0a".."1f0d").to_a.product(r).map{|i,j|(i+j).hex}.sample(5).sort{|a,b|a%16&lt;=&gt;b%16}.map{|x|[x].pack('U')} The splat helped ... r=(1..14).map{|x|x.to_s(16)};r.delete('c');[*"1f0a".."1f0d"].product(r).map{|i,j|(i+j).hex}.sample(5).sort{|a,b|a%16&lt;=&gt;b%16}.map{|x|[x].pack('U')} ... but I'm still too long by 6 chars.
html/css/js are front-end skills you probably won't get in a back-end webdev course.
In the code I ran I set the appropriate store name. 
you know about golf ruby right?
Here is a great intermediate site with oodles of shortish code challenges: http://www.codewars.com/?language=ruby I found this to be a good followup to doing codeacademy. Not only is there a variety of challenges and difficutly, you get to see other peoples' solutions and the discussion of the most 'ruby' solution. A talk I saw the other day (at Cascadia Ruby) that was at the very least fun and definitely information of password management: * Slides: https://speakerdeck.com/tjschuck/80-000-plaintext-passwords-an-open-source-love-story-in-three-acts * Video: https://www.youtube.com/watch?v=GDuSAnMYXFU Are you interested in doing web development? Rails is a powerful framework, that can be a huge task to take on learning, but there are other alternatives that use Ruby, such as Sinatra. Siantra is lighterweight (ie less files to work with, less magic behind the scense). It can still be pretty confusing to learn at first if you are new to web dev, but definitely worth learning. It won't solve not knowing what to do with ruby, but you can look up some tutorials. Eventually you will come up with an idea (once you see what it can do). Have fun!
The event is now over but watch [Confreaks.com](http://confreaks.com) for the edited talks to be released soon.
Replace `sort{|a,b|a%16&lt;=&gt;b%16}` with `sort_by{|a|a%16}` 
Isn't this around the same time Matz did the [same presentation at Engine Yard](https://blog.engineyard.com/2014/fukuoka-ruby-loves-engine-yard-and-engine-yard-loves-fukuoka-ruby)? I imagine he spent time at Heroku that week too...
Is delayed job a prevelant choice for handling async? I have heard of so many other options and this is the first I have heard of delayed_job.
rbenv - because it just works
Ah! Yes, thanks! Of course I could have removed the sort but that would be madness ...
No I did not.
Here's mine in 94 characters: [*10..13].product([*1..14]-[12]).map{|s,r|126976+s*16+r}.sample(5).sort_by{|c|c%16}.pack('U*')
Yeah, I already know those. Looking to expand into backend. Just curious if anyone knows anything about this course or has taken a GA course.
rvm - because that's what I learned first and have been using it for a long time (and because it works).
Ah right. Misread :)
&gt; Ehh, that's speculative. 360 degrees is also one of the first numbers that's divisible by 2,3,5,6 with a ton of available subdivisions. True, not saying any of this is proven fact, just speculation as I have no first hand knowledge of these things or their origins. However classical greek philosophers with fairly accurate predictions estimated the circumference of the earth by measuring shadows from a well throughout a year using geometry, this would lead me to speculate the nature of angles involves the orbit of the earth around the sun. &gt;And humans didn't always or naturally use a base A counting system, some cultures have different bases. Also true, as I said it's all relative and so naturally different areas would be liable to draw different relationships.
chruby, because rvm stopped just working and rbenv is more complicated than it needs to be. I knocked together a [couple](https://github.com/regularfry/gemsh) more [scripts](https://github.com/regularfry/rv) on top of it to make project-local gemsets work.
 '034@CDPST`'.bytes gives me an enumerator and errors when used with :- ... is this a 2.0 thing? EDIT: Yes it's a 2.0 thing The way you golfed down the data set is pretty crazy, there. How did you do it?
Oh, I should have tested it in 1.9. With three extra characters it will work in 1.9 – 2.1: ([*37..98]-[*'034@CDPST`'.bytes]).map{|x|127100+x}.sample(5).sort_by{|a|a%16}.pack'U*' Building the data set wasn't too difficult. I first looked at the hex value of all 52 cards and noticed they all had the same prefix: [127137, 127138, 127139, 127140, ...] Removing the prefix `1271` leaves us with an array of numbers ranging from 37 to 98, with a few gaps, the first of which is 48. I took these missing numbers and converted them to characters (48 -&gt; '0', 51 -&gt; '3', etc.).
Just in case he goes back into the woodwork, I'd like to pay homage to Trevor's (optimally short?) solution to this task by explaining it. Looking at the [codepoints we need](http://en.wikipedia.org/wiki/Playing_cards_in_Unicode#Playing_cards_deck), we can see that they all start with `1f0`, so we can ignore that portion for now. The interesting [nibbles](http://en.wikipedia.org/wiki/Nibble) are the last two, and they range from `0xA1` (161) to `0xDE` (222). That's 62 elements, though, so there are obviously ten we don't need. We have to get rid of the four Knights (the ones ending in `C`), and then the two bytes between each suit grouping, which are `0x[A-C]F` and `0x[B-D]0`. A naive way to acquire the necessary bytes follows: [*0xA1..0xDE] - [0xAC, 0xBC, 0xCC, 0xDC, 0xAF, 0xBF, 0xCF, 0xB0, 0xC0, 0xD0] From here, we could just add 0x1F000 to each byte to acquire the requisite codepoints. Of course, this is far too verbose, so how can we trim it down a bit? Well, as /u/trevorlynnsmith demonstrated, we can pack the bytes to remove into a string and call its `#bytes` method. Alas, none of those bytes is a printable character, so our string would have to look like `"\xAC\XBC..."; we need to offset the relevant values such that we can store the deletion string more aesthetically. There are quite a few that would work, but Trevor's solution uses 124 as the offset. `[*0xA1..0xDE]` becomes `[*37..98]`, `0x1F000` (126976) becomes 127100, and‒most importantly‒the deletion bytes become readable ASCII.
I've yet to find a real reason to version the interpreter itself. I build ruby 2.1, install it globally and add it to the PATH.
rbenv - because it's not rvm
Maybe your quotes around prez1 are not the right kind of single quote, and they are being interpreted as part of a variable name instead of as a String literal? The reason I think this is that the failure is on line 8, not at the usage of the STORE constant. 
rvm, but frankly, only because I'm used to it (i.e. I'm too lazy to explore other options). The DevOps peeps on my team prefer rbenv &amp; thus we use it on our servers.
Food for thought: * What is a class method? * How do you call a class method? * What does `protected` mean in Ruby? The answer will reveal itself if you can answer thee these questions three.
Er, looking back, I am not sure why I put the [] in there, oops. Ye, the monkey-patching of String class was dangerous, in their defense it does seem to be the best, standard way to see if a string is numeric. I admit I would have done it differently as I have nightmares about being the cause of a chainsaw infanticide.
This is really cool! I made one that generates hex colors from a string, these should work great together! :D
You can remove gemset for a specific project along with all gems that you don't need anymore, or clean it without fear that this will affect other projects. Plus you have a global gemset where you can put pp, awesome_print, pry etc that you use for every project. (The latter is rvm specific).
Why not just use presenters? 
Write a [game](http://libgosu.org)
Methods should default to being private until they need to be used by a subclass where they can be made protected until they need to be used externally where they can be made public. Everything you expose is a promise that you have to keep "forever". Don't make promises you don't have to. 
This post gave me cancer.
Currently using chruby, but I've been thinking about rolling my own given some uniqueish requirements. I have a large infrastructure system written for 1.8.7, there's about 600 ruby scripts in a commands folder, and another 200 or so spread across the rest of the system. I'd like to rev it from 1.8.7 to 2.1. My thought is to handle it like rbenv but not just on a directory by directory basis but maybe even on a file by file basis. If you run myscript.rb it looks for .myscript.rb-version in the same directory and failing that falls back to a .ruby-version in the folder or recurse upwards. I'd set the .ruby-version to 2.1, and then auto-create .myscript.rb-version files and have a group of people work on validating/updating the scripts from 1.8.7 to 2.1, deleting the file when it passes new rspecs.
Pretty sure you could do this with one line of javascript in the browser console.
Good. Share it.
Thanks, that's a valid distinction.
Kinda confused by what you're saying here, you say on the one hand a view model is: `a domain model for your view domain/layer` And then you go onto say that the job of the presenter is to transform business objects into view domain objects. So what exactly is the relationship between the two? cos they sound eerily similar - a simple code sample showing what you mean and how the two might work together would also help.
Isn't this just pushing all the "ugly" into another abstraction? What happens when you begin to think that your ViewModels are ugly, and decide that this: class CommentCell &lt; Cell::ViewModel property :body property :author def show render end private def author_link link_to author.name, author end end could be shoved down into yet another abstraction, so that you have so much pretty: class CommentCell &lt; Cell::ViewModelModelModel def just_do_it_all fuck_yeah_render end end ?? 
I think /u/Zequez means a bookmarklet.
Nice work. I'd written a python script that runs in your command line and lets you type replies from your command line. You can move a couple of lines and reply with a standard "Thank you &lt;person-name&gt;" to all posts too. :) You can check it out here https://github.com/keithxm23/pyfb-bday-replier
Post a link!
Someone asked me about that earlier. This was a late night thing to handle my problem yesterday. I added it though :)
I forgot to add that the main differentiator is that a view model is self rendering. In your actual view (which should be called a template) you instantiate the cell and tell it to render itself given the current controller/template as context. This is in contrast to a presenter/exhibit/decorator which has no knowledge of the template or rendering process, but is responsible for making your models "presentable". For example, extending the example from above, your Employee application model might have a start date and an end date, but your employee presenter might not respond to start date and end date but rather a #dates_of_employment method which underneath grabs the employee's start and end date, formats them as a certain kind of string and then adds a hyphen between them. 
Just don't do that? Plenty of people live with certain levels of abstraction. When you understand what the job of each of these objects is in their respective domains/transformations between domains the delineation between responsibilities of objects becomes clear. 
not sure what's worse -- not having enough friends to make this worthwhile, or being so cold-hearted as to actually use it! 
So bookmarks with JS are called bookmarklets? TIL.
They are both equally terrible in their own right.
[**@rememberlenny**](https://twitter.com/rememberlenny): &gt;[2014-08-14 14:29:03 UTC](https://twitter.com/rememberlenny/status/499925674078269440) &gt;Every time I check [@railscasts](https://twitter.com/railscasts), I feel like a loyal dog waiting for its dead owner to return. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2dju8z%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Good suggestion. I'll reply if I get this sorted out. thanks for responding.
I think its up to the coder. If you think you abstraction needs to split, do it. If you think it alright, dont do it. It all depends on the context.
I use docker instead of rvm/rbenv and so on. I've build base image with needed ruby version and bundler inside, and then just creating new images with projects based on this base image. 
This is how I feel waiting for the next Jim Weirich talk.
Yes, that is correct.
Yep, it was yesterday. Thanks!
Commenting on this thread for later reference.
The lack of response is probably because this is outside of the Ruby/Rails domain. Do you need to capture from the webcam using a browser, or can it be via any capture tech? Via the browser I've no real experience but the big issue will be cross browser compatibility. You'll need to look at Flash I suspect. Outside of the browser, its possible to capture via ffmpeg or flash media encoder live and stream to any of a number of sites that offer flash media streaming services. It works, its relatively easy to set up and it can be done cheaply by running your own media server (e.g. wowza, red5) although you will probably need a license if you have a large audience. All that said, we're moving to HLS since the good flash providers tend to overcharge and the cheap ones have some real reliability and support problems ... and I don't want to add another layer of tech which we will need to learn and support. For HLS ffmpeg is the core and its relatively simple ... encode a stream into HLS and upload each chunk to a webserver as it becomes available. A very simple script generates the m3u8 file on the server side as each chunk is uploaded. However when it comes to playback on the client that's were the snag is. Currently I believe only flowplayer, osmfhls and jw player support HLS playback in the browser and all require purchase for commercial use (without some form of restriction), although I just found another (wecast.it/opensource) so there may be other options. Again, if there is any one big drawback to all this its getting cross browser/platform solutions.
Absolutely - what you call "ugly" is domain and presentation logic. Shoving that to a different layer doesn't make your code less "ugly" since it still solves the same problem. However, introducing a separate abstraction layer allows better encapsulation, reusability and makes it simpler to understand and test. It also feels better than helper/partial implementation.
You do have a legit point. I don't see any mention of generators or how each MVC component actually fits together. btw, I wouldn't mind writing a tool to speed up Lotus development... there seems to be a pretty consistent folder hierarchy and basic couple files for every app type. 
What if I want to use my own method name instead of #color? It'd be cool if you could say, status.darken(color_hex) status.darken(some_other_hex) Or something to that effect. Nice little gem otherwise!
I agree with this sentiment completely. Don't expose what you don't have to. It's easier to open things up than close them off. It's worth noting that you don't have to move methods from private to protected to use them in subclasses. Unlike some other languages, in Ruby `protected` indicates a method that can be called publicly by classes of the same type or subclass of that type.
You don't actually need to make the method protected in order for an inherited class to use it. Private methods can be used in that situation. In Ruby, `protected` indicates a method that can be called publicly by classes of the same type or subclass of that type.
That's fascinating, I actually never bothered to verify that. I assume private behaved like private in C#. 
Something which is nicely demonstrated in "Confident Ruby" when he talks about creating a "Metric" set of classes, highly recommended reading.
TIL thanks
He knows regex, it's okay
This would be an even cooler SASS plugin
Oh god that CSS
b-b-but what about `/[^_^]/`, the dancing regex that doesn't match underscores or carrots 
My buddy downloaded an album of FLAC files and needed to convert them to WAV. I seriously had *no* idea how to tell him how to do it without writing a little shell script. Ended up just going over his house and doing it in the command line.
Pretty sure sass already has this? Otherwise it comes with Bourbon :)
Nope, but you don't need this actually. Interpreter, gems AND your source code, everything is in image. And if you want to "run" something from image you just spinup new container (docker can create many containers from single image) `docker run -it --rm=true image_name command_inside_container` where command_inside_container is for example rubocop. `-it` will give you interactive shell `--rm=true` will remove used container after it exited
You talking about the code snippets? I normally use pretty print but was told that draft has support for GitHub style code snippets. Looked great on draft but trash on my blog. I'd love to simply use the GitHub style of syntax highlighting but I need to find those style sheets first. ---- If you are talking about the site in general, then whatever. I bought a theme simply because I am terrible at front end development/design :(
I don't mind helpers, to be honest, but in every project there are inevitably pieces of front end code different enough from your data model that you need separate objects to drive your views. This seems like a great approach in those cases.
Really enjoyed this post, thanks. Good little introduction to performance fixes and I hadn't heard of Stackprof before.
I'm pretty new to Ruby, but that 6th slide blew my mind.
Whare are the downsides of going through bundler? I use binstubs for everything these days, and I even prefer to give projects a `.bundle/config` file that tells bundler to use a project local directory to store the gems. This keeps my set of system gems really small, just like gemsets, but without really any tooling beyond bundler required. I think using `bundle exec my_gem_binary` is a real time sink, but in my experience `bin/my_gem_binary` is pretty fast.
I personally think code should be `monospaced`, and not orange. But that's just my opinion Also [this](http://puu.sh/aTHGy/bfca977e4d.png)
I just took that class there. It was a great fit for me because I was a beginner (mostly front end person) and was willing to put in hours between classes to really learn each topic. The class moves very fast, but you might be a bit bored in the first week if you are already intimately familiar with OOP. I have started 2 side projects since that course and one is already looking like it might bring in some cash. So in my case at least, having an experienced industry person guide me through the material was well worth the investment. My teacher had a lot of opinions about how certain things should be done, which I found accelerated my growth because I could absorb more and then go back and develop my own take on best practices. The TAs in my class were pretty great too with lots of office hours. I have some criticisms about some finer points of the curriculum, and how much faster things moved when the class switches to rails, but I can't really complain about my results. PM if you want more info.
Yeah, this was trying something new with my copywriting tool [Draft](http://draftin.com). [Normally my stuff looks like this](http://dl.dropbox.com/u/113966/Screenshots/u_iiyi_4baae.png) &gt; Also this [Inspect stylized github code, that's what was generated.](http://dl.dropbox.com/u/113966/Screenshots/yey6kgvh22ba.png) I"ve been meaning to go in and fix up my version to use pretty-print again. *Update* Grabbed a stylesheet from [here](https://github.com/richleland/pygments-css) and made some simple adjustments. Highly suggested for anyone looking to get rid of something like pretty-print for their syntax highlighting.
cached article: http://webcache.googleusercontent.com/search?q=cache:fH4NnW9bIUsJ:https://blog.jcoglan.com/2013/05/06/websocket-driver-an-io-agnostic-websocket-module-or-why-most-protocol-libraries-arent/+&amp;cd=4&amp;hl=en&amp;ct=clnk&amp;gl=us
Functional link: https://blog.jcoglan.com/2013/05/06/
It is very fine now, the spans make sense when you're highlighting code. Otherwise, they just look silly
I've been meaning to move away from the JS library I was using for highlighting.
I liked it so much, I started using it in Perl. It's great when you wrap at 79 lines. 
In addition to terminals, if you use a column-able text editor (I use Sublime Text), you can easily fit two scripts side-by-side without scrolling sideways. Same with a diff tool. 
The code is basically saying "give me the first X number of characters of the string. It works by taking your string, and calling the [] method on it with a range. Check out: http://www.ruby-doc.org/core-2.1.2/String.html#method-i-5B-5D `start_of_word`'s first parameter is the string. The second parameter is the size of the string to be returned. aka "How much of the start of the word you want returned" `string[]` is calling the `[]` method on your string. As you can see from the link to docs i provided, the `[]` method can accept a range. By passing `0..length-1` (the `..` makes this a range) to the `[]` method, you're basically saying: "give me back the range of characters that start at 0 and end at length-1". 
It doesn't make any sense because it doesn't have any effect. If you want a class method that can't be called from outside class, you need to use private_class_method.
I appreciate your reply. However, you seem to have answered everything but the question I was actually asking. I understand what the method is doing and how, with one exception. I'll try to rephrase the question for more clarity. The method takes in a string literal as it's first parameter. Does string[] then convert that string literal into an array? Can you point me to documentation about that particular part? Thanks.
As mariozig said, check this out: http://www.ruby-doc.org/core-2.1.2/String.html#method-i-5B-5D
It's not converting the string literal into an array. You can define a method :[] on any object and it will respond to [] notation. 
It's not a conversion. The square brackets are "syntactic sugar" for a method. Take an array a = [a,b,c]. You can access a subarray [b,c] like this: a[1..2] or like this a.[](1..2) the latter is a simple method call, calling an array method called "[]", in this case with a range as a parameter. Writing a[1..2] is the exact same thing. String implements the "[]" method with its syntactic sugar with the parameter inside the brackets, too. 
I think I follow that. Put another way, the string is able to be indexed like an array by using the [] method? I'm just starting to learn this stuff so forgive me if I seem dense or don't use the right lingo.
Haha, I'm not sure what happened there. Thanks!
I'm rather certain this function is unnecessary
I think they're blocking reddit as a referer.
RMagick is a clusterfuck - why not just wrap a different/smaller C/C++ imaging library instead? there's a tonne out there, and most of them are 50x easier to install than the hog RMagick
We are hoping to improve the installation procedure. Part of the issue is that the library has been unmaintained for so long. &gt; why not just wrap a different/smaller C/C++ imaging library instead? Yes, you are right, there are different libraries out there. This fork is about bringing RMagick up to speed because it is used in a lot of projects. If you are looking for alternatives, I've had excellent experience with VIPS and the associated Ruby bindings - however it is a lot lower level than RMagick. ImageMagick is also very mature and is supported on many platforms.
The thing to realize is in ruby, [] is a method, just like anything else. In a language like C, the bracket syntax is an operator that only works on arrays. But in ruby, you can define the bracket method on any class you want, and have it do whatever you like. The String class has it defined to return a substring. So there's no conversion to array necessary. class Foo def [](index) puts "OMG, I'm indexing some random class!" end end 
It looks to me like we are running out of good ideas for website styles
Instead of doing a counter for your HTML output, use each_slice to create a nested look, grouping your elements. elements.each_slice(4) do | batch | Div start batch.each do | element | end Div end end FML on mobile Check out https://www.google.com/url?sa=t&amp;source=web&amp;rct=j&amp;ei=FXvvU-zAAY6LyASR3oDoAw&amp;url=http://stackoverflow.com/questions/1988274/ruby-working-on-array-elements-in-groups-of-four&amp;cd=1&amp;ved=0CBwQFjAA&amp;usg=AFQjCNE77bjSYJVLg6Z26YSTr8bwabztMw&amp;sig2=xO_-D9WNF9GRDg__Je0Bsg
I think maybe [this method](https://github.com/mikedugan/theme_analyzer/blob/master/css_reader.rb#L29) isn't correct. Should this happen? irb(main):050:0&gt; CssReader.new.convertRgbToHex(1,2,34) =&gt; "1222" irb(main):051:0&gt; CssReader.new.convertRgbToHex(1,34,2) =&gt; "1222" Maybe I'm missing some earlier code that won't allow this kind of ambiguity, but I thought I'd mention it.
Running the [] method on a String returns a different String (or nil). The exact contents of that different String depends on what arguments you provide. I think the comment (in the original snippet) is a little confusing. 
Here's another take on the same thing: def rgb_to_hex(r, g, b) raise ArgumentError, "Arguments must be between 0 and 255" unless [r, g, b].all? {|v| (0..255).include?(v.to_i) } "%02x%02x%02x" % [r.to_i, g.to_i, b.to_i] end irb(main):085:0&gt; rgb_to_hex(1,2,34) =&gt; "010222" irb(main):086:0&gt; rgb_to_hex(1,34,2) =&gt; "012202" You may have different ideas about validating your input, but this may give you some ideas.
 def rgb*a;'%.2X'*3%a.map{|a|[[a,255].min,0].max};end irb(main):002:0&gt; rgb(1,2,34) =&gt; "010222" irb(main):003:0&gt; rgb(1,34,2) =&gt; "012202"
Add some tests with rspec, and maybe a gem like ERB to split out your rendering logic.
Yep, that's one of those different ideas about validating input. A little too golf-y for my tastes, and doesn't allow numeric strings as input, but definitely serviceable. Lots of different ways to do it, depending on what exact method signature you want.
There are a few issues that I have with the way the RMagick library is set up right now. I'd love to try and contribute things that I would consider 'fixes,' but I'm extremely busy and I'm not sure how well these 'fixes' would be accepted.
I don't see where you get the total of the even ones.
My approach: acc = 0; a = b = 1 while (b += a) &lt;= 4e6 acc += b if b.even? a, b = b, a end puts acc 
waiting on op
done, I have refactored/commented all that stuff. Is somebody interested by a gem ?
For a JS version?
Your MClient class is still kind of weird / differen from the rest. Sure, do a gem! I'll try it out with my lighting system.
&gt; Pretty sure you could do this with one line of javascript in the browser console. [OP will surely deliver](http://1-media-cdn.foolz.us/ffuuka/board/tg/image/1345/40/1345400355266.jpg)
Please elaborate on what you'd like to do and I'll give you feedback. We welcome all PRs but right now there is a focus on keeping things stable and fixing the tests on more recent versions of ImageMagick.
Oh, whoops
An explanation has already been given as to how a console one liner would differ from this solution. 
My first issue with RMagick is its documentation; it's extremely unclear on the intent that each and every class is meant to be used for, and extremely annoying to navigate. Moving it over to something like rdoc or yard would be something that I would like. The organization of the classes within the RMagick also really bugs me (first of all, you require rmagick but get the magick module?). Not only that, but some methods also don't follow some ruby standards (for example, some methods on the Magick module should be defined in other places). Actually creating and drawing an image is extremely odd (I think), and once the block exists, you can't easily modify the image (to my understanding). I understand the need to keep things stable, but the library should be easy to use within Ruby.
Anyone else find this API completely weird? The method names are totally non self-explanatory, also - the technique of completely replacing the exception with a new one is unnecessary. You can use tagged exceptions instead: i.e begin yield rescue *HTTPErrors =&gt; e raise e.extend(GenericHTTPError) end This way you can just go `rescue GenericHTTPError` and you get the actual exception of the appropriate class back, not some weird wrapper class. But in general you don't need any of that complexity -- simply defining a constant that contains all the possible HTTPErrors and then just going `rescue *HTTPErrors =&gt; e` is sufficient IMO. 
Yup, agreed. Net::HTTP is kind of a wreck exception-wise, but I'm not sure that this does anything to solve the issue. (Incidentally, frustration with this issue is why I made all [Manticore](https://github.com/cheald/manticore) exceptions inherit from a common base exception.)
Thanks for that insightful response! The funny thing is Lisp is something I'd like to learn too, I've always heard good things about it, but I fear that my colleagues would have a seizure if they encountered something like that in production; they only seem to be familiar with stuff like Java... Anyway, Ruby's definitely on the next project.
&gt; My first issue with RMagick is its documentation; it's extremely unclear on the intent that each and every class is meant to be used for, and extremely annoying to navigate. Moving it over to something like rdoc or yard would be something that I would like. Makes sense, we will try to improve this, feel free to contribute in this respect. &gt; The organization of the classes within the RMagick also really bugs me (first of all, you require rmagick but get the magick module?). Not only that, but some methods also don't follow some ruby standards (for example, some methods on the Magick module should be defined in other places). Agreed, we will be trying to address this issue in a backwards compatible way going forward. Feel free to come on board to contribute improvements in this area. &gt; Actually creating and drawing an image is extremely odd (I think), and once the block exists, you can't easily modify the image (to my understanding). Feel free to create an issue and suggest how the API should work. We can try to improve it. &gt; I understand the need to keep things stable, but the library should be easy to use within Ruby. So, the stability thing is sort of the initial plan. Going forward, the 3.x release will break backwards compatibility for the sake of improving the usability of the library. We will aim to firstly fix all unit tests on all major versions of ImageMagick, then secondly tidy up the other issues, e.g. code formatting, documentation, organisation. Once we get to this point, this will be the end of the 2.x release, we will consider it stable and good for backwards compatibility, and work on a 3.x with major breaking changes. We'll try to include a compatibility/deprecation 2.x release which marks all the deprecated API with warnings so it should be reasonably easy going forward. Does that seem reasonable?
Inheriting from a common base class is a great idea ;)
You may want to move some of your methods to private methods since they shouldn't really be accessible outside of your class. My rule of thumb is that if you have public methods then be prepared to support them. If they should never be called but from within your class then they should be private.
Oh I see. Now I understand. Thank you very much for that explanation.
Excellent information. Thank you.
Definitely.
The main idea behind the gem is the I was finding myself redefining this list of exceptions in ALL my projects. I think it makes sense to have a gem to at least document all of this. The gem also provides facilities to check the response code of the request, and raise that same exception base class. Doing so, lets use unify your error handling code easily. As far a dynamically inheriting a base exception, that's more a question of programming style. I tend to favor composition over inheritance. Thanks for the feedback :)
Yes. This should, IMHO, be handled by the HTTP library. Unfortunately, many do not. In a large Rails app, it's common to actually have several HTTP library as indirect dependencies. My hope is that this gem makes it easier to work around the "bad" design of those http library and write better exception proof code. Thanks for building Manticore, it's one of the better lib out there :)
"I started learning Ruby about a year ago and was hired at this company, my first programming job, about 6 months ago. " Talk about what you know! 
One of the amazing things about programming is that our field is so vast and so detail-oriented, that even after 25 years of experience, I can pair with someone with less than one year of experience and generally find something they know that I don't. One of the nice things about the ruby ecosystem is the huge number of libraries available in the form of Gems. Pick several and demo them. I guarantee that you'll be able to find something that is: - relevant to your audience - not widely known - will be useful to them almost immediately Looking for material? Just listen to the last few weeks worth of Ruby5 podcasts for a few recent gems: http://ruby5.envylabs.com/ Keep that material ready too... I bet you have a local user group where you could do the same presentation, and having a gem to demo up your sleeve is great for conference lightning talks.
This is not [digest](http://en.wikipedia.org/wiki/Digest_access_authentication) authentication (Which is an HTTP authentication mechanism that does not use url parameters, it uses headers and does not change per request.). In fact you can see from the headers that it uses BASIC authentication This "digest" is obviously a set of hashed values, possibly for error correction or possibly to stop/hinder people doing exactly what you are trying to do. (Which should probably cause you to stop and reflect on if you should continue) You have the raw information in a sample request: url, parameters, date/time, device ID / sessionID, other properties if used (Not sure), username/login etc. Now you have to take that data and try and replicate that hash using it. Or you disassemble the source-code and try and figure out how they are creating the hash. It is 40 hexadecimal characters so maybe an SHA1 hash. Good luck (Insert usual legal warnings about messing with private APIs here.)
Glad it was of use.
While I think its hard to tell you want to speak about, others have given you great advice. Speak about what you're passionate about, what you enjoy, or at least, what you've been doing and know well. Be honest in your presentation style -- if you're funny, be funny, but don't try to force it, just try to be yourself. FWIW: I think the all time classic Chicken presentation might help you relax: https://www.youtube.com/watch?v=yL_-1d9OSdk ... enjoy.
1) You should not dictate the language or framework Is not a hard and fast rule. 1) You *probably* should not dictate the language or framework unless you have specific reasons for doing so, and even then, discuss them with the dev so that the reasoning is clear... and be open-minded to feedback.
&gt; is Ruby the best way to go as far as language is concerned? It seems like the fastest development platform, with good security &amp; stability etc, but a trade off as ruby developers are so expensive &amp; in such high demand. The criteria you gave for picking languages don't give Ruby a huge advantage over other languages. I might argue that Python or Java programmers are easier to find (most colleges even teach these languages). I feel the best reason to find a Ruby developer is that this community insists on highly readable code, and this is reflected in the beautiful frameworks that have been developed by the community (Rails, Sinatra, Jekyll, etc.). This means that any future developers you bring on board will be able to get productive quickly. I am not as confident of saying this of other languages (such as PHP, Java). I would say that whomever you hire should exhibit good practices. My list would at least include: - [effective version control](http://nvie.com/posts/a-successful-git-branching-model/) - rigorous testing - practices like continuous integration, continuous deployment - etc. I guess I would suggest that you and your partner do a bit of research on what is considered best practices before making a random hire.
$30 to $100K does not sound exorbitant. Also, remember that quote is probably just for the initial version, which probably won't match what you actually need (though it might match what you think you need, if that makes sense). You mention you're both business guys who are looking for a good developer who you're willing to offer equity to. Take a look at things from the opposite perspective, what do you have to demonstrate to a potential developer you have good business skills? If I was a developer looking to join you guys, I'd be looking for either existing product sales, or for firm commitment from prospective customers to buy it on launch in the $X,000 / month range. If you don't think you can do that without first building the CRM, I'd try and come up with something a little less ambitious that you can sell without getting a developer involved.
Time = money. The average salary of a senior web developer is around $140k/year. If your project will take half a year in total developer hours then that's a good estimate. Offshore development = gets tricky legally if you have to protect your IP. The reason why they are cheap is because they are usually not as good as their on-shore counterparts in terms of quality of product and service. You get what you pay for. 
1) Stick to what you know: things like "what i learned in 6 months in ruby" or "how to be productive in ruby as a newcomer" or "how does ruby compare to X" where x was the language you worked with before. 2) A second option would be - picking a subject within ruby you are really excited about which you didn't see in another language/technology/framework eg. Migrations or RSpec or Active Record Design Pattern etc 3) Check out this series of blog posts by russ olsen ( who also wrote 'Eloquent Ruby' and 'Design Patterns in Ruby' ) [Ref](http://russolsen.com/pages/archives/) If you scroll down a bit, you should see entries for "Acing the technical talk". I like the way he goes over the whole process. Note though, that this is mostly intended for conference talks - and not so much for internal talks, but it's still excellent advise. Hope that helps
Hey thanks for your input. What do you mean by ruby stores? 
Would a developer not subjectively pitch the languages they are best at? rather than perhaps what is best for me?
I'd suggest you get someone experienced on your side. Maybe in a part-time architect/CTO role. He can help with hiring, and answering big picture tech questions (like how much time will such and such a feature take?). He can also point out any red flags if you choose to go with an offshore dev. Take a look at fatfreecrm.com, its open-source, Ruby based and has a permissive license. Ruby may be a very good choice if you can find the developer you need. It has reached the maturity that enterprise/semi-enterprise projects expect, and the go-to-market time is better than the traditional enterprise platforms. Offshore maybe a risky bet, but sometimes that's the only remaining option. If you find yourself in that position, it can be made to work with additional caution and diligence. Also check with people at Melbourne Ruby user group.
by ruby stores, I mean ruby agencies 
It's all about preparation! You don't have to know anything, just make sure you sound like you do. Think about people on infomercials. Like others have said, y'all about something you enjoy. Sprinkle I'm sure humility and don't worry about what you don't know because no one knows everything. 
This does the metasploit email harvester as well.
I recently took the course, and thought it was worthwhile. I don't have any professional experience as a developer, but I've dabbled in Python and JavaScript, and had played around with some online Rails tutorials in the past. I know myself well enough to know that it really helps me to have structure when I'm trying to learn something, hence my interest in learning Rails in a classroom environment as opposed to on my own. One thing that struck me a bit is that the class really does seem geared towards absolute beginners. This is good, because it doesn't assume that anyone knows anything, but it can be a little frustrating because for a lot of those in the class, this is the first time they've tried to learn to code. As such, they may not understand that their feelings of being stuck are totally normal, and they may not have the benefit of recognizing common elements from other languages they know. I was kind of surprised at how often I heard some folks just give up when they couldn't solve something: I'd have figured that enrolling in the class was enough of a commitment that people would want to persevere. Still, for everyone who I overheard saying they'd given up, there were probably more folks who didn't make a big deal about completing their work. As in all things, it's really up to you what you make of it. One thing: you say you want to beef up your skills with Ruby, but the course only spends its first half on Ruby. The second half is all Rails, which, despite being a Ruby-based framework, doesn't really use deep Ruby skills. The instructors were great. Really approachable and encouraging. And General Assembly has tons of events going on. Folks there really want to make sure you're enjoying yourself and getting what you need. This was probably the biggest surprise to me: the classroom instruction and curriculum was maybe less important than the larger community aspect. This, to me, was the most valuable part, and it's something that even after finishing the class I find myself engaging with.
There is some very good advice in this thread. One opinion I will echo and then give a further reason for is to check out development shops and agencies. This is for two very important reasons. 1. They buy you, hopefully, specialized talent that is not working on your project all of the time. You need a system administrator or architect, great... They've got one and you're only going to pay for what you use of them. Now, you're going to have to confirm... They are experienced enough to do the work and they have a history working with the agency you hired. There can be some not so great side effects of hiring an agency that pulls in subs they don't know to work on a project. 2. They provide you with redundancy. A single developer you give money, equity, or anything else to... Can be gone in a flash. Disinterest, a better job, a life change, and even death can take this person from you. Your development agency is going to provide you with a more robust ability to weather this... Because again... They should be trying to maintain redundant staff and should be able to due to having multiple clients. There are a ton of other points I agree with in this thread. I would also say getting a part time CTO is a good idea. This is what I do for a living. A good one will have an open mind and seek out the best options for your project. They're also going to make sure whatever option is chosen, that they're continually lowering the risks present in your ongoing development and maintenance.
This site has lots of great tips about speaking: http://speaking.io/ . As far as picking your topic goes: keep it focused on a smaller topic, and make it something you're excited about. Also, consider your audience. A technical ruby talk may go over much better at a ruby conference than an internal company one. My most well-received internal talk was a Minecraft one :)
Nice Rowan, very trendy !
I'm in a similar situation. I learned Ruby about 6 months ago. I made a quick app for a 6 week course at my university. I gave a stellar presentation on it, and the professor asked me to give a guest lecture to her programming languages class this semester. I'm so nervous. 
Do not rely heavily on written notes for each slide. I made this mistake, ended up stumbling through the entire talk. Practice until the image of the slide itself guides you in what to say.
Nah.
You need to be looping through...something like: index = 0 while input = gets break if gets == "quit" index += 1 sheet.add_row([index, gets]) end 
yea, I noticed that and fixed it but it still keeps overwriting my values. After I get my 2 initial values in, the 3rd and 4th values replace those two first values. enter: 1,2,3,4 --&gt; 1 , 2 becomes 3 , 4
This keeps rewriting row 1. I put in 5 values and got back: 1, 1879 instead of: 1, 429427 2, 842047 3, 4284024
oh, gotcha. Write them into a data array and then write the file when you are done then.
Using eval and avoiding security risks are not mutually exclusive. Eval should not be considered something to avoid like the plague. It's a sharp tool sure, but knowing how to use it is part of assuming competency in Ruby.
not professionally. I attempted to create a comic organizer/library in ruby using shoes (this is when I first started programming). It was decent but there were some memory problems where it would crash after too many clicks so I had to abandon it. You could probably do some decent programs using some ruby qt bindings, but I've never done or know of any programs that use it and are particularly successful. Most gui programs seem to use either java or c/c++ (sometimes python if speed isn't too important)
I know of Redcar http://redcareditor.com which is a ruby based editor that runs on jruby. Its open source so you could poke around to see how they did some things.
Thanks for your input. A part time CTO would be ideal, it's something that I'm considering. Fatfreecrm: what does a permissive licence mean in this context? can it legally be altered and then sold for profit? 
I've been working on a terminal/console based GUI framework for Ruby for around 4/5 months. Its still very basic, but there's a complimentary mp3 playing app which uses it to showcase capabilities. Not quite cross-platform, and still needs a bit of work. Welcoming pull requests. Vedeu: https://github.com/gavinlaking/vedeu (The mp3 player; Playa: https://github.com/gavinlaking/playa).
I used redcar for a bit too and liked it well enough, but then I found Sublime Text!
Lol same. Redcar was too slow for my likings. ST vanilla (no addons) is my main editor (or Vi).
http://www.rubymotion.com/apps/
In most cases you probably won't want to use eval though. Even though if you're a competent ruby programmer you should be able to avoid a security problem, even experts make mistakes and risks should be minimized unless it has a significant effect on the product. 
Ruby's Qt bindings work well on every platform, and you can always package them up as an executable.
I believe that yast by open suse was or is written in ruby. 
EDIT: Updated to include your prompts. How's this: require 'axlsx' p = Axlsx::Package.new wb = p.workbook wb.add_worksheet do |sheet| for i in 1..3 do puts "What is the value?" num = gets puts "Thank you, the value is: " + num sheet.add_row [ i , num ] end end p.serialize 'num_Ex.xlsx' 
Don't use string substitution to define methods with eval was all that needed to be said. You don't have to eliminate all uses of eval to have secure code.
$30K-$100K is not unheard of at all, that's norm for something custom. Cheaper is doable if the requirements are small. If you can get away with an open source CMS to achieve your goal, you should. Totally. If it needs heavy customizations and code written, then maybe it becomes a bigger question. Have you thought about trying to build it yourself? Best case... you build it yourself; worst case, you have some idea of whats involved and the types of effort required. When I had "my great idea" some years ago, I wanted to find a developer to build it for me and I would focus on the business. But that's foolish. Now I'm a developer and know what a nightmare that would have been. 
I haven't heard of email harvester. Could you expand in more detail?
There are a few things I think could improve this. 1) Do not name your class after the data provider (PixelPeeper) because if you change to a different data provider you need to rename your class for consistency witch means you have to change all the calling code as well. When you have a class that acts as an interface to the outside world name it for what it provides. (e.g. ProductInformation or something equally generic). 2) There appears to be 0 error handling here for if the API returns anything but a successful request. Anything such as 404 or 503 would be disastrous if you then cache the result.
I haven't seen a reliable, well documented cross-platform ruby executable packaging system. especially one using Qt bindings. More info please! (Have attempted to use Warbler, Ocra and Monkeybars)
I'll have to give that a try. Past experience has lead me to feel that getting Qt libraries on windows isn't exactly the most fun time to be had. That being said, I haven't attempted it in some time. Perhaps it's been made more streamlined and practical for end-users by now. :) As the other person asked, do you have more info on this anywhere? Thanks!
I should have mentioned JRuby providing access to the Java GUI bits... (java gooey bits, heehee.) But, for some reason, my brain tries to make me not think of that as actual Ruby.
Kudos to you for putting that out there! I'm playing with rb_termbox on some of my local console projects. Not really going for an actual GUI of any sort, but I'll definitely be taking a look at what you've got. :)
There are stable and usable libraries for jruby.
JRuby is pretty nice (I'm using it for a project at work right now), but you end up with a rather large application size if bundle your project up as a jar. If that's not a concern, then I recommend it. For desktop apps, I've started developing Chrome packaged applications. It's not perfect, but it works well enough for my purposes. The project I'm working at work is a VoIP project which uses JRuby on the server side to serve an API and interact with Asterisk, Chrome packaged application for desktop clients, and Cordova for mobile clients (I wrote a PJSIP Cordova plugin so I can make VoIP calls from a hybrid app). 
According to the message, very little. Tenderlove will maintain point releases. Major maintenance and v 2.0 isn't needed, as the project is apparently that stable.
For line 97 you could do something like this: ret = "".tap do |string_to_concat_to| # All your other code here end Though, I would probably break out that block into another method. I'm not sure what you mean by "inappropriate" though, if you need a local variable to be set up before your loop, then that's what you need. I don't see a problem, I guess. Maybe I'm used to it. I suppose if you want, for 116 and 117 you could do this: `ret = gen = ""` or `ret, gen = "", ""` though I don't really like the style of either of those, personally. When you use `raise "something"`, you're raising a `StandardError` with that message. If you want to raise a different exception, you should write a new exception, such as: class InvalidPaddingError &lt; StandardError; end Then you can just `raise InvalidPaddingError` and rescue it. This is just a nit-picky thing that doesn't really have anything to do with ruby, more my personal style, but please STOP using single letter variables and abbreviations. Just friggin' name the variable so it's not ambiguous at all (and so others know what it is at a glance). It helps big time when having people review your code, and it will help you review your OWN code 2-3 months down the line when you've forgotten everything about it. Last thing I have is very minor: I believe standard ruby style is 2 space indents. Edit: Missed the line 143 question. You could do this: gen = ret.bytes.map.with_index do |x, i| ((Blocksize-k+1).ord ^ x.ord ^ prevblock[k+i].ord).chr end.join Or, alternatively, break up the inner expression into a method and name it something that makes sense (cause I have no fuckin' idea what the hell that does at a glance), and then it would be: gen = ret.bytes.map.with_index { |x, i| clear_method_name_aha_moment(x, i) }.join
http://visualruby.net/ and https://github.com/ryanmelt/qtbindings/
The license in this case (MIT) does not force you to contribute your changes back, which means you can make a closed-source product by altering it. Selling it for profit should also be possible, just that you'll have to check the copyright restrictions. I'm not an expert on licenses and copyrights, (please consult one) but I'm optimistic this can work for you. All the best.
The Ruby/GTK bindings are in active development by some devs in Japan.
I make my own tools with ruby/gt3/Ruiby, and use thl every days. they are on github at https://github.com/glurp : * vpn access with providers choice : hma/hma.rb * plot 'real-time' curves : see minitcp/samples/pingpongplot.rb * bench/compare some ruby instructions : Ruiby/samples/sketchi.rb * monitoring some process/net access with systray icon/popup alert. Not on github, skeleton is at Ruiby/samples/systray.rb * games : ang (gosu, so ruby 19...) and rrobots (gtk3).
"Packaging" here means being able to distribute your ruby app in a native format, for example .exe, .MSI for windows, .dmg for Mac or .deb / .rpm for Linux. It should be usable by an end user who has never heard of ruby and doesn't know the app they just installed uses ruby.
httparty really uses self.class.get to send requests? That syntax is just *bonkers*.
Metaprogramming can be just as SOLID as the rest of your code. Consider your example: class AST # def self.name def self.args(*arg_names) attr_reader *arg_names define_method :argc do arg_names.size end define_method :parse_args do |args| arg_names.each do |name| instance_variable_set("@#{name}", AST.build(args.car)) args = args.cdr end end end end Consider extracting a module: def self.args(*arg_names) include Arguments.new(arg_names) end class Arguments &lt; Module attr_reader :arg_names def initialize(arg_names) @arg_names = arg_names end def included(ast) ast.singleton_class.send :attr_reader, arg_names ast.define_method :argc do arg_names.size end ast.define_method :parse_args do |args| arg_names.each do |name| instance_variable_set("@#{name}", AST.build(args.car)) args = args.cdr end end end end Now the module can be refactored: class Arguments &lt; Module attr_reader :arg_names, :ast def initialize(arg_names) @arg_names = arg_names end def included(ast) @ast = ast define_arg_name_readers define_argument_count define_parse_args end def define_arg_name_readers ast.singleton_class.send :attr_reader, arg_names end def define_argument_count ast.define_method :argc do arg_names.size end end def define_parse_args ast.define_method :parse_args do |args| arg_names.each do |name| instance_variable_set("@#{name}", AST.build(args.car)) args = args.cdr end end end end Many further improvements can be made. The point is that instead of backing away from metaprogramming because it can lead to some gnarly code, why not just refactor it into something that *isn't* gnarly? Usually I find that people don't do this because they don't set up an adequate testing environment to be able to confidently refactor their magic.
To be fair, even your final version is pretty verbose (I wouldn't say ugly) compared to lisp macros. I do agree that it is a great improvement. People who come from a lisp probably just give up on making ruby metaprogramming look nice, since they really just want macros. I wouldn't be surprised if many don't even really try.
&gt; include Arguments.new(arg_names) wth? That's not even valid Ruby 
You sure about that? I do it all the time. Subclass `Module`, define an initializer that takes in arguments.
Maybe [xiki](http://xiki.org/) is semi-gui
It is verbose. There are a lot of common patterns in defining subclassed modules like `Arguments` that can be extracted, but I agree, there's a limit in ruby as to how simplified your metaprogramming can be. But, to the author's point, I think you can simplify it *enough* that the deduplication and simplification of the consuming code outweighs its' internal complexity.
it is much simpler to use another framework, such as Sinatra, did you heard about?
Consider: ret = "" (0..enc.length-Blocksize).step(Blocksize) { |n| block = enc[n..n+Blocksize-1] decrypted = cipher.update(block) + cipher.final ret.concat(block_xor(decrypted, block2)) block2 = block #Retain for next found } ret = remove_pad(ret) return ret First, `return` is optional in ruby. The return value will be the result of the final line of code evaluated. This will be important very soon. ret = "" (0..enc.length-Blocksize).step(BlockSize) { |n| # etc end ret = remove_pad(ret) ret Next, we just go ahead and collapse the last two LOC. ret = "" (0..enc.length-Blocksize).step(BlockSize) { |n| # etc end remove_pad(ret) Next, you can chain `Enumerable` objects. In this case, `Range#step` and `Enumerable#with_object`. ret = "" (0..enc.length-Blocksize).step(BlockSize).with_object(ret) { |n, str| block = enc[n..n+Blocksize-1] decrypted = cipher.update(block) + cipher.final str.concat(block_xor(decrypted, block2)) # ret is now str block2 = block #Retain for next found } remove_pad(ret) Now, you can remove `ret = ""` altogether: ret = (0..enc.length-Blocksize).step(BlockSize).with_object("") { |n, str| block = enc[n..n+Blocksize-1] decrypted = cipher.update(block) + cipher.final str.concat(block_xor(decrypted, block2)) # ret is now str block2 = block #Retain for next found } remove_pad(ret) I'd look to see if `remove_pad` can be called on every iteration. If so, then `ret` can go away entirely: (0..enc.length-Blocksize).step(BlockSize).with_object("") { |n, str| block = enc[n..n+Blocksize-1] decrypted = cipher.update(block) + cipher.final str.concat(remove_pad(block_xor(decrypted, block2))) block2 = block #Retain for next found }
Yes. A `Module` cannot be instantiated. You're calling `new` on a module.
In my example, I'm calling `new` on a subclass of `Module`. Have you tried it? class Foo &lt; Module def included(base) base.send :define_method, :hello do "world" end end end Bar = Class.new Bar.send :include, Foo.new Bar.new.hello I just typed this in a pry session and it worked fine.
yeah and then you end up adding in so much crap that you might as well have gone with rails-api. every time.
This shit is so confused. For a start -- in your code you do not subclass module, you just define `Arguments` as a straight-up module (`module Arguments`) and then you go on to attempt to instantiate it with `Arguments.new`. This will never work. The code you posted earlier is broken. Secondly -- why would you ever subclass `Module` ? Rather than putting `included` as an instance method on `Foo` (which is a subclass of `Module`) - why not just make it a class method on an actual module? 
&gt; For a start -- in your code you do not subclass module, you just define Arguments as a straight-up module (module Arguments) and then you go on to attempt to instantiate it with Arguments.new. This will never work. The code you posted earlier is broken. Whups, thanks for spotting that! You're right, I fixed the example. &gt; Secondly -- why would you ever subclass Module ? Rather than putting included as an instance method on Foo (which is a subclass of Module) - why not just make it a class method on an actual module? Because, when you subclass it, you can pass arguments into the constructor, that can shape the methods that get defined. This is essential for the refactoring I showed.
&gt; 1) Do not name your class after the data provider (PixelPeeper) because if you change to a different data provider you need to rename your class for consistency witch means you have to change all the calling code as well. Naming the data provider `PixelPeeper` seems perfectly fine to me. Each API has different response formats and you need to account for that by providing specific classes for each of them. But as you already said you shouldn't reference the class directly (DIP violation) and program against a common interface instead.
I would also take care with a Ruby gem to namespace your code, even if this is only ever being used by yourself. module CSSAnalyser class Theme end end And since this is wrapped up into a gem, you could provide a `bin` directory and have an executable to run, rather than running `ruby theme.rb`.
OK, then how (and for what) do you _safely_ use eval? Only legitimate use-cases I can think of are a REPL and loading in a ruby file such that you get back the final return value. We already have `define_method`, `define_singleton_method`, `Class.new` and `Module.new`.
Thanks for all that. I'll work through all of that. &gt; I'd look to see if remove_pad can be called on every iteration Unfortunately it will raise an exception if called without the last block intact (or another block that looks like a pad).
Mock external dependencies. Test if you want to be able to maintain it in the future or if you want to learn how to test. Don't test if it's a prototype.
Many thanks for all of that. &gt; name it something that makes sense Other than calling it "magical encryption breaking string" that's a struggle. I was considering embedding a description of the process in the comments, but it would run twice the length of the code.
It's important to know how to test things like those you mention. All your code must have some kind of input and some kind of output. If not, it's just not doing anything, and can be deleted... You want to make the input and output clear, and then testing becomes a simple matter of "when I give it input X, it should return output Y".
You could mock the TCP connection with something like this https://gist.github.com/earlonrails/1470076 You could also dump responses from your server as fixtures and respond with that. In general I would say this about testing. Ideally test how and what works best for you and your team. It doesn't need to be test or behavior first, although it might be useful to some. It is better to have a working project that you can learn from, than no project at all because testing prevents you from going forward. It is better to have a working project with test than without. It conveys the message that you care about your craft and future maintainability, you could have contributors and would make things easier to change. If you feel that bdd/TDD is for you, please try it. If it's preventing you from learning how something works, skip it and get experience, there's no point in cargo culting.
Test it against a test server? One that you can manage the state of. The thing with TDD and BDD is that it's more about design that it is about testing - or at least it should be. The penny-drop moment for me was years ago when I realised I would end up with much less code (and much cleaner code) by going through the TDD write test / write code / refactor cycle.
i think ill go ahead and use ajax for this one.
Hello. So I didn't test my personal projects until I tried to come back and maintain my code a year later. I started noticing edge cases that weren't working right, and combined with trying to refactor things. It quickly became a nightmare. The only way I found any sanity was by writing specific interfaces and testing them. So do you need to do tdd? No surely not but if you don't do any tests at all you may find yourself in the same situation, where you don't even remember how the code works well enough to make changes confidently
&gt; ...is it important to test it? It depends on whether you'll be maintaining it in the future, or if it's a one-off. If it's a one-off, I'd test the happy path and make sure it works for what you need it to, then leave it alone to do its job; otherwise, automated tests are really helpful. I wasn't a huge proponent of unit testing until I'd seen a large code base written *without* unit tests. It's terrible.
Testing is incredibly important. It's been the lifeblood of development ever since programming was, like, a thing. There's pretty much no way to make any piece of non trivial software work without testing it. *Automated* testing is pretty cool, it helps you ensure that future changes don't break, or *regress*, existing functionality. It's important to learn how to do this. After a while, when you've got the automated testing thing down, you can start to use automated tests to actually drive your development. You'll write a failing test, and make it pass. This is great for more complex software that will have to sustain active development over a prolonged period of time. Eventually, when you've practiced TDD enough, you'll be able to release yourself of the need for *automated* tests to drive TDD. You'll learn to write objects that are as natural to test as they are to put into production. Often you'll drive them with automated tests, but other times it'll feel more natural to build control systems around your features so that you can exercise them easily within the context of the larger application. Keep your mind open, commit to practicing automated testing and then TDD, and eventually you'll know exactly how you can be the most productive in any situation.
Exactly, so say you find a PHP-based CRM that almost does what you want, then even if PHP usuallynever is the right language, it might just be what you have to buy into. Note however that your preselection of "good starting points" is different from a developer's, and might just be shaped by what you have seen on sites you know. A good developer might know newer or less popular options that are technically superior for your use case, and can also investigate how easy integration and extension would be. If you decide in advance that you say "Need a PHP developer" then you might never hear about those options.
Post the form to the Rails app and have the Rails app send the email. Just because the form is static HTML doesn't mean you are required to use Rails form helpers.
&gt; Often you'll drive them with automated tests, but other times it'll feel more natural to build control systems around your features so that you can exercise them easily within the context of the larger application. Could you give a more specific example of this? I think I know what you mean but I'm not sure.
Sure there are other frameworks which are lighter out-of-the-box - like Sinatra and Padrino. But I think it's easier to strip Rails that to extend Sinatra. What's more, keep in mind there are useful, rails-specific gems which won't work with Sinatra out-of-the-box.
On Mac OS X Mavericks 10.9.4 using rbenv with Ruby 2.1.2 /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/facy-1.2.9/lib/facy/output.rb:58:in `refresh_line': refresh_line() function is unimplemented on this machine (NotImplementedError) from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/facy-1.2.9/lib/facy/output.rb:58:in `clear_line' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/facy-1.2.9/lib/facy/output.rb:9:in `periodic_output' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/facy-1.2.9/lib/facy/core.rb:66:in `block (3 levels) in start' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/eventmachine-1.0.3/lib/em/timers.rb:56:in `call' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/eventmachine-1.0.3/lib/em/timers.rb:56:in `fire' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/eventmachine-1.0.3/lib/eventmachine.rb:187:in `call' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/eventmachine-1.0.3/lib/eventmachine.rb:187:in `run_machine' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/eventmachine-1.0.3/lib/eventmachine.rb:187:in `run' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/facy-1.2.9/lib/facy/core.rb:51:in `start' from /Users/username/.rbenv/versions/2.1.2/lib/ruby/gems/2.1.0/gems/facy-1.2.9/bin/facy:18:in `&lt;top (required)&gt;' from /Users/username/.rbenv/versions/2.1.2/bin/facy:23:in `load' from /Users/username/.rbenv/versions/2.1.2/bin/facy:23:in `&lt;main&gt;' [~]$ Google searching has lead me to believe that the particular error is related to readline, however, readline is installed. Not sure what's possibly missing on my machine or how to resolve this.
A prototype is production code management hasnt seen yet. see: javascript
Just my two cents, automated testing is also an easier way of making sure that your code is doing what you are planning especially in the case of bots. Use guard and every time you save you will see your test run, see if the bot responded like you were expecting without having to wait on requests or other time dependant things to test your code manually.
Well-played, sir/madam/other. Well-played.
Someone would really pay that much money for a service like this? Codeclimate i can understand (and is a great service) -- but *style guide* violations? ...
It's just as important, if not more, for a single-man project to practice BDD as it is for a team. However for your case, you may just want to cowboy out a project without bothering with tests. The reason is you're doing it 'for the heck of it'. If it's not a serious project, why bother using serious tools? On the other hand, it looks like you might not have a lot of experience with TDD, little projects like this are perfect to cut your teeth on it. Unfortunately this will involve learning two new domains, testing, and IRC. This means there's going to be a lot of wheel-spinning before you get traction. But you'd have this problem no matter what new project you have, so there's that. I'm typically always doing something 'meta-tooling' related on all my new projects, so I'm used to a certain amount of wheel-spinning, I consider it good for your skills. The first thing I usually do when I start a new project is to work out a test environment. In your case, I'd probably find an IRC server that you can host in Vagrant, and 'black box' your bot in it. Your test environment can manipulate the IRC server, say, by starting it up and shutting it down, having new users join, stuff like that. But your bot joins the test server just like it would any other server. You're going to do this anyway, you have to test your bot, you're going to find an IRC server just so you can make sure your features are implemented to your satisfaction, so why not do it right and BDD it?
 maybe do gem = RubyGem.find('whynot') gem.destroy! end =&gt; nil (or not)
So, let's say the software we're implementing *Super Mario Brothers* as a web app. Bear with me, clearly this example is terrible. Everything is humming along, you have a Cucumber test that plays through all 9 worlds as Mario. Green dots, yay! But suddenly your stakeholder tells you that there's a bug in World 8. Looks like flying fish are no longer killing Mario upon contact. Your plan to fix this is to determine how to reproduce the bug, then write a failing test. Standard test first TDD. The problem is that you have to play Mario all the way through to World 8 to even *try* and poke around and find the flying fish bug. This is painful. The answer, of course, is to implement a warp system. Or a secret code that opens up a hidden interface to select a world and level to jump straight to. This kind of control system is common in games, but uncommon in most web apps today. In my experience, it provides as big a velocity boost as TDD first did. Adding the ability to control *production* behavior on the fly has dramatic ramifications. Suppose you sell products with a shopping cart interface. What if admins could enter "1" as their credit card number, and immediately induce a successful charge. Or they could enter "2" as their credit card number and induce a failed charge? Suddenly, you can test the entire accounting system without having to interact with a physical payment processor. The ramifications are dramatic. Your automated tests become easier to write, too. The amount of mocking you need to do substantially decreases. You can have credible integration tests that don't a payment gateway, that still exercise your entire e-commerce stack. This is largely why I don't use VCR; it encourages *avoiding* isolating concerns, since your integration tests can interact with the entire universe. I'm trying to think through this stuff a lot more and write up a more meaningful blog post with better examples. I hope this makes at least some sense.
For me, is very useful, because force me to chop the product on very small pieces, that can I test individually. 
You're ruining my life!
As far as the STDIN goes, how come in the previous exercise it doesn't require me to use $stdin ? It just lets me use gets.chomp .
 undefined method `ruined?' for nil:NilClass
It's either scan(/./) or split(//) Use string.split to split a string up into an array with the help of a delimiter, this would in your case be "nothing" or //. Use string.scan if you want to use a regex to get an array with the exact matches, you want 1 char so you need to use: /./. Hope that helps.
Consider the result of splitting " R u b y " on `/\S/` (non-blanks); as you might expect, you get an array of five empty strings. If we removed the spaces, we might expect to get an array of five "nothings", because that's what exists between each of the letters, but there is no Ruby value representing the kind of nothingness that's not present here, so the array of length five can collapse to an array of length zero and still represent the same result. You could split on `/\B/` (non-word bounaries) to obtain the characters of a string, but splitting on the nothingness discussed above (`//`) makes much more sense. It makes even more sense to just use the `#chars` method, of course, and that only if indexing directly into the string (`str[0..3]`) doesn't serve your purpose.
Thanks. See my edit for details.
No worries - glad you found it useful!
Will try to follow up soon on the refactoring to classes :-)
Sure. There is a penetration framework written in Ruby - called metasploit. Just google for it. It also has a lot of awsome data collectors like that ruby gem in the link. I also have to admit that this gem is still useful because no one is going to install metasploit for just one purpose.
Trying to install Ruby 1.9.2 is what you're doing wrong here. 1.9.2 is unsupported bastard hellspawn. If you *need* a 1.9 interpreter, use one of the later patchlevels of 1.9.3. If you just want to see how rvm works, something modern-but-outdated like 2.1.1 should give you absolutely no trouble.
Your video helped me have a breakthrough and "level up" when it comes to programming. Thank you so much! I've read her book but I will read it again now that I understand. 
Oh I see! THANKS! So can RVM only install supported versions of ruby? I was able to successfully test install 2.1.1. This whole things started when I was trying to install a ruby gem (rspec) and didn't have the right permissions. So now when I install a gem will it only install on the version I'm on when I install it?
Why not? If it saves developer time (hence, money) from having to point them out during PRs it could be a net benefit. It also removes the "God this guy is a style pedant" aspect from PRs which might stop some devs from raising these points.
https://rubymonk.com/
I'm not familiar with Magento's api and whatnot but should you be posting your username, password and token/secret on Stackoverflow? I don't have my laptop with me right now but if you still need help tomorrow, message me and I'll try to help. 
Answered on SO. You are authenticating against yourself, not the API.
Aaiiiii, that was painful reading :p but great, didn't know she did a course as well. Hopefully she decides to visit my neck of the woods at some point.
&gt; but should you be posting your username, password and token/secret on Stackoverflow? I've created a demo store and setup a demo Admin just for this question. This way people can reproduce the error and maybe find out what's going wrong. I'll be deleting it as soon as I know the answer. &gt; I don't have my laptop with me right now but if you still need help tomorrow, message me and I'll try to help. That would be great, I still didn't get it to work.
If I'm reading the documentation correctly, I should be authentication against myself. "Myself" is the API. Take a look at the PHP Examples; http://www.magentocommerce.com/api/rest/authentication/oauth_authentication.html. 
That's awesome to hear! I tried to approach it from a beginners perspective as much as possible
He means Ruby design / development companies like this one: http://redartisan.com Just do a search on google for Ruby development companies or consultants in Melbourne to find more.
I would say this is more for the intermediate - advanced people that learned ruby as a first language. Someone coming from different programming language should be fine with this. [http://ruby.learncodethehardway.org/book/](http://ruby.learncodethehardway.org/book/) Is a more hand-held start that I recommend all the time.
While it's a little dated, [Why's Poignant Guide](http://mislav.uniqpath.com/poignant-guide/) is never a bad place to start.
I started in a similar position as you a few years ago. I found this guide to be one of the best h www.railstutorial.org/book and also enjoyed railscasts.com. Like anything it just requires a lot of hours. Start making something and care about it, you'll figure it out. 
If only this actually happened when you ran that code..
Tealeaf Academy is an online boot camp I'm doing. It's really deep and I'm SUPER happy so far. It's an online bootcamp that starts w ruby fundamentals (4 weeks), then rails (4 weeks), then an advanced course (8 weeks). I'm over halfway through course 2 (rails) and I'm really blown away at how much I've learned. I'd highly suggest checking it out. http://www.gotealeaf.com
I wouldn't neccesarily explain it that way, but I think you've got it right. I actually start with proc/lambda (without bothering to distinguish), and then explain that a `block` is basically just a special syntax for passing a single proc/lambda to a method, since that's a thing you do so often in ruby. And then I say that lambdas and procs are basically the same thing, but for a couple differences. But I don't know if my way is actually less confusing for newbs or not. :) 
&gt; The &amp; operator transforms a proc into a block so that it can be passed in to a method as an argument. It also lets you turn the code of methods into a block; that is, you can turn the content of the upcase method into a block with userlist.map(&amp;:upcase) That's not actually quite right. It might serve the newb will enough as a mental model (not sure), but it's not what's going on. "turn the code of methods into a block" doesn't really mean anything. Since this is such a confusing thing to explain the subject of many threads on reddit before, I'm not going to try to explain it here in case you actually already understand it yourself, just didn't write it clearly. :) But I can explain what `.map(&amp;:upcase)` is doing if you want it. (update: actually, I just did that on reddit last month, here you go: http://www.reddit.com/r/ruby/comments/29tgdk/question_about_lambdasprocs_and_the_ampersand/ciqlve6)
I recently completed the back end web development course at GA. I'm a computer science major and hence have decent command of C/C++ and was looking to sharpen my web development skills. The BEWD course at GA is 10 weeks long. The first half of the course focuses on Ruby and OOP concepts. If you already have a grasp of other OOP languages, this part would have a familiar feel to it. However, this is the best opportunity to smooth out any kinks in your understanding, because the second half of the course which focuses on web development using Rails, will call upon your ability to use your Ruby skills with ease. For programmers who haven't worked with a web development framework before, learning Rails might seem more challenging than learning Ruby itself. What I really liked about the course is that it also touches upon many related concepts in the web development ecosystem, such as effective use of APIs, application deployment to a web hosting service, twitter bootstrap, working with GitHub and professional programming practices. At the end of the course, I felt fully equipped to be able to develop and deploy a working web application independently. Needless to say, that the more hours you're wrangling assignments, the more you use office hours, the more you'll get out of this course. Our instructor and TAs were very approachable and supportive. Hope this helps. 
There is [The Odin Project](http://www.theodinproject.com) it is free and comprehensive. Just look at the table of contents - it teaches you from a complete newbie to a full-stack developer, it has links to the resources that are up to date and easy to learn from, it has lists of important questions that you should be able to answer, and most imporantly it has projects and some of the solutions by other students, so that you might compare your solution to theirs! It includes Michael Hartl's tutorial. I also might recommend [The Jumpstartlab Tutorials](http://tutorials.jumpstartlab.com/) which are also linked from The Odin Project. In particular, since you are interested in e-commerce app, there is a spec for one [The Dinner Dash](http://tutorials.jumpstartlab.com/projects/dinner_dash.html). It is also about food. I suspect that's *exactly* what you need. I myself am working through these.
what do you mean by this `lambdas - anonymous functions (only inner scope)` ? what do you mean by 'inner scope' ?
 def try_proc my_proc = Proc.new{ return "I came from the proc!" } my_proc.call return "I came from try_proc!" end def try_lambda my_lambda = lambda { return "I came from the lambda!" } my_lambda.call return "I came from try_lambda!" end try_proc # ---&gt; "I came from the proc!" try_lambda # ---&gt; "I came from try_lambda!" When the Proc executes `return`, it returns *from the method* and the last line of `try_proc` never gets executed. When the lambda executes `return` it returns *from the lambda only.* The string "I came from the lambda!" is the returned value of the expression `my_lambda.call` -- but it's not saved anywhere, we go on to the next line, and that line returns "I came from try_lambda!" That's what he means by "only inner scope." EDIT: I originally made some claims about the scope of the lambda being different than the scope of the proc; **I was wrong.** Both lambdas and procs are bound to the scope in which they were defined.
&gt; That's not actually quite right. It's worse than "not quite right," it's downright wrong. The construction `&amp;:symbol` is equivalent to `(:symbol).to_proc`, and on `Symbol` the `to_proc` method will return a `Proc` which sends that symbol to its first argument. So `&amp;:symbol` evaluates to `Proc.new{ |x| x.send( :symbol ) }`. If you want, you can define `to_proc` on *any class* and apply the `&amp;` operator to it the same way: class AbandonThread def self.to_proc Proc.new{ 'nope' } end end %w(post comment another_comment).map(&amp;AbandonThread) # --&gt; ["nope", "nope", "nope"] *You* probably already know this, but I was explaining it to another developer here earlier today and it pisses me off to see OP's book's author get it so horribly wrong.
oh, i just call that "non local returns" ;) It's the only thing (aside from arity check) that differs from procs
Well, it's hard to call it 'downright wrong' mostly because I'm not sure what it means. "turn the content of the upcase method into a block" doesn't really mean anything. But yeah. It _is_ a pretty confusing construct. It took _me_ a while to get it when it first started appearing in rubyland, I guess when they added the Symbol#to_proc feature to the stdlib. Mainly because most people don't actually use the `&amp;` operator that much in daily ruby in the first place, so we take an operator you don't understand in the first place, and add that Symbol#to_proc trickery to it... I'm not actually a fan of the construct. 
I would love it if we could take over the tradition from the Ruby Quiz and from the Ruby Programming Challenge for Newbies (maybe starting with those two sets, or using those as fillers when we can't come up with new problems) and offer weekly quizzes to practice.
I was thinking what 400921FB54442D18 explained. Apparently, i was wrong about 'inner scope'. Sorry
Thanks for your reply and explanation, it's helpful and I appreciate it. &gt; Well, it's hard to call it 'downright wrong' mostly because I'm not sure what it means. "turn the content of the upcase method into a block" doesn't really mean anything. Well, what I assumed by this (I know this is wrong now) is that calling `&amp;:method` would take the entire definition of `method`, every line between `def method` and `end`, and use that as the block argument. That's what seemed to be going on when I called, say, `w%(apple banana watermelon).map(&amp;:upcase)`. There's still one bit that confuses me, though. &gt; So `&amp;:symbol` evaluates to `Proc.new{ |x| x.send( :symbol ) }`. I looked up `send`, and it looks like the main function of `send` is to allow an object to execute a method that exists separately from it. So when I call `&amp;:symbol`, the resulting proc is creating a block variable associated with nothing at all, and having it call `send` on the symbol I chose? What's happening when I call `map(&amp;:symbol)` then? It seems more complicated than my assumption that the method code is just 'dropped in' and I'm not quite sure what's going on there or *why* it's that way.
And, therefore, legacy code is a prototype that management *has* seen and you no longer want to.
Interesting - what did you originally think?
Hi Mazondo, had a look at the site and a flick through the code on GitHub, looking really good. I've been making my own static site generator (also in Ruby) as a fun side project so this is quite relevant and could be a great tool to use in conjuncture with it. One questions I have is why you chose S3 as the initial target? For static sites in the past I've used GitHub pages, BitBalloon or nearlyfreespeech.net so don't have any experience with S3, are you looking to extend to other platforms in the future? 
ruby-vips is four times faster than rmagick and uses 1/20th of the memory, on this benchmark at least: http://www.vips.ecs.soton.ac.uk/index.php?title=Speed_and_Memory_Use But you have to rewrite for it. If you use carrierwave, there's a vips backend, so that's painless at least. 
BTW: the Ruby Rogues podcast just had an episode recently about speaking at conferences (I'm a bit behind in my podcasts, so I just started listening to it: http://rubyrogues.com/167-rr-speaking-at-conferences/
Fine. :)
I've been using PullReview now for about 6+ months and really like it. I think it provides a lot better information than Code Climate and is a bit more affordable as well. I run guard-rubocop locally to catch linting issues, and then PullReview is the automated backstop. I have also used [HoundCI](https://houndci.com), which provides a little more in-your-face feedback, but isn't as comprehensive as PullReview nor has nice project-wide reports. If you're only doing Open Source projects, install them all cause they're free. But I'm happily paying money for PullReview. Feel free to ask me any questions about it (I'm a big fan of using automated tools like this for freeing code reviews to be about important stuff like architecture and design, rather than styleguide violations)
From a style perspective it might be worth checking out [rubocop](https://github.com/bbatsov/rubocop) which is a gem that help identify style that doesn't fit with the (unofficial) [Ruby Style Guide](https://github.com/bbatsov/ruby-style-guide).
I've been wanting to make games that can run on both desktop browsers and run on Firefox OS, BUT I've been teaching myself Ruby not JS. Seeing this makes me so excited!! This is great!
So you have quite a few options. You could, of course do the classic **twitter clone**. Which is actually much more engaging in sinatra than it is in rails. some examples of user stories would be: * A user can log in * A user can retweet others' status updates * A user can see others' profile pages with all their updates * A user can only post status updates of 140 characters or less * A user can post status updates * A user can follow other users * A user sees a styled site * A user has followers * A user can see a list of their followers * A user can see a list of who they are following * A user can see updates from those they are following * A user sees a responsively styled site * A user can see others' profile pages * A user can link a gravatar image * A user has a profile page * Add your own user stories You can also make a clone of **craigslist** or **hacker news**. You can make a clone of **surveymonkey**. I'd say anything that incorporates CRUD and user Sessions will be great for solidifying the information. I have a sinatra skeleton built out to make the transition from sinatra to rails super easy! PM me if you want me to send it over :)
Definitely. I tried to keep things written in a way that new providers could be easily added. Basically, hosting classes just have to have support for setup, deploy, rollback and list functions. I chose S3 for an initial target b/c it's the one I tend to prefer and it also happens to be a bit tricky to setup. I was thinking GitHub next, what's interesting about using GitHub as a provider is that it means you can keep your code for the project site separate from the project itself, and harpoon will take care of pushing it to the gh-pages branch like they require.
Thank you so much for the thoughtful feedback, everyone! It's people like y'all who make the Ruby community so great.
I love the Russ Olsen blog! Thanks!
After giving it a lot of thought and asking a lot of people (including — gasp! — some real-life friends), I think the most important point is that I should choose something I'm passionate about. Even if it seems like kind of an unoriginal topic, or even it's not highly technical. I haven't found my narrower passion within programming yet, but one thing I care about a lot is making the best use of my time, choosing the right things to focus on, and optimizing the learning process. That's something I think I know more about than even the senior engineers at my company. It might be well-trodden ground in the conference circuit, but you know what? I'm a crazy Grant Morrison-worshipping former actor. I'll make it cool.
there's also [Opal](http://opalrb.org/) (Ruby to Javascript Compiler)
Why not just pure ruby? Is that what you mean by compilers? Would those come in the form of a plugin like flash, in order to run embedded ruby content?
I'm trying to follow the rules you stated, and it's not coming close to being a 10-digit phone number -- I think that you've got the rules wrong. Outside of that... 1) You're using when wrong -- not only are you doing an assignment (i="q" instead of i == "q"), using case i, you should only have when "q", when "w", etc. 2) You should look at the documentation for ruby strings and arrays, as there are a number of methods which would make for a significantly simpler implementation -- specifically each_char and index on strings, and each_slice, map, and uniq on arrays. 3) Since you seem to understand indexing arrays, consider the number to replace a character with to be the index of its position in the string 'qwertyuiop'. 4) Then consider that an array's elements can themselves be arrays. If you're looking at pairs of integers, the array can be, for example, [[1,0], [2,2], [1,0], [5,6]]. This makes it trivial to get the unique pairs. 5) It's not common to use while x != array.length in Ruby -- if you want to do something for each element of an array, the .each method is typically used. If you want to know which iteration you're on, look into each_index, but if you have one array like I just mentioned, you don't need to keep track of which element you're on. I think that your rules are missing some information, as I get a total of 82 unique pairs, which if each added together and concatenated as a string make a 125 digit number. Treating the unique pairs as numbers to be summed (02 + 20 = 22, given your example), the sum of the integers is 4 digits, so that can't be right either. As for the order that you're doing things in your code, I don't see how you can hope to get unique pairs when you're summing before "uniq"ing -- that would be unique sums, and would specifically make 02 and 20 the same (2), whereas you said that they weren't to be treated as such. Generally, I think that your solution would be simplified if you tried to go from a string of characters to an array of digits to an array of pairs of digits to an array of unique pairs of digits to an array of sums of unique pairs of digits to a string concatenation of those sums. Though as I said, that doesn't seem to get to 10 digits. If you decide to start down this path and get stuck, post where you get to and I'll try to follow up with help.
Ruby itself is a dependency. The compilers will turn it into an executable for those environments that won't require any dependencies to be installed. I know this is the ruby subreddit, but I figure most of us use multiple languages, but anyone interested in getting all 'cross-platform on this bitch' should check out haxe (http://haxe.org/). It's a little more like java than ruby, but its pretty freaking awesome.
Here's something quick I came up with: https://gist.github.com/2f9dd1d08a2b7a660dde I didn't quite get a 10 digit number though. Also I had to look through your code to find the other conditions that weren't stated.
Your problem is something called *variable scope*. When your variable is in a block, it is ONLY valid inside of that block. For example: [1,2,3].each do |num| puts num if num.even? end puts num That will result in a puts of 2 and then a variable error. Why? because `num` is only valid INSIDE of the block -- in this case, an iterator. More generally, you're doing this in an unnecessarily complicated way. Here's a program that does exactly what you're looking to do: text = "these are some words" redact = 'some' puts text.gsub(redact,'REDACTED') That will result in: `these are REDACTED words` If you wanted to be cleverer about it, you could also make sure it's only whole words -- for example, so "wholesome" wouldn't become "wholeREDACTED": puts text.gsub(/\b#{redact}\b/i,'REDACTED') That's Regex interpolation! Pretty awesome stuff. It's the same as writing /\bsome\b/i -- that means "find all instances of a word boundary followed by my word to be redacted (case insensitive), followed by another word boundary. But you should definitely learn about variable scope. In your code, you could fix this by changing your loop to only use the scoped variable in your loop. 
You are using the variable hoop as a condition of the if block. This variable is defined in the words.each block and is only available in that scope. You want to move the if block into the each block. Your code: words.each { |hoop| print hoop } if hoop == redact print "REDACTED" else print text + "Nothing to do here!" end Moving the if block into the each block: words.each { |hoop| print hoop if hoop == redact print "REDACTED" else print text + "Nothing to do here!" end } The curly braces work, but it is more conventional to use do/end for the multiple line block.
thank you :)
Instead of creating compilers to convert the Ruby into various types of executable files, why not just create extensions for existing browsers that function as interpreters? That way you can avoid fiddling with the memory an executable would require to exist in. Also, checking out that Haxe thing- but I do have a question, is there any advantage to using languages other than, say, actionscript (scripting language used for programming games that are run by adobe flash) or the new, feature-filled HTML5 standard to make web games? I mean, functionally, why not just write web games in C or C++ since most browsers are already written in those languages? That's even easier than using Java since you wouldn't have to install any third-party software in order to run your browser-based game (or program?) Sorry if these questions seem a bit obvious, I'm really interested in the game development and computer science aspect of things.
.. is abandoned. They're working on v2 but that's nowhere near finished: http://rom-rb.org/roadmap/
Datamapper v2 is basically a Perl 6 like project. At this point you can only hope your kids to code in it.
Glad to help. Let me know if I can answer any other questions =)
Just curious: what is it you want to avoid with AR?
Yeah, that is what it looks like. I heard the guy talk on the Ruby Rogues podcast at one point and thought that it was almost finished. It's mostly a wish list at this point. 
I find it really limiting for anything remotely complex. Starting from the fact that it forces naming conventions on me, to not really supporting foreign keys (I'm aware of Foreigner), more complex queries etc. It's great for doing quick stuff but it's just awful to maintain. I use data mapper libraries in other languages, but it seems the pattern never gained any traction with Rubyists. 
[4.2 is at beta 1 and has true support for foreign keys](http://weblog.rubyonrails.org/2014/8/20/Rails-4-2-beta1/).
&gt; Instead of creating compilers to convert the Ruby into various types of executable files, why not just create extensions for existing browsers that function as interpreters? It would take a hell of a lot of work to get the Ruby interpreter extension optimized in a way comparable to the likes of [V8](https://en.wikipedia.org/wiki/V8_(JavaScript_engine\)). Until then, compiling to JS as an intermediate language is more efficient. The issue isn't one of theoretical possibility but rather an amalgamation of mundane, practical matters like incentive, resources, and standardization. Imagine that a blazing Ruby interpreter browser extension existed. If it weren't bundled with all relevant browsers by default, it may as well not exist for most user-facing commercial projects. Here's a simple analog: Chrome 36 and below [render fonts like butt](http://blog.chromium.org/2014/07/chrome-37-beta-directwrite-on-windows.html) on Windows. The current version of Chrome has a [fix for jagged font rendering involving enabling a Direct Write flag](http://www.jordancrown.com/chrome-windows-smooths-jagged-fonts/). However, that setting isn't on by default. Until Chrome changes that, you'd be wise to design around the feature being absent, because most users won't have enabled it. This means that if you *need* some type to look pretty, a hacky workaround is necessary. &gt;why not just write web games in C or C++ since most browsers are already written in those languages Portability issues. Java has the benefit of the [JVM](https://en.wikipedia.org/wiki/Java_virtual_machine).
Sequel is great. Highly recommended.
I use sequel in a project that, in its last iteration, had 1,000,000+ users. Sequel is great, so much better than active record!
So, how come not more people are using jruby?
Sequel; however if you're avoiding AR you might want to consider a different stack (to Rails) entirely. 
Sequel is what you want. It's been around for a long time, it's actively maintained, it's stable and has great docs. There is no reason to look further.
Nah, Rails is otherwise fine, AR is just too much convention over configuration for me.
Met Sandi recently at Burlington Ruby and it was fantastic.. Favorite talk of the weekend. Spent a couple hours chatting with her over some BBQ. Incredibly smart rubyist. Check out her Ruby book if you'd like to level up your ruby again :)
Browsers are already pretty good at displaying flash, or html5. It makes more sense to use that great performance and not reinvent the wheel. Haxe is actually the successor to actionscript 2. Haxe has two frameworks for html5 that I know of, openfl and flambe.
Java
http://truthabouteventloops.com/?r=http%3A%2F%2Fcodedinc.com%2F
EM gave me headaches trying to code for it a couple years ago (including having to pull in the right EM-compatible gems into the project). I had a lot more fun using [celluloid](https://github.com/celluloid/celluloid), which mimics Erlang's actor pattern rather than the event-driven reactor pattern EM uses.
jruby is generally going to be slow to incorporate new language features. Not sure if they have refinements or required keyword args yet.
[EM::Synchrony](https://github.com/igrigorik/em-synchrony) is generally the easier entry-point than raw EM. It simplifies usage plus it adds a bunch of extensions for existing libraries that enables them to be asyncronous/evented. 
There are other easier ways to get in to EM, without starting directly with just EM itself, but if that's your goal here are a few resources to help you: [An introduction to eventmachine, and how to avoid callback spaghetti](http://rubylearning.com/blog/2010/10/01/an-introduction-to-eventmachine-and-how-to-avoid-callback-spaghetti/) [A series by Javier Acero](http://javieracero.com/blog/starting-with-eventmachine-i) Mike Perham has a [github repo](https://github.com/mperham/evented) full of examples 
At 23:35, it doesn't make sense to interpolate the number. You should just call `num.to_s` (which is what interpolation does internally - it calls `to_s` on the variable). Also, I know that Sandi and Katrina are using this as a simple example to learn about refactoring and TDD but I'd definitely take the version of the code at 8:15 over its final, convoluted version. Still, nice blog post and video. Keep it up!
Your post seems really vague. You don't just learn async IO libraries on a whim. Do you have a specific use case in mind? Basic use case for an evented server is a TCP chat application. [This](https://github.com/eventmachine/eventmachine/wiki/General-Introduction) page has enough information to build a [simple chat server](https://gist.github.com/harmesy/2284810). Strap a HTTP parser and response builder on top of that and you've got [Goliath](https://github.com/postrank-labs/goliath). It's basically node.js in ruby. If simply you wish to do some background processing in your synchronous ruby apps then you should use something like [sidekiq](https://github.com/mperham/sidekiq). 
I saw that in the notes, but what does it really mean? I mean, I can put t.integer :user_id in my migration and it feels like a foreign key...
Did you read the explanation I wrote last month and linked to? Try that out: http://www.reddit.com/r/ruby/comments/29tgdk/question_about_lambdasprocs_and_the_ampersand/ciqlve6) `x.send(:foo)` is, for the purposes we're talking about, _exactly the same thing_ as `x.foo`. Don't get caught up on the `send` I'm not sure what you mean by 'a block variable associated with nothing at all'. I'm not sure what you mea by 'a block variable', or 'associated with'. If you still have questions after reading the the explanation I link to above, I'd be happy to try and answer them. It is confusing. But it's really just a couple simple things going on in the end. 
&gt; You don't just learn async IO libraries on a whim. Do you have a specific use case in mind? It's mainly just to learn about how they work and what you can/would do with them. I did have a simple use case in mind, though: I wrote a script that checked my inboxes on various websites (Reddit being one of them), so that I didn't have to click around 7 or 8 sites just to check for new messages. But each check takes ~5 seconds, so the program takes ~40 seconds to run. I think this is a problem asynchronous IO would solve, I could fire off all requests simultaneously and give them a callback telling them to display the result when it comes back, so that the entire thing runs 8 times faster. But I'm not sure whether to start with that in Ruby. 
[This](https://github.com/igrigorik/em-http-request/wiki/Parallel-Requests) should do it then. EDIT: If you are interested in learning how they actually work, then Event Machine is probably too high level. The actual implementation goes all the way to OS kernel, so learning to use poll/select in C/JAVA would be more beneficial.
It might feel like one, but it's not one. Proper foreign keys are enforced by the database. Meaning that user_id can only contain a value that has a corresponding row in the users table. 
I have no idea. We use MRI and jruby at work and I love jruby. Both have their place, but I default to jruby these days. 
You're welcome.
Flash is the technology that should die for good. Flash has never worked well on Linux, but a good news is I haven't seen it on the websites I visit for quite a long time. :) HTML and JS ftw. 
Why at first place are you going to learn EM? You're not satisfied with Ruby performance (replace your web server with Thin)? You need to able to keep a lot of connections open (install Faye, which runs on Thin)? Just curious? Need to make a lot of third party API calls (faraday with em-http-request backend)?
TIL. That's quite clever and would remove a lot of common boilerplate. 
Reminds me of the old Python "mutable value as keyword argument default" gotcha.
Celluloid also supports asynchronous I/O with Celluloid::IO: https://github.com/celluloid/celluloid-io
So I was talking with someone yesterday and they mentioned that they saw my gem and favorited it, but that it did not run with rspec 3. I played it off as if it was ok to write hacky code in you free time and solid code at work. This has been nagging me since. So half a weekend later after refactoring it and making it work with not only rspec 3 but also 1 and 2 I can finally breath again. Thanks also to the people at the [nyan-cat-formatter](https://github.com/mattsears/nyan-cat-formatter) for blazing the trail of Rspec formatters. The weirdest this is that I have not touched this gem in over a year and so far it has gotten 786 downloads. I was flabbergasted. I could not believe that so many people have checked out my gem. I am really glad that it made so many people's lives better (hopefully). https://github.com/cbelsole/GamifyingFormatter
This problem bit me at my last internship. I poured over the documentation and blog posts until I discovered why all of my hash data was constantly being overwritten. It's definitely not obvious what's going on until you really think about it.
That number is greatly inaccurate as there are several external services that scrape rubygems.
And now I'm sad.
Yes, AR has some limitations, but you can work around pretty much all of them. I use AR with a legacy Oracle database originally created in the late 90s, it doesn't follow any of the AR conventions, but I can use AR just fine. - Naming conventions can be overridden. [Configuring Active Record](http://guides.rubyonrails.org/configuring.html#configuring-active-record) - You can run custom SQL in migrations to set foreign keys. The AR Migration guide actually has examples setting foreign keys. [When Helpers aren't Enough](http://guides.rubyonrails.org/migrations.html#when-helpers-aren-t-enough). This might not be ideal if you are trying to stay DB neutral, but like others have pointed out, 4.2 will have foreign key support. - One thing I've had a lot of issue with AR is lack of support for composite keys, something that is used EVERYWHERE in my legacy DB. This gem works nicely [composite_primary_keys](https://github.com/composite-primary-keys/composite_primary_keys) Anyways, the point of this post is don't discount AR without some serious consideration, especially since you are using rails. It is a very mature project that has a lot of information and 3rd party gems. Most likely there is already a solution for whatever you don't like about it. And yeah, you always hear 'convention over configuration', but that doesn't mean the configuration doesn't exists if you need it.
Some more insight. I thought the same thing at first. Then I published another gem that would rarely get used (https://github.com/kobaltz/clamby) yet it has 1800+ downloads... http://stackoverflow.com/a/11697082
One of the very first notes I left for myself on helping start this company more than 2-1/2 years ago now was, "Keep an eye on DataMapper v2". I honestly expect Perl 8 to be in widespread production before it sees the light of day at this point. Sad but true. The *closest thing* to a Data Mapper pattern implementation in Ruby that has a statistically significant chance of hitting production status in the career lifetime of anyone reading this is probably [Lotus::Model](https://github.com/lotus/model), a component of the (*sweet*-looking) [Lotus](http://lotusrb.org) framework collection. They could really use some community support, especially from people whose experience of OO extends beyond Rails.
I think a lot of people would be interested in your sinatra skeleton. Would you mind making it public?
This reminds me of my favorite implementation of fibonaccis in Ruby: fibs = Hash.new { |h, k| h[k] = h[k-2] + h[k-1] } fibs[0] = 0 fibs[1] = 1
Testing is very important for anything larger than, for example, a small shell script. For your tests you could connect to a real IRC server and verify that the tests had the intended effect. Otherwise you could create a dummy server which does not actually do anything, just verifies that the correct commands were sent.
Thank you, I will definitely go through these.
&gt; You don't even explain what your formatter does.... "With trophies and achievements it makes running tests fun." I will update the readme to be more explicit.
Provide a screenshot.
https://github.com/cbelsole/GamifyingFormatter
It really depends on how you define "most games." Even on mobile, you should be able to get a decent 2D game running (couple of hundred sprites at 30fps).
Minor correction: fibs = Hash.new{ |h,k| h[k] = k &lt; 2 ? k : h[k-1] + h[k-2] }
k00 :) looks fun
wow! what a one-liner!
the "Active Record" pattern makes plugging into legacy/non-Rails systems so damned simple and rewarding.
Thanks. I've started with learn ruby the hard way already :)
Neat way to show code generation. Thanks.
I'm not sure that Sequel is going to be any less 'convention over configuration' for you. But Sequel is the only mature ruby ORM I know about other than AR, with anything close to as the power of AR. Of course, maybe you want something with less power than AR! But, actually, sadly, I don't know of anything mature and maintained in ruby like that either. I've tried using ruby DBI before, but found it non-mature, under-documented and barely maintained... looks like since I last looked at it, it's gone even longer without an update and seems safe to consider solidly unmaintained now. It's too bad, I would love a lower-level lower-power alternative to AR -- mainly, actually, because sometimes I need to connect to a weird legacy database which AR doesn't do well or at all, and I wish there were a simpler framework with less feature that made it cheaper to support more database engines, to at least have an alternative. 
You are being sarcastic?
I think this is because in some areas rails is a fairly desired skill set, and ~~is a more appealing language~~ uses a more appealing language. A lot of startups tend to use it for the friendliness of the language. So you have people who know a bit of programming, maybe they're partly into school start learning it. They don't have the OOP concepts yet or what have you. I agree it's an issue for those to not learn ruby first, as it helps understand a lot of the syntax. I myself looked at rails first, and got confused on how things worked, and what did what. Over time as I read through a ruby book and kept trying to build stuff, I learned the distinction and started to apply better OOP concepts. I honestly see a lot of Java &amp; C# code where methods are 50-100 lines long, and classes are far beyond single purpose. I relate this to bloated controllers in rails, or too much logic in the view. It's a similar kind of code smell.
yeah that's the case for almost all rails developers that I know. 
Maybe Rails is the new PHP?
[keyword_search](https://github.com/bruce/keyword_search) is the closest I can find. Looks like you can define keywords as well as handlers. Pretty generic but could prove useful.
Not so much a correction as defensive coding. I like that it doesn't give me a segfault when I enter an index that's too low, but it is also really hard to read.
We talked about this the other night in our Ruby meetup. The trend in recent years is that most new developers in Rails are new to development, whereas a few years ago you had more migration from other development ecosystems. It was surmised that a large number of those earlier devs may have moved on to other languages, so their experience is less of the community's voice than it used to be. It tends to go beyond OO; how many Rails developers don't really know how SQL works, and how many haven't even written any SQL? I hired a Rails dev a few months back; it was a short list of interviewees, due to our timetable, but no one had heard of Sandi Metz. Personally, I think POODR should be required reading.
There may be some of that, but I think that's a bit unfair. Alot of the online courses and offline boot camps tend to fall short in what they teach, giving the false impression that you'll learn all you need to learn, and these new developers don't know what they don't know. 
&gt; but for someone coming from an actual programming background and diving into the "rails world" it's a funny thing to see. &lt;irony&gt;You are not an actual programmer unless you write machine code buddy!&lt;/irony&gt;
Thabks for I great reference, I surely want to read that myself too. Btw, I obviously made a mistake titling this post "... or OOP", cause OOP was meant just as one example of what the wannabe rails "devs" typically lack. Of course theres the whole stack of possible unknowledge, SQL being another good and simple example.
On the recent Ruby Rogues podcast, they explored the idea of teaching Sinatra &gt; Padrino &gt; Rails, so that developers learn the underlying plumbing (HTTP, SQL, etc) before they learn the magic.
I am well aware of that. Which part of my post did you think I meant otherwise?
Videos disappeared now? :(
&gt; **rails** is a fairly desired skill set, and **is a more appealing language** 
You're so retro. We modern programmers use DIP switches.
Well, if you're defaulting the hash to an integer, this technique isn't needed, since integers are immutable.
Reading these type of threads is depressing. I am quite new to rails and programming. I did cs50 (intro to cs) from harvard online (mostly C but some php, sql and javascript) and now have dived into teaching myself rails. I didn't know ruby before but plan to learn it more in depth after I can build apps in rails (that is the point after all). When I read stuff like this I can only think of someone trying to boost their ego by putting others down. Sure I don't know everything about programming (you don't either) and yes I am learning via a different path but what difference does it make as long as the interest and will to learn is there? Laughing at people asking questions so they can learn is really scraping the barrel. Edit: Some good and fully valid replies here. I do sometimes feel like I am 'cheating' in rails because so much stuff happens auto-magically but slowly and surely the pieces are coming together. It is practically impossible for me to use something and just accept that it works. 
ah yes lol. I'll correct it to use better choice of words :)
Here's some unqualified, unrequested advice from someone who's also self-taught: 1) Look at what experienced programmers complain about as a list of things to avoid/ learn/ improve. 2) From my IRL experience with programmers the ones who laugh at other people generally have a coding level of "pencil-dicked". Good programmers don't feel the need to put people down because they're not generally insecure about their code. This isn't just true of coding, it's also generally true in life. But it applies to programming as well.
god, I hope not
Every time I think to myself, 'I finally understand Rails', I end up realizing how wrong I am. Whenever I read through the Rails Weblog or browse the Rails source code, it becomes more and more apparent to me that only a *minority* of Rails developers really understand how everything works and how it all fits together -- certainly not the typical person who took a 3-month crash course and listed Rails on his resume. I'd like to think that I'm on the right half of the bell curve when it comes to Rails. Truthfully, I am still not that comfortable with Rails (not as much as Qt, for example); I can only imagine how the others fare.
Sorry if this is a nooby question, but why would you need to know SQL if you're a ruby developer? ~~I thought the ruby community avoids SQL and prefers noSQL databases...~~ **Edit:** So apparently I was wrong, SQL databases are popular with ruby, and rails uses it by default.
Also keep in mind that like any language, it's rare for a developer, no matter how experienced, to regularly use every component of the language. Just because I don't do manual socket programming doesn't mean that I'm not a Ruby developer, it just means I haven't had a use for it. You can be a "Ruby" developer but focus on Rails/Sinatra. Just as there are many Java developers who know little to nothing about Swing/Awt/Whatever.
I can offer an alternative perspective. I started learning programming a year or so ago and averted this issue by learning Ruby first, Sinatra second, Rails last, and then SQL while learning Rails. Which makes me sound like I had an incredible amount of foresight for a noob. What actually happened was I tried to do Rails from The Rails Tutorial a couple months before I started learning plain old Ruby, and gave up after chapter 2 because it was too complicated. Luckily an opportunity came along at work to use the small amount of Ruby I learned. This particular problem could be solved with some web scraping and CSV manipulation, and after a couple of tutorials on using Mechanize/Nokogiri I had my first "aha" moment. With my newfound confidence I picked up Sinatra + ActiveRecord since that seemed easier than Rails, and after I had a prototype I ported my very basic Sinatra app to Rails. For me it's particularly difficult to understand how people can use Rails without understanding metaprogramming. Only after I implemented a singleton-based DSL, a method-not-found runtime method dispatcher(ala find_by_column_name in AR), and read Practical Object Oriented Programming in Ruby by Sandi Metz did I feel confident using Rails from having a high-level understanding of how it works. For me I was able to be fairly productive in Rails before I decided to learn more database concepts, but all of the OOP, run-time reflection, and metaprogramming really got in the way of me getting anything done in Rails since I was constantly asking "what is actually happening here?"(now that I understand it I appreciate all of the shortcuts Rails provides). My first year of programming was wrought with dead-ends and wasted time, but I think the one thing I did right when I started learning was constantly asking "what is actually happening here?" whenever I encountered something I didn't immediately understand. I would then backtrack through my limited knowledge complimented by research till I understood it, at least qualitatively if not completely technically(now I'm more confident dealing with the technical bits as well). Lately, learning LISP/Clojure is also helping me become more productive in Ruby as I recognize more meta-programming and functional programming patterns to apply to my Ruby code. Regarding bootcamps in particular, I don't think it's realistic for a developer bootcamp to nail down the intricacies of Ruby's OOP model. But they definitely can and should instill an attitude of figuring out how something works and what it's actually doing like your life depends on it, since that's what'll take their students further than any of the Rails trivia they acquire. I contest your point about people just chasing dollar signs. Rather, I think a lot of these developers are attracted to the product development aspects and not necessarily the software development aspects of programming. Which I think is fine, since ultimately programming is a means to an end, and that end often happens to be delivering a product. TL;DR Whatever path a developer takes, as long as they end up learning LISP it was probably the right path.
thanks!
I think that the OP's problem isn't with people who take the Rails-first path, but with people who go for years relying on the "magic" parts of Rails and never backfill with fundamentals of Ruby. Look at StackOverflow, where along with a question, you're expected to supply a list of things that you've tried alongside the question. It's a matter of etiquette. If you're asking for *help*, you should be putting in effort, and explaining what didn't work assists others who've tried the same thing to no avail. I think the viewpoint that OP espouses is that if you don't put in the effort to backfill your knowledge with fundamentals, you're likely to be one of those expecting others to provide pre-built solutions for you in an entitled sense. I don't believe he meant that it's bad to start out that way, but that if you're not growing beyond it, and equating what you do with those that do, you have a humility deficit worth pointing out.
I don't think OP was trying to bring people down. He was commenting on a trend that he recognizes that many others do as well. As another self-taught developer, if you're actually interested in programming(which you seem to be), and focus on covering your basics(which you seem to have), then you shouldn't worry about posts criticizing people who are content with having only a surface-level understanding of development without penetrating the actual programming concepts beneath it. 
You're a dipswitch.
I've had a similar trajectory and totally agree that constantly asking "What is actually happening here" and looking at the underlying principles goes a long way. At the same time I think I also benefited from trying and failing at some more advanced tutorials and Rails guides when I was new. After later going through more basic guides and building my foundational skills it was much easier for me to go "Ah, so that's why we do X in Rails" whereas others I knew didn't really understand the wider context or usefulness of basic concepts like classes. It was frustrating at the time, but I'm glad to have done it that way.
&gt; how many Rails developers don't really know how SQL works and why should they - the point of the ORM is to insulate them from ever having learning about databases. Its just another datastore to them which allows for the magic of productivity to happen! The knowledge that they are usually storing up a wealth of technical debt due to throwing the big-bag of DBA experience under the train often eludes them ... 
[Better specs](http://betterspecs.org) describes all the best practices. 
I used to work with php around 2007-2008... Now the new frameworks like Laravel may be nice, but I'd rather be tazered than go back to working on the crap that I saw back then.
By far not so fun as [this](http://stackoverflow.com/a/13734433/202914).
Not so defensive, since it allows for `fibs[-1]`
This clearly isn't about memorizing everything. The hash constructor while a part of the language is somewhat obscure. The question "what is attr_accessor in rails" demonstrates that the asker and in the OP do not understand what a class or class member actually are. 
If you understand what metaprogramming is then in your first year you knew more than most of the Ruby devs I work with. I mean this with all sincerity. Most of the devs I work with think metaprogramming is a word I made to sound smart. The problem with some people is that they refuse to learn. People like you have chosen to actually learn. It is not that metaprogramming is all that hard, but defining it is odd and it requires actual understanding of multiple abstractions. Your choice to research and actually learn in all the things you mentioned sets you ahead.
You mean instance property? `attr_accessor` is a syntax sugar, I don't see a case when it cannot be avoided.
I think they mostly give the impression that you'll learn what's needed for an entry-level Rails job, which is often true.
Just a counterpoint -- I attended a bootcamp (App Academy) last year, and I was really impressed by how much they focused on understanding best practices rather than just using the framework naively. I was really impressed. I work with a few other people from boot camps and they're all excellent, curious devs. This isn't to say that all boot camps are good -- just that the trend isn't just churning out crappy, ignorant devs.
IMO rack &gt; rebuild rails 
that comes with huge benefits. Real threading without a GIL, amazing libraries that don't exist on MRI like lucene for search. I can go on and on, but the benefits are huge. 
 &gt; learning Ruby first, Sinatra second, Rails last, and then SQL while learning Rails. I followed a very similar Ruby--&gt;Sinatra--&gt;Rails progression. The difference in my case was that I had a lot of prior SQL experience which I think helped me greatly. Another difference in my case is that I haven't researched Ruby OOP/metaprogramming *nearly* as well as you, which has hurt me. I, too, found Rails quite different to understand (because of all the "magic") without knowing the other things first. Sinatra is a great intermediate step, too. Whereas Rails tends to blur the lines between Rails and Ruby, Sinatra didn't leave any doubts as to where Ruby ended and Sinatra began. Don't get me wrong; I like Rails' design decisions. But until I understood Ruby better, I found it baffling.
Still Java.
I get where you're coming from. I started out teaching myself to be a web developer almost 2 years ago. Starting with Python then focusing on Ruby/Rails the last year and a half. It can be very daunting starting out with just how much there is to learn. But you just have to keep forging ahead. As long as you keep that same desire to keep learning and never feel like you know everything you'll be just fine. I finally got a job about a month ago as an actual Rails developer at a startup and it's been amazing. I'm not an OOP master yet but I have Sandi Metz's POODR book and have been trying to learn how to apply that in Rails whenever possible. One key piece of advice I have is to know your weaknesses, keep a list or mental note of areas you want to improve on and focus on one at a time when you can. Don't try and learn it all at once. You will fail, you will write bad code, but you'll improve over time and that's important.
Rails's default ORM is active record, which interfaces with relational databases (PostgreSQL, SQLite, etc.). So, I think that's a pretty bold statement that is not really true of the community at large.
No, the point of the ORM is to avoid doing repetetive tasks and to prevent the need to reinvent it.
&gt; and gave up after chapter 2 because it was too complicated Or, maybe a better way to put it is that because you did not know the stuff that it builds on, it was just all Greek to you. A slightly more accurate explanation than being complicated, I guess.
You need to understand both. Typically SQL databases are better suited for certain tasks and you can't pick your nosql favorite. 
Its like not knowing cursive. You can say how outdated it is but when your boss hands you something in cursive you don't want to say I can't read this. Besides you can optimize with special efficient queries in certain areas.
The vast majority of web applications in any language, including Ruby, are backed by a SQL database. Don't mistake what people are *talking about online* for what they are *using* :-) NoSQL datastores are a (mostly) new trend, so they naturally attract more discussion than the (relatively) well-understood SQL solutions.
It's 3am but this looks ok to me. You could have it check against an array of known methods and then you could error out if it doesn't exist. Something like Owner.some_non_api_method Class Owner def api_methods %w( someApiMethods goHere) end method_missing ... method = camelize... If api_methods.contain? method ... I did this in the phone, sorry for the short hand
In so many ways, I wish this was true. 
Rails does something similar to this in how it defines routes.
Description of the speaker sounds like Sandi Metz, maybe that name will help you in your search?
Is it perhaps Katrina Owens, ["Therapeutic Refactoring"](https://www.youtube.com/watch?v=J4dlF0kcThQ)? Even if it's not, I highly recommend it. :-)
I would say it is a broader phenomenon. It's not just ruby/rails, it's about web development in general. You can get started and get pretty far (even get by for years) without knowing the basics or realizing the need for it. I'm not talking about the theoretical basics (which are pretty important imo) but about looking under the hood. Realizing that there is more below the application layer. Crash courses fall short on showing you what is below the surface.
Well, it's been the new PHP for a while now. People without any programming knowledge have been churning out "Rails apps" for good years now. That said, it could be worse. Look at the Node community where 15 year old "web developers" reinvented everything in Javascript. 
Hashrockets are the devil
&gt; Crash courses fall short on showing you what is below the surface Tell me about it. I've never read a book like "Beginning Rails 4" before. There was a smirk over my face all the time when I went through it. I mean, I took it as a crash course for Ruby programmers and it was pretty obvious for me, but time and again a centence in the book would remind me that it was somehow meant to work for people who never knew anything about, drumroll, not only Ruby, but OO, SQL, etc. in general! (but it's a very good book otherwise, for example if you're coming from another platform, then learn the language and then want a crash course about the framework). Anyways, I must remind all you folks reading this that I do not consider myself a programmer at all (so let alone then being better than someone) and I'm not casting a shadow over anyone or anything, I'm just sharing my sheer astonishment and amusement over this phenomena. I'm sure this happens in other languages too, but what I gather from RoR case is that it's visibility is associated to the 'thickness' of the framework. 
It's not, but I'll definitely check it out, thanks!
YES! That's it! Thank you very much!
Irony aside, just reminds me of a question: does your editor correctly highlight the **foobar:** as a label when you write **foobar: 10** ? That does not seem to happen neither in Geany nor Gedit, works in Vim, though. But here's what I call specially annoying syntax: **status: :created**. It's like if we had two kinds of men in the world: ones having their dick in front of them and the others growing it out from the back. It may seem like an awful lot of cool options, but believe me, the women would be confused as hell in the first week of it. 
&gt; That does not seem to happen neither in Geany nor Gedit, works in Vim, though. Sublime Text highlights it just fine. Really, it shouldn't be that hard to add the syntax to any existing syntax definitions, it's not like it follows particularly irregular rules. &gt;But here's what I call specially annoying syntax: status: :created. It's like if we had two kinds of men in the world: ones having their dick in front of them and the others growing it out from the back. It may seem like an awful lot of cool options, but believe me, the women would be confused as hell in the first week of it. I don't really conceptualize of the status: as a symbol, though I know that's how I will later be getting it. It's a designation for a key, which happens to be a symbol.
&gt; Why do you need to be able to handle symbols? Because I want to use symbols. Sorry, I think I see the confusion but I thought that was funny. I mean "symbols" not `symbols`. By which I mean text characters like "+, -, =, *" (whatever). I don't mean the Ruby type `symbols`.
Interesting. In many people's experience, even people that like Rails ActiveRecord, dealing with legacy and non-Rails systems is still one of it's weak points. But glad to hear you had a different experience. (I think it's also debatable to what extent Rails ActiveRecord represents 'the active record pattern' or if there are other ways to implement that pattern that would be quite different. But I don't care too much about quibbling over terminology myself.)
I don't know of one. But you could try defining your own grammar using Parslet. (There's another gem that is like Parslet but uses a recursive descent parser instead of a PEG, but I forget what it's called. anyone?) I think you might have better luck with that than regexes; if you find regexes seem to work at first but then you get lost in all the edge cases you want to catch, an actual grammar would be the next step, and Parslet makes it relatively straightforward to create. I have a somewhat google-like grammar (except it includes AND and OR too) in Parslet, but it's missing a few key things and a bit too entwined with it's particular use case to be generally shareable. But I can point to the code if you want to see it, but I can't promise it will be useful and can't provide much further help with it. :)
Well played sir !
Well also IRL it sometimes happens that if someone doesn't like the *message* and they don't know how to attack it, they *attack the messenger instead*. An especially common way of doing it is calling in *the all-famous small dick argument*^1. I was pursuing an *intellectual discussion* about an interesting phenomena that I noticed and this does not have anything to do with anyones *personality* or *physical features*. I wish you all the best and hope that you don't rely too much on a dick with your coding :) _____ ^1 Which turns into an especially epic fail if the messenger happens to be a woman, because usually in these situations not much is known about the messenger's person.
You can do this. Should you do this? No. [Lots of getters/setters are already a smell](http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html) ... From an OO perspective its the Query that varies NOT the method, hence it would be better to express that e.g. Owner.get(Query.new(:owner_vehicle_dimensions)) This insulates you from the inevitable day when you find you need to vary the query or even refactor the implementation since it decouples responsibilities in a more SOLID manner ... IMO :)
http://www.confreaks.com/presenters/211-sandi-metz
I just got done with a conversion task based around this last week. Still hoping to see some speed improvements. I have a difficult time understanding when something was an AR object, as opposed to just a normal Array object by looking at the code. Any tips for this? 
This was me 2 years ago. I had just been hired as an intern, pretty much walking into programming for the first time. I had over 12 years of working with HTML/CSS and was told to basically pick up Rails. No JS, SQL, HTTP/CRUD understanding etc. Took about 6 months till my head was aiming in the right direction. I picked up POODR on my own and have been actively reading ... and re-reading it. There's a LOT to know in this field. So walking into it from scratch is a daunting task, please keep that in mind. 
Fair enough.
I wasn't particularly referring to you. It was a general statement and preemptive incase the real trolls stopped by. Your post only has a whiff of "look how much better my code is than these people" but I originally thought it could have been just an honest observation or as you say "an intellectual discussion about an interesting phenomena." Although now I assume it probably does apply. Your reply just reeks of insecurity.
Most of those are very arguable. In particular, throwing the method name in the describe block is an anti pattern. It creates friction when rearranging methods around within a unit -- which is awful, since the unit test should live at the abstraction layer of the unit itself. This friction often leads to "iceberg classes" with a single `describe ".my_one_method"` block adding a superfluous indentation to the whole test. All that `it { is_expected_to eq 4 }` sugar has a huge drawback. The English that gets created conflates the example used by the test code, from the specification of the object itself. Consider the English that both specs emit: # Notice that none of the specifics required to assert whether the unit works # leak into the spec documentation. describe Multiplier do it "calculates the product of any two numbers" do expect(Multiplier.calculate(2, 5)).to eq 10 end end vs. # The English that is generated here is choppy, broken, and confusing. describe Multiplier do describe ".calculate" do let(:result) { Multiplier.calculate(2, 5) } it { is_expected_to eq 10 } end end Most of those "best practices" are designed to get the programmer getting in a comfy groove while writing tests, without considering long term maintainability (which is supposed to be the whole point).
Rails displays SQL queries in it's log. They can really help with debugging and optimizing. Also, when creating new tables/columns via migrations you have to know how your database works, where to add na index etc. 
I'm a huge fan of MiniTest. It does 80% of what rspec does in a much faster, simpler, and saner fashion. Though I've been using it on all new projects since it was first introduced as the new implementation of Test::Unit, I've never done a migration. This post is good inspiration for a "small" migration, but I would hesitate before attempting something much larger or more complex or otherwise more heavily based on other frameworks' idioms.
As many people have said, your solution is okay. (And I think that your instinct to avoid programatically defining all of those methods is a good one.) But there are some improvements that could be made. (1) Move the string processing into a separate method, for better maintainability. If you eventually add *other* things to `method_missing`, or if you find a better way to infer the query from the method name, it will be cleaner if you've already separated it out: def method_missing( meth, *args, &amp;block ) build_query_from_symbol( meth ) end def build_query_from_symbol( meth ) response = Post.build( meth.to_s.camelize(:lower) ) end (2) As much as possible, try to limit `method_missing` to only respond to method names that match the pattern you're looking for, and call `super` if there is no match (so as to avoid breaking other modules that may rely on `method_missing` themselves). For example, if all valid queries are of the forms "getSomethingSomething" or "setSomethingSomething", you might want to have a regex in `method_missing` like so: def method_missing( meth, *args, &amp;block ) if /^(get_|set_)/.match( meth.to_s ) build_query_from_symbol( meth ) else super end end (3) Lastly, *always always always* implement `respond_to?` if you implement `method_missing`, to avoid strange behavior when your code interacts with other code. It should return true any time that `method_missing` would call your code. And don't forget to call `super` if it's not your method: def respond_to?( meth ) /^(get_|set_)/.match( meth.to_s ) || super end (For bonus points, define that regex as a class constant instead of inline in both methods.) 
As unfunco said: [:vehicle_photo_dimensions, ...].each do |method| define_method method do Post.build method.to_s.camelize(:lower) end end # call it with Owner.vehicle_photo_dimensions 
Agree in both cases. But betterspec is a community driven resource. I'm sure with your argumentation you'll be able to prove your point.
Use https://github.com/richhollis/swagger-docs to generate swagger json documents for your API endpoints, and then use https://github.com/d4be4st/swagger-ui_rails to display these and provide interactive API functionality on top.
Tnanks! Swagger was one of the tools I came across when trying to find different options. It wasn't categorized on rubytoolbox.com, though, so I wasn't sure how much support it had.
I like what /u/morphemass [suggested].(http://www.reddit.com/r/ruby/comments/2eigm3/ruby_metaprogramming_for_api_calls/cjzy8zm) Method missing shenanigans only makes your code neat by hiding the ugly. It will still be there waiting for you to attempt any refactoring or changes. Sometimes shenanigans are what you need, and at that time, ruby is there for you. Just like delicious cookies however, try to keep your paws outta the jar or you'll end up with regrets and love handles. That being said, I think the fact that you need to do all of these queries is a thing to have a look at, rather than how they are made. Some clever and sorta famous ruby programmer said something once that I'l quote here despite not knowing the guys name: If you want to change your code, first ensure that the change is easy (this may be hard), then do the easy change. Look at the bigger picture, can you reshape things outside this class, so that this class can be simpler and still do the job? Sometimes you can find a simpler solution by reshaping the problem.
Nwallins, I totally understand your hesitation. As I said in the post, it's a *huge* undertaking. In our case, we had over 18,000 tests to migrate. O.O Next week, I'll post some strategies we used to make the entire migration take a little over a week. :)
Until you use a library which absolutely needs you to use symbols based on string keys do you get to `:'foo.bar' =&gt; :baz`
Nope, not treetop. Treetop is a PEG too, but has grammars defined in ".treetop" files I guess. I like Parslet's It's Just Ruby approach. There was something else I ran accross which took a very similar approach to Parslet's DSL, but didn't use a PEG for parsing, it used something more 'traditional', I forget the parsing technology terminology which is maybe why I can't find it again! But it seemed interesting to me, turns out PEG makes some things inconvenient, if you don't need the other things PEG makes more convenient. But I'm no parsing expert! Anyhow, here's my own embaressingly written poorly tested code (I wrote it a while ago, I just noticed it's got a backfill for ruby 1.8.6 in there!!), but hey, it was already on the internet. Oh, and looking at it now, it's not actually quite what you're looking for, more focused on supporting AND, OR and parens, and doesn't actually support fielded search yet, looks like that was something I planned on adding but never did. https://github.com/projectblacklight/blacklight_advanced_search/blob/master/lib/parsing_nesting/grammar.rb https://github.com/projectblacklight/blacklight_advanced_search/blob/master/spec/parsing_nesting/build_tree_spec.rb
You will never make it as a programmer. 99% of the time we are teaching ourselves. You need to actually study the syntax to understand it. Face it, you didn't really apply yourself in this class and now it's biting you in the ass.
What in the actual fuck is the source code you posted on GitHub? Is that Ruby?
I would also like to see some more practical uses for both. I have read through their explanations many times but still can't grasp their function without a relative use case. I believe rails uses a form of a lamba for model scopes? I could be very wrong. ie. scope :approved, -&gt; { where(approved: true) }
Have a look at http://awaxman11.github.io/blog/2013/08/05/what-is-the-difference-between-a-block/
Here're a few examples in the wild: [sinatra](https://github.com/sinatra/sinatra/blob/28af01e6af721c102b9d6d8abb39f4708a97d808/lib/sinatra/base.rb#L1219-L1220), [lotus-utils](https://github.com/lotus/utils/blob/91a9769dc3e244dbe288e169af1deafd808b1f3d/lib/lotus/utils/kernel.rb#L202), [roda](https://github.com/jeremyevans/roda/blob/89f2aaf89f85b56edbe2a3a9f18666e6625943fa/lib/roda.rb#L239), and [rom](https://github.com/rom-rb/rom/blob/a68ebe34c2012647a4e72c0c7a210b2381d42a44/lib/rom/relation.rb#L286)
Plus you'd have to use a lamda if inside you say Time.now, otherwise, when it caches it, it won't calculate it each time.
I ran into this problem myself and it was a nightmare to catch!
&gt; `# Notice that none of the specifics required to assert whether the unit works leak into the spec documentation.` uhh i do not consider this a good thing. a spec document is a specification of an object's public interface, including the behavior of that interface to known inputs and environments. "Multiplier calculates the product of any two numbers" does not tell me which part of the public interface I need to invoke to get the desired behavior you're telling me about.
I sometimes use if for constants that need to represent a point in time for example: DEFAULT_TIME = -&gt; { Time.now } def index time = params[:time] || DEFAULT_TIME.call @posts = Post.where('created_at &lt; ?', time) end 
If you use a state machine, such as aasm (acts as... well, you get it), you could set up transition blocks with Procs (this is common, and the author recommends it). https://github.com/aasm/aasm
I don't understand your example, wouldn't this be exactly the same? time = params[:time] || Time.now Also, you should use Time.zone.now :-)
Since when is Time.zone.now being cached in controller actions?
Actually I'm not sure. I assumed it. It would seem odd to me, but Page/Action caching could (from the guides) do that. No? Please, if you have more information, share it!
I am pretty sure that calls to Time.zone.now isn't cached. def index @time1 = Time.zone.now sleep(2) @time2 = Time.zone.now end Gives two different results, which makes sense. Page/Action caching is never evaluating the action, if a cache can be served, so that is fine. But calls in scopes/associations in Rails have been troublesome for a while, especially in Rails 2 and 3, in Rails 4 it seems to be favored with the procs, which is good! It is because associations/scopes is only evaluated once on boot if you don't use procs/lambdas. So this will only ever get evaluated once, which caused headaches :P has_many :recent_stuff, :conditions =&gt; ["starts_at =?", Time.zone.now] named_scope :recent, :conditions =&gt; ["created_at &gt; ?", 1.week.ago] Old blog post from 2008 about the issue: http://www.spacevatican.org/2008/11/9/do-you-know-when-your-code-runs/
I faced the same problem and came up with my own solution: look at http://razum2um.github.io/lurker/ it's way better: it uses your tests, is fully customisable at schema-level, looks nice in browser and has a killer feature - allows people to try your api live. If your test suite has good api coverage - you'll get documentation in less than 10 minutes, give it a try ;)
You should also checkout grape gem, an API dsl that can be mounted inside a rails app. There is another gem grape swagger that will autogenerate swagger docs based on the grape dsl. https://github.com/intridea/grape https://github.com/tim-vandecasteele/grape-swagger You would also have the added benefit of the API being moved out of rails at some point to run on pure rack.
I recently released a gem I'm using as an alternative to ERB/Haml that shows one way to use procs in metaprogramming: https://github.com/aelogica/gara/blob/master/lib/gara/html5_emitter.rb#L97 I needed to add capabilities to the ViewContext during rendering with access to an instance variable (specifically the nokogiri builder) so procs and define_method seemed perfect.
...or when it's cheaper to hire a sysadmin and use AWS/Rackspace/DigitalOcean/Linode/etc directly.
&gt; "Multiplier calculates the product of any two numbers" does not tell me which part of the public interface I need to invoke to get the desired behavior you're telling me about. Separating the example from the specification doesn't prevent you from seeing how to actually exercise the unit. In fact, the separation makes it clearer. It's easier to see this with test unit syntax: class MultiplierTest &lt; Minitest::Test def test_calculating_the_product_of_two_numbers product = Multiplier.calculate(2, 5) assert_equal 10, product end end Notice that *inside* the test I have a very easy to read example of my unit in action. *Outside* the test I have a general description of what the software can do. When you mix the example with the description, and the description itself is fragmented into contexts strewn about the file, you have to learn the example at the same time as you study what the unit does as a whole. There is more cognitive overhead. A lot of thought went into xunit style testing. Though there is definitely room for reasonable minds to disagree. Which kind of makes me irritated that we even feel comfortable talking about "best practices" at this point.
In one of our apps. we use it as a callback to call on the success or failure of an action. Oversimplified example: # controller def create SomeCreator.create( params, on_success: -&gt; (created_model) { render json: created_model, status: :created}, on_failure: -&gt; (errors) { render json: {errors: errors}} ) end # SomeCreator def create(params, on_success: success_callback, on_failure: failure_callback) # do some validation and create new record if successful? success_callback.call(created_model) else failure_callback.call(errors) end end
This. Heroku runs on AWS anyways. At some point you hit a complexity and scale where it just makes sense to keep a guy on staff.
refinements: worst feature ever. 
You can, but you shouldn't. Why not parameterize it instead in the method? def get_query(query) response = Post.build query end (Your example is confusing, becuase in your first "eg" you have `query = "getVehiclePhotoDimensions"`, when I think you mean it to be a method call rather than a string? `query = getVehiclePhotoDimensions`). Then you'd call as eg: get_query(getVehiclePhotoDimensions) There may be additional refactoring recommended too, don't entirely understand what you are doing. But use method parameters and refactoring, over method_missing. 
i think they could be useful in some great ways, but only really once the kernel stuff is implemented. without it, i am unsure of the use value outside of convenience for some gem/lib writers.
Yup! As soon as you want to use two or more forms of callbacks in a method you can't rely on the default yield or "last argument is a block" syntax and must construct lambdas to pass as arguments. 
&gt; That means you can’t ... assume that things like global variables will last from request to request. Is that something that people do? O_O
It wasn't exactly what I was doing but it was good to see. And Parselt seems to be doing everything I needed. And even if I there's one thing that I can't seem figure out it should wind up more easily done by Ruby's std lib in post anyway so it's not worth worrying about.
Rubymine is $99 for individual developer license. It's an option, and surely worth the money...but not sure I'll be doing Ruby enough in the long term to justify the cost right now. 
there's a 30 day trial
It's not an IDE, but you can use [byebug](https://github.com/deivid-rodriguez/byebug) to step through code in a terminal, while you do the editing with whatever else you prefer.
Heroku gets expensive fast if your app takes off. Personally, I found the cost of their service prohibitive. If you happen to know how to set all that up yourself or have someone that can, you can build a custom solution that meets your needs best and much cheaper.
I am not a big fan of IDEs while working with ruby. I use [the debugger gem](https://github.com/cldwalker/debugger) instead: just write `debugger` anywhere in your code, run it and as soon as the breakpoint is reached you have an interpreter open in that scope. It also works with rails: for instance, if you put a `debugger`statement in a controller's action, the execution will block as soon as that action is called (in the browser) and you will be able to debug in the terminal.
you are a developer... is not quite a lot :) 
I use byebug
TL;DR never Way too expensive. I never understood the fuzz about it
I'm also a father of 2 young ones that outgrow clothes and shoes at a ridiculous rate :-) 
It's a great feature for library authors. It can drive a lot of cool things. For application code, I don't see the value (and I see a lot of pain). EDIT: Though, I do see some value with using refinements for DCI role injection.
I use proc when I need more than one block. See awk-like, at the end of : http://raubarede.wordpress.com/2014/05/07/174570572/ 
It is also a huge pain to develop for and deploy to. It's a black box full of edge cases.
Have you looked at OpenShift? The pricing seems to be less than Heroku and I've had great success with Rails apps running on it. As an added bonus OpenShift is open-source which allows you to deploy your own private PaaS with relative ease. Note that OpenShift, much like Heroku, uses AWS.
I use pry. Not an ide, but it's useful for walking through code.
Is there a video tutorial series for Rubymine out there somewhere? It seems like it has a lot of useful features but it's just overwhelming and I have no idea how to use them or where to start. Wish they'd put out a screencast or something.
I haven't used it very much but this seems to be nice: https://sublime.wbond.net/packages/Ruby%20Debugger
At this point everything under the sun has a Chef cookbook. You don't even need a sysadmin. Just a week to learn how to provision your infrastructure via Chef and you're off and running. EDIT: This is obviously for the proof of concept/early stages. Clearly if you experience huge growth you're going to want some ops people around to scale and maintain your infrastructure.
Anyone have any experience with this?
can be condensed further as foo ||= bar
&gt; I toyed with using Heroku but found that it was faster and more reliable to put hundred dollar bills through a paper shredder https://twitter.com/Pinboard/status/494239199038828544
That makes a lot of sense. When people say "it's reusable code!" I wonder why they don't just make a method out of it, but if it helps with a caching issue because it actually runs the code every time it's called, there you have a legitimate use. Thanks!
Why? Faster? More accurate? Syntactically prettier?
so ruby supposedly is a child of smalltalk, but the function call syntax required of most modules (operating on core object types) makes it way less of that. i think refinements could, with the right support, help ruby be more like smalltalk. you'd really extend what core types could receive as messages, rather than use them as arguments to functions.
Shorter, and it does the same thing. It also won't error out if `Time.zone` returns `nil`.
If that's the point of an ORM, then every ORM fails miserably at it. Reading between the lines, I think you agree that every ORM fails miserably at that, and are anti-ORM. However, there are plenty of us who like ORM's, but do not think that is the point of an ORM. Including, probably, the authors of every ORM ever. Your can think ORM's are a bad idea, and you can try to get into that perennial online argument if you want, but you don't help anyone to enlightenment by speaking in sarcasticly vague not-what-you-mean strawmen. 
variable scope is overrated /s
docker containers ftw...
How _everything_ works, and how it all fits together? Everything? I'm not sure there is _anybody_ who understands that, even amongst Rails committers. I'm not joking. 
Pry is great. I use it in every project. Not an IDE, but who needs that anyway. Sublime does everything else I need.
If you're a dev you owe it to yourself to learn as much sys admin as needed. You will laugh at services like heroku once you know how to deploy on your own.
There is utterly no reason to use Heroku if you've surpassed the free tier. It gives you absolutely nothing you can't get elsewhere for much cheaper or free, and the only benefit you get is ease of setup. And really, if you know anything at all about Unix or server administration (and you should know the basics if you're creating a web application), setup will still be pretty damn easy elsewhere.
Yes absolutely. Never understood why anyone would spend time learning their deploy methods when you could spend the same amount of time and learn how to deploy on your own server for a lot less. 
I use Amazon AWS free tier for that, personally.
I've also used them for table-driven logic. An oversimplified version: function_hash = { :foo =&gt; lambda {}. :bar =&gt; lambda {} } table_key = some_logic function_hash[table_key].call It's rare that this is probably the very best way to do this, but I like keeping it in my bag o' tricks.
why do you need refinements for DCI role injection, why not just use ordinary ruby modules?
I thought my sarcasm was reasonably transparent - obviously not. My point was that many developers DON'T go beyond the (AR) ORM level, hell a great many don't go beyond AR &amp; sqlite! And they can get away with it because, well, often that's "good enough". The problem is that because they are insulated they usually don't realize when "good enough" ... isn't! /rant on Rails is 11 years old and they are only now implementing foreign keys in the framework. 11 years of ****** rails databases where its the minority of devs actually giving a damn about integrity at the database level and realizing basic realities such as "Maybe at some point this database will be required for more than my Rails web app. Maybe I'd best make sure the **data** is worth a damn and the entirety of the business logic doesn't live in my code!". /rant off Nothing wrong with a good ORM. An awful lot wrong with a generation of developers who have been discouraged from learning that its an abstraction to what should be another layer of business logic which requires its own set of considerations. P.S. The first person who says "Well doh, make other apps a client of the Rails REST API" gets an internet smackdown.
Yes, but I just register a new AWS account each year and transfer my AMI over (which is an exact clone of the instance).
There's [vim-ruby-debugger](https://github.com/astashov/vim-ruby-debugger), but it may not work with 2.x. Doesn't seem to be actively maintained.
Ah yeah, I have some "larger" AWS sites, so I can't transfer as easily.
I've got 10 or so production apps, still not happy with my deploy process. Heroku is bliss for me when I'm working on others' projects. 
&gt; pretty damn easy I know my way around Unix but setting up servers is hard for me :(
this comment kinda applies to jrochkind's comment below, too. first off: look at the code i posted. :) but for the tl;dr crowd: consider for where `instance_of_time_core` is, say, `Time.now` TimeFormattingModule.format_my_way(instance_of_time_core) or the closely related `ClassIncludingTimeFormattingModule.new.format_my_way(instance_of_time_core)` vs instance_of_time_core.format_my_way In the first, I am sending an instance of a core object, Time, to a Module's function as an argument. Nothing wrong with that, perfectly a-ok. But in the second, I am sending a method as a message (`format_my_way`) to a modified receiver (Time with a refinement on it). It is totally fine to not care about this and only ever bother with the normal function call style. If you are curious about what the advantages are to a more object (or even actor) message style coding practice, check out Smalltalk. :)
At the very least, I'd like to understand how all the magic works and the general architecture of rails (including how every major component works). I, personally, wouldn't be *comfortable* with any framework unless I could understand that. I know it might be unreasonably ambitious, but there are too many unknown moving parts for me to be comfortable.
you don't "need" them. :) but i think they can be useful. see above comment for a bit more.
my opinion was formed largely by this though: http://www.sapphiresteel.com/Ruby-The-Smalltalk-Way-1 so ymmv :)
My guess is that the downvotes are because this is harder than it sounds. There are a lot of workarounds and things necessary. Debugging this is my world right now ;-)
Okay, but why is that a reason to use `method_missing` instead of a parameter to a method? They are effectively the same thing. The method missing approach just hides the parameter in the method name. * `get_vehicle_photo_directions` that triggers method missing which extracts the `vehicle_photo_directions` part from after the `get_` and then does something with it... * vs, say, `get(:vehicle_photo_directions)` which just gets the `vehicle_photo_directions` part as an actual method argument and then does something with it. (except I wouldn't actually use `get` for the method name) I don't know if _either_ of those are the right solution for the actual problem, but without even understanding the actual problem, I know those two things are basically equivalent, but the one with the method argument is a lot easier to debug and read later than the one with method_missing. Probably faster too, although it probably doesn't matter too much. 
Sadly, yes. I've debugged some ugly cases of it.
Server setup + maintenance + security updates + product development? No thanks. Heroku is well worth it, even after the free tier. There is a point where that changes, but it's not when it stops being free.
JRuby is ruby executed on the JVM. Currently working on a JRuby project. You can call Java code from Ruby and Ruby code from Java. Executing Java code from ruby is pretty clean and straight forward. Ruby from Java isn't quite as nice and has some irregularities. I'm also having a lot of trouble with my build tools (JRuby maven plugins are not very high quality). Documentation is somewhat sparse and outdated as well. JRuby code is no different than Ruby code with the bonus of being able to utilize Java classes. 
When you first open a new terminal window and type "which ruby" and "which gem", what gets spit out?
try /bin/bash -login then ruby -v
+1,000.
The magic of Heroku is precisely this: You give it some basic parameters--what you need for a db, other services, etc, then add a git remote, and you're done. Your site is up and you just wait for the money to disappear from your bank account. Is it fast? Not particularly. Is it cheap? *Hell no.* But it's faster and cheaper than trying to roll your own, or get your server back up at 3am. Heroku makes sense until it the price difference between it and another solution is greater than the price of a couple full-time devops employees. Plus 12-factor really is great for deployment. Consider how many projects out there exist to duplicate Heroku on self-managed platforms.
Sorry, but any system administrator with moderate experience would vehemently disagree. Setup is very easy. Maintenance is usually pretty easy. Security updates are extremely easy if you have an automatic update schedule, and also if you follow news. Product development you'll have to do with or without Heroku. You can pay $5 a month for a VPS, or you can pay $40+ a month for a VPS with less resources, and some handholding from Heroku.
To add to arctic9's point, one big benefit with jRuby is multi-threading actually results in multiple threads running concurrently. That's not the case with Ruby MRI.
I use Ruby for systems/operations in a Java shop. it would be really useful to interface with our Java without having to write Java (or run Eclipse!)
Often true. But if you skip Chef, you often wind up installing libraries and packages in Capistrano -- so you have to do all your app deploys as root. Not good. Also, you get to use lots of one-off "check and install this package" code, which is usually written badly. And if you skip Capistrano, you often lose things like rollbacks, and have to manually set up things like database migrations and building assets. Also not good. 
...i think this fixed it! what did this do? what was my issue? thanks so much!!
I think i already fixed this with /u/kobaltzz suggestion, but here you go in case i'm mistaken: which ruby /Users/afxjzs/.rvm/rubies/ruby-2.0.0-p247/bin/ruby which gem gem () { typeset result ( typeset rvmrc rvm_rvmrc_files=("/etc/rvmrc" "$HOME/.rvmrc") if [[ -n "${rvm_prefix:-}" ]] &amp;&amp; ! [[ "$HOME/.rvmrc" -ef "${rvm_prefix}/.rvmrc" ]] then rvm_rvmrc_files+=("${rvm_prefix}/.rvmrc") fi for rvmrc in "${rvm_rvmrc_files[@]}" do [[ -s "${rvmrc}" ]] &amp;&amp; source "${rvmrc}" || true done unset rvm_rvmrc_files command gem "$@" ) || result=$? hash -r return ${result:-0} } Thanks for the response regardless. also...why does gem output like that? i've never seen that response to 'which' before.
You can actually use Chef for both, since the [deploy](http://docs.getchef.com/resource_deploy.html) resource behaves exactly like Capistrano. Nothing has to be done manually. Just use the [execute](http://docs.getchef.com/resource_execute.html) resource to run database migrations and build assets.
Common issue with RVM. Google the command to see how you can have it automatically log you into bash for your environment.
Eh, it really isn't that much to write about to be honest. You use jruby, include a JAR and use the API that jar exposes with a few jruby'ish changes. Ideally you don't have to worry about Java's quirks because they are hidden. It is only when you get into things like performance testing etc. that you really need to know more about the Java ecosystem. Also, you need to worship @headius as the bringer of Ruby light to the darkness of the Java world while you wait for the JVM to spin-up.
Sturgeon's Law applies *with a vengeance* to PHP. A depressingly-large amount of the "crap" (which is damning it with faint praise IMO) that we hit our heads against 7 years ago is still in production, still being tended to by the latest fresh-off-the-plane, cheapest-available "talent" imaginable (and, after 35 years in this craft, I have a *vivid* imagination) available in any given week, and now compares to what we saw then as the 2006-era code compares to the best of Knuth or (*insert favoured software demigod here*). It *can* get worse. But PHP has already accomplished the previously unthinkable: it has proven beyond doubt that, not only is entropy locally variable at a fixed point in spacetime, but it continually *increases at an increasing rate* as one approaches PHP "code". *¡Sal si puedes!*
Odd, ctrl+f "roll" on the page about the deploy resource gives me 10 matches. Either use the :rollback action (I don't do this), or just re-run Chef with the revision attribute set to a previous version you want to roll back to (I do this).
This is the killer feature, even if you never ever use ANY of the Java stuff. Actual factual GIL'less multi-threading is awesome and makes jruby a serious option everyone should look at. Better garbage collector as well. Although it does come with its own issues. I.e. Debugging performance issues becomes a shed-load harder and it is always behind MRI in terms of new language features.
Not so much the "beware rewriting from scratch" argument as the "never try to supplant an overwhelmingly dominant *thing* unless you have a solid, dedicated and adequately-resourced team of experts in both the technology you wish to supplant and the tech *your* product is based on" argument. There have been historical counterexamples, but they're memorable precisely because they're so rare.
Aaah, I was scanning through the page for a "Rollback" header section since to me rollbacks are a major thing worthy of their own section with discussions, gotchas, flow etc. Wasn't expecting it to just another action without the above.
Interesting. That's definitely Capistrano-like. There are some places where it falls short a bit (e.g. callbacks), but it would also save a bunch of headache setting up SSH on Windows. So that may be a wash for me. Presumably when you got to the point of customizing your deploy process where you'd need the finer-grained Capistrano callbacks you'd just write a different Chef resource using an LWRP. The resources-in-callbacks thing is... Interesting. Not sure how I feel about that.
http://www.reddit.com/r/ruby/comments/2eo7tl/why_you_should_tap_into_the_power_of_ruby_from/ 
It works with every interpreter/runtime.
Look at JRuby. I recently rewrote an internal API we use with it using Java libraries from the old system and I didn't have to write a single line of Java code. You can import a jar file and JRuby automatically converts method names and stuff to Ruby style (although the Java style names are still available) so it integrates quite nicely. This saved me so much time because I didn't have to rewrite those Java libraries (libraries for interacting with VoIP systems and stuff) and could instead just focus on the actual API using regular Ruby technologies (Padrino, RABL, ActiveRecord, etc)
If you adhere to the container based deployment model, you don't ever want to do anything to a server other then spin it up, and destroy it. For a deployment, spinup a new bunch of servers with chef properly configured, run your validations against them, then promote by swapping the IPs in your load balancer. To roll back, simply use your old servers. It's slightly more complicated then that, but not by much.
RVM wraps the gem command so it: 1. loads rvm configs which might have impact on the environment 2. does `hash -r` which reloads `PATH` in case you install / uninstall gems with binaries (executables like `rake`) 
Sadly I won't be able to make it this year, but out of interest: Is PolyConf the successor of RuPy? :)
The biggest problem with this article is a problem that I've found to be kind of pervasive throughout the Rails community, and I don't get it. Namely: the assumption, or the implicit assumption, that Heroku is the *only* PaaS provider out there, or that it's somehow regarded as the best provider, the gold standard, or the last word in PaaS. *It's not.* It's one of maybe a dozen PaaS providers which support Rails apps. EngineYard is my personal favorite, but there's Shelly Cloud, OpenShift, Duostack, DotCloud, Ninefold, and more. And each of these providers has subtle (and not-so-subtle) differences. For example, one of the arguments against Heroku in this article is that you can't SSH into your running instances directly. Well, with Engine Yard you can. (I'm not trying to shill for them, but I've had good experiences with them so they're my go-to example.) So if *that's* what's keeping you away from PaaS, you're doing yourself a disservice by assuming that every provider is just a clone of Heroku. I wish the author of this article (and the broader community) understood that just because *Heroku* might not be a good fit for your needs doesn't mean that *PaaS* isn't a good fit for your needs.
I just use one variable. I write everything else out to disk. /s
It's completely worth it. My coworker and I seem to find a new feature every day. It has it's kinks, but programming with and without it is definitely a night and day difference. Will your job pay for IDEs?
Have you tried [RubyMonk](http://rubymonk.com/)? It's more challenging than Codecademy, IMO.
Not too shabby actually. I did expect way worse stats. ~~What about Ruby Enterprise Edition? I know my old company still uses it~~ Edit: Nevermind, I did not see the "EE" at the end of 1.8.7
[REE has reached EOL.](http://blog.phusion.nl/2012/02/21/ruby-enterprise-edition-1-8-7-2012-02-released-end-of-life-imminent/)
www.codewars.com
Doesn't mean it's not used anymore