There are people who buy in to the benefits of using Cucumber, and then there are people who do not see the value. If you are two developers, and are not working closely with business-y people, if you don't have a one or two BA's with non-technical backgrounds consistently looking to refine requirements and if you don't have to "convince upstairs", then it will probably be overkill for you two. RSpec will suffice. Indeed this was the case when I was working for a startup a year ago. Counter-example, we are bringing jruby on rails into a primarily enterprise java shop (I still get raised eyebrows when other teams find out we are using ruby) and I find cucumber an invaluable tool for acceptance testing and BDD.
I used Cucumber and hated it. Just use TestUnit or MiniTest. I personally use shoulda context because nesting setup works very well for me. For driving the browser I do use capybara.
No, you are kinda mixing things. Capybara lets you drive the browser from Ruby. It's not a test framework. A less abstract replacement for Cucumber is plain old TestUnit (or MiniTest, which I prefer). You can also try rspec, but I still fail to see its appeal. I feel it would fail in the same way cucumber fails. Any of those frameworks would use capybara to drive the browser tests.
&gt; Finally, I'd highly recommend that you do not test the majority of your app through the web interface or with the database. Uh, what exactly does this mean? Favor written tests over manual testing? About the RSpec book, yes I'm reading it now. First time to do testing so I'm seeing a ton of concepts. Any good follow up books? I see there's The Cucumber book too.
It is good. But be careful, and take my advice from someone who has been down that road. Practice the "no framework" approach a while on your side projects before you introduce it in a setting with other programmers. It's not all sunshine and roses. Making the web and the database a "detail" to your app has a bunch of benefits, but also a bunch of drawbacks that you need to educate yourself on before you plunge a project into the dark ages.
I get what you're saying. So the BDD is done in pure Capybara, or do you have other gems to use?
I'm going to go against the grain here and say I'd rather avoid Capybara than Cucumber. This is coming from a `Test::Unit` devotee. Capybara is a great piece of software, but it's hard to get working 100% of the time. Tests are often unreliable and brittle against updates to the underlying driver (e.g. poltergeist or selenium). Plus, they're dog slow. Like, if you thought ActiveRecord tests that hit the DB were slow, capybara is at a whole other level. What you gain from testing your UI through capybara just isn't worth it. Use cucumber only if you've got engineers who have used it enough to know how to stop and think, "hey, someone else must have selected a date from a date picker before, let's see if they created some step definitions for it before we write a new one." If your team doesn't do that, your `features/step_definitions` directory will become a hot mess.
Ah yeah. Thing here is that from a similar business in another country, their ramp up of personnel was more on the business side. I foresee that our first few hires would be business people rather than coders. But I have to think about the pros and cons first
Retro-fitting tests onto your product might be harder than you think. The basic test driven design process: 1. red - write a test that runs but fails 1. green - make it pass 1. re-factor - change the code while keeping the tests green By writing tests after your implementation you'll never have a red test so you'll not be able to confirm that the test itself works! 
&gt; what exactly does this mean? Like /u/Robsteranium says, do it in a pyramid. Full stack integration tests are only needed to make sure you have the wiring correct in your stack. You should have very few of these. Then you have a little bit more tests that are integration tests of your business logic, but without the web framework. These can use the database and other external services, but there aren't a whole lot of these either. Your business logic should be written without a framework using dependency injection, so you can mock out the dependancies and test the actual business logic of them very quickly. Writing actual unit tests using TDD practices will help you be productive long after you've started your project. I use cucumber all the time without capybara to test drive my business logic, and I find it very nice to do so. This kind of style will take longer in the short term, but the payoff long term is huge. &gt; I see there's The Cucumber book too. The cucumber book is also very good to read after the rspec book.
I'd recommend introducing as few abstractions as possible into your test setup right now. If you're learning then try to stay as close to your app code and lightweight test framework as possible. When you start to feel pain and have isolated an annoying repetitive problem that feels like someone probably solved already, then go look for a tool to help. Keep it close to the app right now, don't get lost in tool hell (I've been there) and let the problems you encounter dictate the tools you adopt. Cucumber can wait.
Capybara is great for acceptance testing. Whether you need that or not depends on your use case. Cucumber is really just a framework to take what could really be comments and make them first-class test citizens. The actual use case for cucumber is so rare I've never heard of anyone really fitting the description. If you want to use capybara for acceptance testing rspec has features. Mostly though I'd say minitest is more than enough for any of your testing needs. I think it may have features as well but I've never used them.
The linked snippet requires two round trips to the database, and sends an IN list that scales linearly with the size of `count`. Model.order('RANDOM()').limit(count) This only requires one round trip, and the SQL query only grows in length based on the number of digits in `count`. This implementation is PostgreSQL-specific, but the general idea can be implemented on most databases.
Oder RANDOM() of PostgreSQL is actually querying for all the rows of a table and then selecting some rows from it in random. Which is a bad idea if you have a really big table. I believe selecting the id and then selecting the data has an issue of two request to the DB but it will reduce the load or time spend.
You can't make the assumption that people want something then claim they take the worst value. In reality they want it somewhere higher than 0$. If they valued it at zero they wouldn't waste their time looking at you. If they valued it at one quarter its stated value then the better deal would be the free 10 unit card. - 25/4 = valued at 6.25$ paid 7$ for a total value of -0.75$ - 10/4 = valued at $2.50 paid 0$ for a total value of +2.50$
I've toyed with using Cucumber though...it's a neat concept but it does add additional overhead, and do you really have the time for that kind of nicety in a bootstrapped-startup that consists of 2 junior devs and one presumable non-dev? Cucumber is more digestable for non-programmers...but perhaps you should be more dev-centric and focus on unit tests and then move up to Capybara to prevent regressions in the web app?
RSpec is more overhead than Minitest, but saying that it fails "in the same way cucumber fails" is a little vague, kind of like saying Ruby will fail in the same way PHP does, because both are relatively high-level languages. Specifically, RSpec is much less abstract than Cucumber, and it's pretty easy to move from RSpec to Minitest and vice versa. However, I find RSpec worth it because you get a lot of conveniences, such as more granular testing from the command-line (being able to run specific tests, test groups, or target a specific line) and better mocks and stubs.
Cheers!
IMO, the only reason to use Cucumber is if you have completely inexperience people (like non-coders) who are wishing to add tests. Ruby is so easy to read, there's really no reason for cucumber. Junior level Rails devs should have plenty of knowledge to work with Ruby itself. Use TestUnit.
Makes complete sense, thanks for the feedback! :)
This doesn't really pertain to the conversation, and I hadn't commented anywhere else, but I just wanted to say thanks for having that attitude. Learning to program for me is like bashing my head against a keyboard until something sticks (and I don't feel like a single thing has stuck yet). I've been plugging away at Rails for weeks and just haven't had the switch flip yet. As a matter of fact, I'm battling right now with how hard it was to set up a Vagrant/VM and then kept shutting it down and felt I had to rebuild because it wouldn't work when I started it back up. I watched the railscast on how to do it and saw the vagrant package option, used it, then couldn't get it restarted. I know these are all just stupid newbie frustrations and it's been maddening, but just seeing that simple "Not a stupid question!" renewed my tenacity to get it right.
Think it through, this obviously should look like a sub-optimal solution: * pull down as many ids as there are rows in the database (wat?) * picking a few random ones (in Ruby, wat?) from that huge list, throwing the rest of results away (wat?) * fetching by chosen random ids I'm pretty sure this is a solved SQL problem, [google around](https://encrypted.google.com/search?hl=en&amp;q=optimal%20sql%20random).
I guess one could write a sub query to find the list of ID and pick items from it in random. 
Let's start from the chocolate example. It's like setting up a lemonade stand or a corner store and watching what happens. In such a case, everyone who approaches the store/stand comes with an assumption that they'll be paying for something. And in the first case, that's what happened: most people chose what they really valued. Then the Amazon shipping example. Everyone is used to paying for shipping until Amazon eliminates shipping costs...sales increase! Now, we know that humans always behave the same way, so if you extrapolate to the gift card example, most people will pick the free one, although it's a bad deal.
For me, the problem with rspec as with cucumber, is the magical declarative tests that makes it very hard to put a couple of puts or a debugger and see what's really going on. For mocking and stubs I just use mocha (or is it mocka?)
The main thing cucumber does is let you specify the behavior in English, and associate blocks of Ruby code with each line. This is great for ensuring that what a development team implements matches the same behavior described in the "feature" files that described the behavior in plain English. If you're not concerned about some client or customer you are developing the software for approving of the specifications you've made in plain English, then you might not need Cucumber. Cucumber is meant for use for integration testing (AFAIK). Both Cucumber and Rspec can be used with Capybara to drive a virtual browser through your website that performs actions and verifies the result from the perspective of an end user. Some protects use cucumber for integration testing, and Rspec for unit testing. I highly recommend rspec. Some use just Rspec for both. Both use Capybara to emulate browser actions within the tests.
I whole-heartedly agree. I think it will still help though when we refactor our methods, some are just too long. Like 80 lines long. XD
You're making a lot of assumptions about what the people in these scenarios value and what they value it at. Of course you get a sales increase when you lower the prices because you meet more customers value point. In my opinion eliminating shipping only procures more customers because it's a simpler method to market your price decrease from the competition. If amazon was the same as companyX in every regard except companyX was cheaper overall and charged shipping. I would bet heavily on companyX selling more.
Yeah I'm rereading the Hartl tutorial right now XD. Thanks for the resources :)
I don't use Cucumber much, preferring to just write feature-style specs using RSpec and capybara directly. That said, the self documenting nature of Cucumber is useful - especially when coming back to something you haven't worked with in a while. Also, the table style option for inputs v expected results can be handy even in non web app scenarios where you want to bang on a method with a bunch of different data. If you give up coding and go into the hotel industry they will tell you that you *need* to put cucumber in the pitcher of ice water in the lobby. I assure you that this is not necessary.
Cucumber and Rspec are two different things. The fact is that many people use cucumber for the wrong type of tests. Rspec, Minitest etc. are TDD and Cucumber is BDD. The approach for how you test code with both are different. Althought you can use one for both types of test, it will just feel hacky. 
Ouch! If you've not already, you might like to watch Katrina Owen's [Therapeutic Refactoring](https://www.youtube.com/watch?v=J4dlF0kcThQ) talk.
Never. Please, don't use it. Of all the Ruby technologies I touched, it's the one I'm most glad I'm not using anymore.
To be fair, I'm not using any of that magic (I don't think) and still get a lot out of RSpec's feature set...believe me, if not being able to get inside to debug manually wasn't an option, I'd be the first to quit...I am the kind of idiot who litters test suites with binding.pry and then proceeds to push them to the repo
Glad I could help. Programmers have this maddening tendency to look down on a lack of knowledge. I'm not sure what causes it, but it can be outright toxic. I study martial arts, it helps to keep that in check. For all my skills there's some dude who can beat me with one hand tied behind his back. I mean truly literally; we tried it. I was congratulated for putting up a good fight. More people need this kind of humbling-but-not-depressing experience in life. Sorry that Rails isn't clicking yet. Keep plugging away, it'll come eventually. I learned by being thrown into the deep end on an old project where everyone else left in some fashion shortly after I joined. Would not recommend that, but maybe looking through some existing Rails projects can help? I've heard Discourse is a good one, although it does its own things beyond Rails' conventions. (All projects of any significant size go beyond Rails' conventions) I'm not familiar with Vagrant. If you're trying to learn *Rails*, Vagrant isn't really essential. You don't need ruby/gem version independence until you're trying to run two incompatible projects on the same box. Even then there's a *lot* of ways to skin that cat. So for learning Rails I'd set Vagrant aside until I needed it. If you need Vagrant, take it slow and check for unstated assumptions. Typically that's where the problem is when I'm banging my head against a wall. It also may help to do something else for a bit and come back fresh from some other victory. Also, if you're on Linux, check to see if selinux is screwing you over. Like half of my "why doesn't this work" at a system level has been because selinux got its grubby hands on something and nothing else knows how to cope. *grumble grumble*
Right. I had assumed that since they were willing to throw around big lists of IDs, the table wouldn't be that big. Basically, if performance is not a concern, the way I did it should be fine, and marginally better than what was linked. And if performance **is** a concern, you're probably going to want to search for a reasonably-optimized approach, as you say. Upvoted. Edit: typo.
As some one that uses cucumber for a living, this is the best comment. 
Cucumber allows you to separate the testing code from the meaning of the tests. Which is helpful if you want to communicate with non-programmers. I use it even on personal projects because it helps me describe the application's core functionality in one place. Also, you may find it useful to describe your app in Gherkin whether or not you end up using cucumber to test. 
The appeal of rspec is that, [when written well](http://betterspecs.org), it leads to a much [more concise](http://kerryb.github.io/iprug-rspec-presentation/#1) test suite compared to 'assert'-style frameworks. The trade-off is the extra layer of abstraction in its DSL can make it more confusing to understand how the matchers may be executing the assertions - I still find myself needing to flip through the [matcher documentation](https://www.relishapp.com/rspec/rspec-expectations/v/3-0/docs/built-in-matchers) frequently. I prefer it, but understand why others prefer simplicity.
He so cray!
&gt; Cucumber is meant for use for integration testing No. Cucumber is story BDD. Rspec is spec BDD. You can do both unit testing and integration testing with either one.
rspec + capybara for ux/request specs. cucumber just annoys me, you end up having to write a lot of the same stuff you'd write if you were just using capybara, but it results in a lot of extraneous step matchers, etc. 
So people use story BDD for units even? I'm surprised. I'd be down with this if Cucumber made it possible to store feature files in organized subdirectories. I couldn't imagine using cucumber for all tests.
Yeah, my purpose was to provide some help to anyone using Constants if they were used to the way they work in other languages. 
Blocks, case/when, and literally everything is an Object.
I really like everything being an object with no real "special" primitives. Possible your thing is nil? ask it with .nil? Want to randomize behaviors? throw some methods in an array, pull one out of the hat and call it. Like you, I do hate that ()'s are optional, and don't like having too many ways to do the same thing. I haven't done much Python, but the one thing I remember is that I didn't like that indentation had real meaning.
Developers don't look for jobs, we just find them
This may seem glib, but it has a lot of truth to it. Once you get the ball rolling it becomes more of a task to optimize what you spend your time doing than worrying about where the next job is coming from. This may feel like useless information, but maybe you could keep it in the back of your mind and use it to boost your confidence when possible, that's what most of the developers I know do (like pilots, software engineers seem to be 'full of themselves' from time to time).
Thanks. Questions/comments on these: How is thing.nil? meaningfully different than the equivalent Python construct: (thing == None)? Yeah, this one really gets me. I've read Object Oriented Software Construction by Bertrand Meyer, and I get the Uniform Access Principle, and see some benefit to that, but having both ways be legal... I actually consider the meaningful indentation in Python to be a strong point. I'll grant that if you get people mixing spaces and tabs for indentation Bad Things (TM) will happen, but you'll literally never see a "badly" indented Python program where the visual flow of the program differs from the syntactical flow. (Beats the heck out of code all down the left margin: people *can't* be lazy and have it work.)
Blocks are something I'm trying to fully grasp the implications of. Python has function objects, so you can pass a function to another function/method (a la strategy pattern). Python also has closures and such. What idioms do blocks permit that the above Python features would not? I will happily grant that the absence of a switch/case statement in Python is an inexcusable defficiency, given that C had switch statements ages ago. Definitely consider this a good feature to have. I think Python 3 is pretty much "everything is an object", but I definitely agree this a good thing. I really appreciate how clean certain designs can be, using this fact. In counterpoint, I'm still wrestling with what I think about things like: 3.times puts "Hello!" I may be ruined by statically typed languages with unboxed primitive values, but invoking a method on an integer values as a means to effect looping feels... weird, maybe dirty. Not sure yet, like I said still getting used to the idea. Thanks for your thoughts.
I just started mucking about with Vagrant last week. Bloody brilliant, can't imagine what I've been doing all this time without it. I love stumbling upon things that either enhance or redefine my workflow. I've been discovering upon such great things lately I'm starting to accept that I know absolutely nothing about development and that there's some real slick cats out there. 
The 3.times iterators definitely feel weird at first, but personally I think it's great to have an clear syntactic distinction between "I want to do this operation for each item in this collection" and "I want to do this operation a specific number of times times. In my -- admittedly limited -- experience with Ruby, there are hardly any real-world instances where you need to use the &lt;literal&gt;.times syntax. The vast majority of use cases I've encountered involve iterating over a set of things, which is something that Ruby handles very elegantly.
Go to your local Ruby Meetup. If there isn't one, make it.
TBH I write Ruby cause of Rails. It has its problems but there is a lot of momentum with the framework e.g. OS tools it comes with.
Meet ups, networking, twitter, local businesses, references, googling, craigslist, job-sites, devshops, startups, etc.
&gt; What idioms do blocks permit that the above Python features would not? The difference between Ruby and Python isn't about *can* I write code that does the same thing. It is about *how easily* can I write code that does X? It is about *how readable* is the code that does X? With that said ... The fact that every function has an implicit or explicit block parameter means that the use of blocks permeates the language. From the auto-close idiom: # PWD == "/foo" FileUtils.cd(somedir) do # PWD == somedir # Do something in somedir end # PWD == "/foo" To the simple use of high-level algorithms: # Get all the objects from `collection` whose `answer` member equals 42 answers = collection.select { |item| item.answer == 42 } To the construction of DSLs: task :complete do puts 'Build complete!' end Can you do all of the above (with perhaps the exception of simple DSLs) with function pointers/objects? Sure. Would it be as easy to code and as readable as using blocks? Not in my experience. Now, if you're talking about lambdas, that might be different. But I've generally found that they don't get much use in languages that support lambdas but do not encourage their promiscuous use like Ruby does blocks. (Ruby has both blocks and lambdas and there are subtle differences between them.) What this means is that the intermediate programmer in that language probably doesn't use them. This further relegates lambdas to an interesting and perhaps useful, but for the most part unused construct.
I should have noted, I think parentheses being optional hides the fact that many things you would think are special language keywords are actually plain old methods. Like require, include, attr_accessor..
yeah, something like activeadmin... it may work at first, but in all the projects I have done, activeadmin falls short on what I need and I just end writing the custom version always... for example, I had a model that represented a geofence, and I wanted the admin to be able to define the geofence on using google maps... such level of customization is not possible on prefab solutions like activeadmin... cheers!
&gt; How is thing.nil? meaningfully different than the equivalent Python construct: (thing == None)? &gt; Yeah, this one really gets me. I've read Object Oriented Software Construction by Bertrand Meyer, and I get the Uniform Access Principle, and see some benefit to that, but having both ways be legal... What is the meaningful difference between: thing == None And: thing is None ? [This StackOverflow answer](http://stackoverflow.com/a/3965129/1954) asserts that it has to do with readability. I would say the same thing about `thing.nil?`.
I personally have used the n.times notation many times.^ha It comes in handy when wanting to query an unreliable device (e.g. old rs232 equipment) and want to allow for some error, but still never create an infinite loop. Ruby: 20.times do result = device.measure() break unless result.nil? end Python: for i in xrange(20): result = device.measure() if result is not None: break or: tries = 0 result = None while result is None: result = device.measure() tries += 1 if tries &gt;= 20: break A minor point, sure, but it is satisfying to me. In the ruby example, it is a big hint that the contents of the loop *do not care which iteration it is on* while still clearly saying "*this loop will always terminate*".
That's fair. I just wanted to point out that Python also has a language construct that lends itself to building dictionaries/lists from generators/dictionaries/lists in a readable but also compact format. Like OP, I'm primarily in Python at this point in time but I do have an interest in Ruby.
Things that come to mind: - no explicit self parameter for methods (call me superficial, but this bugs me a lot) - no magic \__foo__ methods to be called by a stand-alone foo function--Ruby style is to have a foo *method* for each class. Another way of pointing out that 'everything *really is* an object' or possibly that it feels more like object orientation was baked in from the beginning - functional-style programming is a little easier: if, case, etc. 'statements' are actually expressions that return a value; blocks/procs/lambdas can contain multiple expressions; there are often mutating and non-mutating versions of a method in core classes, e.g. String#gsub (non-mutating) and String#gsub! (mutating). But mostly, Ruby is the old, favorite hat I've been wearing for years now. Sure it's dirty and worn, but it's darn comfortable and still gets the job done. Finally, Python never seemed different enough to pull me away from Ruby!
It's name
As many, if not more things are Objects in Python as they are in Ruby. tmp$ cat foo.py print isinstance(5, object) print isinstance("abcde", object) print isinstance(isinstance, object) print isinstance("abcde".replace, object) tmp$ python foo.py True True True True What is there in Ruby that is an object, which is not an object in Python? 
Your comment is best about what ruby gives to readability (compared to python)
Here is the equivalent of your fileutils example: import path, os with path.path("/tmp"): print os.getcwd() Python requires parens around method and function calls, and has no symbols, so your DSL would look more like this: with task("complete"): puts "Build complete!" 
I guess it really depends on your problem domain. The stuff I'm working on is basically all about iterating over sets of things, so I suppose it makes sense that I'm using .each *way* more than .times.
You can pass functions/methods in ruby def print_foo puts "foo" end def run_func(func) func end class Foo def to_s puts "foo" end end def run_to_s(func) func end run_func(print_foo) ==&gt; foo run_to_s(Foo.new.to_s) ==&gt; foo Also, if 3.times puts "foo" feels dirty, try 3.times{|i| puts "foo" * i}
 $ ruby -e "fork while fork" The expressiveness of ruby, as demonstrated in this forkbomb, can't really be beat in any other language. Also, don't run the above command....
I think something like answers = [item for item in collection if item.answer == 42] valid_answers = [valid_answer for valid_answer in sorted(answers, key=answers.get) if valid_answer.cheated? == false] 
a. Metaprogramming feels more natural and baked-in in ruby, In python it is a little more awkward (for me), especially with all those double underscore variables b. I still am frustrated by the python 2.x, and python 3 divide. c. The community around Ruby is amazing, and its omnipresent, meaning it looms over most everything you do, it is sort of that 'second voice' when you are programming, and you are going, "gee I wonder if the guys would like this code. nope its $%(@#$, better rethink it." I didn't really experience that in python circles, you actually had to *go* to them. (That being said, I also realize this is also a reason people don't like ruby/rails development)
This is where I got my first RoR job. Great resource. Not only did I get *a* job, I also was offered 2 others at seperate shops.
The indentation thing bugs me, but the biggest dealbreaker is the "one true way" nonsense. It's mostly true, but different in random places. The specific one that caught me out is method names on builtin classes. It's been a while, so I don't remember specifics, but two methods in different classes that were supposed to do the same thing had different names, for no particular reason.
This joke is baseless.
From the people that brought you 'chmod 777'.
I posted a link as a reply that I think you should definitely watch. Sure 80 lines is bad, but all you really care about are the messages being sent to and from that method. As long as that's happening consistently, then great. Write tests for those messages, and if it will save you money in the long run then worry about refactoring out responsibilities from those methods into objects or private methods. Just my opinion.
I just have two knee-jerk points as to why (I think) Vagrant is great: * Configurations that you can deploy in a text file. * [Pairing it with the fantastic Docker](http://docs.vagrantup.com/v2/provisioning/docker.html) to build non-trivial systems on a single development machine that can mimic complex deployments. I'm sure there are tons of other, better reasons why Vagrant is so great, but these are two specific reasons I'm happy with it. 
They are the same. In both Ruby and Python *everything* is an object.
aSample = *(1..100).map{100.0} aSample = Array.new(100) {100.0}
This makes me realize I was just answering blankly why I like Ruby. I haven't touched Python in over 5 years.
Or you could do [100.0]*100
This Is the best answer really. After switching careers and becoming a developer, I'm working in my second Rails job. I didn't apply for either one. I just went to meetups, hackathons, bbqs, tech talks, and local bike evens (developers all seem to love riding bikes these days). Eventually people start to notice you. Then you'll make friends, and someone will eventually ask if you're looking for work.
There's no one big thing that makes me prefer Ruby over Python. It's just a bunch of little things that annoy me about Python every time I use it. Ruby has an amazing string library. It handles regex quite eloquently. The blocks means you can avoid control flow keywords all together. Overall it takes very little code to process text. And it's all perfectly readable. I actually like () being optional. Less clutter. If you like (), then you're free to use it. Whatever you feel makes the code more readable. Pythons strict formatting doesn't always result in the most readable code; Ruby's code is as readable as you want it to be. Ruby has naming conventions that most libraries follow. method? if the return value is true/false. method! if it is in place. Python gets really sloppy when you start chaining functions calls, which is probably why it's generally discouraged. Ruby reads left to right. ' '.join([word.capitalize() for word in reversed('a b c'.split())]) vs 'a b c'.split.reverse.map{|word| word.capitalize }.join(' ') self.instancevariable gets old quick. Not a fan of \_\_methods\_\_() either. The python interactive shell doesn't autocomplete by default. I can't write Python without an IDE cause I just get annoyed at counting my indents. Even then, if I'm editing control flow, I have to unindent and indent constantly. Just about every editor can fix spacing automatically. Python has no switch statement. Ruby has one of the silliest switch statements I've ever used in a language. [Examples](http://www.skorks.com/2009/08/how-a-ruby-case-statement-works-and-what-you-can-do-with-it/). The Ruby community seems more willing to stay up to date with Ruby versions; it also helps that Ruby 1.9.2-&gt;2.1.0 didn't have major API changes. Python is still having their 2.7 vs 3.x civil war. 
i prefer ruby because of its consistency over python. want to check a string's length? just use its own class method instead of some random free floating len(). another example: why do i have to pass 'self' all the time? if python needs it internally, ok, but why bother me with this?
Well you're right, good reason to be a little more thorough. And I should have realized that I was being pretty loose with what I meant by "pass a function."
 answers = sorted( (item for item in collections if item.answer if not item.cheated), key=lambda item: item.answered_at )
Well for me, its mostly philosophical. First of all, ruby works the way I think about things. Its 100% OO, so you don't have any weird subject/verb reversal, as you sometimes encounter in python (such as the way sort seems to like to hop about). Other than a few syntax quirks (that enable more freedom), it is very consistent. And then you have cool features like blocks, awesome bits of syntax sugar, and lots of other things that just make it nice to code in. The second are the principles ruby espouses and is even based on. The alphabet soup of acronyms: DRY, MINSWAN, TIMTOWDI, KISS, POLA, etc. You can apply these to most any language, but with ruby, they're basically baked in from the start. Particularly TIMTOWDI, or There Is More Than One Way To Do It. Python and other languages force you to use one convention, one way of doing things. Ruby allows you to approach a problem however you like, with many solutions being equally efficient. Even simple things, like map/collect or reduce/inject, which are the same, allow you to feel more at home with ruby, regardless of your background. And then there are "idioms", some of which are reinforced by the language, such as implicit returns, or generally implicit everything. Finally, the whole community just seems friendlier, more open to new ideas, and less judgmental. In python, I sort of got the feeling that it was a giant sperglord competition. Even in light of some of the nicest and friendliest coders I know, the overwhelming majority of interactions on stackoverflow, irc, and even in real life, were negative. Questions that could be answered quickly and simply, even with a factoid bot or whatever, were almost always answered with "RTFM NOOB" or some similar shit. When I started learning ruby, the community happily recommended several books, tutorials, and projects. Commonly repeated questions weren't dismissed, but rather answered by a bot keyed to certain keywords. And you can see the community philosophy in almost every part of the ruby universe. From fundamental features of the language, such as the inability to close a class or module, enabling monkeypatching, to github itself, all seem to be very ruby-ish things. Dont like the way something works? Patch it! While this is not unique to ruby, and has been a part of FOSS forever, ruby seems to be particularly open to it. Steve Yegge explains it better than I ever could, with a simple anecdote: &gt; What about Python? Is Python hip, funny, and fun? Not really. The community is serious, earnest, mature, and professional, but they're not much focused on fun, which is an important part of marketing languages. &gt; One could write a fat book about this, but just to give you the flavor, consider what happens when you type "python" at a command prompt. It fires up a little interactive interpreter. At the prompt, if you type "quit", it responds with 'Use Ctrl-D (i.e. EOF) to exit.' &gt; Well that's not very nice, is it? It *knows* you want to quit, even going so far as to call you an EOF, whatever that means. (Yes, you and I both know, but is it really the right thing to show to a beginner? Hardly.) Why didn't it just quit, then? &gt; If you were to bring this issue up on a Python newsgroup at any time in the past 10 years, someone would tersely have instructed you to go look at the FAQ. Or they'd have explained that having 'quit' quit would be a strict violation of the semantics of the REPL, which has no a priori knowledge of English, and as Ctrl-D is universally recognized as the EOF char on most terminal emulators, excepting of course broken ones on win32 and VAX platforms, and the interactive shell's clean design allows the interpreter to treat the input as if it were coming from a file or similar stream, blah Blah BLAH, ergo, the current behavior is correct, quod erat demonstrandum. &gt; Never mind that it's patently obvious that "quit" should just quit the frigging shell, semantics be damned. They don't care a whit, because they're focused on the "right thing" at the expense of the user experience. There's an old adage for this; it's called "missing the forest for the trees." &gt; Of course it's just as difficult to figure out how to exit the Perl shell, if not more so. But if you were to bring it up on a mailing list or newsgroup, some nice Perl person would come along, eager to show you how to add one more snippet of job security to your lineup of Perl folklore, and would spend an hour explaining how cool it is that you can quit the shell with a single keystroke, one that works in other Unix commands as well, and then maybe show you how to hack the Perl binary so that "quit" also exits the shell for you. The difference is huge: both shells have that crappy misfeature, but Python folks will bore you with justifications while the Perl folks excite you with marketing. &gt; Pedantry: it’s just how things work in the Python world. The status quo is always correct by definition. If you don’t like something, you are incorrect. If you want to suggest a change, put in a PEP, Python’s equivalent of Java’s equally glacial JSR process. The Python FAQ goes to great lengths to rationalize a bunch of broken language features. They’re obviously broken if they’re frequently asked questions, but rather than ‘fessing up and saying “we’re planning on fixing this”, they rationalize that the rest of the world just isn’t thinking about the problem correctly. Every once in a while some broken feature is actually fixed (e.g. lexical scoping), and they say they changed it because people were “confused”. Note that Python is never to blame [(from anti-anti-hype)](https://sites.google.com/site/steveyegge2/anti-anti-hype)
Amen on the "weird underscore things" And they you get the chains of `__self__`
 aSample = *(0..99).map {100.0} seems odd to me. Hanging that * out in front of a range is odd. I am not sure what it is doing. It seems like a method hanging out there with no object. aSample = (0..99).map {100.0} works fine. What does the * do? aSample = Array.new(100) {100.0} I like this because it creates and populates all in one, plus it gives the option to do all kinds of things with the block. Thanks!
The splat (*) operator basically makes that a succinct version of this: aSample = 100.0, 100.0, 100.0, 100.0 ... aSample.map{100} It only works if you're assigning the array to a variable or passing it to a method. Using Range#map is probably better, but I like the Array.new method with the block best.
I personally love both Ruby and Python (though I prefer Ruby, on the whole), and both have definite strengths and weaknesses. Some strengths, as I see it, of Ruby's: * Ruby's syntax is a lot more forgiving, and often less verbose, than Python's. I know some Pythonistas think this is a downside, but it's a **major** plus when using it interactively. Here's a typical irb session for me: irb(main):001:0&gt; def foo a irb(main):002:1&gt; a + 5 irb(main):003:1&gt; end =&gt; nil irb(main):004:0&gt; foo 6 =&gt; 11 Here's a typical python session: &gt;&gt;&gt; def foo(a) File "&lt;stdin&gt;", line 1 def foo(a) ^ SyntaxError: invalid syntax &gt;&gt;&gt; def foo(a): ... a + 5 File "&lt;stdin&gt;", line 2 a + 5 ^ IndentationError: expected an indented block &gt;&gt;&gt; def foo(a): ... a + 5 ... &gt;&gt;&gt; foo(a) &gt;&gt;&gt; # The hell? &gt;&gt;&gt; def foo(a): ... return a + 5 ... &gt;&gt;&gt; foo(6) 11 OK, I may have exaggerated that (slightly), but you get the idea. * OOP that doesn't feel like an afterthought. Python's OOP is... well, really weird. The fact that there's no distinction between private or public, class method or instance methods, and so forth generally feels wrong to me. Then again, you mentioned Ruby's OOP in your post, so maybe this one isn't too surprising to you. * Blocks. OK, everyone's going to be talking about blocks, because they're really nice. Here's a kind of trivial one, that may or may not ever be useful: class Array # Wooo monkey patching wooo def get_upto count items = [] each do |i| return items if items.length == count items &lt;&lt; i if yield i end items end end [1, 2, 3, 4, 5, 6].get_upto(2) { |i| i.even? } #=&gt; [2, 4] Yes, in Python you could just pass in a lambda, but that feels really clumsy compared to blocks. Not evident so much in this example, but oh well. * Chained things feel a lot more natural. Ruby: (1..20).select(&amp;:odd?).map{ |i| i * 2 }.inject(:+).to_s.chars[1..-1].join #=&gt; "00" Python: ''.join(list(str(sum([i * 2 for i in range(20) if i % 2 == 1])))[1:]) #=&gt; '00' * I discovered yesterday that my birthstone is apparently the ruby, so it has that going for it. Is your birthstone the python? No? I didn't think so. * Here's an unbelievably minor one, but it pisses me off nevertheless: Python: 1.a_method() # SyntaxError (1).a_method() # Works fine! Ruby: 1.a_method # Works fine, because Ruby's parser is marginally competent Of course, those are all personal preferences, and there are a lot of things Python does much nicer than Ruby (functions-as-objects, for one). To each their own. As a side note, Ruby does have a lot of TMTOWTDI, but `each` v. `for` isn't one of them. No one ever uses `for` for anything ever. You could argue that then it shouldn't be in the language, and I'd agree with you. But hey, Python has that ugly `a if x else b` statement that most people think should never be used— it's not exactly a unique problem!
you can't check in your vhd to source control to easily distribute. you definitely can with a Vagrantfile. 
&gt; and the two ways to iterate a sequence (using "for", or .each). embrace blocks, embrace `#each`, embrace `Enumerable`. we do not `for` loop here.
Ruby's grammar is based entirely on expressions that return a value, so instead of: if foo x = 1 elsif bar x = 2 else x = 3 end you can do: x = if foo then 1 elsif bar then 2 else 3 end Why is this important? Well, both Ruby and Python support lambdas (Ruby additionally supports blocks). However, all of Python's indent block structured syntax is a "statement", meaning it can't return a value. Okay, so what? Well, Python additionally doesn't let you embed statements inside of expressions, so it's impossible to do: f = lambda x: if x == 42: herp else: derp Okay, big deal you say, just rewrite it like this: lambda x: herp if x == 42 else derp ...but that is pretty much the limit of expressiveness you can have inside of anonymous functions in Python. Rubyists are known to write quite more involved programs using things like blocks, and particularly using blocks as "DSLs" for structuring code. Python's lambdas are significantly less powerful than Ruby's. The typical Python response is "use a named function". My response to that is "Haskell's indentation-sensitive grammar is so much better than Python's" ;)
That quote just put into words why I'm constantly irritated using Python. 
You should check out the whole article, and several of his other articles where he talks about ruby and other languages. They're very good
For me the biggest selling point with Ruby is the way you can chain methods, it just works wonder for readability and productivity: sentence = 'a short sentence' sentence.split.length # Ruby len(sentence.split()) # Python It it really useful when used with the enumerable method: modulu10 = -&gt; x {x % 10} my_values.find_all(&amp;:even?) .map(&amp;:absolute) .group_by(&amp;:modulu10) Yes, that there are more than one way two write something can make it harder to read, but it can also allow you to write really beautiful code. Also, the ruby case operator (===) is just a killer feature, making some functions some complex functions very easy to write and understand. def recursive_map(arr) is_foo_related = -&gt; x {['foobar', 'barfoo'].include? x} case arr when Array then arr.map!{|x| recursicve_map(x)} when is_foo_related then 'IT IS FOOBAR' when /hello/ then 'hello world' when String then arr.upcase! when 1..10 then 0 when 11..100 then 100 else nil end end a = [['nisse'],[1000, 1, 'say hello', ['barfoo']]] p recursive_map(a) #=&gt; [["NISSE"], [nil, 0, "hello world", ["IT IS FOOBAR"]]]
My guess is that when you set up RVM, your system is trying to run or require the files /c/Users/User/.rvm/scripts/rvm. So I don't use windows or RVM, but a good place to start is to open your sh.exe file and comment out the likes that reference that file. Another option, search all your files for '/c/Users/User/.rvm/scripts/rvm' if you can't "find" sh.exe. See here about advanced search on windows http://blog.superuser.com/2011/06/23/digging-deeper-windows/. If you find the file, you can look for the lines and comment them out or remove them, but be careful, because I don't know the pitfalls of windows/RVM you might encounter doing that. Edit: Any restarting your computer probably won't do anything, since these are scripts related to setting up your environment when you start your computer. Also, what kind of havoc are they causing? Just annoyance? 
2 dead simple ways: First, we can actually [instantiate an array that's pre-filled with a number of indeces](http://rubydoc.info/stdlib/core/Array#initialize-instance_method): `Array.new(100, 100)` The first number is the length of the array, the second is the default value. Use a lambda if its something more complex than a fixnum or string Alternatively, you can use [`fill`](http://rubydoc.info/stdlib/core/Array#fill-instance_method) to set any range of indeces to whatever you want: `[].fill(100, 0..99)` or `[].fill(100, 0, 100)`
This is probably not the right place to ask this (/r/learnprogramming comes to mind), but I'm having trouble getting anyone to explain the concept of lambdas to me. Can you please try and explain them using the simplest of terms? Thanks in advance.
It's exactly because `()` are optional that "class macros" look so natural, imagine if you had to do `attr_accessor(:x)`, ugh. Or worse still: `loop() { puts "hi" }`
&gt; modern, dynamic languages (Haskell, OCaml, etc) eh? i'm pretty sure haskell is about as far from dynamic as it gets (and i think ocaml is much the same)
How about ranges? ### Python list[i:j] i:j # File "&lt;stdin&gt;", line 1 # i:j ### Ruby list[i..j] (i..j).class # =&gt; Range
&gt; How is thing.nil? meaningfully different than the equivalent Python construct: (thing == None)? class NothingToSeeHere def nil? true end end 
All Your Methods Belong To Base!
 do_dodgy_thing() rescue true do_dangerous_thing() if authorized? pat_lion() unless lion.hungry?
Using Symbol#to_proc makes that simpler (without changing what the code does): answers = collection.select {|item| item.answer == 42 } .sort_by(&amp;:answered_at) .reject(&amp;:cheated?) 
I feel happier programming with Ruby. I feel more productive programming with Python. It's like an a free form jazz improvisation versus a marching band. 
There's always one :/
It's also about the difference between their respective toolsets; eg Rbenv Vs Venv, Bundler Vs Pip and Rspec Vs Nose. Ruby just seems to care more about the state and quality of the workshop.
 def print_foo(): print('foo') def run_func(func): func() class Foo: def to_s(self): print('foo') run_func(print_foo) run_func(Foo().to_s) Note that it skips two conversion steps.
For me it's the testing suites. My thought process works better writing Car.doors.should == 4 rather than assertEqual(car.doors, 4) Beyond that, I'm fine with either. Prefer Ruby, but work in a shop where most everything is Python or .Net so I'm using Python. 
 answers = sorted([item for item in collection if item.answer == 42 and not item.cheated], key = lambda x: x.answered_at) I believe that would be the closest equivalent. It uses a list comprehension with two filters (`item.answer == 42` and checking `item.cheated` for truthiness, a more specific comparison could be substituted such as `item.cheated is not False`) and passes the generated list to a sorting function using a lambda to define the sorting key rather than a 'block'.
A ~~strong~~ static type system.
I accidentally pasted them in, I got them to try and fix anther error and stupidly got them pasted in my command line. For whatever reason my computer says the rvm command is not found. It also says DL is depreciated, please use Fiddle. Which has something to do with rails 2.0 and windows. 
From PHP :) I miss: * http://php.net/strtotime (e.g. parses most date formats magically) * http://php.net/datetime (e.g. proper TZs, interval calculations) * http://php.net/streams (e.g. simple file_get_contents for HTTP POST) * http://php.net/spl.iterators (e.g. recurse/filter files in a tree) And most of all - presence of good [documentation](http://php.net/manual).
&gt; I discovered yesterday that my birthstone is apparently the ruby, so it has that going for it. Is your birthstone the python? No? I didn't think so. Okay did you just throw that in there to see if we read your entire comment? 
http://rubyjobs.io has jobs from multiple sources 
&gt; How is thing.nil? meaningfully different than the equivalent Python construct: (thing == None)? I'm perhaps splitting hairs here, but a nil object is always undefined and as thus it should never be == to anything. The python syntax bugs me. Maybe I've played with databases too long. null is undefined, not ever equal to anything. 
&gt; What is the meaningful difference between: &gt; &gt; thing == None &gt; &gt; And: &gt; &gt; thing is None a null object (IMO) should never be equal to anything. null is undefined and null should never be equal to null. "thing is None" I don't mind. I can't stand "thing==None" 
Some kind of pattern matching functions ala Haskell, tail call optimization, a simple syntax for contracts (such as argument types, valid ranges etc), named parameters for all the things (properly done), syntax tree access for blocks / lambdas (and a proper ruby parser in the standard lib for the matter of fact) - usefull to replace the functionally of macros and to further broken / unmaintainable but fun DSLs, proper serialization of the entire VM state (think smalltalk images), better ways to deal with exceptions (think lisp continuations for debugers - no pry with that gem doesn't count because its way to broken) 
As a regular Rubyist who is now working on a Python project, the things I miss the most are RSpec, RR, and Bundler.
Nil is not undefined in ruby. Edit: Also nil == nil is true in ruby. nil is actually a single instance of NilClass object. So object equality works out
I guess what I hate is people who use no parentheses at all. some_method_i_made_up and, all, the, params, that, run, on + other_random_method and, a, param is too terse 
Optional type annotation. Multiple dispatch. Improved `case` for pattern matching. Better libraries and documentation in general.
Haskell's pervasive first class functions, currying, and HOFs are really nice. I'm not sure they would really fit in Ruby, though...
You can share the vagrant box with other people from the team and save time of setting up for development, limit amount of things you install on your computer ( doesn't clutter your machine ) and with provisioning it becomes even easier to configure than installing by hand.
The left-to-right thing is a HUGE plus for me. When I showed a couple of my friends how to chain a bunch of method calls in Ruby they were honestly impressed. It's so clean and natural. Problem: I want to convert a number into an Array that stores the binary representation of the number. The Array must have a length of 20 (and it's guaranteed that the number has less than 20 bits in its binary representation). Solution: number.to_s(2).rjust(20, '0').split('').map(&amp;:to_i) This isn't a contrived example, this is actually something we had to do as part of a larger programming assignment.
linux meetups may serve in a pinch
&gt; Here's a typical python session: (...) I pretty much had the exact same experience today, hehehe. It's maddeningly frustrating. It's like asking someone a question, only to have them interrupt you after every couple of words.
Not really, it's about the interpreter/compiler's point of view. I'll illustrate with an example: def derp(x = nil) puts x end At this point, the interpreter doesn't know the value of x (nil = I don't really know how to represent this). def derp(x = nil) puts y end This throws an error, undefined method or variable y. The interpreter has never heard of this variable and doesn't know what to do - it knows what to do with nil. nil is what the computer uses for a syntactically valid value when the programmer doesn't know the value (yet) or doesn't care.
Haha, I do a fair amount in Java (and C# at my job, since we use only Microsoft tech) and that's what bothers me the most about either of them. `print` in python or even `printf()` in C is so much better than `System.out.println()`. C# is even worse because *everything* is capitalized and *very* wordy!
&gt;http://php.net/strtotime (e.g. parses most date formats magically) [Chronic](https://github.com/mojombo/chronic) (natural language time parser Ruby gem) &gt;And most of all - presence of good documentation. Yes, ruby-doc.org is terrible, but [Omniref](http://www.omniref.com/) on the other hand...
I know people will hang me for this, but I wish it had type-hinting and interfaces. Sure duck typing may be more flexible, but I think interfaces help when working with a team of developers. [Edit] Duck typing seems like you have to know what's going on inside the method to pass the correct thing into it. Isn't that violating OO principles?
&gt; Date.strptime or more flexible Date.parse Not nearly the same feature wise (it also does calculations, like [Chronic](https://github.com/mojombo/chronic), but faster/better and comes with PHP). &gt; Not sure what is missing for you. Time.now.to_i? Date/time calculcations that involve timezones with Ruby's DateTime? That's why ActiveSupport::TimeWithZone exists (which still doesn't compare to PHP stdlib DateTime). &gt; like: require 'open-uri' and open("https://path.com").read ? Yeah, try POST-ing something with open-uri. PHP's streams are more than that (more than just HTTP). &gt; like Dir? Dir is nice, but isn't it just `glob` (can't even control the ordering)? PHP's iterators (especially the recursive ones that allow returning parents or children first) are really nice. In Ruby you'd have to implement your own maybe using Enumerator. 
Snakes are creepy.
Yes, it's just text, and one of the commands in the vagrantfile is the location of the box to be downloaded (locally or over http). You can also use chef to provision the base box you just downloaded by pointing to a recipe url or provisioning inside of the vagrantfile 
I agree with everything you say except that python's standard library documentation is bad. I've had more problems with ruby's documentation than with python's, though perhaps it is just because of what i've used in both.
the majority of the ruby documentation is fantastic -- the problems I have is what happens when it is not there on the site? Turns out most the time its on some isolated website that is hosting the rdocs that you have to go digging around for, and usually those are of less quality or harder to learn from.
Ruby canon: http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/
To be fair, ruby's "make everything work" approach does cause many problems as well, causing code complexity for the interpreter and confusion when trying to learn the language. A lot of python's "do it my way or the highway" approach is because it is trying to keep things simple for newcomers.
Ruby is strongly typed. Do you prefer a static type system? Hard to do (impossible I would think) without a compiler.
You've compared ruby to PHP.... May God have mercy on your soul.
Back when I played with Ruby a lot and dumped on Python: * In Ruby, everything is an object, I like the consistency * no need for nasty _self_ "pseudo-OO design" * Prefer explicit block demarcation, Python's significant whitespace creates invisible problems * Python's package management seemed immature * Ruby's object extensibility makes elegant DSL code easy I haven't played with Ruby in quite a while now, and have been using Python a fair bit because we use Fabric for deployment automation, so now I have different opinions. * Ruby (and Rails especially) has far too much hidden automagic logic - downside of monkey-patching * pip is working rather well for Python * I've gotten used to significant whitespace, editors catch errors much better now * still hate _self_ in Python ;-) So now I can't say I prefer one over the other. I like both, but I'm currently focussing on learning Go.
Transpilers are becoming all the rage in JS land, with their main feature being a more rigid type system. :( Thankfully, I think Ruby is expressive enough that you don't really need a static typing system. Edit: Wrong words when they matter
I get a handful of calls a week just off of my LinkedIn profile.
Nice article.
Again, Ruby IS a strongly typed language. http://www.rubyfleebie.com/ruby-is-dynamically-and-strongly-typed/
Yes. Static is what I meant.
Sorry, I mis-typed. I meant &gt; don't really need a static typing system. I'll edit and fix.
Does ruby even have anything other than api docs for the standard library?
One cool thing about #nil? is that you get a nice shorthand for doing stuff with arrays, e.g. myarray.reject(&amp;:nil?). It's just syntactic sugar but I find it handy and clean.
The [entire list](http://docs.python.org/2/library/functions.html) of python builtins really bugs me.
I prefer ruby for scripts under 100 lines because it's fun and has text-munging abilities built more directly into the language. But python is my language of choice for anything that will be non-trivial to maintain, or is primarily glue around third-party libraries; the python ecosystem is more mature, more stable, and more documented.
Those are really valid points and i have to admit i underestimated php a bit.
Was using java on the weekend for global game jam. While i had to relearn how to use things like interfaces for passing around things like callbacks, I did enjoy the fact that I could do method &amp; constructor overloading, I could add or remove a parameter from a method, and everywhere in the code that was called, it would complain in eclipse. Things like tests and that help us in ruby to ensure refactoring doesnt break the app, but it is nice to work with a static language once in a while.
Grow up.
Long answer: I highly recommend you read [Everyday Rails: Testing with Rspec](https://leanpub.com/everydayrailsrspec). Short answer: I use both. FactoryGirl is for quickly generating and initializing ActiveRecord Models with known content. Mocks/stubs are useful for overriding methods within a test. For example, if I'm using the Twitter gem I want to (a) assert that I called the appropriate method on its interface, (b) not actually call the method because I don't want the side effects (a tweet or an error that the my credentials are wrong) to happen in my test and maybe (c) return a faked response from that method for further computation in my test. The analogue to FactoryGirl is a "Double", which is an object that implements the activerecord interface without actually being an actual activerecord object (and thus is faster because it doesn't have all the baggage); I don't use Doubles (my tests run fast enough as it is).
Yes, but in PHP, at least, you can type hint to an interface. So, you can make sure it can be anything that can spin something. Like this: interface Spinnable extends Movable, Graspable { public function spinWheel(); } class ConcreteImplementation implements Spinnable {...} class SpinService { public function doSomething(Spinnable $spinner) { # now we can pass anything that is spinnable in without it being an instance of a particular class $spinner-&gt;spinWheel(); } } In PHP's implementation, you can extend other interfaces, so if you need it to implement more than one you can by adding another interface that extends the others you need. With the duck-typing model, I have to look into the method to see what methods I need to respond to. This seems to violate separation of concerns, IMHO. With the interface, I know right off the bat what my object needs to be able to do. Without it, I have to guess until it doesn't break. Now, I realize that if my methods are doing crazy amounts of things, I'd be breaking the SRP. However, I don't think it's crazy to have a method need to call more than one method on an object being passed in. Ruby has respond_to? which is nice, but I'd like to see the ability to type hint to an interface. I'd even be ok with not being able to type hint to a class at all. It would promote "programming to the interface." So, it would be nice if they could use the respond_to? concept for some sort of capability-hinting mechanism.
I use both. FactoryGirl is fantastic when you are testing relationships between models or when you are doing integration/request specs and need models that you know are valid. I also use it to set up valid models and then I will change one aspect to be invalid, so that I can test only that part and not worry about unexpected problems. Mocks and stubs are extremely useful when you are dealing with multiple factors and you want to reduce your test to only your class, or only one moving part. Many of my tests use both depending on what most matters in that specific test or context.
Grow down? It was mean as a point of humor, how some people will rush to defend ruby regardless of valid points about PHP just because of the comparison. Can we get a "NO HUMOR" rule added to the sidebar to keep me in check? K, thx.
I would kill for list comprehension like in python.
Well aren't you just a badass.
Also you cannot capture list comprehensions as objects, they are more like a macro that is evaluated upon execution. Where as in Ruby, methods can return Enumerators.
One area where python wins in readability (IMO) is list comprehensions. I like ruby a lot, but one of my big bugbears is the lack of list comprehension syntax. I think the above example would look fantastic if it could be written as x.to_i for x in number.to_s(2).rjust(20, '0').split('') maybe I've just done python for too long (or it's because I'm from a maths background) but I just find map() and filter() syntax harder to follow.
I would recommend going entirely through the Hartl book and having a working application with some tests that you maybe don't entirely understand. Then reading a book like Rspec or Everyday Rails (I recommend the latter just because it's a quick, practical and inspiring read) and going back to refactor. TDD is hard because you kinda have to know what you're doing before you write the test. In the spirit of "if it hurts, do it more often" I highly recommend installing [Guard](https://github.com/guard/guard-rspec) which will run your specs automatically when you save your file. That way you can use your specs as an alternative to poking at things in the console: just add a `puts your_object.inspect` in your spec and save the file and it'll automatically run (just remember to remove it before you commit your code).
- proper package management - speed of execution
FactoryGirl and mocks/stubs solve two different problems. FG is great for replacing fixtures when you need a database filled with real-ish data. But it can't do things like stub your authentication methods during testing, for example.
Unfortunately, while the language may have that goal, the community doesn't. So if a user may have trouble understanding why the language does something the way it does, the community will berate them for simply asking questions
* Nested methods actually cause the inner method to be defined in the caller's scope: def meta def foo end end meta method(:foo) # =&gt; #&lt;Method: Object#foo&gt; In C and JavaScript, nested functions are local to their scope. * The many oddities of [String#split](http://rubydoc.org/stdlib/core/String#split-instance_method): 'hello'.split('') =&gt; ["h", "e", "l", "l", "o"] 'hello'.split('',0) =&gt; ["h", "e", "l", "l", "o"] 'hello'.split('',10) # =&gt; ["h", "e", "l", "l", "o", ""] * The naming could also be better. I don't understand why the [Base64](http://rubydoc.org/stdlib/base64/Base64) module defines `encode64` and `decode64`. Also, why is there no `String#base64_decode` method? * RDoc, the defacto documentation tool, has it's own markup syntax and isn't tag based. Although, there is [YARD](http://yardoc.org/) and RDoc recently added support for parsing Markdown. * While the RubyGems developers have been incrementally refactoring RubyGems, it still contains many odd legacy features (that will hopefully be removed in 3.x). For example, specifying the desired version of a gem via the magic `__X.Y.Z__` argument: rails __3.1.0__ new app # wat? * Python's list comprehensions are pretty cool, but I was able to implement [something similar](https://github.com/postmodern/combinatorics/blob/master/lib/combinatorics/list_comprehension.rb#L44-L80) using Enumerators.
Sure, if you are interested, here is the test and development section of the Gemfile from the last app I completed: group :development, :test do gem 'annotate' gem 'database_cleaner' gem 'factory_girl_rails' gem 'launchy' gem 'quiet_assets' gem 'rspec-rails' gem 'shoulda-matchers' gem 'timecop' gem 'vcr', :require =&gt; false gem 'webmock', '&lt; 1.14.0', :require =&gt; false end I'll be happy to explain any or all if you are interested. A short description: annotate adds meaningful schema comments to each of your models. database cleaner helps you escape transactional fixtures and is neccecary if you have any multi-threading in your tests, such as testing sphinx searching. factory_girl_rails you are already reading about launchy is a tool to help launch external programs from your tests, such as if you export a copy of your HTML and want to open it in a browser quiet assets makes those f*****g js and css lines in your log file go away rspec-rails you are already reading about timecop manipulates time objects so you can effectively test time-dependent code vcr and webmock are useful for creating stubs of external services so your tests can use real responses from third party services without actually being internet dependent.
cannon go boom
Ruby ranges are infinitely more useful, from what I can see. You can use ranges for case comparisons, as a replacement for awful globs of `&lt;` and `&gt;`, to quickly bulk out an array, and more.
Java takes the cake for widespread wordyness though `public static void main(args[])` bleh
I'm not sure how this is deserving of sarcasm - would you not use a different tool if ruby wasn't cutting it? It's not like all languages are perfect in every situation.
I don't care for list comprehensions. They read like someone with a stutter wrote them. x for x in x…
I didn't say this in my original wall of text, but I thought of something else today. Ruby is, in many ways, the son of perl. We have sigils, good unix integration, and great string slinging prowess. First of all, sigils. Perl had sigils to denote type. Ruby has sigils to denote *scope*. Which is fucking fantastic, because you never run the chance of using the wrongly scoped variable. Ask a first grader, and they can tell you `herp`, `@herp`, `@@herp`, and `$herp` are all different. Then there's unix integration. Wanna run a unix command? Well pick the way you want to run it. Want to replace the current process with it? You can do that. Want to run it as a subthread? Yup. Fork? Yup. Want to manipulate the input and output? Maybe sanitize something? Easy shit. Even if you *dont* want to use stock unix commands, you have a class that works as a proxy for many annoying features. No need to use system commands to just `cd`, just use `FileUtils#cd` Finally, string slinging. This is basically what perl cut its teeth on. Ruby is very very very good at it. You have all the methods of the `String` class, but then you have things like the ability to easily slice it using ranges. And then we throw in Regexp. Ruby uses the onigmo/onigmuro regexp libraries, which are absolutely fucking awesome. They do fucking everything. And they're fast as fuck. If you use ruby, you need to learn regexp. Simple as that. Not doing so is like getting a 16 burner stove and only heating up soup
I'm sorry you see that as elitist. Personally I see it as sensible.
so is static still an issue?
As near as I can tell: aSample = (0..99).map {100.0} and aSample = *(0..99).map {100.0} behave identically.
There's a [gem](http://rubydoc.org/gems/combinatorics/Array#comprehension-instance_method) for that :)
Thank you. In one sense I love all the ways that things can be done. It's a good way to learn about what is going on inside a programming language.
rails 2.0? ... upgrade that!
I suggest not using pre-loaders like Spork or Zeus unless you *really* know what you're doing. it's a bandaid for underlying pain that you should be feeling when testing.
undefined is an error. not nil.
Tons of things to learn, definitely. Welcome to the community :)
Actually ruby 2.02 not rails. I believe that's the latest 
These are my main two qualms with the language, too. It's like OO was an afterthought or something. Shouldn't the class be able to recognize itself??
Ah thank god haha. Latest version is 2.1 btw
Perhaps I should have given a specific example of the problem I have had with Python's standard library documentation ... At least at one point in time, I found myself dealing with [Python's `os` library](http://docs.python.org/2/library/os.html) quite a bit. The organization of that page is atrocious. Finding the method you want when you don't already know what it is named essentially means you have to just slowly skim the entire page hoping you find it. And it is a long page. And yes, I'm not a fan of the official Ruby documentation at http://ruby-doc.org ... especially when I was just starting out. But I found the YARD-generated documentation at http://rubydoc.info pretty early on and have been using that exclusively ever since. I find the documentation there to be *very* easy to read, search and understand. I have yet to find an alternative documentation source like `rubydoc.info` for Python. If one exists, I'd appreciate if someone could let me know for the times I am forced to maintain Python at work.
Maybe you should edit your original comment to indicate this then?
Unclean! Unclean! You forgot to type args.
[Procs can be curried](http://ruby-doc.org/core-1.9.3/Proc.html#method-i-curry)
Local meetups, mailing lists and personal contacts are the most common. For instance: https://groups.google.com/forum/#!searchin/urug/who$27s$20hiring/urug/4W2_9bN_QXI/YHj96_AwHkYJ
Run them each without the variable assignment for aSample. The splat one will throw an exception.
A lot of python veterans make this claim, but I just don't buy it. Python does things very differently from a lot of other popular languages. So "keeping it simple" means constantly looking up the "Python way" to do things. Conversely, in ruby you can probably write code in a style that's familiar to you and have it work right off the bat. I personally found that writing good ruby code was a breeze due to its open-ended nature. The best part is that unless you do something very strange, the code will be very readable, no after what your style.
I couldn't agree more. Working at a python shop has made me question myself as a developer time and time again. After a while I started to realize that I just don't like the "python way". It's not that my ideas suck, or my ability to write good code sucks, it's that I don't follow the ideas of the python community. Because of this I prefer to code in JavaScript or ruby. Two very open ended languages.
The point is for new people. If you are new to programming, there is no "your style" so it is easier if there is near one way to do things so you don't get confused when trying to look up how to do something.
True, but that is a community problem not a language problem.
So I guess you are complaining about the fact that someone took their own time to make a different method of reading documentation for the ruby community, but no one has for the python community? IMHO ruby and python have pretty much identical quality official documentation. It isn't really fair to compare a user created site to the standard documentation and say "therefore this language has better documentation". You might, though, say "therefore I like this langauge's community better". Not to mention that rubydoc.info doesn't appear to have any of the standard library functions... or if so, it is not immediately obvious where they are. Edit: Found the Stdlib link I missed in the top left! So yeah, I like that better than ruby-doc.org. Edit2: Actually, don't really like rubydoc.info for stdlib stuff. FileUtils, at least, is terrible compared to official docs. Another randomly picked one (cgi) has a high level overview but no in-depth information. Looks like devs aren't keeping up with yard-compatible docs in the stdlib :(.
I get that. If you're new to programming entirely, it makes sense
Well to be fair, the example you gave doesn't really do very much. Something like x^2 for x in list would be a more realistic application (and calling everything x is more of a choice by the author rather than a feature of the language). And to me, that reads quite nicely. As I said in my previous post, this could just be a mathematician vs. computer scientist thing though...
It's decidedly object oriented. It's not trying to be a multi-paradigm language. If I want to do something with an object, I nearly always call methods on that object to do it properly. I'm not doing `len(str)` or whatever. Of course, object orientation can act like a straitjacket in some cases, and in some of those cases, Python can sometimes be the better choice (but so can any language given the right situation - try and use a sensible tool for the job).
Pattern-matching means that you can dispatch based on matching some property. Many static languages have a specialized, limited forms of pattern-matching -- matching function overloads based on type, for example. That's how, say, C# knows whether to call `Foo(Int32)` vs. `Foo(String)`. However, true pattern-matching would let you match on any kind of predicate statement. A hypothetical pattern-matching structure in Ruby would look something like: (1..100).match do |i| pattern(i%3, i%5) { match [0, 0], "FizzBuzz" # match i%3 == 0, i%5 == 0 match [0, _], "Fizz" # match i%3 == 0, i%5 == anything match [_, 0], "Buzz" # match i%3 == anything, i%5 == 0 } end # =&gt; [nil, nil, "Fizz", nil, "Buzz", "Fizz", ...] 
First class functions and methods
You can also pass functions in Python. That doesn't mean that it's convenient and idiomatic.
Grand central dispatch from objc
- a straightforward ability for safe, performant multi-threaded code (e.g: to take advantage of multi-core) ** - better-performing garbage collection
Java Enums!
Hey, I do that! Parentheses, like many symbols, are not generally valuable documentation. I much prefer this: my_method foo, bar to this: my_method(foo, bar) And I even prefer `my_method foo bar` to `my_method(foo(bar))` or `my_method foo(bar)` What value does adding the parens add?
 $ perl -e "fork while fork" equal length
Of course it's sensible (at least sometimes, depending on details). But it doesn't answer the question. You know what I do with wishlists? I implement them (sometimes anyway). Wishlists are not necessarily wasteful pointless pie-in-the-sky unrealistic fantasy.
So it sounds like you already know how to program other languages. I would highly recommend [Metaprogramming ruby](http://pragprog.com/book/ppmetr/metaprogramming-ruby) and [Programming Ruby](http://pragprog.com/book/ruby3/programming-ruby-1-9) Metaprogramming ruby taught me more about the language, and Programming Ruby is a very good tutorial and reference.
puts (0...10).select{|x| x &gt; 3 }.map{|x| x**2}.inspect
My favorite Ruby book is The Well Grounded Rubyist. It's definitely not a beginners book but I think it would be good for someone with experience in other languages.
For what it's worth, the syntactic restriction can be worked around by splatting the `Range` within an `Array`. That is, `[*0..99].map { 100.0 }` works just fine.
&gt; proper package management Eh?
http://www.jruby.org
rubygems and bundler should merge already. I constantly feel like pip is superior in managing dependencies than rubygems. I like comprehensions better than array's map function. However I love how elegant Ruby block is. In Java or Python or Node, after GC kicked in... the heapspace shrink. Not so with Ruby. It keeps growing and growing. I saw this behavior in 1.9.1, maybe Ruby 2.0 is better. Ruby should just choose to use tcmalloc/jemalloc already. Both are better than regular malloc. I don't like how Ruby module sits on global namespace, I like how Python allows me to import module into local namespace. That said it allows easy monkey patching and that's handy for testing.
Both use inefficient recursive algorithm: sqeaky@Inflation:~$ time g++ -O3 fib.cpp -o fib &amp;&amp; time ./fib real 0m0.168s user 0m0.146s sys 0m0.020s 1 1 [REDACTED] 832040 real 0m0.011s user 0m0.010s sys 0m0.000s sqeaky@Inflation:~$ time ruby fib.rb 1 1 [REDACTED] 832040 real 0m1.054s user 0m1.041s sys 0m0.012s This is of course more noticeable for many *real* tasks. 
goto
From Scala I would love pattern matching and for comprehensions (which admittedly are just map/reduce but they're a really nice syntactic sugar for map/reduce). 
mis-typed lol. :)
I am a new programmer, learning Ruby at the moment, so you can take my recommendation with a grain of salt. Having said that, I am using [Pickaxe by Pragmatic Programmers](http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0). One cool thing about getting their book (if you get it digitally) is that you can update your editition for free. Their current edition covers ver. 1.9 and 2.0 of ruby. Best of luck learning Ruby!
strtotime: Why would I want specifically *English* support in a *core library*? datetime: Granted, Ruby's `DateTime` kind of sucks. streams: I don't get this. `file_get_contents` when used for HTTP POST is not all that simple, with setting up context and everything. Ruby has three different levels of simplification and you can take your pick, from the extremely simple to use open-uri (only GET requests), to Net:HTTP::post_form (POST, no headers), to full-blown HTTP protocol implementation. spl.iterators: Granted again, but I haven't found a use case where `Dir` was not enough for me.
yeah
on the first point, the method is defined in the scope where the outer method was defined, not the calling scope.
Ah you are correct. That is even more confusing. module Namespace def self.meta def foo end end end Namespace.meta Namespace.instance_methods # =&gt; [:foo] 
Pickaxe is Ruby canon and a primary reference. Eloquent Ruby covers basic to intermediate colloquial Ruby and is best followed with Well Grounded Rubyist, Metaprogramming, and the Sandi Metz OOP book. Single book? In your case, probably Eloquent Ruby, since it focuses on real-world colloquial Ruby. Someone in your shop will have pickaxe, and look at the rest at your leisure.
I knew I forgot something! I also read that as if a Dalek had said it
Pickaxe.
comefrom 
Yeah, the Pickaxe book is pretty much **the** book for learning the language. Once you're done with that, go grab a copy of [Practical Object Oriented Design in Ruby](http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330). I really like it because it helps you take that step from understanding syntax, to understanding simple and practical design in ruby.
I love ruby, but in this case it's not as readable or easy to write as Python. 
Oh, and if you want something entertaining from when chunky bacon and cartoon foxes roamed the rubyscape, [_why's poignant guide](http://www.rubyinside.com/media/poignant-guide.pdf) is fun.
[Micheal Hartl](http://ruby.railstutorial.org/ruby-on-rails-tutorial-book) has a great beginners guide that is free, he asks for a donation. I feel this book breaks down ruby into layman terms that eases you into the building blocks a beginner programmer needs to learn. Eventually, you'll build a basic social network. I'm also coupling my studies with treehouse, Code Academy, ruby monk, and ruby the hard way. All of these will also walk you through projects that will build up your programming chops so that you can start website portfolio. Just remember to practice a little bit every day; if not code, to read on the subject of programming. Finally this book doesn't even mention one line of how to code, but gives u you the philosophy of how a beginner programmer should approach programming; "apprenticeship Patterns, guidance for the Aspiring Software Craftsman. "
Why not both?
&gt; strtotime: Why would I want specifically English support in a core library? Because it's what you might need in a web app (PHP is *the* web language). `strtotime` accepts date formats *and* calculations (afaik it works correctly with 28/29/30/31 day months and DST too): date_default_timezone_set('Europe/Riga'); echo date('r', strtotime('6.6.2014 first day of + 4 months')); # Wed, 01 Oct 2014 00:00:00 +0300 No idea, how I would do this in Ruby, maybe with ActiveSupport or Chronic? &gt; streams: I don't get this. file_get_contents when used for HTTP POST Streams also allow implementing your own [wrappers](http://php.net/streamwrapper), which means you could for example copy a large file from/to HTTP/FTP/SSL/SSH/whatever with `stream-copy-to-stream` while being memory efficient (buffering).
True, but I don't think anyone has to get killed :)
Will definitely look into this, thanks.
This post helped a lot, really appreciate it. Looks like having Pickaxe as a reference is a good idea regardless of what other materials I take advantage of.
Both look good, Metaprogramming particularly looks very interesting. Thanks.
Cool, thank you for the info.
You're probably joking, but some people do abuse exceptions to achieve something similar. http://www.omniref.com/ruby/HEAD/classes/Kernel##catch
I think you meant `chmod 4777`, but oh well...
What version of Ubuntu and Ruby are you using?
My vote goes here too. Obviously there are some things about ruby syntax that complicate matters, but having procs/lambdas living in a totally different world from regular methods kinda blows. Specifically, I wish there was better/more flexible support for passing methods instead of blocks (like an extension of this sort of thing: `array.each(&amp;:foo)`). Interfaces would be cool too, but they don't seem very ruby-like. After using Haskell's type system (static with type inference and typeclasses), I want it everywhere. But I also want a lot of other Haskell stuff, and really I just want to be writing Haskell code instead of ruby code, but such is life. IMO function composition, partial application, pattern matching, and friends from Haskell make ruby's analogous constructs (such as they are) look kinda crummy. Obviously, though, being an OO language hobbles ruby's ability to provide functional elegance in exchange for some other powerful features, and I wouldn't be complaining at all if ruby didn't already have some powerful functional stuff going on. Obviously better support for threads is a big one, but I think already some implementations do a better job than others... jruby anyone? I had to use it recently to build a quick and dirty rails data API for a client, but didn't get a chance to dip into its more exotic features. Also, I think ruby syntax is a mess. Of all the languages I've used for any real length of time, ruby takes the cake for making me constantly question my style choices.
I agree, ruby documentation could be a lot better and this is one of PHP's strong points that tends to draw people to it. On the other hand, the ruby docs are a work in progress and they improve all the time.
Parens allow you to more easily modify the code later - say, by chaining a method call, or adding an argument.
Python's ranges can go backwards, which is handy sometimes.
rubygems is broken by design, i think there is a reason why there are hundreds of tools that tries to make it usable like: bundler, rvm gemsets and the like but they are far from perfect
i loved reading [Why's (Poignant) Guide to Ruby](http://mislav.uniqpath.com/poignant-guide/)
Obviously this is all subjective, but I find the Python version easier to read primarily because the Python version is a simple, pseudo-code'ish statement while the Ruby version is a chain of block methods. This is an example of how I use list comprehensions in Python: if not all(type(flag) in (unicode, str) for flag in FLAGS): return "'flags' is not correct type - all flags need to be unicode or str"` I just usually prefer the piece of code that resembles plain English more closely. Usually, ruby is better at achieving this than Python, but not in this case IMO.
I would highly recommend "Eloquent Ruby" by Russ Olsen. Rather than an exhaustive catalog of languages features, it describes the patterns and style that good Ruby programmers use to produce maintainable code. Unless you are a team of one, its invaluable knowledge and not covered well by any other Ruby book I've found.
Everything that everyone else said, except that I was a total beginner when I read it the first time and it put a lot of concepts about OO programming in place for me. It's one of only a few programming books that I've read several times, and each time through is amazing. There's so much to this language that you can't even absorb in one {time_period}, so to let it soak in and to get it in your head in practice and then to come back to the book 6 months later and fill your head up again, over and over.. I've been a goddam Drupal developer for so many years, trying to get out and into a Ruby gig. It's like I'm trapped in the wrong body or something. Anyway yeah, get that one.
innernet
Minitest + fixtures Unless you really want to: - Learn RSpec syntax/structure - Manage Factories - Bloat tests with setup code - Have entire test suite run 10 times slower When using Factories you kinda need RSpec for contexts. It's kinda neat, I admit.
&gt; Ruby-on-Rails posts are encouraged to be posted in the r/rails subreddit Right in the sidebar.
Excuse me if I am incorrect, but I believe that you intended to reference **/r/rails**. ***** ^(/u/blackdeth: Reply *+remove* to have this comment deleted.)
I think there's certainly breakage in rubygems' design, but I also think that whatever package management looks like you're going to end up needing something to do dependency resolution, batch install and environment isolation. What I'd *really* like is one tool *each* to do those jobs. Environment isolation is pretty much there with chruby. You *very nearly* don't need Bundler to do batch install, either. If you've got a simple Gemfile.lock, this *can* work: cat Gemfile.lock | tr -d '()' | awk '/^ \S+ \S+/{print "gem install " $1 " --version " $2}' | bash -s The only reason it doesn't is that the gems in the Gemfile.lock are listed in alphabetical order, not dependency order. Why Bundler throws that information away, I don't know. All I think you should really *need* bundler itself for is dependency resolution. That is, for turning a Gemfile into a Gemfile.lock. Anyway, those are my problems with ruby packaging at the moment. What are yours?
Encouraged, but not required.
This isn't Rails specific, it's just ActiveRecord specific. I use ActiveRecord in a few projects.
So while I love the idea (I always like more rake tasks that help me manage my projects, Rails or not) I do wish I saw some tests.
Like [this](https://gist.github.com/regularfry/8709301), you mean? :-) (yes, stinky global, I know...)
The problem i described is only one of the things that testing covers. IDEs wont know if you're breaking your behaviour. You need to either test that manually or have it automated. And yes, when wanting to refactor in ruby, having a test suite is rather essential for sure.
True! The problem is the code has a ton of side effects. We wrote the code before we read Refactoring and Clean Code, now we are making an effort to clean it up, and tests are included. 
Is Vagrant worth for a single developer?
Ruby is broken in ubuntu. Remove ruby via apt-get and then visit http://rvm.io/ and install rvm (although personally I've taken to building from source these days). Don't be tempted to use the Ubuntu version of rvm - it is also broken. If you want a decent gui toolkit you might be better looking at QT...
Great example; it's definitely possible to put it in Ruby! However, it's very challenging to do it in a way that supports _arbitrary_ predicates, which is the key here. Clojure, for instance, lets you do complex things like: (match [(java.util.Date. 2010 10 1 12 30)] [{:year 2009 :month a}] a [{:year (:or 2010 2011) :month b}] b :else :no-match)
I agree. Ruby has some awesome human readable ways of doing things, but list comprehension is just so much easier in Python. Less characters and easier to read.
I agree! View code changes a lot. I was actually just thinking of testing the footer and semi-static parts, but I'm not sure of the benefits when I can literally look at the page itself
Sounds like you're missing the ruby gems package. I agree with the other post here though - the bundled version of ruby on Ubuntu is really old. Deploy a newer one for your profile with rbenv or rvm instead.
Yeah, clojure has a much broader concept of "matching" than `===` in Ruby.
Yeah don't test the views. Integration tests I find tricky enough sometimes, when working with the DOM. But integration is super helpful for checking that partials, and rendering is all going swimmingly.
JRuby with Swing is also worth a mention. There are some toolkits that wrap all of the Java APIs for making Swing apps. Can't recall the names though.
Good point about testing the content itself, not the markup. I feel that I am doubling something that I am doing in the integration test already. Well I am adding tests to our fledgling code base (&lt;5K lines?). I am going with Cucumber for the BDD/integrations, and Rspec+Capybara for the model/controller tests.
My approach ... **What to Test** 1. All the expected elements are present and say the right thing 1. Variations based on data (more on this below) 1. What happens when there is no data For #1, I just test that the right things show up in the view. Does the view have a "Save" button? Then I check to make sure that it is there and says "Save". I don't try to ensure that it is in the correct position or anything like that ... but I do make sure that it is *present*. \#2 is about presentation of the data. Perhaps a blog post's title field is optional, but I'm supposed to display the published date when the title is blank ... a "display title", if you will. I test to ensure that the title is displayed on a record where the title is not blank and I test to ensure that the display title is shown on a record where the title is blank. \#3 is what to do when you have a table with no rows. Or sometimes you have a table that is supposed to always have eight items in it even when there is no data for two of the eight. I test to ensure that the right things show up in the view when expected records are not present. **When to Test** Same time as all the other tests run. They are included in every full pass. I additionally run a view's tests when the view is changed and I run all views' tests when any render template is changed. **Is It Worth It** An emphatic **YES**. View tests run really quickly so they are a quick indicator of at least a minimum of functionality. The way I write my view tests, I'm not guaranteed that things are laid out correctly or are the right color or anything ... but at least what I expect to be there is somewhere on the page and is recognizable. You mention integration tests and this is something I feel very strongly about. Integration tests are slow. The more there are and the more complicated they are ... the slower they run. If you're trying to cover all of your views' functionality in your integration tests, that makes them exponentially more complicated ... which makes them even slower. When tests are slow, you don't want to run them as often. When you don't run tests as often bugs slip in. When bugs slip in, bugs make it out to production. When bugs make it out to production, they cost you a lot more money. [And all for the want of a horse shoe nail ...](https://en.wikipedia.org/wiki/For_Want_of_a_Nail) I'm not saying don't have integration tests. Do have them, but follow the [test pyramid](http://martinfowler.com/bliki/TestPyramid.html) even in your UI tests. Make many, many more simple and fast tests (view tests) and fewer slower, end-to-end tests (UI integration tests). Additionally, integration tests are really hard to write well. And what I mean by "well" is that when an integration test fails, it should point *directly* to where the failure occurred so that you can fix it quickly. But writing an integration test that can do that takes a TON of logging and metrics and other stuff that is a pain and tedious and boilerplate ... which means your integration tests are more likely to have bugs in them, which decreases their value even more. You know what is easy to write that points directly to where the failure occurred? Unit tests, which in the case of the UI are view tests. Testing a UI isn't easy. But don't make it exponentially harder on yourself by cutting corners.
Cucumber is gross. :( Besides that, I second fixxeruk in using integration tests
 squares = (0...10).map {|x| x ** 2 if x &gt; 3} .compact p squares 
You should probably put a sleep in there somewhere so you're not just hammering the socket. 
Awesome! Very helpful.
Your milage may vary. You can test databases with a few lines of puppet, destroy a box and create a new one. You can test application stacks available online and turn it into what suits you. All this without polluting your own OS.
I trust the interpreter to always enforce the rules of order of executing statements on a line, but I don't trust developers (including myself) to remember those rules when typing out a line. Parentheses document for me the intended order of execution.
"zee"? Come on man, we can take it. Call it like it is.
If only the actual language docs were this good. The speaker doesn't quote his sources, but I'll take him at his word on these features unless I hear differently...
I am guessing you are on an older version of Ubuntu? Try uninstalling the default ruby package, and install the [ruby1.9.1-full](http://packages.ubuntu.com/quantal/ruby1.9.1-full) package to get 1.9.3: apt-get remove ruby apt-get install ruby1.9.1-full
[simplyhired](http://www.simplyhired.com/) is OK, but word of mouth and personal recommendations are far better.
Wait, no, nevermind, the version of Ruby that's installed is now *older* that it was before. grey@x60:~/ruby$ ruby -v ruby 1.8.7 (2011-06-30 patchlevel 352) [i686-linux] grey@x60:~/ruby$ Uh, what? 
BUT! RVM says I have the latest? Already installed ruby-2.1.0. To reinstall use: rvm reinstall ruby-2.1.0 Creating alias default for ruby-2.1.0. Recording alias default for ruby-2.1.0. Creating default links/files Okay, I have no idea what is going on anymore.
Tried that, no dice. :(
&gt; You don't always know where, when or why an object was defined, but sometimes you know what is expected of it. Well, yeah that's exactly what I'm talking about with the interface. I don't care what the thing is or where it came from, however, I do want to know that it can respond to a particular method call(s). The difference between the ruby model and the php interface model is that the interface explicitly defines what the method parameter must respond to. In ruby, you have to look within the method to know what the parameter must respond to. This violates, again IMHO, the concept of separation of concerns. With the interface being part of the language construct, in php, it's possible to define this. So, I don't care what you're giving me (can be an instance of any class), but I definitely want to know that it's going to do what I expect. With the type-hinting to interface, you can tell right from the method definition what you need. Think about type-hinting in an IDE; you would be able to see what the parameter needs to be able to do. So, my augmented-ruby code would be like this: class Prodder def self.prod(Prodable myProddableThing) myProddableThing.prod end end class Duck extends Bird implements Prodable def prod # whatever end end duck = Duck.new # I implement the prodable interface train = Train.new(Something.new) # I implement the prodable interface heyoo = AwesomeThing.new # I implement the prodable interface Prodder.prod(duck) Prodder.prod(train) Prodder.prod(heyoo) Now, as I would be typing out the method call, it would hint to me that this thing has got to be 'Prodable'. My main preference for this concept is that if you want something to quack like a duck, tell me that you want it to. Don't make me hunt for it. If a method requires a parameter object to respond to 3 methods, you'd have to hunt them all down. With the interface I don't even have to care what it does. Person implements Animal interface? Well, it breathes, but the method may need any number of other things from this object. I don't care what they are, but I know it can do it. Now, maybe there's a more ruby-like way to be efficient when coding to the interface, but I'm ignorant of that technique. [Edit] For external APIs, you could always just not type int it and use respond_to?. [Edit 2] Even then, I think I'd make an adapter class and just use the respond_to? there; leaving all my internal code to still use the type hinting. 
I've never written anything in python, but I do like some of the syntax you just presented. I like : if not whatever(): // vs php if (!(whatever)) # for like instanceof it would be nice... if (not $x instanceof Funtime) I also like : whatever() in (something, somethingelse) // vs php in_array(whatever(), array(something, somethingelse)) 
&gt; Obviously there are some things about ruby syntax that complicate matters, but having procs/lambdas living in a totally different world from regular methods kinda blows. I thought that was an optimisation choice. a `Proc` occupies more memory and is more expensive to call than a block. &gt; Also, I think ruby syntax is a mess. Of all the languages I've used for any real length of time, ruby takes the cake for making me constantly question my style choices. Oh? I love Ruby's syntax. What are some places that you particularly dislike?
One comprehension is okay. If you have two, it's a mess. Just like /u/yxhuvud, I vastly prefer Ruby's chained methods. unless flags.all { |flag| [String, Integer].include?(flag.class) } is readable enough for me.
A stub is part of setting up your test, while an expectation is what determines whether your test passes or fails. Every test you write will boil down to three steps: 1. setting up the state 2. performing the action under test 3. asserting that the result of that action is what you expected Stubs/mocks fall under #1: you are creating objects or defining methods that have known and explicit behavior that are necessary for you set up and isolate #2 Expectations fall under #3: you are writing an equality statement that, if it fails, will raise an exception and fail your test. 
You'll want to use a version manager like rvm or chruby to manage different ruby versions. Bundled handle gem dependencies. See [this post](http://rakeroutes.com/blog/how-to-use-bundler-instead-of-rvm-gemsets/) for more info. 
Jeepney.
&gt; I thought that was an optimisation choice. a Proc occupies more memory and is more expensive to call than a block. I'm not really talking about the distinction between `Proc`s and blocks; I'm more concerned with the distinction between `Proc`s and regular methods. Lots of other languages have first class functions, which means they have the ability to treat regular functions as objects and assign them to variables and whatnot, while in ruby, as far as I know, if you want to literally pass a function as an object it has to be a `Proc`. Edit: of course, `Method` and `UnboundMethod` exist, and are friendly with `Proc`-like syntax. But they're still fugly next to true first-class functions. I would be disappointed if the designers of ruby made the decision not to have first-class functions based on optimization concerns, given that so many other languages implement them with no problems. My first impulse is that they would be syntactically difficult to handle, since ruby's optional parentheses in function calls (and general lack of curried functions) would make it difficult to tell whether you meant to call a function or refer to it as an object. But, I haven't thought about it that much. It may also be the case that implementations of ruby tend to be "incompatible" with first-class functions, just as a side-effect of the language design in general. &gt; Oh? I love Ruby's syntax. What are some places that you particularly dislike? * Optional parentheses. Yes, I've written DSLs, yes, this feature sometimes makes for "beautiful" code, but it's my personal opinion (see above) that they may be more trouble than they are worth. My use case for ruby is somewhat unusual, though. * Curly braces vs. `do`..`end`. Why have both when they are (*almost*) completely equivalent? Again, this is just my personal opinion, and I'm sure many people love having access to both. In particular, I find method chaining off an `end` to be totally hideous, just aesthetically. * Did we really need another lambda syntax? I don't really care that you can't call `lambda` from `BasicObject`... it's ugly and it's redundant. * Since we're talking about ruby in comparison to other languages, it's probably worth mentioning that some other languages have much more elegant support for combining functions in flexible, powerful, and expressive ways. * ruby needs a better block comment syntax, unless there's something I'm not aware of. I could go on. I love ruby so much and I've spent so long with it that I'm necessarily going to have some fairly strong opinions about it that are nevertheless very much in the camp of "opinions".
None of those are official docs for Ruby itself, which is relevant since we were comparing the documentation for the Python and Ruby standard libraries.
Thanks, the answer does help. If you don't mind I have a follow-up question. Just to confirm if I got this correctly, in the RSpec book... describe MessagesController do describe "POST create" do &gt; Test for controller is divided into 3 parts: making the POST create do creating a new message, saving the message, and redirecting to the index. Assign :message as the "mock model". let(:message) { mock_model(Message).as_null_object } &gt; Make a new model and put it into the message variable before do Message.stub(:new).and_return(message) end &gt; Why is should_receive and post :create duplicated here? One has a message and one doesn't. My assumption is that the tests are each `it` is done independently of each other. So "creates" tests the sending of the create request and "saves" tests the saving???? it "creates a new message" do Message.should_receive(:new).with("text" =&gt; "a quick brown fox").and_return(message) post :create, :message =&gt; { "text" =&gt; "a quick brown fox" } end it "saves the message" do message.should_receive(:save) post :create end &gt; Assuming a post request gets through, the response should redirect. it "redirects to the Messages index" do post :create response.should redirect_to(:action =&gt; "index") end end end
rvm *should* have updated your path...did you read the bit about using the 'source' command and updating your login shell? source $HOME/.rvm/scripts/rvm And read the rvm install documentation https://rvm.io/rvm/install. To give you an idea of what of whats going on though, try: whereis ruby which ruby to determine where ruby is installed. Once rvm is installed properly though, ruby will live in some local sub-dir (if I recall).
The irony of having to pay in PHP for a Ruby conf can not have been lost
What does `which ruby` and `ruby -v` report?
Hm. Fair enough. I think those of us who plunge into the parensless world tend to learn those rules pretty quick (and very thoroughly).
I remember a course where the professor has given us the task to build a shell with Ruby. The sample solution was this two-liner: #!/usr/bin/env ruby exec ENV['SHELL'] Don't reinvent the wheel was my lesson learned. :)
grey@x60:~$ which ruby /usr/bin/ruby grey@x60:~$ ruby -v ruby 1.8.7 (2011-06-30 patchlevel 352) [i686-linux] grey@x60:~$ 
Inventing the wheel again is a great learning experience, which seems to be the goal here.
I was trying to avoid using a version manager just to make the box push forward until something breaks. I managed to figure it out after more fiddling, but I still learned quite a bit from the link you provided. Thanks.
Great write up. Doing this helps keep your code flexible and easy to test. If your using RSpec you can skip mocha and just use rspec-mocks.
Thanks! I've never regretted writing a fake, they turn out to be useful for so many things beyond testing.
Each `it() do ... end` block is its own test. The "unit" part of unit testing means that the test (the expectation/assertion/"should") is isolated from other tests. So you're really testing 3 different things (or really, you're performing the same action 3 times--once per each test--but creating an expectations on different *aspects* of the same thing). Also, these tests are a little confusing because in (A) and (B) you're setting up the assertion/expectation *before* you actually perform the action under test (`should_receive` is special rspec sauce that will raise a "test failure" if the expectation isn't true by the completion of the `it()` block), as opposed to (C) where you perform the action under test and then assert the outcome. &gt; A. This is testing assignment: are the proper attributes sent to the model object? it "creates a new message" do Message.should_receive(:new).with("text" =&gt; "a quick brown fox").and_return(message) post :create, :message =&gt; { "text" =&gt; "a quick brown fox" } end &gt; B. This is testing saving: does the model object get saved? (we're implicitly assuming the assignment happens correctly because we have the other test for that) it "saves the message" do message.should_receive(:save) post :create end &gt; C. This is testing that at the end of the request, it creates a redirect it "redirects to the Messages index" do post :create response.should redirect_to(:action =&gt; "index") end Arguably the first 2 tests could be combined into a single test ("save with correct values"), though the convention of specs is that you only have one expectation/"should" statement per test (`it()` block). Advanced: you're probably still kinda early in the rspec book, but you'll learn later other ways to do this that may seem less action-at-a-distancy. This is just trying to get you to understand the basics of mocks, stubs and expectations (and the different flavors of expectations like how `should` asserts directly whereas `should_receive` sets up a delayed expectation). 
 I have seen only 2 types of package management that works debian way there is a snapshot, and all libraries **have to** work together no matter what, the versions can not change, only every 1-2 years or so npm way (package management for node.js, https://npmjs.org/doc/folders.html) there are no shared dependencies, only when explicitly asked rubygems is in between with runtime dependency resolution LOAD_PATH clutter very hard deployments slow gem install and incompleteness, need tools to make it work 
Appears ruby 1.8.7 is still installed. Try using `update-alternatives` to switch to ruby1.9.1: # update-alternatives --set ruby /usr/bin/ruby1.9.1 Also, you can completely remove all ruby1.8 packages: # apt-get remove libruby1.8 ruby1.8 ruby1.8-dev rubygems1.8 
Martin Fowler has a great writeup [Mocks Aren't Stubs](http://martinfowler.com/articles/mocksArentStubs.html)
Minitest has that ability, but it's kind of difficult (you have to fiddle with things like TESTOPTS). Shameless plug: [I wrote a gem that makes it easy to run a test by line number in minitest](https://github.com/ntl/splot)
I thought you were thinking of something alone the lines of bane: https://github.com/danielwellman/bane
Oh yeah, I did build the shell, and found it quite intriguing. The profs point was that (a) other people have been there, (b) they most likely knew what they were doing. Given the time and community they have had to evolve their programs/libraries the chances of hitting severe bugs tend to be minimal. The shell example was a great one because there are lots of pitfalls (POSIX compliance, job management, performance, ...) not easy to cover with a few-line Ruby script. That said, I do of course rebuild little things now and then to make myself familiar with new concepts, libraries, frameworks, etc. - but not to release yet another incomplete shell :-)
FWIW; I use Cucumber to test integration of the system (the end to end of a feature) and RSpec for unit (model) and functional (controller) tests. I also use t for views but it has to be an exceptional view bit of code for me to test. Use mocks and stubs wisely along with Factory Girl. Hope this helps. 
The OP is more about building the shell than trying to release yet-another-shell, but I do think there's plenty of room for a new shell, and "there are lots of competing solutions" isn't a really good reason to discourage innovation, IMO.
The Ruby Way was my intro, that book covers everything. Still waiting for the 3rd edition to come out, when it does I would buy it asap as the 2nd edition was pure gold. Want to learn some real powerful Ruby? Raganwald's Book does that one well: https://leanpub.com/combinators
I'll have to check this. I was thinking about [VCR gem](https://github.com/vcr/vcr) which records example responses for specific API requests.
There are always bugs, it's naive to assume anything is flawless. Look hard enough and you'll find something. 
ruby5.envylabs.com
Parley / parlay 
on 2.0.0 gem list | ruby list-to-gemfile.rb &gt; Gemfile on 2.1.0 gem install -g Gemfile list-to-gemfile.rb: #!/usr/bin/env ruby puts "source :rubygems" STDIN.readlines.each do |line| line = line.chomp line =~ /(.*)\s\((.*)\)/ gem_name = $1 versions = $2.split(",") puts("gem \"#{gem_name}\", \"#{versions.first}\"") end 
http://rubyflow.com/
Hi, I'm the guy who runs Practicing Ruby. There was some good commentary over on the /r/programming thread, but I'd be happy to answer any questions here or hear your suggestions for how to make Practicing Ruby better. You can see the other thread here: http://www.reddit.com/r/programming/comments/1wn5i1/practicing_ruby_journal_moves_to_openaccess_68/
Of course its recommended. There aren't major changes that make the book outdated. The book is very useful to teach yourself how ruby works, not only the syntax, but how really are the things done with ruby. After read Eloquent Ruby I changed my view of Rails magic. I was able to understand much better how blocks, metaprogramming, etc were working with Rails. You'll be a better rubyist after read this book. You'll learn the "ruby way" and good practices. Compared to that, changes between 1.8, 1.9, 2.0 or 2.1 are not important. 
Another thing to note is that Ruby 2.1 is brand new. That if you're learning ruby, or any language, you should definitely approach it more generally mostly because some shops might still be using 1.8 (dear jeezuz I hope that's not the case though)
Just a simple, but sincere, thanks!
There is no conversion going on from hash to string. *hash* points to the string given by "\{ \"breakfast\" =&gt; \"eggs\" \}". No conversion. You have discovered substring matching with your example. hash["breakfast"] returns breakfast because your *string* contains "breakfast". If you do something like hash["breakdance"] =&gt; nil 
 &gt; string = "\{ \"breakfast\" =&gt; \"eggs\" \}" =&gt; "{ \"breakfast\" =&gt; \"eggs\" }" &gt; hash = eval string =&gt; {"breakfast"=&gt;"eggs"} &gt; hash["breakfast"] =&gt; "eggs" But please don't use eval to assign a hash to a variable.
Another way to understand what is going on: string = "\{ \"breakfast\" =&gt; \"eggs\" \}" puts string.class # =&gt; String hash = Hash.new puts hash.class # =&gt; Hash hash = string puts hash.class # =&gt; String puts hash == string # =&gt; true Here's the documentation for the [] method of the String class that you are actually calling : http://www.ruby-doc.org/core-2.1.0/String.html#method-i-5B-5D
I thought this post was a troll/joke... OP, I strongly suggest you learn about the 'types' of data and how ruby is 'strongly typed' because otherwise the next thing you'll be asking why "1" + "2" equals twelve.
Thanks for your thanks! This was a scary decision for me, so any positive feedback I get is reassuring.
I wouldn't really disagree with any of that, except to say that using .gems and rubygems for deployment specifically is, I think, an antipattern. To draw an analogy with Debian, a .gem isn't equivalent to a .deb, it's closer to a .dsc. Bearing that in mind, it's not surprising that using rubygems or Bundler for deployment is tricky to get right: it's solving the wrong problem in the wrong place. I do think criticising it for incompleteness, while true, misses the mark, though - after all, dpkg needs apt to be useful.
I knew there would be an easier way to accomplish this than manual parsing (though the manual parsing wouldn't be that difficult in Ruby, thanks to the String class' split/partition methods). Hadn't thought of converting the string to a serialised format and then parsing it, though. Mentally filing this away in case I ever need it later. :P
i do agree that bundler and rubygems is not suited for deployment still we need to deploy, and i havent found a good way yet incompleteness is a problem only when the tools that should complement are not very good, and diverse
I definitely agree with the top answer's comment, "Contact the maintainer first". I know that while working on PHP projects years ago Zend's own examples didn't conform to their all of their style guidelines at the time. So we dropped a couple of the trivial complaints from being evaluated. There may be a similar reason behind anyone's project. Even better than just fixing the style, find an issue that needs to be addressed, fix the bug or implement the feature, and clean up the style. But, submit any purely stylistic changes in another commit. Lead them to cleaner code by example and don't try to force them to change their habits on their own project.
Sorry but, where do I run that command? The console didn't work. I'm using Nitrous.IO
I think as a community we should move away from using the term "Best Practices." It doesn't really mean anything useful, and they're a moving target anyways. Besides, maintainability has less to do with appeasing tools like Rubocop and more to do with practicing refactoring and design principles. When I hear someone advocate for "Best Practices" in a discussion, it's almost always a tautology. COWORKER: "You should do it this way." ME: "Why is this way better?" COWORKER: "Because it's a best practice." ME: "Why is it a best practice?" COWORKER: "Because it's better." Contrast that to, for example, conventions in Rails that, when you follow them, win you a bunch of tangible benefits for free. If someone's project uses hard tabs, and it's a PITA to submit pull requests, then they lose out on contributions because of the friction they introduce. For that reason, wonky whitespacing styles should be a self correcting problem.
If that is vim running as the editor, press ":" and type colorscheme. If it's not vim, then I have no idea.
Using bundler to build a .deb works for me so far. I'm not totally happy with my setup yet, but it's better than doing a build on the production boxes.
I'm not sure of the exact theme (to me it looks somewhere between twilight and railscasts, you should check them out
I started thinking about case statements and thought that I may be able to get away with something fun, then I remembered they allow regex, ranges, and procs and thought it'd be too good not to include.
I had a pull request to remove all `then`s from RubyGems. I've been reading ruby with `then`s for over a decade now and I'm used to seeing it helpfully colored in my editor. It helps me see where long conditionals end, so I rejected it. Sure, it's purely arbitrary. Sure, I could get used to `then`-free code. That's no reason to make the change, though. The author continued to try to convince me, but it's just not worth it to me. Such a patch would also clutter up blame view making it harder to track down suspicious changes. (Possibly the worst consequence.) I don't make a habit of rejecting pull requests that don't have `then`s or other style mismatches unless they're egregiously large. 
from cubao XD
To what code are you referring to? If you mean Alakazam's tests, I think it's the first o second time I used them, just to track the observer.
https://github.com/RoxasShadow/Alakazam/blob/master/tests/alakazam_spec.rb https://github.com/RoxasShadow/ChainedExpressions/blob/master/lib/chainedexpressions/chainedexpressions.rb
I can't stand shit like this. Why would you splat instead of just calling `.to_a` so that the next programmers that read your code don't hate the fuck out of you?
Used one very similar at pivotal when I was there, iirc its called toland
Well, about alakazam_spec.rb, as I have said in the previous comment, it's simply because using global variables in that case is the quickest way to be sure that the observer does well its work. Regarding chainedexpressions.rb, you're right, now that I think about it I can safely use class variables.
From my answer on the same thread: Pragmatism over Dogma, always. Coding style guides are an especially insidious form of evil that draw attention away from architectural concerns towards frivolous nonsense like single/double quoting. Ask yourself: Does it really make a difference? They can be good up to a point, but the second you treat them with an almost religious fervor, you've gone too far. They're guidelines, suggestions, opinions, NOT facts. Should they just be ignored then? No, there is merit to using the tools to get a general idea of what needs to be looked at, but no more. It's a wonder how often junior types confuse opinion for fact.
Of the things I would say, I would switch to an MIT license and work on documentation. Look at the specs doesn't count, and at least when I read a Readme I'll pass it by if it's not clear and concise about what something is doing. Note that Global Variables are considered bad practice by most. As far as actually reading into the gems source, I'll see if I have some time tonight to do a bit of a deeper dive. Really though, do what you love mate. Don't take this stuff too seriously.
Downvote? Rather I'd like to say thank you. Anyway I have just commited the fixed version.
As an aside, let takes a block, so you can do whatever set up you need as long as the last statement is what you want to return. I mention it because some would use 50+ let statements because of not knowing that 
"correctly assume it’s intended for profiling. They couldn’t be more wrong." it buuuuurrrrrnnnsss
your gem name looks like porn is somewhere in the word.
Yeah, that didn't bode well for the rest of the article's comprehensibility.
haha well in that case, just have fun. There are still slots for lightning talks, so if you have something you want to share just ping the organizer . his email/twitter is at the bottom of the page
Because the splat is considered by some to be idiomatic Ruby and here is another place that it works.
good work op, good luck for you next gems.
&gt; I guess it's just weird for me why they put the post :create after in tests A and B and not before. Does it serve a purpose or "I can do without it". It's weird, but it's weird for a purpose. The `should_receive` needs to come first because it's setting up a "spy" on on that class/method, as well as an after-hook on the test (i.e. after that test runs) that checks whether the method that is being spied on was called with the expected arguments. If you called `post :create` first, then called `should_receive` the spy wouldn't see anything happen because the `post :create` was already called. &gt; Does the :message =&gt; { "text" =&gt; "a quick brown fox" } serve any purpose or is it just for the sake of the test? This is kinda an odd question :-) The test doesn't really do anything but assert behavior. So the test is asserting that if someone sends a message to the object under test with that hash, it will be initialized with that hash. So it's important if that's a situation you expect your application to handle, or not important if it isn't. But it's not something that can be answered purely from the perspective of testing.
This is so deliciously evil. Now to try and find real world uses for jollies. Either that, or make official sounding gems that auto rot13 strings. 
They're both Turing complete dynamic languages, just pick one despite what r/religion might say on the matter. Of course I'm Ruby biased, but it seems like you should do more homework on this as far as what suits you best. 
+1, but one has to remember a key secret in programming: everything is an opinion, you just have to pick which ones to give credence to. 
Pro tip: examples help, especially code examples. 
Totally. I think at this stage, I'm just trying to figure out where to start. I have a pretty detailed idea of the process, but I'm still slowly deciphering the limitations and quirks I'm designing under.
Realistically if you learn from 1.9.3+ the changes are trivial to catch up on. The goal is to learn the language, and that's the safest point to start. 
Did it: https://github.com/baweaver/izzy
I might try and make some of that in a gem. I've been on a Haskell kick and have been porting various things to Ruby. Pattern matching is slightly high on there. 
10.9 already comes with Ruby 2.0, though.
Do you get any error messages when you deploy?
Despite being posted yesterday, this is all pretty outdated advice. RVM has significantly lost traction with rbenv taking the top spot nowadays. Also, as /u/SimonGray said, Mavericks already comes with Ruby 2. Also, "15 minutes" to install Sublime Text (despite that being pretty irrelevant to install Ruby 2)?!
oh... oh god
Seems pretty similar to the way Django's views work (it's been about 6 months since I've touched Django though so I'm a bit rusty). While it seems like more effort than it's worth for my current projects which are fairly small, I'll definitely keep this in mind for future bigger projects. Also, you may want to cross-post this to /r/rails ;)
I came to the comments to find out if someone pointed out a common use for this. Nope. 
Be extra careful in cases like this or you can end up breaking the law of demeter. http://rails-bestpractices.com/posts/15-the-law-of-demeter
At my previous job, the project lead was a coding style nazi in addition to being a serious micromanager. He was horrible to work with. Entire series of commits would be rejected because a string was quoted with double quotes instead of single quotes or if I used used a unicode character in a template instead of the obscure HTML code for it (ie: I used ※ instead of \&amp;#8251;). Everything had to be exactly to his standards which weren't written down anywhere and changed depending on how he felt that day. He also had a hardon for lambdas (it was a Python/Django project). If I had two lines of easy to read code that could be shortened in to an unreadable lambda on one line, he'd reject my commit until I had a lambda. I'm so glad I no longer work for that company.
Did you already include rails_12factor gems? just following on this guide https://devcenter.heroku.com/articles/getting-started-with-rails4 , you should be fine. Thankyou,
Unrelated, but is Rubinius X still under development?
Having automated tests with good coverage is the *only* way IME to guarantee that a) they get used, and b) you can play *what-if?* refactoring. I've certainly been guilty (fairly recently) of Just Assuming that everything would Work Just Fine, only to find out, 25 changes later, that I should have gone left rather than right when driving north on the east side of my little coding island. That's why we use version control, yes? :-P
You're using `alias_method` quite a lot in Alakazam and therefore polluting the user's class with methods. I wouldn't do this and keep the public API as simple (and small) as possible. You could also get rid of all `if @observers` checks by using the following pattern: def __observers__ @observers ||= {} end and not accessing the instance variable directly.
When I learned ruby I was determined to pick up one of ruby/python/perl. Ruby was the one I tried first and I've not looked back since. I use ruby primarily for general scripting which is different from allot of people who tend to use it for web development. The thing I like about it is a very clean and concise syntax combined with a slight preference for encouraging a functional programming style. These two things are really what I fell in love with. If you are interested in general scripting the fact that it is easy to crank out one liners that are both powerful and (surprisingly) easy to understand is nice. Python would've been my second choice I think. I find it's syntax to be less elegant compared to ruby (totally a personal opinion though). I acknowledge that it is a truly excellent language. You mentioned that ruby let's you do things in multiple ways vs python which trys to convince you to do things in one way. I find having multiple ways of getting the same thing done philosophy freeing which is another reason I prefer ruby to python. Ruby does this while staying elegant.
It looks like the github project is still getting action. https://github.com/rubinius-x/rubinius-x
&gt; Pragmatism over Dogma, always. This is a very dangerous rule to have in your head, because some things that look like meaningless dogma on first glance are absolutely essential rules. Consider a rule like "never rename mutex variables; always lock mutexes at the top of the function in alphabetical order". Think about that rule for a second, whether you know why it would exist or not. Think about how stupid it sounds. Alphabetical order? Seriously? That literally *can't* matter. And we're banning renames to enforce it - how are we supposed to refactor this code ever? And yet, this is a simple (and thus easily sustained) implementation of one of the basic techniques of deadlock avoidance: lock ordering. If anyone ever breaks this rule on a project that uses it without very carefully cleaning up after themselves, the program will then be wrong. The same is true for things like licensing. If a project has a rule "No GPLv3 libraries", it could be because there's plans to Tivoize later. If it has a rule "no non-free-software licenses", it could be because you're planning to redistribute in a way that requires the project to be license-clean. In general, if someone went to the trouble of articulating a rule, make sure you know why before breaking it.
What's dangerous is misinterpretation. It's a perfectly safe rule once you realize what I meant by Dogma. 
Nice tutorial. IMO something like this is a perfect fit for the sidebar. Most tutorials take a lot of knowledge for granted, like using the Terminal app. This tutorial assumes no previous knowledge, which is great for people new to programming.
I would look at http://railscasts.com/episodes/114-endless-page-revised for inspiration as it may help you make your gem a bit more Rails friendly. It looks like you're infinite scroll gem is not much more than a javascript file in the vendor directory.
Yeah included in the production do state with gem pg
I'm having some trouble with methods. It seems that my variables don't work outside a specific method. For example, why does this: def ask print "&gt;&gt;" opt = gets.chomp() end puts "Here's some forest, where to?" ask if opt == "n" x = x+1 elsif opt == "s" x = x-1 elsif opt == "e" y = y+1 elsif opt == "w" y = y-1 end puts x puts y Not recognize opt in the if statement? edit: Alternatively, why does this not work? pmt = "&gt;&gt;" def prompt print pmt opt = gets.chomp() end puts opt
Variables have limited lifetimes. A variable used inside a method is born inside that method and dies when the method returns. The "opt" used in the method "ask" dies after the ask returns. Instead, do something like this: def ask print "&gt;&gt;" gets.chomp() end puts "Here's some forest, where to?" opt = ask # ... You could type "return gets.chomp()" but the return is unnecessary because in Ruby a method returns the value of the last expression executed. The second example won't work for a few reasons. First, the "pmt" defined at the top is not accessible inside the "prompt" method. Them's the rules, at least for Ruby. Likewise, the opt defined inside "prompt" dies (we say "goes out of scope") when prompt returns. That "opt" is a completely different variable than the one that's in the last line. Two different beasts with the same name (just like there can be two different people with the same name). Hope that helps. Edit: spelling.
If you want to have the prompt method be able to use different prompts, then you can have it take a parameter (also called an argument), like this: def ask(prompt) print prompt gets.chomp() end opt = ask("&gt;&gt;") 
That actually helps me a ton, thanks!
Doesn't look like anything is going on there other than an import to start the fork of Rubinius. That was a day ago, though, so maybe things are starting now?
One more hint: instead of the if/elsif statements you can use a single case statement: case opt when 'n' x += 1 when 's' x -= 1 when 'e' y += 1 when 'w' y -= 1 end You can see I also used, for example, "x += 1" instead of "x = x + 1". They mean exactly the same thing.
Is anyone using Rubinius in production? It seems exciting but unsure of adaptation.
Is this still going on? I'd like to join if possible.
is this going to connect to a running service?
https://github.com/adamwiggins/rush
You mean something like [Airbrake](https://airbrake.io/) or [Honeybadger](http://www.honeybadger.io)?
oh I have no idea if the built-in debugger supports remote debugging. There are [some gdb scripts](https://github.com/search?q=gdb+ruby&amp;ref=simplesearch) for debugging CRuby. You might be able to use those in conjunction with remote gdb debugging. Although, you should _always_ try to reproduce the bug in a testing environment and debug it there.
&gt; atombender opened this Issue 3 years ago :/
I do not see how this is better than using the built-in rails configuration files which also have cascading etc.
Wow, just... wow. Shitting on someone who's done an enormous amount of work and given it away. I feel compelled to say that Octopus has been a fantastic solution and I've used it for years now
Do you know of a service that's similar where you can run your own instance? I have internal corporate apps that I would love to hook into something like that but I in no way want to connect them to an external webservice.
Just goes to show, even when your complaint is valid, being an arse about it is not the right way to try and get it resolved. A little politeness goes a long way in FOSS. (On a sidenote, if fixing this bug is such a huge issue for you that you have to rewrite your app's persistence layer if it is not fixed then you can always put a bounty on it for. Say $100 or re-implementation costs / 50% )
Okay, I had a long drawn out discussion about IoC containers. I think those of us who learned OO through a dynamic language need a little more explanation before we "get" why someone would use this approach. I think you get this, but I wanted to throw this here for any other rubyist out there who has gotten as confused as I was. Basically, DI and IoC are important tools to help write more isolated, SOLID classes. Of course, this has the added benefit of making our testing easier/faster, which is great, too. When you move a dependency from one object to the calling object, you have now caused the calling object to depend on one more thing; it has to build out that dependency you're now injecting. If you apply IoC like this enough, eventually you get some objects up top that have to initialize a lot of state in order to delegate their responsibilities to their "lieutenants." IoC Containers are designed to simplify those calling objects by letting them simply ask an injector that knows how to build specific named containers. So if you had to know about a Logger, a Database, a ThumbnailWorker, and an EventSource, you can encapsulate those hard references in one place with an IoC container.
I'm honestly curious how this becomes a problem for people to the point where using a .env file and `ENV` aren't manageable. One of my apps has 82 lines in its .env file in production, and even at that point it doesn't feel unmanageable. The other advantage of just using a .env—especially with a tool like [foreman](https://github.com/ddollar/foreman) or [forego](https://github.com/ddollar/forego)—is that it makes them totally cross-platform: cat my_ruby_app/.env | grep FOO_API_KEY &gt;&gt; my_node_app/.env And now `ENV["FOO_API_KEY"]` from my ruby app is available as `process.env.FOO_API_KEY` in my Node app, or my Go app: os.Getenv("FOO_API_KEY") or my PHP app: getenv("FOO_API_KEY") ...and so on, as long as I've sourced that file in some way.
Youtube-style commenting comes to Github. So sad.
What the actual? Raising an issue for a different gem halfway through the thread. What a joke. Take it to the other guy's tracker.
Actual I got it it was all the database problem 
The new problem is the actual code get an error from one of my method 
what else did you expect it to do? I don't see that much help that can be provided for a developer on the back end.
Yeah but when one problem is solved something else doesn't work! The awesome thing about coding 
no, i mean something that allows me to connect to a running process and see what's going on there.
Why not just tail the log?
Errbit is Airbrake API compatible and hostable on your own server (or Heroku) - https://github.com/errbit/errbit
At `$WORK` we're in the process of moving various backend processes over to Rubinius. So far this process has been relatively smooth for us. Which reminds me that I should really blag about this at some point.
You have http://graylog2.org/
I see you are putting a lot of work into your gem, which is very nice of you. But you also wrote you don't use it in production yourself. To me this is would be a big red flag and most of the time I would choose a similar project which is used in production by it's maintainers. 
It's nice that you're trying to work on project. I'm sure there are many grateful people put there who use it. Though, working on something that you don't have any use of is a huge drag. You invest a lot of time and effort into something you're not interested in. That alone can be a major motivation killer. I'd suggest you finding a new maintainer for the project. You'll have a lot of time to invest into something more interesting for you. List it on [Still Maintained](http://stillmaintained.com/) and add a line into README about maintainer search. I know it's hard to leave behind something you've built but it would be good for both you and the project.
[NewRelic](http://newrelic.com/) has been a life saver multiple times for me.
Basically, using AJAX and Coffeescript, you can keep your views much simpler with the below code. This just seems like a less obtrusive approach. Both approaches accomplishes the same goals, but Ryan's approach is less obtrusive and more agile. &lt;div id="products"&gt; &lt;%= render @products %&gt; &lt;/div&gt; &lt;%= will_paginate @products %&gt;
You can not really compare those two examples because if you start to pack it into a gem you will have to modify the code a lot to make it able for a user set all different kind of parameters. 
It is possible to load controller- or action-specific JS and CSS. But be aware that you might not get the performance benefits you probably expect: if you have a single large file, the file is cacheable (thus ideally only requested once). Besides that, downloading one large file is faster than 20 smaller files, even if the total size is the same.
Makes you wonder how he reacts to getting a sweater in the wrong color for Christmas. What an ass. Good on the author for responding with tact and composure.
Just to clarify, when a method is defined it can be defined with a parameter. Prompt is the parameter here: def ask(prompt) print prompt gets.chomp() end Here we call the ask method passing in the argument "Choose your path.": ask("Choose your path.") So "Choose your path." is a string object passed in as an argument and `prompt` is the parameter (like a placeholder) that is used in the definition of the method.
&gt; A little politeness goes a long way in FOSS. A little politeness goes a long way in all aspects of life.
Or rather, you know, just don't.
I'd have a different perspective here, it can't be that unusual for someone to work on a gem initially because it fulfils a need in one of their products. If the gem gains traction but they move onto a different product, their may be no reason for them to use it in production. I'd suggest it's actually a good sign that the maintainer doesn't abandon it the moment they no longer directly need it.
For development? Absolutely not. It's a nightmare to maintain and work with. For your users in a production environment? Most of the time, yes. By the time you factor in http request cycles, broadband users benefit from asset concatenation and minification. Make sure your assets are cacheable, follow a predictable/modular pattern for css/js ([smacss](http://smacss.com/) is a good place to start), and concat/minify assets as part of your deploy process. 
This has already been done: https://github.com/railsjedi/rails_config
Yeap, also: using several different configuration approaches at the same time sounds like crazy talk to me, particularly when the proposed solution is "LETS ADD SOME MORE LAYERS, IT'LL BE OK"
Hi I was about to start playing with this but noticed on the blog post it's mentioned to support Localizations, but not a lot of details on the github page about utilizing it. We have a client who wants to be able to have different versions of content depending on the visitor's locale (he has 6 that he's chosen). Some of these are already models he can edit via ActiveAdmin (basic CMS type behavior). For other content he doesn't have a model representing it yet, for example - a button text "Sign Up" versus "Join Now" etc. The standard way to do this is with locale files : &lt;%=t 'sign_up_button' %&gt; and have your versions defined in each specific locale. The problem here is then he's going to need someone to modify the locale and push the new version. This seems like the pain point you're trying to solve, right? Thanks
man, it is a bad idea to reuse passwords in multiple place... especially when you just post that info for anyone to come across.
Thank you, very helpful. I'll be looking into those books!
I worked through Michael Hartl's [Rails tutorial](http://ruby.railstutorial.org) which was a great introduction to ruby programming and a bunch of web-app related stuff. Some of the tech is a teensy bit dated, but it's chock full of useful things and is a great way to get from no ruby knowledge to a place where you can sort of put together interactive web-apps.
It's been on Github for a while, if you know where to look. Generally, hip repos.
I always write things when learning, or else I don't learn it. Then I have someone more familiar with the language or library do code review to tell me what simpler or more idiomatic things I should've done.
Thanks! You were a big help today!
Or run [bundle-audit](https://github.com/rubysec/bundler-audit#readme) ;)
The problem is that bundle-audit depends on [ruby-advisory-db](https://github.com/rubysec/), which is not updated frequently enough. In other words, its database depends on GitHub pull requests. [Facets](https://hakiri.io/facets), on the other hand, uses automated scraping of CVE vulnerabilities. The downside of Facets is that it doesn't support OSVDB yet.
In that case a command line version of facets would be cool.
It actually already exists :) It's called [Hakiri Toolbelt](https://github.com/vasinov/hakiri_toolbelt) and it allows you to run `hakiri gemfile:scan` in your command line to achieve similar functionality.
Cool
Yes [ruby-advisory-db](https://github.com/rubysec/ruby-advisory-db#readme) is Open Source and anyone can submit a Pull Request to it (much like the majority of Ruby projects which we all depend on), and it was last updated 18 days ago. The problem with scraping MITRE or OSVDB, is often the versioning information is missing, outdated, incorrect, or cannot be parsed in to proper `Gem::Dependency` objects. I strongly suggest you not duplicate efforts and contribute to the ruby-advisory-db.
Yep. I googled propono to see if I could make an arduino post data this way and most of the hits agree with you.
Except that the maintainer responded asking for a failing test so he could fix it. Then didn't receive a response for a year.
Could be nice if you can have a badge on your project that checks your Gemfile and gives it a score.
The problem is that you still depend on other people while using ruby-advisory-db. Actually, in this case you depend on them at least twice: someone uploading a vulnerability to CVE/OSVDB and then updating ruby-advisory-db. My goal is to create a security monitoring system that doesn't rely on humans at all. As you said, sometimes versioning data in CVE and OSVDB is amiss. However, there are other ways to process vulnerability objects. E.g., natural language analysis of vulnerability descriptions.
Actually, OSVDB depends on us most of the time. When we discover a new advisory/vulnerability for a gem, we report it to OSVDB and they create an entry based on original information (usually within ~5 minutes). If OSVDB already has an entry, we double check the affected/unaffected versions listed. Most of the time, we the maintainers of ruby-advisory-db are the ones adding advisories to the repository. While it's nice that contributors submit Pull Requests, we do not solely depend on the time and energy of random contributors. &gt; My goal is to create a security monitoring system that doesn't rely on humans at all. The entire disclosure/reporting process starts with a human finding a vulnerability, reporting it to another human, so that it is fixed. If you want a truly automated system, then you want a static analysis / fuzzing system that finds new undiscovered vulnerabilities.
Okay, but you're going to get a reply like mine. I've done this both ways; keeping unit tests in sync even after refactoring has redrawn class boundaries, and letting outside in tests be "good enough" when they cover all the bases of their children. "Good enough" wins every time. Use a code coverage tool if you're having trouble finding the coverage for a particular line of code. Your implementation detail classes don't need a spec if the responsibility they perform isn't valuable outside the context of the larger problem you're trying to solve.
I'm pretty sure you don't want to do this to production unless your performance is of zero concern, or you've exhausted all other methods. It's more standard to use exception tracking and logging (and there are a number of tools to help with this) so you don't fuck with your prod environment's performance characteristics. 
I disagree with the premise of `Contracts`, because it's basically a method for enforcing type safety in an dynamically typed language. It's essentially littering your code with `asserts`. You're only trading one fiery explosion for another. I for one prefer a smaller stack trace. Type safety issues can happen, but with good testing it's well mitigated. I also feel that the argument of "it can improve error messages" is flawed, because good errors in ruby should be descriptive enough for developer to solve. With all that said, neat, I hope it's useful for some.
I totally did, and I totally respect this argument! In my experience, though, testing internal classes and private APIs can lead to brittle tests when you come back to refactor later. If I'm changing just the internals of a public API, I don't want to also have to fix a bunch of newly broken tests -- it's a lot harder to feel good about my safety net. I do like the idea I've seen of namespacing classes that are "privately" used by another class in that class's namespace. It makes it a little more obvious when a class needs to be promoted to a public API, and needs to be retroactively tested. Plus, if you're writing outside-in tests, it hopefully shouldn't be too hard to re-TDD the newly promoted public class, since you won't have to test *its* internals directly. This was a great comment, btw. You outlined the counter-argument really clearly.
Hate to be "that guy" but what vim color scheme are you using?
Have project in mind that is something you want to build for yourself. Having a goal has always been helpful to me when learning something new, especially if it helps to scratch an itch.
Looks like solarized dark. 
I specifically picked use cases that are more than just type safety, and can't be covered by tests.
I highly people recommend reading Avdi's book Confident Ruby: http://devblog.avdi.org/2013/08/26/confident-ruby-is-finished/ Rather than use something Contracts which goes against the spirit of Ruby, use the techniques in that book specifically the ideas around "confident code".
Why do contracts go against the spirit of ruby?
Well its not for me to decide that, but thats how i feel - i didn't mean to state it as fact. 
http://blog.bignerdranch.com/1629-debugging-remote-processes-with-pry-remote/ Is as close as you are going to get I think. It still requires breakpoint insertion before running. https://www.jetbrains.com/ruby/webhelp/remote-debugging.html is another possiblity
You can use omniauth alone if you don't need anything from devise. http://railscasts.com/episodes?utf8=%E2%9C%93&amp;search=omniauth The 3 omniauth screencasts about half way down are all free to watch.
Avdi's book eloquently explains why many statically typed purists end up feeling like they need type safety... basically, it's common for folks from statically typed languages to never really buy in to duck typing. His book teaches you *how* to leverage duck typing correctly, and once you do, you'll never care about "types" again.
Yes, its going on; but we ended up being held up recently and thus slowing the pace. Perhaps we can refresh and restart?
In the example where quite a few lines of code are added for the `Writable` class and contract, I'm left wondering why not just do a `File.writable?` check at the beginning of the method in question? It's less code, doesn't depend on `Contracts`, and accomplishes the same goal in an unsurprising way (that any programmer will understand, in any language.) Regardless of how the writability check is done before the query, the state of destination writability can easily change during the long query process. So nothing beats good test coverage with nasty test cases like that!
Can you give me a link to a repo with your project? Maybe the reason is that Twitter doesn't let you to read user email when you authorize by omni auth and devise fails to sign user in. I will be able to tell you for sure when I look into the code.
I typically use the pry gem to debug my applications. It essentially lets you set break points, where you can see what is going on, change values, etc. It's sort of like being thrown into IRB while making changes to the desired code. [Pry Github Source](https://github.com/pry/pry) Use binding.pry at the point to start debugging like so: # test.rb require 'pry' class A def hello() puts "hello world!" end end a = A.new # start a REPL session binding.pry # program resumes here (after pry session) puts "program resumes here."
Why not just just use a method to check the values, and call on it when the STDIN value isn't nil? I would try something like the following: running = true while running position = gets.chomp step(position) # Some other code, set `running = false` to end running end def step(position) case position when 'n' then x+=1 when 's' then x-=1 when 'e' then y+=1 when 'w' then y-=1 end end
IMHO, if you are only going to use Twitter to authenticate to the app, Devise is overkill. In fact, it is pretty much unneccessary. Using Omniauth for the Twitter OAuth implementation, then write a before_filter in the ApplicationController to check the session for a current_user and/or access_token. Devise is really only needed for user management (email, password) and user management functions (validating account, password reset, etc). Twitters will take care of all that for you. EDIT: Check out this Railscasts - http://railscasts.com/episodes/241-simple-omniauth-revised
Well, do you know html &amp; css, if not I'll recommend you learn that before you move on to sinatra/padrino then Rails.
I know a little bit of html / css but we worked with dreamweaver mostly. I haven't heard of sinatra.
PM me. I co-wrote an omniauth plugin for devise and should be able to help you out
It's an easier introduction to web development than Rails. Jumpstart Sinatra and few blog posts on Sinatra should get you going.
Agreed, I would review HTML/CSS and then move on to a Sinatra tutorial if you can find a good one. Sinatra is like a stripped down version of Rails.
Ok thanks!
Thanks I will try that out.
Is there any advantage over just doing this? $ irb irb(main):001:0&gt; require 'my_gem' =&gt; true 
Nifty trick. Cheers
Slightly less typing
Beginning Ruby by Peter Cooper would be a good next step, he walks through the core features of Ruby. Rubymonk is also really good for hammering in what you learned through codecademy. 
Why? Isn't having a global rvm the best practice? Is it because of security risks, or something else?
If your project uses Bundler, you can just use `bundle console`.
A short, unreferenced comment was placed on a still shot from South Park. I must immediately drop everything I do and bow down to its undeniably superior wisdom. 
I ditched RVM a while ago, but I thought if properly setup, there isn't really a problem, I know I had it setup that way before with no issues.
How about this? $ irb -Ilib -rmy_gem Hit `^R` and type `rmy_gem` to quickly find that commad again (*bck-i-search* in readline environments like Bash/Zsh but also Irb).
The only time I've actually used send in anger has been for dynamic message calls (stupid lewd pun about privates omitted) and then there's often a "better" way (tm).
use rbenv
Start with [learning Sinatra](http://ruby.learncodethehardway.org/book/ex50.html). Once you have an understanding how web apps work, then jump on [Ruby on Rails](http://guides.rubyonrails.org/getting_started.html).
Thank you. This seems to be the general consensus so I will do this as soon as I get home.
The lewd pun was rather odd in my book as well... not entirely sure what to think of that. Puns aside, I've used [send rather extensively when dealing with dynamic calls.](https://github.com/islador/Bowling/blob/master/app/controllers/players_controller.rb) Though I'll admit I've not gone looking for a better method, perhaps my use of send was merely compensating for my poor design. Do you have any examples of your "better" way you'd be willing to share?
go into the wild and think about, what you want to do, and don't ask others what should you do cause nobody knows what you do
I've started experimenting with something of a hybrid approach: * *Most* css/js content goes in a single large application.js/css file * Page specific content goes in a relatively tiny :page.js/css file Anything that is only used on exactly one page goes in that page's content file. As soon as I want to share it I push it into the application file. Your first hit on the website from a fresh cache will be "bad" (4 total requests for application &amp; page content and styling) but everything else will be significantly smaller page specific files. To me this allows you to extend the rails structure out into your js/css and maintain most of the benefits of caching shared assets. It also forces you to think hard about how you can reuse something so you aren't bloating up your page specific content. The other option is to wrap things up such that your page specific JS isn't self-initializing and relies on the page's html content to run some dedicated init function. I'm sure that works well enough, but my experience has been that disallowing javascript in html is the only reliable way to keep the two from becoming hopelessly commingled. 
I'm by no means a rails expert (I don't really like rails if I'm honest!) but "Fat models, skinny controller" was my first thought. A lot of the code in that controller appears to me to belong in the score_card model, which would then remove most of your uses of #send. I'm really loathe to offer advice in a framework were I am at best barely competent in, but If I was writing that controller, the controller logic would probably be two lines (+error handling): @player = Player.find(params[:player_id]) @player.update_score(params[:throw_id], params[:score]) with the player model passing along the message to the score card to update itself using the throw_id and score, and the score_card model having most of the "business" logic so as to update and record the scores for each throw, returning the totals. Oh, in the model I seem to recall you can use _update_attribute(name, val)_ or _self[:attribute_name] = val_ .... but I suspect both of those use #send under the hood though, so you probably will use #send, just in disguise.
Where do you yourself store project settings such as API credentials, and how do you restrict access to specific pieces of information in a role-based system? Asking honestly.
Wait, is `Hash#has_key?` really informally deprecated? It's a pretty common convention, I don't see it going away anytime soon.
Whilst *truly* I can't help but admire this, something in me feels like I just glanced a manifestation of Cthulhu. _"this is the first time I've not been able to shoot myself in the foot."_ using sourcify http://rubydoc.info/gems/sourcify/0.5.0/frames: _"Performance is embarassing for now"_ I think the reason he can't shoot himself in the foot is his leg is missing! Brilliant and terrifying!
Yep - http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-core/43765
Build all the things!!! Seriously though, practice your ass off. Build a ton of applications. Throw them away. Try again. One thing I've learned in my journey of self teaching is that there is no substitute for getting your hands dirty with the code.
I use Environment variables, the reasons for which can mostly be found [in the Twelve-Factor App manifesto](http://12factor.net/).
Well yeah I agree with you that storing configuration in the environment is a better approach than using a YAML file, but that's a more specific objection, and this post is more about the general concept of controlling access to settings with role values stored in an external store of configuration values (whether it be via YAML or env vars). You could rewrite this blog post and use env vars, and the point would be the same. The reddit topic could probably have a better title, but it seems that that's the problem he or she is actually solving, if you read the code and the post.
That's a different argument, I was simply answering what I use for them. It's also not the same using yaml or env variables, YAML is actually pretty powerful because it can represent random data structures and so because of that specification gems that implement yaml need to create objects in Ruby when parsing those yaml data structures, and as Ruby uses a global namespace for everything you can see how this can become a problem, this is the origin of some of the most dangerous exploits in Rails that popped up last year - an attack vector which allows arbitrary code execution, all this is because YAML is way more complex and does way more than just storing hashes or array of data, which is why is a bad idea to use yaml for configuration variables. Yaml is more complex than what it's used for, which is bad, env variables are much simpler. 
I'm not familiar w/ Code Academy, but if they didn't cover it, I'd suggest learn how to test your code with unit tests (Test::Unit, Rspec, minitest, whatever tickles your fancy). Also, again if it wasn't covered, learn how to properly document your code. It may sound basic, but these are great skills to have &amp; will make you more marketable as you seek employment.
Is there a way to run rspec with -w to show deprecations?
This is actually one of the best explanations I've seen for fat model, skinny controller. Perhaps it is because I understand it well enough to comprehend the benefits it would bestow in this situation. Thank you, I'll consider this concept in my next iteration. I have one more feature to add to the app itself before it is full featured and I can go rewriting the guts.
If you are using [rubygems-tasks](https://github.com/postmodern/rubygems-tasks#readme), then you already have the `rake console` task. You can even [configure](https://github.com/postmodern/rubygems-tasks#examples) which REPL it uses.
And then alias that to irb_my_gem or irb_mg.
Read [The RSpec Book](http://www.amazon.com/The-RSpec-Book-Behaviour-Development/dp/1934356379) (PDFs available online if you look). Testing and agile programming is something you'll want to learn from the get-go. Hartl's book also focuses on testing and introduces many tools used which was extremely beneficial when I started learning.
Thanks, they didn't actually go over how to test the code so I am researching that now.
That is the problem. I now know the language but not how to do anything with it.
Thank you. I am looking for it now.
Neat, and now `hash["breakfast"]` returns the `"eggs"`. That's really cool! YAML and JSON are the kind of things is was trying to find but didn't know about, thanks!
&gt; Can I ask why you would want to do this? To be honest, I just started manipulating data structures for it's own sake after a Code Academy lesson. For example, I also created some code for transforming a hash into an array for fun: stomach = [] meals = {"breakfast" =&gt; "eggs", "lunch" =&gt; "sandwich", "dinner" =&gt; "stew"} meals.each do |x, y| puts key puts value stomach.push(x) stomach.push(y) end puts stomach I don't know if stuff like this will ever be useful, but maybe it'll come in handy as I learn more Rails. In the meantime, at least now I know about the YAML and JSON libraries thanks to you nice folks at /r/ruby.
Yeah, I got about 75% done with my first stab at this, and started thinking the same thing. I came across the rails casts, and have already taken a lot away from the one you posted. I honestly feel like I'm at a point where it'll be more trouble to go and dig Devise out of my app, but I could be way off 
PM Sent!
I want to say this was my first time posting to /r/Ruby and for somebody that's brand new to the language, and really brand new to modern programming, ya'll are awesome!
My reaction to this article: "Haven't heard of refinements before, let's see where this is going. ... Ok, that's interesting. ... Wait, that seems a little odd. ... NOPE."
So what new toys do we get from this? brandon = Person.new('brandon', 23, 'm') **Matchers:** brandon.matches_all? name: /^br/, age: (20..30) # =&gt; true brandon.matches_any? name: /br$/, age: (20..30) # =&gt; true brandon.matches_none? name: /br&amp;/, age: (30..40) # =&gt; true **Multi Matchers:** longer_than_5 = -&gt; n { n.length &gt; 5 } greater_than_20 = -&gt; a { a &gt; 20 } brandon.matches_all?( name: [/br/, /an/, longer_than_5], age: [(20..30), greater_than_20] ) **Multi Object Matchers:** class Array; include IzzyArray end [0,0,0].all_are :zero? # =&gt; true [0,nil,'foo'].any_are :zero? # =&gt; true [0,0,0].none_are :nil? # =&gt; true
They had an article recently about the null object pattern. I really dig it, and this extension if it. Logic belongs in the model, not the controller. 
Look in the lib directory first. There you will see_(usually) one ruby file that sets up the business logic for the gem. The meat and potatoes should be pretty straightforwardly organized in sub directories of this folder.
Sounds like [duck typing](http://en.wikipedia.org/wiki/Duck_typing#In_Ruby)
In the `send_to_feed` example I think I'd prefer to catch the `NoMethodError` than implement a useless method on `EmailUser`. Even better (depending on the context) would be to have more abstract `user.notify(contents)` that could actually do something for both `EmailUser` and `TwitterUser`. Or if you *really* need to specify the use of a "feed" then make a separate object for it. **EDIT** Or for a more Rubyish way have a `Feed` module that can be mixed into your `User` objects.
Running ruby with warnings enabled is futile since practically every gem out there ignores them. so your output will run to hundreds / thousands of lines of warnings. Enjoy sifting through that.
It's worth noting that in development, by default, Rails serves the assets as multiple files and unminified. Makes debugging easier.
I could try to explain exactly what it felt like, but the words would be so horrific and unintelligible that their mere utterance would drive one to madness. This chronicle is all that remains of my ordeal. 
So, to start, what I do is I set Vim as my shell editor and then I use the 'bundle open' to inspect a gem. My Vim install has the Nerd Tree plugin and it makes it really easy to browse the gem's directory. This really helps when you come across an exception raised from a gem and you want to inspect that exact block. But, yeah, jsf8 is right. There will be a lib/&lt;top_level&gt;.rb file and then a lib/&lt;project&gt; directory. A common design practice is to build out modules under that lib/&lt;project&gt; directory and then require them in that &lt;top_level.rb file. 
True - obviously we're supposed to assume there's a lot of extra state that differs between a Twitter user and and e-mail user, but defining two extra classes, a (presumable) additional layer of inheritance and one of those classes *merely to implement a no-op* is a terrible waste of effort and a pointless increase in code complexity. The general pattern is a good idea, but the specific example is a terrible one.
Curious, what's something (specific) you took away from Haskell and applied to Ruby?
There's more to architecture than MVC. All your business logic does not belong in "models".
+/u/dogetipbot 100 doge
This article is a little old, and doesn't really talk about Thin, but has some good starting info. https://www.engineyard.com/articles/rails-server Edit: as for my personal opinion, I use Passenger for production and Thin for development.
I didn't say "all", and I think it's still fair that logic doesn't belong in the controller, which is where it ends up a lot of the time. 
But again, that's the problem with all examples. They probably can't provide the full example they had (complex, legal issues, whatever), so with a simple example everything looks like over engineering.
Been working with Clojure a lot recently and I'm pretty impressed. Perhaps the greatest benefit of learning different languages is that you are less likely to hammer everything with Ruby regardless of whether it's best suited for the actual problem you're trying to solve.
Delivery logic belongs in the controller. Business logic belongs somewhere outside of your framework. It certainly doesn't belong in a model.
Cool beans. I'll have to give that a shot, I actually just stumbled across bundle open and I'll use it with vim. Thanks!
I like this, but I struggle when implementing this with view code like in Example 1. While it seems harmless enough to have `#welcome_message` in your model, what about places where I have several different buttons that I want to place on a form based on the state of the object, and then another set of buttons if it's accessed by an admin? Certainly my model shouldn't have to know anything about what controllers access them, ideally they wouldn't even need to know they were in a Rails app. Like just about any other pattern or practice, the answer of when to implement "Tell, Don't Ask" is "It depends." I feel like I have decent intuition on where **Separation of Concerns** between my models and views overrides **Tell, Don't Ask**. But it's more of a "I'll know it when I see it" sort of thing, rather than being able to articulate my internal heuristic. So I'd like to know if anyone else has run up against that and what their thoughts are. Or maybe there's another pattern altogether that I don't know about which has a better tradeoff than either of those two. Maybe something like the **Decorator** pattern?
UrbanDictionary is on PHP, according to the URL of [this link](http://www.urbandictionary.com/define.php?term=test) and Twitter is based on Scala, now.
*Here's the Urban Dictionary definition of* [***test***](http://www.urbandictionary.com/define.php?term=test) : --- &gt;A process for testing things --- _This is a test message_ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/ruby/comments/1kv9n3/top_10_sites_built_with_ruby_on_rails/cf8mzgb) ^| ^(**Summon**: urbanbot, what is something?)
means ... understand a gem, after reading [make your own gem](http://guides.rubygems.org/make-your-own-gem/) you could not only read a gem, also you could write your own ;)
"Model" doesn't necessarily mean "something that inherits from ActiveRecord::Base". It could be a decorator used in the view that delegates to your database model, for example.
As I already replied [elsewhere in the thread](http://www.reddit.com/r/ruby/comments/1x4p3v/tell_dont_ask/cf8nq0x), there's more to a rails app than your database models, controllers and view templates. Stuff like decorators that are specifically tailored to a specific template have a lot of power in cleaning up your views.
How do I claim my space dollars?
Thanks! I was looking for something like this.
I wouldn't call it more elegant, but you can use &lt;=&gt;. a&lt;=&gt;b returns -1,0, or 1 for less than, equal, or greater than. Add 1 and you get 0,1,or2. Switch, or use that as an index results=[result_y,result_z,result_z] results[(integer_a&lt;=&gt;integer_b)+1] or in one line [result_y,result_z,result_x][(integer_a&lt;=&gt;integer_b)+1] 
If your business logic isn't in AR and it's not tied to rails, why bother putting it in `app/models`? Why not just keep it separate like it belongs? MVC is a *fantastic* design pattern. It's just a piss poor model for architecture in any reasonably large system. It's a delivery pattern and that's it.
Where would you put it instead? `app/models` is a pretty unsurprising place to put business logic.
a &gt; b ? x : ( a &lt; b ? y : z ) edit: I see lyrqdi suggested the same but sans brackets. 
google it. Sinatra is perfect for the Ruby beginner.
In a gem that you completely control. You then inject the deps you need from the outside, thus isolating your business logic from outside change (like the framework). Your tests will run in 1s, and you can easily upgrade your delivery framework without worrying if it broke your business or even move it to another one completely if you want. I moved one of our APIs away from rails to sinatra in 2 days.
Thank you I will be looking this up.
Reply +accept to /u/dogetipbot to accept it! You can withdraw to an address by creating a wallet on your machine (www.dogecoin.com). You can find out more about Dogetipbot at http://www.reddit.com/r/dogetipbot And you can register to make doge tips by sending +register in a pm to /u/dogetipbot . Enjoy the Doge! 
I think that's fine, but to be honest, there are usually some domain models that aren't ActiveRecord models that I prefer to put in `app/models`. It's a style thing, and something is wrong with someone's dev environment if they find it unmanageable.
Nice, although I typically prefer Webrick for development because it's the only option that really plays nice with debugger/pry. 
I'd like to see a full fledged, non-trivial rails app that runs it's entire test suite in 5s. Notice I said "reasonably large system" above. I'm not talking about a dumb blog or some stupid website that doesn't actually do anything. I'm talking about an actual application for a business that is fairly complex and has many use cases that are non-trivial. &gt; don't have to pay the overwhelming amount of indirection It's hardly overwhelming. &gt; You just need to know ruby well. Again, please show me how I'm doing ruby wrong. I've experienced lots of projects that use "the rails way" and just end up being a big pile of unmaintainable shit.
&gt; The key to understanding the spirit of what Uncle Bob was saying I know what he was saying. I've actually worked with him before and it's not about "the spirit", it's about actually writing maintainable systems.
A lot of non-system things are written in C. Ruby is an example :)
Awesome post, but we may need to bump the age requirement to 6 for this ELI. ;-)
The part of the rails app that you'd extract to your gem is easy to get running in rails in 5 seconds. I'm also not saying that you're doing ruby wrong. Your way is fine, it's definitely working for you. I'm just defending putting files in `app/models`. It's a practice that is very scalable. Yes, a lot of rails apps are really terrible. But that doesn't mean that it's impossible to write a decent app with a fast test suite in rails, following rails conventions for the most part.
&gt; The part of the rails app that you'd extract to your gem is easy to get running in rails in 5 seconds. Indeed, in the beginning it's usually quite sufficient to just stick that stuff in lib. The problem with that though is that you have rails at your disposal there and it becomes very tempting to start including rails features directly in your business logic classes. It's even easy to do it accidentally! &gt; write a decent app with a fast test suite in rails, following rails conventions for the most part. Again, I'd like to see this app that does this. A large scale app with complex business logic written exclusively in rails/models that has fast tests.
&gt; Sub 5 second test suites are not hard to achieve even for rails apps with a non trivial amount of code. How? For most of the rails stack I need to require `spec_helper` which loads rails. On my machine that already takes 4-5s. Even if it takes only 1s you don't have much time left after that. In a typical rails application testing some of your model code (scopes, after_* hooks) would require hitting the database and if you have a fair amount of models you hit 5s within just a few tests. Ruby being one of the slowest languages doesn't help either. tl;dr: I don't believe you.
According to RES I've already upvoted you 7 times. You're fighting the good fight! 
&gt; You should also be aware of Passenger, which is kinda sorta like Unicorn, except it gets compiled into the webserver as a module, so you don't have to do any proxying or daemon management. The downside is that when your http daemon restarts, so does your web app. Almost. Passenger actually has three modes: an Apache integration mode, an Nginx integration mode, and a Standalone mode. The Apache and Nginx integration modes are pretty much how you describe it. The Standalone mode runs standalone, outside Apache/Nginx, and works similarly to Unicorn. You can put it behind an Nginx reverse proxy and restart the two of them individually. See http://www.modrails.com/documentation/Users%20guide%20Standalone.html#_installing_passenger_standalone_behind_nginx &gt; Passenger will be easiest for you to start with, but you'll have to pay if you want some of their advanced features like rolling restarts and error-resistant deploys, which you get for free with Unicorn. As far as I know Unicorn (and Puma, and Thin) don't have error-resistant deploys. If things go wrong you'll have to detect that, and fix that, yourself. I believe this feature is only in Passenger Enterprise, though I'm not sure how Torquebox handles it.
Preloader. Hitting the database isn't all that slow with transactional fixtures. I've noticed gems like FactoryGirl and Fabrication introduce quite a bit of slowness. You have to be judicious about when you decide to actually hit the db. If you're in callback hell, you're not only writing bad tests, but bad rails code. And, really, when I mean "sub 5 seconds," what I'm really saying is that those fast test suites you can get in a bare gem, you can get in rails too.
Bitwise operators are very useful, particularly if you have to store multiple boolean states. Lets go with the library example every fucking tutorial eventually uses You've got a User model, that can have 5 boolean properties: + Has books out + Is a junior + Is in good standing + Has fines + Is a librarian The naive way to store this would be 5 boolean columns in your datastore. But every time you wanted to check, you'd have to use gobs of logic, i.e. see if a junior is in good standing and has books out at checkout. If you use bitwise, you can just check for integers. Aka bitfielding. Very useful trick. There are even gems that do it for you
I don't believe that RubyMotion includes OpenStruct (Rubymotion doesn't have a lot of the standard library), and it seems like the author went to a bit of trouble to support RubyMotion. As someone who suffers through RubyMotion primitives, this gem looks pretty convenient.
Given -1 is the last element of an array, you could do: [z, x, y][a &lt;=&gt; b]
Haha, okay. Here's the ELI5: * WEBRick - Babby's first webserver. No learning curve, probably not useful for actual things. * Thin - WEBRick++(++++++++). Actually useful. * Unicorn - This is how you make your app go fast without having to know anything about threads * Passenger - This is how you make your app go fast without having to know anything about sysadmin * Puma - I herd u like java
You can't when rails takes 5s+ to load itself. I don't believe you either.
The way you have it is more readable than any other response on this thread, for what it's worth. Readability and clarity are elegant, too. Suppose you don't look at this code for 6 months, and you come back to it. Which of these would you rather see? if a &gt; b x elsif a &lt; b y else z Or: [result_y,result_z,result_x][(integer_a&lt;=&gt;integer_b)+1]
I've had a need for this for a while, thank you.
Preloader.
That's not a real answer. That's a hack because it's so slow.
That's an ideological perspective. It'd be more accurate to say, "it's a compromise." It's not as nice as if it weren't necessary, but it brings a lot of benefit along with it. Namely, everything I'd do to build out an application outside of rails would be a foreign universe to other rails programmers. What I've been trying to counterpoint against is this dogmatic "ditch rails" perspective that seems to be cropping up. I have no problem with your approach. I'm just trying to offer the counterpoint to all this "ditch rails" dogma being spread around now thanks to the midwest keynote.
This is the correct answer. Everyone else will want to punch their idiot past self in six months.
I'm not saying "ditch rails". Rails is very good at delivery (it's an MVC system, after all). I'm saying "isolate your business logic" because it's very important not to be coupled to third party systems.
[Metaprogramming Ruby: Program Like the Ruby Pros](http://www.amazon.com/Metaprogramming-Ruby-Program-Like-Pros/dp/1934356476). It really changed how I write code. This isn't a great beginers book but good for anyone who knows the basics.
The pickaxe is considered "the ruby bible", but personally I feel like I got a lot more out of Metaprogramming Ruby.
On my phone so haven't had a chance to fully evaluate, but I'm wondering if you've used hashie and can offer differences between your gem and hashie? Does yours do hashes recursively? Also is there a class that can be initialized from a hash rather than calling to_dish? Thanks!
Interesting talk, thanks!
Either [Practical Object-Oriented Design in Ruby](http://www.amazon.co.uk/Practical-Object-Oriented-Design-Ruby/dp/0321721330/ref=sr_1_1?ie=UTF8&amp;qid=1391751062&amp;sr=8-1&amp;keywords=practical+object-oriented+design+in+ruby) or [Eloquent Ruby](http://www.amazon.co.uk/Eloquent-Ruby-Addison-Wesley-Professional/dp/0321584104/ref=sr_1_1?ie=UTF8&amp;qid=1391751088&amp;sr=8-1&amp;keywords=eloquent+ruby). Both are incredibly great.
I'm with you. Code clarity over that atrocity.
Got to agree with Zed Shaw and others on this one. The pickaxe is not a good book for intro to ruby. However as a reference, pretty good, but then I prefer online ones like apidock.
I know upwards of 27 languages at last count, of those I would class my skill as - {senior: 3, mid: 8, junior: 10, basic: 6} How they're ranked is if I could get a task at that level in that language and complete it at a responsibility level appropriate for the classification. Of course this is IMHO based rankings, take as you will. I also spend inordinate amounts of time reading, which is definitely not everyone's cup of tea. I intend to keep Ruby for system administration tasks, though most of the time I use bash. If I actually require speed I drop down to C extensions. Toying with Julia as another Alt language for ops and system internals. If I had to pick a favorite language it would be a match between Ruby and Common Lisp, with Haskell trailing just behind. Bash and Perl are normally my hacking languages. 
seconding POODR
I've been running an app on Passenger since 2009 now. It's not super huge, but there is some constant traffic on it. I've had zero problems over the years. As long as Apache is running, Passenger is running. The only thing that isn't very helpful is the error message it shows when your app fails at a low level like missing a gem, but this is something that is hardly the fault of Passenger.
&gt; Again, please show me how I'm doing ruby wrong. I've experienced lots of projects that use "the rails way" and just end up being a big pile of unmaintainable shit. uhh can we agree that this isn't some all-or-nothing black-or-white idea? it isn't "the rails way or the highway" you can use app/models as a replacement lib directory and *still* have a 5s test suite. and to play devil's advocate, I'd like to see a non-trivial, reasonably large "Uncle Bob" app with a set of high level state based acceptance integration tests that runs in only 5s.
[why's (poignant) guide to Ruby](http://mislav.uniqpath.com/poignant-guide/book/chapter-1.html), of course. That, or The Well-Grounded Rubyist.
These use-cases look much more compelling than the ones currently first in the README. I would update that to include these more prominently. (Just checking defined methods can be done very easily without izzy. It is the stuff you have mentioned above which takes it above and beyond.)
ruby /path/to/file.rb ? or maybe you should consider using another os
You have to add ruby binary to your PATH variable. After that you will be able to run ruby scripts like pointed above: &gt; ruby file.rb
First of all Ruby is not a hammer. About the hammer: that building was built in 1714 [1](https://upload.wikimedia.org/wikipedia/commons/6/61/Kishi_church_2.jpg), [2](https://upload.wikimedia.org/wikipedia/commons/4/4b/Kiji2.JPG) using only axe :).
Got it, I have to have the path in quotes for some reason 
I would use linux mint if I could - my workstation is windows because I need to run Adobe Creative Cloud apps, and Mac OSs scare me.
**The Ruby Way** especially the upcoming third edition
curious, how is this related to/inspired by monads?
I'd go with [the pickaxe.](http://pragprog.com/book/ruby4/programming-ruby-1-9-2-0) Thats the most reference and general ruby explanation you can get in physical from.
[The Well Grounded Rubyist](http://www.manning.com/black3/)
Mirah.org has malware or something malicious on their site.
That's weird. I don't have any problems. However, you can view the github page instead: https://github.com/mirah/mirah
That's weird. I don't have any problems. However, you can view the github page instead: https://github.com/mirah/mirah
I have to use Windows for my day to day OS at work since I also do .NET development. However, I do use VirtualBox and Samba so that I can do all of my development on my Windows Host, but have ruby running in the VM.
noo.. another groovy language
You could always be nerdy and use arrays and their functions :D g = [a,b].max g == a ? x : g == b ? y : z
You should also try http://www.toptal.com/developer It is a network of developers which holds high bar for both companies and developers. And it worth it.
Why's Poignant Guide http://mislav.uniqpath.com/poignant-guide/
+1, this book is incredible. Far superior to the unfocussed, and sprawling "pickaxe" IMO.
A book made of rubies. Probably Why's (Poignant) Guide.
Mirah's a really neat idea, but it suffers pretty badly from lack of adoption. The tooling is non-existent. As a Rubyist who has done Android development, I found it more expedient to brush up on my Java than to get Mirah working, sadly. Ruboto's a toy, IMO. Fun, but not really at all practical for actual apps.
While this may seem nice at first glance, it's really not worth it imo. You're throwing away all the optimizations that went into Hash. I've done a quick benchmark using `benchmark/ips`. Higher numbers are better (ips stands for iterations per second). Calculating ------------------------------------- hash 69367 i/100ms dish 24472 i/100ms ------------------------------------------------- hash 3948215.8 (±23.7%) i/s - 16023777 in 4.999657s dish 538116.3 (±12.0%) i/s - 2642976 in 5.006639s Source: https://gist.github.com/britishtea/8869118
You'd be surprised what one line of HTML can do when it's including a 250+ KB javascript file...
One potential big (and not easy to spot) problem with this solution is that `result_x`, `result_y`, and `result_z` are all actually called, no matter what (if they're methods). This is not the case with a solution that uses actual conditional statements (either via `if..else` or ternary operators). With your method, you get the correct return value, but with the possibility of unwanted side effects: def foo puts "foo" "less" end def bar puts "bar" "equal" end def baz puts "baz" "greater" end integer_a = 1 integer_b = 2 [foo,bar,baz][(integer_a&lt;=&gt;integer_b)+1] # Output: # foo # bar # baz # "less" Compared to: def foo puts "foo" "less" end def bar puts "bar" "equal" end def baz puts "baz" "greater" end integer_a = 1 integer_b = 2 if integer_a &lt; integer_b foo elsif integer_a &gt; integer_b baz else bar end # Output: # foo # "less" This could be potentially very dangerous if `foo`, `bar`, or `baz` actually do something meaningful.
Eloquent Ruby here too..
Is there any sort of (safe) PoC that can be used to actually test if libyaml is patched or not? Distros releasing updates with the same 0.1.4 version number doesn't help much when I'm also using rvm. Hard to tell *which* libyaml is getting used.
Good point, I agree with you. Octopus is a awesome project, and it's really hard to move on to another one. But, since I don't use it on production anymore, soon or later I'll need to find another maintainer.
It's good to get a refresher on these things, I bet I could use it with Backbone as well.
I agree, this is cool but saying it's "one line of HTML" so misleading, it's not even wrong.
So this is still running a local, internal web server for testing, and it's ignored the domain name? 
ITT just about every super worthwhile Ruby book has already been mentioned. Good job, /r/ruby. Newbs, this is your reading list right here.
Pry is an alternative to IRB. It's like IRB but has a ton of features. http://pryrepl.org/ I would also highly recommend the Ruby Koans. http://rubykoans.com/ I initially shied away from the official Ruby docs in favor of howtos/blogs/tutorials/forums/stackexchange when I started learning Ruby. It can be a bit daunting at first, but once you get comfortable it can be extremely helpful. http://ruby-doc.org/
That is awesome I will definitely check it out, thanks. 
how's about: `self.send([:result_y, :result_z, :result_x][(integer_a &lt;=&gt; integer_b) + 1])`
Seeing an increased level of hate for it recently so I might be missing something, but I'm still a pretty huge fan of RVM as far as going from 0 to 2.0.0. \curl -sSL https://get.rvm.io | bash -s stable --rails If you've got curl, that sets you up with Ruby 2.0.0 and Rails 4. Sure, something might go wrong, but it'll tell you what went wrong and what command you need to run to fix it. Wanna skip all the boilerplating and instantiate a Rails app to mess around in, complete with Twitter Bootstrap and your choice of server? rails new myapp -m https://raw.github.com/RailsApps/rails-composer/master/composer.rb Bam, you've got an app, complete with a Github repo and everything. I know that only helps you in a unixy environment, and I know you're just answering the question the OP asked, but I figured I'd throw this out there for anyone who just wants to get started without stumbling along and fighting with the installation process. Edit: I felt bad for not answering the question, and then realized that I kind of did but needed to rephrase. I guess in a perfect world we wouldn't need RVM; Ruby would include the environment management solutions RVM provides-- or basically, whatever the specific implementation, you could install Ruby from whatever package manager and wind up with the latest stable release. I guess you could say that as far as installation and configuration goes, Ruby could more perfectly conform to the principle of least surprise.
I feel like the elephant in the room is speed (or lack thereof) and usually when it's brought up, it's met with responses like 'development speed is more important than execution speed'. 
Use RVM, if you are on windows switch your os.
It compiles down to java bytecode, and uses java's native types. No extra dependencies necessary. You don't have to ship your app with the JRuby runtime (which is quite big, for mobile app usage). Compared to JRuby *and* Groovy, it's statically typed (with local type inference), so performance is that of java. And if you want to extend it / add some syntax sugar, you can also use its compiler macros.
I know what you mean, Dynamic OO designer's systems tend to be quite different from Static OO ones! With regards to your reply about the up top initialization, this is a lot simpler if the IOC container supports nested containers. This keeps objects close enough that you don't end up contravening Law of Demeter. We used this to good effect in a Project where a bunch of different objects were shared top level with an Application container, followed by a 'Project' container, and finally by a 'File' container. Wiring these manually would have been quite complicated to test.
This was going to be my comment also, and at some point I believe we're going to see a large scale reversal of this perspective because it is not true in *all* cases, and in the cases where it is true, it is so only given certain economic factors all of which will change over time. 
&gt; 10-20% improvement this _may_ have been true before say 2008 but the landscape has changed a bit. nodejs is up to 10x faster (and in some instances even more) than ruby. go is in the same ballpark. &gt; but thanks to architectural changes that Ruby and Rails happily accommodated... so it should be applauded that the framework did not get in the way? yeah the 'you scale architecture, not language' is another popular response. yeah sure, if you fuck up architecture, you have bigger problems but it's not like you are immune to bad architecture decisions due to writing ruby. 
Setup your dev environment in a virtualbox machine and you won't depend on your host's OS.
&gt; you scale architecture, not language 10 years or so ago I took a system written in VB and ported it to C#. From 35 servers it went down to running on **a single box** saving the company in the region of £100K per year. Not everything has to scale *up*.
I think the biggest challenge will be staying relevant in the coming age of massive parallelism. Some newer languages/ecosystems like Clojure, Scala and Go are seeing some great results, while MRI Ruby runtime is still basically single-threaded. This kinda ties in with the notion of 'speed' in Ruby, as there is an ever-increasing demand for performance which is no longer being served by simply waiting a few months for a new processor arch to come out. 
You can use [PHP via the command line](http://php.net//manual/en/install.windows.commandline.php). If you have it on your machine, for client side scripting, then you can do this. It's just the php.exe is usually hidden away since you normally talk to it via Apache/NGinX/whatever. But it will be there, and you can use it via the command line if you want to. &gt; Okay Javascript is a scripting language too . but the difference is JS is for client side and Ruby is for server side scripting same as Php There are also compilers which will turn Ruby into JavaScript, allowing you to use Ruby client side (I even wrote one). You can also use JavaScript server side with Node.js, or on the command line. I have quite a few command line scripts written in JavaScript. Windows has even come bundled with JavaScript ready to use via the command line, as a part of the Windows Scripting Host since Windows 98.
For me, a big issue is taking over rails apps that where build a few years ago and run unmaintained for a while. The owner wants you to add another feature. Suddenly you have a Rails 2.3 app running with Ruby 1.8.7 on Ubuntu Hardy. And the app doesn't even use Bundler. My dev machine runs the latest OSX with the latest ImageMagick and the according RMagick versions (RMagick is needed because it's a dependency of some obscure gem a previous maintainer introduced.) TLDR: dependency hell
Check out rubinius and celluloid - rubinius should have been adopted as the official ruby VM IMO, it's truly multi threaded and very advanced. Celluloid brings a concurrency model inspired by erlang to ruby, I've built a few things with it and it is awesome
That the language ecosystem is almost entirely based around one web framework (Rails). 
&gt; result_x if integer_a &gt; integer_b &gt; result_y if integer_a &lt; integer_b &gt; result_z
If you are using Ubuntu and feel left behind, imagine being on CentOS. 1.9 is *new* on that platform.
Step 1: Introduce bundler into the setup. Otherwise you won't ever have sanity.
mmm sorry, don't know the way, there may be a rails app template that does this, but I wouldn't know which...
Despite the fact that Sinatra and NyNy are perfectly usable and far more flexible than rails... And I would disagree that Rails forms the entire ruby ecosystem. Metasploit, Homebrew, RPGMaker, CocoaPods (Obj-C package manager), and many other large non-web non-rails projects are written in Ruby. 
Not allowed. Violates some network security stuff.
&gt; Installing ruby on an Ubuntu server (whichever version of ruby the community is using) is annoying. sudo apt-get install ruby1.9.1-full Note, this will actually install ruby 1.9.3-p0. If you really need a specific version (you probably do not), you can use [ruby-install](https://github.com/postmodern/ruby-install#readme) or [ruby-build](https://github.com/sstephenson/ruby-build#readme) to install into `/usr/local`. &gt; Getting ruby libraries to work cross platform is also an issue. Cross Unix is not the same as cross platform, which means half of your applications will break on Windows. That's more of an issue with library developers than ruby itself. This is what [JRuby](http://jruby.org/) is for. Since Mac OS switched to a BSD base system, this makes Windows the odd one out. &gt; I, personally, would love it if it was possible to embed ruby (not mruby) within C programs. Official support for compilation to bytecode would also be cool. If you compile Ruby with `--enable-static` it will install a `libruby.a` archive which you can [link against](https://gist.github.com/jefftrull/1305431). **Edit:** answered more of your complaints.
Can you elaborate on that? You can setup the VM's networking as bridged, forward the needed ports (ssh, ...) and you're good to go. You can tailor the VM to meet your security requirements. Edit: Also, the VM becomes your mobile workstation as you'll only need to carry around a .vbox file and you can access all your work from anywhere. You'll use only one SSH key always.
If you're interested in seeing how its actually implemented in Ruby, I'd encourage you to check out the MRI/Rubinius source - the rubinius standard library is 100% Ruby. here's how a Hash works in Rubinius, https://github.com/rubinius/rubinius/blob/master/kernel/common/hash.rb But yours seems to be implemented in the same way (whoops, looks like I learned something new :P). I'd say it's a perfectly reasonable way to access your Grid - there's no reason not to as long as it's documented (someone may disagree though) 
I think that's the thing they didn't like-- sure, it makes sense when it's documented, but someone looking at the code without any clue what it does isn't going to intuitively guess "Oh, he created a method called [] in order to access his grid." It's clever and it works, but it's not a descriptive method name and it's not immediately obvious what's going on if you're not looking at the method definition.
The problem I have with calling a method `[]`, is that it effectively has no name. This means that it is harder to know what's going on. So my advice would be to only call something `[]` when it is absolutely obvious what it means. The default meaning of `[]` is something like "access individual items stored in this collection". You have a grid, which seems to be a collection of things, so I would have no problem with calling it `[]`. The default variable x and the ternary based on that is an antipattern, imho. Just split them out into 2 methods. Since I'm nitpicking on a couple of lines, I would not give access to the internal structure at all. Right now we use arrays for the internal structure, but that might change. So I would make some more explicit accessing methods. For instance: class Grid def initialize(size_x, size_y) @grid = Array.new(size_x + 1) { Array.new(size_y + 1) { Array.new } } end def [](x, y) @grid[x][y] end def each_item_in_row(y) @grid.each do |row| yield row[y] end end def each_item_in_column(x) @grid[x].each do |item| yield item end end end 
well this is a coincidence ;)
Haha. :D
The asset pipeline is Rails stuff, not Ruby. Have you watched the Railscast on the Asset pipeline? Might help you: http://railscasts.com/episodes/279-understanding-the-asset-pipeline
In principle, embedding ruby is perfectly possible. 1.8 certainly made it doable, if not exactly trivial; Google's SketchUp embedded ruby for a long time, not sure if it still does. I've not tried it with 1.9+ though, so it's possible it's less easy than it was.
Also: virtualbox.
Run, don't walk, to JRuby.
Defining the subscript operator to subscript into a collection, good. Special casing it to return the array when given no args or `nil`, bad. Implement `#to_ary` for that.
JRuby _is_ pretty nice in that sense!
This is a great name but poor implementation. You should have your [] method accept x and y coordinates since you have a grid. def [] x, y @grid[x][y] end [] is for access by index or key and a coordinate grid certainly has indexes. Source: Ruby committer with over a decade of ruby experience.
All methods have names. The name of the [] method is []. You know this because those characters follow "def". While I concur with most of the rest of your review, your first line makes no sense at all. There are method-like things that can have no names in ruby: blocks, procs and lambdas.
Yes, you are technically correct (which is the best kind of correct). I meant it a bit more figuratively. It is a name, but not really something that communicates your domain. It feels more like an operation on the object than a message you send to the object. I don't know if that makes any sense.
&gt;[...]but the difference is JS is for client side and Ruby is for server side scripting same as Php . [Are you sure about that?](https://en.wikipedia.org/wiki/Nodejs)
It communicates the intent of the method very well. Every other place you want to get a subset, substring or value out of a collection at a specific point you use #[] so it is definitely appropriate for a grid. I would think "I want to get an item at these coordinates, what should I use? Oh look 'square brackets' is one of the methods, that must be it!" (Maybe you say "index" or something else for #[]). Furthermore, Ruby doesn't make a distinction between methods and operators like other languages. Some methods have special syntax that look like operators, but it's no more than sugar in Ruby. Even Smalltalk has this property, so I don't see how you can justify standing on ceremony here, especially when you provide a proper implementation of #[] in your review. PS: why start your reply with a sentence that doesn't back up your point?
Vagrant 
The magic you seek for returning the columns is [Array#transpose](http://www.ruby-doc.org/core-2.1.0/Array.html#method-i-transpose).
haha I'm going to assume you're kidding. BTW, this will still raise `NoMethodError`s if any of those are variables and not methods.
Wow! I didn't know it's already built in. I left it out as some kind of exercise, but this is even better. Thanks!
If this is just something of yours that no one else will have to deal with then it is fine. If this is something that other people will be dealing with later in a team environment then it is horrible. You're setting the future team up for failure and trying to be way too clever. Actually, following along with what I just said this may be bad all around. If you make this a habit then it could spill over into your team based work which would make it bad again. [Edit] Maybe I'm just jaded from some of the teams I've worked with.
&gt; If this is something that other people will be dealing with later in a team environment then it is horrible. Why is that? How would you have solved this instead?
I was going to say to mask it with a named method but I have changed my mind. I was going to cheat it out when you asked me how I would do it. I used the Matrix class once before and figured I would throw an example down based off of that. Something I missed before: http://ruby-doc.org/stdlib-2.1.0/libdoc/matrix/rdoc/Matrix.html#method-i-5B-5D If it is good enough for the API then it shouldn't be too much of a stretch for a team environment to pick it up. It should be noted that the method is also aliased and probably for the reason I mentioned with team development. 
&gt; You had to have known you were getting this comment: Node is a framework, ruby is a language. You are missing what we were talking about as no one was pointing out that distinction. Also no, nodejs is a runtime and yeah Ruby is a language, but it is pretty commonly used interchangeably with the MRI implementation. But pointing that out is neither here nor there. &gt; I think it is a mistake to say that performance is a reasonable reason not to choose ruby, I mean it's not just about how many requests you can serve but also about request latency. &gt; Instead, a lot of folks are realizing that unless they blame the platform, they can't justify a rewrite... Can you give an example of "a lot of folks"? Your comment is just another example of the sort of denialism that is for whatever reason pretty common in the Ruby community and is hurting the platform more than anything. 
Oooh, I like this. Thanks dude.
&gt; since for example `map` returns an `Array` and not a new `Grid` which might be surprising. You can include `Enumerable` then override any methods that don't make much sense. I'm still annoyed that `Hash#map` returns an `Array`.
Manager, processor, director, admin, file and many other suffixes for class names.
That's what I did. But even Bundler can't solve everything.
Right but per your opinion is it right for OOD?
I found POODR's final chapter (on testing's role in OOD) particularly valuable.
Compile ruby from source or use rvm. Never had issues with Ubuntu and RoR. 
As the docs say, "Can't tell if joke or just Ruby."
It doesn't matter how something is "considered." Do what seems right, learn from what doesn't work.
&gt; I used to program in C for a living. Cool. Send me your address and I'll send you a medal. You are literally the only person to have done that. &gt; Compared to C, both Javascript and Ruby seem ridiculously "slow" to me. What an astute observation, what's your point? It's not like those languages are really in the same space. &gt; Request latency? Humans are much slower than computers. In what respect? What does this sentence even mean? That people don't notice latency? &gt; If you can't serve up a zippy experience to your users, you've got bigger issues than language. Like what? You do realize that e.g. Amazon optimizes latency to like tens of milliseconds right? &gt; It's really irrelevant. If I want pure speed I could jump back into C. Well good luck writing your next web app in C then.
Why would I be kidding? And yeah of course calling a non-existent method is going to give a no method error, wanna give an objection that's meaningful ? 
No idea why this was downvoted.
Done, and cleaned out a lot of cruft in the readme as well.
Going back to my original point: if integer_a &lt; integer_b foo elsif integer_a &gt; integer_b baz else bar end avoids all of these problems, and is significantly more readable.
None of those things have ever bitten me. i'm curious what you've been trying to do all these years that I haven't that's been a problem for you. As for what I wish ruby would do better, I wish there were a way to easily embed tests in the documentation for libraries.
It's not particularly useful, I suppose, but it was fun to mess about with and brings Ruby that much closer (syntactically, at least) to the functional language hiding at its core.
Were you originally a python programmer? :) You know you don't have to make this pollute everything. You could allow people to be explicit about including it in certain modules. 
I did know Python before learning Ruby, and I suppose that motivated the idea a little bit. As for making it more hygienic, I mostly only wrote it to scratch an itch. It's a toy, and it's fun to play with, but no sane developer should *want* to use it in production.
What does your application.js look like, and what does your Gemfile look like? 
Yeah, pretty much. I ask because I have similar-looking tests using [RSpec custom matchers which in turn use Faraday](https://github.com/dogweather/rspec-webservice_matchers). But I'm testing an external web server, so it's a different scenario.
http://i.imgur.com/g3Qf7Es.jpg http://i.imgur.com/V3JdyVb.jpg
Yeah, but that doesn't get you a job unfortunately
This is essentially [operator overloading](http://ruby.about.com/od/oo/ss/Overloading-Operators.htm), and is perfectly fine to do so long as you make the array indexing work as expected. If you write out methods so that you can do everything you'd normally expect to be a ble to do with arrays, then it's fine and dandy! [Check this out. It's discussing C++ but holds true to other languages where you can overload.](https://stackoverflow.com/questions/4421706/operator-overloading)
Whats another word for manager? Controller maybe? Mediator? Commander?. Does it suggest bad design? Sometimes, yes. Funnily enough I'm currently using it to name a sub-component of an application which has conflicting requirements. I actually *know* that the design is bad because I've been unable to come up with a better name than "project_manager" (edit: and the design is bad because the conflicting requirements cannot be reconciled) *Personally* though I often use it as a catch all to mean one of the above (controller, mediator, etc) but its *usually* an expression based on the intent of an **underlying design pattern** (Edit) and I think if you look beyond the naming you will *often* find this to be generally true.
It's more important to be able to defend why you chose to write code a certain way, imo. Anyone who knocks you for something like this is probably not worth working for.
I think that last sentence hit the nail on the head for me. I use minitest, and when I've encountered problems, I've dug into the source to figure out what's going on. I learned to create classes by looking at other code. I can see how preferring to do research first would be frustrating with ruby.
My feeling is that if it doesn't fit on one line, then the conditional operator should not be used.
Ah, yeah that won't work with Rack::Test. You actually provide the Rack app as an object in your tests. So an HTTP connection isn't actually made, it's just simulated (as far as I'm aware).
Looks like i forgot to update it here, but the example is for your development environment :)
I mean I agree and understand that theoretically it's for your development environment, but your examples specifically use a `Procfile` This implies your production ready configuration. (Not that Heroku is your only place to deploy, but) If you were to deploy this to Heroku, you'd get a whole mess of failure, and that's because Heroku (and your ops team) expect a production-ready `Procfile`. Separating out a unique development-version Procfile isn't easy. There's the `bin/service` method that the foreman creator advocates, and there's the `Procfile.dev` method that others advocate. Both have significant downsides.
I have not, I've been keeping my eyes open for any info, too. I've been hacking on a dynamic autoloader for a while on a side project to avoid having to sprinkle `autoload` in my gems. If it gets un-deprecated, I may go back to that explicit `autoload`, which I preferred actually.
Yeah, in the specific case you're using heroku you just have to rename it to something else.
here's matz's announcement: https://bugs.ruby-lang.org/issues/5653 autoload thread safety was fixed in MRI in this revision: https://bugs.ruby-lang.org/projects/ruby-trunk/repository/revisions/33078 there have been recent requests for readdressing the original issue now that it's thread-safe, and a new proposal for change in behavior, but not much feedback from matz and ruby core yet. we'll see
Thanks, I hadn't actually seen it referenced on the bug tracker, only that mailing list thread.
jruby, rubinius, celluloid and vert.x are all things you should be looking at if you are looking at parallelism.
I think he means "My sysadmins are lazy and have a blanket ban on VMs because crippling developers is fine by us if it makes our jobs easier."
Does it detect when assets need to be recompiled correctly? i.e. is there a danger of stale assets being deployed?
Sprockets, the rails asset compiling doohickey, does caching across asset compiliation runs out of the box. The default behavior, however, is to cache the assets on the file system which heroku can't take advantage of because of the ephemeral nature of its instances. This isn't providing any new behavior, only changing the storage mechanism for the caching. I imagine Sprockets accomplishes this through either using the last modified date of the file or by the hash of the file's contents or something, so using memcache shouldn't make this anymore dangerous than it already is.
is this different than `bundle install --path=vendor/cache`? could I be saving precious keystrokes?
If you don't mind, I'll share my methods. [blooper](https://github.com/paranormal/blooper) for permanent logging. I'm the author :) And for everything else [HTTP::Proxy](https://github.com/book/HTTP-Proxy)
Sounds cool, but I don't really want to login with Facebook...
Thanks for the feedback. I just added guest mode.
Controls were a bit laggy, had to hit the buttons half a second or so before you think you need to. Will have a look at the application architecture when I get home but looks like an interesting setup plus I &lt;3 JRuby.
I like this a lot. I appreciate the thoroughness.
Thanks! Those are all good comments! Yeah, you can't really know how it is until you spend enough time with them...
https://github.com/bundler/bundler/blob/master/lib/bundler/cli.rb#L224 
If this was a serious effort, you don't do a very good job of selling it. Most Ruby developers won't like that it "pollutes" something or that it gives you "functional programming" when Ruby already provides decent functional programming support.
Prolly bloom filter is used to detecting malicious urls in your browser.
Not sure about why in the first case foo.empty? would return true. But in general you hit a classical trap of Ruby here, often encountered (but not limited to) default return values for Hashes. What you think you do: You think you tell Ruby to return a clean new Hash for every key request. What you do: you tell Ruby to return one and the same empty Hash object for every key request. What that means: foo = {} foo.default = {} foo[:x]. object_id =&gt; 70234653333400 foo[:y]. object_id =&gt; 70234653333400 foo[:z]. object_id =&gt; 70234653333400 So if you modify that hash (you think is empty all the time, but only is at first) foo[:a][:b] = 123 foo[:a] returns the hash object with id 70234653333400. To this specific hash object you assign the value 123 on key :b. You right now modified the one object that you Hash will return as default for unknown keys. All the fucking time. Now you try: foo[:abc] and get {:b =&gt; 123}, because that's your 'default' object. This behavior has a lot of nasty and unexpected side effects. In addition it seems that a Ruby Hash returns true for empty? as long as there are only "default" objects in the hash.
* Everytime you try to access a missing key from foo it returns the same hash instance (the one you set as default). * Accessing keys never modifies the hash. That pretty much explains it all.
There isn't nearly enough information here for anyone to help you. The query is from or to that address? What session is being terminated? Of what form is the query? What does "terminated" mean - no data is returned, a data stream is returned but cut off early?
updated , sorry again for the lack of information 
Oh man, Ruby has a nasty side after all! So is there a recommended method for getting around this problem? Thank you for your reply. Very helpful!
Thank you for your reply :)
There are a few such things. After all to do all the nice tricks it needs a certain complexity. The correct way to do is this: Hash.new {|hash,key| hash[key] = []} As you see, you can give Hash.new a block that is called for unknown keys. In this case code is executed and a real new Hash generated each time.
As someone new to Ruby, thanks for the info!
The biggest mistake a beginner can make is to learn multiple languages. Stick to one, and one only for a year and learn as much about it as you can. Very few are natural polyglots in terms of coding languages when they start, those who aren't end up burning out quickly. Learn Ruby well. 
Learn more sysadmin related stuff. Configuring a linux server, why pick unicorn/puma/thin etc... Database admin. I've worked with allot of developers who cannot setup their own server and depend on a sysadmin. Knowing the basics can greatly impact how you develop your app. (performance, background queueing, storage) Check out railscasts.com. there are videos on setting up Nginx and VPS. Also look up deployment options, like capistrano. There is so much to learn about besides just knowing how to program in ruby
Completely disagree. Learning new languages reinforces the concepts you learned in one while introducing to things that your first language avoids. You're going to know (and appreciate) Ruby more after you've wrestled with Obj C or C# or whatever other language it is you try. The trick is to not give up your first language when adding another. 
Thank you for this! I've been working on a few Sinatra apps, but I feel like I'm inventing the structure as I go. Your gem provides a good foundation for keeping Sinatra flexible and secure.
Are you thinking of developing with Ruby on Rails, and not ruby? Most of what you said does not apply to ruby software, but rails or any other ruby based web framework.
I think rails would be a wonderful place to start. It's not a new language, but a framework built on top of ruby. First, it will solidify your ruby skills, and second, it will force you to learn some html, css, a sql database of your choice(postgres, mysql, or even just sqlite), and javascript. All in one. Not to mention it will teach you a bit about how the web works. http://ruby.railstutorial.org/ is a wonderful place to start. It took me about a week to get through it. then I started developing my own web app with a bit more business logic and that took me about 3 months.
I moved your code into a [runnable gist](https://gist.github.com/anonymous/8922445) for anyone who wants to take a crack at it. I don't see the session as terminated on my end, it runs, returns data, and the connection is left open by default. If you want to open a new session with each request you will have to study (or figure out) the design of the remote service, and what it uses to define the session. Chances are high the user/session identity is stored in the cookie. 
"That fast" is subjective, and your assertion that people burn out when trying to learn a multitude of things (why 50 things?) is quite a generalization. If anything, I could see how learning different things might _keep_ some people from burning out. In addition, as mattosaur said above, just because the OP moves on to learn another language does not necessitate giving up Ruby. This is what I alluded to when describing web development with Ruby. You'll get exposure to other language just by virtue of working with Ruby in the (full-stack) web space.
Thank you , mine returns but I get a 302 error and I don't how to fix it ! Do you get a 200 response ? Thanks for everything 
&gt; Learn to start and finish projects. Sigh. Even after 15 years in the industry, I suck at this unless I'm getting paid.
I'm in a very similar boat, BOOGIEMAN-pN. I have managed to consume just about all of the "basic" ruby information out there. My goal is to transition from a beginner to a Jr. Web Developer, so, slightly different endgame, but similar state and desire for growth. I find myself in a position where if I had more Linux under my belt I would feel far more confident taking the next steps. It would seem that I have quite a bit of isolated knowledge, many pieces of a complex puzzle. Sadly, I'm lacking the picture and its making the piecing together difficult. Anyway, tossing in my newb advice along with the other folks here... Get your fundamentals down cold with Ruby, start to dig into HTML/CSS as that will help to ease the transition into a framework (Sinatra / Rails) and brush up on your command line knowledge allowing you to manipulate all of those pieces into something real. ABC! 
Does "fetch" meet your needs? http://www.ruby-doc.org/core-1.9.3/Hash.html#method-i-fetch
If I've kept to the first (few) languages I've tried, I'd probably be by now PureBasic/FreeBASIC coding guru ... but then, I would've never discovered Ruby and it's beautiful syntax. I've already decided I'm gonna try other technologies (at least a bit of them, until I lose that feeling that I'm missing something) ... I'm just not sure where to start. 
&gt; Learn to start and finish projects. yes, this. Once that I figure that I know I can make my program work the way I want it (I only need to type sh**load of code) ... I lose my will for working and move to something else. Glad I'm not the only one :)
node is not 10x faster. 
yes, I think I'll have to start with HTML/CSS as I originaly planned, I have feeling that I'm the only one in the world who doesn't "speak" those ... also, I'll add to my list Linux, I know nothing about that OS
Looks like what I'm after. Cheers :)
Seriously, this is about a thousand times more important than learning any specific language or technology (which you can -- and *will* -- just end up googling anyway, most of the time).
http://nodeblode.wordpress.com/2012/04/10/the-great-node-js-versus-ruby-on-rails-speed-test/ http://highscalability.com/blog/2012/10/4/linkedin-moved-from-rails-to-node-27-servers-cut-and-up-to-2.html Google around, it's usually in the ballpark of 10x or more. 
If you want to do web development, I think the next best place to start would be with this : http://ruby.railstutorial.org/ . I jumped into rails while barely knowing how to code using this book. It took my a long time to get through it, and I didn't really understand everything until I started building my own apps. Overall, I think jumping headfirst into confusing things was the best thing I did, even if it was a frustrating.
Now that you've "Learned Ruby" you should go learn Ruby. Ruby goes much deeper than a "basic|essentials" course is going to teach. You may want to argue this and should you feel the need I highly suggest you go check out https://github.com/rails/rails. Go through all of the source and see how much ruby you actually know. You need to understand that "memorizing" something is not the same as "understanding" it. 
I receive a 302, but the forwarded URL then responds with a 200. If you read the [relevant line about the 302](https://gist.github.com/BinaryPaean/03a25b50b59c0ddbbe07) (which happens to be line 36 in my terminal) you can see what is going on. 302 means "resource temporarily moved", so the server supplies the URL they want your client to make a new request to. Curl, as used in the previous gist, does this for you, as you can see on line 46 of my terminal's output. The final 200 success is the contents of that second URL. Looking at the URL the server redirects to via the 302 it is pretty clear that whatever cookie and/or URL parameters you have supplied to that endpoint have expired, and so they are re-directing you to a page to log back in again.
I'd look at NoSQL before Rails. I'd look at databases/SQL before Rails. I'd look at HTML/CSS before Rails. I'd look at Sinatra before Rails. I'd look at Javascript before Rails. If you're lucky, by the time you have learned all that, something else will have come out and made Rails redundant ;) If not....look at Rails. Oh, and personally I've been having a lot of fun revisiting some comp sci 101 stuff such as heaps, AVL trees and sorting algorithms. It really helps to implement stuff for quite a while to get "into" a language.
This seems to be my issue now , I have figured out an encoding problem I was having and no it is telling me to restart my browser in the return html , Thanks for your help not exactly sure where to go from here though 
If you didn't already cover it as part of learning Ruby, I'd recommend learning RSpec, Cucumber, and Capybara (the last if you're doing web development). These TDD/BDD (Test- and Behaviour-Driven Development respectively) technologies, and the concepts behind them, will serve you well. I wish they'd been around 30 years ago - I'd probably have a lot more hair than I do now :-) As others have noted, there's "learning Ruby" and there's "*learning* Ruby".
Have you tried JRuby with Swing? It's actually fairly simple and has become my preferred way to build GUI applications with Ruby.
Overall, the problems is that it looks like you want to automate a request to some endpoint that was not meant to be an API endpoint at all. In other words, this will probably be kludgy however you approach it. In roughly descending order I would consider the following: * Is there a designed REST API that exposes what you want from corpus2.byu.ed? It would surely be easier than trying to scrape a page. * Get an in-browser tool to monitor the (successful) login and request cycle from your browser. See if you can figure out what parameter or cookie is needed for a "good" request. You can update your code to work at least until that cookie expires. * If you MUST make ongoing requests to that (or similar) endpoints, you are better off using a headless browser instead of something as low level as Curl. Consider [anemone](http://anemone.rubyforge.org/) or [mechanize](http://mechanize.rubyforge.org/) for example.
I think I will have to use mechanize ,it had already been suggested to me and I ignored it unfortunately. It worries me that this seems to have been designed for use by computer scientests but has no API! Oh well thank you so much for all your help
Unless you have a specific plan/need for PHP, I'd skip it - you can consider it kind of "redundant" with Ruby. Also, I would consider HTML the general "GUI" for Ruby, so I wouldn't feel bad about Tk/Qt/Shoes feeling alien - they kind of are. Javascript is actually a fairly simple language, [with many good parts](http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742), but the breadth of its libraries and applications can be daunting. It has add-on value as working with that "native GUI" of Ruby. However, if you really want to stretch your brain, you could look into a functional language like [Clojure](http://clojure.org/) or [Haskell](http://www.haskell.org/haskellwiki/Haskell). They will probably not realistically bring you closer to building a specific thing, as your current Rails-oriented plan does - but they will blow the rust off of your brain and right out the top of your head.
Javascript - Start with jQuery for sure !
Java is quite similar to Ruby. I was the same way... kinda looked down on Java and never wanted to learn it. But after trying it out with Swing and playing around, making a few game with LibGDX (A Java game engine) in JRuby, I became quite comfortable with it pretty quickly.
Alright then, time to take a break..
I think its a little of both. One big problem you can run into though is spending too much time relearning programming language. A programming language is just a tool. Once you learn one, its better to learn to really use to build things. That's when you REALLY learn to program. A book like the nature of code is a great example of teaching language agnostic ideas like perlin noise, modelling vectors, marchov chains. Once you get used to building large things in one language, its much easier applying those ideas while learning a new language.
&gt; yes, this. Once that I figure that I know I can make my program work the way I want it (I only need to type I am way past 40 and still learning new things just for the heck of it. Knowing you can make a program work with sh**load of code and actually writing the code to complete the task are two very different beasts. I know enough that if I write lots of code, I can rewrite the Linux kernel, Mars rover, reverse engineer Google's algorithm and find the cure for cancer. Attempting to actually do something tells me that printing "Hello world" in a new language is enough for me to jump up and down in excitement.
I'd vote for sqlite to begin with. It takes a lot of annoyances out of the way to learn on.
Learn [the fundamentals](http://shop.oreilly.com/product/0636920025481.do)\*. Learn about [unix](http://www.jstorimer.com/products/working-with-unix-processes)\*\* \*note, have bought but not read. \*\* have neither bought nor read, but comes highly recommended.
Before you say you "learned Ruby" how DRY is your code? You'll also find as you DRY it up you'll naturally start doing things in a more OO manner ("If this is its own class I can use it wherever I encounter dates!", "Since everything is broken down into simple methods I just to to fix it here and it now works everywhere!"). And those are the good habits to get into that will benefit you when you go on to learn whatever you move onto. I like Rails, the web is cool.
You might want to consider using [Mechanize](http://mechanize.rubyforge.org/) for this. It handles Cookies, Content-Types, Keep-Alive, User-Agents and follows Redirects.
Been enjoying using Padrino in larger apps. It is a nice middle ground between Rails and Sinatra.
I always recommend people start with HTML &amp; CSS... it is a great foundation. Next learn simple javascript (i.e. how to bind events, how functions work, the general syntax of the language, etc). Perhaps dabble in JQuery as well, and understand why it is so powerful. After you have a grasp on these things it is time to bring in the big guns, pick up a scripting/server-side language such as ruby (seems to be your drug of choice), php, python. Research the pro's and con's of each, pick one, and dive right in. This of course means you'll gain some database experience as well... likely SQL based. Next up, pick a popular framework for that language and learn MVC (Model-View-Controller) best practices. Read a book on OOP (object oriented programming). Be sure to use Heroku or AWS and set up a Github account! Last but certainly not least, TESTING. If you really want to be a badass (and a professional) learn about TDD (test-driven development) &amp; BDD (behavior-driven development). 
hi I've actually switched to Mechanize , I am however still experiencing a problem where the site is requesting I restart the browser instead of returning the information ! Have you come upon this before by any chance??
Thanks for sharing. Pretty new to Ruby here; I thought the transformation with the laziness applied versus the non-lazy select-based approach was pretty straightforward and made good sense. The piece that threw me off was the claim that the select-based (lazy or not) approach was "easier to read and maintain". Coming from other languages, the original version seemed obvious and simple, and the later approaches, chaining the next step directly off of the block for the prior step, seemed clunky/weird. Are the latter approaches considered idiomatic?
Yes, for someone experienced with ruby, and especially those who love it and prefer it as their language of choice when all other things are equal, the latter syntax is absolutely preferred. In the latter examples, instead of "looping through the collection and doing stuff," you are `select`ing the rows you want based on some criteria, then passing ONLY the selected rows through so you can `map` them to the desired end result/value, and then `take`ing 5 of those rows as your returned value.
Seeing a project through is a good experience to have, but there is a lot of value in not finishing projects that don't need to be finished. Leaves time to get experience in other areas, for one thing...
I just posted on the guy's blog. This is an overly complex and not very Ruby-ish solution. More Ruby-ish would be to use enumerators, like in this GIST: https://gist.github.com/orend/5134300 which shows how to stream CSV files, only one line in memory at a time, as an example of a technique taken out of one of Avdi Grimm's rubytapas.
Hey John I ended up yesterday with similar kind of idea and drawed some mockups have a look at them http://blog.ravitejak.in/post/76219405433/jekyll-gui-app-kreator-mockups
Thanks for posting this. Part of what bothered me was seeing the methods chained off of the 'end' keyword of the preceding blocks, and the way that the indentation flowed. (Coming mostly from Python of late, where indentation is syntactically meaningful.) Even though I'm aware that the do/end block syntax is mostly equivalent to the {} block syntax (with the difference being binding precedence), the way you re-wrote OP's code with the braces and indentation looks/feels cleaner to me and seems less hacky/kludgey. Given that these are basically syntactical sugar equivalents of one another, I guess I just need to get more used to the concept of a block returning a value and having that value be appropriate to chain another method[/message/block] off of.
what are your favorite parts? I've been interested for a while
To be fair, GUI programming is simply hard. Tk is a mishmosh of old and new ways of doing things, with a lot of historical cruft. Shoes is cool but better for games and experiments, not application GUIs. Qt is massive and has it's own terminology (actually every GUI toolkit does). So any GUI work basically involves learning a lot about the toolkit and how to get it to work for you. Not that you should give up, but maybe come back to it again like you said. That being said, I would suggest sticking with Ruby for a while, to keep it fresh in your mind and solidify your understanding of it. Rails is actually not a bad place to start, to be honest. There are lot of tutorials, lots of guides. Heck, you could start with [Rails for Zombies](http://railsforzombies.org/) and not even have to install anything. (Just be aware that Rails 4 is very new, so you might need to start with Rails 3. But the external differences are pretty minor.)
It's all about what you're used to. I was working on a Rubymotion project where we were doing tons of functional programming (iterating over arrays and hashes from a json api) and we adopted block/end chaining syntax entirely. Though now I'm back to Rails and tend to do the curly Proc style. Heck, you could rewrite it with stabby lambdas too: rows = CSV.new(File.open('input.csv','r'), :headers =&gt; true).lazy .select -&gt;(r) { r['MANUFACTURER'] == "Foobar Shoes" } .map -&gt;(r) { "#{r['SKU ID']} - #{r['NAME']}" } .take(5) .force
&gt; Javascript is actually a fairly simple language, with many good parts... ...But lots of bad implementations, and a bit dated
I would suggest to go by BDD outside in approach, where you write a feature and drive the implementation and complete it. And then move on to the next feature. This really keeps me going in the project, especially when you are a single developer.
One place I despise the lack of parentheses is on method definitions with arguments... def my_method without, parens puts "look how unruly how I am #{without} #{parens}" end UGH!
Once you have the tokens, you should be able to call methods on the calculator to perform the actions directly. Think about how you could translate operators into method calls using something like http://ruby-doc.org/core-2.1.0/Object.html#method-i-public_send **edit** By that, I mean think about what methods you would call on the object as a result of the evaluation of the string: calculator.push(1) # From 1 calculator.push(2) # From 2 calculator.push(3) # From 3 calculator.times # From * calculator.plus # From + calculator.value 
First and foremost the generators, which support multiple ORMs, Template Engines, and Plugins. Being able to generate a skeleton project, then models, then controllers, then views, then sub-apps, is very nice. I also like how apps (made up of controllers) are essentially just Sinatra apps; which you can add app-specific configuration to. I wish they would make controllers Sinatra apps as well, to allow further configuration of controllers. Lastly, the developers are super receptive to feature suggestions.
This line opps = {:+ =&gt; plus, :- =&gt; minus, :/ =&gt; divide, :* =&gt; times } already invokes `plus`, `minus`, `divide` and `times` method. What you want is to store the message name (noted the colons): opps = {:+ =&gt; :plus, :- =&gt; :minus, :/ =&gt; :divide, :* =&gt; :times } And then change the last line of `evalutate` to: order.reverse.each {|o| send(opps[o]) }
For a cooler (and lengthier) explanation of functional programming in Ruby using the lazy method, check out Jessica Kerr's talk [Functional Principles for OO Development](http://www.confreaks.com/videos/2382-rmw2013-functional-principles-for-oo-development).
Just don't assume that the levels of monkey-patching, metaprogramming, and other "esoteric" parts of the language are used as commonly everywhere as they are in Rails.
I think I'm understanding this.. but I'm having a hard time wrapping my mind around how to apply it to this.... but I'm still reading!
I agree that it can be learned from, but Ruby is primarily an OO language, and forcing it to do functional doesn't always bode well. As you said, this is a ... Viable example for Ruby 2.0. One of Ruby's primary strengths is that it it has a high potential for readability when you're done. And that is usually one of my primary concerns when I write code: who will be able to read it in a year, and how long will it take them to understand it?
It should be roughly equivalent. I don't actually know what #lazy will do on CSV.new but I know that using Avdi's method _actually_ only loads one line of the CSV file in memory at a time.
That sounds like a neat workflow. Do you have a blog entry, a tutorial, or things you could link to, in order to get me kickstarted on the path? Or shall I just use Teh G00Gle ?
This is the first time I've seen this explained. Thanks!
Do you really think you know Ruby *well*? It's a biggish language with a lot of bits and bobs you can gloss over in an introductory lesson but come back to and really learn now that you have a gist of the language. I'd read a book or two before branching out. My first pick would be Sandi Metz's [Practical Object-Oriented Design in Ruby (POODR)](http://www.poodr.com).
I agree with everything postmodern stated. I've been using Padrino for over 2 years now after working with vanilla Sinatra for various services. The organization it provides while still remaining bare and easily extensible is outstanding. Padrino is the basis for my company's core application (web front-end with several sub-apps serving as APIs and managers for workers that fetch data from various sources). Counting our in house libraries and pieces outside of the web portion, we're sitting around 60,000 lines of code. Boot times are fast, memory utilization is great. Tacking on atypical features is relatively simple since you're dealing with Sinatra at the core (ie, using Celluloid, I've modified the router to asynchronously perform configurable metrics per route, for example, a call to a fuzzy search logs the traditional metrics, size, access time, etc, but I can record metadata such as number of results returned, results by region, and so on). I recommend taking the time to at least investigate and give it a try, while it may be slightly more work and slightly more difficult to get some things going as opposed to a batteries-included framework like Rails, once you wrap your head around the framework and utilize its looseness to create your own patterns, you'll be very happy and better yet, very productive.
Personally, I'm wary of defining class methods without `def self.method_name`. In big codebases, it can become easy to accidentally do something to a class method that you think is an instance method. You can still create private class methods without having to use a `class &lt;&lt; klass` block, though, using [`private_class_method`](http://ruby-doc.org/core-2.1.0/Module.html#method-i-private_class_method): class MyClass def self.foo "foo" end def self.bar "bar" end private_class_method :bar end `MyClass.foo` will be public, and `MyClass.bar` will be private. Additionally, if you're on Ruby 2.1, method definitions actually return symbols, so you can do this: class MyClass def self.foo "foo" end private_class_method def self.bar "bar" end end It looks a little strange at first, but my teams been refactoring `class &lt;&lt; self` blocks out of our code recently into this and have been much happier with it.
&gt; In big codebases Some frameworks really REALLY want you to put everything on one big file, but one of the things that really liberated my code was breaking large things into smaller pieces by whatever means fit the bill, including having more than one file for a class. Edit: forgot the seocnd half of my reply! I prefer : class &lt;&lt; Sample # ... end To the `class &lt;&lt; self` syntax. It really is hard to parse `class &lt;&lt; self` inline with instance methods, and it's confusing to sort out what `self` means if you're doing other things. `def self.foo` is obviously fine if all you want are instance methods with no other metaprogramming involved. But *if* you're putting class methods in another block and/or file, `class &lt;&lt; Sample` seems like the simplest and easiest to understand convention to my eyes. 
Sure, javascript isn't all wine and roses - I just think OP had an incorrect perception of it being an unusually complicated language.
*Someone's* been reading Understanding Computation.
Forgiving the awkward name, this is a pretty thorough and well-written interpreter. I've been thinking of doing something similar, adding features like simple optimizations, hotspot detection, and various other statistics about the program itself. For now, I'll settle for having sent you a PR that permits actually running the specs you've written. :)
They do have [guides](http://www.padrinorb.com/guides), a [screencast](http://www.padrinorb.com/guides/blog-tutorial) and extensive YARD [documentation](http://www.padrinorb.com/api/index.html).
Also forgot they are working on a [book](https://github.com/matthias-guenther/padrino-book), similar to the [Sinatra Book](http://sinatra-book.gittr.com/).
Sure, but that's beside the point. You're still wasting time trying to parse a giant block of code and make sure you're mentally clear on what's what.
Not ruby specific, but I find that if I have `private` methods that need to be tested, chances are those methods should be encapsulated into an entirely new module.
The worst case here is double pipeline assignment aka memoization. I've did it once and then i've stopped using self &lt;&lt; class after huge mess on production server because of it... class &lt;&lt; self def get_user(id) user = fetch(id) ... user end def fetch(id) @data ||= RestClient.get(...) end end This was really pain in the ass to debug as for my account it worked ok, but then someone else hit the server and he got my data...
I agree. ``private`` methods should ideally be an implementation detail that don't need to be tested directly.
http://rubular.com/r/8Ap4RGNhoZ
That regex is wrong... http://rubular.com/r/hBmSU0GK2L
I'm well-meaning and I'm not intending to be a prick in any way. But, why aren't you utilizing URI? [Ruby Doc - URI (2.1.0)](http://www.ruby-doc.org/stdlib-2.1.0/libdoc/uri/rdoc/URI.html)
it looks like it is the: ([\/\w \.-]*)* Is there a reason you need to match those characters {0,} and then match the subpattern {0,} as well, that doesn't quite make sense to me, and I'm not sure what you mean by it. a string of "a/bds/.sd/a" could either match the whole thing or have sub patterns for each character, or anywhere in between. I'm guessing other regex implementations are just greedy and will give you the whole thing in one sub-pattern (remove outer *) where ruby might be checking all the possibilities.
You two aren't saying the same thing. But you both can be right. private methods should only exist after they are extracted from code that has been tested. They should be helper functions that are extracted to reduce duplication or to provide a more meaningful name to a chunk of logic , you shouldn't set out to write a private method. Sometimes though, too many private methods are a symptom of a god class, thats fsho.
Yeah I just piggy backed on the comment since I didn't want to make two separate comments - one stating that I agreed and another on what I thought a private method should be. I agree with you that ``private`` methods in general should be extracted from an already tested public method. This would ensure that the private method is getting tested indirectly through the public method, and thus, wouldn't require it's own test. As you said, sometimes a large number of ``private`` methods could be a code smell; however, I, personally, wouldn't use the number of private methods as a metric for deciding when a class is doing too much. Also, upvote for "Hook" reference.
So, less time browsing Reddit during deploys. Damn...
I think a war between languages is stupid! Javscript is pretty awesome nowadays and you can do a lot stuff with it, specially with tools like Node JS, Meteor, Ember, Angular and so on. But I think in my humble opinion as UX/UI-designer-Front-developer, Ruby is a fantastic language and plenty of life in near future. I receive continually job offers for Rails developer although I'm not a Ruby developer. This a thermometer of the state of this language in the industry. Also as a designer, I need to say I love the poetry the Zen and minimalism behind ruby.
&gt; I think a war between languages is stupid! That's nice, dear.
Yep, I did exactly this, recently. Someone created a class method in a `class &lt;&lt; self` block with the same name as an instance method. They did almost identical things (I know) and I memoized the wrong one.
You just have to add a little sleep time. After you open the connection, add some wait time and then try sending your data. I recommend you experiment with times between 0.5 and 4 seconds. If it makes it easier to reason about, try this: SerialPort.open('/dev/tty.....', blah) do |sp| sleep 2 sp.write('some craps') end 
I guess I should have mentioned in StackOverflow that I've tried that to no avail :/
Started reading that book after seeing this comment. Can't put it down.
Let's take `/^(a*)*$/` : "ab" =~ /^(a*)*$/ =&gt; nil "aab" =~ /^(a*)*$/ =&gt; nil "aaab" =~ /^(a*)*$/ =&gt; nil "aaaab" =~ /^(a*)*$/ =&gt; nil "aaaaaaaaaaaaaaaaab" =~ /^(a*)*$/ =&gt; nil (long !) Imagine that the regexp engine would have to walk in and out every combination to be able to tell "no match". http://en.wikipedia.org/wiki/ReDoS The a more correct regexp would be regex = %r{^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)\/?$}
Have you considered RAD? http://rad.rubyforge.org/
In your script, have it output the current ruby version. Maybe executing the file alone runs the code in a different ruby version that's incompatible with that version of serial-port. Also, based on your other circumstance where you can't copy-paste, try outputting stuff in every other line to see if the copy-pasted code outputs all of those lines. If not, maybe there's a corrupted part of the file somewhere? I don't know. Just guessing here.
I disagree - if you can read someone's code and understand what it does (and it works) then leave others alone and go do something usefull instead of being a jerk. If you hate it so much *you* fix it and ask the original author to review your changes to look for errors.
I think you're missing the point here. The point isn't to be a jerk. It is to enforce style, maybe even passion, across the team. Perfection is driven from passion and in that you can get clean, maintainable codebases that are consistent. I don't want to pick up code from someone else and inherit their TODO list or their general lack of organization. Nor do I want to inherit a codebase that lacks a certain, consistent style guide. My point was also that a codebase should be "personality-free". Everyone should have the same "personality" within the code. No conflicting styles. No conflicting organization. Just simplicity and consistency. It makes everyone's life easier and the so-called "better" engineers and programmers within a team can help to level-up the people under AND across from them.
'cause Smalltalk had them! Good article by the way.
 puts "#{(4...10).map{|x|x**2}}"
I miss _why.
This task is likely I/O bound so parallelization might not help. Can you measure your maximum disk throughput and then measure the throughput of your script? Are they similar? If you use something like the above, you are right that MRI Ruby uses green threads. If your task is, for instance, making network requests or other IO, the green threads are smart enough to truly parallelize that. Or, you can use jruby which has full on threading. But if you go with processes, I'd dump the Thead.new lines from your example. Also, don't create a new process per directory, instead base the number of processes on the number of CPU cores you have and divide all of the directories among your processes like xargs would do. There are pre-existing Ruby libraries for this. Also you will probably need to wait on all of your processes at the end. 
Don't get me wrong, it's a nice and informative post. Totally agree with you that knowing is better than not knowing, just made me think of a related topic that's been on my mind recently. Sorry, didn't mean to derail too badly :)
Commented on the post, but thought I'd share it here too: Ruby enumerables have some other really useful 'block methods' in addition to #each. For example, the *total* function in the post can be a one liner with #inject: prices.inject { |amount, price| amount + prices } or more concisely and elegantly: prices.inject(&amp;:+) http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-inject
&gt; Ruby Doc - URI (2.1.0) URI is deeply flawed. for example: require 'uri' uri = URI('http://salimane') =&gt; #&lt;URI::HTTP:0x007fd20982a220 URL:http://salimane&gt; uri.scheme =&gt; "http" uri.host =&gt; "salimane" 
I must be missing something because that looks correct to me.
&gt; ([\da-z.-]+).([a-z.]{2,6})([/\w .-]*)/?$} at least tell me that it's wrong fast, right ? 
Exactly. Map, reduce, select, reject, and find are incredibly handy tools. I like to avoid the 'inject' alias as it's an uncommon word for that function, but it does the same thing.
Don't be a jerk... just let the tooling play the bad cop. Use feature branches, do automatic review on them, enfore also human reviews, use github commit status,... Small Ads : For the automatic review take a look at https://www.pullreview.com/ 
I actually looked at that and it made me really angry lol :) I've seen an @$250,000 bug caused by someone (in the name of "style") deleting a comment because they didn't understand the relevance to the code and and a few years down the line another developer doing something that they wouldn't have done had the comment been there. Sure the comment should have been in big xxxxxx **neon** lights, hell it should have been extracted onto its own goddamn library with 1000 lines of documentation and about 5 lines of code but I suspect that the original developer never expected a couple of days coding to have formed the core of a multimillion $ product. Or someone to have been stupid enough to come and delete the comments in order to make their code "beautiful". By all means style guides, coding standards, and reviews are GREAT; but good GOD man!!! Taking a piece of code where there is a private method which says "this does nothing" (RED FLAG!!) and ripping that comment out rather than investigating what it does and either documenting or refactoring it?!! Seriously...I would be having serious words about the value of aesthetics with someone. 
I like how rails implements .sum. I even sometimes feel like adding .avg and .median to Enumerable.
I've some python talking to an arduino successfully which I initialize with: serial.Serial('/dev/ttyACM0', 9600, bytesize=8, parity='N', stopbits=1, timeout=1) You might want to fire up minicom (or similar) and experiment.... 
I've grown tired of this kind of tone, where they have all the answers and know whats best. Whatever useful bits of information that could be plucked from this, is entirely lost in the delivery. 
This anecdote doesn't really make any argument against tidying code up or cleaning old comments. It sounds like there needed to be more caution in the code base but not that it shouldn't be tidied up. 
I keep telling myself to learn more Python, and to try to *really* learn Ruby idioms like lambdas, coroutines etc.
The anecdote is there to illustrate the impact of *deleting* comments as advocated by the op. Understanding the value of cognitive artifacts isn't easy and purging comments based on aesthetic value is plain reckless.
Yes, pure aesthetics isn't the point though. The refactoring should be towards clarification and comprehensibility. The straw man you bring up though is easy to knock down because the scenario sounds like there were deeper problems with the team and code base.
&gt; The refactoring should be towards clarification and comprehensibility. Did you read the article? _"Did you notice the comments? They're dead."_ That blanket attitude to commenting isn't being done for clarification or comprehensibility, its being done because someone doesn't like seeing other peoples 'shout outs'. Trying to grok a new large code-base and having to look through a commit history to understand what the original developer was thinking because someone nuked the comments sucks. Just as code should be refactored, so should documentation, of which comments are a part. &gt; "there were deeper problems with the team and code base" Believe it or not, they were pretty good. Everyone makes mistakes its just some cost more than others.
No, it's a *good* detail, that's the way of the Internet. In fact, there's probably a great post **you** could write about little things like that: What choices do you make differently for a massive code base (# of files) or for massive entities (# of lines in a file or related set of files?)
Blocks are just a poor substitute for the lack of first-class functions. I like having them in Ruby as opposed to not having them because they enable a more functional style of writing code, but having used Scheme, Elisp, and JavaScript, blocks are pretty weak by comparison.
Thanks! I will cross-post, too.
It's a good reminder. Not everyone knows that it's obvious. I'm sure you did not know it was obvious at some point.
what would your first class functions look like in ruby? isn't that what Symbol#to_proc and Method#to_proc do?
This process is running on some pretty high grade, underutilized hardware and the files I'm reading are quite small so I don't think regular file IO would be my issue (though I can try and confirm that). I have somewhere around 18 directories to process and a 24 core system so I think forking by directory makes for a rather natural split rather than adding the complexity of a different queue. Would the additional threading likely just build up overhead without really capitalizing on the network IO type stuff? A more general question - when threading something, should efforts be made to limit the number of threads? If you're doing 1000 things is it efficient to spawn 1000 threads and allow them to all duke it out and collect everything at the end or is it better to create a thread pool of something more like the available cores and have them pick away at the list? Thanks!
I think you've nailed it here. It's about clarity and consistency.
I think that's eventually the case, when the tools can match your style guide and enforce consistency. We use rubocop here at our office and that seems to get us to a consistent style. I'll check out pullreview.com and give it a whirl. Thanks!
I would suggest checking out the tools I mentioned in the article and using rubocop to help embrace a consistent code style. https://github.com/bbatsov/rubocop
I subscribe to the idea that most methods should be documented with comments. I shouldn't have to read all the code every time I want to use a method or class. The comments should save me a lot of reading. It's been reviewed already. I shouldn't need to read the code again each time.
Say "hi!" To Brad, JC &amp; Joe for me. ;)
You either need to do it or you don't. The client either wants it or they don't. Either delete the TODO or do it. TODOs are usually a personal note and don't belong in communal source such as the code base. 
Some of them say he's a badass developer and project lead.
&gt; self document the method There's no such thing :) Damn I thought I'd written a blog post on that - basically the entire idea of self-documenting code falls down if you're in a multilingual team. Documentation/comments/plain language often will make sense if thrown into google translate. Method/variable names though tend to fail miserably. Once you also throw the nuisance of language into the mix, I believe the idea is very brittle... Part of the problem with comments though is a language problem. The "comment" no longer fulfils its role. Sometimes its just not possible to communicate through code the diversity of reasons that a piece of code is the way it is. Sometimes understanding the thought process behind the evolution of a piece of code is as important than the code itself. The diversity of use for comments is very wide and sadly, there is no tool that has the *robustness* of code to serve as the medium for this cognition. 
This sounds like a recipe for developing a reputation as a know-it-all / asshole. I have a developer that would take this to heart.... And undo all the work we've done making him capable of working as part of a team.
Unfortunately it does not support self-hosted Git repositories. Only Github is supported. :(
It is planned. BitBucket &amp; self hosted. See at the bottom of http://blog.drone.io/2014/2/5/open-source-ci-docker.html for a couple things on their roadmap. :)
I also started my own CI as a service for fun last year, but it is more work than one could think! hehe Nowadays I use Codeship at work and it's really awesome. Minutes to setup vs hours for Jenkins, at best.
I think the point is to NOT be an asshole but rather collectively construct a style that makes it easy to become part of a team that creates consistent and readable codebases. In no way am I saying that anyone should detract from the work of others. I think I went as far to say that the team is responsible for pairing and knowledge sharing that often boosts morale and skill sets. Being a "cop" is often associated with being a jerk but the point is that there should be organization and style enforced at the team level so nobody has to play the bad guy or be crazy. Enforcement only gives reputation, like you say, as a know-it-all or bad seed if nobody buys into the fact that consistency breeds readability which then in turn gives you mobility and portability.
That's a great point! Plus, it's a clear exception to what I think I was trying to convey. Having worked with multilingual teams, I found myself wanting more documentation than commenting. Maybe, if in the Rubyland, RDoc or Yardoc would be appropriate which could alway use translations (if their are enough resources to do some translations for the team).
Really glad to hear you've had such a great experience with our framework! Seems like you really appreciate the reasons why we built it and why to this day I do almost all my web development using it.
Thanks for posting this to reddit and helping expose new people to our framework. Really hope we can get to a great 1.0 soon, get a new website going and update our docs.
I was kind of surprised none of the padrino developers posted it to /r/ruby before me. :) Looking forward to the continued improvements.
Anyone actually get this to work? I tried for about 45 minutes and then gave up.
thanks, i was just looking into this
You are comparing two objects. When you see &lt;Dog...&gt; without the quotes, ruby is printing the inspected string representation of an object because that is how it communicates about objects with humans. When you see quotes, ruby is telling you, here is a string (a special case of an object). Self, on the first assertion, is just another name for the object (instance) of fido. You need to assert that the self in the class is the same object as fido out of the class.
Why it works is because a class is one object that works with multiple instance objects. The class has to refer to it's instance objects in some general way. Ruby uses self to refer to instance objects.
I don't think it takes me any more time to apt-get install jenkins and have my project up and running.
oh, another lame blog that repeats something written a billion times before without adding a single line of new information. (And where is the context to Soylent Green?)
In that case, maybe releasing such a braggart blog entry was premature :)
Hi, OP here, About something written a billion time - still something people are talking about, so probably not "resolved" either. Hope it was still useful for some - clearly not for you, it seems. About Soylent Green, looks like the reference is less known that I thought - in the end, the main character screams "What? Soylent Green is -people-?". Did not intend to make it a linkbait. 
I think this is resolved as far as your blog goes: Mostly everybody agrees that names should be descriptive. (At least I didn't hear any discussions about that for a long time) The problems start when it's about what really is a good name and some details about preferring nouns, verbs, adjectives or whatever for certain types of methods. (And that's often a question between different communities, Java people name things different from Rubyists). I still do not fully get the Soylent reference. I'm quite aware of the "Soylent Green is people" thing (though I thought it's more like a statement, not a question). So you just mean to use it as a kind of surprise about a wrong name? 
You are probably better than me then! ;) Also, this is not the only reason why I have never been a Jenkins fan. That said, there are different tools, for different needs &amp; preferences. Cheers
Heh. No, I am very excited to try it but in programming, nothing ever takes 10 minutes :P
you could be surprised, in that case! At least, I was. This is the reason why I decided to blog about it! :)
If reading the code has more mental baggage than reading the comment, something is really wrong with the code.
I don't think your answer in `test_inside_a_method_self_refers_to_the_containing_object` is what the author was expecting. I think you should rather test if `fido` is the same as `fido_self`. In the `test_to_s_provides_a_string_version_of_the_object` you have to implement `to_s`. This ~~function~~ method is called whenever something is turned into a string, eg. when you want to print something. If you don't implement this function, Ruby will create it's own string representation containing the Classname. Edit: functions belonging to objects are called methods. Class methods and instance methods. `self` just gives you the context you are in. It is a special object, which enables code to know the something about the context it runs in. [6] pry(main)&gt; class Dog [6] pry(main)* def self.class_self [6] pry(main)* self [6] pry(main)* end [6] pry(main)* def instance_self [6] pry(main)* self [6] pry(main)* end [6] pry(main)* end =&gt; nil [7] pry(main)&gt; Dog.class_self =&gt; Dog [8] pry(main)&gt; Dog.new.instance_self =&gt; #&lt;Dog:0x007fbe83136f20&gt; [9] pry(main)&gt; class Dog [9] pry(main)* def self.to_s [9] pry(main)* "class Dog" [9] pry(main)* end [9] pry(main)* def to_s [9] pry(main)* "instance dog" [9] pry(main)* end [9] pry(main)* end =&gt; nil [10] pry(main)&gt; Dog.to_s =&gt; "class Dog" [11] pry(main)&gt; Dog.new.to_s =&gt; "instance dog" Whenever Ruby needs an implicit String representing an object, it calls `object.to_s`. Best example for this is inside [string interpolation](https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#Interpolation) And self is really just a special named object. It's a good convention to use it, but you don't have to use it: [23] pry(main)&gt; class Blub [23] pry(main)* end =&gt; nil [24] pry(main)&gt; def Blub.to_s [24] pry(main)* "this is class Blub" [24] pry(main)* end =&gt; nil [26] pry(main)&gt; Blub.to_s =&gt; "this is class Blub" 
Parallel seems like a pretty good option for what I was looking for - I wonder why I didn't come across this when I was looking.. Perhaps I should have been searching 'ruby threading gem' rather than just 'ruby threading' I ended up implementing threading on the directory level and saw something like 60-80% time reduction. In case anyone is looking for an example using the built in bits, this is a basic version of what I did. It worked well because I have essentially no communication between threads as all that comes out is a string containing the errors found (which is logged and emailed). Additionally my script shells out to the external programs giving require 'thread' all_the_results = [] threads = [] mutex = Mutex.new directories.each do |directory_to_thread| threads &lt;&lt; Thread.new(directory_to_thread) { |directory| directory_results = [] Dir.entries(directory.each do |file| #process the files in the directory directory_results &lt;&lt; file_results end mutex.sychronize do all_the_results &lt;&lt; directory_results end } end treads.each { |thread| tread.join } #do stuff with all_the_results 
I have no use for this now, but I'm bookmarking it for the inevitable later need.
Classes and Modules may have dozens of methods. I shouldn't have to read each of those methods each time I intend to use those methods. I also shouldn't have to hold all of them in my head, particularly if I don't touch that portion of code often.
Of course not! But the class name should tell the story of its' responsibility, and the method names should tell the story of what they do. Code should be written such that you can move up and down those levels of detail easily and quickly.
Link to the [ChangeLog](https://github.com/postmodern/ruby-install/blob/master/ChangeLog.md) for the curious.
I prefer the term consistent. When contributors see a consistent style throughout the entire code-base, they usually try to mimic it, to improve the odds of getting their commits merged. Instead of being a cop/jerk, I will go over Pull Requests and make various Style commits.
Not yet, but I am planning on adding functionality to generate the deb/rpm specs and build the packages. For now you could install into fakeroot and use fpm to package the contents up. Note, newer versions of Ruby do require newer versions of GCC, OpenSSL, so you may have to package those as well.
I'm not obsessed with it being the latest and greatest. Cent6 ships with 1.8.7 which is **oooooold**. Ruby isn't our core language, I'm just using it for lots of operational utilities. I'd be willing to ship JRuby too, the JVM is awesome and logstash is doing it :P
When is RedHat going to merge Fedora's packages into RHEL/CentOS? Fedora has been awesome at keeping up with new versions.
I don't recall how packages flow between Fedora and RHEL. RHEL has introduced the idea of "software collections", which are standalone environments in /opt that can be used to deploy up-to-date runtimes and applications. there is a Ruby one in RHEL, although I forget what the system requirements are: it may be 6.5 or 7+. I believe TheForeman project is now using a Ruby SCL to have a reasonably current runtime. as I said, this is all pretty passive. I can make do with 1.8.7 and bundler, I'd just rather not. I do regularly find features in RubyDoc that were introduced in 1.9 or 2.0.
Thanks..I'll definitely check this out
No one should have to make due with 1.8.x. It's performance is terrible compared to 1.9/2.0.
Or Puppet's Ruby, for Vagrant setups. http://forge.puppetlabs.com/example42/ruby
RVM is a Ruby eVironment Manager (read: it does _way_ more than just install rubies). ruby-install only installs rubies. So the biggest difference is that the ruby installation tool is decoupled from the ruby switcher. If you need to use multiple rubies, you can use ruby-install with [chruby](https://github.com/postmodern/chruby#readme). It is also possible to use ruby-install with [RVM or rbenv](https://github.com/postmodern/ruby-install#integration).
This is bad form. You should only use pry in development. If you want to test production data then use a dev box to hit it. You can put binding.pry anywhere in your code and call the method from irb.
Meh. Spent a lot of time doing one off work in console in production. Not that big of a deal. Still working with the app and it's better than mucking about straight on the db where you circumvent app logic. Just be careful! Oh, and these were major multimillion dollar generating systems so it was stressful to log in until one got used to the idea. Eventually we did change console from hitting our master to working of replica dbs but that's a different story.
An upvote doesn't do this justice. Thanks from me as well! We now use chruby/ruby-install in all our deployments and test environments!
Github's official Ruby API `octokit.rb` uses VCR to test the client. Here is how it is configured in [`spec/helper.rb`](https://github.com/octokit/octokit.rb/blob/master/spec/helper.rb#L23) and then it is used like [this](https://github.com/octokit/octokit.rb/search?q=vcr&amp;ref=cmdform). Does this help? In a project I worked with, we also had a little bit of challenge to set up VCR properly. But once we figured out how to migrate from fakeweb to VCR/webmock it was pretty easy. And VCR is currently the best Ruby HTTP-mocking lib I know.
 "You should only use Pry in development." Why? 
There are some beta packages for Centos available somewhere, but it is kinda hard to google for.
Hi, OP here, The post explains my vision on getting your naming better by getting it reviewed. The title was a simple humorous attempt (which did not work well, but that's another problem). Yes, we do have (and sell) a code review tool, and some people find us via our blog (note that this specific post have nothing do to with our tool, as it concerns "human" code review). Could you care to explains what is the exact problem here? This does not looks linked to the post itself (another commenter found it bad and was pretty clear on it, which it pertectly fine with me). Martin
I've had better experiences with straight webmock, personally. VCR makes things like replaying requests when the remote API changes really easy, and that is quite nice. However, pure webmock is really nice, too. Now, with webmock, your tests end up being very explicit, which makes it painful to litter webmocks everywhere, but I've had success solving that smell by isolating the service requests into singleton objects that wrap the requests in methods that make sense to your domain. The nice thing about singleton objects is that they are very easy and clean to mock, so I generally have my integration tests mock *those* service objects, and leave the HTTP testing to the service objects. It's actually pretty nice to *not* have HTTP concerns littering your tests everywhere, even if VCR manages this behind the scenes for you. All that being said, VCR is pretty cool, and I don't think it's a bad way to go at all. TL;DR - VCR is a fantastic choice if you want any integration/acceptance test to be able to hit HTTP. If you're comfortable introducing a service layer between your external services and your app, webmock is an approach that works just as well, and has the virtue of being much lighter weight (and less magical).
If I understand you correct, you essentially decouple a REST-API and the consuming code through a Singleton Service object. This indeed makes testing much easier, because you can just mock this service. You just test your code and the test won't break if the service isn't available for a while. But for our testcase we had to make sure, the API we were questioning would actually return the JSON we expect. Sometimes the API changes and our VCR tests ensure we know what changed as fast as we can. Do you mind to be a little bit more specific about what your services look like?
Maybe you need to install xcode first. Also, make sure you have ruby installed first.
Is these an easy way to upgrade ruby-install (and chruby)? For example to upgrade RVM, all you have to do is "rvm get stable". While to upgrade ruby-install/chruby you have to pull the latest changes and then run make. Not hard really, but I would prefer something like "ruby-install -u".
thanks; downloading Xcode now. I searched on installing Ruby after reading your reply, do I need homebrew installed in order to get Ruby? Or I can just install Ruby in the terminal regardless of wether or not I have home-brew installed? 
I'd recommend you get homebrew installed, then install ruby via RVM http://rvm.io/ It'll likely be the most straightforward way for you to get started.
that's the problem though, I run into an error when I try installing home-brew :(
You also need to install Xcode command line tools. http://stackoverflow.com/questions/9329243/xcode-4-4-and-later-install-command-line-tools
on OSX ruby should be installed by default but it's an old version. You should be able to install homebrew first then update it later.
If you're having problems just use nitrous.io in the mean while.
Very glad I could help out, I would love to hear what you liked and didn't like and any other topics you think would be helpful!
FYI you probably don't need chruby in production. One app, one user, one ruby (installed into `/usr/local`).
If you installed ruby-install via homebrew, then `brew upgrade ruby-install`, otherwise you just install the new version over the old one. Imho, a tool should not be able to update itself. I thought about adding the ability to update the metadata (`versions.txt` and `md5.txt` files), but then you eventually run into backwards compatibility issues when the metadata format changes. There is also a [rpm spec](https://github.com/postmodern/ruby-install/blob/master/rpm/ruby-install.spec) and we're working on writing a debian one. Perhaps in the future you will be able to run `apt-get upgrade ruby-install` or `yum update ruby-install`.
I recommend you check out my tutorial at rubymadeeasy.wordpress.com, hope it helps!
Hi Martin, sorry I was a little harsh. The post seemed to offer something interesting and failed to deliver. Given how obvious the marketing impetus is behind the post, it elicited a negative reaction from me. Or I was just feeling extra grouchy :)
Why use ruby-install over apt, brew, chocolatey, or individual .deb's, .rpm's, .pkg's, .msi's... ?
Don't bother with rvm yet. If you're just learning ruby you don't need it, and it'll just complicate things. You might never need it. The only thing you need to do is install Xcode and Xcode command line tools, then homebrew should work.
Probably want to choose which framework you want to use first: https://www.ruby-toolbox.com/categories/GUI_Frameworks Are you planning on writing standalone applications with Ruby? Or web apps?
ruby-install allows installing arbitrary versions into arbitrary locations, and allows arbitrary configuration options / applying additional patches. Also, ruby-install installs all build dependencies from the package manager.
The problem with that is unless a user is on OS X 10.9 they'll have ruby 1.8 as the system ruby. For anyone reading this who isn't familiar with ruby - 1.8 is no longer supported, most applications in the wild are 1.9.2, or 1.9.3 - with many moving to 2.0 or 2.1 - rvm is the most beginner friendly of the tools available to easily install a more modern ruby version
http://libtorrent-ruby.rubyforge.org/ Look through that. 
I downloaded the .tar.gz and 7z says it's broken, but the library sounds promising. Thanks for the link. I'll keep trying to get it working.
Maybe https://github.com/nullobject/libtorrent-ruby then? 
That should do it. Thanks.
Unfortunately, Ruby isn't so great at GUIs (from my experience). But, there are [various](https://www.ruby-toolbox.com/categories/GUI_Frameworks) libraries. I, also on Windows 7, run Ruby natively and never could get [Shoes](https://rubygems.org/gems/shoes) working, so I've used Tk, but it's slow as a sloth and not really that great. So I don't recommend using Ruby to do your GUI gruntwork. I think that Ruby is a better back-end to GUIs.
Webmock will continue giving you green dots, even after the service you're mocking changes. That problem is simply beyond its' purvue. However, when an API changes, you can change your mock, and get pretty much instant feedback from it. It's never hard to get that kind of red dot to turn green. Webmock is never going to be ideal for integrating with an API that changes more than once or twice a year. But, on the other hand, why integrate with an API that changes more than once or twice a year? :) VCR is cool. I'm just saying that I've gotten some good mileage out of Webmock, and I like it a lot for my workflow.
As much as I hate to deliver bad news about Ruby, I agree with this comment. Ruby isn't super-convenient to work with to create GUIs, and doubly so on Windows. If you're willing to learn more about another programming language, then I would very much recommend C#, Java, or C++ when creating Windows GUI applications. There will be a higher time investment up front, but each of those communities will have vast resources to help you learn to build GUI apps. That being said, you do have options. If your goal is to create a GUI application that will look and feel roughly like every other GUI app on Windows, then you will have to write it for a version of Ruby that can run on Windows, not through VirtualBox. If you're willing to give JRuby (an implementation of Ruby written in Java) a shot, then you'll have access to all of the tools that the Java community has created for GUI applications. This can still be a bit painful, as you'll have to learn all about how Java GUI applications are built and translate that knowledge into Ruby syntax. But the resulting applications can look and feel as good as anything written in Java. Ryan Bates has an excellent [introduction to JRuby that demonstrates a very simple GUI](http://railscasts.com/episodes/376-jruby-basics). If you want to continue using the default MRI implementation of Ruby on Windows, then the only toolkit I've used semi-recently was [qtbindings](https://github.com/ryanmelt/qtbindings). It allows you to use the Qt framework (ordinarily used from within C++ applications) from within Ruby code. You'll have to invest time in understanding how the Qt framework operates normally, and translate that knowledge into Ruby. In any case, best of luck on your project!
Ruby comes with OS X, use that version to install XCode and Homebrew, then install rvm (ruby version manager) view homebrew.
Hi, thanks for the clarification, that is something I can work with.
Exactly what Joe Ferris does in his example ;-)
And whenever you need a special database, using brew is a blessing. Also brew makes updating a breeze. 
+1 for using `fetch`. I hope this will some day become the idiomatic way to access hashes and arrays in Ruby. `nil`s everywhere are so annoying. BTW. You could rewrite your first `map` to: activities.map do |a| { distance: f(a["distance"]), # ... } end which would get rid of the explicit return and the mutation of the argument. Also: Use symbols for hash keys if you can. You save one character and some memory when doing so. Comparing symbols should also be faster than comparing strings. /edit: Using `map!` AND mutating the argument is doing the same thing twice. One of them is sufficient.
You should consider using [`each_with_object`](http://www.ruby-doc.org/core-2.1.0/Enumerable.html#method-i-each_with_object) instead of `reduce` on hashes. You don't have to return the original object. Spelling: "elemnts"
The usage of #map! is incorrect. You're using #map! like an #each here, because you're directly altering the original data. In general, you don't wan't to alter the original. If you really do want to alter the original, you don't do it directly but let #map! and its other bang-friends handle the altering for you. In your case you're working with very distinct structures. You could represent them as a Hash, but it would be much neater to introduce a new class: `Activity`. class Activity def initialize(raw_data) @raw = raw_data end def captured_at @captured_at ||= Time.at(@raw.fetch("captured_at")).to_date end # ... end activies = raw_data.fetch("activities").map { |activity| Activity.new activity } To get your data, you could something like the following: groups = activities.group_by &amp;:created_at groups.map do |date, group| { "distance" =&gt; group.map(&amp;:distance).reduce(:+), "calories" =&gt; group.map(&amp;:calories).reduce(:+), # ... } end It reads a lot clearer, imo.
Hey, thanks for advice. I had a gut feeling that something was wrong with my map there :) Speaking of class activity, my purpose was to work only with hashes in this blog post. In real world I would use something that is more meningful than hash. And this is neat: "distance" =&gt; group.map(&amp;:distance).reduce(:+), Thanks!
There's a sass-bootstrap gem that might be useful for theming if you don't mind doing some of the legwork. It plays nicely with rails. https://github.com/twbs/bootstrap-sass
1. You can use something prebuilt like [Bootstrap](http://getbootstrap.com/), [Foundation](http://foundation.zurb.com/), etc.. If you want to style it yourself but want a solid base, use [Bourbon](http://bourbon.io/), [Neat](http://neat.bourbon.io/), and [Bitters](http://bitters.bourbon.io/) for that. 2. Rails handles all of that for you via ActiveRecord. Basically you have `config/database.yml` which tells ActiveRecord what/how to connect to your database. If you need examples just google for something like "Rails database.yml postgres". 3. http://railscasts.com/episodes/335-deploying-to-a-vps is a very good guide on how to deploy to a server. You don't want to run it via Apache/Nginx in development, but if you want to mimic production a bit just use [Vagrant](http://www.vagrantup.com/). If you have any more questions let me know.
3) You're either going to be using [Phusion Passenger](https://www.phusionpassenger.com/) or setting up a reverse proxy for Nginx/Apache. So your rails app will start on port 8888, then Nginx/Apache just forwards requests from 80 to 8888. You can get fancier than that, but for basic internal shit you don't have any need to at first.
1. Bootstrap or Foundation or other similar CSS framework 2. Data storage is typically handled via ActiveRecord models. Your backend is pretty much plug/play depending on the adapter you use, be it sqlite or mysql or postgres or any other supported dialect. 3. Probably the fastest and least configuration heavy way is Passenger. 
You're 100% right, but as there really aren't many downsides we tend to keep our environments the same for simplicity (at least for all the internal services we're managing). If you know of some reason this is going to blow up in our faces some day, I'll defer to your wisdom! :D
Plus you'll want to learn Capistrano for deployment (there are lots of deployment tools, but I like Capistrano).
Super cool. Thanks for this pointer. I'll have a look at the guide you linked to also. 
I'm partial to puppet, myself. :) Nothing new to learn.
Puppet and Capistrano aren't incompatible. Capistrano does a nice job managing the rails side of deployment; run the asset packager, database migrations, restart unicorn/puma/passenger/whatever. There are some good guides out there for speeding up Capistrano by leveraging git for release rollback.
N00b here: why would RoR be "so bad"?
For deployment, I highly recommend Moonshine, which combines capistrano and puppet into a nice package with sensible defaults. You can use it with Rails 4 by using the plugger gem. https://github.com/railsmachine/moonshine/wiki/Tutorial
&gt;Dev Confession: Maybe RoR isn't so bad and &gt; Ok. Maybe Ruby isn't all that awful. Make up your mind about what you're talking about.
Check out phusion passenger, it's idiot proof for Apache. Bootstrap for themes, if you're lazy like me. And yeah, Rails is alright :) 
So you thought it was awful, THEN created your first simple app? I'd spend more time worrying about making informed decisions than whether X Framework or Y Programming Language is good/bad. Every language &amp; framework has its advantages and disadvantages. Don't get caught up in the religious debates, just tinker (like you now have done), and form your own, educated opinion.
1. Author? no. There are thousands of talented devs I've never heard of, why would I judge based on name alone? 2. Test coverage? Definitely yes. Poor test coverage might (maybe) indicate unknown internal issues you don't want to deal with when integrating it. 3. IMHO, monkey patches are inherently risky, long term. 4. Downloads/popularity are the least important factor for me. I'm looking for the right tool for the job, it doesn't matter to me that other people felt this was the right tool for their job. It's my butt on the line. One of my primary concerns is, if it's FOSS, the level of activity and updates to the project. I don't want to rely on something I can't control that may break my site after an update to my Ruby version, for example. An active project, with recent updates and lots of issue tickets, both open and closed (that aren't outright failures and hopefully more closed than open) indicates a healthy project with support from the dev team. project health and the fit to my need are my primary drivers in using any gem.
I've been doing the same for the past few weeks, so this is what I've picked up on the way: 1. Use the [bootstrap-sass](https://github.com/twbs/bootstrap-sass) gem to implement Bootstrap. (twitter-bootstrap-rails was the obvious choice, but it's outdated as it uses Bootstrap 2.x.) 2. ActiveRecord can use MySQL/MariaDB or Postgres if you like it. Open up ./config/database.yml. [Here's an examle.](https://github.com/cloud66/rails4-mysql-sample/blob/master/config/database.yml) 3. Check out [Phusion Passenger](https://www.phusionpassenger.com/) for Apache. — There's a [Debian package](https://packages.debian.org/wheezy/libapache2-mod-passenger) as well if you're into that sort of thing, and it's pretty easy to set it up. (The trick is to make the ./public/ directory the Document Root.)
Are there any services yet that specialize in either hosting Docker or providing one-click installs?
RoR is fucking awesome. It's the best piece of software, top to bottom, that I have ever seen.
1. Wrapbootstrap or Themeforest and copy the CSS / JS files into the asset pipeline. 2. RoR is database agnostic. You can write the same code for postgres, mysql, sqlite. Just change your .yml file to connect to the db you want. Here is one of the ORM guides: http://guides.rubyonrails.org/active_record_basics.html, http://guides.rubyonrails.org/active_record_querying.html, http://guides.rubyonrails.org/association_basics.html. Configuring: http://guides.rubyonrails.org/configuring.html 3. "git push heroku master" don't eff around and waste time with dev ops. Get the product in the market :).
&gt; Downloads/popularity are the least important factor for me. In many cases popularity is directly correlated with the level of activity and updates to the project. If I made a gem and there were thousands of people using it, I'd be much more inclined to support it.
Sure, but I think that speaks more to my point about project health. Popularity does not necessarily == good code. If it's popular and that spurs devs to support it with pull requests, etc., great, but popularity on its own is not a reliable gauge of quality.
lol. Its more of a dev ops engineer doing some internal tool development than the other way around. What I'm creating is an internal tool for reporting _only_ specific packages across many hosts that are grouped arbitrarily. I think I'll end up accessing puppet-db for the data that I need, but first I need to track the hosts, groups, packages I need to look for, etc. That's why I started with RoR.
Sup troll.
&gt; We will assume that you have a Ubuntu 13.04 (64 bit) server with a routable IP or address. I don't want my CI routable.
I don't know why you think this is trolling. Ruby is a language, Ruby on Rails is a framework. You should make up your mind about which thing you're talking about and stop trying to use them like they're interchangeable.
why are you typing $PATH in terminal? If you are trying to use rvm then you should be able to just type rvm _command_ If you want to view contents of the variable $PATH, type echo $PATH