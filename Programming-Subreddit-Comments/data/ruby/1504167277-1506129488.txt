You can use the [`open-uri`](https://ruby-doc.org/stdlib-2.4.1/libdoc/open-uri/rdoc/OpenURI.html) standard library, which downloads the file in a streaming fashion. require "open-uri" require "fileutils" tempfile = URI.parse("http://somesite.com/audio.mp3").open tempfile.close FileUtils.mv tempfile.path, "audio.mp3" Alternatively you can use [Down](https://github.com/janko-m/down), which is by default a wrapper around `open-uri`. I created it to fix some things I minded or was missing in `open-uri` (Down always returns a `Tempfile`, appends the URL extension to the tempfile path, can limit maximum number of redirects, can limit maximum filesize etc).
Hello, I've updated the [world.db web service starter sample](https://github.com/worlddb/world.db.starter) that gets you started building your own HTTP JSON API using the world.db (incl. continents / countries / states / cities / etc.). What's news? The starter sample now uses the new [webservice library](https://github.com/rubylibs/webservice) (a simplified sinatra 2.0-style library for HTTP JSON APIs). Example: class StarterApp &lt; Webservice::Base include WorldDb::Models # e.g. Continent, Country, State, City, etc. get '/countries(.:format)?' do Country.by_key.all end get '/cities(.:format)?' do City.by_key.all end get '/tag/:slug(.:format)?' do # e.g. /tag/north_america.csv Tag.find_by!( slug: params['slug'] ).countries end ... end Enjoy. Cheers.
Yes, I'm sure all programmers immediately think to write tests such as whether the entity has a `\b` character or to check for a bug that only occurs in a roundabout manner for clients that [happen to be zoomed in](https://www.reddit.com/r/learnprogramming/comments/3do3pk/experienced_programmers_what_is_the_most_bizarre/). ... What two people now have tried to explain is that it's hard to think of every possible obscure bug or case that may arise. Making smaller functions doesn't help with that.
Ruby core guys discussing how to shorten method reference (like ` [1, 4, 9].map(&amp;Math.method(:sqrt))`) syntax. Matz says: &gt; I am for adding syntax sugar for method reference. But I don't like proposed syntax (e.g. `-&gt;`). &gt; Any other idea?
Came here to say this **edit** except I disagree with &gt; and/or the GitHub API hold some responsibility here. Can't blame the API on this one. &gt; I would assuming github would respond with something other than a 2xx for all tokens. Would respond 401 probably. &gt; Granted it's also possible that Github's downtime was incorrectly returning 404 instead of 5xx due to server issues, Extremely unlikely, and in the case that the API is just breaking its contract, there's not much you can do.
It's not weird. GitHub probably doesn't keep track of tokens that have been invalidated, so it doesn't have a way to distinguish between invalid tokens and tokens that have never existed.
I hope Current.attributes gets removed. Not holding my breath, though :-)
I really wish Ruby had built-in concurreny like CSP. Working with [Crystal](https://crystal-lang.org/) made me realize that.
I wish we would have opal integrated and better tools to make the view good enough for today's standard. Something like http://ruby-hyperloop.io/ integrated in rails would be perfect
Good catch can you please send me a PR to move it out of the loop https://github.com/codetriage/codetriage?
When I wrote that you could not paginate through all issues of a repo with the officially supported clients. I wouldn't use my thing if you can help it though as you'll get better support with one of their clients.
Didn't know the gem, remarkable work and outstanding documentation! Will use it for sure 
Github knows the difference between an endpoint that does not exist and a token that does not exist. They don't have to track if a token ever existed to give a different status code here.
I'm really looking forward to [Guilds](http://olivierlacan.com/posts/concurrency-in-ruby-3-with-guilds/). :)
I really wish that there were some "slicker," native way of handling the UI for nested models. As far as I know, the "canonical" way of handling it is [Railscasts #196](http://railscasts.com/episodes/196-nested-model-form-part-1). I've taken to using [Cocoon](https://github.com/nathanvda/cocoon), but the problem is so general that I'm certain that literally 99% of all Rails apps have to deal with it. If that's true, then Rails really ought to incorporate a method for handling this without resorting to a recipe or a gem. Maybe there's just too much variation in the general case that I'm not appreciating, though. On the other hand, maybe DHH has purposely left this hanging, figuring it will eventually be solved neatly by things like React or Angular.
I wish we had collection of well-defined, well-documented (with an RFC) set of core [JSON adapters to choose from](https://github.com/rails-api/active_model_serializers/tree/0-10-stable#high-level-behavior). The current state of affairs is that by default, a new rails-api application will use the "attributes adapter". There is also a built-in "json adapter" and a "json-api adapter" (which is the recommended choice, according to the README). Or, you can write your own custom adaptor (or pull one in from a gem). But *none* of these options feel truly "production ready", yet -- for example, the json-api adaptor is still `v0.x` and there is still lots of debate about its virtues/adoption rate, despite being the "officially recommended choice". Given how web applications are evolving, I'd like to see a proper ecosystem develop - within all frameworks, not just rails. I'd like to see a variety of "official JSON adaptor RFCs", possibly even with built-in ability to use GraphQL.
Have you seen it be abused in the wild? I'd love to know some situations/examples to keep an eye out for. 
Is there a recommended way to transition to webpacker in an existing 5.1 app? Or is it just "follow the install instructions and get it to work?"
Its particularly difficult with Ruby HTTP libraries, in my experience they do a pretty poor job handling exceptions/errors and a worse job documenting it, does anyone know of an HTTP library that handles this sanely, or at least documents it? As an example, last time I needed to use HTTParty to send a request that needed to be retried on system failures I ended up trolling a ton of code/docs for both HTTParty and Net::Http and setting up screwy network conditions to figure out what it would actually do. In the end I came up with this set of types that could either be thrown or returned by `HTTParty.post(...)` which are at least _likely_ to be network condition or temporary server problems. This is kind of a ridiculous list across a number of packages/layers: `[HTTParty::Error, Timeout::Error, SocketError, Errno::ECONNREFUSED, Net::HTTPServerError]`
I love keyword arguments, but I'm missing some kind of "glob pattern" to refer to all of them at once. I might have a method with 4 kw arguments and I have to use two of them in the method and pass the rest on to the next method. That gets either verbose (if you include the kw arguments in the header of both functions) or you lose the locality of error messages (i.e. the "missing keyword" error doesn't happen at the call site of the actual bug). Haskell has a special glob@pattern syntax for pattern matchings for example.
Just add concurrent-ruby and use Rails 4.2 with JRuby :) (currently there's no support for the jdbc adapter for posgresql and Rails 5.x)
Ability to specify types in function signatures. With exceptions on type mismatch. Damn it would be great to have. As an optional feature, of course. 
I miss using it period lol. Currently using Elixir/Phoenix because it's a lot faster with good multithreading so boss opted for it for our current project. So I guess you could say speed, need Ruby 3, it's supposed to get close to Elixir speeds.
concurrent-ruby is nice but it would be nice to have something built in.
This is kinda content-less. 
The good news: it's always 4 AM *somewhere.* The bad news: it'll likely be 4 AM *here* before I'm asleep. Again. I take your meaning with the different workflows/playbooks; my initial POC/learning experience led me *significantly* astray. Correcting... **thwack!** Right. Onward! Thanks again!
Oh I thought three times in one sentence basically.
Note that ActiveModelSerializers is not part of Rails. The attributes/json adapters exist mainly for historical reasons. 
"Node.js Google searches have surpassed Rails Google searches? The old king is dead, long live the king!"
AMS maintainer here. Highly recommend jsonapi-rb
I want:. - object deconstruction. - guilds. - deoptimization. - spread (`...`) for arrays and hashes. - object key shorthand ( `{ key } == { key: key }` ). - piping. - maaaaybe native async/await (to run loop or actor/eventedness).
&gt; jsonapi-rb Just glanced through the README.... It looks like a clean library for building *custom* JSON formats, but this doesn't really solve my desire to have some well-defined standard adapter pattern(s)? AMS already provides a few adaptors, but none of them feel 100% "complete" or "official" yet.
This is true, but it's the arguably the closest thing to an "official" library. `rails-api` is now bundled into core `rails`, and its README [recommends](https://github.com/rails-api/rails-api/tree/91c6c35a3babfcec535e7e2469eca8aa49289b4a#serialization) using the `ActiveModelSerializers` library. And the issue still remains that there's no built-in, well-defined set of JSON adapters in the rails framework. (And the same could be said for many frameworks in other languages too, which is also problematic IMO!)
This README is outdated, as development of `rails-api` after the merge took place in the rails/rails repo. There were talks of merging AMS into rails along with rails-api, but this is no longer under discussion.
I can never understand why search volume is considered shorthand for success of a language/platform. I mean, you could equally surmise that more newbies having all kinds of weird problems with new tech and searching for answers is a potential knock *against* the tech with more search traffic.
It is not – it is an implementation of the http://jsonapi.org spec.
Ah yes. I've stayed with rails all these years because of the "Easy functions and manipulations." God i hate how hard it is to do manipulations in Node. 
Create your own form object and abstract out what you need precisely to build the nested objects. 
Regarding `described_class`, for me that it is the in-spec equivalent of `self`. It feels less repetitious to me. Using `subject` simply supports the usage of single-line-expectation.
How is the statement: &gt; We suggest using `ActiveModel::Serializers` out of date? Is something else suggested instead now?
What should the status code be? Not sure I understand your point.
&gt; You don't always know what obscure issues could pop up. I agree with your point but as /u/moomaka points out this is not an obscure issue. OP chose not to read the documentation. Documentation says 404 response means the token is bad. He was throwing out tokens on any error response, including presumably 5** server errors. This is honestly a very basic and fundamental error in a REST client.
Just follow the instructions. You propably need Node and Yarn on the server to run webpack there (unless you compile your assets locally as part of your deployment). With Rails 4.2 and Capistrano I found [`capistrano-yarn`](https://rubygems.org/gems/capistrano-yarn) useful. No need for that on Rails 5, though.
This is great. These are most of the things that when I saw the initial webpacker release, I thought, "Gee, why didn't they do X instead?" Can one actually use webpacker with Rails 5.0 if one wants? The [gemspec](https://github.com/rails/webpacker/blob/master/webpacker.gemspec) allows &gt;= 4.2, so I might give it a try at some point. 
The answer to that question will always be "it depends". 
The relationship between whether or not github tracks tokens that once existed doesn't have any effect on what status code they return. I.e. they already have sufficient information to determine if you've typed in a valid URL with an invalid token (case I care about) versus an invalid url (which I want to avoid deleting the token for). 
I guess, but you also have sufficient information to determine if you've typed a valid URL. You don't need the API to tell you.
&gt; RoR Cons &gt; Best programming skills are required so top notch programmers with high pay are required. &gt; Cons Ah, yass. Having to hire somebody who understands what they're doing, how unfortunate. 
Probably you can start an SSH session faster through Find action - SSH. The shortcut for Find action is ⇧⌘A/Ctrl+Shift+A. Though I'm not sure that's what you mean by an "SSH button"...
Does this seem false to anyone else? I love both languages, but there are definitely more programming nuances (i.e. "callback hell") in javascript that lead to many more debugging headaches than RoR. In fact it's one of the reasons I like RoR because it's MORE straightforward... I guess it all depends on what they mean by 'top notch'. Also would have been good to touch on testing for the sanity of web developers. It is pretty much a wash though as both mocha and rspec are equally solid imo.
hmmm I would like this: - import x from x OR from x import y (aka: python) - strict typing (will never happen) - modern concurrency (guild, so maybe in 2020) - pattern matching - simple way to pick my backend( jruby, truffle, mruby, ruby, topaz) This is done now by dlang. Impossible I would say - immutability. Maybe - enums. - method overloading - better packages (python way) - remove autoloading. Never I guess - remove monkey patching. Maybe - easier c api interlope - more libraries on ML - more libraries for data. Does a language like this exists? Also, there is life after rails. Roda, Sequel, Sinatra, rom-rb. Yup there is.
&gt; Nate Berkopec‏ @nateberkopec said in his blog post that the previous weak performance show by Rails in techempower benchmarks was due to mis-configuration in Puma threads. I've seen similar complaints about the configuration for Phoenix. For *most* of what techempower tests, Phoenix is probably going to be faster than Rails. Erlang's BEAM virtual machine is pretty good, and has *much* fewer things standing in the way of optimizations than Ruby does. Plus Phoenix is a smaller framework in general. I think the most important conclusion here is that you really shouldn't put very much stock in Techempower benchmarks. They're incredibly far from representative of the real world, and apparently even high profile projects aren't being properly configured anyways.
I'd love to see class variables removed from the language - bonus points for also removing it from Ruby's history.
&gt; - object deconstruction. Why are you missing that? There is `begin ... ensure ... end` and there are finalizers.
+ pattern matching ftw + immutability (maybe with optimizations like persistent data structures) + a sane concurrency model would be nice, CSP at this point looks like a good choice + first-class functions (this makes certain FP-patterns look more natural)
&gt; - strict typing (will never happen) I consider that so fundamental that the resulting language is not Ruby any more. So yes, it will never happen. :-) &gt; - immutability. Maybe There is `Object#freeze`.
`Object#freeze`, but I want to have it on collections, or some more and also in some more generic initialize object maybe. `def initialize_freeze()` 
Down is a great gem
NodeJS is a JavaScript runtime and Ruby on Rails is a web development framework...right? So like, this is like, comparing apples and oranges? Shouldn't it be, "NodeJS/Express vs Ruby/Rails" or something? I don't know...
NodeJS is a web development framework as well.
The article is stupid because good programmers are required no matter what language you work in. The challenges may vary slightly from language to language, but if you want the top talent you will pay the top rate.
- the Ruby stdlib is really great in some areas, and really ancient and behind in others. Net/HTTP for example... - Some consensus regarding coding style. I worked across different firms developing Ruby apps and saw a large variety of single-quotes vs double quotes, defining all private methods below a SINGLE "private" vs explicitly marking each method as private etc. I think Golang did a great job with their format tool. Performance, less memory usage, a good concurrency model, ... These would certainly be great for Ruby, but for me this is just a trade off for using Ruby. If Ruby would have this too, it would have it all. 
...are you sure? https://en.wikipedia.org/wiki/Node.js "Node.js is an open-source, cross-platform JavaScript run-time environment for executing JavaScript code server-side. " "The open-source community has developed server frameworks to accelerate the development of applications. Such frameworks include Connect, Express.js, Socket.IO, Koa.js, Hapi.js, Sails.js, Meteor, Derby, and many others.[31][51]" I guess I'm saying, can you really just build a website easily with raw NodeJS and nothing else? Or would you have to implement the equivalent of Ruby's Rack? Or is NodeJS like Rack?
I mean the function "Tools&gt;Start SSH Session"
christ, the memory usage - and "garbage collection"...sigh. +1
Yeah. This comes across like a twelve-year-old writing "Which is better? A V8 engine or a Subaru WRX?"
Have a look at Celluloid - its another gem in same context of concurrency, that seems to have an easier syntax
I don't think it's been unleashed to the wild yet, but it's global state as a feature. I doubt there will be a single situation or example where it _isn't_ abused.
I concur in spirit, at least, though neither concurrent-ruby nor rails are really a necessary part of any tech stack I maintain :-)
Adding on to this, I also wish one of the JSON parser libraries could convert to/from camelCase key names.
Pretty interesting how according to the google trend line interest in node.js was also much higher than Ruby on Rails in 2004.
I mean... Can you really build a website with raw Ruby and nothing else? No, you'd use a framework like Rails.
You sure can, but it's painful ...just like it is in raw Node for anything non-trivial.
If you try really hard, you can fuck up a rails app too. 
naw, I mean h = { a: 1, b: 2, c: 3 } a, b, c = h a # =&gt; 1 b # =&gt; 2 c # =&gt; 3
Frontend frameworks either use GraphQL and have each user implement their own irregular format for that kind of thing, or if you're using REST or even JSON:API, you just use multiple requests.
^ this! hi /u/beauby! 
I feel like you're trolling at this point.
You can use these: * https://github.com/futurechimp/plissken * https://github.com/futurechimp/awrence 
Yes, I know this is easily generalizable into a casing library. Casing should be done at parse time.
Haha you misunderstood my comment. You could use Rack and not Rails. I've read that Connect is similar to Rack in the Nodejs world? I could be wrong though! I use Node and Express for some projects. Using either would be pretty painful compared to using a full featured framework though, for sure. I prefer Rails for larger projects. Sinatra for smaller ones. 
Is any criticism of a blog post "trolling?" I'm not trying to troll or upset. I appreciate that you've initiated discussion about an error you made. Most people would try to hide them; you've posted yours to the world. I respect that. But the flip side of that is I'm allowed to a) respectfully try to understand what you're arguing for and b) respond. You're saying it's the API's responsibility to save you from making bad requests. It's not. Like I asked before, if you could design the github API, what status code would you return for requesting information about a non-existent resource? Isn't that exactly what 404 Not Found is for? Is it unfortunate that there isn't a distinction between an endpoint that doesn't exist and a resource that doesn't? I guess, although that's more of a complaint about HTTP than Github's API. I would also add that an easy way to overcome this error is to use a client that doesn't hit malformed endpoints. There are plenty available and it's not impossible to write one from scratch either.
&gt; NodeJS is a web development framework as well. Ahh shit. I made this comment earlier today while at work and didn't reread it until now. I stand corrected :|
It's allllllll good honestly I can barely keep it all straight!
This comment is getting downvotes because of the arguing below about handling unknown, unknowns, but it's true. Remote API's being unavailable (even if they're you own in another system) are not an "unknown unknown" - they're something you can and should expect to go wrong at some point, and design to handle the failure gracefully (however that is for a particular use case) accordingly. 
This is a horrible article.
&gt; Does a language like this exists? Scala
&gt; Give credit where credit is due: I found this solution within a StackOverflow answer. Thanks to the author! ...because reading the [official docs](https://relishapp.com/rspec/rspec-expectations/v/3-6/docs/define-negated-matcher) before using the tool is soooo last century, right?..
I really wish Ruby mobile/desktop applications were more popular, too. In my opinion, all the available options suck, in one way or another. RubyMotion is passable, but it's also not "real" Ruby. On the technical side, concurrency is the big one. Hopefully we get _something_ in 3.0. Speed and memory size improvements would be very nice, but are not essential. I want to see implicit block parameters. Something like this: (1..5).map { $ + 1 } #=&gt; [2, 3, 4, 5, 6] I don't think constant lookup should be different when using the `::` operator. It seems inconsistent to me. module Animals class Dog end end module Animals class Cat # this works fine ENEMY = Dog.new end end class Animals::Cat # this fails # uninitialized constant Animals::Cat::Dog (NameError) ENEMY = Dog.new end Namespacing in general isn't very nice in Ruby, which is probably why it's not very popular.
No, I was not actively looking for this in the docs, but read about something related on SO. There _I_ found the hint, that's why I just wanted to say a little "thank you" to the person who posted the answer there. That was meant by "Give credit where credit is due".
What's wrong with h = { a: 1, b: 2, c: 3 } a, b, c = *h.values a # =&gt; 1 b # =&gt; 2 c # =&gt; 3
You do NOT have to try hard to mess up a rails app. You simply need to follow the official guidelines and impose no additional architecture, and it'll do the job for you. 
Well, sorry if my comment sounds too rude... I believe it is a cultural difference (on Russian and Ukranian development forums typical discussion intonations are pretty tough, and from time to time I unwillingly switch to this intonation in much softer environments). Yet to be completely honest, what I've tried to say is "we already have all the information and a bit too much of it, what we need is the organization of it". That's why I feel a bit uneasy when seeing blog posts that just retell some of the standard features of our tools like it was newly found knowledge.
order dependency perhaps? Although, to be fair, this feature request looks more like a needless "javascriptism". Doesn't make in any sense, as in ruby anything can be a key, while in javascript hashes are objects, and keys are attributes. Also, this feature request is technically already implemented, in the case of kwargs at least. 
you mean this? def method(first: , second: , **other) .... method2(**other) end 
Nevermind - but thanks for clarification! And yes, you are right, the blog post is of this type and does not tell something brand new that is uncovered by the docs. On the other hand I like reading these type of articles by myself in between reminding me on these type of little tricks. 
&gt; - spread `(...)` for arrays and hashes. What's wrong with splats? They are practically the same, aren't they?
I guess we'll have to wait for Guilds - I just hope they will land pre-3.0 or that Ruby will get a quicker release cycle i.e. not sure how many Ruby programmers will be out there if parallelism lands in stable Ruby in 2021. I'm being cynical here - on the bright side [truffleruby](https://github.com/graalvm/truffleruby) should be out earlier which should give us a nice boost in VM performance besides the usual JRuby niceties and with full C-extensions support.
No, I want to have all the keywords in one glob, not just the remaining ones
Just right click the upper Toolbar with icons and choose 'Customize Menu and Toolbars'. A very extensive dialog appears and with the expand arrows you can add whatever button(s) you want. Added myself the window -&gt; Editor tabs 'Split Vertically' and 'Split Horizontally' buttons, they are hard to navigate to...
my vote... (EXPR).method(:sqrt) sugar equiv (EXPR).:sqrt "method" + "symbol" characters. good combo since literal form is always used
Haha. That's exactly what I've proposed there! https://bugs.ruby-lang.org/issues/13581#note-8
it's pretty simple too. just like a named method call except we use the symbol name of method. another way of looking at it... just strip out the "method" method, drop parens. sugar!
JRuby start-up times even with `--dev` are much slower than CRuby but if you're not developing CLI tools it works fairly fast on a modern computer. I use it daily and in my experience its benefits (true parallelism when required, better JIT, Java libraries, etc.) fully outweigh its drawbacks (slower start-up time, the JIT warm-up, more memory used, C-exts, etc.). I will say this: I have a slight muscle memory twitch now when I type `rails c` :-)
&gt; order dependency perhaps? That is not given in the first example either. Unless you would expect Ruby to know about the local variable names when accessing the Hash. That is too much, because evaluation on the right hand side of the equals sign is completely independent from anything on the left.
`Object#freeze` does work on collections. If you mean collection manipulation operations that return new objects, that does exist as well, for example `Array#+`.
Yes! This is such an awesome and well-written book.
you can't use splats with hashes a = { a: 1, b: 2 } b = { a: 4, c: 3 } c = { ...a, ...b } # =&gt; { a: 4, b: 2, c: 3 }
the order of things in a hash isn't known / can't be trusted, so this code could be prone to error :-(
`#values_at` xD
Elaborate on that one, please. ╰─$ irb :001 &gt; a = { a: 1, b: 2 } =&gt; {:a=&gt;1, :b=&gt;2} :002 &gt; b = { a: 4, c: 3 } =&gt; {:a=&gt;4, :c=&gt;3} :003 &gt; c = { **a, **b } =&gt; {:a=&gt;4, :b=&gt;2, :c=&gt;3}
but then you need to specify your key on both left and right sides of the assignment. It _is_ much easier than doing a ton of assignments / one per line, but, it can be better!
whaaaaaaaaaaaaaaaa! I didn't know that was possible. noice. Sharing this.
* A decent type system. * native compilation * better memory usage. * faster Oh what the hell, just adopt Crystal and say that it's Ruby 3.0. Get some people to write a ruby to crystal translator so we can quickly build up the new shards. That is all :)
Ruby &gt; JS, that's the only comparison you need.
It is outdated in the sense that it was [made 5 years ago](https://github.com/rails-api/rails-api/commit/62e82d83c3cd4abe248dc1b9890a975c1c976a91). I do not know of any official recommendation at the moment.
We also need an syntax sugar of to_proc like crystal lnaguage. [crystal to_proc](https://crystal-lang.org/2013/09/15/to-proc.html) [1, 2, 3, 4].map &amp;.**(2) #=&gt; [1, 4, 9, 16] [1, 20, 300].map &amp;.to_s.size #=&gt; [1, 2, 3] [[1, -2], [-3, -4]].map(&amp;.map(&amp;.abs)) #=&gt; [[1, 2], [3, 4]] 
Have you done any benchmarking yet?
You can add whatever you want to rails
I'm talking about this thread. It feels like we are talking past each other any my point is not being understood or read. At this point there's two possibilities, you maybe didn't totally understand my point and need clarification, or you understood and are choosing to ignore it and draw out some kind of protracted argument. If I was unclear then I feel like you would be making attempts at getting clarifications. You could repeat back to me what you think you heard and ask "is that right", or you could say "I didn't understand about X" ,or you could say "are you sure about Y", or even "walk me through your logic about Z". There's also "I don't think M is correct due to N" and other variants. This isn't the case. I'm not hearing any language seeking clarification of any kind. So that eliminates possibility 1. That leaves option 2 which would be a protracted argument. I'm letting you know this is my through process, why I said that. If github does not distinguish between an endpoint that does not exist versus a resource that is not there, then there is no way to make that distinction programatically. I'm not advocating for anything really, my response was simply to refute your initial claim that github knowing or not knowing if a token ever existed was relevant. That's all I ever tried to say, and I said it. 
You've got a good point there.
`ls` was written in the 1970s. Does that mean it's "out of date", because it was written ~47 years ago? Being old does not imply being out of date.
Impressive dialectic skills. Note though that the GNU version of ls was [updated 3 days ago](http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=commit;h=799bac0d06cfabe9491498727308df8d1aca6d98). Anyways, you are free to consider this recommendation current. My point was, the people who wrote it do not.
I would generally go for on-the-fly transformations when it comes to images, because I like when I have less things I need to maintain. Note that you also have open source alternatives for on-the-fly transformations – Dragonfly, Refile, Attache.
I'm not *arguing* that it's not (I don't know if it is!), I'm questioning your *justification*. Is there an issue discussing this? A PR? A blog post from a prominent contributor? Anything other than "not updated in years"? 
&gt; At this point there's two possibilities, you maybe didn't totally understand my point and need clarification, or you understood and are choosing to ignore it and draw out some kind of protracted argument. Goes both ways. I've tried to discuss in good faith what the proper behavior of github should be. I feel like I've made good points. &gt; my response was simply to refute your initial claim that github knowing or not knowing if a token ever existed was relevant. I was replying to a comment that said "Though I think 410 for a previously existing but now invalid token would have been semantically correct." That is the only potential semantically valid code besides 404 but, like I said, GH probably doesn't want to store invalid tokens so it doesn't bother. Maybe all you were trying to do was shit on a relevant point I was making, but in the course of doing so you argued that "If github does not distinguish between an endpoint that does not exist versus a resource that is not there, then there is no way to make that distinction programatically." Of course you can distinguish between good and bad endpoints. The endpoints are documented. Write code that points to good endpoints like you see in the documentation. You can even write test cases and validators that ensure that generated requests match the desired format. Ultimately API's are just that; an interface. You have to code up to the interface. If you don't, that's on you, not on them.
There's [this commit](https://github.com/rails/rails/commit/f8edd2043e864aff0bde9289da550709532268a6) removing AMS as a default, postponing the new recommendation for a lib to 5.1, which is already out. Also the [README of AMS](https://github.com/rails-api/active_model_serializers) explains the current state of affairs: &gt; The 0.10.x version has become a huge maintenance version. We had hoped to get it in shape for a 1.0 release, but it is clear that isn't going to happen. Almost none of the maintainers from 0.8, 0.9, or earlier 0.10 are still working on AMS. We'll continue to maintain 0.10.x on the 0-10-stable branch, but maintainers won't otherwise be actively developing on it. It also states: &gt; There's been a lot of churn around AMS since it began back in Rails 3.2 and a lot of new libraries are around and the JSON:API spec has reached 1.0. &gt; If there is to be a 1.0 release of AMS, it will need to address the general needs of serialization in much the way ActiveJob can be used with different workers. &gt; The next major release is in development. We're starting simple and avoiding, at least at the outset, all the complications in AMS version, especially all the implicit behavior from guessing the serializer, to the association's serializer, to the serialization type, etc. Which basically means "we're rewriting the whole codebase all over again, and the result of this is unclear".
Also, I've been one of the "core contributors" of AMS for over a year.
Not sure I'd build something on Celluloid at this point, the project seems largely dead and I've seen a number of projects that were using it move away in the last year+.
I think I fall into the same camp. I like the idea of keeping just one original image and having the flexibility to transform it when needed vs. reprocessing everything. Especially in the early stages. I've been researching the pricing for both cloudfront and imgix and find them to be similar bandwidth-wise at the beginning. I can always move to cloudfront down the line if I hit the higher brackets. I've had the pleasure of implementing both of these scenarios in shrine, and they work fine. Thank you so much for this marvelous tool! I've been meaning to ask you, do you have any plans on monetizing pro/enterprise features or plugins, à la sidekiq? I'd love to support your work if I get the chance, keep the juices flowing and what not.
We started out before these on-the-fly services became popular, but we went for generation and cloud front (with cloud flare cdn) I can say this hugely less expensive compared to cloudinary. But we transfer a lot of images, a few terabytes per day. Perhaps you could devise a way to do on the fly but cdn cached with cloud flare, it would be a neat and cheap solution even at scale.
NodeJS pros: lots of developers can use it! NodeJS cons: front-end developers suddenly think they're full-stack.
I've been mainly researching the pricing and simplicity since I assume most of the images will be accessed from cdn cache which should be fast enough for me on either case. As for pricing imgix is slightly more expensive, but also more convenient. Cloudfront is probably the way to go once you're reaching higher out transfers and have a good grip of the sizes you'll need for your images. However, imgix also has plans that scale with you so I'm not sure if the jump is necessary. One thing to note is that big image-heavy companies tend to use Cloudfront and there's probably a good reason for that. (Airbnb, Dribbble, Dropbox, Pinterest, Instacart). On the other hand, Product Hunt and Zillow run with imgix, so there's that. I think I'm gonna give imgix a try for a while and see how it goes.
Hmm, I'd include pricing as a benchmark. I'd probably use jobs to simulate expected loads and do a comparison of performance, storage, and costs.
do you have a key? Valid one?
I'm very happy to hear that! I haven't really given monetization a serious thought. The main reason is that I don't have some significant features in my TODO list that could go in a pro/enterprise version. Though it could definitely help with further development.
Cloudinary was also too expensive for my use case. This is a gallery-like site (similar to dribbble or deviantart) where I could be loading 200+ images per page view. I initially set it up with refile + cdn, which includes on the fly, but wasn't sure if the gem was still being maintained and had some small issues setting up tests for it. I've never tried cloudflare. How would it fit into this? Would the implementation overlap with cloudfront?
That'd make a fantastic resource. Reminds me of this one I read the other day that compares hosting services. https://www.webstack.de/blog/e/cloud-hosting-provider-comparison-2017/
We use cloudflare for ssl and ddos protection, but it comes with flat rate cdn, which is really good if you transfer a lot of data.
Yes. I have 2016.3 I looked in that directory, and theres no keys or config dir. Wtf?
Oh that is dope! Thanks!
That's cool. I like that shrine is sorta hyper-focused on solving file attachments. I feel that it doesn't overstep into solving other generic problems, using wrappers instead (which I think is where you draw the line). I hope the plugin architecture catches on, been dabbling with it in my own gems lately thanks to you.
Just curious why'd you alias and remove include?
&gt; the order of things in a hash isn't known In Ruby, it is, since 1.9 at least.
keep in mind the Proxy object has no support in windows, but still an awesome little project! https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy
Doesn't windoze now support bash? If I had to suffer such an indignity, I'd look to reproduce the linux env as much as I could, whether bash or cygwin or VPN to back home or even a surreptitious AWS free-tier centos box.
Are you using WSL or some other way of installing Ruby? Have you looked at this (`rmagick` is mentioned): [Setup Windows 10 to run Ruby on Rails using the new &amp; improved WSL](https://medium.com/finc-engineering/setup-windows-10-to-run-ruby-on-rails-using-the-new-improved-wsl-c6894d1ae2ae) And this seems pretty solid: https://gorails.com/setup/windows/10
What have you tried so far? Have you seen [this](http://guides.rubygems.org/ssl-certificate-update``)?
Because I don't know what I'm doing. It was from a [stack overflow answer](https://stackoverflow.com/questions/14749047/how-to-use-rspec-expectations-in-irb) about how to use RSpec matchers in irb.
S3 is surprisingly cheap, I'd price out an estimate and see what you think. Even with cloudfront or cloudflare over it. I'd say the advantage of pre-processing is that it's a lot simpler. With on-the-fly processing you have to worry about latency of delivering them the first time, caching, cache expiration, concurrency if the 'first time' happens more than once at the same time, etc. There may be out of the box solutions that handle all this for you though, I'm not sure, but that's still more places for the solution to have a bug or otherwise go wrong for you. If you're using a commercial cloud solution like imgix though, it pretty much Just Works and is fine, I've used imgix before and been quite happy with it. It's pretty reasonably priced as well. 
I think it can be a toss up whether in-advance pre-processed or on-the-fly is "less things to maintain". It's really just _different_ things to maintain. With pre-processed, once they are processed you have _nothing_ to maintain except S3 or whatever. But outsourcing it to imgix is also definitely the least to maintain. 
Don't know the solution for your problem, but why are you torturing yourself? I just run VirtualBox with Ubuntu (MintLinux) in it. I normally work in MacOS, but this is next best thing.
If you work in a company that forces you to develop Ruby on Windows, you work in a bad company.
Is docker an option? I develop a ruby (Sinatra, specifically) app on windows using Docker (at work). I use ConEmu for the terminal so I can run both bash and Powershell as needed.
stupid ssl errors, saw those on OSX too. Modifying the gemfile and gemfile.lock to point to http vs https versions of rubygems.com was ....dirty but quick?
1) that's a lot of code 2) i want the code to boom if I missed defining or handling something 3) very cool to see u putting something like this together! +1
I think you should just use Linux instead. Why are you saving Linux for "fun" when it's better suited to the work you're doing? Why use Windows when it makes your work harder? It's just the tip of the iceberg with Windows specific issues...
THx all. I am not a developer by any means - this is more of a hobby. I use Ruby at work to make some quick and dirty scripts for various purposes. VM is difficult because I sometimes deploy these scripts on several other windows machines. Bash requires the "windows insider" which I am not. I'll try tweaking the rubygems files 
Because windows domain, active directory permissions and not allowed alternative OSes
I'm hoping to get some of those sweet downvotes...my advice is to get a Mac, build a Hackintosh, or install Linux. I've been a professional developer for almost 20 years, and the last 12 have been on Mac, before that on Windows. If you run Docker or host on almost any cloud platform, your code will be running on Unix, probably Linux. If you don't want to spend all of your time dealing with compatibility and installation issues, don't use Windows for development.
That's a version number not a license key. You should have to log into your Jetbrains account after subbing for the subscription.
My workstation at work is windows and I do a lot of Ruby on it but I find windows subsystem for Linux to be the best option. I used to use a VM but wsl works really well as it provides Linux syscalls in the native windows kernel
Since update 1603 wsl comes with windows 10. If you are using anniversary update or creative update you can enable it in windows features. Also turn on developer mode. Never had luck with gnu image manipulation on windows
In other words, no you don't need to be an insider. I would only recommend WSL if you have the creator's update though, and even then, it can be slow sometimes depending on what you're doing.
THX All I need to register to Windows Insider...Tried doing that but I cannot without a cell phone to receive SMS (live outside of cell coverage ; Microsoft does not accept Google voice number for that :( 
Or use VirtualBox, one of the easiest VM supervisors to setup and use.
Bash is just a shell. It doesn't mean that everything you might run in it is guaranteed to be compatible. 
Drip looks like what I'm after. Thanks 
You need to update rubygems/ruby - download a new ruby for windows to fix it. I suggest going for 2.4.
There's no need for the virtual machine considering Windows has a [Linux runtime](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide) now.
Ruby on Windows has always been a pain and honestly kinda flaky. I've had things fail for no reason I could tell, I've also had constant SSL problems that I fixed in various ways over the years (but can never remember how I did it). And honestly installing any gem that isn't pure Ruby is just painful, install the dev kit and just hope it works. Use the [Windows Subsystem for Linux](https://msdn.microsoft.com/en-us/commandline/wsl/install_guide) and never look back. Most things I've tried on it worked really well, it's just... Linux without Linux. Finally you can just install gems as you would on Linux and it all just works. Install imagemagick, install the rmagick gem and you're done.
totally uncalled for downvoting here ... for the simple reason that virtual machine isn't necessarily native performance (and will be a memory drain anyway) where as Bash on Windows is.
Its a pro/paid account. The licence key was entered at install time. Still has this weird problem, probably since last update?
i realize that recruiters really have this bad a understand of these tools, but the question is always how much I want to school them before I start sounding pretentious.
I believe that the answer from SO shown below is provided to replace standard include with RSpec's include matcher :)
Please show the entire code you've used (e.g. "...and try out a simple matcher" part), I believe I'll help you.
Yes, I know of a project that uses webpacker with Rails 4.2, so I expect 5.0 to work too
Thanks! I definitely have to consider the added complexity from a black-boxish solution like imgix. I have't tried it in production so I'm not sure what the setbacks are. I'm not planning on doing much caching (fragment/turbolink) on my first iteration, so if I feel imgix requires it, I'll probably move to preprocessing. I have S3 + Cloudfront on another site and it works really well. No big issues. My main gripe was the effort it takes hone your images towards an optimized state, lots of trail and error and S3 resets, but once you get there it's mostly downhill. Plus having more control is nice too. 
If you are on Windows 10 use WSL. No VM overhead, 0 configuration, and 99% of Linux software works. You can literally install Fedora or Ubuntu from the Windows Store and get to work. I write all of my code on WSL. 
You could try mobaxterm (http://mobaxterm.mobatek.net/) which has a plugin/extension for installing Ruby.
That is really exciting news! Congrats to the author for this release!
Still that does not mean that the piece of code receiving the Hash can rely on that order! If that was the case, you could either use an Array or fill the known local variables right away. The whole approach of this is broken: you use a data structure that can contain arbitrary many values yet expect to be able to fill a fixed number of local variables from this. The only reliable way to do this is to explicitly request the proper values. So better use what u/Mamucium has suggested a, b, c = h.values_at :a, :b, :c Or another approach that explicitly queries keys.
What exactly are you using? I'm beginning Ruby on Windows as well and so far I haven't got any trouble. I guess with more complex gems, things get nasty.
Yeah, to clarify I don't think there's any added complexity from imgix. Or at least the minimum. You're outsourcing your complexity to them. Imgix (or a similar competitor; I've used imgix) is probably the simplest solution with least work for you, setup or ongoing. I like imgix. I think DIY on-the-fly like dragonfly can sometimes be more complex than DIY pre-rendered. But imgix is pretty sweet, outsourcing most of the possible added complexity to them, it just works. I endorse imgix if it works for you and the price is right. Imgix is pretty affordable but you can probably do even cheaper with pre-rendered on your own S3 with cloudfront or cloudflare. 
Ruby 2.2, rubygem is 2.6.8 
No comment so far, so I'll give one: if you're a Rubyist, I can warmly encourage you to play around with Sequel for data-related scripts, standalone migrations etc in non-web projects (so even without picking Sequel as an ORM for your web-app). The API is extremely powerful. Check it out!
Did you get it from RubyInstaller.org, the explain very well how to make ruby work. Edit: depending on the version you download.
Awesome, Jeremy is such a smart dev and I hope to see his works(Sequel, Roda, etc) get more popular.
Wow, the string splitting change is going to destroy a lot of my apps. Thank you for the informative change log.
This tool can help: https://github.com/jeremyevans/sequel-unsplit (advertised in the [release of Sequel 4.46.0](https://groups.google.com/d/msg/sequel-talk/3DbcAQ7eLJM/COmybcA8BgAJ))
I started using sequel in a few projects and love it as a replacement ORM. Jeremy does fantastic work 
I've only used it for one project but it was fantastic, all the power of the db (PostgreSQL in my case) just felt like it was right at my fingertips. For straightforward works, AR does a fine job, but for more advanced queries Sequel was excellent.
That’s all the code except for the matcher which was expect([1, 2, 3,]).to include(1)
I've seen a number of these discussions and they always seem to create a lot of complexity by conflating two entirely separate concepts: argument passing and object mutability. If you just separate the concepts at the get go, it's much simpler. Ruby is strictly pass-by-value and all passed values are references.
Hmmm... Mine does this: http://storage8.static.itmages.com/i/17/0902/h_1504381347_9895631_5e22dcd04e.png Can you please show a screenshot of yours?
That's a good point. Could you please provide more details on: &gt; Ruby is strictly pass-by-value and all passed values are references. How is it different from "pass-by-reference"? It would be nice to see some examples of code that would show this idea. 
Awesome. Where would I find docs to figure out what the operations are and how to use them? Even something simple like resizing an image?
Hmm. That's odd. Now it's working. Heh. Not knowing why something does work is worse than not knowing why something doesn't work. :-P
Hello, they are on rubydocs: http://www.rubydoc.info/gems/ruby-vips The image page lists all the methods: http://www.rubydoc.info/gems/ruby-vips/Vips/Image Or the Vips one has an introduction: http://www.rubydoc.info/gems/ruby-vips/Vips There are some examples here: https://github.com/jcupitt/ruby-vips/tree/master/example This one is fun, it defines a 'wobble' operation: https://github.com/jcupitt/ruby-vips/blob/master/example/wobble.rb http://2.bp.blogspot.com/-_ZipOkEp-XM/Vk9W9UaydvI/AAAAAAAAAvY/Hax_kKfIz2g/s1600/x.jpg
Feel free to contact me or write to this thread if you'll have other problems. I believe I could say a lot about both tools ;)
Or here's the ruby-vips backend for carrierwave https://github.com/eltiare/carrierwave-vips
&gt; How is it different from "pass-by-reference"? It would be nice to see some examples of code that would show this idea. One way to look at it is this: def swap(a, b) # fill me in end a = 'hi' b = 'hey' a_id = a.object_id b_id = b.object_id swap(a, b) assert(a.object_id == b_id &amp;&amp; b.object_id == a_id) In Ruby there is nothing you can put in `swap` to make this work. In C++ / C# you could write such a `swap` function since they support pass-by-reference. In C you have to explicitly pass pointers to do this as it's also strictly pass-by-value. Java is similar to Ruby with the addition of unboxed primitives being directly passed as a value, so it's impossible to write such a `swap` function in Java as well.
I stopped and smiled when I saw that it dropped support for Ruby &lt;1.9.2... :) in an age where libraries drop version support at the speed of light or the speed of Ruby core version policy, it goes to show that some brave people are still committed to distro support
Here's the thumbnailer: http://www.rubydoc.info/gems/ruby-vips/Vips/Image#thumbnail-class_method
That's a really good example. As far as I understand we can not swap values because of the way how assignment works. Once we do `a, b = b, a` in `swap` function it drops references to original values and assigns it to new ones. def swap(a, b) puts "a: #{a.object_id}" # 70340101387820 puts "b: #{b.object_id}" # 70340101387800 a, b = b, a puts "a: #{a.object_id}" # 70340101387800 puts "b: #{b.object_id}" # 70340101387820 end swap('hi', 'hey') At the same time we can easily mutate string by doing something like this: def concat(str) str &lt;&lt; 'bar' end foo = 'foo' concat(foo) puts foo # foobar If `foo` argument passed by the value it shouldn't mutate original value of `foo`, but it does. PS: Thanks for answers, it's really good to dig into this concept, maybe it will help us to learn something new from this discussion :)
nice, thanks. This seems like a pretty good alternative to imagemagick/graphicsmagick, especially since in ruby the reliable IM/GM options are basically to shell out to command line process.
The reason we can change foo in your example is we pass a reference to foo by value. A way to think about this is we make a copy of the reference to foo and pass that to the function. Therefore, if I change what the reference refers to (by reassigning it) then the original reference is unchanged (meaning it still points to the same thing). If I, however, mutate the thing that's referenced (like concat does) then the original reference reflects that since it's still pointing to the original, now mutated object. The way this was told to me (in Java but the concept is the same) is that references to objects are passed into functions by value, if that makes sense. The original comment is a good way of putting it as well. 
Yup, I still use ActiveRecord for anything in Rails, ActiveRecord is really fine (when all the parts have been set up to support it by your framework), and it hasn't been worth it to me to try to switch it out (when ditto). But in _any_ non-Rails project, I will use Sequel without hesitation. It is way easier to set up from scratch, and has a great API once you get it set up and pretty much just works. 
What do you do for migrations?
Sequel has migrations too
Several of these projects haven't needed migrations, they've been tools for connecting to existing databases managed elsewhere. But [Sequel has migrations](http://sequel.jeremyevans.net/rdoc/files/doc/migration_rdoc.html). I think maybe I used them once in a past project, they were fine. 
I'd kinda prefer dropping support for those older versions. Apps running on such old versions of Ruby are hopefully just continuing to run without being worked on. Anything in active development should be running at least on 2.2 by now, so making it harder for people to drastically update apps on long deprecated versions is probably a good thing overall. I understand places that have legacy apps they need to keep running, that's fine, but they likely aren't trying to update their ORM or other significant parts.
And you'll likely hold that view right up to but not once you've been tasked with a "minor change" to a production Ruby 1.8 or 1.9 app. (Yes, some poor souls still have to deal with 1.8; those shops tend to have more managers than devs, But I Digress.) Yes, having Ruby 1.*x* applications in production should constitute corporate malfeasance at this point, but management will too often have one yob who says "rewriting that much of the app is too risky and, besides, it would cost money we need for other things." (Bonuses, maybe?) Technical people have *very* rarely had both the political and ethical strength to go up against such dunsels and win.
Not everything is web apps or rails. A lot of OS tools must run in system python, system Perl, system Ruby. Convince distro maintainers to package them in the next major version , and you still have to provide support for not yet upgraded clients. Sysadmins prefer stability, and won't care whether the Ruby community considers a version "old". And sequel is not only used in apps. It's an advanced db toolkit, and a lot of companies run a few periodic Ruby scripts to run all kinds of clean up/optimization / report tasks with it
"If you want to mutate it, wrap it in an object before you pass it in."
I use them from times to times in ETL projects without a Rails back-end, and it's been pleasant. It reminded me about [standalone-migrations](https://github.com/thuss/standalone-migrations), in a way.
I love awesome_print. I always add it to my Gemfile as a dev gem on Rails projects.
Well, immediate values are not really references as they are stored in the value itself. 
Why non-web?
I'd encourage folks to consider it for their web applications as well. 
I believe /u/moomaka was trying to explaining the "pass-by-reference-value" concept by pointing out that **reassigning the variable inside the method does not affect the variable outside the method.** You can reassign `a, b = b, a` and of course, their corresponding object IDs will swap, too — but _only within the execution context of the method itself._ To clarify: def swap(a, b) puts "a: #{a.object_id}" # 70340101387820 puts "b: #{b.object_id}" # 70340101387800 a, b = b, a # You're checking inside the method's execution context puts "a: #{a.object_id}" # 70340101387800 puts "b: #{b.object_id}" # 70340101387820 end --- a = 'hi' b = 'hey' a_id = a.object_id b_id = b.object_id swap(a, b) # /u/moomaka is checking outside the method's execution context assert(a.object_id == b_id &amp;&amp; b.object_id == a_id) When it comes to **reassigning variables**, what happens in the method stays in the method, because Ruby **passes by reference-value**. You pass an argument to the method (`a`), and what the method gets is not the value (`'hi'`), nor the reference ("`a` points to `object_id 70340101387820`"), but the **reference value** (`70340101387820`). (I'm fuzzy on this, so take it with a grain of salt.) Unlike pass-by-reference, you can't redefine what `a` points to outside of the method. Unlike pass-by-value, you _can_ change the underlying object by modifying-in-place (_e.g.,_ as you did with `str &lt;&lt; 'bar'`). FWIW I liked your article; the illustrations help a lot. Here's [my treatment of the same subject](http://ryanlue.com/posts/2016-11-07-object-mutability-in-ruby) from last year. Going back to basics is really important and easy to overlook; even just spelling it out again in this comment has helped me clarify my understanding of the subject.
My point was quite unclear, let me improve that :-) I see some people considering Sequel as a replacement "ORM" for ActiveRecord, for their new or their existing Rails app. Sometimes they will just dismiss Sequel because it's not as popular etc, or a change of ORM isn't worth it. What I wanted to emphasise is that you can also use Sequel outside of that type of use-case, and it will really shine. I must say I love using Sequel for Web work though, in particular with Roda.
Not sure what you mean by 'immediate value' in this context, never heard that terms used outside assembly. Do you mean tagged pointers? i.e. how MRI stores integer values in the object_id without allocating a 'real' object?
I use immediate values in the same way it is used in the original link, and how they are used in the documentation for object_id. But yeah, tagged pointers is the concept behind it. Those values that are stored in it are the immediate ones. 
That's really just an optimization that MRI uses and not required by the language spec; it doesn't impact the evaluation model. Other implementations such as jruby handle this differently. 
I wrote a series of unfortunate Ruby scripts to do just this. It's extremely manual and I'm quite embarrassed by the code so I never bothered cleaning it up and releasing it. Glad to see someone didn't wait around :)
Here is a sample program that reads the file, parses the comma separated values on each line and appends them to an array: contents = File.read('sample.txt') elements = contents.each_line.flat_map do |line| line.chomp.split(',') end puts elements # 1001111 # 1010011 # 1010101 # 0101010 String#each_line includes the line break, and String#chomp removes it. If you need actual CSV parsing, consider using the CSV library: http://ruby-doc.org/stdlib-2.4.0/libdoc/csv/rdoc/CSV.html Edit: /u/cmd-t, that is a more idiomatic approach! I have incorporated your feedback.
The simplest way, if the file is small, and indeed inside a singular multi-line string, is: s.split(/[\n,]/) Where `s` is the string. Which would return an array of 4 strings containing those numbers. (Not sure what your end result type needs are, but if you needed diffrent types, you could `map` a conversion function across the array.)
Use flat_map so you don't need an accumulator variable. Edit: great 👍
Any chance to send this thread to the author?
Do you realize...? Nevermind. 
&gt; Use test doubles, stubs and mocks instead of creating real instance of a class and invoking methods on the created instance. I disagree with this advice, incorrect or outdated doubles, stubs, and mocks are a common source of bugs in my experience. Stub / mock as little as possible, if that means your tests aren't technically 'unit' tests anymore, so be it, the more realistic coverage is worth it and 'integration' tests are more valuable anyway. The only place I use mocks / stubs are for external interactions, be it a network request or an environment variable. &gt; before(:all) I don't recommend this in general but there are rare cases where it is useful. You have to be very careful about anything in your tests that mutates what becomes shared state between them. The vast majority of the time if you have expensive test setup code it's likely because of interaction with external data stores. Presumably you're interacting with the real data store because some sort of state storage is important to the test. In cases like this either make the tests not depend on the external store, at which point the performance boost from avoiding the setup goes away so you don't need `before(:all)`, or you shouldn't use `before(:all)` because you do care about state and multiple tests changing the state of the same thing tends to cause problems unless you are very careful. Either way the answer is, don't use `before(:all)`. When should you use `before(:all)`? One place where I use it is when the tests requires loading some sort of largish data from disk. Maybe configuration data or some test fixture data (example html pages you're running a scraping algorithm on, images you're modifying, etc). I'll load it from disk once in `before(:all)` and treat it as immutable data for multiple tests.
Those benchmarks are impressive! Nice work! Glad to see an alternative to the current processors.
Wow, amazing gem here, I always needed to bulk remove the slack messages and its using ruby, which is even better. Thank you.
Thank you both very much! And if I wanted to separate that elements string into 4 separate strings, would that be easy? Again, coming from C++ I am at a bit of a loss. I cant find quite the right documentation or explanations elsewhere either.
Separating a string like `10001011` into groups of two looks something like this: "10001011".chars.each_slice(2).map(&amp;:join) The `.chars` gives you an array of chars, `each_slice(2)` allows you to enumerate in groups of 2, and `map(&amp;:join)` takes those groups of two and turns them into a single string. You're left with an array of 4 elements: `["10","00","10","11"]`
elements is not a string, it's an array of strings already, the last thing is just the result of Array#inspect, which ruby implicitly calls to print things to screen.
I think considering what this problem probably implies, you might also consider `s.split(/[^10]+/)` (greedily split on anything that isn't a 1 or 0) -- this way the string gets split into chunks of 1s and 0s regardless of what freaky deaky stuff (tabs, other delimiters, weird unprintable characters that got snuck in) lies in between your `[10]+`. This way you are focussing exactly on what you want, instead of trying to pre-emptively account for what you don't want. Today it's comma and newline, but that kind of stuff gets wrenched quick.
I've started referencing all constants from the global namespace, just to ensure that the behaviour is consistent, i.e. ::Animals::Dog.new I figure this should be faster than trying to infer the namespace too, but that's just an assumption, I've never bothered benchmarking it.
Yes, it's possible. I think you're looking for about `invoke`. task :something InvokeSomething(Foo.new) end task :test do_some_testing end def do_some_testing setup_test Rake::Task["something"].invoke check_if_it_did_everything_correctly end
I also write in a way that keeps the behavior consistent, but I've taken the opposite approach. I never use the `class X::Y` syntax, and always use the `module X; class Y` syntax instead. It leads to pointless indenting, but at least I don't have to think about the constant lookup rules, or whether module `X` exists yet.
Yeah, that works too, but I value the fact that I can see exactly what class is being referenced at a glance.
Well, I think the problem with what you're trying to achieve is that you assume ruby compiles things more than it does. If you have SomeClass#method and you reference it in your task, but subsequently eval the same class with a different method body, ruby is not gonna remember the first function definition - if you want to modify a function only in a certain scope you want to use a refinement. 
Hi, we at Spark Solutions (https://sparksolutions.co/) are relaunching official Spree website and there will be a list of agencies working with Spree. 
Nice
Hurray!!
Oh, well if you are trying to extract, might as well just do `s.match(/([01]{7})/g)` and work with the capture groups, but yeah, always a good idea to be more exact with regexs.
This should work. Before the invoke you can class_eval Foo and redefine the method bar. This relies on Foo being auto loaded of course and shared between the rake tasks
it sounds like you're not trying to modify a _rake_ task, you're trying to modify any old ruby method, in a rake task. I guess you could use ruby metaprogramming to redefine it, but can you make the first method just dependent on an `ENV` variable instead? And then have the rake task set it? (Or just set it yourself in the rake command, `SOME_ENV_VAR=something rake whatever`) But I don't really understand what you are trying to do or why, so my answer may be off base. 
Currently using jsonapi-rb for a rather largish API that has JSON API and Graphql endpoints. Absolutely adore this lib
Love POODR but can't agree more about recommending confident Ruby. I re read this book so much 
I know Dustin at http://www.smalhaus.com. He does wonderful Ecom work around Spree/Solidus. 
&gt; In Ruby there is nothing you can put in `swap` to make this work. Challenge accepted... require 'binding_of_caller' def swap(a, b) binding.of_caller(1).eval('a, b = b, a') end a = 'hi' b = 'hey' puts "BEFORE:" puts "a_id: #{a.object_id}, b_id: #{b.object_id}" swap(a, b) puts "AFTER:" puts "a_id: #{a.object_id}, b_id: #{b.object_id}" Output: &gt; BEFORE: &gt; &gt; a_id: 70205460060300, b_id: 70205460060280 &gt; &gt; AFTER: &gt; &gt; a_id: 70205460060280, b_id: 70205460060300
jsonapi-rb author here – glad you do! Would you mind telling me a bit more about your use-cases/scale/friction points/missing features in private? (For instance on the [jsonapi-rb gitter](https://gitter.im/jsonapi-rb/Lobby).)
Well, if it's not in English not very many people will actually read your post so keep that in mind.
What is `name.class` ?
`WEBrick::HTTPUtils::FormData`, but that's a subclass of `String`, so it should work...
You truly can't assume that. It's not uncommon to guard for specific classes. e: removed wrong example
that truly sucks :/ I guess it's not even considered a bug than? EDIT: with `class A &lt; String; end; a = A.new "ls"; Process.spawn(a)` it DOES work though
No, it's not considered a bug. And it's actually often a good thing. Pretty much anything in ruby can be coerced into a string either by calling `x.to_a` or `String(x)`, but the reality is that taking advantage of that feature often causes more bugs than it solves. Additionally, the `Process.spawn` method takes an optional first argument, which is a hash. It'd be very hard for this method to understand if the first argument is an environment or a command if a hash (which can be represented as a string) would be a valid command. 
ha, it seems to break when the subclass defines `#to_ary`... in other cases it works even with subclass
Yes - no Perl.
A problem I had using sharp/libvips in node-alpine was doing overlays in svg (it segfaulted). Would be nice if ruby-alpine didn't suffer from the same issues. 
YES! That will do it!
Never heard of refinement. Thanks for introducing this to me.
Tried to get the WSL working. Windows updates are managed by my workplace so it does not work for me :( 
&gt; Keep in mind that SubclassOfString.is_a? (String) is false. Do you mean that `class SubclassOfString &lt; String; end; SubclassOfString.new.is_a?(String)` is `false`? No it's `true`. `WEBrick::HTTPUtils::FormData.new.is_a?(String)` is also `true`. (You wrote `SubclassOfString.is_a?(String)` without the `new` but I guess that was a typo?)
You're totally right, that's my mistake, I was tired I guess. Will remove.
Maybe you meant `instance_of?`
All posts should be in a universal language like binary 
This comment makes me sad.
Grab me whenever. Just joined, username is braidn over there
&gt; However, the two biggest advantages of node.js. First being that it’s javascript ...
Post it! We can Google translate 
Perl makes me sad. 
Why? Genuinely curious. I loved it back in the day. Especially mod_perl. So fast. 
Then again, Japanese is pretty darn relevant for Ruby...
True, however most of this subs subscribers can't read it.
Sure, but there are people capable of translating it - and if all else fails, Google Translate might be at least partially understandable. There was a similar situation in /r/darksouls and related subreddits. Patch information, obviously, was coming out in Japanese; it was posted as-is, then it was translated by Google, then it was refined by people who knew Japanese, then it was refined by people who knew more about DS lore. In the end, everyone was happy. While the situation with Ruby is not quite as dire (most big news do happen in English), blocking relevant content simply because it is not immediately readable by everyone might be a bit shortsighted in my opinion.
Most people hate the syntax. Python as far as I can tell completely bumped Perl And the only people left writing Perl are the people too young to write Fortran and too old to learn a new language (Most of which are not full time developers). However, I am not a rubyist so there may be addition reasons. In general python and ruby (both scripting languages like Perl) have better communities. Community matters a lot in almost any language but a scripting language is meant to allow you to quickly develop a solution and this you want to find a language where a lot is already done for you.There are lots of gems and modules, in Ruby and python respective, so if we wanted to race to complete a non-trivial process, these languages would almost certainly beat Perl.
I said this in the /r/node crosspost, but this is just benching wrapper libraries. If you're just benching I/O, then why not spawn `libvips` directly? If you're benching wrapper libraries, then I'd clarify the title beyond "Ruby vs Node I/O". It'd be more clear with "sharp (Node) vs vips (Ruby) libvips wrappers". Or, even better, add the non-wrapper versions to the benchmark so we can see the wrapper overhead. In my experience with Node's `gm` wrapper, it can be huge to the point where I just spawn the process myself with Node's `exec` module.
I'll add the non-wrapper versions to the benchmarks, thanks!
I'm not sure this is a legit test of anything much - isn't it comparing a multithreaded ruby wrapper around a C library with a **single-threaded** JS wrapper around the same C library? If you forked a new node.js process for each size of thumbnail it might be a fairer test.
I'm moving from Macbook to Windows workstation and this guide is really appreciated. It looks like development under WSL will be quite a pleasant experience.
They are also taking different paths through libvips. The Ruby one is using ruby-vips, which is a FFI-based wrapper library. It's running this code: https://github.com/shime/node-vs-ruby-io/blob/master/ruby_io_speed.rb sharp is using libvips under the hood, but it's not a wrapper, it's a specialized image resizer written in C++ and called from node. It's running this monster: https://github.com/lovell/sharp/blob/master/src/pipeline.cc#L70 In my opinion, the benchmark shows that sharp could probably be sped up a bit, and that Ruby can be competitive if you leave the heavy lifting to native libraries and use it as a glue language. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [lovell/sharp/.../**pipeline.cc#L70** (master → 5f29d1b)](https://github.com/lovell/sharp/blob/5f29d1ba9c2ca89b3e1e166e2747b99e7c6622b9/src/pipeline.cc#L70) * [shime/node-vs-ruby-io/.../**ruby_io_speed.rb** (master → de70a9b)](https://github.com/shime/node-vs-ruby-io/blob/de70a9bed43eb3da2190245aec29896179b51c4d/ruby_io_speed.rb) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dml2r50.)^.
I don't know much about node, but sharp uses libuv, it's fully asynchronous. I think (could be wrong) the test is fair on this point. 
Heh of course I missed some things, the sharp author has submitted a PR with some improvements. 
Typically English is preferred so everybody can read it, but I don't think there are hard requirements. Regarding the user /u/namakemonohuman, this appears to be a bot that is just spamming blog articles. Such users are best reported to the mods.
I made it work with this code!: https://pastebin.com/pBsryN9i I'll leave this up in case it is helpful to anyone.
What's the trouble?
It would only iterate through on winning combination. So it would only look at [0, 1, 2] (top row win) then it would break out of the loop. I had better luck with detect iterator, I put the code in a comment.
It's convenient because it's easy to see and understand
I still wouldn't recommend Windows over macOS, but if you've gotta do it, you've gotta do it. 10.13ß7-9 is awesome so far. Feel like when I did back on Mountain Lion performance wise so many years ago now.
Great solution! I just wanted to drop a few questions which weren't covered in the article, but to which I would like to hear your thoughts and/or solutions: * What if we don't have our data (CSV file) and our DB on the same machine, e.g. if I'm using AWS RDS and EC2? Is there a better method than using the `STDIN` option? * Did you try out the [`PROGRAM` option](https://www.postgresql.org/docs/current/static/sql-copy.html)? I was thinking of using it in conjuction with `curl` to solve the problem described above. * I tried to look around and couldn't find any documentation about the risk of using `COPY` and SQL Injection, [except for this](http://pentestmonkey.net/cheat-sheet/sql-injection/postgres-sql-injection-cheat-sheet) which seems to outline how to use COPY to read files from disk in case you are able to run arbitrary SQL. Do you think that a feature that utilizes this can be public facing? Also, just to comment: &gt; the number of attributes in the CSV file has to be the same as the number of columns in the database table [The documentation](https://www.postgresql.org/docs/current/static/sql-copy.html) states that you are able to select which columns you want to COPY. Are there any limitations to that or is that feature unwieldy?
&gt; Tips to improve speed of your test suite http://rubyweekly.com/issues/360 &gt; When distributed locks might be helpful in Ruby on Rails application http://rubyweekly.com/issues/358 &gt; Racecar: A simple framework for writing Kafka consumers in Ruby http://rubyweekly.com/issues/358 &gt; The Hidden Costs of Metaprogramming http://rubyweekly.com/issues/355 &gt; Using influxdb with ruby http://rubyweekly.com/issues/357 &gt; How to avoid inheritance in Ruby? http://rubyweekly.com/issues/357 &gt; Graphing Benchmark Results in Ruby http://rubyweekly.com/issues/356 &gt; Preventing security issues in Ruby on Rails (based on OWASP cheatsheet) http://rubyweekly.com/issues/356 &gt; Ruby on Rails Code Audits: 8 Steps to Review Your App http://rubyweekly.com/issues/357 &gt; Realtime with React and Rails http://rubyweekly.com/issues/359 Please, don't get me wrong. The goal stated -- "it’s a full-time job just to keep up with the latest developments ... we’re keeping our eyes peeled, so you don’t have to" -- it is a noble goal. But maybe -- just maybe, I am not insisting -- at least one of those "digests" should not repeat weeks top-10 news and libraries, already mentioned in RubyWeekly?.. 
Not OP, but here's my take. &gt; What if we don't have our data (CSV file) and our DB on the same machine, e.g. if I'm using AWS RDS and EC2? Is there a better method than using the STDIN option? IIRC, when you use the psql client, you have the option of using the \copy command, which would then source the file from the current machine. AWS actually documents this [here](http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL.Procedural.Importing.html#PostgreSQL.Procedural.Importing.Copy) &gt; Did you try out the PROGRAM option? I was thinking of using it in conjuction with curl to solve the problem described above. I would not recommend this. You have no control over what happens if the curl fails, and someone could potentially [MITM](https://en.wikipedia.org/wiki/Man-in-the-middle_attack) the data. &gt; I tried to look around and couldn't find any documentation about the risk of using COPY and SQL Injection, except for this which seems to outline how to use COPY to read files from disk in case you are able to run arbitrary SQL. Do you think that a feature that utilizes this can be public facing? It can be, but I've never heard of a case where it has been used. I wouldn't recommend it. You have to make sure that the CSV filename is sanitized, so people can't SQL inject based on filename. i.e. say they uploaded a file named ../etc/passwd and your upload directory was /tmp then it would resolve to /tmp/../etc/passwd which would then be /etc/passwd There are other ways this could be exploited too, such as weird characters in the filename. In fact, you should probably just use your own filename for the temporary file. You would definitely also want to make sure that nothing in the uploaded directory is executable or even publicly accessible. I doubt that the CSV payload itself can contain something that would cause SQL injection to happen, since it should never interpret the CSV payload as an SQL command. Maybe some bad data within the CSV could cause something unexpected to happen, but this would only happen if it fails to be caught by the CSV syntax check, as malformed CSVs would likely be rejected by PG. The other thing (and in my opinion, probably the more vulnerable side,) is actually reading out that data from the database. If you're presenting the data on a webpage, you would have to watch out for [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting). Someone could put, for example: &lt;script&gt;alert('hello');&lt;/script&gt; as a column and if you didn't sanitize that while displaying, this would be an avenue of exploit. Another potential risk is if your application ends up using any part of that CSV input in another query. I could put a column in the file with something like ');DROP TABLE super_important_table;-- and COPY will happily import it. However, if you are not careful with handling this column, then RIP your db. IMO, this is a bit of a premature optimization. You should really stick to importing data at the application level, maybe in batches, and if that's too slow for you then move up to the COPY solution.
**Man-in-the-middle attack** In cryptography and computer security, a man-in-the-middle attack (MITM) is an attack where the attacker secretly relays and possibly alters the communication between two parties who believe they are directly communicating with each other. One example of man-in-the-2 attacks is active eavesdropping, in which the attacker makes independent connections with the victims and relays messages between them to make them believe they are talking directly to each other over a private connection, when in fact the entire conversation is controlled by the attacker. The attacker must be able to intercept all relevant messages passing between the two victims and inject new ones. This is straightforward in many circumstances; for example, an attacker within reception range of an unencrypted wireless access point (Wi-Fi) can insert himself as a man-in-the-middle. *** **Cross-site scripting** Cross-site scripting (XSS) is a type of computer security vulnerability typically found in web applications. XSS enables attackers to inject client-side scripts into web pages viewed by other users. A cross-site scripting vulnerability may be used by attackers to bypass access controls such as the same-origin policy. Cross-site scripting carried out on websites accounted for roughly 84% of all security vulnerabilities documented by Symantec as of 2007. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Thanks for the super detailed explanation :D Forgot that the file has to be relative to the client. I’m a bit embarrassed TBH. For some reason I thought it was server relative. I was mostly worried about SQL injection through the contents of the file, since, of course all user input to a query (such as filenames) would be sanitized. The XSS examples are a valid concer, though solved (for my particular use case) on the frontend by representing the data strings as text rather than HTML. My concern arose because pg_dump uses COPY with the STDIN option where it just outputs the table’s data as CSV. Therefore I thought that that could be used as an attac vector for SQL Injection. Better to ask than be sorry I guess :) I was looking into using COPY with the PROGRAM option for importing financial data from another internal service. The problem I’m currently experiencing is too high memory consuption during a first import (when the client’s whole financial history has to be imported). The problem occurs because a lot of POROs get instanciated to represent the incoming data and then batch stored to the DB (measured and benchmarked this to make sure that’s the bottlneck - exactly to avoid premature optimization). The whole process is excruciatingly slow and causes a high watermark for memory consumption - something I want to try and fix by using COPY. I think I’ll continue with this experiment and see if it will satisfy my use case.
You're very welcome. &gt; Forgot that the file has to be relative to the client. I’m a bit embarrassed TBH. For some reason I thought it was server relative. The COPY command is actually relative to the machine the database is running on, I think. The \copy client command, however, is client relative. Just to confirm, when you say batch stored, you mean that you are inserting X records at a time, right? If you're experiencing high memory consumption it is an indicator that your batch size might be too large. Roughly how many rows on average are we talking here? If you're using Rails, maybe take a look at https://blog.codeship.com/speeding-up-bulk-imports-in-rails/ and possibly https://github.com/zdennis/activerecord-import or https://github.com/jamis/bulk_insert If you're sure that it's still going to be too slow, then COPY is probably your best bet. If you have any application-level validations (i.e., AR validations, or any non db-level) those won't get run when you use COPY. At that point you could probably just skip Ruby entirely.
I'm here from /r/elixir, to be fair, so bear with my possible bias. Speed is money. Every moment spent on processing that doesn't have to be is a dollar spent that you could have saved. In a world where processing power is slowing down in terms of rate of growth, processing is more and more a premium while our demand for it will continue to skyrocket. Maybe web won't need it, but the demand from other fields like AI will slowly drive up the price of processing until web feels the pain as well. Try being a gamer right now with cryptocurrencies hogging all the GPU space. In this, speed, so long as it isn't at significant cost to developer performance, is valuable. You don't "need" it, but waste will not prove successful in the long run.
&gt;This KDF is actually not the best option considering I've been looking at this myself trying to understand if there was method to this madness. Glad to see that.. no.. there isn't.
Hi zverok_kha! This article shows all sources of the information. And it's possible that people who are interested in this topic have not reached all RubyWeekly posts. We just collected the newest useful Ruby info in one Digest post. 
&gt; We just collected the newest useful Ruby info in one Digest post. No you didn't. You just went through old RubyWeekly #355-360, consecutively (end of June - beginning of August), selected random links and called it "digest", because you need visitors for your company blog. I can't think of any other way for digest published at Sep 4 to consist of those links.
Nice DSL that is quite performant wrt to jbuilder.
The Typescript typings generation is interesting
With the end of the summer break, we resumed our Rubygems Monthly! A bunch of good stuff this month, and interesting things to come too! Sprockets and Mongoid are coming with major releases that you should know about...Sequel 5 is out, Spree 3.3 with a bunch of major things...and so on! Worth reading, if you ask me ;)
&gt; Technical people have very rarely had both the political and ethical strength to go up against such dunsels and win. Ain't that the truth!
I agree with this and when I designed `teapot` I used `teapot.rb` for the package configuration file. For the manifest I used `$environment-lock.yaml`. File extensions are good.
Thanks for sharing this with us, NeverUsesCondoms.
I'd prefer bundle.rb to gems.rb since it's a Bundler file.
The readme is a bit confusing on how to actually use the thing. Looks like a lot of work went into it though so very interesting to use. It seems to me that something like typed structs (virtus or dry-rb) might have been a better starting point for something like this.
I totally did not notice the user name. You made me spit cider!
While we're at it, I'd prefer `bundler.manifest` to `gems.locked`. It's a record of _what happened_ when a bundle was created, not a record that anything was "locked."
Couldn't agree more. `.manifest` is way more descriptive than `.locked`.
Seems like this is going to cause bugs for no tangible benefit other than to stroke some neck beards. 
I've updated the README and added a standalone example. Don't hesitate to have a look at the other pages (in Resources section), most of the explanations are there. I'm also here to answer your questions. Thank you for pointing me to Virtus (and Dry-DB) ! I'm a strong proponent of statically typed langages in general, and it always makes me happy to see Ruby libraries trying to introduce types in the codebase. Historically, BABL has been designed to be a drop-in replacement for RABL with which we constantly had many headaches. We were initially focused on having a way to solve N+1 issues once for all in our API templates. Typing assertions have only been added recently in order to provide better guarantees &amp; documentation to our API consumers. However, I love the idea of bringing Virtus integration to BABL! The way I see it is a new operator specifying the current Virtus class. BABL would just have to follow type definitions starting from this point. For instance: `virtus(Article).object(:id, :body, author: _.object(:id, :name))` would expand to: object( id: _.integer, body: _.string, author: _.object( id: _.integer, name: _.string ) ) What do you think about that ?
Not sure. It's always tricky trying to bring types into ruby. Virtus tries to do it, so does contracts.ruby and some other gems. Without a proper compiler it's all a bit fuzzy. Take a look at how crystal does things. With crystal you define a struct and then call a macro called json_mapping https://crystal-lang.org/api/0.23.0/JSON.html#mapping-macro The mapping macro also creates the attributes of your struct. There is also a yaml mapping macro. These give you two calls to_json and from_json and to_yaml and from_yaml. I don't know what happens when you do both :) Sigh. I really like crystal but man I can't seriously consider it for real world work until the community grows a bit and the core team is larger. 
I think Crystal's JSON mapping is great way to create JSON-(de)serializable objects. This is a clean approach, and this also is what I would do in any statically typed langage (Java, ...). The drawback is that you need to create this intermediate object, before serializing it to JSON (unless you make your ORM/business objects JSON-serializable directly, but it's not a good idea). This conversion has to be done manually, and I'm not sure it worths it in Ruby (at least, without Virtus). The approach taken by BABL is different, because it lets you serialize your ORM/business objects directly without having to change/add type definitions to them. They don't need to be converted into any intermediate object manually. Typings are only used here to document APIs (and add corresponding runtime assertions). I would classify BABL as a drop-in replacement for JBuilder/RABL: better &amp; faster. But it really doesn't try to bring types to Ruby.
http://engineering.appfolio.com/appfolio-engineering/2017/5/24/how-is-ruby-different-in-japan
I might give it a try and see how it works for me.
This article exemplifies well the difficulty in providing sane concurrency tools with the existing low-level abstractions within Ruby. IMO Guilds won't be a solution to all problems. They'll be heavy to handle, hard to rewrite tools to (most handle synchronization of memory access, like db conn pools, this seems not to be a possibility with Guilds), and will still have to deal with the existing limitations, like non-transferable fibers or mostly blocking I/O.
Thank you for your interest. I will keep on improving documentation during the new few days. Feel free to create issues or ask me any question you might have. Feedback is important to me.
While the article itself is excellent I was curious about the SVG visuals and was surprised at their construction after taking a peak [under the hood](https://brandur.org/assets/http-transactions/http-transactions.svg) (lines actually made up of many segments, possibility all vertically chunked into columns). This got me thinking that this could be a product of a script that generates SVGs from ASCII inputs and I found [one such tool](https://github.com/ivanceras/svgbobrus) almost immediately. It doesn't appear to be the same as the one used on brandur.org but still a fun rabbit hole to fall down that I didn't even know existed until today.
Take a look at our open source Trailblazer project - http://trb.to . (The umbrella gem/project for Reform, Cells, Representer, etc) Right now at version 2.0 it supports roles, states, events, process flow - etc. Version 2.1 coming out around December, will have BPMN support and a commercial BPMN editor - that will generate your Ruby code from diagrams. We are working on the editor, documentation, and Nick Sutterer (creator of the project) is working day and night on fixing the bugs in the underlying code. Nick is going to give a talk about that in Kiev this weekend. Hopefully it will be recorded. https://github.com/trailblazer/trailblazer-activity is the main gem handling BPMN integration 
Yeah, when bundler decides to use the versions specified in the file we currently name `Gemfile.lock`, I might describe that behavior as "locking." When it decides to use the latest possible versions allowed by the file we currently name `Gemfile`, it exhibits behavior I'd call "updating." Those are both logical concepts, and "locking" is by no means epitomized by the `Gemfile.lock` file itself, but rather by how it is used by bundler.
Good article.. But still, most development in the world happens in USA, Europe and parts of Asia. The language barrier is a big one and if the Japanese government/organizations don't try to market those new tools/ideas abroad, ruby is losing in the long run. 
The benefits of this change seem very minimal. Since both ways will need to co-exist for years to come, is it really worth burdening every newcomer to Ruby with yet another thing to learn about?
The article is not really specific enough to answer the question.
Are programming languages generally used differently across culture boundaries? I have a hard time understanding how Ruby usage in Japan would be any different than anywhere else seeing as Matz is Japanese.
I believe that the reason for this (interesting and not quite answered by an article in the first comment) question is not the "culture boundaries". The reason is Japan has one of the largest and toughest Rubyist communities and one of the innumerous ones which don't bother to translate their achievements into "commonly understood" English. Therefore, we just don't know much, unless accidentally stumble upon some gem. For all I know, there is a lot of work on scientific libraries, for example. 
Interesting, thanks for the context
Very interesting article. Thanks for sharing!
How did you install Ruby? I think that is probably the real issue.
Jekyll certainly doesn’t require root, must be the way your Ruby is set up. I recommend installing rbenv so you can easily switch rubies, and use it all without root.
From the repos.
I have a [blog](www.brewing-bits.com) usinng jekyll. And i don't think my deploy user needs sudo. You might (i don't know) need `sudo` if you are just using `gem install jekyll` since it is not scoped to anything, but if you use a `Gemfile` and `bundle install` it shouldn't be an issue.
I first the first half, but the gemfile and bundle things I am unfamiliar with other than having bundler installed because Jekyll depends on it. What do you mean?
Find a (recent) dictionary and look up "programmatically". 
What definition leads to you being correct?
I guess being a bit smaller is nice but if you ever get to the point that you're putting enough stuff in the session for it to matter you're likely better off rethinking why you're doing such a thing rather than to optimize the size.
It was definitely a nice side effect rather than a goal.
I'd recommend clarifying the goals / reasoning for the project. If it's performance or security, maybe elaborate on those and focus on them first. My take away from reading it was that size was the major win, particularly since 'Smaller cookies' is the top bullet point amongst size, performance and security.
Frankly it's the easiest to explain. Performance is great, but it's an extreme microbenchmark and Cookiestore is probably the least of your performance issues. The overriding goal is security, but it's similarly not easy to demonstrate. I will reorder the README accordingly though.
How does a program tell me that the URL I'm using has a valid endpoint on the github API without a status code?
&gt; The overriding goal is security, but it's similarly not easy to demonstrate. So it's just that salsa20-poly1305 is more secure than aes-256-gcm or something else?
&gt; aes-256-gcm Cookiestore uses AES-256-CBC mode. This is generally a bad idea. You're also comparing OpenSSL code quality with libsodium code quality.
I'll write one for you for fifty dollars.
&gt; Cookiestore uses AES-256-CBC mode. This is generally a bad idea. https://github.com/rails/rails/pull/28132 &gt; You're also comparing OpenSSL code quality with libsodium code quality. I assume you hold the position that libsodium's code is better, which is a great point to make in your readme :)
How does a program tell me that the URL I'm using has a valid endpoint on the github API without a status code? 
I've already told you how for free, I'd be happy to do it for you for a fee.
I'm assuming you installed Ruby as `root` using `sudo`. Another option, often used with version management tools such as `rbenv` and `rvm`, is to install Ruby for a specific user (this can be done in addition to the system's Ruby). When Ruby is installed only for specific users, the gem folder and installations are all performed exclusively for that user, without requiring `root` permissions. This will allow you to install and run Jekyll (as well as other Ruby gems or versions) without using `sudo`. I recommend you try to get Jekyll working because you'll get a lot of community support when you use widely used tools. Good Luck!
A PR appears to change the default in the upcoming Rails 5.2. That's a move for the better, but a) It's not here now b) It's still Openssl &gt;I assume you hold the position that libsodium's code is better I wouldn't have thought there was a question there.
How does a program tell me that the URL I'm using has a valid endpoint on the github API without a status code? 
[bundler](http://bundler.io) is a (or rather the) dependency manager for ruby. If you `gem install bundler` you could do the following: 1. `cd my-project-folder` 2. `bundle init` this will create a `Gemfile` where you can specify you dependencies. In you case you can just write `gem jekyll`. 3. `bundle install` will install your dependencies into (i think) a scoped directory (scoped to your ruby version at least). 4. `bundle exec jekyll build` will call jekyll through bundler, so that it will access the scoped binary. I really don't think you'll need any sudo for that.
https://pragprog.com/book/btrubyclo/mastering-ruby-closures
I am Spartacus.
How does a program tell me that the URL I'm using has a valid endpoint on the github API without a status code? 
I am Spartacus
Nice writeup!
Jekyll doesn't require root. Just `$ sudo chown -R your_user:your_user ./`.
Injection was my first concern too, but as with most things, it depends on your use case. 
I've been working as a Ruby dev in Tokyo for 2.5 years now. I think the idea of "Rails not being big" in Japan is a misnomer, the majority of web dev positions I've seen come up here are either exclusively Rails or JS (to a lesser extent) with some Rails experience considered a plus.
Thanks ☺
Liked the use of merge to place the logic in separate objects. However, as a user of CCC I have to say I'd love to rip it out and use pundit instead.
I'm not saying you're wrong because I don't know how they got their info, but it's not out of the question for two competing sources of news — Ruby or otherwise — to have significant overlap in their content. This is especially true when you consider that most Ruby Weekly content comes from links posted in this very subreddit (Peter Cooper is a mod here). If they also got their links from this subreddit, it simply means they have the same source, which does not imply that one is the source of the other. The fact that Ruby Weekly is a superset of these links could very well just be due to it having more content overall. There's no cause for accusation in that. Again, I'm not saying you're right or wrong here, but you seem awfully confident in a position based on inconclusive data.
I've used [camaleon](http://camaleon.tuzitio.com) for a couple projects. My clients love the ease of use and I love having the ability to extend it in pure RoR if need be.
Never used it myself, but a former coworker was really happy with [comfortable Mexican sofa](https://github.com/comfy/comfortable-mexican-sofa) for marketing/verticals/landing/etc pages
I think I'll be doing some work to get the damn thing working smoothly with rails 5.2 It's working fine in 5.1 but with buttloads of deprecation warnings though.
Where the heck would you find `merge` documented, if you didn't see it in this blog post?
Well it's almost like they're trying o hide this feature. You can find it in the [docs](http://www.rubydoc.info/github/CanCanCommunity/cancancan/CanCan/Ability#merge-instance_method), but there is hardly anything there. I think i once found it while using `pry`. A la `ls CanCan::Ability` while looking for something useful.
Yeah pundit is awesome! I think CCC still has some neat convenience things (like `load_resource` and such), but pundit appeals to my love for POROs.
Nothing like wordpress for sure. I don't know why that is but given that ruby has been out for decades and still not one decent CMS has been written in it maybe it's just not possible.
Well, maybe it was a statement too bold, but... 1. There are a lot of new "cool digest" these days, and I'd be really happy to see some digests that are NOT repeating what all of us already read. There are obvious methods to do such digest (and validate its contents against RubyWeekly seems like a good start, don't you think?) 2. In this case, I don't see even a _slightest attempt_ to do something new, just an attack of cargo cult "We do 10 links, we make them look 'professional', everybody will trust us and read our blog" and buy our consultancy", that's why I became irritated. 3. My "accusation" was, let's say, an educated guess, based on the facts: a) links are overlapping; b) ...with several _consequtive_ RubyWeekly issues; c) ...which are 1.5 months old. Two possible reasons of the latter: (i) that one I've mentioned, they just copypasted them from not-very-recent RW; or (ii) they've gathered the links independently, just did that in June and then... published the digest on Sep 4. I believe that those explanations are equally probable, but any of them marks a really lazy piece of work.
I am trying to change that. The 2.0 version of my blog CMS, [pSaMS](https://github.com/skamansam/pSaMS), will have wordpress API compatibility, so translating plugins would be kind of trivial. It took a while, but I finally got plugins to work with separate views and resources so they can be dropped into the plugins folder, like in WP.
Yaa ya. Thanks. Will do :)
Not to be rude, but this doesn't seem like a very effective pitch. Why do you need money to write a book if you already have a 250-page draft of that book on your website? Seems to me like you have already written the book, so what do you need the money for? And: what will you offer that other self-guided books/programs don't?
Your book is **full** of spelling and grammatical errors. You do not have command over English to the extend where you should be trying to write books for an English market. Spelling and grammar aside, the tone of your writing is *extremely* informal and better suited to a series of blog posts. This is not a book that needs to be funded or published outside of your blog. &gt; To get the latest news about “Ruby Programming”, type it in the search bar and press search. You will get latest trending topics about Ruby language. Try searches like “Ruby language” and blah blah.... Are you serious?
This jumped out at me while I was skimming through: &gt; Poly means many, and morphis means forms. I think its either in Greek or Latin, who cares? Um... intelligent people? Nerds? In other words, *your audience*? And if you don't care what language it's in, why do you care to dissect the roots? ...and then he follows it up with: &gt; Why there are so many difficult words to learn when you want to be programmer? Who knows? Possibly speaking some non-understandable blah blah might make you look intelligent Any technical field is going to be full of jargon. If it is "non-understandable blah blah" to you, then that means you don't know enough about the field to write a book about it. If you think that using specialized language to refer to specialized concepts is "difficult," or if you think that jargon only exists to "make you look intelligent," then you probably aren't cut out for a technical field. Hell, you probably aren't cut out for any professional field; any specialized career is going to have some amount of jargon and at least a few words with 4+ syllables.
Seems like Crystal would be a better fit than Ruby
Ha-ha, people here don't like the truth! :)
It doesn't make sense to use ruby even in that tiny case. It's better to keep dev (research in python) and prod as close as possible, so in most cases prod will be python too. And even if you decide to use different environment for prod, usually for performance or compatibility reasons, it also won't be ruby, but probably java or C.
Do you need the site to be dynamic? If not then [jekyll](http://www.jekyllrb.com) might be enough for you. It basically renders you static pages from markdown and is pretty extensible through short plugin scripts. (I've been told it is comparable to wordpress, but i have never used wordpress myself)
I always thought the `Gemfile.lock` 'locks' the versions used until `bundle update` changes that. So that you can rely on the same versions on different systems (given you have added the `Gemfile.lock` to version control).
Python
They are both wonderful languages. Try them both, see what you think and then go deeper into the one that you prefer.
Why it's more suitable than Ruby?
Yes.
Although Ruby is probably better in web development, if it's your first language to learn I'd go with Python. More market share, less conventions to figure out, easier to debug, it's faster, better data structures, etc. If you're just throwing together some simple MVC app or API I'd probably just use Ruby. 
Ruby is less finicky than Python and is easier to get used to, IMO. Their syntax is pretty similar though, especially compared to C-style languages. As for utility, they both have large established bases, and are both useful to have in your pocket.
It's the second best at everything which makes it highly useful. I find Python easier to read and maintain. You probably wouldn't go wrong with Ruby either. Start with Python 3.6. Python 2's death clock is in a couple years. https://pythonclock.org/
Thank you
Thanks ✌️
&gt;Unix text processing (instead of awk, sed, Perl) You've named the kings of that domain, ruby and python both have text processing/regexp facilities but they are nowhere near as fast. I like ruby's regexp implementation a little better than python's. (go figure, says the guy on the ruby subreddit) &gt;Web development Ruby has some pretty bitchin web frameworks, though django and flask do a lot of the same things. The only thing that might edge ruby out as a clear winner here is that rails has _so_ much community support, so if you don't want to re-invent the wheel, you can use a gem, whereas python might not have the same level of community support for django. It's probably pretty close. &gt;Programs for Unix open source projects Python is probably viewed as more of a "systems language" now than ruby. Both are equally capable of being scripting languages used for everyday tasks, just depends on what you're wanting to do. &gt;Mobile Dev (not as much important as the first three items). Ruboto/Rubymotion/Mobiruby are all things. I think ruby might actually take this the most handily. ----------------------- tl;dr Learn multiple languages, use the tools that make sense for the project. Don't be bound to a single language.
Thank you for your response 👍
¯\\\_(ツ)_/¯
Love the 1994 style homepage of rude boy. 
&gt; Possibly speaking some non-understandable blah blah might make you look intelligent Good god, it's so much worse than I realized. It's like he's trying to alienate his target readership.
Gemfile.lock doesn't lock anything. Bundler locks gems by using the versions in that file.
I did 8 years of scientific programming in ruby, and 3 years of professional web dev in python (yes, it's ironic). Both are great languages, and I'm more than happy to code in either language at this point. I personally think ruby is easier to use for most of the things you mentioned, and I think ruby is a more elegant language than python (I think ruby is a better language, but I do think aspects of python are better). You really can't go wrong with either. And, as was already pointed out, use python 3.6 if you choose python (the 2 train has left the station, thank heavens).
Scientific programming in Ruby? I'm surprised. Ruby is really cool! Which ruby libs did you use: maths, physics, biology, statistics?
Yes.
There are actually a lot of science packages in Ruby. I used bio ruby, rserve (connection with r), various sciruby packages (some of them before they were "sciruby"), and narray. I also wrote many science packages for general use (such as rubabel) and also for my domain of research. I worked at the intersection of systems biology and chemistry.
That's really awesome👍
Python. In my opinion one of Ruby's biggest drawbacks for new programmers is the fact that Ruby allows lots of different ways to do the same thing. Ruby is a language better suited for more experienced programmers (who will appreciate the language more), despite its gentle learning curve.
So that it could be made better by concentrating more time on it.
Nope I was joking. Yes I need to correct lot of spelling and grammar. I need to hire a professional proof reader or some one.
I don't believe in jargon. I think things can be made more understandable by saying it it a way people can understand. For example take the word "Orthopedic doctor", why can't they be called as "Bone doctor"? I wonder why it is that we must use something thats not understandable in the first place.
Well if you are so good enough why can't you write a book of your own? How do you think I am making y money now? Are you ready to face me off in a Ruby programming challenge? Its the duty of teacher to teach people in way that they can understand. Jargons don't help things much rather than make a subject look complicated.
This is a free book. Why don't you edit it and send me a copy back. Numerous people do it.
I personally love ruby but came across this article today [link](https://www.theregister.co.uk/2017/09/09/python_is_an_expander_not_a_constrictor/)
Well people, please point out more mistakes so that i can make it better.
_Well people, please point_ _Out more mistakes so that i_ _Can make it better._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^mindaslab ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
&gt; Well if you are so good enough why can't you write a book of your own? Because I already have a job, and there are already many very good Ruby books. &gt; How do you think I am making y money now? Apparently by asking for handouts on Reddit &gt; Are you ready to face me off in a Ruby programming challenge? Based on your book, I can very confidently say I am a stronger developer and Rubyist than you are. &gt; Its the duty of teacher to teach people in way that they can understand. No, it's the duty of the teacher to prepare their students for the real world. Somebody who reads only your book will make an ass of themselves on a job interview See also ["those who can't, teach"](http://idioms.thefreedictionary.com/Those+who+can%2C+do%3B+those+who+can%27t%2C+teach). While I'm not saying all teachers "can't", I strongly believe you should be successful in a field like Ruby development before you try to write textbooks about it. &gt; Jargons don't help things much rather than make a subject look complicated. Complicated subjects require complicated *specific* language. If you don't believe this is true, than you don't actually understand the complexity of the subject. 
Why do you think you can write a better book than the ones that already exist? The Ruby community (and software development in general) is *full* of people who *want* to write but have nothing worthwhile to say. I keep coming back to this sentence: &gt; Possibly speaking some non-understandable blah blah might make you look intelligent If that's your opinion, then you are *not* intelligent, and you should not be writing. Nobody uses jargon to *sound* intelligent, the "jargon" is actually necessary to unambiguously and correctly talk about many topics. If you don't get this, than you don't actually understand these topics, and you shouldn't be writing about them as though you are some kind of authority.
&gt; There are a lot of new "cool digest" these days, and I'd be really happy to see some digests that are NOT repeating what all of us already read. I could totally get behind that, but not everything _has_ to have unique content. And don't let the fact that you and possibly everyone you know reads RubyWeekly trick you into thinking everyone does. I know plenty of Rubyists who don't read it or only rarely read it before archiving. If this blog series reaches people who don't read RW, that's great. &gt; In this case, I don't see even a _slightest attempt_ to do something new, just an attack of cargo cult "We do 10 links, we make them look 'professional', everybody will trust us and read our blog" and buy our consultancy" I'm not sure I understand how would cause a problem, let alone one worthy of berating somebody on the internet for it. &gt; My "accusation" was, let's say, an educated guess, based on the facts: a) links are overlapping; b) ...with several consequtive RubyWeekly issues; c) ...which are 1.5 months old. The quotation marks are unnecessary. You literally made an accusation. Like, _literally_ literally. There are plenty of reasonable explanations for all of those, though: - links overlap because RubyWeekly catches nearly everything good and certainly everything good that crosses this subreddit - if two periodicals publishing contemporarily popular content have any degree of overlap, they're going to overlap for the same time period because that's how time works :-) And who knows? Maybe they're indeed ripping content straight from RW. But even if your conclusion happens to be correct, it doesn't imply that the information you provided as justification for it wasn't circumstantial. There's nothing definitive in it. In the end, who cares if they publish the same content? The majority of articles I see about React, Elm, and other hot concepts are all rehashing the same content and I see a lot of conference talks covering the same topics, but you can't fault people for working on something that isn't hurting anyone. A human being put effort into this. If someone prefers a 6-week cycle to RubyWeekly's, maybe they'd like this blog instead. And that's okay.
Rails requires you to learn the Rails way (their convention) but Ruby does not. For me Python had more tricky things to learn at first. `self` in methods, `__init__.py` and enforced directory for structure, virtualenv to use different pkg version between projects (compared to bundler). And the significant whitespace :) On the contrast Ruby may do magical things with module and lexical scope, and optional parens, etc. Great for DSL, but can be confusing if overused. Both are good languages for those who learn programming language for the first time. You don' choose one language for the rest of your life :) 
It seems to me that you could do that in your free time. It also seems to me that many of the book's current flaws are related to your English writing/editing skills, and that the work required to polish it may be outside your range of expertise.
What are you talking about? This isn't a dick-measuring contest about Ruby knowledge. I am a novice Rubyist, but I am a professional writer with a background in technical writing. I am critiquing the tone of the material you've produced, which is just as important as the content. In my professional opinion, I believe that your work would benefit greatly from the attention of a professional editor. I can't speak to the Ruby content or organization, because -- as I said -- I am a novice. But I *can* tell you that the way this material is written is unprofessional. It needs polishing. Look: If you want to create a good book, it's not enough to be a subject matter expert; you also need to be a good writer. You're correct -- it absolutely *is* the duty of a teacher to teach people in a way they can understand. And it doesn't seem as though your skill set is particularly conducive to helping your audience understand. Bottom line: Learning jargon is essential to learning a field. If a new Rubyist doesn't know the jargon, how will they be able to understand professional discussions and higher-level reference materials? By pretending as though jargon is pointless, you're hurting newbies and you're alienating intellectually-oriented folks who *want to learn.* You don't pick up a 250-page textbook to learn something on your own if you're the kind of person who wrinkles their nose at jargon.
But jargon *is* understandable. Learning to understand it is part of the process of gaining subject matter expertise. If jargon is "not understandable" to you, that means you haven't studied the field well enough to write a book.
Sure! If you'd like to engage my editing services, I'll proofread this project at the rate of $1.50 USD per page. That's half the market rate for proofreading.
Ruby on rails use is on the decline. Python is the most popular language for data science.
Rails was incredibly confusing for me when I was first learning MVC because I couldn't follow the logic from one point to another - "convention over configuration" meant flow jumped from one place to another without warning (in ways that were much more obvious and standard once I had built several sites in that pattern without Rails). I found Python's "explicit over implicit" much easier then.
This was hilarious! 
The language used seems to be too informal and chock-full of _"[Indianisms](https://en.wikipedia.org/wiki/Indian_English)"_ to be understandable to a global audience. If you intend to release this book to the general public, a full rewrite of the book may be warranted, after you've undergone a technical writing course or even just a general writing course. Or hire a professional technical writer who can ghost-write it for you. 
**Indian English** Indian English is any of the forms of English characteristic of India. English is a lingua franca of India. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/ruby/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
That's one of the reasons why Golang is so popular, there are so few options to do something. Unlike Ruby. 
&gt; Are you ready to face me off in a Ruby programming challenge? Hahaha. 😂
the book more like some blogposts added together. I guess the author should try to see how other have written tech. books. 
I mean, you asked /r/ruby.
I feel a bit lost. What's your point?
So what about the ruby challenge rather than a talk?
are you joking? You 14 or what? Also, if you're english is not you native language. Why not writing in your native language and help community. Ruby has quite a lot of really good books. And your book... /edit I read more on your book. You are confusing stuff. `.class` is a method. Later you say is a `function` You need to be consistent and correct with terms, otherwise people will not understand what you want to say.
Hello People. This book started as a patch work 10 or so years ago. And it was written in a way so that things don't sound complicated. As you must know this is still marketed as a toy book. Regarding the language, yes I am from India and don't mind much about being formal or following jargons. Even though some people think Ruby language is complicated and must be thought in a complicated way. I felt it to be really simple and have written the book in a simple way that felt good to me. This approach seems to have benefited lot and lots of people who are starting to program.
I am not ready to pay any one for proof reading now, sorry. If this campaign generates something surely I may.
I need to pay them well if I do it. Right now this book is all gratis, once I get a good funding I might now worry to spend.
This book is not meant to be too formal or some thing. Its is this, to provide free to use learning resource to people who want to become Ruby. Because for some reason most of Ruby programming books are paid even though they explain very simple concepts. And it was written in a way people can get started and going quick.
Dude there's no distinction between functions and methods in ruby :P
Okay dad I will learn jargon :D http://dilbert.com/strip/2016-08-19
semantic is a mistake. In this sense, a function is a type of procedure or routine, but as in ruby is just about oop, is more correct to say methods, as they belongs to a object `def foo;end` --&gt; will belong to Object.
Ya ya jargon is for intellectuals http://dilbert.com/strip/2011-10-30 :)
The importance of Jargon in tech field understood http://dilbert.com/search_results?terms=jargon :))
When asking people for money, you really ought to be up-front about how you'll use it.
That's one take on a specific overuse of jargon within a specific context. If that's how *you* use jargon, then yeah -- it's not doing you any favors. But that's not how professional adults use jargon. Professional adults use specialized language when their life or work requires them to discuss complex concepts. Professional adults don't look down on other people for using accurate, specific language. And if they don't understand a word, they look it up or they ask for an explanation. Why are you so obsessed with the idea that people only use jargon to look smart? Are you projecting a little, maybe?
Huh, TIL Scott Adams doesn't understand the difference between jargon and buzzwords.
It's like the nerd equivalent of asking me if I want to take this outside.
But why would people give you money if you have no idea how you'll spend it? This pitch is getting worse, not better.
&gt; free to use learning resource to people who want to become Ruby. There are already so many out there. What makes you think you're qualified to write a better one?
I personally don't see that as a bad thing for start-up. It forces you to think about everything you write, but also gives you an element of freedom with what you do write — you aren't force to follow the so called 'phythonic' way. Also it's way more enjoyable to have options.
Exactly the fact that you do not have any functions that are not in fact messages send to objects means that there's no meaningful difference between functions and methods. methods are a particular kind of functions, in ruby all functions are methods, but they're still functions. 
"Function" implies a method on `main`, `.class` cannot be considered a function, even in Ruby. The leading `.` should prevent *anybody* from calling it a "function".
You're cementing your appearance of ignorance by repeatedly reposting this. At this point you seem to take pride in it, and nobody is going to take you seriously.
I disagree about the "easier to debug" part. Have you tried byebug? Does not get much easier than this. Also error messages are objectively better in Ruby for a beginner.
You're not qualified to define the terms *or* judge the results of such a contest, and it's sad that you think "oh yeah, wanna fight about it?" is the way to "win" an argument while ignoring every other opposing opinion or disregarding it with a link to a Dilbert comic.
Well for someone who would be new, being shown all the ways to do one thing is well, confusing. Imagine teaching someone calculus and as you're teaching them implicit differentiation, you show how you can solve the same problem using an approach with arc length, or partial derivation. Cool? Yes! But for someone learning, it's best to stick with one way of doing things until they're comfortable with it.
That you were unnecessarily harsh about someone posting content on the internet that you've seen before.
When you use any web framework, you cannot avoid "jump from one place to another" anyway. That's how framework works. Check out the inversion of control. Rails convention is just one opinionated way to avoid tedious configuration with specific abstraction. Django has it's own way to do it, with less "magic" than Rails. So for OP, just choose one. You cannot fail with Rails or Django in most cases. Both Rails and Django are good framework to get things done. And most knowledge are transferable when you switch language/framework anyway. 
Then why re you taking it seriously? :) I am just a mad on the Internet, are you more mad than me to take it seriously?
Care to back that up? Because that's nonesensical to me. `main` is an instance of `Object`, and you can call `.class` on it and get `Object`. That seems to me like an imagined difference, but if you have some source or reason why there should ever be a seperation in ruby, I'd be happy to see it. 
I don't know, there are so many better people then we are whats makes us think we are qualified to live of this planet? Possibly some blind hope!
Well they can put their personal accountant to monitor me 24X7
Not really. If thats the case none of us should pay taxes.
Zero is not native to the western world, then why are you people using it? Why can't you people use numerals developed by Europeans and help your community? Thanks for pointing out. Will correct it. It would have been great if you have said which section did the mistake appear, but I can find it.
You can comment that on dilbert.com
I don't say that people use jargon to just look smart. All I say is you can do away with it in most of the cases. For example Hemingway is more understood in many countries than compared to Shakespeare because he uses very simple English. Yes he received a lot of criticism for that even after he the Nobel prize, but his aim was to tell a story. My aim was to get people in my office started with Ruby as quick as I could.
Face if you, or run. I don't care.
OK, we've both already spent much more time on the problem than it deserves, so... Let's spend some more, I think? So, first: we are speaking of information economy here, or economy of attention: author spends some _time_ to receive some _attention_ to something author self-identifies with (his person, or his business, or ideas he believes, or tools he loves, or approaches he values, or something). Then, this subreddit is like a small "attention market"... Imagine a local food-market, for example. Not a big deal, just $1 here, 70 cents there for a bite of snack. If somebody will sell you really bad food there, you'll not call it "good", right? But your reaction would differ depending on the person of a seller. If it is nice old lady, you'll probably mumble some thanks and go away. If it is some young person too proud with their cooking, you may politely say something like "nice, but could it be less salty next time?" And so on. Now, what we have here? The seller is, say, some city shop trading fancy plates. They made this "food" not because they live on it, or because they like to cook, but just to promote their shop with logo on food packing. So far, so good. But what if the "food" they try to sell you is _really_ bad? Like a slice of moldy bread topped with cheap dried up cheese. In this situation, it is hard to be polite or tolerant. They **could** do good (if they want a good PR), but they just **didn't**. Now, why I think this piece of "food" is really bad? Not because just "content on the internet that you've seen before". The thing I've already pointed at (which you ignored): it is not just "intersects" with RubyWeekly. It intersects with _6 consecutive old issues_ of Ruby weekly. And then topped up with noble statement about &gt; ... it’s a full-time job just to keep up with the latest developments. The good news is that we’re keeping our eyes peeled, so you don’t have to What's your mind model how they've come up with this result? What's your expectation about how people should react to it?
That's a ridiculous comparison. Shakespeare and Hemingway are separated by 300 years.
I picked up Rails a couple of years ago and initially felt like I was late to the party. But I really enjoy it and there is still a high demand for it. As was said before, try them both and pick with the one that you like better.
See, the difference is that I'm not asking you for money just so I can exist on this planet. If you're asking people for money, but you're not willing to explain your credentials or justify why anyone should give you money... you're just wasting time.
You're utterly missing the point. It's not about *finding out* how you spent the money after you've already spent it. It's about how you *plan* to spend the money before people give it to you. Why would anyone give you money for no reason? You've already produced a draft, and it's frankly not great. So what is the money for? Why should strangers pay you for your not-great book?
What are you talking about? When I pay taxes, I have a really good understanding of what that money pays for. I know that it funds roads, education, military, social safety nets, and a whole lot of other specific things. Things that benefit me in a tangible way. I don't know a damn thing about what you plan to do with this money you're asking me for, and there's no social contract in place that says I owe you money for services that you provide. If this is how you attempt to fundraise... you'll never succeed.
Why would I waste my time? I don't know about you, but I have better things to do than commenting on dilbert.com.
&gt; you can do away with it in most of the cases. Not when you want to talk about specialized subject matter in an intelligent way... but it's clear that's not what you're going for, so no worries. &gt; My aim was to get people in my office started with Ruby as quick as I could. If this is a project that you're doing for your employer to help your coworkers, why in the world should *we* help you fund it? &gt; For example Hemingway is more understood in many countries than compared to Shakespeare because he uses very simple English. So, all you're saying is that more people understand simple english than complex english. Yes, this is a fact. There are more people out there who can understand *The Cat in the Hat* than there are people who can understand a text about quantum mechanics. What exactly is your point? You can have a simple writing style and still use jargon. You just have to be a competent writer.
&gt; Zero is not native to the western world, then why are you people using it? When your grasp of English is as good as a child's intuitive grasp of the concept *zero*, then let's revisit this discussion.
&gt; I am just a mad on the Internet, are you more mad than me to take it seriously? Glad to hear it... I thought you were serious, guess you're just trolling?
True, but with Ruby you can begin with more simple method, but if you're keen though, introduce other ways of solving things. To continue your analogy, you start calculus with day first principles, and then gradually learn shortcuts, and more complex methods. _edit; spelling_
Give [this gist](https://gist.github.com/luislavena/f064211759ee0f806c88) a read.
you can't compare rails to python. One is a big boilerplate, the other is a language. You'd be better to compare rails to django or flask to sinatra.
&gt; `load_resource` I always had mixed feelings about that design pattern... On the one hand: * It removes some "boilerplate" code from your controllers. * It generally provides a *consistent* approach for loading resources, throughout the application. But, on the other hand: * It really doesn't remove *much* boilerplate code... You can achieve the same thing with some simple `find`/`where`/`find_by!`/`find_or_initialize_by`/... statements. * ...Which makes the code much more explicit, and obvious what it's doing. (Especially if you're unfamiliar with the `CanCan(Can)` library.) * The loading of resources and authorisation feel like two totally separate tasks; why is one library doing both things?
Totally agree. I think it would be quite easy to duplicate using controller_name and instance_variable_set (but I haven't tried it so far so don't take my word for granted) and I also agree that cancancan really oversteps its boundaries here. The one thing I'll say is that I don't know exactly what passing sql conditions to a ccc rule does (i suspect that could be a point where loading resources through ccc can have its benefits). Edit: sorry that I cannot really provide examples or links, but I am on mobile right now.
&gt; this subreddit is like a small "attention market" They didn't take any attention from you. You chose to invest your own attention into this. You're the one that looked at their article, then went through 6 separate issues of RubyWeekly to find the same links, and then troll them on the internet about it. &gt; But what if the "food" they try to sell you is really bad? Like a slice of moldy bread topped with cheap dried up cheese. Not an appropriate analogy. You don't sell people moldy bread not just because people don't like it, but instead because it can kill people. This danger does not exist in posting links you've seen before. If you want to stick with the market analogy, you're walking up to the merchant to tell them they copied their menu from another merchant because both sell chicken tikka masala. &gt; The thing I've already pointed at (which you ignored): it is not just "intersects" with RubyWeekly. It intersects with 6 consecutive old issues of Ruby weekly. I have not ignored this. In fact, I addressed it head-on twice: - "If they also got their links from this subreddit, it simply means they have the same source, which does not imply that one is the source of the other." - "if two periodicals publishing contemporarily popular content have any degree of overlap, they're going to overlap for the same time period" Given these two facts and that the previous article in the series was 6 weeks prior, I'd be surprised if they _didn't_ overlap with 6 issues of a weekly newsletter that covers the same topics. &gt; What's your mind model how they've come up with this result? The same as it has been since my first response: they probably get their links from the same sources, one of which is this very subreddit. I'm happy to take suggestions on how I can make this clearer. &gt; What's your expectation about how people should react to it? Why react to it at all? If it doesn't appeal to you, why not just keep scrolling past it? As I mentioned before, some people might prefer the 6-week cycle. Some people have spouses, children, and plenty of other obligations where they don't have enough time to read every single Ruby Weekly because their entire lives don't revolve around programming. It's a safe assumption that not everyone has all the same information that you do. If this provides value to someone who is not you, then that's still pretty great. This is most likely just a side project for someone at that consultancy that enjoys it rather than something some corporate bigwig wants to do to market their company — which would make it a personal project that the company backed because it has value for them. Admittedly, that's a pretty charitable interpretation. However, you went the other direction entirely with it by choosing the least charitable interpretation possible.
THX All, I got the green light for Windows Insider preview + WSL. Works fine now. 
Yes, this makes perfect sense!
You want `JSON.parse(variable)` to convert it into a hash, using `.to_json` is usually used for turning hashes into strings representing json objects.
http://ruby-doc.org/stdlib-2.0.0/libdoc/json/rdoc/JSON.html#method-i-parse
Ugh. OK, let's continue. &gt; They didn't take any attention from you. You chose to invest your own attention into this. Yes, that's how attention economy works. Sticking to my metaphor, yes, "I decided to buy this cookie", yet it doesn't mean I can't complain if the cookie was bad. &gt; You're the one that looked at their article, then went through 6 separate issues of RubyWeekly to find the same links, and then troll them on the internet about it. Sticking to my metaphor, I was so angry with the marketers that sell bad foods, that I've wanted to do something about it. In terms of the attention economy, yes, I've spent _my_ time to earn attention to ideas that are important to _me_ (that consciously lazy or bad writing for the sake of promoting some business is a garbage polluting informational space). &gt; If you want to stick with the market analogy, you're walking up to the merchant to tell them they copied their menu from another merchant because both sell chicken tikka masala. No, you got the analogy wrong here. Digest that consists of 10 old links is bad digest in any case. It would be "copied menu" if they'd decided to tell something interesting on top of the links (like their experience with this ideas or something). Being just 10 links, posted with the pompous foreword -- it is just useless content people spend time on. So it is "bad food" (OK, being less bold, "just not a good food, very simple and not tasty"), not just "same food that in another place". &gt;&gt; What's your mind model how they've come up with this result? &gt; The same as it has been since my first response: they probably get their links from the same sources, one of which is this very subreddit. I'm happy to take suggestions on how I can make this clearer. 10 links from July? And publish them in September? How so? &gt;&gt; What's your expectation about how people should react to it? &gt; Why react to it at all? If it doesn't appeal to you, why not just keep scrolling past it? Because I really don't like marketing-induced informational spam. If it was a digest in somebody's personal blog, I'd probably use this possibility to discuss the ideas of a good digest in a friendly and pleasant manner. If you'll see closer, my first comment was in joking intonations, "don't get me wrong"-s and stuff, yes, it already was aggressive a bit, but I was ready to meaningful discussion. It was the author's response that made me click on author's profile, understand that the only thing that user does on the entire Reddit is posting lazy half-baked articles on all kind of topics to get attention to the company -- at this point, things went sideways. &gt; This is most likely just a side project for someone at that consultancy that enjoys it The problem is, all the situation definitely does _not_ look this way for me. It looks like the company is "cargo culting" the "let's do a company's tech blog" idea and the people that were asked to do the digest was loathing the task and did the simplest thing that could possibly work.
&gt; I think it would be quite easy to duplicate using `controller_name` and `instance_variable_set` ... Looking at [the source code](https://github.com/CanCanCommunity/cancancan/blob/da997d5b3337662cb0c090a30ec7d4f199d2529f/lib/cancan/controller_resource.rb#L32-L39), it's fairly straightforward. You could probably pull this out into a separate gem quite easily. (Someone probably has done, already!) It is indeed [doing a bunch of `instance_variable_set/get`](https://github.com/CanCanCommunity/cancancan/blob/da997d5b3337662cb0c090a30ec7d4f199d2529f/lib/cancan/controller_resource.rb#L164-L182) calls. And it seems the magic naming convention at its heart is: def name_from_controller @params[:controller].split('/').last.singularize end
If you have a string containing quotes inside a hash, then when that hash is converted into JSON (or parsed back using JSON.parse as the other comments mention) the quotes should be escaped and unescaped correctly. If you have to deal with the escaping yourself, then something is wrong and you've got it overcomplicated, I reckon. As someone who's done it before and thought it was a good idea at the time too, don't nest JSON inside strings in JSON. You'll only confuse yourself. If you at all can, just make it all top-level JSON.
I am not sure if there's a way to do exactly what you are doing (if you provided a summary of API/requirements, it would be more useful to me than trying to understand the code), but I'd suggest checking out the primitives and components offered by [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) to see if any of them, alone or in combination, can meet your needs. It's hard to get concurrency right, it can be helpful to build it from community-maintained components. I'm assuming what you need is not just a simple thread-safe queue, but if for some reason you haven't considered if there's a way to use a queue, you might want to! 
I did consider to use `Queue` but my storage array should also be threadsafe and `Queue` itself lacks a lot of enumerable features. Basically what I want is an array that I fill in one thread (executing command via open3 or SSH) and process in another thread. Basically I need an "IO array" that I can "#gets" until eof, if that makes any sense. And after the array has been "closed" it behaves like a normal array. My approach currently is: * I gzip large files on the remote side via SSH * My "execute command" method defines an array, starts operation (thread) which uses this array, return that result array and the thread * Wait for the thread to finish while displaying a progress (running for XXX seconds) in a second thread * Use the result array which has been filled by now (useless in the gzip operation) Now I want to add an extra step: * I already detected if the remote has "pv" utility installed and I now want to use this to gzip the file, read the stderr in realtime (pv output) and display that instead of my second-countup-progress. I guess I _could_ actually use an IO object but I use the array approach already in a lot of operations, also while it's not required at this point, an IO object would not work with multiple "consumers", my approach at the moment is maybe dirty in terms of index-tracking but I can "listen" to new entries in as many threads as I want.
I don't entirely understand why you can't use a Queue and/or a [thread pool executor](http://ruby-concurrency.github.io/concurrent-ruby/file.thread_pools.html), but you understand your requirements better than me! 
Well I actually already use (my own) thread pool but each task has to run through X steps and some of those will create new threads (like SSH channels) or status displays. I could use Queue but it would lack a few things over my implementation (which is like Queue in a lot of ways): * I can't have more than one consumer * If I consume the queue, it's empty after that * I might not consume the queue at all (in realtime) but after the process finished * Queue lacks enumerable features (right now I can call things like #each, #map, #first etc. on my instance, given that it's closed)
ugh. Since you understant what it does and where it is appropriate to use, perhaps you want to help out the community by submitting a doc PR? :)
This is so true. Consider the tricks Enumerable packs. There was nothing wrong with me using everything_is_good = true things.each do |thing| if !thing.is_good? everything_is_good = false end end if everything_is_good things_are_good() end Nothing at all wrong with that. It's easy to reason through and write down when you don't know much about the features of the language. This is a perfect example of "multiple ways to solve the problem" that people talk about. You'll start to pick up tricks and conventions over time that all make sense. They don't inhibit your ability to understand and read what's going on: everything_is_good = true things.each do |thing| everything_is_good = false unless thing.is_good? end things_are_good if everything_is_good One day someone will come to you and show you this: things_are_good if things.all? do |thing| thing.is_good? end Again, very powerful, more concise, and easy to understand once you know your Ruby a little more. Then eventually you learn about `&amp;:proc` tricks. At first you don't understand why it works, but the syntax is simple enough to understand "if I put these things like this, it just works." things_are_good if things.all?(&amp;:is_good?) And over time, that too will make more sense. You start to understand *why* it works. Sure, lots of ways to accomplish the same thing. To me, that's what makes Ruby powerful. You can work through your problem with a sledgehammer or a scalpel. I suppose there is an argument to be made: "it's harder for entry level rubyists to interpret advanced code because of shortcuts like above" but I don't find it compelling. It's easy to learn what has happened above, and advanced code is advanced code. I can't just jump into a Python project and immediately understand everything either. Most learning resources don't try to convey it all at once, but instead allow you to build a foundation. Everything in life has gradual levels of "how to accomplish something" -- from brute force to finesse. Why not your programming language too? And let's be honest -- just the same, even Python has a bazillion ways to accomplish the same things.
Interestingly before I learned Ruby/Rails, I was a novice C# programmer and .NET MVC was terribly confusing to me. Once I picked up Rails, I understood .NET MVC *sooooo* much better. It's essentially the C# port of Rails. Perhaps seeing how two different frameworks accomplish the same thing helps you more easily see the different things the frameworks are accomplishing.
I've actually tried just that but upon doing so I always get something like this: undefined method `bytesize' for {"name"=&gt;"Mens Tshirts"}:Hash (NoMethodError)
Good idea! Will do so once I'm home. ☺
I was trying to avoid all this by just sending the hash but get: undefined method `bytesize' for {"name"=&gt;"Mens Tshirts"}:Hash (NoMethodError) Everything I see online says nethttp needs to have the data encoded as a string before sending. 
Can you post a bit more of your code? We might be able to help more if we can see a bit of context...
See the below, I should have mentioned I tried doing just this!
done :) https://pastebin.com/yduDZEmZ Thanks for your help!
I think there's a bit missing where you actually call CategoryPostJson#generate and create a Request, but I'm assuming that the result of generate goes into the request_body. i.e. the request body should be a JSON string that's POSTed to the remote API. Your problem therefore (if that's right) is that you're not create a correctly-encoded JSON string to send in the request. It's dead simple to do so from a Ruby Hash, just call #to_json. So, in #generate, just create a Ruby hash, and call .to_json on it: val = {"name" =&gt; category_name}.to_json That way you (correctly) stay well away from all the string encoding yourself, and Ruby handles it for you.
apologies, I've added that above, doing that makes me end up at a similar/same result as the original post. I end up with output like: @request_body="{\"name\":\"Test category\"}" Which un-escaped is valid, it being: {"name":"Test category"} Additionally when using 'puts' to see what the value is it shows: {"name":"Test category"} If I manually make a post request with the above via ARC, it works fine as well
Does this really have to do with how Ruby is installed vs the Jekyll gem? If Bundler was used to install the gem at a non-system level, wouldn't his issue go away?
scratch the above, I've found the issue and updated the Original Post!
Use `JSON.generate` or `JSON.pretty_generate` to take a ruby object and turn it into JSON. Use `JSON.parse` to turn JSON into a ruby object.
Yeah, I have to say that this new behavior is it bit annoying.
Done! Here it is https://github.com/CanCanCommunity/cancancan/pull/441
Hah, I *almost* mentioned setting the content type but it seemed a little out of scope of the question! Well done for getting it :)
Are you thinking `Object#const_get`? &gt;&gt; class Junky ; def tie_laces ; puts "tying" ; end ; end =&gt; :tie_laces &gt;&gt; Object.const_get("Junky").new.tie_laces =&gt; tying
It was thoughtful of Sam to call out the config setting in his first comment, though, just: `bundle config disable_version_check true`
If you're the kind of person who reads that and just installs it, you probably shouldn't be a software developer.
Asking normal users to upgrade to a prerelease is a bit much. Telling users they are on an older version, reasonable.
Get downvoted to hell. They are free to ask for contributions but they are issuing a warning to update to a pre-release. If you don't know what people are upset about, don't comment. 
Won't that disable all version checks? Meaning if a new stable version comes out you won't ever know.
They could change to message to ask for volunteers. 
Not really. R does a far better job at data science. Rails is still the best option for building a web application. Python might be good for machine learning (which is only a branch of Data Science), but I still haven't tried out myself. 
I do not like this. "You are free to ignore this", but the more messages one might want to ignore, the more one starts ignoring all messages literally not noticing them including things that one really should be paying attention to. A new released bundler is at least arguably something one should pay attention to. A prerelease? It's just noise keeping me from the messages that matter. Worse, a newbie may see the warning and follow it's instructions to install prerelease bundler on a production machine. It's just a bad idea. I don't know why the bundler devs don't just roll it back, I don't get it. 
Where is that config stored, how do I get it on my production machine so I don't see the warning on capistrano deploys? And yeah, ideally I want to see the warning for actual releases. 
Mmm good point I hadn't thought about that.
His solution to people complaining that a new release is unstable is to lure newbies into using a prerelease version. Doesn't he realize that that effectively make all that users using unstable version? I think it's a big brain fart of him. "If I didn't call this version a release, nobody can complain that it's unstable!!"
$APPDIR/.bundle/config or $HOME/.bundle/config for the user running the command. More [here.](http://bundler.io/v1.3/man/bundle-config.1.html)
I can't help but wonder why you would want to do this.
Hey there! Nice article! I'd add another good practice to the context about setting permissions. I see in many projects that permissions are not given progressively and "increasing". I try to explain myself: cancancan increases permissions, it starts by giving no permissions to nobody and the user can then increase those permissions depending on the user. The best approach is to increase the permissions on the user the more "power" the user has. A properly written ability.rb looks like that: class Ability include CanCan::Ability def initialize(user) can :read, Post # start by defining rules for all users, also not logged ones return unless user.present? can :manage, Post, user_id: user.id # if the user is logged in can manage it's own posts can :create, Comment # logged in users can also create comments return unless user.manager? # if the user is a manager we give additional permissions can :manage, Comment # like managing all comments in the website return unless user.admin? can :manage, :all # finally we give all remaining permissions only to the admins end end following this good practice will help you to keep your permissions clean and more readable. the risk of giving wrong permissions to the wrong users is decreased. Another help, to make cancancan work more in a “pundit way” is to define a separate Ability file for each model, or controller, and then use def current_ability @current_ability ||= MyAbility.new(current_user) end To use a specific ability file: this way you don’t have to load the whole ability.rb file on each request.
im confused, so do you have to type all the associations in manually? or are they autoloaded?
Egh. This is an opensource project, right? OS project can be exhausting. It might not be ideal, but I'd cut the maintainers a break. I agree with the feedback that the warning message is bad. While I didn't read every line of the rather long thread there, but what I don't see is someone submitting a pull request with the suggested changes or soliciting feedback on a pull request. That would probably make it a no brainer to include the update, rather than initiate a long-winded philosophical discussion where the maintainers are all but forced to dig into their positions. 
The thing is it's not really possible to code anything before knowing what you want to achieve. The necessary code changes in this case are trivial - the hard thing is to reach a consensus on what people want. That's why a PR is missing - it's not that people don't care (in that case they would just monkey-patch bundler or turn off the setting and go on with their lives). The fact that they put in the time to discuss this makes me think that they care. I agree we owe a huge debt of gratitude to any open source maintainers putting the work, but that does not justify being dismissive or absolute in a discussion about a piece of software used by, and affecting, thousands of people. My X cents.
Because they *need* prerelease testers. People complaining about a superfluous warning message is strictly better than the increased risk of people complaining about an actual bad bug in bundler. Some of these complainers are saying this is the maintainers problem and not theirs so they shouldn't be confronted with it. This is a deplorable attitude showing a misunderstanding of how open source works. They should either contribute and help the maintainers solve this particular problem, or deal with it and leave constructive feedback on that thread. They even offer a paypal donation! as if their $5 donation is going to have any significance. If you hate using software that's being responsibly maintained by a proactive team, fork the project and use the fork.
True enough, but the entitled attitude of many complainers is really aggrevating. The original submitter of the issue is nice and neutral. Some of the complainers make a point of showing how their supposed rights have been violated and denigrating the maintainers. That's not ok.
Agreed. Although, without wanting to justify such attitude, I feel like much of this is a direct result of dismissive responses like "Done for X, not going to change, feel free to ignore it". This doesn't strike me as listening to your users' feedback with an open mind.
This gem is REALLY simple, it just finds the closest match in dictionary passed to the method, and that's it :)
The early return is a good idea, but really only works if you have a linear permission structure. I don't know how common it is, but since i have only worked with branching permission systems, where one set of permissions is not necessarily a superset of another. So, to be more flexbile in a situation like this, i'd write the above like this: class Ability include CanCan::Ability def initialize(user) can :read, Post # start by defining rules for all users, also not logged ones user_abilities if user.present? manager_abilities if user.manager? moderator_abilities if user.moderator? admin_abilities if user.admin? deleted_abilities end private def user_abilities can :manage, Post, user_id: user.id can :create, Comment end def manager_abilities can :manage, Comment # like managing all comments in the website end def moderator_abilities can :delete, [Comment, Post] end def admin_abilities can :manage, :all end def deleted_abilities cannot :manage, Deletable, deleted: true # No one can do anything with 'deleted' records end end In This case, we have 2 roles that are seperate and not really supersets of one another (manager/moderator) and we have a clause at the end (which has to be at the end) that states that no one can do anything with records that are marked as 'deleted'. Here the early return wouldn't work as well. But again, it might be that i am too focused on these edge cases and for 90% of application ot there, the early return is really the more practical, readable solution. So, if you are okay with it, I'll mention it in the article and link back to your comment. Because for a linear structure, i really liek the early returns :) 
(disclaimer: I'm a cancancan maintainer) I ❤️ pundit, but I now decided to keep maintaining cancancan up and running because last release of Pundit is from January 2016.
I think it's ok to advertise for testers. But the content of the message should be appropriate. The current message makes it seem like there's a new release of bundler, and not asking for testers. I'm sure more people would defend them had the message been something like "We are looking for testers! Please upgrade to 1.16.1.pre.1 to try out the latest pre-release version".
&gt; open source consumers that are essentially leeches Jeebus... Do you hear yourself? If you don't want "leeches" stop handing out software saying "this is free software". You don't get to climb up on a high horse because you've contributed some code here and there because you wanted to. You don't get to classify users as valid or invalid because they used software freely given instead of writing it.
I've added your feed to http://rubyland.news Oops, maybe not, that's more than just the design patterns. Can you give me a feed that is just ruby-related content, including the design patterns stuff?
Here you go: http://www.sihui.io/category/ruby/feed/ Thanks! :D
I wanted to thank you for putting in a little effort with your link post here, and adding a small write up instead of just making a link post and letting the title speak for itself. It improves the perception of quality and effort in this subreddit. Aa for the content, that's a fun idea. Thanks for writing!
Asking about it is fine, but doing it as a warning is a bit much.
haha, thanks! Good to know! Will keep following this "convention", then :)
that one doesn't actually have your design pattern posts in it though! Tag them 'ruby' if you want, I guess!
They are on the ruby category. But b/c I posted them awhile ago, the first post is actually in the last one on the list. lol Do you want me to bump them up?
aha! All good as far as I'm concerned. rubyland actually won't let you bump them up in it's listing unless I delete your feed from its list and start over, to avoid people bumping posts up to always keep them at the top. :)
Let's keep it as it is then :) Thanks!
 grid = %w(08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48). map(&amp;:to_i).each_slice(20).to_a diag = -&gt;a { (0..19).map {|r| [1]*r + a[r] + [1]*(19-r)}.transpose } gstm = -&gt;a { (a + a.transpose + diag[a] + diag[a.reverse]). flat_map {|e| e.each_cons(4).map {|_|_.reduce(:*)}}.max } gstm[grid] #=&gt; 70600674
Monad and Burrito.
Yes this... I have done projects in both, I love ruby.. python not so much... others are just the opposite. Learning both will not delay your learning curve, but make it steeper... AND you will know which one is right for you... instead of always doubting if you chose correctly. 
Gotta say... I have used ruby almost 20 years... I don't care if it is prom queen anymore... I am here for the syntax. The backend is fine for almost everything I have done in that 20 years... While my code is better now, I can still understand that 20 year old code where I was reinventing every wheel known to man... Oddly enough, I chose ruby because I hated the whitespace thing with python... These days, I think a ruby dialect with whitespace instead of {} and end would be pretty nice.
Preloader is ":nodoc:" - for internal use, should not be used outside ActiveRecord. Try `Product.includes(:prices).where(prices: {currency_code: 'USD'})` or `Price.where(currency_code: 'USD').preload(:product).group_by(&amp;:product)` instead.
With that you unfortunately cannot choose to eager load in a separate query, you can only do that when associations are preloaded with `LEFT JOIN`. Sequel has this elegantly solved: ``` Product.eager(prices: -&gt;(ds){ds.where(currency_code: "USD")}) ```
I found this one on Github. Not sure which state it is in though. https://github.com/mtsmfm/language_server-ruby
So why don't you want to use Heroku?
Just want to know other options, that's all :)
`joins` combined with `preload` results in two queries though; is that what's needed here? &gt;&gt; Product.joins(:prices).preload(:prices).where(prices: {currency_code: 'USD'}) Product Load (0.5ms) SELECT "products".* FROM "products" INNER JOIN "prices" ON "prices"."product_id" = "products"."id" WHERE "prices"."currency_code" = $1 LIMIT $2 [["currency_code", "USD"], ["LIMIT", 11]] Price Load (0.5ms) SELECT "prices".* FROM "prices" WHERE "prices"."product_id" IN (1, 2) =&gt; #&lt;ActiveRecord::Relation [#&lt;Product id: 1, name: "widgit", created_at: "2017-09-12 22:36:52", updated_at: "2017-09-12 22:36:52"&gt;, #&lt;Product id: 2, name: "toy", created_at: "2017-09-12 22:36:58", updated_at: "2017-09-12 22:36:58"&gt;]&gt; 
Cloud66 and EngineYard are the two that immediately come to mind.
Diet_order_tmp.rb has a typo It has the vessel listed as "bowel" and not "bowl" XD Fantastic write up! It's super clear and concise. Great job! I really enjoyed your elegant "Ruby" style. It reminded me of Why's guide
Thanks a lot for your feedback and encouragements! Will change that later tonight lol. Glad that you enjoyed it!
Elastic Beanstalk.
App Engine also supports ruby now.
As an employee of Heroku you should definitely use Heroku ;) 
I have never seen a reason to use bundler or any of these tools so never had that problem.
If it's a rails app, I highly recommend Hatch from GoRails. It's cheaper, works with Digital Ocean or Linode, and you get full control of your server. It has what you need to launch a typical rails app including Sidekiq, Postgres, Elastic Search, SSL, etc.
&lt;trollmode&gt; You should learn algorithms and technologies. &lt;/trollmode&gt;
That's actually not the same as described in post. If you look at the queries you have problem with loading data that won't be used. The second query will fetch also prices in other currencies and not only USD. I know the preloader api is internal but used with caution it can be very useful.
what is a use case for such a gem? how do you use it?
I usually resort to two simple CMS's for similar cases: - middleman + contentful (or prismic) + netflify - or Comfortable Mexican Sofa 
I've wrote the initial code for [yard-junk](https://github.com/zverok/yard-junk) -- YARD docs checker. When YARD gives you `Unknown tag @params` (it is easy to mix param/params, raise/raises, return/returns), yard-junk says `Unknown tag @params. Did you mean @param?` Then I noted that my other gem can also use the trick: [infoboxer](https://github.com/molybdenum-99/infoboxer) Wiki-client in `develop` branch introduces "wiki-path" (like XPath, but for Wiki AST), so, when you type `page.wikipath('//sections[title=See Also]//wikilnks')` (instead of `wikilinks` for the last selector), it would be nice to suggest right name, right?.. So, I've extracted the thing from yard-junk to small gem.
You're right, and reading more, I agree, I don't see a way to do this outside of the way you described.
You might want to avoid posting spoilers to ProjectEuler – instead you could rewrite the problem statement.
There is a Euler solution subreddit and plenty of solutions all over github. When I am working on one of the problems I don't look for solutions until I am finished. Its pretty obvious I didn't copy mine from anyone. But, thank you for the suggestion. I can understand what you are saying.
That's pretty neat - would be super helpful to have sth similar exposed as public api in AR!
As far as I can tell, the only real use for this is as a wrapper to provide a *consistent* interface to `do_you_mean` across multiple ruby/gem versions. If you're working on any regular project (not a general library), then wouldn't it be better to just use the `do_you_mean` gem directly? Assuming you are using the latest ruby and gem versions, then [the following](https://github.com/zverok/did_you/blob/1bbb7f53a635c334ed1ef85e406423869c82fc16/lib/did_you.rb#L58) are [equivalent](https://github.com/yuki24/did_you_mean/blob/5ab2e3259d56a6104e5a0a9c6f5f4ed499f49413/lib/did_you_mean/spell_checker.rb#L8-L36): # Using the gem directly: DidYouMean::SpellChecker .new(dictionary: %w[param return tag abstract]) .correct('params') # Using your wrapper: DidYou::Spell .check('params', %w[param return tag abstract]) Plus, if the interface to `do_you_mean` changes, then the wrapper gem will get out of date - so you're just shifting the source of the problem. ---- I think this is a great little project, but it should be made clear in the README what the real use case is; most people should use the gem directly, not this wrapper.
&gt; As far as I can tell, the only real use for this is as a wrapper to provide a consistent interface to do_you_mean across multiple ruby/gem versions. Yes, that was the only intent indeed. I hoped that README states this clearly, but I'll try to rephrase it.
Uuunh, no. Ruby is the one that has a community that insists on metaprogramming in a language without a proper spec. Take a look at the official Python docs, and take a look at the syntax. The Python one is far more consistent. Ruby has _shortcuts_ up the wazoo.
Out of the loop. What is Ruby Together and why did Basecamp cancel its membership?
Their money is theirs to do with what they like, but announcing this and explaining it in a series of disjointed 140 char tweets is a pretty anti-community-minded way to do it IMO. And unproductive if he means it to spur changes in whatever he was unhappy about. Immature move, dhh. I still have little idea what he's talking about or why he decided to stop contributing. **update** reading more and researching, I have _some_ idea what he's talking about. But it's just ridiculous. @indirect making a mistake about a project he thought had copied code but hadn't, and then appropriately admitting an error and apologizing for it and even offering to do additional work to make gemstash work better for the downstream user; and then the person wrongly accused [saying](https://github.com/GoogleCloudPlatform/google-cloud-gemserver/issues/36#issuecomment-324504403) &gt; Thanks Andre. It's OK. These things happen. If you run into any licensing issues in the future, please don't hesitate to contact us -- that's a reason to cut off funding to a project that @indirect is involved in? Really? How immature. Makes me think the things dhh listed are just post-facto justifications for some other reason he really had to stop funding... or else I question his decision-making. If someone making a mistake and then recognizing and apologizing for it is a reason to do the equivalent of "firing" them, I'm glad I don't work at basecamp. But still his money to do with what he wants, but aside from the decision to fund or not, this is a very anti-community and unproductive way to announce it. 
Waiting for the announcement of rails 6 core feature: active-bundler
These two issues I would imagine: https://github.com/GoogleCloudPlatform/google-cloud-gemserver/issues/36 https://github.com/bundler/bundler/issues/6004
this podcast explains a bit why DHH chooses Twitter as a medium for such announcements "Basecamp CTO David Heinemeier Hansson is known for many things, including creating Ruby on Rails and writing business books. He also has a knack for arguing with people on the Internet. This cheerfully profane conversation explores how Twitter is like a virtual pillow to scream into and the role that extreme voices play in moving important conversations forward. We also relive some of David's memorable Twitter melees, including the one that got him blocked by Paul Graham." https://art19.com/shows/rework/episodes/77508be1-639d-4d21-a838-6dc8bc2cb35e
https://rubytogether.org/ TL;DR Its a non-profit to help finance the hosting costs of open source projects like Bundler and RubyGems. If you look at the replies to DHH's tweets people make some guesses as to exactly why they are cancelling.
I think this is an over-reaction. It seems like the head of Ruby Together made a mistake and thought that Google was using Ruby Together's source code for Gemstash. After being shown that Google did not steal the source code, he apologized (and it appears pretty sincere https://github.com/GoogleCloudPlatform/google-cloud-gemserver/issues/36#issuecomment-324503159). His initial message to Google was a little rude (https://github.com/GoogleCloudPlatform/google-cloud-gemserver/issues/36#issue-252398311) but I can only imagine what it feels like to work your ass off on an open source project for years and then come across a Google repo that appears to take the code without giving any credit. The other issue is the issue with Bundler suggesting to upgrade to a pre-release version https://github.com/bundler/bundler/issues/6004. I agree that its probably not a good idea to recommend a version that's not officially released but it doesn't seem like that big of a deal. I wouldn't be surprised it was an oversight when they initially built the feature.
ISTM the alternatives were to quietly withdraw without saying anything, which would lead to the same accusations of freeloading that have been levelled at other notable ruby companies who support the community in ways that don't involve giving RT money, or publishing an extensive breakdown of the issues observed, which would likely be seen as petty and as attempting to influence others.
Not totally surprising given the way the latest RubyGems vulnerability was handled with little transparency into [the actual issues/fixes.](https://www.reddit.com/r/ruby/comments/6wthj4/multiple_vulnerabilities_in_rubygems/dmavlmo/)
Twitter is so NOT like a "virtual pillow to scream into." Screaming into a pillow is something you do privately. That's the whole reason you are screaming into a pillow instead of just screaming, to muffle it. 
I think the issues he mentioned _are_ petty. If those are the real issues that led to his decision, then I guess functional communication was indeed successfully achieved and no need to improve on communication style or forum! (And I don't like the same things he didn't like, I just think everyone makes mistakes and does things I don't like sometimes, and those particular things I disagree with are some petty things!) And withdrawing funding seems like it's _gotta_ be an attempt to influence others, no? My guess is the real thing is that @dhh just doesn't like @indirect personally. 
Now, I think _that_ would have been a non-petty issue at least! That is IMO a very serious issue -- in particular IMO that they didn't file an official CVE and/or have a rubysec.com posting ready to go, just announced it on the rubygems blog, the end. That's some serious mismanagement of vulnerability handling in such a widely used tool. That isn't even one of the ones he mentioned! And personally, I think the way to deal with that would be to work with the rubytogether team to improve their practices with vulnerability handling, not to just cut off funding because of a mistake. If working with them you found they were unwilling to acknowledge that was not an acceptable way to handle a vulnerability or work toward improving in the future, that'd be another story. Withdrawing funding, while it's dhh's right it's their money -- is not going to actually lead to improvement in rubygems maintainer vulnerabilty handling I can guarantee vulnerabilty handling would be no better _without_ rubytogether funding! that the community would hope rubytogether funding would lead to improvements in _exactly this sort of thing_, vulnerability handling, is what makes it especially alarming. Some past vulnerabilities and their handling are even a primary motivator of rubytogether in the first place, if memory serves. If funding isn't sufficient, I think it's probably still necessary to have professional handling of vulnerabilities. But that's not even one of the issues dhh mentioned. 
Lets not forget [the post_install ads](https://github.com/bundler/bundler/issues/5311) that imply RubyTogether pays for RubyGems hosting (they don't, RubyCentral does) along with [doubling down](https://github.com/bundler/bundler/issues/5311#issuecomment-271477520) and even [tripling down](https://github.com/bundler/bundler/issues/5311#issuecomment-275875233) on "RubyTogether pays for servers". The only clarification for this is buried [in a monthly update](https://rubytogether.org/news/2017-03-08-january-and-february-2017-monthly-update). Just too many bad takes. I can understand why he did this.
Lol nailed it. I used my virtual pillow to tell DHH what I think about this
I think it's more likely that twitter doesn't give a ton of room to express all the possible issues and that DHH can sense the lack of maturity/direction the organization is heading towards.
As you seem to suggest, it might be more appropriate to temporarily continue funding RT, and instead privately communicate a more comprehensive list of specific concerns to them, and only consider withdrawing funding if one were still unsatisfied some time later. But then, if such communication had occurred, it would have been in private...
One can of course say "We tried to work with rubytogether to make it less likely for such mistakes to happen in the future, but we did not find them receptive." Who knows if that happened, but I doubt it. The actual issues dhh lists still seem awfully petty to me. I'm actually more concerned about the way the recent security vulnerabilities in rubygems were handled, as /r/knowledgebethekey mentioned, but that is a problem that _desperately_ needs some cooperation to improve, not just cutting off funding (which won't improve it and has a good chance of doing the reverse). 
Then twitter is a poor choice of medium for such a community-affecting announcement. 
gah. 
From one of /u/tenderlove's links, and dated six months ago: &gt; the Ruby Together board was approached in private by a group of concerned developers (though the list of specific grievances provided there is [understandably] less comprehensive than it could have been) So, doubt if you must, but I say it happened, and so does Ruby Together.
I'm gonna say what schneems didn't seem to want to come out and say: I think the way rubygems maintainers (funded by rubytogether) handled this vulnerability was unacceptable. * The vulnerabilities needed CVEs. And [rubysec.com postings](https://rubysec.com/advisories) ready to go (which maybe would have happened automatically if they had CVEs). * CVE's are how people determine the impact of vulnerabilities, as schneems mentions * CVEs and infrastructure built upon them (including rubysec.com/ruby-advisory-db, which then has more infrastructure built upon it like [bundler-audit](https://github.com/rubysec/bundler-audit)) is how people track vulnerabilities in their deployed software in an _automated_ fashion, which is crucial in this day and age. * (Incidentally, the rubygems vulns are _still_ [not listed in rubysec.com feed](https://github.com/rubysec/ruby-advisory-db/pull/298) ). * The vulnerabilities needed security-patch-only releases for supported versions of rubygems, as schneems says. What happened instead does not meet what we need for vulnerability handling for such widely-used and core infrastructure ruby software. I would suspect that lack of developer-hours and burn out is part of what led to the insufficient handling. If memory serves, a similar vulnerability in core infrastructure was actually one of the main motivators of the [rubytogether funding stream](http://bundler.io/blog/2015/03/19/announcing-ruby-together.html) originally, but I can't find docs on that and don't remember any details. At any rate, insufficient developer-hours and developer burn-out on core ruby infrastructure was _definitely_ a significant motivation for rubytogether. This incident suggests rubytogether is not yet working to give us the professional handling of core infrastructure we need, whether that's because the developers involved are still over-worked and getting burnt out, or other reasons. We can't really know the reasons without more transparency and analysis. [Withdrawing funding from rubytogether](https://www.reddit.com/r/ruby/comments/6zvvg4/after_20000_in_ruby_together_donations_over_past/) obviously has **zero chance** whatsoever of improving vulnerability handling for core ruby infrastructure in the future, if this particular issue even was part of dhh's motivation, who knows. Either it'll just make it worse, or at best have no effect. But it's not even clear to me that rubytogether staff or other stakeholders acknowledges the vulnerability handling here was not up to par. These were (apparently?) low-impact vulnerabilities. They still needed to be handled right. But the consequences were hopefully not too dire of not doing it appropriately. The next vulnerabilities may be worse. (And there are ALWAYS next vulnerabilities -- please note that nowhere here do I 'complain' about the vulnerabilities' existence, there will ALWAYS be vulnerabilities). What can we as a community do to encourage them to recognize that this incident handling was not up to professional expectations, and help them improve in the future? 
**NO**. rubytogether is **NOT** about hosting costs at all. They have ***NOTHING*** to do with hosting any ruby services whatsoever. That is entirely done by rubycentral. Always has been, always will be. This misattribution to RT is exactly the type of thing that RT has encouraged over the years in order to get more money out of people and companies.
Can we give the benefit of the doubt to a team that has been quietly supporting the Ruby community for **years**? Email privately, ask @indirect for a quick video chat, anything to work things out. People make mistakes. (Note: I'm a member of RubyTogether)
My thoughts exactly. Followed by: "But do we know that DHH did not contact the RT team, or talked to @indirect?". What if he mailed, asked for clarification and got some (or none) which get DHH pissed and write a tweet like that? I'm just speculating here, but we *don't* know what happened behind the curtains. Nor do we know what made DHH not only drop support but be loud about that. It hints at him being pissed. I'd love to get some follow up to learn what was going on here, what pissed him off (if anything).
Right. RubyCentral pays all hosting costs. They make money through ticket sales to RubyCentral conferences (like RubyConf and RailsConf). If you want to help support hosting, buy a ticket or sponsor a conf. It's really a win-win, and I wish they would promote that fact more.
Private comms have already happened. See earlier comments in this thread.
what is rubytogether, the page seems not very obvious to me
There is no way I'd fund a book written by the same person who [wrote this.](https://mindaslab.github.io/2015/05/19/who-am-i.html)
I saw you and zenspider having issues with "hosting costs" but indirect speaks only of maintaining the Bundler/RG software AFAICT. He's not claiming to pay for rubygems.org anywhere that I've seen. I guess I'm out of the loop.
I think maybe we do know dhh is pretty easy to piss off. 
Did you read the comments I linked to? Unless you know the exact financing situation, they sure read as "Ruby Together pays for hosting".
Ah, I didn't realize "$40k/mo for servers" was Ruby Central's bill. I had read that as his way of saying "big companies that spend a lot on _their own_ expensive hosting". I think if we start nitpicking word choice and phrasing over the Internet, the discussion is kaput. A video chat would be a much more effective medium at this point; people need to regain trust in each other -- typing at each other won't do that.
A consultancy that works on open source that overstates their necessity in order to get more contributions.
https://pbs.twimg.com/profile_images/518132954120204288/yVvIdVOH_400x400.jpeg who wears "misandry" on a t-shirt? super cringe. ruby ecosystem trends. very unwelcoming.
ya seriously haha. It's more like a virtual window to scream out of with everyone in the world standing right outside.
Maybe it's just me, but having made a mess of a bunch of codebases using OO methods, I'm starting to feel like functional programming techniques might hold more promise. Purity, immutability, referential transparency, etc. If I had 5 minutes to chat with Sandi that'd be my first question - what do you make of functional programming?
angry children, that's who.
so i'm pretty much an outsider but rubytogether seems pretty obviously make it confusing "Community funded developer infrastructure Ruby Together is a grassroots initiative committed to supporting the critical Ruby infrastructure you rely on: Bundler, RubyGems, and other shared tools. " if they do not pay for rubygems bills then that sounds really deceptive.. TBH
*checks post history* https://www.reddit.com/r/dadjokes/comments/6wtm5s/apparently_scientists_are_working_on_self_driving/ *tenderlove confirmed*
Will that be MIT or Apache?
Seems like a weak reason to stop donating to something that keeps ruby ecosystem working. It takes time and effort to maintain open source software. And not all devs race Ferrari in their spare time.
**budget &amp; expenses** In the months of January and February combined, we saw $45,031 in total income, and spent a total of $44,893.72. * $9,994 for 66.6 hours worked on Bundler at $150/hour * $10,134 for 67.6 hours worked on RubyGems.org at $150/hour * $2,505 for 16.7 hours worked on RubyGems at $150/hour * $2,543 for 17.0 hours worked on other OSS and devtools at $150/hour * $142.09 on dedicated servers for RubyBench.org * $1465.08 on payment processing fees * $5337.41 on company overhead like hosting, services, software, hardware, taxes, etc * $8025.0 on accounting, copywriting, design, and other professional services * $4749.14 on marketing, evangelism, and community outreach --- Those numbers look pretty made up to me, hours worked is all 6's and 7's, the dollars charged seem to have similar patterns working in pairs. Would be interesting to see a more detailed breakdown and how the cost was split.
I spent about 3 hours on rubygems.org PR that got merged. Where do I send bill for $450? Somebody please hire me. 
Not that there have ever been any of *those* in this industry. smh
In case you missed, bundler will be added to ruby core https://bugs.ruby-lang.org/issues/12733
Seems like a good idea, but I'm not sure it's a panacea. Good test coverage sounds better to me.
I wonder what Sandi thinks, too. Reading her books, I found myself agreeing with all the techniques she demonstrates, but disagreeing with the reasoning behind the techniques. I'm paraphrasing here, but it was something along the lines of: the techniques make the code better because they make the code more OO.
Ah yes, two Ruby heavyweights duking it out.
Milpitas
Millpitas Apt 2 bedroom 1 bath
Updated the README, thank you for pointing to the problem! &gt; Plus, if the interface to do_you_mean changes, then the wrapper gem will get out of date - so you're just shifting the source of the problem. Well, I am (currently) active in open source, so if the `did_you_mean` interface changes I hope to be able to update the library ¯\\\_(ツ)_/¯
Programming industry is so entertaining! 
I took a 3 day course with Sandi and she touched on some of this: - objects should be small, immutable, and always being instantiated and then discarded - do not use inheritance if it can be avoided - separate business logic and persistence. (Don't inherit from ActiveRecord). IMO rails encourages devs to write big, mutable and ultimately unmaintainable god objects. There are ways around that, but it's much easier with a new app than an existing one. 
&gt; super cringe. What's super-cringe the air of superiority people seem to have about the clothing of others. 
It's probably worth reporting to the Code of Conduct team. It's open discrimination towards a part of the Ruby community and pretty distasteful.
Have you checked out https://weworkremotely.com/ ? Also https://remoteok.io/remote-ruby-jobs I'm a big fan of remote work, and not staying in a job you hate.
the unfortunately part is after seeing that they claim to fund stuff they don't makes me less interested in donating because now I feel like if they lie like that publicly what are the chances donation would be misappropriated. :( I'm not saying that's what happens either, but trust is a tough thing to gain back after losing it and I can see it driving people off if donations really are needed
No need to fund in that case.
Why did u waste it till now?
Why haven't u quoted the second part of the comment :)
Haha runaway :))
U trust when you pay taxes. U never know exactly where it goes unless and until for select few countries.
I can post the bills online, why not. Thats how projects are run. Possibly I can hire a part time accountant to do this job.
Okay lets say Churchill then. His texts are difficult a bit.
If I wasn't using Rails, my default would be Sequel instead of ActiveRecord, unless I had a good reason to need ActiveRecord (shared code with apps using AR I guess). 
Yay!
Posting expenses is a great way for people to hold you accountable *after* they've given you money. But why would anyone give you money for a project if they have no idea how you plan to use it? 
I trust when I pay taxes because I'm giving money to an organization that's proved itself trustworthy. The only thing you've proved to me is that "u" aren't qualified to write a book. So why would I trust you? 
You're the one who ran away from this thread, not me. 
Are you saying that your project is a waste of time? 
No need to fund in *any* case, because you don't need funding. You need solid technical writing skills.
Still more readable than your book. 
It's not exactly *free* if you're asking us for money...
Lets say *neither*. Comparing Churchill to Shakespeare to Hemingway is completely irrelevant. These people were writing *prose*, not technical manuals.
As someone with a background in technical writing, this guy makes my blood boil...
There's not a lot of point in engaging with him any further. He's pretty obviously not interested in feedback, and I don't think he's really even capable of accepting it at this point. He's obviously written this to the best of his English and Ruby abilities and refuses to admit how lacking he is in both. I can only hope he'll look back at this book in a few years time and *cringe*.
OOP looks a lot like FP when it's taken to its logical conclusion, IME. When data (state) is encapsulated, objects present an interface that exposes _behavior_, just like functions. There are, of course, many differences, but I've seen a lot of folks develop a notion of OOP that is more class oriented than object oriented.
This isn't entirely accurate... &gt; the terms “boolean,” “string,” “symbol” and “float” are data types. Booleans have only two values, that is, “true” and “false.” Ruby does not have a "boolean type". It has `TrueClass` and `FalseClass`, which implement the singleton objects `true` and `false`; but *all* objects other than `false` and `nil` are considered "truthy" in ruby. &gt; Symbols are primitive data-types generally used for call-backs. Symbols are used for a lot more than just call-backs... &gt; The float data type is used when large (and complex) numbers (usually upto 7 digits) and decimals are to be dealt with. What??! If you want to put it simply, then `Float`s are **decimal** numbers. These values are `Float`s: 0.1 827637843248.213432 -0.00000001 (This answer is still not 100% accurate, but gets the right general message across. Ruby's standard library also has the concept of `Rational`, `BigDecimal` and `Complex` numbers.) These numbers are all `Integer`s (and pre-ruby 2.4, would be classified as either `Fixnum` or `Bignum`, with the cut-off dependant on your specific computer): 123 123456789 999999999999999999 10 ** 100 --- I get that this was only supposed to be a simplistic, introductory post; but you've given some misleading answers here.
Super sleeze ball of them. I wouldn't put up with this from any other non-profit, I don't get why people are defending this nonsense. The whole thing smells like a slush fund. Open source supports itself. Implying we need this set of individuals to keep ruby alive is somewhat coercive and antithetical to to the OSS spirit. It's also kind of a self fueled argument: 'see how much money we had to pay ourselves?! Donate more money so that we can continue to pay ourselves!'... reading those github threads is bizarre too. Strange people these ones. 
Yeah I agree with you. Sequal is great. It's certainly the case if you have existing code you'll probably stick with what you've got rather than rewriting everything though, as you point out.
you must live under the chicago airport beccause that one went right over your head!! :D at 150/hr thats a pretty high rate.. don't you think?
Don't u have brains. I was telling about how emingway was able to explain things with simple words.
have you ever heard of "Free as in freedom and not free beer?"
Thanks for admitting my book is readable.
How does your book embody *freedom*, specifically?
Then don't fund. You are not the only one in planet.
I didn't say anything of the sort, because frankly, it's not.
Nope possibly reacting to some idiots are.
&gt; You are not the only one in planet. The more you write, the more you demonstrate that you're not qualified to write an English-language ebook.
Sorry, was that supposed to be a meaningful sentence?
For an independent contractor paying their own taxes and insurance (not to mention retirement, and occasional unpaid vacation or sick days), in the U.S.? Someone with lots of experience who knows what they're doing? No, not particularly. 
Please stop, I can't stand the irony.
**You** are the only idiot here. You are the one who seems phobic of any kind of *remotely* intelligent form of writing or thinking. In this entire thread you're the only one who consistently acts *stupid*, and then seems to revel in it. Your entire argument seems to be a defense of stupidity.
You're talking a lot of bollocks there, IDK what the US rate is, but the going rate in London is 350-500 GBP / day for a contractor (and 500 is rarely seen), 150 * 8 = 1,200 USD, which is 900 GBP, are you saying that US rates differ that much?
in my experience, apparently. It probably doesn't help that independent contractors in the U.S. need to pay their own health insurance, which ain't cheap (if you are paying for a spouse/children, can easily be $1000+/month). Income taxes (including self-employment taxes) will prob be about 35-40% of your revenue, although it depends on your total deductible expenses, can vary significantly as a % of revenue before deductible expenses. your 350 GBP / 8 == ~USD$60/hour. I can confidently say that no skilled ruby/Rails dev with 5+ years experience, working as an independent contractor (meaning they pay all their own benefits, and when they take vacation or sick days -- or spend time looking for work, 'development' -- don't get paid) would charge as little as $60/hour. It's hard to find market numbers on this, but here are some listings from upwork, kind of all over the map, but average definitely above your $60/hour estimate. https://www.upwork.com/hire/ruby-on-rails-developers/ I definitely know of full-stack consultancies that charge their clients $150-$200/hour. Of course their employees don't take home that much, that pays employer's share of taxes, health insurance, office rental, the accountant, etc., all the overhead. If you're a business of just you working out of your home, you don't have office rental, but you've still got taxes, your own health insurance to pay for, some other overhead, plus you are never going to be billing 40 hours a week for 52 weeks a year, it's not possible. Even a solid 32 billable hours a week for 48 weeks a year would be pretty crushing. $150/hour is on the high end, but not crazily high for someone that really knows what they are doing and efficiently produces high-quality work. But yes, this is an odd situation, not a normal independent contractor/consultant situation -- it's unclear who would be evaluating if the contractors were efficiently producing high-quality work, what 'client' would decide if they were happy with the work or the price, and what they would do about it if not. Except, well, what @dhh just did. 
I'm actually kind of surprised by the anti-rubytogether sentiment. All-volunteer maintenance/development of rubygems/bundler was NOT working, and they are too important to us all for that. So anyone that says "let's just do that and hope someone dedicates themselves to it for free, it's open source", I kind of discount. The more typical way these kind of open source platform/infrastructural things happen in general across platforms, is some one company just does it -- has employees doing it on company time. If there's a company that wants to do that, that can work fine -- but as mentioned in the rubytogether announcement, that does give one company an awful lot of control, and we all have seen how sometimes that can backfire. I thought rubytogether is/was a pretty interesting idea for cooperative funding. I too haven't been too happy with some of the decisions made -- but I was none too happy with some of the decisions made (and bugs/mistakes made) in rubygems/bundler before rubytogether was funding it too. And heck, I'm none too happy with a LOT of the decisions dhh makes about Rails, heh. I guess I'm kind of a grumpy engineer. But there seems to be an awful lot of underlying animosity towards rubytogether and/or @indirect. I don't think it can just be from the fairly petty things dhh lists specifically. The things listed are mistakes, but aren't that big of a deal. I'm guessing there must be other stuff going on under the surface, that the 'public' isn't privy to. I don't know if it's that people just don't get along with @indirect and find him hard to work with (if this is true, I don't know if it is), or what. Looking at the list of [who is on the board](https://rubytogether.org/team), I don't like that André Arko (@indirect) is on the board and also on the development team (getting paid, probably for more hours than anyone else). That seems like a conflict of interest to me. I also notice listed "Coraline Ada Ehmke from GitHub", when I know Ehmke is no longer at github, which makes me wonder if she's still active on the board, which makes me wonder if the board listing in general is accurate and represents people actually active. Some additional transparency (say, even rudimentary board meeting minutes including attendance; also more budget details) would probably go a long way. At the moment, I feel like a lot of what is going on, as well as reasons people for have for being dissatisfied with it, is sort of an "insider game" most of us have no way to see. The project definitely needs an active board independent of the developers getting paid to develop, monitoring the budget and expenditures and guiding priorities -- I don't really know if it has one. My _guess_, with no actual info cause there isn't much public, just based on my experience with social dynamics in this kind of thing, is that people are finding @indirect hard to work with, and my guess is that @indirect is over-worked and burned out (something that tends to make engineers hard to work with, ironically especially when the overworked/burned out engineer really does care about the work). If so, how to deal with that is another thing, and there are unlikely to be any easy ways. 
Note that doesn't mean that anyone is taking over maintenance of it. It still needs maintainers, nobody from core ruby team is offering that or anything. If you read the thread on that ticket, that's clear, and mentioned as an issue to consider. 
Are u trying to make the ri tool work? On my Fedora 26: $ which ri /usr/bin/ri $ rpm -qf /usr/bin/ri rubygem-rdoc-5.1.0-1.fc26.noarch So install rubygem-rdoc package if you don't have it. Also if you don't know about it, we started developer documentation here: https://developer.fedoraproject.org/tech/languages/ruby/ruby-installation.html 
Do you really think that DHH/Basecamp does not know how hard is to maintain an open source project? They gave a lot of stuff to Ruby community over the years.
stdlib is where packages go to die
Yes, sir. Looks like I can't communicate for fuck today! Sorry and thank-you. Prior to writing I had installed rdoc (and the actual data files) via dnf I believe. I don't think it actually indexed the content, though; I'm assuming it actually works like man-db. It's early here, and I'm not by my PC. I'll investigate and update this message. Thank-you again for your reply! I'm going to your link now. My initial install was probably bad (dnf install ruby).
that's interesting, I wasn't aware that the AR management middleware had been removed. What's the replacement, and how does it improve on the middleware mechanism?
I believe the docs are auto-generated. If you want to dig deeper go find the actual source between 2.2.0 and 2.4.1 and compare. It looks like the file holding the class changed from `.ext/thread/thread.c` to `thread_sync.c` so it may be that it was reimplemented and lost some of the needed comments to generate the documentation. &gt; stdlib-doc is a RubyForge project that converts Ruby source code into this documentation you are looking at. So yes, it's auto-generated from the source code.
It's absolutely not bollocks. I do some consulting on the side (I have a full-time day job) and my base rate is $150/hour. My rate exists on a slider that depends on a few factors. Am I looking for work? Do I want this work? Is the job easier, harder? Familiar tech stack? Familiar/repeat client? New client? etc... Each of these and a few more move the rate up and down. The most I've charged was $225/hour for a 20 hour project that I did not want but was willing to take (some bug fixing and extending a legacy VB6 app, this was in 2015, that modeled some fluid dynamics problems).
I think this really underscores an unfortunate reality in software: we learn what we think _looks good_ before we learn what _is good_. Teaching software design thus becomes more of an exercise in tuning people's sense of aesthetics rather than instilling a sense of what kind of problems should be easy to solve thanks to the design. My wager as to why that is the case: almost no one gets to work in an environment that has achieved the actual qualities that design principles are supposed to beget. Common implementations are so poor than the benefits of quality software appear mostly theoretical. So we're left to guess what a spaceship might look like, so to speak, because we're still dreaming of reaching the stars. And then we end up in endless debates about whether the Enterprise looks "cleaner" than the Millenium Falcon. Eventually, many give up on the idea that software can be anything but a huge mess and shift focus towards looking for palliative care. I digress... :-)
Well see, the thing with Ruby is
WHAT IS THE THING WITH RUBY I MUST KNOW!?!?! :D 
not just you. ruby core/stdlib is historically not documented very well, but I think continues to improve over time -- although that doesn't explain your finding that the docs seem to have gotten worse for Queue between 2.2.0 and 2.4.1, that's distressing, and I'm not sure what happened to the auto-gen'd method docs either! Hmm, in that case, it looks like maybe Queue was reimplemented in C instead of ruby for performance, which eliminated the auto-gen'd method-level docs. Or actually it was C before too, but changing the structure of the C maybe accidentally eliminated extra things that had been done to make sure the method-level docs were present? It is unfortunate. This one might be worth filing a bug on the ruby bug tracker for. 
&gt;$ which ri &gt; /usr/bin/ri &gt; $ rpm -qf /usr/bin/ri &gt; rubygem-rdoc-5.1.0-1.fc26.noarch (My) which returns the 'local' path: /user/local/bin/ri but they're the same. However, rpm -qf `which ri` Says that ri is not owned by any package. Putting the alternate path in, as per you, gives the 'correct' answer (ok, it's 5.1.0-2 but ..). I'm not sure where to go back from here.
https://github.com/rails/rails/issues/26947#issuecomment-257482316
in 37 lines of ruby*
I'm waiting for `DidYou::Smell`
Cool, what do you plan to use this for?
Daw it's so cute.
Wait, so a blockchain is just a linked list?
&gt; One common use case I have is: execute an external process. Do not let it output to stderr/stdout, but do capture the stderr/stdout in string(s). If the command fails, raise with the captured stdout/stderr included (that I intentionally didn’t output to logs, but I wanna see it on error). Do it all with proper protection from command injection attack, of course. Note that you can already do all this (except automatic exception raising) with the lesser-known `Open3.capture3`. require 'open3' stdout, stderr, status = Open3.capture3('vips', 'dzsave', input_file_path_string) unless status.success? warn "Our vips thing failed!!! with this output:\n #{stdout} #{stderr}" end I'm not saying that `Open3` has everything that `TTY::Command` has, it certainly doesn't, just that it can cover that particular scenario. One feature that I'm wondering whether `TTY::Command` has is streaming input and streaming output. For example, I had a use case where I want to allow users to stream large remote files through their app. For that I wanted to use `wget`, because it automatically retries the download on timeout errors, and is smart enough to resume downloads via `Range` requests. I didn't want to first download the whole remote file onto disk, and then start streaming the downloaded file into the response, because then the user would have to wait for the whole file to get downloaded by the server before it can start downloading it from the server (which isn't ideal if these are videos that you want to play), also it would use unnecessary disk space, even if it will get deleted at the end. I wanted to stream the remote file to the response as it is being downloaded. So I told `wget` to redirect to stdout. But I couldn't capture a simple string stdout here, because it would mean that the whole file would be loaded into memory. I knew that `Open3.popen3` uses Ruby pipes for stdin/stdout/stderr, which are readable/writable IO objects, so after a lot of fiddling [I managed to utilize it](https://github.com/janko-m/down/blob/ff214aa8a810f830a0fd985da0abc92255156b77/lib/down/wget.rb#L124-L196). It would be great that instead `TTY::Command` provides some wrapper for that.
No. A linked list is only required to have a reference to the previous element, a block must have an identifier depending on the previous block's identifier, meaning that you cannot replace a block without recomputing every single block that comes after. In his implementation that happens as the previous digest is input in the calc_hash method.
Wait, what? 
Got it! Thanks for explaining it.
&gt; It looks like the file holding the class changed from .ext/thread/thread.c to thread_sync.c so it may be that it was reimplemented and lost some of the needed comments to generate the documentation. Looks like the rdoc comments are there and look correct at first glance: https://github.com/ruby/ruby/blob/274c6180b7ff3ed146dddaf841211a633648c322/thread_sync.c#L664
Is it okay if I just call it RacktiveRecord?
Neat
This is a "blockchain" in only the most literal sense of the word.
That's the best sense of the word.
No, this ruby class misses the whole point... a distributed data structure built by independent actors all putting in real work and receiving rewards for successfully solving the next block.
I think we cling to aesthetics because they are concrete. We can enforce a style guide, or implement a well-known design pattern, or adhere to a set of rules that are considered best practice. It's something we can point to and say "look, I did it properly." But that's all fairly low-level stuff. Rigidly following a style guide has very little impact on wether an application is well-designed at the architecture/system level. At that high level of design, what constitutes "doing it properly" is a lot more hazy and situational. It's certainly a lot harder to write an article about, without sounding overly vague. So we obsess over aesthetics not because they are important, but because they are easy to audit. The higher level decisions are more uncomfortable to defend, because you can't rely on Rubocop to tell you whether you're right or wrong.
I won't stop you :)
I think you miss the whole point of the repo - and the blockchain implementation. The committers to that repo are not trying to create a production blockchain. It is more for illustrative purposes. But you are free to conclude whatever you want from the repo.
While you're on to the fact that blockchain is not quite as interesting without proof of work, those are two totally independent concepts, and one is not needed to illustrate the other. 
Good point. In part ii of the series I will add consensus, mining, audits, network distribution and more. See [Let’s Make the Tiniest Blockchain Bigger](https://medium.com/crypto-currently/lets-make-the-tiniest-blockchain-bigger-ac360a328f4d) for the inspiration (in python) that got it all started.
Good point. I just count the lines of code (no blanks and comments) e.g. class Block attr_reader :index, :timestamp, :data, :previous_hash, :hash def initialize(index, timestamp, data, previous_hash) @index, @timestamp, @data, @previous_hash = index, timestamp, data, previous_hash @hash = calc_hash end def self.first( data="Genesis" ) Block.new( 0, Time.now, data, "0" ) end def self.next( previous, data="Transaction Data..." ) Block.new( previous.index+1, Time.now, data, previous.hash ) end private def calc_hash sha = Digest::SHA256.new sha.update( @index.to_s + @timestamp.to_s + @data.to_s + @previous_hash.to_s ) sha.hexdigest end end # class Block Using a struct and inling the calc_hash method I'm sure you can cut out even more lines (of code) :-) If anyone tries, let us know. Happy blockchaining. 
I strongly disagree. Not everything is about speed the same way not everything is about productivity (ruby/rails). Languages / technology have spikes in usage / popularity based on hype. 
 Ruby is slow and loosing its momentum lets use JavaScript -&gt; Javascript is single threaded,muh eventloop,callback hell,low quality libs lets use elixir -&gt; Elixir is not that fast anyway and the community is too small. Besides deploying it is a hassle lets use Go -&gt; Go is cool but...MUH GENERICS. I have heard Java has improved a lot -&gt; But Java is too verbose, devs are shit because it's too popular so lets go with Kotlin or Scala but muh jvm warm up time -&gt; I have heard about this .NET Core and MS is the old-new cool kid but...it's so unstable and everything changes so fast -&gt; So maybe we should just stick with Ruby for our core product (maybe until Crystal is ready!)
Answers are like software; by the time they're complete, they're "obsolete" and "in need of reevaluation and reimplementation" :P
I went down the rabbit hole a bit... - The docs are fine up until 2.3, it's only in 2.4 that they're messed up. - The docs for 'Thread::Queue' (https://ruby-doc.org/core-2.4.1/Thread/Queue.html) has the method definitions, but not the top-level text. - I wasn't able to find the source for ruby-doc.org - docs.ruby-lang.org has proper documentation for 2.4.0 (which ruby-doc.org doesn't): https://docs.ruby-lang.org/en/2.4.0/Queue.html. However, it doesn't have docs for the version 2.4.1. - ruby-doc.org suggests using http://documenting-ruby.org/ to report documentation problems, but a quick look at their github repo suggests that it isn't actively maintained. 
Leaving out white space is generally how LOC is calculated. That's perfectly fine.
Also, if you want actual POSIX process groups, consider https://github.com/ioquatix/process-group
that would be really cool. your baby-blockchain clearly demonstrates the simplicity of the concept, well done. I'm personally also interested in the consensus/network-distribution, would be great to see a small proof-of-concept implementation in ruby for didactical purposes. 
So what is that thing that `TTY::Command` has that `Open3` certainly doesn't?
Well, if I look at the the README I see a couple of things: * Automatically raising errors on non-zero exit status * [Timeout](https://github.com/piotrmurach/tty-command#324-timeout) – the real one using `IO.select`; `timeout` standard library won't terminate the subprocess when timeout is hit * [Logging](https://github.com/piotrmurach/tty-command#23-logging) – useful for feeding to metrics and then monitoring how long did the commands take * [Wait](https://github.com/piotrmurach/tty-command#25-wait) – extremely useful if you want to start a web server in a subprocess and you want to wait until it's ready * [Ruby interperter](https://github.com/piotrmurach/tty-command#27-ruby-interpreter) – looks useful as well, I think that simply using `ruby` doesn't work in all cases
We use it for example to notify systemd that our Unicorn worker is indeed up and ready to serve requests. This makes spawning (or restarting) our Unicorn synchronous, contrary to our previous setup where the service was considered "up" as soon as the Unicorn master booted the app. In general, you'd use it whenever want better visibility/instrumentation between your service and systemd and when a simple "service is running", "service is down" is not enough. We'll probably use it for most of our critical Ruby-based systemd services. For some other use cases take a look at https://zerokspot.com/weblog/2016/11/06/systemd-service-startup/.
It's not just automatically raising errors, but automatically raising errors that have stdout and stderr as strings in the message, which is exactly my typical need. Also suppressing stdout/stderr from being sent to the actual parent actual stdout/stderr FDs, but still capturing them in strings (so they can for instance be included in that exception!). The `printer: :null` in my example is one part of it that I'm not sure if your open3 example does? And can't seem to find any ruby docs for open3. One way or another you can of course do anything TTY::Command does with stdlib, TTY::Command is of course written using the stdlib itself, it's not doing anything magic. But TTY::Command gives you straightforward natural ruby-like API for it's things, with good docs. And the exception-with-stderr-stdout-in-it is standard enough for me that it justifies it on it's own. I've often found it confusing and multi-line-code to figure out how to do some of these things with the more primitive classes, and can't find docs for ruby open3 at all! (I did not write it and have not contributed to it, I'm just an appreciator). 
&gt; My first example also includes suppressing stdout/stderr from appearing in parent process stdout/stderr Yes, that's the case with `Open3.capture3` as well; it redirects stdout/stderr into a Ruby pipe (so they don't get printed to parent's stdout/stderr), and then calls `#read` on that pipe. As a proof, this shell command doesn't print anything: ruby -r open3 -e 'Open3.capture3("echo foo")'
Cool, thanks. I actually edited my comment cause I realized I wasn't sure if capture3 did that or not -- and then got confused looking for docs for `open3` not `capture3`! (and what's with capture2 vs capture3, is there any reason to use capture2 instead of just ignoring some of capture3's args?) Basically, I just find the API of TTY::Command less confusing. What I want to do with stdout/stderr are rubyish arguments, instead of having to hunt around for different methods in Open3 that do what I want. But how about passing through to parent stdout/stderr FDs _and_ capturing it too? I have occasionally wanted to do that -- show the output in the logs, but also look at it, especially in case of error. Straightforward with TTY::Command. 
&gt; I need to limit the scope of the items being ransacked Can you explain what you mean by this exactly? Based on my interpretation of the problem, you need to define a [model scope](http://api.rubyonrails.org/classes/ActiveRecord/Scoping/Named/ClassMethods.html#method-i-scope), and tell Ransack to [whitelist it for searches](https://github.com/activerecord-hackery/ransack#authorization-whitelistingblacklisting). You can see an example of this [here](https://github.com/activerecord-hackery/ransack#authorization-whitelistingblacklisting) in the project README.
Thank you for writing the article! It captures very well the sentiment behind creating tty-command library. No matter how many years I've been using Ruby, I always had to lookup different methods such as system, exec, backticks etc... and figure out which api will help me out in my situation. By creating this library I wanted to provide nice abstractions over regular bash and remove any gotchas that people may have. Most importantly, I wanted to have extensible logging capabilities baked-in similar to capistrano output logging during deployments. The more experienced I get, the more I prefer to work with right abstractions that capture the intention well. I don't get much kick out of writing arcane bash or reinventing the wheel every time I wish to redirect or capture output. And I am sure that by creating tools such as tty-command I will tap into experience and innovation of the community. For example, the `wait`was suggested by a user who had a specific need that fitted well with the library idea. In other words, I feel that right abstraction will attract higher level apis to build on. Thank you again for writing this article and spreading the word!
Thanks for your comment! In reference to streaming. Currently if the executable streams output to stdout or stderr that is line delimited then `TTY::Command` can yield it back to your script: ``` cmd.run("tail -f ...") do |out, err| output &lt;&lt; out if out errors &lt;&lt; err if err end ``` This part was written to allow me to implement `wait` feature. Therefore, if `wget` streams its output to stdout line by line when downloading a file then this should work like a charm. Otherwise the library would require change in how the subprocess pipe is read to allow for chunks being sent. Anyways, if you have time it would be awesome to make this work. 
I really would encourage you to give a `Readme` a try since I take a lot of effort to make sure it's comprehensive and helpful. Thanks for taking the interest in the library even if you won't use it!
Thanks for your suggestion. Btw, one of the items on my todo list for this library is a parallel runner for grouping and running concurrent commands. 
 Right - so something like this: fields = [DYNAMIC_FIELD_1, DYNAMIC_FIELD_2] -------------------------------------- ransacker DYNAMIC_FIELD_1.to_sym do Arel.sql(DYNAMIC_FIELD_1) end ransacker DYNAMIC_FIELD_2.to_sym do Arel.sql(DYNAMIC_FIELD_2) end Where the fields can be populated from the database. So far I've been able to pluck all of the values I need from the database, but that isn't enough because the table might get very long. So I need a way to filter it out... at the class level. Short of using class variables, I'm not sure of a sane way to get this working? Honestly I should have asked this in the rails subreddit too - my bad!
Thanks for the digest, looks very interesting, will give it a shot next time.
&gt; So far I've been able to pluck all of the values I need from the database, but that isn't enough because the table might get very long. So I need a way to filter it out. I see you've already found and commented on [a StackOverflow post](https://stackoverflow.com/a/33418523/1954610) for precisely this solution! So what do you mean by "filter out"? Why would the database query be problematic? Bear in mind that this query will only be made when the rails server is started (i.e. if you update the dynamic list, you'd need to restart the server). You could also add a hook so that "after a new filter is added to the DB, the ransacker is defined". I'm also unclear why you'd need *so many* ransackers!! Maybe you have a valid use case, I don't know.
"Filter out"... would mean giving our query a bit more of a 'hint', like an id or something, rather than calling pluck on the whole table, since the table can have a varying amount of rows. I don't actually need so many ransackers. In fact, I only need one dynamic one which is unknown in advance! However because I am unable to pass through any parameters normally... this is giving me a bit of a headache.
Are you asking for more answers or promoting the only answer given there?
I'm still not entirely sure I understand... You have one table that contains a list of "search types". The user chooses a "type" of search, and which model to apply it to. And the issue is that there are so many "types of search" that it's impractical to fetch all of their names. Is that correct? It would help if you showed the models/database schema of that you've designed currently.
Can you explain at a high level what you are trying to achieve? I feel you may have gone down a path at the start that has left you with a very wonky situation.
&gt; And can't seem to find any ruby docs for open3. Open3 has an ok API documentation, but I admit that I learned how to use `Open3` mostly by reading its source code, especially how to use the `Open3.popen*` methods (`Open3.capture*` was fairly straightforward). &gt; TTY::Command gives you straightforward natural ruby-like API for it's things, with good docs. I wholeheartedly agree. For me it's foremost much nicer to have one nice "command" object through which I can retrieve all the information (status, stdout, stderr), than to have to store each of that information in a separate variable. And of course not to mention all the other features, Piotr has really done fantastic work with `tty-command` and all the other `tty-*` gems.
Right.. the goal of this is to have pre-defined (at the database level) a bunch of ransack parameters/search fields that account admins can define. And now that's where I'm running into this problem where I'd like to filter by account, but the way the ransackers work won't let me ☹️ So in essence... Pre determined search parameters from the database.
Yes. What you are saying is correct. I'd like to have the ability to filter that list, but I can't pass parameters to filter it because of the way the ransackers are called
&gt; Currently if the executable streams output to stdout or stderr that is line delimited then TTY::Command can yield it back to your script Nice! &gt; Therefore, if wget streams its output to stdout line by line when downloading a file then this should work like a charm. That unfortunately isn't the case in my scenario, at least not in general, because `wget` simply writes the downloaded file content as-is to stdout, and large files are very often videos, which are binary files that I don't expect to hold a whole lot of newlines. What would work is if instead of `IO#gets` (which blocks until it has received a whole line and returns it) we use `IO#readpartial`, which blocks until it has received *any* content and returns it. Since I've already implemented this in my gem, I probably won't find time at the moment to bring it to `tty-command`, but I agree it would make a lot of sense, and it's great to hear that this feature would be welcome. To be honest, the main reason why I implemented this in `Open3` for the [Down](https://github.com/janko-m/down) gem is that the `wget` downloader is optional, so I wanted to limit the number of dependencies to make it easier to remember without having to look at the README (I couldn't add it as a runtime dependency because that's the only downloader that goes through shell). But I'm happy that through this blog post and the conversation I found out much more about `tty-command`!
The term `DDD` is used without explaining what it is. It's the first time I've come across it. Data driven development? (The first link touches on it -- *Domain driven development* -- an Arkency thing)
Heroku gets too expensive fast. Their dynos are pretty small, which gets annoying if you've got a large app.
IIRC `capture2` is useful when you want chronologically interleaved `STDOUT` and `STDERR`. `capture3` lets you process them separately (including ignoring them), but there is no way to interleave them chronologically after-the-fact.
&gt; I'd like to have the ability to filter that list ...So what's the issue with creating an endpoint that takes a `search` param (or similar), to filter the list? If this is a very heavily used endpoint, or the table becomes *huge*, then you could look into using ElasticSearch for example. ...But back to the original point of all this: **Why** do you need to store such a large list of custom filters for ransack?! Could all of this not just be achieved with a set of standard ransack queries; so the only thing you need to store are the *parameters* for a given search?
I think I'm still missing enough details to give a great answer, but I think you should look at: https://github.com/activerecord-hackery/ransack#authorization-whitelistingblacklisting You can load the allowed 'stuff' from some other model which stores the configuration from your admins to determine which fields/associations/scopes/etc are 'allowed' to be searched. Note that AFAIK, `auth_object` is any arbitrary object, you can pass whatever ids you need to make your decision through it, for example as a Hash. Now, this assumes that you can create the `ransacker` methods at boot time, but that may not be the case. i.e. if you regularly get, e.g. new products with new properties. In that case, what I would probably do is define a `dynamic` ransacker that accepts arguments and filters as needed based on the admin logic and also override the methods described in the link above. 
I presume it's [Domain Driven Design](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/) -- This was a popular, well received book. DHH in particular has [blogged](https://signalvnoise.com/posts/3375-the-five-programming-books-that-meant-most-to-me), [talked](http://www.fullstackradio.com/9) and [tweeted](https://twitter.com/dhh/status/289811920301719552) about it on numerous occasions.
Sure thing, I understand that you don't want to carry extra baggage and wish to keep your library lean. I still want to add this functionality as I think it is a good idea. I may provide option for mode of execution. If for example content is binary, it will read content chunk by chunk with `readpartial` etc... Thanks for taking the time to comment. I've created an issue to remind myself to tackle this in the near future [issue](https://github.com/piotrmurach/tty-command/issues/34)
Use VPS like Vultr, Digital Ocean, Linode or use AWS. 
Oh nice! It's nice to get some background info into why tools are built and used instead of just a "hey, here's a thing that does stuff, maybe you can use it too?". Thanks for making it open source, thats super cool you did that!
Thanks for the kind words, it's a really simple gem actually! Let me know if I can shed some more light into how this can be used or if you have any questions in general. Cheers.
Process::Group does that pretty well :)
Very cool idea. Bonus points to integrate this into Sidekiq's process events: https://github.com/mperham/sidekiq/wiki/Deployment#events
"rails new" creates all the directories you need to start with. Am I missing something?
I’ve used DO for years. Been giving Vultr a try. This is just my second month but happy thus far. I really can’t tell a difference between it and DO other then it’s half the price. Think I’m going to move what I have on DO over and save the $. 
As far as directory structure, use the rails new command: http://guides.rubyonrails.org/command_line.html#rails-new Jumpstart Lab has some good tutorials for getting started. It sounds like you might be past this step, but here's their environment setup tutorial: http://tutorials.jumpstartlab.com/topics/environment/environment.html Just a heads up, sqlite is totally fine to get started, but you might want to consider using Postgres or another more robust database in the future. It's better to try to mirror a production environment as closely as possible for your development environment, and no production environment will be using sqlite. Good luck!
with regards to the database...not being able to simultaneously run the server and a rails console is a deal breaker for me. I'd be dead in the water without the ability to do this.
Very True!
I've used mysql a bit, is that ever used in production? 
Yep, MySQL is fine. Postgres seems to be more popular because it's open source which kind of fits with the ethos of Rails, but ActiveRecord definitely has an adapter for MySQL. /u/hero_of_ages makes a great point. You can run into issues running rails server and console simultaneously while using sqlite, so I'd definitely recommend using MySQL or Postgres.
Great point, I forgot about that. It's been forever since I used sqlite.
MySQL is open source.. but it is controlled by Oracle.. MariaDB is a much nicer licensed fork... A religious war exists between the MySQL crowd and the Postgres crowd... both are great, both have pretty dang good communities... You will ultimately want to know both.. not to worry, from a user stand point, 80% will be the same for both.. 95% if you are using rails / activerecord... but for now pick what ever is most convenient for you (or just stick with Sqlite until you need production) I have used both quite a bit, MySQL much more (cuz I'm old) 
Sorry... the first sentence was for you.. the rest was kinda directed at the comment above yours... ;)
Of course I'm asking for more answers, otherwise I would have shared link to the answer, not to the question.
Linode's and vultr's pricing is approximately the same, so which one s better? And to the original question: is it an easily scalable way of deploying rails?
Honestly the real lesson here is that Quora is cancer. At least you could ask this here and get ten conflicting replies from anonymous people, and you'd be forced to do some critical thinking about the answers. Or you could Quora, and apparently there's one objectively correct answer.
Gorails: https://gorails.com/setup
This. I always hated javascript, but it is getting better... V8 ... [if it can boot linux](http://jslinux.org) then it can kick ass with the transpilers like Opal / Scala.js I am looking forward to Crystal getting better, but ruby 3 should be pretty awesome all on it's own. I really want to like Elixr, but Ruby is just so effective for ME to solve problems in... and I just don't find too many problems where speed is a factor these days. I WOULD like to see a nice easy way to use Crystal to make slow chunks of ruby faster when needed.
I'm the OP, this question was originally asked by someone (Anonymous) at Quora, and I am posting this question here, not to promote the answer(s) at Quora, but to get more answers, because on reddit I'll get answers faster.
No need to replace MVC, rather factor out the fat that gets conflated with the responsibilities of each part: http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/ Note you could just go with a framework like Hanami that gets you a lot of this out of the box, but there's a lot to be learned by refactoring your existing apps by hand first. 
Seems like you might be past this part already, but this is the guide I used when I started out with Ruby fairly recently: https://learnrubythehardway.org/book/ For Rails apps, **rails new** should get you going as /u/hero_of_ages pointed out.
hello all ! I totally agree, Ruby isn't the favorite langage when it comes to ML or AI but you can do funny stuff with As ruby and rails are very readable code, IMHO it will be the best option to learn specific domain like chatbot :) 
GoRails is an awesome resource. If you subscribe there’s a Slack channel where you can ask questions, share ideas, etc. Just that by itself would be worth the $ in my opinion. Chris makes great videos and lays things out so you know exactly how something works and can implement it quickly. Saved me a lot of time and frustration. 
I was a die hard MySQL fan until I started really listening to what Rails veterans were saying. There’s a bunch of situations where MySQL doesn’t behave as expected. I switched to PG and immediate got an error on one page. Come to find out, I had an ambiguous association. Worked fine with MySQL but was giving incorrect results and I hadn’t noticed. PG was like are you drunk? I don’t recall the specifics or I’d share. But there’s a number of things where MySQL just isn’t great. And that sucks because I have many years of experience that is semi-wasted now. Thankfully the transition hasn’t been too bad. SQL is SQL but I’ve had to learn how to work with it. Much different commands for things. 
[Elm architecture](https://guide.elm-lang.org/architecture) has significant advantages.
Just to toss this in, I built Hatch (https://hatch.gorails.com) to let you deploy to your own VPS as easily as Heroku. It certainly makes things more cost effective and you can scale up your VPS to add more RAM or CPU really easily on DO, Vultr, Linode, etc.
I got inspired by your implementation. Here's my own take: https://github.com/MatiasFMolinari/blockchain-ruby/blob/master/blockchain.rb It's 8 lines, but that's because I removed the class methods. Cool stuff!
dokku + DO + heroku buildpack
Are you on Windows? OS X?
learnXthehard way is from that guy that thinks that ruby is a shit community and python3 is not turing complete?
Blockchain! Blockchain! Blockchain! In less than 10 lines. Wow. Thanks for sharing.
1. Profile it, work out the bottleneck (io, cpu, etc) 2. Look at threads, parallel, concurrency etc if the bottle next is rmagick
&gt; Hatch When are they supporting international pop's? latency is an issue in Australia
&lt;3
I agree with most of the posts here, and what they recommend... but at some point, you will get to the point that you will just start reading code at github. The exposure to a lot of different coding styles and levels of competency will really help you understand what the world of code is really like.
I think it would be good to have an option for binary reading, rather than relying on auto-detecting of whether the content is binary or not -- not sure if you meant that or not, but just a manual option is likely sufficient, and not relying on getting a guess wrong. If you can _also_ provide a writeable stdin stream to the block, you've now made interactive possible, a block that both reads and, depending on content, writes. Unlike trying to do this oneself with the lower-level stdlib primitives, I would expect TTY::Command to buffer all the real stdout/stderr, so it's not up to me in the block to make sure I'm reading enough of it to keep the underlying process from blocking because it's buffer is full. If you know what I mean. That's the big pitfall in doing 'interactive' write+read stuff with external processes normally. Next, how about a way to pipe one process to another without having bash doing it, just having TTY::Command doing it directly? :)
&gt; When you use any web framework, you cannot avoid "jump from one place to another" anyway. That's how framework works. Not... really. So, keep in mind that I haven't done any Rails since Rails 2, I think it was, so things have almost assuredly changed. :) And my Django knowledge is similarly dated. Rails would have a controller that looks something like this: def my_view(request) some_data = some_calculation end Django would write the same sort of thing like this: def my_view(request): some_data = some_calculation() render_to_request('template.html', data=some_data) They're basically the same. But in the Django version, when you get to the end of the controller, you see "oh, now we're going to render a template", and you can go look up that function and see what it does, and see that ok, we're going to render template.html and we're passing some_data to it. In Rails, meanwhile, the framework automatically inserts that code at the end of the function (essentially), which is nice if you're tired of writing that line hundreds of times, but if you're a newbie... you're just left dangling, and you have to go through the documentation to find out what magical thing is happening there.
Replied to the wrong thread I think? I don't know anything about Hatch. You can deploy a private server to the australia region with Heroku (pretty sure Australia is available). https://www.heroku.com/private-spaces 
Framework calls your code - your Django or Rails controller and uses the return value. And you need to learn anyway how your framework works. Rails has convention (for productivity) so that you don't need to explicitly call render - but if you need you have to run different render call anyway. Different framework uses less convention and less decoupled components, which requires you to be very explicit. There are pros and cons of those different approaches. But frankly you should ask this: if you use the same patterns in 90% cases, why don't you try to avoid that? Isn't that a purpose of using framework? :) I totally agree that Rails does many magical things. I understand people who don't like that. But I think no one would disagree that Rails is one of the most productive framework out of box, at least for most use cases. Don't get me wrong - I'm not saying Rails is the best solution for all cases. It is not. But I do think avoiding rails only for that reason is not a good decision. 
When I needed to do this recently, not knowing it existed as 'interpose' in clojure, I hackily did it like this: array.zip([separator] * (array.size - 1)).flatten.compact
That's really awesome! It gets the job done 😄😄
I think I found it, or at least hints toward it, on StackOverflow somewhere. :)
Honestly, it depends on the scale of your application vision. If you have a huge engineering roadmap with lots of new features + broad/complex architecture I think it would be wise to use a cloud architecture platform. AWS (+ Elastic beanstalk) is pretty solid out of the box while having a ton of support for AWS services like Lambda/S3. (Also for consideration here are Google cloud and Azure cloud) If you're planning to only focus on the rails app itself and don't need to grow much outside of that, a simple VPS service like DO/Vultr is fairly scalable and simple and will get you pretty far. Keep in mind that while it's definitely possible to migrate if the features/cost demand it, there's bound to be technical debt so minimal migrations are advised.
I like hanami. Its definitely better at separating responsabilities than rails. And I don't NEED to replace mvc, but I think there is value in doing something different just to see whether or not it works.
You're right, it would be very interesting to see if you could transfer this pattern to a backend application and find out if that has any benefits. Thanks ☺
Elm can and has been used on the back-end. It's not necessarily _encouraged_ by the language developers, but the compiler makes back-end use attractive.
I imagine that the first of these Ruby-like languages that supports proper multi-threading will see a ton of interest
Crystal currently runs on single-thread with CSP concurrency. Multi-thread parallelism support is coming soon :) 
Couldn't we look at JRuby or Rubinius there? I don't see where they got a ton of interest. For "Ruby like" we could looks at Elixir as well, which has definite garnered interest but it has not swayed the core Ruby community for the most part.
JRuby definitely worths a shot. I'm not sure about Rubinius though, haven't seen any new significant releases at near time.
Yeah, I don't know the state of either JRuby or Rubinius today, but those Ruby runtimes definitely gave Rubyists access to powerful threading models, which is why I mentioned them. 
Rubinius is extremely slow unfortunately.
JRuby is still active
http://trailblazer.to &gt; Trailblazer gives you a high-level architecture for web applications. It extends the basic MVC pattern with new abstractions. Rock-solid conventions that go far beyond database table naming or route paths let you focus on your application code, minimize bugs and improve the maintainability.
Thanks for your suggestions! When I wrote "I may provide option for mode of execution" I was thinking of actual option such as `:binary` or similar, and not auto-detecting for the exact reasons you have provided. I agree that exposing writable stdin stream would be a great addition, as well as any abstraction should take core of the details of how much should be consumed when streaming. If I understand correctly, `tty-command` already provides [pipes redirection](https://github.com/piotrmurach/tty-command#322-redirection).
I am way happy to see a compiled language with Ruby syntax, but I am just shaky about the GC and the fact the project is not 1.0 yet. Although I have seen some posts around about them targeting 1.0 soon but you never know :D. I will probably write a push server for one of my heavy traffic websites to try it out.
Crystal is not 1.0 yet however there are already a bunch of companies using it in production :) https://github.com/crystal-lang/crystal/wiki/Used-in-production
...and Truffle Ruby
I was thinking of redirecting one process to another, not just to a file. some_command something | other_command other There may be a way to do that with the existing tty-command, but I haven't figured it out -- other than just passing that whole command as a string to the shell (which loses you automatic shell escaping among other things). 
It seems really cool. I'd love to see some GTK library for it.
These companies are either using Crystal for experimental, trivial, unimportant-if-they-fail components, or they're what we technically call "idiots". ;-p ----- **Edit:** Downvotes, really? People are going to defend using pre-1.0 software in mission-critical production systems? When even the authors of Crystal themselves imply its inadvisable? &gt; **Crystal is still changing and growing rapidly**. Here we list the **brave** folks that start to use it in production nonetheless
I've seen (and used part of) trailblazer before. It gives you a good, expansive structure that encourages better code imo, but as it says, it expands the MVC pattern instead of replacing it.
https://github.com/Fusion/libui.cr
Not really new, been around for a couple years, but good to see it getting more exposure.
Thats not GTK, but it's neat as well.
libui is just a wrapper around platform native UI libs. It wraps GTK when targeting linux.
OH! Well cool!
5 months later and still no mention of a ruby LSP on http://langserver.org. What's more, ATOM announced ATOM IDE and didn't mention ruby once; not even on the horizon. It's still a top 10 language, what's going on?
Sequel is awesome! 
Thx. the pixel to pixel comparison is taking ages, I am tryg now chunky-png instead of rmagick and speed seems to be at least an order of magnitude better
Is there a live stream or link to watch the keynote or presentations?
What exactly you need to be explained? Did you run the code? What did you see as output?
AFAIK, no live streams, unfortunately. But all videos and presentations would be published in a week or few (though I am afraid, Japanese-language videos would be published without the translation).
If you are installing native packages like rubygem-rails you also need the documentation package rubygem-rails-doc, but if you just install gems using gem install, than you can tell it to install ri docs; gem install rails --ri (should be default I think though).
What does it take for a language to qualify as "a Ruby"? From what I understand, Crystal is different enough from Ruby to not qualify.
There's clearly a couple of syntax errors in your code: 1. The `login_page.form_with(...) do` block is missing an `end` statement. 2. You've written `do |f|` and then used an (undefined) variable called `form`. Use one or the other, but make it consistent. But other than that, could you clarify your question? What exactly are you trying to do, and what unexpected/missing behaviour are you seeing?
And nowhere near as popular as it should be imo
Why don't you use the bot API?
Just because something is used in production doesn't mean it is actually mission critical.
Right. Hence: &gt;&gt; **either** using Crystal for... unimportant-if-they-fail components, **or** they're what we technically call "idiots"
I guess that version will remove nil from your original array, put the proper slice on the end to remove the last element instead of `compact` to avoid that. 
curious why they pick vladimir JIT instead of this
because LLVM
I see more energy or maybe is just `marketing` on llvm than GCC on internet. Even so, will be amazing that in future we can pick out backend: - llvm - mri - gcc - jruby - truffle As a config, or even gem :) 
In principle, I'd agree with you. But "jack of all trades, master of none". Trying to officially accommodate so many backends would hurt ruby even more in the long run. Ruby core already struggles with the external dependencies they have, and all new feature proposals which involve a new dependency are rejected. The advantage of the JIT you mentioned is that it's gcc based, and gcc is already a dependency. The other reason is support. If you'd have to bet on gcc or LLVM, what would you do? gcc is conservative, but a core infrastructure piece for +30 years, while LLVM is relatively young, and has (only?) Apple backing it up. As far as long-term bets go, it's not a bad call. But ultimately, an alt-ruby which targets LLVM and has better C-extension support than JRuby will always be interesting.
I'm really excited for Crystal. The syntax is so familiar and you cannot argue with that performance. Still, someone in the Crystal subreddit posted a blog entry the other day where the author reported compilation times of 8s every time they save a file. This seems pretty crucial to fix if they want to convert Rubyists.
I'd guess most are in the "trivial" category. If you think that the benefits are worth a little risk, a small project that's carefully tested and locked to specific versions of language and dependencies can be fine. I wouldn't bet my business on it and I wouldn't use it for anything too big, but if I had a coworker that had a very narrowly defined goal, I'd be ok with it. It's a very promising language. 
to be fair so does crystal, maybe not much in terms of syntax, but in terms of having to forego the existing ecosystem of ruby libraries. 
In addition to these, the thing stopping you most quickly is likely that you are using `page` as your block argument for the `get` method, but referencing it as `login_page` in the block. Finally, I haven't gone to the site myself, but being Facebook, I imagine the functionality is very JavaScript dependant -- Mechanize won't do the trick in that case-- it's strictly an HTTP getter/session manager. It doesn't understand JavaScript. Either way, good luck getting your login form working. With these couple notes you should be able to get on to the next challenge. 
Yea I don't really get it either. What makes Ruby, Ruby is the object model and metaprogramming. Crystal has neither so the only relation to Ruby is very superficial. Same is true of Elixir.
Cool to see some competition in the space. I wonder if this implementation could benefit from from mjits iseq updates.
I think you got caught up in the anti-enterprise spirit of Ruby there, or maybe someone took offense at being called an idiot ;) I would not down vote you , BUT I remember standing up quite a few Linux servers that were pre 1.0... and quite a few people were making fun of it... I took quite a bit of flak over it... it worked excellent in production... then other people started to use it... same story with MySQL, Postgres, Perl... A lot changed frequently back then but it sure beat the hell out of SCO or System V... or coding everything in C or using Sybase all the time.. I would have used Crystal in production for small simple little chunks that performance was just required a year ago... Most things on earth are not as mission critical as people try to make them out to be... I remember a thread where reddit (I think) was crashing all the time when they just started getting traction and they were using some little process monitor to kill everything and then restart it... then I think they migrated to supervisor or the like... they got a lot more sleep by expecting things to fail... and one of the big tenets of google is planning on things to fail... and fail often... you can overcome the problems of beta stuff when you code defensively... I think the authors advise against it so they don't get the blame... but pretty sure they are using it themselves...
Perl is where Ruby got 2 of my favorite things... string interpolation and trailing conditionals... I would hate to do Perl again, but it was better than ANYTHING else back in the 90s for scripting... 
THEY ARE!!!
Why do I need change a file in my repo? It seems like you should be able to run a scan right from the web interface, at least so I can see what the results would be like. I am also very leery of downloading and executing some file from the Internet.
I understand. The design of the application is to hook into your Continuous Integration process so that you can get updated results any time you commit changes to GitHub. You can directly download the script that we ask you to download in your CI post-build step and check out what it does, mostly sets environment variables before downloading another script called [Hub Detect](https://github.com/blackducksoftware/hub-detect) which is our integrations team's all-in-one scanner. Hub Detect pokes Rubygems and generates a file with your dependencies, which is then uploaded to CoPilot for analysis. You can check out our corporate website https://www.blackducksoftware.com for more information on our products and background. We're a pretty well-regarded firm in the software security business. The fact that you're wary of downloading random code from the internet probably means you've got good instincts for security already! Hopefully after learning more about us you can trust us enough to let us help you keep your projects safe.
It was mentioned on RubyKaigi yesterday and looks pretty fresh and promising!
thanks for this
Really cool, but what's a practical use case for it? I'm not saying that there aren't any, but as someone who's just a hobbyist, why would you use this?
Do less...
Our model is based off of other build integrations, such as code coverage tools. When we go GA (hopefully next month) we will be adding the feature of building Pull Requests and commenting on your pull requests to let you know if merging a PR is going to add vulnerable components. The goal of the project is not to provide people with one-time security scans, but to seamlessly integrate security into your build process so that you continue to care about it. Something we are investigating is a one-time preview scan that we could do without requiring you to commit any changes, but that is further down the roadmap.
In the [talk where it was mentioned](https://rubykaigi.org/2017/presentations/masa16tanaka.html) it is used to create Ruby ports of Python scientific libraries previously missing in Ruby. First, you bootstrap the port with py2rb, then refactor it to have more Ruby-idiomatic interface (but can leave most of the math and classes relationships intact). I believe it is a pretty important example (and really do want js2rb for the same reasons).
I wonder if the developer licensed the content. If not, Chris Pine might want to know about it.
I'm a MS SQL database dev/admin for ETL projects and I use it all the time for fixing data. Sometimes when I have Ruby on the mind, I even take it a little too far and forget about simple TSQL statements, and things the DB is naturally good at. Like using it when a simple `update replace() from join` type SQL statement would work and be way more efficient both in terms of dev time and execution time. The truth is, doing it in a ruby way and leveraging Pry+Sequel is usually much more joyful. I've written some gems specifically to drop me into a DB dev pry session set up how I like it, setting up `Sequel::Model`s for my usual needs. `&lt;3`, seriously.
Another outtake of RubyKaigi. It is an experimental version of patched Ruby interpreter/proposal of language addition, which allows doing things like this: res = [:ng, 500] case res when %p([:ok, status]) p "You got! status: #{status}" when %p([:ng, status]) p "Nooo! status: #{status}" else raise "unexpected response!" end 
Eyyy, I wonder if I had any influence on this: &gt; %p allows [...] _ + class name. &gt; &gt; obj = %w(a b c) &gt; &gt; case obj &gt; when %p(_String) &gt; p obj &gt; when %p(_Array) &gt; p obj.join(',') &gt; end From [RSchema](https://github.com/tomdalling/rschema): blog_post_schema = RSchema.define_hash {{ title: _String, tags: array(_Symbol), body: _String, }}
Yeah, looks familiar! (Though, I wonder why it doesn't use just `%p(String)`—it should be easy to use just `===` of the components of the pattern).
It definitely wouldn't pass the ruby spec but it's near ruby.
I don't think they even have a plan to reduce compile times yet. There was some discussion but looks like nobody can figure out how. I think it's going to take some outside expert to step in.
It's probably the difference between `x == String` and `x.is_a?(String)`. %p(String) =~ String #=&gt; true %p(String) =~ "hello" #=&gt; false %p(_String) =~ String #=&gt; false %p(_String) =~ "hello" #=&gt; true People might want to match actual class values instead of types, although I don't know why.
&gt; People might want to match actual class Hm, makes sense.
Looks very interesting; I wonder if there will be `Regexp` support? Also would be nice to have a syntax for "the matched object responds to method `x`" of some sort. Also maybe "the matched object obeys this predicate" (such as `:nil?.to_proc`.)
&gt; the thing stopping you most quickly is likely that you are using `page` as your block argument for the get method, but referencing it as `login_page` in the block. Ah yeah, good spot. Such an error would be quite obvious if you actually *run* the code, which I did not :D Although, the missing `end` keyword will be the most immediate error; running the above will result in an error message like: syntax error, unexpected end-of-input, expecting keyword_end
I like this idea of this; at least for small-ish projects. If the style checkers are quick to run, it can be a bit annoying having multiple different checkers. For larger projects, I currently just use a bunch of plugins (e.g. for Atom) to perform multiple checks on individual files as I edit them. And there are existing CI integrations such as [Code Climate](https://codeclimate.com/), that already uses these tools (and many more) to provide analysis of the code quality. If you are planning to make this into a SaaS platform, then what is your USP? What new/better solution are you building?
&gt; I wonder if there will be Regexp support? According to README, it always can regexps: language = { name: 'pm-ruby', version: "development" } case language when %p({ name: /^pm-.*/, version: version }) p "This pattern-match's version is #{version}" when %p({ name: name, version: version }) p "This #{name}'s version is #{version}" end (But in fact I'd like to have regexp matches to be damped into instance variables too)
Yep, I used it for small and medium projects (like gems), to get fast tabled-view report. When you've got CI it doesn't mean you've got no need in local fast check.
Finally! :) I'd love to see it in upcoming versions so I should give it a try
After re-reading your question, perhaps we all misunderstood your question a little bit. I think you're asking not so much "why doesn't this code work" but more "what does Mechanize do, and how." Mechanize is essentially a session manager for HTTP requests. i.e. -- It can make web requests on your behalf, and keep track of history, cookies, and HTTP headers to pass back and forth. It's a bit more similar to using a web browser to make web requests than something such as `curl`, `wget`, `openURI/Kernel.open`, `NetHTTP` etc. Each of these strictly send a web request and get a response. The next web request has no context of the session as a whole. This is problematic when using websites that require login, or other stateful information. Technically, you could still read all of the responses from those tools, keeping track of what cookies and headers are needed and send them yourself -- but this is where Mechanize comes in. Mechanize solves this by implementing structures to maintain the state of your session. You can think of `Mechanize.new` as creating a fresh private browser window. In your example, you might think of `a` as a browser. It's important to note that Mechanize is still more similar in nature to the above tools than a full-fledged browser, in that it doesn't render any pages, and doesn't understand javascript. It strictly makes HTTP requests for you, and keeps track of history and the appropriate headers over time. You are beginning by requesting a page using the `#get` method. The `#get` method will return the results of the request -- typically when successful, this is a [Page object](http://www.rubydoc.info/gems/mechanize/Mechanize/Page). A Page object is essentially a decorated [Nokogiri XML document](http://www.rubydoc.info/github/sparklemotion/nokogiri/Nokogiri/XML/Document), in that it has some Mechanize specific methods, and for what it doesn't, it passes to Nokogiri. This gives us a robust HTML parser on the response, and will feel familiar to most users. Mechanize offers two ways to handle your page: - `page = agent.get(url)` - `agent.get(url) do |page|` ... Your example is using the second of those, keeping the page in scope only for the duration you wish. As such, your page object is referenced as `page` in the block. In your example you've referenced `login_page` -- so you'll need to correct that. Mechanize is helping you fill out the form on the page by first finding and targeting it using `form_with` and an identifier (the `action` attribute of the form node should match the string). Using block syntax, it's scoping the form to `f` in your block and proceeding to target specific form elements, and fill them out. In your example, you've referenced `form` instead of `f`, so you'll need to correct that. They are setting elements explicitly, but since they are only referenced once, you could just as easily do: my_page = login_page.form_with(:action =&gt; '/account/login.php') do |f| f.field_with(:name =&gt; "").value = "whatever_user" f.field_with(:name =&gt; "user_session[password]") end.submit Notice the change to the `submit` line. Since we opted for block syntax, passing `f`, we aren't going to call `submit` with the explicit reference -- we are submitting the result of the block, which is the form we targeted with `form_with`. In doing this, we've now set `my_page` to the response of trying to login. Mechanize provides an easy interface to inspect the body of the page for the sake of exploring and traversing it. One such example is the `#links` method on a page object, which returns an array of Link objects. A Link object has all of the typical HTML elements on it, so you can access the text, the href, and so on. You can also easily navigate to this next page by sending `link.click`. In the example you've listed, we are iterating through all of the found links on the page, and printing the found text of the links. &lt;a href="#" class="this has no text"&gt;&lt;/a&gt; &lt;a href="#"&gt;This will get printed.&lt;/a&gt; &lt;a href="and this won't" /&gt; Finally, to give you two examples of your specific problem, using both assignment and block forms: # Standard form is better for exploration, and objects that expect to be around a while require 'mechanize' agent = Mechanize.new page = agent.get 'https://www.messenger.com/login' form = page.form_with action: /login/ # using regex to search for a text part -- less likely to break in the future -- our form will almost certainly have "login" in the path. form.email = EMAIL # Above we used `field_with` -- but if you're just using the name, you can do this. form.pass = PASSWORD dashboard_page = form.submit do_things_to dashboard_page # Block form may be better for specific, isolated interactions # (I personally don't usually like it, particularly for pages). require 'mechanize' agent = Mechanize.new agent.get 'https://www.messenger.com/login' do |page| dashboard_page = page.form_with action: /login/ do |form| form.email = EMAIL form.pass = PASSWORD end.submit do_things_to dashboard_page end Take note though -- neither of these really seem to work with my login, almost certainly because of Facebook's heavy reliance on javascript. But, to answer your question, this is generally how Mechanize works.
Use a text editor like sublime or atom. Write programs with the `.rb` extension and run them on the command line like so: `ruby some-program-name.rb`. Or just type `irb` on the command line and start playing around with some methods. Also I'd recommend [Learn to program, Chris Pine](https://pine.fm/LearnToProgram/)
Thank you very much for the quick and concise answer and the recommendation. I've been reading ruby beginners guide on my kindle by icode academy and I'm always looking for more material to learn more. 
Would it be possible to make something like this? match res do %p([:ok, status]) do p "You got! status: #{status}" end %p([:ng, status]) do p "Nooo! status: #{status}" end %p(_) do raise "unexpected response!" end end
It sounds like you're truly taking your first steps. I've been there! It's super frustrating when you don't know what's what and don't know where to start. I highly recommend checking out (from personal experience) the Odin project. www.theodinproject.com The Odin Project will take you from "what's Ruby?" to understanding how to get started and writing code and it's completely free. It guides you assuming you know nothing about any of this and even teaches you "the tools of the trade" before diving into code. It's a great starting place IMO. I found that the most frustrating part wasn't learning the language but rather understanding all of the things involved surrounding it. Good luck! 
How it is different from the `case`, shown above?.. 
Hey thanks, I will definitely go through that. So many resources and I just want to consume all of them. Started with the guide /u/t3hj4nk linked by Chris Pine and I began making my way through the numbers part. Had a little trouble navigating the command prompt and run the simple addition program but thankfully the intro to command prompt I went through on code academy helped me tremendously with navigating to my d drive and going through the folders to execute that simple command. And when it actually worked I literally threw my hands up in the air in triumph of such a simple thing. I am enjoying this immensely and cannot wait to learn more. 
Replace the `%p` literals with method calls and you could probably implement this as a library.
This looks very interesting. It sounds like there was a talk about this at RubyKaigi? I'm looking forward to the video being posted.
So just to clarify, the ruby executable you've got there is what actually _runs the code you write_ not what you use to write the code. You can use a text editor like notepad++ or sublime text or an IDE (integrated development environment) like Eclipse. Whatever you choose is up to your personal preference. Once you have some code written, you run it from the command line _using that ruby executable_ like ``` ruby script_I_wrote.rb``` and that will run the program! Best of luck!
I second the suggestion of The Odin Project, that's how I learned Ruby! You may want to bookmark https://rubymonk.com/ as well, it's an interactive site that has little problem sets and challenges to work through. It's a nice change of pace/format and the site goes from the most basic of concepts to really high-level, Ruby-guru kind of stuff. Plenty of meat for all levels of understanding. Sounds like you're making excellent progress, stick with it!
Enjoyed your talk too! 👋
Ahhh so that is my command line not the one that came with windows. Thank you for clarifying that for me! 
Just semantics I guess, not really a lot to gain from it asside from making it explicit that I will be pattern matching here.
Yes, the image you showed is the ruby executable :)
I'm new, a few months old to Ruby. Anyway, I use Sublime some, but am replying to say you can also use sites like https://repl.it . Just search for Ruby there. There is a host of languages to choose from. The upside is you can run your code instantly (no save after edits). By creating an account there (or similar sites) you can save your work as well. The downside is you won't be able to use other gems (eg. require 'somefile') or have access to your own computer directories. For example if I want to debug using 'pry' then I copy from repl into sublime, then load 'pry'. Having both (online repl and sublime) is a nice combination.
library, declaring variables on the calling scope?
What about the problems with Ruby servers when you have slow users, shown in this [Nate Berkopec's post](https://www.speedshop.co/2015/07/29/scaling-ruby-apps-to-1000-rpm.html) (scaling ruby apps to 1000 rpm).
Heh, so, I made the same mistake when starting That's something called the interpreter, it turns your code into readable computer format You should download something like Notepad++ or Sublime, type your code, and save it with the .rb extension
Just syntax actually, not semantics. 
Yeah, you'd have to replace a lot more, and wind up with a "DSL" looking thing. It'd have to look something like this" Matcher do |m| m.match(Fixed(:ok), Variable(:status)) do |m| p "You got! status: #{m.status}" end end Not nearly as nice. I wouldn't be shocked if someone has already done something like this as an experiment. 
What can you do with this if you don't mind me asking? I tried running programs in it like I would with cmd but nothing is working. Example: ruby (program).rb is not working when I type it in that. I've been racking my brain trying to figure out how to work it but it does nothing but let me type into it. 
Correct, it does nothing. By using CMD and putting: ruby (filename), you are actually sending data to this program to compile it Edit: run and execute, but doesn't technically compile
I didn't say it would be a library you should use in production.
You can make it cleaner depending on how many metaprogramming treaties you're willing to violate.
Most programming tutorials assume you understand the OS you are running so they leave out details about the OS. They assume you know that ruby would need to be in your path to be able to run it from any folder. Try this: https://www.ruby-lang.org/en/documentation/quickstart/ This talks about Ruby and the PATH in Windows. It's old but the instructions are close. https://www.tutorialspoint.com/ruby/ruby_installation_windows.htm 
The thing you opened is the `ruby` part of `ruby (program).rb`. It's the ruby executable. 
Sure, that would be a perfect reason to use another technology. I'm not saying this is true 100% of the time, of course there are exceptions, but for general use web apps it's generally not needed.
 No, that's the ruby executable ... you would use your normal command line to run it. The command line will use that to run, but you don't need to touch it. Chances are the ruby installer put that in your path, so you can just open normal command line and call "ruby filename.rb". You can also call "irb" from command line and that will give you an interactive terminal. In there, you can call ruby code on the fly. You can use it for testing and whatnot. But tldr... not need to touch the .exe
Awesome! Keep it up. You've got a bunch of rewarding victories ahead of you.
&gt; to compile it correction: to interpret and run it line by line. no compiled executable is produced.
After you get your feet wet, look into the various ruby wrapper apis for things like Twitter, Reddit, etc. It can be fun applying what you've learned into something that interacts with stuff you know and love. Look into getting set up with github and heroku early. Edit: if you're really new and have some downtime during your days: check out ruby warrior. It's a game that has you programming in ruby to kill blobs and save captives as a Ruby introduction. Works on mobile. 
&gt; I wouldn't be shocked if someone has already done something like this as an experiment. Yeah, kind of. https://github.com/katafrakt/noaidi
I am really not getting anywhere. Where is the documentation for something fundamental like the File class? Is that the obvious thing I am missing? What is the recommendation, use the Fedora package or the Gem route?
this is cool. I bet it'd be possible to write some abstraction upon method building which allows for pattern matching arguments. 
Well, I believe that `case` is exactly how we do pattern matching in Ruby, we just need more powerful patterns.
It's awesome that you get it working. Believe it or not, programming is ALL about small victories like this. It's great that you are celebrating moments like this. Keep up the good work! We **ALL** started there. We **ALL** struggled with command lines and setting up the right environments before. So you are on your way to success! Programming is one step after another, one struggle after another, one small victory after another. The great thing about programming is that the more time you put in, the faster you progress. Before you notice, you would have traveled a long way. :)
This is an old article, Rails 5 already does this: http://blog.bigbinary.com/2016/06/07/rails-5-prevents-destructive-action-on-production-db.html
There are ton of them ([guilty myself](http://zverok.github.io/blog/2015-07-18-matchish.html)). What you can't achieve with library is two really important things: * storing matched parts in local variables; * any reasonable performance (imagine any parser, where pattern-matching is extremely useful, performing this `case` 10'000 times, each time using ton of smart library code to first construct the pattern and then apply it... absolutely unusable)
Yep, and it was a really fascinating talk! I believe in a week or two they will be available. BTW, as far as I understand, ko1 (Koichi Sasada, Ruby maintainer) is helping with developing this experiment, so there is a reasonable chance it will eventually make it into the core.
Well, I believe this approach would be a too huge change of Ruby. While this experiment is both promising and really non-invasive, which increases its chances for being merged.
I cannot recommend Eloquent Ruby by Russ Olsen highly enough
Write more code. Find a simple problem. Write something to solve it. Go look at other solutions. Write tests for your code. Write a testing framework, then go read minitest to see some really nice code that does it really well. Go read more code. Read libraries you use, particularly if you don't know how you'd implement something you're using. Most of all, keep writing code.
First, way to go jumping into coding with no tech or CS background! That is awesome and you can totally do this! Second, not every explanation is going to find a way into your brain. Sometimes you need to hear something explained a different way like four or five times, in different contexts, before it clicks. Instead of struggling to understand one explanation, try seeking out new explanations. Third, I found that I was able to passively absorb a lot of unfamiliar CS concepts by listening to a lot of talks. If you're like me, listening/watching talks can be a FAR more efficient use of time compared to books--which I struggle to get through quickly. There are plenty of reasonably priced, very high quality services out there like Pragmatic Studio (https://pragmaticstudio.com/courses/ruby) and Lynda (lynda.com), but there are also a ton of amazing free talks on Confreaks (https://confreaks.tv/), Railscasts (now free! http://railscasts.com), and Youtube (of course). You might not think you're getting much out of the talks or that they're mostly just entertainment, but they will make a lasting impression and you'll find yourself remembering them even years later. Some of my favorite presenters have been Uncle Bob ("Architecture the Lost Years"), Dave Thomas ( https://www.youtube.com/watch?v=X2sgQ38UDVY ), and Sandi Metz ( https://www.youtube.com/watch?v=zc9OvLzS9mU ). See also: https://www.reddit.com/r/ruby/comments/2qavfn/what_are_your_favorite_rubyrails_conference_talk/ Fourth, like any new language, the more time you spend immersed in it, the faster you'll absorb it. So along with your course/reading/listening to talks, try getting a mentor, listen to podcasts (RubyRogues, Developer Tea, etc.), and if there are any Ruby meetup groups in your area go to them! EDIT: Oh, also, don't worry too much if some parts of a talk seem to go over your head, like if someone throws out the word "idempotent" or "singleton" or "tuple", you'll hear those again and again, and you'll probably look them up more than once, but soon you'll find yourself using them to describe stuff. It's weird. 2nd EDIT: Also, don't worry too much about remembering everything. I've been coding RoR professionally full-time for close to three years and yesterday I had to look up how to sort an array alphabetically. 
I second this book! This book took my Ruby understanding to a whole different level in 3-4 days that it took me to finish it. I recommend this book to everyone aiming to get better with Ruby. 
Very excited to see what might become true when Ruby 3 released
Get books by Sandy Metz it will sure help with understanding OO design. 
Practise, practise, practise. Read, read, read. Talk to peers, no such thing as a stupid question......
Anything that is IO bound which needs to run concurrently. I made https://github.com/socketry/async to try and solve the problem. It implements an event reactor in C. The actual project was RubyDNS. https://github.com/socketry/rubydns
I did a few CLI applications which - while totally working - may not have been the best target for Ruby. The most interesting thing in terms of "make it work" was my wrapper application for Minecraft servers. It's Ruby and I made it work on *Windows*, yeah you heard right. Since I require symlinks this lead to [hacks](https://github.com/2called-chaos/mcl/blob/master/lib/mcl/windows_hacks.rb) and hence, on windows, it must run [with elevated privileges](https://github.com/2called-chaos/mcl/blob/master/lib/mcld.rb#L29-L42) while on *nix it [prevents you](https://github.com/2called-chaos/mcl/blob/master/bin/mcld#L13-L18) from doing so... My favorite windows gotcha: [Setting the path with `setx` has a 1024 character limit](https://github.com/2called-chaos/mcl/issues/13) Was a pretty funny project though :) If you (d/c)are: [Github](https://github.com/2called-chaos/mcl) and [Project site](https://mcl.breitzeit.de/) --- Also a fun project but hadn't had any real problems (except for speed because I reindex everything after every change): [DLE - Directory List Edit](https://github.com/2called-chaos/dle) - *edit file structures in your favorite editor!*
Is remote welcome?
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [2called-chaos/mcl/.../**mcld.rb#L29-L42** (master → 7e00b76)](https://github.com/2called-chaos/mcl/blob/7e00b76bea55d45f3430919b85fb091745510424/lib/mcld.rb#L29-L42) * [2called-chaos/mcl/.../**windows_hacks.rb** (master → 7e00b76)](https://github.com/2called-chaos/mcl/blob/7e00b76bea55d45f3430919b85fb091745510424/lib/mcl/windows_hacks.rb) * [2called-chaos/mcl/.../**mcld#L13-L18** (master → 7e00b76)](https://github.com/2called-chaos/mcl/blob/7e00b76bea55d45f3430919b85fb091745510424/bin/mcld#L13-L18) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dncn8hn.)^.
Sadly, no. I will amend my post to reflect that. 
A Lineage II MMORPG server (ported from the [L2J server](http://www.l2jserver.com/) which is written in Java). - The garbage collector fires up rather frequently and the brief lag gets annoying. Even if nobody is currently logged in. - I use [concurrent-ruby](https://github.com/ruby-concurrency/concurrent-ruby) to deal with periodic/delayed tasks and so far it has been serviceable. - 1,697 files in my lib folder make requiring stuff a pain in the ass so I use [require_all](https://github.com/jarmo/require_all) although it messes up (or outright swallows) backtraces if an error happens while the server is booting up. - L2J uses lots and lots of enums and I didn't like any of the gems that implement them so I rolled my own. - I use [nio4r](https://github.com/socketry/nio4r) for nonblocking IO and it works great so far. Its ByteBuffer class is rather slow and limited (it can only write and read strings) so I wrote my own using FFI pointers. - Ruby doesn't have method overloading like Java, and sometimes a method in L2J can have like 10 overloads. Most often I check the types/respond_to?. Less often, I use methods with different names for each overload (remembering each one is hard!) and only in the most egregious cases I resort to using [contracts](https://github.com/egonSchiele/contracts.ruby), but only for methods that are called VERY infrequently because the performance is terrible. - I've been putting of working on things like zone boundaries (this territory belongs to that castle, this area burns because it's lava, etc.) and others that require calculating polygons and lines because math is not my thing and the gems I've seen so far don't come remotely close to what Java has. - XML parsing is not as awful and slow as I thought it was going to be in a project that uses it so pervadingly. When the server is booting up it has to read hundreds of XML files with the properties of each skill, item, NPC and all sorts of things. I have a small abstraction to be able to use either [REXML](https://ruby-doc.org/stdlib-2.2.3/libdoc/rexml/rdoc/REXML/Document.html) or [Nokogiri](http://www.nokogiri.org/). - I've been using ActiveRecord for the database and that has complicated things when trying to run the server on JRuby. No problems with MRI in Linux/Windows/OSX. Some of the obstacles I've found have probably more to do with my lack of experience or with trying to ape Java where I shouldn't.
Stuff that they were the boss of. Maybe I am wrong, but have they contributed to projects they don't control?
I use AWS opsworks for an app. Pretty happy with it. And I have another on cloud66
You might want to consider using jruby. You will gain the ability to use real threading and (assuming that you have the xsd files) can use jaxb to parse and manage the xml.
I intend it to be able to run on JRuby but I don't want to make it mandatory.
twitter, github
ya no kiddin who wants to live in NYC
&gt; I've been using ActiveRecord for the database and that has complicated things when trying to run the server on JRuby. No problems with MRI in Linux/Windows/OSX. Interested in more info on this. What sorts of problems are you having with AR on JRuby? Also, if you had to do it over, I'd consider Sequel instead. I've got no real problems with AR, I like it enough and haven't had any significant problems with it (like you seem to have), and use it without question when doing a standard Rails app. But when doing anything that isn't Rails or that isn't an HTTP server, I start with Sequel without question either. And I'd consider it for something in Rails that is an HTTP server, if I had specialty needs. 
Roughly 9 million people.
There were errors installing the database drivers and getting ActiveRecord to use them. It has been almost a year since but I think that ActiveRecord was complaining about the driver not being compatible despite being written specifically for JRuby. Perhaps it would work if I tried it now. I've seen Sequel being recommended over ActiveRecord a few times. It's something I will look into before implementing more things that depend on the database. 
I could crush this job, from Seattle...
I find it useful to do it for my own custom tasks too though. 
Welcome to the programming and Ruby world! :) &amp;nbsp; Many folks have given some great suggestions, such as read Eloquent Ruby by Russ Olsen, practice more, and listening/watching talks. I think all these should be sufficient to help you level up. &amp;nbsp; Since you mentioned you are struggling logic based things, you can check out Discrete Math courses. It's a course in the CS curriculum dedicated to "logic based things". I did a quick search and found these two free courses: [Coursera: Discrete Mathematics](https://www.coursera.org/learn/discrete-mathematics) [MIT:Mathematics for Computer Science](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/) &amp;nbsp; By no means, you have to take these courses to get better at logic things. I still think practicing more and programming more is the best way to go. But these courses will give you a very solid foundation. You can just watch the videos for fun if you want. &amp;nbsp; Happy coding!
Me. I love it here! Cost of living is a downside but software developers do ok. The only thing I don't like about New York is how rare grass is. I miss grass. 
This is really a lesson to me. The language can be spec'd in a few days. The runtime takes engineer-decades to really polish. I think LuaJIT is the one exception to this rule. AFAIK, it's mostly the output of one amazingly talented fellow.
The title should probably say "NYC" instead of "Northeast" then, since you have to live in NYC to do the job?
It's a fair point, but the company is open to relocation, so if you live in the northeast you might be willing to relocate to NYC. (More willing than say, someone from California). 
Why don't you link the actual URL instead of your Tweet? https://github.com/ruby/ruby/blob/e3bb5c4ba3470b0e5803434ab7506591c8bc6cf4/NEWS
Big, asynchronous and concurrent data pipelines. What was I thinking!? Tried it with Celluloid initially — was a massive disaster. Ended up resorting to manual threads and Ruby's built in SizedQueues, which was also horrific, but at least it worked. Would not try to use Ruby for something like this again.
You have an instance method and want to call it as a class method. Read about class methods and instance methods in Ruby. 
No worries - just wanted to check before I share it with others
Please do, haha. Share widely and wildly. Profligately. 
can i wear jeans and tshirt
Do you want an instance or class method? if it's instance ,you need to first instantiate an object of the Foo class, then you can call the method on your Foo object. If you want evaluation1 to be a class method, then it needs to be defined as such, i.e. def self.evaluation1 or Foo.evaluation1,
\^ This With an instance method, you're telling a specific object to do something; this usually changes or reads from that object's state (object.getX, object.calculateY). With a class method, your function is separate from any specific object's state.
The job description says "Start up culture." I think "Jeans and tshirt" basically defines start up culture. Shoot, I'm wearing a tshirt right now. Although you wouldn't be working where I work. I work at untapt. The job is not with untapt.
If it's really order of operation of your callbacks you care about, `around` is kind of a workaround to accidentally get the right order of operation, but as soon as you have other order-dependent `around`, it'll break too. 
cool so tight shorts and mesh tank top?
I....I'm really curious as to how that would go over. 
also top hat and monocle but i wanted to see what you'd say before i finished off my sweet outfit
I still want to see it. 
Hi all, Let me put it this way. On this website, https://gist.github.com/malandrina/3744867 it lists a Class called RPNCalculator on the second example. I know that if I delete the class tags, I can call one of the function using string = evaluate('11+') puts string If I keep the class tags there, my code above doesn't work. How do I not delete the class tags but still call the function within it? Thanks, Bill
To clarify the other posts with an example: class Foo def self.static_method(text) puts text + ' is generally great!' end def instance_method(text) puts text + ' is great in this instance' end end Foo.static_method('Tim') foo1 = Foo.new foo1.instance_method('Bob') Note the "Foo.new" call, which takes your class and instantiates an instance of that class as an object. Hope that helps!
Thanks!
Bookmarked. Thanks!
I think you are missing the point of the getter and setter methods, which is one of the central tenets of OOD: encapsulation. Variables are not "passed" from one object to another. Each object is responsible for its own variables so that they are implemented and handled correctly. If this seems too locked down, it is "by design" (pun intended). I am upvoting your post, because it is a very good question about OOD.
Thank you so much! That's exactly what I needed to understand!
I'm not sure it's that I don't get getters and setters. I'm trying to follow the way of modeling classes as real world items. Based on that I have, as an example, a class that pulls up various lists. Whatever is involved in list making is in that class. I have another class that lets a user choose which list they want. It's how to get the two classes to work together, in correct OOD patterns that is eluding me. 
Or you could just use .is_a? Numeric
You need to think in OOP in terms of passing messages from object to object. Every function call is actually sending a message to an object: a request for it to do something. If I have a car object, and I want it to toot its horn. I'm not going to ask him for his horn and toot it, no, I'm asking it to do the tooting himself. The car object in turn asks it internal horn object to do the actual tooting, but from the outside I don't know and don't care how the car manages it. 
Good suggestion. Thank you. I have this now. However, the value inside of the array is still a string. I need to convert to a number somehow if the inherent value of it should be a number. Any help would be appreciated. def calc(input) array1 = input.split(//) # // splits into individual characters array1.each do |i| puts i if i.is_a?(String) # if i.match(/[0-9]/) Then print " this is a String" end end end string = calc('11+') puts string 
Don't model the real world. Create the world you need. You'll get better responses by posting the code somewhere. Don't be shy about getting feedback on real code. I'm trying to understand what a "class that lets a user choose which list they want" is. What does it look like? What does it currently do? You also mentioned that you have a class that "pulls up various lists" and then said that "Whatever is involved in list making is in that class." So it gathers AND creates? If you want help getting the code to work well, you need to be clear about the process you're modeling. You haven't described the work to be done as far as I can tell. Can you elaborate with more detail?
You have a capital `Then`which causes Ruby to look for a constant by that name. Most ruby code I've seen would probably not even have a `then`. if i.match(/[0-9]/) print "this is a number"
Well, for one "Then" is not a Ruby thing. if i =~ /\d/ puts "yo, its a digit" end
Sorry for the confusion and lack of details. I try not to post code so I can try and figure out the details on my own. It depends though and how many hours / days have gone by. So, I think I figured something out here and hopefully it's more in line with good design principles. This project is a file / directory explorer. Really I want it for my media, to catalog and possibly (later on) play, like audio and video. The other goal which I will start soon is to put it into a Sinatra app (running local). Anyway I"m just talking right now and really just begun to get some handle on the Dir and file related classes. Code below. 2nd to last line shows how I worked out my problem and hopefully it's a better way to pass values between objects. class MyComputer attr_accessor :dir_listing def initialize @dir_listing = {} end def change_directory(directory) input = directory Dir.chdir(@dir_listing[input]) end def set_input(number) @input = number change_directory(@input) end def display_directory @dir_listing.each_pair { |i,n| p "#{i} - #{n}"} end def get_top_file_structure Dir.chdir("/") Dir.glob('*').each_with_index {|folder, index| File.directory? @dir_listing[index+1] = folder} display_directory end end class User &lt; MyComputer def get_input input = gets.chomp.to_i end def program_wait next_command = gets.chomp end end display = MyComputer.new display.get_top_file_structure next line is how I am sending the user input to the 'MyComputer' instance, setting the instance display.change_directory(User.new.get_input) 
Why does telling the Computer to "set input" automatically mean to chdir to the directory named in the input? In ruby, you don't name classes `set_thing`, you can just do def thing=(v) @value = v end and then call: `some_obj.thing = something`. Ruby lets you define methods for `some_name=`, yup! That's a good thing to know, but in this case I think it probably doesn't make sense to have a `set_input` or an `input=`. Why would the Computer have "input" as state? At the very least, this will represent the `most_recent_input` or something. But does your "computer" really have a need to keep track of the "most recent input"? If not, it's got no reason to have an instance variable for it. Instance variables are "state", things that continue to be true once set. If you're trying to write a shell interpreter though, that may not be the best sample project. Because the next thing you are going to need is a parser, to figure out if the command really was meant to be 'chdir', and in learning to write a parser you'll be getting into all sorts of interesting stuff that probably has little to do with OO modelling. (I mean you can model an Abstract Syntax Tree conveniently as OO, but I don't think that's what you're looking to learn here....)
fantastic ELI5
Okay, fixed things up here. Dropped the set_input method and the @input instance variable. Now with the line display.change_directory(User.new.get_input) It's working as I want. Really what I've been working to implement is a way to list out the top directory and then be able to go into a sub-directory and so on. I'm not entirely sure at this point if I want to even save state on the top directory like I have currently. This is not going to be a shell interpreter though. I just want a way to catalog media files, pictures, videos and audio files. 
Ok, sorry, I don't guess I got your full meaning. And I agree, it is fairly difficult to get your classes designed so the right classes have the right responsibilities. When I was doing it in the 90s, we used something called CRC cards. I see that they are still often recommended. You might try giving them a shot.
You might want to try starting a bit top-down, what do you want the thing to do? Maybe what you want is not a 'computer', but a 'catalog'. You might want to ask it things like: catalog = Catalog.new catalog.picture_files catalog.media_files catalog.video_files Perhaps you do want to tell it what directory to start in, what directory to catalog all the items in it (and sub-directories). That might be a characteristic of the Catalog. catalog = Catalog.new("/home/jrochkind/documents") And that might actually be state that it remembers (and lets people see, but not change once a Catalog is created, each Catalog object is created for a certain directory). class Catalog attr_reader :top_level_dir def initialize(top_level_dir) @top_level_dir = top_level_dir end end And then the `media_files` method has to take that `top_level_dir`, and find all the media files in it, and return them -- as string paths, or maybe as `MediaFile` objects that can tell you something about the media file. 
It's Ruby, so there's a few ways you could do this. Checkout the [String docs](https://ruby-doc.org/core-2.4.0/String.html) and see if you get any ideas for turning strings into numbers using the built in methods for String. Might even find another way to have a String give you an array of its chars, without needing to do use the split method. 
At this rate, it could be stable by early 2019, and maybe make it into a release *before* Ruby 3.0 (which will probably be 2020).
Yes, thank you, those are great ideas. Changing it to catalog or something in that vein would definitely be a more aptly named class. My thinking though is it does need a directory to start in and should be the top level. It would give the user the ability to drill down and then choose (maybe save) any particular sub directories. 
Actually I did those for my tic-tac-toe. I read a few chapters of Sandi Metz's book "Practical Object Oriented.." Probably a known book here. Then after listening to Sandi speak about the target audience for the book, decided I am not there yet. Anyway, I did make it through the section where she mentions (might be paraphrasing) UML and various tools for design. Regardless, while my cards looked fine on the surface , I found my code actually strayed very far. I think though I will try again to use them.
What we did was refine our cards as we saw (usually in our coding) that things weren't exactly working out. In other words, if we hit a coding roadblock because the objects could not do what we had planned, we fixed the cards as well as the code, so we kept a clear view of the evolving object model. Both the modeling and the coding were involved in the prototyping and refining.
Which is why I was saying 'theory easier then practice'. Seems like the mechanics is the more difficult part for me at this point. 
Put it up on a hosting site like http://gist.github.com and let us see what you're doing. We'll be happy to provide more concrete feedback. :-)
Absolutely, once I get a little further down the road. Actually I had it up on repl.it so I should have just posted that link earlier. 
+1 for the Smalltalk reference ("think in [...] terms of passing messages from object to object")