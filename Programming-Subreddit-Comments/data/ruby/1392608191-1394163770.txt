Could it have been improved? Possibly. Would it have been improved enough? Definitely not.
And if you need to implement a bayesian filter and use it within Ruby, that'd be a good candidate for a native extension written in C with a Ruby interface. 
Yeah, that's not a call I can sit here and make, not really knowing anything about what you had going on. My perspective is that I've seen a lot of folks complain about how slow ruby is, when they did silly things like use `String#+` instead of `String#concat` inside a tight loop. Ruby is the last choice when you know you need a ton of performance, but it's not as bad as a lot of people make it out to be, IMO.
Ultimately there was no need for it to be tied to ruby, it was just one of those things which was initially done that way because we weren't sure just how slow it'd actually be. It was an experiment which failed, but yielded very useful results all the same since it gives me an idea of how much I can get away with before ruby stops being the right choice.
I have been on a puma+nginx kick lately and been getting great app performance. He is a good write up for multiple OSes: [http://ruby-journal.com/how-to-setup-rails-app-with-puma-and-nginx/](http://ruby-journal.com/how-to-setup-rails-app-with-puma-and-nginx/) Here is a similar setup with unicorn+nginx: [https://coderwall.com/p/yz8cha](https://coderwall.com/p/yz8cha)
I'm fairly new to Ruby, but I highly recommend people start with Sinatra if they're Ruby beginners who want a web framework. Its design is far more line with the Ruby philosophy than Rails is.
For the first one: Arrays were instead of hashes for a dataset that can increase in size an awful lot and needs a lot of traversal. In that situation I would say the design was probably the bottleneck, not ruby. This is a Big-O Datastructure issue (In fact, this was was level0 of the stripe CTF challenge earlier this month) Ruby hashes are constant lookup time, arrays are ... very much not. Had you used hashes instead of arrays, you probably would not have had this issue.
What version of Ruby are you using? What are the errors?
First off, I think you're using [this](http://rubygems.org/gems/inline) gem when you intended to use [this](http://rubygems.org/gems/RubyInline).
&gt; when they did silly things like use String#+ instead of String#concat I was curious: https://gist.github.com/os6sense/9047795 Ruby 2.1 user system total real &lt;&lt; 3.050000 0.000000 3.050000 ( 3.056063) concat 3.590000 0.000000 3.590000 ( 3.589266) + 3.390000 0.000000 3.390000 ( 3.384535) #{one}#{two}#{three} 3.780000 0.000000 3.780000 ( 3.778866) one#{two}#{three} 3.190000 0.000000 3.190000 ( 3.184592) onetwo#{three} 2.070000 0.000000 2.070000 ( 2.069278) Negligible performance difference on 2.1 with &lt;&lt; leading the pack.
Along with all the guides telling you to use Bootstrap, I'd highly recommend using SCSS, which Rails includes by default, I think. It's an extension of CSS3 that allows you to use a nicer syntax with many features, such as variables and mixins. Also, if you haven't, do read [Michael Hartl's book](http://railstutorial.org). It's a step-by-step guide on how the full application development process works in Rails. I know it looks like beginner stuff (and it is!), but it answers your first two questions in great detail. As for your third question, I think it's just a matter of configuring Rack, which is a part of Rails. Have a look at the docs for that.
I prefer to install the same ruby into `/usr/local` (either via ruby-install, custom package or the package managers ruby) across all machines. Specify the desired ruby via `.ruby-version` still requires that you install it beforehand. Plus `/usr/local` is pretty much always in `$PATH` by default.
@morphemass It's different problem with String#+ vs String#concat. Many programmers would write like this: out = '' 100.times {|i| out += "foo#{i}" } It's better to change 'out' variable inplace with String#concat method out = '' 100.times {|i| out.concat("foo#{i}") } Change 100 to some high value as see difference ;).
Also, I believe you'll have the best luck using this with Ruby 1.8.7.
Please feel free to create a bayes filter in userland ruby that must process 1000 unique variable length posts a second and tell me how much hardware it winds up taking. We used roughly 100,000 posts for training data. I think you seriously underestimate the issues. Optimizations could definitely have been taken further, and it still never would have been enough.
&gt; For instance, does the author of the gem matter? Not massively, but I know what to expect from some authors and it might tinge it one way or the other. &gt; What about it's test coverage? Sure, you need code coverage to be sure of what it's doing. &gt; Or, do you care if (and what) it monkey patches? If it's monkey patching, it's probably doing it wrong. &gt; Does the RubyGems # of downloads factor in? A choice of two gems of equal age where one is in use on tens of thousands of sites, and the other is on a handful means one of them is safer and the other needs a closer look to understand the drawbacks of. Downloads != Sites in use. It's why the analysis done of Gemfiles in Rails Rumble is so interesting: it shows biases not there in the download numbers. &gt; What else do you consider? Maturity of code base is important - I prefer v1.0 and above with a git commit history going back a year or three ideally. Size is important: too small and I wonder if I want that as a third party component. Too big and I worry it's bloated. It's dependency needs are important. If it needs ffi and ImageMagick, I'm going to be less intrigued by it than if it stands on the shoulders of better written code of less impact to the operational needs. I care about performance too both in terms of wall clock numbers and how well it understands asynchronous concepts. My site measures CDN bandwidth bills in the petabytes/month region and the difference between a gem that locks a process for each request into an API for 300ms versus one that releases in 10ms is huge: the cost savings achieved by using the second one pay could pay for another developer on the team. Likewise, anything that causes a memory leak or for processes to die under heavy load is going to get removed. I realise that's a rare problem/consideration to have. But it also explains why some gems are popular elsewhere but are banned on my teams now. &gt; How much do those things contribute to your decision? For me, it's up to the individual programmer to make decisions based on a bit of conversation with peers, but in some teams I've seen it where each gem had to be voted in. We're moving towards that here, because the impact can be significant, and it's worth having these discussions. On one system recently we lazily introduced devise to "speed things up" but realised we didn't need 80% of its functionality and removing it cost us 3x more than if we'd just coded what we really needed ourselves from scratch. That's the kind of situation we want to avoid. But if you produce a new gem tomorrow it's going to need to be amazing for me to roll it out next week. I'm more likely to come back in a year and see how its going and evaluate lots of things at once on a *mature* and *stable* and *consistently developed* code base.
24 downvotes from jealous non-rubyists, lol
I would suggest you (shameless plug) [freightrain](https://github.com/bolthar/freightrain) As people have said here, Ruby is not so great for desktop GUIs. Freightrain mitigates some of the issues but the big painpoints (lack of mainstream bindings, poor Windows support) are still there. And if you need help with freightrain, feel free to write me :) it's a good reason also for me to do some work on it, it's been more than 2 years now :(
Have you checked out [virtus](https://github.com/solnic/virtus)? They seem to do very similar things. Also, I love gems like this... really an important tool for a rails developer.
&gt; What is your typical development environment like? a Linux Box (Gentoo, Debian, Ubuntu), a terminal, an editor, git, rvm &gt; Do you primarily use git clones in terminal? Yes &gt; Do you use a web editor (like Coda 2 for HTML/CSS)? No &gt; Do you use a text editor like (Notepad++)? I use SublimeText or Vim. But I'd advise to pick one editor and try to work with it. [Don't waste your time to find the best, it's by coding that you'll find eventually the good one](http://blog.8thcolor.com/2014/02/which-development-editor-should-i-use-when-developing-in-ruby-on-rails/). &gt; Where can I learn about designing algorithms in Ruby? There are several good online resources to start with, especially the one where you learn by doing: For instance * [Ruby Koans](http://rubykoans.com/) * [Try Ruby](http://tryruby.org/) * [Ruby Monk](https://rubymonk.com/) * [CodeSchool](https://www.codeschool.com/paths/ruby) * [Codecademy](http://www.codecademy.com/tracks/ruby) * [Exercism](http://exercism.io/) * [Project Euler](http://projecteuler.net/) To go farther, there is some great books. To start in Rails, I would start [Agile Web development with Rails 4](http://pragprog.com/book/rails4/agile-web-development-with-rails-4) When you get a good enough grasp on the language, I would start a simple project, something that you can use yourself. You can then submit some piece on [Code Review Stackexchange](http://codereview.stackexchange.com/) to get feedback or on Reddit. There are plenty of ppl ready to help. &gt; What are the things that you presently struggle with in Ruby? Nothing in particular. But every day could be the opportunity to bump into a problem. &gt; What are some of the problems that you have had and how have you solved them? That happens often and that's the best way to learn something new. Usually, I first try to figure it out by myself, googling, looking on stackoverflow, reading several material, then if very complex I discuss it with others (online, colleagues, etc.). &gt; Did you learn Ruby for a job? Did you learn Ruby for yourself? Both &gt; Do you often use Ruby in your personal life? If so for what? Last example was crushing the notes taken on my kindle. &gt; Have you ever made a patch for something you didn't make on GitHub and then your patch was included in the next release? Yep &gt; Will you fork me like you love me? Can I fork you? Can you explain forking? I fork in two situations: 1/ I want to make a change and eventually submit it to you 2/ I use the gem/code/etc. but it's not more maintained, I fork it to maintain it. &gt; Can you recommend a blogging platform? What do most people use? Is it more common to write your own page? Do people use wordpress? Should they be using wordpress? Wordpress is good enough, or use [GitHub page](http://pages.github.com/), or [Svbtle](https://svbtle.com/).
Surprised it hasn't been mentioned yet but the gem's dependencies is high on my list of things I checkout before pulling it in to my Gemfile. For instance, I often use [ActiveRecord](https://github.com/rails/rails/tree/master/activerecord) without [Rails](https://github.com/rails/rails) which means that if I find a gem that sounds great but pulls in Rails its a no (especially if it's without reason!) Another reason (which is a touch irrational) is that if a gem does one thing with little to no dependencies then I'm all for it. [Amico](https://github.com/agoragames/amico) is a great example of a complex problem solved whilst still being very light on the dependencies front.
So basically, I should carry on with learning Ruby (I'm reading Chris Pine's book) and remember, when the time comes, to treat Rails with kid-gloves?
what's the hassle of using nginx + unicorn? i use it on a daily basis, and we use it in production and i've never had any problems getting it to behave. that and setup, at least to me, was so much easier than apache + passenger.
To setup Nginx+Unicorn (or Nginx+Puma) you need to: Step 0: Install Ruby. And then: 1. Install Unicorn. 2. Start Unicorn. 3. Add an Nginx virtual host entry for your app. 4. Configure Nginx to reverse proxy to Unicorn. 5. Configure Nginx to serve static assets. 6. (Re)start Nginx. 7. Setup an init script, monit script, or something similar to ensure that Unicorn is started on system boot, restarted when it crashes. If you have N apps, then you need to repeat steps 2-7 N times. With Phusion Passenger, these are the steps: 1. Install Phusion Passenger. 2. Add an Nginx virtual host entry for your app with `passenger_enabled on`. 3. (Re)start Nginx. If you have N apps, then with Phusion Passsenger you only need to repeat steps 2-3 N times. Note that there is no "Step 0: Install Ruby". Phusion Passenger provides [Debian and Ubuntu packages](https://www.phusionpassenger.com/install_debian) that will even install Ruby automatically for you. I'm curious, why did you find Nginx + Unicorn easier? Could it be caused by Apache? Have you tried Nginx + Passenger?
You don't automate all of that?
Ah. Nice. Thank you very much for that. Last time I did that, things became a bit messy…
Lets break down the two lines in between the do/end block: return false if array.include?(yay) This line is pretty self explanatory, I think...if you need an explanation here then treat it like an english sentence and I'm pretty sure you'll understand it :) array &lt;&lt; yay This line puts yay into the array. So, if you put this line before the other one, you're guaranteed to get false, because of course the array includes `yay`, you just added it! Edit: This is not what you asked but with a predicate method, you should always return either true or false. In this case, you're either returning a string (which is truthy, so it still works, but it's weird) or false. I'm guessing that this method is meant to ask if the year in question has any digits that are the same? If this is the case you could simplify down to something like this: def no_repeat?(year) year.to_s.chars.to_a.uniq.length == 4 end This assumes of course that the year is always going to be of length 4, otherwise, you could use `year.to_s.length` instead of 4. 
twitter bootstrap and bootswatch themes. There are gems available for both. I prefer to use the gem twitter-bootstrap-rails, and add in the theme from bootswatch manually.
Hello! Thank you for replying for my question! Just to clarify, why does the code need to be written as such: return false if array.include?(yay) array &lt;&lt; yay instead of array &lt;&lt; yay return false if array.include?(yay) To me, it looks like it would be the same either way, but the output is saying otherwise.
I'm not trying to be rude but did you even read my comment? I'll try to explain more in depth I suppose: If you do it the first way, you're checking if the array includes yay. On the first pass through, array is empty, so array most definitely does not contain yay. It skips the return and adds yay into the array. On the second pass through, now there is something in array. If it's a duplicate, we will return false right away and that's the end. Otherwise, keep going until we hit a different duplicate, or we run out of things to compare. Now, if you do it the second way, you're adding something into the array, and then immediately checking if the array contains that thing. Of course it does! You just added it! So, the second way will ALWAYS return false.
If you add "yay" to "array" first array.include?(yay) will always be true
Let's say your input is "hh" and we're doing it with the &lt;&lt; first. First loop: "h" inserted into array return false if array.include? "h" oh man, it does include it because we just stuck it in there. 
Sorry about that. I had to read your two comments multiple times to get an understand of what's happening. I think I understand what is happening with the code! I appreciate all the help :)
No worries, I just wasn't sure what you misunderstood about my first comment as you had basically asked the same question again so I was confused. If you need more help then let me know.
Here's a token of my appreciation. I hope you enjoy gold!
Agreed. If your app isn't going to be the next Twitter or LinkedIn in its first few years of life, and you're comfortable with The Rails Way of organising an app and the code that lives inside it, Rails is great. If you're doing a prototype or small demo that you're willing to put the resources into evolving as your needs change, you'll likely be quite happy with your Rails experience. If you're doing a "document-related" app that can be easily visualised as a wrapper around a database with minimal-to-no user action other than forms, you'll find Rails a good experience. People have had great success with Rails exclusively on the back end of their system, exposing an API that's used by a front end in AngularJS, Dojo or Ember, or mobile apps on iOS or Android. There's big parts of Rails you won't be using (views, obviously), but the rest of it *could* make your life easier as long as you don't stray too far from the golden path. If you go too far outside those boundaries and The Rails Way is the *only* way you know, you'll be in a world of agony, like the Twitter team that left Ruby entirely after their Rails-induced trauma. My earlier post was primarily intended to get folks to bookmark some resources or add to their reading lists, just in case they fall into that briar patch.
I'd recommend learning Sinatra, as [`/u/redwall_hp`](http://www.reddit.com/user/redwall_hp) suggested above. I wouldn't necessarily *avoid* Rails, but I'd work through Sandi Metz' [POODR](http://www.poodr.com) and Avdi Grimm's [*Objects on Rails*](http://objectsonrails.com) as first exposures that will help you build better, more survivable if not sustainable apps. I've just been burnt because our bread-and-butter app *isn't* such a Rails Way-compatible app and I went through *existential-level* flail before figuring out *how* to migrate to an architecture that will let us survive to and past 1.0 (services- and [Gem] component-based, ["vendor *everything*"](http://ryan.mcgeary.org/2011/02/09/vendor-everything-still-applies/), clean architecture with major UI-level functionality). Your mileage *will* vary from mine, but as with any other endeavour, the more tools you have in your toolbox (as supplements/alternatives to Rails itself), the more likely you are to get things closer to right on the first go. Good luck.
Any proper devops obviously would! However, many beginners are not always savvy, and some intermediates don't even feel comfortable leaving the heroku gardens. If you don't have experience setting it up by hand you also likely don't have experience automating it with puppet/chef/ansible/salt/blahblah. Passenger is a very easy alternative to those getting off heroku. 
you should move this to /r/hiring
I do... by using Phusion Passenger! Of course you can automate all those steps manually. But why should you have to bother spending an hour or multiple days (depending on your experience and skill level) when a well-written, well-tested piece of software can take care of it for you? If you do it yourself then you're even likely not to do it correctly the first few times, by missing important edge cases etc. Isn't your primary job to solve core business problems instead of micromanaging your server?
Frameworks only really produce good code when they're used by people who don't *need* frameworks -- but appreciate the time savings. Unfortunately, though, there's a paradox here. When someone is getting their feet wet in a new language, frameworks might be necessary to get them started. Otherwise, they have to stay mired in a lot of details that get in the way of productivity. I've sort of resigned myself to accepting that most apps out there are just going to be a steaming pile of dog doo-doo. There's no way to prevent it; if you take them down the "here's how to build your app The Right Way" they will either lose interest or else glue themselves so closely to the letter of the law you give them that they cargo cult away any hope of actually learning how to build a decent, maintainable codebase.
Phusion Passenger does not replace automation. It augments automation. By using Phusion Passenger in your repeatable build process, that build process becomes much smaller. I find reducing the number of steps by over 50% pretty significant. Plus all the config files that I do have to write, are much smaller as well. I mean [check this](http://vimeo.com/phusionnl/review/77539358/b02870dc87), at the 4:45 minute mark. Look at all that copy-paste work you have to do with reverse proxy rules, reduced to 2 lines. Granted, for you and me, the difference between Phusion Passenger and Unicorn is maybe 10-15 minutes including testing. But I've talked to many people who just can't seem to understand what a reverse proxy is, or even how processes work (let alone what processes are). For example I've encountered a lot of people who don't know how to restart Nginx, don't know what /etc/hosts is, etc. And even for me, if my app hosts more than 1 web app then configuring daemons for every single app quickly becomes a pain. For many other people, those 3-4 extra steps can literally mean a few days.
Then for now you will have to use something else that Drone. And it also means you don't want to use GitHub's hook system, which is fine. The Drone team have self-hosted Git repos on their roadmap, I guess this will also come with other ways of triggering a build...
Yes, there are Docker hosting services, but I never used any of them. I use Digital Ocean, they have a pre-built Docker image if you want, too. If you are looking for something even easier than that, I suggest you use Codeship, Circle CI, Travis CI, or any other CI as a Service out there (there are tons!).
Post your code and I'll benchmark it / profile it on JRuby. As of Java 7u40, JRuby code can inline with/just like Java, as well as compile directly to native code via the HotSpot JIT compiler(s). This sounds like exactly the kind of thing that would benefit from JRuby's optimization potential.
Heartfelt agreement. Sometimes, a framework will explore useful/interesting nooks and crannies of the language it's implemented in as example code — and then let you choose what pieces to use without penalty. (The early C++ [Boost](http://www.boost.org) libraries were good examples of this.) However, "opinionated" software, like Rails, tries to give you a near-complete application that you "just" plug your own code into strategic places within. Too often, those are pitched to newbies with click-bait like "Write a Complete Blog System in 30 Minutes or Less". Newbies follow the tutorial, try to adapt it to their own projects in cargo-cult fashion, wonder why they feel so much pain trying to maintain or extend what they've built, and give up and move on to something else. The experts get ticked off by the decisions made for them that in their opinion are just *wrong* (*my* pet peeve is ActiveRecord models containing domain logic), and fight like mad to turn their existing mass of framework code into something else while still meeting deadlines. But at least they *can* work around them as well as work *with* them when it's convenient to. And your last paragraph is something I've been living with for *years* now. Call me slow, but I haven't yet proceeded along the [Kübler-Ross model](https://en.wikipedia.org/wiki/Kübler-Ross_model) to the "acceptance" stage yet, and have generally regressed from "depression" to "anger" recently. We *have* to be able to do better than this.
Alls I can say is "cheers." If it were *that* easy to build scalable, maintainable codebases, everyone would be doing it. You're probably just coming to grips with the fact that you're on the right side of the bell curve. There are worse things in life, so cheer up! The only thing I can really offer to those folks just learning application architecture for the first time is to practice refactoring, always. Our goal is to make software maintainable and extensible in the future. The only way to do that is to learn what makes code easy to change, and what makes it hard to change. The only way to do *that* is to practice changing your code. Hence refactoring :)
Even if I could post it (which I can't, it belongs to the company) I can benchmark my own code. I don't really need help there. Thanks for the offer though.
[state_machine](https://github.com/pluginaweek/state_machine) gem could be useful for your state machine. The web is stateless yet, but you could load the "state_machine"object into a session. You'll have to do the ground work and integrate it with a timer and then define your states to react as they are supposed to though. Im not entirely sure here as i'm not certain of how you'd be implementing it. Just a thought though 
Much to the same, Ruby isn't exactly very strong on front. How about we fix it then?
You raise an excellent point. Ruby doesn't *have* to be difficult to integrate with existing UI frameworks on Windows. But someone (or somefolks) will have to build the integration that's currently missing. That's a tough sell for a language community that is unix-focused and which has primarily thrived serving websites. Maybe it would be useful to brainstorm about what would be required to create first-class Windows GUI applications. Currently, the options I'm familiar with (though it's been a few years since I've worked with desktop apps) are: 1. The Windows Win32 C API. This is a collection of C libraries that may be called from any language with appropriate bindings. Ruby could (and may have already) call and manage objects created through the API. 2. The Windows MFC C++ framework. This is a set of C++ primitives and a runtime that abstract the Win32 API into a more object-oriented world. Ruby has the ability to interface in a limited way with C++ APIs, though the MFC's specific dependencies on Microsoft C++ do pose some challenges. 3. The .NET WPF API. This is a collection of .NET classes and a runtime that abstract the Win32 APIs as well as integrate with the kernel on their own to present a well-evolved object-oriented GUI framework. Unless I'm just unaware of the ability, non-.NET languages can't seamlessly manage this library. IronRuby was a .NET implementation of Ruby (similar to JRuby for Java) that had the ability to call and manage .NET code, but I think that project is dead. Please correct me if I'm wrong :) So of the three options, dealing with the Win32 APIs directly would provide the least resistance to integration. But that would still require significant engineering effort to present an attractive API. MFC integration would be difficult, but would perhaps be a more attractive programming model to translate into Ruby-land. Both options would require a large effort, on par with Laurent Sansonetti's Herculean work on RubyMotion to integrate with the OSX and iOS APIs. And maybe that project can provide a roadmap for this goal, if someone is willing to take the leap.
Aware of the gem, but like any other state transition gem it does not have support for implicit time-based transitions and I'm going to have to code around that with a long-running task somewhere or subscribe to an expire event in Redis or something. BTW, AlterEgo looks a good alternative to state_machine
For queues I prefer SQS or Resque depending on context. In this case I'd probably use SQS for ease of managing availability, I'm not sure what advantage beanstalkd offers over either SQS or Resque, TBH.
Ahem. size matters.
It's not easy; I never meant to imply that it wasn't gruelling, thankless work in dire need of far better tools than we presently have (which are themselves far better than we ever have had previously). But, any day now, there's going to be a software-driven [New London School explosion](https://en.wikipedia.org/wiki/New_London_School_explosion)-level disaster that's going to cost lots of people their jobs and fortunes (if we're lucky) or their lives (if we aren't), and politicians the world over are going to start waking up to the ideas of "duty of care" and "fitness for purpose". Then things are going to get much harder for a lot of us than they already are, since commercial software is defect-free almost as often as I win millions in the lottery (and I never buy tickets). ---- Refactoring is the single most important skill for a software developer, in any language; I'll agree with you there. But, as I believe was originally stated by "Uncle" Bob Martin, the purpose of full test coverage is to give you the *freedom* to refactor *and know your changes actually work*. And most of us are Doing It Wrong, even with years of experience under our belts. One of the things I learned from being around medical folk (including an ex-gf, an RN who practically ran the perinatal CCU at a good-sized hospital, is &gt; If you don't write it down, it *never happened*. At least, not in the way you *think* you remember it, and the details you've forgotten will be the most critical ones. As software practitioners, we don't know how to do that; we've been conditioned by the bean-counters to think that engineering discipline is "too expensive", and by the epic-hero hackers to think it's "too difficult" for us to bother our pretty little heads with. Continuous refactoring backed up by comprehensive test coverage and analytic metrics is the biggest hole we've found yet in those arguments; we need to exploit it pervasively and enthusiastically as we work furiously at refining our craft.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**New London School explosion**](http://en.wikipedia.org/wiki/New%20London%20School%20explosion): [](#sfw) --- &gt; &gt;The **New London School explosion** occurred on March 18, 1937, when a [natural gas leak](http://en.wikipedia.org/wiki/Gas_leak) caused an [explosion](http://en.wikipedia.org/wiki/Explosion), destroying the London School of [New London, Texas](http://en.wikipedia.org/wiki/New_London,_Texas), a community in Rusk County previously known as "London". The disaster killed more than 295 students and teachers, making it the deadliest school disaster in American history. As of 2014 [[update]](//en.wikipedia.org/w/index.php?title=New_London_School_explosion&amp;action=edit), the event is the third deadliest disaster in the history of Texas, after the [Galveston Hurricane of 1900](http://en.wikipedia.org/wiki/Galveston_Hurricane_of_1900), and the 1947 [Texas City Disaster](http://en.wikipedia.org/wiki/Texas_City_Disaster). &gt; &gt;==== &gt;[**Image from article**](http://i.imgur.com/B7jxT1x.jpg) [^(i)](http://commons.wikimedia.org/wiki/File:New_London_school_explosion_of_1937_newsreel.ogv) --- ^Interesting: [^New ^London, ^Texas](http://en.wikipedia.org/wiki/New_London,_Texas) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfi7c9d) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfi7c9d)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 61259:%0Ahttp://www.reddit.com/r/ruby/comments/1y313x/dev_confession_maybe_ror_isnt_so_bad/cfi7c5x)
Yeah, all of this. I think anyone who actually practices true red-green-refactor arrives at the same conclusion: complete *and* fast test coverage is the only way to go. If you're not under the covers of valid, passing tests, any attempts to actually refactor code are pretty much guaranteed to break everything. Most people confuse refactoring with rewriting, anyways. Events like Healthcare.gov should cause people to demand more quality from their engineers, but bean counters have been trying to marginalize us for a while, and they'll probably try throwing more quantity at it -- more "QA," more oversight, more planning, etc.
OK, that isn't immediately obvious on the docs, but with a bit of digging what you're suggesting is using beanstalkd to create a message for a job to kill the object with a TTR at 2x seconds and then on a heartbeat, you "touch" it and it resets the TTR. Once the TTR expires, the message gets delivered, and the job runs and the state transitions. Is that how you were imagining it? I was thinking about doing something similar with SQS message delays, but I don't think you can update the delay seconds on a message once it's created. I might try that though.
I like Javascript's lack of private methods, and you can do some awesome things with prototype chaining.
I like this too. I'm currently working through a book on the Corona SDK and was pleased to find that Lua also has this.
Erlang's tightly integrated message passing concurrency is a marvel.
Whats the point of not having private methods? In Ruby you can call all private methods if you REALY want to (via instance_eval)... So its more like a hint "don't use this unless your really really want to"
When everything is forced to be public, you have to put a lot more thought into your instance methods.
makes sense, I believe I never even used private once in ruby tbh. So I assume this to be me a relatively small advantage feature... (also I haven't seen much code using private methods really)
AWESOME! I've completed the tutorial for levels 4-6. It will be released March 1st. I'm currently writing and aiming for March 15th for the finally.
I like IBM RPG Greenness I like Java class names ([AbstractSingletonProxyFactoryBean] (http://docs.spring.io/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html)) I like French deep inconsistency (said as a French speaker) I like Cobol uppercase'ness (the only language [that shout](http://lh4.ggpht.com/_sQvdFWqMlMg/Sxr5vOyB_ZI/AAAAAAAABQ0/5owylTq6ytg/Image04%5B2%5D_thumb%5B3%5D.png%3Fimgmax%3D800)) I like whitespace cleanness (How can you get [writer's block](http://en.wikipedia.org/wiki/Writer's_block) when there is nothing on the page?)
I like Python's significant whitespace.
Or you end up being reluctant to write helper methods out of fear that you'll have to maintain them as part of the public API forever.
1. No pipelining 2. No pre or post-build triggers 3. no shared configuration unless you roll your own. etc This is a great idea, and I like the minimal configuration compared to jenkins, but calling this a 'fully working CI server' is very naive. At the very least I'd expect the ability to chain builds and pass command line parameters to builds without needing to edit the build scripts. 
I use private methods in Ruby (and other languages). They indicate that those methods are subject to change and are part of the internal implementation details, not the public API of the class. That way I know that I can completely remove, replace, or refactor those methods in the future without fear of breaking external code.
On a brief reading I think this will encourage people to link business logic to web routes. While this may be ok for small-scale projects, it doesn't scale well in large codebases. Also, your stackable verb support e.g. get post put :user, def multiple_methods »I intercept GET, POST and PUT methods on /user/.« end doesn't lend itself to easy inspection. Sinatra (the framework I use by choice for rest-like frameworks) is quite a bit clearer, even if it's more verbose get '/user' do end post '/user' do end Finally, a route like this: get :api, :version, def version {version: 1.0} end is slower for me to parse than get '/api/version' do end All of these are stylistic arguments drawn from me working with Sinatra on a day-to-day basis with no real use of your gem, but my initial impression is that the syntax, while nice, doesn't lend itself to high-speed reading as you need to pay attention to commas, symbols and normal methods. 
You are obviously used to Sinatra a lot, therefore you are not a primary consumer :) However, with REST support which resembles Rails': put '/user/:id' do params[:id] end patch '/user/:id' do params[:id] end is IMO worse than: update def upd(id) id end or if I allow blocks, not just def's: update do |id| id end Thanks for your comment!
This is exactly how I wrote classes for a long time. It worked well, but a pair turned me on to the idea of refactoring away all methods you'd *want* to be private. I was skeptical, but I gave it a shot, and I ended up liking my code more. Of course, nowadays I do sprinkle a few privates here and there, but not nearly as much as I used to. When I say I like JavaScript's lack of private methods, I'm saying I like what that constraint does to the design of my code.
Can you explain what you mean by "refactoring away"? It sounds like you'd be combining them into single monolithic public methods, which is the opposite of how I approach refactoring.
Did not know about OpenStruct, thanks! I've used method_missing before to allow dot notation, it worked OK but always felt a little skeezy.
Yeah, I am definitely *not* into folding those private methods back into the public ones. What I mean is, following the smell of "I don't want the outside world to be coupled to this method; it's an implementation detail" -- well if it's an implementation detail that you want to hide, it likely belongs in another object. That could mean building a small `module` with some singleton methods, a `Struct` subclass, or standing up new class. If your public API is the "captain" of the ship, the captain should be delegating *all* responsibilities to lieutenants. The captain should have no responsibility *other* than delegation. Keeping the entire class at the same level of abstraction is a key element to cohesion. I phrased that as an absolute, but it just takes practice and judicious critical thinking to apply it in the real world; practice makes perfect, and sometimes I break the rule when it makes more sense.
Good thoughts, will definitely think about this as I plan future classes. Thanks for providing a deeper explanation of your approach.
This needs an opening paragraph/ abstract. It should hit the major points: This is a new routing method that uses X so you can Y. This is (a general improvement| better in certain situations) because of Z. For example, if you're building A you would just... And then what you have. Also, strikes me as a security concern to have anything from the user being used to create a new method. I'm no hacker, but I could see it being a field day for one.
Sort of same reaction as Floppy: I see the difference with Rails (regarding the routing syntax, did not go much further), but can you tell me why it is better? Or what it is better at? I'm all for having different tools for different job, what would be the ideal case for Rubko? Rails routing is "good enough" to me, ie, while it can certainly be improved, it is not something I struggle with, so the ROI of having something better would be small.
The main advantage is: Instead of having a huge global (app-wise), routing matching, like this (Rails example): https://github.com/gitlabhq/gitlabhq/blob/master/config/routes.rb the behaviour is encapsulated on per-controller basis.
rails is the slow one ruby is not that slow: http://hlxwell.github.io/2012/02/11/eventmachine-vs-node-js-performance/ 
I like Haskell's clean syntax, pure functional style and unrivaled type system. I like how C# manages to harness such a powerful syntax in a statically typed and performant language. I like how Javascript runs in my browser. I like how Coffeescript prevents me from having to write Javascript. So that's all languages I regularily use besides Ruby. All other languages I've encountered thus far are pretty sucky in comparison I'm afraid. Python has cool significant whitespace, but its OOP isn't pure enough (too many helper functions). Java is too rigid and verbose. C could have been clean but lacks namespacing, proper modules and has a few too many weird cases in its syntax. C++ has too much baggage. Languages I haven't had the chance to really get comfortable in but seem interesting: Go, Rust, Clojure. People are positive about Erlang, but I get the feeling the whole distributed thing is a bit too much part of the language. I like my complex features in loadable modules. So.. those are my [opinions](http://i.imgur.com/m5T4JYK.gif)... 
Thanks! I'll try running it, though I must wait a bit, as I need to boot to a unix-like system. I will post my results. **EDIT:** I don't want to deal with Cygwin right now.
In addition, I think that looking at the quality and quantity of documentation relating to the gem is something to consider.
The fonts on that blog almost gave me a seizure. Seriously, why?
Another question, how is the syntax different from Padrino, which allows named Sinatra routes grouped into controllers: App.controllers :api do get :version do json {version: '1.0'} end get :user, map: '/users/:id' do json User.get(params[:id]) end end 
Nice :) I'm looking forward to seeing your take on it.
Amen. Having a basic example in the README in necessary, and having full docs available on RubyDoc.info is almost as important.
Ruby is pretty slow as well. As in I believe that it's the slowest of all popular languages. The test is not really painting the whole picture as it measures only networking performance as the server does not have to do much processing since it just returns "hello world". Nonetheless, any real application will also do a lot of processing on the server (e.g. routing, creation of HTML from templates, processing data returned from DB) which will most definitely be slower in Ruby. So you should be looking at some CPU bound benchmarks as well E.g. http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=yarv&amp;lang2=v8&amp;data=u32 That being said, one should take those benchmarks with a grain of salt but I think that the trends are correct. 
There was a very good talk at one of the ruby confs (Damned if I can remember) on how to write forwards and backwards compatible code to deal with things like migrations and different versions of the same codebase running at the same time. Following those practices will always allow you to do a phased-restart. Cannot remember the presentation though :(
It's a really fast and easy way to make desktop programs for Windows. I used it two weeks ago, and even though I felt really dumb, it got the job done. (I used VB instead of C# because I still remembered a few parts of it from a required class a few semesters ago.)
So... I'm relatively new to Ruby, and I've been using shell scripting (including bash, but also csh, ksh, over the years) for many years. Keep that background in mind for the following: IMO, Ruby is to be preferred for many reasons, other than what you listed, and, to my understanding, bash has the things you said ~~Ruby~~ it is missing, and Ruby has built in the things you imply it's missing, unless I don't understand your thinking. Specifically: bash does have functions (consult a shell scripting book, or man bash and search on function), and you can achieve much of what modules provide with "source". In terms of "better" error checking and error return... depends on how you are currently testing; I'll grant that "[", "[[", and "test" aren't exactly super friendly, but they, together with $?, get the job done. For Ruby: foo = `command to exec` # foo gets output result = $? # result gets exit status code This is almost exactly what bash has... no gem needed and no advantage to either language, based on these limited examinations. I'd still far rather have the power of Ruby available for when my basic little script needs one more feature that becomes tricky in bash but is easy in Ruby. HTH. Edit: meant to say it (bash) above, not Ruby.
I use [mixlib-shellout](https://github.com/opscode/mixlib-shellout/) for all my 'shell' stuff by I try to write as much as possible in native ruby. Sadly, GNU, BSD, and SysV systems all have variants on common UNIX commands. You can't really trust that arguments will be accepted in certain orders, or at all unless you're dealing with posix. Even then, tar != gtar != star etc. =) (sorry, rant). Another option is [mixlib-cli](https://github.com/opscode/mixlib-cli). I haven't personally used this, but many projects that I use do, and its pretty good. Thor is pretty good, I've used it a bunch. The thing to remember when writing 'scripts'. Thor will be your user interface. You're going to specify a run list that can be one huge mess of a script, or you can compose it from smaller methods, or classes. Even when I'm writing a 'script' I try to follow general programming rules. Never know when something is going to become important, and its nice to be able to write tests and validate your scripts =)
Oh yeah, [last commit was 3 years ago](https://github.com/jacius/rubygame/). Always look for that, first thing.
It's true that an alternative memory allocator will probably yield noticeable performance gains. With Ruby Enterprise Edition, we shipped tcmalloc and it made things a bit faster.
Thanks, but nope. Roughly 13 years w/ OO (initially C++ and Java, added others over the years). I wasn't actually trying to show full error handling, just how to "simply execute some system commands", and grab the results, such that errors could be handled. There is a fairly strong school of thought that decries exceptions as being too expensive: * [Google coding standards](https://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Exceptions) * [LLVM/CLang coding standards](http://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions) I realize that most of the arguments in support of banning exceptions don't really apply to interpreted scripting languages, but I wasn't trying to wade into the debate about how errors should be handled. Both bash and ruby give you the basic tools to handle errors. Ruby has many, many language features and reasons to be preferred, was just trying to point out some ways to get equivalent behavior to bash. From your original question, I wasn't sure what level of background you had; didn't read through post/comment history, so I didn't want to assume you knew all the ins and outs of exception handling. GL with your development efforts :-)
 class ApiController &lt; Rubko::Controller get :version do {version: 1.0} end end /api/version class UsersController &lt; Rubko::Controller show do |id| User.find id end end /users/12
I still do not understand how this differs from Padrino. Have you done a comparison between Rubko and Padrino?
Enough to know to use [Gosu](http://libgosu.org) instead.
love the game! +/u/dogetipbot 1 doge
This is one of the better use-cases for refinements that I've seen. But for production code, I am still very skeptical.
- I like Python's significant indentations, as well as the module/import system. - Haskell's type system and pattern matching, of course. - Javascript's prototypical object model can be used to great effect. IMHO there's no need for those class-like APIs some people throw on top. obj['foo'] == obj.foo is also very useful. - PHP has closures now, so I guess that's cool. - Informix 4gl's embedded SQL and iterator where phenominally easy to use. SQL was embeded right into the code - didn't even need to be a string. You could pull local $vars into WHERE conditions and iterate rows directly into a local struct. As easy as ActiveRecord really, but without mountains of code behind the scenes. Of course it wasn't exactly a general purpose language...
I'd say shell scripting in general. I use bash, zsh and ksh. My favorite is the Korn.
I think refinements have a good use case for things like `active_support/core_ext/string_extensions` -- I'd imagine being able to opt in/out of the `String` monkeypatches on a per file basis would be pretty cool.
I do too, didn't particularly care for one fellow developer's monkey patch to Hash to give it the same behavior...
I miss Python's import/module system, docstrings, decorators, and built in generators (with list/generator comprehensions). Also the `with` statement is pretty nice. Most Ruby libraries get the same behavior out of blocks, but `with` externally ensures that resource disposal happens in the face of exceptions, which makes it easier to write things that use the interface.
Good point. In my real world problem, `query_options` is being used to search, sort, order, etc the results.
Oh, cool. I get to watch the examples as they're typed out. So much more efficient than just reading at my own pace. The Future is Now.™
So annoying.. people are actually argueing that it is ugly to reopen classes like Time and Date.. in *ActiveSupport*. I wish people like that pmarrek would stop wasting Rails coredevs time. Applying DI on the initialize of ActiveRecord objects is just crazy talk. I think the Time#travel methods fit within the scope of ActiveSupport, it's not a matter of dependency management. If something fits within the scope of your project, you can pull it in, regardless of whether gems exist that do what you want. Of course you really have to ask yourself if the code really is within the scope of your project.
+1 this. People stuck maintaining shitty rails apps think that the framework is what caused their apps to suck. Then they start parrotting every OO related pattern as the remedy -- I swear if I see Uncle Bob's Midwest Keynote linked one more time I'm going to go insane. Many of those patterns patterns have a place, but only after you realize that the tool isn't the problem. It takes a lot of time and practice to learn how to write maintainable, flexible code that is easy to understand. When you do, Rails will never get in your way, because you'll know exactly when it's there to help, and when it's staying out of your way and letting you do your thing.
C is for data. That's good enough for me!
if I understand your requirements correctly you are talking about string interpolation. def warn_user(animal) animal ? false : "#{animal}_not_found" end dog = input.match /dog/ warn_user(dog) Your requirements sound a little wierd and could probably be done better. If you post more code we may be able to change the design so that you do not need to do this.
Ah I see how that wasn't a very good choice of variables. more like: animals = input.match(/animal:(\w*)/)[1] warn_user(animal) people = input.match(/people:(\w*)/)[1] warn_user(people) def warn_user(thing) puts "#{thing}_failed_to_find_match" unless thing end output: animals_failed_to_find_match people_failed_to_find_match else do nothing 
Hello, I'm trying to make sure I understand the issue, so let me know if I'm solving the wrong thing. Have you looked into re factoring into a method def warn animal temp_animal = animal warn_user "#{animal}_was_not_found' unless temp return temp end Then you can do dog = warn 'dog' cat = warn 'cat'
Similar but if animal is not matched, then it will be null so that would warn_user '_was_not_found' but I want it to say animal_was_not_found. The problem is I want this to work for anything, so it could be persons_name or animal and the content would either be the matched data, or null. But I want the output to say the matched actual variable name like animal or persons_name, not the actual output. See reply to comment above.
Also take a look at OwnCloud.
This may be just what I'm looking for. Thanks a bunch, I'll report back. But yes it's something that has been "it's just how we do it here" at my work. So it would be nice to clean it up a little. Or rather dry it up. Thanks. 
Rest in peace, Jim Weirich. :( I use your work daily, you have impacted many lives.
I think that actually illustrates (one) of the reasons why I dislike Rails. There are wrappers f****** everywhere for trivial operations. Sure its dry but its like picking up a C app where someone has #def'd everything so that it reads like Visual Basic, and they did it multiple times....but with slight variations. How I manage my dependencies? It depends. At the architectural level SOA solves a lot of problems, anything "minor" gets shoved in my shared lib, anything major eventually becomes a gem. I also believe that code can be too DRY and affect maintainability just as badly as cut-and-paste code, hence I don't tend to obsess over taking a couple of lines of code which anyone familiar with Ruby can understand and shoving it in some out-of-way support library somewhere.
Passed away? Died of old age?
Extremely sad. I saw Jim just yesterday. As usual, he was excited to show me the latest pet project he was working on. This time, it was designing 3d-printed bumpers for a mini drone that he has on his desk. I don't know any details of his death, but I take solace in knowing that as of lunch yesterday he was doing something he enjoyed — geeking out over something and getting others interested in joining the fun &amp; learning along the way. Classic Jim. Jim was a mentor in every sense of the word to me and countless others. He will be dearly missed.
Or SparkleShare
I remember when I first used rake. It's an incredible tool for doing some extremely useful things, and can save you countless hours.
Really sad news :(
It's a legitimate question, I don't get why people are downvoting you like this. People don't handle death well I guess. I don't think it's because of old age. 
Noooooooooooooo..... This is the worst news possible... May you always code. May your code always compile. May your builds be smooth eternally, Jim.
Awww man that really stinks. I saw him speak at Steel City Ruby Conf last year about drones and programming them with ruby. I'm pretty n00b to this whole thing so I had no idea his importance in the scene until afterwards when I looked him up. He gave a great talk, and opened my eyes to this thing being more about building webpages but manipulating the world around you with code. I'll miss his enthusiasm and down to earthiness. Come to think of it, this whole scene is like that probably because of people like him. RIP. 
I first met Jim at the XP-Cincinnati meetup more than 10 years ago, which later became the Agile Roundtable. Later he was the center of attention at our Cincinnati Ruby Brigade meetups. His knowledge was deep and his personality made him great at what he did. I have very fond memories of working through code katas with him, trying to figure out how he got done in 3 lines something that took me 20 :) We'll never forget you Jim — the best programmer I've ever met.
I was there too! He gave a great talk.
Yeah, I need to note the Izzy mixin more, as that's where a lot of the power comes from. Izzy is another gem I had made. 
I don't think you need to even reference Izzy. I just can't see from the readme what this library really gets me, because: people.select do |person| person.name =~ /^j/ end Just some more complex examples would be nice. 
Probably a heart attack. Mid to late 50's and inactive = recipe for heart trouble.
I posted about omniref a few months ago when I launched it, and I've added some new features. I always appreciate feedback from fellow rubyists.
What a kind soul! He will be missed.
AeroFS and btsync are also decentralized and work well. Was the motivation for this to just have an open source version of btsync?
Ditto. I use it everyday. Definitely made my life better.
Double check your twitter application permissions that you created on Twitter's website anyway. What you have written above is just about how I have it in a few of my applications that need to write to Twitter. A question for you. The consumer_key and consumer_secret, are they the ones from the application or from a user account that has authorized your application ? If it is from the application and not from a user account, then it would fail, as your application cannot post on its own behalf. To tweet, or "update", it has to use a user account that has authorized your application (edited for clarification)
Met him @ Ruby Hoedown 2010 - here is a video I took of him singing &amp; playing ukulele there: http://www.youtube.com/watch?v=L2vVaIF2MYY
also, I apparently don't know how to spell ukulele. 
No really, don't. OwnCloud shits the bed so hard for random reasons. It also is a massive install requirement for something as simple as point-to-point sync.
&gt;it makes installing git easy Not as easy as using the git (and ruby) already installed by Apple's dev tools.
I used the API Key/API Secret on my application, are these different than 'consumer_key/secret? In my app home page on app.twitter.com it shows my logged-in image so I think my user is authorizing my app? How do I authorize my app?
I like this gem. Probably lame suggestion ... `#select_by`, `#reject_by`, and `#find_by` might be names that more closely resemble stuff the average ruby developer is familiar with. "where" feels more like a SQL term, anyways. Seriously, though, I think this gem is cool. Also, since you use Izzy, and Izzy uses `#===` for `#matches_all?`, you may want to highlight passing in ranges as well as regexes in your readme. EDIT: I see you're also the author of Izzy. Cheers! This may actually be something that is worth being inside Izzy, to be honest.
I'd have been tempted to call it "diuretic".
I had the privilige of attending his Y-combinator talk at Arrrrcamp in Belgium. He would explain very complex matter in a way that people with less math-heavy backgrounds could understand and make sense of. His knowledge really reflected in the kind of questions he asked during/after other people's talks. I never spoke with him, but from the comments here I can gather he was kind, enthusiastic, approachable and a great teacher. This is a loss. RIP.
Just guessing here but your script isn't outputting anything. Did you mean to add a `puts`? `puts client.update('ayo tho')` Does it actually post the tweet? 
I was there also. It was a great talk and he will be missed. :( RIP Jim
Trying not to make it too big, but a fair point.
He had a heart attack at work. https://news.ycombinator.com/item?id=7271909
Well said
Put in a few more. I might just mix this into Izzy.
Since this code runs thousands of times in any given day, on a very large range of inputs, warning on the matched data could vary from anything to null. Printing a null value is not very helpful, as well as this is just an example for the sake of examples. The real sue case would be stored in a database, and I need to know the name of the variable that is not working so I can fix it. Your suggestion is what I currently use, but just is annoying to constantly type out two variables when they both look the same except one is the string version and the other is the variable. Not a huge deal, but just was wondering if anyone could come up with a way to just pass the variable, and derive the string version from it. Just would be really cool.
It works in the sense that it prints something, but not what I want. If the match fails its going to say '_failed_to_find_match' since thing will be null. I want it to actually print 'thing_failed_to_find_match' only pass in thing. So basically derive the string from the actual variable name if that makes any sense. This in practice will be saved to a db on failure and do nothing on success. This is why knowing the variable name is important to fix the problem, while the thing stored in the variable will make it look like every error is a different problem, while it actually is just one match statement that is breaking. 
I tried messing around with local_variable_set and could not get it to not have a local_variable_set method missing error. I could get instance_variable_set to work just not local, and instance would make my code ridiculous considering the amount of methods, and need to have common variable names occasionally. Any suggestions? I also experimented with eval, but wanting to pass the argument to a method (warn_user) I would have to pass the binding in with the variable which just puts me back to where I started with two variables (sometimes rather long descriptive variables), as well as I'm not sure how dangerous that could be. def warn_user string, binding puts "#{string}_failed_to_match" unless eval(string, binding) end Basically the best solution would not to programmatically set the local variable. But to set the local variable with the match, than pass in that variable into the method. Now it will have both the variable, and what is stored in it. Then, in theory, it could derive the variable name for the puts statement from the actual variable name itself and not what is stored in the variable, but then will still be able to evaluate the variable for the unless check. However I realize this is asking way too much of ruby since the variable name wont even make it into the method since only the value will be passed, at least by any normal means. So please let me know if you have any further suggestions on how to use local_variable_set, or any other suggestions at all. I may just be out of luck, but regardless it sparked a nice discussion and I learned about binding! Thanks for your input. 
 def find_person(input) thing = input.match(/person:(\w*)/)[1] warn_user('person') unless thing thing end def find_dog(input) thing = input.match(/animal:(\w*)/)[1] warn_user('dog') unless thing thing end Then just make warn_user a simple log / puts / whatever statement using string interpolation.
`local_variable_set` is a method on the `Binding` class, and it's only available as of Ruby 2.1. However, I just realized that `binding.local_variable_set(:x, 1)` will only affect the variable `x` if `x` is already defined, so it's probably not a good option, after all. I might have some more suggestions if I could see in general what you're trying to do here. Why not wrap the entire task in a class and use `instance_variable_{get,set}` methods on instances?
Cant believe I missed out on this! kicking myself for missing this deal. the 45 dollars it costs right now is pretty steep.
Try running "rake routes" in the root of the app and look for one named "user_omniauth_callback". That should tell you where it will go. It might be using Devise though, which is a gem and the code for it wouldn't be in a place that you could easily change it. Maybe there is a callback in there somewhere though.
another gotcha (imo) is that ruby allows you to be too clever for your own good. i'm not sure if this is still the case, but when i was learning ruby and looking online for examples, it felt like a lot of the people in the ruby community prided themselves on packing as many operations into a 1 line statement as possible. i had a terrible time trying to reverse engineer them to understand exactly what was going on.
That Exception example kinda buries the point: - Don't `rescue Exception` (it's perfectly fine to just `rescue) - When defining your own exception class, don't inherit from `Exception`, inherit from `StandardException`
I've been working on new analysis to try to find the most relevant ruby docs and would appreciate hearing what other rubyists are looking for most often.
I disagree with some of the author's recommendations. Most of all, to avoid using `and`, `or`. They express code intention clearer in many cases when used for control flow, and it's not that hard to remember the semantics. Also, they are useful in conditions with assignment, say: if my_data = fetch_data and my_data.valid? # do the job end
Without any doubt, one of the best and most important articles I've ever read about Ruby.
You can: `super(:different, :arguments)`
I almost always use and/or/not (assignments are an exception) but I'm afraid we are a dying breed and have lost the war on this one. Too many high-profile Rubyists have argued against them so now &amp;&amp;/|| are "right". Which is weird, because and/or/not used to be something used to demonstrate "hey, look at how nice and readable Ruby is!"
I think this is what you want: def self.intersect_segment_segment(line1,line2) # ---snip, not relevant--- if ref_pts.length == 4 if line1.include?(ref_pts[1]) &amp;&amp; line1.include?(ref_pts[2) return PGL_Intersect.new(:line,[ref_pts[1],ref_pts[2]]) else return PGL_Intersect.new(:normal,[]) end elsif ref_pts.length == 3 return PGL_Intersect.new(:normal,[ref_pts[1]]) elsif ref_pts.length == 2 return PGL_Intersect.new(:line,[ref_pts[0],ref_pts[1]]) elsif result.pts.length == 0 return result elsif result.pts.length == 1 intersect = result.pts[0] if line1.include_point?(intersect) &amp;&amp; line2.include_point?(intersect) return result else return PGL_Intersect.new(:normal,[]) end else raise "Error: Invalid result state passed to intersect_segment_segment, #{result}" end end You're closing that initial if-block after the else. Also you should ditch the `thens` and convert your `and`s to `&amp;&amp;`. Also, I removed the return at the end because it will never be called. 
There's square bracket missing at ref_pts[2] in that if statement in the section you comment out
You're doing something horrible. Exactly what if statement do you think that elsif is part of? Here's the basic structure of your code def x if #start of first if statement if #start of second if statement elsif end #end of second if statement elsif elsif else end #end of first if statement elsif #note that this isn't part of any if statement elsif else end end You see? You've got two if statements -- they both end properly in the first section. Then you're starting(?) another if statement with elsif instead. I'm not sure exactly what you're trying to accomplish -- are both of those else statements supposed to occur in the same scenario? It looks like you want something like this: if ref_points.length == 4 elsif ref_points.length == 3 elsif ref_points.length == 2 elsif ref_points.length == 1 elsif ref_points.length == 0 else end 
Whoops, I left out something in the --snip-- that was very important, I added it back in: if result.desc == :line_array then This makes it nest correctly and I'm still having the error. :S The length == 4, 3, and 2 are in the event I'm trying to intersect two line segments on the same line (4,3,2 reference points to figure out whether it's overlapping, joining, identical, or not intersecting). The length == 0 and 1 are for intersections of two segments not on the same line, they either intersect (one intersection point) or don't, they can't overlap or have multiple intersect points.
Oh hell. -_- Got it. I was missing a closing array bracket: if line1.include?(ref_pts[1]) and line1.include?(ref_pts[2) then The testing suite I'm using somehow threw both syntax errors and I was only looking at the second one. Thank you for the advice, in any case.
Got it! Fixes the issue, I wasn't looking for it; was just checking my else syntax. Thank you!
Well, the case in the article was rather to show that "and" in not an equivalent of "&amp;&amp;" (like most beginning Rubyists, a-few-years-ago-myself included, think), and you cannot simply replace "&amp;&amp;" with "and" and vice-versa. I agree that "and" may *look* nicer than "&amp;&amp;", but it also *does* something else. This is why I consider it kind of quirky feature of Ruby.
So I just finally finished this library and I think it's really great :) Anyway looking for any kind of feedback. It can get UTC offsets from timezone names in multiple languages and abbreviations. It supports all known timezone abbreviations. Way more than any language have supported in itself. Can also convert abbreviations to timezone identifiers and much more. Or for example in localized Windows Time.now.zone returns that zone name localized and thus you've no way knowing which that timezone actually is, but this library can parse that and get normal timezone identifier or UTC offset. And can also filter matches by region and locale.
The article did then go on to say, "Good practice: Use only &amp;&amp; / || operators ... don't use keyword versions at all." I'm afraid I will go on writing code that the author considers bad practice. Yes I also agree that it's important that programmers are aware of the precedence issues.
You're welcome! Try http://stackoverflow.com next time, its an awesome code question/answer site. Happy coding!
I believe you mean inherit from StandardError.
Thanks, I don't have a stackoverflow account and it was a quick one, so I posted here; is it preferred that these questions be posted to stackoverflow? I didn't see it in the sidebar and I'm more comfortable with reddit, so I opted to go ahead and post.
Gotcha. Thank you!
Might wanna try using a linter next time to see if that picks it up.
justinwsmith: I host the local ruby brigade here in Cincy. You should definitely stop by some time. We have meetings on the 3rd Tuesday of the month at the Gaslight office in Blue Ash. Losing Jim has been a huge blow to our community and to me personally. I will miss him so much. 
I feel it improves code quality when developers pick a descriptive exception base class (ArgumentError, TypeError, NotImplementedError, RuntimeError, StandardError).
Oops, yep!
Oh, I agree. I guess to be more general the advice would be "Inherit from something that has StandardError in its inheritance chain".
It depends on what your child-class is doing: 1. You're modifying some of the initialization values. Sure, totally reasonably. 2. Your subclass's initialize method has a different signature than its superclass (so calling a bare `super` causes an ArgumentError or a transformation is *required*). This would be a violation of Liskov Substitution Principle and is an indication that you're doing something wrong or at least not typical. One thing to mention is that RubyMotion is kinda weird in that if you're subclassing a Cocoa method the implicit `super` doesn't work and you have to pass the arguments through.
Get out while you still can! http://www.youtube.com/watch?v=-5wpm-gesOY
Why not just use ".upcase" (without the "!")? There is no reason to need the "!" in this kind of case 
'Nother early gotcha: always remember the following two facts: 1. Ruby always returns the last thing it evaluates 2. Puts Evaluates to nil I lost hours early in my career by putting what I thought were harmless traces in my code, without realising that the trace was actually impacting the implementation!
H-how?
Yes but why are you asking for a return value in the first place? there's a purpose to: foo="foo" bar=foo.upcase # foo=&gt; "foo" ; bar=&gt; "FOO" but no purpose to: foo="foo" bar=foo.upcase! # foo=&gt; "FOO"; what do you need bar for? the only use for the return value in the "!" version is in something like this: if foo.upcase! then puts "foo changed" else puts "foo not changed" end perhaps it should return true/false rather than returning foo or nil?
Yes but he's asking for a return value, which is pointless if you aren't looking to allocate a new string. Why would you write: bar=foo.upcase! Are you wanting bar to be exactly the same as foo? There is no point for two references to the same object.
Because it's common to initialize several objects at once before they diverge in their values later. e.g. def create_files(basename) source = header = basename.downcase! log "creating files for #{basename}" source += ".c" header += ".h" # do something else end And how this might surprise a programmer: create_files("Util") # &lt;- ok create_files("test") # &lt;- error (NoMethodError: undefined method `+' for nil:NilClass) Obviously, it's pure programmer error to write code like this but I agree with the author that it's a "gotcha" because it reads quite reasonably. Nearly all (but not all) bang methods behave this way.
yes, but it's not that bad and actually I knew it all already :P that's why you should always keep everything in UTC and there's where this library comes handy because you can get UTC offset for user entered timezone (or from some website or book). It uses [TZInfo](https://github.com/tzinfo/tzinfo) un [CLDR data](http://cldr.unicode.org/). It should be accurate starting from 1900 and you can specify which region/country that time is in thus correctly get offsets ;)
Yeah, fair point. 
I can see as a beginner you might expect this to work and it is a 'gotcha' like that but you seem to imply that there's something poor about how ruby has implemented this - how would you change it? I'm not sure having the return value the same as the object given would simplify things - more likely confuse them further.
Nine times out of ten, I want to invoke the superclass' method with the same arguments. Almost never do I want to take arguments in the subclass, but have the superclass take zero.
Dying breed though we may be, I write my code with `and`, `or`, and `not` without shame!
I just don't understand why i'd use this over and above normal Enumerable methods. Your code: `people.select_where( age: [ (20..35), -&gt; a { a.odd? } ] )` vs Normal Ruby code: `people.select { |v| (20..35).include?(v.age) &amp;&amp; v.age.odd? }` Your code really doesn't save me that much, and is likely a bazillion times less performant.
Yes, my point is I see inconsistency. I'm sure a language designer could construct a justification for this. Among array methods, `shuffle!` and `map!` and `sort!` have a return value the same as the object given. (Whether or not the object's data was changed.) This can be confirmed with `object_id` before and after. But `select!` does not. Among string methods, `reverse!` has a return value the same as the object given. (Whether or not the object's data was changed.) But most others like `downcase!` do not.
I second that other comment that suggests using a linter. Also, consider auto bracket completion and auto indenting. Lastly, a more coding style solution is to avoid giant nested if else situations. You could use a case when to great effect here.
Pretty bold claim. A couple of points: * Ruby's convention is to use `under_score` for variable and function names, not `CamelCase`. * https://github.com/davispuh/TimezoneParser/blob/33d0163530f119a947222bf799e079a53e6797e2/spec/rails_zone_spec.rb#L8 It looks like you're testing Ruby here. * You should change the tests expect(a.isValid?).to be_true to expect(a.isValid?).to eq true otherwise this test passes if you return any truthy value. And when writing a library you want to be as strict as possible with your return types. * `TimezoneParser.getTimezones` accepts a boolean parameter. This is a design smell and can be solved by splitting it method up in two separate methods. In general: This method accepts way too many arguments.
I see. right you are its inconsistent. Even if you ruby doesn't intend for you to use it like that.
[Here's a Tribute video someone made for him.](http://confreaks.com/videos/3072-imjw2014-goodbye-jim)
Must have been a fluke that I ran into it so quickly. Although, maybe it's different with games, because a lot of the time you'll have an Entity class and then a subclass for something like Fighter. The Fighter takes a bunch of arguments like HP, MP, and Defense while the Entity class constructor has none of those arguments. I guess I tend to use composition instead of inheritance most of the time now anyway. 
did you try "ruby -v" with a space between ruby and -v?
when you use ruby installer for windows, you have to check the path environment variable. if you forgot, you can do it manually later. Google it and you will know how.
I googled it and i'm still a bit lost. I updated the path environment variable, but nothing changed in cmd so i'm pretty sure i did it wrong. Here's what I did: 1. go to system properties 2. create a new system variable named "ruby" with value "C:\Users\UkuleleBaller\Ruby193" 3. Check cmd, only to see that problem persists 
what part of the path did you add this to? beginning/end?
install a Linux VM and run Ruby there?
now I'm lost. i created a new variable with the location of my install. If you guys haven't noticed yet, I really have no clue what I'm doing. TBh I'm surprised I haven't deleted my sys32 yet and bricked my pc.
I may just have to do this. I hate windows so much right now. Any suggestions? 
VBox and optionally Vagrant. or rent a cheap VPS somewhere. or maybe find a spare PC in a dumpster and install Linux on that :P
If you didn't tick the "Add Ruby executables to your PATH" in the installation process, Ruby will not be added to the PATH so running the command prompt as is will give you a console without Ruby. So instead of cmd, open a command prompt via "`Start -&gt; Ruby 1.9.3-p484 -&gt; Start Command Prompt with Ruby`"
The PATH variable is "Path", not "ruby". There should be one in the "User variables for ..." part. Here's a similar question in SO with steps on how to set up your path via Windows env variables: http://stackoverflow.com/questions/6318156/adding-python-path-on-windows-7
i did tick that part, thats the weird part.
can i run those on a usb to boot up as?
You have to open a fresh command window after you change the path. Paste your path here and we'll make sure there's no typos.
Did you close and reopen your command prompt? The path is applied the next time you open a console. Either way, you can check whether the Path was correctly applied by looking at the Path user env variable.
I tried this! It worked, I'm so happy right now!
Nope, edit the path variable that already exists. Since the input entry is so short you may want to copy it (Ctrl-a, Ctrl-c), then edit it in a text editor, and paste it back in.
I figured it out, turns out it was something else!
Sweet! You'll love Ruby.
No prob. Don't forget to install the DevKit if you're planning to install complicated gems like Rails. http://rubyinstaller.org/add-ons/devkit/ 
You can probably just install jruby.
What an impact this man made. I would be happy to accomplish 1/100th of what he did. Goodbye Jim. You will be missed.
The language is awesome! 
Benchmark.measure { 100.times { people.select { |v| (20..35).include?(v.age) &amp;&amp; v.age.odd? }}}.real =&gt; 0.000705947 Benchmark.measure { 100.times { people.select_where age: [(20..35), -&gt;a{a.odd?}]}}.real =&gt; 0.003397795 Granted, but if you're REALLY concerned about performance then why are you using a dynamic language? The point is to make things more understandable and legible.
 Person = Struct.new :name, :age, :location do def initialize(*) super self.location = 'Austin' end end
Ditto. 
Just download VirtualBox and an ubuntu image. or, if that's too complicated: https://www.digitalocean.com/ - $5 a month:
Thanks for this. 
Except, IMO, your code doesn't make things legible/clear enough to make it worthwhile.
It should actually be like this: Person = Struct.new :name, :age, :location do def initialize(*) super self.location ||= 'Austin' end end In the code that you've written, even if you make a new Person instance, it will always have the location "Austin", instead of the passed one (if there is one). The modified code will give this behavior: person = Person.new("John", 24) =&gt; #&lt;struct Person name="John", age=24, location="Austin"&gt; person = Person.new("John", 24, "Dallas") =&gt; #&lt;struct Person name="John", age=24, location="Dallas"&gt; 
that's because I seriously haven't seen such library which could parse so many timezones, it's not so about code quality but rather about features. Also it's kinda joke from [this ad](http://3.bp.blogspot.com/_EFIuNhUmclY/TDctSQIwf8I/AAAAAAAAAPg/dwQGcRzNB0Y/s1600/carlsbergpearl1.jpg) :D * I know, but I like CamelCase/camelCase way better and I use it for almost all languages. It really makes no difference and when I'm contributing to other projects of course I use their preferred coding style. * it's meant to test if #new works fine without raising exception, but yeah I just updated it to use `expect.not_to raise_error` which is more correct way I think * that's valid point, fixed now :) * I'm not sure, basically difference is current way "`tz = getTimezones(t, something == value)`" vs something like "`tz = (something == value) ? getTimezonesFast(t) : getTimezonesFull(t)`". Maybe I could provide those methods but I don't see this as bad. As for arguments, that's convience because most of time default values will be fine and you can get result in single call, 1 line. But it's possible to assign values individually, eg. &gt; tz = TimezoneParser::Timezone.new(t) &gt; tz.Locales &lt;&lt; 'en' &gt; tz.Regions &lt;&lt; 'US' &gt; tz = tz.getTimezones anyway Thanks :)
Jim's funeral will be broadcast today @ 4pmEST http://www.ustream.tv/channel/jimweirichfuneral022314
That wasn't a troll.
Actually, to be fair, we're both wrong. It really should have been this: Person = Struct.new :name, :age, :location do def initialize(*) self.location = 'Austin' super end end That way, if you explicitly pass in `nil` or `false`, you'll still override the default: person = Person.new("John", 24, nil) =&gt;#&lt;struct Person name="John", age=24, location=nil&gt;
You might try cygwin. Its served me well for quite a while as a linux-comatibility layer for Windows. Install a basic gcc-based development toolset and then grab Ruby Version Manager so that you don't have to worry about their windows installer or path environment variables.
Avid rubyist here. Here's how I've done this in the past, I like python's SimpleHTTPServer module, I think it's the easiest way to get a full-featured static HTTP server going. `mkdir -p ~/tmp/sharescreen &amp;&amp; cd ~/tmp/sharescreen &amp;&amp; python -mSimpleHTTPServer &amp; while true; do import -window root screen.png; sleep 1; done` This uses "import" as provided by imagemagick for screen capture - works great on linux, you might need to adjust on other OSs. If you cancel screenshotting via ctrl-c, you can kill the backgrounded python process by bringing it to the foreground via `fg` and then another ctrl-c (or via any other job management technique you prefer). Not ruby, I know, but other tools are good, too.
Damn, you're so right. That's actually why I didn't do it that way in the first place. I think your solution is the best you can get with structs. Thanks for correcting me!
Hi, could you take a screenshot please? I agree the font could be sexier, but it's not thad bad (currently using Open Sans from Google Fonts).
in a nutshell, jruby works exactly like ruby, except you have to make sure the libraries you use are threadsafe, and you don't get Kernel.fork()
People talk too much and take hacker news hype too seriously. Is this anything new? Not really. 
Christfuck so much this. After around four years now on Hacker News I feel like I've already read every article that's ever going to be posted there. It's the same shit, rephrased every few weeks to months. Mostly link bait, hype, "growth hacker" bullshit, framework/language death knells, and (in my opinion) niche, esoteric, hipster nonsense only interesting to people maturbating around in academic pursuits/for cool factor (read: nothing actually useful to anyone actually trying to get shit done). I'm honestly not sure if HN degraded or I just became jaded. People have been beating the same fucking "language x is over" drum for Java (outside enterprise), PHP, and Perl forever now and I still see plenty being built with those. Edit: Also, a language is just a tool. Not a religion. Use what works for you/your project and stop giving a fuck what other people are prattling on about. The signal to noise ratio of subjective technical topics is fucking terrible.
I pretty much agree with what's been said so far. Ruby seems more consistent in its design, is definitely more aesthetically pleasing, etc. That being said (and sorry for turning the topic on its head), I still prefer Python. Mostly, it comes down to one topic: debugging. Debugging Ruby is extremely frustrating. Basically my gripes are these (and pardon if these are no longer true, I don't actively use Ruby for any of my projects): * Nils. An uncaught ``nil`` can trickle its way through dozens of layers of an application before finally causing a runtime error. And that's if you're lucky. Sometimes it just doesn't throw any errors at all. This issue is somewhat alleviated if the lib uses methods that throw exceptions (e.g. ``Hash#fetch``). But I often find that if the default behavior isn't the correct behavior, then most people will behave badly. * Implicit imports. Nothing makes me feel stupider than trying to understand how a Ruby library or app of any complexity, that I didn't write, works. * Flat namespaces (sort of related to previous point). While it's more mathematically pleasing (for lack of a better phrase), the fact that every object has 493+ methods makes it difficult to play around with Ruby (e.g. in the REPL). Especially when many of those methods don't even apply to the object in question (but they're there, just in case you need them). * Monkeypatching. This isn't really unique to Ruby (you can monkeypatch Python as well), so maybe this isn't entirely fair. Yet you definitely see this quite frequently in Ruby code, and quite infrequently in Python. Writing Ruby is very user friendly. But reading it, for any non-trivial project, is not. At least that's my experience.
I agree, HN feels like it degraded into a bunch of tweens having a pissing matches over and over. Come back in a couple months and they will be trashing framework-2months and praising the newest shiny. I feel the proportion of magpie developers to veterans has shifted a bit too much to really trust comments. I'm trying to stop visiting there daily and instead wait for http://www.hackernewsletter.com/
I read HN because there are occasionally articles I find interesting, but the amount of "Doing [widely accepted thing] is wrong. You should do [niche thing i found/developed]!" blog posts drive me crazy. You described my thoughts on HN perfectly.
I'm tempted to look into the HN Newsletter but honestly, I feel like pretty much everything is "hacker porn" at this point. I've seen the term "entreporn" used a few times regarding entrepreneurial interests that falls in the same category. (I think swombat coined the term. I can't get his article to load right now but here's a blog post about it: https://mondaybynoon.com/entreporn-learning-vs-doing-vs-wasting-time) I don't really think it's likely there is much more to be gleaned from reading general hacker blog posts for me. You fall into this trap where you feel like reading all these articles and keeping up with the latest news is useful. In the beginning it definitely is. It helps to make you aware of what the options are. It doesn't take long though before you pass expanding your horizons and move into just slapping your junk around because it feels productive. I don't mean to suggest just stopping from reading hacker/entrepreneur/whatever material. I think you just severely limit your consumption and become very discerning instead. I dropped all input that: a) isn't specific to my interests (r/ruby is just ruby stuff, not Node, not why PHP sucks today) b) doesn't have a good, consistent signal-to-noise ratio I'm very quick to drop info sources and I regard everything as fluffy horseshit until proven otherwise. Edit: I'm crazy tired right now. Hopefully this isn't too ranty/is intelligible. 
This was an awesome read. Feels good to know one can make such an impact on a project.
 animals = find(animal, input) people = find(people, input) def find(thing, input) return input.match(/#{thing}:(\w*)/)[1] if input.match(/#{thing}:(\w*)/) puts "#{thing}_failed_to_find_match" end This should be exactly what you want. It will assign the animals to nil if there is no matching input and will output the correct statement &gt; a = find("bird", "bird:works, dad:doesn't") =&gt; "works" &gt; b = find("cat", "bird:works, dad:doesn't") cat_failed_to_find_match =&gt; nil EDIT: Another way of writing it that may be a little more readable. def find(thing, input) return_found(thing, input) || warn_about(thing) end def return_found(thing, input) input.match(/#{thing}:(\w*)/)[1] if input.match(/#{thing}:(\w*)/) end def warn_about(thing) puts "#{thing}_failed_to_find_match" end find("bird", "birdjesus") bird_failed_to_find_match =&gt; nil &gt; find("bird", "bird:jesus") =&gt; "jesus"
Meteor has already taken over. I was able to write a simple chat app from scratch in *one hour* last week (amazed at the $16 billion price tag for WhatsApp).
I just can't read HN. Its everything I left CS to get away from. Pedantry, hate, academic masturbation, and total lack of social skills. That, and the weekly "dae le haskell" jerk that crops up
While I agree with some of your points, your Python example for "chaining" is dumb. ''.join(list(str(sum([i * 2 for i in range(20) if i % 2 == 1])))[1:]) Is really just: "".join(str(sum(i * 2 for i in range(20) if i % 2 == 1)))[1:] Or preferably: "".join(str(sum(i * 2 for i in range(20) if i % 2)))[1:] Which is in fact... str(sum(i * 2 for i in range(20) if i % 2))[1:]
You caught me :) Both of them are dumb, in fact (the Ruby version can be simplified in pretty much the same way, as `(1..20).select(&amp;:odd?).map{ |i| i * 2 }.inject(:+).to_s[1..-1]` ). I over-complicated it because I was having trouble thinking of a reasonably long chain that didn't require a lot of context to make sense. Of course, you could take that as a sign that chaining things naturally isn't actually that important, but I'd argue it's more a sign that I'm not not very good at coming up with code examples than anything else.
Still if you want your gem to be used it should use standard ruby terminology. Otherwise all ruby apps using your library will look weird having two different kind of conventions
I write web apps in ruby without rails. Rails is just a (bad, imo) web framework that uses rails to deliver websites. There's other ways to do it too.
A good non-rails ruby centric repo of code is the ruby-quiz stuff. 
You can use it just like any other scripting language. Anything you'd use a bash or Python script for, you can use a Ruby script to do.
Care to elaborate?
I assumed that but I don't see it as being as common for the tasks bash or Python is used for. 
There are many other web frameworks like [Sinatra](http://sinatrarb.com) and Padrino (http://padrinorb.com) that take a more minimalist approach.
That's just about all I use it for, command line scripts. Not sure why it hasn't taken off, but it just works really well for my brain. 
if it's so big deal to someone they can just fork and rename variables.
It's gaining steam, ruby has been seeing steady usage increases year after year. http://blog.codeeval.com/codeevalblog/2014 While a large chunk of those numbers are with rails, ruby itself is a very powerful OO language. The more people are exposed to it, the more people begin to see the potential in the language itself. Not to mention ruby itself is being actively developed, I think it will start to become as common as python in the coming years.
I agree there, coming from a Python environment there is a lot of "hatred" between the two languages. A kind of binary mindset that you are either Python or Ruby. I do like some of the language constructs in Ruby and since I have been introduced to Ruby, I find myself rather liking it. Some of the difference that are a welcome change is operator overloading and a freedom in how we can do certain things.
There's libgosu for writing games.
Ruby has built in syntax for executing programs on the PATH, which, IMO, makes it better than Python as a Bash alternative. I use it this way all the time
I use Sinatra for APIs and small dynamic sites, and Nanoc for static site generation. This weekend I converted my WordPress blog to Jekyll (their post converter worked quite well). I've scripted both video and image processing tasks in Ruby using beanstalkd, and have created a handful of command line tools using the Thor and Trollope CLI libraries. I've been using Ruby professionally for over two years and have never written a Rails app.
Homebrew is one of the biggest non web Ruby projects. There's a fair few command line tools written in Ruby. 
Metasploit is ruby. And (as I was told by a ruby fanatic friend): ruby is 'better' than python due to it being a cleaner and broader implementation of oop concepts: Python is a bit easier at first, but ruby will let you do things python can't support directly.
You can run out of gas using bash when things get complex. It's great for complicated sysadmin, such as running a remote backup on db servers, using WMI to query services, using data pump, parsing logs for errors, fetching the completed backups or reporting results in an html doc with inline charts to a mailing list. Bash would choke on that.
Didn't know that ! As for the ruby better than python, those arguments are pointless
Um, why pointless? Do you just mean to you? Metasploit modules can have some good code snippets for net interaction and data handling, btw.
Ex-Pythonista here. I've thrown Ruby at a number of projects and now prefer it to Python - for some reason the syntax just feels more natural and fluid. Lets see - what have I done in the last year.. - A rather complex crafting returns calculator for GW2 (http://ec2-174-129-236-8.compute-1.amazonaws.com:8000/gw2sp2g/). That uses CGI so is basically "framework" free. - A website + shopping Cart. My second Rails site, and Rails actually shined for that. - A backup tool with a QT4 GUI. I found that I prefer to use Python for this sort of work (QT4 doesn't really feel like a natural fit for the Ruby language) and actually switched back to Python in order to write the new front end for our in-house video recording system. - A rails based CRUD application which serves as the UI/REST backend for the recording system. Again, Rails shines here although I found myself doing things the "Rails way" and really questioning the sense of doing so. - In Sinatra, multiple applications that have simple/minimal REST or HTML interfaces (e.g. start/stop/status). - A chat app. I haven't actually finished this since I was playing about with Celluoid attempting to get the performance to scale. Again Sinatra over rails since there are only two "mount points" for the application. - Lots and lots of recipes/modules for ~~Python~~Puppet and Chef. Two DSLs for the same domain... Sorry for the "year in review" but where Ruby has seemed most natural is writing REST based services. I should mention that just because I'm talking about REST, this is actually a "desktop" application. SOA was a natural fit to handle the separation of concerns. Rails has its place but I think its a case of many people having a hammer and all problems looking like nails. But again, here I have one database front end so it doesn't have to be used to build websites... Python felt more natural scripting desktop based UI interfaces which may say more about the primitive style in which I write Python. And if you do any dev-ops work its hard to avoid Ruby. I think its also worth noting, while Ruby IS a nice language to work with, I think the biggest benefits for me as a programmer have been in appreciating the broader communities philosophy. Buying in to TDD, ~~DDB~~BDD, SOLID, DRY etc etc have definitely made me a better programmer. 
To give you an idea: the company that I work for does a lot of data aggregation in the form of scraping which is then presented in the form of web services, reports (PDF), etc. For pretty much all of this we use Ruby. The web frontends are pretty boring Rails apps, the backends are Ruby daemons (based on daemon-kit and some custom stuff). We have a bunch of libraries, commandline tools, etc. In terms of numbers we have (give or take a few) 15 daemons, 11 Gems, 9 web apps (some Rails, some Sinatra) and a handful of commandline tools. [1] [1]: these numbers are based on our Jenkins setup. Not everything is in Jenkins (e.g. one-shot tools) so the actual numbers are probably a bit higher.
Also I write most of my random/one-off scripts in Ruby instead of Bash because Bash is god awful.
Since everything in ruby is an expression, you don't need these explicit returns. Also, use CASE statement instead of bunch of IFs. Here you go: https://gist.github.com/strelec/9189465
I use ruby for all my grunt work, essentially. Anything I might have used perl to do 10 years ago, I do in ruby now.
I write a fair amount of command line utilities in Ruby. If a bash script is getting a bit convoluted, I generally reach for Ruby. I also knock up web services in Ruby using [Sinatra](http://sinatrarb.com), although I guess that's still "web".
Isn't Heroku tool written in Ruby? 
Have a look at the Ruby koans 
Both Rails and Sinatra actually build of something far simpler called Rack which all the Ruby web servers support.
Find someone to pair with :-)
Python was picked by Google because they could easily hire the guy who made it, as i understand things. Other people followed suit. By design both languages should be pretty similar for such tasks.
Michael Hartl http://ruby.railstutorial.org/ruby-on-rails-tutorial-book
Coming from Python, I see Ruby as quite the relief
This helped me when ramping up quickly with Ruby and I'm a PHP dev. http://learnxinyminutes.com/docs/ruby/
http://www.codecademy.com/tracks/ruby
it's great so long as you aren't processing lots of data through it. then it gets really freaking slow (at least mri does). i like ruby as a bash replacement, but often drop down to awk and other coreutils to do large stream processing (where ruby is doing the control flow, shelling out, parsing responses, etc)
Too soon good sir. Thanks for all your contributions.
Seems to stack up well [vs Python](http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=yarv&amp;data=u64q).
Some great libraries that are very performant mostly built on numpy, scipy that can handle large multi-dimensional arrays and matrices at nearly c speeds. Since numpy is pretty mature, lots of other stuff is built on it like pandas, lots of CompVision and AI / ML stuff etc. MAybe https://github.com/SciRuby/sciruby will get there sometime, but not now. 
&gt; Python and Chef. Puppet and Chef 
Hey thanks for ruby-lint !! 
similiar to what i do with ruby. I also maintain some gems, create parsers/data scrapers, started and never finished some 2d games. Some rails, some this, some that. @op as Python programmer you should know that each language can be used for nearly everything.
Slap me silly. Ta :)
Fun projects. although I don't know what a "Orichalcum Greatsword Blade" is :-) Celluoid is fun too. I seem to be like Ansible these days over chef/puppet, you tried that ? Its pppppyyyyyttthhooonnnn .... 
&gt; I think its also worth noting, while Ruby IS a nice language to work with, I think the biggest benefits for me as a programmer have been in appreciating the broader communities philosophy. Buying in to TDD, DBB, SOLID, DRY etc etc have definitely made me a better programmer This is big point. I would say that Rails influence in creating a whole ecosystem of software craftsmanship, is most import aspect of the whole project. All by using empty folders.... 
blocks maybe.
td;dr: [Ruby Koans](http://rubykoans.com) This is a great starting place.
&gt; I just accepted a job where I need to write Ruby and Rails. Someone in the future is staring at their screen and cursing you... &gt; [probably not the best idea] Something I played about with when I first started with Ruby. This: def something array proc = Proc.new do |element| puts element; end array.each do |element| proc.call( element ); end array.reverse.each do |element| proc.call( element ); end end Became: puts [arr, arr.reverse].each {lambda { each }} Rubys beauty is that it is possible to be VERY succinct. You should be able to write code but if there are code reviews, you are in for a rough first few months. HOWEVER if a lot of the work is Rails based, Rails has is own ways of doing things. I'd probably throw myself into (the rails guides)[http://guides.rubyonrails.org/] as a starting point and perhaps a sub to railscasts. For Ruby, you actually should be able to pick it up fairly quickly. Quite a few resources on going back and forth between the two and I would really worry more about Rails. 
&gt; I seem to be like Ansible these days over chef/puppet, you tried that ? Its pppppyyyyyttthhooonnnn .... I actually haven't but I will take a look, thank you. I'm not a great fan of Puppet or Chef (pros and cons to both) and since I'm just about to roll out a new batch of code for Ubuntu 14.04 its a great time to do so :)
Howdy! Sure -- this is what it looks like on my system: http://i.imgur.com/SBWHVDf.png Fonts are so... edgy? =) Cheers!
I am amused and a little bit concerned by their understanding of the newly adopted semantic versioning. https://www.ruby-lang.org/en/news/2013/12/21/semantic-versioning-after-2-1-0/ &gt; MINOR: increased every christmas, may be API incompatible
This was a "TEENY" release for which the changes seem to be consistent with what they've documented as appropriate for this type of release. Can you be more specific about their (mis-)understanding of semantic versioning? Is the problem that they're tying their MINOR releases to a particular date, instead of to something more feature-oriented?
Mind telling me which gem and how to get started? I'd like to learn...
Sure thing. As someone else mentioned, Rack is also good to know about as it is the foundation of Sinatra, Padrino, and Rails. I recently used a barebones Rack app to host a combination of modular Nanoc and Sinatra sub-apps.
awesome post 
I believe RedHat's [OpenShift](https://www.openshift.com/) is mostly implemented in Bash and Ruby.
Happy birthday, Ruby! Don't get too drunk tonight.
I think the problem is that a MINOR release should be backwards API compatible.
Don't need the explicit 'then'. Don't access arrays by their indicies, use a hash for clarity. Don't use underscores in class names. Don't need the explicit 'return's. Be careful of using 'and' in this way- use &amp;&amp; as it is safer. Consider breaking this into multiple methods. Have fun.
They have that privilege.
I don't think anyone's arguing that they shouldn't be allowed to do whatever the fuck they want with their product. I'm saying it's disingenuous to call it something it's not and insist upon it unquestioningly
huh, hasn't really been my experience. e.g., take input line by line for a 5M+ line file, split on some character, sort fields [1..-1] by some function, maybe do some other transformation, and spit the end results (maybe rolled up by key?) to another file gets really slow at medium data sizes in ruby, but still is relatively quick in python. the most recent stripe capture the flag had a naive ruby implementation for the first problem (https://stripe-ctf.com/) that could get 4X performance by converting to python (but keeping a lot of the dumb inefficiencies in the original naive implementation). of course, ymmv. 
thanks!
google better ruby python -- or any permutation. The articles tend to hit hard on pros and cons both directions, so it'll let you decide for yourself. To be fair, there are a lot of times when python may fit your needs well. But there's something deeper there. I sense it, but haven't hit the epiphany yet: Ruby's OOP concepts remind me of something said by Lisp proponents: Ruby is capable of things powerful enough that it forces you to forever rethink how you program. You start to think in terms of code that organizes and builds the structures, rather than building them yourselves. This comes from deeper object introspection, object modification, an ability to create DSL's within the language, to name a few traits. edit: http://paulgraham.com/avg.html is one article on 'why Lisp'. A friend that's part of Metasploit talk this way about Ruby... 
The latter. I just think it is funny that they are trying their minor releases to Christmas. I know they have traditionally done that, but tying all minor releases to a specific annual date does not conform with my understanding of semantic versioning. Especially considering that the article says that they are adopting semantic versioning. I guess it is semantic versioning with one major caveat.
They don't understand SemVer: In Ruby 2.1.0: class SuperHash &lt; Hash; end &gt; SuperHash.new.reject{true}.class =&gt; SuperHash In 2.1.1 &gt; SuperHash.new.reject{true}.class =&gt; Hash 
I'm gonna guess it's Mechanize/Nokogiri for interacting with web-services through their front-end.
Those don't exactly seem to fit the perfect for Facebook mold... but maybe! I already know how to use those, so...
Just use class methods.
Off topic, but as someone who doesn't use Ruby on a regular basis, Ruby "DSLs" drive me crazy. I can never quite figure out which :words need colons behind them, or where = needs to be =&gt; instead. 
Wait, wait, wait... What's the problem you're actually trying to solve with this dynamic-classes-from-config-files solution in the first place?
Very happy to see daemon-kit mentioned as it's often overlooked or forgotten about.
oh hey.
They are the law afterall http://i.imgur.com/TX5Sp17.jpg
The class member variables need to change based on the configuration of data in a file that is subject to frequent changes. To avoid having to go and edit code when a member changes, I decided to generate the class based on the file
It doesn't sound like you need dynamic classes though. You're only storing dynamic _data_. There are data structures designed for this sort of thing, like hashes and openstructs. Something that'd be slightly more customized/"intelligent" would be a custom dynamic data class that wraps these data structures and has special functions defined to initialize and manipulate the data.
Yeah, but at the same time, I kinda feel like "screw it, just metaprogram the shit out of that assignment." School is one of the few places where you can really wank out and not hurt anyone else trying to read your code later.
The first problem of the stripe-CTF could be fixed in a few lines of code by changing from arrays to hashes since hashes are constant look-up time and arrays are definitely not. Out of curiosity, Your python script also used arrays? If so, I wonder why it is so much faster.
The documentation says that these methods return a *new Hash*, so I would consider 2.1.1 to be somewhat "more" correct. 1.9.3 appears to inconsistent in how it constructs the return values. "reject" constructs a new object of the bound object's class, while the similar "select" returns a new Hash object. &gt;&gt; class SuperHash &lt; Hash; end =&gt; nil &gt;&gt; x = SuperHash.new =&gt; {} &gt;&gt; x.object_id =&gt; 20859180 &gt;&gt; y = x.reject{true} =&gt; {} &gt;&gt; y.class =&gt; SuperHash &gt;&gt; y.object_id =&gt; 20774680 &gt;&gt; y = x.select{false} =&gt; {} &gt;&gt; y.class =&gt; Hash
Maybe you're not trying to solve the same problems as the guy/gal writing the gem? Maybe in her/his case, this gem *is* worthwhile? It's not like the author sprang forth this gem and asked the entire community to start using this gem for every project ever.
To add to this list, our whole test automation framework is written in ruby.
Wow actually that is really interesting. Totally different approach but cleans the code right up, and without any crazy meta code. Thanks a bunch! 
You should check out Ansible
I would heed the advice of sztupy; even if only for the public API. If you want to use camelCase internally, while maybe not the greatest idea, is not the end of the world, but forcing people to use camelCase to use your gem in their code will probably put people off. The camelCase gem name is also a bit jarring. (I am assuming your goal is to actually want people to use the gem rather than releasing it as a practice / learning experience. if not, ignore everything above) Apart from that, looks good. I like the well laid out readme and the fact that everything is setup regarding cc, travis etc.
Love the tip on third party Apis. 
I can't really think of a good example because it's not going to be a very common "technique". You'd be hard-pressed to find a good example where some other alternative wouldn't work better. Classes are constructs to organize behaviors together with data. Technically, everything that can be done with classes can be done without them - it's just that grouping data and methods together makes sense conceptually. I suppose a really contrived example would be a "Strong AI" that would learn about the world around itself, creating classes to represent new things it came across, defining new behaviors as it learns about them, and associating the classes together in meaningful relationships as it understands them.
I do some data scraping using ruby and capybara. Another popular-ish use these days is making mobile apps using [ruby motion](http://www.rubymotion.com/). You can actually also use that or [mac ruby](http://macruby.org/) to make OSX apps as well. 
Since nobody's mentioned it yet... RPG Maker. :P
As long as they bump the appropriate part of the version there's nothing to prevent semver and dedicated release days. 
This already exists in OpenStruct. If it were me I'd probably just use a hash. That's pretty much what they're made for. 
 a = %w(a b c d e) a[4..10] returns [4] a[5..10] returns [] a[6..10] returns nil. That's actually.. kind of weird. Returning [] is listed as a special case. some enlightening responses here: http://stackoverflow.com/questions/3568222/array-slicing-in-ruby-looking-for-explanation-for-illogical-behaviour-taken-fr a[5..10] is within the range of the array, so you can write to it. a[6..10] is out of the range of the array, so you can't write to it. a[5..6] = %w(f g) a returns ["a", "b", "c", "d", "e", "f", "g"] 
I expect to get back nil, because in `[0, 1, 2]` there's no element 3, so a subarray starting from 3 with any length should be nil IMO.
I understand that, but what is the justification for this? What's a use case where one would rather want to think of pickets instead of the actual elements?
The positive effect of this is that the method is very consistent: it always gives back an Array as long as the first argument is within the array size. You are asking for a range which would have an effective size of 0 - and it is exactly what you get back. In other words: an empty array. It also helps to make the difference between empty results (your example) and invalid none (for instance if I asked for a range starting outside of the array size): arr = [1,2,3] arr[3..5] # =&gt; [] arr[4..5] # =&gt; nil This could have been implemented another way, but the logic behind is sound. 
&gt; It also helps to make the difference between empty results (your example) and invalid none (for instance if I asked for a range starting outside of the array size) 3 _is_ outside the array, the indices go from 0 to 2. Also I wasn't talking about indexing with a Range, but seems like its behavior is similar: if you overindex just by one, you get [], if you overindex by at least 2, you get nil.
I get it, it's a not well formed question, and maybe some of the information is rudimentary, but that's no excuse for you to be a douche back. Maybe we can offer him a perspective or insight he wouldn't get from searching. Remember if three people ask the same question 3 times, they more than likely have three different reasons for asking it -- one may not understand the language constructs, one may not understand the conceptual underpinnings, or one may just simply not know why it's not working for him when he read it should be working for others, and needs some help debugging. 
Looked at it, but we're pretty deeply locked into Chef. But thanks!
Many languages slice arrays with half-open ranges, e.g. in python the statement arr[0:x] returns x elements, 0 through x-1. In ruby, you can choose. There's either arr[0..x] or arr[0...x]. The first returns x+1 elements (0 through x) the second returns x elements (0 through x-1). If you want to slice an array into chunks of 10, you could do: arr[0..9], arr[10..19], arr[20..29] or you could do arr[0...10], arr[10...20], arr[20...30]. The second method actually has an easier calculation, because it is all multiples of 10. i.e. the first generalizes to arr[(x\*y)..(((x+1)\*y)-1)], the second to arr[(x\*y)...((x+1)\*y)] (for chunk x of size y). In that context, it makes sense to think in pickets. Now if you think in pickets, what should arr[0...0] return? It returns an empty list. So ruby allows you to select everything upto, but not including, the first element. And by symmetry, it allows you to select everything from, but not including, the last element. It also, btw, allows e.g. arr[2...2], which also returns an empty list, because you're selecting from picket 2 upto picket 2.
Salary as a junior programmer if it's not too much to ask?
I know this doesn't help at this point, but it's generally [a bad idea to subclass core classes](http://words.steveklabnik.com/beware-subclassing-ruby-core-classes) for this exact reason: Ruby's core library is either "optimized" or "inelegant" depending on how you look at it. Though I can understand why it's frustrating to expect the behavior, rely on it, and then have it pulled away. I'd still file a bug report as you have an easily reproducible test case and even if it gets closed, it's documented.
6\. Spending all your time reading articles about writing tests
http://railscasts.com/episodes/206-action-mailer-in-rails-3
The best strategy is to read ["Exceptional Ruby" by Avdi Grimm](http://exceptionalruby.com/). 
I recently switched to Jekyll as well. Absolutely love it. Very easy to get up and going.
Just checked it out. I have a few scripts written for stuff my co-workers needed. I can now just pass them the exe and let them do it themselves. Awesome.
Watir is also great for web scraping. I use it instead of mechanize for a few things.
Spending all your time writing articles about writing test.
Spending all your time writing comments about comments on reading articles about writing articles about writing test.
Great blog post! I have a habit of spending a lot of time on #1, deciding which tools to use.
Thank you very much.
Oh neat, the more I learn about Ruby Arrays, the more I love them :)
Yeah Jekyll is slick! And I still can't quite believe how smooth the conversion from Wordpress has been. Was even able to replicate my permalink structure in no time. Nanoc wins when it comes to flexibility and extensibility, but it can't touch the ease with which you can get a blog style site up and running on Jekyll. I've been really happy using both tools.
I've done a little rails, but not much. Is this book still ideal for me?
Think of a feature. Think of a way to test the feature. * Command-line: Cucumber * Library: Rspec Sketch out a test for the feature. Watch the test fail. Implement the feature, then ensure the test passes.
With [Honeybadger](https://www.honeybadger.io/), of course. :) If you're asking about exception/failure handling patterns, +1 for Exceptional Ruby.
Would brackets help? config.vm.network("public_network", {:bridge =&gt; 'en1: Wi-Fi (AirPort)'})
Sure, but nobody ever writes it that way. Though I should probably start for my own stuff, that's not a bad idea. 
&gt; semantic versioning Yeah, they really shouldn't call it "semantic versioning" if their version numbers can't be relied upon to indicate important things like compatibility. In fact, that's the whole point of having *semantic* versioning! If the minor version numbers are simply incremented every (e.g.) Christmas, then there's nothing "semantic" about it!! It's what they've always been doing with their version numbers -- making them up as they go along.
I can really recommend Cucumber and RSpec together. Cucumber for organizing business statements, and rspec to implement them mostly.* * I use Watir-Selenium and Cheezy's PageObject, as well as a bunch of custom matchers to do UI automation.
Great way to ensure you end up with a bunch of awkward code because you don't want to go back and change the tests now.
your method name should be in lowercase e.g. def hello also put some 'puts' in to see if it's going to you controller, you may need to fiddle with the routes.rb
Upload the project to dropbox (zip it or something).
If you have the discipline to do that (I don't think most people do, to be frank), I suppose it works, but then you've spent a whole bunch of time writing tests for a strategy you quickly realized wasn't so good.
Ultimately, the real question is why ranges outside the bounds of the array don't consistently return *either* [] or nil. Personally, I'd prefer [] for all invalid cases, but that's mostly because I really hate seeing "NoMethodError for NilClass" errors. I also have to admit that I've read [this answer](http://stackoverflow.com/a/3568281/1760544), from /u/tadrinth's link, a couple of times, and it doesn't make any sense to me. (Mainly for the reason that /u/herminator demonstrated in his comment. If Ruby were strict about not allowing sparse arrays, that would be one thing. But it happily lets you make assignments that are way outside the bounds of your array.)
Yes it appears to use some ancient technologies indeed. To be honest it would probably be hard for me to get it running, as it appears classic_pagination was around for rails 1.2.3.. Probably the only thing is to try and upgrade to a reasonable version of rails. Couple of questions: is there a Gemfile in there? This may indicate which versions of the software are needed If you are an extreme newbie, I don't envy your task.. If you put up the files on dropbox &amp; share it with me, I have some time today.. (Not sure why im feeling so generous..)
By Ruby convention, anything with a name starting in a capital letter is considered a constant. So, for instance, when you call "class SayController ...", what you're really doing is instantiating a Class object and storing that instance into a constant variable called SayController. But that's not important right now. I honestly don't know what the implications are for giving a constant name to a method, but I imagine your code would have wound up failing even if routes.rb were pointing to the "Hello" method instead of "hello". (Or, worse, it would appear to work and then proceed to behave unpredictably once you started using it.) EDIT: I went and tested this in irb. Giving a constant name to a method certainly does *appear* to work. Maybe it doesn't cause problems directly, but you should stick with standard naming conventions anyway.
In this case, no, it's not a constant. It *would* be if it weren't a method definition, but method names are just Symbols, so that's what you get here. To make this visible, define a method in IRB using Ruby 2.1 and see what happens: &gt; method_name = def Foo; puts 'foo'; end &gt; method_name #= :Foo &gt; puts method_name Foo #= nil &gt; Foo() foo #= nil &gt; EDIT: Note that you must either call the method with parentheses or call ```self.send(method_name)``` to access the method, because if you simply type ```Foo``` into IRB after running this code, Ruby will think you're trying to access a constant! END Edit This only works in Ruby 2.1 because that's when def started returning the method name. This is handy because you can now do private def Foo puts 'private foo' end and it will work as you'd expect. ```private```, when called as a method, takes a Symbol as a parameter, and makes the method with that name private. In this case, because the ```def``` statement returns ```:Foo```, you're just calling private on ```:Foo``` after the method is defined. A great move.
Here is the [Dropbox](https://www.dropbox.com/s/9bgdfei0x3bla8o/Bills.zip) link with the files. 
Yeah, I think it's important to make distinctions between "this is something I do all the time so I know what I'm doing and the tests are just verification for future refactoring" and "how the hell am I gonna do this?" Unfortunately, people who don't write tests are overly sensitive to the latter, while people who do write tests point to the former.
I think Govtrack.us has that data available via an API and their source code is open as well. Even if you get this working, the LOC might have changed their website and added features that your code doesn't expect. 
TDD is also good from a problem solving perspective because it keeps you focused on the output. It's easy to get tunnel vision when you're buried in an ingenious function but you've always got to be thinking about what you want to come out of it.
I think that Exceptional Ruby will give me all answers that I need. My question is about if we should just raise a exception or render a 500 page with somes generical message, for example. But I will read this book. Thanks!
vim
I've played around with several IDEs for Rails in the past. Every single time, I find myself going back to SublimeText. The main issue that I have is that I must use Windows as my Primary OS since I also do .NET development. I do equal parts of .NET &amp; RoR and may be working on two issues simultaneously so dual booting is not an option. However, I do use VirtualBox with an Ubuntu Server installation that I map a network drive to so that I can use SublimeText on Windows and just have the VM minimized. I played around with RubyMine and the Remote Ruby SDK, but it barely works and often causes more issues than not.
sublime bad vim good
Just want to throw this out there.. minitest is also a great starting point for getting into testing. Test unit syntax is very easy for someone who is familiar with ruby. You can't go wrong either way, as long as you're practicing writing tests all the time. The more you practice, the less those 5 reasons will matter.
Do explain. Don't get me wrong, I'm comfortable with vi as I use it every day to edit stuff in busyboxes. However, I haven't ever really seen a use over ST for day to day development.
vim
i can't take this article seriously without a mention of vim 
Use rescue_from in your controller to catch exceptions, and then render a 500 after you've logged the error. The book will explain this
I was JUST having this conversation with someone a minute ago. Having a degree is great for a lot of reasons, especially if you want the knowledge you would gain from such a degree, but also because it give you employable "power" in the workforce. People will take you more seriously because you have a degree, but it will not in itself get you a job. Many people in the CS field, including Ruby programming, are given jobs based upon their experience and work product and not their degrees (necessarily), but no one has ever been punished for having the degree. The obvious balancing factor is cost/benefit. NYU and New York City are very expensive and the job market is still not extremely strong. If money is not an issue, you can get ample scholarships, or you think risk is worth the reward, then go for it! If you are already a Ruby programmer or you are just dissatisfied in your life and looking for a change, there are better programs for less money that will give you skills that you need. 
No... Its exactly what I thought it was. A set of decent principles wrapped in the most unsightly of syntaxes. 
If the course is good it really shouldn't matter what language you use. The loaded question there is "What is a good CS course?". For me I'd lean strongly towards algorithms and theory where language is incidental. For others they want stronger SE content. From *personal* experience having looked into this last year (UK), I didn't consider a 1 years MS to be long enough really give enough depth but that's as much because my math is woefully inadequate for a math heavy course.
Spending a year with RubyMotion taught me a ton about Objective-C: - Something is complicated in Objective C... oh, that's really easy in Ruby. - Something really magical in Ruby... oh, that's totally possible in Objective-C. Awesome! - Some weird hard to track down dynamic issue in RubyMotion code... dammit, this would have been so much easier to diagnose in Objective-C It gave me new respect and confidence both with Objective-C (exactly as you said: good stuff with unsightly syntax) and Ruby. 
I don't disagree with you but it takes just a few days to get used to it and then you get on with your life and build great stuff. I enjoy writing stuff in both languages
I unfortunately do not have the experience to apply to these jobs. So freelancing it is
I didn't downvote, but I definitely think that you and I write very different ruby code from one another. I've been using ruby for years, and have never been able to talk myself into introducing things like type checking, matching, etc. When I build visitors, it's usually for dependency inversion, and I just build a ruby object that responds to the methods I care about. `Object#try` from rails 4's activesupport is really helpful when method calls are optional. Your matching style of visitors has more indirection, but isn't any less coupled to the object it visits. `SomeClass.(x,y)` looks a little funky to me, but that could just be me needing to get over myself. Anyways, if I had to inherit a ruby codebase that made liberal use of this gem, there would be a high degree of mental encumbrance to understanding the code, because pieces of other languages like Haskell and Java had been thrown in liberally. There are solutions inherent in ruby for some of the problems your gem solves. For example, the `Array#map` monkeypatch -- I leverage `Symbol#to_proc` plus the `&amp;` block coerce operator to achieve the same thing: `[1, 2, 3, 4].map(&amp;:to_sym)`. Anyways, I don't want to discount your gem at all or kill your buzz; it's fun put something out there in the world. This wouldn't be a gem *I* would use, but hell, maybe a lot of folks reason about code more like yourself and *would* enjoy using it.
Interleaving of "bare metal" C and Obj-C in "an arbitrary way", no graceful handling of error conditions, a runtime loop inside the main, runtime-managed, runtime loop (0_o) ...I don't mean to sound obnoxiously critical, but I don't see those practices as indictments of the *language* so much as the *code*. I'm sure I could write something just as bad in Ruby, for example.
You raise some fair points. The motivations behind some of these features aren't exactly things I would expect most people to run into. I added the type checking functions because I was using FFI and *really* needed to make sure that the objects I was passing to C code were actually of the types I expected. If they weren't, users could get a segfault instead of a helpful error message. The match and visitor code was largely inspired by ML style matching, and motivated by my work on a compiler project. This style of pattern matching makes it much easier to traverse ASTs. Thanks a lot for your response. Maybe some others will show up and share their opinion.
Surely, many thing I described are sort of tangible to ObjC. Though, my impression is that Ruby doesn't encourage any of that while ObjC does. Especially mixing up ObjC with C. Once again, that is only my impression after working with one code base. But it's one of commercially successful application written by professional ObjC programmers. So I assume it to be at least somewhat representative. 
Yeah, and actually, I can see how that style of matching would really be awesome in those cases. I'm just not seeing the value in this as a general purpose gem for every day ruby development. I inferred that you wrote this gem to adapt the style of programming you were used to in past lives to ruby; I was definitely incorrect. Looks like you were trying to adapt ruby to your problem set, which is the most awesome thing about ruby, imo. For certain problem sets, I think ML style matching is a really great fit; in those cases, I'd be more motivated to use a gem that *just* gave me that matching. Cheers!
I evaluated other EM-based solutions — I just missed em-websocket, which is odd, because searching my mind it's the first one I remember hearing about. The only thing I considered in the process and that could go against EM (and, consequently, against sinatra-websocket, faye-websocket and websocket-rails) was that some of the operations on the service were CPU intensive, and I was afraid of blocking the EM loop. Considering that, I needed threads and good performance, which led me to JRuby, and made a Celluloid-based solution attractive.
Responding to both you and coffeesounds: If you want to use *just* the matching or type checking you can require `filigree/match` or `filigree/types`. Each piece of functionality is fairly well compartmentalized, and pulls in as few of the other files as possible (usually zero, or just the ClassMethodsModule file). I put them all into one gem because I thought they were each too small for their own gem. Would adding a listing of the different files/modules to the README help?
You don't have to explain the concept to me. I know what it is. I don't agree with it.
We now have @(1) to create an NSNumber with a value of 1. There have been a lot of these improvements in the last few years. The wordiness takes some getting used to, but it makes things readable and thank goodness for autocomplete. :) 
If you do import static java.lang.System.out; then you can do out.printLn
That's definitely a neat trick, but I still can't fathom why something as common as outputting text to the console isn't part of the default namespace. It would be like writing `IO::puts("text")` every time in Ruby. And I don't have to `require 'io'` in every program.
Having short ways to output text, while convenient, are often little hacks. In Ruby, `puts` is a method on `Kernel`; in Python, `print` is a keyword (or a function in the global namespace in Python 3). Java, on the other hand, eschews small shortcuts in favor of a consistent, organized language.
I don't think java has any free/static function in default namespace(I suppose they could add something like a System.Prefixincluding a printLN allowing you to to statically import it (or automatically importing it)) I may be wrong.
This is rather neat stuff, but it is a bit omnibus. Try to take a divide and conquer approach, making some gems around shared behavior. That way you can really polish smaller gems that fit a need and get people wondering what else you made if you get this responsibility grouping right. 
Just out of curiosity, why are you writing ruby? This language doesn't have much going for it (in my opinion) other than being extremely expressive and highly opinionated community. One of those things we are highly opinionated (possibly above all other opinions) is testing driven development.
RubyMotion (just like Xamarin.Mac and Xamarin.iOS) doesn't compile to Objective-C, they use the fact that you can actually call methods directly in the Objective-C runtime and construct objects out of meta-programming to make it "work like Objective-C", but they never actually compile to Objective-C. And I think the main issue of not investing more in MacRuby is much more a resource availability perspective. If you are writing apps for Mac or iOS you will eventually find yourself calling C code from the libraries that still have no Objective-C wrappers (I wrote a wrapper for FSEvents not that long ago myself). Now, if after all these years, Objective-C is still not covering everything, when would they be able to cover this stuff with MacRuby? For them, even with all the trouble, the fact that Objective-C can interact more or less cleanly with C has been a huge gain, putting their bet in something like MacRuby would require a huge investment into making all those APIs there as well and I think someone there figured out there wasn't that much value on it. I wouldn't pick Objective-C as a language for something I'd write unless it was a requirement, but albeit it's unnecessarily long sequences of characters for method calls, it has some interesting design decisions, like having immutable containers by default, bindings and the Cocoa UI toolkit. It's definitely something you would choose to use, but there is still some value in learning it and looking at how people solve problems with it.
I'm mostly just following this sub out of curiosity... most of my work is in C# with some Perl on the side. I didn't realize I was stepping on one of the Ruby community's sacred cows by voicing my distaste for TDD.
I learned with Lynda.com tutorials. Here are a bunch of resources kept up to date: https://www.ruby-lang.org/en/documentation/ It's definitely worth reading through [The Pickaxe Book.](http://ruby-doc.com/docs/ProgrammingRuby/) And since you're coming from C++, [here's a language intro tailored just for that.](https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-c-and-cpp/)
I believe the openssl standard library package has an HMAC implementation. Also Base64.strict_encode64 shouldn't add the newlines.
I read your post, and the entire GitHub readme, but I'm still not entirely sure what the gem does.
All good points, but @"" strings have been around since the early days of Objective-C. You may be thinking of @() numbers, @[] arrays, and @{} dictionaries, which only came in the last few years.
Right you are!
Hey there, The Pickaxe Book mentioned by @Godd2 is great. You can also try CodeCademy.com - it has it's ups and downs but overall it is a good course. After CodeCademy I did the Ruby Monk (it's great, especially the tasks!) and then go to Ruby Koans. Doing all three will give you some nice background (icluding TDD). Have a good day, Mike
For the lazy: &gt; mruby is the lightweight implementation of the Ruby language complying to (part of) the ISO standard. mruby can be linked and embedded within your application. We provide the interpreter program "mruby" and the interactive mruby shell "mirb" as examples. You can also compile Ruby programs into compiled byte code using the mruby compiler "mrbc". All those tools reside in "bin" directory. The "mrbc" is also able to generate compiled byte code in a C source file. You can check the "mrbtest" program under the "test" directory. &gt; &gt; This achievement was sponsored by the Regional Innovation Creation R&amp;D Programs of the Ministry of Economy, Trade and Industry of Japan.
Thinking about it some more... &gt; It all depends on what your definition of "is" is. If by "these methods return a new `Hash`", the docs mean "these methods return instances of the standard `Hash` class" then, yes, the 2.1.1 behaviour is correct. But if they take a more historically Rubylike interpretation and mean "these methods return new objects conformant to the interface *defined by* the standard `Hash` class", then I'd argue that the most reasonable assumption is that they return an instance *of the `Hash` subclass they're called on*, rather than an actual `Hash` instance. Java or Ruby? You decide... ...but I suspect the implementers, if asked, would say that they did it that way for performance reasons: the doc states that it's a *new* `Hash` (or `Hash`-*like*) object, and simply instantiating a `Hash` is faster/easier/less prone to error (pick any four) than walking the inheritance chain for `self`.
&gt; This book documents Version 1.6 of Ruby, which was released in September 2000. Is the content of the Pickaxe book still relevant today?
Am I the only one around here.. That genuinely likes Obj-C syntax?
I'm very much aware that ObjC is not new. Though, my main complaint was that it's a hack to get some Smaltalk-ish properties on top of C instead of a good Smaltalk implementation. Mixing two syntaxes (C and basically Smaltalk) is a huge compromise and I don't believe anyone ever though of it as a solid technical decision. Regarding multiple implementations per interface. Yes, I think I'm talking about categories (I'm an ObjC noob). And Yes, I've seen it used for mokey patching. ARC is a solution for Objective-C Runtime but is not for everything else out there. You can use C code and libs directly and there ARC can not help you. @"" and others only make it more complicated because `@""` is very different thing than `""`. Same goes for `@()` and `@[]`. They look so similar to their C counterparts but act completely differently. Again, I see it as a problem that comes from Objective-C being a superset of C. So that we could talk about something real and not only about some abstract things: here's a code base of [arq_restore](https://github.com/sreitshamer/arq_restore/). Could you please take a look at it and tell me how typical is it for Objective-C to be written in such a manner?
I've had absolutely no issues with Snooby. I have some example code in a bot that I wrote here: https://github.com/bloot/GrammarNaziBot. If you decide to use it and have any questions feel free to PM me. 
And for the confused: &gt;mruby targets game developers (to use instead of Lua), embedded application developers (devices, TV, phones..) and small memory footprint server applications (instead of JS for instance). http://matt.aimonetti.net/posts/2012/04/20/mruby-and-mobiruby/ &gt;If you don’t know Lua, it’s quite close to JavaScript in the sense that it’s a prototype based language and you can therefore write code that is Object Oriented. &gt;Ruby being a full OO and richer language, you can organize your code differently and write more of your complex logic in a scriptable language. One could even potentially leverage the language to create its own Domain Specific Language in pure Ruby and create a “Rails like” experience within its application. http://matt.aimonetti.net/posts/2012/04/25/getting-started-with-mruby/
What is "heat"?
I love codeschool.com it's a paid service but I find their quality unmatched.
It's not just this; I actually enjoy the verbosity. It feels strange to me when I hop over to another language that doesn't name each of the function parameters
I don't have source code access, but compiling to LLVM byte code doesn't mean much, your native code would have to call the Objective-C runtime in all cases (the runtime itself is just a collection of C functions to create objects, call methods and so on), you don't have any other way to access Objective-C objects from C. RubyMotion also bundles a GC, due to the lack of GC in the iOS Objective-C runtime. 
The verboseness is good for self-documenting, and with Xcode, it rarely takes more than 5-6 keys no matter how long the message actually is. 
NSNumber is an object wrapper that supports several primitive types. NSUInteger or NSInteger are typedefs that make the C primitives look more Objective-C-ified. Each to their own though, I prefer the verbosity and parameter naming when it comes to reading code. Typing it is no ballache, Xcode has terrific auto-completion
Care to back that up with something other than the Rubymotion home page?
Don't discount all of the "older" works just yet. Ruby's been around since 1995. A book that's four years old now was written when Ruby was 15. The new features are different in the details, not in the concepts. * [The Well-Grounded Rubyist](http://www.manning.com/black3) Go to the publiisher's site for [The Well-Grounded Rubyist](http://www.manning.com/black3). (Skip the Amazon link in the subreddit sidebar.) The author is creating a second edition right now. If you buy the 2nd edition from the publisher's early-access program, you get a PDF of the first edition free. Go read the sample chapters (1 in the second edition, 2 in the first) and see how you like it. _Well-Grounded_ is the most carefully written of the tutorial books. We started a Ruby study group to read and discuss it, it's that good. I looked at six books before choosing that one. * The Pickaxe book? A couple of us in the study group weren't as thrilled with the Pickaxe book. It was great when it was the only serious book about Ruby. Nowadays we have other resources to take us where a single book couldn't go. * [Eloquent Ruby](http://www.eloquentruby.com/) A good second book is [Eloquent Ruby](http://www.eloquentruby.com/), our group's runner-up. It's not a tutorial and its author doesn't recommend it as one. But you'll learn how to write Ruby -- instead of writing C++ using Ruby syntax. * [Practical OO Design With Ruby](http://www.poodr.com) Given that you're coming from C++, you're used to working with object-oriented ideas. If you wanted to polish up your OO design skillz, take a look at [Practical Object-Oriented Design with Ruby](http://www.poodr.com). It's the chattiest of the Ruby books, as a writer would say, but its ideas are critical for good program design. * [Learn Ruby the Hard Way](http://ruby.learncodethehardway.org/) You learn to write Ruby by writing Ruby. Also by looking at a lot of good Ruby. There's a lot in the Ruby books, but you need to type. Check out [Learn Ruby the Hard Way](http://ruby.learncodethehardway.org/). It's all on the web. You can also buy a PDF for three bucks to take with you. A workmate who learned Ruby highly recommended it to us. * Ruby Koans? The Ruby Koans were an interesting idea but they can be frustrating. You have to be okay with googling up answers when you're stuck. I'm too weak-minded. Going out to my browser took me too far offtopic. I needed something that would help me stay focused. The Koans weren't for me. * [OmniRef.com](http://www.omniref.com/) After you're a few chapters into whatever book you choose, you'll be ready for a good online reference to Ruby syntax and libraries. [OmniRef.com](http://www.omniref.com/) is the best I've seen so far. (The website designer announced it on Reddit.) It shows you the methods and examples. If you really want to geek out, you can see the C code for the Ruby interpreter. It shows you how that language feature was implemented. Go look at the String class. 
All caps would make it a constant (as far as constants go in Ruby). I think constants have a slightly different handling of scope than normal vars, so as a constant this variable can be visible inside the method, while a normal variable is out of scope. Alternately to what you have you could use $ to declare a variable in global scope like $hash, if this makes sense for your code. 
From the rubymotion homepage: " Thanks to this tight integration, Ruby can interface with iOS and OS X very naturally at no performance expense." "neither the code is interpreted" So I am not sure exactly where you are getting the performance issues bit from.
My 2 cents: I think the issue is bigger than just performance. I really enjoy the Ruby language (for Rails mostly) and think RubyMotion is incredibly interesting. Unfortunately, I think it is too risky to use in an important project for one main reason: it adds a layer with a (smallish at the current time) risky dependency on RubyMotion and you might not be able to work on the latest &amp; greatest from Apple right away vs. just going direct to the platform vendor (Apple). That said, for a small personal projects I think I would try it.
Anything that involves a Ruby VM at runtime is going to incur a significant performance overhead compared with Objective-C or similar. What they may mean by the above statements is that no *extra* overhead is incurred, i.e. that calling a platform function is a "toll-free" operation with similar performance characteristics as calling any other Ruby method. But let's be clear: Ruby is slow. It's slower than almost anything out there. Oftentimes, you don't care about that, because it wouldn't be a bottleneck anyway (that particularly true for UIs or a lot of I/O-bound tasks). But if you *do* care about wall-clock performance (you're developing, say, a physics-intensive game), Ruby is usually not a very good choice.
Is there a ruby vm at runtime? I don't think there is. 
Going back to the q of performance though, simonask makes the point that Ruby isn't the go-to language for high-performance in the first place. If that's the #1 goal, then objective-C is the way to go. It can be really worthwhile to go with RubyMotion if there is an interest in code portability from a directly related Ruby project.
Thanks for the insight, and it cracks the argument open to say that the performance issues aren't with RubyMotion but with Ruby in the first place. How does Objective-C's performance rank compared to the most common languages? I am guessing it is relatively high-performance given its roots in C.
im using 'heat' as a metaphor to describe the distance of time of an ActiveRecord ( or collection of) from a reference point in time. i'm building a founding for visualizing cohort analysis on activity within a system ( particularly user behaviors within a game). sorry its not so clear yet :) the next release will add visualizing of this data and it may make more sense then
I'm pretty sure RubyMotion compiles everything into machine code like Objective-C.
There is no Ruby VM at runtime. Rubymotion is a Ruby dialect of Objective-C that **compiles** down to the same Objective-C machine code. The OS runs the machine code and knows no difference.
And that's definitely their target audience. If you have a Ruby shop without any iOS devs and need to build an iPhone app, RubyMotion could be a good fit. If your Ruby shop already has iOS devs, however, then Objective-C is probably the better answer - not necessarily because of performance, but because of uncertainty as mentioned above.
Thank you, jemminger / gensyms / error_and_trial this brings a lot of clarity to my question. In that case the only issue that stands is the added layer of risky dependency that chicagobob mentions? Or I would be curious to hear if that is disputable as well.
makes sense! Thank you for your answer. I will build my knowledge from your answer.
~~No.~~ ~~If you are just starting out, then having a robust community of developers, a stable language specification and large ecosystem of libraries, tools, etc. will be considerably more important that the specifics of any given language.~~ ~~Learn something common, then worry about the details of language design and implementation and investigate other languages accordingly.~~ EDIT: lol. I read "Rust" instead of "Ruby," so the above applies much less (though there may still be some relevance, so I won't delete.)
Yes. It's slightly harder than Python, but it's still very simple. Ruby vs Python vs Perl vs Lua vs PHP vs other is mainly personal preference.
Okay lol
I'm no expert on RubyMotion, but achieving Ruby semantics in Objective-C still has some overhead compared with "native" Objective-C, simply because native Objective-C has: 1. Less dynamicity (Ruby requires the ability to modify *everything* at runtime, which in turn forces the runtime to keep most indirections around that can be optimized away in Objective-C) 2. No garbage collector. ARC is not equivalent to a Ruby GC, and the Objective-C garbage collector is deprecated.
[Since 3 people responded with basically the same thing...](http://www.reddit.com/r/ruby/comments/1z37sy/where_do_you_stand_on_rubymotion_vs_native/cfq7od9)
Try ruby is probably very basic for you if you're coming from C++, but [codeschool](https://www.codeschool.com/) has more advanced ruby courses too.
I am 40+ but know about a dozen languages at various skill levels so take that in consideration. I tried learning Ruby and Python simultaneously and somehow, Python was far easier to grok than Ruby. However, Ruby looks much prettier than Python. I would suggest you learn both but if you had to choose one, start with Python for couple of weeks before adding Ruby. Do as many hands-on examples as you can and work on building something usable, a small project, in both languages. Should give you good experience and show the difference in flavor as well.
Alright, thanks for the help.
In general, Ruby methods give no consideration to "self.class"; it's not efficient and having an object's class affect implementation would violate "duck typing". It's simply not "the Ruby way". Consider the analogous methods in a subclass of Array. They likewise return new Array objects. &gt;&gt; class MyArray &lt; Array; end =&gt; nil &gt;&gt; ary = MyArray.new =&gt; [] &gt;&gt; ary.class =&gt; MyArray &gt;&gt; ary2 = ary.select { true } =&gt; [2] &gt;&gt; ary2.class =&gt; Array &gt;&gt; ary2 = ary.reject { false } =&gt; [2] &gt;&gt; ary2.class Perhaps it could be argued that these methods should construct their return value using "self.class.new", but I would disagree.
Not surprised to hear your experiences w/ JavaScript. Its a very odd and different creature, I'd suggest tackling that after you've got some experience under your belt and know a few languages. I've been programming for 40+ years and still feel its pretty odd. Good Luck.
Check http://iwanttolearnruby.com/ out! I learned Ruby like 6 months ago. My path was TryRuby.org, Rails4Zombies, RubyBits (all of them were from Code School), read some chapters of the Pickaxe book (Programming in Ruby), RailsTutorial.org, crying because it was too many things to learn at once, then code a Sinatra app. Afterwards back to RailsTutorial again, then code on Rails (no tests), then read testing books, then put tests in the app, make new app using TDD. From time to time I go practice on http://rubykoans.com and http://codequizzes.com.
Ruby (and esp. Rails) has a lot of "magic" though. Once you understand where it all comes from, it's really cool and expressive, but it makes the learning curve steeper in the meantime.
Thank you for the help.
Some good ones linked here: http://www.reddit.com/r/rails/comments/1xfnan/skinny_rails_controllers/cfb5btc Also the "Fuck You, Pay Me" http://www.youtube.com/watch?v=jVkLVRt6c1U video if you do consulting 
Oh, I love good horror stories ;) jk General comments: 1. You have been programming against the implementation (a hash containing data)*. If performance isn't a major factor and you can afford to do it, use a class to represent that data structure. 2. Store the date as a date not as a string. 3. Your score-date pair I'd consider making into either a class or struct. AGAIN don't code against the implementation, code against an abstraction. * * What I mean by this is, even if you are just using an array for storage and are unlikely to change this *ever* write some container class to wrap around it. While you can preserve array like semantics (e.g myStore[100]) if appropriate, it allows you far greater flexibility. RE: Final Solution Far nicer, its what I love about ruby - a few lines of code can be boiled down to something quite elegant.
Here's what I came up with in a few minutes: https://gist.github.com/anonymous/9256871 How should this evolve? The hash is obviously a store or repository of some kind, the values are venues, which have various attributes like name, ratings, and geometry. You should create appropriate objects like that. Mucking around inside triply nested arrays is good enough for one-off scripts, but if this is going to evolve any further it will be harder to change, or even remember how this works in the first place.
Ruby's great and has excellent beginner resources. http://tryruby.org Normally I don't recommend non-free resources, but the CodeSchool Ruby stuff is good enough to pay for: https://www.codeschool.com/paths/ruby
I am no expert myself. I do however, own RubyMotion. So if someone can develop a battery if tests -- perhaps we can come up with a good answer regarding relative performance. 
I'm a HS student. How long do you think I can learn Ruby if I commit 3 hours a day to Ruby?
You're right. The `has_many` relationship idea is a good one. I may go that route.
I personally recommend Python for beginners. It's less magical than Ruby, and it enforces good code structure through its whitespace-significance.
Asking in /r/ruby you will get very biased answers. It is a good language and has a great community. If there is a problem it will be if you look to do something web based and people recommend Rails which sadly has a steep learning curve. More importantly though, Ruby has a number of philosophies that I wish were emphasized more in the general programming community hence if there was actually a good reason to learn Ruby over another language, its for those more than the language itself.
Full disclosure: I prefer RubyMotion. I primarily work with objective-c at my day job -- so I'm very comfortable with apple's frameworks and documentation. Which makes it super-easy to transpose the examples in my head. I suspect that it would be difficult for someone not already familiar with objective-c and apple's documentation. 
To be honest, I am going to go against the grain here and suggest you learn Java/C++/C first over Ruby. I love Ruby to death, but you wont get a lot of the core comp-sci knowledge with Ruby as you would with Java/C++/C. With the exception of Java, you will learn how to properly handle your memory management instead of depending on Garbage Collection. You will also learn a lot from compiling your code, and how to optimize. Now, with that said, once you learn the basics of Java/C++/C, I would highly suggest Ruby. It's a fun language and has a very robust library. Once you understand a C-based language learning Ruby will be a breeze. Hell, learning any language is easy once you have a grounded understanding of one of the three I suggest. Good luck with your endeavors. Remember, with much practice come much awesome wizardry.
What is your end goal? Do you want to eventually write games or demanding applications? Then go with C++ instead of ruby, but the learning curve is much harder. And by harder, I mean segfaults galore! Knowing C++ will give you a good idea of what is going on under the hood for most languages. Do you just want to start to learn how to code, write some scripts, maybe some web dev work with Ruby on Rails in the future? Ruby is a fantastic way to do so.
Well, my goal is to be a Software Engineer.
Alright, thank you very much for the help.
Hi. If coding is completely new to you, I recommend checking out: [Learn to Program](http://pine.fm/LearnToProgram/). It's a well written introduction to coding in general and uses the Ruby language. As for what to focus on afterwards, you should first understand what the different languages are for. Please note that the following is for web development. If you are looking to code games, the tutorials on [unity3d](http://unity3d.com/learn/tutorials/projects) are a good place to start. **The process of requesting a web page.** * A browser will make a request to a web server. * The web server will execute code to generate the information requested by the browser. * The code that the server runs will be in either **Ruby**, **PHP**, **Python**, **Perl** or **Java**. (these are the main languages, but there are others) * The web server will also communicate with a database, using the language **SQL** * After executing its code and talking to the database, the server will then generate a combination of **HTML**, **CSS** and **Javascript** that it will return to the web browser. Here is a brief description of these 3 languages: * **HTML**: This is the primary language that web browsers understand. It allows you to display Text, Images and Forms and embed external objects such as a streaming video player or a flash application. * **CSS** This is the way HTML is styled. It allows you to choose different colors for your texts and backgrounds, and set values for column size, margins, borders, etc... * **Javascript** allows a web browser to dynamically manipulate the HTML elements that are on a web page. You can resize elements on the fly, insert some where needed, hide or animate elements. All of this is done dynamically, meaning that it is done on the browser side, without requesting any new information from the server. To make the best use of Javascript, you will want to use a library of javascript code like [Jquery](http://jquery.com/). **Web Frameworks** When coding web server applications, you will eventually run into problems managing it. To ease development, frameworks have been built on top of their native languages: For Ruby, there is Ruby On Rails. For PHP, there is Symfony. For Python, there is Django. I personally use RubyOnRails, but have heard positive feedback from the others. **Final Notes** For Web Development, you will need all of the following: * HTML * CSS * Javascript * One of the following: Ruby/Python/Perl/PHP/Java * Ideally, a web development framework such as RubyOnRails, Django or Symfony. To ease into it, you should do the following: 1) Learn the basics of coding and ruby. As mentioned at the top, [Learn to Program](http://pine.fm/LearnToProgram/) is a great place to start. Follow up with [Learn Ruby The Hard Way](http://ruby.learncodethehardway.org/book/). 2) Learn HTML and CSS. Code them both in the same text file on your desktop, change the file's extension to .html and launch it with your browser to test. 3) If you choose to stick with Ruby, learn RubyOnRails. You may prefer [Codeschool](https://www.codeschool.com/) to Codeacademy, particularly their Rails For Zombies tutorials. 4) Read up on some basic SQL, then read up on how your chosen framework interacts with a database. 5) Read up on Javascript and Jquery. Then try to code a few simple scripts. Again, you may prefer CodeSchool to CodeAcademy for this. You can sample their try jquery course here: [TryJquery](http://try.jquery.com/). Once comfortable enough, look into Coffeescript (a friendlier way to write Javascript). Edit: Thank you for the gold :) 
I'm not sure what you mean "learn". I'm 25, I learned Ruby like 6 months ago. About 2 months in is when I understood how to make a Ruby on Rails app. Don't worry about that yet. Basically what you want to happen is you have to have some sort of "end goal" in mind. Ex: Todolist application, your own blog, etc. I think by at least 20 hours you should have some sort of progress. Check this out: https://www.youtube.com/watch?v=5MgBikgcWnY. If you can get a copy of the book it would help you in your life, I think. It helped me when I picked the book up when I was 24.
If HTML is pretty interesting then go for it. Then you can learn CSS to make a simple website of "About Me". Once you learn Ruby you can make your own blog via a software library of Ruby's which is called Jekyll. Then you can learn the tool which we developers use called Github to put your blog on the Internet for free. Check out http://www.codeschool.com. Tons of resources there, focused on Ruby too. I find http://tryruby.org better than Codecademy, but the more resources the better. Small achievable steps with "something to show for" is the way it is in programming, I noticed.
For my part, I first tried learning to program with Python when I was your age. I quit after a week— something about the language just rubbed me the wrong way. Soon afterwards I tried again, with Ruby, and I absolutely loved it. Later, I learned Python again, and I like it a lot now— but, as a beginner, I couldn't stand it. OTOH, I hear a lot of people say the exact opposite! I'd recommend just trying any one out, but don't be afraid to try a different language if you're struggling with your first choice.
Hey there, Jpugh99 :-) There is a lot of overwhelming answers here ;) Do what I did - create an accoutn at codeschool and complete both Python and Ruby way. Some may say that Ruby is a bit harder but I think that they are on the same level. I tried both and simply like Ruby more. Have fun while programming ;) Mike
Thanks, I think I'll just go with Snooby. Seems to cover all the use cases I need.
Its a shame they didn't put a bit of effort into the site; get people excited about it.
**EDIT: Please not that the guy I responded to changed his post considerably. He was claiming that C++ has the *most* job offers, not just more offers than Ruby.** Please do not listen to this. The claim that most of your classes will be in C++ is definitely wrong for many schools, possibly for most schools. It is equally wrong for job offers, which are dependent on the area of industry you are in. If you are going to do systems programming, embedded systems, or something in the direction, then go with C++. Otherwise, don't burden yourself with it and just learn Java if you want something "C style" that you will be able to benefit from career wise. It will be a much easier path, and you can also pick up C++ later.
I'm not sure about RubyMotion on OS X but on iOS it doesn't have any GC and uses system similar to ARC. It handles all the allocation/release of objects at the compile time rather than at the run time.
Yes. I teach all of my new hires (non-programmers) to code in Ruby. It's a very solid fundamental language -- object orientation, concise syntax, lack of general idiocy. Here's a good book for you: https://pine.fm/LearnToProgram/ I'd recommend buying the actual book version. It's fantastic; it starts simple but gets tricky pretty fast =)
&gt; it enforces good code structure through its whitespace-significance This is the least compelling reason to learn python, and it does nothing to enforce good code structure. It enforces code formatting.
Yeah, I think Python's easier for programmers to understand, but I think Ruby's easier for non-programmers to understand.
+1 for Learn to Program. I've taught 10 people to code with it.
Very cool!! Any thoughts on Q in other languages (i.e. Python)?
Do you have any examples for how ruby is magic? Just curious what you mean. I know rails is but I've never had that sense for ruby. 
Can you explain the magic in ruby? I asked this earlier but I'm really interested in this perception. 
That's a long term goal I would say. My brother started Qjs a few days ago. https://github.com/llambeau/qjs
I would agree with this too. Then learn perl followed by ruby or python. This will make learning ruby or python feel like you are alive again and there is hope for the world. 
Please refer to the RubyMotion documentation. I'm not an expert RubyMotion developer either.
Lets do some simple magic. def puts str super str + ' magic!' end then later that day ... puts 'hi' # output 'hi magic!' Of course, it may not be completely evident how this occurred, and tracking it down could prove to be difficult. When it's hard or awkward to track down the the how or why of something, it's often referred to as "magic".
Here is part of my reasoning towards my claims. I am assuming software engineering is referring to simplify programming which includes embedded programming, web development, and the more "general" programming, in which case I am using indeed to compare the numbers. http://www.indeed.com/jobs?q=Ruby&amp;l=USA Gives me 14k jobs in the USA http://www.indeed.com/jobs?q=C%2B%2B&amp;l=USA gives me 32k jobs in the USA While this is most certainly not the ideal way to measure how many possible jobs, I feel it gives a good idea regarding that there will be more C++ jobs than ruby jobs, based on the general term of software engineering. Regarding most classes, what schools are you referring to? I am going based on Computer Science classes at Cuny Hunter and friends from related colleges. Not to mention, I can't imagine students completing a computer science major without having a firm grasp on pointers and related low level topics. If you do feel I am wrong still or have any information pointing otherwise, do tell! Perhaps if /u/Jpugh99 would tell us more concrete information on which path he would wish to take then we will reach agreement.
Starting off is significantly challenging and a struggle because the syntax is unfamiliar, idioms unvisited and libraries unknown. However, the compare and contrast actually improves understanding. At that point, I stick to whichever language is better for my immediate needs and go on to develop some proficiency in it. I need neither Python nor Ruby in my day to day work. Heck, I don't need any programming language for my work but I learn them simply because I enjoy learning them. 
http://www.rubymotion.com/developer-center/guides/runtime/#_memory_management Unclear what and how it does it, I'd say. In any case, it's a great implementation. Being able to run Ruby-like code around the Objective-C runtime (and in a way that you can sell it) is an amazing feat already.
"magic" is just an exaggerated way of saying "special expressions" or "domain language". Ruby is able to make very unique, concise, and expressive code, and libraries take advantage of that, creating special syntaxes like (in Rspec): # test that validation works describe "the validation method" do let(:invalid_arr) { Foo.new(INVALID_SIZE) } it "should check array size" do invalid_arr.valid?.should be_false end end # what exactly is `be_false`? # when is invalid_arr actually created? # what does `describe` and `it` do? Sure, it's amazingly concise and expressive - you can almost read it like English. The "problem" is that it's not "normal code", i.e. "vanilla Ruby". It's a special syntax that creates an abstraction layer on top of normal code syntax. My concern is that after getting past the "Introduction to Programming" stage, you'll very quickly come across special Ruby syntaxes that would dilute your understanding of normal code, which should be your priority at this point. If I wanted to be really critical about Ruby, this is basically my reason to recommend Python over Ruby as a first language. However, I personally love this quality Ruby has. If this methodology and/or the challenge excites you, then by all means, start with Ruby.
If you program web applications you will likely end up using HTML anyway. HTML is not a programming language though. Its a way of telling a browser "this is a link, this is a heading" etc. Most web applications go for one of two options: 1. Have back end code written in your language of choice that generates HTML including your data for the browser. 2. Send the user a HTML page with some JavaScript on it, which downloads data from the backend (written in your language of choice, may even be JavaScript) and inserts it into the page.
&gt; The "problem" is that it's not "normal code" I don't agree with that statement. That is perfectly normal code. if anything makes it magical it's the fact that it's not immediately evident where those methods are coming from. This is not a "new syntax" any more than defining a new method for an object is a "new syntax".
That's why I put it in quotes. It's not normal syntax. To programmers unfamiliar with what ruby does, it doesn't even look like valid code.
So it looks like your bot has a bug. You're constantly retrieving the /r/all comments in an infinite loop, but you may very easily be getting duplicate comments. Additionally, you'll be making lots of unnecessary requests which return the exact same response while you wait for reddit's API to flush its cache. PRAW provides a comment stream helper which does all these things, implemented here: https://github.com/praw-dev/praw/blob/master/praw/helpers.py#L90 Unfortunately, none of the Ruby reddit API wrappers provide anything like this. I suppose I'll just have to implement it myself. edit: None of them seem to natively support API rate limit handling, either (other than sleeping by a static amount per request). I might just have to write this in Python instead.
You don't need a test to tell you that a virtual method call / dynamic dispatch is slower than a direct method call / static dispatch. You don't need a test to tell you that running a garbage collector is slower than ARC under the specific workloads I mentioned. This is not a question of ideology. It seems reasonable that RubyMotion can approach Objective-C in performance under normal workloads, especially in apps that are mostly UI (i.e. not CPU-bound). It is *un*reasonable to claim that a dynamic language like Ruby will be on par with Objective-C in all cases. EDIT: Just to be clear, I'm aware of all the clever things the Objective-C runtime does to cache method invocations at call sites and so on. A lot of that relies on the fact that you can't change or rename a method of a class in Objective-C. You can do that in Ruby, and you can't just let it become a new metaclass without breaking Ruby semantics.
Java, sure. C, sure. C++ What are you smoking? :-) 
If OP is in the US. OP would be in middle school or high school right now. Most US computer education at that grade level is formally in Java (not my favorite language, but its adequate). I strongly disagree about your comments on C++ being the first language he should learn. Regardless of how widespread its used (or not), the standard is a MESS. There are some industries where C++ is common, but in my environment the key languages I need are: C, Objective-C, Ruby, HTML (if that is a language), BASH, and a little SQL. Personally, I've never used C++ outside of a classroom. So, I think its all very geographic and industry dependent.
&gt; What I mean by this is, even if you are just using an array for storage and are unlikely to change this ever write some container class to wrap around it. While you can preserve array like semantics (e.g myStore[100]) if appropriate, it allows you far greater flexibility. This code smell has a special name: "Primitive Obsession". 
Thanks for the spot check! To be completely honest I just used the example from the Snooby repository for my comment polling. Initially in my testing I what printing to terminal to look for duplicate comments as well as monitoring posts my bot was making but I was unable to find instances of this occurring. So, I am not 100% sure either way but I do appreciate the help. Best of luck.
&gt; http://www.indeed.com/jobs?q=Ruby&amp;l=USA Gives me 14k jobs in the USA &gt;http://www.indeed.com/jobs?q=C%2B%2B&amp;l=USA gives me 32k jobs in the USA And Java gives nearly 70k. So, even using *your* metric, the claim that most job offers will be C++ is false. &gt; I feel it gives a good idea regarding that there will be more C++ jobs than ruby jobs I don't really doubt that at all. The issue is that you didn't say that C++ will lead to more job offer *than Ruby*. I.e., this is a (possibly accidental) strawman. &gt; Regarding most classes, what schools are you referring to? I am going based on Computer Science classes at Cuny Hunter and friends from related colleges. So, when you say "most of your classes", you mean *most of your classes, assuming you go to a certain subset of schools*. My retort is that this depends on the school. I don't doubt that some (or even **many**) schools do use C++ for some (or even **many**) courses, but simply stating that a future CS student will use C++ in "most" classes without any additional qualifications is simply absurd. I for one, took a single C++based course in my 8 years of CS classes (spanning across three schools). Even at schools where C/C++ is an introductory language and used for a few core classes, that in no way implies that a given student's particular path will be "mostly" C/C++, since school's typically do not bind students to a single language. In my experience, it's actually rather common for schools to have an intro language, then require another language like C++ or Java which represent more of what one would see in industry, then pretty much arbitrarily picks languages for most other courses. For instance, one might learn C++, then use it in 3-4 courses, but never use it again, because he or she is taking courses related to web applications, mobile devices, etc. &gt; Not to mention, I can't imagine students completing a computer science major without having a firm grasp on pointers and related low level topics. To begin with, this does not imply that "most" of one's courses will require C/C++. Additionally, C/C++ aren't the only languages with pointers. I learned about pointers using Ada, for instance. Of course, you don't have to take my word for it... [Just listen to Joel's complaints about the tendency of Universities to become "Java Schools"](http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html) 
&gt; I'm particularly interested in knowing if there was a better way to structure my hash. To clarify: You have full control over the data structure and it's not something you get from some external API? If so: Don't even think about using nested arrays. That's called primitive obsession and makes for pretty hard to understand code. /u/morphemass pointed out a few alternatives. That being said: Your final solution is pretty nice. ``` date_sort = -&gt;(x) { x[1].split('/').reverse } ``` My though process when looking at this line: 1. What is `x`? 2. Alright, it's an array with at least two elements. 3. The second element is a string and probably contains some slashes. 4. ??? 5. I'm searching for some example data structures and/or debug print some variables. 6. I find an example and still have no idea what the first element of the array means. The second one is a date given as a string formatted as `MM/DD/YYYY` which is horrible. This string format is only acceptable when entered by a user, but should not make its way into the internals of any system. Iso8601 exists for a reason. Even better: `Date`. tl;dr: Every time you use nested primitive data structures you lose the ability to give them names. This leads to harder to understand code.
Hi, I am familiar with git (my username is rws4px). The Ruby version I am running is 2.1.0p0 (which comes preinstalled in MacBooks). 
What do you find odd about JavaScript, out of curiosity? To me it feels like the most intuitive web language, especially with jQuery. I'm struggling a lot more with Ruby than I did with JS. 
&gt; While this is most certainly not the ideal way to measure how many possible jobs, I feel it gives a good idea regarding that there will be more C++ jobs than ruby jobs A big reason why there are more C++ jobs is because there are more C++ code bases out there which need to be maintained. And I've yet to find a C++ code base which I'd like to be part of. So, I'd be pretty cautious before using the amount of jobs for any kind of argument.
HTML is really straightforward and simplistic, especially today. You could spend one day studying it, write a single page of notes, and know pretty much everything you need to. And it's a prerequisite for JavaScript too.
6. The first element of the array is an integer representing a score (min 50, max 100 in case that matters). The second array element is indeed a date formatted as a string thusly "02/27/2014" I did not choose this format as the dates were a column in a CSV file I imported into the db (postgres). I dont know much about databases but I'm sure if I look into it I'll find that there's a 'date' data type for columns or something. If there is perhaps I should have used that. Edit: Just looked into it... maple_dev=# alter table restaurants_test alter column inspection_date type date using ("inspection_date"::text::date); This command converted the column to this format: 2012-09-13 with type date.
Interesting. I'm a similar age but I had the opposite experience. I knew Perl very well first though and whilst they're different languiages Ruby just feels like Perl does in ways other languages don't to me. 
Starting with Ruby would be a great idea. Ruby is very opinionated. The community is quick to crucify those that do not follow standards and this is a good thing! Many other languages are lax when it comes to standards. This leads to bad code which is hard to follow, debug, and scale. If you learn Ruby first and adhere to these standards then it will show up in your work when working with other languages down the road. Other developers will love you as you're not giving them crap code with 30 line methods and 1000+ line classes. You'll be grateful to yourself as your code is much easier to manage. The fact that you do not know any other language is an advantage. You're not going to be bringing bad habits from a previous language into Ruby. Go check out tryruby.org and see how you like it. It is fantastic that you're wanting to do this. I started at your age and now I'm 34. I can not even imagine doing any different than what I do now.
sooo...method overriding and ruby's top-level are magic? 
Yes. Its a very easy language to get started with, the applications, scripts, and tools you can build with it are things that are actually useful (not php calculators or vB drawing programs), and its a good segue into other types of programming, thanks to the language's flexibility Also, http://tryruby.org
Well jQuery helps a lot, and I've used it on several projects, but JavaScript is not an intuitive language for me and I spend way more time looking stuff up for it than I do for any of other technologies that I use regularly. Some things that have tripped me up: I've been bitten by variable scoping problems before in ways that surprised me; I've tripped over == vs. === more times than you can shake a stick at; oh, and one thing that really was frustrating --- a few years ago -- I had some code that worked in all of my test browsers, but my boss was running an older version of one of them and (blam!) 
I fail to see how this is asinine, but perhaps you could elaborate on what you think magic is in a programming context.
&gt; Way I saw it, Ruby appeals to the heart while Python appeals to the brain. That is poetic truth! :) For me it's always: Ruby = creativity Python = science
Hey I really appreciate your putting the time in to write this gem and I'm sad to see that it's getting no love :( Anywho, I'm trying to use it and I'm curious why you've chosen to read from a .config file instead of letting the user pass the config info into an Rlocu object? I'm getting: /Users/swiftdemise/.rvm/gems/ruby-2.1.1/gems/rlocu-0.1.0/lib/rlocu/config.rb:7:in `initialize': No such file or directory @ rb_sysopen - /Users/swiftdemise/.rvm/gems/ruby-2.1.1/gems/rlocu-0.1.0/.config (Errno::ENOENT) I'm not quite the biggest fan of putting a config file in my gems folder :D
I'm actually more interested in what you think a good programming language that *has no magic* is.
Could you point out where I said magic doesn't exist in a given language? The point here isn't to say X has magic but Y doesn't. The point is to try to explain what it is. Obviously you can create confusing situations in any language. Ruby makes it very easy to do this however, since you can modify object methods at runtime.
Actually never heard of Q before. This looks quite cool.
 def dec(fn): def inner(arg): fn(arg + " magic") return inner print = dec(print) print("hi") #=&gt; "hi magic" Or, as a one-liner: print = (lambda x: lambda y: x(y + " magic"))(print) What exactly is the big deal here? I mean, Ruby magic is definitely more common than Python magic, but neither should pop up too much for a beginner who's just learning to make toy examples.
it is normal ruby syntax. those are just methods that take blocks as arguments. blocks are very common in ruby, and very powerful. in your example, "describe" and "it" are methods that take a string argument and a block (do...end).
I started out with Java, Ruby can't be any worse ;) With Ruby you can learn the fundamentals of Object Orientated Programming (OOP) without all the ceremony and syntax of Java or C++. Ruby also has both traditional for/while loops and functional-ish methods like `.each`, `.map`, `.select`, `.reject`, `.reduce` which take a block.
Objective-C is a programming language. RubyMotion is another programming language. iOS is an operating system. The iOS SDK is the development kit used to develop on the iOS platform. Objective-C is never "native", it's a language, just like C is a language, just like C++ is a language, just like RubyMotion is a language. C, C++, Objective-C, and RubyMotion are all compiled. Ruby is not RubyMotion, they are similar languages, they are not the same. Ruby is interpreted, RubyMotion is compiled. Ruby uses a garbage collector, RubyMotion uses its own version of ARC. As for where I stand, I personally like Ruby-ish languages and the command-line environment, so I use RubyMotion. If I liked an IDE like XCode and Objective-C, I'd use that.
I'm not sure about that. There's something to be said for understanding everything you've personally typed. There will ALWAYS be abstractions. There's nothing wrong with abstractions. Anything short of assembly is an abstraction in some form or another. One of the reasons I love Ruby is how it starts off letting you code almost BASIC style programs, and add things as you need. You don't have to understand visibility, objects, the concept of static methods, a return type, an array type, arguments, the System object, etc just to get Hello world out there. I remember learning Java for the first time, and there was a lot of, "ok, you don't have to worry about what this means." I remember finding that very irritating. Java also just introduces more mental overhead. Having to type out setters and getters, pre-decide the type of any variable, fix yourself to one particular return type... these are all things a professional programmer can absolutely handle, but when you're starting off, there's enough to worry about without micromanaging. I think this boils down to a top-down vs bottom-up style of programming. I find it was much easier to learn assembly with jumps and the stack once I had a good understanding of the concepts in C, and C's pointers were easier to grasp once I understood Java's references, etc. Other people might become frustrated at how much is hidden under the hood. That said, MIT starts students off on LISP, which is a pretty abstract level to be learning.
As a programmer I found Ruby easier to grasp than a Python. I don't know why, but Ruby seemed to be closer to my mental model of computation.
I use [json_expressions](https://github.com/chancancode/json_expressions) for pretty much the same idea, but this looks like it has more capabilities. Neato.
You may be right. I actually started with x86 assembly and Windows and Unix device drivers in my first job so pretty much a system programmer most of my coding career. I picked up Perl at a time when I was deep in in the intricacies of C++, mainly because I wanted to learn regex. Those were the days when the Perl gurus strutted around like peacocks and TMTOWDI ruled. It was a wonder how the language got out of my way and let me focus on the problem. I wrote a web crawler that would go to the INS site, search for my immigration status, parse the HTML and if the status had changed, send me an email and an IM on Yahoo. I also wrote a log parser for the Java guys to track all exceptions output an excel report. I was the hero of the office for a while. Six months later, what I had written was incomprehensible :) Beautiful language though and happy that I learned it. I tried Ruby with RoR and Python with Django. I constantly chafed at the extreme handholding and mysterious magic Rails used to generate its scaffolding. Compared to that Django just got out of my way with few surprises. To take another example, I understand Objective C quite well and have been meaning to write an iPhone app but keep putting it off because I find Objective C too verbose. :) To each his own. YMMV. Edit : I apologize if I am coming across as a show-off or negative about Ruby. I have moderate expertise for languages used for work and a beginner on many others. Regarding Ruby, it is a beautiful language and I pay it the highest compliment when I say that it is Perl done right.
&gt; There's something to be said for understanding everything you've personally typed. This goes both ways. Much of the convenience you describe is only convenient because it allows you to write Ruby code without *really* understanding what you are doing. Allowing people to bulldoze through code without a solid understanding of scope, visibility, etc. is not the same as *understanding* the code.
You always need to measure. That's how we convert hunches into knowledge.
I'm on 23% completion on Codeacademy. It's so far given me zero basic knowledge of fucking coding outside of the browser IDE. It's stunting my knowledge of Ruby more than helping. No include directives, no nothing. It doesn't name the methods it just shows you a picture. This is like giving a vague notion to people who want to pick up programming and making it confusing. screw this site.
Hi. In the last year I've held two courses (about one afternoon each) to teach absolute beginners with no programming experience at all how to code in ruby and it went great. So yeah, I would say, Ruby is a good start. Here's (roughly) how I structured those courses and how a beginner could approach the topic: &gt; First, learn how variables work and how to manipulate them. Learn what "simple" types of variables there are in Ruby - like numbers, strings, arrays and hashes. Then, learn about using functions and control structures like if/else/while. Learn a little about the Ruby standard library. &gt; &gt; With that, you will be able to write simple command line tools. I prefer writing a simple address book as a beginners' task. Nothing fancy, just create, show and delete entries. &gt; &gt; *(end of part 1)* &gt; &gt; Once you get comfortable with what you've learned by now, learn how to define your own functions. Take a deep breath and learn what object oriented programming is and how you define your own classes. Improve your application: redesign how your data is represented internally. Implement a few new features. The Ruby standard library provides at least three easy ways to store your data in a file so you can get it back later. &gt; &gt; The last major thing you have to learn when you want to work with ruby are lambda functions / blocks. For most beginners they're a little weird but you'll get used to it. &gt; &gt; *(end of part 2)* &gt; &gt; That's it. You've learned the most important parts of Ruby. From now on it's less about learning things by heart and more about getting experience. The best way to progress from here is to read other people's code and try to understand what it does. Sure, you'll sometimes trip over stuff you don't know but a few minutes on google usually help. Also, experiment! Nothing helps more than actually writing code. Originally, those courses were live coding sessions. I wrote some code and explained it along the way, giving the others a chance to ask questions right while I was doing it. If anyone's interested, I turn it into a written tutorial. I also thought about videos but you probably wouldn't want to listen to a guy with a German accent for eight hours. ;)
RubyMotion does not use a garbage collector, though it does use autorelease pools. It uses a mechanism similar to ARC. It is also less dynamic than flat ruby in some significant ways, most importantly that it cannot do "eval". But what exactly are you claiming the objective-C compiler does with methods other than generate a call to objc_msgSend with the target object and a selector? As far as I know, it invokes that function every time. That sounds pretty dynamic to me. And indeed, my micro benchmarks of several different ways of defining and calling methods (including define_method) seems to indicate that there is very little overhead to RM methods versus objective-C methods. This is not to say you can't get in trouble. method_missing is monumentally expensive, and ruby-style .each loops are about 50x slower than for loops (which you can use in RM too). With careful coding, you can get excellent performance. Lots of code won't be performance-sensitive in many apps. The biggest pitfall is that most libraries are not written with performance in mind. That's likely to improve over time, and if it matters to you, just use ObjC libraries for critical parts. Here are the benchmarks results: ObjC native loop: 0.000013 ObjC native loop w/objc_msgSend: 0.000013 ObjC method called from ruby (raw): 0.000035 def method (raw): 0.000039 define_method (raw): 0.000058 method_missing (raw): 0.000865 module included in class (raw): 0.000019 class_addMethod (raw): 0.000026 Those are seconds to make 10K method calls (empty method). The code is here, if you'd like to poke holes in it: https://github.com/kemiller/rubymotion_benchmarking 
Ruby is one of the easiest programming languages to learn, has many excellent tutorials, teaches good OOP coding habits, is free, open source, and community owned; has excellent support for different operating systems, is in demand in the industry, has possibly the best website generator framework (Rails), can be used to write command line, desktop, mobile, and client-side browser apps, has a package management system on par with NPM, can be installed in several versions simultaneously with RVM and Bundler; has anonymous functions and fully automatic garbage collection. You might not know what these are yet, but when you learn other languages, you'll miss these features.
I've taught people Ruby, C++ and Java on different occasions and I can tell you that the main reason why I got the best feedback on Ruby was that I almost never had to say something like "Yeah, just accept that line, I'll explain it later". The only thing you ever have to "just accept" when learning ruby is `puts` and that will be explained pretty soon. With C++ and Java I *always* got questions what void, main, int and so on meant and wasn't satisfying at all that I couldn't explain it at that point. Neither for me nor for my "students". The point is, people don't *need* to understand scope, visibility, etc. to write simple ruby scripts. So you can just teach them what they need for a certain task and explain the rest later as soon as it's needed.
I've done some micro benchmarking on raw method calls. RM's penalty is not large. If you are writing idiomatic ruby, you may get into trouble, since there are parts of ruby that are much slower than the equivalent idiomatic objC (looping is one). But it is possible to write very performant RM code, especially if you use ObjC libraries (or carefully-written RM ones). Here are the benchmarks results: ObjC native loop: 0.000013 ObjC native loop w/objc_msgSend: 0.000013 ObjC method called from ruby (raw): 0.000035 def method (raw): 0.000039 define_method (raw): 0.000058 method_missing (raw): 0.000865 module included in class (raw): 0.000019 class_addMethod (raw): 0.000026 Those are seconds to make 10K method calls (empty method). Here's the code: https://github.com/kemiller/rubymotion_benchmarking 
I partially agree. C-style languages need a lot of boilerplate code to actually do something which is hard to teach to people. On the other hand, what you say about bad habits is absolutely true. I'm still looking for a language that's as flexible and easy to read and write as Ruby but still forces you to keep a good style. Sure, there are tools like linters that notify you about bad style but most people don't actually use them so that's no real solution.
You are still avoiding the question: why is this a pedagogical advantage? 
One important thing that might be burried in the thread or not: It's not that important what your first language is as long as you are willing to work with other ones along the way. Once you understand the basic concepts, most languages are pretty similar (apart from the syntax) and the majority of programmers know at least half a dozen different languages well enough to write decent code and can read many more. So take one that looks like you might like it and work from there. Once you find another one that looks promising, invest a few hours and see if it fits your style. If it doesn't, you still haven't lost anything but a few hours of your time.
I understand it's normal _ruby_ syntax, powered by ruby's particular ability to manipulate blocks, but it's a very abnormal syntax in the common realm of [C-style languages](http://www.reddit.com/r/ruby/comments/1z3oq6/is_ruby_a_good_language_to_start_with/cfqn1r2?context=5 "C, C++, Java, PHP, Javascript, Python, C#, Go, Objective-C, Perl, etc, etc, etc."). It's like having someone with no experience in functional languages (like myself, kinda) trying to understand how to read Lisp or OCaml. You can even write ruby in a purely functional manner if you wanted to.
The problem for small projects is that there's no easy/cheap way to try it out. Especially smaller startups (e.g. exactly those companies that can't afford an iOS developer) won't just spend $200/€150 just to build a prototype and possibly throw it away after a few weeks. At least not when there are cheaper alternatives like MobiRuby (or PhoneGap if you have web developers)
I'm also 15 years old! I've been learning Python for about over a year and I've really liked it. Sometimes I feel like I've made very minimal progress. I can barely program anything. But, I keep going. Ruby is definitely on my list.
That's pretty standard Objective-C
you are either very smart or you still believe in magic. ruby it is not one of the easiest language to learn...
Thanks! Didn't think about covering everything is an object. A lot of them hate on me for Ruby because they 'love' Python. Any rebuttals?
One thing I like about the actual JSON-Schema ( http://json-schema.org/ ) format is that it is language agnostic (Since it is just another set of JSON). Although it does have some limitatations, especially with data-types. This does look interesting. Do you have a link to the actual Q language since, with a name like that, it is basically impossible to find in google.
That's why you use Virtualbox/VMware (and optionally Vagrant) with Ubuntu or whatever.
So basically I have to figure out how to install, and then learn an entirely separate OS just to be able to use the language?
Learning to code in anything reasonable is vastly more important than which language in particular. Ruby is pretty great for anything except scientific/engineering computation and game programming. Also, it's so pretty and convenient that you won't ever want to switch to C++/Java. I guess that's a potential downside.
Don't like it? Go somewhere else :-) I don't work or own CodeCademy so I don't care :D Have you tried RubyMonk?
My bad :-) Been thinking about basics of TDD in M. Hartl's book and wrote that instead :)
I've been using RubyMotion since a couple months after it came out and have always had access to the latest APIs the same week (usually same day) that a new version of iOS is released. The way that RubyMotion works is that there's a very small cost to introducing new Cocoa Touch APIs. HipByte essentially runs a small script and sends out a new build.
While not immediately applicable, OP might also want to look up the [TCP-IP stack](https://en.wikipedia.org/wiki/TCP-IP), which is a representation of how the Internet and other networks work (the large majority of them, anyway). It totally blew my mind the first time I got it and it explained *a lot* about why application level protocols like HTTP work the way they do.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**TCP-IP**](http://en.wikipedia.org/wiki/TCP-IP): [](#sfw) --- &gt;The **Internet protocol suite** is the networking model and a set of [communications protocols](http://en.wikipedia.org/wiki/Communications_protocol) used for the [Internet](http://en.wikipedia.org/wiki/Internet) and similar networks. It is commonly known as **TCP/IP**, because its most important protocols, the [Transmission Control Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol) (TCP) and the [Internet Protocol](http://en.wikipedia.org/wiki/Internet_Protocol) (IP), were the first networking protocols defined in this standard. It is occasionally known as the **DoD model**, because the development of the networking model was funded by [DARPA](http://en.wikipedia.org/wiki/DARPA), an agency of the [United States Department of Defense](http://en.wikipedia.org/wiki/United_States_Department_of_Defense). &gt; --- ^Interesting: [^Internet ^protocol ^suite](http://en.wikipedia.org/wiki/Internet_protocol_suite) ^| [^Transmission ^Control ^Protocol](http://en.wikipedia.org/wiki/Transmission_Control_Protocol) ^| [^MicroC/OS-II](http://en.wikipedia.org/wiki/MicroC/OS-II) ^| [^Internet ^Protocol](http://en.wikipedia.org/wiki/Internet_Protocol) ^| [^TCP/IP ^stack ^fingerprinting](http://en.wikipedia.org/wiki/TCP/IP_stack_fingerprinting) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfqt3om) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfqt3om)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 74101:%0Ahttp://www.reddit.com/r/ruby/comments/1z3oq6/is_ruby_a_good_language_to_start_with/cfqt3m8)
if they can't articulate their love for Python, then that's just a holy battle/dick measuring contest. I'd use the metaprogramming ability of ruby to demonstrate creating a DSL.
I can recommend podcasts by Thoughtbot, which are my usual choice when travelling or on long commute. http://podcasts.thoughtbot.com/giantrobots I really enjoyed those two episodes: * Episode #44 I feel the opposite of burnt out with Chad Fowler * Episode #52 You look really fancy in your tuxedo (special episode recorded during RailsConf 2013 with Aaron Patterson &amp; thoughtbot CTO Joe Ferris) 
This was just what I needed. Thank you!
Any language is good to start with but C is the best.
&gt; ruby is the closest to reading english, so it's very easy to make sense of things Counterpoint: While this might make ruby slightly easier *right at the very beginning* (when you're still struggling to remember even basic syntax), Ruby's flexible syntax might actually make it *harder* than necessary for beginners to correctly parse out the different parts of ruby code, and can introduce subtle bugs that might not be obvious to beginners. Consider as an example the optional brackets around method parameters - to a new developer who's just learned about functions `myfunc(thingy)` is easily-parsed and understandable, but `myfunc thingy` is a lot less obvious, and harder to discern from other pairs of words like `if thingy` or `def something` or `return blah`. Then consider issues like operator precedence - `myfunc(number1) + number2` and `myfunc(number1 + number2)` are both unambiguous and easy to parse out, but - quickly, *as a beginner* - which of them does `myfunc number1 + number2` correspond to? And lets not even get *into* things like implied hashes - `myfunc(a,b, {c:d, e:f})` is clear, unambiguous and easily-read, but `myfunc a, b, :c=&gt;d, :e=&gt;f` is far, far harder to parse out and makes it *much* easier for beginners to cause nasty-looking bugs without realising it (eg, simply by trying to pass two separate implied hashes as successive parameters to the same function). Similarly, Ruby blocks may be delimited by `do... end` or `{...}` (so you have to remember two different bits of syntax that do exactly the same thing, and remember that whichever you do use you have to keep them balanced - no `do...}` or `{... end`). Then you have things like conditionals: when `if(x) { y; }` is the only way to express it it's easy to learn and easy to read - compare to ruby's `if x [then] y end`, `y if x`, `y unless !x`, `unless !x [then] y` and variations. Don't get me wrong - I love ruby to bits, but its a power-tool, and you don't give power-tools to beginners because they're confusing and scary and make it far, far too easy to lop off fingers without intending to. You give absolute beginners something like python (where the restrictive syntax and TIOOWTDI approach that often feels restrictive to us Rubyists is a positive boon to learners), instead of them drowning in a sea of idioms, implications and hidden magic that makes it so convenient for the expert.
Measuring is never a bad idea. There's basic laws of physics, though, and extra indirection is extra work. There is no way to get around that.
Ruby is a good choise. Try [CodeWars](http://www.codewars.com/r/ktciuQ). Good Ruby language learning curve. Shows best answers after you solve a problem. 
Not really. With Vagrant there's no OS install required, and it doesn't take long to get rails up and running on an Ubuntu base box (for which there are plenty of guides). Once your Vagrant box is set up, there's very little difference to how you would develop natively in Windows, but without the dumb gem/dependency worries. The ruby/rails specific terminal commands stay the same (and the few other linux-specific ones you *might* need are very easy to learn), you edit your files in Windows through shared folders, and view your site on your Windows browser.
Are you going to deploy to a Windows server? Probably not. Learn your deployment environment.
Having a Linux/OSX is better for almost every web language/framework. And VM are great if you are stuck on windows.
One place where the standard library does it is Struct. Person = Struct.new :name, :age john = Person.new 'John Doe', 25 puts john.name
Pascal then C/C++ will be the best for beginner. I use them to learn programming in the first time. Now, I use Ruby! It has great code style.
&gt; I'd love any feedback and suggestions of good resources for cryptography in Ruby. I've got what you're looking for! - [A Survival Guide to Ruby Cryptography](http://confreaks.com/videos/2902-rubyconf2013-being-boring-a-survival-guide-to-ruby-cryptography) - [Modern Cryptography](http://confreaks.com/videos/1114-gogaruco2012-modern-cryptography) - [Krypt: The Next Level of Ruby Cryptography](http://confreaks.com/videos/1311-rubyconf2012-krypt-the-next-level-of-ruby-cryptography) These are all conference talks.
What are some uses for this? It just adds a header, right? Why call it an easter egg when it could have legitimate, useful purpose?
Twitter
So with the Vagrant approach, it's just Vagrant, and nothing else? Or do I also need Virtualbox/VMware? Might have to investigate that.
hehehe, feels the same here.
Why does it matter?
When innovation is the focus for a startup or more established company, it's worth taking nootice so that you can carry their learnings forward.
This is neat, I didn't know about that options, but it seems really useful (if basic).
Which programming languages do you think are the easiest to learn?
I absolutely love Eloquent Ruby, it filled in a lot of the gaps in my understanding of how to write idiomatic ruby code.
You're right, Ruby lets you write code without really understanding what's going on under the hood. That said, I'm a professional coder, and 95% of the code I write in ruby, I don't understand what goes on under the hood either! I mean I know how an array works, but how does Ruby resize its arrays when it gets full? I can dive into the C code and look, but do I really need to know to parse out some text from a call log? Probably not, unless I need to do performance tuning. I could do this, but I have years of experience. Would you tell a young fledgling Java programmer that he needs to understand generational garbage collection and compilation to bytecode before he can write Hello World or he doesn't "really know" what's going on? The thing about scope and visibility is that you can introduce them incrementally. You start off with a basic script with variables, without even needing methods. Then you introduce a method and visibility inside the method. You don't need to talk about it until you're ready. You then say "oh by the way, this is an object. You've been using them all along." Eventually you can get to the point where you say "as it turns out, when you call self inside a simple script, you get back main, because that's the object which provides the context for a basic script" and start talking about the Kernel, etc... but you can do that when you are ready. Don't take this as a dichotomy between learning scope and not. The goal is to get people to absorb bite-sized chunks, where each layer of complexity is investigated by the user typing out what they need to get there. This is the same reason I love rails. You can get to the point of having a web server up and running very fast. (not as fast as you once could, but it's still very quick.) You can have it talking to a database in no time. Without really understanding what is going on, you can reach the point of going "oh hey I changed something, oh look the web page updated!". That kind of feedback is ENORMOUSLY rewarding. The shorter you make the gap between action on the part of the user, and seeing the computer react, the better.
no you're not!
Done. See www.q-lang.io
&gt; No, but I would expect them to understand scoping, visibility, etc., since they are programming concepts. This seems like a willful avoidance of my question. Let me clarify to be sure. Would you expect a person to need to understand this before they reach the hello world stage? &gt; Again, this doesn't really differ from Java. But it does. That's the point. Java introduces a heap of syntax you have to kind of ignore. Why do you have to pre-define what an integer is? What is an int compared to a float? Why are ints initialized with small case and strings are capitals? These questions require you to explain what a primitive is vs an object, when the fledgling coder just wanted to get Celsius from the command line and output Fahrenheit. &gt; Again, is this pedagogically better? In my personal experience, the experience of people I've informally tutored, and in conversations with others in education, the answer is absolutely yes, it is better. Languages like Logo exist for a reason. &gt; Also, you can learn Java in bite sized chunks as well. The smallest possible Java program still introduces a crapload of concepts that either need to be typed out like a magic incantation, or explained in great detail. Ruby programs tend to have a 1:1 ratio of "thing you are trying to do" and "thing you need to type." Ruby is not unique in this regard, but it is much better than Java in this regard. I speak from personal experience, but I am not alone [in this line of reasoning.](http://www.theatlantic.com/technology/archive/2011/06/how-i-failed-failed-and-finally-succeeded-at-learning-how-to-code/239855/) The fewer impediments you throw at people to get started, the better. /u/DFYX provided some [good practical answers](http://www.reddit.com/r/ruby/comments/1z3oq6/is_ruby_a_good_language_to_start_with/cfqnabv) to that question in this very thread. And I'll turn this around. Why does having all that stuff frontloaded constitute an advantage to you? You can just as easily learn scoping, objects, and types in Ruby as in Java. What essential lessons from Java *can't* be learned by a Ruby programmer, except for language specific things like interfaces?
&gt; This seems like a willful avoidance of my question. Let me clarify to be sure. Would you expect a person to need to understand this before they reach the hello world stage? It's not avoidance at all. You asked if I would expect them to know this. I said no. The reason I mentioned scoping, etc. is because understanding garbage collection isn't all that necessary to learn how to program in general. Very few current CS students will ever need to manage memory in the real world, so it's not really critical to understand memory management to become proficient in most modern languages that will actually be faced. I would recommend learning this, and some students will *have* to know this, but it's really not a very general requirement for learning to program. Scoping and things I have mentioned, though, are still rather critical topics that students will almost certainly need to know to reach any level of competence in any language. &gt; Java introduces a heap of syntax you have to kind of ignore. Why do you have to pre-define what an integer is? What is an int compared to a float? Why are ints initialized with small case and strings are capitals? I wouldn't call those things you have to ignore. These are things you need to learn to be a good programmer. When you learn them seems rather irrelevant. &gt; These questions require you to explain what a primitive is vs an object Which you need to learn.... &gt; when the fledgling coder just wanted to get Celsius from the command line and output Fahrenheit. Actually, the coder wants to learn to program, if I recall correctly. The task is merely a vehicle for that. If that vehicle results in a basic understanding of types, etc., then it would seem to be a success, even if it takes more time to complete the task. &gt; In my personal experience, the experience of people I've informally tutored, and in conversations with others in education, the answer is absolutely yes, it is better. Languages like Logo exist for a reason. Then why do *actual educators* tend to not use languages like Ruby? &gt; The smallest possible Java program still introduces a crapload of concepts that either need to be typed out like a magic incantation, or explained in great detail. Ruby programs tend to have a 1:1 ratio of "thing you are trying to do" and "thing you need to type." public class SomeClass{ public static void main(String[] args){ [...] } } Hmmm.... a crapload isn't as much as it used to be back in my day... If that creates a significant difference between learning and not learning, then either the teacher or student is not really competent enough to teach or learn. I mean, that, in itself, it a bite sized chunk of stuff that is good to learn. I realize it's not as hip as what you want to do, but this needs to be learned. Period. So, again, why is order so important? And if the ratio of "thing you are trying to do" and "thing you need to type" is really so critical, then use Haskell. Of course, you wouldn't use Haskell, because it's actually not as important as you imply... &gt; The fewer impediments you throw at people to get started, the better. What you are calling "impediments," though, are *things that need to be learned.* So, you're argument is that Java isn't good for learning, because things you need to learn get in the way of learning... &gt; And I'll turn this around. Why does having all that stuff frontloaded constitute an advantage to you? And this is where the strawman comes in. My argument is not that Java is better. My argument is that acting like this is a significant difference between the two--pedagogically speaking--is silly. I think *either* language is just fine with respect to this specific topic. &gt; You can just as easily learn scoping, objects, and types in Ruby as in Java. What essential lessons from Java can't be learned by a Ruby programmer, except for language specific things like interfaces? I'm not aware of any, which is why I never said there were any. 
Case statements, no awkward top-level functions (what is `len` doing in a OOP language?), and "everything is an Object" (ie: array`[1..10]` vs. `list[1:10]`, `1..10` is a Range, `1:10` is special syntax). See also, [Greyhat Ruby](http://dontstuffbeansupyournose.com/2011/04/27/greyhat-ruby-source-boston/), which introduces Ruby to predominately C/C++/Python programmers.
PHP does not make collections easy, and collections are the backbone of programming. Python is Ruby--. Not a bad language, but the `self` confusion makes OO harder to learn. Write Hello World in Java and get back to me.
Ruby is good because it implements all of the traits of modern languages and will be incredibly useful (along with Rails) if you want to become a web developer.
&gt; LISP Which language features are derived from LISP? Functional programming?
You have to install Virtualbox (VMware integration with Vagrant costs money unfortunately), but Vagrant does everything else for you.
I remember hearing on the Ruby Rogues, that closures are apparently from Blue Book LISP. Or maybe they meant to say Bluebook Smalltalk?
&gt; Then why do actual educators tend to not use languages like Ruby? There are plenty of bootcamps, aimed at educating people who were not programmers, in the art of ruby. What you mean to ask, presumably, is "why do large educational institutions not use languages like Ruby"? You might just as well ask "if the lecture format has been shown to yield poor retention, why do so many schools use the lecture format?" Because schools have inertia. Moving into Java was a big deal. It would be difficult to mandate they all move out. Other universities advocate Scheme or Python. Python has a bit more history than Ruby, and while I like Ruby more, Python fits the same paradigm of getting started quickly. Scheme lets you use a read-eval-print-loop, which is another fine way to get the kind of interactivity you need. &gt; Hmmm.... a crapload isn't as much as it used to be back in my day... I challenge you to explain to someone in 10 minutes what all that means, assuming they have no prior programming experience, without telling them some variation of "we'll get to that later." You are handwaving because you are showing two lines with less than 10 words, but contained in those 10 words are at least six distinct unique concepts -- visibility, objects, methods, instance methods vs class methods, arrays, command line arguments. (Plus the part you snipped, the need to remember the System object.) You cannot introduce someone to Java without telling them either "here is the huge list of things you need to understand before every word of that make sense" OR tell them "ignore that, we'll get to it later." The former means a lot of learning before any practical experience, which is inferior. The latter encourages rote memorization and copy-paste instead of really deeply thinking. The overhead of new terminology seems invisible to someone after they've been using Java for years, or have anther programming language to compare it to, but it puts a world of distance between "let's learn programming" and the magic spark of "hey, I made the computer do the thing I asked."
Number of jobs is not as important as number of jobs vs number of coders out there. One of the reasons I am glad I learned Ruby is I did it at a time when no educational institutions were teaching it. In doing so I set myself apart as a self-learner, but I also entered a field where demand was quickly exceeding supply. While it's hard to estimate the number of actual programmers, take a look at the chart in this article. https://plumbr.eu/blog/how-many-java-developers-in-the-world You might be able to find 2x the C++ jobs compared to Ruby, but there are at least four times the programmers. I am not saying for sure these metrics are comparable, just that looking at the absolute number is really dangerous, unless you're waiting for a bunch of C++ programmers to retire (in which case you might as well learn COBOL)
new relic?
In that case, I'd suggest a PaaS like Heroku or otherwise. It will cost more, but will reduce maintenance and save/create a few deployment headaches.
It's a command line tool for finding the lines that contain a TODO inside a directory, sort of what some IDE's provide. It is very basic, but I find it useful and I have learned to love ruby, so this is really cool for me. Suggestions and comments are more than welcome!
Congratulations on releasing a gem! 
I'm unfortunately on a non-dev-ready Windows machine so I can't try it, but does this work with Ruby code? Like.. #TODO # TODO etc?
I was definitely thinking Heroku for deployment, however that doesn't solve my dev environment challenges with Windows. Or does it in some way I'm not grokking?
Yes. For the moment is very simple, it just matches lines that contain 'TODO text' and it would return the text, no matter what was before the TODO word (i.e., comment symbols). Of course, it would be better to only check comments depending on the file extension, but for the moment this works. It also returns the path of the todo and the line number (with colors! yay!) so I think it might be useful.
I second this. congrats on creating and releasing, and good luck with your future projects.
Thanks a lot! There are two things about ruby that are amazing; the language itself and its community.
First off, congrats on releasing a gem! Contributing to the Ruby community is awesome. :) You might find a similar project, [rake-notes](https://github.com/fgrehm/rake-notes), interesting, as well.
we are talking about "easy to learn" not easy to work with or fun ;) PHP doesn't not make collection easy? seriously? How many years of exprience you have in PHP? Python is Ruby? which part of python is ruby? (except similar syntax) Not gonna write an hello world in java, did that for 5 years professionally. No fun inside! :( But is it easy to learn? Yes, compared to Ruby (no hidden tricks aka. magic) Anyway, I don't want to push this discussion futher more cause it's not constructive at all since we talk about which language concepts are easier to grasp to a rookie. Thanks!
Somehow I thought that the RHS would be evaluated first and then the LHS. Testing some other languages, this is how Python works: $ python bugtest.py Traceback (most recent call last): File "bugtest.py", line 1, in &lt;module&gt; x = x NameError: name 'x' is not defined 
Depending on your objectives, but usually it is a very good language to get started with. Ruby promotes an idiomatic way of writing it, and that is quite important when learning a language. Examples of other languages that promote an idiomatic way are Java, Python and Haskell. Non-idiomatic promoting languages are PHP, Perl, JS (Node.js) and Scala -- usually these communities have several approaches (paradigms) to write the same code, which is confusing when learning a language. I think Ruby is one of the easier languages to get started with. If I had to point you an other good contender to what I think is an interesting language to learn at first, I'd say Haskell. It is not are "easy" to get started with, and the community/market is smaller. You'll learn more when getting to know this language, programs written in Haskell tend to be more "correct" and it performs much better for most tasks. Haskel and Ruby are both very-high-level languages (the allow for very terse/expressive programs -- much result for little typing); yet Ruby is run-time typed and OO where Haskell is compile-time typed and pure-functional. If you are interested to have a look at Haskell see this: https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard/haskell-fast-hard-part-1 For having a look at Ruby see this: http://tryruby.org (a similar site exists for Haskell: http://tryhaskell.org) Either way good luck and enjoy! 
It seems like it's an accident of the parser implementation. (?)
Hah, that talk was pretty hilarious, thanks.
Yes, it makes total sense to ignore the *.gem files, and I had no idea about referencing the gemspec from the Gemfile. I'll correct those things. Thanks for the feedback!
similarly: x = 42 if false x =&gt; nil 
Well done, sir. Definitely going to use this.
Sure. Why wouldn't it be? :)
Similar question from a few days ago: http://www.reddit.com/r/ruby/comments/1z3oq6/is_ruby_a_good_language_to_start_with/ BTW: yes in 2014 Ruby is a great language to learn and use (but there are many other great languages too, so I guess it depends on what you want to use it for).
yeah. Even if you never used it for webdev it's ~~nice~~ essential to know a scripting language.
[Eloquent Ruby](http://eloquentruby.com/) was an excellent introduction for me, I also have [The Pickaxe](http://pragprog.com/book/ruby/programming-ruby) but found it harder going. [Code School](https://www.codeschool.com/) has some good material and the initial courses are free. If all else fails there's stuff on [Youtube](https://www.youtube.com/results?search_query=intro%20ruby&amp;sm=3) that might be worth a look. There are no shortcuts, you just have to practice. Good luck!
Just because one fad takes off doesn't make Ruby a bad choice in itself ;) 
In fact I use Ruby heavily for writing extensive programs to run from the command line, and I've never touched Rails; I find the idea that Ruby is only good for Rails to be rather peculiar.
just in case, &lt;/sarcasm&gt; :)
Yeah, the Gemfile only exists to make it easy to use bundler while developing your gem - the gemspec needs all the requirements
I figured as much :)
It depends on what your intent is. Let me introduce you to something: http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html That index tells you what programming languages are most popular. Ruby is currently #12, and on the decline. For long term relevance, look to C and its derivatives (Java, C++, C#, Objective C, etc.)
Congrats on releasing your first gem! Have you looked at rails's implementation of this? If you didn't know, Rails (and I know this is /r/ruby not /r/rails) has a rake task to list TODO, FIXME, OPTIMIZE, and any other "tagged comments". You can see the source [here](https://github.com/rails/rails/blob/master/railties/lib/rails/tasks/annotations.rake) and [here](https://github.com/rails/rails/blob/master/railties/lib/rails/source_annotation_extractor.rb). It was also apparently extracted into its own non-rails gem [here](https://github.com/fgrehm/rake-notes) It might give you some guidance on better practices, or maybe the focus of a next iteration, etc. It's also got some pretty awesome features you could replicate.
I wouldn't place my bets on it. It really is a pretty badly designed language that just doesn't feel at home in today's collection of programming languages. For example, Node.js is a new programming language that is taking the industry by storm because it can scale linearly across multiple cores. Another example is Go, a language designed by Microsoft. Go has this fascinating concept of Monads that allow it to scale really fast. The error handling is also revolutionary. If you want to try something a bit more old school (but still very good), you can probably give Cobol (and Cobol on Cogs in particular) and Java a try. If Java is too boring you should try Scala, I heard good things about its type system and error messages. --- In all seriousness, yes, Ruby is a great language to learn. It may have its quirks but it's by far the most pleasant to write language. The vast amount of libraries out there make it easy to get started. Typically the community, except for a few bad apples, is also very welcoming/helpful. A few good resources to start out with: * https://rubymonk.com/ * http://ruby.learncodethehardway.org/ * https://practicingruby.com/ I also recommend subscribing to http://rubyweekly.com/ run by the lovely /u/petercooper. 
Fantastic video. Should be required viewing when choosing a programming language. 
i liked ruby monk www.rubymonk.com
&gt; I posted that I was looking for work in the middle of January and was contacted by like 10 companies, one of which I start working for on monday. Where did you post this? I've been looking for work for about a month and haven't really gotten anywhere, except recruiters calling me asking to apply for jobs unrelated to my skills.
It was part of the joke...
What is your goal? If making web applications or handling large sets of servers is your thing then I'd say we're well served. If you want to write a search engine it's not the ideal though.
The [poignant guide](http://mislav.uniqpath.com/poignant-guide/) is a fun way to go about it. All work and no play makes Jack a dull boy.
Ask questions. Maybe you have a complex code sample that we can deconstruct. 
this seems very fun to read. Thank you.
I think it depends more on you than on Ruby, on how you think about code. Ruby is really expressive. That means that ou can put a lot of stuff into a single line of Ruby. And when you do, people can usually read that single line of code and no exactly what it's doing without having to think too much about it. It's very clear. On the other hand, if you want to think about exactly how the code is being processed, it can be kind of confusing at first. There's so much magic in the language (stuff that just "makes it work") that it can sometimes make you feel like you're not sure what's going on. To take a really simple example, when I started, I remember being confused by the way that hash keys were used as parameters in method calls. I knew what the parameters meant, and what they were doing, and I knew they were being passed to the method, but I didn't understand the details. So I find the magic to be kind of disorienting sometimes. It bugs me when I don't have a solid picture of what's going on, and I get sort of uneasy and paranoid. So I end up having to track it down, and figure it out. Once I've done that, I'm fine. A lot of people don't have any problem with magic. It works, it's easy, it's clear, so what's the problem? This is almost certainly the most reasonable way to think about it. But it's not the way everyone thinks about it. Python covers a lot of the same ground as Ruby. I don't know it well, but I think it's less magical. In a lot of ways, a language is like a pair of shoes. You have to try it on and walk around to see if it fits. So do a couple of tutorials with Ruby, a couple with Python, maybe some Javascript, and see what feels good.
Especially considering you don't really need to 'know' Ruby to have a decent Rails app. 
Anonymous functions are ~~closest to~~ lambdas in Ruby. http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/ 
I watched that :/ It's mainly using the authorization of the user in conjunction with the api is what I'm searching for.
I made a website which tries to give an unbiased opinion about what languages you might want to start with: http://programming.dojo.net.nz/ IMHO, Ruby is a great language to start with. Python is a close second.
There are also a few nuanced differences between blocks, procs, and lambdas that make implementing each of them slightly different. Conceptually/theoretically though, they're pretty much the same.
In ruby, the typical block looks something like this: def some_method yield 2 end some_method { |x| puts x } # =&gt; 2 This is what you were referring to earlier, about blocks having restrictions. There are more ways to do this. def some_method(&amp;block) block.call 2 end some_method { |x| puts x } some_method(&amp;proc { |x| puts x }) All of that does the same thing as the example above - but in a (debatable) more roundabout way. The `proc { }` syntax is the normal way to define a generic block - these have the same ["tricks"](http://www.ruby-doc.org/core-2.1.1/Proc.html#method-i-lambda-3F) (yes, that is the real term they use) that method blocks have (i.e., the number of arguments doesn't matter). In Ruby, methods **are** basically blocks - if you were to do `method(:to_s).to_proc`, [you'd get a `Proc` instance](https://eval.in/107644). [You can even define a method with a proc](https://eval.in/107645). Ruby, being the nice language that it is, lets you pass these blocks with syntaxic sugar to other blocks. This is used commonly in the core: iterator = proc { |x| puts x } [1, 2, 3].each &amp;iterator # same as... [1, 2, 3].each { |x| puts x } So, if you were to use it as like a callback system, you could do something like [this](https://gist.github.com/redjazz96/9300000). [In one of my libraries I'm writing, I actually use this quite a bit](https://github.com/redjazz96/liquidscript/blob/master/lib/liquidscript/compiler/icr/literals.rb#L10-19). Hope that helps!
great link, found that an interesting read.
I'd rather not say in public, PM'd
how do people like shoes? I didn't even realize it was still maintained post-What...
It's a pretty decent way to develop a cross-platform app. The Shoes team is currently working on a new version. Should be interesting to see what they come up with.
First, thanks! Second, I had no idea it existed until your comment and another one above. I'm going to check out the code. I think the advantage of this project would be that it is Rake independent, but of course is waaay less mature, and I'm sure I can get tons of ideas from that one. Thanks again!
This is an unfounded fear. RubyMotion began on iOS5. Since then I've watched it update to iOS6 and iOS7. RubyMotion has always updated within a day or two of beta SDK releases (HipByte/Laurent are in Europe so there's always some time zone offset between Apple's time of day release schedule and when the European workday would start). I personally had an iOS7 ready app on the App Store the same day iOS7 was available to the public. 
The omniauth gem just handles authentication. You need to pair up the data you get after authentication with a Github API gem, like Octokit as /u/schneidmaster mentions.
This explains some of the nuanced differences. http://yehudakatz.com/2012/01/10/javascript-needs-blocks/
Good answers in this thread, but I just wanted to point out that it's considered to be proper style to use curly brace syntax for single-line blocks.
Oh, don't get me wrong, I think they're an excellent development shop, and for the near term there is likely nothing to worry about. However, history is littered with numerous third party tools that fel behind or closed up shop. So, I am pointing out that it is a risk that one needs to consider, not that they have any evidence of that yet.
The single really important difference is that when you do a return inside a block, it returns from the enclosing scope, rather than just from the block itself. So if you do this: def find_non_zero some_array some_array.each{|x| return x if x != 0} end the return is out of find_non_zero, rather than just from the block itself.
It's more likely because you answered a question that wasn't asked. Nobody asked about job marketability, just if ruby is a good language to learn in 2014. The answer is yes.
Would you mind if I asked as well?
I love Ruby, but it ticks me off that Ruby has three different ways to express the lambda concept. Incredible reduplication of what JavaScript does with just callbacks.
This is an important point. The reason behind this is to make blocks act more like the bodies of 'for' or 'if' statements. Think of how confusing that 'each' example would be if 'return' just returned from the block and the each loop continued. This kind of special case rule is a major way ruby's design is different from python's. Ruby has a bunch of pretty complicated special rules that make it less purely logical but more intuitive. Another good example is the full specification of the '||=' operator. It's useful in a lot of cases where it wouldn't be if it were logically simple and "a ||= b" just meant "a = a || b".
&gt; Is it accurate to think of them as anonymous functions being passed as an argument to a function/method? Yes. Blocks in ruby allow you to define a function without binding it to an identifier, which makes them anonymous functions. In practice, though, there are three related concepts in ruby that have to do with anonymous functions: blocks, `Proc`s, and lambdas. As I understand it, "block" simply refers to the syntax used to pass an anonymous function to a method, which can then `yield` values to it (as in your example case using `each_line`) or convert it into a `Proc`, which is an object that encapsulates a function and allows it to be passed around and called kinda like first-class functions in other languages. A lambda is a special case of a `Proc`, with some differences that you should go read about! But the gist is that a lambda works more like a regular function. I've heard that when you use a block with `yield`, it never gets made into a `Proc` and therefore you can see a slight performance gain, which illustrates that there is a real difference between "blocks" and `Proc`s.
tryruby.org starts with the very basic, and cover a surprisingly big amount of material. Take your time, do it several time if needed, try to be sure you understand each step (instead of copy/pasting answers). Make pauses. Learning has its own pace.
&gt; they return from the calling method rather than the block itself What does this mean, exactly? That if I invoke a method, pass it a block, and inside the block write `return 5`, that the entire method will return `5`?
Or `puts "Importing data. This may take several minutes.`
Nice work! Good job on releasing your first gem! I have one suggestion though: can you make the monkeypatching thing optional? So, when you require your gem, you can do `Hashtel.from_string("foo")`, and if you require "hashtel/core_ext", it will add the monkeypatch (which would be just a `Hashtel.from_string(self)`.
It's kind of weird to include Ruby as a "functional" language. It has functional features, sure, but no more than Python, really. Both are still definitely imperative languages when used idiomatically. Also seems a bit odd not to include Scala or Clojure. Overall, though, it's a good idea.
Highlighting the fact that functionality provided by your gem can be cherry picked will definitely help. My initial thought was - "wow this is some neat stuff but I don't want to use most of it".
Nice post. Many people recommend using `reduce` (an alias of inject) because it's much more known in other languages. Talking about functional programming, you might want to make the method more "functional". There is not a whole lot of difference between your `each`-using method and the `inject`-using method, is there? Both of them keep adding elements to a hash until no elements are left. Actually, I think the method that uses each is more readable than the one using inject because it is straight up adding to a hash while the `inject`-method does some gimmicks. What you might want is something that represents the transformation that you want to obtain. You want to obtain a hash of words and their sorted counterparts. How about this? ``` words.map{|w| [w, w.chars.sort.join]}.to_h ``` It clearly states your purpose and is more concise.
Pretty much all your questions are answered in the ruby style guide: https://github.com/bbatsov/ruby-style-guide Four spaces in front of code formats it properly: class Item def initialize(description, color) @description = description @color = color end def get_info return @color, @description end end This blurb is ok except for that the return in get_info is implied and that you would need to encapsulate the variables in an array if you wanted to return both simultaneously. #"main" item = Item.new "mango", "red" You should use parens when you're assigning the result to a variable. item.get_info.each do |x| puts x + "hello" end Ruby's string interpolation is excellent, that puts line would normally be: puts "#{x} hello" Note that interpolation only works in double quotes.
The "right" way? It's a way, though without knowing what else you're trying to do, offhand it seems way more 'natural' to write something like: class Item attr_accessor :description, :color def initialize(description, color) @description = description @color = color end end item = Item.new("mango", "red") puts "#{item.description} hello, #{item.color} hello" 
To clarify, if you explicitly return, multiple values will automatically be wrapped in an array. If you aren't explicit, you must wrap it. def foo(a,b,c) return a,b,c end def bar(a,b,c) [a,b,c] end
&gt; Just type "x" in irb and it returns nil [1] pry(main)&gt; x NameError: undefined local variable or method `x' for main:Object from (pry):1:in `__pry__' 
this is what I was looking for. ruby has some cool but unfamiliar things going on (attr_accessor is neat, but new). what does the #{...} symbolize? 
&gt; what does the #{...} symbolize? It's string interpolation, only available with double quotes. It evaluates the statement in the parantheses, calls `to_s` on it and concatenates it at that position. 
I fail to see how that page leads anyone to conclude that "TIOBE is the programming language equivalent of NetCraft." Frankly, I'd call it a very balanced way to measure a difficult concept such as "programming language popularity". Were you aware that Gartner Inc. and ThoughtWorks use TIOBE to make recommendations to Fortune 500 companies? If it's good enough for Gartner, whose business model is _built_ on making good recommendations, it's good enough for me.
it seems like about 2 times per hour of studying I get to think "damn, I love ruby." Thanks for your help. 
Ahh, TIL! I'd still recommend the "bar" approach though since that's the convention you'll find more often than not.
`each_with_object` is probably the best middle ground. It's like `reduce/inject` but the expectation is that your block mutates the object you pass in. words.each_with_object({}) { |word, sorted| sorted[word] = word.chars.sort }
I came across a Bash function a long while ago for showing a spinning cursor, something you can throw in the middle of no-feedback `for` or `while` loops so you can see that everything is progressing normally. Never thought of doing the same in Ruby, though.
I can't believe I haven't noticed that method before. I find myself using the slightly messier pattern that requires declaring a Hash/Array before the each block all the time.
Huh...maybe I just forgot that I did something with X before trying this and didn't restart irb. I did try something else however. Just typing x in irb throws an error, so I tried explicitly raising an error and assigning to X. x = raise("WTF") and while the error popped up, x became nil. Perhaps because raise returns nil? So assigning x = x is like saying x = (the result of an error being raised, which is nil). It is curious how the error isn't actually raised in the application though. EDIT: Perhaps this post illustrates what's happening? https://www.ruby-forum.com/topic/53573
I had originally deleted my comment since I re-read the post and it only seemed semi-relevant but OP commented that it was useful so I'm reposting it. FWIW my about_scoring.rb: def score(dice) total = 0 unless dice.empty? (1..6).each do |n| x = dice.count(n) if n == 1 total = total + (x/3*1000) + (x%3*100) elsif n == 5 total = total + (x/3*500) + (x%3*50) else total = total + (x/3*(n*100)) end end end return total end With the koans in particular I really tried to think about "what are they trying to teach me here" and "what's the most Ruby-way of doing this". Edit: Also tried for the most concise solution, which I feel like is the Ruby way.
What does that solve? The problem, from the article: "It’s impossible to distinguish whether the program is in an importing state or in a hanged one — that is, to impossible to know whether to sit and wait for it to finish, or to interrupt it because something’s gone wrong." 
I was thinking that adding `nonscoring += x % 3` to the else clause would be the best way to make it more useful to the Greed code. Anyways this is much simpler than my approach and I should remember `Range` next time.
Good call, I actually did basically that in [my objective-c version](https://github.com/jurre/hashtel-objc). I'll do this soon, thanks! https://github.com/jurre/hashtel/issues/2
Pass `--verbose` on to sub-programs.
would you mind telling me as well?
No problem! Omniauth is great once you get your head round it. Glad I could help.
For arrays definitely check out map (aka collect). It automatically fills an array with the return of your block and returns the completed array.
each_with_object probably is the best for creating hashes. I wrote this right after I started breaking away from each's and it was inject that did it for me, so I was kinda championing it for a minute there. Could you think of a situation that really calls for an inject?
I wasn't sure if the DiceSet class was provided or coded by OP, so I neglected it. For the Player and Game classes, I inserted commentary inline. In some cases, I commented out OP's code and replaced with my suggestion. In other cases, (where I wasn't 100% sure of the intent), I added suggested code in comments and left the original code. If there's any confusion about my paste, feel free to ask for me to clarify. [http://pastebin.com/fL6Rn3eR](http://pastebin.com/fL6Rn3eR)
Nice work. A lot of gems require redis just for pubsub so this would make a nice alternative.
The dive set was from another task so it is heavily guided. The winner method is supposed to return an Array if there's a tie. Maybe I should make it always return array by using players.sort.last.score then players.select with the score. The attr_accessor thing.. I really had no idea. Thanks. I was totally thinking in Java. Reading the amended code is mind-opening. Thank you for taking your time to help me.
Yeah, I get the same "Fatal server error" output when I type "x = []" into a shell. That's to be expected since you're essentially telling the program "x" (the X11 server) to start with the arguments "= []", which is apparently not valid. This has nothing to do with Ruby and should not affect your Ruby install. &gt; And when I try accessing my .rb files I now get a message like Can you elaborate on how you're trying to access the .rb files? Are you just trying to execute them, like ruby ./myfile.rb 
It only gets better from here. :)
Two years ago I had the exact same story, Ruby from Java.
+1. What happens if the import takes more than 120 seconds? The fake progress bar will either get stuck at 100% or go over (I'm not sure how it works). I would be better to either give a generic spinner, or real progress like pv does. You could even do the same thing as pv - get file size; spawn MySQL process; send chunks of file to process in Ruby; report progress based on (sent chunks / total chunks).
I would really recommend reading [Eloquent Ruby](http://www.amazon.com/Eloquent-Ruby-Addison-Wesley-Professional-Series/dp/0321584104). It's a good structured introduction to practical Ruby.
I agree, `inject` is almost always a code smell for me. The intention is more clearly expressed using `each_with_object`, `map`, `select`, or even some custom Enumerable extensions like `sum`, `index_by`, `group_by` from ActiveSupport. 
I find myself using reduce in this way sometimes: list_of_hashes = [{a: 1,b:2},{a: 1,c:2},{e: 1,b:2}] p list_of_hashes.reduce(:merge) #=&gt; {:a=&gt;1, :b=&gt;2, :c=&gt;2, :e=&gt;1} Or: list_of_lists = [[1,2,3,4,5],[5,3,2,1],[2,3,4]] intersection_of_lists = list_of_lists.reduce(:&amp;)
ruby-progressbar, when given a total of "nil", uses an indeterminate progress indicator, as explained [here](https://github.com/jfelchner/ruby-progressbar#unknown-progress). Basically the CLI equivalent of the pulsing progress bar in windows/osx
The explanation is below it: &gt;Limiting Instance Variables &gt;A normal controller action is going to have one instance variable. Many actions will use two or three variables, but if you’re getting up above that it’s a sign that you’re missing a domain abstraction. &gt;What is the essential "link" between these objects? Why do they all belong on the same page? Whatever the reason, that should probably be a domain object. Check out the Facade pattern. There is nothing bad about instance variables, in fact, you need them to get your data to the view. However, if you tend to use more than 1-3 instance variables for that to happen, you might want to check your data model. Those instance variables usually correspond to some sort of concept, and maybe should be grouped together in a class. In general, such heuristics are known as [code smell](http://en.wikipedia.org/wiki/Code_smell). They are indicators your code *might* not be optimal. Code fulfilling a 'code smell' criterion doesn't have to be wrong or buggy, however, its design might not be optimal. 
Ah don't listen to most of that; it's wrong. If not wrong, less right than it could be - a half answer at best. http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/ is much more useful. The idea is 1. Take a lot of the logic you are doing in a controller to locate things, look up things, and do useful work. Go and put that into your model 2. All of a sudden you have thin controllers but fat models; now what do you do? 3. Apply single responsibility principle; rinse and repeat. The key insight here is also that "saving your data to a database" (active record) and "doing things that model what your application simulates" (business logic aka "Model") are often mixed together when they shouldn't be. If you aren't familiar with SRP or other SOLID concepts, google has plenty of info; but the simplest way to decide if code should be in a controller or a domain model is to find something you want to do through the web UI and a rake task. Write it in one. Then try and copy/paste it into the other and fix it up a bit. All of the bits that don't really work in the other: keep those in the controller; those are glue code. All of the bits that are pretty much the same: push those into common code (hint: use a lib/ directory to store your application logic) and call that from both places. Pretty soon, your controller becomes very simple and looks more like if PeopleLoader.load('/path/to/file.csv') render "Hurray" else render ":(" end Ditto the rake code.
Well, given this progressbar is faking progress, you have the same problem, only with the false impression that it might be continuing, because mysql might be hung and Ruby is still going. So maybe this is worse, because you're lying to your users?
I was confused as well.
And you'd continue to be lying by saying the process is continuing fine. You don't know that, but you're telling it to the user anyway.
&gt; I restarted my cup and it's working again Exactly.
Given that mysql isn't reporting any of its own progress, then I assume that as long as the process is running, it will continue waiting. It could be in an infinite loop, or hung waiting for IO, or something similar. But as long as it hasn't exited, Process.wait wouldn't know any better.
Seven. There are [seven](http://innig.net/software/ruby/closures-in-ruby) ways.
I am unsure of how up to date this analysis is but here's the in depth detail on closures in Ruby. http://innig.net/software/ruby/closures-in-ruby If anyone knows if this has been superseded or if any of this is no longer true it would be interesting.
Thanks. I have a feeling I'll be reading the CodeClimate article many many times. I'm currently building a "dashboard" with an "activity feed" so I'm looking to reduce the ivar count for the controller. Do you have any recommendations/articles? I'm looking into Facade
Ahhh but why do you use DataMapper? It hasn't been updated in two years.
honestly that codeclimate article is fantastic. I'm a pretty advanced rails developer and I still read it at least once every few weeks. Honestly the facade pattern isn't really what it sounds like. Read the section in the codeclimate article on "View Objects" which sounds like what you're doing. It's basically creating "Widget Models" so if one of the widgets on your dashboard is an Activity Feed, make sure you actually capture an ActivityFeed as a domain model instead of just constructing it from component parts.
Is there a superb reason to use Padrino over Rails? It seems like once you're done with everything you end up where you began, except with less plugins and less support.
What's up with the custom headers you set up? Also, I kinda feel that using an unversioned cdn you don't control for jquery and especially bootstrap is bad news bears.
One would typically place this sort of input validation in a model. Check out the documentation on model validations and their friends here: http://guides.rubyonrails.org/active_record_validations.html :)
Would you suggest anything other than activerecord? I'm a datamapper user, but I'm always up for better options.
ActiveRecord has served me really well with Sinatra. Do you have a reason not to use it? Here's an example project using AR: https://github.com/zachfeldman/sinatra-twitter-mvp
Not sure about the OP, but when I was starting out I wanted to stay as far away from Rails' magic as possible. I wanted to learn Ruby, not just ROR. My next project is big enough that Rails is probably a necessity, so I'll be cozying up to ActiveRecord soon regardless. I just like knowing what options are available, really, in case there's another interesting ORM out there.
if I could give you ten-thousand upvotes I would. Thank you very much! 
Yes. You need a scripting-type interpreted language. It's this or Python. (Go Python!)
&gt; Some people will choose to wrap that finder with a method in their model to hide `ActiveRecord`, but I believe that’s silly for such a simple case. I believe using a memoized helper method to find what article is in params[:id] is silly for such a simple case, I would use an instance variable unless I was loading articles this way in multiple different parts of the site.
Thanks. I'm looking at the different patterns available and weighing what's good and not. (First time to make a view object). How do you feel about decorators (draper/cells)?
That's totally fair - whatever works for you. Admittedly, setting up the asset pipeline on new projects feels like pulling teeth, so I understand the need for "nope, lets work right away".
https://github.com/jeremyevans/sequel is the only really "mature" alternative. I've not used it myself (next project) but https://github.com/jeremyevans/sequel/issues impressed me.
I'll try to come up with something on the spot here. Let's say we have some sort of university database, with models something like: class Student &lt; Base end class Teacher &lt; Base end class Lecture &lt; Base end class StudentLecture &lt; Base attr_accessor :student, :lecture end class TeacherLecture &lt; Base attr_accessor :teacher, :lecture end class LectureController def show lecture_id = @params[:id] @lecture = Lecture.find(lecture_id) @students = StudentLecture.where(:lecture_id =&gt; lecture_id).map(&amp;:students) @teachers = TeacherLecture.whhere(:lecture_id =&gt; lecture_id).map(&amp;:teachers) # the instance variables get accessed in the templates as @lecture, @students, @teachers end def index @lectures = Lecture.all @student_count_per_lecture = @lectures.map { |l| StudentLecture.where(:lecture_id =&gt; l.id).map(&amp;:students).count } @teacher_count_per_lecture = @lectures.map { |l| TeacherLecture.where(:lecture_id =&gt; l.id).map(&amp;:teachers).count } # they get accessed as @lectures, @student_count_per_lecture, @teacher_count_per_lecture end end Note how in both of the methods, all three instance variables occour in some variation (yes, this example is very contrived). There apperently is a relationship between the three variables, that all of them are needed. We also have code duplication (accessing the `StudentLecture`, `TeacherLecture`). If we refactor just a bit, we can actually make it much easier (I'll only show the changed parts): class LectureController def show lecture_id = @params[:id] @lecture = Lecture.find(lecture_id) # to access the same variables, @lecture.students, @lecture.teachers and @lecture would be used end def index @lectures = Lecture.all # as above, just iterate over them and access lecture.students.count, lecture.teachers.cound and lecture itself end end Now, with active record (which is the default in rails), we'd actually use [associations](http://guides.rubyonrails.org/association_basics.html), and it would like the following: class Lecture &lt; ActiveRecord::Base has_many :students has_many :teachers end and they do all the work for you. 
the decorator pattern is a great one, and draper is an implementation of decorators focused on presentational concerns. View Objects or View Models can be more complicated than draper, though. Draper decouples pre-existing component models with their presentational concerns. Other View Models/Objects encapsulate multiple component models. A BlogArticleCalendar might show you a calendar with each day lit up if an article was written on that day and the number of posts on that date, e.g. [this wordpress plugin](http://wordpress.org/plugins/archives-calendar-widget/). The idea of a BlogArticleCalendar is a special View Model/Object that is composed of several (potentially "draped") Article objects. I haven't looked too extensively into cells, but it matches more with the Desktop idea of MVC as it was originally created in Smalltalk.
It's a specific tool with a specific set of takeways and tracks for success.
Interesting, but I feel like the comparatively flat file organization doesn't lend itself to anything other than tiny little apps. I [did something similar](https://github.com/l3ck/sinatra-boilerplate) and put together a boilerplate a while ago (that I've not updated in a long time) based on some projects I'd been working on, but I use a bit more of a hierarchical Rails-esque folder structure. Also, why do you use Rack::Cors if you're just going to add the headers in manually during the `before` block? Seems redundant to me.
Great answer, thanks!
Yes.
Link? Something? :)
https://github.com/sunsations/speed_read
http://stackoverflow.com/questions/159797/is-ruby-a-functional-language
Really the biggest issue I have seen with Sinatra, Padrino, etc. Is if you want others to join in and work with the code. People know Rails patterns, abstractions, and plugins. If you move off that and migrations, environments, tests, logging, etc stray far it gets confusing. In our company because of this we really push even smaller projects to just stick with Rails. It makes getting up to speed faster and making company Rails Engines and Gems that will work for all our apps.
Althou you link to the perl version it is probably a good idea to include a 1-line description of what it actually does. "speed_read is a XXXXXXXXXX. See the perl version for more information"
&gt; Thank you for your feedback. 
I recently exchanged emails with Neal Ford from ThoughtWords (of NoFluffJustStuff fame, among other conferences) about how he comes up with his "Technology Radar" things. It sounds like it's mostly ad hoc based on what he's seeing when he's consulting. I then asked Gartner how they do similar things, and they referenced TIOBE and internal Community of Practice type groups. Personally I'd like to get out of this "fashion-like" mode we're in, and come up with a set of less religious criteria for picking "the next big thing"... but that's probably a pipe dream. P.S. Nodejs is going gangbusters, but the rest of its ecosystem (like Bower, Yeoman, etc.) isn't catching on as fast, which is a little weird I guess.
Also, while it is probably not needed in this case, it is good practice to try and get it running under Travis-CI, gemnasium, coveralls, code-climate etc. ( Example: https://github.com/rurounijones/bsf-scraper ) 
In a controller, there's nothing wrong with having a 'core' instance variable that gets, say, passed to a view. However, in standard OOP I consider it even worse to have too many instance variables. They serve a purpose, which is to describe properties of the class they compose, but one should always be careful about how the methods of a class communicate with each other.
Thanks again. I will have a look at it!
Nice but seems to crash with non-ascii chars. &gt; speed_read-0.0.3/lib/speed_read.rb:29:in `split': invalid byte sequence in US-ASCII (ArgumentError) How about an **#encoding: UTF-8** on the first line? **Edit:** Never mind... it's the encoding of the source string. I'll try to figure it out. --- Got it! This should work for ascii and utf-8 def tokenize(input) input.force_encoding("utf-8").chomp.split(/(?:-|\s)+/).compact.reject{|e| e.empty?} end Tested on spanish text file.. worked OK.
Other quality command-line tools : rubocop, flay, flog, yard, ... Another saas review tool (requires a user account, free for open source) : https://www.pullreview.com/github/mestachs/speed_read/reviews/master
I would be down for this, let me know :). oh and by the way Im not a complete beginner, I have experience building apps in ruby on rails
I'm a beginner myself and would also be interested in this.
&gt; Thank you. Just released version 0.0.4 which forces utf-8 encoding. 
I would be down :)
Sounds fun.
 How about I just give you challenges that will improve your knowledge ? One of the best ways to learn code is to read it. E.g . There is Rails engine (gem) called "active admin" - Explain how the default route "admin" is created - When you register a "Model" in active_admin, how do the default routes get created - How does the default actions get created? - What gems are used in active admin ? - What is warden, and how is it used in Active_admin - How does a rails engine hook into rails? If you are new to rails and ruby you will learn a lot answering those questions. (and learn something you can use in your rails projects) 
I'm not completely new to Ruby, I switched to Rails from ASP.net about 4 months ago when I got a new job, but I'm still new-ish and happy to take part.
Thank you for your input.
I'd love to participate, I find it pretty fun to learn in groups, even when you're the one in a mentor role there's often a lot of rabbit chasing that results in "I don't know, let's look it up." For what it's worth, even if the study group doesn't materialise, feel free to poke at me if you have any questions, the above is the worst answer I can give to something, and that still usually ends up being pretty good when you have someone to help you parse the bits you don't understand. :)
will eventually come out with a sequel version of the boilerplate.
Good point. rack-cors is perfectly fine, actually.
Good idea. rack-cors is much better in production situations, actually, like if you deploy to Heroku. I'll remove the custom headers. **The whole point of Sinatra is to get away from Rails! WHY WOULD YOU MAKE IT RAILS-ESQUE?!** We all need a break from RoR, and Sinatra is the best option. Just saying..
Nice idea. I always found that learning together was better. In addition, you could even do project together, which is much closer to the real situation (ie most of us work in teams). Cannot join as a member (I'm working as a Ruby/Rails developer), but if you want some coaching, I would be happy to chime in.
These are great questions. Do you have a link to more of these questions that require a deep understanding of Rails?
I've long been wondering about this myself, actually. If I could just get Emacs open in a Chrome tab, I'd consider it a huge win.
I just pulled those out of the top of my head :-) 
I haven't used Chrome OS for ruby, but I have used it for web development. If you can SSH into a server, and like developing in some Command Line text editor like Vim, then I would say you are fine. I plan on trying to root a Chromebook soon to try some real dev!
You can easily [install a normal GNU/Linux distribution inside a chroot](http://github.com/dnschneid/crouton), so, yes.
Come join us at [Agile Ventures](http://agileventures.org/)! We're an open source coding collective, focused on improving our web dev skills. We're pair programming (via screensharing through google hangouts) everyday on a variety of web projects (most are Ruby on Rails). All levels of programmers welcome. Scrum times are listed on the about us page, join one us for one of those if you want an overiew of all the projects. We use skype (sorry) for persistent chat to coordinate most of our meetings and pairing sessions, so add Sam Joseph on Skype (username 'tansaku') if you want to be in the loop.
Nice, can you speak to the security issues with this technique that are mentioned on the Github page? It seems like installing Ubuntu and dual-booting would be the way to go. Honestly, I just really like the new form factor, but I don't think there's much of a price advantage to going this route.
&gt; Agile Ventures This sounds cool. I like that you have different scrum times : EuroAsiaScrum 
Thanks for a writeup on testing. It can't get enough attention. However the syntax you're using in your examples is deprecated. Instead of: character.name.should == 'greg' the correct syntax is now: expect(character.name).to eq 'greg' see [this](http://myronmars.to/n/dev-blog/2013/07/the-plan-for-rspec-3) blog article by the lead maintainer of RSpec for more information.
Hmm, yeah this Chromebook 2 will be available as an HD 13" model, so that's a nice boost in screen size. Hopefully the build quality is a bit better. It's actually using a mobile processor, but there have been any benchmarks that I've seen yet to determine if it's got enough horsepower for dev work.
Ah, thanks for pointing that out. I'll be sure to make edits later today. Mind if I link to your comment?
Not at all.
Yeah, we're hoping to grow the organization to the point where we have scrums / pairing sessions all around the world, all the time.
Good Luck, I hope you find something that works for you. FWIW: most of us use 13" MacBook Airs and *really* love them for development (granted they are 3x as much, but they are laptops and not ChromeBooks). Personally, I doubt I could live without my large external monitor .. and local storage, since I'm off the network so much. Honestly, I have trouble fitting everything onto my 256 GB SSD.
Production Machine? You mean like running an application your end users would access? Probably not, You wouldn't want to use a laptop for a app you depend on. Assuming it met the HDD, Memory and CPU specs, read up on the difference between server hardware and consumer hardware. Consumer hardware isn't designed to withstand the long hot temps Server hardware is. Don't use a laptop to run a production app.
I wrote an article about this you might find useful: http://blog.zfeldman.com/2013-10-05-setting-up-a-chromebook-development-laptop/
I'd hardly say having an organized folder structure makes a Sinatra project Rails-esque, I simply aped their basic folder structure (models, helpers, views). For me, the folder organization simply provides a little clarity and sense of structure as the project grows. I have some Sinatra projects that rely entirely on API calls for the data layer but otherwise handle the controller and view layers. With roughly 300 files in each of those projects (between the views, the routing, assets, thin models, helpers, and config) I find having a little structure goes a long way. I find that without that structure the project lacks clarity at scale. The "whole point of Sinatra" is not to get away from Rails. It just isn't. I think Sinatra vs. Rails is just a question of having the right tool for the job; Sinatra is a simple HTTP verb-mapping DSL that otherwise runs pure Ruby. Contrastingly, Rails is a full-blown framework with a baked in ORM and all kinds of syntactic sugar and non-obvious magic. I personally use Sinatra because of the simplicity and the lack of magic. If a project can be accomplished using either tool then I understand exploring Sinatra as a simpler tool to complete a different job, but if something like Rails is required then I don't see how Sinatra can fill those shoes in any sane sort of way. I'm curious why you say that "we all need a break from RoR"; what do you feel about Sinatra is a break from RoR or what do you need a break from about RoR? I'm legitimately curious, not trolling, because it seems a semi-popular opinion that I've not yet heard a good reason for.
Production machine? You can't be serious. These aren't workhorse computers, they're low power machines designed for common casual tasks and long battery life. You can make it work, but you won't be happy with it. It could be useful as a remote desktop to access a more powerful machine, but that's as far as I'd go with it.
Instead of this, try [the 'pv' tool](http://www.ivarch.com/programs/pv.shtml). Highly recommended. No need to reinvent the wheel if you just need a progress bar for your own sysadmin scripting purposes.
Just found this, and I'm interested to see what you end up with! I'm mostly iOS right now, but if you need a hand feel free to shoot me a message.
Having decent specs in a dev laptop saves you a lot of time. I used an Atom netbook for three years as my dev machine (poor uni student). When I got a dev job and my employer bought me a Macbook Air, it blew my mind how much time I'd been wasting waiting for Rails' server to boot or `bundle install` to run or managing how many tabs I could have open and all sorts of related things that add up. I don't really see the appeal of using a Chromebook for dev. It seems like worst of all worlds. If you're trying to pinch pennies, I'd think it's more prudent to use your budget to buy a used laptop with better specs.
Not really trying to pinch pennies, I am just a little curious about it being a tool that breaks the rules a bit. But it might just be better as a fun toy, and let the Macbook Pro do the heavy lifting for 95% of the time.
Yeah, the biggest learning curve in RoR is really just Active Record. I think it's uncontroversial to say that Sequel is a better library for query generation, but Active Record is more useful to learn since everyone uses it. Also much easier to google any issues you have as you learn. Sequel served me better once I was used to Active Record and could appreciate/acknowledge the things that Sequel does better.
I'm pretty new and would love to have people to talk about what I am learning with. 
&gt; jumping on the Rails train You can say it this way, but in reality it's because they built the first "push here, your site is up" stack availble, and it was easier to build a quality product for a single, known stack than to support every possible Ruby application. I've been using Heroku since it was rails only and largely unknown, even in the rails community. (rails 2.3.5 was the most current version, I think). At the time Heroku launched, Rack wasn't really a thing, or at least in its current incarnation - as frameworks started using Rack as the middleware, supporting Sinatra / Camping / whatever became feasible. Once ruby was handled, they added Node.js. Then PHP, then whatever. Heroku is a fantastic example of MVP, then iterate, iterate, iterate to something better. Edit: Looking at [the rack site](http://rack.github.io/), rack only went to 1.0 a few months before heroku was a thing - it took a little while for frameworks to start supporting it en masse, and also took time for Heroku to get their buildpacks using rack as a basis instead of just running rails servers.
I would avoid it since there's usually a simpler solution like using a hash.
It's been a long time coming, glad to see it's officially out!
Nowadays, webdev is more fragmented across interests like the client-side, mobile, single-page Javascript apps (SPAs), the server-side, CSS preprocessors, responsive design, and more. The ecosystem keeps expanding and solutions just can't arch across its entirety anymore. We're all pretty familiar with the MVC/server-side convention now. Any time new tech makes a splash, it's in one of the more focused areas above and doesn't have the same mass appeal as webdev tech had when things were simpler. For that reason, there really isn't a cohesive "bandwagon" anymore. For example, Angular.js is a popular client-side framework, but it shares its niche with Backbone.js and Ember.js (and others). They don't dominate the news. Also, there are a lot of ways to skin a cat now and Angular isn't the obvious solution for most websites. Meanwhile, there isn't a whole lot of new ground to iterate on with server-side frameworks, so even interesting projects aren't going to get the kind of coverage monopoly Rails had in 2007. Most of all, the "best tool for the job" for most websites is still just the same server-side paradigm we've been using. It's just not a sexy topic anymore. Whether you use Ruby or Python or Clojure or Java to build a conventional data-driven website like Reddit, the solution is going to be pretty much the same.
I would be pretty interested in this. I just finished the Ruby course on course academy and am taking the Lynda.com course on Ruby on Rails.
Well, by installing this you more-or-less downgrade your machine's security to normal GNU/Linux levels, which is no different than using Ubuntu or some other distribution directly. You just need to remember that, yes, by default ChromeOS with developer mode enabled is completely insecure, from [the official documentation](http://www.chromium.org/chromium-os/poking-around-your-chrome-os-device): &gt; By default, you can login as the `chronos` user with no password. This includes the ability to do password-less sudo. So you'd have to change your password with `passwd` and (optionally) edit /etc/sudoers to disable paswordless sudo. 
Personally, I've found that I prefer Sinatra over Rails. Rails has too much magic, while Sinatra's lightness and routing/controller scheme strike me as more in the spirit of the Ruby language.
Cool. How does Sinatra play with Heroku vs. EngineYard?
Heh.. hey zach. Still at nycda?
Hey dude or dudette! Totally haha. Who is this?
Haha Oscar from last semester. I recognized your domain.
Ha! I knew it from the pokemon posts =). Hope to see you next week if you've decided to re-take the class! Shoot me an e-mail if you'd like.
It's a Rack app, so it's trivial to use it with them. Really, if there's a Heroku buildpack (https://devcenter.heroku.com/articles/buildpacks) for your language, you're little more than a Procfile away from hosting it on a Heroku dyno.
I realize this is a 'let me Google that for you' situation, but do you personally have a good go-to primer for Procfiles?
Absolutely. But in a script for end users, particularly where you can't guarantee the presence of `pv`, it's useful to know the principles of how to do this.
https://devcenter.heroku.com/articles/procfile When you spin up a dyno, by default it runs whatever `web` command you have in your Procfile. Like: web: rails server -p 3000 In fact, create an empty Rails app right now. `rails new demoapp`. Now create the Procfile in that demoapp folder and put this line in it: `web: rails server -p 3000`. Now install Heroku's foreman: `gem install foreman`. If you run `foreman start` from within your demoapp folder, it will run that Procfile's `web` command. It's how you can replicate heroku's proc system locally. What's cool is that you can add different processes. Like you can add a line to the Procfile: `myworker: ruby custom_worker_script.rb`. Now when you `foreman start`, foreman will launch a process with your `web` command and another one for your `myworker` command. In `custom_worker_script.rb`, write this line of code: `puts "Hello"`. Now when you `foreman start`, you'll see that foreman shows you which process the output came from. It's really simple.
Yes. Using the acer c720 with ubuntu 13.10 on it. Works great with the exception of some hiccups as it is the 2gb model. Its good enough that I've made it my primary machine, but ill probably replace it next fall if/when the next line is released. If you were to get one go for the 4gb model and look into buying a replacement ssd. I was doing nitrous.io for awhile off chromeos but shoddy wifi made it annoying. Otherwise it was solid enough as a secondary machne with just chromeos.
1. Rails had been by this point abstracted into a web-framework-writing-framework called Rack which exposed a standard API for this kind of stuff. 2. It had a critical mass of programmers doing work with real money who were used to experimenting with new tech all the time. 3. It has a pretty good tools culture, and so given the lack of fragmentation in the market meant that Rails deployment looks fairly identical from project to project - everyone's on git, bundler was a thing (iirc), etc. So - it was easier to support a larger number of initial users compared to every other platform. If you support Rack, you get Sinatra for free - much simpler than going through all the myriad Python options.
Node. For better and for worse, it doesn't make a lot of sense *not* to write js centric apps anymore. If you're fresh out of university, there's prob a better chance that you've picked up node than rails.
As an owner of a macbook air I'd never go that route again. They cost too much, and are a pain in the ass to service.
Awesome primer, thanks for writing it. Just a style question. I tend to use let, let! or a named subject block rather than setting an instance variable in a before block. Is there any advantage to the before method?
Citation needed, my friend. When we launched the first version of Heroku (late 2007), Bundler was still several years away, Subversion was the RCS of choice in the Ruby world, and Rack either didn't exist or at least was not in common use. Sinatra existed but was almost completely unknown. We worked really hard to help make Git, Bundler, Rack, Sinatra, and Postgres support common in the Ruby world!
We launched Rack support in March 2009: https://blog.heroku.com/archives/2009/3/5/32_deploy_merb_sinatra_or_any_rack_app_to_heroku Heroku was 1.5 years old at that point, and it looks like the first version of Rack dates back to 2007: http://rubygems.org/gems/rack/versions
Cool... do you work there now?
Correx: I see you were a co-founder. Can you speak to the shift to node/js in general that hiffy mentions, and how that affected your decisions to move past Ruby/Rails to integrate more frameworks?
Not anymore, I left last summer after six wonderful years. Nowadays I'm doing this: http://tech.eu/features/571/heroku-adam-wiggins-europe/
Do you feel like the Ruby community is equally as strong as it was when you founded the company? Do you feel like the (admittedly disjointed) Javascript community, Python community, Objective-C community etc. are able to match up in terms of 'beauty, simplicity, and focus on making developers happy' in some cases?
I don't think it makes sense to talk about “matching up” when it comes to core values. Different programming communities value different things, but values are not quantifiable or objectively comparable. For example, Python is a language that I've always loved. It has values like “explicit is better than implicit.” I wrote about the Python community in depth when we launched Heroku support: https://blog.heroku.com/archives/2011/9/28/python_and_django Similarly, Clojure values composability and correctness: https://blog.heroku.com/archives/2011/7/5/clojure_on_heroku I haven't participated much in Javascript or Objective C conferences or open source so I don't have a good feel for what those programming communities value.
Not sure why you got downvoted - node is pretty obviously the current sociological equivalent to rails circa 2007.
It makes sense if you're building a large app that you'd like to be able to maintain.
What? Node? Honestly I wouldn't know - at this moment I have limited node experience. I want to say that I *doubt* it, but I have inherent biases against js visavis ruby.
I think, in a few years, a lot of places are going to wonder why the else they chose Node, just like after a few years a lot of place wondered why they chose Ruby (although I think Node will be even worse, since since Ruby at least offers some tools for maintainability and correctness).
[ir_black](https://github.com/twerth/ir_black) is pretty popular.
[Tomorrow Night](https://github.com/chriskempson/tomorrow-theme) seems to be pretty common among Rubyists using Sublime Text, and the Vim port isn't half-bad. That said, I've been a Molokai user for years now; the vibrant contrast somehow manages to slip into the background, and that makes it a joy to code in. Edit to recommend `let`ting `g:ruby_operators` be `1` in your `.vimrc`.
Zenburn all the things
Wow, I remember you personally responding to a support email I sent in early 2008. TechCruch had billed you guys as the "online IDE for Rails." At the time I was just getting into programming professionally and was new to Ruby as well. I've had apps on the platform ever since. Crazy to think how much it has evolved.
[Solorized](http://ethanschoonover.com/solarized)
molokai
I spend my times straddled between ObjC and Ruby. ObjC would be lucky to have half the community Ruby has. Cocoapods (based on rubygem and implemented in Ruby) has helped, but it's still not really comparable. ObjC needs a _why, whom I attribute much of my personal love of Ruby to. Chunky Bacon for life. 
Source: https://twitter.com/qrush/status/441023587525218305
This may also be a reason to use let: &gt; [before] has the problem of introducing subtle bugs since @instance variables spring into existence as nil when first referenced. This means that if I have a typo in my spec and say @usar.should be_nil, the spec will still pass even if the correctly-named @user variable is not nil. Not good. Taken from the first example in: http://bitfluxx.com/2011/05/23/some-rspec-tips-and-best-practices.html
So what?
Because interesting?
Up vote this. I've been using solarized for several years. It's fantastic and easy on the eyes. 
I rock [base16](https://github.com/chriskempson/base16) with the Tomorrow-Night flavor for both Vim and iTerm2. It's a great color scheme and has several implementations of popular color schemes and has some of the best color groups from my experience with it. It's especially awesome if you use terminal Vim since terminal Tomorrow-Night (non-base16 version) is horrible.
desert
It costs money to run a business/service. Neat.
Slow news day 
I really like [smyck](http://color.smyck.org/). Its a dark theme with cool undertones; its colorful enough without being overbearing. My eyes really like this one.
ya, the guy who pays the bills on this just responded...
rubygems is not exactly a business.
But it is a service...
Sign up with github is broken.
I've been coding in Ruby for a little over a year now and haven't even begun to look at testing. Why? Because my first exposure to it was also about a year ago in Michael Hartl's Rails book. There was such little explanation of what was going on in the example tests and even less of an explanation of how they were written. I found the entire experience to be very frustrating because the bits on testing got in the way of the bits on Rails. By the end I think I knew less about testing than before. Since then I've been looking for a good (*easy*) read on RSpec and the like. Your writeup seems like it might be what I have been looking for. Thanks.
We know :) Working on it! Oddly, it sometimes works after multiple tries. Working with 3rd party APIs is hard ...
It's completely ineffective at preventing any of the normal mess you see in the controller action/view handoff. The only real problem it fixes is your conscience if you feel that handing off instance methods to a template is "gross." It does seem to clean up a small amount of duplication, but why add a gem when you can just create a method in the controller and expose it to the view via `helper_method`?
&gt; Google "how to deploy Rails" &gt; About 1,810,000 results 
Thanks, that's a thoughtful response. See, I thought that color schemes can impact productivity, but I guess I was wrong. It doesn't matter at all, especially for someone just starting out. Great to know.
I think the idea is that he can provide insights that will save you a lot of code monkey hours down the road. Not sure if he tends to take on more of a consulting role, or more of a production role. Or else, yeah he may just be extraordinarily productive like you said.
&gt; &gt; In the past, RubyGems was hosted on dedicated hardware within Rackspace. While this was certainly cheaper, it created administrative issues. Granted those can be solved without using AWS, but we get back to again desiring to have as low of friction on the administration as possible. &gt; &gt; If Rackspace can be of assistance in the future, feel free to reach out (brian.curtin@rackspace.com). We currently donate hosting to many open source projects, including ones in a similar space, like the Python Package Index. Really cool of Rackspace to do! Have they considered using p2p software like torrents for the gems themselves? It might be more complicated, but allows other companies and people to easily "donate" their bandwidth to help out. For example, I would love to seed all my most often used gems and upload at my glorious 2 mbps upload speeds.
better than* you
Yes, definitely. I switched to Solarized Dark a few years ago after trying all manner of colour schemes, and it's testament to its quality that I haven't changed since.
$300 dollars an hour is an absolutely ridiculous number for consulting.
In the Pricing. Click on the "Try 1 week for free" 
Latency would be really high, which is undesirable considering how often 'bundle install' runs, methinks.
Even limited to that, he needs to be amazing before I'll pay that wage.
While 300 seems a little high, Hipstamatic is a extremely sucessful app, and he just sold another app called Cheddar. Also, if you look at the other things he's contributed to, and created on his own, the guy looks like he knows his shit.
Ideas are cheap and NDAs bring a large amount of legal overhead to future endeavors. If someone wants me to sign an NDA to hear an idea, I tell them to jump in a lake.
I prefer using inherited_resources.
Too often HN is a big pissing contest where everyone tries to project themselves the expert.
This.
You're correct, but that's an unfortunate indictment of our industry: those who are 10x as productive as the "norm" do not get to collect 10x the wage. The value of consulting is that, in theory, you get to mark up your expertise more than with a full time job. In practice, however, without a great reputation and brand name, clients will annualize out whatever rate you give them and refuse to pay more than what the market will bear for full time programmers.
Nowadays, if we want the codebase to not be reloaded in every asset request (in development), we have to use external gems (eg. rails-dev-tweaks). Do you know if it's planned to have that kind of smart mechanism builtin to Rails, just like happened on Rails4 regarding not recompiling what wasn't changed during deploys (which was a big win for faster deploys imo)?
My problem isn't that I dont know how to restructure it, I would rebuild it like this: http://pastebin.com/UaF62DKC My problem is, that I don't know how the right syntax is. I would like to inject a Proc into the middle of the method and I would like to add some options, but how can I do this?
in your couple model, you could put the logic as a before_save or validation method to do the validations and then activate the couple if applicable.
Are there any significant differences (or gotchas) between using regular sprockets require statements and using Sass @import statements ? Is one preferable to the other ?
I've not personally used sass import statements with a Rails 4 app, but it looks like quite a bit is different https://github.com/petebrowne/sprockets-sass. It seems like sprockets does not understand @import to mean that you have a dependency on the other file. Check out that library, hope it helps.
Yes, that's high. And looks like thats by design. But he gets to decide what his time is worth, and how much he wants to make available. Maybe he enjoys spending his time drinking espresso in cafe's and that's how much he wants to make to not do that. He could charge $1000/hr if he wanted, and if nobody wants to pay it, that's fine too. But if he's looking to get regular work, or otherwise needs the money, he'd naturally have to drop the rate. As reference, katz' rate of tilde is $275/hr http://tilde.io/consulting/
Code style and such, is very much opinion. So you kinda need to develop your own sense as to what matters to you. I don't see anything offensive with that. Actually, I think some of those method calls are kinda bleh and would pull them back into the controller if they aren't used elsewhere in the app. For me, a good rails codebase is boring. I can grasp whats going on without a lot of hopping around, and it's all just... basic stuff. I personally would barf at what you refactored it to; I don't consider duplication between create &amp; update to be worthy enough for DRY. Sometimes duplication is fine. Sometimes using fixtures is fine. Sometimes not writing tests first is fine. These are all calls you have to make for yourself. What DHH likes to do, which I favor, is compare before/after; compare both versions beside each other and determine which you like more. 
We deploy to Ruby using Rack and Passenger. It was almost completely headache free to setup, and we can add new projects on a whim in under 5 minutes.
This is not probably about assets, but what is the preferred way of including a coffeescript partial in another coffeescript template? This just seems like a hack https://coderwall.com/p/i62phq
You're the best, thanks. This is what makes the ruby community so great. 
I've been reading "Confident Ruby" material by Advi Grimm. The most accessible and relevant content for you is a [post on Practicing Ruby](https://practicingruby.com/articles/confident-ruby) under "Represent special cases with objects". (He also has a [website](http://www.confidentruby.com/) with a [sample](http://devblog.avdi.org/wp-content/uploads/2013/08/confident-ruby-sample.pdf) and a [video](https://www.youtube.com/watch?v=T8J0j2xJFgQ)) He recommends that you represent these special cases with objects, rather than with repeated `if` checks. As an OO and duck-typed language, let the classes determine themselves which method/special case to call. For example, wouldn't it be nice to just handle the success case: couple = Couple.create(params) couple.activate redirect_to couple.redirect_to(:create) You can then implement the failure case by controlling the class that `Couple.create` returns: class Couple def self.create(params) return params.valid? Foo.new(params) : NullFoo.new(params) end def self.redirect_to(endpoint) case endpoint when :create then "couple.create.success" when :update then "couple.update.success" end end def activate #stuff end def buildProgresses #other stuff end end class NullCouple &lt; Couple # can inherit here, use mix-in, or neither def self.redirect_to(endpoint) case when :create then "couple.create.fail" when :update then "couple.update.fail" end end # one idea is to turn these methods into no-ops def activate; end def buildProgresses; end end There is only one `if` decision fork to make at instantiation, and every other invocation is determined via polymorphism.
&gt; It seems like sprockets does not understand @import to mean that you have a dependency on the other file. u can use `depend_on` directives to make sure sprockets knows that ur `@import`ing things
yes, and exactly. I just meant out of the box, it doesn't work...you have to do extra work. Thanks for clarifying
**I'm not seeing what you're saying :(** Gonna need you to be specific as to what level and what part of your code. Also, let me know if you're just showing an inconsistency or if you think there's an actual issue :) As for unable to modify warrior: I've tried modifying warrior outside of their public methods. I think the code could be A LOT cleaner if we could monkey patch or touch `warrior` instead of being stuck inside `Player`! Unfortunately, the website got a bit frustrated with me when I tried, and refused to run the code. I'm open to better ways to solve :)
He was comparing P2P to the standard HTTP download mechanism currently used by gems.
A little spin off of this, I enjoy Monokai.
"Matz is nice so we are nice." I don't think he is part of the Ruby community.
I'm not really getting the "I'm better than you" vibe here. Yeah, $300 is a pretty high hourly wage, but other than that his conditions are reasonably common, and presented in a completely emotionless manner.
I wouldn't totally agree with his advice. What he says is merely the inevitable outcome of "not knowing any better", i.e. "you don't really know/learn until you try it yourself". While that's certainly true, spending some time to improve your methodology is healthy. Many problems we individuals come across fall into the class of "has been solved already", so that's we should read other people's code and learn different techniques rather than stumble around aimlessly on our own. That being said, you'll have to strike a balance between "just getting it done" and "learning how to do it better".
If you hire someone from Accenture or Deloitte for any business consulting you're paying WAY more than that. Also if this was a lawyer's rate no one would have a problem with $300/hr. I'd have a hard time you telling me the lawyer is adding more value to your company than a talented developer
that's just the usual hn noise; to be honest i've started mentally filtering it out. the good bits were the people actually maintaining ruby gems chiming in and explaining stuff, the discussions of how they are currently paying for it, the offer by the rackspace people to donate hosting, and the issues of what tradeoffs trying to lower the bill would involve.
The only reasonable reason to have a consultant sign an NDA is if you're doing something truly revolutionary that is easy to copy, otherwise it doesn't matter. If you idea is not revolutionary, there are probably others doing it. Even if you think it is, there's probably others doing it. If your idea is easy enough that disclosure of your idea can make it easily and quickly replicable, its not revolutionary.
Ah, I'm just pointing out that you can always re-open the "warrior" object (*the instance of the class*) and define methods in there. Not that it's a very clean solution, but it's an option. We can't modify the *class* but we can always modify the *object*.
I know sprockets and the Rails4 integration pretty well, unfortunately i've never used a coffeescript partial before.
Right? This is the first time I've gotten blasted for asking an honest question. It's actually my first time ever posting to /r/ruby in general. I'm about to start a new project, and I'll be the first to admit that I'm not doing this full time, so it takes a lot of effort to stay on top of all that's happening, changing, and what are considered best-practices. I viewed a colorscheme as a tool, and was asking what 'tool' people found to be most effective. I assumed that since I'd been recommended solarized and molokai in the past, there must have been a reason why - many must find them effective, and therefore the group-wisdom would be established. That's all I was asking. I knew that in the end I would need to pick for myself but I'm not designing my own colorschemes. Thanks for reassuring me that it wasn't a totally unreasonable question.
Unless you come to it straight from Java. Then it makes you angry for a little while. And *then* you're happy. :)
Feedback appreciated 
I came to Ruby from Java via Python. Now I am looking into more Javascript/Coffeescript stuff, which is great because it is easy to distribute your code, but I miss things like optional parentheses all the time.
Hustle is a better way to think about it.
maybe they can propose something to a Japanese government agency... see... ruby was made by a Japanese, and lots of its contributors are Japanese... and 7k per month is small for them (the government) tho... and yes... ruby powers a lots of web application nowadays... and rails is still standing tall too... dunno.. this might be a terrible idea... but given ruby and its community are open source... i think they might as well consider a donation or sponsorship...
I may in the future, but this script is just a small part of a bigger project I'm making
This reads to me like he doesn't want to do much consulting, but so many people ask him about it, he threw this page together to very explicitly state what his requirements are and make sure its nothing but the perfect situation.
I just added an explanation of the code in the post. I hope it is educational!
www.findthatcheatingjerkwhosleptwithmywife.com
I fed it my first and last names and my email's domain but it couldn't find my email, which is simply first.last@domain.com
This is the best description of using sass and sprockets: http://pivotallabs.com/structure-your-sass-files-with-import/ Long story short: don't use sprocket's require statements; use @import. As for sprocket's own dependency graph... that's a good question,
Why would you do this at all? Why not just wrap your coffeescript in a function and bring that into your local scope? You don't compose ruby code by moving around text snippets, so why would you do that with coffeescript? (sorry if I sound hyperbolic, I'm just utterly baffled by that link). 
Nope, none at all (that i'm aware of). There's been talk of adding some kind of JS package manager, but so far it's gone no-where. One of the biggest problems is that so far there isn't ONE package manager system for JS the same way bundler is THE dependency resolution system for Ruby. It's hard to declare what we should use to manage a language when the users of that language haven't settled on one...
I've noted in the readme and in an open issue that there is a limiting happening
Some alternatives: No need for all that escaping. Just use `n="too"` instead of `n=nil` and remove the ternary. %w[i love you].each{|m|eval %Q{def #{m}(n="too") "#{m} \#{n}" end}} i love you #=&gt; "i love you too" Use `define_method` (or `define_singleton_method` on 1.9) %w(i love you).each{|m|define_method(m){|n="too"|"#{m} #{n}"}} i love you #=&gt; "i love you too" Use method_missing def method_missing(m, n="too") "#{m} #{n}" end i love you #=&gt; "i love you too"
The problem I've had with `inherited_resources` is that it's opinionated in pretty much the same directions as the "classic" Rails Way; it just gives you a nice shorthand that moves the standard scut work out of your code. (Which itself is a *great* feature, but…) If you've started trying to move your apps to use any of the Interactor pattern Gems out lately, or a "hexagonal"/"ports and adapters" architecture, or use something like [Wisper](https://github.com/krisleech/wisper) to [decompose your application](http://www.sitepoint.com/using-wisper-to-decompose-applications/) (perhaps because you're moving towards a service-based architecture that can actually *scale*), you'll find yourself beating down the same walls, because `inherited_resources` *really assumes you're still building a "classic" Rails Way application*. If you go down (or get pushed down) any of the paths I described, or many more… that assumption will bite you. **tl;dr:** Both `inherited_resources` and `decent_exposure` are great tools that do what they do very well. They *don't* do the same thing, and they, like most tools, assume that you're a competent, cognisant developer who understands exactly what you're trying to do with your app. *There are no silver bullets.*
IANAL but I don't think we're necessarily describing the same NDA. For the purposes of protecting code, an NDA isn't necessary. Copyright law (at least in the US) makes it illegal for any employee to "take code" if they are not the rightsholder. For the purposes of protecting sensitive personal information, an NDA–or Confidentiality Agreement as its more commonly described in that context–seems perfectly fine. I'm not Sam, but my instinct is that if he consulted on a financial application he would happily sign a document agreeing not to disclose bank account balances. But for the purposes of protecting a product idea, business plan, or application architecture, an NDA actively costs the signer future opportunities. Get an opportunity to work for a competitor two years down the line? Sorry. Have a half-completed side-project that kinda resembles something covered under the NDA? Gotta abandon it. It is perfectly reasonable for a consultant to ask for compensation in order to offset those lost opportunities. 
It's still eye-opening to see the detailed costs of running a community project. Those kinds of numbers aren't often disclosed and even less frequently make the news. It was also neat to find out that those hosting costs are supported by RubyConf and RailsConf.
Not so nice.
Feel free to show some code how you would handle the validation example.
Brute-forcing a private LoginStatus API to fish for emails, even politely with an exponential back-off, seems like a good way to get yourself in a lot of trouble with the provider of said API.
For a moment I thought your email address was literally first.last@domain.com and was thoroughly impressed.
Oh. I just glanced at the source. I kinda assumed the string manipulations were just some formatting for the api.
wat! u suk! this is fashism Seriously, though, I like it! I like the way the code is laid out. I also like that there is a class called Holocaust. Have you tested it out yet? If I can offer one minor criticism: Set up your text editor so that it inserts 2 spaces instead of a tab. Your code may look fine in the editor (maybe it's set to display tabs as 2 spaces), but when you view it on github, it looks kinda wonky because github displays tabs as actual tabs. This can especially look bad if you use a combination of spaces and tabs in your code -- I'm guilty of this, too, but it doesn't matter because my text editors are set up to insert spaces instead of tabs, so there end up being no tabs in my code regardless.
I'm getting a 403 error when opening `https://profiles.rapportive.com/contacts/email/name%40gmail.com`. JSON returned with the error: { "error_code": "missing_session_token", "html": "\n&lt;div class=\"error\"&gt;\n &lt;h1 style=\"font-size: 16px; color: #404040;\"&gt;Rapportive needs upgrading!&lt;\/h1&gt;\n\n &lt;p&gt;\n It looks like your Rapportive has not been upgraded in quite some time.\n Please &lt;a href=\"javascript:window.top.location.reload();\" class=\"text-link\"&gt;refresh Gmail&lt;\/a&gt; as soon as is convenient.\n &lt;\/p&gt;\n\n &lt;p&gt;\n If you see this message continually, please email &lt;a href=\"mailto:supportive@rapportive.com\" class=\"text-link\"&gt;supportive@&lt;wbr\/&gt;rapportive.com&lt;\/a&gt;\n and we'll try to help!\n &lt;\/p&gt;\n&lt;\/div&gt;\n" } Cleaned up html: &lt;body&gt; &lt;div class="error"&gt; &lt;h1 style="font-size: 16px; color: #404040;"&gt;Rapportive needs upgrading!&lt;/h1&gt; &lt;p&gt;It looks like your Rapportive has not been upgraded in quite some time. Please &lt;a class="text-link" href="javascript:window.top.location.reload();"&gt;refresh Gmail&lt;/a&gt; as soon as is convenient.&lt;/p&gt; &lt;p&gt;If you see this message continually, please email &lt;a class="text-link" href="mailto:supportive@rapportive.com"&gt;supportive@&lt;wbr&gt;rapportive.com&lt;/a&gt;and we'll try to help!&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;
I've detected multiple hexadecimal color codes in your comment. Please allow me to provide visual representation. [#404040](http://color.re/404040.png) [#404040](http://color.re/404040.png) *** [^^Learn ^^more ^^about ^^me](http://color.re) ^^| ^^Don't ^^want ^^me ^^replying ^^on ^^your ^^comments ^^again? ^^Respond ^^to ^^this ^^comment ^^with: ^^'colorcodebot ^^leave ^^me ^^alone' 
this code was meant for tutorial, which is why it was written like that. Thanks so much for the help! One question I do have is the until loop. Is it stating until false, keep running the loop? Meaning if we set it to true and the numbers are in order, it will infinitely run the loop? Thanks!
I've been trying to write a guide for my co-worker who is moving over from PHP/Wordpress. I gave up because it made my blood pressure rise to document all the inconsistencies with PHP (I also was a PHPer years ago). The ruby-lang site has a helpful series of "To Ruby from [other lang]" articles: https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-php/
Until tests for 'false'. It's somehow the opposite of 'if' or 'while'. As long as sorted is false the loop will run. (Which makes sense obviously). So if you set it to true, the loop will stop. If you don't want this, you set it to false (as is done when two elements are found in wrong order). If the sorted=true would be missing, the loop would run forever. (I have seen experienced programmers get confused by 'until'. Most other programming languages do not have this and it needs some time to get used ti it)
Great stuff! Thanks for contributing!
That makes more sense. I did not know until tests for false!?! So basically, since we put sorted = false, the until loop will keep running until it's true? 
Sure! I recently switched from custom CSS to Foundation. I followed their instructions to use both `require` statements (to link the code) and `@import` statements to access variables/mixins and all of a sudden my asset:precompile time went to 3 minutes (!) and my CSS ballooned to nearly 1MB uncompressed as the Foundation CSS was being outputted multiple times. So after going down the rabbit hole of "how is this all supposed to work?"... and only found that blog post after lots of hair pulling. Longer story: If you're using both `require` and `@import` make sure you're only @importing Sass that doesn't generate CSS (so variables and mixins only), otherwise that CSS will be generated multiple times. And if you're only using `require` you share Sass variables/mixins between files (because Sprockets doesn't have a sense of a shared Sass scope). I'm not sure if this is already widely known (and was just oblivious) but it seemed really hard to diagnose it (and now when I'm searching around on Github code search for examples, I can't unsee all the projects that seem to suffer from this issue)
First, [here's the post](http://burgestrand.se/articles/quick-and-simple-ruby-thread-pool.html) which leads there. It's from 2011, but seems pretty relevant still. If any more experienced Rubyists see a problem please let the rest of us know. I'm posting this since there is a lack of good information on threading. With some exceptions most posts on the subject are either a rehash of the docs, which don't give much context or guidance on when or when not to use this or that feature. Or they seem to assume some prior knowledge of threading. I only recently learned about thread pools in a one line StackOverflow comment.
Theres a couple of coworkers that use it and they love it. It has many features that are useful to ruby and rails devs. The main reason that the other devs dont like it is the size. Other devs have tried it ( including muyself ), but they go back to vim, textmate, or sublime after a few days for that reason. Given that you already use Eclipse, you should give it a try; RubyMine is a great tool. 
I like it, very complete and nicely documented (especially for a first outing!). You mentioned in the readme that it could be used for users to find if they're registered, but I didn't see that in the api. If I missed it (I didn't read too closely) I think you'll want to make sure either people can only search for themselves or at least can't find the personal information of too many private citizens too quickly.
I spent several years in IDEs (Aptana, Eclipse) before moving to text editors. My coworker has done the opposite, and from what I've seen of his environment, if I wanted to go back I'd go straight to RubyMine.
RubyMine is a great editor and I use it every day. It can be a resource hog at times.
Will do. 
That's not really an issue because when you enter the browser, you're not sending a valid X-Session-Token in the header. 
Unlearning things can be sometimes harder than just learning something. I have seen a lot of C code written in Java, and a lot of php written in ruby.
I neglected to include the error I was getting from running your script from my terminal: $ ruby find_email.rb joe fox gmail.com ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:353:in `open_http': 403 Forbidden (OpenURI::HTTPError) from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:708:in `buffer_open' from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:210:in `block in open_loop' from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:208:in `catch' from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:208:in `open_loop' from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:149:in `open_uri' from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:688:in `open' from ~/.rvm/rubies/ruby-2.0.0-rc1/lib/ruby/2.0.0/open-uri.rb:34:in `open' from find_email.rb:162:in `request' from find_email.rb:172:in `process_email' from find_email.rb:131:in `block in find_valid_email' from find_email.rb:130:in `each' from find_email.rb:130:in `find_valid_email' from find_email.rb:189:in `find_email' from find_email.rb:215:in `main' from find_email.rb:219:in `&lt;main&gt;'
I found this script fun. But it might need better precision. Plus is it OK from privacy perspective? LOL
Does anyone here *use* Opal? I'd love to hear some honest feedback on it...
Lean vim, and you'll have a great IDE for the rest of your life.
This being my first OSS project that others may use, I'm very open to feedback. 
So, as I understand it, Sinatra is meant to be a very tiny replacement of application servers like Ruby on Rails? Seems like a fantastic idea to first learn how to make a basic website using Sinatra and then expanding to Rails once your requirements begin to ramp up beyond what Sinatra can do as quickly as Rails can.
I use RubyMine alongside Vim (my day to day editor). Being able to use some of their advanced refactoring, formatting and code-insight tools can be incredibly handy despite me having a fairly complete Ruby/Rails development configuration for Vim. Nobody should only use one tool but should apply the best tools they can for a job. :)
Just updated the script to fix some of these issues
The manual way of doing this is well documented. I just got tired of doing it manually. https://www.distilled.net/blog/miscellaneous/find-almost-anybodys-email-address/
I'm curious what refactoring features you get in rubymine?
I don't know if I agree. The same reasoning could be used to say, "use C and learn how a computer works, and *then* switch to ruby when you're ready." I would have hated learning web programming if I had to understand it all at once just to get started. Rails gave me a nice environment to start making the computer actually *do* cool things right away.
Ah, I see. Yeah, I just use something like this: `find app -type f -name *.rb -print0 | xargs -L1 sed -i '' -e "s/old_method/new_method/"` I've often been tempted to build a vim macro around that, but it's one of those things I do rarely enough to not feel like I need to really automate it much. Text-only matching has always been "good enough" for me.
As the main author, I can answer any questions you have. I run opal in 6 production apps (in-house/internal). I will be as unbiased as possible - there are definitely situations where it does work, and those it doesn't.
And will that update a comment in a README file or a Haml/ERB/Slim template? What about that one file that had a usage of the string token you *didn't* want to change. Seriously, there's a plethora of tools available to a modern developer. I love me some shell but this isn't a very good argument against having RubyMine in your arsenal.
I started off using RubyMine but found it slow and a bit of a resource hog. The IDE would lock up on me regularly and eventually I switched to SublimeText out of frustration. Recent versions are greatly improved though and many of the problems I experienced are rare occurrences. I have a licence through my company but these days I only really use it for its source control integration and occasionally when I need to debug some ruby. I write all my code in SublimeText. (Linux)
Welcome to OSS and congrats on releasing the project. The first question is always...how is this different, or better, than what already exists? In this case, I'm asking because I have my own [units gem](https://github.com/bfoz/units-ruby), and I'm curious. But, in general, there seems to be a lot of partially complete units gems (mine included) that are all in various stages of abandonment. 
&gt; The same reasoning could be used to say, "use C and learn how a computer works, and then switch to ruby when you're ready." This is, in fact, what I tell people who want to learn how to *program* (as opposed to merely learning how to *code.*) There is quite a range in skillsets that most web coders don't ever use that can benefit them in how they design and build software. I'm of the opinion that those skillsets come from having a broad base of experience that includes, at a minimum, C and at least one functional language.
I'm pretty new to Javascript and web development in general, but so far Coffeescript is already close enough to writing JS in Ruby for me, syntax-wise. On the other hand it's not so far removed from JS that I can't understand the compiled output and how it operates.
Its currently paid for by RubyCentral (which gets money from hosting the two biggest conferences on ruby technologies RubyConf and RailsConf) *Essentially, its already paid for by donations of conference attendees
That's what /r/ruby is for.
/r/ruby's stated purpose is: "A reddit for discussion and news about ruby programming" The purpose of the new subreddit is specifically for asking and responding to questions about the language. It's analogous to: * /r/math and /r/askmath, or * /r/science and /r/askscience This would allow /r/ruby to focus more on discussion of news and topics among more knowledgeable Rubyists. And defer questions like the "Help me understand bubble sort in Ruby" to a different subreddit. The purpose is not to supplant this subreddit for anything except questions from those with less experience with Ruby. 
I'm with Jemminger though, Ruby is slow enough as it is, any segmentation would make it that much slower.
Thanks! Yeah, I covered some of it in my Rationale section, but I try to keep it pretty diplomatic and not tear down other gems. There are actually a ton of alternatives, many of which I was not aware of during early development. I've compiled a list here, http://stackoverflow.com/questions/4235764/libraries-for-converting-physical-units-kilograms-pounds-in-ruby/21794537#21794537, although I may need to update that to include yours =). On to the real question: The main feature that makes mine unique and advantageous is that the unit definitions are not defined and maintained by me. The UCUM spec is maintained by a group dedicated to doing so. By using that spec as my core data, users can be sure that the unit definitions they need are available, accurate, and up to date. Also, many unit libraries support conversions and sometimes math with units they know about (like inch, millimeter, pound, etc.). Another advantage my library provides is that you can combine known units to create whatever you need, say 'kg2.(inch/second)2/pound' -- it's weird, but possible, and Unitwise understands that this unit is compatible with other energy units, like the Joule. And lastly, a common thing I see in the competing libraries is extensive monkey patching on core classes like String, Symbol, Numeric, etc. While I do have a few extensions (two methods on Numeric), these are completely optional. The library is completely functional (except for some syntactic candy) without the extensions, but they can be required for those who like it.
Just at a cursory glance, yours looks like a great start. I can't help but appreciate your choice in syntax -- `3.meters.to_inches` is strikingly similar to my syntax: `3.meter.to_inch` 
Also if I change a constant name it will rename the associated file if it exists.
No, but an environment that is magically "bullet proof" against every edge case isn't a very good argument for having a commercial IDE in my arsenal, because it won't be. I was actually interested in RubyMine until your comment assumed I was trying to offer some kind of "argument" against using it. I would seriously be interested in RubyMine if I could see how it would improve my day to day workflow. Besides, if I wanted to clean up after a rather invasive pattern matching script, I'd use git, not my text editor.
Yeah, that's definitely a valid concern.