more coming
Ha, are all start-up like culture companies mutually exclusive to relocation?
What does it mean? VS code with ionide plug-in already had autocomplete on .Net core projects. What this is about? 
My understanding is you only would have had that, yes on .NET Core projects, but only if you *also* had Mono installed. It was using Mono for autocomplete, whatever the target of the project. This update helps those of us who are .NET Core only, don't even want to have Mono installed.
And Linux? I don't remember installing Mono, but maybe it installed it in the background.
Very cool. I will give this a shot later this evening.
So no. K, thanks
- WPF/Winforms cant run on ARM or Xbox. - browers apps sucks
Uhh how is that a 'no'?
Is it possible to use experimental version of Ionide now?
Function Point from Wikipedia: "A function point is a "unit of measurement" to express the amount of business functionality an information system (as a product) provides to a user.".
ok
It's in the release build, you just have to enable the setting and reload the workspace
Nothing convinces me of the rigorousness and usefulness of a statistic quite like (a) having C and XML appear in the same table and (b) giving the exact same scores to both. And whoever wrote this thrilling piece of literature definitely got paid by the line.
IMO if you know F# then it's 100% worth looking into - as for Cake: if you don't know F# then yes maybe it's a better choice - but why does it seem more mature?
I’ve been using FAKE and Paket for the last few years for work, and if you know F# it is very easy to use (should be simple even if you don’t). I’m still using v4 at this time. I also have some projects building on Cake, and it is much less mature, both in terms of documentation and usability. Error messages from Cake tend to be very nebulous, which has made build debugging extra annoying for me at times.
Can you tell me how you use Paket in your build system?
All my FAKE/Paket projects have a structure similar to what the [fsprojects/ProjectScaffold](https://github.com/fsprojects/ProjectScaffold) layout looks like. The projects each have: * `build.cmd` file, the contents of which look pretty much like the scaffold's `build.cmd`. This is the file used to kick off a build, call Paket to do a package restore, and pass parameters to the FAKE build file. It's used both in local development and by our CI system (Jenkins and now Gitlab Runners). @echo off cls .paket\paket.bootstrapper.exe if errorlevel 1 ( exit /b %errorlevel% ) .paket\paket.exe restore if errorlevel 1 ( exit /b %errorlevel% ) IF NOT EXIST build.fsx ( .paket\paket.exe update packages\build\FAKE\tools\FAKE.exe init.fsx ) packages\build\FAKE\tools\FAKE.exe build.fsx %* * `build.fsx` which builds the project. For things that publish NuGet packages, the `build.fsx` contains lines similar to this (taken from one of my project build files). Target "PublishNuget" &lt;| fun () -&gt; Paket.Push (fun p -&gt; { p with ToolPath = ".build-system/paket/tools/paket.exe" WorkingDir = outputDir PublishUrl = publishUrl EndPoint = publishEndpoint }) Target "PackNuget" &lt;| fun () -&gt; !! "src/**/*.csproj.paket.template" |&gt; Seq.iter (fun t -&gt; Paket.Pack (fun p -&gt; { p with ToolPath = ".build-system/paket/tools/paket.exe" BuildConfig = buildConfiguration Version = version.VersionString TemplateFile = t OutputPath = outputDir })) Our `build.fsx files also define different paths for code building. Most of the time, developers only care about building the software, and not packaging it or shipping off a pre-release version from their own computer, so my `build.fsx` targets look similar to this (from a simple NuGet package repo) "Clean" ==&gt; "Rebuild" ==&gt; "CopyAssets" ==&gt; "UnitTest" ==&gt; "All" "PackNuget" ==&gt; "PublishNuget" ==&gt; "Publish" On a build machine, `build.cmd Publish` is executed, whereas on a local machine, the standard `build.cmd` will just do all the targets specified by `All`. * `.paket` top-level directory - this contains the `paket.bootstrapper.exe` and `paket.targets` files from [Paket's Github releases page](https://github.com/fsprojects/Paket/releases/). * `paket.lock` and `paket.dependencies` - The files Paket needs to know what software versions to install. Stuff to be aware of: * By default, this setup will fetch the latest Paket release pretty much always. Tends to not be a problem as Paket is very backward-compatible, but I've had to lock versions before due to some package resolution issues I didn't want to fix at the time. * [paket.template](https://fsprojects.github.io/Paket/template-files.html) files make life pretty easy.
Ive used both and Im currently replacing all cake scripts I find with fake. Cake looks more mature on the outside but ooooh jeeez how immature it feels after using it. Fake feels rock solid in comparison, it often takes me shorter time to rewrite cake scripts to fake than to troubleshoot cake issues. Not kidding. I seriously do not get why cake is getting so much positive attention....
I tried Cake because I’m responsible for getting people to use tooling, and I haven’t been able to get many people to understand Fake beyond the basics, because they’re all turned off by F#. Everyone I work with is a C# developer so I figured maybe Cake would appeal more to them. It’s too unpolished for me to recommend so I’ve stopped trying to use it for any other projects.
Yes, you need a custom converter, but you don't need to write it. Install Fable.JsonConverter from NuGet (or copy it from GitHub - it's a single file), it handles this case specifically in addition to a few other improvements.
FAKE was a great way for us to introduce F# to folks who were intrigued by it, wanted to stretch their skill set and looked to experiment with a functional language having been so focused on c#. I think you could "sell" F# to people pretty easily. And FAKE is a credible and accessible way to do this. (especially if you are replacing a lot of msbuild/xml build tools).
I've managed to get a few people to 'own' their software builds and some developers have learned FAKE and some of the F# necessary to extend/customize their builds or write extensions for their own purposes. The majority of the people I work with are essentially C#-only and would rather someone else deal with the hassle, which has created an environment that's hostile to new ideas and technologies (not just in building, but in writing software in general). I still have developers saying they're trying to build projects that are using "my devkit" (if you can't guess from that terminology, our proprietary build system for .NET is written in Ruby), when all it is is just a combination of off-the-shelf FAKE and Nuget/Paket, and all they have to do is run `build.cmd` from a console window.
Thanks! Seems odd that it's not part of the standard JSON.NET, or seemingly documented anywhere. My Google-fu may be weak.
Nice video!
After spending a day looking into cake, just a simple build, I'd have to agree. I wrote a simple bootstrap script to target fake v5 and it works great. 
More docs, more plugins, etc. After using it though I feel that fake has a better experience. Write a bootloader script for v5 and so far so good.
Oh, you mean there’s an OCaml to JavaScript or WASM compiler? Can you point me to that? Sounds interesting. How do they handle interior with other JavaScript libraries. Elm uses “ports”. 
The main OCaml to JS compiler is [js_of_ocaml](http://ocsigen.org/js_of_ocaml/). It is maintained by Bloomberg and used by, amongst others, Facebook. Apparently much of the main Facebook mobile app for iOS and Android is written in OCaml... 
Also, BuckleScript (from Bloomberg): https://github.com/BuckleScript/bucklescript
How were you setting it up? Did you use a project generator like Forge (or the Ionide dialog menu in VS Code), or `dotnet new`? If so, the easiest way would be to make a blank project instead, then add in the nuget packages. If you really just want to use FsLab, and don't need your build system to do anything other than make an executable for a single project your fastest option would be to not use FAKE or Paket. Also, please note that type providers do not yet work in .net core 2.0, so you may need to either use 1.3, or just the full .Net 4.6 framework.
I've had similar issues recently, and I've concluded that: - There's a bug in Newtonsoft.Json about this because if C# enums can be used just fine for Dictionary keys, single/simple F# DUs should be allowed as well (might create a PullRequest to fix this at some point). - Until I fix the above issue, I've used a TypeConverter like @NihilCredo recommended. However, this has the disadvantage that it doesn't work for Portable projects, see https://stackoverflow.com/questions/46598143/typeconverter-working-for-newtonsoft-json-but-not-jsonconverter-f (another bug to fix, damn)
Wagh, this is complicated! I think I'll just use Python + Jupyter instead.
Go to https://fslab.org/download/, download Journal template, run build.cmd, open folder in Code. 
eh?
He is not currently residing in the US. He's living abroad, not a US citizen and requires a VISA that is not sponsored, so this offer is out of the question for him.
Clearly. That said, "we sponsor anyone who can breathe" &gt; "we sponsor people abroad" &gt; "we sponsor people already in the us" &gt; "we don't sponsor any visas" This does not meet the "no" criteria of "sponsors visa." They just don't sponsor people who aren't foreign nationals.
Why discord when there is already the slack channel? Seems like unnecessary fragmentation of already small community.
[removed]
+1 for the slack one
A lot of us prefer discord
Why not both? People are probably not going to install slack for this if they don't have it, but may drop in if they use Discord. I say the more surface area F# has, the better. 
Both Slack and Discord have web apps as well as desktop ones. 
Thanks! I'll join!
I don't think v5 is ready. v4 is super mature and stable. Unfortunately the website takes you to v5. Look for the v4 docs. Plenty of examples of its use in fsharp repos on github.
I'm writing a graph visualisation tool for events in the game Crusader Kings 2 (to help with modding). It's a "hybrid" F# ASP.Net Core project using Electron.NET. The same project can either be deployed to IIS/Kestrel and run as a website or downloaded as an executable and run in Electron. I'm basically forcing myself to use "modern" tools. So I'm developing in VS Code using Typescript and Electron. I'm using FParsec for the game file parsing and Cytoscape.js for graph drawing.
How does that compare to this: https://www.fstar-lang.org/
much has been said here https://news.ycombinator.com/item?id=15852517
This isn’t really dependent types but it’s still cool.
Works for me.
only advice I can give you: remove the F# support via the setup and then reinstall it ... I have to do this almost every other update that comes along ... yeah #drunkvs
Yes, that fixed it for me too. Thanks. 
Fsharp for fun and for profit. Web site Check that
Thanks. I like the idea of starting out with some "toy" functions. I'll browse through the site and pick a few.
&gt; Uncle Bob, for those who don't know, is an expert on software quality More like an expert on suckering people into buying his books. Give him a bunch of buzz words he and repackage for this audience. Clean, Immutable, Transitive, Decoupled, whatever. They don't even have to make sense in the context, just sound impressive.
Just in case you haven't seen this already, there's nice video presentation by Scott Wlaschin named "F# for C# programmers". You can watch it [here](https://www.youtube.com/watch?v=KPa8Yw_Navk).
As a C# programmer just dipping my toes into F# on my own time... Pull data asynchronously from a bunch of different sources in different formats, process the responses, and combine the data into something meaningful. Trigger it from a GUI, with asynchronous UI updates as each step is finished. e.g. a checkmark appears next to "Got Data from A" when A is done. Why? Well I *know* F# is great for mathematical things. But how often do we actually get to do cool algorithm shit in our daily jobs? Show me doing regular work in F# is not a pain in the ass.
I think the one advantage that F# has over *every* programming language is type providers. I'd be sure to show that off.
I teach programming for game developers, so I have some relatable experience, and I think that people tend to make one mistake in situations like this: Whenever we think of programming we immediately jump to imperative programming. Several of the tips given so far focus on the features you can use to write imperative code (like match statements) or on showcasing "what the language can do". Many tutorials and courses start with the REPL and how it can evaluate expressions like "3+4", and to me that's just a means to an end, and it's the end that I am interested first. Of course features like type providers are a very nice reward for learning F#, but they aren't what you need to see to get an impression of the language. So I would suggest starting with the declarative differences between C# and F#. Start easy by pointing out the similarities and explain how in C# you tend to start with classical KISS objects and as your code grows more complex you tend to drift more and more to behavior-less data structures combined with service-like singletons that perform operations on that data. E.g. you might start out with a Player class that contains a function to persist the player, but as the Player class grows, as you want to improve modularity and as you want to facilitate unit testing you often change the design to a "PlayerData" class combined with a "PersistenceManager singleton". While in object oriented languages that has a certain code smell to it in functional programming that's a very natural thing, and you can showcase that by creating a record type for the data and a module with the persistence function, compiling it to a dll and then opening up that dll with a tool like IlSpy to show what the IL code would look like displayed as C# code. That way you can show that a module with a function is the equivalent to a class with static functions. Next I would show how first class functions and partial application are the reason why you need a lot less code patterns, since partially applying a general persistence function with a database-/file-/network-persistence function to create the persistence function for your data is basically equivalent to binding a PersistenceManager in a dependency injection framework. I think with that base it will be much easier to explain how composing or piping functions, passing functions as parameters or return values and other core features of F# are really helpful and not just a nice-to-have feature. This approach might be especially helpful since you are aiming at explaining the structure of quite a large F# app, so in order to know what you are looking at understanding the structural elements of the language would probably be more important than understanding the match keyword or how folding collections works. 
This is the answer. It’s far more practical. However, as someone else mentioned in this thread, Uncle Bob sometimes seems to be more about what is easy to package and sell than what is truly valuable and practical. I think the SOLID example is also a good one on how functional programming leads you to the pit of success while OO sometimes makes things harder on you. Just google F# SOLID and you’ll find some blog posts by Mark Seemann and Dave Thomas. Seemann’s course on pluralsight about Type-driven development is also excellent as he shows clearly how leveraging the type system can get excellent quality with fewer unit tests and can obviate the need for all the mocking you need to do to get good test coverage to ensure quality with OO and imperative approaches. 
Btw, what is your open-source app?
Can anybody give a quick (heh) rundown of the differences between Hedgehog and FsCheck? The one mentioned in the docs is that Hedgehog shrinks counter-examples before reporting them. Also the Expecto testing library has a FsCheck plugin, but Henrik [declined to support Hedgehog](https://github.com/haf/expecto/issues/136#issuecomment-292935855).
I would make sure you cover the relationship between F#, strong typing and TDD. Show how: - Using a strong type system well (eg. DUs) can let you avoid representing invalid states (so that some tests aren't needed and indeed can't be expressed. - BUT also show how strong the unit testing story is in cases where unit tests and/or TDD ARE appropriate. Consider whether to write standard NUnit/Xunit tests (may be more relatable at first) or whether to go for Property based testing (less relatable initially but more powerful.) It's very important to take the audience with you rather than showing some perfect endstate. But I don't need to tell you that. ;-)
I've never been able to really make use of them except in simple cases.
[EasyAM](https://github.com/DanielBMarkham/easyam)
From your source code: "let doStuff (opts:EasyAMProgramConfig) =..." I love it. I have at least 3-4 of these doStuff or doWork functions per project.
Thanks! Over time I've been collecting various functions that do common useful things. After a few projects, I ended up with a generic way of handling command-line programs. I have generic types that represent command-line parameters, and I instantiate them with the option letter, type of information to expect, and default value. So once I've set up a generic way to handle this, where do I put the core of the work? Main didn't work for me. I was using that to start up the code and handle any exceptions. So I needed a generic function to do stuff, a new main. That's how I got "doStuff" Can't wait to hear Bob on that! I'm also writing a compiler. I should have used something like FParsec and a stack metaphor, creating an AST. Instead, since I didn't have a firm grasp on exactly how I wanted the language to work, I hand-coded it all. It makes the code much bigger than it needs to be -- and I know I've missed some edge cases. It's an academic, experimental use of the language to develop a larger idea, not necessarily solve a problem. I'm quite interested in how Bob handles that goal, as it is unlike the vast majority of commercial coding that goes on -- and perhaps a bit outside his wheelhouse. Don't know.
Does it come as an update of 15.4.x or is it a separate download/install/product? For some reason, I am not getting the usual "update available" for my VS 15.4.5.
It’s a regular update, but I didn’t see it until I happened to exit and then restart VS.
Got a project on my knees that only compiles when an SQL server is running on a fixed adress and port
I'd second the SOLID take... if one is doing OOP and doesn't practice SOLID, well... you really don't have a foundation to sell FP. But I imagine the Clean Coder might be receptive if you can show that once you take SOLID to its logical conclusion you'd end up with FP.
What be these?
Your build script or CI pipeline should take care of instantiating the database with the correct schema before compilation.
So starting a docker instance with SQL server on each compile? E.g. what about generating the database classes based on the schema and if the schema changes regenerate them.
This is how I do it: In debug mode (for active development), the project simply compiles against a locally installed database, so the developer can directly mess with the schema while coding new features. In release mode, the project compiles against a database container on the build server, which gets spawned as a pre-compilation step by the build script and immediately populated with the schema files (which are committed alongside the code). Also, I haven't bothered (yet) with this last part because I don't need it (yet), but to do everything properly the container should be given a unique name and port and the build script should write the connection string for the container in app.config during the build (FAKE has a module for that). This way you can have multiple branches building (and testing) at the same time without their databases interfering with each other.
f# support has been real wonky for me, too. Breaks every upgrade, I recently uninstall/resintalled whole VS 2017 for this. Now its broken again. I dont use VS that much though, mostly VS code and thats good enough for advent of code =)
I'm a C# developer myself and trying F#, and I find that C# asyncs make such asynchronous scenarios much easier then F# does. So it will hardly surprise C# audience. But I understend, that it might be only due to my lack of experience in F#.
Language discussions are weird. At the end of the day, most any .NET language is going to be able to do what any other one does. So it's not about capability -- one language having more capability than another. It's somewhat about syntax and how the language syntax can encourage or discourage common errors. (Like off-by-one and buffer overruns using C arrays) I think the real advantage is that different languages train the programmer to think about solving the problem in different ways. When I was heavy into OOP, whenever I encountered a problem I thought about solving it in terms of classes and graphs. Where do things _go_? Now that I've drank the FP coolaid, I think about _results_. What is this thing supposed to do? Is it supposed to return a web page with a list of items? Ok, write a dummy function to return a static list of items. Build out the CI/CD/DevOps pipeline and go to the next step. As I add more and more complexity, the discussion becomes about transforms. I have a bunch of these things. I want a bunch of these others. Here's how I transform them. It's much the same as coding/describing a SQL statement.
[F# operators](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/operators.%5B-hh%5D-%5D%5B't1,'t2,'u%5D-function-%5Bfsharp%5D)
This is really good. I re-watched it today in prep for my meeting. I think I'll just refer folks to the video. There's just way too much to go over. Plus, I'm still not sure that approaching it like he does is the way to go. As Scott points out, it's the philosophy that's key here, not so much the syntactic sugar (although that's great to know, it's really just a result of the philosophy)
So he didn't look into F# programming at all leading up to this? It's cool that you were able to work him through it, but I'm a bit scared that he would be teaching F# programming principles as he was being introduced to the paradigm himself.
This sounds really interesting. I have only just started looking at F#, so I could use some good resources. Where do I find the videos? 
&gt;Type errors appear in places other than where they are caused and so forth. Even though F# has amazing type inference, I think you can mitigate this problem and make your code more readable by having type signatures in your functions.
Beats me. I don't know a lot about the business side of things. Bob said it'd be 2-3 months before they were "processed", whatever that means. I figured if it was okay I'd come back and post a link then.
Yes. Most definitely. I made the point a couple of times that I start off with well-typed, domain-specific language my code, moving to a more generic format as I test, refactor, and organize my code. One of the interesting things I saw Bob doing was refactoring way too soon, looking for how to express things as succinctly as possible. You can't so that in pure FP, especially if you're a great refactorer. Everything kinda collapses into nothing -- before you've even finished expressing your thought. I found it interesting that a lot of the intuition you bring to the table as an imperative coder can actually work against you.
Do you have an example of that? I mean refactoring to soon seems like a problem you might have in OO as well, you can only refactor well once you've iterated through a few requirements and you see some potential simplification keeping your requirements intact.
Pluralsight
This wasn't Bob teaching anything. Nobody was teaching. I was introducing Bob to the language and talking about how cool it is, why I picked it up, and so forth. As part of that, Bob got to play the student and we worked through a couple of sample projects. This was n't to teach as much as it was to show other OO programmers the kinds of things they should look for if they decide to make the leap. At one point, off camera I said Bob, dude, there is a ton of stuff we're not going over. In my mind I can see all of my friends who code in F# saying "You dummy! You forgot X! You're teaching Y all wrong!" He told me you guys weren't the audience, and this wasn't teaching. If anything, hopefully, it'll be sales material to convince more and more traditional Java and C# shops that F# is ready for prime time. That's why I was there.
I do not. It's something I noticed in the video over a couple of days between watching Bob and James and then Bob alone. I even modified the TDD rules and told Bob to "Find the smallest function you can possibly find that will advance the incoming data towards the solution without creating code pathways -- but once you start, finish that function at all costs. Then figure out what to do with it." I need to review what we did and put it together as an example. I think it would work best as a video, because the programmer is chasing through one test case which he got green and moving to the blue refactor stage, but the function is incomplete, ie a match statement doesn't have all the cases covered. That's not the time to refactor!
Personally I come back again and again to https://fsharpforfunandprofit.com/ - its a really comprehensive and pragmatically oriented site. Its author just released a book on functional domain modelling, DDD in F#, highly recommended. There you'll find one of my favorite F# articles: [low risk ways to use F# at work](https://fsharpforfunandprofit.com/posts/low-risk-ways-to-use-fsharp-at-work/), which gives some really practical scenarios to bridge the gap from passionate hobbiest to pro. There are a lot of other really influential articles there, [railway oriented programming](https://fsharpforfunandprofit.com/posts/recipe-part2/) for example. Up to date community news, and a trove of videos and blog posts at F# weekly: https://sergeytihon.com/category/f-weekly/ Dig around and you'll find there are functional programming slack channels where #FSharp and #FSharp-Beginners are great live resources once you've found your feet. There are a bunch of F# for C#'er articles, too, if that's your background.
&gt; ...once you've iterated through a few requirements and you see some potential simplification keeping your requirements intact. Part of the beauty of F# for me is being able to force those requirements into the Type system so that the code you're working with is 'complete', leaving it open for immediate refactoring... Type signatures on the minor functions and local logic guarantee I can simplify constructs and improve readability while maintaining all functionality, and since the domain types capture the corner cases and dimensions of change and the functions constrain those I'm free to shoot alternative approaches to challenges with very little alteration of the code (and guarantees that the splints satisfy the required signatures). End of the day it moves the point of "solution &amp; quality improvement" forward compared to OOP TDD, and around the time I get to the point of stable beautification in OOP TDD my F# solutions enter into a lovely period of "backspace-based refactoring" - where I can delete every hint of fat across the code-base (unneeded type signatures, removing variables for 'point free form', etc), and things tend to shrink 5-20%. A lot of what TDD provides to OOP (with nulls and without exhaustive pattern matching...), is built in to the functional languages.
I finally started work on the tutorials for the language and here is the first chapter of it. All kind of feedback is welcome. From here on out I intend to work on documentation up to the point I feel the coverage is good enough. I've been working on this for a long time - officially, I've only worked on it full time since the end of February, but if I count the point where I threw in the towel on the machine learning library of the same name and started experimenting on code generators, it has been 14 months. Once I am done with the documentation, I intend to use the language to pursue my interests which are all deep learning related. Originally I wanted to make a machine learning library in F#, but the lack of a Cuda backend and F#'s relatively slow approach to functional programming was a too heavy burden for me to bear. Please forgive me for that. Regardless, Spiral definitely has a strong connection to F# given how syntactically similar it is to it and that it compiles to it and Cuda.
&gt; A lot of what TDD provides to OOP (with nulls and without exhaustive pattern matching...), is built in to the functional languages. That's it. I think if I can get Bob to figure that out, or somehow state it so that enterprise programmers can grok it? It'd be a huge win. F# actually works for you, instead of you working for it. I know that sounds kind of weird to folks who don't understand it. When I code good F#, even if I'm heading down a bad path, the system keeps encouraging me to write good code.
What exactly should I search for to find the videos mentioned?
I think you need to provide a slightly longer overview of the language's purpose, design philosophy, and pragmatic usefulness. The current overview says very, very little, while the tutorial you've written feels like a stream-of-consciouness dump of feature descriptions in varying level of detail, and it left me very confused. As it is, I can understand *most* of the features you described, individually (with some effort), and I understand how they improve over F#'s comparatively limited `inline` and SRTP features. But I have no idea *why* each of them is so important to machine learning, or how the overall architecture of a Spiral program would differ from that of a F# program. As a suggestion, perhaps you could show a small F# machine learning program, explain how F#'s semantics and limited inlining make it unacceptably slow, then show the equivalent Spiral program and how it solves those problems?
Thanks for the advice 
I hate when that happens.
Found it. ^^ Apparently F# interactive uses .NET Framework 4.6.2 while my solution was set to 4.5.2.
Thanks for the feedback. As the language author I definitely have a bias in that the language will always much more clear to me than to the users, so I have to strive to keep it clear. The tutorial is tilted towards people who already have some experience with functional programming and F#, and I intend to for most of the learning to come from contrasting the two languages. Spiral right now is definitely not intended to be beginner language. &gt; The current overview says very, very little, while the tutorial you've written feels like a stream-of-consciouness dump of feature descriptions in varying level of detail, and it left me very confused. The first chapter has been intended to cover what I consider Spiral's most notable features. If there is something you feel that I've covered particularly poorly or insufficiently, tell me and I will fix it. I have every intention of making the language as clear as possible. Otherwise you do not need to worry about being confused. Unless I did it particularly poorly that emotion is just a signal for more information. &gt; As it is, I can understand most of the features you described, individually (with some effort), and I understand how they improve over F#'s comparatively limited inline and SRTP features. This is good to hear. &gt; But I have no idea why each of them is so important to machine learning, or how the overall architecture of a Spiral program would differ from that of a F# program. This is something I will go into in the future tutorials. Do you think it would have been better to have written more before doing this introduction? Or maybe to not have called this an introduction, but leave that for something with more impact than the very first tutorial for the language? When I meant introduction, I meant it literally - as in the language is finally usable. My intention was to do the tutorials in this style until I've gone through all the features, and then go into more depth in the user guide (and the reference.) &gt; As a suggestion, perhaps you could show a small F# machine learning program, explain how F#'s semantics and limited inlining make it unacceptably slow, then show the equivalent Spiral program and how it solves those problems? The actual machine learning parts are intended to come towards the end. The architecture of the ML library is fairly complicated and builds on the earlier abstractions, so it makes no sense for me to cover it before building up the essentials. Regarding F#'s limited inlining, that I am going to go into some detail in the next chapter or two when I introduce monads in the context of parsing. What does that have to do with machine learning? Well, accumulating the backwards trace uses the writer monad pattern. Since Spiral uses staged functions, that allows it do it without allocating any closures. Monadic computation in Spiral can easily be done with no cost at all while I haven't seen a benchmark in F# where using them did not slow down the program by 10x. This is actually a good reason to avoid them in F#, while in Spiral you'd actually want to use them as much as possible. No language that I've seen can do them without the abstraction cost, but Spiral can so I want to highlight that there. In the Cuda section towards the end, the highlight will be how easy Spiral's stage functions together with join points make crossing the language boundaries. Before that though, I am going to want cover Spiral tensor module. This is something that F# cannot at all do without resorting to dynamism and it is fairly miraculous to me how well it turned out. I will take your suggestion to heart after I am done with the essentials. All languages need something short and to the point in order to demonstrate what they are, so a demo should be made.
It seems it's not as per this post: https://www.infoq.com/news/2016/04/fsharp-dotnetcore-linux-mac
https://www.reddit.com/r/fsharp/comments/7ejc07/experimental_support_for_net_core_f_autocomplete/
Nice writeup.
April 2016 is pretty old though.
&gt; I haven't seen a benchmark in F# where using them did not slow down the program by 10x. True. &gt; Before that though, I am going to want cover Spiral tensor module. This is something that F# cannot at all do without resorting to dynamism and it is fairly miraculous to me how well it turned out. I'm curious to know more about this and other aspects. 
&gt; F#'s relatively slow approach to functional programming Are you referring to the performance of computation expressions?
Yes, but in general the way the current crop of functional languages approach abstraction is [inefficient](https://youtu.be/YRoruJRmuLc?t=2449). That link is to a talk by Siskind in which he does some benchmarks for AD in his own language which is not related to Spiral. Vlad uses a similar approach to Spiral (abstract interpretation + partial evaluation), and I am confident I could get the same figures as him for an AD library in my own language. I want to push forward the notion that "inline everything and then optimize" is a much better default than "heap allocate everything and then optimize" in a functional language using Spiral. How much is better is something that needs to be determined. I am yet to make a single benchmark. My focus in Spiral is not so much on performance rather than on abstractions needed to achieve it. This also happens to unlock new levels of polymorphism and way to cross language boundaries with significantly more ease is good and something that I sorely need.
They have multiple videos of F#
*Cough* Search for "Kit Eason" on Pluralsight *Cough*
I couldn't agree more. Are you familiar with HLVM? 
Oh yes!
You accidentally a word
On Linux? 
One correction. Regarding the command line parameter stuff. It's not that I didn't want you to show it to me; I'd already read it. My interest was to re-implement it on camera in a scheme that was different enough that we'd both have to think carefully about it.
Actually, I had studied the language a bit before Daniel came. I've also been programming in Clojure for many years. So the issue for me was much less about functional programming and much more about type inference and static typing in a functional language. 
I've heard about it and I knew about it before I started work on Spiral, but I haven't looked into it. I simply haven't thought about it. I sort of got the impression that it was discontinued back then which made me forget it. On the subject of platforms, .NET as a platform has prove surprisingly difficult to integrate with. So much that I've actually decided not to use the standard .NET reflection to query the types and moved to an entirely macro based approach to interoping with it. I knew I would have to do that for Cuda, but having to do that for .NET was a disappointment to me. The great integration that F# and other mainstream .NET languages have with the platform can be attributed to entirely to the great effort their creators made and very little to its qualities as a platform. Besides the necessity of being easy to work with, the most ideal platform for Spiral would be something that has a clear separation between mutable and immutable objects as Spiral needs that information at compile time to do partial evaluation. What this would allow the language is to expand the range of its literals to include any immutable object and not just the basic primitive types (and strings) that it has now. I've been impressed by some of the work from Rompf's group. Spiral could very well take advantage of a surgical JIT like [Lancet](https://github.com/TiarkRompf/lancet), but .NET does not have anything like it. This would allow it to have compilation at runtime. Currently, Spiral has limited support for runtime at compilation. Apart from what has been built into the language, Spiral cannot compile functions at compile time and run them. This could not be done for arbitrary inputs to them, just literals, but the functions themselves could use any kind of construct and be mutable within their confines. This is why it would be interesting to expand the range of literals allowed to the language. I also think a language like Spiral could very well do tagless GC as it has such precise tracking of types and variables, but that is not something I am interested in trying out personally as my interest in making the language is in different directions. More importantly than doing it taglessly, Spiral could benefit greatly from GC that could manage Cuda memory. Right now I am using a monad for that which adds complexity to the ML library. If HLVM could address some of those needs, I'd be interested in looking into it. That having said, I am sort of satisfied with how things are now. The languages is finally in a state where it not uncomfortable to work in and once I am done with the documentation I can look forward to increasing my machine learning prowess beyond the point where it was 14 months ago. Right now I've only finished the basic backwards pass (logistic regression on Mnist) which I've set as a milestone before moving to documenting the language.
More specifically *generative* type providers; erased type providers were already possible. Unfortunately in both cases this is not running the compiler itself on .NET Core, but cross-compiling to .NET Core using the .NET Framework compiler (running on .NET Framework or Mono depending on your platform). Talking about platform, this should be more portable using this in the project file instead of a `c:\...` path: &lt;FscToolPath&gt;$(MSBuildExtensionsPath32)\..\Microsoft SDKs\F#\4.1\Framework\v4.0&lt;/FscToolPath&gt;
I haven't tried this yet, but theoretically it's possible https://fsprojects.github.io/SQLProvider/core/netstandard.html
Great, will this become syndicated in Apple Podcasts or elsewhere?
Thanks
Absolutely! Perhaps even today, as I have some spare time on my hands.
Great! I'll keep an eye out for it.
Yes, it's possible. In fact, I'm currently using Windows for development and Linux for the build server. This is how I'm set up: 1) Check into source control a folder with the .NET 4.6.x compile-time libraries (FSharp.Data.SqlProvider.dll plus whatever your database needs, e.g. Npgsql.dll). Use this as the static ResolutionPath parameter to SqlProvider. Updating these manually (should you want to) will be *much* easier than figuring out where everything is looking for libraries all the time, I assure you. 2) Remove SqlProvider from your paket.references file (but leave it in paket.dependencies so you can notice when an update is released). Add it manually to the project using conditional references by platform: &lt;ItemGroup&gt; &lt;Reference Condition="'$(IsWindows)' != 'true'" Include="FSharp.Data.SqlProvider"&gt; &lt;HintPath&gt;Path/To/Compile/Time/Libraries/FSharp.Data.SqlProvider.dll&lt;/HintPath&gt; &lt;/Reference&gt; &lt;PackageReference Condition="'$(IsWindows)' == 'true'" Include="SqlProvider" Version="1.1.23" /&gt; &lt;/Reference&gt; 3) Add this boilerplate to your project files to provide the Fsc.exe compiler to the dotnet sdk: &lt;!-- Type providers currently can't run inside the .NET Core 2.0 hosted compiler, see https://github.com/Microsoft/visualfsharp/pull/3658#issuecomment-334773415 --&gt; &lt;PropertyGroup Condition="'$(MSBuildRuntimeType)' == 'Core'"&gt; &lt;IsWindows Condition="'$(OS)' == 'Windows_NT'"&gt;true&lt;/IsWindows&gt; &lt;IsOSX Condition="'$([System.Runtime.InteropServices.RuntimeInformation]::IsOSPlatform($([System.Runtime.InteropServices.OSPlatform]::OSX)))' == 'true'"&gt;true&lt;/IsOSX&gt; &lt;IsLinux Condition="'$([System.Runtime.InteropServices.RuntimeInformation]::IsOSPlatform($([System.Runtime.InteropServices.OSPlatform]::Linux)))' == 'true'"&gt;true&lt;/IsLinux&gt; &lt;/PropertyGroup&gt; &lt;PropertyGroup Condition="'$(IsWindows)' == 'true' AND Exists('C:/Program Files (x86)/Microsoft SDKs/F#/4.1/Framework/v4.0/fsc.exe')"&gt; &lt;FscToolPath&gt;C:/Program Files (x86)/Microsoft SDKs/F#/4.1/Framework/v4.0&lt;/FscToolPath&gt; &lt;FscToolExe&gt;fsc.exe&lt;/FscToolExe&gt; &lt;/PropertyGroup&gt; &lt;PropertyGroup Condition="'$(IsOSX)' == 'true' AND Exists('/Library/Frameworks/Mono.framework/Versions/Current/Commands/fsharpc')"&gt; &lt;FscToolPath&gt;/Library/Frameworks/Mono.framework/Versions/Current/Commands&lt;/FscToolPath&gt; &lt;FscToolExe&gt;fsharpc&lt;/FscToolExe&gt; &lt;/PropertyGroup&gt; &lt;PropertyGroup Condition="'$(IsLinux)' == 'true' AND Exists('/usr/bin/fsharpc')"&gt; &lt;FscToolPath&gt;/usr/bin&lt;/FscToolPath&gt; &lt;FscToolExe&gt;fsharpc&lt;/FscToolExe&gt; &lt;/PropertyGroup&gt; 
I learned the basic concepts by completing the easy challenges on codewars. Learning by doing is still the best way if you ask me.
Thanks! I do plan to learn by working on small problems for the business, but I'll definitely do codewars as well to accelerate the process.
Learning by doing is 100% the best way. Go through a tutorial and then try and build something that will interest you. My go to project is usually a basic mud game, since I think it hits the main areas of programming. Making a to-do app website or a calculator is another popular one. I think the issues you might get going right to f# is twofold beyond normal programming learning. The first is I think there do exist some areas you occasionally need to jump into c$ in my experience. The other is that functional languages love to get into the higher level features really early that might be confusing as a complete beginner.
https://fsharpforfunandprofit.com/
GUI apps wouldn't be ideal for F# imo. F# is best suited for back-end calculation models etc. For beginners, especially, I think they should be focusing on learning how to manipulate data with the built-in collection modules and writing solutions to simple problems in a functional way.
Yeah -- the company is using it for backend stuff -- any good tutorials on manipulating data with F#?
I actually learned F# to use Xamarin, so mine was with gui apps. But I had pretty extensive functional programming experience through lisp, scala, and some haskell, scheme, javascript so it wasn't anything new.
I'm not aware of any good tutorials specifically for F# other than https://fsharpforfunandprofit.com/. Outside of that, I would recommend solving some simple practical problems such as [these for example](https://adriann.github.io/programming_problems.html). One of the listed problems is: &gt;Write a function that checks whether an element occurs in a list. I just wrote a very simple function that solves this using one of the [built-in List functions](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/collections.list-module-%5Bfsharp%5D). let in_list query data = data |&gt; List.contains (query) let data = [1; 2; 9; 7; 24; 15] in_list 3 data // evaluates to false in_list 9 data // evaluates to true You can see here that F# has already solved this problem for us with [List.contains](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/list.contains%5b't%5d-function-%5bfsharp%5d). My process for solving problems is looking at the collection modules for List, Array, Seq, or String, and thinking about which function is best suited. In hindsight, the problems in that link aren't particularly interesting. Bioinformatics is interesting though, and the [ROSALIND problems](http://rosalind.info/problems/list-view/) are often thrown around. A very simple problem listed there is [transcribing DNA into RNA](http://rosalind.info/problems/rna/). A common pattern programmers use is the application of some logic to each element of some data structure. We can solve this problem imperatively using that pattern. let dna = "GATGGAACTTGACTACGTAAATT" let mutable result = "" for x in dna do if x = 'T' then result &lt;- String.concat "" [result; "U"] else result &lt;- String.concat "" [result; x.ToString()] This "mapping" pattern is so common to the point where it has been natively implemented in F# and each collection module has it, including String. [String.map](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/string.map-function-%5Bfsharp%5D) will allow us to solve this much more elegantly. let rna = dna |&gt; String.map (fun x -&gt; if x = 'T' then 'U' else x) I suggest trying some more of those ROSALIND problems using the process of first solving the problem imperatively so you understand the logic required, and then using recursion and/or some of the built-in collection functions to solve it functionally. Almost all of the MSDN pages for these functions have examples to help you understand what they do and how to apply them. I have found those examples to be really useful so definitely check them out. For example, the [Array.map](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/array.map%5B't,'u%5D-function-%5Bfsharp%5D) page demonstrates some more usage of the map function.
Tomas Petricek has a few videos out about using Deedle to work with data. If your company is doing data science in F#, then you definitely want to check them out.
As someone who has watched a bunch of clean code videos and slowly drifted over to f# about 2 years ago, I'd be really curious to get your impressions of F#. Clearly functional programming won't be new ground if you've been hacking on clojure, but enforcing rules via the type system might ( I haven't checked in on clojure spec in awhile). Any first blush impressions of F#? 
This: https://www.amazon.com/OCaml-Very-Beginning-John-Whitington-ebook/dp/B00DJF1ZBQ/ref=sr_1_2?ie=UTF8&amp;qid=1514235617&amp;sr=8-2&amp;keywords=ocaml Then internet your way around F# itself :)
If we're going to propose learning another ML before learning F#, then I'd like to suggest Part A of Dan Grossman's Programming Languages on Coursera. It focuses on functional programming concepts with SML as the vehicle for instruction. The entire series is also worth checking out as well.
Obligatory self promotion! I have a couple of commercial courses which don't assume much prior knowledge: https://www.pluralsight.com/courses/fsharp-jumpstart https://www.lynda.com/F-tutorials/Develop-Financial-Applications-F/516573-2.html?srchtrk=index%3a4%0alinktypeid%3a2%0aq%3akit+eason%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2 (You can get a free trial on Pluralsight.) 
The result is that Spiral is 18x faster than F# for a parser written in the same style. This is the first time I seriously tested Spiral's performance and the result is as you can see in that article. I am really gunning for C with Spiral. One thing I've learned while making this benchmark is to use a library to do it rather than write offhand scripts. I will never do that again as it can completely skew results. The 4 parsers covered in the article can be found in [this folder](https://github.com/mrakgr/The-Spiral-Language/tree/master/Benchmarking) in compiled form. I've been adding to the tutorial for 10 days now and it is going well. I think there is enough material now to really take in what the language is about and use it well, so please have a look. Also do send a PR if you see typos which are no doubt lurking. I am definitely in need of a proofreader and should put more effort in that myself. I definitely have a lot to go before I've cover everything that I want.
I was asking for these specific videos mentioned here. Not just any. 
With pluralsight the answer is “any”. They are all good.
Looks interesting, thanks. 
Hey man thanks -- I'm going to give this a shot
Giraffe + server rendering could be an option if it's mainly a form based app w/o much need to deliver it as SPA
While you'll need to learn all of F#s basic features, l highly recommend getting a really good understanding of algebraic data types and pattern matching. These are so powerful that they'll dramatically improve the quality and readability of your software.
Can you recommend a good starter resource for this?
Very interesting!
If it’s a commercial project, I would probably choose whichever is least risky. You’ll be grateful for the simpler tech if the project turns out to be more difficult than initially thought. 
OK, based on the responses here and on Twitter it looks like it's going to be some combination of VSCode, Ionide, F#, Giraffe, Elmish, Fulma and Fable. (I.e. SAFE stack with some options.) Wish me luck! If it goes well there'll be a conference presentation on the experience, in 2018. Thanks for the responses!
Good to know
This may be a dumb question, but would it be a good idea to consider Spiral to resolve performance hotspots in my F# code? As in, could I re-write an F# module in Spiral and incorporate it into my existing code with relative ease?
It would be awesome if the performance numbers were scaled, with e.g. C# at 1.0.
good idea. I'll see what I can do.
&gt; This may be a dumb question, but would it be a good idea to consider Spiral to resolve performance hotspots in my F# code? It is not a dumb question at all. The answer is a bit nuanced unfortunately. The first thing would be to ask what is the nature of your code. Take a look at the F# parser that I made. It is entirely made out of composed lambdas and the reason F# is slow is because they get allocated as objects and the dispatch is done done virtually. In contrast, Spiral inlines it all and attains great speedups. Parsers are a great target for Spiral. In hindsight, I should have made an F# version of the parser where I used `let inline`'s instead of `let`, but it slipped my mind. That having said, I do not think F# `let inline` would have helped for the kind of code in the parser example. I got great speedups where I replaced `let inline` in the partial evaluator because the functions taking higher order functions were at the top level and they weren't composed, but when I tried it in the parser for the Spiral language I actually got worse results. So before you'd start you'd need to determine whether your code is more like the parser where `let inline` is unlikely to work or more like the evaluator where it would because you'd not want to switch to Spiral unless you have to. Going further, Spiral has a learning curve you'd need to go through before you can harness its full power. There are new levels of polymorphism, staging and divergence issues that need to be taken care of. F# is definitely more suitable for people starting out with functional programming and that would be true even if Spiral had good tooling which is does not at the moment. The ideal kind of beginner in Spiral is actually a programmer who has hit the limit in F# or some other functional languages and wants to move to the next level. This was actually my situation at the start of the year. I made Spiral not because I thought it would be cool, but because I literally could not have made progress on the ML library otherwise. &gt; As in, could I re-write an F# module in Spiral and incorporate it into my existing code with relative ease? The opposite where you write an F# module and incorporate it into a Spiral program would be a lot easier right now. I've tried to make .NET interop better and not succeeded so I can vouch that the great interop that F# has with the platform is the entirely the credit of its team and not the platform itself. In the future that might change, but I do not see it as priority right now. It is unlikely to be to your satisfaction even if it improved. To be a plugin for resolving performance hotspots, Spiral would have to be integrated with the F# compiler and be capable of being called at compile time by it. As a matter of fact, F# is going in that direction of calling custom languages at compile time with its type providers, so there maybe be a path through there, but...I won't say any more than this. If despite it all you do try out Spiral and make some benchmarks, do post about it and your experiences as it would be interesting. Right now the tutorials have too many vapid claims of performance that I'd like to replace with domain benchmarks and I do not have the time to do that work on my own.
Type providers do actually work in .Net Core now. However, as an alternative there's the tried and true Newtonsoft.Json https://www.newtonsoft.com/json
Thanks for the thorough and thoughtful answer, I'll definitely keep an eye on Spiral, I might find a niche for it in my work yet 😊
Also +1 for Newtonsoft, I'm not a big type provider fan though (too many problems with special cases).
&gt; there is enough evidence for some general conclusions I would extremely skeptical of any conclusions drawn from the results on that site. Some of the programs are extremely well optimized while others have been subjectively "de-optimized" by the site's author. Many of the benchmark tasks are fundamentally flawed, e.g. print a constant like pi, and they are all extremely limited in scope due to the requirement to be able to easily solve the problems using just C. 
I don't recognise any of what you are saying. Over the past 6+ months I've found the site always to be fair. The author removes programs that break the rules. Its obviously a low level benchmark focusing just on the languages. It shows to me than even in this extreme C is only twice as fast as managed languages. Why is the pi benckmark flawed?
&gt; The author removes programs that break the rules. That is a broken methodology. There shouldn't be "rules" and there shouldn't be a requirement to have them subjectively enforced. If you look at the history of what he has done, for example: he has subjectively "de-optimized" numerous programs over the years for various different reasons. One common problem was that he invented benchmark tasks that required code to be written that did not actually do anything and, therefore, many languages (but particularly Haskell) simply didn't execute the pointless code. Rather than fixing the actual problem (the flawed tasks) he went through the code in languages foreign to him and subjectively "de-optimized" it himself. If you Google you will find many examples of this. &gt; It shows to me than even in this extreme C is only twice as fast as managed languages. You're assuming the C solutions are fast. In the past I submissed many programs that were often many times faster than those listed only to have some of them subjectively rejected by the site author. The programs listed there now will not be representative of fast code. They also aren't representative of idiomatic code. &gt; Why is the pi benckmark flawed? It accepts no input and outputs a constant. Therefore, its computation is trivially reducible and we have no idea how much of that work is being done at compile time. People have submitted aritrarily-fast C++ programs that used the type system to compute the answer at compile time and some of those have been rejected or subjectively de-optimized by the site's author. 
I think you are exaggerating the problem. Similarly to sport you have to ban unfair practices and have rules. I've always seen a good effort to keep it fair. I've had several entries rejected and seen others dropped at a later point for good reason. Its subjective yes but imo they do a good job and the results have meaning. Point to or construct a better more complete set of benchmarks if you think they can be improved on.
&gt; Similarly to sport you have to ban unfair practices and have rules Benchmarking programs should be similar to science, not sport. &gt; Point to or construct a better more complete set of benchmarks if you think they can be improved on. Sure: * [Ray tracer language comparison](http://www.ffconsultancy.com/languages/ray_tracer/) in Java, Lisp, Standard ML, OCaml, Haskell and C++ * [Symbolic derivative](https://flyingfrogblog.blogspot.co.uk/2017/12/does-reference-counting-really-use-less_26.html) in Swift, OCaml, F# and Mathematica * *n*-th nearest neighbors in [F#](https://gist.github.com/jdh30/05c6cb6adc4861dc6db133163bb9a6fa), [Rust](https://gist.github.com/jdh30/48d041b5f1558fcc3aee77cd6cc860b4), [C++](https://gist.github.com/jdh30/4bdbc34cd158fd86c194) 
I'm going through [this parsing project](https://fsharpforfunandprofit.com/posts/understanding-parser-combinators-4/) to build a few of my own parsers. I should be able to do bibtex pretty quickly, then I'll work on some basic web scraping. From there, I'm going to see about extracting text from PDFs.
&gt; Similarly to sport you have to ban unfair practices and have rules. Even in sports this kind of thing is a gray area at best. I remember reading about a champion skier who was convinced his victories were due to hard work, but the doctors who analyzed his blood found that it could retain oxygen much better at higher altitudes. The mutation ran in the family and some of his relatives were excellent skiers as well. So having good genes is okay, but doping which is the only thing that could narrow that gapped is banned. Do pro sports specifically exist to measure genetics? I think some form of answer will come in the nearby future when AIs start to encroach on esports where large sums of money are at stake. That can be banned as well (and in fact is banned) but then the problem will resurface once they step out in the real world. Ban again? I guess the story could be summed up by saying that fairness creates shadows. &gt; Point to or construct a better more complete set of benchmarks if you think they can be improved on. C might look impressive compared to other languages, but if you think about it, for impure static languages C is more like a competing style than a competing language. You can write C in F# and you'd get C performance if you do that. The same goes for Java, C#, Rust and so on. I'd guess that over a large enough sample of programs, they'd all converge to about the same performance. C is what you get when you do inlining by hand.
Chiron alpha for .net core
I spent the holidays updating a pet personal productivity project, newspaper23.com It goes to a bunch of different news sites and collects all the new links and puts them in a sortable, filterable view. It's easier for me to scan 50 sites quickly that way. I've written this app 3 or 4 times over the years. Yesterday I got it running but then it started hanging when bringing up pages using HtmlAgilityPack and their webClient, even with the timeout set. So now I gotta figure out how to deal with that. It's most enjoyable. I decided to use the NewtonSoft Json serializer for persistence, and it's way cool to be able to suck my data directly into a web app using JQuery and Vue.js without any extra work at all.
I've found this site extremely useful to get acquainted with basic F# functionality http://exercism.io/languages/fsharp/about The idea of this project is: You get one task at a time, and you don't see answers until you submit your solution. After that you can browse other people's solutions to see how it could be done differently. This really helped me. But you should go through some basic tutorials before using this site, to know what are your options in F#
Yeah, as far as I can tell Chiron doesn't actually **do** anything yet. And hasn't had any development in a year. I spent a few hours trying to use it as a replacement for Newtonsoft then realised all the docs and samples were wrong and that Chiron didn't actually seem to do anything related to JSON, just adds a bunch of functional jargon utilities like optics.
Show the fsharpforfunandprofit.com right away! It was the best resource when I learned F# as my first FP language. I was able to successfully use F# in production for an application. It's reached 10K lines, three major revisions changing much of the underlying code, all while having only 1 critical bug and 4 don't-really-have-to-fix bugs in total in it's 2 years in production. Much of this is thanks to Wlaschins site!
&gt; Would you say the functional paradigm helped to write bug-free software? I would say a combination of several features was important to avoid bugs. I still don't know a lot FP, and learning Haskell over the past 1.5 years makes me even more aware that I don't know a lot of FP or create as elegant design as people with experience with it would. That said, there were features that greatly helped: - Discriminated unions (including single-case DUs) - Immutable records - Structural Equality - Immutable containers - Pattern Matching - No nulls - Type Providers - Configuration through partial function application When embracing these features, the project got a lot more type-safe than what's feasible, or even possible, in popular OOP languages. When designing functions as pure, it yields designs which is easy to test, even end-to-end, and the project has a lot of tests. Having lots of features to make it simple to create and use types is a real game-changer, and I was able to re-architecture the application three times as wildly different new requirements was added (because the project was delivered in a short time without bugs). Projects with less safety would be a lot more difficult to change without introducing bugs -- the critical bug (data corruption) was in the first feature launched due to me misunderstanding the domain. 
Can you tell me more about single case DU s. I've seen this on various open source projects, but can't figure out why they're useful
Well alrighty then. How often do you use them? Are you aliasing every primitive?
Here's my [shitagon](https://imgur.com/a/9UVQD) 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/fwhkvAv.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
I've added it where I think it helps to avoid errors or aids in understanding the domain. It needs a bit more boilerplate, not that I think that matters more than avoiding errors. I guess there's performance implications, but it's spread out and haven't shown up during profiling -- for my use-case, being able to parallelize workloads, memoize results and so on has been much more important in getting high performance. I often need to refactor from just taking the type to deconstruct it somewhere. It's not a big deal though as we already have type-safety. type X = X of int let x1 = X 1 let tooHigh (x : X) = x &gt; 2 //tooHigh x1 // Error. Expected int let tooHigh' (X x) = x &gt; 2 // ok 
Going through F# Weekly should give a few pointers. It often contains links to cool showcases, demos, projects etc: https://sergeytihon.com/category/f-weekly/
You should try exercism.io F# has the most exercises if I'm not wrong and so far has helped me a lot to learn Haskell
That last bullet point is basically what “proper” OOP ends up being with interfaces and classes closing over injected config values. 
How much did you enjoy the project? On which component did you most enjoy working?
&gt; How much did you enjoy the project? It has been 6months non-stop in my spare time and part-time the last month, so you can imagine I'm loving it. &gt; On which component did you most enjoy working? The Xamarin.Forms frontend because it leads me to think much more about UX and simplicity. Working on the backend is challenging but less rewarding and exhausting.
Why are you rounding your angle calculation in the polygon function. That’s the first change you might try. 
What were some of the most annoying / interesting challenges you faced while working on this project?
Annoying challenges: - Xamarin.Forms cross-platform appearance. Default styles look good on iOS but not on Android, and viceversa. Still learning. - JSON serialization with F# types is tricky, especially combining it with Xamarin (because of PCL; using .NET Standard was the solution here but it's still immature and I'm not 100% happy with my current solution/workarounds). If I look at this again I'll probably end up creating my own JSON+F# serialization library... Interesting challenges: - Learning the differences between how the most mainstream cryptocurrencies work, and trying to abstracting them in a single backend with simple (common denominator) API for the frontend(s). - Writing fault/inconsistency-tolerant algorithms in F#, covered by tests (really proud of my current approach here, soon to be improved even more). - Contributing to opensource libs that I've had to use when I find issues with them.
&gt;I guess there's performance impllications Since [F# 4.1](https://blogs.msdn.microsoft.com/dotnet/2016/07/25/a-peek-into-f-4-1/) you can use the [&lt;Struct&gt;] tag on single-case DUs (and tuples and records), to create them at one position in memory. If you use the keyword there should be no performance impact of single-case DUs anymore. Multi-case DUs for obvious reasons can't be done as a struct (although you could argue it can be done, if they implemented like C unions where the struct has the size of the largest member, but this might lead to awkward, hard to understand memory impact for most users).
I don't think I found anything I can *only* solve using FP, but the features present in F# (and other FP-languages) greatly reduce the number of lines needed for a lot of things -- and thus less bugs, more safety, faster to read, less noise and more concise domain model.
Try posting this to /r/CryptoCurrency/ and /r/Bitcoin/. You'll probably get more/better feedback from a functionality perspective.
Thanks for the response. I'm rounding it because it smooths out the line, so that it breaks in the middle instead of at the very end if it needs to move over a pixel, if that makes sense. It basically just makes the line more straight
Thanks for your feedback. I've also been working on a Xamarin F# project but I'm finding that F# is kinda getting in the way. For instance: - my app requires a lot of native android functionality which means that I need to do things using android Intent which require recursive type references. This forces me to place all the platform code in one file (expecting over 1000 lines) - Many libraries rely on interfaces and the VS do not have good support for templating implementations in F# and VS 2017 removed support for generating F# by pressing F12 on types defined in other libraries (previously supported by F# Power tools for VS 2015 I believe) - Creating ViewModels requires a lot of object oriented code which is a bit messy Dd you face any these challenges? Would you recommend switching some of the code to C#?
Yes. You misunderstand what I’m asking. Why do it in that method. Put the rounding at the last possible instant. Inside the move method. I suspect your polygons will begin to work better. You shouldn’t round the angles, but the points at the other end of the line. 
Yeah I plan to do this, as soon as I finish a couple of features.
1. borrow my projects then? (frontend branch) then remove my code and add yours, should work. 2. not familiar with Android Intent, what's that? I don't understand why that would require recursive references? 3. you mean to generate interfaces on the fly? I don't see that as a big deal, just develop one interface and when you need another one, copy+paste from the one you did first :) 4. with viewModels you mean the code-behind .fs files that map to .xaml files? yes it's a bit messy but I don't think it justifies moving to C# honestly Do you have twitter? Might be good to check how we're getting along in the future (my username there is same as in reddit).
Hey what does your fsproj file look like? The newer project types target .net standard / .net core. I had a similar problem last week (and I'm not new to .net at all) Try adding / messing around with: &lt;PropertyGroup&gt; &lt;TargetFrameworks&gt;netstandard1.4;net40;net45&lt;/TargetFrameworks&gt; &lt;/PropertyGroup&gt; Note: I took that from https://docs.microsoft.com/en-us/dotnet/standard/frameworks
For those *thinking* about getting one of this guy's books: Do it. Very high quality content explained quickly. A+
Is reading F# Applied a prerequisite? Or the other way round: Is it enough to read F# Applied II if I'm already somewhat proficient in F#?
You can directly dive into F# Applied II. The previous one focuses on individual features (like REST API, OAuth, Rx, EventSourcing) and the latest one is all about how to build a complete user-facing application. Basic understanding of F# (including async) is enough, and you can learn Suave on the go!
Thanks for the information!
I bought this book and the previous book, and I think the complete opposite, it is NOT very good. 15 chapters in and all that's accomplished is a user signup system. The instructions are not clear, many of the framework libs are now updated and incompatible and the book makes mention of it. To me this is the complete opposite from being practical. This is "I REALLY REALLY want to use suave in production even if it isn't the most practical choice and there are far better practical options for doing F# web apps" 
Thanks, Keith for your detailed feedback. It is regrettable that the book didn't meet your expectation. One of the hardest thing in writing a technical book is baselining the versions of the tools/libraries/frameworks. The picked versions while started writing the book may go outdated by the time you complete the book. I did my best to accommodate this up as much as possible while I was writing and based on the feedback, I'll publish the updated version sooner or later. The second hardest thing is the target audience. Each reader will be at the different skill level and come from a diverse background. Some people find going shallow is hard to follow and some other see going deep is a waste of time. Striking a balance is something that I am working on and learning with my each blog posts and books. Regarding your concern about having 12 chapters for explaining user signup process, I agree that it may look unnecessary from the outlook. Here is my take on what I chose to go that way. Each of these chapters is smaller except the two chapters in the middle and each one focusses on only one thing (like Project Setup, DotLiquid Setup, Serving Static Assets, Form Handling, Validation, Database setup, Error Handling in Asynchronous operations, etc.,). I could've put them together in few chapters but preferred the other way as it provides granularity on how to do each thing while doing web development. On the F# tooling concern that you raised, I second your thoughts that it is not at its best. The entire community is working towards it, and it is improving day by day. In the book, I preferred to mention the state of the ecosystem as it is instead of sugar coating it and that's why in the book you might find these parts as hard to digest. To answer your question on "practicality", It depends on the context of your application. If you are going to deploy the application on a windows box, then you can safely ignore the Mono SQLProvider Transaction limitation (from the book) and use it for production. However, if the application requires deployment on a Linux box, It is probably not a go-to option. I faced a similar situation in one of my recent engagement, and I chose to use a different stack. Once again thanks for the feedback and I will work on it in my upcoming writings. 
Have a look at signature files https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/signatures
That makes sense, thank you! And yes I actually ended up solving this by rounding the endX and endY in the move method. Thank you!
&gt;You can write C in F# and you'd get C performance if you do that there are quite a few barriers to doing that. Ignoring having less control of memory which is maybe the most important, there are a great many cpu instructions you can induce from C programs that you cannot from the JVM or .NET 
I would just like to say that if you find the style of teaching on that site impenetrable, you are not alone, and you may find other resources much easier to understand. A lot of people love that site but there are a few of us who are reasonably capable otherwise, but find that site hard to read.
&gt; Ignoring having less control of memory which is maybe the most important It may be just my lack of experience with C, but I am not convinced that having manual allocation is what would allow one to have good control over memory. The key to that is inlining. Inlining is essentially exchanging heap allocation for raw computation. A language [like Spiral](https://github.com/mrakgr/The-Spiral-Language) which makes it easy to make that tradeoff is in fact the one that offers the greatest control over memory regardless of whether it is compiling to a managed language or not. It can be done by hand, but it is not something a human would ever willingly do in ordinary circumstances and for a good reason. Not only would it be enormously tedious and time consuming, but exceedingly unsafe as well. &gt; there are a great many cpu instructions you can induce from C programs that you cannot from the JVM or .NET What do you mean by induce? Do you mean that the C compiler is better or that it is possible to drop into inline assembly? If that is the case then I'd have to agree you are right, but it does not feel like this is intrinsic to difference between the managed and unmanaged languages.
I know I'm a bit late, but F# 4.1 already implements Multi-case DUs (they were missing only in the preview). In fact, the new Result type is one. But, sadly, cases don't share memory like a C union would and they have some naming restrictions, so they're mostly useful when only a couple of cases have data.
But if they don't share memory then they don't have the main feature I'm talking about (memory locality), or am I missing something here?
Bought the first book, and was very unhappy with it. Many typos, unclear and spotty instructions. Stopped reading after a few hours of trying. 
You get _better_ memory locality, since it's a single struct. No allocation + pointer dereference. But it's much more bloated compared to a proper implementation: They emit a single struct with a discriminant, and keep a separate field for every field in the type declaration, most fields being unused depending on the case. So the higher memory usage and copy overhead may make performance worse instead of better, depending on the union. I agree the F# team should fix their memory layout.
Solution will be in the next post... Really?
I used [perfview](https://github.com/Microsoft/perfview) to track down some of the hotspots for my compiler. It is more difficult in F# because if you use a lot of tail recursion as you will get broken stacks, but it was helpful to me nonetheless.
This is the standard for micro benchmarking your code: https://github.com/dotnet/BenchmarkDotNet Used a lot on the F# compiler itself. 
&gt; I don't understand your comments about inlining. Inlining is specialization. The interesting thing about specialization is that for example when you specialize to values known at compile time, it becomes possible to compile what would take runtime matching on values into branchless code. If those values would have resulted in closures or union types at runtime, then this would result in them not being instantiated and instead replaced by code. Hence specialization can be thought of as a trade of heap allocation for code. I describe this kind of thing in the [parsing benchmark](https://github.com/mrakgr/The-Spiral-Language#parsing-benchmark) where I compare a fully specialized parser to ones that do boxing and closure allocation. I did not paste the resulting parsers there directly as they are 150-350 lines, but they are in the repo and a link is provided at the end of the chapter. Spiral really makes stark the choice between heap allocation and simply burning control flow into code. This is not something that would occur to you unless you spend some time programming in a language with first class staging. Even a language like Rust which is touted as a C++ killer cannot do this. At most it can make sure that the heap allocations one does at runtime are safe, but it cannot make the fundamental exchange that Spiral can. &gt; Maybe not in theory, but in practice, it is. I can agree with this.
What would you say is a more practical option for doing F# apps?
I think a lot is broken in VS2017 with F#.
I use F# at my job (on Windows) and at home on my personal computer (Ubuntu). Once you're setup, it's good. Right now type providers don't work on .NET Core (at least, not without some weird workarounds, see https://github.com/Microsoft/visualfsharp/issues/3303). If you need to use type providers, go with Mono (and I suggest using MonoDevelop as your IDE. In my experience I found it faster with type provider completion). Otherwise, go for VS Code/Ionide and .NET Core. As a side note, I usually recommend only using type providers for exploratory data analysis, or on a local file. Why? Well, if you use them to connect to a database, or some API, you're essentially taking a network dependency in your build. Which is a little bonkers. Also, it has the potential to slow the build down by a lot. Happy to answer more questions about F# on Linux.
Also, re: library support I've found it to be fine. The vast majority of libraries will work with Mono, and the "important" (think Json.NET) libraries have explicit support for .NET Standard (although many libraries that target the .NET Framework can still be used with .NET Core). Most F# libraries were also written with some level of Linux support in mind.
Hey, thanks for the answer! So, for someone just getting started with F# on Linux (and F# in general), you would recommend .Net Core over Mono? Type providers are not a must have for me, I just considered them to be a nice language feature to play with a bit. Also, are there any other "core" languages features that you would use in everyday development on Windows that are not yet available on Linux?
For now, I'd actually say stick with Mono. I find myself using the REPL a lot, and that doesn't work on .NET Core (in Windows or Linux). Also, type providers will work just fine using Mono. Code quotations are another feature that will currently not work with .NET Core (in Windows or Linux) but work with Mono. The reason these features (type providers, code quotations, REPL) don't work with .NET Core is because a bunch of APIs and some types/functions that were used in the .NET Framework/Mono implementations changed or became private.
To me, the only compelling reasons to want to use .NET Core are that the project files and CLI are much nicer. Otherwise, from a developer perspective there's not much difference (there's a performance difference, but it doesn't become apparent until you're trying to scale a huge amount).
Haven't they released Visual Studio for Linux and Mac? I know a number of my students used it on Mac for C#.
Visual Studio for Mac is a rebranded MonoDevelop
That's an oversimplification. A year ago, it was a rebranded Xamarin Studio (which was MonoDevelop + some proprietary extensions), but significant changes have gone in now to the point where it's quite different even from XS. The most immediate difference is that [.NET Core](http://addins.monodevelop.com/Project/Index/202) is an alpha package for MonoDevelop. In VS for Mac, it ships in-box as a full release. Beyond that, it has a lot of additional features for ASP.NET Core development, largely due to the fact that ASP.NET Core apps are the largest project type in terms of usage.
I think that's a bit unfair, but I get where it comes from. It's a rebranded Xamarin, which was based on Mono. It's similarities to Mono have been in decline for a while, and it's becoming more similar to the actual VS at a good pace.
&gt; As a side note, I usually recommend only using type providers for exploratory data analysis, or on a local file. Why? Well, if you use them to connect to a database, or some API, you're essentially taking a network dependency in your build. Which is a little bonkers. Also, it has the potential to slow the build down by a lot. Surely this is a dependency whether you use type providers or not, right? There's always an assumption about the DB schema inherent in any code that access data, right? Up to an including that the DB exists at all? Type providers don't actually do anything outside of intellisense, anyway? Thus when your app is compiled and deployed, type providers aren't doing anything.
I've not had great experience with Type Providers. This might not be a popular opinion but I think they're oversold (FWIW I rarely work on Windows so that might have something to do with it). That said I've found F# works pretty well on Linux and macOS and can't think of any issues (Type Providers aside).
I use it on osx and Linux all the time. It works well, though shutdown signal handling can be a bit funky. This presentation is a good overview of signal handling in F#: https://ninjarobot.github.io/openfsharp-resilient/#/
[F# Koans](https://github.com/ChrisMarinos/FSharpKoans) (this can be done with VSC or, really, with anything as long as you don't mind manually compiling) and F# For Fun and Profit are probably the two I would recommend the most.
I'm beginner as well and this has helped me https://docs.microsoft.com/en-us/dotnet/fsharp/ along with F# for fun and profit page that is here http://fsharpforfunandprofit.com pluralsight.com has some good F# courses. There are also pretty good F# videos in youtube as well. One video there that i haven't watched my self called "F# Tutorial" it's made by Derek Banas it's suppose to be learn F# in one video kind of thing. F# 4.0 is quite close to 4.1, so it shouldn't be a problem use 4.0 stuff to learn. But I did find 4.1 standard Result type pretty useful. I bet if google for F# 4.1 you will find out what changed between them. I think most changes are to make F# compatible with new version of C#.
I have quite a few F# books. Out of the two Apress ones, I think I'd go straight for Expert F# 4.0. It has almost everything Beginning F# 4.0 has and a lot more, but both can be a little hard to read. You can't go wrong with the O'Reilly Programming F# 3.0 by Chris Smith. I have the older copy, and despite it being a little out-of-date, it is still my favourite F# book. Almost all of the content still applies for F# 4.0 and later. I found F# 4.0 Design Patterns less interesting, and the formatting leaves something to be desired. Once you get into some more advanced F#, the F# Deep Dives is good, and has some more advanced code examples that you won't find in other books. And I would also say that http://fsharpforfunandprofit.com is probably the best resource on the internet for F# programming. You can also download it as a PDF, which is great for train/plane journeys.
For Xamarin, there are a number of questions (and none have an obvious answer): * What does better Xamarin.Forms support mean beyond fixing bugs? * Is a Type Provider for the X.F. XAML done right something people need? * Are there tooling features people use in conjunction with Xamarin apps (e.g., some Azure hookup) which are broken or could be better? For Azure, it's a similar story: * What are the major things people struggle with in running F# code in various Azure services? * What services are people *looking* to use in the future, and where do the problems lie there? * Are there any language changes which are influenced by running F# code in the cloud? (e.g., a `task { }` workflow in FSharp.Core) There are obvious issues to deal with - such as tackling compiler and tooling bugs that we already have logged, or redesigning some components based on performance analysis work - but beyond that, there are a number of unknowns to tackle. Put differently, I have a vision for what F# development will look like, especially for people new to F#, in the next 1-2 years. Is that vision the right one? What are the holes to fill for that vision to come into fruition, and where to Xamarin and Cloud development fit into that?
Aside from the suggestions made so far, you should definitely also check out 'domain modeling made functional'. The book is currently in 'beta', but the contents are practically finished and it is a really good read. It is not super focussed on teaching all of the little f# tricks, but I guarantee you will be able to make sense of f# and how to structure programs with it when you've reached the end of the book.
Thanks for the reply. Let me give my experience with Xamarin.Forms. I don't know what is going on in Azure well enough. XAML type provider: yes this is needed. Reed Copsey did a great one for WPF but X.F [didn't expose enough](https://github.com/fsprojects/FsXaml/issues/70). While pure code works well, XAML + type provider + code is very elegant and having a XAML UI previewer is great especially for beginners. For Xamarin.Forms, there is an elephant... there are three main X.F platforms... and one is missing. I know that bringing this up makes people unhappy so I will just leave this with the observations that elephants are not small and that 1/3 = 0.33333.... I have never run into problems making use of Azure from F# Xamarin apps, or making use of any .Net components for that matter. For beginners a problem is that structuring large ui projects is hard, the F# community is small, and everyone does it differently. People like me should write blog posts, so each approach is fully written up. When I am done handling emergencies! Interested to hear others' experience or to learn about the F# team's plans as they take shape.
If you're just doing really simple stuff, the .NET Core CLI is easy and has a [documented guide.](https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/get-started-command-line) Mono will be necessary for Type Providers right now, as you mention, so it wouldn't hurt to install that just for future use.
as a beginner you are probably not interested in TPs in the first place (and hopefully they will be available in .net core by the time you are ... well maybe not) but chances are high that you already have mono on your system and if not it has not nearly the impact on your OS that .net has on Windows ;) (it's easily installed and just as easy deinstalled completely) - so just install it If you want to I would recommend adding the repository (see here: http://www.mono-project.com/download/#download-lin) to your system instead of using the basic sources (assuming you rare on something like ubuntu/mint/debian - don't know how things are in other distros sorry) - I think recent F# compilers go there as well Have fun and hack away
I asked a similar question 2 days ago, you can see some interesting comments [here](https://www.reddit.com/r/fsharp/comments/7qcosj/how_good_is_f_on_linux/).
I wrote a lot of F# code during the last years but hardly ever needed type providers. You'll be fine without them. Mono is great, but .NET Core is the future. 
If you don't know exactly what you will need go for what is stable and predictable. If you have a good idea, you can go for .NET Core. If something not work as planned, the switch will be not that hard (ie: Is easier to target Less Features &gt; More than the opposite :) )
I'd install both, but target .Net Core for my products. I'd keep mono installed locally for using fsharp interactive and the few parts of tooling that aren't netcore-only, but run and deploy to production on .Net Core
If you plan to work with any kind of structured data, you'll probably want type providers. Want compile-time type checking of CSV, HTML, JSON, and XML data? Then you want type providers. Want compile-time type checking of SQL database query results. You want type providers. I think type providers are a really attractive feature of F# and I'd sort of hate to have to go without the things they enable. So my choice would be to start by targeting Mono and hope to port over to Core once the feature support comes.
When people usually post this, it's interpreted as "what classes should I take?" or "What books should I read?" That's an important part of learning new stuff, but it's not the most important part. Whatever media you consume, find some project you'd like to write and write it in F#. When I started with F# there was only one book, so I started with a couple of OCAML books and the only F# book. Once I finished those 3, I wrote a small project. Repeat and rinse.
We primarily use Arch as our workhorse. It's working well. We are starting new projects in F#.
If you're already familiar with asp.net I would recommend Giraffe. https://github.com/giraffe-fsharp/Giraffe 
&gt; I would also need an ORM, F# has type providers, something like this for example: http://fsprojects.github.io/SQLProvider/
Look at https://freya.io. It’s based off webmachine. Very nice for APIs, and very functional. For ORM, SQLProvider is pretty good, or any Type Provider based ORM
You are right - that is exactly the guidance I was looking for. The recommendation of Expert F# 4.0 was really good. I am reading the book right now. I was sceptic at first, because seems that 4.0 was released in 2015. If I were judging it the same as javascript, it would mean that the 4.0 is obsolete now and there is no point learning it. I guess I am a bit spoiled by JS ecosystem anyways. In JS language its self is maybe 20% of the knowledge you need, all the rest are libraries and tools. Take as an example this page: https://medium.mybridge.co/learn-react-js-from-top-45-tutorials-for-the-past-year-v-2018-28b7f4d4b2c4 This is for one of the libs there is quite popular at the moment. I was hoping to find something similar for F#, but with no luck. I am happy with the book I am going through right now though. 
This is a great recommendation. Really wish this book was out when I was getting started. It has a ton of lessons that my team and I had to learn the hard way.
What do you see yourself working on?
I want * learn the functional programming mindset *properly* for the sake of learning something new, becoming a better programmer, recognizing functional programming patterns popping up in sw development, ... * develop intermediate scientific computing skills
I see myself in the not-very-near future working on scalable numeric/scientific projects.
In the first case F# can help. Keep in mind it's a functional first language, which means you can use it to write OO/procedural code as well. It won't force you to be functional, but it does make it easier to write functional code. For scientific computing you can use pretty much any language. I don't know if F# is especially suited for that, but it's also not bad. One feature that other languages lack, that F# has in this space is [units of measure as a part of the type system](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/units-of-measure).
Define scalable.... Also industry. I've heard of quite a few financial/algo trading places using f# and ocaml which are similar languages. But if you're in physics for example, focus on python, and some combination of fortran, Matlab and CPP. But if it's for your own benefit it's a good idea I think. 
One reason to choose F# that you might not have considered is that the editor experience is top notch. I think vscode+ionide is smoother than most other functional languages.
if it's about this and not about using it in production I would advise you to learn Haskell (if you are interested in types) or Clojure instead. F# is a hybrid language where you fall back to OO quite often (interfaces, etc.) Haskell on the other hand will teach you *pure* FP with all good and bad that can come with it. Also the FP patterns (Monoid, Functor, Monad, ..) are actually expressible in Haskell (you can only implement them in F# or simulate stuff with SRTP - which are ... well let's say I'm not a fan).
for this kind of work a look at Python or R is probably a better idea.
&gt; For scientific computing you can use pretty much any language. I don't know if F# is especially suited for that Units of Measure, Deedle, the R-type provider, smooth higher order functions and exhaustive pattern matching... F# is very strong for scientific, and analytical, computing. Arguably you might be better off with Python or pure R, but if you want the kind of platform that .Net offers it's the way to go. 
Checkout the R type provider for F# :) R is pretty great for what it is, it's also pretty ass at a lot of things "we programmers" expect languages to be not-ass at. Parallel and cloud computing + number crunching might put someone in need of a stronger platform, where F#s hybrid approach is well suited. Checkout people using MBrace, it'll give an idea of where the industry is :)
all nice and fine - but is your advice to a beginner to both FP and data-science/etc. to start with F# + TP for R + MBrace? that might be an option if you know F# and R and more important know what you want to do If you are new to this than you can find good intro material (books, courses, etc.) in both R and Python I did not want to imply that you can only do it with those tech
I think this is good advice; I learned functional programming via Erlang and being forced to use immutability and not having typical imperative constructs such as while loops really helps put you in the “functional” mindset. I imagine that even though F# is “functional first” that the mix might muddy the waters, especially if you’re not planning on sticking with .Net.
Your question is a bit open ended but unless you're primarily involved in GUI/UX development, I'd say F# is a suitable for you as it's a general purpose programming language with an emphasis on FP. It's also a fairly easy language to learn. Unlike C# which has recently started to look like C#++, F# has managed to stay simple while still remaining very powerful. I would recommend starting with ["Programming F# 3.0"](https://www.amazon.com/Programming-3-0-Comprehensive-Writing-Problems/dp/1449320295/ref=sr_1_7?s=books&amp;ie=UTF8&amp;qid=1516346119&amp;sr=1-7&amp;keywords=F%23). As the title suggests it doesn't deal with F# 4.X but it's a great book for learning the fundamentals of the language. As you get more familiar with the language you should have a look at ["F# Deep Dives"](https://www.amazon.com/F-Deep-Dives-Tomas-Petricek/dp/1617291323/ref=sr_1_10?s=books&amp;ie=UTF8&amp;qid=1516346119&amp;sr=1-10&amp;keywords=F%23). For an advanced book on F# ["Expert F# 4.0"](https://www.amazon.com/Expert-F-4-0-Don-Syme/dp/1484207416/ref=sr_1_2?s=books&amp;ie=UTF8&amp;qid=1516348277&amp;sr=1-2&amp;keywords=F%23) is hard to beat. As for "F# for Scientists", it's a an old book with some obsolete syntax but still very good to for learning some hard-core FP techniques. The author Jon Harrop is very knowledgeable and the book still stuff that you won't find anywhere else. Jon is a real pattern matching ninja!
if you are not planning on sticking with .Net then there is only Fable that might justify any interest in F# - and that is IMO not a really a big incentive. If you are not interested in .net but want a language like F# then you should look at things like Ocaml, ReasonML, ... instead. If it's JVM then probably Scala. Or just go all in Haskell ;)
&gt; is your advice to a beginner to both FP and data-science/etc. to start with F# + TP for R + MBrace? My advice to a beginning *data scientist* to know what they'll be working with in order to see how the ecosystem handles it... If the projects being handled by MBrace resemble what you want to do, then it's reasonably close to best-of-breed for what it does and is *wildly simpler* than the alternatives which also require deep, deep, stacks to complete... Particularly for someone with a programming background, the application development experience through R can be painful, and the BigData story isn't newb friendly... If you don't know what you want to do, language is the wrong place to start. Each specialist area of data science has its own tools, own platforms, and own ecosystem. Start there :) If you spend 2 hours with the F# Type provider you can use any R tutorial, and execute them, in hybrid environment that gives you all of .Net, and won't force you to misuse R for every day programming. Python can be directly integrated into .net apps, so the story there is quite similar, only in areas where a proper type system is required F# can provide the formality. Again, the difference is really the .net platform and the scalability story attached to that. And that's really what it boils down to. For real-world data warehouse, data science, big data, parallel computing, and data crunching: Python and R are pretty great for what they are, but they're also pretty ass at a lot of things "we programmers" expect languages to be not-ass at. If that's not an issue for you, then fine. If that *is* an issue for you, then F# gives the best on-ramp story of any language to do the data side, and on the plumbing side. The MBrace projects should give a nice sense of those aspects. Good info here: http://fsharp.org/guides/data-science 
&gt; Unlike C# which has recently started to look like C#++, F# has managed to stay simple while still remaining very powerful. I would disagree with this slightly. I believe that C# is starting to become C#++/F#-lite. Non-nullable kinda-sorta, pattern matching but non-exhaustive, higher order functions with an almost-there syntax, record-ish types that have no guarantees... A lot of the foundational design decisions of C# have been shown, in the light of industry at scale, to be wanting and the decisions of F# to be far superior. I feel like C# has been trying to converge for many releases, but will never be able to match F#s elegance by not subscribing to and ML design from the get-go...
I would recommend looking at the [SAFE-Stack](https://github.com/SAFE-Stack) and start with [SAFE-template](https://github.com/SAFE-Stack/SAFE-template). It kan be configured for nice minimalist examples with [Suave](https://suave.io/) or [Giraffe](https://github.com/giraffe-fsharp/Giraffe) back-end and with [Fable](http://fable.io/), [Elmish](https://fable-elmish.github.io/elmish/) and [Fulma](https://mangelmaxime.github.io/Fulma/) for SPA. SAFE-Bookstore showcases a fair bit more. 
Try https://fsharpforfunandprofit.com It explains the what's and why's really well in a format that is easy to digest. Especially if you're familiar with C#
On the other hand I tried learning functional programming for quite a while using Haskell and Erlang and never got past the stage of small, rather useless projects like reverse polish calculators. F# on the other hand allowed me to learn the language step by step, and while it's true that I did everything in an object oriented fashion in the beginning the benefits of the language often only work if you let go of that paradigm. After all procedural and object oriented programming are all about managing mutable state, and features like the REPL or piping work best with immutable state. So in the end I found myself just using F# because of type inference and the elegant syntax, and rather than fall back into object orientation I was actually falling forward into functional programming.
This. So many languages are pretty much useless because you have no tools to write any code.
Rider is great, too.
Nice, didn't know about generic zero!
I liked the blog post but in this sense all operators on decimal are a lie. What about: System.Decimal.MaxValue + 1M or System.Decimal.MaxValue * 2M. They both throw. OT; IMHO it would be great if .NET had an IEEE 754 compliant decimal data type. Then the operations would not throw and return +Inf instead (as is the behavior of double).
Yes, i do. Being relatively fluent in french is one of the job requirements, however! 
JavaScript?
Don't ask. The students wanted to cry. At least that particular iteration was sold as a "programming languages" course, so the name of functional programming remains relatively untainted.
Pareil, super poste /u/jfbourget ! Bon courage pour les recherches 
Once you got everything installed and working, about the same as windows. Debugger etc - everything works great. I use Mint/Core and maintain a small micro-service (Suave/Couchbase) to support my micro-business. I would have stuck with windows, but windows VPS are not worth the price in comparison to linux providers.
f prime
Thanks. I had a vague recollection of prime.
And [here's](https://github.com/SaturnFramework) a link to the GitHub org for Saturn. 
Yet another project by some hippies doing OSS, no one cares... 
Not sure if sarcasm? vscode+ionide is certainly not the worst thing ever, but it bugs out all the time. And it's often very slow (even on really beefy computers).
Not if the goal is to learn how to think functionally.
It has had a few growing pains but lately the stability and performance have both been really good. I wish that I'd had it when I first learned F#. Having the inferred type signatures for functions displayed is a huge boon when learning the language.
Good question. There is List.tryFind that has the second signature. I guess List.find is to be used in closed situations where you know for certain that an items is in the list. I see a number of these functions like List.head etc as a warning sign.
Interesting suggestion but I'm having trouble understanding how a language that doesn't have any exceptions is incompatible with something that supports exceptions. It'd be a .NET app that never raises an exception. That's already possible today by creating a .NET app that calls a single function that doesn't raise an exception.
I am not sure that Option and Result were in the original F#. Even if they were, this was when there were very few functional programmers. F# needed to be multi-paradigm back then. 
Consider this (relatively naive) example. You create a Thread using the .NET library. If that thread is aborted or unexpected stopped by the OS, it would result in a ThreadAbortException. If you were using C#, you can easily write a handler for this. But if your language does not support exceptions, the behavior would be undefined and, more importantly, undefinable, which is not good.
&gt; I'm having trouble understanding how a language that doesn't have any exceptions is incompatible with something that supports exceptions. Interoperability between the different .NET languages is a big deal. You should be able to use C# libraries in an F# app and vice-versa. A C# library may throw an exception, so it makes sense for F# to be able to handle that. And if you're writing an F# library that will be used primarily by C# applications, you'll want to consider turning your `Result&lt;T, Errors&gt;` in to just a return of `T` with throwing exceptions; DUs aren't fun to work with in C#.
Another reason for the particular use case above could be that you really know the item you are wanting to find in the list will be in there, and so you just want to find it using `List.find`. If that function always returns an `Option`, you'd then need to get it out of the Option value. If you aren't sure the item you want will be in the list, then you can chose to use `List.tryFind` instead and handle the possibility of getting a `None`. Having two functions just gives the programmer more choices, depending on their specific use case.
Exceptions and Result/Options/ErrorCodes are actually 2 competing camps: http://yosefk.com/blog/error-codes-vs-exceptions-critical-code-vs-typical-code.html That actually shine in different scenarios: - Error Codes/Result is for pessimistc code. - Exceptions is for optimistic code. You actually want both. Also, is very hard to thread a bunch of results/error codes (if you see how a future library work, you see how akward is to extend the idea to all the language!). Think in a function that could return dozen of different failures. Not always the *inmediate* caller is the one best suited to handle all or most of them. For example, a stack overflow or a memory error. Or a network call that fail inside a transactional db operation (where make sense to keep the handling of data separated to the connection to the remote db). In the case of Erlang it have the concept of "supervisors" where different "process" have different policies in how handle a sub-process failing. This show that not all the error are equal, neither how handle them. 
Is there a specific argument made in that article that is particularly convincing to you? I can't say I agree with it but I'd rather discuss the best argument than a lower hanging fruit.
It feels like a bit of a straw man to be honest. For example, [here](https://cdn-images-1.medium.com/max/2000/1*ySYUKlXaxyE_qn81CxzDvA.png) is a similar example from a [post](https://hackernoon.com/rewriting-the-thoughtworks-tech-radar-in-elm-41a4e8244a13) I write. `Maybe` is Elm's `Option`. If I can match a value in a deep record, then use it, otherwise return a single error value that the caller is forced to handle. Imagine the same thing in F#. `List.head` can throw. The return value for that can be null and throw an exception when getting that record's `submatches`. Its submatches can be empty and throw again on the second `List.head`. If the argument is Results/Options lend themselves towards bad OO patterns with a bunch of files everywhere I think that analogy can be dismissed. &gt; For me, if it's not helping the business or improving developer productivity I'd be happy to follow you down this thread if that's the meat of your argument.
First, `List.tryFind` has the behavior you want. The existence of two functions for this is lifted [straight from OCaml](https://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html#1_Listsearching). Another thing to note is that Result has only been in the standard library since F# 4.0, so it wasn't a viable alternative to exceptions until then. But most importantly, a big part of F# is its ability to interact very well with the rest of .NET; it's even the original reason for its existence, since it was originally a reimplementation OCaml for .NET (though it has diverted significantly since then). Interacting with .NET means, among many other things, being able to handle exceptions thrown by .NET libraries, as well as throwing exceptions because that's the kind of behavior expected by .NET consumers of your F# code. Now, within a purely F# code base, you'll still see exceptions used, but significantly less frequently than eg in C#, because in a number of cases Option or Result are indeed better solutions.
Personally I never use Exceptions for control flow. It not just the poor performance, its also that it break purity. I find Result with applicative etc much nicer. I don't see the nesting problem people have described. I heavily use types like list1, map1 (non-empty) and precise function signatures so they are total functions. This eliminates the next orders of exceptions after null. I will use Exceptions to fail fast a sub system but that's all.
I think it's probably useful to split out the two different topics that we're talking about. On the one hand we have *pure functions* that call each other. If you know what I mean by railway programming I wonder if you'll agree `Result` and `Option` work pretty well when functions are free of side-effects. Then we have functions that imperatively produce *side effects* which is the example I believe you are describing. In that example I'd agree that Results and Options can get cumbersome but at that point it's imperative, stateful programming anyway (which I understand F# is multi-paradigm and allows). So we might have agreement there. I'm coming from Elm so in terms of productivity if an Elm program compiles it will not crash at runtime because there are no unchecked exceptions. I'm not hunting down strange runtime errors where I have to reproduce some weird state caused by complicated imperative interactions (this sounds familiar to OOP). I don't get the same productivity out of F# because I do have to hunt down unchecked exceptions and retroactively handle errors.
Really poor choice in name
I think we are largely in agreement. I'm a big fan of railway oriented programming, especially for the canonical validation case. I just think having both APIs that return exceptions and APIs that return Option/Result types is best for developer productivity. Here's another example where having both APIs available is nice: imagine you are playing around in a REPL with a local CSV file. For exploring the data, maybe you don't care about handing edge cases. You might not care about wrapping things up properly, you just want to know if it fails. Later on, if you want to change the functions you are using to make the code more robust, you can do that.
I like the idea, I'm going to try it out sometime. The name isn't a problem, who cares what internal 3rd party libraries are called? It's not like management are going to see them. 
Errors that throw exceptions should be EXCEPTIONAL. Stuff you can't predict. Results you can predict, such as a HTTP 500 or a parsing failure, should be a result.
&gt; I am not sure that Option and Result were in the original F#. Option might have been, but Result definitely was not.
Please consider a literal name policy like the one Elm is using (very successfully, see https://discourse.elm-lang.org/t/literal-names-policy-i-e-how-to-name-packages/242 ). Your package could be something like `Vivaino.DataMapper` instead of `Fapper`.
One reason you would want to use exceptions instead of wrapper types would be to minimise allocations. Every time you map over or do other functional operations on options or results, you allocate new wrapper values and probably put pressure on the GC. Exceptions are an alternative control flow pathway that minimises that.
Have you tried measuring whether the performance difference is large enough to make a difference?
I have not. However, I don't think I have made any claims about performance, only memory pressure.
The problem is googling for it. You effectively can't. 
Have you looked at the implementation? With lists the implementation is way more straightforward. Also, there are other solutions that use query builders (e.g. SqlProvider)
Yawn... so boring and without any humor policy 
Good points, I will add these to FAQ later (differences to rezoom.sql and why not use query providers). But here's my use case: In my unpublished apps I'm actually building my queries like you build suave.html and giraffe viewmodel views. I compose parts of the query in functions, and then splat them on the main query. I'm not sure how well this would work with a stricter system. You avoid typos on table names (see Table "Emp" declarations). If you wanted to avoid that on column names you would need to know the structure of the db, and then things get way fatter. With Rezoom.SQL you are back to writing your queries as strings, not composing them. 
It will crash if `KeyNotFoundException` is not handled somewhere up the stack.
I would be interested, but this name is too stupid.
My understanding is that Microsoft is "officially" moving towards UWP over WPF, though I don't think adoption has followed suit. That being said, you might be able to find some templates online (look for Visual F# under Online &gt; Templates when you create a new project. Here are some libraries that might be of interest: * [FsXaml](https://github.com/fsprojects/FsXaml) - Tools for working with XAML in F# * [Elmish.WPF](https://github.com/Prolucid/Elmish.WPF) - A more functional alternative to the MVVM architecture following Elm if you are interested
I added a paragraph in FAQ that maybe addresses what you were thinking: https://github.com/vivainio/Fapper/blob/master/README.md#why-not-use-xxx-or-yyy-instead
Yep, it will. But at least it is the programmers decision. For instance, you might have some code further up that guarantees the object you are looking for is going to be in the list (maybe because it explicitly adds it), and so you can be sure that your List.find function will always find an item and not throw an exception. The root problem is that you cannot express the fact that the item you want is guaranteed to be in the list via the F# type system. This is something that a dependently-typed language might be able to help solve.
I've used Cake in my latest projects but I'll try nuke.build in the next one
I had the same thoughts as you. From a personal perspective I would go with Fake because I like it better but I have to think about the team and the others as you also point out. Not everybody want to learn F#. Thank you for sharing your experience an thoughts. 
Thanks for the input about your experience with Fake . It sounds reasonable that Fake is more stable and mature because of a more active comunity around it. Most c#ers probably stick with Msbuild until they are forced in to cake.
The humour and excitement should hopefully be covered by your docs ... not when people are trying to evaluate your package to figure out if it does what they need.
I am speculating ofc but as many said F# is running on .NET and .NET supports exceptions. In addition, exceptions has a nice feature over Option/Result. They capture the stack trace. While I tend to avoid exceptions I still think they are ok for "catastrophic" errors that basically should crash the process/thread
I have recently switched a team over to cake and I have to say I liked it. I was able to get up and running within minutes. It provides a decent set of primitives and I love that if something is missing or to extract common behavior I can just write C#. C# is also a very strong reason in favor of cake as I can point any dev, including juniors, to the build file and they can add enhancements easily. Cake also has a large repo of add-ins: https://cakebuild.net/addins/, although I’m sure fake’s is the same. I will try using fake for my personal projects, but that’s because I do want to learn something new. For an existing team I wouldn’t hesitate to use something they’re comfortable with and that’s where cake comes in strong.
I am not recommending to use but recommending to consider one of PowerShell build automation tools. The language homogeneity is decent, PowerShell in some ways is similar to C# and the whole .NET is available. Candidates: - [Invoke-Build](https://github.com/nightroman/Invoke-Build) - [psake](https://github.com/psake/psake) Invoke-Build is less popular than psake but it is easier to use and more powerful and mature. I am the author of Invoke-Build, consider me biased, make your own research and decisions. Unlike CAKE and FAKE, these tools are rather task runners than true build systems. They do not include "build batteries", you have to call build tools yourself. But they include the power of PowerShell, and depending on tasks this may be more important. 
Nothing.
Then start something! :-)
WebSharper for .NET Core! We're almost there, hoping to put out a beta today.
Great news!
Working on a pipeline to move cryptocurreny prices into a Elastic search cluster. At home though. 
Sounds neat but I had a question specially on clusters.. do you run it on the cloud ($$ expensive?) or on VMs (slow performance)
Trying to work out how to set up a project for Fable-Elmish + Giraffe. I can't find any templates for this combo.
&gt; I like the idea, I'm going to try it out sometime. 
Trying to find a good functional workflow for game code in Unity - which turns out to be quite tricky since Unity requires you to break with some of the best practices that F# encourages and my one year old is totally fascinated with my keyboard.
What exactly is the communication between the two threads? I'm probably being naive here, but why can't the engine thread just PostAndReply() and the processing thread **immediately** reply "I don't have anything for you, try again next frame" or "Here's what you want". &gt;it looks like the intended way to use a MailboxProcessor is to have the main thread send messages to a function that is run in a thread pool I only have limited experience with MailboxProcessor and multithreading in general, but my usage is that many tasks Post to it and many tasks wait with PostAndReply. Every request I receive on IO is immediately used to either create a task which might PostAndReply, or to create a task which calls Post (and fulfills an earlier request).
[removed]
FAKE. We have been using a good amount of Cake where I work, but it tends to occasionally break down and cause a ton of troubles (and no, we dont even use any crazy parts either). It's gotten to the point where it often takes shorter time to rewrite the entire Cake script in Fake than to actually identify what is causing Cake to fail. So currently we are rewriting the cake scripts to fake when they start acting up (and they tend to do that occasionally...without any warning or any changes), and using Fake for most new projects. My colleagues dont know much F# (but many want to learn) but you can write fake scripts that are pretty easy to read and modify so no one has really complained. The fake scripts that we are running has so far been completely problem-free. Also, if you want to be using Paket (which I highly recommend even for C# projects) then you should _not_ be using Cake. Even with the paket addin, Cake is highly integrated with nuget and throws a hissy fit if you try to use paket and do anything more complicated than just building....
what is the performance difference and what is the directionality? i.e., which is faster?
thanks! that would have been my guess due to it being the new hotness, but i wasn't for sure.
Try out SAFE template, it has flag for using Giraffe instead of Suave
The engine is running on one thread that loops over all objects in the game and calls their update methods, so changing what's displayed means changing the mutable state of those objects. This may of course not happen while the state is read, so if the gameplay is run on a secondary thread those changes must be applied either using locks or using a message queue (unless there's another option I haven't heard of yet). You are right that the solution I am going for does involve the engine thread polling for changes, I just don't want it to poll by sending messages back and forth. Currently I am doing it like this: This is the core loop of the gameplay thread: let gameloop (engineMailbox : MailboxProcessor&lt;GameState&gt;) (inbox:MailboxProcessor&lt;Turn&gt;) = let rec loop state = async { let! msg = inbox.Receive() return! state |&gt; move msg |&gt; display engineMailbox |&gt; loop } loop {turns = []} The engine thread creates two mailbox processors, one of which is never started but passed as an argument to the processing function of the second one. let engineMailbox = new MailboxProcessor&lt;GameState&gt;(fun _ -&gt; async{return ()}) let gameMailbox = MailboxProcessor.Start(TicTacToe.gameloop engineMailbox) And this is how the engine thread checks for messages: let rec getCurrentGameState () = let nextMessage = Async.RunSynchronously (engineMailbox.Receive()) if engineMailbox.CurrentQueueLength &gt; 0 then getCurrentGameState() else nextMessage let Update () = if (engineMailbox.CurrentQueueLength &gt; 0) then getCurrentGameState() |&gt; updateBoard |&gt; updateActivePlayer |&gt; ignore So now the engine thread can send commands to the gameplay thread by using gameMailbox.Post and the gameplay thread can send updates to the engine thread by using gameMailbox.Post. This works and it's exactly what I want - if only it didn't seem so much like a hack to create a MailboxProcessor with a dummy processing function that is never started. What I find especially disturbing is that apparently there is no Mailbox class. I mean if it is possible to use the class as a Mailbox without using the processing function, then it seems quite obvious that not splitting the MailboxProcessor into a Processor class that has an instance of a Mailbox class means breaking the single responsibility principle.
Huh, funnily enough, internally they do use a Mailbox. https://github.com/fsharp/fsharp/blob/master/src/fsharp/FSharp.Core/control.fs#L1847 So, all receive does is: // look in the inbox first async { match x.receiveFromInbox() with | None -&gt; return! processFirstArrival() | Some res -&gt; return res } then wait for a new message if there was nothing there (forever unless you give a timeout). Why not just have two MailboxProcessors? Do you think the overhead of: type msg = | Post of GameState | Read of AsyncReplyChannel&lt;GameState list&gt; let engineMailbox = MailboxProcessor.Start(fun agent -&gt; let rec loop queue = let msg = agent.Receive() match msg with | Post s -&gt; loop s::queue | Read r -&gt; r.Reply(queue) loop [] loop []) let getCurrentGameState() = return! engineMailbox.PostAndReply(msg.Read) let Update () = getCurrentGameState() |&gt; List.iter ( updateBoard |&gt; updateActivePlayer ) Is that high? 
Pair programming at its best! :-)
Thanks Krzysztof. Is there any way to discover these options via the tooling? For anyone else interested, look at the "Template options" section here: https://github.com/SAFE-Stack/SAFE-template
Building web framework 
Doesn't .net heavily rely on exceptions? I find that really ugly in C# that you need to wrap basically everything with try catch. I'm just wondering =) thank you
reading about fsharp. I'm fascinated by the language but I don't know how to start. I feel even my fsharp code will look extremely OOPish and that kind of puts me off :D
Even without F#, this is a simple intro to kubernetes. Something i've been looking for. thanks
Update: Since the mailbox implementation uses locks as well I ended up using a simple list that's made thread-safe with a lock. That is until I found out about Async.StartImmediate which allows me to run the coroutine on the main thread making thread-safety unnecessary (in cases where running the coroutine on the main thread is feasible in terms of performance).
I would try to get msbuild directly from mono - they recently updated it (F# broke on the ubuntu sources directly after the release of mono 5.8.0.108 because msbuild was missing but they fixed it the day after - maybe you have similar issues with stuff expecting the new msbuild)
Same - first time project with both Unity and F#. Spent a day trying to understand why the native F# Set collection was failing silently in a Unity project but not a console app. In terms of design approach, I'm planning to use Unity only for display - for a 2D Tilemap based game - and keep all game logic in a separate DLL. This means I'm (re)inventing rather than learning the Unity way, but on the other hand free to iterate as much as I want on underlying architecture. 
Discord is faster at least
I wouldn't say rely. There are areas like File IO that use exceptions but I just wrap them in a more sensible API. If you manage possible exceptions at the boundaries (UI, IO, DB, Web, Parsing etc), and make sure you have a sensible policy as I described above, then I find I rarely think about exceptions in F# code.
I am unable to build msbuild from Mono's repository (master branch, HEAD) either. The build breaks because of a non-existent path to 'init-tools.sh' somewhere deep inside of the file system structure of the repo. Next, I might try .NET Core to build F
How are you familiar with functional programming? 
Wonder if there will be F# support from scratch?
&gt; It's also mildly amusing, for the time being. Uhm.
yep! There's nothing language-specific about this proposal, you just ship a xml manifest like that post describes and you're good to go. There are already PRs out for Fake and Paket for example to make them compatible with this proposal.
&gt; There are already PRs out for Fake and Paket for example to make them compatible with this proposal. That is excellent 
Nice, thanks for sharing. For now I just have a stub script attached to a GameObject which passes control to my FSharp code every Update call. Will tackle async one of these days. On the native Set problem, I think it's some sort of strange bug in the comparer being used by Core for a simple custom structure record. I have a sample repo and question open on StackOverflow: https://stackoverflow.com/questions/48604315/f-and-unity-set-contains-fails-on-simple-structural-equality-test
To add on to this a little bit, pretty much any time you see a TypeInitializationException it means that something has gone wrong in a static constructor somewhere. In F# what that means is that you should look for places in the module where values are being initialized when the type is loaded.
thank you very much. It works now.
thank you very much. Why cannot f# deal with that? Whenever I do: try { new Foo() } catch (...) {} in c# then it does work. Where can I read more about that? Thank you
It can't. That's a minimal repro what it would be in C#, when the exception is in the module initialization: using System; public class Program { static Program() { throw new Exception(); } public static void Main(){ try { Program p = new Program(); } catch (Exception e){ System.Console.Write("Error:" + e.Message); } } }
ok got it. thank you. So can I assume that f# tries to initialize everything except for 'units' (which are declared with the "()") and since units are not predictable they can have side effects. If anything can have side effects it should be declared as a unit aka ()? I just try to find a rule of thumb for me :)
It's not about whether or not it takes a "unit" value, it's about whether or not it is a function. If you hover over `a` in `let a = 1`, you'll see `val a : int`. It's a value which is eagerly evaluated. If you write it `let a () = 1` and hover over `a`, you'll see the signature is `unit -&gt; int`. It's a function now, the contents of which are not eagerly evaluated. You could choose anything to make it a function (i.e. `let a (notUsedVariable:int) = 1` which would change the signature of `a` to `int-&gt;int`).
awesome replies. I got it now, thank you very much =) and sorry for my stupid questions.
The more I read about Fable, the more I'm incline to try it out over Elm. One note, I would drop the Font Ligatures just to make it slightly more clear for people that aren't used to seeing those.
Ah yes I like the ligatures but it's true that they can confuse people that never used them. Maybe I should disable them for such articles. Thanks.
Looking forward to the follow-up posts
Book author here. :-) &gt; I am wondering if learning F# through this book is a good idea. My books are designed for people who are coming from a technical but non-programming background like scientists and engineers. I have also published a more recent related book called [Visual F# 2010 for Technical Computing](http://www.ffconsultancy.com/products/fsharp_for_technical_computing/). &gt; I do not see myself working with the .NET framework anytime soon in the future. F# and my books on it are closely tied to .NET. If you're interested in similar stuff that isn't .NET related then I would suggest [OCaml for Scientists](http://www.ffconsultancy.com/products/ocaml_for_scientists/index.html) instead. 
&gt; EDIT: Jon, if you read this, Of course I am. :-) &gt; how about an updated and revised edition of "F# for Scientists" F# for Scientists was written in 2006 so it covers very early F#. I wrote a related book called [Visual F# 2010 for Technical Computing](http://www.ffconsultancy.com/products/fsharp_for_technical_computing/) in 2010 that covers modern F# (but different technologies). &gt; or even a book based on what you've published on "The F#.NET Journal" site (an absolute gold mine of advanced F# material). There's ~1,000 pages of content in the F# Journal so it could be several books. :-) &gt; It would fill a gap in the F# book market which at the moment lacks a good book about truly advanced data structures and algorithms. I don't think there's much demand for advanced data structures in F# outside academia. Algorithms is very interesting. However, these days I'm doing other things. Amongst other things I'm actually working on my own language as a replacement for F#. &gt; To fill that gap I've had to buy books using ML (e.g. the excellent "ML for the Working Programmer"), OCaml and Haskell, but it would be wonderful to have a F# book in that space. F# is quite unusual in that respect because it doesn't have any of the usual abstraction mechanisms like a higher-order module system or type classes. F# has .NET-style objects but they're extremely limited in what they can express when it comes to data structures. The main thing I'd personally like to see is more coverage of solving modern problems. For example, all of the legacy F# content is about things like building Windows-only GUI apps but there is nothing about building web apps or even mobile apps. To give a concrete example, as I'm now managing a team of analysts at a market research company I used F# to write a script that calculates lots of business analytics. I used type providers to access the SQL database and F# for Visualization to plot the results. It worked great to start with. As I added more the type providers started to creak. Once I hit 5 minute compile times for 100 lines of code I had to ditch the type providers and write the DB layer by hand which was, with the benefit of hindsight, really easy. Then I started showing other people the output and they all wanted access to it and they want it to be a little more interactive so they can tune the analyses. I tried a WPF app first which was easy but didn't solve the business problem because they want it on phones and tablets. CTO advised me to turn it into a web app. That was months ago. I've tried several different libraries. Turns out the support for web programming in F# is absolutely terrible. The libraries are complete junk. Nothing works properly. My analytics system has been down for the whole of January due to bugs in XPlot. I'm now effectively rewriting all of those libraries myself from scratch (HTTP server in F# sending JSON to a client written in JS that will use Google charts) and wondering why I am using F# for this. Coming from an OCaml background, the motivation for using F# was always wonderful interop. Now that there is no demand for anything F# can interop with, I think there is little reason to use F#. Also, the problem isn't just me. I've sunk close to £200k on F# developers over the past couple of years and have virtually no working software to show for it. We paid an external consultancy company to build an Excel productivity tool for in-house use that has never worked and never been deployed. We paid another external consultant to deploy a search engine. Just to clarify, I did all of the clever PDF/PPT/Word file processing stuff and the NLP myself and gave them a working search engine so they just needed to give it a web UI and the project was over budget and over deadline. I hired an in-house world-class F# expert to write our mobile app in F# using Xamarin and, two years later, we've shipped a tiny fraction of the features I wanted and what little we have is unusably buggy. I tried to demo our mobile app to someone yesterday and it just crashed immediately. Suffice to say, I'm putting almost zero effort into F# these days. 
&gt; I think vscode+ionide is smoother than most other functional languages. You're joking. VS2015 was good but is no longer available. VSCode+Ionide is a complete reboot currently far behind other functional languages. 
Sorry but I tried Rider and it sucks too. The current F# tool stack is the worst it has been since before F#'s official release in 2010. Really really poor. Cannot recommend. 
They aren't stupid questions at all; they're *ignorant* questions, which is nothing to be ashamed of. Being ignorant just means you don't know something yet, and asking questions is the best way to cure your ignorance. The only "stupid" question is the one you should have asked to cure your ignorance, but *didn't* ask, so you remain ignorant. :-)
Sorry, but ignorant doesn't mean not knowing something, it means not wanting to know something (as in to ignore it). 😉
Sorry to be nitpicking, but both values are evaluated equally eagerly, it's just that one contains a function while the other contains a value. What's confusing for beginners is the difference between declarative and imperative code. In C# the code that is not inside a function is declarative (e.g. class declarations, namespaces, member declarations etc.) while in F# it's imperative. The difference is that declarative code declares something to be true while imperative code gives the command to do something now. So in C# class CS { int i = 3; } means that at some point when or if CS is instantiated there will be an integer called 'i' with the initial value of 3. In F# on the other hand this code module FS = let i = 3 means that at that point when this code is run i should be bound to the value 3. That's why this works: class CS { void test() {Console.WriteLine(i);} int i = 3; } while this doesn't: module FS = do printfn "i is %A" i let i = 3 And it's also why the keywords in F# are named as commands ('open ...' instead of 'using ...', 'let ...' instead of 'var ...').
Sorry but you are ignorant of what ignorant means.
Not wanting to know something is what's known as "invincible ignorance", where the ignorant person just doesn't care to listen to your arguments, and nothing you say, no matter how true it is or how good your evidence, will persuade him. Which, in my book, comes close enough to stupidity as to make no difference. :-) Which is why, for me, calling someone stupid is an insult, while calling them ignorant is no insult at all.
:D
Looks like Fable has made some improvements in the last several months. Maybe it's time I give it another try
Well one of the strengths of Giraffe is that it sits on top of ASP.NET Core, which already has web socket support: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/websockets This means you can already develop web sockets in F# alongside Giraffe. The PR aims at adding a higher level API on top of the plain WebSocket implementation in ASP.NET Core which makes it more FSharpy, but it is not like the web socket feature is missing at the moment.
It's the record creation syntax There is somewhere a record defined like that : type Document = { Title: string; Link: string; Description: string } And the code create an instance of this immutable record
I agree with /u/virtualblackfox, though it took me a few minutes to work out. It's confusing because: a) the type definition is elsewhere (it's actually the *type RssItem* bit just above) b) *doc.DocumentElement* is a property so doesn't have any brackets when it's accessed in the *let item* bit. c) The bit after that which looks a bit like it's type initialization for the let item binding, (i.e. the bit in curly brackets) is actually a new line, instantiating a record as virtualblackfox says.
Noice! Gonna give it a try.
If this is still confusing after my and virtualblackfox's explanations, reply here and I'll post a clarified version of the code.
No, this is clear now. Thanks for your help!
An IoT platform for LPWAN (Low Power Wide Area Network - such as SigFox and LoRaWAN) applications. It includes MQTT, MQTT-SN, Postgres via EF Core with jsonb support, REST APIs via Suave, encryption and authentication via libsodium... and many more. https://github.com/kiotlog Check it out!
On the scale 1-10, I'd say about 6 or 7.
I haven't tried their serverless offerings, but my backup sync program that runs every night uploads and deletes files from storage. (It runs on a Digital Ocean Linux VM.)
How do you like Digital Ocean?
It's great. I have two VMs (a 4GB and 2GB), and with their all-SSD storage, disk access is lightning fast. They have "cloud firewalls" you can set up too, so that they block the stuff you'd normally ignore with ufw/iptables before it even gets to your VM. I host web and mail with them, and store my backups in Azure ("cool" level blob storage). DO didn't have that as an option, but even now, they don't beat Azure's rate for storage. I host podcast media out of Azure storage too. :) My Azure bill is &lt; $4/mo, and DO is $60 - although, if I were to create new VMs, it would be even less. (They recently altered their pricing structure, but it only applies to new VMs.) 
It is not a F# problem for sure. This is how it works with new products in Azure. You are beta tester :D Few examples I've encountered recently: - Uploading file to DataLake with &gt;30Mb gives you 404 without any meaningful reason. It happens because between you and Hadoop WebHDFS there is IIS with DEFAULT config which prevents octetstreams more than 30Mb. WTF - Azure Functions could work up to 10 minutes on AppPlan, but because runtime V2 is being hosted on AspNetCore which have DEFAULT 2 minutes response timeout, you will get 502 response from proxy AspNetCore, but your function will run successfully. WTF
I currently have some HTTP Trigger functions that return a 404... when running from the portal. Makes no sense
404 means that runtime couldn't bind your request to function entry point. Try this: 1) Check function logstream. When you invoke it there could be errors of type loading. It happens everytime when you use fresh versions of nuget (for me it was AspNetCore.Abstractions 2.0.2, downgrading to 2.0.1 solved the issue) 2) Double check function.json so every function parameter has binding. Also double check your request itself.
Ah you know what, I am guessing this is a problem in my function.json: `"methods": [],` This is generated from F# attributes in my function dll, so must be another bug I've found :)
Giraffe is now [1.0.0.](https://github.com/giraffe-fsharp/Giraffe/releases) :-)
The statuses are "TimedOut" and no exceptions are ever thrown. However, I tried the some program on windows dotnet core and it doesn't happen.
Ah - that may be the problem. What OS are you running it on where it fails? *(It shouldn't be that way, but you may be on to something.)*
The Linux ping command doesn't do 4-and-done like Windows does. I wonder if specifying a timeout may help ([overload](https://docs.microsoft.com/en-us/dotnet/api/system.net.networkinformation.ping.sendpingasync?view=netstandard-2.0#System_Net_NetworkInformation_Ping_SendPingAsync_System_String_System_Int32_)). The Ping class also implements IDisposable, so changing "let" to "use" on line 45 may help as well. It would be odd for that to be the cause, but depending on the OS-level implementation, it may.
you did not say exactly what is not working but I think it will most likely be the policies for running .net from portable devices/intranet if so you probably have to talk with the IT of the computer you are using
If you can afford it, consider spinning up a VM in the cloud. You can access it from anywhere, provided they allow the RDP port through their firewall.
I was hoping to avoid this, but it may be the simplest option. Thanks.
I find single case DUs overblown, since they lead to more code to do the same tasks, reduce the singal to noise ratio of code, don't improve the structure of code, and all they achieve really is enforcing good naming. Some people (not this blog) are promoting them as an advantage of functional programming, but they are not an advantage, and are not functional programming either (since you can do the same in any OO language).
I was going to try it out, but got this error: https://github.com/giraffe-fsharp/giraffe-template/issues/11
Ahh no luck, still the same results with specifying a timeout and changing the let to a use. I guess I'll just take this a loss. Thanks for the help though :)
I appreciate this podcast. Thank you to the people involved in producing it!
Thank you! :) 
the libraries should be no big issue - just copy the dll there and redeploy them locally I'm not sure what dependencies fsc needs to run - but it will probably work as is (as a local copy of the .exe) - maybe just try it and see if it complaints about any missing stuff another option of course is to try to compile F# on the spot and then use the build output (should have anything you need included) 
I also like it. F# needs things like this if it is to expand its user base.
... and a working IDE.
What doesn't work for you?
Like right now F# is totally broken in VS2017? They lost "Move file up/down" functionality in .NET Standard and .NET Core F# projects months ago. Since file order matters a lot in F# this makes using F# pretty much impossible right. Besides that... try renaming something in a mixed F# / C# solution. You'll end up with lots of broken code. Or "Find all references" in mixed F# / C# solutions.. or "Go to definition" which decompiles code instead of just going to the source.. or "Go to implementation" on an F# interface which just claims that no implementation exists if it's implemented in C#. That crap hasn't improved for years but needs to be fixed first before any sane person's going to touch F#. (Note I love F# and use it a lot, but I stopped recommending it to colleagues lately and even converted some of my own projects back to C# :/ )
Please don't, people who've been using it all along would like it to remain the secret weapon ;)
&gt; They lost "Move file up/down" functionality in .NET Standard and .NET Core F# projects months ago. This was never lost - .NET Core and .NET Standard projects are in a new project system altogether, and [it's always been on the roadmap for the 15.6 release](https://blogs.msdn.microsoft.com/dotnet/2017/11/15/announcing-f-support-for-net-core-and-net-standard-projects-in-visual-studio/). You can try it all out with the latest preview [as per the release notes](https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-preview-relnotes#fsharp-p4). &gt; Also the file order displayed in the solution explorer does not match the file order in the fsproj file. It does. As stated in the linked blog post, it respects ordering and displays it unless you modify via the project file and _do not_ reload the solution. This is fixed for VS 15.6 in addition to adding all of the UI gestures and folder support with ordering semantics. &gt; That crap hasn't improved for years but needs to be fixed first before any sane person's going to touch F#. The rest of your comment refers to cross-language IDE tooling being the pain point. Are there F# tooling-specific issues that trouble you, or does it primarily reside in features like Rename and Find all References not working across C# &lt;&lt;--&gt;&gt; F# boundaries?
Honestly, I might not try it again. In the time it took me to figure out WTF was up with Fable's tooling, I learned Elm and I may not ever leave it.
Sounds good!
&gt; This was never lost - .NET Core and .NET Standard projects are in a new project system altogether, and it's always been on the roadmap for the 15.6 release. Well if you create a new F# project in VS2017 ("Other Languages" -&gt; "Visual F#") you can choose between "Console App (.NET Core)" or "Class Library (.NET Standard)". Neither of these project types are usable since months. I know things are supposed to improve in 15.6, but they shouldn't ever have been released that way in the first place. &gt; It does. As stated in the linked blog post, it respects ordering and displays it unless you modify via the project file and do not reload the solution. Can't confirm.. when I create a new F# "Class Library (.NET Standard)" project it contains Library.fs. When I add Foo.fs the solution explorer shows Library.fs followed by Foo.fs. But when I open the fsproj file I see Foo.fs followed by Library.fs. I'd say that's broken and it is since a long time. Make Foo.fs use something from Library.fs? Won't compile... right now one has to reload the solution every time a file is added and fix the file order in by editing the fsproj file.. :p &gt; Are there F# tooling-specific issues that trouble you, or does it primarily reside in features like Rename and Find all References not working across C# &lt;&lt;--&gt;&gt; F# boundaries? F# tooling is usable in pure F# solutions. But most people have lots of code written in C# and I won't be able to convince anyone to try F# if everything breaks across C# &lt;-&gt; F# boundaries. 
&gt; Neither of these project types are usable since months. Can you clarify what you mean by not being usable? Is it the lack of UI for file ordering, or are there other issues? &gt; The old F# .NET Framework project types don't even seem to be included when the ".NET Desktop development" workload is installed. What you're referring to is an issue where the component rename set it back to the original state (unselected by default) rather than respecting the previous setting. No way around that bug. Sucks (sorry about that :(). F# has never been included by default with the .NET Desktop workload (or ASP.NET workload), which is a shame because they're the most popular. .NET Core offered an opportunity to get F# on everyone's box. Pre-15.5: Any installation of F# required you to check a checkbox (.NET Desktop, ASP.NET), or know to select the right workload (Xamarin, Data Science) Post-15.5: Any installation where .NET Core is required will include F# _except_ desktop templates. Desktop support now replaces F# wherever it was optional in previous versions. This change was [documented in the release notes](https://docs.microsoft.com/en-us/visualstudio/releasenotes/vs2017-relnotes#a-idfsharppreview2-a-changes-in-f-setup). &gt; Can't confirm.. when I create a new F# "Class Library (.NET Standard)" project it contains Library.fs. When I add Foo.fs the solution explorer shows Library.fs followed by Foo.fs. But when I open the fsproj file I see Foo.fs followed by Library.fs. I'd say that's broken and it is since a long time. You're referring to something else: adding a new project via the project node and the file being added to the end of the list of files in the project file. This behavior has always existed for F# projects of any flavor. We've since changed this for .NET Core SDK-based projects in 15.6 to add to the beginning of the list (or the beginning of a set of files within a folder if you added from a folder node) because of what you've mentioned. What I was referring to earlier is that if you load a .NET Core/.NET Standard solution with some ordering of files, that ordering is respected in VS 15.5.x. I've just verified this with three open source F# solutions on my machine. After changing the ordering in the project file, I must reload the project for the *Solution Explorer UI* to display those changes. This is what I mentioned in the previously-linked blog post which announced the initial support for .NET Core SDK-based projects in F#. &gt; But most people have lots of code written in C# and I won't be able to convince anyone to try F# if everything breaks across C# &lt;-&gt; F# boundaries. When you say break, are you referring to something *breaking* your code, an expectation that features work across all languages (even if there is no modification of code, e.g. a Find all References), or all of the above? I'm interested in where the impression generally falls short. Is this particular solution very interop-heavy and under enough change such that cross-language IDE features are a necessity to keep the project moving along? Or is this more of a, "C# developers expect XYZ available" sort of problem? Or a mix?
See reply there! It's a `dotnet new` regression bug.
Getting back into F# to have a go at tackling an arc consistency algorithm with a constraint satisfaction problem-forklift truck configuration :). (Yep I think that sounds technical enough :P ).
I prefer the way it worked where force update in Visual Studio 2015 meant we I see the table change if I recompiled immediately. Just feels now like its less functionality. We switched to the entity framework because we have too many table changes among the team.
Correct. We moved to Visual Studio 2017 with Sql Sever 2017 and when a schema change is made such as adding a column, I recompile but the update is not reflected on the ServiceType. 
I just wanted to weigh in in favour of SCDUs. It's definitely the case that they involve some overhead, and one has to pick and choose when to use them. As u/eliquy has said, they do help achieve "making illegal state unrepresentable". I think the reason people promote them as an advantage of FP is that declaring and consuming them requires good implementations of DUs and pattern matching, which tend to be FP, and notably F#, features. 
Could you add an issue with potentially a reproduction to the repo on GitHub? That would help focus any discussion. I know that the TP code hasn't changed in a while, so my guess is that the invalidation mechanism isn't being triggered correctly on VS 2017 for some reason.
I hope to see lots of folks there this year :)
If you don't need to produce executables, https://dotnetfiddle.net/ supports F#.
You need to write a startup scrip. See here: https://unix.stackexchange.com/questions/56957/how-to-start-an-application-automatically-on-boot 
Should I change this line: touch /var/lock/blah to: mono /path/myapp.exe
If this is something you're running on your personal machine you can just use @root in cron. $ crontab -e then add a line `@reboot /path/to/mono /path/myapp.exe` 
Thanks for the info. It'll be useful for my personal projects. However, this particular project is for production. So ad3mar's suggestion is the best route to take. I'm just not sure about one line.
No. You should do touch /var/lock/myapp Later in the script under the start section you would invoke your program. You could then capture the pid and use it later under the stop section to kill the program. It is a somewhat elaborated you will need to investigate a little bit more. 
I'm probably not the person that should be working on something that complex :) At the moment I do not have anytime with current projects. But if I do get some time freed up I will look pull it down and see if I can identify where a suggesting change/changes should occur. But at this point I would not want to try and take on that responsibility or obligation. 
Note that that question and answer are several years old, so they don't mention systemd. Debian 9's default startup system is now systemd, not init; it can use init scripts for backwards compatibility, but the native way to have systemd control your app and start it on boot (and, optionally, restart it if it crashes) is to create a systemd service file. I don't have enough experience myself to tell you how to do that, but you could probably copy this one since it's also a Mono app: https://github.com/Jackett/Jackett/wiki/systemd-service Or you could look at this one: https://github.com/Radarr/Radarr/wiki/Autostart-on-Linux Documentation of all(?) the things you can do with a systemd service file: https://www.freedesktop.org/software/systemd/man/systemd.service.html (or run `man systemd.service` on your Debian box)
I'm not sure if this helps but I wrote a full tutorial a while ago on running ASP.NET MVC on Linux. It covers the startup process ... https://coderscoffeehouse.com/tech/2016/01/19/aspnet-linux-setup.html
Thank you. I'm sure it'll be handy in the future.
This worked with some slight modifications. For the benefit of others who might be interested. Here's the code and instructions. File contents: [Unit] Description=myapp Daemon After=network.target [Service] User=user ExecStart=/usr/bin/mono --debug /root/project/myproject/bin/Debug/net461/myapp.exe --NoRestart Restart=always RestartSec=2 Type=simple TimeoutStopSec=5 [Install] WantedBy=multi-user.target Instructions * Change "myapp" to your app's name. * Change the path to your app. * Save the file and name it "myapp.service". * Upload the above file to /etc/systemd/system/ * Reload systemd: systemctl daemon-reload * Enable the service: systemctl enable myapp.service * Start the service: systemctl start myapp.service * You can check the status: systemctl status myapp * You can start/stop/restart the service: systemctl stop myapp Thank you for helping me solve this problem.
This may not be helpful to you, but here's the approach I'm taking to developing multi-threaded Unity game logic in FSharp. I have a simple Entity-Component-System architecture. On top of that, I have a simple Event Store. (Both are concepts you can research if you're not familiar with the terms.) Most relevant to your case is probably the Event Store approach. State transitions in the game logic are handled by adding transitions to a queue. The queue is held by an Agent (aka MailboxProcessor), so it can handle incoming transitions from many other threads at once without locking. The key integration point with Unity is the Update method. I have a single GameObject that passes Update control to the Event Store transition queue. Every Update, it empties its queue, processing the transitions that have taken place since the last Update, and notifying any observers of the transitions. Those notifications is where the loose coupling between systems takes place. Here's an example. The player clicks on a destination tile, which triggers an expensive pathfinding operation. The player system creates an async workflow to compute the path. The async workflow will create a Transition affecting the relevant Components and Post it to the Event Store queue when finished. During the next frame's Update, the Event Store queue will apply the changes to its state and notify other systems which take care of moving the player along a specified path. Another example: procedural generation of an infinite map broken up into chunks. As the player moves in the game world, new chunks come into view. An Agent is responsible for maintaining the set of currently-loaded chunks. It is sent a message (a Post) whenever the player moves. If it notices that new chunks need to be loaded, it fires off several async workflows to do the procedural generation. When finished, each of those workflows Posts the relevant Transitions to the Event Store, and during the next Update frame, the systems responsible for updating Unity objects to reflect the new chunks receive the notifications and make their Unity API calls. I know this was a pretty high level description and may not deal approach things in the way you're thinking, but I hope it helps.
You are right, it's not really helpful. ;-) The thing is that you are describing a situation that is similar to mine, but you aren't touching on my question: is there a class in the .NET framework that can be used as such an EventStore out of the box, since the MailboxProcessor can't for several reasons, three of which you illustrate with your examples: 1. "The queue is held by an Agent (aka MailboxProcessor), so it can handle incoming transitions from many other threads at once without locking." - The Mailbox in the MailboxProcessor is not lock-free, it's just a Queue with locks. 2. In the pathfinding example the EventStore is filled from the worker thread and read from the thread that created the EventStore. This does happen to work with the MailboxProcessor, but both the API and the examples in the documentation seem to suggest that this is not the intended workflow. 3. In the procedural generation example you have two threads that communicate back and forth by sending messages to the other thread's message queue. Again this happens to work, but the resulting code has a significant code smell to it. That's why I asked if there was a Mailbox without a Processor, because in theory the Mailbox class does exactly what you expect from such an EventStore as you call it, but since you can't create one without creating a processing function at the same time it's weird to use it that way, to say the least. And when you use a class in a weird way you always have to expect that someone improves the implementation, doesn't think of the way you used the class and applies an optimization that breaks your code.
I happen to think my code smells just fine, thank you very much. :-) Have you looked at ConcurrentQueue in System.Collections.Concurrent? That would seem to give you a thread-safe Mailbox-like thing to work with however you want.
You misunderstood, I said that my code with the MailProcessor class had a code smell. And thanks a lot, the ConcurrentQueue sounds exactly like what I was looking for. Weird that it's not used in the MailProcessor implementation. 
Glad I could help. One thing ConcurrentQueue doesn't offer is what Erlang called selective receive, which MailboxProcessor provides as Scan, which can be handy in patterns like [ThrottlingAgent.](http://www.fssnip.net/5o/title/Throttling-agent)
Looks like you want mutually recursive functions. There are some options: Mutual recursion via `let ... and ...` let helper tree point = ... func tree2 point and let func tree point = .... helper tree point Using a recursive module in F# 4.1 to scope it just to that module module rec TreeStuff = let helper tree point = ... let func tree point = ... Using a recursive namespace in F# 4.1 if you might need to do this in multiple modules in the same file namespace rec TreeStuff module TreeStuff = let helper tree point = ... let func tree point = ...
 let case1 (tree: Tree, point: Point) : Tree * Point = ... (tree, point) let rec func (tree : Tree, point : Point) : Tree = if someExpr then match tree with | Case1 -&gt; case1 (tree, point) |&gt; func | Case2 -&gt; case2 (tree, point) |&gt; func else if otherExpr then tree else if nextExpr then ... func tree3 point .. etc What happens inside your ...'s materially changes how best to approach this but in the example above you can use a set of smaller functions to calculate the expected results by the time you get to your recursive call. The version above uses a tuple to pass around your multiple arguments. You could possibly also look into using mutually recursive calls to fix your original error as noted here: https://msdn.microsoft.com/visualfsharpdocs/conceptual/recursive-functions-the-rec-keyword-%5bfsharp%5d your example code would probably end up looking something like let rec func (tree : Tree) (point : Point) : Tree = if someExpr then helper tree point else ... and helper (tree : Tree) (point : Point) : Tree = ... func tree2 point
Got it. Thanks!
On that lambda thing: fun r -&gt; r |&gt; ListFiles.handle |&gt; OK You could replace this with ListFiles.handle &gt;&gt; OK Also I'm not a big fan of the Kleisli operator. I find it makes the code harder to read for everyone except the most functionally initiated. But that's more a preference of mine. 
`module rec TreeStuff =` Woah... 
FSAutocomplete is incredibly slow and memory intensive. [My memory usage on linux](https://user-images.githubusercontent.com/447391/34455784-5846d82e-ed7e-11e7-9660-ca223418ecd1.png) This means the out of the box experience on linux is unusable, as intellisense just stops working and all your builds grind to a halt due to memory pressure. :( Actually, not just linux, VS Code on Windows too, but Windows has VS2017.
Not really. Maybe some folks who are extra religious about top-down ordering would object to the usage, but I've not observed any actual downsides. It also lets you express things that you could not do before: module rec Wheeee = exception DontSqueezeTheBananaException of Banana type Banana = ... interface IFruit with member this.Juice() = raise (DontSqueezeTheBananaException this) Prior to recursive modules or namespaces you'd have to have a separate type for diagnostic info about the `Banana` that you construct in an error case should you wish to raise an exception. Not a mind blowing new capability, but it's now possible. You can also more easily code up a pattern where a type uses helper functions to compute stuff, and the helper functions can act directly on the type: namespace rec Fooooo type Foo() = ... member this.Whatever() = FooHelper.doStuff this module FooHelper = let doStuff (foo: Foo) = ... As before; not something that changes your life, but it's still useful.
FSAC is very memory intensive, yeah. The language service is also very memory-intensive, and you can get a similar experience as you've described in Visual Studio with large projects if you don't turn off In-memory cross-project references. Some work has been done to improve that recently, but there is a lot of work in the language service to bring it up to par with C# or VB. Can't speak for FSAC improvements, though, since it's not something Microsoft owns or contributes to. As for .NET Core build times, yeah with 2.1 it should be a lot better. This has been a big problem that they've been steadily whittling away at.
Thank you for your replies. Why did I get downvoted? 
 Response.asJson (request (fun r -&gt; r |&gt; ListFiles.handle |&gt; OK)) Response.asJson (request (ListFiles.handle &gt;&gt; OK)) Response.asJson ((ListFiles.handle &gt;&gt; OK) |&gt; request) ((ListFiles.handle &gt;&gt; OK) |&gt; request) |&gt; Response.asJson ListFiles.handle &gt;&gt; OK |&gt; request |&gt; Response.asJson This one should be correct. Personally, I'd stop at the second line.
Maybe I'm missing something about the implementation details, but couldn't you do, for a specific example: type Tree = | Empty | NotEmpty type Point = | APoint let inline helper (tree : Tree) (point : Point) (funcToHelp: Tree -&gt; Point -&gt; Tree) : Tree = match tree with | NotEmpty -&gt; Empty | Empty -&gt; funcToHelp tree point let rec func (tree : Tree) (point : Point) : Tree = match tree with | Empty -&gt; Empty | NotEmpty -&gt; helper tree point func I don't think you need the inline - I wrote this with statically determined type parameters first to make sure it worked. This works too - either tree is sent to Tree.Empty. Easy to make an infinite loop here :) The point is you don't necessarily need the mutually dependent types here - and I think those work under-the-covers like this anyway. All this stuff is syntactical sugar for a code template :)
Use the alpha pull request https://github.com/xyncro/chiron/pull/81
You aren't doing any error handling in case the file is unable to be read for whatever reason. I suppose a web service can just go #yolo and throw a 500 if an exception happens, so it's not as critical as in a local app, but I'd still harden the `File` type. For example: ``` type File = { Name : string; SizeInBytes : int64 } with static member Load filename = try Ok { Name = filename; SizeInBytes = System.IO.FileInfo(filename).Length } with exn -&gt; Error exn ``` Even if you don't use records, I'd still make the type immutable (remove the `set` from its properties). There's no good reason you to change either property separately from the other. &gt; Also I really don't like the line with: path "/files" (routing). I feel like I should modularize it better but I'm stuck in my head how to do it better. A good Suave/Giraffe pattern, as the application grows, is to keep the routing function as plain as possible and encapsulate all the actual work in separate functions. The idea is to eventually get something like: ``` let app = choose [ GET &gt;=&gt; choose [ path "/files" &gt;=&gt; serveFileList path "/text" &gt;=&gt; serveText path "/foo" &gt;=&gt; serveFoo ] POST &gt;=&gt; choose [ path "/login" &gt;=&gt; handleLogin Authentication.authenticateBasic handleBasicAuth (path "/files" &gt;=&gt; receiveFile) ] ] ``` This way you have all your API layout in the same location in your code, where it's easy to read and reorganize.
thank you very much for your feedback. About the error handling you are totally right. I just didn't do it yet because I didn't know how to do it the correct way but it was on my agenda to check it out. I would use records more often but I want to set them explicitly. like: type foo = FooRecord { Name: string; SizeInBytes.... (example) } and I don't want it to be implicit (personal taste). Need to figure out how to do it The part about the "Suave pattern": Yes you're right. That's what I also wanted to improve in my code (see my question). I'm a bit further now with my f# knowledge so I'll tacke that as my next thing ;-)
yeah, that's what I was looking for thank you.
That GitHub TLS change caught out a lot of people - Cargo, the package manager for Rust, had [issues as well](https://github.com/rust-lang/cargo/issues/5066).
A new F#-like programming language with first-class IDE support. 
You've got my attention. Where can find more info about it? - What's the motivation behind? - How different is the syntax compared to F#? Is it less verbose (yes, I find `fun` verbose because I write it a lot)? - Any new type system capabilities in comparison to F# (module system, type classes...) - Does it run on an existing VM (.NET, JVM) or it is compiled to native? - Does it have a GC? 
A lot of ETL tasks with almighty Hopac 
A microservice based, license free, federated data streaming solution to provide a self-service Enterprise data lake and accordant SOA on/off ramps for legacy systems (F#, Kubernetes, Kafka, Suave, &amp; Akka.Net).
An IoT toolkit for LPWAN (SigFox, LoRaWAN, MQTT-SN over Cellular) applications. https://github.com/kiotlog/kiotlog Persistence is done on Postgres via EF Core using Jsonb and other amenities... A lot of other stuff hidden inside!
Sounds impressive. Are you creating that for a *particular* legacy system?
Hello world :)
pair programming on a feature for vscode ionide to search fsdn type signatures. Through the FSharp Foundation mentorship program.
Finishing up a blog post about the upcoming release, some docs updates, finishing up some pull requests for the next release, and realizing I misspelled something in the release notes only to know that I might forget about it because it’s the weekend and I’m going snowboarding.
Always a good first start!
This sounds really cool, and I bet it’ll be awesome. I look forward to tweeting and/or blogging about it in the future :)
Rejoicing at my small success in integrating [p5.js](https://p5js.org/) and [fable](http://fable.io/). https://gist.github.com/ssmock/05bb81130bc5762729d16307c6da2364 (Thanks to /u/statuek for advice/inspiration.)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/zVd1VGC.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dv5jkw7) 
Could you give a source code? Github or gist. Would be cool to check it 
Implementing a language feature (namely, `match!`)
If I could get the code I can probably get this checked in as sample code on the official site
Yes, I will put this on github - but give me a bit. If it's been more than a few days please PM me and remind me that I said I'd do it :) I was in a rush with a distributed numerical computation deadline on Monday and this code has sensitive business logic in it - plus the "hello world" actor is actually doing math now :) Currently I'm a bit too busy to go make a template .sln but I will get back to this ASAP. 
Thanks - I think having a Visual Studio extension would also be really helpful. This stuff doesn't seem too hard to do and it's a shame that more of Azure isn't officially supported in F#. Repeating my response to /u/OmgSzer : I will put this on github - but give me a bit. If it's been more than a few days please PM me and remind me that I said I'd do it :) I was in a rush with a distributed numerical computation deadline on Monday and this code has sensitive business logic in it - plus the "hello world" actor is actually doing math now :) Currently I'm a bit too busy to go make a template .sln but I will get back to this ASAP.
It seems this was an issue with my installation. Reinstalled and all seems good now :-)
We are getting there :) Once FSI comes for .net core things will be even sexier (and I'm vaguely hoping that cores dist model will make integrating scripts/scripting support more viable than an SDK installation on the client). Great to see the progress -- F# on core on k8s is just too nice.
in Nim you can just do distinct type casts: type ShaderId = distinct int setting a ShaderId type to an int is then a compiler error, you have to cast. This is useful in making a type safe wrapper for opengl, for instance, without as much extra code. 
Where do you see a mention of k8s?
We now have: * Full .Net Standard 2.0 support (file ordering was missing in 15.5). * Folder support which has been a missing feature for ever. * Nice coloring and outlining and better intellisense. F# tooling is in great shape as of VS 15.6.
I am deeply disturbed by the amount of bug fixing attributed to Vasily because he doesn't work for Microsoft and is strongly advocating avoiding it at all costs, to the extent that he is switching to other languages.
Would you prefer we not attribute open source contributions in release notes? I think it’s important to attribute people, and assumed others feel the same way. Vasily is free to express his opinions on Twitter. He’s blocked me, so I can’t see what he’s saying. I wouldn’t advise making decisions based on what you see there.
&gt; Would you prefer we not attribute open source contributions in release notes? Attribution is wonderful, of course, but I am concerned that we (as industrial users of F#) seem to have become reliant upon Vasily to keep F# working in Visual Studio when Vasily clearly isn't committed to doing this going forwards. Word on the street is that F# in VS would essentially be dead if it weren't for Vasily having fixed it. Are Microsoft committed to F# going forwards or is it essentially abandonware now? &gt; He’s blocked me Oh wow, ok. 
I internet at Microsoft a year and a half ago, even got to say hi to /u/philipcarter2! F# support inside the company looked moribund at best. Most internal contributions outside of a 2-3 people team were basically from hobbyists who happened to work at Microsoft. F#'s future is in our hands. Yours, mine, Vasily's, and everyone reading this. Microsoft hasn't completely disowned it, but they do look like they're banking on it quietly dying off. I'm begging the community: do not go gentle into that good night.
Getting started on a F# web service (.NET Core on Linux) to learn the ecosystem and deployment. Not sure about the web framework/library to use yet, discovered Suave but don't know any others. Will dockerise it and push it to Azure once I'm done. Open to suggestions for other web libraries to use.
I'm extremely happy to learn this.
While I am happy to read this, and kudos to all the work you guys have poured into it, none of our customers will ever consider F# until it has equal footing with VB.NET and C#. The very fact that desktop applications aren't properly supported and the whole UWP story kills any discussion about possible F# adoption.
I think for a lot of people they would like to see more investment in the language over VS tooling. I mean I don't use Windows so Visual Studio 2017 upgrades don't affect me.
Yes. I don't care about VS because there are better alternatives, offering F# support backed by real developers doing real work, every day. And yes, I'm more interested in evolving the language, not the tooling. A language is dead when nobody is able to seriously contribute to it (everyone, but Don), or nobody _wants_ to change, improve and make it more powerful and faster, considering it "in a good shape" (Don). So, what I've seen for all those years I've been into F# is few volunteers working on tooling with occasional help by Don, that's all. About the "expanded" VFT team, it's _VFT_ team, working on VS tooling, mostly (it's fair, they are MS employees after all, and should help with selling VS).
Mark Seesmann's [Dependency Rejection](http://blog.ploeh.dk/2017/01/27/from-dependency-injection-to-dependency-rejection/) Scott Wlaschin's [Domain Modeling](https://pragprog.com/book/swdddf/domain-modeling-made-functional)
I just installed this on one machine as a test and I've lost the ability to reorder files in a project using ALT+UP and ALT+DOWN. There is a context-menu item I can repeatedly choose but it is quite tedious in comparison because this is such a commonly-required operation in F#. Is there an easier way to do this? 
&gt; I don't care about VS because there are better alternatives Are you talking about Scala again? ;-)
&gt; most of our users have it on their list of priorities by our measure That's very interesting. Assuming those are industrial users, do you have any idea why they would be interested in .NET Core? &gt; those who have been able to use F# running on .NET Core to convince their bosses and coworkers to give it a go I don't understand why they wouldn't just use the .NET Framework on Windows. Are these non-Windows users? 
&gt; I'm begging the community: do not go gentle into that good night. I don't understand this. If you want something built and maintained by the community then use OCaml. F# is a product of a company aimed at industrial users. If it is abandoned to its tiny open source community it will surely die. The main discrepancy I see here is Philip Carter saying that most F# users are going after .NET Core when everyone I know (all industrial users of F# and not OSS contributors to it) regards .NET Core as an interesting side show they're nowhere near ready to bank on. 
&gt; the most important thing for .NET strategically Can you elaborate on why .NET Core is the most important thing for .NET strategically? Are you saying that the .NET Framework is going to die and, therefore, all of its uniques like WPF? 
&gt; F# is a wet-dream for microservice production. Particularly the ability to succinctly and powerfully model isolated domains and create lightweight rich DSLs means I'm looking at multiple live production systems that are so small and tight they would seem unrealistic had I seen them in a textbook or blog post. Unless you're on Windows, OCaml is a *lot* better than F# for that: Much lower latency, much higher throughput, much smaller binaries and far more reliable. 
I'm including business users under "community", even business users internal to Microsoft. Basically the only people I'm excluding are The Powers That Be at Microsoft, and those people's executors. I'm excluding OCaml because it has lesser tooling, and [perceived or actual] lesser potential for business use. GADTs would be nice, but I was never wed to them.
&gt;you see 40x more subscribers to the .NET subreddit than .NET Core which only has ~600 subscribers compared to, for example, 4,000 for the OCaml subreddit. That's because /r/dotnet is .NET + .NET Core + .NET Micro + C# + F# + ASP.NET + VB.NET.
Unless you need ... you know... libraries, interop with enterprise solutions, specific cloud capabilities, editor support, and, as you've pointed out, *client support*... OCaml is better in general for DSLs. OCaml is *infinitely worse* in every direction as a serious Enterprise solution in the specific domains I have highlighted, and fails miserably at the specific users-as-coders-for-free solution I sketched out in my post (and have used at a national health authority for scientific users...). That's not even to mention the laughably bad hiring picture that would make even a technically superior option (which OCaml is not), a total non-starter. More importantly, outside of basic latency which has a wholly different profile thanks to recent .net improvements, every point of comparison you're proffering here is directly and holistically addressed by Kubernetes with one exception: disk size, the cheapest and easiest thing to fix in the world. OCaml is really good for what it's good for. Jane Street is kicking ass... But if you're in position that it's halfway viable: Haskell will do more, for less, has a better type system, is wildly more popular, and carries better non-techie name recognition...
&gt; Functional is taking over. C# will eventually be a weird syntax you can invoke I think you've nailed a major point with regards to language advocacy in the Enterprise: everything that was 'out there' in terms of F# a decade ago is wildly close to 'modern C#' in 2018. If I'm training my guys up on how to use pattern matching anyways, why not go for the pretty and exhaustive version? Immutable non-nullable data, why not go for the one with compiler guarantees about abuse and language support from the ground-up? And since the kinds of Domain Modeling you can pull off in F# is markedly more powerful, why would I want to be training junior devs on worse solutions that take longer to read and require more code? ... I think C# has done the hard work of F# advocacy for me :) 
This FUD is kinda boring to read over and over again... 1) F# is .Net, so libraries can mix and match and adoption can happen piecemeal . Functional domains, OO glue-code for the nonsense shiney-shiney at the top layer. The same solution mixed language stacks have taken for *ages*... I mean, take python and C++: you don't write your web code in C++ and you don't write your 3D rendering code in Python, you mix both and win. 2) UWP support for native apps (Desktop Bridge, IIRC?), means UWP is as popular as people think it is and there is a solution for this for anyone who cares. 3) This argument that following the "latest and greatest" form MS is smart for anyones customers is not based in historical fact, or industry results. It is the default opinion of MS-based consulting shops though (wonder why? The partnership benefits and licensing kickbacks, maybe?). Being removed from the treadmill of failed techs is not a negative. It also opens a lot of smarter doors across the wider industry, highly accessible now that .Net Core is mature enough for real world work :)
RightClick+UP/DOWN is not so hard. But they are fixing this for you anyway: https://github.com/Microsoft/visualfsharp/issues/4405
&gt; Can you elaborate on why .NET Core is the most important thing for .NET strategically? The cloud. Also: without a radical shift in licensing models MS will not be allowed into server rooms they want to be in thanks to new virtualization tech... Azure is taking off, thats where more and more of their money is coming from, so MS wants to be a cloud player more than they want to preserve platform locking as the scales tip that way. Plus the better their Azure story is the more business they can capture for semi-IT shops... Easier up-sell to Azure-Biztalk and Azure-Sharepoint aligns nicely with getting .net out on cheap linux hosts. There are also some rumblings at national levels about open source and such that make cross-platform support look like more of a 'must have' than 'nice to have'. We're not there, yet, but the risk picture is much nicer cross-platform. &gt; Are you saying that the .NET Framework is going to die and, therefore, all of its uniques like WPF? Hate to be the one to have to say it, bro, but WPF is dead. Not "dead don't use it dead", but "they've already replaced it, kinda". It's not going away, but it's not really going anywhere now is it? .Net core is strategically important to keep the platform going across the board. Cross platform GUI will take over for the client apps that can't be handled through HTML5+. That doesn't mean they don't want WPF on the client, just that its no priority and isn't where the strategic weight is. For thick windows apps, though, WPF is an ok bet (dat UWP tho...). Once .Net Core is 10,000% maybe WPF will make the leap to Linux/mac? Or heck, maybe they'll bring back Silverlight The Right Way and make a cross-stack attack... hard to say ;) 
This is misinformation, admittedly based on MS marketing a lot of things as UWP. Store apps that are compiled from the desktop are not UWP proper. UWP has a lot of things that WPF does not have: compatibility with Xamarin.Forms and Xamarin.Forms components, performance, updates.
Hopefully they'll fix the default (if there is an issue there). In the meantime: any command visible in Visual Studio can be searched for in the Tools -&gt; Options and bound to desired keys.
&gt; That's very interesting. Assuming those are industrial users, do you have any idea why they would be interested in .NET Core? Many organizations have had one or more of the following problems: 1. Broken app deployments due to no side-by-side installs of the .NET Framework (which you can do in .NET Core). 2. A need or strong desire to run on Linux and use Linux tooling (e.g., Docker and Kubernetes). 3. Windows Server licensing issues. 4. A fear of missing out on the evolution of the server space, which is centered around Linux. .NET Core fits the bill for these. That list is not exhaustive, but covers major issues that customers have directly expressed. .NET Core is absolutely production ready, with many large customers already switching over to it for their server workloads. It will never replace .NET Framework for windows apps of course, which is why .NET Framework is continuing to evolve and absorb backported improvements. But in the server and cloud space, the industry is moving in a direction which is centered around Linux and various tools built for it. .NET Core must be there to capture new developers. By extension, so must F#.
For our consulting projects, MS tech only matters on MS shops, for anything else we just use other stacks where .NET doesn't matter. Just two months ago we got a contract to rewrite a .NET project into Java, as the customer wasn't willing to rely on .NET Core for UNIX like deployments. So a company prefered to pay for a full rewrite, that just try out .NET Core. You might say their loss, however this is the harsh reality of many enterprises.
Who cares about MSFT store, lol. Not only targeting Windows only in 2018 is silly enough but using store that everyone hates is just adding to this stupidity 
This will be fixed in a service update soon.
This doesn't make sense. Targeting the windows store does not imply not targeting other platforms. On any platform a store is generally the right way to provide native apps since it provides security and updates. In the case of regular desktop non-store apps, updates are hard (just open a task manager and see how many updaters you can find). In the case of UWP, installing an app outside the store requires admin privileges, flipping switches in the control panel, installing security certificates...
Don't worry - JDH is famous for using meaningless, random numbers to proof his narrow-minded view of the F# (and .Net) ecosystem. 
&gt; Having recently done commercial servers in both OCaml and F# I found OCaml's libraries to be better in all respects. Yep, it's clear that this dozen of OCaml developers around the world produces more and better libraries than .Net ecosystem with millions of developers. Suuuure. &gt; That's not something I noticed when I helped write the Citrix' code that runs Amazon AWS (i.e. the world's largest) cloud... in OCaml. Are you talking specifically about Microsoft Azure? Please show me any OCaml libraries that provides integration with any cloud? Sure you can put OCaml program in container and host it whenever you want, communicating with any cloud's APIs by the REST APIs they expose but it's not really integration. At least in case of F# we have deep integration with any Azure feature since MSFT always provides .Net libraries... and we have many cool projects specific to F# and Azure such as FSharp.Azure.Storage etc. Not to even mention modern ways of hosting applications such as serverless - which for F# is possibe on both Azure and AWS... and for OCaml you need to compile things to JS with BuckleScript to enable hosting on AWS Lambdas. What a great cloud support! &gt; Pre-VS2017, editor support was indeed a compelling reason to prefer F#. Today, not so much. Editor support for F# is now the worst it has ever been whereas OCaml's continues to improve. In contrary, F# editor tooling is in its best place ever - lot of new powerful IDE features, working cross platform editors, different vendors working on it (MSFT, JB, or stuff built by Community). Rewriting VS integration while caused some minor problems has create modern platform for the future. Also, non-editor tooling is really good - Paket and FAKE continues to be in their own class when we talk about .Net, SDK-based project files is nice step forward, `dotnet` CLI is decent and having F# support there out of the box is huge from marketing point of view and shows MSFT commitment. &gt; I pointed out WPF, not "client support", and WPF appears to be dead. Yes, indeed. WPF is dead. Bad luck. Building Windows-only apps is so 2000s, no one sane does it nowadays. &gt; If you want to talk about client support then you need to talk about web UIs, for which F# has absolutely atrocious support. What few libraries F# has are unusably buggy and have no serious industrial users as a consequence. In contrast, OCaml has a long history with many large companies like Facebook and Bloomberg heavily invested in it. Again, in contrary - F# is great fit for web applications, both on the server side with Suave, Giraffe or normal ASP.NET (Core) and client side - Fable has been fastly growing, seeing increasing usage in the industry, multiple companies using it already, and decent interest in consulting / training around this technology. It's also something that excites many members of core F# Community actually doing cool stuff, is one of the reasons for several language features that are being considered at the moment, etc. ... And that's just Fable, not to mention WebSharper around which is built successful company with many industrial usage. Maybe the problem is not industrial usage of those technologies but seeing outside your narrow WPF, Windows-only bubble? And mentioning those 2 Facebook devs (ReasomML), and one Bloomberg dev (BuckleScript) as an example of support and investments is nothing else but demagogy. &gt; Only in academia. OCaml keeps garnering more paying contributors to the CAML Consortium, now 15 members, while Haskell has succeeded in garnering no new industrial users at all since the three founding members 10 years ago (!). And I assume the Haskell in Industry page is still full of fakes? :-) But Haskell reddit has 31577 subs and OCaml only 4173. And we all know that's best way to see how popular is the language! Right?
&gt; Yep, it's clear that this dozen of OCaml developers around the world produces more and better libraries than .Net ecosystem with millions of developers. Suuuure. &gt; Please show me any OCaml libraries that provides integration with any cloud? [xen-api-libs](https://github.com/xapi-project/xen-api-libs) &gt; in case of F# we have deep integration with any Azure feature since MSFT always provides .Net libraries... and we have many cool projects specific to F# and Azure such as FSharp.Azure.Storage That's great but a Microsoft employee working on Azure advised me never to use it so I, like most of the professional world, use the larger Amazon AWS Cloud. &gt; F# editor tooling is in its best place ever You cannot even re-order files with ALT+UP/DOWN in this latest VS2017 release. &gt; non-editor tooling is really good - Paket and FAKE continues to be in their own class when we talk about .Net, SDK-based project files is nice step forward, dotnet CLI is decent and having F# support there out of the box is huge from marketing point of view and shows MSFT commitment. That's great that Microsoft are taking their first baby steps in open source by trying to reinvent package managers. Meanwhile OCaml already had APT and opam. &gt; Suave Where [HTML forms are still "experimental"](https://github.com/SuaveIO/suave/blob/master/src/Experimental/Html.fs). &gt; ASP.NET (Core) My company never modernised to ASP.NET because it is, from what I gather, crap. &gt; Fable has been fastly growing, seeing increasing usage in the industry, multiple companies using it already, and decent interest in consulting / training around this technology Not compared to Bucklescript and ReasonML. &gt; nothing else but demagogy Ok. So concrete counter examples of massive companies seriously investing in OCaml is demagogy but you can cite a company bankrolled by the CEO's father as a successful industrial case study. 
Jon, I suggest taking a break for a little while. These threads don’t help anyone.
&gt; There's a reason why Intel use OCaml to verify their CPUs: it is rock solid And .Net has been used by tens of thousands of companies in millions commercial projects. It's rock solid. And it doesn't need fringe examples (because verifying CPUs while something super impressive it's just that - fringe example) of how it is used. &gt; xen-api-libs. Don't forget: the server code on the other end that you're talking to is written in OCaml and I know because I helped write it. Great! Thanks for showing perfect example of small and dead OCaml ecosystem - 20 contributors, last commit 4 (!) years ago, used to connect with some fringe project no one in "industrial world" is using. Meanwhile F# (and .Net) cloud libraries include integration with all modern features and building blocks provided by Azure (and often AWS) &gt; Oh please. You cannot even re-order files with ALT+UP/DOWN in this latest VS2017 release. LITERALLY UNUSABLE. &gt; That's great that Microsoft's ecosystem is taking their first baby steps in open source by trying to reinvent package managers. Meanwhile OCaml already had APT and opam. Huh, you realize that MSFT has something called NuGet that's there for more than 15 years and is used by 3 orders of magnitude more users than any OCaml stuff? I'm pretty sure you don't understand what's the place of the tools I've mentioned in the bigger ecosystem created by both MSFT and Community. &gt; Where HTML forms are still "experimental" It's been there for 2 years, it's been used in many of projects... and its file with 90 LOC. Is your only problem with it fact it's put in the namespace "Experimental"? &gt; Meanwhile OCaml has rock solid alternatives with serious backers. Again, you compare OCaml ecosystem with handful of devs, and companies with the whole .Net ecosystem (F# is .Net - you can also use C# libraries) with millions developers and thousands of companies. If you don't like Suave there is Giraffe which is basically thin layer on top of ASP.NET Core - hard to get more serious backing than one that ASP.NET Core has. If you don't like that use Nancy, or ASP.NET directly and get all "industrial level" support you want from MSFT. Also there are multiple companies that offer consulting and training around F# web stack, so it's not like there is 0 support for this stuff. &gt; My company never modernised to ASP.NET because it is, from what I gather, crap. Yeah, technology that powers millions of internet applications around the world is totally crap. I guess that's enough for the comment. &gt; Not compared to Bucklescript and ReasonML. Not sure how you judge that since you have nothing to do with Fable and its ecosystem. Just like I can't compare that since I don't have anything to do with ReasonML &gt; you can cite a company bankrolled by the CEO's father as a successful industrial case study. You that's exactly what all my clients (and clients of all other companies doing F# consulting) are. Whole F# user base knows that you're the only one working with Real Industrial Users Of F# ™️ and everyone else is just doing nothing real. :) 
&gt; some fringe project no one in "industrial world" is using Amazon AWS, the largest Cloud in the world, is not a "fringe project no one in the industrial world is using". &gt; Huh, you realize that MSFT has something called NuGet that's there for more than 15 years and is used by 3 orders of magnitude more users than any OCaml stuff? [APT](https://en.wikipedia.org/wiki/APT_(Debian)) is the most popular package manager on three of the most popular Linux distros which is the most popular server and mobile OS in the world. If you want to compare F#'s Fable then compare it with OCaml's [Opam](https://opam.ocaml.org/). &gt; It's been there for 2 years, it's been used in many of projects... and its file with 90 LOC. Is your only problem with it fact it's put in the namespace "Experimental"? So you dismiss the toolstack at the core of the world's largest Cloud because it hasn't been tweaked recently enough but you don't care that HTML forms support hasn't made it out of experimental in Suave for 2 years. &gt; &gt; &gt; Fable has been fastly growing, seeing increasing usage in the industry, multiple companies using it already, and decent interest in consulting / training around this technology &gt; &gt; Not compared to Bucklescript and ReasonML. &gt; Not sure how you judge that since you have nothing to do with Fable and its ecosystem. Just like I can't compare that since I don't have anything to do with ReasonML Do you seriously think that Fable is growing anywhere near as fast as ReasonML? &gt; Yes! That's exactly what all my clients (and clients of all other companies doing F# consulting) are. Whole F# user base knows that you're the only one working with Real Industrial Users Of F# ™️ and everyone else is just doing nothing real. You gave an example that I have heard is fake. 
&gt; &gt; some fringe project no one in "industrial world" is using &gt; &gt;Amazon AWS, the largest Cloud in the world, is not a "fringe project no one in the industrial world is using". Fair enough, Xen Project looks impressive - I've edited my previous post. However it's still infrastructure project for Cloud providers, not one of high level building blocks provided by Azure or AWS for building business applications (at that's what most people do). Where is OCaml library for Amazon Kinesis, or DynamoDB driver, or interface for any other feature provided by AWS? For Azure's CosmoDB? ApplicationInsight? Azure Storage? etc. Because that's the stuff people need for building boring business applications. &gt; If you want to compare F#'s Fable then compare it with OCaml's Opam. Why do you want to compare subset of F# ecosystem, with whole OCaml ecosystem? Comparison of .Net and OCaml (so whole ecosystems) looks just like I've mentioned - 3 orders of magnitude, at least. &gt; So you dismiss the toolstack at the core of the world's largest Cloud because it hasn't been tweaked recently enough but you don't care that HTML forms support hasn't made it out of experimental in Suave for 2 years. Again, how "experimental" is something that's been used by people for last 2 years, and is 90 LOC ? Seriously, do you want to argue over name of the namespace? I don't know what's the reasoning why the namespace wasn't changed - it's breaking change for the users, or maybe no one really bothered since most of the times people are using Suave for hosting APIs and using client side apps rather than server side rendered views - but there is nothing experimental in this module. It's not rocket science. It's been used by many people. That's all. &gt; Do you seriously think that Fable is growing anywhere near as fast as ReasonML? I don't have any data point on that. I just think that are multiple industrial users of Fable, and there is growing interest from what I can tell. Also there is huge interest from MSFT side, both Don and Phillip promoted Fable in blog post / talks, and there are language features considered that were inspired / or driven by Fable. So I wouldn't call it "buggy hipster abandonware". &gt; You gave an example that I have heard is fake. I haven't gave any name of the company in this thread... :)
&gt; I'm not familiar with them but going to the [Opam repository](https://opam.ocaml.org/packages/) and searching for AWS I get [this](https://opam.ocaml.org/packages/aws/) which seems to cover everything. 2 contributors, last commit year ago, last release 2 years ago - industrial ready with serious backing or hipster abandonware? Because I know what would be your answer if that was F# library. &gt; Are those Microsoft Azure specific? Yeah, they’re. So I assume answer is that there are no libraries for this things. Which means OCaml ecosystem doesn’t have industrial ready support for neither of 2 biggest cloud providers. So... maybe let’s go with something not platform specific? Apache Kafka? Apache Storm? MongoDB? GitHub API library? Firebase? SW API? People have different use cases, write different applications, need to integrate with different systems. I guess it’s easier to find library you need in ecosystem with 100K packages than with 2K, isn’t it? 
Scott’s work has been very impactful to my work and consider it to be essential.
JDH is the moderator of this subreddit, while you're a guest, so I suggest that you and your buddies take a break. Look at the nonsense k_cieslak is spouting. https://www.reddit.com/r/fsharp/comments/82eofe/improvements_for_f_in_visual_studio_2017_release/dvbvxfd/ &gt; Who cares about MSFT store, lol. Not only targeting Windows only in 2018 is silly enough but using store that everyone hates is just adding to this stupidity https://www.reddit.com/r/fsharp/comments/82eofe/improvements_for_f_in_visual_studio_2017_release/dvc0gk8/ &gt; Don't worry - JDH is famous for using meaningless, random numbers to prove his narrow-minded view of the F# (and .Net) ecosystem. If I were MS, I would have fired you for allowing people like k_cieslak to be associated with F#. Your direction and the attitude of current contributors have driven many people away from of F#. All the people and organizations I introduced to F# since a decade ago have since stopped using it, thanks to your management. JDH has done more to F# uptake than you ever will.
It's not FUD. Desktop Bridge apps look and behave differently from native modern UWP apps. 
Bothe the language and tooling are lacking now.
And still no sign of .NET Native/UWP support.
I think the F# community is stronger than ever before. Vasily’s antics on twitter aren’t representative of the diverse and strong group of people I’ve come to call friends. Sorry that F# isn’t evolving in the direction you prefer.
The anti-Windows antics of the F# community is very unprofessional and immature and I warned you about it a few times before. I'm afraid I will have to bring this to the higer-ups at MS to get you replaced.
There hasn’t really been a “binary” shift as far as I can tell. As F# has grown and the software ecosystem has evolved, peoples’ priorities have shifted. The bulk of feedback we get is still around better tooling support in VS, but it has increasingly focused on better cross-platform tooling support for .NET Core (and not necessarily in VS, as lots of folks use Ionide and some are using Rider). Others are happy enough with the current tools for their needs and want more language features. Others want better Xamarin support. A few want UWP support, and a few more want better WPF and WinForms support. A good lot of folks want to compile to a single, native binary for Linux deployments (a .NET feature, not really an F# one, but still quite valid). Long story short: there are a lot of folks who have diverse needs!
Well, with that I’m afraid I cannot take you seriously nor respect your position. If you proceed, know that you’re about to do an incredibly immature thing.
Language is just as good as it was 3 years ago, most changes over this time were small quality of life changes. Some people would love to see some more changes to the language, others think the language is fine. Community is diverse and such are opinions about language evolution. I think tooling is still nowhere near of how good it could possibly be if there were lot of serious investment in it... but F# is tooling with best editor tooling out of FP languages.
I wonder how many threads will you troll with that useless complaint. It’s not there because UWP is dead, simple as that - targeting Windows-only platform in 2018 is symptom of being stuck in 2000s and being mentally shaped by MSFT marketing from those times. 
&gt; Windows Server licensing issues Thank you for being this honest. 
I wonder when MSFT will finally take action against the anti-MS feelings in F# community.
This is ridiculous. Get a grip on yourself TensorMetric. As this thread makes clear, the F# community has to accomodate people who are brilliant but very difficult to work with. Philip does a very good job of that. PS Vasily has a very normal, even conservative Twitter account as far as I can see. I do not see any antics.
Who cares about UWP it was DOA anyway. F# is a cross platform language, not a Windows only language.
They should give out lollipops.
Mostly its not anti-windows, its pro cross platform, equal support over all the platforms now a windows centric approach.
What people want over time changes as get more experienced, also if your new to functional programming you begin to experiment with other languages and approached and begin to see issues with F# that you like to see addressed. I don't have any particulate issues with tooling its been fine for years, they only thing that bugs me is stability.
I wonder when MSFT will finally take action against the anti-2000s-MS feelings in 2018-MS... 
I think it's rather about IDEs like Ionide and Rider
There are couple of options with F# and web services: * Suave as you've mentioned is mature project, battle tested by many people. It has some performance problems and doesn't look too hot on benchmarks which may or may not be a problem for you * [Giraffe](https://github.com/giraffe-fsharp/Giraffe) - provides Suave-like API on top of ASP.NET Core. Which means better (really good) performance, integration with existing ASP ecosystem, but it requires you to know thing or 2 about ASP which creates some additional cognitive load. * [Saturn](https://github.com/SaturnFramework/Saturn) - is a library that builds higher level API on top of Giraffe and tries to hide some of this additional knowledge you need to use ASP. * Other choices for F# are [Freya](https://freya.io/) and [WebSharper](https://websharper.com/) Good news - all those are xplat, can be run in docker etc. [SAFE-Bookstore](https://github.com/SAFE-Stack/SAFE-BookStore) sample shows how Giraffe ( + some other technologies) are used to create application that's running in docker and deployed to Azure. 
As usual I'd say: 'it depends'. I personally work for a very 'Enterprise-ish' company that produces software that has to some extend been used exensively in the market for more than 15 years (with the normal transitions VB to VB.NET to C# with a hint of Pascal, JavaScript and now also traces of F#). Writing about my experiences there would be boring to say the least. I can only assume from my personal experience that people rather write about new and shiny things as they are more exiting - especially as they bring lots of internet points. To give an example: we currently started the transition from .NET 4.0 to .NET &gt;= 4.7 as well as .NET standard for our libraries. The resulting blog post would boil down to 'this experience sucks a lot but it went smoother than we would have expected but still we burnt a couple of weeks'.
It surely does not. I'm sorry if I came through too dismissive. The thing I like very much about the F# community is that (at least as I see it) they tend to be far more pragmatic than other functional communities which leads to a lot of 'get-business-done' posts, libraries and frameworks. Do you already follow Sergey Tihons blog (https://sergeytihon.com/)? He produces a great newsletter with things that happen in the F# world. Other than that there is Mathias Brandewinder who produces great posts on F# scripting (like http://brandewinder.com/2016/02/06/10-fsharp-scripting-tips/) and naturally Scott Wlaschin's blog (there's even a post on F# scripting for CI/CD https://fsharpforfunandprofit.com/posts/low-risk-ways-to-use-fsharp-at-work-2/#fake). There is also a ton of interesting gists with F# scripts like graphing Nuget dependency trees and stuff like that - but yeah - not everything is easily discoverable.
Did you miss this? https://reddit.com/r/fsharp/comments/6tdrwq/after_so_many_years_still_no_net_native_nor/
Did you conveniently overlook the personal attacks of the community towards UWP users and jdh30 in this current thread that phillipcarter2 turns a blind eye too, but has the nerve to tell jdh30 to take a break? It's things like this why I'm going to lobby to get phillipcarter2 replaced.
All the examples you give are a single developer who doesn't even work for microsoft... You're incredibly negative, is it a sign of unfit management that you're still allowed to participate in the community!?
He's breeding an anti-Windows community by giving those people free reign to disrupt every conversation regarding UWP on GitHub etc. And even made statements like how it might be better to avoid UWP, since Windows 7 still has a large % of the market. This is not something someone should say when on the payroll of Microsoft.
I have enormous respect for jdh30 but he did need to take a break. There are people that have an anti-Windows bias and express it but that is different from personal attacks.
&gt; You're incredibly negative, is it a sign of unfit management that you're still allowed to participate in the community!? Wouldn't tell that some anonymous trolls are "participating in community". :-) 
Hey phillipcarter2, you may never see this, but I want you to know that as an F# user, I appreciate the work you are doing. I understand the complicated reality of F# right now (where there are active and important contributors in the community who are seemingly exasperated with Microsoft). Remember that most of this conversation is just that, exasperation, and desire to see more weight be thrown behind something they really like.
Are these not a personal attacks? https://www.reddit.com/r/fsharp/comments/82eofe/improvements_for_f_in_visual_studio_2017_release/dvc0gk8/ &gt; Don't worry - JDH is famous for using meaningless, random numbers to prove his narrow-minded view of the F# (and .Net) ecosystem. https://www.reddit.com/r/fsharp/comments/82eofe/improvements_for_f_in_visual_studio_2017_release/dvc1bc0/ &gt; But you don't have view of the world shaped my 2000s MSFT marketing where "industrial users" is one group of people and "hipsters doing OSS" is another not important group of people. Unlike some other people in this thread. Fortunately even MSFT is changing, seeing that cooperation with Community is way forward. It's just sad that some once-respected back in the times folks are stuck in the reality that's just not true in 2018. But well, some people are still doing COBOL, pushing OSS vs Industry dichotomy is just like that. https://www.reddit.com/r/fsharp/comments/82eofe/improvements_for_f_in_visual_studio_2017_release/dvd9t3s/ &gt; I wonder how many threads will you troll with that useless complaint. It’s not there because UWP is dead, simple as that - targeting Windows-only platform in 2018 is symptom of being stuck in 2000s and being mentally shaped by MSFT marketing from those times. And there are plenty more in that other thread. 
F# works on Windows just fine, it just doesn't support one niche, dead platform.
What is dead for you? Just because you don't like it?
Thanks!
&gt; UWP Thats a windows only technology, its only going to work on Windows. 
/u/TensorMetric got me fired once for putting too much creamer in his coffee. I'm a pilot, now.
How is it equal support, when F# doesn't support modern Windows?
They already have it working on Android and iOS... I'm not getting your point. 
&gt; It's targeting just desktop which is more and more diminishing type of machines and provides 0 story for mobile devices It's targeted at Desktop, Xbox, Mixed Reality and IoT. What's the problem in targeting that? 
Yes, exactly.
As a daily and "industrial" user of F#, I strongly disagree with you, and I think that /u/phillipcarter2 has been a great advocate and member of the F# community.
I guess you got lucky, fsi breaks fairly often as do many other parts. F# is not tested before mono is released so your always running the gauntlet really.
Tensor you should take some time out from this forum. Your behavior on this thread is really immature and you are now boosting up your posts and down your enemies' posts with fake votes. This forum is a place where people come to converse and learn about F#, including professionals.
I have a small team. We have been working on maths software in F# for a couple of years. Lessons, graphing, assessment, Plan to be in it for the long term!
[Just Send Your Cash!](https://youtu.be/ibMf68i4rz8).
I've been interested in using OCaml a few times over the last few years, but find the lack of libraries for common tasks thwarts me each time. Specifically there doesn't seem to be a common library abstracting, or even much support for, relational databases. The other area I find lacking is web frameworks - oscigen with its slow semi broken website has never filled me with confidence.
Mark's blog are great. The follow one really is it for me. Composing a system from functional modules is the way to go. http://blog.ploeh.dk/2016/03/18/functional-architecture-is-ports-and-adapters/ 
+1
Ok. Of the top 25 posts on /r/dotnet only 4 mention .NET Core and [Google Trends](https://trends.google.com/trends/explore?date=all&amp;q=%22.NET%20Core%22,.NET%20Framework) says .NET Framework is still a much more common search term than .NET Core. 
Thanks. You can also fix it via Tools\Options\Environment\Keyboard searching for moveup etc.
&gt; including professionals But mostly OSS hipsters. Hee hee... :-)
&gt; This subreddit is literally irrelevant Then why are you scribbling all over it?! 
I'd like to understand /u/k_cieslak's point of view and I can only do that by conversing with him. The thread actually proved quite productive. 
Excellent, thanks.
The main thing I'd like in the F# language is support for inline parsers but tooling is my bugbear: I'd like VS2017 to be as solid as VS2015 was. I don't care about fancy features, just rock solid support for all the basic stuff. 
Right now posts 1,2,4,5,8,9,10,21,25 are directly related to .NET Core. The rest are agnostic to Core vs Full...
&gt; "hipsters doing OSS" is another not important group of people Nobody is saying they're not important. I said it is disingenuous and counter productive to pretend that the software they lash together as a learning exercise is industrial strength. The Haskell community made this same mistake and it cost them dearly. 
When I first read this thread I thought you were being ridiculous but now that I look at /u/k_cieslak's comment history I'm starting to see what you mean. For example, when people ask for UWP support for F# so they can use F# to write commercial Windows applications in the future his reponse is to tell them that all of these MS technologies are dead and advise them to compile F# via Fable to Javascript and then integrate that into Google's Electron to create a cross platform app instead. From my perspective that's insanely bad advice. 
&gt; Also, it is worth noting that the library in question is actually a code generator that generates code that interops with AWS so it only needs updating when they change the interop language, i.e. very rarely. That is a well engineered solution to JSON+HTTP API shims: autogenerate them. I’m not super huge AWS user, but on Azure they announce and release new features every couple of weeks. I’d expect that in those 2 years since last release of the library there were some new features and services released on AWS. Anyway, I think we focus too deep on one particular example of something that is actually worrying - really low support for OCaml from any external vendors, and too small community to make it up. &gt; The examples you're giving aren't libraries that do any non-trivial processing. All they do is take a procedure call and (mostly) turn it into a JSON message to send over HTTP. Firstly, that is trivial to do from any language so the shim is of minimal value. Secondly, most of the libraries you've cited are monkey work that should have been automated. So they are either examples of bad engineering or they aren't the source code. The AWS bindings you cite are almost certainly autogenerated because they will be descended from our original OCaml bindings that autogenerated both interfaces and documentation in multiple languages. Some of those libraries are simple HTTP bindings, some are more complex like Database drivers... those were just examples. And yes, probably any F# developer as skilled as you would be able to write some of those, and others are indeed just “monkey work”... but I think most developers are expecting such libraries to exists in mature, industrial ready ecosystem, so they don’t have to not reinvent the wheel, to not waste their time that should be used on solving problems if the business, not on writing communication wrapper around popular tools. &gt; The only advantage of the CLR in the context of interop is mature high-level memory safe bindings to unsafe C libraries like OpenGL, DirectX and others. The killer example of this was WPF which was far better than anything OCaml has. But now it is dead. And in the new web-based world .NET has no such major advantages. Literally none of your examples leverage the CLR's sole advantage. I think you are pushing your requirements as an requirements of everyone. People write different applications - some needs WPF, some needs specific CLR advantages... other just are happy quickly writing their intranet business apps in rich ecosystem in which integration with most tools, databases, services is done by adding NuGet package so they can solve business problems instead of focusing on technical ones. &gt; You're misrepresenting me. I'm not saying that the F# ecosystem has a problem because I found one library that has bugs. I'm saying the F# ecosystem has a problem because I find *most* of its libraries to be too buggy for serious use, i.e. poor quality is a general trend here since F# went OSS. I mean, we’re just ping ponging same argument whole time - I can just repeat myself that many people are using those libraries in commercial applications and they don’t find them terrible. I guess the obvious question is why you stick around F# complaining so much on social media if the ecosystem is clearly not fitting your requirements? Maybe it’s just time to move on to the greener pastures? &gt; I'm sorry but F# is nowhere near being an "industrial standard". The F# ecosystem has been shrinking since VS2017 was released and it will continue to shrink until Microsoft fix F# in Visual Studio. .NET was the dominant platform but, from what Philip Carter was saying, the .NET Framework is abandonware and, of course, .NET Core isn't competitive (and I don't see how it will ever be). F# is tied to a ship that is currently sinking. This is not true according to any telemetry I have access to ( usage statistics of tools I’ve created, hits on their webpages etc), nor in my business experience as consultant. Also Phillip in [his blog post summing up year 2017](https://hackernoon.com/reflecting-on-f-in-2017-5ac67fb138ff) is writing (based on MSFT telemetry data which is way better data source than “feelings” of either me or you) that F# is growing and especially in .Net Core market... so unless you’re accusing him of lying there is absolutely no data to proof “F# ecosystem is shrinking” statement &gt; Do you really think that the majority of vendors are more interested in .NET Core than Linux? I think vendors are interested in both Linux and .Net Core - for example AWS SDK supports .Net Core ( and again that’s only an example). Also with .Net Standard 2.0 reusing existing .Net Full Framework libraries on .Net Core is super simple. 
&gt; &gt; I said it is disingenuous and counter productive to pretend that the software they lash together as a learning exercise is industrial strength &gt; OSS is done as learning exercise That is literally not what I wrote. 
Isn't .NET Core unstable and slow too? 
The current F# direction has rendered the language practically useless for many developers. Electron apps are resource heavy, and unlike UWP apps, don't allow for suspending their process in the background and don't support the modern fullscreen handling and have bad pen support. All the Electron apps out there are a disaster for battery powered Windows devices, let alone 2-in-1 and tablet users. I also need low level DirectX access in my UWP apps.
Thanks for that SAFE bookstore example. That’s exactly what I was looking for. I’m going to keep on with suave as I don’t necessarily care about performance right now. 
&gt; Sounds like the F# team are placing their bets on .NET Core on non-Windows so I don't think we'll be seeing anything like official DirectX bindings any time soon. Only .NET Native support for F# is needed, then I could use SharpDX inside UWP apps. 
Is that HLVM by any chance? :)
Actually no. HLVM was a high performance target for languages. This is quite the opposite: a language front-end targeting the web. Some characteristics: 1. Very simple core ML with unit, int, tuples, unions and pattern matching. 2. IDE with color syntax highlighting, error throwback and clear error messages. 3. REPL with native support for color and graphics. 4. References dependencies directly in source form on Github. My primary objective is to make a tool that can be used for education. A secondary objective is to turn it into something my companies can use to build web apps. Having written HLVM I have designed this language to permit easy compilation to high performance native code but that is a very low priority. Also, as this is work related I'm hoping to pull some developers from work in. 
I don't find it buggy at all, at least Ive never had a seg violations like get quite commonly in mono. It also seems faster to compile, compiling the compiler in .Net Core is around 1 minute faster than mono.
By the way are you using the new .fsproj files? You can tell by looking at the files and asking "is this a mess?": the new ones aren't. Package references have improved as part of this (dependency management in particular). This MAY be tied to .Net Standard, but you can run .Net Standard 2.0 projects on the .Net framework. Just a heads up. Don't ask me for more details.
Yes we will have this; we are integrating MyScript for handwriting. We use Xamarin Forms for UI and hope to target UWP when that is possible; otherwise we will need to build a temporary WPF UI.
I've been working on a ("serverless" platform)[https://prolucid.github.io/FsShelter] since before "serverless" became a thing and we've had good experience with it over the last several of years. Local debugging, no cloud vendor lock-in, no billing per message, low latency and pure F# dev experience. Released netcore20 version of it a few month ago and seen 2x speed up when running on a cluster, 4x speedup when running in-process, compared to Mono.
This is why I find this UWP resistance so baffling. It's due to UWP and the new form factors that it enables, that I'm still excited about Windows.
There’s now caqti (abstraction over RDBMSs) and opium (Sinatra-like web framework).
I don't use Windows so its not relevant. I think in this modern age cross platform solutions would be the obvious choice.
how do you do development without fsi on .net core? do you development on windows or with mono and then do final resting on .net core? doing development without a repl is a lost cause, in my opinion.
You are not passing the transaction into the query. The second parameter for dapper's Query method is an ojbect for all the SQL parameters. You should be using the following: conn.Query&lt;User&gt;("select * from Users where Id = 1 ", transaction = trans).FirstOrDefault() 
Wow! His goals are much loftier than mine but extremely interesting...
Its hardly indicative of a cross platform language if no work occurs on non Windows components. Work on Language and cross platform tooling would be my aim. In fact I tried several times to combine the steams so cross platform tooling became easier, I helped with the creation of the FSharp.Compiler.Service which allowed different tool client so share access to the compiler infrastructure. I think work along those lines that benefits everyone is really important.
I have just upgraded to VS 2017 15.6.1. In the Git commit history when I open the diff for a changed file I get "failed to start the configured compare tool". The problem is for .fs files, others seem to be opened fine. Is it just me or it is a common problem?
Are you using that approach in a non-toy project size? Did you find any problematic aspects?
Yes, I've used done it in a production risk system and also in a more general asset management platform. It take a bit of getting used to to consider your database, all feeds and UI as the same external layer. Very different project structure, data access layer moving the most. Up side is it more easily generalizes so portfolio and risk modules can be used for portfolio optimisation more easily say. Nothing majorly problematic. It all become more event based at the external layer. You could say that makes integration testing harder but not really compared to mocking dependencies.
&gt; I was just thinking about cross compiling the core of it for QA purposes: so a server could repeatedly check that nobody has broken the web API it relies upon. This is actually a perfect scenario that .NET Standard was created for! It also buys you a bit of future proofing, should you choose to do something like incorporate a .NET Core backend if it's applicable. The code will be able to trivially be incorporated just by adding a reference to the project and calling it good.
&gt; Is there any downside to doing that? Error messages will be 2x more convoluted. 
&gt; Is there a way around this? Two ways: 1. Make them mutually recursive. 2. [Untie the recursive knot](https://books.google.co.uk/books?id=Sjt54L6hueYC&amp;pg=PT144&amp;lpg=PT144&amp;dq=f%23+untie+recursive+knot&amp;source=bl&amp;ots=sFnO7tm2E3&amp;sig=c-mJGpXii-3MwINjvQrCPV9z5Ow&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwjfn4zg7unZAhVHCMAKHd3eArUQ6AEIQDAD). 
https://insights.stackoverflow.com/survey/2018/#top-paying-technologies is the direct link to the specific section. Note: No idea what the sample size is here. I believe that they will release their data in the coming days, at which point F# devs will likely dive into the data ( with Type Providers? ;) )
Interesting, another reason for me to get into F#. Looking forward to devs thoughts on the data.
&gt; No idea what the sample size is here. They cover that in [the last section](https://insights.stackoverflow.com/survey/2018/#methodology): &gt; This report is based on a survey of 101,592 software developers
If anything the salary section says to me that the language you use doesn't matter. The difference between high and low on the list is $20k worldwide, $17k in the US. BUT that's probably only looking at averages. The F#, Erlang, etc. jobs probably are in more specialized fields that pay more, but there are also probably the same high paying javascript and python jobs out there, its just that there are fewer of the low paying Erlang and F# jobs.
It's great, but on the other hand it's also probably in large part because F# has trouble expanding beyond its finance niche, and that makes me sad.
Not really. My previous work was bookmaker company (worked with Betradar), where F# excels as superb data-processor (Akka.Net + F#). At present I am working on innovative ads where F# works as ETL backend (scrape, aggregate, publish). And I know guys who works on Etherium (blockchain), music streaming and video streaming. So definitely not only finance. Moreover none of offers I got were from finance area
It's spelled 'Ethereum'.
oh fuck, really?..
Seems like my anecdotal evidence disagrees with yours, for what it's worth. I'm not on the market for a job right now, but I still receive occasional offers on Linkedin, and every single F#-based one is in finance. I've never worked in finance, so it's not like they get my profile based on my history.
At least in the US market (which we can tell from telemetry is the largest), I anecdotally see pretty varied places where people use F#. Lots of focus on web services. Finance itself is also a bit varied. Anecdotally, it seems the London area is bank- and quant-focused, which I think most people would think of as finance. I've also spoken with F# developers who are _technically_ part of the finance industry, but are doing other work (web services, ML, CRUD work on databases with domain logic, etc.). I imagine there's a lot more variance across Europe, but my own view of it is limited to basically London and what other developers tell me :).
The way I see this is that developers who use a functional language (such as F#) correlate with developers who get paid more. Perhaps developers who know FP are worth more? It's not clear if the respondents are using an FP language for work (the description was a bit vague on that), but it's a promising correlation and I hope it helps drive more people towards learning FP (and F#).
Yes this. Corollary to the “Python Paradox”. 
As far as an employer is concerned - worst possible metric to be winning :/
Railways? In the UK? I've always been interested in National Rail, but have never quite worked out how they recruit for/commission their software.
Published two years ago. Installed 4 times last month. [Last commit](https://github.com/inhabitedtype/ocaml-aws) to master 1 year ago. I opened [an issue](https://github.com/inhabitedtype/ocaml-aws/issues/18) there 1.5 years ago, there's a [6 months old unmerged PR](https://github.com/inhabitedtype/ocaml-aws/pull/34) that fixes it. On F#, you can use the [official toolkit](https://aws.amazon.com/visualstudio/).
&gt; I'm not familiar with them but going to the Opam repository and searching for AWS I get this which seems to cover everything. It covers 9 AWS services out of about a hundred.
I used Hopac for something last year. These tutorials are great, they would have saved me a chunk of time if they were available back when I started using it.
Agreed. Too bad Hopac is dead for 2 years.
&gt; It covers 9 AWS services out of about a hundred. No, it covers everything that the botocore API definitions cover (same as Python) because it is a code generator: "ocaml-aws is an Amazon Web Services SDK for OCaml. Its source distribution includes a core runtime API and a code generation tool that generates individual libraries from botocore service descriptions." Same as Python. As I said before, interoperating with AWS without a library is trivial anyway so this discussion is pointless: these "libraries" just generate trivial JSON messages and send them over HTTP. You don't need 100 separate Nuget packages to do that... The fact that [Nuget offers 820 different AWS packages](https://www.nuget.org/packages?q=AWS) that are all slightly different concrete implementations of the same abstract API betrays design flaws in the entire .NET ecosystem. Pretending that is an advantage over OCaml is disingenuous. 
&gt; No, it covers everything that the botocore API definitions cover Lol I wish. It generates modules for the following AWS services: * autoscaling * cloudformation * cloudtrail * ec2 * elasticache * elasticloadbalancing * rds * sdb * ssm * sts The [full list of AWS services](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_actionsconditions.html) is a bit larger.
&gt; It generates modules for the following AWS services: Sure but the heavy lifting is done by the code generator that (AFAICT) eats generic botocore definitions and isn't specific to those services. &gt; The full list of AWS services is a bit larger. So is the [list of botocore API definitions](https://github.com/boto/botocore/tree/develop/botocore/data). 
I've heard that elsewhere too, and I'm curious as to what aspect of it is dead. I know the main dev moved on to other (Javascript ?) pastures, but the software itself seems to still work for me. Are there many unaddressed bugs?
You mean they might have to run the code generator? 
What is missing?
This is likely with an older nightly build (a reported issue demonstrated this on nightlies only). I fixed an issue with loading diff tools in an F# editor for the latest nightly a fee days ago, so if you upgrade your nightly build it should be good to go
When you run the code generator on the botocore files for the other AWS services what, if anything, is missing? The services that are bundled seem to be entirely autogenerated... 
`make gen` only runs on the services I listed.
Can you file a bug on [github](https://github.com/Microsoft/visualfsharp/issues) with full context? The issue template will have sections where you can fill out helpful information. Thanks!
Hmm...Java isn’t on the global list and C# isn’t on the U.S. list. Interesting.
15.6.{0,1,2} were the worst releases in VS's history so far. Even our C# devs started to complain about VS in the last few weeks. It feels like we stepped into every single bug they introduced and spent days getting our projects alive and compiling (mostly problems with references, lost/incorrect project dependencies/build order, nuget,..). Worst of all - I didn't even get the time to look at all the F# goodness yet.
framework is very well written, but it seems except minor fixes (like change paket.bootstrapper.exe) nobody able to maintain it.
okay okay
Try running the example algorithm by hand on a piece of graph paper. Key points of the example: * The example invocation passes `len` of `512` (`2^9`) to the outermost layer and always passes `len / 2` to the second layer of recursion. * The base case is `len = 32` (`2^5`). * You can scale the algorithm draw in blocks other than 32px by changing `len &lt; 33`.
Comment here to let me know what topics you'd be interested in hearing about in the future!
I'll consider that to be a stretch goal :)
Contributors/Users talking about interesting projects. Made with F# or for F#. Tooling/infrastructure/ecosystem is the first aspect newcomers are confronted with and even old farts have to keep up with. How about Steffen Forkman or Matthias Dittrich talking about paket and or FAKE. Also history and future of the language itself is always welcome: Tomas Petricek, Don Syme? Mark Seeman talking about functional concepts and similarities to OOP and design patterns. About the community in general - episode 3 is on spot here. In general it's a good idea to let the people involved in the projects to do the talking by asking just the right questions. They have deep knowledge and some stories to tell. You knowing about the topic certainly helps for a better conversation but cannot an expert everywhere. BTW: why do you beep out words? It's not like you're in public TV...
beeping out - mostly because it was fun to learn how to do such in Audacity :) Thank you very much for the input! I'm hoping to grab infrastructure-level people soon based on my own thoughts in combination with input like this.
Why are you using mono on Windows?
I am using it in my class and our teacher told us to use mono. I do not know why 
yes, unfortunately it is. 
I don't think that graphics is a strong point of either. But both are very similar in the sense of syntax. However F# feels a bit more modern and it is a .Net language, so you can have all you graphics wrapped in C# and the backend logic in F#. 
F# by far because when you want to actually make things you have dotnet at your disposal
So I was able to solve this by grabbing an old project of mine and just renaming it and clearing everything out. But there has got to be a better way! 
The desktop app templates got replaced by the core templates in the last VS update. You have to go to the Visual Studio Installer and make sure "F# desktop language support" is selected.
This is not quite accurate: .NET Standard and .NET Core templates hadn’t existed and starting with 15.5, are now installed by default any time .NET Core is installed. Prior to this, any F# support of any kind was optional and you had to turn it on somewhere. However, there was a bug where previously-selected desktop F# support was turned off by default. This, you need to go in an enable it again to get the classic F# templates.
:( Sorry to hear that. Wish I could help. Hopefully you can get it sorted out.
You can change a .NET Standard template. There’s just no UI for it. You can open the project file (no need to unload) and change the target framework to net46 (or whichever you like) and then it’s a .NET Framework project using the new SDK-style project system.
Think an active pattern is what you are looking for yes: ``` type AST = | A of int list | B of int list | C of string | D let (|ABPart|_|) ast = match ast with | A xs | B xs -&gt; Some xs | _ -&gt; None let patternTester ast = match ast with | ABPart xs -&gt; printfn "Got an A or B with %A" xs | _ -&gt; printfn "Not an A or B!" let astA = A [1; 2; 3] let astC = C "just a test" patternTester astA patternTester astC ```
I can't speak to the compiler side of things, but if you're wanting to do graphics work I think F# might be a good fit because Xamarin maintains good .NET bindings for Metal in Xamarin.iOS and for Vulkan in VulkanSharp. * https://github.com/mono/VulkanSharp * https://developer.xamarin.com/api/namespace/Metal/ | https://developer.xamarin.com/api/namespace/MetalKit/
The old .NET Framework project templates are installed separately in VS2017. In the installer, under "Individual components", you need to select "F# desktop language support". Or you can create a .NET Standard or Core project and change the target framework in the project file, like /u/philipcarter2 said. Editing project files by hand is a much better experience with the new project system -- there's little to no boilerplate in the file, and you don't need to unload/reload the project in VS.
Not sure if you're the same person, but there was the same question on ReasonML discord yesterday. If you go with OCaml and/or ReasonML there is reprocessing to do graphics. You can even cross-compile it to windows, osx, iOS and Android. I'm coming from JS -&gt; ReasonML and now want to pick up F# as a C# alternative for work. Looking at examples F# seems really similar to OCaml and I think learning it will mostly be a question of learning the ecosystem.
perfect, thanks. I had an intuition that active patterns would come to the rescue here. Then I have just one spot to update as more ops are added. 
thanks everyone for the tips
It's mono-only though.
.net core, so it's cross platform.
https://github.com/SAFE-Stack/SAFE-template/issues/45
We use UWP at work. It's shite. Why would you want to combine F# with UWP?
Quick follow-up: I have digested these suggestions, and have adjusted the course of WTF# slightly, given such. Thank you for your input - every optimization helps.
It is paid extension by the way.
How did this work? I saw they have license keys, but does the extension phone home every now and then to make sure it's valid?
Cool thanks. I appreciate all the work you've been doing in the community
Monadic combinators? &gt;&gt;= &gt;-&gt; and so on
Kinda looks like Rider has no permissions on those folders? So maybe set permissions on folders or run Rider as administrator?
The error message is coming directly from paket. Even if I run it in a powershell with admin rights...
I used to use the emacs integration when learning F#. It was a bit of a struggle since I was only mediocre with emacs as well. I would really recommend asking your professor about using vs code+ionide. I believe mono still works with it, and the product is free, cross platform, and open source. Is it possible that he/she just isn't aware of it's existence? It's seems a much friendlier solution for students than emacs (especially since you're not using a lisp-based language). 
The error message is coming directly from paket. Even if I run it in a powershell with admin rights... 
The way I got started with a learning project was to install Visual Studio Community and follow the online documentation for its Hello World console application. Since it's a self-contained system, everything just works.
I like to make one object to hold all of the graphics resources, then initialize it like you're doing. That way you only have to do this once. type GameAssets = { spriteBatch: SpriteBatch; myTex: Texture2D } type Game() as this = inherit Game() let graphics = new GraphicsDeviceManager(this) // If having to unpack the option type everywhere (e.g. using Option.iter) bothers you, you _could_ just make this null. But beware. let mutable assets = None override g.Intialize() = assets &lt;- Some { spriteBatch = ...; myTex = ... } // etc (I didn't make sure this compiles, but you get the idea) Or maybe combine that with /u/OmgSzer's idea and make the field: let assets = lazy { spriteBatch = ...; myTex = ... }
Since the issue lies with copying files to (and from?) the packages folder, perhaps disabling it could help you: https://fsprojects.github.io/Paket/dependencies-file.html#Disable-packages-folder
This is an area where the received wisdom of the F# community is not good. Paket is not right for beginners. Paket has a steeper learning curve at the beginning than F# itself. Paket is suitable for advanced use, projects with complicated dependencies, or if there are specific limitations of Nuget. Getting started with F# in the way you want could not be easier. Download VS2017, making sure to tick the F# boxes. Create a new .net core project. Install the FsLab and Deedle packages via Nuget. That's it.
I did nothing other than installing the IDE, installing the F# tools, creating the project from inside VS community and running the main file (without even importing anything). When I run the standard main file I get warnings that "the packages weren't restored with the target framework for the project (.NET Core) but with .NET v4.6.1" and that "the package might not be entirely compatible with my project". Also, for some reason the RTypeProvider complains about "an error while reading from an IPC-Port". And further that "the referenced assembly RProvider.dll has the attribute [...] and that couldn't be any public type provider classes found". Might this be the case because I don't have R installed? (*Edit: I seem to have checked the box for R support...*) This would be strange as I'm not importing anything. Honestly, this already turns out to be more frustrating than I expected it would. 1&gt;------ Erstellen gestartet: Projekt: ConsoleApp2, Konfiguration: Debug Any CPU ------ 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "Deedle 1.2.5" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "Deedle.RPlugin 1.2.5" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "DynamicInterop 0.7.4" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "Foogle.Charts 0.0.5" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "FSharp.Charting 0.90.14" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "FSharp.Data 2.3.2" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "Google.DataTable.Net.Wrapper 3.1.2" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "MathNet.Numerics 3.13.1" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "MathNet.Numerics.FSharp 3.13.1" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "R.NET.Community 1.6.5" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "R.NET.Community.FSharp 1.6.5" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "RProvider 1.1.20" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "Suave 1.1.3" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "XPlot.GoogleCharts 1.4.2" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "XPlot.GoogleCharts.Deedle 1.4.2" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;C:\Users\barkonnen\source\repos\ConsoleApp2\ConsoleApp2\ConsoleApp2.fsproj : warning NU1701: Das Paket "XPlot.Plotly 1.4.2" wurde nicht mit dem Projektzielframework ".NETCoreApp,Version=v2.0", sondern mit ".NETFramework,Version=v4.6.1" wiederhergestellt. Dieses Paket ist mit Ihrem Projekt möglicherweise nicht vollständig kompatibel. 1&gt;FSC : error FS3053: Der Typanbieter 'RProvider.RProvider' hat einen Fehler gemeldet: Der Typanbieterkonstruktor hat eine Ausnahme ausgelöst: Fehler beim Lesen von einem IPC-Port: Die Pipe wurde beendet. 1&gt;FSC : warning FS3005: Die referenzierte Assembly 'C:\Users\barkonnen\.nuget\packages\rprovider\1.1.20\lib\net40\RProvider.dll' verfügt über das Attribut 'Microsoft.FSharp.Core.CompilerServices.TypeProviderAssemblyAttribute' auf Assemblyebene, es wurden jedoch keine öffentlichen Typanbieterklassen gefunden. 1&gt;Die Erstellung des Projekts "ConsoleApp2.fsproj" ist abgeschlossen -- FEHLER. ========== Erstellen: 0 erfolgreich, 1 fehlerhaft, 0 aktuell, 0 übersprungen ==========
I resolved the issues with access denial but they were unrelated to FsLab in Vs community. I still can't run the main file as soon as I install FsLab... Same errors as in the other comment. I just don't get it.
Sorry you had such a struggle with this. I don't think FsLab has been updated for .NET Core/.NET Standard - [example](https://github.com/fslaborg/Deedle/blob/master/src/Deedle/Deedle.fsproj). Attempting to resolve dependencies for .NET Framework on .NET Core will do the following: 1. Attempt to resolve what it can (e.g., with .NET Framework as a target rather than .NET Core) 2. Unless you're lucky and the projects were just authored poorly and/or transitive dependencies have issues, fail unceremoniously. The Type Providers used by FsLab are not updated to work on .NET Core, so you'll likely just observe a horrible failure for that even if dependency resolution worked just fine. Additionally, FsLab is not simple, and starting out with it involves numerous new concepts: * The notion of different target frameworks * Enabling 64-bit mode for F# interactive so interoperation with the R runtime works * Paket, an alternative package manager * Deedle and other projects with a high concept count, especially for a beginner to F# Instead, I'd recommend using the IDE to new up a console app and run through some of the basics covered in [F# for Fun and Profit](https://fsharpforfunandprofit.com/posts/fsharp-in-60-seconds/). Only when you're comfortable with the concepts of F# and .NET in an IDE would I recommend moving on towards using more advanced tools like FsLab in an IDE. &gt; Even languages like Haskell or Clojure were a breeze to setup, configure and use, even with tools like Spacemacs. &gt; &gt; Well, this ends my interest for F#. Nice idea but bad execution. Now it's becoming clearer to me why it's not more widely used. Although I agree that the issues you're running into are particularly heinous and would be vexing to even F# experts, I don't think this is a fair comparison. Setting up a basic Clojure app with something like Leiningen is no different than [using the .NET CLI to create a new F# project](https://www.microsoft.com/net/learn/languages/fsharp/get-started/macos), or File | New Project in VS/Rider/VS4Mac/Ionide. What you're attempting to do in F# is an order of magnitude more complex than setting up Clojure or Haskell with the respective build and package management systems. It's certainly more attractive (console apps are kind of boring after all), but with that comes a mountain of complexity and assumptions about how F# and .NET work. That said, if you're finding the .NET CLI difficult to work with, I _really_ want to know about that. Basic stuff like a new console app project with a CLI should be dead-simple, and if they're not then there's clearly something wrong. Sorry you had such a bad experience. Hopefully you decide to give it another go.
Well, the first few things that I try with any language is setting up the environment and just running an example project. That usually gives me a rough overview over the situation. In this case, nothing at all worked. It would certainly make sense if FsLab etc. haven't been adapted to Core yet. Still, that wasn't obvious to me at all. My comparison wasn't just about the setup process with Leiningen or Stack, I've done more in those languages than that and it worked more or less fine. In any case it didn't come close to this. I already went back on this statement because I wrote it when I was angry: &gt; Well, this ends my interest for F#. Nice idea but bad execution. Now it's becoming clearer to me why it's not more widely used. but the first part still stands. The only reason why I tried F# in the first place was because I had heard good things about it but this has been ridiculous. I wanted a modern ML and F# seemed very promising. Maybe I will give it a try again some time, not sure though. Thanks for your detailed answer though.
I want to use .NET Core because I want to be able to work on Linux as well. From what I've heard Core is supposed to provide that. If F# support in Core isn't sufficiently advanced yet then I can't really use it anyway.
I wrote a super simple authorisation boilerplate project for ASP.NET Core not too long ago that quite a few people liked ([here](https://github.com/matthewblott/simple_aspnet_auth)) so I'm currently doing an F# version.
Writing my first F#/Android project, a simple "get Bing's daily wallpaper to use on the smartphone". Everything seems to be working fine but I'm having a really bad time with xamarin's GUI designer, probably due to my lack of experience.
Thanks, now the REPL works. Do you by any chance know how I can do things like "open Akka.FSharp" or "open Foogle" in the REPL that are installed in the project as dependency?
I think I do :) So, REPL is just another "small runtime" so you have to point it out what DLL you are going to load in it. So it has such syntax for it: `#r "../packages/Akka.Net/Akka.Net.dll"` (absolute or relative path is ok) In case Akka.Net makes some call from transitive dependency you will need to load that dependency (e.g. Newtonsoft.Json or whatever). For VS Code there is nice extensions `refsharp` which could generate all these `#r` calls from project dependencies.
I'll have what this guy is having!
That seems great but now I get this: .\.paket\paket.exe generate -load-scripts --framework net45 Paket version 5.155.0 Could not detect any platforms from 'sl3-wp' in 'C:\Users\mgyt\RiderProjects\ConsoleApplication2\packages\FSPowerPack.Core.Community\Lib\sl3-wp\FSharp.PowerPack.Compatibility.dll', please tell the package authors Performance: - Runtime: 1 second Paket omitted 7 warnings similar to the ones above. You can see them in verbose mode. 
I don't get it, something I did apparently changed something and now I can't run a fresh project with .NET 4.7 created from Rider. .NETFramework,Version=v4.7.1.AssemblyAttributes.fs(2, 26): [FS1108] The type 'ValueType' is required here and is unavailable. You must add a reference to assembly 'System.Runtime, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'. With 4.5 and this argument in the run config I can run a new project: --mscorlibAssemblyName System.Runtime Why is this so difficult with F#? :/
F# is uses in some algo trading firms, doing back end logic. I've also used it with xamarin after some work, which is what I believe jet.com uses for their app.
netbalancer.com uses F# for interop, data storage, statistics and reporting. (I'm the author)
Derivative pricing in certain banks.
why people think f# is great for finance? because of functional, concise code?
I've used it for web apis, data processing, one-off scripts, database work, and testing over my career. It's a solid general purpose language whose feature set and syntax make it easier to write correct, legible code the first time, and drastically reduce time to final product IMO
OCaml &amp; F# are somewhat close. OCaml has been successful for Jane Street, so I'd say if it works for OCaml, it works for F#
Jet doesn't use Xamarin for their main iOS and Android applications, but it's used for a few internal applications (one for a pilot project to have employees deliver packages on their way home, and one to show various financial stats to investors).
I think a big role plays the 'unit of measure' feature which makes the finance juggling code a bit more safe.
im a quant, we built our pricing library with F#, we have a F# to CUDA compiler for GPU pricing. later we added some F# based web apis using Swagger. Works like a charm. Why are u asking? Where are your interests?
In short: Numbers. When an industry is largely about numbers, you'll find a lot of functional programming usage in that industry. The functional programming paradigm is inspired by higher order functional mathematics. Finance is all about numbers with little in the way of typical programming state - so we don't need (as much) objects or classes for managing state, we just want to compose functions to perform calculations. "Huge" algorithms to calculate the risk on capital bonds, or crunching the compound variable interest of a whole book of collaterelised mortgages, or longevity trend risk when assessing the viability of underwriting an insurance contract, Al have little to do with anything but raw numbers. 
Just finished a DSL parsing library for our project using fparsec. 
those terms aren't equivalent. the second one \` c * ( u / (c * c)) is equivalent to (c * u) / ( c ^ 3) &lt;=&gt; u / c ^2 which does not equal u / c
Your running into integer division issues. For example: 9/2 = 4 AND 8/2 = 4 This is true for all of your examples.
Wow, that's quite nice! Thank you &lt;3 Do you know anything about DbC inside F#?
I think refinement types are more interesting here - but yes you can play with this in F* too (look for refinement types here: https://www.fstar-lang.org/tutorial/)
Also one other I want to ask is whether any new GUI libraries have been developed for F# in the past 1.5 years? I asked a similar [question](https://www.reddit.com/r/fsharp/comments/4qsodm/what_would_be_the_best_way_to_make_guis_in_f/?st=jfjkaybq&amp;sh=a1c1b167) two years ago so it should be time for an update. I am not sure whether it shows up on the top of Google search for others, but it does for me.
[This seems](https://github.com/Prolucid/Elmish.WPF) new. Has anyone tried the new Elmish related libraries in practice? If so, what did you think?
Was going to suggest this one. I'm admittedly biased, but I've enjoyed using it on several projects. IMO the Elm/Elmish architecture is much more idiomatic to F# than something like MVVM, leveraging immutability and functional bindings instead of OO plumbing. That being said, WPF will limit you to Windows. You could also check out the [web version](https://github.com/fable-elmish/elmish) of Elmish that compiles F# into JavaScript.
Also: * Single field records. * Phantom types. 
I'll surely give it a try. After mulling it over for a while, I think I will do the GUI in F# itself as the lack of IDE support and having to use macros for interop would make it 5x harder than it would be otherwise. I'll put it on a separate thread and use message passing to communicate with it.
You may want to look beyond the F# community when it comes to this question. Last time I checked, F# people were still doing stuff like data binding, templates, etc, and a lot of other communities have developed much better approaches in the last 5 years.
i would love to use f# on any project internally that uses python. you see all these cool projects, and then you find out people are using python and are completely committed to it. :(
Take a look at Hopac. It can convert to/from async when needed to work with other libs. And I’m using it in conjunction with GUIs, no sweat. 
@isak_s, Can you expand on this a bit? I've used F# only for algorithms, data processing and I'm looking to make my first applications (web or otherwise). I'd like to start learning the best practices of today rather than the ones from 5 years ago. What are the alternatives to the methods you mention above and what frameworks would you suggest I start with? 
First step would be to gain an understanding of [how plain React works](https://www.youtube.com/watch?v=-DX3vJiqxm4). That is one of the biggest innovations, and a lot of people underestimate how different it is from the older data-binding or KVO type approaches. Once you've done that, learn how to do state management in a non-trivial React application. The state of the art is to have all (or almost all) of your state in 1 structure, which can be hard to achieve. The community that has developed the most ergonomic and productive solution to this is ClojureScript with re-frame, in my opinion. F# also has a contender in this category (Fable-Elmish + React) that I haven't tried yet (*). Though if it is anything like Elm, I worry that it could be a bit verbose. In the benchmark I posted above, the Elm version is 3x more code than the re-frame version! `*` not WPF Elmish, that is very different
Do you have a link to more information on the CUDA compiler toolchain ya'll are using with F# or any other info you can provide on this? This sounds really cool.
A bit; I was wondering more about whether the behavior is the same to the end user in terms of input and output, even though the program flow is slightly different. I think that input/output behavior is indeed the same.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/kjnilsson/fez) - Previous text "Fez" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dx0s96q) 
Microservices on .net core with Akkling &amp; Kubernetes. Type providers make lots of service-oriented code easy mode.
Please open GitHub issues or jump in to [Gitter](https://gitter.im/dotnet/orleans) and ask if you're running into trouble - I'd be very happy to help. For F# support in particular, check out [Orleankka](https://github.com/orleanscontrib/orleankka), which sits on top of Orleans and provides a more F# friendly interface.
I havent used it in the last few years - but couldn't you just compile the C code with managed C++ (or C++/CLI or whatever it is called now)? We used huge amounts of C/C++ code that way a few years after .NET came out. It worked really well - we didn't have to modify the C code in most cases, just add a few ".NET wrappers".
It's just called VisualC++, and yes, you should be able to use the C/C++/C# code with thy F# code without any real difficulties. I think C just needs to be compiled as a separate library that can be referenced, while C# and Visual C++ can be used inline.
Wrapping the code/interop isn’t an option (*see first sentence*). It needs to be translated from C to F#. First thing I did was use PInvoke, but it is not suitable in this instance. The parts I have already translated are running better and are much more maintainable. 
Not yet, no. F# interactive doesn't quite work on .NET Core yet. You can technically get it to execute basic F# code, but anything involving references will go **poof**
So I think I may have not been terribly clear - I am having no problems actually translating the code. My question is what to do with the headers. There is one header file that contains a struct with types in it, and I’m wondering if that’s something I need to include from the header? Can I just use the preprocessor with the h and c files (gcc -E) to mash it together and translate from there? It’s the *approach* I’m curious about - believe me I would have given up if the actual translations were the problem 🤮.
C++/CLI is not P/Invoke. If your use case is maintainability through a rewrite in F# that won't help of course.
Can't you hardcode the reference paths using \#r 'path/goes/here'
Oh to bad :-( i so wish that MS would pump more money in to F# . C# is a good language but it's so nice to code in f#. If I had more time I would contribute myself. Perhaps in the future . 
Assuming you are doing a rewrite and backward compat isn't a concern, the concept of "headers" is meaningless. In C you need headers to share the shape of binary API between the implementer and the consumer. In .NET the shape of the interface is available *with* the implementation.
Not sure how this relates to F# interactive. Proper F# interactive support on .NET Core is very difficult and time-consuming, and we're not going to release anything until it's ready. ScriptCS is an open source project which has no affiliation with Microsoft nor the engineers who work on C#. It is not the same thing as the Microsoft-authored C# interactive (which also does not work on .NET Core).
I’ve pretty much ignored all of the other headers since I know I don’t need them for the most part - I just wanted to make sure I wasn’t neglecting some sort of functionality or interface by ignoring them. The person who wrote the code I’m translating did a spaghetti job of it, so it’s not even really clear what’s going on in the header or the source.
I totally agree that it's better to wait until it's ready. I just wished that Microsoft would put more resources in to F# on .NET core. It's not just Microsoft since it's an open source project but Microsoft is the major backer. I really believe that Dotnet needs a 1st class citizen functional language to lure over the best programmers from the jvm world. Scala has a strong community and for them F# might be more tempting if the F# community had stronger backing and support from Microsoft than it has right now. 
&gt; You are comfortable in a high-paced environment and can respond to urgent (and at times ambiguous) requests Solid no. If you can't clearly tell me what you want with reasonable runway to get it done then I am only going to be frustrated and likely quit 
FYI: According to glassdoor, Software Developer II in ClearTax gets 30K$/year
Indeed. How is it even possible to respond *urgently* to ambiguous requests! *WHY HAVEN'T YOU DONE THIS IMPOSSIBLE TO UNDERSTAND THING I JUST TOLD YOU ABOUT?!*
That wasn't my point. I posted it just for reference because OP link doesn't have salary info.
This reads more as, “We have customers who report issues that you will need to prioritize” to me.
I've tried to get into WebSharper before, but haven't made much headway. Are there any non trivial applications out there that one could learn from?
RunSitelet is the Suave based server for running several WebSharper sitelets. Sitelets are lightweight WebSharper libraries with minimum dependencies and code. They are designed as desktop applications with web browser GUI. 
No timeline (other than this likely not making the 2.1 RTW release). This is, unfortunately, one of those problems where nothing even partially works until it all of a sudden starts working. The implementation is an MSBuild task which can find `.dll`s at design time in the right way, which is surprisingly difficult thing to get right, FSI itself knowing how to invoke that task properly, and verification work under different scenarios (type providers, scripts loading scripts which reference things we need to resolve, etc.)
Two recent issues were resolved for me on archlinux by setting TERM=xterm and installing msbuild-stable. This fixed compiling fsharp itself, installing fsharp from aur, building forge and running apps in vscode.
This was my difficulty when first trying to learn Elm. There are a ton of hello world tutorials, but those aren’t much help the first time you try to solve a real problem. Luckily Elm does have some really great production app examples that I was able to use to finally break down the wall. Hopefully someone knows of something similar for this. 
ono /home/amey/Projects/GameOfLife/GameOfLife/bin/Debug/GameOfLife.exe Can't find custom attr constructor image: /home/amey/Projects/GameOfLife/GameOfLife/bin/Debug/GameOfLife.exe mtoken: 0x0a00001c due to: Could not load file or assembly 'FSharp.Core, Version=4.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. assembly:FSharp.Core, Version=4.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a type:&lt;unknown type&gt; member:(null) signature:&lt;none&gt; Unhandled Exception: System.IO.FileNotFoundException: Could not load file or assembly 'FSharp.Core, Version=4.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. File name: 'FSharp.Core, Version=4.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' [ERROR] FATAL UNHANDLED EXCEPTION: System.IO.FileNotFoundException: Could not load file or assembly 'FSharp.Core, Version=4.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' or one of its dependencies. File name: 'FSharp.Core, Version=4.4.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' This is what I got :O
You need to look up how to format code on Reddit, this is unreadable. Worst case use gist or pastebin
&gt; System.IO.FileNotFoundException: Could not load file or assembly 'FSharp.Core, Version=4.4.1.0...' or one of its dependencies This is saying that a file was not found (FileNotFound), and that missing file is FSharp.Core 4.4.1.0. Now a few things can be happening here... 1) You don't have that version installed on your machine or referenced by the project -- update to the newest .net core SDKs and such 2) FSharp core versions have been automagically linked in newer versions of .Net Core which makes cross-platform work a nightmare. An implicit reference in a newer project might error on another platform -- the solution is to explicitly link to FSharp.Core 3) Mono supports an older version, not the one linked to in Windows -- the FSharp.Core versions bring new F# language features, but are generally quite compatible between one another, so a reference downgrade should be fine ... I know they're working on this in the .NetCore space. I hope they clean up the magic around that lib because it hurts cross platform a lot. F# on .net core on linux is a dream to work with otherwise.
The type checking was my biggest concern - I know F# has fantastic type inference, but the library that I’m translating has a header file that specifies a file format with a struct and struct fields to define the types of the fields within the struct. I’ve been using the explicit BitConvert methods to convert the n bytes defined by the c header, but it’s getting messy and spaghetti-y so I thought I must be missing some C like mechanism to allow me to say “this is of type x, convert accordingly” but DU, records, and classes don’t seem to be doing the trick.
We have an open position for a senior F# engineer at Amyris in Emeryville, CA. We're a synthetic biology company that has already brought many products to market, built on one of the most advanced high-throughput genetic engineering pipelines in existence. This position will focus on development on our whole genome sequencing pipeline and our domain-specific Genotype Specification Language compiler, both written in F#. We even open-sourced the vast majority of the GSL compiler: https://github.com/Amyris/GslCore We offer competitive pay and excellent benefits. We have multiple full-time devops staff and push-button deployment. Our team is friendly and co-operative. Overall working here is a ton of fun, with lots of opportunities to learn as much molecular biology and genetics as you'd like.
As with previous hiring post :) According to glassdoor.com (only one report) Senior Software Engineer in Amyris, CA gets: $146K-$159K / year I wish more employers start to actually give this information by themselves and we won't need glassdoor or similar services.
No support yet, mostly because of lack of time. However, the backend architecture is fully modular and thus adding a new one is quite easy. The [CUDA backend](https://github.com/DeepMLNet/DeepNet/tree/master/Tensor/Tensor/Cuda) would probably serve as a good starting point. The kernels would need to be translated from CUDA to OpenCL C\+\+ and the API adjusted accordingly. If you want to give it a try, I am happy to answer questions and help.
Can you comment on the motivation? Just off the top of my head I can think of 2-3 other libs that of similar nature... 
I am not aware of an open source library for F# with the same level of functionality and ease of use.
Make sure to advertise on the functionalprogramming slack and the FSSF slack as well! Both have active #jobs channels. Is there a tweet or something we can retweet to spread the word as well?
What are the other libraries?
Not that I'm complaining, but you are leaving the analysis as an exercise to the potential user?
When the project was started we had the feeling that introducing a tensor type into [Math.Net](https://Math.Net) would require significant changes throughout the whole library. This is because all functionality and algorithms are implemented on top of their DenseMatrix type \(or plain .NET arrays\). Changing the foundations of the library would be a huge development undertaking and people who are happy with vector and matrix types would rightfully ask if it is worth it. Extending [Math.Net](https://Math.Net) would also mean working in C#. While I think that C# is a good language with superb tooling, I am personally more productive in F# and believe that it is a great language for numerics.
I can't take anyone's advice on technical matters if they think light grey text on a white background is a good idea.
I only see the #general channel in functionalprogramming slack?
Thanks, I cross-posted to both of those places.
any chance of remote work?
Because as we all know, mastery of typography is a prerequisite to mastery of existential types.
I'm being snarky, but it's really hard to read. And I *would* like to read it (and did skim it). It's not typography, it's accessibility.
Filled it in and pointed out how important F# is. 
Potentially part-time remote. Full-time remote would be difficult as our development activities involve a lot of direct interaction with scientific staff and physical co-location is very effective at keeping communication barriers low. PM me if you'd like more details.
If you are reading a structure from memory (e.g. from a memory mapped file, or byte buffer), you can look at the StructLayout attribute. It somewhat works in F# but you may have to write a little C# to get exactly what you need.
Do you guys do internships?
Do you guys do internships?
Do you have internships?
Yes
Yes, and enjoy it! We call it "the F# bible" at my place :)
It is for compatibility with C#
Do we have to install several gigabytes of CUDA C++ SDK magic or does it work with normal Nvidia drivers?
We require only libcublas.so.8.0 and libnvrtc.so.8.0 or the corresponding DLLs on Windows from the CUDA SDK. They are not shipped with the NVidia drivers. I would bundle them with the library, but I am unsure if this is allowed by the nVidia license for the SDK. Do you have some information on that?
 I'm writing a WPF application using F# (FsXaml is awesome), and its working beautifully. It's definitely not back end only. 
Why do you use F# for at your place? Just curious! :\)
[;-)](http://www.scriptgodsmustdie.com/wp-content/uploads/2013/09/yellow-book-doorstop.jpg)
I use json the providers. Feels pretty maintainable
If a project requires the use of a database type provider I'd say it's also required that the projects build pipeline initialize and migrate a database. It's not hard these days with docker, and is inexcusable to not go full-circle.
Imho SQL Type provider is sutable for scripting, data explore and similar small tasks. It is very helpful if you are not in control over DB scheme, so it will do compile time checking. But if you ARE a DB owner, then you should model your scheme in types yourself, then you don't need SQL Type Provider. Others TP like Json or SQL are fine even in bigger projects. Just attach small Json or CSV to your project so Type Provider could read scheme from it.
In terms of "what to do with the DB" then Dapper is great, as are most of the other 'micro ORMs' (PetaPOCO used to be my go-to, but Dapper had a better Serilog integration last I peeked). WRT to whether this is an anti-pattern: no. This is a feature, not a bug. It's not always appropriate, but in those cases you should not be using something that is generating types live... If you want compile time verification of the schema that's when the Type provider becomes highly appropriate (detecting minor schema changes between dev and prod, or cloud environments, for example). For some apps it's important to run no matter what, for other apps the idea of having production errors is so horrendous that you really really want something that dies immediately if the environment is diverging. Pulling something off github and building it is one use case... Adding a `docker run` step in there is pretty common these days, if that's popping up around a project like this. *[I'm not sure about the SqlProvider, but generally you can provide a schema or point to a live source with the common Type Providers... if that's not already possible it'd be a pretty ok enhancement to the open source project]*
I really want to understand what is meant by a "existentially quantified type," here. Would someone kindly explain what this means and what it solves? (Your audience has a background in symbolic logic. I think that the intersection between propositional and imperatives forms is confusing me.)
If F# and Clojure (e.g., [Arcadia](https://github.com/arcadia-unity/arcadia)) were first class citizens in Unity, there really would never be any reason to use anything else (for me, anyway). Thanks for the article!
You compare native (go) vs cold CLR (f#)
That's probably not the issue. This benchmark is measuring how long it takes to allocate a List of 500 values, not how long it takes to run this in parallel. When you change the `[1..500] |&gt; List.map (fun _ -&gt; pickNumber ())` to `List.init 500 (fun _ -&gt; pickNumber ())`, it speeds up dramatically. With that change on my machine, Async goes from 35ms to 2ms and Hopac goes from 30ms to 0ms. Benchmarking is hard.
Oh I see why this happen? 
Because of JIT. That's how CLR and JVM works 
Ok really nice the second one is pretty fast
Wouldn’t you get better performance without async for a sample this small? I thought I read a while back that you get some overhead with async for &lt;10,000 ops that brings it to par with sync methods. Also, it’s not F# that’s slow, it’s your code. Titling your post as F# being slow is going to deter newcomers from adopting when they come to reddit to explore a language they may be interested in, and see something like this.
I've been using F# in Unity for about a year now and have completed one commercial game with it. Really loving it and have had very few issues during development. The major issues I've run into are mostly related to trying to integrate 3rd party libraries written in C# into the game.
Can't link to the game because it's for a custom hardware platform and not currently available to the public. Once it's public I'll post a link in the subreddit. Hopefully this helps you get going. As far as workflow these are the steps for creating the F# project 1.Create an F# .NET Standard Class Library 2. Add a reference to UnityEngine.dll and any other Unity DLLs you plan on using. They're stored wherever in the sub folder "\Editor\Data\Managed\UnityEditor.dll" 3. In the properties for the Unity DLLs make sure to set "Copy Local" to false 4. In the project properties set the build output path to the plugins folder in your Unity projects Plugins folder. In the Unity project's PlayerSettings set the "Api Compatibility Level" to .net 4.x Then you should be good to go. Whenever you build your F# project it'll output to your plugins folder and you should be able to use it like you would C# scripts in editor.
Just as a clarification, the F# .NET Standard Class Library is netstandard2.0, and the UnityEngine.dll was compatible being a reference? I was planning on trying this in a week or so \(working on basic RPG engine before plugging into Unity\) and was going to try out ECS for it. If they make their DLLs .Net Standard that means it's very likely to work out fine :\)
As far as I can tell it works with both .NET Standard 2.0 and .NET Core
You might check out Logary. I’ve never used it myself before, but I’ve been meaning to?because I’ve heard great things.
Yes, I have heard Logary and I'm following the development. But because we are using NLog in other projects also, it would be nice to use it also here. 
For your best bet I'd look at the list of approved RFC's in the [fslang-design](https://github.com/fsharp/fslang-design/tree/master/RFCs) repo. This has all approved-and-in-progress changes. As RFCs are completed (ie development and testing is complete and the feature is merged into mainline for a release) they will be moved into versioned folders at the repo root to match what release they are included in. Also check out the [fslang-suggestions](https://github.com/fsharp/fslang-suggestions/labels/approved-in-principle) repo for issues marked `approved-in-principle`. These can be turned into RFCs and added to the fslang-design repo.
A couple of things that I think are cool, but not necessarily new: * [Auto-quotation](https://github.com/fsharp/fslang-design/blob/master/FSharp-4.0/AutoQuotationDesignAndSpec.md) * And quotations in general (check out [unquote](https://github.com/SwensenSoftware/unquote)) * Computation expressions * Extension properties (in addition to methods) * Units of measure * Auto-open modules * Pattern-matching, obviously * [Static type constraints](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters) * Using constructors as normal functions * Tuples just because they're amazing * Discriminated unions (and the ability to abuse them via single-case unions)
I see a simple but common error in your code: list elements should be separated by semicolons, not commas. This: [addAssoziativ, addKommutativ, addExistNeut, addExistInv, mulAssoziativ, mulKommutativ, mulExistNeut, mulExistInv, distributiv] is a list containing a single element, which is a tuple. That's why you see ``System.Tuple`8[...]`` mentioned in the error message. You need this instead: [addAssoziativ; addKommutativ; addExistNeut; addExistInv; mulAssoziativ; mulKommutativ; mulExistNeut; mulExistInv; distributiv]
I would keep it simple. Find/replace `printfn` with a logging function, then in that function call `printfn`, NLog, or whatever. (Use `kprintf` so you can still have type-safe formatting.) Making the logger into a dependency is unnecessary unless you have a reason you may want to switch logging libraries at runtime or depending on the environment. I would only consider a `MailboxProcessor` if NLog's logging calls are synchronous and are causing slowdowns. And even then, I'd try a simple async logging function first.
Good to see that people are keeping an eye on this. I've poked at doing it a few times, but haven't committed to it yet because every roadblock makes me question if it's worth it. I've also been looking at [Zenject](https://github.com/modesttree/Zenject). I figure if I'm gonna do something experimental, I might as well go all out.
FsConfig is really helpful and I love it. So a big THANKS from me for adding .NET Core support!
What /u/kibiz0r, plus active patterns.
Having used FSharp.Configuration in production for several years (specifically the yaml provider), I'm eager to give FsConfig a look. It's not that FSharp.Configuration is a bad option, but it's heavily dependent on the Type Provider developer experience being 100% frictionless. We'll be able to make a more direct comparison when type providers are fully-functional in .net core.
Great talk covering more than just the tech comparison, but also how to compare things. Worth a watch!
I'm rewriting one of my earlier projects as an exercise in learning F#. It's a sound change rule applier. So far it's been a really fun experience, especially refactoring PrefixTree.makeTree. http://github.com/marriola/Transmute
i saw a presentation recently on youtube where the unity people were asked about f# support. the speaker asked how many f# developers were there in the room, and it was crickets. he basically implied it's only a dream for f# support at the moment.
They're so delightfully cringy. Tomas and Gian 4 ever.
Bit late to the party but a subtle but IMO important thing in F# is that there are no statements, just expressions. Commonly programming languages like C# (but many others like C, Java, Scala, Swift, kotlin and so on) have two very similar concepts statement &amp; expressions. Statements are basically expressions that produce no value (because they might have side-effects). But in F# we have unit to indicate no interesting value. So a statement in F# is an expression that returns unit. Improves composability and simplifies the language. Also in F# because of unit there's no need of dual classes like Action &amp; Func that is basically the same thing except Action "returns" void. 
SAFE stack? 
SAFE is about as close as it gets, though you don’t really avoid HTML/CSS/JS since the way you write code depends on knowledge of how that environment works.
Thanks for the info! We are now redistributing the required binaries from the CUDA Toolkit with the library. You don't need the CUDA SDK anymore, but still a fairly recent nVidia GPU driver.
I wonder why you'd not want to use css, html and js. Any F# framework will only be able to trabspile to that, which IMO will give you a lot of hurt, but having said that. Except for the aforementioned SAFE stack you can also take a look at Giraffe+Fable. Giraffe is just asp.Net core made functional, nothing more and might be more suited if you're already experienced with asp. Net core or you just need better performance than Suave can get you. (besides it works really well with all of the existing middleware) 
Websharper might be a fit. https://websharper.com
You certainly could avoid doing HTML/CSS of any kind, with webgl! Mighr even be great. But SAFE stack/Websharper probably satisfy the spirit of what you are after.
I’m working on [Felistar](http://www.moonstarsky.com) which is a tool for downloading from open directories, video-sharing sites and from subreddits
Was there anything in this article you couldn't just do with normal reflection loading of the assembly?
FSharp.Data.TypeProviders (and maybe others) are broken in this release: https://github.com/Microsoft/visualfsharp/issues/4795
Hopefully it's a faster fix this time around
This news is about Microsoft consolidating their .Net stacks. When this is done .Net Framework will be superseded by .Net Core. This will be better for all of us since Microsoft can consolidate the work done on Framework/Core into one place. I hope Mono gets superseded by Core in a similar timeframe.
&gt; /u/jdh30 The WPF/Xamarin/Avalonia approach is good for customer-facing apps. Web apps are already bogging down PCs and with the decline of Moore's law I believe the current trend of ignoring performance is temporary. Webapps are popular because they solve a cross-platform problem but .Net solutions can solve that without the same sacrifices. Besides performance the concurrency problems introduced by web apps are a nightmare compared to the likes of WPF. However, I've had customers asking for web apps and no desktop apps whatsoever for 6 years now. I'm just not seeing any industrial demand for them. 
This is pretty sweet! When they say type providers support .Net standard, does that mean we'll be able to use them in FSI again? I'm working on .Net core now and *really* miss my exploratory typeprovider based scripts...
&gt; I'd be much more exciting to see a compelling web story for F#. What do you find lacking in F# web story?
They already have a fix, just can’t ship it yet. 
&gt; They're academically exciting but practically useless What in your practice makes them useless?
Pretty much everything. Last I looked there wasn't even a decent library to help with HTML generation so I use a home grown one with `HttpListener` to serve pages. F# has become too complicated to compile to JS cleanly. Fable didn't work out of the box when I tried it and I haven't seen any compelling examples of it. 
They add a lot of complexity for marginal benefit. They're fringe software with a tiny number of users so far less support (e.g. SO answers) vs the traditional solution. They tend to produce lots of closures on the heap making them harder to debug IME. But above all they often don't result in simpler or more maintainable code, IME. 
Fantastic work by the F# team... especially the Azure tooling and VSTS CI/DI work. It's very convenient to be able to one-click Publish C# apps and up til this point that mostly involved reverse-engineering the proper C# configs for F# apps.
&gt; I got much cleaner code going to a reactive structure. Compared to what? &gt; What library did you use when you tried this? Rx, Elmish (and Elm). &gt; And how are you managing your updates without a reactive structure? Message passing between communicating sequential processes, one of which is the UI thread. 
I think this is better. I find it error-prone if negative indices count from the end like they do in eg Python.
How so?
If I were to list the biggest negative and positive on what Mads and Dustin showed: * Lacks exhaustiveness (and the DU type which could offer them that) * Recursive matching on members in classes The latter is quite interesting. As you can see in the video, you can match on the "shape" of a class and pull out a property to check in a guard expression. This could make dispatching functionality based on an inheritance-based hierarchy nicer. However, I wonder how common of a problem this is for modern C#. I've almost always avoided inheritance-based hierarchies in my user code because it was too complicated to realize in the context of an already complex system. Pattern matching makes so much sense in F# because dispatching functionality based on the shape of an input is at the very heart of how you program in F#. That's not really true, in my experience, for C#. I certainly welcome this feature for C# programmers because it introduces them to the general concept, but I wonder if it'll just be consigned to the bin of "things to rarely use" when compared with something like `async` or LINQ.
This is more explicit. If I mistakenly pass a negative index, I won't get an inconsistent result, I'll get an error, for which it's much easier to find the source.
Great point. I'll vouch for this system now!
Yeah I think this is true with the current state of c#, but I also think, when paired with non-nullability, and if the framework went more functional, then we could see a really good change in the whole ecosystem.
I can't help but think that the proposal has been put in primarily out of self interest, to make the C# compiler writers life easier, an not something that the C# community has been screaming for.
"Async rolled out into C# many years ago, copied by many other languages" C# ripped off F# which ripped off OCaml which probably ripped off Lisp you [self-aggrandizing idiot](http://i.imgur.com/1XHGizO.jpg). Async is an *ancient* idea. 
Yes indeed. Excellent point. 
Other posts from u/NiveaGeForce in r/fsharp: [Modernizing Desktop Apps on Windows 10 with .NET Core 3.0 and much more](http://reddit.com/r/fsharp/comments/8j2m7c/modernizing_desktop_apps_on_windows_10_with_net/) *I am a bot and this action was performed automatically. Downvote to remove|[Blacklist](https://www.reddit.com/message/compose/?to=allsubmissionbot&amp;subject=blacklist&amp;message=blacklist)*
&gt; Compared to what? Compared to bits and pieces of 1 and 2. &gt;Rx, Elmish (and Elm). These are two extremes. Rx is very non-functional and is about changes and doesn't have a concept of current value. Elm is very functional and you have to put the entire model in a DU. You might prefer somethign in the middle. Approaches 1 and 2 tie your logic to a platform very hard.
Is this at all relevant to the subreddit? I honestly haven't watched the video, but I doubt it. Please don't aim for internet points - aim for bettering society.
&gt; aim for bettering society. Isn't that what PWAs are about?
Many devs also eat cheese, but I wouldn't post videos about cheese wheels here.
Every developer should be aware of PWAs.
That is a wild exaggeration; PWAs are entirely irrelevant to many devs. Regardless, you're grasping at straws and this is not worth discussing further.
They may be now, but the industry is changing. * https://www.youtube.com/watch?v=LBsGSW2-qr4&amp;feature=youtu.be&amp;t=2532 * https://www.reddit.com/r/rust/comments/8bzex4/a_microkernel_that_implements_a_webassembly/
F# depends on .NET. I will keep posting these videos.
No they don't, not everyone is a front end developer. Do you think the guy writing router drivers cares needs to know about pwa's
There are some typos on the last one
I actually don't hate this. Can we get this in the standard library?
||\&gt;, |||\&gt;, \&lt;|| and \&lt;||| are already in the standard library. The others look, um, "interesting". Could you give examples of how to use these. They could prove useful, even if they aren't used very often, such as ||\&gt; and |||\&gt;, which come in handy occasionally.
&gt; does this mean more luddites sticking to C# as it "catches up" with ML? I dunno if luddite is the right term. If what you're looking for is a more ergonomic java, then C# with all its bells and whistles seems like one of the most advanced languages on the planet.
I think the reason C# makes sense as a language today is because of how it evolved from Java-style OOP, which has remained its primary idiom. If you strip away all that context and lineage, the idiomatic way of writing C# wouldn't be very clear.
stop. you'll attract haskellers.
oh god thanks for pointing out! will fix ASAP &lt;3
I know, I included them for completeness, I guess. |&gt;&gt;, |&gt;&gt;&gt;, ||&gt;&gt; and |||&gt;&gt;&gt; are 'tuple map operators' ("50", "100") |&gt;&gt; int // (50, 100) ("50", "true") ||&gt;&gt; (int, bool) // (50, true)
I made this for shits and giggles originally, but in retrospective, these 'tuple map' operators are actually quite useful in a few cases, maybe me or someone should open a suggestion on the fslang repo :p
I was hoping there was an easier way to do it but thanks.
what some people do is get it set up the way they like, then save it off to a github repo as a template, then you never have to do it again. 
Oh, and if you need a base `.fsproj`, you can use this: https://github.com/romanov/monogame-fsharp
|\&gt;\&lt;||||°\&gt;
Yeah, it's consistent and self-explanatory, so it's not so bad.
I think there are a number of problems stalling F# adoption: * Weird syntax; most veteran devs or students coming out of school are used to a C++-style syntax, which C# tries not to stray far from * Similarly, the job market is heavily skewed towards languages in the C++ lineage * F# targets the same underlying runtime, so technically there are hardly any framework capabilities that it has over C#; really the issue is ease of access to those capabilities, but that's hard to quantify * Virtually all language-oriented tooling for .NET languages is primarily or exclusively aimed at C# ...all of which leads to businesses not wanting to take a risk on something that might be harder/slower to work with, provides no obvious technical benefits, and hardly anyone knows how to use. A lot of it is kind of a self-fulfilling prophecy from Microsoft. If they had said "F# is the official language of .NET!" from the start, then C# would be the second-class citizen, probably as a pidgin language to help C++ and Java veterans migrate to F#, much the way that VB.NET was positioned. I don't think that it's necessarily a bad thing for it to be unpopular though. http://paulgraham.com/avg.html &gt; Our secret weapon was similar. We wrote our software in a weird AI language, with a bizarre syntax full of parentheses. For years it had annoyed me to hear Lisp described that way. But now it worked to our advantage. In business, there is nothing more valuable than a technical advantage your competitors don't understand. In business, as in war, surprise is worth as much as force.
I don't think weird syntax is really a barrier. As others have noted, Python took off with weird syntax. The ML style syntax has been spreading of late with bits of it in Swift and Rust and Reason, and Go even has a little of it.
It also has weird perception issues from both the FP and OOP camps. You can see two distinct thought processes play out in many discussion with those not drinking the koolaid. * FP: It's not pure, and the .Net framework has all sorts of mutation and state, so I'd rather use a more "pure" language for my FP since this is obviously a heavily OOP language. * OOP: It's designed with FP in mind, so OOP is an awkward fit, so C# has all the benefits without the weird FP stuff. Obviously F# isn't worse than Haskell or C#, but it can take some work to bring people in from the dichotomous mindset. The fact that it's Microsoft also has a way of pushing some devs, especially from the FP side, away. 
What sold it to me was speed at which I was able to produce solutions of considerable complexity. Clear examples of composition advantages over OOP patterns (which exist only to organize logic) would sell fp to most people. Problem is I discovered this on my own. No one explained it clearly. At some point I saw that I could compose additional functionality that I needed from a few simple higher order functions, using existing more or less atomic functions - which by contrast would require whole new OOP schemes to achieve in c# And it is really clean too. Being part of .net is a huge advantage. Erlang for instance still doesn’t have a solid driver for couchbase - which itself relies in large part on Erlang for scaling. But it does have first class .net driver.
My job prevents me from being able to use f# regularly but what I can say is it changed the way I write c#. F# really drove home the notion that there are a lot of common patterns we do in loops without realizing such as map, fold, reduce etc... By using these functions we reduce the risk due to loop state variable bugs and are able to better describe what we are doing \(assuming the person reading your code is familiar with the standard higher order functions\). After playing with f# for a while using linq has become so natural I write far less loops these days. Also I love discriminated unions. F#'s implementation is just wonderful. For so many years I've been doing the same concepts in c/c\+\+ only far more clunky and often prone to runtime issues.
Fable still requires html and css. Wait for blazor.
Most of my colleagues who gave F# a try actually enjoyed the language but reverted back to C# due to lack of F# tooling (especially when it comes to cross-language solutions). There is absolutely no cross-language tooling. Yet cross-language solutions would be the perfect way to introduce F# to a team / project because you could keep using the C# code and just write some new code in F#...
I fixed it for 4.7.1 by changed .fsproj file. I commented all direct references and added reference to netstandard. &lt;ItemGroup&gt; &lt;ItemGroup&gt; &lt;Reference Include="netstandard" /&gt; &lt;/ItemGroup&gt; &lt;!--&lt;Reference Include="mscorlib"/&gt;--&gt; &lt;!--&lt;Reference Include="System"/&gt;--&gt; &lt;!--&lt;Reference Include="System.Core"/&gt;--&gt; &lt;!--&lt;Reference Include="System.Numerics"/&gt;--&gt; &lt;!--&lt;Reference Include="FSharp.Core"&gt;--&gt; &lt;!--&lt;HintPath&gt;..\packages\FSharp.Core.4.3.4\lib\net45\FSharp.Core.dll&lt;/HintPath&gt;--&gt; &lt;!--&lt;/Reference&gt;--&gt; &lt;!--&lt;Reference Include="System.ValueTuple"&gt;--&gt; &lt;!--&lt;HintPath&gt;..\packages\System.ValueTuple.4.4.0\lib\netstandard1.0\System.ValueTuple.dll&lt;/HintPath&gt;--&gt; &lt;!--&lt;/Reference&gt;--&gt; &lt;/ItemGroup&gt;
&gt; My job prevents me from being able to use f# regularly How so? 
&gt; I really enjoy F# and I would like more to get their eyes open for the language. How can we as a community market F# to the rest of the world. Who is the best target audience? What kind of content should be produced? Learn from history. The first official release of F# was announced in 2007 and it was first shipped as a core part of Visual Studio in April 2010. F# adoption accelerated rapidly and peaked around 2012 when there was high demand for WPF-based Windows apps. People were desperate for a decent high-performance high-level language on a major VM for Windows app and server work. Since 2012 F# lost its way. While the community were [crying out for basic tooling like rename refactor](https://visualstudio.uservoice.com/forums/121579-visual-studio-ide/suggestions/2213611-provide-refactoring-support-for-f-code), Microsoft gave them academically-exciting but practically-useless language features like type providers. When demand for WPF apps dried up and web apps became ubiquitous, F# grew more and more complicated, more closely tied to .NET and harder to compile to JS. Now there are half a dozen web solutions for F#, none of which are reliable. &gt; The reason is that I really think that others would enjoy it and also that more companies will get involved in F#. The only reason F# has any IDE support at all is that some random eastern European guy did all of the work himself. If you can get any of the toolstack to work then you are one of the lucky few: well done! And there will be no serious commercial support from Microsoft going forwards. What companies are going to gamble on that? Heck, the whole of .NET has become a high-risk low-reward venture. &gt; A bigger community would benefit us all. Ok. If you want a bigger community then you need to provide what lots of people want: 1. **Simplicity**: strip out all of the incidental complexity that is now bogging down the language and tools. 2. **Tools**: web-based IDE with REPL and code saved in the Cloud. 3. **Graphics**: easy to use web-based graphics for both visualization and UIs. With the new open source direction I'd say the best place to target would be open source developers on platforms like the Raspberry Pi. Would be amazing if there was a decent Linux-based IDE that let you write an run F# code and libraries that let you interface with hardware for robotics projects or do OpenGL. However, the problem at the open source end of the spectrum is that everyone hates Microsoft. Good luck persuading Facebook (who are using their own dialect of OCaml called ReasonML even for their mobile app) or Bloomberg (also using OCaml) to switch to F#. 
what would cross language tooling look like? I've always just have solutions with a mix of C# and F# projects. 
gotcha, yeah agreed. have some of those features been added recently? I have a vague memory some might have. 
Sorry I should have said prevents me from using f# regularly at work. It's a banned language there (we can only pretty much use C/C++/C#)
Can you use F# to generate C/C++/C# code? Can you write test harnesses in F#? 
You can try to create a plain .NET Framework application. I haven't tried with FSharp.Data, but Mono can execute most .NET Framework applications up to .NET 4.7.
You want `3.0.0-beta3`
I admire your creativity but it's a pretty strict policy. I do have a couple personal projects I think it would be a good fit for at the very least so it will be a fun summer :\)
While VS IDE support was done by a few guys, it was also the migration to Roslyn that gave feature parity wih C#. It's there now so I don't see why you are complaining. Why ask for a complete rewrite from scratch when it is in finally in a great state for the first time? Tools: there is an IDE with a web-based UI (VS Code). I don't know why you would care about that though. Code saved in the cloud: that is what everyone does already. Visual Studio Live Share is worth checking out; something I have been waiting for for years. A big step for online collaboration. Database: type providers seem pretty good here. I don't know about the state of the art though when it comes to functional languages connecting to databases.
Try &lt;_,_&gt;
Where?
I just got an idea for a workaround type U\&lt;'a\&gt; = UGen\&lt;'a, string\&gt; let \(|U|\) \(UGen u : U\&lt;\_\&gt;\) = u let U u = \(UGen u : U\&lt;\_\&gt;\) let f1 \(u:U\&lt;\_\&gt;\) = func u : U\&lt;\_\&gt; //Works let m \(u:U\&lt;\_\&gt;\) = match u with U u' \-\&gt; U u' //Works But isn't there a proper way?
I think the point is that they want to be able to match against and construct with `U1`.
That's what I came up with too. I checked and they do get completely optimized away when compiling in release mode, so at least there's that.
One thing to remember is that case labels are not types: Compare: type Foo&lt;'a, 'b&gt; = Case of ('a * 'b) type FooString&lt;'a&gt; = Foo&lt;'a, string&gt; // this is an alias -- FooString and Foo are the same runtime type let m1 (u:Foo&lt;_, _&gt;) = match u with | Case (a, b) -&gt; () let m2 (u:FooString&lt;_&gt;) = match u with | Case(a, b) -&gt; () Note that in either case, you never matched on `Foo` vs `FooString`, you matched on the case label `Case`. One option for your `U2` is to give your wrapped type a `map` function to lift all your old functions: type U2&lt;'a&gt; = U2 of Foo&lt;'a, string&gt; // this is a new type module U2 = let map f = function | U2 foo -&gt; f foo let m3(u:U2&lt;_&gt;) = U2.map m1 u 
It's pretty much fixed in 15.6 and 15.7. Why would you want to code in a browser? Browser-based apps are inferior in every respect to desktop apps.
Nothing really new in here for those already used to Fsharp. Not worth the 30mins for those interested.
Are there any juicy upcoming stuff for F\#?
No, there's talk of type providers, and .net core integration.
Yeah, channel 9 fsharp videos tend to be, "What is fsharp". There seems to be a few of those.
&gt; The thing that was easy in object oriented code (adding new cases), was difficult in functional code. Exhaustive pattern matching forcing you to exhaustively match all your patterns is a feature, not a bug. It's an exact 1:1 match between logic and usage. There really aren't a lot of domains where you want to be ignoring changes in domain logic willy-nilly. Not to mention, if this is a genuine problem, the [functional equivalent to the visitor pattern](https://fsharpforfunandprofit.com/posts/computation-expressions-continuations/) is available to help.
F# *the language* development pretty much stopped around version 4.0, even 4.0 didn't deserve a major bump.
Yeah, I didn't get that either. It's true that it doesn't satisfy the expression problem, but in a good way. And you still don't need to reimplement more here, because you're just implementing the basic calculations for your new case of the discriminated union.
You're assuming you can edit the union type because it is in your code. 
&gt; Exhaustive pattern matching forcing you to exhaustively match all your patterns is a feature, not a bug. It's an exact 1:1 match between logic and usage. It's good but it does become intractable in places. &gt; Not to mention, if this is a genuine problem, the functional equivalent to the visitor pattern is available to help. That doesn't solve the expression problem. 
&gt; The Duality of Object Oriented and Functional Programming Good article but note that this has nothing to do with functional programming. The limitations you refer to are quite specific to the F# type system and close relatives but don't even apply to OCaml much less more distant functional relatives. 
explain
Here is changelog for 4.0 release, see if you spot *language* changes (as opposed to compiler or core lib): https://github.com/Microsoft/visualfsharp/blob/fsharp4/CHANGELOG.md
Why would adding `| _ -&gt; nan` or `| _ -&gt; NotImplementedException() |&gt; raise` not be a solution to the problem?
&gt; It's good but it does become intractable in places. And in such places it's easy to add `| _ -&gt; &lt;default&gt;`, so that's not really an issue.
The problem is not that we have to edit all functions to add an implementation for the new case. In fact, we _want_ the compiler to tell us this, because we want to write these implementations anyway. The "expression problem" is that we had to edit the initial type definition to add a case. That being said, I agree with /u/jdh30 that it's pretty much never a problem in practice.
That is an issue because you just lost the exhaustiveness checking you were relying on to catch bugs.
Catch-all patterns cost you exhaustiveness checking.
OK I don't follow what you mean by intractable then.
Ok, but what if I would use type constraints instead like this: type Shape'() = class end type Rectangle(width: double, height: double) = inherit Shape'() member this.area() = width * height type Circle(radius) = inherit Shape'() member this.perimeter() = 2.0 * Math.PI * radius type NotAShape() = member this.area() = 3.14 member this.perimeter() = 1. let inline sqrtOfArea (shape:'a when 'a:&gt;Shape') = let shapearea = ( ^a :(member area:unit-&gt;double) shape) shapearea |&gt; Math.Sqrt let inline sqrtOfPerimeter (shape:'a when 'a:&gt;Shape') = let shapeperimeter = ( ^a :(member perimeter:unit-&gt;double) shape) shapeperimeter |&gt; Math.Sqrt let sqrtOfAreaRect = sqrtOfArea &lt;| Rectangle(2., 3.) //Works let sqrtOfPerimeterRect = sqrtOfPerimeter &lt;| Rectangle(2., 3.) //Compiler complains, because perimeter is not implemented let sqrtOfAreaCircle = sqrtOfArea &lt;| Circle(7.) //Compiler complains, because area is not implemented let sqrtOfPerimeterCircle = sqrtOfPerimeter &lt;| Circle(7.)//Works let sqrtOfAreaNotAShape = sqrtOfArea &lt;| NotAShape() //Compiler complains, because it is not a Shape let sqrtOfPerimeterNotAShape = sqrtOfPerimeter &lt;| NotAShape()//Compiler complains, because it is not a Shape here I can allways use the members if they are implemented, and get an error if they aren't. 
Static dispatch like this is quite limited though. You can't do this for example: let sqrtOfAreas (shapes: list&lt;Shape'&gt;) = List.map sqrtOfArea shapes The point of the Expression problem is that we want to be able to hold a value of arbitrary shape (unknown statically) and be able to call arbitrary operations on it.
But without the libraries and easy learning curve.
Agreed. Polyglot is everywhere now but still few people are using MLs.
Today, cross language tooling needs to look like F# and Javascript working together in harmony. 
We've had this discussion before. Agree to disagree.
&gt; If you have a mix of C# and F# projects, I think you're out of luck Alternatively you could specify the version on the command line dotnet build /p:Version=1.2.3.4 This would apply to all projects when building a solution. I'm using the semver tooling to maintain a ```.semver``` file which is then read by Rake task :build do sh "dotnet build /p:Version=#{SemVer.find.format "%M.%m.%p"}" end It should be pretty straightforward to do this using Fake or Psake or whatever else.
A few projects: 1. Web-based analytics. Server code written in F# that downloads data from our MS SQL DB, crunches it and generates an HTML page using Google Charts to visualize the results. 2. Mobile app using an interpreter to download the user interface and data from a remote server on startup so we can change the UI without having to re-upload the app to the AppStore and Google Play. 3. A new programming language that will let me do these things more easily. 
If ASP.Net Core is production ready for you? :) Giraffe is just a functional wrapper around it.
Awesome thanks a lot.
Why is the framework not from Microsoft? 
Service Fabric :) A while back I had a Reliable Actors app written in F# (with a Giraffe backend acting as a stateless service). It didn't do anything except say "greetings from your F# Reliable Actor" or "this is the Giraffe endpoint" but I was glad that it worked end-to-end. Then for work I had to use C# for a bit, but currently I am back in the F# saddle. I am writing a (largely tutorial) service fabric app to fetch and process weather data from the Integrated Surface Database https://www.ncdc.noaa.gov/isd I am hoping to post source code soon but I have been saying that for a while :) As a note: I don't think people should necessarily writing service fabric applications in strict F#. I think all the services should be written in C#, written to C# interfaces, but with an F# implementation assembly that doesn't touch anything service-fabric-y. The interop is just too risky and confusing without it being formally supported by Microsoft. But at the end of the day a Service Fabric application is just a handful of .NET .exes implementing a few specific interfaces and abstract classes, so there's no reason why you couldn't do it in F# - or VB.NET if you want to draw even more ire from your coworkers :)
As Newtonsoft.Json for example. Why it should be?
You'll find most frameworks that the FSharp community backs don't tend to be from Microsoft. * Suave * Expecto * FSharp.Data * Fable * Logary * Fake * Freya * Ionide Basically, Microsoft has a habit of trying to make 'everything' because, historically, they had to. It wasn't until nuget appeared that it started to change (funny story about nuget and this pattern...). Then Microsoft started making spiritual copies of popular libraries on nuget and releasing them as the 'Microsoft' version. They still haven't quite kicked that habit, but I think it's starting to go away a bit. As azure becomes the main money maker, and they become less windows centric, it will eventually feel more like Java, where companies and individuals that need solutions build and share them, and MS employees might contribute to those, rather than building clones. Not meant to be overly critical, just giving some context to why these frameworks don't come from MS. C# is going through this change as well, it's just behind F# from an ethos perspective.
I'm working on an event source based game state manager. It's not inside a game yet, but since Unity supports .NetStandard 2.0, I'm planning to eventually use it in a Unity3D based game. So far, the abstraction I am using for everything is working out, and I'm using it as a learning experience since aside from some simple things for work, I haven't really done anything complex in F#.
There's a good reason for this. According to [the readme in fslang-suggestions](https://github.com/fsharp/fslang-suggestions/blob/master/README.md): &gt; Adding endless new language features in every version has major downsides. Here are some observations on why adding features is not necessarily a good thing: &gt; &gt; 1. Stability is a virtue &gt; 2. Gradual evolution is good &gt; 3. Adding new language features on every version is not a necessarily a sign of strength. Many languages have spread very widely while remaining very stable (e.g. Java in 2000-2013) &gt; 4. The addition of new features on every version can be a sign that language implementors are being incentivized (e.g. getting paid) for feature-completion rather than overall simplicity and utility. &gt; 5. New features add learning costs to every user of the language &gt; &gt; In contrast, features which make the language more orthogonal, simpler and easier to use are generally a very good thing. In line with this kind of thing, the biggest focus from the F# team and community seems to be on compiler optimizations, and in general, making the F# experience a whole lot more fluid, like bringing F# interactive to .Net Core. There's been a lot going on in this area. However I will say that there are a few really nice _language_ features (e.g, things that will evolve F# as a language) coming up soon, many of which are poised to enter F# 4.5; namely: - [match-bang](https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1047-match-bang.md) - [anonymous records](https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1030-anonymous-records.md) - [Span&lt;t&gt;](https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1053-span.md) (I list this because this is not an ordinary type, and requires many changes to multiple parts of F# [compiler, corelib, etc]) Just check out the [RFCs](https://github.com/fsharp/fslang-design/tree/master/RFCs) and [language suggestions](https://github.com/fsharp/fslang-suggestions/issues) to see what's going on. There's really a lot of features that have been approved but haven't been implemented yet, and there's nothing stopping you from grabbing an item and tinkering in the compiler! It's actually quite a lot of fun, and it's how F# progresses.
&gt; If I do define it like U1 then I can't use Pattern matching As /u/moosekk explained pattern matching works on cases, not types (well there's :? type testing but that's different). This works: let m1 (u:U1&lt;_&gt;) = match u with UGen u' -&gt; UGen u' // val m1 : u:U1&lt;'a&gt; -&gt; UGen&lt;'a, string&gt; 
Giraffe is good. I'm using it in production right now with AWS Lambda.
Your calling code "max_list []" fails to "compile", because it doesn't know the data type (is [] a list of integers, or a list of strings, or what?). If you provide a type annotation, e.g. do "max_list ([] : int list)" it will behave as expected.
Thanks.
Web Framework 
This is a great and usable post. Thanks! wish dotnet core came with built in templates for this
Two thoughts: First, what you're trying to do is transfer the license to someone else. That might not be legal: check the legal terms of the license you won, and see if it allows you to do that. For example, https://www.jetbrains.com/store/license_personal.html (which is *probably* the license you were awarded as a prize) says (emphasis mine): "JetBrains grants You a non-exclusive and **non-transferable** right..." So you can't actually transfer that license to someone else; you must redeem it yourself. Second, you're a student NOW. But will you *always* be a student? Once you finish your current studies, you'll no longer have free access to their tools. Pick one of their products (say, Rider) that you think you'll want to continue using after you're no longer a student, and use that coupon to "purchase" (for free) a license for Rider, like the hackathon organizers intended you to. Then when you're no longer a student, you'll still have a valid license for Rider.
1) I do not have a key, it is a discount code, so it is not associated with any account yet, or any product. It is like any other discount code, you can give it to anyone you like. 2) The key must be redeemed by the end of this month, and can then be valid for 1 year. By the time I graduate all my studies, this software will be so out of date it'll probably be useless ;)
you can probably use an active pattern to create this functionality for yourself. 
* opentk for low level opengl https://github.com/opentk/opentk * sdl2 by itself can work if you just need to do 2d stuff https://github.com/flibitijibibo/SDL2-CS * monogame, more of a game framework but can simplify some things vs using sdl2 or opentk http://www.monogame.net/
Unfortunately I have some constraints I need to meet for this assignment: everything has to be purely functional. No bindings means, so no active patterns.
How Active Pattern makes code less functional? Does it have side effects? Or maybe result is unstable? 
Check out the mkbundle utility that's part of recent mono distributions! It's a configurable mechanism that you can read more about [here](http://www.mono-project.com/docs/tools+libraries/tools/mkbundle/).
You're right, after thinking about it a bit theyre effectively functions. My bad, I spoke without thinking.
Without easy learning curve or with easy learning curve? 
I managed to strip unused classes and methods using 'monolinker -l none -a test.exe' command, seems it works perfectly fine.
Python has an easier learning curve and far more libraries.
I've built some PoCs in Freya. That was fun, but i'd probably try out some of the others like Giraffe and Suave.io.
I tried various libraries and bindings a few years back but found they all sucked. If you find anything reliable, I'd love to hear about it! 
##r/dotnet --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
sdfsdfsdf
I guess everyone's got to start somewhere. But F# file management really gets interesting when you have dependencies between files - I find the hierarchical file order requirement does a lot to inform the architecture of your code, but it confuses C# developers used to (effectively random) alphabetical ordering and mutually referential files (aka spaghetti). 
Thats what I’ve been seeing . At first I thought like C# I could just create a file and as long as it was in the same directory/namespace I should be able to access it in my main app. This was a way for me to effectively achieve that but it does not seem to be the way to go about it. 
[This article](https://fsharpforfunandprofit.com/posts/recipe-part3/) cleared up a lot of the confusion for me.
This is very helpful. Thanks for the link.
That whole website is gold for someone learning F#, and/or using F# professionally. Scott's website is dope.
Function overloading. It isn't supported explicitly, i.e. you can't just define two different versions of a function, but you _can_ do some trickery involving combining inline functions with method overloading. ``` type T = T with static member Doubl (T, x: int) = x * 2 static member Doubl (T, x: float) = x * 2.0 let inline doubl (x: ^a) = ((^T or ^a) : (static member Doubl: ^T * ^N -&gt; _) T, x) doubl 42 doubl 42.0 ``` Courtesy of https://stackoverflow.com/questions/501069/functions-with-generic-parameter-types
There's actually a StackOverflow post for this too :) https://stackoverflow.com/questions/181613/hidden-features-of-f One of the points is that F# is really a pretty simple language, and there aren't too many "hidden features." I am also just not sure what features are exactly hidden. But there are some I don't see out in the wild too often: * Well, one language quirk that I wouldn't necessarily call hidden: class instances are not immutable by default. If you do a let list = new List&lt;int&gt;, then list.Add(1) will change list. Obviously if they were immutable by default then any form of C# interop would be horrible. But it's something that I think is easy to forget - and I typically mark list as mutable even if it doesn't need it, just as a reminder that the state could change. * [Statically resolved type parameters](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/generics/statically-resolved-type-parameters), which let you constrain generic types based on static member constraints (e.g addition on numeric types). Note: this isn't supported by the CLR and disappears after compilation, but it's still pretty cool for numeric programming. Frankly, this one doesn't get used too often because it's just not that useful. I have done it a few times with numeric code, and it's nice to prototype types without having to write an interface - "I'm not sure exactly what an IDataReturnItem looks like, but I know it has to have a fun 'TDataType -&gt; float, so let's write the function with that constraint." Anyway, it's interesting, and something you can't do in C# or VB.NET. * [Computation expressions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions) Essentially this hacks in some of the category-theoretic stuff from Haskell in a way that's actually computationally useful rather than just confusing. You don't see computation expressions in the wild too often because the F# team already wrote the two naturally useful ones :) One is for collections (seq) and another for asynchronous computations (async). But there are a number of patterns that fit into a computation expression - and I suspect a lot of F# that could be simplified with them. * [Object expressions](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/object-expressions) Allows you to implement interfaces on-the-fly. type Noise = string type INoiseMaker = abstract MakeNoise : unit -&gt; Noise let barkingDog = {new INoiseMaker with member __.MakeNoise() = "woof woof"} let meowingCat = {new INoiseMaker with member __.MakeNoise() = "meow"} Note that we didn't have to define Dog inheriting from INoiseMaker or anything like that. In some cases that might make sense, but in other cases you might not want to clutter up your design with lots of types. Note you could equivalently do type NoiseMaker = { noise : unit -&gt; Noise } let barkingDog : NoiseMaker = {noise = fun () -&gt; "bark bark"} but then you can't compose interfaces as easily. Here's an example of how a purely functional data structure representing a stream can be converted into a seq using object expressions. type Stream&lt;'a&gt; = | End of exn option | Chunk of 'a * (() -&gt; &lt;Stream&lt;'a&gt;&gt;) type private IEnumerableState&lt;'a&gt; = | Uninitialized | OpenSocket of Stream&lt;'a&gt; ref /// Note to the caller: this uses mutable state and is not thread-safe. let toSeq (stream:Stream&lt;'a&gt;) : seq&lt;'a&gt; = let seqEndHandler a = match a with | None -&gt; false | Some exn -&gt; raise exn let startStream = stream let mutable state : IEnumerableState&lt;'a&gt; = IEnumerableState&lt;'a&gt;.Uninitialized //thisStream = ref startStream {new seq&lt;'a&gt; with member _this.GetEnumerator() : IEnumerator&lt;'a&gt; = { new IEnumerator&lt;'a&gt; with member _this.Dispose() = () member _this.Current = match state with | Uninitialized -&gt; failwith "underlying stream socket is closed" | OpenSocket thisStream -&gt; match (thisStream).Value with | Chunk(a,_) -&gt; a | End _ -&gt; invalidOp "Current was incorrectly called on an End stream. Note that the Stream.toSeq method is not thread-safe." interface IEnumerator with member this.get_Current() = (this :?&gt; IEnumerator&lt;_&gt;).Current :&gt; obj member _this.Reset() = state &lt;- Uninitialized member _this.MoveNext() = match state with | Uninitialized -&gt; state &lt;- OpenSocket(ref startStream) true | OpenSocket thisStream -&gt; match (thisStream.Value) with | Chunk(_,f) -&gt; thisStream := f() true | End a-&gt; seqEndHandler a } interface IEnumerable with member this.GetEnumerator() = let enumerator : IEnumerator&lt;'a&gt; = (this :?&gt; IEnumerable&lt;'a&gt;).GetEnumerator() enumerator :&gt; IEnumerator } Of course you could also use a sequence expression, but doing it this way lets you control the implementation more directly. The System.Collections.IEnumerable is a mutable pattern by design and you might want to have specific access to an underlying state. This example was more of an exercise but later I am hoping to expand this for a (poorly thought-out) asynchronous collection class, in which case I will want to implement my own enumerator rather than let the compiler do it for me. * F# generally has fairly weak support for covariance and contravariance in object hierarchies. This is fundamentally about prioritization, and it also reflects a design idiom to not have too much in the way of object hierarchies. But I always forget that you can use [flexible types](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/flexible-types) in F# to quick-and-dirty replace the out parameter in C#.
Haven't tried this yet, but seems promising: SkiaSharp: https://blog.xamarin.com/cross-platform-2d-graphics-with-skiasharp/ &gt; a cross-platform, high-performance 2D API for .NET developers available across mobile, desktops, and servers. &gt;SkiaSharp provides a powerful C# API for doing 2D graphics powered by Google’s Skia library, the same library that powers Google Chrome, Firefox, and Android’s graphic stacks.
My favorite little discovery is a workaround against those pesky "Possibly incorrect indentation" warnings when producing records. Imagine you have a record inside a record and try to write this: type A = { Number1 : int Number2 : int } type B = { InstanceOfA : A SomethingElse : int } let withWarnings = { InstanceOfA = { Number1 = 1 // Possibly incorrect indentation. Number2 = 2 // Here too. } SomethingElse = 3 } You get a warning about incorrect indentations. To fix it, you could do something hideous like this: let withoutWarningsButUgly = { InstanceOfA = { Number1 = 1 Number2 = 2 } SomethingElse = 3 } Or, you can throw a call to the identity function `id` in there and the warnings magically disappear. This works in a lot of places: // Note the call to `id` in there :) let withoutWarningsAndNice = { InstanceOfA = id { Number1 = 1 Number2 = 2 } SomethingElse = 3 } No more warnings and more pleasing to the eye.
Custom numeric literals: http://techneilogy.blogspot.com/2011/07/f-user-defined-numeric-literals.html You can use one of the following six letters as a suffix: Q, R, Z, I, N, G (I remember those letters with "QR Zing!" as a mnemonic), and if you've defined a `NumericLiteralsQ` module (or NumericLiteralsR and so on) with the appropriate functions in it, you can write `100q` or `100r` as literals in your code and F# will turn them into function calls to the appropriate module. I'm not sure what practical use this would have, since most of the useful types already have defined syntaxes. (For example, if you're dealing with currency and want to use the Decimal type, you can just write `123.45m`. But if anyone really needs to create a new custom suffix to change how numeric literals are interpreted by the compiler, those six suffixes (Q, R, Z, I, N, and G) are available.
I love that you have a mnemonic for something rarely used. Thanks for the trivia I will never forget. :-D &gt; I'm not sure what practical use this would have, since most of the useful types already have defined syntaxes. From the article: &gt; It allows for numeric literals which translate binary representations into uint32 So we can do compile-time conversions of numeric literals with arbitrary letters. I guess if you're working in a domain with a lot of *constants* that require conversion this could be handy. As someone who makes things with code (i.e. for 3D printing), I prefer to keep imperial measures of length in my code (i.e. inches) but need to work in millimeters. This seems like a perfect case: * Lots of constants per specifications * Few conversions (I for "inches to mm," etc.) Now I just need to figure out how to code things in F#...
Does the style guide/Don have an opinion on this?
If you [write your own custom numeric types](http://tomasp.net/blog/fsharp-custom-numeric.aspx/) that feature will certainly come in handy.
I don't believe the style guide mentions this technique. However, there are currently suggestions open to make using STRP (statically resolved type parameters -- the generics with `^` instead of `'`) easier to use, buy allowing you to do away with the crazy `((^T or ^a) : (static member Doubl: ^T * ^N -&gt; _) T, x)` syntax, so I think Don would probably approve of this kind of thing. It's the only way to do "function overloading" other than using the F# stdlib-only inline IL stuff.
I believe there's an F# language suggestion around that proposes to fix a few weird syntactical things like this, because it is kinda silly that one has to do that to work around it.
The API part of it can be built with any of the perfectly capable F# web libraries out there, like WebSharper, Suave, Giraffe, or Saturn.
Also, OpenGL.Net is good for just OpenGL stuff. However since it's _just_ the GL bindings, you have to use something else for the window management (like SDL2)
It really depends a lot on what you want to do and what level of F# / .NET knowledge you have. I've always written F# web servers using ASP.NET and haven't messed around much with Suave or Freya. In the latest VS 2017, there's a template for an F# ASP.NET Core application, with an "API" option for making a REST API. I haven't used it much because I've taken a liking to Giraffe, but the Visual Studio template might be worth looking at. It at least gets you up and running on localhost. If you want to try Giraffe, this tutorial is really quite nice at covering everything beneath the front end for a full application: https://blogs.msdn.microsoft.com/dotnet/2017/09/26/build-a-web-service-with-f-and-net-core-2-0/ There's also Saturn, which sits on top of Giraffe and is an integral part of the popular [SAFE stack](https://safe-stack.github.io/docs/overview/). This might be a good option in terms of getting an end-to-end application up fairly quickly. The database question is separate, and not really an F# thing IMO. The example from MSDN uses SQLite for a database but it could have been anything. The specific technology depends much more on the data you're interacting with than it does the language or web framework - F# can play nice with almost anything .NET, so don't worry about that too much. Honestly, if you're just getting started, use a CSV or a text file with a small subset of the data and load it into memory when you start the app. Build to some IDatabaseAccessLayer interface and mock it out with a StreamReader() - you can plug in an actual database later. But if you want to use a SQL database, SQLite is a decent option for getting things up and running. If you have a large amount of data and an Azure/AWS subscription, it's easy to get F# to connect to either providers' cloud storage (SQL, NoSQL, blob, etc - if there's a .NET API you can use it). Like /u/Jwosty said, Logary is a pretty popular logging framework for F# applications - it's written entirely in F# and has decent C# interop. It would probably be fine for this. That said, ASP.NET core has built in logging frameworks which also work just fine, and might be better suited since they're tailored to ASP.NET. But any decent implementation of ILogger will probably do the trick. I have not used FSPickler but will endorse the built-in System.Runtime.Serialization methods. [Here's a bit of a tutorial.](https://theburningmonk.com/2012/03/f-serializing-f-record-and-discriminated-union-types/) F# does play nicely with them - as does FSPickler, based on a quick glance at the source :) - and I think if you have your domain modeled well enough to know which types will need to be serialized, it's worth the annoyance of adding the attributes. And there's plenty of support and documentation since they're System libraries. 
&gt; FSPickler is nice for serialization. It's not meant for long-term storage though as it isn't version tolerant. If you're going to store json, use Newtonsoft.Json.
Forgive my ignorance, but what do youean by "version tolerant"?
When you upgrade to a newer version of FsPickler, or a newer version of F#, there is no guarantee that you'll be able to deserialize old data.
I've used: Suave - web server Dapper - db orm (with hand-rolled db schema migration code, although FAKE comes with support for the excellent FluentMigrator library out of the box) Logary - logging Newtonsoft Json.net - Json serialization for api contracts. Chiron is a more "functional" alternative. Json.net is convenient, but it's reflection-based and allows null values to leak into your application. Expecto - testing Paket - library/dependency management FAKE - builds Argu - command line argument parser Http.fs - http client Fsharp.Configuration - configuration library with a number of type providers for standard config file formats. It's kind of nice, but FsConfig might be a more lightweight alternative. FSharpx - standard library code. I use it in all my projects, but there may be a better one these days. 
&gt; I've heard about Logary being good for logging (it's made by the Suave guy). If you use Giraffe or Saturn (or plain ASP.NET Core), you need to acquire a commercial license to use Logary. [Source](https://github.com/logary/logary/blob/71f4844da4db62dd168b9e2cffa65c0e017e5d46/LICENSE.md).
Version tolerance effectively means that the serializer won't blow up when you add/remove fields over time. Eg, you can deserialize the following using Json.Net: type Foo { one: string; two : string } let foo = """{ "one" : "two is missing" }""" |&gt; JsonConvert.DeserializeObject&lt;Foo&gt; printf "%s" foo.one // "two is missing" printf "%s" foo.two // null A "pickler" on the other hand expects the serialized data to be in a very specific format. The missing `two` property would cause serialization to fail. Json.net can be configured to work this way as well, but it's not the default behavior afaik.
Good catch. I didn't know that!
&gt; Json.net ... allows null values to leak into your application. Even if you use the `JsonPropertyAttribute` and set `Required` to `Required.Always`? Is that + custom DataAnnotations giving me a false sense of security?
I'm not sure. I don't use those attributes.
That license screams stay the fuck away from anything that guy has ever written. It's a legal minefield and it doesn't at all reflect well on the developer. 
&gt; That license screams stay the fuck away from anything that guy has ever written. I strongly disagree. Hopac's license is [MIT](https://github.com/Hopac/Hopac/blob/e11787417515b78ff47d0c70f4abbeb76a5f1024/LICENSE.md), Suave has an [Apache 2.0](https://github.com/SuaveIO/suave/blob/90627ae006837dfff313c5e40dc865da827b0c83/LICENSE) license, and Expecto is [Apache 2.0](https://github.com/haf/expecto/blob/150eba21a3dd5795f45a956506ded7d60a0fa58b/LICENSE). Haf has done a lot of great work, and he has many libraries that should be considered/used. Don't avoid everything he's worked on just because of the Logary license.
It's not clear whether distributing code under that license is actually legal even for Haf. It's not clear how or even whether you can ever safely use that code without a commercial license. Writing that license reflects really badly on the developer.
Lol what?! Is it a way of protecting suave?
Kestrel + Freya + Serilog (with ELK) + FsCassy (Cassandra) + FsBunny (RabbitMQ) + FsShelter (Apache Storm) + Unquote (with NUnit) + Fable + Elmish + React + Aether 
No, but I'll likely add something along the lines of "generally don't do this".
First-class active patterns: let (|SecretPattern|_|) string = match string with | "SECRET" -&gt; Some "you guessed the secret!" | _ -&gt; None let doStuffWith (|Pattern|_|) string = match string with | "boring" -&gt; "I'm not boring, you are" | Pattern x -&gt; x | _ -&gt; "whatever" let pattern = (|SecretPattern|_|) in doStuffWith pattern "SECRET" // &gt; val it : string = "you guessed the secret!"
I like proper respecting of \`\[\&lt;Optional\&gt;\]\` and \`\[\&lt;DefaultParameterValue\&gt;\]\` \`\`\` open System.Runtime.InteropServices type C() = member \_\_.M(\[\&lt;Optional; DefaultParameterValue(3)\&gt;\] value) = value let c = C() c.M() |\&gt; ignore // Returns 3 c.M(12) |\&gt; ignore // Returns 12 \`\`\`
Is it an option to use core and ship the runtime binaries with your app? 
I can try, but I'm not sure .NET Core will run on WinXP. I'd rather prefer the compilation to .NET 2.0 framework.
What OS is your dev machine running? In visual studio you can change the target. 
I think the last version of F# that supported .NET Framework 2.0 was F# 3.1, so you would have to install that compiler I think this SDK will work for you (but I'm not as sure about the Mono side of things, just not familiar with it): https://www.microsoft.com/en-us/download/details.aspx?id=44011 Actually you might be able to get the version you need straight from Nuget. If you figure this out let us know :) 
Not that this solves your problem, but it is well beyond time to upgrade your legacy system 
Windows XP supports .Net Framework 4.0
This indicates that 7 is supported. https://github.com/dotnet/core/blob/master/release-notes/2.0/2.0-supported-os.md 
Yes you can pull that old version of FSharp.Core on nuget. That will help make sure that regardless of environment you're using a compatible binary.
Great question with some great answers, thanks. One nit pick: &gt; the memorizer pattern Memoize. 
Thanks fam :)
Do not add more complexity to a legacy system that old. Not FSharp, not anything **unless** it is a critical part of making that system not legacy anymore. Don't add extra languages to existing projects unless you have a good reason for doing it or it's part of making them not legacy anymore. Especially don't do it based purely on your own preferences. This is a **bad** idea. If you legitimately can't move this steaming pile off XP then it's a landmine. Don't make it worse.
Great post! was doing a similar thing but ran into issues at the training phase. Just starting with F# so I’m sure I missed some parts. I’ll reference your post to try and fix mine. 
Thanks for this, I didn’t realize this was released. I’ve been using the Accord framework for machine learning with F# for a couple of years, so some variety will be welcome. 
Using Giraffe in production for some of our internal microservices at Jet.com
It sure comes off that way. He wrote [this blog post](https://haf.github.io/2017/10/01/open-source-in-the-fsharp-community-part-1.html) about transferring ownership of his open source projects once Giraffe started gaining traction on ASP.NET Core.
You have to appreciate how he feels about Giraffe being a knock-off of Suave that benefits the ASP.NET ecosystem, which I'm sure he's not too fond off. I too would feel a bit slighted.
&gt; I too would feel a bit slighted. I guess so, but other than ego I can't find a reason why these decisions are beneficial. Tech is a fast changing world, and trying to tie people to libraries with 1-2 active contributors doesn't seem like a good idea when there are newer, more robust alternatives in the ecosystem. There are good ideas in the F# world, but for some reason there are a handful of people who get pissed when they belong to others.
I'd be careful about claiming that Giraffe is more robust just because it hitches its wagon ASP.NET/Kestrel. Suave's strength, besides its innovations, has always been its independence. The fate of the project is really in its own hands, whereas who knows what sorts of tectonic shifts will happen in the ASP.NET world and what sort of effects they'll have on Giraffe? What if there's a breaking change and Giraffe gets left behind, forcing users to stick with older versions of ASP.NET/Kestrel? Though Suave's "web server" is perhaps not as robust as Kestrel, it's pretty darn reliable, and it comes without all of the ASP.NET baggage. Also, it's a library that can be easily embedded in the rest of your application, so the developer experience has always been light and unceremonious. Giraffe on the other hand, is a library that is meant to be layered on top of a framework. From a design perspective, Freya's modular approach is maybe more robust than either Suave's or Giraffe's. Freya can sit on top of any OWIN compliant server. If Suave 's Webpart combinator library were separated from its "server" this way, Giraffe would be totally redundant (although they did have to break the OWIN spec in order to get Giraffe to work according to haf.)
Well this relies on the string being able to be null, and the nulls will cause problems elsewhere. So that lack of version tolerance is not a problem. Is FSPickler non-version-tolerant in the more problematic sense that @THabitesBourgLaReine inteprets it as?
&gt; Is FSPickler non-version-tolerant in the more problematic sense that @THabitesBourgLaReine inteprets it as? It's problematic in the sense that even the FSPickler documentation warns you that it's not intended for serializing data for long term storage. 
Does [ML.NET](https://ML.NET) offer a functional non\-OOP api ?
Swift llvm\-frontend written in f# :D
I dont think so. From what I saw it was all OOP.
That null is liable to cause problems down the line, it seems like Newtonsoft is just passing the buck.
Half of your Githhub links don't work.
##r/dotnet --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/853qg2/ignore_list/)
RFCs get moved around when their feature is completed. I'll fix them -- thanks for pointing this out :)
How does accord compare to scikit-learn or tensorflow? Never used it. 
i've only dabbled with scikit-learn, and never tensorflow. it seems like a smaller version of sk-learn, and a complement to TF (which itself is very focused). that's my understanding of how those compare, it could be wildly inaccurate. 
ml.net is so confusing for me every time i see it since i am not a machine learning person. so i immediately think of an ml running on .net, i.e., f#.
When i built [Felistar](www.moonstarsky.com) I simply used the built-in HttpClient in .NET. Worked out fine for me
Yes, use the built-in System classes unless you have a specific reason not to. WebClient is the easiest to use for simple things, but you'll want to use HttpClient if you need async methods, and you might even need HttpWebRequest if you need to dive deep into the structure of the web request. These days I think HttpClient is the "default good choice. 
any wrapper-libraries for System.Http that make the api a bit more.. f#-ish?
HttpFs from v5 beware of license in v5
Yes this is the best for high level graphics. The APIs are good, it's well maintained, and it's very cross-platform.
@TensorMetric We finally wrested F#/UWP from the Microsoft F# team and are doing it ourselves. Please contribute to testing. See the thread on the CoreRT repo.
This is the correct answer. The only other option I can think of is to write your F# application as a service, host it on a modern server, and write a minimal client in .NET 2.0 to access it from the legacy system. 
Even then though you're adding one more thing that people who are supporting and maintaining that app have to get their heads around. Unless the new component is completely separate and effectively black box, adding another item to the mental stack is not something to do without really good reason. 
[FSharp.Data](https://FSharp.Data) presents a lightweight client. Very convenient. let! resultJsonString= Http.AsyncRequestString ( url=url, headers = \[ FSharp.Data.HttpRequestHeaders.ContentType ("charset=utf-8;application/json") \], body = TextRequest data, httpMethod=HttpMethods.Post, responseEncodingOverride="utf-8" )