Are you targeting full framework or core? (This is important context.) I've developed multiple in-production and (AFAIK) bug-free solutions with VS 2017, and am looking forward to the full release of 2019 next week. What are the bugs that linger? FWIW, it's also been my experience that Ionide using VS Code is rock solid. Sometimes I have to build outside the app, but apart from that, it works well. If you're having issues with it, search first, but submit issues against it; KC does a great job with this plug-in, but he can't possibly know all the ways people are trying to use it. I would be a bit less dismissive than OP was with their question; though he does have a bit of funding at this point, Ionide is something he's poured a lot of himself into. I'm continually impressed with how well it works. :)
&gt; Are you targeting full framework or core? (This is important context.) Framework. &gt; I've developed multiple in-production and (AFAIK) bug-free solutions with VS 2017, and am looking forward to the full release of 2019 next week. What are the bugs that linger? Off the top of my head, type: type 'a Tree = Tree of 'a Tree list Right click on the type variable `'a` and rename refactor it to, say, `'foo`. On bigger projects you'll find there are concurrency bugs where it only updates some of your identifiers or updates completely the wrong bit of code because it hasn't caught up. The trick is to type really slowly. Can you re-order files in solution explorer using ALT+UP/DOWN? Didn't work on either of my machines until I manually fixed the key bindings. &gt; FWIW, it's also been my experience that Ionide using VS Code is rock solid. Interesting. It seems to work well for some people but is entirely broken for others. I'm sad to see people who complain that ["The Ionide extension is littered with bugs"](https://www.reddit.com/r/fsharp/comments/b6pcvv/how_to_even_start/) are downvoted into oblivion on this subreddit. &gt; Sometimes I have to build outside the app, but apart from that, it works well. If you're having issues with it, search first, but submit issues against it; KC does a great job with this plug-in, but he can't possibly know all the ways people are trying to use it. I would be a bit less dismissive than OP was with their question; though he does have a bit of funding at this point, Ionide is something he's poured a lot of himself into. I'm continually impressed with how well it works. :) I tried it and gave up almost immediately. I want an IDE that builds for me, not an editor and a command line. If I was going to do that I might as well use OCaml... 
OP is right about the bugs. VSCode frankly tends to get a bit overrated, perhaps for community-related reasons moreso than objective evaluation. For example right now you can try to create new F# project and immediately get "project parsing failed" error, a widespread issue for many months now on both new and existing projects (https://github.com/ionide/ionide-vscode-fsharp/issues?utf8=%E2%9C%93&amp;q=project+parsing+failed). Imagine VS2017 not being able to open any project without spitting out errors, MS would get crucified. Also fairly discouraging is this destructive rename bug for almost 3 months (https://github.com/ionide/ionide-vscode-fsharp/issues/986). And indeed the tool/community do tend to excessively push Fake/Paket which, while fine tools, are overkill for many projects and extra unnecessary noise for someone just starting out. VS2017 does have its own bugs but on Windows it's a better starting point than Code at this time. (Can't speak for Rider.)
Quality info-dump!
&gt; OP is right about the bugs. VSCode frankly tends to get a bit overrated, perhaps for community-related reasons moreso than objective evaluation. Agreed. &gt; Imagine VS2017 not being able to open any project without spitting out errors, MS would get crucified. That was literally the state of VS2017 for the first few months after it shipped: completely broken. 
No idea but boy am I waiting with bated breath!
Hasn't VS been overtaken by Rider at this point?
Aside from F# 4.6, some new tooling features and a slew of fixes, the people who will notice things the most are those with medium-to-large solutions (50+ projects). VS 2017 and all other versions before it had not had significant and \_correct\_ performance analysis done on the compiler service in the context of being a long-running process that services a large corpus of code. You can see specific issues and hard data behind the improvements going into the GA release in this rollup issue: [https://github.com/Microsoft/visualfsharp/issues/6096](https://github.com/Microsoft/visualfsharp/issues/6096) As VS 2019 updates you can expect more incremental work in the performance space, as this is something that has historically been neglected for F# since its inception. For example, we're just now sussing out serious architectural problems that duplicate expensive work when TypeProviders are used. You can see a full list of the (user-facing) diff between VS 2017 15.9.x and VS 2019 16.0 here: [https://github.com/Microsoft/visualfsharp/milestone/17?closed=1](https://github.com/Microsoft/visualfsharp/milestone/17?closed=1)
No matter how good Rider is, it will never be a solution for everyone as it doesn't have an unlimited free version.
Not even close.
I like Rider more than VS on Mac, so I subscribe to it. It's pretty decent but it makes Resharper look like a child's toy...there's too many options to configure and way too many keyboard shortcuts. It's not the most user friendly experience and I personally am a little disappointed with the quality of interactions I have had with JetBrains. I was interested in producing classes for their education programs, and it was fairly obvious they were responding to my messages without reading them (one month later and still haven't been put in touch with the right person).
The UI designers support will be outstanding! 
What concretely are you having issues with? .NET Core has been a primary focus for F# since mid-2015 and remains as such (in fact, we explicitly added support for features that are natively only on .NET Core in F# 4.5).
F# is more open source than most of .net, not less. There have been some (horrible, annoying, needless), breaking issues around certain aspects of certain tooling for a while, but those are very soon to be resolved (new package management in FSI with VS 2019, right?), and predominantly a result of .Net Core churn. They are also avoidable if you just stick to mono....
Interestingly, are you a pm at MSFT for F#? If you are I saw your video on the YouTubes where there was that horribly placed camera angle. Anyhow, on a clean Mac and possibly linux box (Ive yet to try this in linux) can you tell me how far you go with something like SQLProvider? I‚Äôve seen wonky examples where I have to either point at a different compile time dll that‚Äôs non netcore (possibly 451 or something similar), or do some other complicated things. Then one has to fight with the compiler saying it‚Äôs invalid, or not found, or better yet ‚Äú#r directives aren‚Äôt used on non fsx files...‚Äù All of which after going down the rabbit hole, are problems that spring up here and there regarding dlls that are found on this runtime but not the other, etc. So, what use is it to me to have some super sweet tooling if I‚Äôm going to be actively fighting it because it can‚Äôt detect that the nuget package I installed isn‚Äôt actually being picked up? 
I suggest not starting out with a very complicated library like SqlProvider. .\[NET Core support is still underway\]([https://github.com/fsprojects/SQLProvider/issues/575](https://github.com/fsprojects/SQLProvider/issues/575)); the issue is that it relies on numerous database drivers, all of which are the responsibility of some other vendor. Something like a web service written in Saturn is significantly less complex as a beginning project. I also recommend reading about things at a high level here: [https://docs.microsoft.com/en-us/dotnet/standard/components](https://docs.microsoft.com/en-us/dotnet/standard/components)
I‚Äôm aware of that issue as well. But it proves what I‚Äôm saying does it not? Can you clarify what is the roadmap with so many different runtimes and when are they going to merge if ever ? Or will there always be a different spec for each one?
I cannot give a roadmap for the SqlProvider library because it is an open source project run by maintainers who are not employed by Microsoft. But I will say they have my sympathy for having to deal with the complicated world of type provider infrastructure \_and\_ managing the complicated setup involved for multiple database drivers. &amp;#x200B; In the meantime, if you need to use SQL, libraries like Dapper (and many others) are perfectly suited to the task and work 100% on .NET Core.
Afaik there are three runtimes for .NET: .NET Framework, .NET Core and Mono. The .NET framework is the only closed one among those, so which "other closed runtimes" are you referring to? The "deal" with having "so many frameworks" is that Mono is an open source multiplatform implementation of the .NET framework whereas .NET Core is an open source implementation of just a part of the whole framework. If you need all the newest features use .NET framework on Windows. If you need some of the newest features cross platform use .NET Core. If you need all features cross platform use Mono and wait or contribute until they are available. That's the thing - "the powers that be" are mostly members of open source communities, and these people are typically mostly interested in their own application domain. Why would for example someone who works exclusively on Windows applications vote to prioritize cross platform support? And as always "the community" consists in large parts of the users themselves. So if you think that they should be working on .NET Core then my response is that one of them is currently on reddit complaining about "wonky issues" and "terrible experience". ;-)
I'd agree with the general point you're talking about, but this whole "microsoft loves open source" only began to be a thing when they realized that the money and this whole "cloud" thing was becoming a giant thing and they would be left behind if they don't open up so to speak. Or when the tech community at large thought "lol c#" and the evil doings of the msft empire. I don't blame them for their actions, just let's not go there for now. On that same token, there are clear cut benefits to developing tooling and implementing a platform to make it easy to create and develop on top of Azure etc that benefits msft investing time and money into the project. 
I am a teacher and I am using harp.js on Windows to create my teaching materials. The last two days I spent several hours trying to install harp on Linux. In the end I found the correct combination of versions of node, npm and one of the dependencies that worked. Python's version 3 has just turned 10 years old and still it's common to have both python 3 and 2.7 installed because there still are libraries that weren't updated (at least that's the explanation you read everywhere). So "just download and it works" is a nice idea, but it's not quite the truth. I would say I have had about as much trouble with Mono and incompatible libraries as I have had with node or python. Ok, maybe a bit more, but then Mono is an open source port of a windows only framework whereas the other languages you mentioned have been cross platform from the start. With that in mind I really don't think that F# on Linux is a terrible experience. 
It‚Äôs not terrible which is the only reason I am looking at it. It‚Äôs open sourced and with the changing attitude of Microsoft, it‚Äôs opened up the possibility for someone with my core opinions to look into it. Sometimes I think I‚Äôm special, but I‚Äôm really not... üòù
I'm posting this monthly thread since October 2016, but I don't remember ever actually reporting what I'm working on. Today is a go-live day of the project I was working on in the last 11 months: https://github.com/OwnMarket/OwnBlockchain It's a blockchain for financial asset/equity management, with BFT-based consensus protocol and Delegated Proof of Stake as a Sybil control mechanism. Deciding to develop it in F# was one of the best technology decisions we've made. It made the code, the development flow and the final outcome much more reliable and confident than we could ever achieve with a "less typed" language. I'd also like to take this opportunity to express my gratitude to the F# community as a whole, and cannot resist to mention Scott Wlaschin, who's website[1] and an excellent book[2] had a lot of influence on the codebase design. [1] F# for fun and profit (https://fsharpforfunandprofit.com) [2] Domain Modeling Made Functional (https://fsharpforfunandprofit.com/books)
We moved from SQLProvider to FSharp.Data.SqlClient to get .Net Core support and a more complete implementation of querying. And working with sql directly in ssdt projects is a good experience which FSharp.Data.SqlClient plays relatively nicely with.
I‚Äôm starting the new F# contract today ^_^
What education programs? Are you considering teaching or learning?
Blimey, F# contracts are a thing?
lol
I know, but that was understandable, since it was to get Scala on .NET, which is worthy language to invest in, unlike C# and VB.NET. Also, at that time, the future of F# still looked bright.
Congrats
Im still working on Falanx, a code generator that uses provided types, quotations and ast, to generate records and unions etc from a schemata.
Working full time at [olo.com](https://olo.com) on a new project that is in F# &amp;#x200B;
The final touches to a blog post on F# 4.6 and the VS 2019 release :)
How's it all going? Any issues in getting started with a new initiative?
I write my test code and data tweaking scripts in F#. The team policy requires C# for production code, unfortunately.
we have 3 people on the f# project. it got started before i was here so i dont know how hard it was to get started. i dont sense any hostility to it though. we are following idioms from the ‚Äúdomain driven design‚Äù book which is a challenge for me to get used to, we will see how it goes.
Hope it goes well! And don't hesitate to file any issues if you come across them.
Not at the moment, no. Though as it stands, there's little to gain from doing that. Both .NET Framework and .NET Core FSI use the same core "engine", and it's that engine that is being updated. Additionally, since FSI in VS 2019 targets .NET Framework 4.7.2, it can load .NET Standard 2.0 components.
They have student versions of some of their software packages...right now I think mainly IntelliJ and PyCharm with tutorials to follow. I was going to offer to help produce some for either C# F# or JS.
So if I wanted to be able to use types like Span in FSI, this wouldn‚Äôt be a solution anyway?
Nah, F# is just a global conspiracy to make you believe that MSFT care about OSS 
Not at the moment, no. It may be in the future, but there‚Äôs design work needed first.
Ha ha ha!
Ok, thanks for clarifying that! As much as I love playing with F#, the stuff under the hood is all magic to me.
Are you intentionally engaging in a hostile way for some purpose, or are you not aware that you are doing it? &amp;#x200B;
Adding the final touches on an F# project for the applied challenge! It‚Äôs a static billing engine for beginners! You can find it here, it‚Äôs not complete but the code is somehow decent ! Reference: https://github.com/Kavignon/F--Sample-Store-App Afterwards, having a hard time deciding between using Fable and UnrealEngine.js to build this game with a YouTube tutorial : https://youtu.be/g0nM43FOVdk Or start leveraging the new TF 2.0 API that looks more than decent to do AI work with ML.NET 
At least on OS X, there is a fsi.exe instance in the 3.0 SDK preview install folder. I was able to point Rider at it and use it without issues. Haven't tried it in Visual Stuido 2019 for Mac because I still find it incredibly underwhelming.
I haven‚Äôt had the chance to play with Mono/VS Mac much, but I don‚Äôt think that would let me use .NET Core specific features in FSI. I have pretty much replaced Matlab with F# so I‚Äôm still getting used to not being able to run *everything* in the interpreter.
Anonymous records is awesome. Excellent for scripting. Nice work fsharp team !
Yay, anonymous records! Boo, compiling a project with 750 LOC still takes 20 seconds :(
You can make the C# compiler crawl with only 4 lines! https://mattwarren.org/2017/11/08/A-DoS-Attack-against-the-C-Compiler/ More seriously, are you using SRTP or Type Providers? If so, that‚Äôs the reason why.
Never knew SRTP was a thing. I'm using type providers in this project, but I also have a 2000 line .NET Core project with neither that takes nearly 30 seconds.
Did away with the type provider, down to 14 seconds. Still pretty slow.
Also, the VS2019 installer doesn't ngen fsc.exe. Did that, and it's down to 10 sec or so.
As it turns out, part of the reason is because the VS2019 installer doesn't ngen fsc.exe. Don't know how they could have missed this. Did that, and it's down to 10 seconds. `PS C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\IDE\CommonExtensions\Microsoft\FSharp&gt; C:\windows\microsoft.net\framework\v4.0.30319\ngen fsc.exe`
I believe this was an issue from last release, too.
It _should_, but NGEN isn't guaranteed to run instantly for all components. It does that asynchronously so that the time for setup isn't crazy long. How long was it until you ran NGEN?
I don't think this is the case. We just verified that it's NGEN'd on our own installations of the release. NGEN does not run immediately after setup, so there is a period of time whenever a new VS is installed that binaries may not yet be NGEN'd.
That has been an issue several times IIRC.
Sorry to hear about your performance woes (I had a 100-line program that took 5 minutes to compile thanks to type providers) but, tbh, at this point all I want to know is: does the editor run reliably or are many things still broken? 
Bah. Does the F# support in VS2019 still crash all the time? 
I haven't had that issue in 2017, and so far not in 2019 either.
"[You told us it would be faster](https://www.youtube.com/watch?v=EPfsr8BBdA8)". 
The editor seems to be better. Colorization is much better. There are limitations to what IntelliSense can do because of the language's syntax, so that's just something I've had to learn to accept.
What happens when you rename refactor a type variable like `'a`, for example? 
I was mistaken per /u/phillipcarter2's comment.
I wonder how Haskell compiler performs in comparison.
Don't think I've noticed anything odd. Do you have a specific example?
A couple hours, I think. I guess that makes sense, given how long ngen runs.
Sorry, no idea why I had such a hard time understanding your question earlier. Yeah, uh, it doesn't crash, but the behavior isn't exactly optimal. [https://imgur.com/NGkMlDQ](https://imgur.com/NGkMlDQ)
This might be a silly question, but what's the workflow to update to a new version of F# using .NET Core? Just change the nuget package version for FSharp.Core? Does that package bundle the compiler as well, in which case why does the version of .NET Core matter?
Two great keynotes announced as well. David Spivak on Graphical Logic, and Donya Quick on Algorithmic Music.
That's slow. Is that on a SSD with a modern CPU? I'm curious how fast it compiles on my machine. How do you measure it?
My Elmish.WPF solution (4 projects, several thousand lines) rebuilds after cleaning in around 3-4 seconds. That's in 2017 though.
I do not know if this is still the case with vs2019 but I feel like vscode+ionide is a much better ide than visual studio. Better intellisense, better error and warning reporting, it shows the inferred type of each declaration. It's a bit slower though.
There have been several deal-breaking bugs for me [1](https://github.com/ionide/ionide-vscode-fsharp/issues/924) [2](https://github.com/ionide/ionide-vscode-fsharp/issues/706) in Ionide that have been known for six months to a year and still not resolved.
SSD, modern-ish 8 core CPU (AMD FX-8350) with 32gb RAM. Was going to try on another computer when I tried again and realized it was down to 3 sec. No idea what I changed... Haven't even restarted my computer. If it was ngen, it would have compiled all the dependencies when I forced it yesterday, right?
That's a great question actually! You need a new compiler, which I think you can get via: - NetCore SDK, - via full framework SDK (aka VS) or - via Mono (or a separate mono-based distribution, depending on your OS). Mono-based release of the compiler might be lagging, but upgrading NetCore SDK to 2.2.3 released 2019-04-02 should give you the new compiler.
i don‚Äôt like how ionide displays the type to the side now. and it often doesn‚Äôt work. (it often doesn‚Äôt work on visual studio either when hovering.) i get the feeling ionide is developed by only one or a few people, which will mean it will be opinionated. are there settings for these choices?
In VSCode with Ionide you can do it by using the Project Tree view. 
I think that F# UoM have their own set of frustrations. I‚Äôve had some very confusing dimensional analysis moments when the units don‚Äôt negate quite right, no matter how many different aliases or permutations of equivalent units I include. Something like problems dealing with flow can give really ugly units. UoM was a reason I adopted F#, but I don‚Äôt use them much anymore.
Oh this is neat indeed
I don't use UoM much, but a type synonym should work just fine. [&lt;Measure&gt;] type N = kg * m / s^2
I have used UOM in the past however I don't commonly do unit conversions. Frequently in my domain there is only one kind of unit, however when you have feet and kilometers and foot pounds etc it can be very very useful. 
That‚Äôs what I was talking about. My UoM aliases never reduce properly.
I just tested the following: let accel (mass: float&lt;kg&gt;) (force: float&lt;N&gt;) = force / mass and it infers `float&lt;N/kg&gt;` as the return type. It's not what you expected but it's honestly not unreasonable. And if I add a type annotation `: float&lt;m/s^2&gt;`, it happily accepts it.
Ok, you might find it reasonable for simple stuff, but try something like the Hagen-Poiseuille equation. 
How would you improve this system? Honest question, it might even be worth a [language suggestion](https://github.com/fsharp/fslang-suggestions/).
Honestly, I have no idea how the system works. I‚Äôm a physicist, not a programmer, so I mostly just complain without being able to offer actual solutions. But if I did know how to fix it, the only thing I would think to fix is the unit reduction. Just like we have been saying, a `&lt;kg*m/s^2&gt;` divided by a `&lt;kg&gt;` will give you a `&lt;m/s^2&gt;`, but a `&lt;N&gt;` that is explicitly defined as being equivalent to the above units by using the `[&lt;Measure&gt;]` attribute gives you `&lt;N/kg&gt;`. That said, I don‚Äôt know if it‚Äôs some mechanism of reflection that would be required to expose the type alias of `&lt;N&gt;` to the expression.
Considering the abysmal state of tooling at the moment, he is taking it pretty mildly actually. The current state of F# can be compared to how .NET vNext in the beginning of 2015. Stuff is broken beyond belief unless you are a .NET guru and master of NuGet, it will be hopefully be fixed second half of 2038 and for some reason, MS and the community insists that everything is fine. wtf?
Just to be sure we're on the same page: type inference _does_ know that they're equivalent, and `float&lt;N/kg&gt;` and `float&lt;m/s^2&gt;` are just two ways of writing the exact same type. You can do `1&lt;N/kg&gt; + 2&lt;m/s^2&gt;` and that will give you `3&lt;N/kg&gt;`, which is equivalent to `3&lt;m/s^2&gt;`. Now regarding the fact that the type inference should always give the fully reduced unit, I don't think that's always what you would want. Say I divided Joules by Seconds somewhere, I'll figure out much more easily that I'm dealing with Watts if the compiler tells me about `float&lt;J/s&gt;` than `float&lt;kg*m^2/s^3&gt;`. I think in general the compiler can't really guess which one it should show me.
Right, type inference already knows that they‚Äôre equivalent, but my idea of a solution would just add to that by inferring which units to return based on the units it‚Äôs given. Say you give it `&lt;kg&gt;`, the example we have been using would know to give you `&lt;m/s^2&gt;` instead of `&lt;N/kg&gt;` because the former is ‚Äúmore reduced‚Äù since there are fewer composite units of measure (when I say composite, I mean it in the sense that a Newton is a composite of multiple UoM); however, with your example, I agree that some units are better left in their composite forms, and it may be that a step could be added after the negation of units that adapts the return units to match some user-defined units. Expanding on your example, the compiler could see that you have Joules defined, and you get `&lt;kg*m^2/s^3&gt;` as a return type from some expression, and then the compiler can plug J in to reduce the expression to J/s, or even W if that‚Äôs defined.
Unfortunately, what has happened so far is pretty much the opposite. The more functional features C# has had, the more people thought "there is no reason to switch to F#, I can already do all these things in C#". Contrast with Scala, whose advantages over Java were much more obvious (back when Java didn't even have lambdas) and which got more adoption.
I thought F# might be to C# what Scala is to Java but you're about right. Regrettably I've stopped using F# for production work now as C# is good enough and also infinitely superior when it comes to support / tooling / ecosystem etc.
"Good enough" is what gave us the "Javascript everywhere" world
Yes. Good enough is largely subjective and is totally wrong from many-of-us's point of view. If it was good enough, we would write C# instead of F#.
Also to note, is the fact that the C# tooling ecosystem is available to F# developpers. It's all .net, folks.
Been trying to finish an algorithms library for a while now (For learning CS, API design and testing). The algorithms (largely imperative) are written in C#. Test code is an F# project. Link: https://github.com/bfdes/Treadstone 
I'm using Falanx in my personal project - a websocket server that does coordination. Your tool has been working great for me. Thank you!
Had a breakthrough with my new ML implementation. See this [screenshot](https://pbs.twimg.com/media/D3bNT9pWwAIVz4z.png). I now have: * Int, string, tuple, union and function types. * First-class lexical closures. * ML-style pattern matching. * Modules (not higher order). * Parsing, type checking and interpretation. * IDE with error highlighting and throwback of inferred types. * 1.4kLOC for the whole thing. i.e. a usable language! Future work: * Exhaustiveness and redundancy checking of pattern matches. * `open` * Autocompletion in the IDE. Features I want to add longer term: * A fake object system built entirely upon extension methods, i.e. no subtype polymorphism or inheritance but better autocompletion and more concise code. * Reflection. * Web-based IDE. * Built-in serialization. * Graphical REPL. * Rich code comments including typeset mathematics and graphics. * Consumption of JSON web services integrated with the type system. * A programmable wiki with this as the core PL. * A Mathematica-like notebook front-end. * A graphical language where you draw `let` and `match` and only simple expressions need to be parsed. Still no idea what to call it... 
I don't suppose you can post the code?
I've been using VS2019 for a couple of days now and I actually prefer it to VS2017 because it feels faster. However, some of the old bugs are definitely still here. For example, putting the caret at the end of an identifier and trying to use autocomplete to replace it results in autocomplete appending to the end of the current prefix rather than replacing it. On the other hand I haven't seen the rename refactor concurrency bug since I started using it. 
The .Net core 2.2 binaries for linux that run on my machine (fedora 29) have just shown up (in the last few days) and with them installed, a lot more is working for me now. 
&gt; Still no idea what to call it... I'll take this as a call for suggestions :) How about "Verne" (yes, as in "Jules Verne")? Once when I was thinking about what would I call a language if I would be developing it, that name came to me as one of the options.
I can't, unfortunately, as it's a work project :( Still not sure what was causing the slowdowns, though it seems to be gone for the time being.
I did notice that the weird extension exceptions have gone away, which is nice. OTOH not being able to edit .fsx files while the project's being debugged is a bit of a step back.
I find the debugger in VS to be practically useless. It cannot debug stack overflows. It cannot debug exceptions raised in type initializers. It fails to debug mistakes caused by making a library compile to an EXE instead of a DLL. And so on. I had a problem the other day and tried to solve it using the debugger. Completely useless. Couldn't show me the values of any local variables. Clicking on any of the four threads other than the main thread (a WPF app) just gave stock information and no actual debugging information (it claimed they were all running C++ code). 
I feel you. Trying to understand an exception coming from within a sequence or computation is a nightmare.
I didn't even know VSCode had a debugger. I've tried VSCode a few times but found the F# support to be unusably buggy. 
Kind of. It's really clumsy.
To be honest, I'm seriously considering going back to C# after 10+ years of mostly F#. The tooling sucks, debugging sucks, bug fixes are slow to come by, and almost no one else understands my code because F# syntax is so foreign... With C# now having most of F#'s features, the list of reasons to tolerate it is shrinking.
 type Salary = { month: int week: int day: int hour: float } let salaryByUnits salary hours = let month = salary / 12 let week = month / 4 let day = week / 5 let hour = float day / hours {month = month; week = week; day = day; hour = round hour} 1. Typically, record fields are lowercase. 2. The F# compiler can infer the type for the `hours` parameter, so the type annotation is not needed. 3. There's no point in assigning an expression to a name just to have it returned on the next line. An F# function returns its last expression and you can just write the record on its own line. 4. The right pipe (`|&gt;`) is unnecessary when its a single parameter being applied to a function. 
Thank you, F# is fun!
I agree!
the short and direct answer is that instead of doing the individual lets, you could just do: let salaryByUnits salary = {Month = salary / 12; Week = salary / 52; // note there are 52 weeks in a year, not just 48 Day = salary / 365; // could use working days based upon some given holiday schedule Hour = salary / 2080 } I removed your hours because it isn‚Äôt clear what it is for and just to illustrated returning the Salary record directly. now, it is confusing that you have an int parameter called salary but then also a record named Salary. i feel this is confusing. i also feel that the Salary record is too bloated. it contains essentially redundant data. also note that some of your calculations are using integer division. i also feel some of your calculations are incorrect. hopefully this helps some.
As a side note - do not use float for money. It's imprecise. Use Decimal or int. 
1. No PascalCase. [https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting)
Code review: \- Your Salary type is bad because invalid data is easily representable. E.g. \`{Month=1; Week = 1; Day = 1; Hour = 1.}\`. \- The intent of your type is to perform precomputations and avoid calculations when the various members are accessed. This is not applicable here as the calculations are extremely easy. \- salaryByUnits is badly named and its inputs are badly named. One of its inputs is called salary, which is not of type Salary, and not distinguished from the output of the function which is supposed to be a salary/Salary. \- Salary should be a class with implementation details (salaryByUnits) hidden and consistency guaranteed. \- The convention for variables is pascalCase (let Salary =...). \- The numeric types chosen are bad. Particularly overuse of ints.
Yes, you have to sign in to watch the videos. It's worth it, I believe.
I would also suggest a better namings. Your function computes rates based on an annual income, so why not explicitly saying it? Your function parameters become "annualSalary" and "hoursWorked". Then in your record, add the "rate" suffix: "monthlyRate", "dailyRate" and so on... 
I'm coming from nearly the opposite direction: 17 years of C#. C# is a great language. I used to love it. It's still the best for writing OOP. But I can write and refactor large sections of F# code with surprising ease and confidence. Tooling is good enough since I'm just writing code with it. If there's an area where C# has better tooling, like xaml, I can just use C#. (Fortunately, there nothing saying that i can only use one or the other). However, Fabulous is starting to look better and better. The concise syntax is very compelling to me. For example, creating grid column and row definitions and populating the data with tuples looks very nice. Meanwhile in C# land, I'm sick of creating view models for everything. And converters... What a pain. I will agree with you about the syntax being foreign to other people. That is probably the biggest issue. 
Darn it. My bad. Switching between OCaml and F# is too jarring. Thanks for the link, I was looking for the section on records and I guess I missed it.
Thanks for this - definitely my weeks are out! I put together the example rather quickly, my primary goal was to find ways to improve the function body and removing the let statements reads much better :)
"This video does not exist" error [https://skillsmatter.com/skillscasts/13734-lightning-talk-how-to-give-amazing-technical-presentations#undefined](https://skillsmatter.com/skillscasts/13734-lightning-talk-how-to-give-amazing-technical-presentations#undefined) 
That makes sense - thanks
Interesting, I'll have to look into Fabulous. Thanks!
my personal style is to use let declarations (other than when needed or required) to make the code easier to read and debug. in your case, the calculations are easy enough to be put directly in the record expression.
Oh man, I just started submitting bug reports against VS2019 and found that Microsoft rejected all of my similar reports against VS2017 claiming they cannot repro any of them. Here is a 3-liner that shows up two bugs: type MyClass() = member this.My1stMember() = () (MyClass()).My1stMem() Go to the end of "My1stMem" and hit CTRL+J to get autocompletion. For me it doesn't even suggest the member! What do you see? Now move the caret left one character and try again. When I choose to autocomplete to `My1stMember` it actually fills in: (MyClass()).My1My1stMember() 
The first one seems to work fine when I hit Ctrl+J. Moving the caret back seems to work fine as well. https://imgur.com/3Fzww2u The second one gives me "global." https://imgur.com/nmwEz7K I've honestly given up on F# IntelliSense It's always been pretty terrible, and improvements are extremely slow to come by.
Everyone here knows how to do it, but when you ask people to do your homework for you, you could at least try for the bare minimum of formatting this spaghetti.
&gt; is there anything for which C# just isn't as practical as F#? While C# has adapted some very useful features from F#, like for example Linq and lambda expressions, it still remains a language focused around OOP and procedural programming with mutable state being the default. I would say that C# isn't as practical as F# if you want to write FP style apps. Yes, C# has copied many things from F#, but that doesn't mean it is intend or suitable for writing FP style apps. These lifted features are used here and there - usually to do calculations (not for architectural / structural purposes, as you might do in an FP app). Writing F# style code in C# is not idomatic C#, regardless of whether C# has records, tuples, Linq or lambda expressions. C# = OOP with some FP flavor F# = FP with some OOP flavor ploeh has a nice presentation showing how difficult it is to write F# style code in C# without type inference. It's pretty nasty looking. Anyone who tried to do that in a C# shop would likely be checked pretty hard! &amp;#x200B;
&gt; ploeh has a nice presentation showing how difficult it is to write F# style code in C# without type inference. Do let me know if you happen to have a link handy. I just spent a couple hours looking at Fabulous... it looks fabulous, though I almost wish they wouldn't have called it that, because now I can't say anything nice about it with a straight face. I wish Elmish.WPF worked as well as it does. Would have been great to do my work project in Elm/Vue style!
Note that this isn't quite accurate (though I should probably update the actual blog post): &gt; Unfortunately, Microsoft has not released any figures to better understand the range of these improvements. You can see each specific problem here: https://github.com/Microsoft/visualfsharp/issues/6096 Part of the issue of releasing specific figures is that those figures will be completely inaccurate for large swaths of F# users. Unless everyone used the same codebase and performed the same actions, there would be no uniformity in the numbers. Generally speaking, "using less memory" is about as accurate as we can get. For some people, the changes may not even make a difference, especially if they didn't have memory usage issues in the first place.
\&gt;&gt; F# is completely traditional in this sense: massive Framework, massive IDE and slow startup times combined &gt;&gt;with library, DLL, Nuget and DNC vs DNF woes. This is exactly the kind of crap these people don't want to deal &gt;&gt;with. This is correct for me, I don't want the overhead, however I will work with it to get the benefits. What absolutely drives me crazy and its not limited to F# is the fact GIT solutions are posted, but simply downloading them and compiling fails! Then I spend hours or never actually succeed to get them running, Fable was one, Xamarin another and some Jira API. In fact I think I have failed more times to download and get something to work more times than I have succeeded. On top of this if your using these libraries to help you learn how F# works by stepping through a real lief example. its going to put you off, need to be seamless, needs to work even if its not complete.
Ditto. There are too many ordinary developer problems preventing F# from being the turn-key solution many people want.
nice!
Edit: I found a better way to represent the image button via the `View.TapGestureRecognizer`! One on the image and one on the cell `View.Frame`: let view (model: Model) dispatch = View.ContentPage( content = View.StackLayout( children = [ View.Grid( rowdefs=[50.; 50.; 50.; 50.; 50.; 50.; 50.; 50.], coldefs=[50.; 50.; 50.; 50.; 50.; 50.; 50.; 50.], columnSpacing=0., rowSpacing=0., children=[ for (cell, (colIdx, rowIdx)) in indexedCells do let color = getCellColor colIdx rowIdx let imageSource = imageForPiece model.GameState.Board.[cell] let onTap = View.TapGestureRecognizer(command=(fun () -&gt; dispatch (PickCell cell))) yield View.Frame( backgroundColor = color, gestureRecognizers = [onTap] ).GridColumn(colIdx).GridRow(rowIdx) yield View.Image( source = imageSource, gestureRecognizers = [onTap] ).GridColumn(colIdx).GridRow(rowIdx) ] ) View.Label(model.GameState.Message) ] ) )
&gt; The first one seems to work fine when I hit Ctrl+J. Moving the caret back seems to work fine as well. &gt; &gt; https://imgur.com/3Fzww2u Woah, that's really weird that it works for you and not for me.
I had no idea about "Make Object ID". Thanks for the tip. I agree that not having to worry about reference semantics vs. value semantics is one of the main benefits of FP in general, and F# in particular.
I have years of experience doing MVVM in C#. When I started doing F#, I tried for awhile to continue this approach, but eventually just gave it up, and went to programming the visual tree directly. I still do MVVM very occasionally, but only "in the small". I no longer have the giant web of view models managing domain objects all wired together by a DI container, etc. Life is just easier without that, IMHO. &amp;#x200B; This feels much more natural, though I do now feel like I've slipped into some parallel dimension that nobody else knows about.
If you‚Äôre planning on using Core 3 at all, you‚Äôre gonna want to switch to 2019
Unless you have a policy reason to be on vs2017 you should probably move over to vs2019. vs2017 will not be getting any more fixes for F# tooling.
Here's another one :D https://github.com/fsharp/fsharp/issues/898 ``` let e = Event&lt;_&gt;() e.Trigger {|number = 3|} e.Publish.Add (printfn "%A") // Type constraint mismatch. The type 'IEvent&lt;{|number : int|}&gt;' is not compatible with type 'IObservable&lt;{|number : int|}&gt;' ``` Easy enough to work around by either casting the event explicitly to IObservable or using Observable.add instead, but it had me stumped for a while.
The easiest way for me was to target .net core and use the cli tools to create projects. Then I continue using VS Code + Ionide. Rider works pretty well, but I guess you do not want to buy it just for trying F#. Maybe something like this works with the full framework as well. ü§∑‚Äç‚ôÇÔ∏è
It‚Äôs like the Linux Desktop. Always next year! üòâ
I wouldn't expect XAML designer fixed. It was crashing like hell eight-ish year ago, and still not fixed. I ended up just switching to XML editor mode for xaml-heavy applications. It's faster and more reliable.
I know that feeling.. It just becomes so much easier to reason about code.
They've closed that bug report too.
Please can you try the first one again but using `(MyClass()).My1Mem() ` (i.e. with `()` after the incomplete identifier)?
Here's a regression: let f' x = x f' 3 Rename refactor `f'` to anything else and (sometimes, randomly) it fails to change the other.
If you need reliability then you need to stick with VS2015 (which was rock solid). VS2017 was unusably buggy when it was first released but has been fixed up to a barely-usable state. VS2019 retains most of the remaining bugs. For example, rename refactor on `f'` in this code randomly breaks: let f' x = x f' 3 If you enable completions on character insertions and try to autocomplete `My1stMem`: type MyClass() = member this.My1stMember() = () (MyClass()).My1stMem() It autocompletes to the incorrect: (MyClass()).My1My1stMember() Rename refactor is broken on type variables, so trying to rename `'a` to `'b` here: type T&lt;'a&gt; = T of T&lt;'a&gt; list gives: type T&lt;``'b``&gt; = T of T&lt;``'b``&gt; list If you type this quickly then it works: a b c d e f g h but if you type too slowly the editor changes it to: a b c d e f global h And so on. It is quite frustrating to use.
Does Core 3 support F#?
I heard this was the biggest F# Exchange ever with ~200 delegates. Well done!
Thanks. I stayed on VS 2015 for two years, and just felt like I was starting to fall too far behind, so reluctantly made the leap to VS 2017 - which has promptly turned into abandonware. &amp;#x200B; I'm actually contemplating a Frankenstein setup where I use 1) Rider as my primary IDE 2) VS 2015 (and occasionally Blend 2015) when I need the XAML designer. 3) VS 2019 - to monitor for progress and handle files or situations Rider may not be good at. 4) Visual Studio Code - because who knows? It does have extensions for everything, and might be a good alternative at times. Lately my problem with it has been the Ionide extension won't parse F# projects anymore. &amp;#x200B; Needless to say, this is completely nuts.
If you want to see the complete diff between VS 2019 (version 16.0) and VS 2017, it's in the release notes: https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes#fsharp The rename issue mentioned is fixed, for example.
I might be accused of pulling the old ‚Äúno true Scotsman‚Äù but that doesn‚Äôt sound like OOP in a true sense because, from what I‚Äôm hearing, it lacks encapsulation. Having property setters is a huge red flag. Ideally your code wouldn‚Äôt be calling multiple methods (let alone properties) on your class and it wouldn‚Äôt be referenced all over the place. If your object is being mutated and manipulated and everything thing knows what to do it and whenever then I‚Äôd say your code is procedural.
&gt; The rename issue mentioned is fixed, for example. The bugs I listed are all in VS 2019 (v 16.0).
&gt; felt like I was starting to fall too far behind FWIW, I don't think I use any of the language features added since 2010. &gt; Lately my problem with it has been the Ionide extension won't parse F# projects anymore. I've heard mixed reviews but for me VSCode is a non-starter because it is just an editor and not an IDE.
&gt; Rename refactor on f' in this code randomly breaks Yes, this has been fixed. You're probably not saving your file, which is a different issue and unrelated to using `'`.
\&gt; yet, almost all were closed as "cannot repro" Apologies if this
Thanks. Let me know if there is anything I can do to help you repro them. In particular, please note the **"If you enable completions on character insertions (via Tools-&gt;Options-&gt;Text Editor-&gt;F#-&gt;Intellisense and check the check boxes there)"**.
Oh wow. I had no idea it was unsaved files causing the problem. Thank you so much!!!
&gt; but that doesn‚Äôt sound like OOP I would say that OOP is just *software constructed around objects*. Inheritance, encapsulation and polymorphism are *features* of OOP. That doesn't mean that all three of those are required for a code base to be considered "true OOP". &amp;#x200B; &gt; Having property setters is a huge red flag. If that's the case, then why does the an OOP language like C# have property setters? I don't see how the existence of property disqualifies code from being considered "true OOP". If you mean it violates encapsulation, I would disagree with that on the basis that properties exist to preserve encapsulation by providing you with "check points" to validate incoming data instead of simply exposing your class fields publicly. If you are saying that it's just a "bad practice", I would point out that lots of OOP people say that it is bad practice to create inheritance hierarchies. Are they not doing "OOP" either? I think a lot of people have struggled to agree on an answer to the question *what is OOP*. Anyways, I'm not even saying that OOP is bad. I like OOP; but I am tired of the fact that *everything* in C# is a class; however, it's kind of hard to get away from that in C# since that's quite literally the *only tool in the box*. (If you want to be really pedantic, you could argue that you can also code with static methods, but I would counter that that is not idiomatic C#, and you would likely be ostracized by your team). &amp;#x200B; More to your point, I guess you can make the argument that "it's your fault, not OOP's!" (somebody had to say it!) Maybe so. My point was really that C# makes it incredibly easy to shoot yourself in the foot. I am, in fact, starting to feel like I am either too dumb or too lazy to debug other people's OOP creations ever since I started learning F#. :.( I just think to myself, "It doesn't have to be this hard!" &amp;#x200B; Maybe my issue is more about *mutability* than OOP. So maybe a better title would have been, "Mutability &amp; The Make Object ID Band-aid". Actually, it's the combination of mutability and OOP that really gets me, which I guess == C#. ;\^)
Heh, I wouldn't be thanking me - it's a horrible bug that's existed since the feature was added in VS 2017 that is due to how the compiler service itself reads data from disk rather than memory (in certain circumstances) :(
&gt; Maybe my issue is more about mutability than OOP. Pretty much. Now, C# is a direct descendant of Java and Delphi, and thus gained C++ concepts by association. It inherited mutability as a believed-to-be-desirable feature. Luckily, it's evolving into a more and more functional language each iteration. Hopefully, it gets proper immutables sooner rather than later.
Took some digging, but we actually do already have issues filed in these cases. I decided to just create a rollup issue instead so that it's easier for everyone: [https://github.com/Microsoft/visualfsharp/issues/6486](https://github.com/Microsoft/visualfsharp/issues/6486)
Yes, .NET Core 3.0 has equivalent F# support as the latest non-preview .NET Core release. There's some a subtle issue with tail calls, but in normal usage of F# it's not really an issue . . . otherwise, we'd have had endless reports from the people using .NET Core today, since the F# compiler emits \`.tail\` instructions like it's going out of style.
Actually I've had a lot of success using WPF from F# via `MailboxProcessor` which is arguably more OOP.
Actually I've had a lot of success using WPF from F# via `MailboxProcessor` which is arguably more OOP.
&gt; I agree that not having to worry about reference semantics vs. value semantics is one of the main benefits of FP in general, and F# in particular. Big question: does no mutation mean purity is good or are other side effects ok?
&gt; What wasn't clear is that you meant using ctrl+space, not using autocompletion. Just to clarify: I was *not* using CTRL+space, have never used it and don't even know what it does.
TBH these kinds of workarounds are incredibly useful in practice and worth publicizing.
Records are a good step towards more immutability for C#. I have even seen people declare private fields as readonly; which, as nice as it may be, never got much traction since it isn't the *default*. (That guy moved on to work at jet.com, as a matter of fact). Sure you *can* utilize immutability in C#, and you arguably should, but it's still not the default (unlike F#), and that matters. Will it ever be? They copy everything else from F#... why not that too? ;\^)
Well, readonly != immutable. Using actual immutability in C# involves so much boilerplate that it's basically never done. Just yesterday, I had to pause a CR because a developer did public static readonly List&lt;Foo&gt; SomeList = ... Thinking it was safe.
You got an example of ‚Äúprogramming the visual tree directly‚Äù? Or a link to some examples?
F# doesn‚Äôt track other side effects, such as I/O. Personally, I think that‚Äôs just the right amount of purity, but I still admire strict languages, like Haskell.
Meaning they thought that the contents of the list were safe? (Clearly you could just call SomeList.Clear()).
Yep. Even public static readonly IReadonlyList&lt;Foo&gt; SomeList = ... isn't perfect. It's only readonly when accessed via the SomeList variable. It probably started life as a `List&lt;T&gt;` and if someone else has a reference to that, they can still add things to it! So the compiler can't guarantee that the contents did not change, which means that you can't do all the nice things that immutability lets the compiler do for you.
To be fair, they want it in Microsoft/visualfsharp instead. I'll do that later.
That one autocompletes properly when I type My1Mem when "Show completion list after a character is typed" is unchecked, but not when it's checked. So I think that particular feature is just shoddy.
I assume you're being a little sarcastic on that last point. At least for F# compiler and closely related issues, I can't help much because I'm not as deep into compiler theory as some other folks are. BUT, I have contributed to Suave, FAKE, and SqlProvider. Ironically, because I was hanging back with VS 2015, I began to have trouble compiling those projects, as they all went to VS 2017, and I just gave up.
&gt; I have contributed to Suave, FAKE, and SqlProvider. Wow. You're doing better than I am. When this happens to me I think of [Dilbert](https://assets.amuniversal.com/866792b0a205012f2fe800163e41dd5b). &gt; Ironically, because I was hanging back with VS 2015, I began to have trouble compiling those projects, as they all went to VS 2017, and I just gave up. Ooh, I hadn't considered that.
I decided to drop the ball on something less interesting and put out a fix for generic type parameter renaming: https://github.com/Microsoft/visualfsharp/pull/6491 Should be out in the 16.1 update for VS 2019.
Source: [StackOverflow Developer Survey Results 2019](https://insights.stackoverflow.com/survey/2019#top-paying-technologies)
Yessss... Funny that people down voted that. Haters.
Sounds interesting. What does that look like?
https://i.imgflip.com/2yaopq.jpg
I love rider for the big solutions I work on most days, but whenever I get the chance to work on a small single-project codebase VS-code with ionide is great.
This is actually pretty surprising, to me. I would have assumed that pay-per-language would be more heavily influenced by which languages were popular in Silicon Valley (and other super-high-paying enclaves) among the high-paying companies, with JavaScript being the notable exception that is used basically everywhere enough to undo the Silicon Valley bias.
Pay correlates with number of professional years of experience, which is one of the reasons F# is so high. That, and rich fintech companies of course :)
4/5 top paying tech are functional languages. It‚Äôs a great time to be doing FP!
More likely vote fuzzing. :P
Totally. Rider for big projects, VSCode for small ones.
I‚Äôd say encapsulation is the feature that defines OOP. Otherwise you can do anything you want with the data and it is no longer an object that defines both the data and the operations available on that data. I agree your beef is probably with mutation and C# (c# developers?) and it annoys me too!
Union types for: 1. Message catalogue going from the brain to the WPF UI thread. 2. Message catalogue going to the brain from the WPF UI thread. Declarative description of the structure of the UI as a tree of a union type decorated with lazily evaluated WPF objects (the evaluation of which is only ever forced on the UI thread). A `MailboxProcessor` sending and receiving those messages. Recursive knot untied. A function that uses WPF dispatch to receive messages on the UI thread. Recursive knot untied. Main function that initializes everything including tying the recursive knots.
Same reasons I would assume clojure is so high as well
&gt; I‚Äôd say encapsulation is the feature that defines OOP. Otherwise you can do anything you want with the data and it is no longer an object that defines both the data and the operations available on that data. I agree. &gt; your beef is probably with mutation and C# (c# developers?) I love C# (and C# developers -- I am one of them)! OOP and procedural style programming provide such an intuitive way to solve problems that it's easy to see why it's so dominant. But at the same time, it has its drawbacks. This post was really me pushing towards another answer for the question "what can F# do that C# can't." In fact, most of my posts that are critical of C# are just me developing my case for F#. Because otherwise, people will say, "C# is copying all of F#'s features, so why should I bother learning it?" It's a good question, and one that requires some preparation and forethought to answer in a way that is compelling. People will only put forth the effort to learn a new language if they have a strong intrinsic desire to do so; but most of them don't know why they should even bother because it's solving problems that they haven't realized yet, or problems that they have already accepted as facts of development-life and have moved on. I feel like my job then is to get them to revisit these annoying problems, like mutation allowing references to change behind your back. Once that foundation is laid, then it naturally builds the case for F# as the solution to those problems. &amp;#x200B; To put it another way: most devs are way more familiar with statement based programming, and expression based programming seems like an inconvenience. And it is inconvenient at first, if you're not used to it. So it's hard to point out why it's worth going through the hassle of moving to expression based programming without first highlighting the downsides of statement based programming.
Very creative!
It is cool to see, but I don't put much weight in SO survey metrics
vs code all the way, thank you ionide
Well, it's really just WPF programming without MVVM. Create the app and main window, wire up events, and go. I do the UI as a separate C# project. One thing I do is add a custom build step to that so I don't have to mark every member in the visual tree with x:FieldModifier="public" - that gets old very quickly. Also check out jdh30's comment further down, sounds like that's pretty interesting.
Oops.. how could I forget VS Code!
Silicon Valley is just one small mart of a much larger ecosystem. It might be the largest small part, but it is still just a small part.
That is fair, but this chart seems to follow the basic rules of supply and demand. The more common languages have lower salary (easier to find employees). So it makes sense.
I assume a language like go is very affected by where the userbase lives. If most users are getting payed hundreds of thousands in SF because cost of living is so high while ruby/rails developers live in a lot of other areas with lower cost of living, then the numbers aren't indicating what they suggest. I'd like to see metrics adjusted for cost of living by location.
That makes sense. The more niche the language, the harder to hire for it and the higher the pay.
They pay well but I rarely see them posted in my local market. It's a see of PHP, .Net (C# mostly) and Java. At least I like Kotlin though.
Yep. I'm curious how many SE's there are in the world, its in the millions but beyond that I've no idea.
I have played with FSI on Core 3 using the `‚Äîreadline` option and it‚Äôs actually really nice. Has syntax highlighting, tab completion, and is responsive. I don‚Äôt know if this is stable or not but it‚Äôs amazing to not need to open VS and make a script file for some quick doodling. It‚Äôs similar to FSI in VS Mac in that regard.
And it follows the rule of "you get what you pay for." ;^)
Maybe this would be a good use of anonymous records? You‚Äôll need F# 4.6 though.
Now normalize it for cost of living and number of available opportunities.
&gt; syntax highlighting Color?
If you still want some of the F# niceness then take a look at the library language-ext [1] that I've been developing for a number of years. It's a functional 'base class library' that gives you immutable collections, immutable record-types with structural equality, all of the common monads, ad-hoc polymorphism, lenses, newtypes, parsec, etc. I tend to agree with you that that tooling for F# is it's biggest problem. I've had so many problems with it over the years, and it's so slow (the tooling) that it's just a frustrating platform to work with. The .NETCore debacle caused me to drop some F# projects from multi-language solutions. It is totally possible to write pure functional programs with C#, but of course you need a bit more discipline than with F#. Things that bother me about F# when coding it: * Tooling (as mentioned) - things like the file dependency crap * The type inference. Which might seems like a good thing, I often find coming back to old F# code, or looking at F# code that I didn't write, without type annotations - that it can sometimes be hard to just *see* the data flow. * Monads weren't really given the love they deserve and so most libraries aren't building on a common core * It's really just a reskinned C# in many ways. What I mean by this is that it's never gained any of the killer features that other functional languages have (like higher kinds, etc.) Things that bother me about C# when coding it: * Having to explicitly type generic arguments when they should be inferrable (I'm talking about at the point of use, not the declarations) * Lack of discriminated unions (with completeness checking) - this really needs to be resolved * Lack of higher kinds * Keyword overload - it would be nice if C# was slightly more terse. It's starting to happen with the expression methods and the like (which removes the need for so many curly braces), but having to type `new` before a constructor is just unnecessary (for example). * Method group to Func inference it poor - and no built-in option for currying or partial application I still rate F# as a language, it just feels like it could have been so much more. Now, I find it easier to produce principled functional applications in C#. [1] https://github.com/louthy/language-ext
``` let rec myFunc a = match a with | 1 -&gt; myFunc (a + 1) | 2 -&gt; "Yup!" ``` Is this what you want ?
You can declare an either/or type (I don't remember if this is in the standard library) as type Choice&lt;'a, 'b&gt; = | Either of 'a | Or of 'b And then your function as let rec myFunc a = match a with | 1 -&gt; Either (myFunc (a + 1)) | 2 -&gt; Or (printfn "Yup!") Incidentally, the example you gave [compiles and runs successfully](https://ideone.com/kDWUv7), so you might want to take a second look at the problem.
&gt;However, since recursively calling a function is a type mismatch with string the function is a compile-time error. Type inference works just the same with recursive functions, aside from having give it a hint with the `rec` keyword. As long as the types match up, there should be no error for making a recursive call. There doesn't seem to be anything wrong with how myFunc is written in your example, and compiles without errors, although with a warning that the cases are not exhaustive (what to do if a = 3?). The printfn function returns unit (aka void). This makes the type of the second case expression unit and since all cases of a match expression must return the same type, type inference deduces that the first case must also be unit. The first case is the recursive call to myFunc, so type inference deduces return type of myFunc must also be unit. If you want to return a string, remove the call to printfn. For cases where you're not sure what the types F# deduced are (often the case when first learning F#), try specifying the types explicitly. let rec myfunc a : string = ... Doing so now results in a compile-time error that the expected type of the second expression is string, but was unit instead. You can find and fix issues this way, and usually remove the type annotations afterwards or leave them for clarity. In time, you'll get more familiar with how type inference works, and it will be your best guardrail while writing F#. [https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-inference](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-inference)
Thank you all commenters! &amp;#x200B; I took your word that the function compiles and took a good, hard look at my (actual) code. True enough, the problem was not in the function itself, rather in the function's call site (that, since I'm new to F#, I didn't understand the compiler error correctly, attributing the error to the function implementation). Had you not assured me the function should compile I'd probably still be tweaking its body this way and that trying to make it work. :) Thanks again!
Thanks for the very through explanation of type inference in match expressions. That's a **real** "need to know" thing.
I feel like you would have more traction by trying to get people to code in an immutable, well encapsulated and cohesive style. Not all developers realise it can even be done and if they can‚Äôt see that then they won‚Äôt be at a level where the benefits of fsharp make sense. A prime example is adding properties, for a lot of devs that is just their default because that‚Äôs how they‚Äôve always seem it been done others think you need property setters for serialization. Another one is thinking about command and query separation. I believe if you can get your team thinking about those things it makes people more open minded to other languages - or you might decide it‚Äôs not needed after all!
Type errors when using type inference usually have their origin somewhere else than where the compiler shows them. Basically the type inference system previously chose the wrong type on a function and the error only shows up when you use it an hour later, like a function you expected to return an int actually returns a float, and that makes a type inference error later down the road.
eh i dunno, i also have hard time looking at some of these salaries..I'm making 250 round'about doing C# (even tho i love you F#!!!) and there are lots of C# devs out there. when i see averages so low i just wonder what the hell kind of work my fellow devs are subjecting themselves to :(
How much you make is often a product of where you live. At $250,000 I would guess your salary is inflated based on where you live. No one where I live would make that kind of money as a programmer of a mainstream language. As well, a lot of times the average can be brought down by a larger portion of devs being on the younger side with less experience. Typically younger devs make up a larger percentage of the pool as they haven't burnt out yet, or moved on to management yet.
BTW, there's a simpler way to write a function that consists of a `match` at the top level. Something like this: `let rec myFunc = function` `| a -&gt; myFunc (a + 1)` `| 2 -&gt; "Yup!"`
Yes all good points but I live in the middle of nowhere my house cost 109k, but I do work remote and I admit I have a good gig
Wow, that's some really nice work you've done there. Thanks for sharing. I can see that coming in handy for refactoring or adding new features to brownfield C# solutions in an FP way.
The video about JSON really resonated with me. +1,000,000!
FWIW, I originally didn't read this post because it had the self-aggrandizing word "fabulous" in the title. Only when I watched the F# Exchange videos from Skills Matter did I realise that Fabulous is actually some kind of library for F# did I come back and take another look...
How are higher kinds a "killer feature"?
A biased view (but I think has _some_ merit) : FP languages tend to bring more value companies, but also tend to require fewer developers to maintain their codebases, thus making FP developers more valuable and job positions rarer.
Lack of DUs is definitely one thing that's holding me back right now. Language-ext looks pretty nice! How does the Parsec module compare to Fparsec?
Could use Result: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/results
I can see how that could be off-putting. But then again, most of my recent posts have had "click-baity" subject lines. ;)
UPDATE: &amp;#x200B; After reading Jim [Bennett's "Fabulous Resources Guide"](https://github.com/jimbobbennett/Awesome-Fabulous), I saw this really cool nuget package by Zaid-Ajaj called ["Fabulous.SimpleElements".](https://github.com/Zaid-Ajaj/fabulous-simple-elements) It sometimes results in a few more characters, but I like this for three reasons. First, it looks a little more like WPF to my eyes by having PascalCased properties for the elements, one per line. Second, it solves an initial gripe I had in my first post about not having an easy way to browse through the optional function arguments because all arguments can be found as methods on the module name. (Example: "Grid.Rows", "Grid.Columns"). Third, it looks very uniform to have square brackets all the way down. It's also slick the way you don't have to type "=" because each "attribute" is actually a function that takes a single list argument. It makes for a really nice syntax. (Also, you can mix and match with the existing Fabulous controls, as I have done below). &amp;#x200B; Here is the updated version using Fabulous.SimpleElements: View.ContentPage( StackLayout.stackLayout [ // &lt;-- Fabulous.SimpleElements nuget package StackLayout.Children [ Grid.grid [ Grid.Rows ([ for n in 1..8 -&gt; 50. ] |&gt; List.map GridLength) Grid.Columns ([ for n in 1..8 -&gt; 50. ] |&gt; List.map GridLength) Grid.ColumnSpacing 0. Grid.RowSpacing 0. Grid.Children [ for (cell, (colIdx, rowIdx)) in indexedCells do let bgColor = getCellBgColor cell colIdx rowIdx let borderColor = getCellBorderColor cell let imageSource = imageForPiece model.GameState.Board.[cell] let onTap = View.TapGestureRecognizer(command=(fun () -&gt; dispatch (PickCell cell))) yield View.Frame( backgroundColor = bgColor, borderColor = borderColor, gestureRecognizers = [onTap] ).GridColumn(colIdx).GridRow(rowIdx) yield View.Image( source = imageSource, gestureRecognizers = [onTap] ).GridColumn(colIdx).GridRow(rowIdx) ] ] Label.label [ Label.Text model.GameState.Message ] ] ] )
Explains the plebian hate from C# legions.
Doesn't really work with c#.
Its not all that useful in my opinion. Just open up IL spy if you want to get to know a DLL.
It doesn't make sense to mark the other type in this context as an error
best guide for me is Microsoft site where you can download &gt;2000pages PDF with documentation about C#, F#, VB#, UWP, .NET, .NET CORE, etc etc. Also any documentation/examples for C# or VB# are very helpful if you are writing in F#, they are very easy portable to other .NET language. Also ecosystem and frameworks mostly are the same, so documentation based on C# is useful for VB#/F# programmers too. I'll give you several links: * [https://docs.microsoft.com/en-us/dotnet/fsharp/](https://docs.microsoft.com/en-us/dotnet/fsharp/) * [https://fsharpforfunandprofit.com](https://fsharpforfunandprofit.com) * [https://fsprojects.github.io](https://fsprojects.github.io) * [https://fsharp.org/](https://fsharp.org/) * [http://www.fssnip.net/](http://www.fssnip.net/) * [https://wtfsharp.net/](https://wtfsharp.net/) * [http://www.visualfsharp.com/](http://www.visualfsharp.com/)
I found this to be a good guide to .net: [Pro C# 7: With .NET and .NET Core]( https://www.amazon.es/dp/1484230175/ref=cm_sw_r_cp_api_i_9HASCbQ36E8AJ)
Could be, I suspect that fact that all the existing systems are pre-dominantly written in a procedural/OO language creates a feedback effect. I didn't start to learn FP with any plan of getting a job out of it, mostly out of interest and boredom with existing languages which all start to feel a bit the same after a while.
AFAIK the yield bang is just a yield which accepts a collection. The yield keyword is very similar to the one in c#: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield It just returns the element and then continues with the rest of the function. Multiple returned elements will end up in the same enumeration. In your case the yield bang will put all of the elements in that collection in the returned enumeration, which I your case is a sequence.
I am a little confused by this question - that first line isn't valid F# and the general question is unclear. The type `Board` won't get you far because you can't implement `matrix` with a class alone - `matrix` here is a type alias for *any* function that takes in two integers and spits out an int option. You should think of this type `matrix` as being analogous to an interface with only one method. &amp;#x200B; Here's an example implementation of this "interface" using the Array2D module: &amp;#x200B; /// A Matrix is any function that takes in an integer row and integer column, /// then returns an int option. This is an abstraction of a (mathematical) matrix of integers (returns None if the row/col is too large, etc) type Matrix = int -&gt; int -&gt; Option&lt;int&gt; /// twoDArrayToMatrix takes a two-dimensional array of integers and returns a Matrix - /// i.e., this function returns a function that takes a row and column and returns an int option. let twoDArrayToMatrix (input: int[,]) : Matrix = fun row column -&gt; let isValid = (row &gt;= 0 &amp;&amp; row &lt; (Array2D.length1 input)) &amp;&amp; (column &gt;= 0 &amp;&amp; column &lt; (Array2D.length2 input) ) match isValid with | true -&gt; Some (input.[row,column]) | false -&gt; None &amp;#x200B; Testing in REPL: &gt; let my2dArray = Array2D.init 3 4 (fun row col -&gt; row + col);; val my2dArray : int [,] = [[0; 1; 2; 3] [1; 2; 3; 4] [2; 3; 4; 5]] &gt; let myMatrix = twoDArrayToMatrix my2dArray;; val myMatrix : Matrix &gt; myMatrix 0 0;; val it : Option&lt;int&gt; = Some 0 &gt; myMatrix 1 1;; val it : Option&lt;int&gt; = Some 2 &gt; myMatrix 1 3;; val it : Option&lt;int&gt; = Some 4 &gt; myMatrix 1 5;; val it : Option&lt;int&gt; = None You could create `Board` using an underlying 2D array: type Board(inputAr : int[,]) = member AsMatrix : Matrix = twoDArrayToMatrix input and maybe add other helper methods that might be useful, depending on what `Board` is for.
`yield!` "flattens" a sequence. So, [ yield 0 yield 1 yield! [2..3] yield! [4..5] ] will evaluate to: [0; 1; 2; 3; 4; 5]
Starting a spaced repetition pet project in Blazor and F#. Should be fun!
Link please!
Python keeps driving me away from doing anything in ML. I hate the python libraries so much.
I already know all of these sites. The problem is that they talk about things like paket and Nuget and fake and whatnot, usually in a way that implies that I already know them :) But never-mind, I guess it will start to make sense slowly...
Where to start depend on what you're doing. If you're creating a xamarin powered desktop or mobile app, go to the Fabulous site and follow the instructions to install templates and create a project (it creates a sln file as well). Templates will be downloaded and installed via the "dotnet" command line tool that is installed by .net core. This tool will pull from nuget behind the scenes to download and scaffold projects for you. If you're creating web app, go to the Fable site and follow instructions... Same thing. If you just want to create a simple command line app, use "dotnet" cmd to create a new F# command line project. Paket is a package manager that is a superset of nuget; it allows you to pull oss libs from nuget as well as directly from github and a few other sources. Plus it manages dependencies better behind the scenes. Honestly, i only use paket when it is part of a pre installed template, like Fake for example. Fake is usually the last thing i do, as i don't need it until I'm ready to start my dev ops loop for automated builds. I hope that helps.
Thanks, I was overlooking the fairly obvious fact that anything between the braces gets added to the sequence regardless of how the items are generated - function, recursive function or literals etc!
And that book, and many more, are available very cheaply right now as part of a Humble Book bundle: https://www.humblebundle.com/books/microsoft-and-dot-net-books
I assume it's the same here (seems to be, anyways), but in javascript you can think of it as handing over the control of `yield` to another item. So when you `yield!` to `[2..3]`, the `[2..3]` gets control, iterates over all its own items, and `yield`s them directly to the original caller.
Lots of book recommendations here but I say just use Intellisense and play with some examples and you'll get up to speed in no time. What kinds of applications/libraries are you planning to attack?
The "handing over control" metaphor just makes my brain hurt. It's easier to think about the semantics declaratively. Secondly, `yield` in F# doesn't have the same coroutine semantics as it does in Javascript (and C#). There's no handing over of control to the caller. Instead what happens is that the yielded values are "combined" into the resulting sequence.
That's fair. Maybe that is a better way of thinking about it in F#. I wonder why they went with the `yield` keyword in F#, in that case.
It's just a different way of thinking about it :) Co-routines are really handy, and I wish F# had them, but in the case of `yield` there's some incidental complexity in having to think about the thread of execution. As for the `yield` keyword, I dunno why it was chosen. Although it doesn't mean the same thing as yielding control in a co-routine, it gets the point across that multiple values are being returned. It's reminiscent of generators that way I suppose.
Vim
Thank you, didn't know. Now I have lots of books :)
Currently I have a command line tool in OCaml which, as task #1 I want to port to F#. But afterwards I want to add web UI, desktop UI (possibly Electron) and later also mobile apps. &amp;#x200B; I started by creating an app with the SAFE stack, but honestly this feels like an overkill. I just want a simple web server that exposes a GraphQL API.
Whelp, you ARE welcome! (Read 'em all already! :)
Sounds like you just need Giraffe then.
UPDATE: Apparently the Live Update does work, but only for Android / iOS; not for WPF. Had I read a bit more carefully, I would have seen that in the instructions. My bad!
The question is a bit unclear about what you want to do exactly, but yes, I would say that is possible &gt; Is it possible to have the types not erased at compile time ? There are 2 types of type providers. Erased and generative. You will want to create a generative type provider. Do note however that most tutorials and example code are for erased type providers.
Fuck. Videos are in MP4 format and it is not playing in Linux.
Just found out about the Fsharp.TypeProvider.Sdk the ‚ÄòComboProvider‚Äô is a simple starting point. (generative and erasing example) I basically want to generate a DSL from types implementing a certain interface.
This is very amost identical to how you would define normal Xamarin.Forms elements directly in code. In a normal approach in XF, for a move you would remove a piece from a grid cell and then add it to another cell. This is efficient but involves working with changes manually. You could instead, keeping the same grid, remove all pieces, and then add them based on the current positions of the pieces. A little less efficient, but more functional code. In the most functional but most inefficient implementation, the whole view is recreated whenever the grid changes. Can Fabulous manage this updates efficiently while maintaining a functional approach?
Yes, it is efficient. The `view` function creates a virtual UI consisting of a `ViewElement` (which is a graph containing all nested children elements). When `update` is called, a new `ViewElement` is created which is then incrementally compared with the previous. Fabulous then makes intelligent decisions based on the incremental changes detected and only updates those children in the UI graph. It's the same "Virtual DOM" technique that is used by modern UI web frameworks. So Fabulous is providing you with *controlled (and tested) mutability* behind the scenes, on your behalf, in order to achieve this efficiency. Fabulous (and Fable) afford you the benefit of being able to develop using immutable models and a unidirectional flow while mostly mitigating what would otherwise be a huge performance cost in a more naive implementation!
Your types seem fine (personally I would use functions instead of static members for construction, but that's a matter of personal preferences). The validation of the team can be done using applicatives. You should really invest some time into learning about functors, applicatives and monads. They may seem rather complicated at first, but they actually aren't once you understand how they work. Also, they are an integral part of functional programming, even though everyone seems to be afraid of monads. I recommend reading a wonderful series on F# for fun and profit about this stuff ( [https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html](https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html) ). If you're new to F#, learning and understanding this stuff may take a lot of time and effort, but it's definitely worth it. Basically, instead of matching on `homeTeamName`, `homeTeamAttack`, `homeTeamDefence` and `homeTeamMentality`, applicative lets you write something like this: `createTeam &lt;!&gt; homeTeamName &lt;*&gt; homeTeamAttack &lt;*&gt; homeTeamDefence &lt;*&gt; homeTeamMentality` , which (if you remove `&lt;!&gt;` and `&lt;*&gt;`) looks like calling a normal function. Also, it will let you accumulate errors, so instead of a vague `"Error constructing team"`, you'll get a list of actual errors.
Thank you for the reply, I will check that link out and read more into applicatives!
I think let-bound functions inside modules compile to static members, so I would say the first thing to do would be to get rid of any static members that don‚Äôt need to be overloaded, and define them as functions within a module with the same name as your type. If you need overloads, then you will need to define static members, like operators and whatnot.
Check out `Validation` in the FSharpPlus repo [here](https://github.com/fsprojects/FSharpPlus/blob/600f538b4caef97f3159094cb0e34b2215871fef/src/FSharpPlus/Validations.fs), with examples [here](https://github.com/fsprojects/FSharpPlus/blob/600f538b4caef97f3159094cb0e34b2215871fef/src/FSharpPlus/Samples/Validations.fsx).
\&gt; it seems that I need to do a lot of boilerplate code 1. Don't use single-case DUs. They have no value but unfortunately are talked about all the time. 2. Use result types carefully. Result types increase code complexity but have higher performance than exceptions, so should be used if Error cases are expected to happen often. Here is something a lot simpler using exceptions: ```fsharp type Team(name, attack, defense, mentality) = let isValidTA x = 0 &lt;= x &amp;&amp; x &lt;= 100 if [attack; defense; mentality] |&gt; List.forAll IsValidTA |&gt; not then failwith "Invalid attribute score" if String.IsNullOrWhiteSpace name then failwith "Name cannot be empty" member t.Name = name member t.Attack = attack member t.Defense = defense member t.Mentality = mentality ``` However if invalid data is likely to be encountered many times you can use Result types, and a TryCreate method on those paths: ```fsharp type Team(name, attack, defense, mentality) = member t.Name = name member t.Attack = attack member t.Defense = defense member t.Mentality = mentality static member TryCreate(name, attack, defense, mentality) = let isValidTA x = 0 &lt;= x &amp;&amp; x &lt;= 100 if [attack; defense; mentality] |&gt; List.forAll IsValidTA |&gt; not then Error "Invalid attribute score" elif String.IsNullOrWhiteSpace name then Error "Name cannot be empty" else Team(name, attack, defense, mentality) |&gt; Ok ``` In the latter case you can use a record type too if you prefer.
Thanks for the explanation. That is interesting. Grids are fiddly so would be impressive if Fabulous knows how to remove and add items efficiently.
I have used the constrained data types a lot in my fsharp projects and recently open sourced a utility library https://demystifyfp.gitbook.io/fstoolkit-errorhandling to make certain things easy while using this approach. You may find it useful if you are going by the applicative approach and this documention https://demystifyfp.gitbook.io/fstoolkit-errorhandling/index/trycreate may also be useful.
&gt; ...single-case DUs. They have no value... Is this really true? They provide safety, no?
Single-case DUs provide no safety per se. They are just a more complex way to describe an underlying value. They can be used to provide safety by hiding the constructor, but you can do the same thing with less complexity with a class. `type XContainer = TheOnlyCaseOfXContainer of X` is more complex than `type XContainer(x:X) = member t.X = x` because it involves even a type definition and a case definition. Even worse, some people use the same name to describe both things `type XContainerTypeAndCase = XContainerTypeAndCase of X`, extremely confusingly.
Maybe I'm misunderstanding you but I don't see much difference in complexity. What are your thoughts on [this page from fsharpforfunandprofit](https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/)?
To see that it's more complex: 1. In the first example you are defining two things in addition to X, the discriminated union XContainer, and the discriminated union case TheOnlyCaseOfXContainer. 2. It's very hard to name as you can see from the overly complex name TheOnlyCaseOfXContainer, which results in the bad practice of using the same name for the two entities. 3. compare [IL from first](https://sharplab.io/#v2:DYLgZgzgNALiCWwoBMQGoA+B7ADgUwDsACAZQE8IY8BbAWACgYz8iBJAmAYSw4EN4CeAE5EAvEQAqACzwB5AsDKdeEOWHZceMfoJFYwRATCA) with [IL from second](https://sharplab.io/#v2:DYLgZgzgNALiCWwoBMQGoA+MCeAHApgAQCSAdjAMID25AhvKfgE4AUAHguQJSEC8hAW3wCARs0IwAdAA0+hNkA==). What do I think of that page? Terrible. A lot of the rest of the site is very good, but that page has single-handedly created this monstrosity that has now become an obsession that the community has become obsessed with. \&gt; we would ideally like to have lots of separate types for them so that they cannot accidentally be mixed up Occasionally OK but it's actually better not to be obsessed about this. Usually this should be handled by good naming of objects. (If you want more safety in the type system, you could use a dependently typed language.) \&gt; The simplest way to create a separate type is to wrap the underlying string type inside another type. OK, has some value occasionally. \&gt; We can do it using single case union types, like so: type EmailAddress = EmailAddress of string Terrible. This confuses a DU type with a DU case. It attempts to persuade readers that it's simple because the natural language usage looks simple, but this is deceptive. Where you are at the end of the article: very complex code which breaks rules of naming, which does handle unsafe construction from unreliable places but has no way to handle construction from safe places (when you want to create an object yourself that you know is good).
You can cut down on the boilerplate with a bit of OO juice: [&lt;AbstractClass&gt;] type Validated (value, validator) as this = let validationResult = match validator value with | [] -&gt; Ok value | errors -&gt; Error errors member this.Value = validationResult type TeamAttribute(number) = inherit Validated(number, fun value -&gt; [ if value &lt; 0 || value &gt; 100 then yield "Attribute can only be between 0 and 100" if value % 2 &lt;&gt; 0 then yield "Attribute must be even" ]) let attack = TeamAttribute 70
Can you share what you would suggest for a type like EmailAddress? Aside from the naming, I'm curious how something like you proposed before is much different for the following (assuming we want to encourage callers to use a function with validation for creation like the example) points you make: &gt;which does handle unsafe construction from unreliable places but has no way to handle construction from safe places (when you want to create an object yourself that you know is good)
If you don't trust yourself/your team to validate at the appropriate times, you can use: ```fsharp type EmailAddress private (value:string) = static let isValid (s:string):bool = failwith "not implemented" member t.Value = value /// use when handling reliable data static member Create(value:string) = if isValid value then EmailAddress value else failwith "invalid email" /// use when handling unreliable data, e.g. from a UI static member TryCreate(value) = if isValid value then Ok(EmailAddress value) else Error "invalid email" ``` Or do something similar with a record type if you want reference equality.
Ionide often shows errors that aren't in the code. You have to cut and paste the code to get rid of them. Ionide also often autocompletes to library methods/functions when you don't want that. Do you know how to fix that?
The single case DU gives you structural equality for free, but the class uses reference equality. I'm a huge fan of single case DU's BTW!
pretty badass! thanks for posting
Perfectly possible, just remember you can't create any F# based types like records or unions.
Opps sorry I just found this message, glad Falanx is working for you!
Im now working on Myriad which is another code generator, what fun!!
I typed your code into a script and am not seeing the issue you describe. Did I understand your question correctly? ``` type SimpleStack&lt;'T&gt;() = let mutable _stack : List&lt;'T&gt; = [] member this.Push value = _stack &lt;- value::_stack member this.Pop = match _stack with | result::remainder -&gt; _stack &lt;- remainder result | [] -&gt; failwith "empty stack" member this.TryPop = match _stack with | result::remainder -&gt; _stack &lt;- remainder Some result | [] -&gt; None let asd = SimpleStack&lt;int&gt;() asd.Push 5 asd.TryPop &gt; val asd : SimpleStack&lt;int&gt; &gt; val it : int option = Some 5 ```
This is neat, but it would help a lot if you would describe what it actually does at the top. I had to scroll all the way down to the example before I understood what you were building.
[https://github.com/SAFE-Stack/SAFE-BookStore/](https://github.com/SAFE-Stack/SAFE-BookStore/) has an example for both server-side and client-side React rendering with the DSL that looks very much like your example.
Yeah people have been asking to write up Falanx for the last few months so I suppose this has a little bit of identity crisis, the topic of what I could write got out of hand quiet quickly I could of probably wrote 15-20k words on it :-o
I never wrote a front blurb either, so that might of helped, remember Ive not written a blog for a year+ so I'm a little rusty.
There are, naturally, several: https://github.com/ptrelford/FsHtml http://www.fssnip.net/hf/title/DSL-for-constructing-HTML https://github.com/giraffe-fsharp/Giraffe/blob/master/DOCUMENTATION.md#giraffe-view-engine ---- Depending on your needs I'd either stick with a templating engine (separation of concerns), or giraffes, as it's quite popular. Frankly, I've done something similar with XML and the basic syntax isn't that much work to setup, so handrolling something is a viable option here.
Is that DSL general purpose, or is its use tied into the Fable.React library?
It's defined by Fable.React and uses react to do the actual rendering.
Echoing /u/_pupil_, I'd say just use Giraffe's View Engine. They spent some time optimizing the rendering of the nodes and it has quite nice performance overall. You can also easily cache nodes for faster rendering (at the cost of memory) quite easily: [Sample](https://github.com/ImaginaryDevelopment/giraffeCacheTest/blob/master/Cacher.fs)
I can vouch for Giraffe.
TLDR: Process your F# source files with F# code before handing them to the F# compiler. &amp;#x200B; This can be used to do most things you would use a TP for, except without all the silly limitations (e.g., no providing generics, discriminated unions, records, etc.) &amp;#x200B; It works by integrating with MSBuild, using your code to transform one F# AST to another, and finally using Fantomas to render the AST to F# source code.
And what the "applied F# challenge" is. Or at least [link](http://foundation.fsharp.org/applied_fsharp_challenge) to it in the comments over here, or something.
I use them, and overall I don't have many complaints, but I find they still feel like an add-on rather than a core part of the language. I just find it slightly awkward with the amount of *(LanguagePrimitives.FloatWithMeasure 1.0) /(LanguagePrimitives.FloatWithMeasure 1.0) All over the place in my code.
Happy cake day my friend
Checkout Tamizhvendan's books on web development with Suave https://www.demystifyfp.com
So I suppose this isn't suitable (or meant to be used) for the general creation of HTML (e.g. for writing HTML to a file), because the library gives no guarantees that general use will be supported. Thanks anyway for bringing this to my attention.
Not a book but the docs/wiki for Giraffe are surprisingly very good if you're already familiar with the web
Thanks for the suggestion. Is Giraffe's view engine suitable for standalone use? I don't plan on using the rest of Giraffe.
Yep! I've used it with a paket single file reference and integrated it into Nancy for a while.
Strange - I just re checked and it is fine for me too! Thanks for looking. While on this topic, what is the significance of using () ? Many functions seem to work exactly the same for me whether I include them or not. &amp;#x200B; Does it depend on what the function is doing? I remember experimenting with a function that had an inner function to generate random numbers and without () the function always returned the same random number. I'm guessing using () evaluates everything again while omitting them simply binds to the final expression (so it's simply a value)
This is where I‚Äôm currently stuck. I just want DU‚Äôs so badly.. Do you know why type providers cant generate f# specific types ? isn‚Äôt it just metadata ?
Type providers just do basic IL emission from quotations, essentially .net 1.1 era types.
so it is totally possible, the abstractions are just not there in the current type provider sdk.. ?
There‚Äôs no way to write any f# types in the TP SDK, you could probably output the needed attributes and internal classes for unions but there would be no metadata in the generative TP. Also there would need to be a compiler change to write the metadata when the static relocation of types occurs, I.e. moving the generated dll contents to your assembly.
If your matrices are immutable, I would use a named record, which is much more idiomatic in F# than .NET-style classes. Then create a separate Matrix module that implements your functions. If the matrices are mutable and performance is important, then you need to worry about value vs. reference semantics. You might as well be using C# in that case, though. :)
A record type is the appropriate choice if you want structural equality.
Is a single case record less complex than a single case DU?
Thank you for the straightforward guide! It really made it easy!
Yes. It accesses a sinlge piece of data in a standard way and there is no scaffolding for case handling.
What is your reason for avoiding Array2D?
That's super cool! What does gui.cs do?
That's the implementation for the console gui, it does the rendering etc.pp. I "only" build a wrapper around this, for using elmish. &amp;#x200B; look here: [https://github.com/migueldeicaza/gui.cs](https://github.com/migueldeicaza/gui.cs)
Array2D is much leaner as far as higher order functions go, and those functions have made implementing some of my operations very easy. If I use array2D, I‚Äôll probably have to use lots of loops.
Thanks. As someone who just started blogging this year I really appreciate the feedback.
I cannot wait to shoehorn this into my work somewhere. Very, very nice!
nice :) let me know, if you need something :)
You are correct. Leaving off unit as a function parameter defines it as a value that is only evaluated once within a particular context.
This is the start of my new **#FSharp #MonoGame Platform Game Series**
I'm happy about the stronger than usual showing for F# this year. :)
Thanks! As tweeted, I'm using this for a real internal app. (Luckily a relatively simple, low-stakes one.) Just raised my first issue, would be interested to hear your thoughts on that. Apart from that issue, it's working really, really well!
Thanks :) , a part of the fix for the issues is already merged on miguel's side. :) He releases a new nuget package late the day, so that I can merge my fix and release an update.
Yes mad about no mad...
This is brilliant. Not just the synchronization but the quality of the writing as well, a lot of the downfall memes missed the mark but this one definitely didn't. The last line made me genuinely laugh.
This was awesome. So well written. I missed the last line and decided to rewind to see it, so glad that I did as what a kicker. I think I'd enjoy lunch with whoever wrote that.
lol'ed so hard
I‚Äôve just finished myriad: https://github.com/7sharp9/myriad Now working on more YouTube videos
I'm working on DocSoup, monadic extraction combinators for Word docx files. The monad is basically a parameterized Reader monad (the type of the environment changes as you go from Document to Body to Table to Row etc.) plus Error for failure. It used to use Word automation to access the components of a Word file, but since I moved to using the OpenXML SDK I've made a lot of progress and the parametrized monad seems to be working very well. https://github.com/stephentetley/docsoup
Look at https://theimowski.gitbooks.io/suave-music-store/en/
Maybe next year there can be a meta-talk :) "**How F# managed to take over LambdaConf** F# is a strange beast. No higher-kinded types, no typeclasses, and no profunctor optics to be seen. A bastardized version of OCAML for Windows, with adorable aims to be cross-platform one day, F# is run by a bunch of enterprise goobers at Microsoft who struggle to recite even the first Monad Law. But despite all odds, F# programmers now make up the majority of the LambdaConf audience and speakers. Was it all a lie? Years spent waxing mathematical about categories and composition and types just thrown down the drain? Shall we cast away Haskell, Idris, Agda, and ATS and shout, "not today, Satan!" at the top of our lungs? Find out how Microsoft can take over your life with this talk!"
Very cool!
I'd see that...especially if it came true. üòÉ
So a monad is just a fancy flatmap?
Monadic bind is a flatmap operation.
Try this in John Oliver's voice: "You can diminish and undermine anything by inserting 'is just a fancy\`, here me show you \- Tiger is just a fancy cat \- Submarine is just a fancy boat \- Universal healthcare is just a fancy healthcare"
except, not really... [https://stackoverflow.com/questions/35387237/difference-in-capability-between-fmap-and-bind](https://stackoverflow.com/questions/35387237/difference-in-capability-between-fmap-and-bind)
Looking forward to seeing folks there!
Can you post some examples of your arrays? It‚Äôs hard to understand what you‚Äôre trying to do, especially since you‚Äôre naming functions without definitions that we can try in FSI.
Updated the OP.
This is a pretty quick and dirty interpretation, and I didn't get to actually test it, but I think it captures a better way of collection processing, wherein you don't worry about indices as much, and use the higher order functions instead. &amp;#x200B; let diagram = "VRCGVVRVCGGCCGVRGCVCGCGV\nVRCCCGCRRGVCGCRVVCVGCGCV" let students = [|"Alice"; "Bob"; "Charlie"; "David"; "Eve"; "Fred"; "Ginny"; "Harriet"; "Ileana"; "Joseph"; "Kincaid"; "Larry"|] diagram |&gt; Seq.filter (fun elem -&gt; elem &lt;&gt; '\n') |&gt; Seq.toList |&gt; List.splitInto 2 |&gt; List.map (fun row -&gt; row |&gt; List.chunkBySize 2) |&gt; function | [a; b] -&gt; List.foldBack2 (fun row1 row2 xs -&gt; row1 :: row2 :: xs) a b [] | _ -&gt; List.empty |&gt; List.splitInto students.Length |&gt; List.map (fun plants -&gt; plants |&gt; Seq.concat |&gt; Seq.toList) |&gt; List.map (fun plant -&gt; plant |&gt; List.map ( function | 'C' -&gt; "Clover" | 'G' -&gt; "Grass" | 'R' -&gt; "Radishes" | 'V' -&gt; "Violets" | _ -&gt; failwith "Unknown plant identifier" )) |&gt; List.zip (students |&gt; Seq.toList)
I think that roughly speaking, this let shim = Shim.Replace (fun () -&gt; DateTime.Now) shim.With&lt;DateTime&gt; (fun () -&gt; new DateTime(2004, 4, 4)) |&gt; ignore should be more like this, no? let shim = Shim .Replace (fun () -&gt; DateTime.Now) .With&lt;DateTime&gt; (fun () -&gt; new DateTime(2004, 4, 4)) The .With is what actually returns the completed shim, but you're chucking it into the `ignore`. Seems odd that the exception isn't more informational though, seems like it would be pretty easy to tell that you have a half-built shim.
I assumed since this was a C# library that the call to .With would mutate some internal state. But as it turns out, I couldn't get the DateTime example working in a brand new C# project either, but I did manage to get this working: &amp;#x200B; let shim = Shim .Replace(fun () -&gt; Console.WriteLine (Is.A&lt;string&gt; ())) .With(Action&lt;string&gt;(fun (s: string) -&gt; Console.WriteLine("Hihacked: "+s))) PoseContext.Isolate ((fun () -&gt; Console.WriteLine("wefwef") ), shim)
I think it would be safe to make that assumption if it returned void / Unit. I don't think it's too common to see something that both mutates and returns.
What made you think fmap is the same as flatMap (or flat\_map)? They seem to have different names and types.
Ok, I figure out how to get Pose working at all in F#, but now I'm struggling with getting the correct signature of a call to printfn "Herp: %s" "derp". I know it takes in a TextWriterFormat&lt;'T&gt;, but how does it work with the other parameters? &amp;#x200B; I've updated my post with another code block. &amp;#x200B; Thanks for the help
think that remaining issues is probably just that Console.WriteLine returns void while printf returns Unit - just put () on a line on its own after the Console.WriteLine to get the return types to match.
That was it. I Had to change the F# Func casting from Action to Func .With(Func&lt;Printf.TextWriterFormat&lt;unit&gt;, unit&gt;(fun s -&gt; &amp;#x200B; &amp;#x200B; Thank you so much for your help
I am currently estimating / architecting a solution that will backup around a 1000 projects that are hosted on Autodesk Forge (AWS) to Azure. My team lead said, "maybe this would a good project for you to use F#." I wholeheartedly agree! (NOTE: you would have to refer to my previous posts here to understand the full significance of that statement). Incoming F# Durable Functions! UI would most likely be Aurelia, because it's my favorite UI framework, and also because baby steps (I'll have to build up to Elmish).
You should post these here: https://github.com/Microsoft/visualfsharp/issues
Oh yeah, that's a great starting point (a tad TMI since I'm trying to solve it for learning purposes, but you taught me stuff in the process, so I suppose it all works out, hehe). &gt; |&gt; function // interleave the two rows &gt; | [a; b] -&gt; List.foldBack2 (fun row1 row2 xs -&gt; row1 :: row2 :: xs) a b [] &gt; | _ -&gt; List.empty This is the actual answer to my original question of "how to cleanly pass two elements of an array in as parameters to a 2-parameter function." I learned about `function` previously but hadn't understood the use-case for it properly. This makes much more sense, as you can freely customize how you handle the resulting expression based on its structure, even capturing elements in the process. Thanks for the headstart!
A separate random question: Do you know if there is a way to "step through" a pipechain in an expression in F#? Using the interactive console can be really annoying since I'm having to re-type stuff that's already in a file, and there's no intellisense either. I'd like to be able to just add a breakpoint and see a print out of the variable's state after each pipe operation. Is that a thing?
Hm, not that I know of. You know you can highlight sections of your code and hit Alt + Enter to send it straight to FSI so you aren‚Äôt retyping stuff (works in both VS and VSCode), so you would basically highlight up to the point in the pipe chain that you wish to evaluate, hit Alt + Enter, and it will only evaluate the selection. I‚Äôm a diet programmer - I know the language and whatnot but there may very well be some feature of the tooling of which I‚Äôm not aware.
Please post this in https://github.com/Microsoft/visualfsharp/issues
I found a [solution](https://exercism.io/tracks/fsharp/exercises/kindergarten-garden/solutions/2114c493bfce41b9bd65f47399031f68), by the way, in case you wanted to have a look. Cheers!
&gt; You know you can highlight sections of your code and hit Alt + Enter to send it straight to FSI so you aren‚Äôt retyping stuff (works in both VS and VSCode), so you would basically highlight up to the point in the pipe chain that you wish to evaluate, hit Alt + Enter, and it will only evaluate the selection. Wow, this is a lifesaver that makes it so much more powerful. Combined with vim controls to help highlight things more quickly, this can make for some impressively nice workflows.
Just posted on github, [https://github.com/Microsoft/visualfsharp/issues/6688](https://github.com/Microsoft/visualfsharp/issues/6688)
I had a similar problem for a small project I am very slowly working on. I ended up doing something like this: &amp;#x200B; type Matrix&lt; ^T when ^T : (static member (+) : ^T * ^T -&gt; ^T ) and ^T : (static member (-) : ^T * ^T -&gt; ^T ) and ^T : (static member (*) : ^T * ^T -&gt; ^T) and ^T : (static member (/) : ^T * ^T -&gt; ^T) and ^T : (static member Zero : ^T) and ^T : (static member One : ^T) and ^T : (static member Sqrt: ^T -&gt; ^T) and ^T : struct and ^T : equality&gt; = | Diagonal of ^T array | Tridiagonal of Tridiagonal&lt; ^T&gt; | Dense of Fast2DArray&lt; ^T&gt; | Sparse of SparseMatrix&lt; ^T&gt; | UpperTriangular of UpperTriangular&lt; ^T&gt; | LowerTriangular of LowerTriangular&lt; ^T&gt; // ... Orthogonal, etc etc etc. I actually have IntegralMatrix&lt;^T&gt;, RealMatrix&lt;^T&gt; and ComplexMatrix&lt;^T&gt; separately. The `Fast2DArray` type is a slightly more performant (but less safe) 2D array using a backing 1D array. But you could use an out-of-the-box 2D array for this. `Tridiagonal` is a record type using 3 backing 1d arrays. `SparseMatrix&lt; ^T&gt;` actually uses a dictionary whose keys are (struct) pairs of integers and values are \^T. And the constructors of all these have validators (tridiagonal arrays have length restrictions, Fast2DArrays check the input number of rows and columns against the backing 1d array, etc. &amp;#x200B; The point is that type of your storage implementation depends on the structure of the matrix, for both performance and semantic reasons. But you use a union type to bring those disparate data structures into one `Matrix` type. And then you use pattern matching when defining operations on those matrices. This is far from optimal but still faster than doing everything with an out-of-the-box 2D array. static member inline (+) (fst: Matrix&lt; ^T&gt;,(snd: Matrix&lt; ^T&gt;)) : Matrix&lt; ^T&gt; = if fst.Dimension &lt;&gt; snd.Dimension // Dimension is a two-integer struct then invalidArg "fst,snd" "matrices must have same dimension to compute sum" match fst with | Diagonal d1 -&gt; match snd with | Diagonal d2 -&gt; d1 |&gt; Array.zip d2 |&gt; Array.map(fun (a,b) -&gt; a + b) |&gt; Diagonal | Tridiagonal t -&gt; let newDiag = t.Diagonal |&gt; Array.copy |&gt; Array.zip d1 |&gt; Array.map(fun (a,b) -&gt; a + b) Tridiagonal (new Tridiagonal&lt; ^T&gt;(Array.copy t.LowerDiagonal,newDiag,Array.copy t.UpperDiagonal)) | Dense d -&gt; let dCopy = d.Copy() d1 |&gt; Array.iteri(fun index value -&gt; dCopy.[index,index] &lt;- dCopy.[index,index] + value) Dense dCopy | Sparse s -&gt; let sparseCopy = s.Copy() d1 |&gt; Array.iteri(fun index value -&gt; let coord = {row = index; column=index} sparseCopy.Update (value + s.nonzeroValues.[coord]) coord) Sparse sparseCopy // assume adding diagonal entries doesn't meaningfully affect sparsity // and so on with the other cases of fst. &amp;#x200B; So I think you're on the right track with how you're approaching this problem, but don't limit Square / Hessenberg / Tridiagonal / Unitary / etc to be represented with the same data structure.
I stand corrected
Looks really good! A huge improvement you could make, though, is by not using List.concat. It would be better to use a cons pattern to combine the Lists. Due to the nature of Lists in F#, concat is a very inefficient operation.
I'm not a candidate, but I'd be keen to hear your experience in hiring F# devs if/when your recruitment process is complete?
I couldn't stop laughing at this - brilliant.
Thanks Phillip. Hopefully I'll work it up to being ready for Nuget by the summer.
Because it takes people to do the work bro! Seriously though, I‚Äôm jumping into F# as well and while everything is great many things are undocumented or ‚Äúcommon knowledge‚Äù that isn‚Äôt obvious to non .NET insiders.
I don't think the Visual Studio install adds any of its tools to the path. Instead, it gives you a separate [Developer Command Prompt](https://imgur.com/a/f3ElVin) that knows where fsi.exe lives.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/4TtguqK.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20emm7hr9)
I think the latest dotnet core or F# lets you do `dotnet fsi` `dotnet --help` says Additional commands from bundled tools: fsi Start F# Interactive / execute F# scripts.
i am not at my computer to try this out but how does this help? is there a shortcut file that tells you where fsi is at? because it isn‚Äôt in that directory. it knows where it‚Äôs at, but i want to know. again, this may be simple, but i can‚Äôt check right now.
\&gt; automatically added to your path What does this mean?
added to you user or system path variable upon installation.
Side note about searching files on Windows. I use Everything by Voidtools instead. Seriously quick. I have no idea why Windows Search continues to be such a dumpster fire. I have nine fsi.exe on my machine now :) [https://www.voidtools.com/](https://www.voidtools.com/)
I assume it's not added to Path because of side-by-side versioning (more than one version of F# installed at once). The location does appear to be [documented](https://docs.microsoft.com/en-us/dotnet/fsharp/tutorials/fsharp-interactive/).
Been at it for a long time now. We rarely are able to find people with F# experience, so we target desire to learn. We have a set of materials we have the new devs work through after they start.
thanks for that. i use it but was on a new machine. haha. it is indeed crazy good at finding files.
thanks for loating the documentation! i was wrong then. this will be great to bookmark since it has changed location a handful of times.
This is how you start fsi.exe from a command prompt without having to know where it lives.
It‚Äôs changed once.
Thanks [u/aviniumau](https://www.reddit.com/user/aviniumau) !! &amp;#x200B; To try it out, just follow 3 steps: 1. Download the Java JAR ([https://oss.sonatype.org/content/repositories/snapshots/org/openapitools/openapi-generator-cli/4.0.0-SNAPSHOT/openapi-generator-cli-4.0.0-20190506.150008-621.jar](https://oss.sonatype.org/content/repositories/snapshots/org/openapitools/openapi-generator-cli/4.0.0-SNAPSHOT/openapi-generator-cli-4.0.0-20190506.150008-621.jar)) 2. Rename the JAR as "openapi-generator-cli.jar" 3. Run the following command to generate a F# Giraffe server stub for Petstore API ([https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/modules/openapi-generator/src/test/resources/2\_0/petstore.yaml](https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/modules/openapi-generator/src/test/resources/2_0/petstore.yaml)): Mac/Linux: \- java -jar openapi-generator-cli.jar generate -g fsharp-giraffe-server -i [https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/modules/openapi-generator/src/test/resources/2\_0/petstore.yaml](https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/modules/openapi-generator/src/test/resources/2_0/petstore.yaml) \-o /var/tmp/fsharp-giraffe-petstore/ Windows: \- java -jar openapi-generator-cli.jar generate -g fsharp-giraffe-server -i [https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/modules/openapi-generator/src/test/resources/2\_0/petstore.yaml](https://raw.githubusercontent.com/OpenAPITools/openapi-generator/master/modules/openapi-generator/src/test/resources/2_0/petstore.yaml) \-o C:\\temp\\fsharp-giraffe-petstore
okay.
I can't say that "I knew it," but I suspected it. This is going to be really, really cool!
It's a shame I'll be out of my current job by then, but leaving them at 4.8 should posture them for years to come.
While I don't think this means anything specific directly for F# (maybe I'm wrong here), this might be great for overall .NET usage on Linux, and F# would benefit greatly from that. People I know IRL that would love to working in a language like F# are more into Linux than Windows (this could be anecdotal, though)
Hi Will, good to see you in here! I don't have much time right now, but here's my solution, maybe it helps: [https://exercism.io/tracks/fsharp/exercises/kindergarten-garden/solutions/4073270c74c44ddead3df6bf2fef4548](https://exercism.io/tracks/fsharp/exercises/kindergarten-garden/solutions/4073270c74c44ddead3df6bf2fef4548) &amp;#x200B; In order to combine two containers of equal size into one container of value pairs you can use the zip function.
This is fantastic. I was looking for something like this!
This is correct. Especially since .NET 5 is so far off there's nothing specific about F# planned for it yet. We haven't yet decided if we'll version in lockstep similar to what is planned for C# (as mentioned in the post), but it's certainly a possibility.
Thanks. This is available on .NET core 3 preview.
 Almost forgot, I am working on a Revit - Fabulous template: [https://github.com/JordanMarr/revit-fabulous](https://github.com/JordanMarr/revit-fabulous) &amp;#x200B; The template part is done, but I'm still having some technical difficulties getting the LiveUpdate to work the way I want it to because... [reasons](https://github.com/fsprojects/Fabulous/issues/397). It's complicated, so I may not be able to get it do what I want, but I'm not giving up yet because I think it would be hella cool to be able to change UI code on the fly without having to restart Revit every time.
I‚Äôm actually using a Matrix DU that looks almost exactly like yours. I‚Äôve seen you post some quality stuff, so I‚Äôm definitely happy that my code parallels your example. I have specific types (eg. L/U matrices are `'T[][]`, whereas Tridiagonal has its own struct with its own linear system solver, etc.) defined for everything except NxM matrices, for which I have been using `'T[][]` but figured I could squeeze a little more horsepower out of it by using a 1D array after a some preliminary benchmarking, and also more easily add some static member overloads for linear system solvers and inner products without needing to extend the built-in array types (which I only try to do as a last resort in any scenario). But, for something as simple as a 2D regular matrix, I just wondered whether other F# users would use a record, struct, class, etc with fields for the dimensions. I tried using `array2D` but it was ~40-100x slower for solving linear systems and eigendecomposition for the matrices I benchmarked, and the paucity of higher-order functions made for some ugly unintuitive code. I also tried a solution using DUs of DUs, but this ended up throwing an internal compiler error about an unsolved type variable `?_^...` that intellisense didn‚Äôt catch (the bug report is on the visualfsharp repo - I‚Äôd link it in case you‚Äôre interested in seeing it but I‚Äôm on my phone). It looked like it would have been a clean solution to unify DUs of `Vector` and `Matrix` types under a generalized rank-n tensor/holor type. - As an aside, what is your opinion of array2D on .NET Core performance-wise? I‚Äôve read mixed reports, especially with regard to the array2D bounds checking. I‚Äôm using Framework at the moment so I can work with WPF and Wolfram .NET/Link, but I‚Äôd like to switch to Core 3.
You're correct. It's a problem for F#, they want the cool kids interested but when they see Dom Syme only doing stuff in Visual Studio they don't think about OSS (no diss at Dom btw, he's great).
That would be considered to be a handful of times though?
I feel that he's exaggerating. Windows Store is a necessity and will only grow more popular over time as the next generation assumes that app stores are where you get software. Which makes me question the rest of his claims, especially in light of the back peddling at the end. Finally, WPF never "died", UWP was always an alternative rather than a replacement.
I went from c# to f# and thought that I would never use c# again. Then I went to Haskell and realized that if I‚Äôm doing FP then I‚Äôll use Haskell, no competition , so now I will just use c# if I have to be on .NET and Haskell otherwise.
I feel some anti-UWP folks always try to bend the facts to their narrative, despite what we on Windows land are actually developing on regarding APIs.
I see UWP is still as irrelevant as ever.
&gt; Windows Store is a necessity and will only grow more popular over time as the next generation assumes that app stores are where you get software. Wouldn't it have already become the default, given that it's been more than 10 years since Apple popularized that particular flavor of distribution? That's quite a long time for people to get used to things. I don't buy the argument that the next generation will assume that app stores are where you get software. If they can _easily_ install something from a page they got to via a web browser, why not just do that?
Changing habits take time. And for a long time full desktop applications weren't available in the store. Also, people are taught to not download random programs off the internet. So for many customers the app store is the only way to reach them.
I don't disagree with what you've said here, but at the same time I don't find that compelling enough to believe that the app store will grow more popular over time as the next generation assumes that app stores are where you get software. Unless some radical shift happens, I don't see it being any more popular than today, proportionally.
I'm certainly not betting on it myself.
I have known that UWP would be a dead-end since day one. What did the demise of Silverlight tell us? MS could fop that one off on Google, but then they deprecated WPF, thereby sending a clear message - "Every few years we are going to deprecate the UI framework that you have so heavily invested in and ask you to start over." &amp;#x200B; Consider what a wonderful grid control DevExpress makes for Winforms. Later, their WPF grid reached feature parity and became just as good. How long did that take them? *Years*. And about the time they finish - MS throws WPF in the trash can. &amp;#x200B; This is why one reason that the majority of young developers today are so focused on web development. Well, obviously the world wants and needs the web platform to continue to evolve, and lots of sharp people to do that. But many desktop apps will not soon, or in some cases, ever, be replaced by a web application. The web platform is constantly evolving, but last I checked, &lt;title&gt;HTML Tutorial&lt;/title&gt; still works and will never be deprecated. Remember when Microsoft was known for backwards compatibility? Remember when Raymond Chen himself patched some game so it would run on Windows 98? &amp;#x200B; Developers won't flock to an ecosystem that is being suicided by its creator. Can anyone blame them?
Easy updates are just as important as easy install. On my Windows machine there are some apps that are not updated because I did not manually update them, some apps that require admin priviliges to update, some apps which have deployed their own update services that are running all the time. It's crazy. Where you go to get the app is not the main thing. Users do not care about stores per se, but they do care about automatic updates and performance. UWP has both. WPF will get good performance (with AOT compilation planned for .Net 5 late 2020) and if it also gets an easy integrated updating mechanism then no one will care about the difference between UWP and WPF.
Agreed. All this news is that, as we knew before, UWP and WPF are going to get closer together. No need to frame this in terms of life and death.
This is pure FUD. Thurrott is clueless regarding modern Windows development these days. https://www.onmsft.com/news/build-2019-microsoft-says-its-still-fully-supporting-uwp-apps-and-the-windows-10-microsoft-store He also declared Cortana dead, yet it's more alive than ever.
Indeed, this article is baseless FUD. Thurrott doesn't know what he's talking about. Meanwhile * https://www.onmsft.com/news/build-2019-microsoft-says-its-still-fully-supporting-uwp-apps-and-the-windows-10-microsoft-store * https://twitter.com/ryan_levick/status/1099944047152689152 * https://twitter.com/WABetaInfo/status/1125852891997143040?s=20 Also, Intel, Realtek, NVidia, Adobe and others are embracing UWP. See also here, with his agenda to keep making UWP look bad https://www.thurrott.com/dev/203536/dev-interview-corels-gerard-metrailler Also with a dishonest developer that claims that Corel's apps are optimized for pen &amp; touch. &gt; But, again, the real question is why? What is the benefit to the user versus just getting the CorelDRAW for Windows? It‚Äôs working today really, really well, and is already optimized for high DPI, is already optimized for pen and touch, and is already optimized for all those things that you would gain as a benefit of UWP in theory. Meanwhile https://www.windowscentral.com/coreldraw-review-unique-and-professional-graphic-design-software-windows-10 &gt; At least the 2018 non-Store version (which I love overall) also lacked good touch support. That was disappointing to me for a product designed for artists on Windows 10 in 2018. If this is like a Centennial bridge from the 2019 desktop version, I don't think they've made many changes to the touch support. &gt; I want to be able to use my left hand for touch to pan and zoom the canvas, while drawing with a pen using my right hand. That's not really possible (at least not in the 2018 desktop version). &gt; I have only 2 gripes with Corel‚Äôs suite relate to touch and pen support, where only two-finger touch to zoom can be used concurrent with pen and mouse. Otherwise, it treats all forms of input the same, which is a real shame in the modern era with Windows Ink, and expectations of touch to drag the canvas or workspace with one hand, while actually drawing on it with a pen in the other. You pretty much need hacky workarounds to make Corel products usable on tablets. https://www.youtube.com/watch?v=8MGQMHU2XvQ He also spreads FUD about Cortana being dead, yet it has significant usage. https://www.reddit.com/r/apple/comments/bipf1m/microsoft_releases_voice_assistant_usage_report/ But he keeps writing negative about it. He just wants to be right. https://www.thurrott.com/smart-home/205588/microsoft-issues-digital-personal-assistant-report Also don't forget his overly negative Surface Go reporting and Mail app reporting, yet he's overly praising the Surface Laptop, wrongly predicting that it would be the best selling Surface product. Thurrott is simply out of touch regarding modern Windows usage and development.
Thurrott is also spouting FUD on twitter. https://twitter.com/thurrott/status/1126191478659792898?s=20
&gt; I feel that he's exaggerating. Bitter Old Man Thurott? Misleading ClickBait titles? You don't say!
Well, MS definitely has to improve the app store a lot, too. Apple started with 0 apps on iOS outside of the App Store, so obviously that's where all the developers and users went. Windows has not abandoned backwards compatibility and the vast majority of apps and app developers were pre-app store. *That* is what is going to take a lot of time to change. You don't just throw away your knowledge and workflows for no reason. You'll notice that Microsoft is doing quite a lot to set the stage, however. Rather than letting the store wither and die, they doubled down by expanding what you could put in the store, which keeps it short term viable. Meanwhile, on the app development side, they are making it easy for the MS dev toolchain to be *the* one-stop shop for cross-platform development. And they bought github. If you're sitting there with a developed app and you're just one checkbox away from "publish to Microsoft Store", you're more likely to do it.
Perfectly neutral question, why would you choose any language? The two reasons you mention there are pretty great reasons to use it if you ask me, but it seems like you're searching for something else. Are you trying to look for examples of where F# is currently used?
You named it. It has all the benefits of functional programming plus all the benefits of the .NET platform. Honestly, it‚Äôs a great all-around language. It can do everything C# can do, but better.
I'm an F# newb, and just learned about type providers. The fact that I no longer have to deal with Entity Framework (or any other ORM) has me positively *giddy*. It eliminates so many boilerplate DTOs and possible null exceptions from missing `.Includes` https://www.youtube.com/watch?v=RK3IGYNZDPA *GIDDY* I tell you.
Strong type safety. It's type system allows you to ensure your domain objects are always in valid states. You resolve most errors at compile time rather than during execution. If it compiler it's probably correct. The type inference it's hella good. It's incredibly terse and expressive. Your code will be four times smaller than equivalent C# code and with fewer bugs due to the above type system. Concretions are never null. Instead of nullable you use an Option which allows the compiler to ensure you don't have any of those stupid null reference exceptions at runtime. You don't use exceptions. Although they are available there are better ways to handle exceptions which provide perfect consumer contracts. Values are immutable so multithreading is easier and functions are easier to reason about. Union types and pattern matching allow the compiler to validate your handling of different types. When you add another possible type to your union the compiler tells you everywhere you need to add it. C# has nothing like this. Functions are first class. Using functions instead of classes makes SRP out of the box. You don't need an IOC container, object mocks, or a deep dependency graph, all of which make testing hard in C#. Instead you just pass state and functions (including partially applied functions) around. F# interops with C# so you can use C# libraries although you have to be careful about the C# types and exceptions being passed back.
I highly recommend checking out fsharpforfunandprofit. It has so many good language examples. Once you learn them writing C# becomes painful because you want to use a useful pattern but either impractical or impossible in C#.
&gt; It can do everything C# can do, but better. i don't think that's true for designing user interfaces or coding video games.
- domain modeling - data handling - less bugs - easier to refactor code - easier to reason about code - concise, easier to see more code at once - type providers are nice (when applicable)
If you like Elmish architecture, C# can't touch it.
mind pointing me to something regarding that? or something someone has built for it? event based and oop architectures are pretty good for user interfaces.
Even the front-end people like the elm architecture - see react/redux
- https://fsprojects.github.io/Fabulous/ - https://fsbolero.io - https://fable.io
i wasn‚Äôt referring to web apps in my original post. i was referring to desktop apps and wpf/uwp/xaml.
i guess i should have been more clear in my original post (thought it was clear in reference to c#), but i was primarily referring to desktop apps and wpf/uwp/xaml. the first link targets xamarin forms, which is a choice already putting you multiple generations behind .net core wpf/uwp. fable seems okay, and i hadn‚Äôt heard of bolero. however, none of these will have the established use and testing of uwp/wpf.
Great point. It‚Äôs quite likely that asking for examples would have been the superior question to ask by far.
I was just pointing out other examples of of the same architecture's success, which is quite a departure from traditional event based oop ui. There's probably more literature/articles comparing it in the context of web apps
It‚Äôs actually very nice for UI‚Äôs. I build WPF apps in F# using [FsXaml](https://github.com/fsprojects/FsXaml). Do people really write video games in C#? I‚Äôve never tried in F#.
The Unity game engine uses C#.
&gt;it can do everything C# can do, but better. Would you mind going into more detail? I am a mere novice at C#, and so don‚Äôt fully appreciate this remark‚Äîbut I‚Äôd like to.
- https://github.com/elmish/Elmish.WPF
&gt;or coding video games. Why? I get the UI thing because of lack of tooling support, but games? I can't do _Unity_ (well, it _can_, but I wouldn't recommend it) but it works perfectly fine with Monogame, SDL2, SharpDX, etc. My only request for F# in that department would be applicative syntax for computation expressions. It would _help_ writing functional code that barely allocates at runtime, but nothing you can't already do. Specially now that we have support for read-only structs and better byrefs.
I've been doing F# since 2011. Still giddy!
That‚Äôs fud/trolling.
1. Static typing (and lack of nulls) eliminates most bugs. 2. Functional type system includes first class functions and discriminated unions. You can model an object according to its true nature, without reducing it to primitive objects and table structures. 3. Clean and concise syntax, with type inference helping here. 4. Linear code, where to understand a piece of code you can read the previous code in order up to that point. Opposite of spaghetti code. 5. Easy access to a large set of libraries and UI frameworks via .Net. 6. Type providers are great for database access.
To add my 2c: F# is also a very versatile and expressive language that lets you model in DSLs way beyond what C# syntax and lack of currying allows for: Take for instance [canopy](https://lefthandedgoat.github.io/canopy/), an F# selenium wrapper, which allows for web ui automation via a dead simple scripting convention that you barely need to know any programming to use, let alone F# (which makes it a pretty good fit for QA depts with limited coding expertise), and it's also worth checking out how [Fable](https://fable.io/repl/) and [Fabulous](https://fsprojects.github.io/Fabulous/views-elements.html#layouts) use F# to completely do away with markup languages (html &amp; xaml respectively). It also boasts scripting and a REPL, which is a great help for algorithm mock ups, trying out APIs, being able to immediately find out how something works, or just plain brute forcing a problem to get an idea of what sticks. Trying stuff in the REPL can give you quite the running start for when first feeling out with library you've never used before. A REPL is basically indispensible for machine learning and data science, nothing like not having to relaunch an entire project every time you want to interact with your models or visualize your data. In the same vein, note that F# also has a pretty good [jupyter version](https://github.com/fsprojects/IfSharp).
You don't even use Windows. archive.is/cOY0G
Filthy lies. UWP will show all lying liers to be lying when Windows Phone is born again
OK but there is already a thread about this and this is the wrong forum.
that article is just a click bait title and isn‚Äôt anything microsoft has said.
fsxaml is completely undocumented and hasn‚Äôt been touched in over a year.
monogame and sharpdx are effectively deprecated. sdl2 the library doesn‚Äôt appear to be, but i would be very surprised indeed if the f# wrapper for it poses any challenge to developing games with unity and c#. people keep responding to me with all these little projects, but they are all basically unused, undocumented, side projects that are nowhere near the usage and documentation and capability of uwp/wpf/xaml and unity. my original point stands that f# is objectively not better than c# for graphics or games.
no it isn‚Äôt at all.
The lack of documentation is unfortunate, because it works great. It hasn‚Äôt been touched because it‚Äôs finished.
The title of that thread contains a lie. Also, why not tell to the trolling OP of that thread that it's the wrong forum? Especially since he doesn't even use Windows. https://www.reddit.com/r/fsharp/comments/bmiksr/microsoft_confirms_uwp_is_not_the_future_of/emwzg54/
does it work with .net core 3, which is the recommended way to start new uwp/wpf/xaml projects? the only type provider i have ever tried to use was the .ini type provider in fsharp.configuration, and that didn‚Äôt even work in the simplest case, so i have remained suspicious of type providers being robust.
C# is an imperative, object-oriented programming language (OOP). You can write code in that style using F# as well, but with a greater awareness of the pitfalls, such as null references and mutable variables. F# is mainly a functional programming language (FP). Many of its best features have been shoehorned into C# over the years, but are often more pleasant to use in F#. Examples: Type inference, lambdas, tuples, pattern matching, local functions. Since you're a newbie, I have to be honest with you: I was exaggerating for effect in my original comment. Technically, there are still a few things that C# can do that F# can't. Probably the biggest one is the limitations on imperative loops in F# (for loop, while loop). There are also a few minor features of C# that F# never bothered to implement, such as partial classes and nested classes.
I don't think it works with .NET Core, since WPF is a Windows desktop platform (or so I thought anyway). Can you point me to that recommendation? I'm sorry your experience with the .INI type provider was poor. Most of the type providers I've used are amazing, but of course it varies depending on the implementation (just like any other NuGet package).
I must say .NET gamedev was much more alive a couple of years ago, when I last had the chance to make games. I didn't know SharpDX got officially abandoned, that's actually quite bad. FNA is still maintained and has been used for many commercial games; many people used it on desktop over Monogame anyway, but the API is dated. I still think F#'s type system is much better suited for writing game logic, but even I wouldn't recommend it over C# _if the only viable tool is Unity_. It seems like _open source_ gamedev is dying as a whole is .NET then.
https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#windows-desktop https://devblogs.microsoft.com/dotnet/net-core-3-and-support-for-windows-desktop-applications/ (it‚Äôs mentioned there that new desktop applications should use .net core 3 and not .net framework) .net framework is stabilizing and is turning into a legacy framework, even for windows only applications.
to be clear, i certainly prefer f# as a language over c#, but i was simply correcting the original commenter that f# is not better than c# in every way. c# gets microsoft‚Äôs full focus. f# does not, and is probably at least a few positions down.
Interesting, thanks. Hopefully this becomes a non-issue in .NET 5, which merges the different flavors of .NET back into a single platform.
Yes it is, there‚Äôs no actual information to back up your claim.
Of course improvements_for_f_in_visual_studio_2017_release is not relevant if you don‚Äôt use it.
mind elaborating? microsoft and visual studio fully support uwp/wpf/xaml desktop applications for c#. f# does not have anywhere close to the support c# does. unity fully supports c# for video games. f# has no official support and can work, but only for experts of both unity and f#. basically no one uses it. in the replies to me, there is nothing but a bunch of side projects with limited use, documentation, and support. there are a couple, like fable, that seem heavily used by f# people, but that is only for web applications. f# is clearly not better than c# for building desktop applications and video games. can it? yes. is f# a better language? yes, i think so. is the support there for desktop apps and video games compared to c#? not even close.
I got a lot of similar questions at the languages booth at //Build this year. My answer was along these lines (and aligned with the printed-out cheat sheet we handed out to people): * Discriminated Unions and Record types for domain modeling * Immutability and Pattern Matching for correctness * Type Inference and function composition for writing less code * Full .NET construct support for interop and using packages in the .NET ecosystem * Visual Studio and VSCode for great IDE support Each of these pieces _individually_ doesn't necessarily change your life, but the combination of them all completely changes the way you write code such that you'll never want to go back to the likes of C# or Java again. N.B. I tried to avoid showing tricks with Type Providers, since although they demo _incredibly_ well, their magic wears off a lot when you use them "for real", and I didn't want to
F#'s comparative advantage is as a typed functional programming language that's simple, easy to pick up, relatively well-tooled, and generally well-designed. If you're coming from "mainstream" programming, you'll appreciate pattern-matching, sum types, and the clean syntax. If you're coming from functional programming you'll appreciate the tooling and simplicity.
I don‚Äôt suppose you‚Äôd be willing to dumb that down a bit more? I‚Äôm a novice programmer, frankly. I appreciate your answer regardless, though, and if not will be sure to refer to your list when I have build additional maturity.
Elmish for XNA: [https://github.com/ChrisPritchard/Xelmish](https://github.com/ChrisPritchard/Xelmish)
The title of that other thread contains a lie. Also, why not tell to the trolling OP of that thread that it's the wrong forum? Especially since he doesn't even use Windows. https://www.reddit.com/r/fsharp/comments/bmiksr/microsoft_confirms_uwp_is_not_the_future_of/emwzg54/
xna is discontinued. the latest download for microsoft xna is almost a decade old. i'm not really asking for examples of how to do graphical application in f#. i am fairly aware of most them. i was making the argument that f# is not better than c# in this area.
A down vote? Don't shoot the messenger; I was just trying to answer *your* questions with something other than my own opinions. ;\^)
I recommend following these steps and filing an issue with, if you can, a repro project that can be shared: https://github.com/ionide/ionide-vscode-fsharp#how-to-get-logs-for-debugging--issue-reporting
As a novice programmer, most of these things are probably going to be less valuable to you. The biggest one is this: * Type inference and function composition for writing less code Consider the following: ``` let square x = x * x let isOdd x = x % 2 &lt;&gt; 0 let getOddSquares xs = xs |&gt; List.filter isOdd |&gt; List.map square ``` That code will accept a list of numbers, filter down to the ones that are odd, and give back a list of the odd squares. It's very little syntax - no braces, parentheses, other structures, etc. Reproducing something like this in other languages (such as Java or C#) is going to be more verbose and require you to learn more syntax just to understand a pretty simple concept.
Okay. I'll do that.
Indeed. Hot takes on the hot takes of a media guy doesn‚Äôt feel particularly F#-y.
As for UI, that is because Blend is locked on C#. If MS wanted to, they could as well add the option to have F# as "code behind". &amp;#x200B; It can do everything C# can do, but a wee bit slower, usually. You can convince yourself if you "disassemble generated F# assemblies and look how the code would look in C#". There is a tool for that... forgot the name. What you see, is that there are a few extra layers and classes etc. which mangle functional ML like constructs onto the rather OOP-ish .NET runtime. I say this in the same sense as I would say C# Linq is a wee bit slower than the same done without Linq.
I'm on 18.04 as well. VSCode works pretty great for the medium-sized project I'm working on (maybe a dozen project files.) There's a `minimize background parsing` option that you can turn on in your works space that might take a little load of your CPU. Normally, when you exit a file, Ionide will attempt to re-check all the dependent projects, which can cause the compiler service to get backed up. Fortunately, there's some active work being done in cooperation with microsoft to improve performance and specifically fix things like project parsing. Krzytov's tweeting daily updates: https://twitter.com/k_cieslak
Whatever floats your boat, but I think the poster who brought up MVU might have a different criteria for what constitutes "better". F# excels at defining embedded DSLs. React (and ReactNative - MS-blessed way to build UWP apps today) is a good example of type-safe DSL that is compact and flexible. As multiple people have pointed out MVU pattern is incredibly popular and applicable to any underlying technology.
there are other people here you know. there isn‚Äôt a downvote from me.
If you're doing some sort of coding bootcamp (which seems to be where most junior C# devs are minted these days) then don't waste your time with F#. I would guess you're just looking for a coding job. There are few for F#. Lots more work for C# in corporate IT departments. Don't get me wrong--huge fan of F#. Just super, super tired of justifying my preference. Especially to people who haven't written much code who can't really appreciate the differences.
I‚Äôm actually pursuing a formal CS degree, with intent not to look for a coding job, but to go into data science (double majoring in math). I‚Äôm simply not that mature in my field yet; and C# is something I‚Äôm required to learn for coursework.
\`minimize background parsing\` - After disabling this feature, I'm able to work finally. Thanks for the tip.
Yeah, I wish I'd learned Haskell before I learned F#, just as much as I wish I'd learned C or even Java/C# before C++. But I think Haskell and F# are sufficiently different languages that I still *want* to like F#.
They are different yeah - I just don‚Äôt know when I would use it nowadays. The only reason I‚Äôd pick it over Haskell is if I was doing a project on .NET which would be a requirement from customer (I‚Äôm in this situation right now) which usually means they want C#
Ah, well, support is quite different from better at. C# has a lot more wizards etc but it often needs it due to more code and patterns to be generated. F# tends to have simpler solutions to a lot of that.
The maintainer's icon is the picture for some reason... Lol
BTW, just saw this: https://reddit.com/r/fsharp/comments/bndldc/f_elmish_for_monogame/
Is your view always updated after the view, with monogame they should be independent
My favorite thing in F# right now is FParsec, which is based on a Haskell package of course, but lets me parse .NET strings *much* more conveniently than I can C# strings. There's definitely some real value there. .NET aside, I do think F#/ML are different from Haskell in that the former are eager evaluating, which makes them a little more appropriate for applications where latency is an issue. But yeah, at some point, I do think C# is just going to be (or already is) better than F#.
Whaaaat?! That's so cool!
Another issue is that since most f# code uses type inference so heavily, its even more important than normal to have an editor with IDE features, so you can tell what types things are. Code you wrote a long time ago, or someone else's code, that doesn't have type annotations is completely impenetrable without a code editor that can show you the types in some way, and let you hop to definition.
Yeah this hasn't proven a problem for me yet since I have a mental map of the entire codebase I work on, but I could see how important this would be for approaching a new or only semi-familiar codebase.
I‚Äôm a newcomer to the space and i just heard of ‚Äúmono sgen‚Äù. Mono is another runtime right? Have you tried using .netcore ? In a year it will all fall under the ‚Äú.net 5‚Äù umbrella but it‚Äôs essentially .netcore with pieces of the other runtimes brought in.
Yeah we've used the .netcore runtime. The resolution of project dependency trees still seems to leak memory, since they are both calling the same libraries under the hood (FSAC, Project Cracker, etc) last time I checked.
When was the last time you checked? Seems like .netcore2.2 is significantly different than mono at this point. I‚Äôd check again. Also what ‚Äútooling‚Äù are you talking about here? VSCode + Ionide? Try loading the project and see how it goes. If it really is such a frequent event where ‚Äúits muscle memory‚Äù at this point, then it should happen right away right?
Just loaded a project (loaded in fine), made a few edits to existing types, then all analysis failed on the next load. Squiglies everywhere. Had to `cmd+shift+p -&gt; Reload Window` and wait for the project to load again to see any syntax errors. The load was nice however, and I'm excited to see if it works with less friction than before. Even if there is just a bit of friction, I personally can deal with that (even though it seems like it shouldn't just break and require a reload).
What? So in your mac machine you have the updated .netcore installed? What versions do you have currently? Can you show the output when you call it from the cli? Then on an updated version of vscode and updated version of ionide you opened the project and immediately it crashed so to speak? Can you expand what you meant by ‚Äúmade few edits...next load.‚Äù What‚Äôs the next load here?
Interesting comment about having a mental map of the code. When I change a name that will temporarily made the code incorrect, I have a mental map of how many places (at least roughly) in the current file that might cause a problem. So I except that many lines to suddenly appear in the error window below. It throws me off now that those messages are now multi-line, with each line making a suggestion of what name might possibly be intended (usually these are all completely unrelated, coming as they do from every visible namespace). I find this "feature" to be extremely annoying, but I haven't found a way to turn it off.
&gt; How do you guys write F#? I use the latest version of Visual Studio 2019. It has some bugs but I've figured out how to work around the most crippling ones.
Yeah we have multiple versions of core installed on our machines. Right now we're working with 2.2 and 3.0 preview 5 to test out the updates. The next load is the intellisense picking up type changes in a file that references it.
I‚Äôm still not sure what picture you‚Äôre trying to paint. If you make an issue with the fsharp repo or if you make a small gif of the issue I‚Äôd love to see it. As far as I understand you: 1. You make changes in some other file 2. The intellisense takes a second to pick up the changes? We talking under a couple seconds? 3. It crashes your Mac? And what does vscode have to do with mono here?
Ah I see where the confusion is. The process goes like this: # Working in a project # Change types in MyTypes.fs # Go to the tab where MyService.fs is (which depends on MyTypes.fs) # Since MyTypes.fs changed, it reloads the analysis for the current file to show up to date syntax data # In that process, it breaks and the entire file shows as syntactically incorrect Nothing crashes, I just have a buffer full of red where none of hover-for-definition, resolve-issue-at-code-point, etc work. As far as making an issue, I'm not exactly sure where the problem lies with this one. To find out what's causing the issue, I'd need to set aside a decent portion of time. I timeboxed the investigation (looking at ionide debug output along with changing various parts of the code, reloading, etc) to 2 hours, but I couldn't get a solid sample put together in that time, so I just switched to vim and finished coding the feature. Does that make more sense?
Yes, so maybe it‚Äôs an issue with your machine? This is even happening with VS2019 on your Mac? That would help you differentiate if it‚Äôs a vscode/ionide issue. You did say it happens to everyone though you didn‚Äôt actually say what editors they are using. Lastly, you did mention mono which afaik who‚Äôs using mono when you can use netcore on your Mac?
We've had this issue happen in: * VSCode with ionide (both mono and .net) * vim-fsharp plugin * Visual Studio for Mac (not 2019) I'll give VS2019 a shot and see if it improves upon anything.
Also just had an idea, it‚Äôs possible you have something like a recursive &lt;something&gt; that while valid in theory it causes a bug, therefore when you make changes this happens. Anyhow, best of luck! I‚Äôd try to a new project and see if it happens on a different project. But unless you figure out what it is and report it then nothing will go unchanged!
Rider 2019.1.1 was a big step forward for me. Happy to pay for a license because it‚Äôs so much better than the alternatives for editing large f# projects on macos.
Cool, I wondered if this would be possible, might give it a spin
There are multiple editors out there and you have not even mentioned which editors have the problem. The standard for F# tooling has always been Visual Studio (for Windows). While it's not bug-free, it's pretty reliable and very powerful, way beyond what people coming from non .Net languages are used to. \&gt; fixing the editor tooling should be a higher priority item to fix for the f# team The Microsoft F# team is responsible for Visual Studio (non-Code, for Windows). They probably should update their docs to clarify that as multiple editors are now called Visual Studio. It doesn't make sense for them to use valuable time just to allow people to use multiple editors. Fixing language issues and adding features is much more important. It does make sense for them to work on language tooling in such a way that people working on F# tooling in other editors can use. I believe they are doing that already and this may be part of the project that k\_cieslak is working on. \&gt; Most people at my work have muscle memory to kill mono-sgen Why would people at a workplace use sub-standard editing tools? If the community-suported tooling don't work, they should get Windows and Visual Studio, or else Rider. You can get a good editing experience straight away. Or you can take the inferior choice of waiting 2 years and maybe Microsoft combines VS2019 and VS for Mac, mono somewhat goes away with .Net 5, the community improves tooling on multiple other IDEs.
\&gt; Now i am stuck with a 85% project coded in F# as well as genetic programming in it... I am not coder nor technical in nature. How did you end up managing a genetic programming project if you are not technical? Can you tell us the purpose and story of this project? \&gt; Now i realized this combination of skills #f and genetic programming is even rarer. You may find someone here or on the F# slack. If not, anyone with any functional programming experience can take up the project. Since genetic programming works with tree structures, anyone doing genetic programming should be using a functional language.
I believe the warning refers to your `async { ... }` block. You're not doing anything with it, other than declaring it. Note that Asyncs have to be started manually. If your program is just this example, maybe you not even need Async. Doing `result |&gt; ignore` does nothing, by the way. Just use `do!` or `return!` instead of `let!` inside the block. If you needed to discard the value *inside* the Async, chain an `Async.Ignore`.
Here‚Äôs one that‚Äôs the common case everyone always brings up: https://jet.com/
The Vim emulation of VSVim: https://github.com/VsVim/VsVim/tree/master/Src/VimCore
There's also "the other F# plugin", https://github.com/fsprojects/fsharp-language-server It's not as full-featured as Ionide: for example, it doesn't provide a separate project explorer. It's focused on providing the core language server features like autocomplete and navigation in the simplest and most efficient way. Try it out! It takes about 5 seconds to install from the VSCode marketplace: https://marketplace.visualstudio.com/items?itemName=georgewfraser.fsharp-language-server
Three non-research products that I know of (and can talk about): * [Microsoft Security Risk Detection](https://www.microsoft.com/en-us/security-risk-detection/) * F# tools in VS, which are installed by default for most users now * Infrastructural "plumbing" in parts of Azure and Office F# is used a lot within Microsoft Research, but lots of research work doesn't materialize into a product. A non-Microsoft one I learned of a while ago is Buckaroo, a C++ package manager: https://buckaroo.pm/
Hi [u/phillipcarter2](https://www.reddit.com/user/phillipcarter2), I configured my VM with 3 GB of RAM earlier and now increased it to 4 GB. Things are stable now. So it was failing with low memory I guess. Sorry for being an idiot. Thanks.
It must be incredibly hard to be the ‚Äúchampion‚Äù of F# so to speak within MSFT. In most public events, videos, content they only talk about C#, how do you keep fighting for F# within your org?
Hey thanks for the suggestion. Please look at my Edit.
Well, I have good news and bad news for you. The good news is that I have been working with genetic programming (classic Koza approach with trees, as well as Cartesian Genetic Programming) in F# for a couple of years now. I'm trying to evolve tactical behavior from simple agents engaged in combat. The bad news is that I'm a 70 year old retired consulting actuary. While I have years of coding experience - FORTH, C, C++, Java, Scala, Wolfram, and F# - I have never worked as a full time professional coder, so many aspects of industrial programming are foreign to me. In addition, after so many years as an actuary, I am extremely careful and conscientious, which probably makes me slower than programmers with a different background. So, it's your call: Contact me if you'd like. As CSMR250 points out, you have other options as well. In any case, good luck! I hope you're successful.
As far as dev tools, there's: * [https://fsprojects.github.io/Paket/](https://fsprojects.github.io/Paket/) * [https://fake.build/](https://fake.build/) * [http://ionide.io/](http://ionide.io/)
F# is widely using in financial area, but sure you can not find those soft in MS Store. The same as Ada - no Ada applications in MS Store, but - in most planes, trains, etc. You can try [https://github.com/search?utf8=%E2%9C%93&amp;q=f%23&amp;ref=simplesearch](https://github.com/search?utf8=%E2%9C%93&amp;q=f%23&amp;ref=simplesearch) for OSS
Warning, if you ignore a Task's result and it throws an exception, your whole process will crash. You need to be 100% sure that you either it can't fail or write a wrapper around it to properly catch and log the error.
Definitely not an idiot :) Perf problems are very challenging to understand, and TBH F# tooling has no business using up 3GB+ of RAM. It‚Äôs a focus point for Ionide in the coming months.
Q# has been written in F#
The [Continuous IDE](http://continuous.codes) (C# &amp; F# IDE for iOS) is written in F#. [blog post](https://praeclarum.org/2016/07/06/continuous-c-and-f-ide-for-the-ipad.html)
I don't believe the F# compiler should concern itself with serialization. It's too peripheral, and you cannot please everyone because there are more readable and more efficient ways to serialize. When [type providers can take types as inputs](https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1023-type-providers-generate-types-from-types.md), then an efficient type provider can be created which analyzes a type and generates efficient code for serialization and deserialization. I find that doing manual serialization has overwhelming advantages: high performance, suitable for persistenace because as types change you can maintain deserialization logic for old data, and very easy to write and maintain. 5% of our codebase ends up as serialization code, but it's only 0.5% of overall effort to maintain, and it's worth that. If you are doing internal communication between methods that you control, and you care about performance, I don't think JSON makes sense because direct human-readability is not important, but that's an orthogonal issue.
Fable has had significant uptake, although I think the whole approach of F# to javascript is unfortunate as compilation to javascript will make your code 10x slower. I agree a nice web interface, updating TryF#, would be appropriate as a shop window, but if you are going to be spending at least a few hrs with the language then VS is worth downloading.
That makes perfectly sense, thanks!
Thanks for the warning
&gt; Here‚Äôs one that‚Äôs the common case everyone always brings up: From what I hear they were acquired by Walmart who are switching everything from F# to Java and have already begun axing F# devs. I expect there won't be any F# left at Jet.com in a year or two.
Source required.
I think it's probably a complex situation since Jet is a big company and Walmart is even larger, but I personally know of three teams being spun up there who are F#/.NET.
In short, nah :) As far as marketing goes, I really wish C# were actually emphasized more than it is. Selfishly, the .NET brand is more neutral and can thus be claimed by F# as well, but I personally think that for the purposes of getting _new_ people, the C# and F# brands should be pushed rather than the .NET brand. It's easy to think that C# is what gets all the attention when you're an F# programmer and _look_ for things that are programming-related, but from my point of view, C# isn't pushed enough (and neither is F#). Another thing worth mentioning is that the C# people I work with are all on the same team. There is no real "C# team" vs. "F# team", and every three weeks we get together with other teams in the org and brag to each other about the progress we've been making. Just last week, I got to share a spongebob meme related to some architectural changes to our language service that shave 1GB off the memory usage for a test solution.
This can‚Äôt be that real, is it? I know there‚Äôs tons of jvm inside Walmart but with oracles recent moves against open source and the JDK, while msft is going fully open, there seems to be no real benefit in moving away from .net
&gt; there seems to be no real benefit in moving away from .net Sure but companis do it all the time, especially after acquisitions.
That's what a former F# dev at Jet.com told me recently.
That's interesting.
It's a big company with \_hundreds\_ of F# devs, let alone the front-end and infrastructure orgs, so it wouldn't surprise me if some teams are asked to switch what they do while others are spun up to do more "fun stuff" kind of work. At companies of that scale, entire teams and spun up and down pretty quickly since the money to do it is probably still a rounding error.
&gt; Looks like the issue was low memory. I increased my RAM to 4 GB in the VM and things are stable now. VS Code and Ionide works great. You need 4GB to run an F# editor?!
I agree but not to something that used to be open source but is now effectively looking like it will become closed and will cost an arm and a leg to run
By all accounts they are already heavily invested in it so whatever the future of their entire Java code base this is surely a drop in the ocean.
Well, the way those things usually go, it ends up being 1) Development stagnates as you're switching a perfectly good product to a different language for no reason. 2) New code is buggy code, and once you reach 50% "ported" code, the new stuff is pretty buggy. Because you axed the "legacy" developers who actually knew the code, the new code is even more buggy. 3) The high-up guy from the original company who made the stupid decision to port perfectly good code for no reason gets promoted. 4) His replacement freezes the porting and switches to pragmatic rewriting (new things in the new language, old things ported only when they need a major functionality rewrite anyways).
Nah. Just switch from Oracle‚Äôs JDK to any one of the many OpenJDK releases. If anything it‚Äôs becoming easier to get a free and well supported JDK.
Actually, FParsec - https://www.quanttec.com/fparsec/
I'm OK with C# being the flagship language of .NET. Its ability to retain such a large pool of developers in the .NET ecosystem allows F# to be a viable alternative (or supplement). &amp;#x200B; Now if only "Go to definition" worked better between C# and F#. :.(
It looks nice! Very pretty code. On `publishAsync` and `subscribeAsync`, consider putting the function bodies on a new line to avoid having the indent the second lines all the way out. let publishAsync&lt;'T&gt; (bus: IBus) (message: 'T) = bus.PubSub.PublishAsync&lt;'T&gt;(message) |&gt; Async.AwaitTask Also, I tend to see more records with curly braces like this: type BusConnection = { Address: string Port: uint16 Username: string Password: string } Here is the official style formatting guide: [https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/formatting)
Yeah I overheard something like this on a conference, didn‚Äôt get the Java thing, but something seems to be going on in that department.
How about Kotlin or Clojure?
Doesn't Clojure require JVM?
Yes, as does Kotlin. Kotlin Native isn't production ready yet afaik. But there is no .NET Native for .NET Core either. Which is why I said languages that require runtime are poor choices. But afaik there aren't any ML-esque languages that compile directly to native. OP already listed the languages that would be closest fit.
Try Rust, is not really ML but takes quite a few features from it.
\&gt; there is no .NET Native for .NET Core either. Yes there is. .NET Native for .NET Core is CoreRT. It's not supported for production but it works very well in practice. There will also be another AOT created for .Net Core based on Mono AOT which is scheduled for .Net 5 (2020).
Huh, so there is.
Haxe is really nice
If "unix systems programming" means get access to libc functions, it's possible by declaring them as [external](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/external-functions). However, I'm not aware, if there is ready to use module, so this approach may be DIY-like.
There the style guide is not great as it doesn't work with tooling (tabs). The formatting in the OP is OK, apart from lines being too long.
The useful thing this library gives is a typed CreateBus. This can also be done with less ceremony: \`\`\`fsharp type RabbitHutch with static member CreateBus(address, port, username, password) = ... \`\`\` I.e. creating the record types is not useful becuase methods contain the same information (argument names and types). \`type NamingConventions\` is way too complex to be usable. It doesn't create this complexity, which is present in the underlying API, but it doesn't help either. You have a nice container type, but the internals subvert the safe part of the type system with functions on System.Type.
They still have job offerings for F# devs https://careers.jet.com/results?q=engineer&amp;page=1&amp;sort=rank&amp;expand=department,type&amp;jobCareerArea=all
What do you need multicore for? Speed?
What will happen to the .net core AOT project they were working on? Can't remember the name off the top of my head.
Of course it's OK - I was just nitpicking *based on the style guide*. What do you mean by the style guide not being "great" because of "tabs"? I don't see a tab in the entire file.
Tab and shift-tab support in Visual Studio (not tested other IDEs) is best at moving things into 4-space-wide "columns". Records formatted as in the OP can be pushed out or in as needed with tab and shift-tab with no problem. Records formatted as in the style guide can't and need manual alignment when doing that.
&gt; F# is widely using in financial area i also keep hearing about it but never be able to actually find anything as a tool, do you know what kind of system f# being used?
That has not been my experience. Tab / shift+tab move the style guide formatted record properly without the need for manual alignment (tested on VS2017 and VS2019 for Windows).
I've developed several things commercially running in production exclusively on linux and some of them were fairly low-level (I/O over serial ports) and running on custom linuxes on low-power hardware. Mono has quite a bit of stuff covering Linux primitives and those can either be used directly or compiled from sources using .net core.
Your post isn't very clearly worded, but I think what you are looking for is a language with good concurrency and parallelism on Linux? Haskell is great and even has a [book on that subject alone](https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/). You want a systems programming language? Rust has a focus on solving problems with concurrency and parallelism and doesn't have the overhead of a garbage collector. Rust is more verbose than Ocaml or F#, but it does have algebraic data types.
Regarding languages with runtime check these out https://www.wildernesslabs.co/meadow http://www.astrobe.com/default.htm https://www.ptc.com/en/products/developer-tools/perc https://www.aicas.com/cms/
Just in case anyone doesn't know what a consulting actuary is: it's quite likely that the smartness premium of being an actuary likely offsets any supposed decline caused by being aged 70. I would seriously consider this person if I were OP.
Didn't there used to be 2 or three different ones at MS? I forget the names too... lilac
OK I may have misremembered and defer to you!
Another, recently new language which might be to your liking is Pony. https://www.ponylang.io/. I was playing with it for maybe 30 minutes some when last year and it did not look all that bad. How about you try it and then let us know what you think? :)
f# has mailbox processors. https://fsharpforfunandprofit.com/posts/concurrency-actor-model/ f# has asynchronous workflows. https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/asynchronous-workflows and .net has tpl dataflow (and is thus supported by f#), which appears to be supported in .net core. https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library if you're doing systems programming, then it's possible you could use powershell, which is supported on linux and has a .net api.
Mailbox processors are a bit flimsy, I would not want them in production code, ok for demos and prototypes though.
I'd say it has the potential to be good for ML and AI. Python and R are so common in ML because of the huge amount of amazing libraries and frameworks people have built. F# is still getting there. For example, the implementation of TensorFlow is still a work in progress. Microsoft research has done some interesting ML work with F# though, and the future looks somewhat promising.
Maybe you can check fslab.org or https://github.com/fsprojects/TensorFlow.FSharp or https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet
how so?
I‚Äôd use The actor model with Akka.net over mailbox Processor
I'm doing deep learning and love F#, but have found, sadly, that all roads lead to TensorFlow and Python. Here's what I've tried: * [Deep.Net](http://www.deepml.net/): A neat F# library, but incomplete and hardly supported. * [Microsoft Cognitive Toolkit](https://docs.microsoft.com/en-us/cognitive-toolkit/) (CNTK): A wannabe TensorFlow that supports .NET, but not very well. Its Python wrapper gets more attention, but will still leave you wanting. * [TensorFlowSharp](https://github.com/migueldeicaza/TensorFlowSharp): A .NET wrapper around TensorFlow. It's a fine idea, but is incomplete and will have you pulling your hair out before long.
does akka.net support .net core? also, i find the f# api isn‚Äôt well documented.
Have you tried [ml.net](https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet) ?
I've heard of it, but haven't tried it. How does it compare to CNTK? Why does Microsoft need two separate ML frameworks?
ML.NET's use case is putting existing models into production. It comes with built-in models ready to be trained and run, but also supports running pre-trained models made in other toolkits.
Yes it does now: https://petabridge.com/blog/akkdotnet-v13-dotnetcore/
The idea is that learnings from CoreRT and Mono AOT are merged into one that can handle the mobile and .NET Core scenarios.
MailboxProcessors are just fine, but they're not an equivalent to a fully-fledged Actor system or something. They're a good way to have a relatively simple message loop that can process a pretty decent amount of traffic without too much hassle. We use it in the [F# tools for VS](https://github.com/microsoft/visualfsharp/blob/master/vsintegration/src/FSharp.Editor/LanguageService/FSharpProjectOptionsManager.fs#L253) for that.
It's pretty easy to break them, they are not like akka or better still Erlang. Ive heard good things about akk.net too.
Succinct for basics &amp; to evolve as you may want to build own DSL for own processor info-processor(c) extending compression &amp; math so make a compiler; in LLVM or bolero I can use some help/intern-ship,? Here's one in F# (pls use 80 char wide screen to avoid wrapping lines- thanks)! type Parser&lt;'a&gt; = string -&gt; int -&gt; ('a \* int) list type Expr= |Num of int |Var of string |Add of Expr \* Expr | Sub of Expr \* Expr type ParserClass() = member t.Bind(p: Parser&lt;'a&gt;, f: 'a-&gt;Parser&lt;'b&gt;):Parser&lt;'b&gt; = fun s n-&gt; p s n |&gt; List.collect(fun(a,m)-&gt; f a s m) member t.Return a =(fun str pos-&gt; \[(a,pos)\]): Parser&lt;'a&gt; member t.ReturnFrom (p: Parser&lt;'a&gt;)= p member t.Zero() =(fun \_ \_ -&gt; \[\]):Parser&lt;'a&gt; let parser = ParserClass() let numFct (str: string) = Num (int str) // Conversion to types let varFct = Var let addOpFct =function |"+"-&gt; fun x y-&gt;Add(x,y) | \_ -&gt; fun x y-&gt;Sub(x,y) open System.Text.RegularExpressions let captureSingle (ma:Match) (n:int) = ma.Groups.\[n\].Captures.\[0\].Value let token (fct: string -&gt; 'a) (reg: Regex) : Parser&lt;'a&gt; = fun str pos-&gt; let ma = reg.Match(str,pos) match ma.Success with |false-&gt; \[\] |\_-&gt; let pos2 = pos + ma.Length \[(fct(captureSingle ma 1),pos2)\] let addOpReg = Regex @"\\G\\s\*(\\053|\\055)" let numReg = Regex @"\\G\\s\*((?:\\053|-|)\\s\*\[0-9\]+)" // Regular expressions let varReg = Regex @"\\G\\s\*(\[a-zA-z\]\[a-zA-Z0-9\]\*)" let num = token numFct numReg // Token parsers let var = token varFct varReg let addOp = token addOpFct addOpReg let (&lt;|&gt;) (p:Parser&lt;'a&gt;) (q:Parser&lt;'a&gt;)= (fun s n-&gt;(p s n)@(q s n)): Parser&lt;'a&gt; let numOrVar=num &lt;|&gt;var // Choice combinator let rec infixR op q= fun p-&gt; q &lt;|&gt; parser{ let! a = p let! f = op let! b = p |&gt; infixR op q return f a b } let psR = var |&gt; infixR addOp var psR "a - b + c" 0 //\[(Var"a",1);(Sub(Var"a",Var"b"),5);( Sub( Var"a", Add(Var"b",Var"c") ),9)\] &amp;#x200B; //for kicks want a Left to Right infix let rec infixL op q= fun p-&gt; p &lt;|&gt; parser{ let! a = p let! f = op let! b = q let a1 = f a b let p1 = parser { return a1 } return! p1 |&gt; infixL op q } let psL = numOrVar |&gt; infixL addOp numOrVar //|&gt; infixL addOp numOrVar psL "a - b + c" 0 //psL "a - b + c" 0 //psL "8 - b + c" 0 //\[(Var"a",1);(Sub(Var"a",Var"b"),5);( Add( Sub(Var"a",Var"b"), Var"c" ), 9)\]
I love f# but depending on what you mean by systems programming you may find Rust or plain o' c better (especially on Linux where nearly everything is C anyway) f# likely has everything you need but I'm guessing most of your interactions will the OS would be though the .net framework which may not be what you're looking for
What exactly do you mean by unix systems programming?
If you mean AI as in planning/search algorithm, then F# can be a good language for learning. However Rust is much stronger if you are looking for something that can perform. If you mean AI as in deep learning and statistical models, then F# is very lacking and you should look to python instead.
I started a project a couple years ago, which is now part of fsprojects, to do a more minimalist, performance-focused implementation of the language server protocol: https://github.com/fsprojects/fsharp-language-server It works with VSCode, emacs, vim. It doesn't have IDE-style features like project explorer/test explorer, but it should give you the fastest possible performance for things like autocomplete and hover. It's quite mature, the remaining issues relate to understanding project files, which have many corner cases.
Microsoft really wanted F# to be their vehicle into the world of AI, ML, stats, and big data - to eat the lunches of Python, R and Scala. That never panned out. You're better off with any of these three languages depending on your use case. F#'s comparative advantage is in highly concurrent services. Simpler than Rust, Haskell or Scala; safer than Python or JavaScript; more expressive than Java or C#; better tooled than OCaml.
Depending on your definition of "systems programming", F# or Rust is the way to go. If you're not writing drivers or kernel modules you want F#.
I built an elmish wrapper for Console/Terminal apps. Emlish everywhere. [https://github.com/DieselMeister/Terminal.Gui.Elmish](https://github.com/DieselMeister/Terminal.Gui.Elmish)
Geiler Schei√ü ... or in english "amazing". Now we have: elmish web (half)elmish WPF! elmish xamarin elmish console/terminal elmish mono games So we need. elmish WinForms. ;) (full)elmish WPF. elmish UWP WPF and UWP are maybe with xamarin possible. I didn't build any (real) WPF applications with xamarin.
Yes, Fabulous can target WPF and UWP through Xamarin.Forms. You can specify `dotnet new fabulous-app --WPF --UWP`.
[https://www.linkedin.com/jobs/view/software-engineer-java-‚Äì-dublin-ireland-at-jet-1234904898/?originalSubdomain=ie](https://www.linkedin.com/jobs/view/software-engineer-java-‚Äì-dublin-ireland-at-jet-1234904898/?originalSubdomain=ie)
Jet Dublin are taking on 50-100 Java devs, Walmart is a Java shop and thats the tech that they want. When I was there it was a stated that all new projects would be in Java.
I introduced F# into one investment bank over a two years period.
Julia: [https://julialang.org/](https://julialang.org/) While it is often framed as a scientific/numerical programming language, it can do a lot more. An example talk of system level programming in Julia: [https://juliacon.org/2018/talks\_workshops/42/](https://juliacon.org/2018/talks_workshops/42/)
Oh wow I expected this to take longer to happen for some reason. Great news!
Even C has a runtime.
&gt; there aren't any ML-esque languages that compile directly to native. There's SML/NJ, MLton, OCaml and GHC.
&gt; better tooled than OCaml. I'm sceptical.
&gt; Rust is much stronger if you are looking for something that can perform. Really?
&gt; F# is still getting there. Is it? I was under the impression that AI in F# was a Haskell-style flash-in-the-marketing-pan where MS got fanboys to travel the world extolling the virtues of F# in this context using trivial microbenchmarks when, in reality, virtually no AI production code is written in F#.
CNTK is (was, MS recently kind of washed its hands of it by declaring 2.7 will be the last major version and that we should all look into onnx to port our models elsewhere) a deep learning framework like tensorflow, whereas ml.net seems to be less about designing neural networks than it is about providing a robust pipeline where any machine learning model could be integrated, trained and evaluated.
I'm sorry to hear that Microsoft is giving up on CNTK, although I can't say I'm surprised.
&gt; It hasn‚Äôt been touched because it‚Äôs finished. Reed is also super responsive to emails and tweets too. He's a really cool guy.
How is persistence handled?
This is flexible. There are interfaces for [Transactor.Store](https://Transactor.Store) and [Selector.Store](https://Selector.Store). Everything is serializable to bytes. Simple file example for the Selector snapshots are in the codebase. It would make sense that transactions are just saved to cloud storage as individual files.
i wouldn't put much consideration in either f# or c# for writing games unless you're thinking of casual mobile apps. even then, with f#, there is so much layering involved that it makes the process not ideal.
Next steps are to work on authoring community components (like FCS libraries, FCS documentation, and mono builds of F#) from this repository in a way that is both: * tested as part of MS and community pipelines, and * able to be done by community owners/maintainers outside of the MS/.Net SDK release pipeline I for one am glad to be working towards retirement of the two fork repos, if only because merging them has been a huge pain for me personally :D
Precedent typically wins in these situation, as rewriting will inevitably set you back much further than you‚Äôd think, as you reimplement and then fix bugs it already fixed. If 2 devs already want to learn it, it‚Äôs not a bad idea to move forward.
Always put the most motivated person on the job. TS background and some dotnet folks to help with build system debugging should make the transition comfortable
If they are good developers and appreciate FP already, they will be able to pick up F#. It's not intrinsically harder to learn than other languages, so the main barrier is just having a willingness to learn. You could successfully teach it to college students, for example. That said, they may have to unlearn some OO habits that they picked up from JavaScript, such as mutable variables and reference semantics. Fortunately, F# isn't a pure FP language, so it doesn't require you to give up these concepts immediately.
They are heavy Redux users and already write immutable and functional code, i think they should be fine! :)
Awesome. They're going to love it!
If the node people wanna learn .Net, let them... but that's a separate issue. You have .Net developers who are looking at .net projects that result in .net libraries compiled by .net run on the .net platform... They're already working with FP in C#. They're already working with immutability and immutable structures. Picking up a language that has those as fundamental principles is generally considered 'fun programming', but if they don't wanna expand their resumes... They don't have to. They can transpile the solutions into C# if they need. They can use the libraries directly from C# today, in their favorite test rigs. They can establish smart interfaces and port the existing systems piecemeal into new C# versions. Because if it ain't broke, don't fix it. If your .Net coders aren't up to snuff (and lets be honest, lots aren't), then focus on filling the competency hole left by the senior developer.
They should be delighted. It is much easier to write code like this in F#. ("Actions" are just Discriminated Unions. Immutable data structures are built-in. Redux is basically a trivial pattern in a functional language.)
I have a couple of physicists I work with who are C# gurus, and they were comfortable with F# after about 2 weeks of being introduced to it; 3 months later and they‚Äôre beyond fluent. I would hardly consider it to be a case of learning a new language. It‚Äôs like learning English after spending years speaking Olde English. Your .NET devs can surely look at F# code and immediately understand what it does, and your noders surely have been exposed to Reason at some point.
This is good to hear, i was a bit worried it could lead in a dead end, but all the responses here are optimistic, so i'm kind of relieved.
From the point of view of a C# programmer, basic F# is a different layer of paint on the same car. Advanced F# goes a little bit further but the docs are excellent.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small project with F#, my thought is that F# is easier to write and analyze, as it's design is very elegant and consistent, like it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small project with F#, my thought is that F# is easier to write and analyze, as it's design is very elegant and consistent, like it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small project with F#, my thought is that F# is easier to write and analyze, as it's design is very elegant and consistent, like it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small project with F#, my thought is that F# is easier to write and analyze, as it's design is very elegant and consistent, like it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small projects with F#. my feeling is that F# is easier to write and analyze, as it's design is very elegant and consistent, for example, it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small projects with F#. my feeling is that F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small projects with F#. my feeling is that F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me, though F# is a FP, but it does not have very complex concepts. I'm a FE developer myself, I wrote some small projects with F#. my feeling is that F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me. I'm a FE developer, I wrote some small projects with F#. my feeling is though F# is a FP, but it does not have very complex concepts. F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me. I'm a FE developer, I wrote some small projects with F#. my feeling is though F# is a FP, but it does not have very complex concepts. F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
Rewriting is last option for me. I'm a FE developer, I wrote some small projects with F#. my feeling is though F# is a FP, but it does not have very complex concepts. F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
In my company we are building ReactNative app and are heavily relaying on Redux &amp; ReduxSaga. And everything is written in TypeScript (we even have bit of domain modelling on the mobile app as we have NoSql mobile DB). I wanted to point that out because JS in 2019 is so much different (read better) than let's say 2013 JS. And thanks to React it is more and more used in FP paradigm than OO (this will be even more true when React Hooks become more used). I have started to play with F# just couple days ago and it is absolutely pure joy to use! If you have used TS typesystem, F# is similar but on steroids :) If you enjoy FP paradigm in JS, F# is like that but even better! &amp;#x200B; Also if your devs embrace F#, I would recommend looking into [ReasonML](https://reasonml.github.io) for writing client-side React. ReasonML is just another syntax for OCaml - language which heavily influenced F#, it is backed by Facebook (ReasonML is, OCaml has been around since 90s, it is functional, statically typed ML language which compiles to JS (similarly to TS - think of it TS on steroids), in theory every dev could be full stack dev in this combo and ‚Äúrelatively easily‚Äù switch from backend to frontend. Finally I am thinking of moving our backend from C# to F#, and your situation is pretty different to ours, but here is my related [reddit post](https://www.reddit.com/r/dotnet/comments/bp14qw/state_of_f_f_for_next_project/). &amp;#x200B; Please share your finally decision, I am very intreated in learning have you decided to go F# route :)
In my company we are building ReactNative app and are heavily relaying on Redux &amp; ReduxSaga. And everything is written in TypeScript (we even have bit of domain modelling on the mobile app as we have NoSql mobile DB). I wanted to point that out because JS in 2019 is so much different (read better) than let's say 2013 JS. And thanks to React it is more and more used in FP paradigm than OO (this will be even more true when React Hooks become more used). I have started to play with F# just couple days ago and it is absolutely pure joy to use! If you have used TS typesystem, F# is similar but on steroids :) If you enjoy FP paradigm in JS, F# is like that but even better! &amp;#x200B; Also if your devs embrace F#, I would recommend looking into [ReasonML](https://reasonml.github.io) for writing client-side React. ReasonML is just another syntax for OCaml - language which heavily influenced F#, it is backed by Facebook (ReasonML is, OCaml has been around since 90s, it is functional, statically typed ML language which compiles to JS (similarly to TS - think of it TS on steroids), in theory every dev could be full stack dev in this combo and ‚Äúrelatively easily‚Äù switch from backend to frontend. Finally I am thinking of moving our backend from C# to F#, and your situation is pretty different to ours, but here is my related [reddit post](https://www.reddit.com/r/dotnet/comments/bp14qw/state_of_f_f_for_next_project/). &amp;#x200B; Please share your finally decision, I am very intreated in learning have you decided to go F# route :)
In my company we are building ReactNative app and are heavily relaying on Redux &amp; ReduxSaga. And everything is written in TypeScript (we even have bit of domain modelling on the mobile app as we have NoSql mobile DB). I wanted to point that out because JS in 2019 is so much different (read better) than let's say 2013 JS. And thanks to React it is more and more used in FP paradigm than OO (this will be even more true when React Hooks become more used). I have started to play with F# just couple days ago and it is absolutely pure joy to use! If you have used TS typesystem, F# is similar but on steroids :) If you enjoy FP paradigm in JS, F# is like that but even better! &amp;#x200B; Also if your devs embrace F#, I would recommend looking into [ReasonML](https://reasonml.github.io) for writing client-side React. ReasonML is just another syntax for OCaml - language which heavily influenced F#, it is backed by Facebook (ReasonML is, OCaml has been around since 90s, it is functional, statically typed ML language which compiles to JS (similarly to TS - think of it TS on steroids), in theory every dev could be full stack dev in this combo and ‚Äúrelatively easily‚Äù switch from backend to frontend. Finally I am thinking of moving our backend from C# to F#, and your situation is pretty different to ours, but here is my related [reddit post](https://www.reddit.com/r/dotnet/comments/bp14qw/state_of_f_f_for_next_project/). &amp;#x200B; Please share your finally decision, I am very intreated in learning have you decided to go F# route :)
In my company we are building ReactNative app and are heavily relaying on Redux &amp; ReduxSaga. And everything is written in TypeScript (we even have bit of domain modelling on the mobile app as we have NoSql mobile DB). I wanted to point that out because JS in 2019 is so much different (read better) than let's say 2013 JS. And thanks to React it is more and more used in FP paradigm than OO (this will be even more true when React Hooks become more used). I have started to play with F# just couple days ago and it is absolutely pure joy to use! If you have used TS typesystem, F# is similar but on steroids :) If you enjoy FP paradigm in JS, F# is like that but even better! &amp;#x200B; Also if your devs embrace F#, I would recommend looking into [ReasonML](https://reasonml.github.io) for writing client-side React. ReasonML is just another syntax for OCaml - language which heavily influenced F#, it is backed by Facebook (ReasonML is, OCaml has been around since 90s, it is functional, statically typed ML language which compiles to JS (similarly to TS - think of it TS on steroids), in theory every dev could be full stack dev in this combo and ‚Äúrelatively easily‚Äù switch from backend to frontend. Finally I am thinking of moving our backend from C# to F#, and your situation is pretty different to ours, but here is my related [reddit post](https://www.reddit.com/r/dotnet/comments/bp14qw/state_of_f_f_for_next_project/). &amp;#x200B; Please share your finally decision, I am very intreated in learning have you decided to go F# route :)
In my company we are building ReactNative app and are heavily relaying on Redux &amp; ReduxSaga. And everything is written in TypeScript (we even have bit of domain modelling on the mobile app as we have NoSql mobile DB). I wanted to point that out because JS in 2019 is so much different (read better) than let's say 2013 JS. And thanks to React it is more and more used in FP paradigm than OO (this will be even more true when React Hooks become more used). I have started to play with F# just couple days ago and it is absolutely pure joy to use! If you have used TS typesystem, F# is similar but on steroids :) If you enjoy FP paradigm in JS, F# is like that but even better! &amp;#x200B; Also if your devs embrace F#, I would recommend looking into [ReasonML](https://reasonml.github.io) for writing client-side React. ReasonML is just another syntax for OCaml - language which heavily influenced F#, it is backed by Facebook (ReasonML is, OCaml has been around since 90s, it is functional, statically typed ML language which compiles to JS (similarly to TS - think of it TS on steroids), in theory every dev could be full stack dev in this combo and ‚Äúrelatively easily‚Äù switch from backend to frontend. Finally I am thinking of moving our backend from C# to F#, and your situation is pretty different to ours, but here is my related [reddit post](https://www.reddit.com/r/dotnet/comments/bp14qw/state_of_f_f_for_next_project/). &amp;#x200B; Please share your finally decision, I am very intreated in learning have you decided to go F# route :)
Rewriting is last option for me. I'm a FE developer, I wrote some small projects with F#. my feeling is though F# is a FP, but it does not have very complex concepts. F# is easier to write and analyze, for example, it doesn't have much "==" and "===" caveats like JS.
F# is gaining some interest among both C# forks and front-end folks (with fable). I know that you personally might not be interested but may be your team could take this as an opportunity to investigate the SAFE stack.
We could help you in a couple of ways: a) Get your FP interested devs up to speed with F#; b) We could maintain your F# apps remotely (we are located in Ecuador, and we do software maintenance from here to clients in the US).
I think it's best to approach this situation as an _opportunity_ for someone to _get paid_ to learn F#. As someone else said, be sure to choose someone who has not had their natural sense of curiosity purged due to years of grind. Also, the idea of going back to C# seems more like a backwards step than a lateral one, imo, because there are many benefits that F# has over C# - especially given the up front hit of money lost to rewrite.
Are there any examples of how this might be used, or when it might be useful to use?
&gt; Linear code, where to understand a piece of code you can read the previous code in order up to that point. Opposite of spaghetti code. I consider this to be a huge downside of F#.
Sorry not yet. I'm just trying to get the API right before creating examples.
Sounds like F# sucks a lot. Never using this language again.
I know you say that you need to attach an event after creation, but you're intended to create a button in React and set-up dispatching an event that way, ala the example. button [ Id "TestMe" OnClick(fun _ -&gt; dispatch MyMessage(arg1OrWhatever)) ] [ str "Click Me" ] If you want to subscribe to JavaScript events globally then you would set up a Subscription when initialising Elmish, though that's much more an edge case. When creating the button, there is the Ref callback you can pass to the first argument list to get access to the button element. Overall, I strongly recommend you rethink how your app should work so you can dispatch messages through Elmish the way they intend. Things will be much easier in the long run.
That was actually the perfect response. I did definitely run myself into a corner, so now i changed my "layout" and it works and looks cleaner\^\^
Kit, thank you for the kind words. However, I showed your comment to my wife of 30 years and she laughed her ass off. Oh, well. Thanks again.
Blog post out now: https://devblogs.microsoft.com/dotnet/the-f-development-home-on-github-is-now-dotnet-fsharp/ Wanted to make it live for a few days just to make sure nothing was broken :)
so a couple of things: 1. There should be something like a `global.json` in the root directory of the project which unfortunately hardcover a runtime. Just change your version number that you have 2. I‚Äôm also a new comer and find the environment and tooling strange. I just stick to using nuget as I find paket more noise and haven‚Äôt found time to explore it. But the nuget site will tell you how to install via the cli.
I guess you don't need any tools like virtualenv/rbenv..., if your current dotnet core is compatible with the one specified in global.json, you can just update global.json, if not, as Dotnet core already support installation side by side, you just need to install the right version. Command **dotnet** itself is pretty much like virtualenv/rbenv, it will choose the right sdk version based on global.json
Dotnet manages its own parallel versions, so that if a global.json file specifies a version then it calls its own corresponding version if you have it installed. So this looks like it should just work. I think what's going on might be that two different dotnet executables are being called, so they each look in a different place for installed versions of the sdk. The first call goes to a specific location in your ~/.local, while the second call doesn't. I think prepending ~/.local/share/dotnetcore to your PATH should work around the issue. But really this is an inconsistency in Saturn's build script.
Package and dependency management is done with NuGet. A solution (a group of projects) I believe can only target a single dotnet version.
I did but it was for a company that uses F#
I don't know, last time I interviewed with MS I used C#, but I'm also not confident enough with F# to use it in interviews so that's more important haha.
You might want to use the decimal type instead of double or float.
This sounds like an [xy problem](https://en.wikipedia.org/wiki/XY_problem). Can you elaborate a little more on what your end goal is?
.NET has a decimal type built in that is exactly this. What are you working on that you think you need it though? Once you go past doubles there are no longer native operations to do the math so it can get fantastically slow.
I figured with the leaps and bounds that Core has made in the last few years, it might be worth checking in to see if brighter minds than mine have approached similar problems with newer technologies. I looked into the decimal type, but it doesn‚Äôt seem to have support for many of the operations that double has, especially trig. I will update the question with an example of my usage.
I updated the question with an example.
Unfortunately the decimal type is not suited for higher order mathematics. Otherwise it would certainly be a step in the right direction.
This isn't the best solution, but a bit of Googling led to [this stack overflow answer](https://stackoverflow.com/a/47956382). Looks like this guy reimplemented most of the functions from `System.Math`, but since it's not in wide use I guess YMMV in terms of whether the stuff you use is implemented correctly.
I‚Äôm hoping that it will be a last resort for us to roll our own extension of the decimal class.
Coming from Matlab with the work you do, I'd recommend Julia instead
Julia was initially recommended, but we ran into a slew of issues that soured the language for us. Julia just wraps the GNU MultiPrecision libraries, which we can probably P/Invoke anyway. Our interest is if anyone has any tips/tricks for doing this on dotnet.
Very interested and have been wanting to find an F# job for years, but I have a criminal record. Given the nature of the business, I am guessing that would be an instant disqualification?
If you already know the .net framework, you might be surprised at how easy F# makes your life! Give it a go!
P/Invoke is going to be super slow. I'd be curious to hear about the domain you're working in where you need this kind of precision!
&gt; if I wanted to do a search for optimal Lanczos coefficients for the gamma function approximation, using the double type propagates a non-trivial degree of rounding error as the number of coefficients increases. This isn‚Äôt a problem in Mathematica, which supports arbitrary precision. yeah nothing is built in that can do the trig operations, you will want to find an arbitrary precision library. There is bigrational but you would need to extend it to add cos/sin/etc
&gt; it can get fantastically slow For anyone that doesn't know, while still slow, .NET Core 3 improves speeds for `decimal` according to [this](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/). See third table under "Parsing/Formatting" header.
I was actually just throwing together some demonstrations for my students. This has always been a sinister problem in my work (physics), but fortunately, academia doesn‚Äôt require the same performance considerations, so it may be an ok trade-off. For instance, the eigendecomposition `sstedc` subroutine in LAPACK, formulated in 1981, wasn‚Äôt even possible until the realization of a workaround that provided suitable error mitigation until 1992.
yep I'm very excited about the .NET Core 3 speedups in general!
I just tried this again and noticed that shift+tab does seem to mess with the spacing. You were right! (I don't know how I missed that when I tried it the other day). So the official conventions are at odds with the tooling. With that being the case, it's probably best to err on the side of tooling defaults.
I've always preferred the second style myself!
I use the second style.
I like being able to add and remove fields without having to modify the other ones, so I like the second one too. Kinda weird considering it doesn't save more than a couple seconds.
The code I see generally uses either the first style or this one (which is the one I use): type PostalAddress = { Address: string City: string Zip: string } member x.ZipAndCity = sprintf "%s %s" x.Zip x.City Your second example won't work as is actually, because the indentation rules don't allow `member` to be all the way to the left.
&gt;a devs, Walmart is a Java shop and thats the tech that they want. When I was there it was a stated that all new projects would be in Java. I have not heard this. If this is actually true this sounds like a site+team specific decision and definitely is not a company wide decision; there is a significant body of F# and F# developers within the company.
I prefer the first style, the structure feels more clear.
Except that UWP is still the future of Windows apps. https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md Some people should not write about what they don't understand.
And Xenko, CryEngine , Godot and even Unreal has C# support now.
Yeah right, https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md
I was there when they made the announcement.
I think the second one is the most prevalent, but I might be wrong cause I am kinda new to F#.
I don't think you're going to find what you're looking for. However you ARE likely to find the components of what you want. instead of looking for a full business example app, look for a CQRS example app, and event based example app, a rest api example app, and so on.
you should hack Perforce server of some company, OP, to research their code IMHO lol
There are companies that work on stuff like that in F#, but unlikely to have released the source code. Its likely all closed source.
What about a domain driven design approach? https://fsharpforfunandprofit.com/ddd/ Also: Domain Modeling Made Functional: Tackle Software Complexity with Domain-Driven Design and F# You can get that directly from Pragmatic Programmer or through Amazon.
Probably not the best place for reddit but this news certainly hasn't made its way to Hoboken ;).
I attempted to code a UWP app. It required me to put my computer in dev mode, opening security holes. Nope.
Note that this is not really what is typically called DDD. It's still nice though.
Well, I no longer work there now so I can only tell you what they announced in April in Dublin.
&gt; Note that this is not really what is typically called DDD. How does it vary from "typical DDD"?
Another one I do sometimes: ```type PostalAddress = { Address : string City : string Zip : string }```
Thanks! Do you have any thoughts on NuGet vs Packet? Is NuGet better?
Jane Strret uses OCaml, check their [Github](https://github.com/janestreet)
If your C# developers wouldn't get excited over an excuse to learn F# I would be surprised (in a bad way). As someone who writes C# for work and has "toyed" with F# for a year I would kill for the opportunity to work in something like F# (or elixir, etc.) at work -- it's very rare programmers have the chance to learn something "cool" on the job instead of just being stuck with the same stack a resume corners you in by your late 20s/30s barring a ton of time invested outside work. So yes, assuming your .net guys aren't just office space types, you should absolutely maintain his base instead of rewriting it. Just pick whichever one you think is more enthusiastic about programming in general (which definitely isn't the same as someone who feigns excitement over writing the same EF crud app a sixth time).
Never used this Packet, but I haven‚Äôt had any issues with NuGet, and it‚Äôs built into Rider.
Let me guess, you came from Haskell?
It makes for cleaner diffs too.
I've only used Paket, it seems to be better technically - [Why Paket](https://fsprojects.github.io/Paket/faq.html#I-do-not-understand-why-I-need-Paket-to-manage-my-packages-Why-can-t-I-just-use-NuGet). It can also install from places other than a nuget repository. I'd say NuGet is much more well known in the .net world and Paket seems more popular in pure F# open source projects.
That seems like a good thing to do, I hear the tooling is quite difficult, but your welcome to give it a go!
Paket is sort of a super set of NuGet in that it can pull from NuGet repository or directly from GitHub, and it has historically boasted better handling of transitive dependencies (dependencies of your dependency) via a lock mechanism. However, NuGet recently added a [similar lock feature](https://blog.nuget.org/20181217/Enable-repeatable-package-restores-using-a-lock-file.html). &amp;#x200B; So then the breakdown as I see it: &amp;#x200B; NuGet Pros: \- built-in to Visual Studio and dotnet core \- has a nice GUI &amp;#x200B; Paket Pros: \- can also pull files from GitHub \- cool kid status
Kinda. I picked up Haskell after F# and found myself wishing I'd learned that first, just so that I'd have had a more solid foundation in FP first.
I'm just trying to use ML.NET for the first time. The world needs a lot more working demos written in F# because this API is really hard to use.
The approach in the linked post does seem very smelly, with reliance on annotations. (`type PriceData () = [&lt;DefaultValue&gt;][&lt;LoadColumn(0)&gt;]val mutable...`). This circumvents the type system so the approach is look at examples, copy and paste, and don't look again at what you wrote. Apparently you can avoid this approach either by using an IDataView or the PiGSTy API. See last two posts [here](https://github.com/dotnet/machinelearning/issues/1991). I would be interested in what you make of this. I'm not using ML.NET yet so I havent tried anything, but am keeping track as we are likely to use it in the future.
I'm having a lot of problems with these ML samples for F#. Haven't managed to get a single one to work yet, e.g. compared with Python and Mathematica where everything works first time. The first problem I had [here](http://www.codesuji.com/2019/01/14/F-and-MLNet-Sentiment-Analysis/) was finding out which packages to install because MS seem to have changed it. They've even put PCA in its own DLL when PCA is just a few lines of code. Same for k-means. Turns out I had to install `Microsoft.ML.FastTree` from Nuget, IIRC. Next problem was changes in the library. They've changed the names of things and moved things around. Furthermore, everything seems to be an extension method and the F# toolstack doesn't play well with extension methods so I have no idea where the program counter is going. Next problem was run-time type errors because their API isn't typeful and most of the algorithms they provide don't seem to work on boolean inputs. Final problem I hit was it trying and failing to dynamically load `CpuMathNative.dll`. I never managed to fix that problem so nothing works but I gather the problem is that I'm using .NET Framework and ML.NET only works on .NET Core. I tried spinning up an F# console project targeting .NET Core but that breaks F# Interactive because it still doesn't support .NET Core. Really an incredibly awful user experience compared to, say, Mathematica where the required code is: Classify["Sentiment", "I enjoy working in this company"]
What do you think about these samples? PiGSTy. They look a lot better to me. [https://github.com/dotnet/machinelearning/blob/master/test/Microsoft.ML.OnnxTransformerTest/OnnxTransformTests.cs#L180](https://github.com/dotnet/machinelearning/blob/master/test/Microsoft.ML.OnnxTransformerTest/OnnxTransformTests.cs#L180) [https://github.com/dotnet/machinelearning/blob/master/test/Microsoft.ML.OnnxTransformerTest/DnnImageFeaturizerTest.cs#L92](https://github.com/dotnet/machinelearning/blob/master/test/Microsoft.ML.OnnxTransformerTest/DnnImageFeaturizerTest.cs#L92) Should work in F# (now that F# has anonymous records).
I think some of those issues aren't isolated to F#. It is the danger of playing with a pre-version 1 API, it can change a lot. For me, the pain of changes is worth the opportunity to get an early look. Agreed, it would be nice if the API supported idiomatic F#, but we can't figure out to get there if we don't at least experiment.
It's mathematically impossible to do this in a way that works for an arbitrary pair of functions: [https://www.quora.com/Is-it-possible-to-define-a-general-equality-function-testing-if-two-arbitary-functions-are-equal-in-the-lambda-calculus](https://www.quora.com/Is-it-possible-to-define-a-general-equality-function-testing-if-two-arbitary-functions-are-equal-in-the-lambda-calculus) That said, there are some interesting subsets of functions for which it is possible: [https://www.fewbutripe.com/2018/12/05/seemingly-impossible.html](https://www.fewbutripe.com/2018/12/05/seemingly-impossible.html)
Not to mention all the mutable values. It looks like C# that's been translated directly into F# with no appreciation for the difference between OOP and FP languages.
Yes quotations make sense . These are DUs that represent general F# code. If you have a smaller set of logic it may be better to write a smaller structure to represent operations. You can then define equality if the structures are identical, or implement a looser notion of equivalence.
Express the possible functions as cases of a union type and compare those instead.
The func is passed by a user of my MVU library. ```f# view dispatch model = button { onClick (fun () -&gt; dispatch Increment) // user could also do something else here } ``` One of the first things I tried was ```f# Assert.True(&lt;@ fun () -&gt; dispatch Increment @&gt; = &lt;@ fun () -&gt; dispatch Increment @&gt;) ``` I am currently experimenting with comparing the IL of the method bodies. ```f# module FuncCompare = type Msg = Increment | Decrement let dispatch (msg : Msg) = () [&lt;Fact&gt;] let ``Comparing funcs`` () = let getIL (func: 'a -&gt; 'b) = let t = func.GetType() let m = t.GetMethod("Invoke") let b = m.GetMethodBody() b.GetILAsByteArray() let compare (funcA: 'a -&gt; 'b) (funcB: 'c -&gt; 'd) : bool= let bytesA = getIL funcA let bytesB = getIL funcB let spanA = ReadOnlySpan(bytesA) let spanB = ReadOnlySpan(bytesB) spanA.SequenceEqual(spanB) let a = fun () -&gt; dispatch Increment let b = fun () -&gt; dispatch Increment Assert.True(compare a b) ``` but this comes with some restrictions: if 'dispatch' is not a static method (top level let on module) the function stored a reference to the dispatch method in a local field. This causes the [ldfld](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes.ldfld?redirectedfrom=MSDN&amp;view=netframework-4.8) IL Opcode to differ. (I guess because it gets passed a different 4 byte pointer).
please see my answer on @CSMR250 s comment
I'm not familiar with custom operations on builders, and the linked document doesn't explain what they're used for at all. Can you explain further?
People lose hype because they get used to it. Now, type providers are standard F# and you obviously should learn it.
Custom operations on CE builders let you write code that looks like its native syntax even though the F# language might not have that synax. Saturn is based on showing off this functionality. Instead of merely using `let`, `let!`, `return`, `return!`, `match!`, etc., custom operations let you write a programming model that looks very much like a DSL but implement the code behind in an contained way. The example in the blog post shows off how you can use a custom operation (in this case `use_basic_auth`) to set up a ton of underlying config in the actual code-definition, yet still present a nice API to the user. Another example of the use of custom operations is the `query` CE, which has a SQL-like language embedded into it via the use of this mechanism: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/query-expressions#table-1-query-operators.
Personally i think they make alot of sense when scripting but not in compiled F#. I think that together with nuget import support in fsx script it will be a mindblowing combination. Blowing python out of the water.
Not your code that's the problem, rather the dynamic API which is designed around what many C# devs are used to. But fortunately there are two other APIs, a more primitive one IDataView, and a more functional one [PiGSTy](https://github.com/dotnet/machinelearning/issues/632), which should be better to use from F#.
Thanks. In the example given, the `use_basic_auth` operator takes no arguments, but the underlying implementation takes an `ApplicationState` argument, which I assume is the monadic value managed by the builder? Is this value always implicitly used as the first argument to the member? And after that I can add any additional arguments I'd like?
That's definitely the right approach.
I've never done this, but it seems feasible. Usually, I just let exceptions behave impurely rather than try to wrap an impure API in a pure functional layer.
&gt; I'm thinking if I should go *deep* into it or it it will be wasting my time. Interpretation 1 (paddling pool): you want to use type providers. In that case it depends on what you are trying to do. For some tasks they are great, with the less hyped but heavily used SQLClient great for database interop. Interpretation 2 (the deep end): you want to develop type providers. Again it depends on what type provider you want to develop. The approach is stable now with .Net Core/Standard support. Anything you do should last. Interpretation 3 (swim with sharks): you want to extend the type provider framework. This would be a large addition: https://github.com/fsharp/fslang-design/blob/master/RFCs/FS-1023-type-providers-generate-types-from-types.md
You are correct on all counts. Normally the application CE would return an Application&lt;ApplicationState&gt; wrapped value, but because the Run member is on the CE and takes ApplicationState as it's parameter, the applicationState is evaluated and returned as the aspnetcore webapp described by it's state. Regarding additional arguments, yep! Any additional arguments past the first state argument will end up as additional parameters to the CE custom operation itself. Eg if the basic auth realm was going to be configurable, a string could have been added to the new operation as a parameter and then invoked via `use_basic_auth "myrealm"`.
Use `Result` for errors you want to force the caller to catch, and exceptions for those you don't want to force. I use `Result` most of the time, especially when the error is related to the application logic, e.g. "Cannot place the order as you have insufficient funds"
I'm thinking about develop a type provider. As I understand I can use Generative TP in other .NET languages, for example C#.
&gt;rrors you want to force the caller to catch, and exceptions for those you don't want to force. I use &gt; &gt;Result &gt; &gt; most of the time, especially when the error is related to the application logic, e.g. "Cannot place the order as you have insufficient funds" So basically if there is something unexpected / an unexpected behaviour you would say to not go with result then?
I'd say that's a good general rule. Take it with a pinch of salt, as most rules in software design.
I recommend checking out the error management section of the F# style guide: [https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions#error-management](https://docs.microsoft.com/en-us/dotnet/fsharp/style-guide/conventions#error-management)
From experience I'd say representing IO as Result/AsyncResult is an unnecessary painful in F# world. I like errors in Rust and in F# I like \`Result\` for logic/control flow and exceptions for everything else. Both FSharp.Core and BCL throw exceptions, besides proper stack trace is invaluable. Also read this: [https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/](https://eiriktsarpalis.wordpress.com/2017/02/19/youre-better-off-using-exceptions/)
You should avoid ever using exceptions.
The suggestion for an error DU is good, but wouldn't it be better as type MoneyWithdrawalError = | InsufficientFunds of balance:decimal | CardExpired of DateTime | UndisclosedFailure Result&lt;decimal, MoneyWithdrawalError&gt; Maybe even have a Balance type instead of decimal? And also the advice to raise an exception for invalid arg and null arg - would be better if the function being called simply couldn't accept invalid values?
F# is a general-purpose programming language, like C# or Java. I don‚Äôt know much about PowerQuery M, but I don‚Äôt think it‚Äôs used in the same way. What they seem to have in common is writing functions that transform data, so PQM experience might be somewhat helpful in that regard.
There are some similarities, but M is much more focused, and therefore can't do a lot of the things that f# can. It's helpful in the sense that any programming experience is helpful, but I don't find much direct transfer of knowledge.
There is some similarity, I think that F# probably influenced the design of M. With M being more focused on Data Munging a good bit of F#'s power was left off. I think it would be worthwhile to learn M from a functional programming standpoint and the fact that Microsoft seems to be putting it into a lot more stuff such as the new Data Munging flows in Data Factory and Power Apps / Flow.
If you're just experimenting with Deep Learning, then I'd advise you to stick with Python &amp; TensorFlow. &amp;#x200B; If Python is not fast enough, or you need to deploy machine learning into production (Python can often be an obstacle there, due to limited throughput), then F# is certainly an option. But more than language, you might think about which platform to use: While no platform has as many libraries as Python or R, Java does have quite a lot of ML libraries and so does C/C++. DotNet is catching up really fast. I don't know how good are Go and Rust in this respect - as far as I know they are not as evolved. &amp;#x200B; In terms of DotNet: for general machine learning, [ML.Net](https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet) and [Accord.Net](http://accord-framework.net/) provide very good set of algorithms, but again the learning curve is steeper than Python (but no worse than any other statically typed language like Java, Scala or C++). The good thing is that Microsoft themselves is working on many of these projects and investing lots of resources into it. And usually Microsoft's code is quite high quality. ML.Net is also close to state-of-the art in performance [https://arxiv.org/abs/1905.05715](https://arxiv.org/abs/1905.05715) In my case, I started using F# for ML due to excellent [Infer.Net](https://dotnet.github.io/infer/) library for Bayesian Inference: it is orders of magnitude faster than anything else I know. Infer is rather limited in how models can be expressed and composed (but that is due to theoretical reasons of how probabilistic message passing algorithms work), but after I managed to describe my model, the execution times went from several minutes (in PyMC3) to several milliseconds. Like 10000x improvement. And results were much better as well. (There's a good free book that helps you get started with Infer: [http://www.mbmlbook.com/toc.html](http://www.mbmlbook.com/toc.html) ) &amp;#x200B; Another thing that I prefer using F# for is the other 90% of code related to machine learning - the not actually machine learning per-se, but more stuff like data extraction, cleaning, preparation, etc. A big problem with data science is that it is hard to make unit tests, and if something is wrong, is really hard to detect (the result is still a number, how do you know it is not correct). I've had several occurrences with some hidden bugs in Python causing data not being correctly exported and prepared and most of these cases could be easily detected had I used F# for those tasks. And again, it is much faster: data filtering that used to run 4 hours in Python, ran 7 minutes in F#. So if you are familiar with writing F# code that uses Functional Domain Modelling and Curry-Howard correspondence, you can avoid at least 90% of those hard-to-find bugs. For data science particularity, this is a huge benefit. &amp;#x200B; A great thing is also that F# code is often as short (or even shorter) and as concise as Python and doesn't take any longer to write. But it is usually much faster to debug. &amp;#x200B; So yes. I think F# is a good language, particulary for data science.
There is maybe some fanboyism regarding F# as a language (it is an amazing language that doesn't get enough attention compared to C#). But the point with F# compared to Haskell is that F# can use every library that DotNet platform has to offer and there are some great machine learning libraries written for DotNet. I think as a platform, DotNet is second only to Java. Many people switching from Java world to dotnet are saying that while there is a larger quantity of various libraries available for Java, the quality and consistency of libraries on dotnet is on average better. In this perspective, F# is in a totally different league than Haskell.
ML.Net is much more broad and versatile machine learning library than just neural networks. Amongst others, yes, it can load and use TensorFlow models. But its primary intention is the other sorts of machine learning.
Interesting, my experience was rather different. Maybe because I'm not into NLP. Apparently, when DotNet 5 comes around Stanford NLP (just as any other .jar) should run natively on DotNet without any need for IKVM. I wonder how that turns out...
There's a difference in my mind to an application error ("Insufficent Funds", "Access Denied" due to application rules) and a fault ("Access Denied" due to OS permissions, Logic errors such as trying to decrypt a file that isn't encrypted). The former should be handled in band via a Result. The latter should be an exception. &amp;#x200B; In theory, a well formed program running on a correctly configured environment on non-faulty hardware should never fault, but reality often gets in the way. Meanwhile errors are to be expected, even if unusual (e.g. a hostile user trying to access something they don't have permission to).
Thank you very much for this extremely detailed answer. I'm not yet sure where my journey into data science will take me, but I will very much keep your remarks in mind as I progress further in my education and mature as a data scientist. I think that your comment, along with the others, mean that F# won't be right on the top of my list to learn, but I will definitely be keeping it in mind --particularly if Python is slow for a given application.
That article is really insightful
Most people disagree with this - note particularly /u/et1975's article and the F# Style Guide. It's a bad idea (from the performance point of view if nothing else) to \*raise\* exceptions as part of the control flow of your business logic (e.g. if funds &lt; 0.M then raise &lt;| InsufficientFundsException("You can't afford this") but that's certainly not the same as never using exceptions.
Example #r "nuget:include=fsharp.data, version=3.0.0" open FSharp.Data // Api Key = 93a2637fe6dad8426d128d5289325ca9 open FSharp.Data type Weather = JsonProvider&lt;"http://api.openweathermap.org/data/2.5/weather?id=2172797&amp;APPID=93a2637fe6dad8426d128d5289325ca9"&gt; let apiUrl = "http://api.openweathermap.org/data/2.5/weather?id=2172797" let sf = Weather.Load(apiUrl + "&amp;APPID=93a2637fe6dad8426d128d5289325ca9") let country = sf.Sys.Country let speed = sf.Wind.Speed let temp = sf.Main.Temp printfn "Temp for Australia is {%M}" temp
An alternative approach is to use something like FSCheck which can generate a variety of inputs within a distribution so that you can compare that two functions don't necessarily have the same implementations, but the same behaviour. In the ```fsharp let addImplA a b = a + b let addImplB a b = (-a + -b) * -1 let bothAddFunctionsAreTheSame a b = addImplA a b = addImplB a b FsCheck.Check.Quick bothAddFunctionsAreTheSame ``` This code has two functions, `addImplA` and `addImplB`, that we test are the same. `bothAddFunctionsAreTheSame` takes in two numbers and confirms that supplying these to both implementations always results in the same output; The `Quick` call in FsCheck supplies the distribution of values and will automatically shrink to find the simplest "negative" test case.
I'm so happy for this feature.
Agree. Can't wait for it to go live. I think it will open up so many doors.. Ex: automation, simple scripts to do machinelearning etc..
No one cares, neither MSFT nor community
I care. I build WPF/XAML apps in F#.
Who elected you to speak for all these people?
Which is why I only care about the languages that MSFT cares. Namely C++, C#, JavaScript, TypeScript, Python, even Java has more tooling love than F#. F# has turned into an hobby project.
"even java..." makes little sense, java is one of the most popular languages on the planet.
With limited resources to draw upon I can think of at least 172 things more important than UWP in the scheme of things..
You should value your own opinion rather than following what MS dictates.
My opinion values what makes business sense. Currently F# only incurs additional development costs to workaround missing support in tooling and libraries. Not something our customers enjoy paying for.
It makes sense when we are speaking about MSFT and their relation with Java.
for example ? Im pretty happy with the tooling and language. The only pain point for me is UI.
It‚Äôs a new Microsoft. Nobody pays for VS Code, Typescript, .. It‚Äôs about attracting developers, and selling services. And I‚Äôd say F# solves real problems for developers delivering products to customers. Microsoft cares, look at the linked discussion.
Not enough people care. VSCode doesn't support native GUI development. You can say the same about people at Google caring about Dart. For me they are on the same basket.
I'm not speaking for anyone, I'm stating observations of reality around us.
Oh god, I'm so sorry you're miserable in your job
What do you mean by native GUI development ? (a designer) Dart is the core of [Flutter](https://flutter.dev). Googles solution to Cross Plattform mobile / desktop apps.
WPF apps works just great in F#. You can use the visual designer in VS. There are MVVM and MVU libraries as well if you don't want to roll your own
What? No, it‚Äôs awesome. Beats C# by a mile.
Yeah, I use FsXaml and ViewModule (MVVM library).
If you don‚Äôt care about F#, why are you in the F# subreddit?
I mean Windows Forms, WPF, UWP, WinUI, including designer tooling. Dart is a language abandoned by Chrome and Angular teams, rescued by the AdWords team, and trying to escape oblivion via Flutter. Just like MSFT with F#, there is a group trying to push it to the market, but it hard matters long term. Google's solutions for cross platforms that actually matter to business are PWAs and the Kotlin Everywhere (including iOS support) that was announced at IO, including the alpha version of a Kotlin like Flutter.
I think you can see pretty clearly that the F# community disagrees with your ‚Äúobservations‚Äù.
Because I am a fool that still likes to know if its status will ever change.
Wasn‚Äôt the whole deal with UWP and .NET Native not being fully compatible with F# due to F# tossing around tail calls like crack in the 70s, but the C# compiler doesn‚Äôt have a .tail IL opcode? Plus, F# UWP apps have been published on the App Store. Sounds like it‚Äôs a work in progress? At least from my understanding there are some nontrivial technical barriers posed by both C# and F#, but I am a pretty below-average F#‚Äôer so I could be completely wrong.
In a world of React, Elm, and Fable/Elmish ... Can we please finally admit that functional is useful for UI developer well? It's just a strange sentiment to me in 2019 to read a design doc that suggest still that F# is only useful for "business logic". It's this just some artifact of extreme enterprise thinking? Because from the perspective of the apps I work on, I can think of only very large batch processing applications where it would even be worth the bother to factor out logic to an entirely sperate library, let alone an entire new language. It's just setting it up to fail.
this
But ui is full of sideeffect, somehow I feel it's not too useful to create a monad for a button interaction and then realize it in the end. I mean, I am not going to test it in my unit test anyway. On the other hand, the mvvm binding is really good already, easy to write and easy to test. I don't mind having my view model prepare all the data and the delegate to f#, but if I have to write the entire ui flow in f#, feels we will need too much boilerplate
Crack happened in the 80's, no?
*hnnnnnggggg*
Why do languages need to be able to do everything? Is it really a bad thing to mix and match languages based on the strengths of each language? You can get the best of both worlds instead of trying to play the zero sum game, and shoehorn a feature onto something that is better done another way. This obsession with only using a single language to do everything really needs to stop.
I use F# for WPF a lot. I don't know anything about UWP. And I never will.
It seems strange that C# would add such a Haskell oriented feature.
the tooling is all over the place. visual studio and ionide are quote different in how they work, and neither works all of the time. for example, the type inference displays (which are both different) barely work.
C# has added many features from functional programming over the years. This would be another excellent example. I believe the reason it‚Äôs coming from Haskell rather than F# (which is the usual proving ground) is that until now the CLR was unable to support typeclasses. I assume that this limitation is finally being removed and F# will also implement the same enhancement.
I asked this awhile back of one of the people on the PowerQuery team and Don Syme actually answered [Tweet](https://twitter.com/Aggregreat/status/1071129838977761281)
Could you explain the benefit of type classes? I fail to see any gain over using an interface.
An interface only works for instance methods on a single object. A typeclass is a more powerful because it can define behavior that isn't tied to a single object. There are many sophisticated mathematical examples, but I'll try to give a simple one called a "monoid". Being a monoid means that two instances of a type can be combined somehow. There are two requirements: * An operation that combines two instances. * A special "identity" instance that doesn't do anything when you combine it with others. String, for example, is a monoid because a) you can append one string to another, and b) appending an empty string to another string doesn't do anything. Integer is another example because you can a) add two integers together, and b) adding the number 0 to an integer doesn't do anything. (In fact, you can implement an integer monoid two separate ways: addition with 0 as the identity and multiplication with 1 as the identity.) Note that you could use an interface to define the "combination" requirement, but it would be kind of awkward because you have to give priority to one object over the other: interface Monoid&lt;T&gt; { T Combine(T t); } More importantly, you can't define the "identity" requirement using an interface at all. But you could do it with a typeclass like this: shape Monoid&lt;T&gt; { static T Combine(T t1, T t2); static T Identity { get; } } Hopefully that gets the idea across, but I'd be happy to explain further if necessary.
nice. more ways to add complexity and make source code going forward unreadable.
Why was this downvoted? I feel this is very true because I see this obsession of people to do everything with JavaScript. I'm not saying it is wrong, I'm just saying that atleast think about the language before quickly deciding. C# is a better example at that.
Another extremely meat-and-potatoes example of things you can't do with OO interfaces is a true De/Serializable contract. Serialize (T -&gt; string) works as an instance method, but Deserialize (string -&gt; T option) cannot because you don't have an instance yet. So you either need a helper class De/Serializer&lt;T&gt;, which can be awkward e.g. with nested objects, or (the CLR approach) you need to make the object mutable with a default constructor so you have an empty husk on which to "attach" the Deserialize method - but you're sacrificing immutability and probably some class invariants by doing that. Plus, interfaces need to be implemented by the class itself. Typeclasses being declared separately means you can take a class from a dependency and quickly make it fit your typeclass by directly matching the typeclass functions to its methods, instead of having to write a full wrapper class that implements your interface and pass that around.
Well, for one thing, despite what people say, UWP is effectively dead. If you're not using any third party libraries you can probably port it to WinUI, but if you are it's likely to be quite painful. In either case, what you're going to end up with is going to be similar to UWP, but it's not going to be UWP. Any kind of UI tooling for UWP at this point is effectively wasted effort. For another, whatever the future of thick client apps in the Microsoft stack is going to be, it's not particularly likely to be UWP and even less likely to be UWP with F#.
&gt; Well, for one thing, despite what people say, UWP is effectively dead. You're mistaken, since [UWP is alive and well](https://pbs.twimg.com/media/D6s_RoAWsAM6bSu.png). What's happening is that they will make WinUI seamlessly available from Win32 applications. What's also happening is that .NET Framework with .NET Native are being replaced with .NET 5.0 aka .NET Core 4.0 with Mono AOT features. This is good for F#, since we won't have to do anything extra to support WinRT/UWP. The only thing that's asked here, is proper idiomatic F# WinUI 3.0 support. &gt; In either case, what you're going to end up with is going to be similar to UWP, but it's not going to be UWP. Any kind of UI tooling for UWP at this point is effectively wasted effort. You are conflating WinUI with UWP, which is only a small part of what UWP provides. &gt; For another, whatever the future of thick client apps in the Microsoft stack is going to be, it's not particularly likely to be UWP and even less likely to be UWP with F#. All the new APIs are based on WinRT/UWP. Also, React Native for Windows targets WinRT/UWP.
Don't forget ReasonML.
F# is a general purpose multi-paradigm language. There is nothing about C# that makes it inherently better for GUI than F#. The only reason for this false dichotomy, is due to politics.
All compiler issues are resolves. What currently blocks UWP UI in F# is the package availability. It is possible to use a F# library in an UWP app, but you don‚Äôt have access to UWP specific APIs from F# (because you cant reference them, they are some special thingy). With Win UI and UWP becoming .Net 5.0 (core) based and the packages being available via NuGet this all changes.
Look at the Elm Counter / Todo sample. I think this will change your mind. I‚Äôm building document based Applications and getting proper Undo/Redo with a MVU architecture is basically effortless.
We have type annotations on all functions, works fine for us. (But I personally dint use code lens) VS 2019 works for me. Also I think rider has good F# support.
Yep, UWP is definitely the future. As they said, WPF is in maintenance mode, UWP controls are available to embed in all other UI frameworks.
UWP is dead, they're fixing it to finally not be total shit, but anything you've written in it is going to need to be changed to continue working. At the very least, the namespace of pretty well everything is going to change for Windows UI which is going to be ugly. That's dead. UWP has struggled to get developers on board since it began, not least because it's not universal, even on Windows and the mobile platforms it was supposed to be for is gone. Renaming the WinRT apis **again** doesn't change that. The code you're writing today won't look the same and the react native code won't have a clue that those apis are even there.
&gt; but anything you've written in it is going to need to be changed to continue working. That's not true. Everything will continue working for decades to come. &gt; At the very least, the namespace of pretty well everything is going to change for Windows UI which is going to be ugly. That only for apps that will use WinUI 3.0, and it will closely resemble WinUI 2.x. So it's nothing to make a fuss about. &gt; the react native code won't have a clue that those apis are even there. As I said, [UWP is more than just WinUI.](https://pbs.twimg.com/media/D6XZssGXsAArSDZ.jpg)
I am currently working on a toolbox for a pen and paper rpg called Pathfinder ([Pathfinder Toolbox](https://github.com/Freymaurer/PathfinderAttackSimulator)). Recently i started working on a SAFE stack, to implement the functions of my toolbox into a web application ([Web Application](https://github.com/Freymaurer/PathfinderWebApp)), because most people that would want to use it are no programmers, so a user interface would help a lot. I am also working on a biological topic, as i am a masters biology student. So i programmed a Peak/Chromatogram simulator, which creates single peaks or chromatograms randomized based on values taken from real data. But it has also a option to have every parameter set separatly (This repository will be on my github page on tuesday) . &amp;#x200B; Feel free to give criticism \^\^
Got an answer on SO: &gt; A close approximation of what you're looking for would be something like this: &gt; &gt; bus.PubSub.SubscribeAsync&lt;Message&gt;("subscriptionId", fun message -&gt; &gt; async { &gt; do! handle message &gt; } &gt; |&gt; Async.StartAsTask :&gt; Task) &gt; &gt; `async-await` constructs in C# only provide syntax sugar for composing `Tasks` - all the `.***Async` methods that are now ubiquitous in .NET apis are entirely usable from F#, though sometimes the necessary plumbing code can get unwieldy. The situation there [might be improving][1] in the future though. &gt; &gt; [1]: https://github.com/dotnet/fsharp/pull/6811 &gt;
it works sometimes but not all the time. i haven‚Äôt yet used vs 2019 yet, but it stops working on vs 2017 all the time. and the projects i have used it on are very small. i find it extremely hard to believe that anyone who used vs 2017 for anything never saw this problem.
From my own on SO: &gt; I supposed cause `Async.StartAsTask` return `Task&lt;Unit&gt;` hence the need to convert to `Task` to match the `SubscribeAsync` overload signature. Makes sense. I guess I still have a long way to go...
That is a beautiful explanation. Thank you. You should consider writing more on this topic in a more visible location.
Interesting that they might get this before discriminated unions and real pattern matching or other algebraic type system features.
It's not particularly interesting from an F# point of view, but as someone who plays Dragon Warrior Randomizer (a mod of a very old NES game from my childhood), I've enjoyed decoding bits of the [ROM](https://github.com/brianmcn/DragonWarriorRandomizerTools/blob/master/DWR_Tools/DWR_Tools/ROM.fs) to learn about how the map and monster data are stored, and be able to make my own manipulations, etc...
&gt; But ui is full of sideeffect No problem for F# because there is good support for mutable values, events, and reactive approaches. (What you describe are difficulties in a pure functional language like Haskell.) &gt; On the other hand, the mvvm binding is really good already No it's terrible. Ridiculous amount of scaffolding, no type safety because it was developed for wpf pre-generics and never got improved since. &gt; feels we will need too much boilerplate Getting less boilerplate is one of the advantages of using F# and avoiding mvvm binding.
Good example, and good point about being able to implement a typeclass separately. Thanks!
Thanks! Glad it was useful. I've thought about blogging, but hanging out on reddit is usually more fun. :)
Microsoft rebranding Windows RT for the fifteen millionth time is irrelevant. A UWP app is an app using a particular architecture and a particular UI framework, with a particular set of largely annoying restrictions. And again, WinUI is a major rewrite. They are decoupling it from windows feature updates. That's a **huge** deal. Namespace changes are the minimum you're going to see, and if you're dependent on any code you don't control that's bad enigma. UWP as a platform, and not another inane name for WinRT is struggling. The UI can't survive without being decoupled from windows updates, but decoupling it may break the few people using it. Microsoft needs a real direction client side, and locked down mobile apps on the desktop probably aren't it.
HYPE. Can't wait.
&gt; I assume that this limitation is finally being removed and F# will also implement the same enhancement. I wouldn't put too much credence into this article, which wasn't written by a Microsoft nor Microsoft-affiliated person. Typeclass encodings have been on the docket of "potential future C# features" for a few years now, and this article is going off the //Build talk where potential futures are typically talked about for a bit. The reality on the ground is that we're trying to land C# 8, especially Nullability (which is perhaps the biggest C# feature ever done in terms of work). Put differently: _if_ runtime support for typeclass encodings is to be added, then F# will implement feature work atop it.
Thanks. That's sobering. I won't hold my breath.
There are still limitations in the .NET Native toolchain that UWP apps use today. They're not prohibitive enough to rule out using F# as they once were, but issues do exist. There are some specific issues [here](https://github.com/dotnet/corert/issues/6055) and [here](https://github.com/dotnet/corert/issues/6055#issuecomment-421032358) (the latter is only a problem when compiling for x86, not x64). In the first set of issues, there is likely some compiler and/or FSharp.Core work that can ameliorate these problems, but the [.NET 5](https://devblogs.microsoft.com/dotnet/introducing-net-5/) push is when we'd be prioritizing that sort of work so that fully cross-platform native compilation (including for modern Windows apps) is where F# is supported on. Some of that tech will leverage pieces of .NET Native and CoreRT today, but it is a fundamentally new effort.
I'm just glad that if they implement this they will be calling them "shapes" instead of "type classes". Seriously, "type classes" is a terrible name for the concept.
Shape is definitely worse.
good to know.
are you using .net core (we are) ?
In what way is shape worse? I cannot think of a more meaningless name than type class, at least not within C# where both words already have defined meanings that are related to each other. A class already has a type. Calling it a shape distinguishes it, and reduces confusion while also implying some of its functionality, which I'm still not to sure about how it significantly differs from an interface.
It's worth noting that the downside to not using the term "typeclass" means that people who are new to the topic will primarily only have Microsoft documentation to help them out with. If it uses a more commonly-used name for the concept, then there's a wealth of additional information to draw from when understanding the purpose of the feature and how you could use it.
&gt; WPF is in maintenance mode I don't think [that's the case](https://github.com/dotnet/wpf/blob/master/roadmap.md). While it's true that WPF is very well "baked" and isn't in need of big redesigns, bringing it up to .NET Core 3 (on Windows) and making it OSS means two things: 1. Active development and improvements 2. An opportunity to evolve, driven by an excited community who is now capable of making changes to the stack Maintenance mode at Microsoft effectively would mean frozen in time aside from security patches and ensuring it all still runs on Windows as Windows evolves. I believe that improving it for .NET Core 3 and accepting OSS contributions distinguishes it from that. I don't expect _massive_ changes to the WPF stack given that it's stable, mature, loaded with features, and not the only game in town for building Windows desktop UIs; so perhaps my previous point is uninteresting for a lot of people. But the idea that you could submit a change that implements something you need and have it ship in the future is exciting to me.
Well, they're more likely to find Haskell docs which will really confuse them!
Not necessarily. Haskell is not the only language that implements typeclasses, nor is it a ‚ÄúHaskell concept‚Äù.
why do you feel that way? and what would be an alternative
I don't think a vague "barely works" is useful in any context, I assume you have logged any issues you have found? Personally I find inference works almost all the time unless you have some kind of version mismatch or are working on the F# compiler project itself.
Updating some F# docs as I await my flight in the airport :)
&gt; I don't think a vague "barely works" is useful in any context sounds like a software developers response. what am i supposed to say? they frequently stop working. i don‚Äôt know why or when or what causes it. all i know is that typically only a full restart of visual studio or visual studio code fixes it. barely working is strong, but if the type inference display has not worked for on both, it makes me wary of the rest of the system. i am talking about the intellisense features (was for some reason not calling that). there are plenty of reports of this for both IDEs. some of them are closed as fixed, but that has not been my experience.
So, elephant in the room... Do you think they care enough about F# to add some of these features?
What performance issues have you observed with key-value data structures in F#?
I highly recommend switching to vs2019. The list of perf fixes and general improvements even compared with the 15.9 release of vs2017 is immense.
okay, thanks. i will do so soon. it's installed, but i haven't been working on my f# side projects. my experience is definitely based upon vs 2015 and vs 2017 and ionide.
Just about every operation is a lot more expensive than using pointers or references. Maps require an O(log n) process for every operation, including lookup, whereas with a pointer or a reference, it's literally just the cost of assigning or dereferencing -- and GC/heap stuff as well, but that also goes for a map.
I remember reading [in a GitHub issue](https://github.com/dotnet/fsharp/issues/1770) that part of the main performance impact on the map is their use of a generic comparer. Would be good to see this issue be resolved but I have similarly experienced performance pains with `Map`. FSharpx.Collections provides a [`PersistentHashMap`](http://fsprojects.github.io/FSharpx.Collections/PersistentHashMap.html) which provides I found to be better but it's been a while since I used it and can't recall how much better it was.
Yes, O(log n) is prevalent due to needing to traverse an AVL tree. And the allocations involved with that structure are nonzero compared with a different kind of structure. This is inherent with immutability and there isn't much to be done about it. There's also a spectrum of what you gain from a soundness vs. performance standpoint. You could write a basic object that wraps a Dictionary and provides no ability to mutate the dictionary, but you don't get the same kind of comparison semantics that you do with the built-in map. Perhaps that's more appropriate to your scenario. &amp;#x200B; But my question is: has this property of built-in collection types been a problem that necessitates moving the needle towards more performance and less soundness? I ask because the Map type in the F# compiler and tools hasn't exactly been prohibitive from a performance standpoint. Or rather, attempts to replace its usage haven't yielded meaningful performance benefits while upholding the same properties we need.
&gt; has this property of built-in collection types been a problem that necessitates moving the needle towards more performance and less soundness? That's the tricky part... I don't know yet. I want to represent hundreds to thousands of connections. It doesn't need to be super-duper fast since it's not a game or anything. That said, I need to run thousands of A* pathfinding runs, among other things, so I do worry that the slowdowns will become significant. What makes this kind of complicated is that it's not much of a drop-in replacement. Mutability will have pretty far-reaching implications on the design of the program, so I want to get it right if I can.
the alternative is to lock down the feature set and work on optimizations. &amp;#x200B; adding more and more 'features' to a language will just end up adding unnecessary complexity, it will result in the code base becoming more unreadable going forward and the user base beginning to migrate to something else.
I would consider going full FP with [algebraic graphs](https://github.com/algebraic-graphs/fsharp), rather than trying to translate an imperative design into F#.
Thanks! This is really fascinating.
I find it really cool, too. Being able to compose graphs opens up lots of possibilities. You can find the original paper here: [https://dl.acm.org/authorize?N46678](https://dl.acm.org/authorize?N46678)
I'd say that it's worth a benchmarking. Three options might be on the table: * Using the built-in map type * Using the result of the built-in `dict` function, which does offer O(1) lookup * Build a quick wrapper around `Dictionary&lt;T,U&gt;` [like this](https://gist.github.com/cartermp/667d61794b3325b42719c53ccce0d394) And compare common operations via BenchMarkDotNet to see which you feel is the best. In this case, each is immutable, but they come with varying tradeoffs.
Aside from the nicer syntax for TryGetValue, What would be the purpose of the wrapper?
Easier construction via a function similar to dict, but optionally with support for removing or setting data. Or if you want something more or less restrictive than IDictionary or IReadonlyDictionary and the underlying type. It‚Äôs just a small example; there‚Äôs a variety of things you could do depending on your need.
None of the comments have mentioned hiring more F# devs, preferably at least 2...
I don‚Äôt trust this website
It's important to consider this framing: * The article isn't written by a Microsoft employee or anyone affiliated with Microsoft * "Shapes" has been talked about as a _potential_ future direction for C# for a few years now, but if you hunt through the design notes on dotnet/csharplang you'll find barely a trace of the proposal * Due to requiring a runtime change to do this effectively, such a feature would take a long time to land even if it were committed As I mentioned [here](https://www.reddit.com/r/fsharp/comments/bvd9dk/candidate_features_for_c_9_type_classes/epq946c/), if the appropriate runtime support is implemented and stable we will build atop it. But the reality on the ground is that this proposed future is not being actively worked on by anyone.
Welp, I got excited over nothing :D I thought since the author called them "candidates," they would at least be under current consideration.
Interesting, thanks!
Just spent a few hours going through it and playing with it... Looks like the one major disadvantage to this approach (and probably any algebraic approach) is that to find an arbitrary edge takes O(n) using a foldr-based search or O(n log n) to first create an adjacency tree. The latter's may not be *too* bad since it'd only need to be done once, but it may also be quicker to just start with a tree :/ I've just come across [this one](https://web.engr.oregonstate.edu/~erwig/papers/PersistentGraphs_IFL97.pdf) as well, but I haven't gone through it yet. I'll probably use either Alga or a map for now.
That's interesting. I haven't had an opportunity to use this approach myself, so you already know more about it than I do at this point. :) Can you clarify what you mean by "find an arbitrary edge"? Are you talking about edge-labeled graphs in particular?
Sorry, I meant either edges or vertices. If you look at hasEdge or hasVertex, they're implemented using a fold and a filter: ``` hasVertex :: Eq a =&gt; a -&gt; Graph a -&gt; Bool hasVertex x = foldg False (==x) (||) (||) ``` The example code I saw for finding and returning a specific vertex is similar.
&gt; when run from FSI it cannot find the native DLLs Were you able to try out [the approach documented here](http://christoph.ruegg.name/blog/loading-native-dlls-in-fsharp-interactive.html)? Loading native .dlls is very tricky business for FSI, unfortunately. &gt; F# doesn't support UWP It does, but with some caveats: https://github.com/dotnet/corert/issues/6055 These are more deployment-time concerns, though. When compiling for debug, UWP apps use the .NET Core runtime under the covers, where F# is fully supported. So you should in theory at least be able to dev out a solution for a bit with the Windows 10 SDK. Deployment to the Windows Store is also unblocked if that's an eventual goal, but it does require an extra step.
&gt; Were you able to try out the approach documented here? Loading native .dlls is very tricky business for FSI, unfortunately. That's exactly what I'm trying to do now... :-) &gt; Deployment to the Windows Store is also unblocked if that's an eventual goal, but it does require an extra step. This is a script to process some images on my machine, not for deployment. Is there a quick way I can get that library running from FSI then?
I've used Tesseract from a compiled F# app with no problem, but have never tried from FSI. I just put the native DLLs in the expected location and the app picks them up.
F# has better practical positioning. What i mean is: unlike elixir or ocaml, it can be just as effectively used for programming tools, networking, or UI. It doesn‚Äôt niche itself.
I've used opencv successfully from FSI before on mono. It took some copy/pasting of the C++ libs into the right directory before FSI was able to resolve them.
If you're making non-UWP application you can still use UWP APIs https://blogs.msdn.microsoft.com/lucian/2015/10/23/how-to-call-uwp-apis-from-a-desktop-vbc-app/
What is genetic programming?
Well at least you are honest.
It was actually banned from posting on /r/csharp
I've done it in F# with the new Textract service from AWS (still in preview, I believe).
I spent the last week refitting a homegrown WPF time entry system with an F# / Cosmos DB back-end. The demo after one week of development went very well, and will have testable beta at the end of week two. That includes custom 2-way syncing to Excel. It's amazing how quickly you can crank out quality software when using F#. Getting lots of use out of the "TaskBuilder" library in conjunction with the Microsoft.Azure.DocumentDB.Core" library. Unfortunately the latter requires Linq expressions for querying, but not a big deal since F# automatically converts to lambdas to expressions when calling into a class method that requires them. Since my composition root is in a C# front-end, I opted to create an F# facade layer that would allow me to compose my FP components together. Also, no interfaces required because all domain and transform logic is easily testable via pure functions. Interfaces are such a pain, so removing them is a very big quality of life improvement. :)
This example uses a F# script file and Tesserect: https://github.com/Martin4ndersen/tesseract-example
The first line of the script references a .NET DLL that doesn't exist in the solution. Are you supposed to install Paket and then get it to restore the packages directory or something? The rest of the code looks exactly like what I already tried and it didn't work because it doesn't pick up the native DLLs. I tried setting the current directory and even explicitly loading them via PInvoke but neither solved the problem.
Great project! I suspect this kind of thing will become even easier with the release of .NET 5. That's when all of these different runtimes will converge on using the `dotnet` tooling, and will also be using the new project system. https://devblogs.microsoft.com/dotnet/introducing-net-5/
I've very much enjoyed a series on [Enterprise Tic Tac Toe](https://fsharpforfunandprofit.com/posts/enterprise-tic-tac-toe/). It's from F\# for fun and profit. Excerpt: *This post is one of series in I which I hope to close the gap between theory and practice in functional programming. I pick a small project and show you my thought processes as I go about designing and implementing it from beginning to end.*
Not exactly project-based, but [https://fsharpforfunandprofit.com/books/](https://fsharpforfunandprofit.com/books/) "Domain Modelling Made Functional" highlights the benefits of the language nicely. [https://github.com/CompositionalIT/SAFE-Dojo](https://github.com/CompositionalIT/SAFE-Dojo) might be of interest from practical perspective.
I like this series of blog posts about building a D&amp;D simulator and how he models the rules: https://brandewinder.com/2018/07/23/give-me-monsters-part-1/ It's 9 parts so far and not yet finished, but I doubt it will ever be finished.
This one speaks to me.
I‚Äôm doing a series on building a platform game on my YouTube channel, from the ground up.
I wrote up a series of posts detailing how I built a project using Vue on the front end, with a Giraffe API back end, using EF Core for data access. https://blog.bitbadger.solutions/2018/a-tour-of-myprayerjournal/introduction.html
Sounds amazing please post a link.
https://www.youtube.com/playlist?list=PLIH3o_QrxxcfNMC3TjZ5NlHnB1AmcyaiV
Trying to abstract over numeric types is generally a bad idea because different types have different properties, e.g. rounding errors. You can also implement a power series as a function rather than a lazy list which is much easier. For example, here is my implementation of differentiation: let differentiate f n = Q.FromInt(n+1) * f(n+1)
What was the rationale behind not using `Seq.unfold`, or even `Seq.initInfinite`? Either of those would have been significantly less convoluted and more efficient.
&gt;Trying to abstract over numeric types is generally a bad idea because different types have different properties, e.g. rounding errors. I agree that it needs to be done carefully, but I wouldn't say it's a bad idea. The coefficients of a power series are usually intended to be exact (e.g. int, BigRational), so I would avoid anything that rounds. Haskell supports this sort of abstraction very gracefully (e.g via the \`Num\` typeclass), and F# supports it with much more effort via type constraints. &gt;You can also implement a power series as a function rather than a lazy list which is much easier. For example, here is my implementation of differentiation: &gt; &gt; let differentiate f n = Q.FromInt(n+1) \* f(n+1) I'm not certain what you're doing here. Are you calculating the derivative of \`f\` at the point \`n\`? As an example, say f(x) = x\*\*2. How does your code calculate the derivative, which should be f'(x) = 2\*x?
An infinite sequence can certainly be used to represent a power series, but the math depends on being able to process the series recursively as a head value with a (lazy) tail that's also a power series. For example, if F and G are power series, we can multiple them as follows: * F = f + x \* F1 // f is the head value, and F1 is the tail power series * G = g + x \* G1 // g is the head value, and G1 is the tail power series * F \* G = (f + x\*F1) \* (g + x\*G1) = (f\*g) + x \* (f\*G1 + (F1\*G)) This translates directly into F#: * (f :: fs) \* (g :: gs) = (f \* g) :: lazy (f \* gs + fs \* (g :: gs)) In other words, we compute the product's head value by multiplying the head values of the two operands. We also create a (lazy) power series that will compute the rest of the product when evaluated. I'm not sure how to do this with an F# sequence, but I'd certainly be open to the idea if you want to give it a try.
It is not possible to reference .NET Framework components from .NET Core applications. So you'll either have to use alternatives or manually reconfigure your server to run on on .NET Framework (and thus Windows).
I agree, this does not seem possible.
I see. Thank you for the quick reply! Are there are any database type providers available for the .NET Core apps? I also tried SQLProvider to no avail. Do .NET Core apps just not have any type provider options when it comes to databases? That was one of the biggest draws of the language for me.
I agree that "typeclass" would be very confusing in the context of F#. I think "trait" would've been better than "shape", though.
I think trait would be a good alternative also. Trait I think works well within the traditional OO ways of thinking. I think shape makes more sense within terms like pattern matching.
Username checks out
I see, this is *specifically* for a cons pattern. Since F# has neither infinite nor lazy lists implement cons patterns like Haskell, I always default to thinking of anything lazy/infinite in terms of sequences. With lazy lists computing an element exactly once, I think the closest native analogue would be `Seq.cache` if you used a sequence approach. Definitely a cool pattern that I‚Äôll look into more; I‚Äôm especially interested in seeing the performance characteristics vs. using sequences.
I think the best you're going to be able to do is to write the "guts" of your functionality in F# in a project that precedes compilation of the WebForms project, and call it from the code-behind. You should be able to reference all the libraries in your F# project as well, so the instances that the runtime populates (context, etc.) should be populated as well. (This is what I did for an MVC project that used EF6; it toggled back and forth between C# and F# in the compile chain.) To your original question - you can write extension methods in F# that will be visible from C#. The module and the function should both be decorated with the Extension attribute (from the System.Compiler.RuntimeServices namespace); that's described [here](https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/type-extensions). Again, the F# project will precede the C# one, but it can't reference a type from the C# project that follows it, so you'd need to extend a type you could see at the point the F# project is compiled. Hope that helps!
&gt; I think the best you're going to be able to do is to write the "guts" of your functionality in F# in a project that precedes compilation of the WebForms project, and call it from the code-behind. What I was afraid of. *Sigh*. Is it bad if I just don't like C# very much? lol &gt; You should be able to reference all the libraries in your F# project as well, so the instances that the runtime populates (context, etc.) should be populated as well. Oh, I didn't realize that. That's pretty nifty. &gt; Again, the F# project will precede the C# one, but it can't reference a type from the C# project that follows it, so you'd need to extend a type you could see at the point the F# project is compiled. Hmm, I wonder if I defined an F# type with the callback method and then somehow make the C# code automatically forward the calls to it, rather than having to manually hook them up from inside a C# callback. I don't think C# supports Traits/Mixins to just merge in the functionality from an F# type. The only other thing I can think of would be setting the CodeBehind value of the .aspx file to an .fs file directly, but I'm pretty sure that would fail since it doesn't have the .aspx.fs magic associated with it. Unless...maybe if you define an F# type that inherits Page and do Default.aspx.fs? Perhaps there is some way to configure that to work, if it doesn't ootb? Just grasping at straws here. T_T
This sounds like Kleisli composition, which is commonly known as the ‚Äúfish‚Äù operator: &gt;=&gt; I‚Äôm on mobile right now, so I can‚Äôt give more details, but you might start here: https://fsprojects.github.io/FSharpPlus/tutorial.html. Scroll down until you see the section on the fish operator.
since you want to do both tests and not short circuit the second test if the first one fails, I'd do this: ``` match! ProjVal.valName editedProject projectNames, ProjVal.valTasks editedProject with | Ok _, Ok _ -&gt; do! projectRepos.SaveProject(editedProject) return Ok () | r1, r2 -&gt; return [r1;r2] |&gt; List.choose (function | Error msg -&gt; Some msg | Ok _ -&gt; None) |&gt; (fun errs -&gt; System.String.Join("\n", errs)) ``` the Kleisli operator `&gt;=&gt;` or railway programming approach wouldn't run the second test if the first returned `Error _`.
I thought Kleisli composition allows appending side-effects together (like a log file, or multiple error messages), rather than short-circuiting. I could be misremembering.
You could be right, I'm going by memory.
What about something like this? [https://demystifyfp.gitbook.io/fstoolkit-errorhandling/list/sequenceresulta](https://demystifyfp.gitbook.io/fstoolkit-errorhandling/list/sequenceresulta)
I think this sounds more like the applicative style described [here](https://fsharpforfunandprofit.com/posts/elevated-world-3/#validation). `&gt;=&gt;` is for composing functions similar to how `&gt;&gt;` works, but it's for the "elevated" types as described in that link.
Why?
FSharpPlus has a [Validation](https://fsprojects.github.io/FSharpPlus/reference/fsharpplus-data-validation-2.html) type straight out of the box with the appropriate applicative methods. I haven't looked but bny reason that couldn't work here?
Check out Bind and Apply from here: https://fsharpforfunandprofit.com/series/map-and-bind-and-apply-oh-my.html
The semigroup operation on `string` is plain concatenation (without the additional newline like here), so you would need to wrap the error in a single-case union and define its semigroup operation with the newline. Otherwise it should work well.
It is, but it also isn't. If you write your functions to deal with values, rather than controls, you can more easily write tests for it\*. You can create an F# function that takes values, and returns a discrete status of whether the operation was successful or not, or any other state to which you'd want to respond. Then, your C# code calls that and branches based on the return value. You would end up writing more C# code, but you would have a clean separation between your UI/presentation logic and your business logic. &amp;#x200B; \*You could still do that with controls, but your test setup will be larger. If you don't care about the separation of concerns (at this point, or ever) or want an F# UI layer, and want the F# code to manipulate the controls directly, you could define a `struct` of controls (in F#) that you pass to the function, and use [AutoMapper](https://automapper.readthedocs.io/en/latest/Getting-started.html) in your C# project to map the properties from the form to the struct (keeps you from having to write `x.Label1 = this.Label1` over and over). You'd still have to wire it up in C#, though you could do one mapping per form; and, if you changed controls, you'd also have to update the `struct` definition. But, it could get you close to what your vision was when you started.
I was working on Unity voxel game engine with destructible environment (octree is done, used to place/remove cubes and generate path maps). The development was stopped until second person will solve some of his IRL problems. Now I'm writing an untyped functional scripting language with string interpolation and full-blown pattern matching. Both things are closed-source, though. _Maybe_ it will be possible to show the scripting language code, but I can't say for sure.
Thanks for the ideas! Evaluating the responses this morning got me thinking that I was really after very specific verbiage in the way I expressed my intentions. The ideal approach, I thought, would be to handle positives first by saying, "if ALL results are Ok, then do work, else handle errors". My original hope was that the Result type had some sort of built-in way to accumulate and handle multiple results, but after reading the responses, I see that something custom is in order. Which then led me to the early morning (well, 11:30 AM) epiphany that this is the perfect place to use an active pattern! module ProjectValidation = /// An active pattern for handling multiple validation results. let (|AllOk|Errors|) validationResults = let oks = validationResults |&gt; Seq.choose (function | Ok ok -&gt; Some ok | Error _ -&gt; None) let errors = validationResults |&gt; Seq.choose (function | Error err -&gt; Some err | Ok _ -&gt; None) if errors |&gt; Seq.isEmpty then AllOk oks else Errors errors let validateProjectName (project: Project) (projectNames: string array) = ... then in my facade class: /// Saves a project to Azure. member this.SaveProject(editedProject: Project, actions: TaskSyncAction seq, isNameChanged: bool) = task { let! taskIdsWithEntries = projectRepos.GetProjectTaskIdsWithEntries(editedProject.Id) let! projectNames = projectRepos.ListProjectNames() let res1 = validateTasksWithEntriesAreNotDeleted editedProject actions taskIdsWithEntries let res2 = if isNameChanged then validateProjectName editedProject projectNames else Ok () match [res1; res2] with | AllOk _ -&gt; do! projectRepos.SaveProject(editedProject) return Ok () | Errors errors -&gt; return Error (System.String.Join("\n", errors)) } I don't actually care about accumulating the `Ok` values in this case, but it's easy enough to ignore them with `_`, and I suppose it makes it more reusable.
This Kleisli fish operator piques my interest for sure, and seems like something I *should* understand. In fact I have even used it before with Giraffe. But while I enjoy how nice it looks, I still do not understand what it is actually doing behind the scenes. It's great until something breaks down or doesn't work the way I intend, at which point it becomes hella-frustrating (this has been my experience customizing routes in Giraffe). &amp;#x200B; Maybe it would be more compelling if I could see an actual example of how it would solve this problem specifically; but seeing the uncertainty of even the enthusiasts in this forum makes me less inclined to want to actually try to use it. &amp;#x200B; I know if it confuses me then it confuses other people as well, and I need this code to be simple to understand (lest I invoke another F# ban). However, I am still interested on an academic level!
 This Kleisli fish operator piques my interest for sure, and seems like something I *should* understand. In fact I have even used it before with Giraffe. But while I enjoy how nice it looks, I still do not understand what it is actually doing behind the scenes. It's great until something breaks down or doesn't work the way I intend, at which point it becomes hella-frustrating (this has been my experience customizing routes in Giraffe). Maybe it would be more compelling if I could see an actual example of how it would solve this problem specifically; but seeing the uncertainty of even the enthusiasts in this forum makes me less inclined to want to actually try to use it. I know if it confuses me then it confuses other people as well, and I need this code to be simple to understand (lest I invoke another F# ban). However, I am still interested on an academic level!
Constant shitposting of low quality articles
Also I hope you don't mind me asking questions here... Stack Overflow is a experiment in gamified human interaction that has gone terribly wrong.
As a single line statement this doesn't make sense. Assuming it should be formatted like this the warning shows up on line 2. let f (x:obj) (y:float&lt;m&gt;) = let x' = x :?&gt; float&lt;m&gt; x' = 3.&lt;m&gt; I've found whenever I've worked with UOMs that I end up with a lot of * 1.&lt;UOM&gt; and / 1.&lt;UOM&gt; to manage different parts of code that are more or less UOM-aware. So applying that logic to your issue, the warning goes away if I format that line like this: let x' = (x :?&gt; float) * 1.&lt;m&gt;
Weird, it should be on three lines. (Also I just realized the second parameter isn't needed.) That solution works for numerical types, but it won't work for anything else. For example, this bombs out: ``` [&lt;Struct&gt;] type V2&lt;[&lt;Measure&gt;]'u&gt; = V2 of System.Numerics.Vector2 let f (x:obj) = let x' = x :?&gt; V2 x' = V2(Vector2.Zero) ``` &gt; error FS0033: The type 'FSI_0078.V2&lt;_&gt;' expects 1 type argument(s) but is given 0 And of course, adding a type parameter to V2 causes the warning again.
Hmm, I can't figure out a way to make this one work without the nuclear option of: #nowarn "1240" let f (x:obj) = let x' = x :?&gt; V2&lt;_&gt; x' = V2(System.Numerics.Vector2.Zero) This might just be one of the cases where F# measures just don't work. Because they're compile-time only, I find they can be limited in surprising ways.
Thinking about this some more, is a vector type object with measures what you are trying to achieve? I think the issue is that types like Vector2 that weren't built as a UOM type don't play nicely when UOMs are applied. The UOM doesn't propagate through the field types and return types. I think you would be better off building your own UOM aware vector2 rather than trying to apply a UOM to the existing type. You're probably best off to stick with regular numeric types or types you've built from scratch if you're using UOMs.
I'm actually wrapping a full wrapper around the Numerics Vector2 since it's built into .NET and has a decent set of functions. As far as I know, that's the only way to go. I also just realized that struct equality will kick in even if I don't implement IComparable, so this particular instance may not be that big of a deal. Hopefully performance will be moot once it's compiled, since whether I use a single-case struct union or a single-field struct, it should optimize out the dereferencing. Still, not being able to downcast kind of leaves me with doubts about the viability of UoMs...
&gt; Weird, it should be on three lines. Depends on what version of Reddit you're using: old website, new website, or one of the many apps. The old website doesn't support triple backticks, and neither do many apps. Indenting by 4 spaces is the only code block syntax supported everywhere.
User defined types can't omit measure parameters, unlike built-in ones, so `x :?&gt; V2` won't work, you need to use `V2&lt;1&gt;` I believe. But you can make an alias yourself `type V2 = V2&lt;1&gt;`.
This looks very cool. I wouldn't have thought it possible in F#. Thanks for sharing.
Thanks, there are several [implementations](http://www.fssnip.net/sq/title/Simple-type-arithmetic-with-Peano-numbers) of Peano numbers in F# but that way of type-level arithmetic quickly becomes intractable for the F# type checker after only small values, and isn't very elegant to write. This way uses fixed-point decimal types and F#'s ability to have polymorphic static inline operators, which ls much more tractable. It also uses an F# type provider to make creating types out of static numeric values very easy.
`V2&lt;1&gt;` still gives the same error: `This type test or downcast will ignore the unit-of-measure '1'`. Ditto with a type alias.
Then, I *guess* the warning (it's a warning, not an error, right?) won't go away unless you use `V2&lt;_&gt;`. It shouldn't raise a warning with the type alias I proposed though. You could consider opening a suggestion to remove the warning in certain cases or reach some other solution. Units of measure need a bit of an overhaul in my opinion; they're not ergonomic at all when they interact with other features of the language, specially on user defined types. But I don't think many people use them so, understandably, there's few resources dedicated to identify and correct the edge cases.
It won't go away with any type annotation. Which makes sense, considering `(3.&lt;ft&gt; :&gt; obj) :?&gt; float&lt;m&gt;)` could potentially crash a Mars rover. For now I'm just going to use #nowarn. I wonder if more people would use it if it were easier to use. There ought to at least be a way to annotate existing types with units for use in your own code. Even just making &lt;1&gt; cast with non-UoM would be really helpful.
Look at the slide of my workshop for learning how to contribute to th F# compiler at openfsharp https://github.com/AviAvni/openfsharp-workshop
&gt;Which makes sense, considering (3.&lt;ft&gt; :&gt; obj) :?&gt; float&lt;m&gt;) could potentially crash a Mars rover. That's reasonable, thinking about it. Although it should be harmless to cast to `&lt;1&gt;` because there's barely any difference between that and casting to non-UoM; you have to add back the units yourself later in both cases. &gt;There ought to at least be a way to annotate existing types with units for use in your own code. Problem is, you wouldn't be able to infer which methods/parameters/properties should take which units, so the annotations would end up resembling a wrapper type anyway. I'd rather focus on more general features that help reduce the boilerplate instead. &gt;Even just making &lt;1&gt; cast with non-UoM would be really helpful. Agreed, this should be a language suggestion. I actually think they should behave exactly the same at the type level, just like there's no notion of non-UoM for user defined types. PS: Just so you don't waste any time debugging, you may also hit [this bug I already reported](https://github.com/dotnet/fsharp/issues/5558) when working with units of measure.
Honestly probably not bad. Your react folks should be able to help you with FP, and you can help them with types. If they join the F# slack ([fsharp.org](https://fsharp.org)) the community should be able to give them help as needed.
Yes and I can think of at least two devs who are experienced F#ers who are looking for work.
This is OUTSTANDING. I'm super excited about this.
Hey this is pretty cool...I didn't realize it was that easy to hack on the F# compiler. I've been wondering for a while now if it is possible to modify the compiler with additional flags to speed up type checking for things like recursive types, Thanks for posting this.
Hey thanks a lot! I have a lot more examples to add with things like lists and vectors and HLists.
I'm working on a SQL builder, [Norm](https://github.com/zeekozhu/Norm), it is inspired by SqlKata. But I think SqlKata is not extensible enough. Generating CTE for SQL Server 2008 pagination is really stumping me.
Holy crap. I wonder what we could use this for?
One use is for creating lists or arrays with with type-level bounds checks. e.g in the screenshot below [VS](https://i.imgur.com/HPnrNgv.png) Array access to a VList is checked at the type level before run-time.
That's amazing.
&gt;Edit 2: For anyone who sees this, I found that neither FSharp.Data.SqlClient nor SQLProvider worked properly with any version of .NET Core. I will just have to wait around till the APIs update/get more refined. We have the former in production use on a small .NET Core app right now, fwiw. The latter is a bit more painful to use with .NET Core due to the need to manually janitor database access libraries, but it worked for me last year as well.
&gt;Edit 2: For anyone who sees this, I found that neither FSharp.Data.SqlClient nor SQLProvider worked properly with any version of .NET Core. I will just have to wait around till the APIs update/get more refined. We have the former in production use on a small .NET Core app right now, fwiw. The latter is a bit more painful to use with .NET Core due to the need to manually janitor database access libraries, but it worked for me last year as well.
first and foremost, understand that F# is not just another language, it's a different paradigm from what you've already learned, it will require a different way of thinking. you're going to struggle for resources, as the language just doesn't have the popularity that the others you have used do. Start here: [https://fsharpforfunandprofit.com/](https://fsharpforfunandprofit.com/)
I know that my answer might seem to be obvious, but on official F# site has a lot of tutorials, recommendations, books that 100% will help you to learn F#. Also if you‚Äôre feels good with OOP, you might struggle from learning F#, because it requires another way of thinking and it require time from you to start thinking in FP paradigm.
Thank you very much
Ok, thank you very much
&gt; We have the former in production use on a small .NET Core app right now, fwiw Oh nice. Do you have any insights about how to make it work? Any issues you encountered that you managed to work around? Version numbers involved? I'm guessing you would have to build a design time dll yourselves.
Hi guessing you would have to build a design time dll yourselves., I'm dad.
I like the book [The Book of F#](https://books.google.fr/books?id=-4vlAwAAQBAJ&amp;printsec=frontcover&amp;dq=isbn:1593275528&amp;hl=fr&amp;sa=X&amp;ved=0ahUKEwjX9vfO0ObiAhUS3xoKHdB0CfIQ6AEIKDAA#v=onepage&amp;q&amp;f=false) . It's well written and accessible.
I'm not knocking other books, but check out [Functional Programming Using F#](https://www.amazon.com/Functional-Programming-Using-Michael-Hansen/dp/1107684064/)
I agree with the others here. The most important thing will be to learn the ideas behind functional programming. I recommend seeing some videos on YouTube about it. It's a very rewarding way of programming in any language really. It's really something you won't regret learning whether it's through F# or some other functional language (e.g. Scala). F# is a very fun language though :D so it's not a bad choice.
Thanks, I will check it
Thanks, I will check it
Thanks for your insightful reply, it helps me a lot
Method that always worked for me, no matter the language, is - create something! Pickup some problem you want to solve, something simple for start, and go for it. Learn on the fly as you try to solve your problem.
I'm sure people are shocked by this.
Thanks
This is hardly relevant. It‚Äôs not like Jet‚Äôs use of F# was responsible for Walmart‚Äôs failed attempt to compete with Amazon lol. In that regard, Java is just as much to blame.
It was not my intent to suggest anything like that. [Jet.com](https://Jet.com) has been the most visible big adopter of F#, now I wonder if F# will whither way at Walmart, or if as these folks get subsumed into the organization, they will continue to evangelize it. Hopefully the latter.
I'll check tomorrow, but I'm pretty sure it's been 'install the nuget package, done' since it added .net standard support. I say this because one of my coworkers doing this project mentioned how happy they were that it ran entirely on SQL Server, so they were able to just run SqlClient without a care in the world, compared to the super fragile architecture of the multi-vendor SqlProvider.
I wonder if the reason I've been having issues is because I'm using Paket? I have to build via the command line on SAFE apps since VS can't just run the build command directly (or seems that way). Every time I try to use it, it has issues, and when I look them up online, they say that it doesn't yet have netstandard support/dlls, etc. Hmmm.
There is no reason why F# would ‚Äúwhither away‚Äù at Walmart. Jet did what it was supposed to do, and it did it well. This was the result of poorly strategized market penetration on Walmart‚Äôs part, nothing else.
Who said Jet did something wrong? I think you're reading between the lines of my posts. I disagree with you, F# *could* whither way at Walmart, though I certainly hope it doesn't.
&gt; There is no reason why F# would ‚Äúwhither away‚Äù at Walmart. you give no reason for that. once the teams get integrated into other teams, it is likely they will get integrated into those other teams' environments, which are unlikely to be f#. who are these "big" adopters of f#? microsoft does not seem to be one of them. they use it, but as far as i can tell it is still incredibly niche there, especially given the amount of people involved in the actual f# development and management at microsoft. my uncle is an architect or whatever else high up title at microsoft, who takes on huge consulting projects for some rather large customers of microsoft. when i asked him about f#, i could tell he has heard of it but that it wasn't even close to being on the radar to even being considered for use. when i was on a recent job hunt, it was easier to find jobs for smalltalk and common lisp than f#. practically no one uses it. anyone who advertises it just lists it to attract people. i know of two companies in my area, a major area, that actually uses f#, and as far as i can tell, that's two people total. i think there is more, but they don't hire and they aren't just f# teams like jet.com advertised themselves to be. usually it's just some small service written in f#. so basically, you are completely overstating f#'s market penetration.
wither
I never said anything about F# ‚Äúmarket penetration‚Äù - in fact, I used that phrase in the context of Walmart‚Äôs purpose for acquiring Jet. You just scrambled my comment up and used it for some platform for whatever your counterpoint was supposed to to be. Just to reiterate in words that can be read more slowly, my point is that posting this in the F# sub is akin to FUD because Walmart‚Äôs failure to meet expectations that were driven by Jet‚Äôs acquisition has nothing to do with the language. If that‚Äôs still difficult for you, let me know and I‚Äôll try again.
No one said Jet did something wrong, I *literally* said that Jet fulfilled its purpose, and probably did it well. By all means, disagree with me, but I never said F# *couldn‚Äôt* wither away at Walmart. I said there is no reason for such a consequence since it was at no fault for the failure of the platform to deliver on Walmart‚Äôs expectations. I really don‚Äôt get how this isn‚Äôt understandable.
Walmart's labs teams already use less "main stream" languages like Clojure, so I would bet f# keeps on keeping on with the Jet team in some form or fashion.
&gt; There is no reason F# would wither away at Walmart because the language is not at fault for Jet‚Äôs inability to meet Walmart‚Äôs expectations. No correlation, no causation. what does this even mean? &gt; failed job search lol. okay. nowhere did i say it was a failure. &gt; my point is that posting this in the F# sub is akin to FUD because Walmart‚Äôs failure to meet expectations that were driven by Jet‚Äôs acquisition has nothing to do with the language. maybe you should read more slowly, as no one said f# had anything to do any of the failure. mind pointing to where someone said that? as can be seen by the op‚Äôs reply to your own comment, that you also replied to, the original poster is clearly curious about what this means for f#. it‚Äôs a ‚Äúnow what?‚Äù question for f# at jet.com/walmart which is perfectly relevant because other than tachyus, it is the only company who seems to be all in on f# and was really the only large company peddled around as one using f#. my comment was a response to your comment which seemed to imply that f# was adopted heavily by other companies. *however, you have slyly edited your comment i replied to which does indeed seem to make my comment not relevant.*
I had more written out, but you‚Äôre an actual lost cause so I‚Äôll just leave this here for you to ponder. You can always try moving your lips while you read if you get stuck on any of the mire difficult concepts. I removed that bit because I didn‚Äôt want to have to risk my anonymity, but since you latched onto it, here goes - my imaging lab at UTHSC uses F#/C# (formerly Python/QT), Crystal, and Rust. We use F# for the majority of our MRI and CT reconstructors and automated diagnostic engines/landmark detectors. I only joined this group in the last year, so I‚Äôve been catching up on F#/C#, but our research, the realizations and applications of which exist significantly in the form of F# code, net millions in federal research grants and industry support. Some universities with whom we collaborate on the same projects are UTK, Duke, and UNM, to name a few. I know of many international universities (several in Denmark, for example) that include F# in their curricula. _Maybe you should try to even gather an iota of evidence (hint: Google) before making ridiculous, wrong, sweeping statements like: ‚Äúyou even mentioned f# was used at ‚Äútons‚Äù of universities. that isn‚Äôt true at all, unless you can provide examples. in my experience, no one at universities has even heard of f#.‚Äù since it‚Äôs now clear that you have no experience._ As far as the ‚Äúnow what‚Äù at Jet, who cares? Jet hasn‚Äôt dissolved and there‚Äôs no evidence that Jet is going away. _The only thing this post serves to do is potentially scare away people who are interested in the language, and come to this sub to learn more. A post about Jet is especially visible since it‚Äôs very likely that, like you, they can only name a single entity that uses it._ Reply all you want, I‚Äôm done.
just because a few of universities use it doesn‚Äôt make ‚Äútons of universities ‚Äú make sense, which was my point. i am aware of a few using it, but isn‚Äôt a lot, especially percentage wise. i have direct experience with some of the best universities in the u.s. and even world, and f# is nowhere to be found in the curriculum or research applications. again, it was certainly clear that i was countering your implication that f# is *widely* used at *a large amount of* universities. you have still failed to present any evidence otherwise. there are over 50 universities and colleges in my metro area alone. you named only four universities and implied a few others. that isn‚Äôt ‚Äútons‚Äù of universities. it is what it is, a few.
Good company
Not sure if this will work but a potential workaround might be to implement a virtual filesystem as per this example [http://fsharp.github.io/FSharp.Compiler.Service/filesystem.html](http://fsharp.github.io/FSharp.Compiler.Service/filesystem.html)
Fixed it, thanks.
Kind of a bummer to see this, but overall I think there's quite a positive takeaway from the F# perspective: you can build a company worth 3.3 billion and have developers using F# to power it. F# most certainly isn't the reason behind that purchase price, nor is it the reason behind "only" being able to make hundreds of millions per year. But it's a great story and evidence that F# can power a huge business. As for the future of F# at Wal-mart, it's all hard to say. I know people who are spinning up new teams that use F#, and I know people who are moving to other things. Wal-mart itself is such a huge organization that the variety of tech is probably mind-boggling. I'll certainly be involved (to an extent) to ensure that teams who _want_ to use F# can tell their management that they have Microsoft support when they do so. Any folks at Jet reading this can feel free to reach out to me if they feel they need that kind of messaging.
This is the best suggestion. This and get reference resources
Thanks
Something like this shit: {-# LANGUAGE ViewPatterns #-} {-# LANGUAGE RecordWildCards #-} module Main where data Foo = A Int|B String Example|C Example deriving Show data Example = Example { x :: Foo, y :: String } deriving Show asStr :: Example -&gt; String asStr Example{..} = let s1 = case x of A n -&gt; show n B s e -&gt; s &lt;&gt; asStr e C e -&gt; asStr e in s1 &lt;&gt; " " &lt;&gt; y test = Example (B "bar" (Example (A 6) "foo")) "baz" showit (asStr -&gt; s) = print s main :: IO () main = showit test
It works, yes, thank you. But why would you call this code being a "shit" ?
Lol
Hello, Notepad++ has an uninstaller that you can execute with the '/S' flag to silently uninstall. VSCode can be downloaded using [WebClient.DownloadFile](https://www.google.com/url?q=https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile&amp;sa=U&amp;ved=2ahUKEwjKg6DOuvHiAhXPIDQIHVArDXsQFjAAegQIAhAB&amp;usg=AOvVaw34Eyk0OdKkXEEkqnr_tAda) and silently installed with the '/VERYSILENT' flag. Hope this helps.
Also.. its easy to forget that one can be pragmatic in F# and do OOP. Searching for C# solutions for stuff can be useful. Solving problems is more important than to get blessings from the FP gods.
This kind of scripting *can* be done in F# or C#, but Powershell would be a better fit.
Haskell, sir
Ok, lol \^\^ Thanks
The default dotnet templates are unaware of paket and assumes that you use Nuget. You can install and use Paket in your current repo with `dotnet tool install --tool-path .paket paket` Then add a packages to your project with `.paket/paket add -p Project.fsproj` [`FSharp.Data`](https://FSharp.Data) There might be smoother ways to do this and maybe there is a way to do this in Ionide. I find this to be quick enough so I have not been searching for better ways. Often I "cheat" and just use Paket as a global tool tbh.
As others have mentioned, outside of practicing the language, there are much better tools for that job like powershell or maybe even C# a .NET executable. The problem with .fsx scripts is that you need something to run that script, which is fsi.exe. You need to have it installed on the machine you want to execute the script. Maybe others can enlighten me but you would have to install vscode or visual studio to get fsharp executable stuff. This defeats the purpose of automatically installing vscode. If I were you, I would try to find C# examples for installing and uninstalling programs and then try to port it to F# (since its all the same .NET, C# and F# interop quite well). I would deploy it as an executable to avoid installing fsi. ... or from the practical standpoint, write it in powershell.
You get FSC and FSI when you install .net
Right... but this also doesn't come with the default windows installation? Usually it's the dev machine that has it.
I was enlightening you, per your original comment.
As good as Ionide is, it is not a C# extension so cross language functionality is not really given. Visual Studio also does not work very well (go to definition, find usages from C# to F# does not work). Imho the only tool that has good cross language support at the moment is Rider from Jetbrains.
thanks for your reply. does ionide decompile the code to show the sources though since it shows the same throw null in method definitions as rider?
I don't know but I don't think so
+1 for paket as global tool (and 'storage: none')
I‚Äôm also newish to this but not from C#, are you trying to run it as C# inside F#?
Well it's not really decompiling per se, but it does seem that the information comes straight from the assembly, if that's what you mean.
I don't quite understand what you mean
I downloaded this project: [https://github.com/gothinkster/fsharp-realworld-example-app](https://github.com/gothinkster/fsharp-realworld-example-app). Built it. Tried to go to definition of \`&gt;=&gt;\` and got error Unable to open `'C:\projects\suave\src\Suave\Operators.fs'` so I wonder where this info is saved since I work on mac and don't have such directories at all
maybe a dumb question, but why use packet ?
I think that's a reflection of a general annoyance I have with .net/dotnet projects (compared to say Python where the third party source code is usually available). From what I've tried you only get 'go to definition' for things defined in your solution or project. Third party libraries don't have a way to jump to their source code even if it's an open source project. The editor can show docstrings, type information and assembly info because that is all part of the dll dependencies downloaded from nuget. Suave is a third party dependency in that fsharp realworld app so you just get a dll download from nuget as far as I know. Jetbrains Rider has a decompiler but decompiled F# looks more like C# and its harder to follow. I thought that [dotnet sourcelink](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink) would provide go to source for libraries that enable source link support, but it only seems to be about pulling the source code down whilst debugging.
that‚Äôs a pity :(
Historically it have been (and arguably still is) more dependable / deterministic in how it handles dependencies and version conflicts, but if you use NuGet and have no problems, by all means continue to do so. Just remember that Paket exists if something goes fishy. With that said, Paket have a killer feature that I **really like.** That I can reference GitHub projects and even specific files instead of Nuget Packages... I have a few helpers that I often pull into projects, and its real sweet to just reference it like `github: myorg/myrepo MyStuff.fs authKey`
Good to know, the github ref part seems neat!
Cool project! Also, I think it‚Äôs awesome that almost every fsharp tool seems to have a great logo :) I‚Äôm very new to the fsharp ecosystem, it would be great to have some sort of comparison or docs on what problems Avalonia aims to solve that other tools (e.g. Elmish) does not.
Avalonia UI is a cross platform UI framework. I‚Äôve built Avalonia.FuncUI on-top of it (similar to Fabolous and Xamarin.Forms). It‚Äôs not an alternative to Elmish, it actually provides binding to use the elmish programs, etc. If you have further questions let me know üòä
Does anybody have a sample of moderately complex app on Elm-like architecture? All I see is counters and other small todo-MVC like samples. I'm interested in, for example, how do you reuse code, "elm controls"?
Ah, okay. So, coming from web dev, would it be fair to say something like: If elmish is an alternative to elm or react, Avalonia is a cross platform alternative to, say, bootstrap?
Hmm, I don't think there is a simple and correct analogy to this, Avalonia is a whole UI framework. Maybe checking their website makes things clearer :) [http://avaloniaui.net/](http://avaloniaui.net/)
Personally I just tend to make functions :D ```fsharp let tagView (tagName: string) (tagColor: string): View = Views.border [ Attrs.margin 1.0 Attrs.padding (2.0, 0.0) Attrs.cornerRadius 5.0 Attrs.background tagColor Attrs.child ( Views.textBlock [ Attrs.text tagName ] ) ] ```
Do you know the elm-spa app by Richard Feldman? It is supposed to show some patterns for bigger apps. https://github.com/rtfeldman/elm-spa-example I know it is elm but the similiarities to F# are big enough to make good use of it.
I've built a fairly complex application using Elmish.WPF for my teams internal tools. Reusing controls under that framework is a little different than Elmish due to the nature of WPF. However, you can still reuse controls the "classic" WPF way and any duplicated logic can be thrown into a core library for the application.
Yes, this will be a first class concept in a future F#. Just not this year, though.
Thanks. Good to have a little context on timeline. &amp;#x200B; It is a testament to F# and the power of Computation Expressions that the community was able to create an implementation of TaskBuilder as if it was a built-in feature. Even better is that the upcoming Core implementation will likely be a seamless replacement for the vast majority of cases -- remove the old library and namespaces and done! That is really cool, and could not have happened in C# where async/await is a one-shot feature.
#fakejob
Great video, love these insights into the compiler. Sometimes i wonder, why doesn't the compiler understand me... If you understand that better it makes you a better f# programmer. As C# developers, we are so spoiled with tooling. It makes it hard sometimes to get into other languages like f# or clojure, rings very true
How do you test your data access layer? With C#, I write specification tests that basically do the following: * a generic PersistenceSpecification for each TEntity where the TEntity has an Id column of type long (Int64) * a set of verification parameters: * State * can I read an object in the database, can I save an object, can I delete an object * Behavior * throw if there were no results * throw if a specific property check failed (by "property check", I mean verifies that each property in the POCO round tripped from the C# client to the database and back) This achieves a couple of things: 1. Ensuring my entities don't break if I change my DbContext, such as plugging in a new change tracker (such as can happen *implicitly* when we upgrade from EF Core 2.0 to EFCore 2.2, and now EFCore 3.0) 2. Ensuring there is nothing weird happening in the database, like "instead of triggers" or just any trigger logic. 3. Randomizes the input to verify that I'm not just getting lucky by picking good test values; I use AutoFixture for this. I ask, because I'm curious why I haven't seen anyone do something similar with FsCheck.
Good idea but apparently too complex to implement. See [https://github.com/fsharp/fslang-suggestions/issues/201](https://github.com/fsharp/fslang-suggestions/issues/201) and linked threads.
hmm interesting, thanks. I‚Äôm actually after a ‚Äòpureish‚Äô approach. For me it would be good enough if there was a type of function that only works with the provided arguments and global (static) scope. Having comparable functions would be so nice üëåüèΩ
First, a pure function can definitely use variables from outer scopes; how else would you use other functions or constants? Second, a function being pure is not enough for it to have equality.
I guess you mean global scope. Because FSharpFunctions are delegates after all they will include references to non static outer scope values. Why not ? If you have two functions with the same code that only work with the provided arguments the resulting IL should be (and actually is) the same. let a = fun args -&gt; args + 1 let b = fun args -&gt; args + 1 why should the compiler generate different implementations for the functions (Invoke) method ? There surely are limitations. The following will not result in the same IL and therefor are not equal. let a = fun args -&gt; args + 1 let b = fun args -&gt; 1 + args
There's many issues with that. First, that's just one of the many different notions of function equality; it just happens to be the one you want. You'd have to make a really good case for IL-equality to be the one they make available. Second, it's not obvious which IL is *the* IL. Due to currying and FSharpFunc's calling conventions (`InvokeFast`), F# functions implement multiple methods. Which one do you use to compare? For example, the IL called for `Invoke` would probably, I think, the same for `fun a b -&gt; a` and `fun a b -&gt; b`, because all they do is build a new FSharpFunc that will then call the actual implementing method, stored in a field, which has different IL. Is it reasonable to consider those two equal? How deep should the comparison go otherwise? What's the use case you have in mind for this feature? I'm curious.
Even if you had this, I don't think such semi-textual comparison is useful in general. All it takes is a commutative operation, such as multiplication. Consider `fun x y ~&gt; x * y` vs `fun x y ~&gt; y * x`. If you cannot make them compare as equal, it is hard to argue that you have a generally useful relation.
I need to cache the result of a function, for example ```fsharp let lazy (state: 'state) (args: 'args) (func: 'state -&gt; 'args -&gt; View) : View = // check if there is a cached value for given state and function. type State = { count : int } let viewA state dispatch = lazy state dispatch (fun state dispatch -&gt; // build view from state (might also use other top level functions) Views.textBlock [ Attrs.text state.count ] ) let viewB state dispatch = lazy state dispatch (fun state dispatch -&gt; // build view from state (might also use other top level functions) Views.button [ Attrs.onClick ... ] ) ```
Yeah, you right. This is not a general problem