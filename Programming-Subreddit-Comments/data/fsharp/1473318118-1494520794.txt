FYI Not exactly your case, but you can use this hack to emit MSIL nop instruction. let nop _ = (# "nop" #) 
The original system contains a quadratic term: * x^T H x The system you propose is not equivalent, AFAIK. 
It is equivalent. If you optimise a quadratic f(x) = 1/2ax^(2) + bx you get f'(x) = ax + b = 0 which is linear. This is also the case in multiple dimensions: the minimum of g(x) = 1/2x^(T)Hx + f^(T)x is given by g'(x) = Hx + f = 0, or Hx = -f. The extra linear equalities can be incorporated with Lagrange multipliers, and then you get the system above. Quadratic programming is only difficult when you have linear *in*equalities.
Thanks for the explanation. I will look into this.
I've been teetering on the fence about diving into F# and this convinced me to give it a shot. Thanks for the post.
Not saying this is a good solution, but for a function taking arguments a, b, and c, it might be possible to do a =&gt; b =&gt; c =&gt; myMethodBody
That's great. Lots of content here https://fsharpforfunandprofit.com to get you going.
Can confirm just started looking at fsharp this week and it is fantastic. Hard to break the years of c#. 
If you need help come join the f# slack at functional programming.slack.com. tons of folks in the #fsharp-beginners channel willing to help out
 selectPage("page").getDomNodes(myDomNodes).map(dataExtractor).save()
In fact didn't he just describe that process approximately as a series of data transformations, i.e. a classic way of thinking about FP? (also F# ain't that pure if you have reason not to be)
F# loves data and this makes a great example. The extract function can be done in 1-3 lines of code using the .Net WebClient. F# is very low on boilerplate. Yes its impure but we keep these functions on the edge of our system and protect ourselves from them with great parsing. The database types are accessible using the SQL Type Provider which is 1 line of code. That's amazing, easy type safe database. The pure parse function can be written in a hacky way if you like, but if you want a bullet proof parse that will protect your system from runtime exceptions then there is a great solution that only functional can offer. You need to learn the pattern but it makes parsing data simple and a pleasure. In summary I think you can write this in less lines of code in F# while at the same time being of higher quality.
hmmm. According to [the docs](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/computation-expressions) async { do! Async.Sleep(100) in printf "done"} translates to Bind. Yet the above results in parsing error.
Functional languages abstract away any worries about purity and immutability. Haskell is one thing, but there are a ton of user friendly functional languages out there. Clojure, elixir, f#... You don't have to think "oh shit if I do this I'll accidentally mutate everything and break the system". You have dead standard APIs, they're just non-destructive on data.
&gt; Let's say C can be 20% faster than F# for a given algorithm. It is way more than that though.
For your domain? For mine valuation models which are basically float algorithms they come out to be about this in my experience with no optimisation. I know people say you need to write quant stuff in C++ but I think they are wrong. My point isn't to argue about the 20% but to say the optimisation you can do in a high level langauge by picking a better algorithm far outways being closer to the metal.
Perf query replied to below. In F# you have discriminated union types. Not sure the precise difference you are pointing out. Just know they get rid nulls, exceptions and a whole host of other accidental complexity. https://en.wikipedia.org/wiki/Tagged_union
Discriminated unions are sum types, and are (effectively) a special-case of union types. [See Ceylon's introduction.](http://ceylon-lang.org/blog/2012/01/25/enumerated-types/) Note that the second section, [enumerated classes](http://ceylon-lang.org/blog/2012/01/25/enumerated-types/#enumerated_classes), shows how sum types relate to union types. Also, your perf comment below says it was with "no optimisation", which is hardly a comment on how fast "C can be". 20% also sounds unbelievable to me anyway.
My point is that F# doesn't have union types. F#'s sum types don't give it union types any more than Java's primitives give it value types.
Does choosing F# mean having to choose also the Windows ecosystem? I'm interested in F# but if that's the case I just can't.
[No](http://fsharp.org/use/linux/) 
&gt;Are you cpu bound or developer resource bound? By Jove, your right! I should have been writing Prolog all these years!
purity and immutability mean there's less to think about, you can reason better about the code you just wrote; you seem to suffer from just not being familiar enough with fp.
I wasn't the one who said "Languages without union types shouldn't be able to claim type safety as a feature". But union types are pretty rad. For example, see [Ceylon's `reduce`](http://ceylon-lang.org/blog/2013/12/23/reduce/), where union types feature heavily to let it do things that mere sum types cannot (some of which are extra safety benefits, if you care about the context of the quote).
I googled "f# union" and it seems to show them almost universally referred to as "discriminated unions" (the Microsoft docs are particularly diligent here). If people are referring to them as just "union types", they're using very nonstandard terminology.
&gt; In the third example I am not sure myself, but I am guessing that do! and yield! might have different parsing semantics which is why the yields acts as separators. If I were to harbor a guess, this is because the compiler can't tell that `Async.Sleep 100` is in a different scope than `printf "done"`. Since `do!` is just a "monad-y" `do` block, you can execute any number of lines of imperative code within its scope. `yield` and `yield!` require an expression on the right-hand side, which when terminated with a `;` signal that that's the end of the `yield` expression.
It says Expression: {| do! expr in cexpr |} Translation: builder.Bind(expr1, (fun () -&gt; {| cexpr |})) 
Yes, my guess was that I incorrectly delimited *do!* with *;* instead of *in* Still, it looks like verbose syntax doesn't work in async cexpressions? 
Verbose syntax works for `let`: let f x y = async { let sum = x + y in printfn "%d" sum; return 12 } However I've never thought about the need to use verbose syntax with `do` blocks, so I have no clue how one would even express such a thing, even outside of a CE.
Looks like you might have it backwards? `{| do! expr in cexpr |}` --&gt; `async { do! printf "done" in Async.Sleep(100) }` Still fails to parse. No clue how this works; I've only ever used verbose syntax once or twice. I admit, that table in the docs is kind of confusing.
&gt; I request a page , select some DOM nodes, extract the data , save it into the database. &gt; 4 steps. Now let's say I want to do that the functional way. url |&gt; selectSomeDOMNodes |&gt; extractTheData |&gt; saveItIntoTheDatabase &gt; i'm sure some problems are better solved with functional thinking ( writing a parser for instance ) , but some are definitely not. Graph algorithms are generally worse when written in a purely functional style but I'd note that the context is F# which isn't a purely functional language. 
&gt; Discriminated unions are sum types, and are (effectively) a special-case of union types. Can you give an example of a union type that cannot be expressed as a discriminated union? &gt; See Ceylon's introduction. I've read it. Looks pretty grim. What am I supposed to be gleaning from that? 
In functional programming you don't necessarily need purity. The point is that you don't need classes to everything, even for Windows Forms. However it is better to separate pure from impure functions. You only need to design the functions in away that they can be combined and composed to build more complicated ones, it is called combinators or combinator library. It is like Unix pipes. Even If you need procedural programming like for loop for performance reasons you can encapsulate it in a function. And finally you can have impure higher order functions like: - List.iter (fun (x: int) -&gt; Console.WriteLine (x)) [1; 2; 3; 4; 5- ; 6] ;; 1 2 3 4 5 6 val it : unit = () &gt; - let sum = ref 0 ;; val sum : int ref = {contents = 0;} &gt; List.iter (fun (x: int) -&gt; sum := !sum + x) [1; 2; 3; 4; 5; 6] ;- ; val it : unit = () &gt; sum ;; val it : int ref = {contents = 21;} &gt; !sum ;; val it : int = 21 &gt; 
Unquote look interesting, definitely something I will follow up. I generally recommend NUnit; there's not really much different between most testing framework, but NUnit is *SO* well supported across the board by tooling, that it just doesn't make sense to use anything else in my opinion. 
I believe MLers use the term "tagged union". As far as I know, ML never had union types.
How do you handle error?
&gt; Algorithms aren't language specific. Implementations are language specific. Algorithms are language agnostic. edit: which is what you said... somehow i missed the "not"
Consider the simplest function that might need to return a `T|U`. T|U iff&lt;T, U&gt;(Boolean cond, T lhs, U rhs) { return if (cond) then lhs else rhs; } The type of the expression `iff(cond(), "hello", "there")` is `String`. Because `Foo` is nominal (henceforth renamed `F`), the return type using sum types is `F&lt;String, String&gt; != String`. This is clearer when you express it as its union type representation, `A&lt;String&gt; | B&lt;String&gt;`. The use of nominal types forces each side of `Foo` to be disjoint, so the return cannot collapse the type down. Though it's simple to work around this case, what if each side has a chance of containing an error? With union types, one would have `T = X|Error` and `U = Y|Error`. The union of the types is `X|Y|Error` With nominal types, this becomes `F&lt;F&lt;X, Error&gt;, F&lt;Y, Error&gt;&gt;`. Merging the two becomes a nontrivial process of unpacking and repacking. With union types you can of course still opt-in to this at the call-site with `iff(cond(), A(...), B(...))` to get the type `A&lt;X|Error&gt;|B&lt;Y|Error&gt; == F&lt;X|Error, Y|Error&gt;`. Ceylon's `reduce` takes advantage of this difference in two ways: 1. The function passed to it is type `Result accumulating(Result|Element partial, Element element)`. This means that the function's output does not have to be the same type as the type of the elements of the array, but if it is the type `Result|Element` collapses to a single type. 2. The function's return value includes `|Absent`, which is a generic parameter decided by the iterable itself. If the iterable is not known to be nonempty, `Absent` is `Null` and so the `reduce` may fail. If the iterable is known to be empty, `Absent` is `Nothing` (the bottom type), so `T|Absent == T` and the failure case is statically guaranteed not to occur. This is why `(1..n).reduce(plus)` is guaranteed to be of type `Integer`, but `sum = (1:n).reduce(plus)` is merely of type `Integer|Null`. Note that subtyping means an iterable known to be empty can be passed to any function requiring an iterable not known to be empty. Hopefully that clarifies things a bit.
&gt; Can you pass a List&lt;int&gt; (using C# generic syntax) to a function taking List&lt;int|string&gt; without complaint, or do you need a cast? It depends on whether `List` has appropriate variance. It's mutable, though, so no - what if you wrote a `string` to that `List&lt;int|string&gt;` and then read it from the original `List&lt;int&gt;`? &gt; you have a function that takes a List&lt;string&gt; and you try to pass in a List&lt;userid&gt;, does it suddenly infer that the function takes a List&lt;string|userid&gt; or does it complain? No, the function asks for a `List&lt;string&gt;` so you need to pass a `List&lt;string&gt;`. If `List` is appropriately variant, you might be able to pass a `List&lt;string|userid&gt;` (which *is* then a `List&lt;string&gt;`), but that will only work if `List` is a sink (aka. things only go *in* and never come out). Note that these questions don't require union types; Scala's class inheritance introduces the same questions, and the same answers. Union types just ensure that you always have a principle type, which makes things predictable: you can *always* take a union, rather than only in special cases, and taking a union always results in a minimal type, rather than some conservative supertype. &gt; This is insanity, how is this good? I don't see the problem with what you wrote. I mean, it's really odd to want to get the union of a set of strings and a set of integers, but it's not Ceylon's fault you tried. If you want a concrete use-case, consider a `Set&lt;Result&gt;` and a `Set&lt;Result|Failure&gt;`. Their union is type `Set&lt;Result|Failure&gt;`. Or consider `Set&lt;A|B|C&gt;` and `Set&lt;A|C|D&gt;`. Their union is `Set&lt;A|B|C|D&gt;`; a use-case might be if two parts of your system work on different components of a model, but a later more general function needs to work on all of the available components. The ability to restrict the function to only those parts that you're interested on at the moment without preventing it from composing with more general ones is useful, as you can then compose the function `CheckUserFacingComponent` with `CheckGeneralComponent` without messy conversions of enums.
Eh, single paradigm languages are meh. If I want FP, I can use the STL's algorithms (which have become very functionally-minded) or I could just link to the [FTL](https://github.com/beark/ftl). That way, I have all the support of everything C++ offers (low-level access, mostly) and the good parts of FP.
Between this post and your other one I think I have a better idea of the situation. I went to google for more but didn't get far as I don't feel like spending 30-45 minutes reading more about type systems. Of your two examples, next time when explaining it I'd avoid the iff example (which is nice, and points at the issue, but is still syntactic sugary) and get right to the Set example. I'm not sure how Set&lt;A|B|C&gt; and Set&lt;A|C|D&gt; would become Set&lt;A|B|C|D&gt; in F#; you'd have to have use options or reflection or have some intermediary type of A|B|C and A|C|D to match on, it'd be quite awkward (TypeShape maybe?). At the same time I'm not sure I've ever run into a situation where I've had to combine types like that. On second look, what I wrote about the union operator only seems like insanity to me because I expect type safety from the operation, as I get in every other typed language I use. If your language freely accepts these type unionizing operations then it's fine, I suppose. I still think it'd be best if they defaulted the | to a type safe operator and had say a UnionAll operator that performed the current behavior.
F# has exceptions and exception handling constructs to go with it. Alternatively, each step could return an object that contained either a value or the error (exception) that was generated, instead, and you could use pattern matching to detect or propagate the error.
https://fsharpforfunandprofit.com/rop/ has a good explanation.
&gt; You can infer which sum type is used, but the type itself must be declared and values must be explicitly wrapped. Aren't OCaml's polymorphic variants a counter example? Indeed, the union types you describe sound like everything is a polymorphic variant except nominally typed and without type inference.
I was worried someone would bring some obscure ML thing along and complicate things... :P &gt; except nominally typed and without type inference. It looks exactly the opposite to me. Polymorphic variants seem to be union types formed exclusively of specific nominal values. You have reductions like [`Int of int | `Float of float] ∪ [`Int of int | `Char of char] == [`Int of int | `Float of float | `Char of char] but you can't remove the name, so you can't have [int | float] ∪ [int | char] == [int | float | char] Both of these are expressible with union types, which seems to be the only real difference. This matters because you can't express something like `T|U iff(cond, T lhs, U rhs)` unless `T` and `U` are both polymorphic variants.
I've had chance to review and I see union type being used a lot for F# at least. I never hear people call them sum types. It may be incorrect in your book but it sounds logical as a type which is a union of cases. https://fsharpforfunandprofit.com/posts/the-option-type/
&gt; Polymorphic variants seem to be union types formed exclusively of specific nominal values Aren't they structural rather than nominal? They are typically inferred from use and the types are not written by hand in the source code but, rather, entirely inferred. &gt; This matters because you can't express something like T|U iff(cond, T lhs, U rhs) unless T and U are both polymorphic variants. Exactly, yes. 
&gt; Aren't they structural rather than nominal? The "branches" are nominal, the type itself is structural.
I'm using ASP.NET with Mono on Linux. You don't need a template - go with self-hosting approach and you'll be fine.
I've been looking at providers for SQL and was wondering how you actually go about creating the database and table schema themselves. One of the features I like best about Rails is the database migration api and the fact that I can collect my changes as migration files and have them output into a schema file. If I'm interested in this feature for F# (specifically as it relates to web apps), what path should I head down? Thanks.
The default `List.sort` uses `compare`, which in turn respects `IComparable` (though strangely enough, not `IComparable&lt;'T&gt;`), so you can use that. Note that to implement `IComparable` on a record you need to add `[&lt;CustomComparison&gt;]` on it, and for consistency `[&lt;CustomEquality&gt;]` too: open System [&lt;CustomComparison; CustomEquality&gt;] type Rank = { Name: string Distance: int } interface IComparable with member this.CompareTo(that) = match that with | :? Rank as that -&gt; compare this.Distance that.Distance | _ -&gt; 1 override this.Equals(that) = match that with | :? Rank as that -&gt; this.Distance = that.Distance | _ -&gt; false override this.GetHashCode() = this.Distance let a = { Name = "a"; Distance = 100 } let b = { Name = "b"; Distance = 50 } List.sort [a; b] // returns [b; a] The other solution, if you don't mind letting the caller decide how things should be sorted, is to use `List.sortBy`: List.sortBy (fun x -&gt; x.Distance) [a; b] // returns [b; a]
I've always been hoping for an F# port of Elm. Looks like my prayers will soon be answered
Read the comments (show all) to the original question in this post for some interesting contrasting opinions: https://stackoverflow.com/questions/3713233/f-type-declaration-possible-ala-haskell . 
This ended working for me perfectly. Thanks!!
I couldn't say since I'm not the author, but it looks like it is only providing functions to maintain application state via the elm-architecture. The model is just passed to react [render-sample-call](https://github.com/fable-compiler/fable-elmish/blob/master/samples/react/todomvc/todomvc.fsx#L338) and the state is updated via another [helper-function](https://github.com/fable-compiler/fable-elmish/blob/master/samples/react/todomvc/todomvc.fsx#L325) 
Looks like it was renamed and underwent some big changes to be more modular: https://github.com/fable-compiler/fable-arch/commit/ec5839f55af8d398d7622b60eb6856298148c64e
Is it possible to write one F# library and have it work as both a normal F# library (meaning, .NET/CLR and all of that) and work with fable (or funscript)? I've been googling for this but I didn't find anyone doing this or talking about the possibility.
I was already testing Suave but wanted to try the standard asp.net but, after looking at the Suave gitbook, I am going with it, that's the type of documentation I like! I will have time to learn asp.net later. I may actually try Suave with .net core... just for the sake of it :)
Thanks for the info!
For your consideration: let isPal (str:string) = let rec impl idxa idxb = idxa &gt;= idxb || (str.[idxa] = str.[idxb] &amp;&amp; impl (idxa + 1) (idxb - 1)) impl 0 (str.Length - 1)
&gt; Your second problem is a classic mistake when learning pattern matching. This is so common that I know of at least 3 stack overflow questions resulting from this confusion. There really should be a better warning for this with an explanation.
Yes. ILSpy C# translation: while (idxa &lt; idxb) { if (str[idxa] != str[idxb]) { return false; } string arg_22_0 = str; int arg_20_0 = idxa + 1; idxb--; idxa = arg_20_0; str = arg_22_0; } return true;
&gt; You have to know the syntax for printfn. This is a hard function to understand and I haven't seen a good explanation of it out there. The following two pages are fairly comprehensive: [Formatted text using printf: Tips and techniques for printing and logging](https://fsharpforfunandprofit.com/posts/printf/) [Core.Printf Module (F#)](https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/core.printf-module-%5Bfsharp%5D)
You don't need to reverse a string in order to check for a palindrome. It is quicker and easier just to compare the characters in place: let isPalindome (s: string) = Seq.forall (fun i -&gt; s.[i] = s.[s.Length-i-1]) {0..s.Length-1} In fact, even that is over-engineered because you only need to check the first `s.Length/2` characters. If you really want to reverse a string then you might want to take unicode escapes into account, in which case you must be careful. There is a thread [here](http://stackoverflow.com/questions/4556160/is-there-more-simple-or-beautiful-way-to-reverse-a-string) about it. &gt; why I'm getting so many errors! Whenever I fix an error I just get another one somewhere else! Thanks :3 (Sorry if this too basic!) I strongly recommend picking up any introductory book on F#. 
I'd love to live in a world where I pick books based on how good looking the authors are! I'll check it out :).
I actually don't care for the functional part of F# at all, it is the syntax that appeals to me. That *is* the main benefit. Dramatically less typing has to happen and it is nicer to look at. I tend to end up with every mutable and using arrays. 
&gt; C# is good enough for most C# is not good enough compared to F#. In C# everything is a object and you are required to always create classes and methods unlike where you can use functions directly. F# has a much better REPL than C# and also the best minds of Microsoft Research are behind F#. F# gives faster development speed (it means less costs) and less time to market. The problem is that most code examples for .NET libraries are in C# but they can adapted quickly to F# generally with less code. &gt; That said, I hated the .NET ecosystem. Get a job at a .NET shop, and you’ve got a 99% guarantee that you’ll have only one choice of technology It might be fear of not find someone else that knows F# if someone leaves. Well, it is good for the competitors who use F#. &gt; This is especially true if Microsoft would have said, “This is our new, dominant language.” the way Apple did with Swift. The .NET documentation of MSDN lack many F# examples while they provide C# and VB examples. 
I agree, it generally *feels* faster, and after I got used to F# it felt a lot faster to read than C# code does. Unfortunately, these sorts of things are really hard to measure even with something like C#. The only convincing measure I've seen is the study that showed a linear correlation between number of bugs and number of lines of code, irrespective of language. Since F# generally requires less code to accomplish the same task, I buy the notion that you might have less bugs if you use F#. However, not all bugs are created equal, and as you said, you could go down a rabbit hole chasing down some performance problem that might not be a concern had you used something else.
My take is a bit different. Why isn't F# used more? * Harmfully assuming devs use the VS ecosystem. * Mono does not suffice (yet) due to poor computational and GC performance. * Non-IDE project management is immature (ex: Forge, but improving fast and I'm glad to have it) * Small communities are hard to grow * Where are my docs? Haskell has haddocks easily available. Python and others have reasonable sets of heredocs. What is the main API to, say, KDTrees? How does one find out? * Where are my packages? Nuget, for example, sort of hides the code. It's hard to fetch and look at the internals of a package. * Where are the developers? It seems a 3 step process to get onto slack is the only way to find a live community. I'm tempted to continue on with bullet points along the lines of "F# is not Haskell" - such as where is my `mappend` or polymorphic `map` - but that's probably more my own issue learning how to write idiomatic code. 
&gt; Development speed is not about the performance it is about the deliver the product faster I know that, but there can be a relationship between the two, as often features that speed development, reduce performance. For some problems, the performance doesn't matter so you get a net win. For other problems, you then have to work around the reduced performance, and lose the productivity gains you hoped to gain with the feature. If you aren't very well aware of these issues, you might find out that you need to work around problems at the end of the development cycle and that can be a disaster. 
&gt; I'm tempted to continue on with bullet points along the lines of "F# is not Haskell" - such as where is my mappend or polymorphic map Your polymorphic map is hard because [CLR doesn't have support for higher-kinded types.](https://fslang.uservoice.com/forums/245727-f-language/suggestions/5664242-simulate-higher-kinded-polymorphism) So while F# could have them anything that used it wouldn't interoperate with the rest of .NET in a sane way. Or at least, that's the claim. I think there are things that could mitigate this, but no one on the F# team has gone there yet.
Performance is important. But before performance it is necessary to model, simulate the problem and try new algorithms and for this exploratory programming F# is good. Let's see Python: It is slow compared to F# and C#, however it can use the high performance numerical library Numpy which is written in C and exposed as a shared library to Python. F# can do the same and reuse the exposed functionality better. 
I would add assuming people are .NET devs. All the documentation assume you are a OOP C# dev that needs to learn the functional paradigm rather than a functional programmer that needs to learn .NET.
Yes, and the community is nice about it too. They will not strike you down for throwing mutable variables around =) 
&gt; I'm optimistic that once .net gains foothold on Linux servers Given that F# has been available on Linux for years thanks to Mono and, yet, still hasn't gained any traction whatsoever outside .NET I am skeptical. 
&gt;I don't find it hard to know. I've been doing this for decades and the evidence is plain as day. Can you construct a problem that is easier to solve in C#? In every domain of knowledge, very smart, highly skilled people at the top of their field are sure of things from personal perception that turn out to be wrong. I'm not saying that you are wrong, I'm just saying personal experience is not a reliable indicator of truth, no matter how smart or experienced the person is. Example problem that is easier in C#: * Sum an array of integers using SIMD. With C# you can just use a for loop, with F# you have to use a while loop, which makes it messier. * iterate over an array from 0 to array.length/2 as fast as possible. With C# you can accomplish this with an unsafe block, with F# I don't know that you can avoid array bounds checks. &gt; Nope. If performance was ever that important I write F# code that generates low-level code. I wouldn't write C, C++ or C# by hand. hmmm... 
&gt; I'm just saying personal experience is not a reliable indicator of truth Well, I disagree. :-) &gt; Sum an array of integers using SIMD SIMD is a solution, not a problem. &gt; iterate over an array Iteration and arrays are solutions, not problems. Keep going though: try to construct a problem that is easier to solve in C#. 
I would love to start an actual business project in F#, but there is no way that I would bring a language into my workplace where I am the only one that would be able to maintain it. I'm getting enough friction as it is with pushing for typescript on the front end.
I've taken a look. The code looks quite nice, but as you suspect those F# core library function like map, fold, filter and such are quite slow. You might be able to get as much as a 10x performance gain by replacing them with imperative solutions. If I was doing a chess engine myself, I'd still start out like this though. DUs are .NET class objects under the hood so avoiding allocating them too much is a good idea too. Replacing them with enums which are struct types would be a good optimization as well. In the next version, F# will get struct DU types, until enums are the way to go and you can pattern match on them as well. A bool array would be good. While bools take [4 bytes](http://stackoverflow.com/questions/294905/why-in-net-system-boolean-takes-4-byte) on the stack, in an array they take only 1. You might want to use [BitVector](https://msdn.microsoft.com/en-us/library/system.collections.specialized.bitvector32) instead. And rather than using an immutable Map, a mutable Dictionary(HashIdentity.Structural) would be much faster unless you are doing immutable updates. Of course an array would be fastest. So basically, getting maximum performance out of F# involves writing the code much like it is C. There is definitely a tradeoff between speed and expressiveness, but in terms of correctness, starting the code out in a F# idiomatic style and gradually optimizing it is the way to go. The thing you've written now will be a pretty good test for the imperative code.
I think the thing that turns Linux people off the most is that Mono has something to do with Microsoft. Now that Xamarin are actually owned by Microsoft I can only imagine that feeling being stronger... 
&gt; I've found that the quickest way to elicit doubt is by mentioning something unprovable like "you'll write less buggy code" Fair enough. I have no idea what elicits doubt but I'm confident F# is vastly more productive than C#. 
For me its mostly the absence of having to use design patterns. Design patterns are just workarounds to bad APIs as far as I'm concerned, trying to simulate a language feature that isn't there.
I like the fact that if one wants to do nothing but OOP he or she can and at the same time switch back to being functional with immutability and additional types without having to switch languages. If none of us ever had seen C# or F# and starting from scratch I think F# would be the easy choice. With the exception of C# support like Entity Framework or having asp/mvc project templates in visual studio I have not needed C# for anything. 
With regards to nuget hiding code, paket allows git dependencies
So when you have patterns like this: |&gt; Array.rev |&gt; Array.map ofFenRank |&gt; Array.collect id |&gt; Array.mapi (fun idx F -&gt; ({ Rank = idx / 10 + 1 File = idx % 10 + 1 }, F)) |&gt; Map.ofArray You can often get a big speed up by doing a single imperative loop, instead of iterating over the array ~5 times and allocating a new array each time and doing lots of function calls each iteration. You can also consider https://github.com/nessos/Streams (also on Nuget) which will provide similar higher order functions but evaluates them lazily so you don't iterate multiple times, and https://github.com/jackmott/SIMDArray which can SIMD accelerate some of the Array operations. In Piece.fs the vectors, you are storing a list of tuples. Tuples are reference types, so you will be pointer hopping * 2 as you traverse that list. Better to use an array of structs or just an array of chars or ints inline. Any place you are using List, consider using an array instead, or ResizeArray if you need to be able to add items on the go. Recursion usually performs fine as long as it is tail recursion, but there is sometimes a small improvement when you change it to a loop. BitVectors can be good for reducing memory but are usually hard to get a speed improvement from them, depending on how you are using them. So be sure to measure if you try those. You can sometimes roll your own bit-vector approach with lots of bit masks but this gets very ugly fast. Of course with all of this advice, test and measure everything to be sure a change is actually beneficial, somethings things are not intuitive. There is a great tool for benchmarking here: https://github.com/PerfDotNet/BenchmarkDotNet (also no Nuget) 
To add: "total functional programming" separates functional *programs* from object-oriented *coprograms*. You can't go very far with only one or the other.
Mono has had historical performance and stability problems, to the point where few people will trust it. If it hadn't been attached to a successful product like .NET, it would have been dead in the water.
Yeah. I've planed two posts ahead, and my third post on the series will cover converting to/from JSON which I am really happy with my solution of. So look forward to that :P
I think you're missing the point of functional programming. Most of the features you mention are not actually discouraged and have better functional alternatives. 
Well yes, just about every language has higher order functions now. More to the point, F# has optimised tail calls. However, I still don't feel that their presence justifies including half-baked imperative constructs. I think we should either have break or not have loops.
You mean the ability to write them? There isn't the basic uniform HO building blocks on all collections e.g. map, reduce, fold, scan in C# for example. I'm not sure why break wasn't put in. Maybe you do need loops for perf sometimes but can work around break. Or maybe it was harder to put in extra branching. Or maybe an incentive to get away from telling the machine how instead of what to do.
Agreed
Great post. Also the typography of this site is beautiful.
&gt; I think the thing that turns Linux people off the most is that Mono has something to do with Microsoft. Queue endless bleating about microsoft still trying to embrace, extend, extinguish. MS' latest change of direction puts those concerns to rest IMHO, but some people seem to have a hard time accepting change.
They have F# for dummies. Even the F# for C# devs don't assume you know much other than basic data types and your way around VS. 
I know this is not very constructive but you should seriously consider 10 mins of looking into .NET/C# (the .NET core website has a very good try-C#-style tutorial). Knowing .NET libraries is big advantage. 
I've not done much with F# yet beyond coding challenges, but after growing beyond a few files In a solution one thing I'm rather disappointed with is the lack of folders in Visual Studio. What the hell is up with that!? Are F# people generally not using Visual Studio to build projects or are the just dealing with having 10s or 100s of files all sat in one folder?
You tend to have multiple types and modules in each file. Its not like C# where it is one file per interface etc. That plus code is much shorter means you only have 10-30 files per project.
That's a standard answer: "you aren't from the same camp". I wish you are more constructive.
Thanks, I can see how that could work better, but it still feels a little unpolished in comparison to C# when we're told that F# is a "first class citizen" of Visual Studio. I struggle to imagine what a large F# solution with many assets (.js, .css), views, code files etc would look like. Maybe a C# solution with supporting F# code/projects?
Here's my take, for what it's worth. I agree that "you don't get FP" is not a helpful response. On the other hand, most programming languages have a certain style or philosophy associated with them. Any language makes some things easy and other things hard. When you flow in the same direction as the language, writing code tends to be smooth and straightforward, but when you go against the grain of the language, things become painful. For example, in Lisp, doing recursion is easy, but doing for-loops with breaks is hard, so the "natural" style for Lisp is to use recursion. On the other hand, in C, for-loops with breaks is easy, so that is the natural style in C. F# is opinionated that way too. You can use mutable values, but it looks ugly. You can break out of loops (using recursion) but it is awkward. And so on. When I am learning a new language, I find that adapting to the natural style of the language is one of the most important things I have to do. Initially, I often find everything hard and painful, and ask "what idiots designed it this way", but after a while, when I have figured out how the language likes to be used, everything becomes much simpler. So, I encourage you to stick with F#, and perhaps in a year or so, you might find that you no longer feel so strongly about some of those issues you raised. As to some of the specific language warts, much of that comes from F# being based on OCaml, but also being compatible with C# (the two syntaxes for generics), or being on the bleeding edge of .NET (tuples as reference types before they were added to the CLR). Perhaps with hindsight some of those decisions would be different, but every language that has been around for a while (over 11 years for F#) has annoyances like this -- C# has plenty of them too! If you are a language designer, one way to avoid issues in the first place is to delay adding new language features, because if you make a mistake: tough -- you now have to support that feature forever. That's why things like break and do-while are unlikely to be added, I think. There are usable (if clumsy) workarounds already. 
I'm not sure what you're asking for. You'd like examples of functional alternatives to some imperative constructs?
Just days after you posted this, openTK released version 2.0 https://github.com/opentk/opentk It seems to be quite a nice wrapper over opengl, I am playing with it right now: https://github.com/jackmott/galaxy2/tree/master/client 
Well, pattern matching for a start. And you don't need loops when you're using chains of functions, see Seq (for example Seq.map, there's tons of others!). Read 'Thinking Functionally' by 'F# for fun and profit'.
Have you read through the whole of https://fsharpforfunandprofit.com? Have you read the post about file order? The blessing reply gave you a link to the post. Some time has to be put in to understand the benefits. It can't be just passed on in a simple reply. This is probably why its been so difficult to catch on while at the same time people who have made the jump are so certain.
Check out the many large oss projects on github. Assets such as this are stored in separate directories.
Fsharp.tv has a course that assumes no prior knowledge of dotnet and it is free.
While it's always good to know how the underlying parts work, it's not necessary to go through react/fable-react stuff. I've added some more samples to the fable-elmish/react-native samples showing how to do some basic stuff (building blocks for creating larger apps). So yeah, feel free to just jump in and use the Elm docs for patterns. That's what I did. Examples can be found here: https://github.com/fable-compiler/fable-elmish/tree/master/samples/react-native and a few here: https://github.com/fable-compiler/fable-elmish/pull/5
I wish I had a bunch of sock-puppet accounts to give you the upvotes you deserve :) Thanks for the solid info :D
Thanks a lot!
You're absolutely right. I've had that extension installed in the past, but I wasn't doing anything serious with F# and I wasn't making use of the features of the power pack so I uninstalled it. I will definitely give this another whirl. I first noticed the issue when I'd written a project in MonoDevelop that would not load in Visual Studio due to the folders.
This is great! I was thinking about a project that required text classification. Can't wait to try it out! Thanks for sharing!
 let n = 10 seq { 1 .. n } |&gt; Seq.sum or let rec sum n = if n &lt;= 0 then 0 else n + sum (n - 1) let n = 10 sum n
 let mutable i = 1 let mutable sum = 0 while i &lt;= n do sum &lt;- sum + i i &lt;- i+1 it's bad style, but you specifically asked for a while loop.
Interestingly, if you want to sum the numbers the most efficient way possible, a while loop is necessary. Guess why! 
Actually, that's quite surprising. I'm rather sure that both a ``for in`` and a ``for to`` loop should be compiled exactly the same way. 
I do this on OS X and mono using cron. You can also do this on Windows and schedule a task to run periodically. https://technet.microsoft.com/en-us/library/cc748993(v=ws.11).aspx Cron tutorials abound if you're on OS X or Linux. If you compile the .fs to a .exe make sure you have a main and an entrypoint defined. Then it'll run as A typical process. Hope that gets you started. 
Yeah, that's what I settled on (cron).
Here's the implementation I came up with: let grouper l = let rec oneChunkAndRest acc = function | a :: (b :: _ as r) when a &gt; b -&gt; List.rev (a :: acc), Some r | [a; b] -&gt; List.rev (b :: a :: acc), None | a :: r -&gt; oneChunkAndRest (a :: acc) r | ([] | [_]) as l -&gt; l, None let rec gatherChunks acc l = match oneChunkAndRest [] l with | l, None -&gt; List.rev (l :: acc) | l, Some l' -&gt; gatherChunks (l :: acc) l' gatherChunks [] l When testing with `List.init 10000000 (fun i -&gt; i % 10)` as input, it turns out faster and less GC intensive than yours, though I'm not quite sure exactly why. I think the reduced GC is because I don't `rev` the whole input list but only the chunks and the final result, both of which are shorter, so I need less memory at once. Edit: just realized that the whole `gatherChunks` part can be replaced with `Some l |&gt; List.unfold (Option.map (oneChunkAndRest []))`.
Here is my take on it. Like the function posted by Nhowka, it uses two list. The only difference is the use of List.pairwise to make pairs of each element in the list and its predecessor - in my opinion it makes patternmatching, some what more readable. let part ls = let rec part' acc temp = function | (x,y)::[] -&gt; (y :: x :: temp |&gt; List.rev)::acc | (x,y)::xs when x &lt; y-&gt; part' acc (x::temp) xs | (x,y)::xs -&gt; part' ((x :: temp |&gt; List.rev)::acc) [] xs | [] -&gt; temp::acc part' [] [] (List.pairwise ls) |&gt; List.rev It appears that this function runs a little bit slower than the function posted by TarMil: (this) Real: 00:00:04.638, CPU: 00:00:04.640, GC gen0: 146, gen1: 103, gen2: 1 vs. (Tarmills) Real: 00:00:03.064, CPU: 00:00:03.078, GC gen0: 100, gen1: 63, gen2: 1
Can you test this one? let grouper n = let rec inner l inCont outCont = function |[] -&gt; outCont ((inCont [l])::[]) |a::b when a &gt;= l -&gt; inner a (fun x -&gt; inCont (l::x)) outCont b |a::b -&gt; inner a id (fun x -&gt; outCont((inCont (l::[]))::x)) b match n with |[] -&gt; [[]] |l::r -&gt; inner l id id r Seems that it's faster than my previous function, but I'm not sure how expensive the closures are. I wouldn't expect it to be cheaper than rev'ing memorywise, but at least it's fast. Pity it lost most of its readability.
Sweet script! But I can't wrap my mind to see what triggered the gen2 collection. Luckily the performance hit wasn't that bad for the gain in readability. The F# lib is really awesome.
Would it be better to sleep short amounts until the desired time, rather than all at once? 
actually i can't have another parameter. My function should follow this structure : int list -&gt; int list
You could always pass tail.rev back into the function. It'd make it cleaner but it's probably not very efficient Edit: seems like someone already posted that idea
You'd take one element from each, so yes it would (unless you stop in the middle). let l = (original list) let r = List.rev l let rec combine = function | [],_| _,[] -&gt; [] | h1:t1,h2:t2 -&gt; h1::h2::(combine t1,t2) let cl = combine l,r cl will be twice le length of l and/or r. Note, I typed this on my phone in a bar, so it may veer into OCaml and also have bugs. Deal with it. Note also, this is still pretty inneficient, but something, something, premature optimization and all that jazz. 
Ok I see what you are saying now. I don't think you'd want to start with reversing the list because that would essentially be creating a new list, the reversed list, in order to create a third list, which is the desired output. It just doesn't seem necessary to recreate a list if it's only the reverse of a list you've already stored. What I thought you were talking about is passing the reverse of that list (minus the head) back into the function. So [1;2;3;4;5] loses the 1 and becomes [5;4;3;2]. Eventually you'll get the list [1;5;2;4;3] then to get your output you'd only have to concatenate it with reverse of the output. [1;5;2;4;3;3;4;2;5;1]. 
&gt; It just doesn't seem necessary to recreate a list if it's only the reverse of a list you've already stored. It's a space/time tradeoff. Reversing and copying the list keeps you from having to reverse it (or it's tail) multiple times. It's the difference between an O(n^(2)) routine v. an O(n) routine.
You will probably not like it, but that's kind of problem where the freedom of paradigm makes F# a good choice. let shuffle n = let input = n |&gt; List.toArray let mutable front = 0 let mutable back = input.Length-1 [ while front &lt; back do yield input.[front] yield input.[back] front &lt;- front + 1 back &lt;- back - 1 if front = back then yield input.[back] ] It's still a pure function, because every side effect is constrained: the same input will always yield the same output. Also, even with the change to array it's a ('a list -&gt; 'a list) function. If you wanted a "I want to grasp a better list manipulation knowledge by solving this problem" this won't help as much, but I hope it helped if the thought was "That problem is interesting, how F# can help me to solve it?".
Ah that makes sense. I'm assuming by removing the last index of the array you're basically doing just that, which is why there isn't a List function to do that. It just feels a little awkward with the immutable data principle. I guess it could still be considered immutable outside the scope of the "shuffle" function.
Edit: Re-reading the OPs question, i can see that my solution does not solve the problem, so please ignore this. I am assuming this is for some kind of assignment or course, so a little explanation might be in order. F# list are non-mutable data structures, so we can't simply swap values like one could do had we used a mutable data structure like an array, e.g. let arr1 = Array.ofList [1..2] let tmp = arr1.[1] arr1.[1] &lt;- arr1.[Array.length arr1 - 1] arr1.[Array.length arr1 - 1] &lt;- tmp Instead it becomes a bit more involved. We want to extract the head of the initial list, append the last element, and then all but the last element. Here is my take on a solution: let reshufle (xs : int list) = let rec allButLast = function | [_] | [] -&gt; [] | x::xs -&gt; x :: allButLast xs match xs with | [x] -&gt; [x;x] | x::xs -&gt; let lastElement = List.rev xs |&gt; List.head x::lastElement::(allButLast xs) | [] -&gt; [] Results: &gt; reshufle [] val it : int list = [] &gt; reshufle [1] val it : int list = [1; 1] &gt; reshufle [1..2] val it : int list = [1; 2] &gt; reshufle [1..3] val it : int list = [1; 3; 2] &gt; reshufle [1..5] val it : int list = [1; 5; 2; 3; 4] &gt; Note that this solution has to recurse the entire length of the list (O(N)), instead of the O(1) constant operation when using an array. So the take away could be that you do not want to use the list data structure when performing this kind of swap operation.
Right now the function is generic: &gt; val part : ls:'a list -&gt; 'a list list when 'a : comparison You can constrain the type to int as so: let part ls : int list list =
Is it bad to alias a modules external dependencies at the top of the module? I have been in the habit of doing that so the stuff I'm using within the module is not quite so hidden. This could be a place to "fix" some of the uglier .net functions. But that is also littering all your modules with similar lines.
This applies to e2e testing overall, not just Canopy. We are adding string attributes in dom, like data-t-rel="dlg-ok-btn". This is more frugal than 'wasting' a full attribute name everywhere
For the past year or so, on and off I've been working on a deep learning library and am currently doing a fourth rewrite. As I learn new tricks, my focus has been gradually on improving its expressiveness. A year ago, when I first started learning machine learning I had great difficulty writing neural nets by hand, but with the things I know now it has become much easier. I still have a while to go before it is done, but I am 3.3k LOC in already. My aim is to make it a combinator library in the vein of Fparsec so as to make expressing various kinds of recurrent nets easy for the sake of reinforcement learning, and I myself plan to use it to raid the online gaming scenes starting with poker once it is done. Currently I am breaking the API every few days, but hopefully by the end of the year I'll release it on Nuget. I'll definitely do it eventually. The long term plan would be to study the making of compilers in the depth and evolve the library into its own language capable of compiling code for neuromorphic chips. Those are still in the lab though and I am not sure how they will compare to future GPUs with non-volatile memory, but I am decently sure there will be a need for new languages for such devices. If you have ever programmed in Cuda you should know how excruciating it is.
I am building an AI and management tools for a market research company to improve the productivity of our analysts.
OOC: I vote yes, we should be doing this monthly! Also this sub needs some css.
I am working on a GUI to download Miencraft Modpacks from Curseforge. I'm using Eto Forms to keep it cross platform compatible, and am using this project to learn about the actor model for state management https://bitbucket.org/kaeedo/cursed/src
That could be self correcting so that inaccuracies don't add up over time.
The language part will be very easy. The .NET will be very hard because everything assume you are a .NET programmer who needs to learn functional programming rather than a functional programmer that needs to learn .NET so .NET fluency is assumed pretty much everywhere.
I'm kinda stuck at the toolchain part. I read a full book on the language and it's rather easy to get, it's OCaml with .NET objects rather than OCaml ones. Easy peasy. I can do anything I want at the REPL. But I'm struggling hard to find what's the equivalent of `lein new` from Clojure that setups a nice best practice scaffold. I did find F# scaffold but it seems to only make libraries, not app. The documentation is not helpful. I'm googling a lot but all the documentation for noobs everywhere tells me not to be afraid of functional programming and tries to give me a functional tutorial...
Much of the F# documentation and books assumes you are running Visual Studio on Windows and may already know C# or .NET. Which makes it a bit more challenging depending on your circumstances.
&gt; Technically leiningen isn't part of clojure it's just the defacto standard project tool, but that's neither here nor there. It's a rather moot point given that there's no alternative. &gt; But this is MUCH less mature than using F# in visual studio, which imo currently provides the best experience if you can get into the IDE mindset (VSVim is also one of the best Vimitations i've ever seen). I've yet to find out how to generate a proper project skeleton with Visual Studio where I get paket, fake, tests, and everything setup. And I'd rather be able to code on Linux too.
What was the main motivation to move from Python to .NET?
These are internal tools, but as a whole the whole company is now focused on .NET, so I wanted to make utilities that don't require a Python install. Plus I'm intrigued by F#. 
This isn't really something I'm "working" on.. but I'm playing around with Fable and trying to get it working in a Phoenix/Elixir server application. I've got it kind of working, but there are a couple issues still: * When I Ctrl-C the Phoenix server, it kills node/webpack but there's still this Mono/Fable compiler process left running and I have to manually `ps -aux` to find it and kill the process. * React hot loading isn't working yet. This is probably that something in my webpack setup is not configured correctly. I like the idea of Fable, but every time I touch Webpack or Node or React I get kind of depressed because I feel like a noob again. They rewrite and break things at a *blistering* pace in that community.
Enjoying my second year as a freelance developer specializing in functional programming/F#. Currently working on soft-real-time reporting solutions in the finance sector. Taming gnarly third-party systems with types and agents.
I Wonder if [FParsec](http://www.quanttec.com/fparsec/about/fparsec-vs-alternatives.html) might be of help?
I finally made it on sergeys blog i can now die happy
It really smells like a job for Perl! But yeah I think you could really quickly build up a nice set of tools for doing this in F#, I would stick with it. Option types etc will come in handy. 
btw, this Connect Four is really cool. What is the license on all of this? I don't see it in the repo.
Thanks! I guess this would be my "what I'm working on", though I haven't had much time to look at it lately. I just added a license (MIT). I'm curious since I don't often think about licensing - does that make a difference for you?
I just want to be mindful of licenses and stuff in general to be respectful. If something doesn't have a license then I assume I can't use it.
Thanks, that was useful. So I think the answer is "Yes, it can be done technically, but no, we don't recommend it for canonical F#."
Python was my preference due to readability. I might have to maintain or re-use code from several years ago. Or write some quick scripts for profiling a single field in large file.
I have some real world public data sources which I'm going to test against, so that might be possible. Note: I'm approaching this from the viewpoint of a ETL data janitor scripting dude, not a computer scientist parser/compiler/DSL programmer. 
[Classes for the Masses (Extended Abstract)](https://c10109cf-a-62cb3a1a-s-sites.googlegroups.com/site/mlworkshoppe/2016-7.pdf) [Experimental Implementation &amp; Samples ](https://github.com/CaptainHayashi/visualfsharp/tree/hackathon-vs/examples) [Conceptual Overview of F# TypeClasses](https://github.com/CaptainHayashi/visualfsharp/blob/hackathon-vs/examples/fsconcepts.md) 
Is there a case study of a problem where it would be useful in practice to have this language feature? Hmm, just reading the paper they cite it walks through just one ill-specified example (writing a graph library) in many languages. In the case of OCaml (which has the best graph library I've ever seen: ocamlgraph) they choose to use a completely different approach to the proven module-based solution and, instead, opt to use object orientation (which is the wrong tool for the job) and then they conclude that Haskell is better. I can only assume that they not only didn't bother seeking expert advice but hadn't even done a [basic literature review](https://www.lri.fr/~filliatr/ftp/publis/ocamlgraph-tfp-8.pdf). 
Writing generic functions over numeric types is one of the most basic use cases. They'd be useful for defining functions that abstract over the module functions of the seq, array, list, and other collections. You can define string manipulation functions that work just as well on char arrays. If you want to investigate the kinds of abstractions that can be constructed with type classes check out the ~~[Typeclassopedia](http://www.cs.tufts.edu/comp/150FP/archive/brent-yorgey/tc.pdf)~~ [Typeclassopedia](https://wiki.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf) _(I meant to link to this doc in the first place)_ [Diagrams](http://projects.haskell.org/diagrams/gallery.html) [(repos)](https://github.com/diagrams) is one my favorite haskell projects and it makes extensive use of typeclasses 
&gt; Writing generic functions over numeric types is one of the most basic use cases. F# already has generic functions over numeric types so you can do wonderful things like conflate division of pseudo-real numbers (`/` for `float`) with Euclidean quotient (`/` for `int`) and pretend that `(a+b)+c=a+(b+c)` when that is actually true for `int` but not for `float`. &gt; They'd be useful for defining functions that abstract over the module functions of the seq, array, list, and other collections. Can you give a concrete practical example? &gt; You can define string manipulation functions that work just as well on char arrays. I don't think I've ever used char arrays instead of strings. &gt; If you want to investigate the kinds of abstractions that can be constructed with type classes check out the Typeclassopedia They look like extremely abstruse academic curiosities. 
*questions at end of talk* &gt; **Q: Have you looked at typeclasses like Read that are polymophic on their return type, and how that intracts with F# type inference?** &gt; Well I think you'll get the same problem—the "read after show" problem. &gt; I think F# will.. i'm not what they implemented for the hackathon. Turns out F# already has a contstraint solver, so they just added a bit more constraint solving for typeclasses. &gt; I think it will just say that it wasn't able to resolve that dictionary. &gt; **Q: (inaudible) .. the name for the type? Because I have the impression you can have multiple different types implemented.** &gt; Well, in Haskell you can't, and to be honest I don't actually care that much either way. &gt; I'm more interested in getting a mechanism for implementing the actual dictionary translation without necessarily forcing a coherent type / coherent system on the users. &gt; I think the language can probably choose to do whatever they want, as long as it's sound.. as long as the compiler is forced to produce evidence nothing will go wrong at runtime. &gt; But in practice, in F#, you could probably just do what haskell does, but in C# type inference just isn't good enough in many cases. &gt; For instance, if the dictionary is determined by the return type, even in ordinary type inference if the argument types of your method don't determine the types of the, ah, the type parameters.. values/instantiations for the type parameters, then c# will just give up and force you to use an explicit instantiation. And in that case, you want to have a name so you can reference it.
Numbers are a simple case since those types are often atomic. In that case the inference mechanism will simply pick the float aritmetic operations module for floats, and the int arithmetic operations module for ints. Thus as a special case you get overloading for generic numeric operations. The way F# does equality and hashing is very much like a baked in type class that doesn't even work very well for user defined types. It is clearly a terrible idea to bake every new such feature into the compiler.
[The Diagrams Manual](http://projects.haskell.org/diagrams/doc/manual.html#understanding-diagrams-types) lists all of the type classes in the library and how they're used to organize and transform the contents of the affine space.
&gt; Numbers are a simple case since those types are often atomic. In that case the inference mechanism will simply pick the float aritmetic operations module for floats, and the int arithmetic operations module for ints. Thus as a special case you get overloading for generic numeric operations. That is a perfect example of factoring out commonality that isn't there. Many `int` and `float` operators have different properties (e.g. `+0` is a no-op in `int` but not `float` and `+` is associative for `int` but not `float` and so on). &gt; The way F# does equality and hashing is very much like a baked in type class that doesn't even work very well for user defined types. It is clearly a terrible idea to bake every new such feature into the compiler. A "terrible" idea that works better in practice IME. Whenever I hear that argument it reminds of [this paper](https://github.com/wh5a/Algorithm-W-Step-By-Step) I read a few years back and tried to translate into ML. Thanks to type classes, the Haskell code there is unnecessarily obfuscated. I can only imagine the trouble such a language feature would cause in industry where every junior developer would want to work them in because they see commonality to factor out even when it isn't there. But I'm a reasonable person so I'm still looking for that elusive practical application of type classes. 
[Slides](https://neoeinstein.github.io/hopac-concurrency-with-synchronous-messaging/#/) [Hopac Repo](https://github.com/Hopac/Hopac) [Programming in Hopac](https://github.com/Hopac/Hopac/blob/master/Docs/Programming.md) 
The way I see it, typeclasses are kind of like souped up, structural interfaces meaning unlike regular interfaces they do not lug around their virtual table. Work on them goes hand in hand with the work on structural DUs and record types. They have the potential to make code a lot more efficient even in C# by eliminating virtual calls where interfaces would be used today. Now F# does not really need them as it has quite powerful structural typing. On the other hand, the only downside to actually having typeclasses in F# would be that they would put more pressure on the constraint solver. This is actually a problem in Haskell, as on a project I've been investigating, the typechecker for the Atom editor regularly hangs and runs out of memory. That was a few months ago, now they've fixed it so it just keeps running forever. Well, the solution in either case is to do more work on the constraint solver. I kind of do not want F# to become a language where every feature under the sun gets added like Haskell and Scala, but I think typeclasses (and in the future HKTs) would be acceptable. Edit: It turns out, I had underestimated what typeclasses are really [capable of](http://okmij.org/ftp/tagless-final/course/lecture.pdf). I did not think they would allow one to do everything that is possible with [GADTs](https://vimeo.com/12208838) except without having to create intermediate structures and even going as far as allowing emulation of nested pattern matching using contexts. Edit2: In turn, the finally tagless style (from the first link) can be imitated in OOP languages using the [object algebras](https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/) pattern.
Enterprise dev example: asynchronously retrieve a value from a database and then transform the resulting value and then combine it with other similarly retrieved values into some larger structure while validating the values and resulting structure and then asynchronously writing the structure somewhere. each step along the way parameterised by configurable values. i would like to compose these various effects (async, result, reader, exception) as needed within applicative and monadic computations so that the resulting computations can also be composed without me having to think to hard about all that plumbing. The Entity Framework didn't do it for me. In F# i ended up writing a workflow for every combination of effects, duplicating code. Maybe this is a better approach?: https://github.com/palladin/Higher ... but some kind of composition of effects would be nice (and hkt would help). With all those effects canned I can just concentrate on the "business logic".
I don't want to have to write things twice for floats and ints, but if you do want that then type classes support that too. Just define one type class for exact math and one for inexact math, or whatever split you may like. That float equality defined in the standard has warts is a criticism of floats, not of type classes. Type classes enable you to deal with that in any way you want. Let's look at how equality is done in F#. The F# type system has a constraint `'T : equality`. When you define a custom data type you can implement your own equality by putting a `[&lt;CustomEquality&gt;]` attribute on the type and defining an Equals method. This is like defining a type class instance `Eq t` for that type. For a generic type this is not enough, since you often can only support equality for `F&lt;T&gt;` when `T` supports equality. For that you have an `[&lt;EqualityConditionalOn&gt;]'T` attribute. This is like defining a type class instance `Eq t =&gt; Eq (F t)`. In F# equality must be added to the type when defining it. This is perhaps not such a big deal with equality, but it's not nice for other things like pretty printing. &gt; Assuming you're referring to higher-order modules, I'm not a fan. Alright, I got that impression because you praised ocamlgraph above. &gt; I have never seen a compelling example where type classes are useful. I gave these examples: equality, comparison, hashing, pretty printing (text, html, ui widget, etc.), serialisation/deserialisation (binary, json, xml, relational db, etc.), numbers. Some other examples are writing code polymorphic over any iterable type (compare with separate List and Seq modules in F#), or code polymorphic over the type of computation expression, generic linear time sorting &amp; generic tries, random generation and exhaustive enumeration of elements of types, quickcheck, generic unification, type reflection, and of course the Haskell category theory zoo, or math related things like groups, rings, etc.
&gt; I don't want to have to write things twice for floats and ints What things do you write twice for ints and floats in practice? &gt; When you define a custom data type you can implement your own equality by putting a [&lt;CustomEquality&gt;] attribute on the type and defining an Equals method That is very rare. To quantify, of the 395,329 lines of F# code I have on this machine only 68 use `CustomEquality`. That's 0.02% of LOC! &gt; For that you have an [&lt;EqualityConditionalOn&gt;]'T attribute That is practically unheard of. In 9 years of writing F# professionally I have never used it in production myself nor seen anyone else (outside the stdlib) use it. &gt; In F# equality must be added to the type when defining it. In the vast majority of cases the autogenerated structural equality is what you want. In a minority of cases you want a non-default equality function you pass a custom function or object in. The F# solution is the best I've seen. &gt; This is perhaps not such a big deal with equality, but it's not nice for other things like pretty printing. Agreed. I use reflection for pretty printing and serialization so we should compare type classes to reflection in that context. &gt; Some other examples are writing code polymorphic over any iterable type (compare with separate List and Seq modules in F#) Another of my pet peeves where I often see people factoring out commonality that isn't there. We have all these lovely data structures (arrays, lists, sets, maps, heaps, etc.) that each have their own algorithmic advantages and are suitable for different things and this idea is to abstract away this (the only) advantage and fail to take advantage of the differences. &gt; code polymorphic over the type of computation expression Yes, that's perhaps the best example I've seen so far. You wouldn't have to use a bespoke `asyncseq` for example. Great except I've never used or wanted `asyncseq`. I only know about it because I read a blog post by Tomas many years ago and thought it was academically interesting. &gt; generic linear time sorting Can you elaborate on that? &gt; generic tries I already have generic tries. What do you mean? &gt; random generation and exhaustive enumeration of elements of types Use reflection. &gt; quickcheck Like FsCheck? Never used it. &gt; generic unification What is that good for? &gt; type reflection Use reflection. &gt; and of course the Haskell category theory zoo, or math related things like groups, rings, etc. Category theory, groups and rings are really abstruse really academic examples. 
Google can help you find those things, if you are interested. If you're not convinced of the usefulness of type classes, that's fine. There are plenty of Go programmers not convinced of the usefulness of generics, and many C programmers not convinced of the usefulness of closures, C++ programmers not convinced of the usefulness of pattern matching or GC, and so forth. They also tend to think that their workarounds are adequate. The world moves on regardless.
&gt; Google can help you find those things, if you are interested. Google refers me to many obscure academic papers on the subjects you've listed but still no case studies of practically useful applications. &gt; If you're not convinced of the usefulness of type classes, that's fine. I've never heard of a single practically useful example of type classes but I've studied Haskell code that had blatantly suffered due to the use of type classes. &gt; There are plenty of Go programmers not convinced of the usefulness of generics, and many C programmers not convinced of the usefulness of closures, C++ programmers not convinced of the usefulness of pattern matching or GC, and so forth. They also tend to think that their workarounds are adequate. The world moves on regardless. So you want all features in all languages. Conversely, there are plenty of PL researchers convinced of the usefulness of every feature in Haskell and, yet, when pushed cannot cite a single practical application or draw a fair comparison or explain why Haskell is such a monumental failure despite all of these amazing advantages. 
&gt; Well, I gave you a list of practical applications These things: * Generic linear time sorting * Generic tries * Random generation and exhaustive enumeration of elements of types * Generic unification * Type reflection * Haskell category theory zoo * Groups * Rings Are all solutions looking for problems to solve. None of these are practical applications. Furthermore, most are incredibly obscure: just think about the minute amount of the world's code that uses generic tries and, therefore, what a vanishingly small advantage it would be to layer abstractions over them. Quickcheck is the closest to a valid example. The practical application is testing. This is a solved problem in F# and the solution I currently use is, again, reflection. The effort I expend solving this problem is tiny so the potential advantage of having another way to solve this problem is, therefore, also tiny. &gt; These workarounds are more complex and less powerful than type classes In what sense is reflection less powerful than type classes, for example? Have you actually done or seen a fair comparison of two solutions written using these different approaches? &gt; even though there is obvious commonality between List and Seq Let's just examine that for a moment. The key characteristics of `list` are: * Core operations: head and tail. * O(1) prepend and decapitate. * The potential to share tails. * Pure. * Classically designed to be used for very short and often empty collections or for easy backtracking of state (in logic programs). * Ideal for things like the arguments to functions in a metaprogram (a classic ML problem) but this is a non-problem for most F# programs. * Very bad for things like the lines of a file (ubiquitous in real OCaml and F# code). In contrast, the characteristics of `seq` are: * Core operations: start enumerating, `MoveNext` and stop enumerating (`Dispose`). * Designed to be impure with start and stop enumerating acting entirely by way of uncontrolled side effects (like opening and closing database connections). * Designed to be used for implicit sequence that are often very long or even infinite. * Ideal for things like database queries (definitely used in F#). * Incurs massive performance overheads when as an abstraction for enumerable collections (much more common in real F# code than database queries). Is there obvious commonality between `list` and `seq`? From a purely academic perspective, yes, because they are both enumerable. But in terms of practical applications there should be almost no overlap. In fact, the only reason there is an overlap in practice is that both collections are abused for things they are actually bad at (`list` for long lists and `seq` as a very inefficient abstraction over enumerable collections). So, while what you say is technically true I think you're barking up the wrong tree. My belief is that most of the people most of the time would be better off with a collection as readily available (i.e. with literals and patterns) as `list` but a jack-of-all-trades and master-of-none collection that provides as many operations in `log` time as possible. This would replace almost all practical uses of both `list` and `seq`, simplify the core of the language and make many programs more efficient for free. And when you need performance you drop to impure collections. 
I agree that there are differences between list and seq, that is precisely the point: factoring out a common *interface* but different *implementation*. I also agree that a jack-of-all trades collection is a better default than list, but as you note it doesn't replace all the uses of seq or array or others. One of the advantages of factoring out the common interface, besides avoiding code duplication and an explosion in the number of different function names, is that this makes it easy to switch to a different underlying data structure. &gt; In what sense is reflection less powerful than type classes, for example? With reflection you lose type checking. So it is more powerful in the same sense that F#'s type system is more powerful than Python's. With reflection it is also more difficult, but not impossible, to put in custom implementations for some types. It is also slower. And the code looks horrible. &gt; These things: [...] Are all solutions looking for problems to solve. You include reflection in that list while you advocate using reflection. Random &amp; exhaustive enumeration is used within quickcheck, which you included as useful. I've found the mathematical abstractions to be occasionally useful, like lattices for dataflow analysis, or a monoid for accumulating results. These may be small abstractions, but type classes make it very light weight to define and use. It's like the Option type: the advantage of this abstraction may be small, but it's still worth having *if* the language makes it lightweight enough to define and use. A good implementation of linear time sorting could be nice. I've found radix sort to be consistently faster than comparison based sorts. Of course such a thing can only work if the abstraction is zero overhead. Don't get me wrong, each of these individually don't make type classes worth it. If the only generic thing you ever wanted was equality you might as well build it into the compiler, but it's not. The alternative of four ad-hoc workarounds is far worse. I know that you find Haskell a very academically oriented language with many fatal design mistakes in both the language and the libraries, and I agree with you on most of that, but type classes are in my opinion THE useful innovation coming out of Haskell.
&gt; One of the advantages of factoring out the common interface, besides avoiding code duplication and an explosion in the number of different function names, is that this makes it easy to switch to a different underlying data structure. I agree to some extent but: 1. When I switch from one data structure to another I tend to do it in order to leverage the differences. However, I'm sure at least some code will still be indifferent. 2. Higher-order modules handle this well (see Okasaki). I thought type classes were acknowledged to be worse at this. &gt; With reflection you lose type checking. In production code I write generic curried functions that inspect their own type parameters in order to create a functions that consume values of that type. If there is a type error then it is caught immediately at run-time when the appropriate function is generated, not when that function is invoked. So although that is technically not compile time it is a non-problem in practice. &gt; So it is more powerful in the same sense that F#'s type system is more powerful than Python's. With reflection it is also more difficult, but not impossible, to put in custom implementations for some types. I just used a `Dictionary&lt;System.Type, _&gt;` of functions last time I did that. And I haven't done that since because I never need the extensibility in practice. &gt; It is also slower. Ok. Serialization code is often a performance bottleneck for me so faster would be good. On the other hand, OCaml is already 10x faster than F# here... &gt; And the code looks horrible. Certainly not ideal, granted. And my projects seem to devote more and more code to serialization these days so better code would be welcome. &gt; You include reflection in that list while you advocate using reflection. Yes. I'm not saying those things are useless, just that they're not practical applications. &gt; Random &amp; exhaustive enumeration is used within quickcheck, which you included as useful. I've written both random and exhaustive enumeration for testing using reflection. And I haven't used Quickcheck (or FsCheck). Would be interesting to compare. &gt; I've found the mathematical abstractions to be occasionally useful, like lattices for dataflow analysis, or a monoid for accumulating results. These may be small abstractions, but type classes make it very light weight to define and use. It's like the Option type: the advantage of this abstraction may be small, but it's still worth having if the language makes it lightweight enough to define and use. Hmm, I'd rather have polymorphic variants. :-) &gt; A good implementation of linear time sorting could be nice. I've found radix sort to be consistently faster than comparison based sorts. Of course such a thing can only work if the abstraction is zero overhead. Ok but do you really need to abstract it? I think the last time I had to optimise a sort was about 20 years ago and I was writing in assembly... &gt; Don't get me wrong, each of these individually don't make type classes worth it. If the only generic thing you ever wanted was equality you might as well build it into the compiler, but it's not. The alternative of four ad-hoc workarounds is far worse. I know that you find Haskell a very academically oriented language with many fatal design mistakes in both the language and the libraries, and I agree with you on most of that, but type classes are in my opinion THE useful innovation coming out of Haskell. Fair enough. 
This is a bit of a rant from someone I follow in Twitter but I posted it as I think it's an important point. F# is way better with OSS than other .NET languages and yet it still isn't where it should be. The over reliance on Visual Studio and Microsoft tooling is a BIG problem and barrier to growing the ecosystem.
Many people have tried to help her on the functional programming slack and official F# slack, so it's unfortunate that she posts this rant disparaging the hard, unpaid work so many have contributed to the OSS F# ecosystem. 
I don't get the situation. As far as I understand the person wrote an app that uses all the statistics/graphing functionality coming with F#. Then she wants to have that for all bigger platforms like Mac and Linux within the same toolkit. Is it that? My 2 cents: maybe F# is not there yet, I'm not sure if Haskell is. R and Python are definitely usable for that or what about Java? If you know F# by heart, maybe OCaml can provide everything needed? The post does not state anything about the history of the project or any circumstances so anyone can only guess. Why did she choose F# at first place? Often you start projects because you want to do something with a certain platform, framework or language and the project grows until a point where the technical basis is wrong. Or you already know what you want to do, then you choose the technical basis accordingly. So something went wrong, unfortunate but no need to rant about. Microsoft open sourced it, that was a good move and now the community can let the platform grow. No hate needed. Nobody rants about Apple not providing a Swift compiler for Windows (at least I didn't read about it). And there is tooling for F# on Mac and Windows, you have Visual Studio Code and Atom with Ionide and Xamarin. And with .Net Standard it seems like they try to get all the frameworks on the same basis to overcome those issues. So I think they deserve some slack there. 
I hate to say it, but yes. We don't have *any* fancy tooling like Visual Studio in Haskell land. She'll probably have to use Gtk2hs for graphical stuff (unless she's using R for that) and that's not going to be easy to master. She's probably better off using GHCJS and electron for gui stuff.
I've been doing F# on OSX/linux from day one and have had 0 problems (other than contributing to the compiler which has some undocumented workarounds for working on non-MS systems). This is like saying you're moving your perfectly fine rails app to node because you can't webscale and you need grpc kubernetes container webscale to handle your blog.
Yeah, I'm in the FP slack where a lot of F# folks hang out. She used to come in there pretty often and ask questions, which people generally offered to help out with. Folks even suggested she give talks and offered to help her out with that. I've found from my experience that people in there are generally really helpful, which is a pleasant surprise -- not all IRC/Slack rooms are as nice even when I ask really dumb questions sometimes. But her questions got more and more aggressive in how she asked...and she started blowing up at people when they'd ask for more details or clarification, going on about how she has had such a hard life and doesn't deserve to be mistreated. She finally ragequit the channel one day after telling everyone in the channel to F off and how they're horrible humans who should be ashamed of themselves for being "so rude" to someone who's suffered....&lt;insert long description of her hard life here&gt;. From the sounds of things, she *has* had a hard life. But if someone's trying to give you tech support, it doesn't help anyone for you to post &gt;25lines yelling and swearing at them about how you're broke or were abused in the past or you're tired. What you really need is a simple exchange of "this is what I'm seeing" "oh, okay, hmm....maybe give this a shot?" &lt;repeat until problem solved&gt;. From the looks of this post, she's continued that unfortunate tendency; it's a very angry rant against F# with one or two valid complaints about workflow mixed in with lots of shouting and exaggeration, followed up by her replying to herself "no wonder I got Crohn's disease"....I'm sorry you've suffered that, but no programming language can give you a disease. Best of luck to her in Haskell-land...her personal project seems to have a noble use, but I think she'll find life harder and worse there.
Can someone explain to me what's going on here? Been using FsLab just fine on Ionide. 
Yes, I believe monad transformers allow you to compose effects without having to duplicate code. I use a handful of custom workflows. Result and AsyncResult being the most heavily used. Typically they are used to interact safely with "other people's code" (databases, http apis, file systems etc). This helps keep my own code pure, simple and composable.
&gt; The over reliance on Visual Studio and Microsoft tooling is a BIG problem and barrier to growing the ecosystem. VSCode + Ionide (which is open-source) is so much better imo. To say there's an over reliance on VS and MS is a little disingenious.
&gt; I do NOT love being unable to get the data visualization tools to work for me You are going to love Haskell. /s
Apologies. I follow her on Twitter and have had a couple of friendly exchanges (no more than that) after watching a tutorial of hers but had no idea she'd been giving people grief.
No worries! I'm not trying to censor ya or stop ya from posting this...I'm just sad to see that she's still so angry. There's so much exploration and discovery and fun to be had programming, especially in personal projects. It's tough to see someone get *this* frustrated and know that it's not really possible to help.
Wow, ok. Thanks.
*Should*? Definitely objective. A "here's how you do this", given politely, with some back-and-forth of "here's what I'm seeing". Should auto repair be subjective or objective? What about plumbing? Or medical practice? These are all cases where someone needs help, so they contact someone with more expertise to help them. A plumber, a tech support person, a mechanic, or most (non-therapy) doctors shouldn't reasonably be expected to play the role of therapist, and the person seeking help shouldn't be pushed around just for seeking help.
Last I looked, F# has awesome support for GUIs on Windows and nowhere else whereas Haskell as awful support for GUIs everywhere. So, yeah. :-) Linux sucks for GUIs anyway so it is the wrong place for her to start. The nearest thing I ever did to decent GUI work on Linux was to use OpenGL but the Linux OpenGL drivers from major vendors like nVidia and ATi were so fragile in those days that we shelved the entire product line because 80% of the users of our OCaml code saw segmentation faults (!). Taught me an important lesson though: type safety is worthless for real world code if you have few libraries and your FFI is fragile. 
&gt; GUIs in F# are one of the weakest points of the language and its ecosystem. FWIW I've done many GUI projects in F# on Windows that I could never have done using any tool on Linux. 
&gt; over reliance on Visual Studio and Microsoft tooling is a BIG problem and barrier to growing the ecosystem. &gt; I'm perplexed by your phrasing. &gt; F# is a product of Microsoft and is intimately tied to the M Thanks for the detailed response although you have addressed this point after I offered some further clarification (and to which you'd already responded). Anyhow, my reasoning personally is that I work on macOS and deploy to Linux so using Windows isn't part of my workflow. I have no issue with Windows as a desktop OS (in fact as a former user I frequently defend it from the silly hate it gets from the Apple fanboys) but I have no intention of using it in a server environment as costs are a big concern where I work and Linux is free (and better suited for the server imho). You make lots of good valid points. It's refreshing to hear an F# author state the language isn't really suited to anything other than Windows. F# works for me because I know the .NET framework really well and haven't had much exposure to the JVM but perhaps I'd better take another look at Scala ...
Someone who was helping her without even having breakfast this morning! I personally think it's crazy to give up something she spent some much time learning just because of this! 
&gt;(unless she's using R for that) F# has an R type provider, meaning you can call out to R libraries as if they were written in F#. So if you're planning on using R for visualizations, F# is a great bet.
These days I do all my GUI work in the web. It's a good Schelling point - web dev might suck, but it's everywhere. If you're feeling lost in the vast landscape of web technologies, [State of JS](http://stateofjs.com/) is a fantastic way to assemble your stack. I'll vouch for React and TypeScript.
I haven't tried it. Do you get Intellisense? 
Yup! And error highlighting too. I can't remember if it has integrated debugging though.
To be clear, are you talking about tooling or the performance/stability/platform support for F# on Linux vs Windows? I'd agree that IDE support in Visual Studio is much better, but otherwise server applications seem to work pretty well on Linux/mono. I'm really hoping .Net Core/standard will help F# server applications on Linux reach parity with .net framework on windows, but I think you're right that it will be up to the community to provide its own tooling. The Ionide project is very promising (for my purposes anyway), and seems very close to becoming a workable albeit leaner substitute for Visual Studio.
That actually makes no sense. Do you think regular expression implementations should be written in regular expressions? You're better off doing metaprogramming in a metalanguage. 
Thanks for the assesment. I'm not confident, but I believe Ionide is transpiled to javascript from F#.
[Ionide is written in F#](https://github.com/ionide/ionide-vscode-fsharp) coded against [interfaces for the vscode api generated from its typescript definition files](https://github.com/ionide/ionide-vscode-helpers/blob/master/Fable.Import.VSCode.fs) that gets transpiled into js using [Fable](http://fable.io/)
Oh, I had no idea anyone was using Fable in anger.
&gt; statistics There is Mathnet library and Deedle for R-stuffs. Yes, I tested it and it worked on Linux. &gt; graphing The standard FSharp.Charting doesn't work on Linux, but on FSharp.Charting.Gtk works. There is also Oxyplot that works very well. It is very easy to create any wrapper to a FSharp library. &gt; OCaml can provide everything needed? Unfortunately not. OCaml doesn't work well on Windows and has less packages than .NET.
Ironically, this somehow seems more direct than most actual javascript projects. 
&gt; Short of tacking a JS web front-end onto a functional server back-end, which probably is a solution worth examining. This.
This isn't really the competition for Data Vis though, is it? If I go to one of my friends in data science and suggest that over Jupyter+Python, they're going to say no. 
Yes, for the built-in types (list, option, etc.) I always use the OCaml suffix form as well. My question was specifically about defining a suffix-form for your own custom types.
I don't agree with her conclusions, but I certainly feel her frustration. Using FSharp outside of Windows when you're not familiar with the ecosystem is extremely difficult. The community guidance on how to proceed is really spotty and most of the time. For example, how do you manage an FSharp project outside of MonoDevelop, Xamarin Studio, or Visual Studio? I personally only heard of Projekt because I bought a copy of Applied F# and they mention it in passing. That was a huge help, but adding a reference to a project and then making it available in FSI is a multi-step process and it's hard to find a clear, concise, step-by-step that actually covers everything. And certainly I've NEVER gotten FsLab to work on OSX. I've tried a bunch, asked other experienced F# devs for help, poured hours in, etc. You can say it's easy, and link me to a concise guide and I will be grateful, but the fact that I couldn't find it on my own without a fair sum of guidance. It's easy to be dismissive of this complaint because the conclusion is weird, but for every 1 facebook post like this there are surely many people who simply never even put in the effort to get over it. FSharp is really interesting right now; MS is aggressively widening the scope of .NET, lots of people are very nervous about Oracle's handling of their Java IP, and we've never seen higher interest in functional programming globally. It's not a terrible time to revise the garden path for new developers in the community.
first of all you use let to bind identifier to value (see from F# interactive): &gt; let a = 3;; val a : int = 3 &gt; let b = 4;; val b : int = 4 &gt; let c = a + b;; val c : int = 7 Then they are immutable by default, you can't change value like this: b &lt;- 8;; ^^^^^^ stdin(4,1): error FS0027: This value is not mutable You can hide b declaring identifier with the same name: &gt; let b = 8;; val b : int = 8 but c remains the same: &gt; c;; val it : int = 7
&gt; I've yet to see a single thing substantiating that claim. Just like every single other ML language out there, F# has an absolutely low number of people who use it. Perhaps that's due to the fact that most programmers simply don't even know about functional programming, let alone think it's worth it. I have no idea, and I doubt most people do, either. Please allow me to be a data point of substantiation. I've had a huge sum of trouble trying to get Fsharp working on Mac OS X. Everything that everyone boasts about fails, there is almost 0 guidance on how to admin a project without using either a really frustrating IDE or one that's only been freely available rather recently. I am now pushing some Mono-based code to production on Linux servers and writing some tooling, but if you asked me how to do it without Xamarin Studio I couldn't even tell you. That makes me extremely reluctant to go much further than some secondary analytics stuff. Even relatively newer books like F# Applied seem confused and can't quite agree. Other popular references are similarly outdated. That isn't GUIs or anything. That's just *getting builds working*. Even if we ignore the FsLab part of it, there's a huge barrier to entry right now for anyone outside of the Windows platform to build code with the same basic affordances (even just something like Ionide) that VS users think is so baseline that major selling points like Type Providers are deeply connected with it. And it's not like Functional Programming is my barrier. I've shipped code in Haskell, Erlang, Ocaml and Scala in a variety of contexts. I can certainly gripe about their build systems too, but it's nowhere near as absolutely locked in. I really like F#, but I could never have asked anyone else in my organization to research it. It's been 6 months of my free time, on and off, trying to just figure out how to get it to work. And I never did, I just appeal to Xamarin Studio now. 
&gt; If Linux ever gets its act together in this respect then it might be worth putting some serious effort into F# on Linux but until then what would be the point in this context? It is the industry standard for shipping middleware, frontline servers, and network appliance code? Perfect it is not, but it's a hard sell for most of the industry to imagine moving back to Windows backed network services. Even Microsoft has recognized that the ultrathin-vm methodology Linux has co-opted from FreeBSD and called "Docker" or "LXC" is a really important step for enabling heterogenous deploys. FSharp is not inherently worse for that ecosystem than any of the other Java languages. In many ways the CLR and F# are better suited than Java and Scala. It'd be a shame to ignore that. 
Objects or functions are the only way to accomplish what you described (recomputing a value based on new values). In F# c will remain as 7 in your example. Functional programming has a different mindset than imperative or OOP like c#. I recommend perhaps going through some [tutorials on thinking functionally](https://fsharpforfunandprofit.com/series/thinking-functionally.html) before trying to accomplish anything cool.
If a,b,c are reference objects instead of primitives, this would work (the same in all .Net languages). Or if b is marked as mutable, c is a function, and you change the print to c() this would work. Run through fsharpforfunandprofit.com, it's the best place I've seen that shows what you can do, gives you the theory behind why doing things the "F# way" works well, and has solid code examples so you can try it out yourself.
You can do it if you define "c" as a function. let mutable a = 3 let mutable b = 4 let c() = a + b printfn "%A" (c()) // got 7 b &lt;- 8 printfn "%A" (c()) // got 11 
&gt; But the reality is that Microsoft are putting almost no effort into getting F# to run on Linux and Linux folks aren't putting any effort into getting tools that smell of Microsoft to run on Linux. Forgive me my optimism but, Core is "real effort" for linux quality and performance and initial numbers are good. Clojure is a very successful Java effort but for a long time had less resources than I perceive FSharp as having now. Microsoft doesn't need to beat Oracle Java on Linux, they need to get good enough that the tooling and languages have credibility THEN they can point out, "Hey our ______ is better." I mean, it's not like linux folks don't know that epoll is a frustratingly bad implementation. If the community starts to rally around those targets, there is the potential for real change on a variety of fronts. I'm here because I think there is a real opportunity for big change in our industry.
&gt; Forgive me my optimism but, Core is "real effort" for linux quality and performance and initial numbers are good. .NET Core is my best bet too but I feel it is a long way from ready (look at F# support, for example). &gt; Clojure is a very successful Java effort but for a long time had less resources than I perceive FSharp as having now. IIRC, Rich Hickey had a whip round and got a lot of companies to invest money in the development of Clojure. In contrast, F# has fsharp.org which is some kind of hippie commune that people toss around like a hot potato. &gt; Microsoft doesn't need to beat Oracle Java on Linux, I think that's exactly what they need to do. And not just Java but Clojure and Scala too. Clojure has as much traction as F# without a company like Microsoft backing it and Scala is miles ahead of F# in terms of traction. &gt; they need to get good enough that the tooling and languages have credibility THEN they can point out, "Hey our ______ is better." I mean, it's not like linux folks don't know that epoll is a frustratingly bad implementation. Interesting example. I recently developed a Linux server in OCaml and the latency was 10x better than an equivalent server I had previously developed in F# on .NET on Windows, most probably because OCaml async on epoll is so much better than F# async on whatever Windows+.NET uses. So I seriously doubt Microsoft (or anyone else) can make .NET Core competitive in that context. To me the killer advantage of F# on .NET is WPF and nothing like that exists or is even under development on Linux (which sucks beyond belief for GUIs). The nearest alternative is something web based (and the entire web stack sucks beyond belief) so I watched Funscript excitedly but it flopped and apparently Fable is the new Funscript so I'm watching that instead now. &gt; If the community starts to rally around those targets, there is the potential for real change on a variety of fronts. I'm here because I think there is a real opportunity for big change in our industry. I agree that it would be great if this would happen. I'm just skeptical because I've been burned by OCaml and F# flopping before. 
&gt; Interesting example. I recently developed a Linux server in OCaml and the latency was 10x better than an equivalent server I had previously developed in F# on .NET on Windows, most probably because OCaml async on epoll is so much better than F# async on whatever Windows+.NET uses. I'm hunting around for a reference but recently someone made Python MUCH faster than the equivalent epoll for async file and network operations because the Win32 async abstractions are so good. But also, OCaml compiles directly to the environment and has a lot more work put in. Also, it fakes threads (which can be good or can be bad, really depends). &gt; I'm just skeptical because I've been burned by OCaml and F# flopping before. I don't mean to presume you aren't privilege to an equal perspective here, but I think your view of the uptake of Clojure and Scala is very rosy. Clojure has been a grassroots effort for a LONG time and as hard as Hickey has worked, many of us have also literally started our own companies (or tech orgs in larger companies) to get Clojure equal time and it's only now, past all that difficult legwork that you see these communities with credibility. Maybe you can talk about why the F# community hasn't stepped up in a similar way. But it's not something Microsoft can or ever will solve for us. The VM vendors and even the language designers and implementers can only ever follow behind us. F# is an interesting option, because quite frankly the alterantives are frustrating. Haskell has a frightfully unapproachable and fragmented ecosystem and has set down on a very brittle set of implementations for their good abstractions (Monad Transformers are a very difficult environment to build reusable effectual code in, which is what we all ultimately benchmark). OCaml is fast but lacks certain parallel execution properties that leave it ultimately in the same bucket as Node. Scala is by its own creator's admission a bit of a mess, Clojure is dynamically typed and therefore only in this set for historical reasons. We could do worse, is what I'm saying. :)
&gt; But also, OCaml compiles directly to the environment and has a lot more work put in. Also, it fakes threads (which can be good or can be bad, really depends). Well, OCaml exposes the threadless concurrency that is native to Linux. AFAIK .NET Core doesn't and probably never will. Serialization is another issue. OCaml was also ~10x faster at serialization than F#. &gt; Maybe you can talk about why the F# community hasn't stepped up in a similar way. Yes. The reason is, I believe, that F# is a product of a highly anti-competitive company (Microsoft) and the people who use it do so because they expect Microsoft to put their money where their mouth is and make something of it. It is put up or shut up time for Microsoft. The idea of contributing to Microsoft's open source software is repugnant to many. If you're going to contribute, why contribute to *Microsoft*'s open source software? &gt; But it's not something Microsoft can or ever will solve for us. Exactly. &gt; The VM vendors and even the language designers and implementers can only ever follow behind us. That doesn't make sense to me. There's plenty of room at the top in language design. Despite having underlying support for value types F# still managed to screw up tuples. &gt; F# is an interesting option, because quite frankly the alterantives are frustrating. F# on Linux is frustrating. The only option on the table that isn't frustrating is F# on Windows and nobody wants their servers on that. &gt; OCaml is fast but lacks certain parallel execution properties that leave it ultimately in the same bucket as Node. F# does have the potential to be faster than OCaml on the server but until that happens (which will require a complete overhaul of async and the .NET Core GC so I seriously doubt it will ever happen) the fact that OCaml is single threaded is academic. 
Yepp, maybe I should try to figure it out and write a blog post about it. Seems to be a common problem.
I have found [Expert F#](https://books.google.co.in/books/about/Expert_F.html?id=NcrMkjVxahMC&amp;redir_esc=y&amp;hl=en) to be a very accessible resource (authored by the creator of the language) that does not build upon such presumptions. While I have only gone through about half of the book, the content is presented through a very pragmatic example driven approach. And for all tooling/setup related recommendations author has provided pointers to utilities that work on mac/linux. 
As an aside, it would be great if you could publish a comparison of Elm and F# based on your experience somewhere. 
you don't need to know any C# to go through that tutorial. The existence of arguments for C# developers to use F# is orthogonal to the actual teaching material therein. 
IF you have silverlight installed, goto http://www.tryfsharp.org/ The first few lessons don't assume any .NET background. [This PDF file](http://tomasp.net/articles/fsharp-i-introduction/article.pdf) by Tomáš Petříček is a good overview. 
Ocaml's concurrency model doesnt work well when you're genuinely doing a ton of cpu-boind work. Not everything is waiting for someone else's API call to return data. Actual threads doing actual work is critical. Multi-process deployments are their own headache. As for that strategy, that's every Open Source's projects actual goal: get work for free. I'm not sure why we're now disparaging that while forgiving Linux, which is essentially a corporate standards partnership these days.
Do you guys provide visa sponsorship for Non-EU folk? I work in Amsterdam now, but I only be able to work within The Netherlands. would require me a visa to work outside of the country. Personally, would be interested to live in Berlin.
I agree that Expert F# is a good resource if you're not familiar with C#. In that book, they do a good job of showing how you "drop down" to the .NET BCL (Base Class Library) to do things that were already implemented in .NET and didn't need wheel-reinventing for. It might help to think of the BCL as F#'s "Standard Library" although maybe that's a bad analogy (I'm not a language expert). If you were trying to use something like `DateTime` or a static `String.xxx` feature, F# doesn't re-define its own implementations of those so it gets them from `System.DateTime` and `System.String` which are the same used by C# and VB.NET. I guess it's unavoidable to need to use .NET abstractions when you need to do stuff like I/O in F#, but someone that didn't start with C# IMO is way better off than someone like me who is stuck in OO-land (like me) knowing that I can use C# conventions as a crutch when I don't know how to do something functionally. Oh yea and the Visual Studio Code IDE is very solid for writing F#, as well as project scaffolding tools like [Forge](https://github.com/fsprojects/Forge)
Do you think that book is still up to date? Or has the language not changed much since then?
While I am fairly sure that the language idioms have not drastically evolved over last four years (since the last release of the book) - most of the [changes](https://github.com/fsharp/fsharp/blob/master/CHANGELOG-fsharp.md) seem focussed on fixing edge cases or .net and mono integration aspects. I think it is still a valuable resource in conjugation with an up-to-date reference manual (MSDN/docs.microsoft.com). 
Off the top of my head, you should get your entities from your controller and pass them to your getActiveResults and your setInActive so that you are always working with the latest set of entities. The entities you have now are a the same as a static global value on a class.
I apologize for being greedy, jdh30, but do you have any references or have you published any data on things like F# latency for server applications?
I guess it really depends on what environmental entities are. If it was a user, and every call the controller could be a different user, you would want to pass it to your functions. Passing an argument to a function vs a function accessing with a higher, possibly global, state is Dependency Injection. The function depends on the data to be 'injected' into it. If Environmental entities never change, then they are static and it is safe to keep them the way you have it. If they do change, you can use a mailbox processor like you stated, and you can send it a Get message, and a set message. Mailbox processor can work well as a singleton like object because its a concurrent queue and only processes one message at a time. You can't have race conditions. Does this clear things up?
If you can get access to PluralSight, both my courses there ("F# Jumpstart" and "F# Functional Data Structures") assume little or no .NET/C# exposure. If it's any comfort, I knew very little C# before I learned F#. Personally I think that was an advantage. +1 for "Expert F#". That's how I learned.
&gt; and you can send it a Get message, and a set message. Mailbox processor can work well as a singleton like object because its a concurrent queue and only processes one message at a time. You can't have race conditions. I understand how it can avoid race conditions and behaves like a queue but will need to look how i could share the entites or "context" if you will between calls since the state changes. I have not seen an example using Mailbox with databases. I will go fish. Thanks for the feedback. 
I'm especially missing something like Python Pandas. I know Deedle exists, but it's far from the ease of use of Pandas.
Side effects can be encapsulated in [monads](http://santialbo.com/blog/2013/03/27/monads-in-f-sharp/).
Well, I've tried it now and it is a complete disaster too. Just took me two hours to get Mono, F#, Ionide, Visual Studio Code and Atom installed on Debian and they suck. Most won't install from the Debian repos and must be installed by hand so you cannot uninstall them. I'm seeing some coloring in editor windows but no throwback of type information, no REPL and no Intellisense. 
Sounds like an issue with Debian (and/or your package manager). Under OS X all you have to do is download VSCode from their website and install the Ionide extension. This will prompt you to download .Net Core which is another installer. Once that's done you should be ready to go (it might have to download a couple of other installers. But it will prompt you about anything that you need). EDIT: OS X instructions are [here](http://fsharp.org/use/mac/) if you're interested.
I've used FAKE but only via mimicry or templating. Its documentation assumes experience and while it seems powerful, it is also complicated. FAKE just builds projects as per a spec and automates some other shell tasks. It doesn't sort your tooling, your dependencies, or even seem to offer its own bootstrapping the way rake does.
I don't really have an answer, but a question: Why do you want to remove type annotations? Which kind of type annotations do you want to remove? I strive to be explicit about my type declarations. If I change the code, I like getting error messages where the function is, not at it's callers for getting the wrong type. I think explicit types signals the intent of the code. By specifying types precisely and not relying on, for example, arbitrary precision number types, you can actually squeeze some extra performance out of the code. For local definitions, I usually rely on the type inference, but if I have put type annotations in there, I usually don't bother to remove them unless it really cleans things up.
I dont think there's an automatic way of doing this but it would be an excellent addition to [f# power tools](https://fsprojects.github.io/VisualFSharpPowerTools/)
Could you run into a situation where deciding which annotation to remove (either would yield a valid parse) results in differing behavior depending on which was taken out? 
You cannot uninstall them? Just do "sudo apt remove code" and VS Code is uninstalled. I'll grant that a lot of the versions in the Debian repos are kind of old, but here's what I did to install VS Code + Ionide on Ubuntu 14.04: 1. Go to http://www.mono-project.com/docs/getting-started/install/linux/ and set up their repos, to get the latest mono. 2. sudo apt update; sudo apt install mono-complete fsharp 3. Download the .deb file from https://code.visualstudio.com/ 4. sudo gdebi ~/Downloads/code-1.6.1-########.deb 5. Run VS Code, install the three ionide-* plugins 6. Restart Visual Studio, and now I have autocomplete, intellisense, REPL... If that doesn't work for you, then file a bug against whatever didn't work (Mono, VS Code, Ionide). All three of these projects want their stuff to install smoothly and easily, so if there's a major Linux distro where the installation *isn't* smooth, that's a bug they'll want to deal with ASAP.
And I am currently learning from your book. :)
I actually think removing type annotations should be a anti-pattern. If the function should be generic then we should use generic types.
I believe something along those lines may possibly have been done as part of https://github.com/fsprojects/FsReveal. That might give you some clues.
Thanks! I'm interested in both. I will try them as soon as I get my win10 PC running as F# on osx is too much work for a beginner. 
I wrote a post about this not long ago. http://banashek.com/posts/20160602-fsharp-live-development-docker.html Docker isn't required
The reason it's not in the NuGet package is that Linux isn't binary compatible with itself (due to dependencies), i.e. what runs on Fedora might not run on Debian etc. That's why programs have to be repackaged for different distros. That's also why Docker is such a big thing, as it's supposed to save you from the Linux dependency cluster mess.
I remember WebSharper is licensed a little too restrictive for an open source framework, IMHO. 
Thank you very much! Anything in particular, you'd like to see? :)
Nice. Did you notice any uptake or more github activity after the license change?
We did, but since at the same time we migrated from bitbucket to github, it's hard to tell which change had the biggest impact.
WebSharper seems like a very well thought out framework but I'm a bit concerned that development has slowed down when it was completely open sourced. As an observer, the framework seems to be mostly in maintenance mode. if that's the case is it because it's deemed to be complete, or is the commercial incentive isn't there? Lastly, thanks for the great work on WebSharper.
Have you tried ASP.NET Core (F#) on the backend? I'm currently starting to learn Suave (&amp; Fable) but was wondering if the former plays well with the functional paradigm.
Sure. I always enjoy a fleshed out example in a github repo that contains non-trivial behavior. Some interesting things like custom renderers, effects/animations, and optimistic updating (and handling of failure for unsuccessful calls) comes to mind. I'm sure someone could work from the examples you provided in this article up to those, but it's always easier if someone else more experienced does it first ;)
With ASP.NET Core, you'll be using more OOP techniques for dealing with the framework and associated libraries, but you can still keep your business logic in FP. Suave is FP all the way. Each is good in their own right.
Fabel's a bit closer to modern JS stack (eg. React/babel/etc...) and is lower risk in this regard. WebSharper i think has some interesting abstractions (particularly piglets/formlets/sitelets/template providers), but is more a full-stack web framework. It interops with Suave (as an OWIN middleware app). I'm going to give WebSharper another serious look when 4.0 is released. The API seems to be in flux right now.
Fully agree with this. When I'm using F#, I make it a point to use FP as much as possible, so in this case that means avoiding ASP.NET
Adding to /u/Banashek's suggestions, something that does routing to different pages.
Feel free to share the project, if you can! I'd love to see more Fable and Suave examples.
This is suuuuper relevant to my interests.
I use this setup on Linux. There is a mono debugger extension for Vscode that allows you to set breakpoints, and with the result of a FAKE build debug. I set up a launch.json task for it. As for a visual test rubber, I want one too :(
F# really needs a smooth command line workflow. If the compiler had a way to handle packages and dependencies like Racket or Haskell, that'd be great. I'd love to work on F# with just Vim and a terminal, but the language and compiler and build tools and dependency tools are far too coupled not to use something like VS Code, and I don't want to. Especially since VS Code saps my MBP battery worse than any game.
Second this: I'm constantly spinning up Linux VMs and spend a lot of time in Vim and I'm pretty sure there are a lot of people who work like this too.
Agreed ... in a sense. What I'd love to see is an implicit search system like Scala has, and like OCaml is about to get. Without that, I'm able to get quite close--e.g. I have code now which goes like `map t (fun x -&gt; x + 1) my_container`, where `t` contains the logic for mapping over functors with type `my_container` and I can swap it out for some other functor instance. If I had a way to pass in that `t` implicitly based on the type of `my_container`, it would get me to Haskell level.
Have a stab at my questions please! Note that I'm open to replacing VS Code if it has better TDD &amp; debugging support (and isn't Visual studio...).
Nice to read some comments from some real-world production F# code. I'm about to put some F# into production myself, and found your post very useful.
Figure 30% change you are laughing right now, 70% chance you have no idea what I'm on about. Serious thing: You might profile the toString and fromString methods for your DUs, to see if they are coming up as big bottlenecks in your code base. They did for me and it was a big surprise. 
To be accurate, FP and OOP are _isomorphic_ concepts. You can implement one in terms of the other. (Neither will necessarily look great, though.)
That would take the fun out of things :-)
1) I write a lot of automated UI tests using canopy : https://github.com/lefthandedgoat/canopy It has multiple reporters but the main reporter is console. So I write code and when I want to run tests I run `fake tests`. `fake` is a bash alias for `sh build.sh`. It will run a FAKE task that builds the code and runs the test suite. You can download a solution that does this here: https://github.com/lefthandedgoat/canopyStarterKit For regular unit tests, I extracted parts of the runner I wrote for canopy, and I made a parallel unit test library/runner for console which you can find here: https://github.com/lefthandedgoat/prunner Note that I write unit tests in a console app, not a traditional class library. 2.) I started in VS many years ago and never found myself debugging F# often, but when I did it was there. When I switched to OSX, in the rare (like 1 time per month rare) occasion that I need to debug I open up Xamarin Studio and use it. Since everything I do is console (ui tests, or web sites via Suave.io) I will do very basic 'debugging' with print statements. I graduate to REPL first with some guess and test style debugging, and if I am still stuck I use the real debugger in Xamarin. Hope this helps.
I would say F# is a strict superset of C# in terms of functionality. Well, maybe except for implicit conversions.
Why you chose Visual Studio Code? Have you tried Atom? 
Yes, definitely helpful, thanks! I'll check out the test runner soon. I know that F# requires much less debugging because the compiler tells you everything that's wrong, but I found it very tedious to have to make a debug FAKE build and run it every time I want to run my app (my FAKE build takes about 20s to finish! You can imagine how that kills my enthusiasm!). With other languages in VS Code I could just click the green debug button and it just instantly works. Even in standard VS I could just click that green button in an F# solution and everything just works. But not in VS Code :(.
I made the switch away from windows prior to VS Code, so I have never actually tried it. The author of the Ionide plugin along with many other helpful people are on the F# Foundation slack, and you may be able to get more help there.
My advice: * First, if you're using FSharp.Data, use CsvProvider to read in your input file (this will also allow you to attach a unit of measurement to your kilometers column using the Schema type parameter). * Secondly, using the new CsvProvider-provided type, you'll be able to refer to columns with dot notation--a plus. * Finally, if all you're after is a sequence of transformed values, use a generator to build the sequence lexically. So, something along the lines of: open FSharp.Data type ImperialData = CsvProvider&lt;``Insert File Path Here``, Schema = "Id,Km (int&lt;km&gt;)"&gt; let imperialData = ImperialData.GetSample() let output = [ for r in imperialData.Rows -&gt; r.Id, r.Km * 1000&lt;m/km&gt; ]
thanks! Infact I started using CsvProvider itself since I posted here, I have some custom unit of measures that I need to use. I am getting an error with the following code. let x= imperialData.Rows |&gt; Seq.map (fun row -&gt; convertImpMPG (float(row.``Imperial MPG``)&lt;ImpMPG&gt;)) I'm getting an error : "Unexpected symbol ')' in expression for the before last ) convertImpMPG is function which i've made with this definition : val convertImpMPG : x:float&lt;ImpMPG&gt; -&gt; float&lt;litresPer100Km&gt; 
Alright, so to clean some of this stuff up, how about this? let litersPer100Km = imperialData.Rows |&gt; Seq.map (fun r -&gt; r.``Imperial MPG`` |&gt; float |&gt; ( * ) 1.0&lt;ImpMPG&gt; |&gt; convertImpMPG) As I understand it, your trying to cast to float and add a unit of measurement in a single step won't work (hence the error). Additionally, try to cut down on your use of parentheses (as they're difficult to parse sometimes), and increase your use of pipelines instead. I think it's a more fluent style of coding, as each pipeline application demonstrates the transformation being applied.
About using point-free style, that's interesting. I wonder if the type of generated MSIL would be different if you were to, say, specify your function's type exactly in a signature file and then define it in point-free style? E.g. in the `whatever.fsi` file: module Whatever = val f : 'a -&gt; 'b -&gt; 'a And in the `whatever.fs` file: module Whatever = let f a = fun _ -&gt; a
&gt; I remember reading in Real-World Functional Programming that the preferred F# style is to include brackets for single-argument functions (so writing f(x) rather than f x /u/tomasp, I wonder why that would be preferred? :-)
Visual Studio Code is less slow than atom. This becomes especially important with Ionide doing a lot of work to process larger F# files. aside from speed they are very nearly identical. 
How do you have the target setup? Is it using build or rebuild? Is it compiling projects you don't need it to compile? I often add a quickbuild target for projects I need up and running with a bit of haste. There's also the option of running the tests in the REPL. [You can use #directives to setup a module file so it loads its dependencies when run in FSI.] (https://github.com/fsprojects/VisualFSharpPowerTools/blob/master/tests/FSharp.Editing.Tests/OutliningTests.fs) 
Even though I only work in VS and vscode I still use the commandline extensively during F# dev for the same things. Paket for packages, FAKE for builds and running tests, git for vcs. The editor tooling features are the main reason I stick with VS and vscode, besides needing to eat my own dogfood and whatnot. I see the project management aspects as the biggest drawback of not using VS, which we're trying to address via Forge, which is what Ionide is using for project templating and management behind the curtain. 
At this point I'd say there's a significant disparity in the breadth and quality of features in ionide-vscode vs ionide-atom. Not to mention all of the internal dependencies like Suave, FSAC, &amp; FCS are pretty outdated in Atom. The issue with Atom is the extension API requires a lot more work on our part to implement new features whereas with vscode it's much much easier. We'd need to create a lot of bespoke GUI elements to reach any kind of feature parity. Working with the Atom API is also more tedious due to it being in coffeescript and any changes require manual tweaks to the bindings we use, while with vscode we can use ts2fable to generate new bindings for the API. Which is tied into the biggest issue which is that ionide-atom is still written in Funscript (which is basically dead) and needs to be ported over to Fable and that's going to take a fair amount of work. Currently the vscode extensions are the only ones being actively developed and they're the ones we recommend that people use.
List of "VSCode only" features is pretty long - http://ionide.io/#features ;)
Which Rider won't support :)
This is a good item for [fslang-suggestions](https://github.com/fsharp/fslang-suggestions)
Thanks for the pointer! https://github.com/fsharp/fslang-suggestions/issues/341 looks close to the issue so I'll leave a comment there.
What does "official .net language" even mean?
Maybe I should have condensed half the post to 'read the guidelines'! It's amazing what you pick up on when trying a new language - flashy features seem to trump readable code (that is, until you come back to it much later on) 
Yah project management w/o a gui can be a bummer. I just got really good at editing proj files by hand.
Writing a small set of functions on top of HTML Agility Pack to help me quickly parse a couple of websites :)
Doing the 50ish first project Euler problems trying to beat the efficiency of my old solutions in scheme. Not as easy as it sounds, as I used Chez back then and spent quite some time doing "smart" brute force. Just finished writing a lazy seq of the sieve of Eratosthenes with a simple wheel for the first 4 primes (ie: I don't have to calculate any multiples of 2,3, 5 and 7). I am pretty damn happy with the result.
Complete opposite here, I find the type providers to be really handy. I do not know what magic they do but I also get 'live' intellisense of the webpage I'm scraping which is really helpful. Although I haven't looked into advanced parsing, the [F# Data HTML Parser](http://fsharp.github.io/FSharp.Data/library/HtmlParser.html) has been enough so far.
I almost finished a working version of a [Summary2Pages](https://github.com/aloisdg/Summary2Pages) (I dislike the name). It is a program to generate files and folders from a GitBook's SUMMARY.md file. I am using F# with .NET Core. Any help is welcome. Be gentle, it is my first ever useful F# program. ;) Now, I want to add unit tests, documentation, arguments support and fake.
I just installed F# on my development machine after playing around with SML and OCAML
I've been exploring how to encode typeclasses in F# using structure types and explicitly passing in the instances to the operational methods. Right now I'm using the domain on encoding JSON as an exploratory vehicle. Lack of higher-kinded types is not a huge problem; there are ways around it. The main interesting problem right now is how to implement functions that derive instances for sum types given instances for their constituent types. The problem is that it's difficult to pass in extractor functions for the different cases of the sum type in a clean way. I'm now exploring if quotations will simplify things....
This is a great time for you to be getting into F#. Check out dot.net, install the dotnet dev kit and CLI tool (it's like npm), read up on the `project.json` and `global.json` project file structures (like `package.json`), set up your projects and you're good to start coding.
Haven't really heard of AngleSharp before. I'll take a look, thanks.
Nice I haven't heard of that before. I'll have to check it out!
You can try using Flynn which is like an open source PAAS similar to Heroku. I recently used it to deploy to Linux VMs in Azure but it works with other cloud providers and I think DigitalOcean as well.
Currently using F# for the json config R/W part of an app. I've taken advantage of F# type providers in a couple of projects. Nothing end to end, other than small team-internal utilities and testing appliances.
Flynn definitely looks cool. A couple of notes: - Looks like their production wants 3 machines with 2gb minimum. On digitalocean that's $60 already. - Their security page says not to use it for anything with sensitive data. I consider user information sensitive, so it's kind of a negative for me. I'm definitely going to check it out for small side-projects however.
A soft-real-time financial report system. A calculation engine.
We should create a technology to follow feed of articles from blog. It will be free, libre and easy to use. Oh wait.
- Asp.net (Owin/Nowin) -&gt; but looking at freya more closely these days - fsShelter (contributed by Prolucid ;) ) with storm - Choose your own nosql for persistence - Prolucid has a library layer to kinda tie it all together and make certain parts feels a bit more idiomatic - Front-end is Fable-Elmish (contributed by Prolucid) - Cell phones is about to become fable-elmish as well (check out the react-native samples) 
https://www.reddit.com/r/fsharp/comments/5aqxjg/how_do_you_use_f_in_production/d9kmblu/
Nice way of thinking about it, I'm currently looking into Linode and testing it out trying to do the same with a suave app. By the way, what would you do about 'zero-downtime deployments'? I've heard that could easily be managed by azure service fabric but I'm really unsure about what exactly that term means, how would you get downtime anyway if you're using CD? (sorry, I'm a beginner in that area)
I am moving to _Fummary_ as a name. better? :)
We have a complex website (+apps, +realtime update, 500k loc), run perfectly in mono/linux under highload (20k reqs/sec/server) from 2011
A web service (suave) bridging couchbase to unreal engine game. Leaderboards and statistics data.
* Alt-&gt;F-&gt;New-&gt;project * Select Visual F# * Select Console Application * hit OK * replace the contents of the main function you see with printfn "Hello World" System.Console.ReadLine(); 0 * hit f5 * should compile, run and print hello world to a console window. Visual Studio is very nice for beginners, certainly the nicest IDE option. If you are more used to command line work, you can use any code editor you want. Visual Studio Code has a nice plugin for F# called Ionide. 
&gt; Help will always be given at Gryffindor to those who ask for it, Harry. A simple alternative to Visual Studio, in case you ever want a more lightweight experience, is to run the compiler and interpreter (`fsc.exe`, `fsi.exe`) manually at the command prompt and compile and run your own files after typing them with your preferred editor. You'll find the location of those executables listed at http://fsharp.org/use/windows/ (actually you'll find many other ways to use F# there too). Enjoy!
Still hoping you have some more info on this. I could really put it to use. 
I was literally just looking for something like this! Thank you! After I become fully acquainted with syntax and everything, do you know of a resource for some projects I could attempt?
Unfortunately no. My playground projects have all been related to either work stuff or random things I wanted to try
Reddit's own /r/DailyProgrammer is gold!
I didn't know about this! Thank you!
I'm submitting a link to my own blog post: I would love some feedback from the community about this approach.
Yeah just noticing it looks like it goes through periods of inactivity. Something to consider if we want to jump in. ASP.NET took quite a bit of wrapping to get it to look mostly nice and have a half-decent async usability story. 
I started 2 weeks ago with [Try F#](http://www.tryfsharp.org/Learn/getting-started) then moved to [`fsc.exe`](http://stackoverflow.com/questions/15147930/how-to-create-a-shortcut-for-f-compiler-fsc-exe) and `fsi.exe` (as /u/yawaramin said). Now, I am using [vscode](https://code.visualstudio.com/) with [ionide](http://ionide.io/). I dev in F# with .NET Core and everything works fine for me. [My first project is running](https://github.com/aloisdg/Summary2Pages/tree/dev)! Good luck!
I don't think any F# to JS libraries have been production ready. To me they have all been concepts so far. I think the best combo is elm for front end and suave for back, because the whole purpose of elm is front end so we can assume it's not going anywhere soon. If you really want f# for front end in production then maybe try websharper?
As a member of the WebSharper team I'm most certainly biased, but here are my thoughts on the topic anyway. There have indeed been a bunch of community F#-to-JS projects over the years; FSharp.WebTools (2007, which inspired the very early versions of WebSharper in 2009), then after WebSharper came out there was Pit (2011), then FunScript (2013), and most recently Fable. Currently, I would say that the only projects that are indeed alive are Fable and WebSharper. Fable has made the bold choice of favoring Node-based tools (eg npm, babel) over .NET tools (eg NuGet). I'm not quite sure how this will turn out for them -- on one hand it will probably help attract some people to it that would not otherwise look into tools like WebSharper, but on the other hand the turnaround for Node tooling is incredibly fast and they'll have to keep up the pace.
If you have access to PluralSight, my F# Jumpstart course is VS based: https://www.pluralsight.com/courses/fsharp-jumpstart
Also checkout fable-Elmish. It follows elm pretty closesly and works well with fable-react to give you a nice vdom experience. We're using it in production on 2 projects at the moment 
Fable was made by one of the main contributors to Funscript and it has done a great job of addressing many of Funscript's issues. In under a year Fable has already surpassed the number of contributors Funscript accrued over 4 years. I've seen a lot more people experimenting with it than I did over the course of Funscript's lifespan. There's no reason to mourn Funscript, it's obsolete. btw - Fable is already being used in production projects
It seems like an interesting approach. Of course the general problem with encoding rules in function values is that you can't serialise/deserialise the dynamic rules, only their output. The source code has to serve as the place where the rules get stored. You can't easily read a new set of rules from say a CSV file that some other system produces. But in your scenario (describing a UI) that's probably not very important. Anyway, a few code observations: You have two different types which are lists of basically `something -&gt; bool`, or in other words a predicate. You can capture that: type 'a pred = 'a -&gt; bool With this general predicate type, I'd argue you don't actually need the more specialised ones. Also, for things where I intend to type in literal sequences in the code myself, I've come to prefer arrays over lists for efficiency. type 'a ColumnSpec = Quotations.Expr * TdsReturn pred array * 'a pred array Next, you've got a predicate that always returns `true` defined twice. You can unify them: let always : _ pred = fun _ -&gt; true Now, you have some predicates which test or just straight-up return properties of your `TdsReturn` and `Deduction` values. I would argue that apart from the above-defined `always`, the other predicates should really be put in the associated modules of the `TdsReturn` and `Deduction` types, because they are almost entirely simple property accessors of those types. Keeping them separate avoids having a mish-mash of things in a single module. Same with the property accessor functions that you put in quotes in the final UI spec, actually. Those can be defined in the `Deduction` module. With those changes, the final spec becomes: let deductionColumns : Deduction ColumnSpec array = [| &lt;@ Deduction.date @&gt;, [|always|], [|always|] &lt;@ Deduction.sectionCode @&gt;, [|TdsReturn.isRevised|], [|Deduction.isNil|] &lt;@ Deduction.amount @&gt;, [|TdsReturn.isRevised; TdsReturn.isForGovernment|], [|Deduction.isNil; Deduction.dateIsPresent|] |]
Thanks :-)
Ah, that's a cool technique. I'll try to use it sometime. One last small thing, you could use the untyped quotation `&lt;@@ ... @@&gt;` since you just need to get a string value out of the quotation and not any type info.
Maybe that key combination is already assigned to a different command. In my case it's assigned to "workbench.action.terminal.openNativeConsole". 
For the frontend consider Fable, Websharper or drive into the JS ecosystem (good luck - have a look at Elm if you do). For the backend, the popular libraries are Suave (100% F#, pretty simple), ASP.NET Core (you'll have to go object oriented, but its the most maintained one so far), NancyFx (There are F#-specific tutorials and I hear good things but havent tried), WebSharper (yup, it works on both sides), and Freya (sexy website but has not been updated for a while). For Suave there is the book that someone else mentioned, and also there's the other one [F# Applied](http://products.tamizhvendan.in/fsharp-applied/) (talks you through Suave). For WebSharper, their website sums it up but if you need more, Expert F# 4.0 (book) has a section on that.
Here's the meta-deal as our cross platform F# dream goes. It's possible to do F# on Mac/Linux, but... 1) F# is always going to be second fiddle to C# 2) Linux/Mac are always going to be second fiddle to Windows/Visual Studio So you have two extra sets of issues to deal with that the main developers and core users of .NET don't face, plus the fact .NET evolution is messy and confusing right now . And most of the F# community doesn't deal with Linux. I love F# as a language. But I have to fight the normal .NET corporate mindset to use it on my Windows systems at work and I have to fight the environment and lack of support to use it on my Linux systems at home. It may get better in the future, but I'm turning to other languages on my Linux projects. At work I'll try to be functional in C# and sneak F# in where I can...
I can't add much to what "xradionut" has said. I'm an OSX / Linux guy (formerly Windows) who works with Mono mostly during the day and I've had to deal with all the friction that comes with this. I can see the situation changing for C# because Jetbrains are on board and their tools are always first class - plus there are a lot of people using C# for Unity. But I don't see F# getting the same love for tooling anytime soon (Jebrains have said they have no plans to support it). I use Xamarin Studio for my F# work and it's 'okay' but nowhere near as smooth as using C# with Visual Studio.
In the ideal case, the community will decide on a readable format for F# projects. I have seen discussions around using TOML, like Rust's `Cargo.toml`, as a base for a project file format. Don Syme has said that if a well-thought out, well-implemented proposal is made, he will happily accept it and consider it the standard for F#. But it will take a lot of work both to decide on this new format and to implement it for all the tooling out there -- Visual Studio (creating a new project format for VS is apparently its own hell), Ionide, Fake, Monodevelop... It's not considered enough of a priority to divert resources to it from the MS Cambridge or Redmond F# teams (which I can completely understand).
http://forge.run/ It's a tool that provides command line ways to manipulate a project file. Also includes templates/scaffolding of new projects and solutions. This is the tool that Ionide uses to do project file manipulations. It'll be kept up to date with the changes to fsproj coming with dotnetcore.
Ugly.
How does Paket fit into all this? Will it work with MSBuild and fsproj (for dependency management)? 
Out of curiosity to what languages are you turning to on linux? Is it dart?
Racket for functional wizardry and D for systems programming. And some C for libraries and micro-controllers. 
OCaml?
You should do something about it =P
I doubt the tooling for OCaml - even on POSIX systems - will be any better will it?
&gt; Racket I'd never heard of Racket but just looked at its website and the first thing that jumped out is it looks a bit like Clojure. It might be very different but if not why not go with Clojure which targets the JVM and (I'd assume) has a much larger community?
Is anyone planning to do this? It's starting November 28th and lasting for five weeks. I am planning to follow along the course with a few colleagues, but in F#, because I think F# is a great modern interpretation of SML/OCaml. We obviously won't get any grades, but it should be fun.
If you want an F#-alike on Linux I recommend OCaml.
Depends what you're doing. I build a substantial JSON over HTTP server in OCaml on Linux a few months ago and it worked extremely well. In particular, the latency was much better with OCaml than F#. 
The course has been on the university website for a few years. I did it a while back - highly recommended and will definitely help your F#!
F# allows currying, meaning "obfuscating" function parameters and giving that a new name. For example, consider a function, 'Add', which takes two int's and yields an int. The typical example provided is using this function to create an 'Increment' function, as such. let add = fun x y -&gt; x + y let increment = fun x -&gt; add x 1 printf (add 2 3) // prints "5" printf increment 4 // prints "5" In short, you will curry the needed functions to omit parameters that originate in config files, then use those new functions in your pipeline. Disclaimer: I'm kind of new to F# as well, and this is just my *attempt* at an answer. Hope this helps.
As "jackmott" says, it's probably a Core issue. I've avoided using Core - it's a moving target and needs time to settle down.
&gt; Would the F# way to do it then be partial application, i.e. giving the configuration input into the functions first, storing the already partially "filled out" functions (only one parameter left open: the actual data) as let bindings and chain (compose?) those together to transmit the "real" data from function to function? Basically, yes. &gt; Wouldn't that result in a lot of repeated code No, call these partially applied functions from the different controllers. This is the exact same concept as how dependency injection frameworks wire up all the dependencies into an actual instance that is called throughout the application.
If i understand correctly, you have a series of pure functions that you don't want to pollute with the logger. One potential way of solving this problem would be to leverage [Railway Oriented Programming](http://fsharpforfunandprofit.com/posts/recipe-part2/) where each function returns a discriminated union of Success with the return value or Error. Then you would compose these functions and check at the end if there was an error that needs logging
You pass in a log function or interface as the first parameter to every function and curry those functions with the actual logger. You may also find this helpful: http://blog.ploeh.dk/2015/11/30/to-log-or-not-to-log/
I found this kind of interesting where they show how you can use computation expressions to automate logging. https://fsharpforfunandprofit.com/posts/computation-expressions-intro/ 
Visual Studio for Mac is just a rebranding of Xamarin Studio, so you can get a good idea what it can do by installing the latter.
To me it seems that this signals that they're investing time and money into making it more than just for mobile development. We'll see how it turns out. 
It supports F# for iOS and Android, it just doesn't have templates for those yet.
Xamarin _Studio_ never was just for mobile development though, it was a general-purpose IDE. I guess the rebranding will make that clearer, as now indeed the Xamarin name will only be used for the mobile cross-compilation technology.
Historically it's been 6-8 weeks between VS RC and RTM. I'd bet on January.
I installed it last night and bugs aside (it crashed several times) it is very similar to Xamarin Studio. My guess is this is where all the focus will be and us .NET NOW people (Not On Windows) will have to switch from XS sometime soon.
Thanks for the link, but in the video they show multi-case unions getting tagged with the `[&lt;Struct&gt;]` annotation.
Really love all the new module quality of life improvements. Keep it up boys
Yeah it works fine with multiple cases. Seems you need to explicitly name all fields uniquely and the result is a flat struct with all fields from all cases. Don't think it is packed in any special way (tried two double cases and got default (double) for the non-active case in c#. Would have expected the same value for both fields if they were overlaying?)
Where can I buy this shirt?
Of course, with all these `@` list appends, the actual performance is not good. But it's a neat way to show very readably how quicksort works.
No, because then you can't use `::` and `@` on a `seq`.
*and girls
[codegolf.stackexchange.com](http://codegolf.stackexchange.com/) /r/codegolf/
Hi, /u/TarMil! Are formlets coming back in release 4.0?
You can shave off an extra character by removing the brackets around the tuple assignment, and another by rearranging the pattern match (if `a :: b` fails to match, then we must have the empty list): let rec f=function a::b-&gt;let x,y=List.partition((&lt;)a)b in f y@a::f x|l-&gt;l
Yeah, sectioning would be really cool--maybe even a little _too_ cool for an ML :-) I do like the prefix form partial application and the `List.partition` function which others have mentioned. Here's another attempt which I think strikes a good balance: let rec quicksort = function | [] -&gt; [] | pivot :: xs -&gt; let smaller, bigger = List.partition ((&gt;=) pivot) xs quicksort smaller @ pivot :: quicksort bigger
The void type is represented by `unit` and a void value is represented by `()`. let print message = printf message () // signature // print: string -&gt; unit Indicating that a value may not make sense is handled by `Option` / `Some` / `None`. let divide a:int b:int = match b with | 0 -&gt; None | _ -&gt; Some (a / b) // signature // divide: int -&gt; int -&gt; int option Now because it is built off of .Net, F# does have the concept of `null` which is roughly related to `None`, but you want to avoid using explicit nulls whenever possible. 
So, using `option` to indicate that an operation may not return a value is sensible at the value level; but if you're trying to encode logic at the type level, it's not enough because the `'a option` type includes the possibility of evaluating to an `'a` value. Neither is `unit` good enough, because at the type level it indicates that your operation will always return a single value. If you want to say at the type level that it's _impossible_ to return a value, you would return the `Void.t` type that I described. E.g., if you look at the link I posted above, it has the following (Haskell) proof of the assertion 'if proposition _p_ is true, that implies that the inverse of the inverse of _p_ is also true': data Void proof :: a -&gt; (a -&gt; Void) -&gt; Void proof = \a -&gt; \f -&gt; f a Now, here's the F# port: module Void = type t = private T of t (* val proof : 'a -&gt; ('a -&gt; Void.t) -&gt; Void.t *) let proof (a : 'a) (f : 'a -&gt; Void.t) : Void.t = f a
Visual Studio 2017^RC turns out to be super buggy (crashes when creating an .fs file in a library and any nuget packages don't work (`namespace or module not defined`) except after restart, also no F# power tools). Then there's .NET Core which literally doesn't work with F# (clean `dotnet run` gives a compilation error). Finally there's Paket/Ionide, where there's no debugging support for windows so I'm stuck with VS 2015 as the only thing that 'sorta' works.
Certainly debatable :D but i figured the function being accomplished was the seconding. Perhaps other data can be seconded? In this hypothetical MotionSeconded codebase...
fsharp on dotnet core is coming soonish - I'd expect a big hop there in january or so. VS 2015 and paket can play pretty nicely together - kinda depends on your project type and cross-platform story as to which will be "best" for you though.
Ah, okay. Thank you so much! How would I go about fixing that?
To draw a random card from a 4 * 13 grid of cards, you need to randomly sample two numbers: one between 0 to 3, and another between 0 to 12. Then using these, you check if there is a card at those coordinates on the grid. If there is, you draw that card and mark it on the grid as drawn (assuming you want to sample without replacement). This leads to the problem of: how to check if there's a card at the grid? The idiomatic F# way is to fill the grid with `Card option`s instead of just `Card`s: let deck : Card option [,] = Array2D.zeroCreate 4 13 for suit_num = 0 to Array.length suits - 1 do for value_num = 0 to Array.length values - 1 do deck.[suit_num, value_num] &lt;- Some { Suit = suits.[suit_num]; Value = values.[value_num] } Now before you draw a card from the grid, you must first check that it really does have `Some card`, and if it doesn't you have to try again. Then after drawing the card you must replace that card on the grid with `None`. This all can be expressed very nicely as a recursive function `val draw : System.Random -&gt; Card`. Edit: at the end of the game your deck may be totally empty. It's probably best to have `val draw : System.Random -&gt; Card option` to account for the possibility that there are no cards left to draw.
I have same issue with Ubuntu 16.10. The error is "The specified framework 'Microsoft.NETCore.App', version '1.0.0' was not found. ... - The following versions are installed: 1.1.0 ... This is odd because the project.json specifies version 1.1.0 for the Microsoft.NETCore.App dependency, so it's not clear why it's looking for 1.0.0 anyway. However, looking at the project.lock.json shows that the tooling, dotnet-compile-fsc/1.0.0.-preview2-02000 has a dependency on Microsoft.NETCore.App 1.0.0, which I presume is where the failure occurs.
Ah you're right, I was looking at SNI supported SSL. With the Basic tier it comes to $60 with the database as well. I'll update that to reflect the correct amounts.
It won't. It's focused on .net core and mobile
Interesting. Thanks for the tip!
I admit both of your latter points, but can you clarify how I'm contradicting myself? I think I said essentially that we can get the void type indirectly.
I really like that they're obsessed with documentation, observant of column widths, and not afraid to use vertical whitespace to break up sections of the code; but--my only critique is that they've filled the codebase (at least, the sections that deal with asynchrony) with `#ifdef`s. They're trying to parameterise the codebase over the asynchrony primitive (.Net `Async` or Hopac `Job`), but they're hampered by the lack of parameterised modules (functors) or typeclasses and higher-kinded types in F#. So they've taken an approach (preprocessor directives) which I believe is less than optimal; you can see why in e.g. [Core.fs](https://github.com/xyncro/freya-core/blob/0a8737af924c831333a3c46736b7753e562dd3ab/src/Freya.Core/Core.fs) which is littered with `#ifdef`s.
preprocessor approaches may look ugly but they solve problems, with no runtime overhead! 
Perhaps i misunderstand how one is less direct if it achieves the same effect using essentially the same mechanism. 
Can't claim any relation to the code, but I see no reason to plan for "what if". Besides hopac is relatively recent addition, I'm sure they will figure something better. Wouldn't be surprised if they end up dropping async and it's there just for backwards compatibility until the users finish migrating. 
To me it's not really a 'what if' after the same pattern has been used twice--it's time to factor it out so we can use drop-in replacements in future without preprocessor directives everywhere. Also, I would be surprised if the Freya people were to drop `Async` for Hopac entirely, given that the Hopac author doesn't seem to promise anything in terms of support or responsiveness (not laying blame or anything, just it's difficult to justify replacing a .Net standard API with an unsupported open source equivalent--unless the Freya people themselves take on the responsibility of Hopac support).
OK, so in my haste to ignore OOP I forgot about the most direct way: `module Void = type t private () = class end`. IOW, an empty class with a private constructor, so it can't be instantiated.
Hello, this is my own blog post. I wasn't sure about how I'd go sharing this so I just posted it here. Any feedback is highly appreciated!
Type providers make for a very slick demo. If I were using something like this in a production app, can I get the code to compile even if the external site was unavailable? Eg by using a local copy of the HTML when compiling on a CI server?
Yeah, it feels really weird when using non-headless web drivers; the browser just opens up and things magically happen before your eyes (fields fill up with text/buttons get pressed). You can even manipulate tabs and take screenshots!
 type Prop = | A of string //some literal being an atom | Dis of Prop * Prop //Disjunction of 2 atoms | Con of Prop * Prop //Conjunction of 2 atoms | Neg of Prop //Negation of an atom let isConsistent = let rec fix f a = f (fix f) a fix (fun dissect -&gt; function | A a -&gt; Set.singleton a, Map.find a | Dis (p1, p2) -&gt; let (ls1, f1), (ls2, f2) = dissect p1, dissect p2 in Set.union ls1 ls2, fun ls -&gt; f1 ls || f2 ls | Con (p1, p2) -&gt; let (ls1, f1), (ls2, f2) = dissect p1, dissect p2 in Set.union ls1 ls2, fun ls -&gt; f1 ls &amp;&amp; f2 ls | Neg p -&gt; let ls, f = dissect p in ls, f &gt;&gt; not ) &gt;&gt; fun (ls, f) -&gt; Set.toList ls |&gt; fix (fun table -&gt; function | [] -&gt; Map.empty |&gt; Seq.singleton | l :: ls -&gt; seq { for tt in table ls do for v in [true; false] -&gt; Map.add l v tt } ) |&gt; Seq.exists f Con (A "a", Neg (A "a")) |&gt; isConsistent |&gt; printfn "Consistent: %b" This checks if the proposition given to isConsistent is satisfiable.
Aww man , I truly appreciate your help! Your solution works! I hope you have a nice day!
so what happens precisely at the &gt;&gt; before the fun (ls, f) ? I can't see it for myself clearly.
&gt; e function split up into its components... d yes it does ! Thank you very much sir! 
I don't know what you mean. Can you clarify?
Out of curiosity, since you mention propositional logic, have you studied type theory? In type theory the proof of 'p &amp;&amp; not p is inconsistent' is the following: module Void = type t = private T of t // val proof : ('a * ('a -&gt; Void.t)) -&gt; Void.t let proof (a, not_a) = not_a a If you're interested, [here's](http://gciruelos.com/propositions-as-types.html) an introductory article. But the gist of it is, `*` at the type level is conjunction, `Void.t` is non-existence, and `-&gt;` is implication.
.net is. F# runs as part of that
There is another way: exceptions. In OCaml the `exn` type was designed to work like an extensible discriminated union type: whenever you'd declare a new exception, it would get added to the known overall list of exceptions that could be matched against. F# has largly preserved these semantics by cleverly layering them on top of OOP inheritance: the `exn` type is an alias for `System.Exception`, and newly-declared exceptions are subclasses of `exn` that can be matched with the same `try ... with exn1 -&gt; expr1 | exn2 -&gt; expr2 | ... | exnn -&gt; exprn` syntax as in OCaml. To put it concretely, your module exceptions would look like this in OCaml 'style': module Download = exception Failure module Application = exception Invalid_arguments exception Inputfile_corrupt // No need to redeclare Download_failure, it's already known as Download.Failure Now, I have to point out two flaws of exceptions: - They're not statically guaranteed to be handled. Sum types are, mostly. - Performance could be an issue. Jon Harrop [reports](http://fsharpnews.blogspot.ca/2012/09/performance-of-compiler-translated-from.html) extensive use of exceptions was a bottleneck in an app he ported from OCaml to F#. But--unless you're raising and catching exceptions continuously in hot loops, I wouldn't really worry about that.
Linux is. OCaml runs as a part of that.
1. I work with Mono full time (mostly) and have written a few apps with it that are in production. There are some issues but Mono is still a perfectly viable option if you want to use Linux. Python, Ruby and PHP power a lot of the web and back end services and they aren't exactly known for their speed. The speed thing can get really overplayed. I used to worry about it but for most LOB apps how many users and concurrent requests are you likely to have? If you're writing the next Twitter then you might want to go with something else but for most apps and services Mono is fine. 2. I've left .NET Core as its a moving target. It's probably more performant than Mono but the tooling isn't there and the .NET Core team are still making changes (project.json with ASP.NET as one example). 3. Yes (at least I'm pretty sure). Mono and .NET Core are independent of each other. If you want to run F# with .NET Core that shouldn't conflict with your distribution's installation of Mono. 4. I know there's tooling for most of the editors for F# but with .NET Core I'm not so sure. Ionide is the project for delivering code completion to the editors but I've not used it with Core.
"Linux" as such doesn't provide much library / framework support, so you are stuck with stuff written in OCaml or FFI
Yes, very much this! I get that it's easy enough to show the signature in most IDEs by putting the cursor there, but that is still much slower than just being able to move your eyeballs. Also that option isn't available if you're trying to read code on GitHub. 
Hi, I'm the author. Happy to discuss suggestions or answer any questions.
I find often it's easier to write a function if you already have the type signature you're writing against.
I think part of the idea of ROP is that it's encoding monadic exception handling using an explicit type that doesn't break the deterministic control flow of your code. Another key point is that you are forced to 'handle the exception' by usign the type, rather than hoping that you remember to wrap everything in `try`blocks Would it not be the case that using exceptions goes against the principle of what the OP is trying to achieve with the `Result` type?
I understand the tradeoffs (I mentioned the static guarantee briefly), I just wanted to point out that there's traditionally another way available in the ML world.
Any idea why most posts aren't getting the default link thumbnail? I've done a little googling without any great success.
I found the koans of F# very helpful in teaching and learning
I am trying to do gui programming on linux. It is a rather painful experience, since it lacks documentation and I don't know C# well enough to be able to port examples without trial and error. Any pointers are welcome.
I've had a little bit of success (though I haven't had much time to play with it in any depth) using https://github.com/picoe/Eto from F#. It lets you do truly cross-platform GUI programming, wrapping the native libraries on each platform so your GUI "looks right" to WIndows, OS X and Linux users. However, the only place I've found F# samples on using Eto is in Eto's Visual Studio plugin, which means Windows. While the VS Code + Ionide IDE experience is very good on Linux, to my knowledge nobody has yet included the Eto sample projects in the project templates that Ionide gives you. So depending on whether you also have a Windows machine available to you, Eto may or may not be a good solution for you.
I think the prize for "shortest quicksort implementation ever" is still held by APL, along with the prize for "most unreadable quicksort implementation ever" (they just stuck both plaques on the same trophy, since it's unlikely that anyone would ever manage to come up with a shorter implementation that was actually readable): Q←{1≥≢⍵:⍵ ⋄ S←{⍺⌿⍨⍺ ⍺⍺ ⍵} ⋄ ⍵((∇&lt;S)⍪=S⍪(∇&gt;S))⍵⌷⍨?≢⍵} Source: http://www.dyalog.com/blog/2014/12/quicksort-in-apl/
I've been working on this with Eto if you want to take a look at how I structure things https://github.com/kaeedo/Cursed
What library are you using to train the net? I am guessing you rolled your own in NeuralFish.
Blog post author here The library used for training is [NeuralFish](https://github.com/JeremyBellows/NeuralFish). [This is the NeuralFish function that is used in the prototype to process the training](https://github.com/JeremyBellows/NeuralFish/blob/6e7be4759e961e6a7084b859ae0615eb173eb4d4/NeuralFish/EvolutionChamber.fs#L765) 
Nice, thank you. 
I'm coming from Python and C# and I haven't used Jupyter. I'll look into it, thank you!
Oh really? (I mean you really didn't use Jupyter with Python?) Jupyter is incredibly useful, at least in conjunction with Python. Unfortunately, it is a little bit difficult to explain why you might need it. It necessary to try it and understand why it is so different experience from editor coding. I would say it is like use REPL on steroids. You have ability to see all your history clearly and with possibility to rewrite everything back. In the same time, you already have your values in memory so you dont need to run all your code over and over. You can save your notebooks, publish them, rework them etc. For example, I used Jupyter notebook for web scraping. In IDE I saved html file locally and then I load them into memory every time. Using notebook I just made cell with loaded page in variable. Then, I made another cell and started to experiment. No need to load content again and again. Not to mention that Jupyter is irreplaceable tool for data, math and other scientists. Check it here: http://jupyter-notebook.readthedocs.io/en/latest/examples/Notebook/examples_index.html PS: Jupyter supports more programming languages: https://github.com/ipython/ipython/wiki/IPython-kernels-for-other-languages 
I'm a maintainer for FSharp-Charting and tinkered with the porting process of IFSharp from ipython to Jupyter. I think Jupyter/IFSharp has a lot of great potential for interactive demos, and would love to see us step up from the default FSharp-Charting charts to an SVG plotter (or even an extension of FSharp-Charting that exports as SVG, maybe [this](https://github.com/tpetricek/FSharp.SVG/blob/master/svg.fsx) is a good starting point). Also, one or two killer demos in IFSharp along the lines of the Gamma Project or FSLab would be a great step forward. 
We have support in IFSharp for XPlot (https://tahahachana.github.io/XPlot/) which is capable of producing SVG outputs. There are some examples in the sample "FSharp for Azure Notebooks" at https://notebooks.azure.com/. The save buttons will give you a PNG but it's also possible to get the SVG out directly. We're always looking for more contributions on the IfSharp project https://github.com/fsprojects/IfSharp Disclosure: I work at MSR and contribute to the F# kernel for Jupyter.
F# doesn't have function overloading, but it has match guards, which are equally if not more compact. let get_cost = function | value when value &gt; 100 -&gt; // do some work | value -&gt; // do some work 
This was extremely helpful!
I have never used build.sh to make my vscode work with ionide. What is your problem exactly? 
I am confused. On windows I just download and installed bundled F#, put fsharp to PATH. I installed VSCode. In extension installed ionide, paket and fake. Thats all no build.sh used. What steps you are talking about?
Looks like I'm way behind the curve on IFSharp chart support. Thanks for the info!
remove the `;;` in `comment`. 
Still writing Procedural Graphics in F#. The Heightmap and mesh generation was written in F# for https://www.reddit.com/r/proceduralgeneration/comments/5g2qcg
I'm doing a modern download manager/accelerator with additional features such as searching for open directories and integration with reddit. I'll be releasing a new version soon with support for FTP. Check it out. &amp;nbsp; Web site:[moonstarsky.com](http://moonstarsky.com) and [screenshots](http://moonstarsky.com/screenshots/)
I'm on OSX.
OK, this is not something I can help you. It is pity. I dont know about Sublime but I would prefer VSCode over Xamarin. Good luck anyway.
 Thanks. It worked. The compiler was pointing that error was in this function: let parseINIString&lt;'T&gt; : Parser&lt;INIValue, 'T&gt; = parseQuoted &lt;|&gt; anyText2 |&gt;&gt; INIString
I'm guessing the `;;` ended the `module &lt;x&gt; = ` expression, so then the parser just saw let functionA = foo let functionB = bar which is an incomplete expression outside of a module. (one of the "inconsistencies" of F# is that a let-expression in a module is a definition but a let-expression otherwise is an expression and requires a body)
The Azure Notebooks team has posted some details on here: https://news.ycombinator.com/item?id=13104200 For the F# kernel itself then the GitHub page is the best location to ask (as I've seen you did) or contribute.
I've got to say looking at testing support for F# (.NET Core) was pretty frustrating and disappointing. I get that F# is very much down the pecking order for .NET and support would be behind a bit, but I'd hoped something as mature as xUnit (given its pre-core history) would be a lot better, and certainly better documented. It also left me wondering if I'm going about this the wrong way. Should F# be tested in this fashion? And has anyone got ideas on F# unit testing frameworks - particularly those supporting .NET Core?
Creating your own testing library in F# is really easy so I generally just write my own. I generally write code on OSX so I don't need a GUI runner, and I prefer to run from console on Windows also, which removes almost all of the complexity. I wrote my own for canopy: http://lefthandedgoat.github.io/canopy/ prunner is stand alone and parallel (no UI automation bits) https://github.com/lefthandedgoat/prunner This shows how I tag tests so I can run subsets of them https://github.com/lefthandedgoat/canopyStarterKit/blob/master/canopyStarterKit/Tests.fs It works really well for me, and many of the people who have used it find it acceptable. Everywhere I have worked there is always one person who wants VS integration though. Hope this helps.
Thanks on the module gotcha - it's interesting to uncover the details of the language :)
Yeah I guess writing something that can find some test methods and run them is pretty trivial. Coming from my enterprisy background the thing I'd be worried about (eventually) is code coverage tools which are very nice to have when 'the big refactor' starts out.
&gt; This lack of attention to documentation is a disappointing and but fairly expected consequence of being open-source. Literally stopped reading at this point. Incidentally, I'm all up for jumping on the bandwagon as much as the next guy, but I've seen no good reason to move on from NUnit 2.6.4. Documentation is there and has served me well enough, it's well understood, works on Mono/Linux and integrates with every tool, service and library out there. The same can't be said for others, though there's a couple of additional features in NUnit 3 that I may need one day. Incidentally I'm using unquote for F# to add in some much needed type safety. 
And perhaps with the amount of blog posts I get through on reddit I was a little hasty to dismiss the rest of the article. To be clear though, having read back my comment, I wasn't suggesting you were jumping on the bandwagon. Certainly my head has been turned a little by xUnit on more than one occasion and .Net Core moving to it certainly seems to give it some additional credence. But I just haven't seen any compelling reasons to move away from NUnit 2 for me personally, which is a shame because I do like seeking out new and better ways of working.
For those wondering, [LambdaConf takes place on may 25-27 in Boulder, CO (USA)](http://lambdaconf.us/#events#lcusc).
Coincidentally, I started using SQLProvider with Postgres yesterday. I also didn't want to have the DLLs stored somewhere locally, so I just installed Npgsql with Paket, passed an empty string to `SqlDataProvider`, and everything seems to work just fine. I'd recommend trying that, either with Paket or NuGet. Edit: As an addendum, if you explicitly name arguments and omit the resolution path arg like let ConnString = "Host=localhost;Database=postgres;User Id=postgres;Password=postgres" type Sql = SqlDataProvider&lt; ConnectionString = ConnString, DatabaseVendor = Common.DatabaseProviderTypes.POSTGRESQL, CaseSensitivityChange = Common.CaseSensitivityChange.ORIGINAL&gt; that works as well.
It is a programming language aimed at making (or at least simplifying) verified programs, ie: formally verified correctness of a program. This lets you avoid a whole bunch of errors (but some remain) and is really useful in places where formal correctness is a big deal(tm) like crypto protocols. It compiles to f# and JavaScript iirc.
It's a research language aimed at formally verifying code using the technique of dependent types. It compiles to F#, and I've never tried it out, so can't really comment on performance. But from what I've read, they're positioning themselves as a language fit for general use now, much like Idris (which is similar but comes from the Haskell ecosystem).
"This application is written in F# so it takes some time to start first time" - I don't get the inference here...
&gt; compile times can be very long. Yeah, I'd expect that to be the case as the program needs to be checked exhaustively using a constraint solver. Another problem is that formally proving even simple programs is quite difficult. Well, while formal proof systems have been around for a while - ML which F# derives from started out as a proof system - using dependent types for general purpose programming is quite new so I am willing to give them benefit of the doubt for now. There are many other language features I'd rather F# have though.
*Sine ira et studio* after few gulps of vodka :) Allow me to humbly suggest not to start flamewar **f# vs python**. I do not intent to evangelize Python on F# forum. My intentions were to correct some false accusations against Python but, apparently, this is never-ending story. Firstly, allow me to humbly present my current standpoint. IMHO, there is no doubt that F# is slightly superior to Python in some aspects. Remember the "slightly" word please. This is not the same as to compare F# to C# :) or Python to PHP (Yuck!). Secondly, I understand the necessity to be a little bit a rigorous fanatic when it comes to defend your favourite language but actually, this is not valid point here assuming we are all "so into F#" girls and guys. Thus, we dont need to close eyes to uncomfortable truth. Thirdly, allow me to boldly deduce you are not familiar with Python. If you were you would probably not pick code which shows exactly opposite of what you intended: [| 1.0 ; 3.0 ; 4.0 |] |&gt; Array.map f |&gt; Array.sum This exactly why I found Python a little bit shorter. Please compare to: sum(f(x) for x in (1,2,3)) About introspection. So far as I know there is no easy way to make introspection in F# interactive shell. Allow mi to clarify myself: def add(x: int, y: int) -&gt; int: "This is simple function" return x + y &gt;&gt;&gt; help(add) Help on function add: add(x:int, y:int) -&gt; int This is simple function Lets do us a favor and stop thinking hard how to explain that you have all of this in your IDE. Thats not the point, really. Digging deep in my example you can see I am using type annotations similar to F#. You can stay calm they are completely ignored in runtime and seemingly useless except for documentation. In fact, using these annotations you can mimick static typing - see my link to mypy library. So far as I know, PyCharm is able to check your type in the same manner. Again, it is not that perfect as F# but technically almost the same. Trying: add("d" + 1) has red error underline as expected. The only difference is that F# wont compile while Python fail in runtime. I am tired of static typing arguments. It is not even funny anymore. Needless to say, PyCharm is able to infer types from contex without annotations. Again, it works similar as F# compiler. And again, F# has upper hand here. BTW, mentioning *null exception* is totally outre when speaking of Python. There is not *null* like C# has. Python has only None but if you read carefully module [typing](https://docs.python.org/3/library/typing.html) you will find: typing.Optional Optional type. Optional[X] is equivalent to Union[X, None] I dare you to say it is not something what F# does. For example, if any Python object is of type *str*, there is no way to be *None*! Mind you I am talking about object, not variable name. Python works differently from static typed languages. Variable has no type, object has type. This might be confusing for you. Hopefully, I have covered the light side of modern Python, so lets carefully step to its dark side. The truth is that type hinting is new construct, practically not adopted by Pythonistas. All libraries I checked so far are relicts from Python 2 and type annotations is practically uknown. Before mentioned **mypy** is far from being cool enough which I tested personally :) Since I am not user of PyCharm I cannot judge this IDE but it might be pretty good. Finally, allow me to explain why I dislike seeing negative comments from Fsharpists fo Pythonistas. Actually, I believe there are a lot of good Python programmers who might be seduced by beauty of F# (as I was). The seduction should not be performed by calling "Hey, your beloved language sucks, come to us!" but rather by gentle alluring "My dear, you might find interesting this very language which has syntax inspired by Python. No stupid brackets I promise. More functional if you care. Compiled. No GIL." HOWGH :) 
Adding dependent types to F# would change the language at its core. It is not the kind of thing that can simply be bolted onto the language. Don Syme, the creator of F#, remarked that dependent types are beyond F#'s [intended purpose](https://fslang.uservoice.com/forums/245727-f-language/suggestions/6062821-add-dependent-types). If you want to see what dependently typed programming is about, I'd recommend you check out [Idris](http://www.idris-lang.org/) as it seems to have the most comprehensive tutorial. Agda also has a [free book](https://svn.divms.uiowa.edu/repos/clc/projects/agda/book/book.pdf). Finally, if you want to see how difficult theorem proving with dependent types is, try Coq and go through some of the problems of the [Software Foundations book](https://www.cis.upenn.edu/~bcpierce/sf/current/toc.html). What happened to me is that I wanted dependent types for a while and then after giving learning the above languages a good shot, I wanted them less.
Don't know
1 point: You can start several heavy computational threads in Python. If you look at processor cores you will see that only one core is working. 3 point: newName = "someName" - and then somewhere - newNam = "anotherName". Here a new variable will be created (and you simply misspelled variable name). And variable newName continues keeping old value.
My god...I've been doing python for so long and my only gripe was having to manually document types in docstrings - you just changed everything for me! How did I never hear of this! Thank you!! On a side note - IronPython has no GIL...
Working on an MMOSPACERPG. In the spirit of TW2002 but with some 3D graphics. Mix of C# and F#, using MonoGame: https://twitter.com/PerlinMandleBro/status/807313611106480128 
I do not think that writing code in F# should be inherently slower than in those other languages. F# is not Haskell and for these kinds of problems you can emulate the style you would use in Python or C#. Given that, you should ask yourself why are you slower in F# than Python for example?
About 10x faster in F# than C# for me in general but I don't write anything as small as 8 lines. Here's my F#: let rotate isLeft (dx, dy) = if isLeft then -dy, dx else dy, -dx let move n (x, y) (dx, dy) = (x+n*dx, y+n*dy), (dx, dy) let dist (input: string) = (((0, 0), (0, 1)), input.Split([|", "|], System.StringSplitOptions.RemoveEmptyEntries)) ||&gt; Seq.fold (fun (p, d) s -&gt; rotate (s.[0]='L') d |&gt; move (int s.[1..]) p) |&gt; fun ((x, y), _) -&gt; abs x + abs y dist "R5, L5, R5, R3" A seriously boring challenge, IMO. It is basically an interpreter for a machine code with just two instructions. A Brainf*ck interpreter is a lot more interesting and not much more complicated... 
Are you the OP? At any rate, for this problem it took me a bit more than half an hour. It only took me 15 minutes to code up the following and it was correct the first time I tried it, but I messed up and read the problem description in the link above and my mind started thinking about how to solve it rather than work, so I had to spend some time doing it. Damn it Reddit. It came out a bit longer than I'd like, I'd be curious to see how you did it in Python. // For http://adventofcode.com/2016/day/1 let input = "R3, L5, R1, R2, L5, R2, R3, L2, L5, R5, L4, L3, R5, L1, R3, R4, R1, L3, R3, L2, L5, L2, R4, R5, R5, L4, L3, L3, R4, R4, R5, L5, L3, R2, R2, L3, L4, L5, R1, R3, L3, R2, L3, R5, L194, L2, L5, R2, R1, R1, L1, L5, L4, R4, R2, R2, L4, L1, R2, R53, R3, L5, R72, R2, L5, R3, L4, R187, L4, L5, L2, R1, R3, R5, L4, L4, R2, R5, L5, L4, L3, R5, L2, R1, R1, R4, L1, R2, L3, R5, L4, R2, L3, R1, L4, R4, L1, L2, R3, L1, L1, R4, R3, L4, R2, R5, L2, L3, L3, L1, R3, R5, R2, R3, R1, R2, L1, L4, L5, L2, R4, R5, L2, R4, R4, L3, R2, R1, L4, R3, L3, L4, L3, L1, R3, L2, R2, L4, L4, L5, R3, R5, R3, L2, R5, L2, L1, L5, L1, R2, R4, L5, R2, L4, L5, L4, L5, L2, L5, L4, R5, R3, R2, R2, L3, R3, L2, L5" |&gt; fun x -&gt; x.Split([|", "|], System.StringSplitOptions.RemoveEmptyEntries) |&gt; Array.map (fun x -&gt; x.[0], int x.[1..]) type State = | North | East | South | West let turn d s = match d with | 'R' -&gt; match s with | North -&gt; East | East -&gt; South | South -&gt; West | West -&gt; North | 'L' -&gt; match s with | North -&gt; West | East -&gt; North | South -&gt; East | West -&gt; South let go_forward s num_steps (cur_x, cur_y) = match s with | North -&gt; (cur_x, cur_y+num_steps) | East -&gt; (cur_x+num_steps, cur_y) | South -&gt; (cur_x, cur_y-num_steps) | West -&gt; (cur_x-num_steps, cur_y) let (_,(end_x, end_y)) = Array.fold (fun (state, cur_xy) (lr, num_steps) -&gt; let s = turn lr state (s, go_forward s num_steps cur_xy) ) (North,(0,0)) input let result = abs end_x + abs end_y Edit: A shorter solution than the above is possible by using degrees instead of states for directions.
That depends in how fluent your are, and if the task at hand play at the strengths of the lang/libraries you have. I have learned (and use in production!) FoxPro, Delphi, Python, VB, VB.NET, C#, F#, Swift, Obj-c, Sql, Js.... I'm more productive in python and delphi. C# take me more time (even more than Vb.net!). I'm slow at swift than obj-c because is, with F#, the latest language I have learned, but not chance in hell swift will be slower than obj-c in the near future. F# trow me because is the most different from the bunch. The type inference is my enemy! I don't like it. I prefer if F# force to annotate the types manually, like Pascal/Delphi. Why???? Because that is how I think. Some langs fit your way more than others, so that biased your perceptions. However, where I can use AGDT and pattern-matching I fly in contrast with other languages. SLow me is when I try to use more imperative code and slow me more when I try to use more functional code with mix of uncommon conventions (according to *me*). So, if a lang is way different to your normal way of work, expect to be more challenging. 
I've never tried TypeScript. What is so great about it?
My background: I got a few things done with VBA, wrote many useful PowerShell scripts, used Clojure for fun in coding exercises and a couple of toy projects. Only then (2 years ago) did I start working as a developer doing C# and some JS. I did not enjoy C# but it was my first real statically typed language, and I could see the benefits of static types when working in a team. During this time, I also learnt F# and have found it to be my most productive language yet, even for one off scripts, except for certain things that can be handled with a long but terse PowerShell one liner. It didn't take long for me to be more productive in F# than C#. The first reason is that C# forces some structure - classes and methods - that you don't always want to think about up front. And C# also has much more verbose syntax. Even now, I often mess up when writing new classes and methods: e.g. `public string MyFunction&lt;T&gt;(T a, int b) {` vs `let myFunction a b =`. The syntax means that F# programs/scripts fit into fewer lines of code and look less noisy. This makes it easier to keep a mental overview of the whole program and how the parts fit together. These are some of the advantages of F# for simple programs. As you start to get to less trivial ones, the usual correctness benefits of F# over C# obviously come in to play and have a much greater impact on overall productivity (defined by time to produce correct and maintainable code). **Tooling**: In my experience, when I get about 10 minutes into writing a program I start hitting lots of really silly errors that would be easily caught by static types and/or tooling. I haven't really worked in a dynamic language with good tooling but I imagine your editor could catch misspelled functions, misspelled variables, invalid syntax etc. Catching type errors on top of that is a nice bonus. It's not just just the fact that you get compiler errors, but exactly how they are presented. So to be clear, I write F# in Visual Studio and I love the fast feedback of having errors underlined in place as soon as I have made them, and good auto-completion, and hover tips with inferred types, and a REPL window that I can run any bits of my code in. It's only really with these features that I find F# to be so productive. Without such features, I'm not sure if the benefits of static types would outweigh the cost for nearly as many situations. Disclaimer: In C# I've mainly worked on web apps and F# has been mainly personal projects/exercises, so that will colour my comparison. I've not had the chance to do more serious work in F# but I will do soon :)
If you haven't seen it in other languages it might be hard to explain. Basically you union your languages and you intersect their interpreters. It's a pretty advanced technique, and I wouldn't start there if I were you. That said, my Scala link is a great presentation of the idea.
I don't have a TypeScript code example offhand, sorry :( I've also never dug into finally tagless style, though I guess I'm going to need to do that now that you've mentioned it. &gt;The only real question that I have now is how could I have missed this? You'd imagine that Haskellers and Scala-ers would be all over this, so what is the catch? * The machinery required to do this in Haskell and Scala is gross. Like [Hacking Generativity into Rust](https://curve.carleton.ca/system/files/etd/05076cd2-c1c2-4207-9667-a3ee1af58db4/etd_pdf/60a59a782199a35d15b63e1fcf16eb98/beingessner-youcantspelltrustwithoutrust.pdf), [C's Duff Device](https://en.wikipedia.org/wiki/Duff's_device), and [list chunking in Python](https://www.stavros.io/posts/brilliant-or-insane-code/). It takes mild stubbornness to use this pattern, and chutzpah to actually submit it into code review. * UI-centric TypeScript code is often done in FRP style (React, etc) which I'm not sure composes very well with this idea. * The theory overhead is pretty high here, compared to something like Angular's dependency management which hides all of this from you.
Fake should set up the project file so the native assembly is copied to the correct directory. I've used sqlite with paket before in production.
I'd like to see a comparison between this style and what are the benefits versus a classical piping. I find this a lot more easy to read: let request (url: string) = url + "?api_key=dc6zaTOxFJmzC" |&gt; (fun url -&gt; new HttpRequestMessage(HttpMethod.Get, url)) |&gt; (fun (req:HttpRequestMessage) -&gt; req.Headers.Add ("Accept", "application/json") req) |&gt; makeHttpReq |&gt; Async.bind (fun res -&gt; res.Content.ReadAsStringAsync () |&gt; Async.AwaitTask) |&gt; Async.map (fun res -&gt; Regex.Match(res, "\"url\":\"(.+?)\"").Groups.[1].Value.Replace ("\\", "")) |&gt; Async.map Process.Start request giphyTrending |&gt; Async.RunSynchronously Here I can see exactly whats done to my input and my output. It has a flow to it that makes it much more easily understandable to me.
What I do is configure a Task to run a FAKE script which executes NUnit tests. Although, calling NUnit.ConsoleRunner from a task would also work. That's actually one of the few things I miss in VSCode: A GUI Test runner. Between that and having multiple windows for the same workspace and a debugger on Windows is keeping me from uninstalling full VS 
Another one? Why not use Paket?
Totally agree, I still have respect for building that and yea, looks cool. But I miss the WHY section in the README. All READMEs should contain WHY sections :)
Have you checked out Argu? It could help with some of the command line parsing logic in your code
The first one. It is really good.
I think it would be more beneficial to contribute these features to Paket than to fragment the user base.
&gt;Elm still seems the sensible solution if you have a team of people that are learning functional programming. Elm has a lighter cognitive load, since there's almost only one way of doing it, and the defaults are very good, making it a great learning tool as well. I agree with this strictly in terms of learning FP, but I think Fable's interop is going to be much more valuable in the long run to reuse existing code and the wealth of third-party JS libraries.
I tend to agree with that too. Let's see what the future brings! :)
&gt; Not everything needs to be in paket - it's ok to do small command line apps that complement the functionality. Yes. But with this project I want to test and develop new ideas quickly. It is first and foremost an experimental project and hope that someone take those ideas or some of them. &gt; It starts to get more questionable if we start to get pget.lock and pget.dependencies though ;). I will make this be compatible with existing tools. Pget is just an alternative interface to NuGet.Core library that is the same library used by Package manager console and nuget.exe client. I just leveraged it with F#. It is the same as use nuget.exe, however with a better and more meaningful command line interface. - Pget.fs - Is just a F# high-level interface for NuGet.Core that makes this library more functional-friendly. - PgetCmd.fs - Handles the command line tasks. I intend to build a [busybox](https://en.wikipedia.org/wiki/BusyBox)-like tool. With many utilities to automate and handle F# and .NET project in a single application that can be integrated in editors like VI and Emacs and also be command-line-friendly giving the maximum control possible to the user. &gt; Some of the features like dumping fsx references to stdout would seem like straightforward things to add to Paket though And also search packages and display metadata. I really don't understand why they didn't implement it. Python and ruby package managers can search packages, display metadata and so on. I just want the same functionality of pip (Python package manager) for an F#-package manager.
So it appears this is sort of like Babel plugins for F#
[removed]
As I mentioned, neither of our implementations are the 'full' finally tagless style, because you need higher-kinded types to encode the 'repr' type that holds values in the DSL of the TTFI 'expression'. Our examples can be seen as just using the 'identity' type as the 'repr' type. See e.g. (Scala) https://github.com/ypg-data/TTFI/blob/0059115ad514a961a1ea8bde8064143a682db346/ttfi-core/src/main/scala/sss/finals/Integers.scala for the actual finally tagless style. We're both encoding ordinary typeclasses in different ways. I'm using record types, you're using DU types. They're both equally static--no virtual calls in either. All calls are known at compile time. &gt; ... I am not forced to specify the types of functions in the datatype I'm seeing a bunch of functions in your datatype.
&gt; All calls are known at compile time. I guess I should check the IL to make sure. &gt; I'm seeing a bunch of functions in your datatype. I was not being precise with my language. By the above I meant the generic type parameter declarations is what I am not forced to do as they are implicitly defined.
[removed]
Hey, 40 is not middle aged! 40 is the new 30.
Unfortunately I don't have any beginner tutorials to recommend, there are probably some good ones out there. http://fsharp.org/ is a good place to start; you can also look at https://fsharpforfunandprofit.com/learning-fsharp/ As to your specific problem, fsharp code can run like python does, that is, compiling it on the fly from source. It can also run in a precompiled form (as a .net assembly packaged in a .dll or .exe). &lt;EntryPoint&gt; is only relevant for the latter. You could start writing your program in python style like this: // wc.fsx open System open System.IO let text = File.ReadAllText("sample.txt") printfn "%s" text I didn't actually count the words because you probably want to fill that in :) Anyway, you could run this program with "fsharpi wc.fsx" on a mac or "fsi wc.fsx" on windows. If "sample.txt" does not exist it will throw an exception. If you wanted the precompiled .net assembly form, the source would look like this: // wc.fs open System open System.IO [&lt;EntryPoint&gt;] let main argv = let text = File.ReadAllText("sample.txt") printfn "%s" text 0 // return an integer exit code You then build that with "fsharpc wc.fs" (on a mac) or "fsc wc.fs" on windows. On windows you can run the resulting .exe directly, on a mac you need run it with mono, eg "mono wc.exe". Fsharpi works like the the "python" command with no arguments, it starts interactive mode, you can paste code in there and see what Fsharp does with it. It helps to have a good editor to start. Visual Studio is obviously good for windows, and Xamarin is decent for mac. I haven't extensively used any of the other editor plugins. 
Sounds like you are on Linux or Mac. VS Code with the Ionide-fsharp extension is your friend for writing programs. Also fsharpi is great for working thru the concepts at https://fsharpforfunandprofit.com/learning-fsharp/ (Just don't put ;; after a in-line comment...) 
At first I was put off by the complicated title for this link and article, but I'm really glad I read it. I wonder how much this pattern is actually used in practice.
It's the any difference to using the new keyword or not, other than it simply being optional? 
Actually, what is presented in the article has been possible for a long time. What F# 4 added is the possibility to use the constructor as a first class function, for example `|&gt;`-ing into it or passing it as argument to a higher order function.
Like /u/eliquy, I also have this preference: * One namespace per project * One toplevel module per file * Toplevel modules may contain nested modules * Types inside modules Further, I like the OCaml style of naming a module's 'main' type just `t` and referring to it using its module as a prefix, e.g. `Person.t`. It's similar to the C style of appending `_t` to type names, like `size_t`, but for different reasons.
allways a treat.
These are some very useful tips for C# (and, god forbid, VB .Net) interop, I'll definitely be coming back to this page often. 
Compile time is OK, as the sample file is small, but I was getting OutOfMemoryException at runtime when trying to import any file larger than ~200 MB.
&gt; You can use the type provider to create the classes, but use a custom XML parser to parse the huge file. At that point it sounds like Visual Studio's "Paste XML as class" feature for C# / VB.NET would be more efficient/
Maybe you are already doing this, but you should batch up your jobs. My ETL processes run on batches of 500 rows (this is transforming between databases) and this prevents memory issues. Any aggregation is done database side for me, so it might be a bit more work for you; but using a stream/reader of some sort to import limited rows, or iterate over to build aggregates, would solve a lot of memory issues
Sorry for the late response, my job has me working like crazy, but no I am on Windows with Visual studio.
I am on Windows with Visual Studio, so I might skip the VS Code but thanks :) But I'm sorry I still don't understand, so if I have a bunch of code on top of EntryPoint, do I, and what do I have to type under EntryPoint to make it work? Everything I have tried (is wrong) but comes up with this error every time I hit 'start' to run the program in Visual Studio. http://i.imgur.com/CbNCPbB.png
Writing in VS as a script I can get Hello World to work. I can write in Python so I'm used to IDEs, it's just F# I can't figure out. 
To add to what hanpari said, you actually have an indentation error in another place. Notice that the `0` in that last line is not indented correctly.
It would be cool if you could share some code for your solution because I'm doing a similar with ETL and data sources from documents REST APIs and databases. Most open source projects I have been able to find have only been libraries and i have not been able to find many open source f# "applications".
If you mean reading XML sequentially wit XmlReader, I'm already doing that (take a look at other comments I wrote), but that removes the type provider from the story (again, explained in my other comments).
excellent article. SIMD works fine on doubles. does f# compiler turn recursive loops into code that the JIT will do array bounds elision on? i know thst iterating backwards prevents the jit from doing the elision, so that may be net slower.
In that case I would still need to have a separate type provider definition for all levels in the structure. Seems messy :-)
I think there is an issue in how type provider is parsing the structure (all at once), because when I moved from type provider to using XElement directly there were no memory issues.
[removed]
Consider that a classical ETL approach like SSIS or Talend would require you to define the schemas of all your data sources anyway, and they would be inside the opaque ETL jobs; so either way you're dealing with defining types. It's just that in F# the types are low-ceremony, easier to understand, and easier to diff since they're stored in the repo. Now, your main problem is that you're dealing with highly denormalised data. Let's say, (F#) e.g., type address = { id : int; street1 : string; street2 : string; city : string; postal : string } type person = { id : int; age : int; addresses : address seq } type organisation = { id : int; addresses : address seq; people : person seq } So when you try to read an `organisation` it pulls a bunch of people and addresses into memory: could be tons of them. Loading even a single `organisation` into memory is a no-go. You're forced to do stream processing, but how do you disentangle the `people` and the `addresses` from your `organisation`s? To me it looks like you'll have to do normalisation while you're doing the streaming. So when you read an `organisation`, you'll have to write out a record for each `address`, a record for each `person`, and its contained `address`es. Then join them up with foreign keys etc.
int.TryParse(string, int) Edit, not out
The f# `int` function will convert from a string but it will throw if the input is invalid. &gt; int "3";; &gt; val it : int = 3
&gt; You come up with an abstract algorithm then think about how to implement it in a specific language. At the point you start actually writing code you already have a good/bad algorithm. Which language you choose to implement it in does not influence efficiency of the algorithm. Except the language choice might influence how easy is it for you to introduce new bugs. And, because of several facts (the time the language was developed, the intent of the developers, the inertion of backward compatibility), some languages are more difficult to write **correct** code in. In particular, in languages like C it is laughingly easy to write a code that looks like it works correctly (but it won't when the architecture, the compiler, the input data or some other random environmental variables change). To say more, some people turned this “feature” of C [into a sort of a programming contest](http://www.underhanded-c.org/). Mind you, the challenge is not to introduce the bug—it is to hide it in plain sight, or even make it impossible to debug. The biggest offender is **undefined behavior**, an artifact of how the language standarization in 70's and 80's worked. It is so sneaky because (1) it fails silently and in very specific circumstances, (2) when it does, it can lead to catastrophic results (when a compiler comes across one, it can **literally** do whatever it wants), and (3) most programmers aren't aware of its extent. For instance, undefined behavior caused by integer overflow [could be found en masse in various pieces of software, including common utilities, compilers and even in “safe integer” libraries!](http://www.cs.utah.edu/~regehr/papers/overflow12.pdf) So, when coding in C (or C++, which inherited most of that), even if you have a theoretically proven algorithm, even if you think you know how to implement it, even if you think you have tested it thoroughly, there might still be an obscure design flaw from before almost half a century that will cause your implementation to fail in some very specific circumstances. PS. And before you say, “but as long as I read the standard, I should be ok”, well… [even the authors of “The Annotated ANSI C Standard” couldn't get it right](http://www.davros.org/c/schildt.html).
[removed]
`Convert.ToInt32` will throw either a `FormatException` or an `OverflowException` on bad inputs.
You're looking for [`Math.DivRem`](https://msdn.microsoft.com/en-us/library/yda5c8dx.aspx). let quotient, remainder = Math.DivRem(dividend, divisor)
At that point, you probably won't be looking at the instantiation site to see that it has 'new' (especially since some other places have new as well). I probably just don't get it :)
I wanted to provide an update. [This article](http://blog.ploeh.dk/2017/01/03/decoupling-application-errors-from-domain-models/) by Mark Seemann might be of assistance. 
[removed]
[1;2;3] @ [4;5;6] -&gt; [1;2;3;4;5;6] If I've understood the question properly :) If not you might want to look into "zip" functions.
 let l1 = [0;1;2;3] let l2 = [1;2;3] let r = List.zip (List.tail l1) l2 // [(1, 1); (2, 2); (3, 3)] Maybe you wanted this? Edit: Reading your question more closely you wanted what /u/OolonColluphid wrote except with `let list3 = List.map (fun x -&gt; x::list2) (List.tail list1)` 
That is a damned good blog post! Great for experienced devs looking to try out the goodies, well done.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Welch t-test statistical performance testing • \/r\/fsharp](https://np.reddit.com/r/programming/comments/5mrsoc/welch_ttest_statistical_performance_testing/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Thanks for the feedback. There are way easier ways to get an f# project and tests up and running. Xamerin studio makes it much more straight forward. However, the aim with my post was to give more insight into the F# .Net ecosystem and to show a little bit under the hood how things piece together. I have also learned that unit testing f# in visual studio code is a lot more straight forward using the expecto tool which there is an plugin integration for. I plan to do a follow up post on this tool.
Thanks a million
Wow, this is really amazing. Nice work!
[removed]
Thanks. Will look to reword. Tricky to express properly and still be understandable for the layman.
It's better than it was a year ago. Almost every article or blog post assumed you had Visual Studio on Windows and were a C# professional. Now there's more folks writing about F# on Linux and Mac, coming from a non-.NET centric prospective.
It's .net specific not f#
This worked for me open System open System.IO open System open System.IO let readFile path = let document = File.ReadAllText(path) let length = document.Length printfn "length = %A words" length let wc () = let commands = System.Console.ReadLine() let command = commands.Split [|' '|]; match command.[0] with |"wc" -&gt; command.[1] |&gt; readFile | _ -&gt; printfn("Error, use the 'wc' command.") [&lt;EntryPoint&gt;] let main argv = wc () printfn "Press any key to continue" System.Console.ReadKey() |&gt; ignore 0 Your version did not compile, maybe it did not paste in correctly. I made `wc` take a argument of () so that you can invoke it in the main, instead of at the time of binding.
The '@' is for not escaping the characters in the literal string. It will work just fine if you use only 'filePath'.
https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/strings &gt; If preceded by the @ symbol, the literal is a **verbatim** string. This means that any escape sequences are ignored, except that two quotation mark characters are interpreted as one quotation mark character. So the @ symbol only makes sense when directly before a string **literal** (your second example), where it basically makes it more convenient to enter Windows paths with backslashes without having to escape them. In your first example the @ symbol is used before a name, which happens to be a string, and that doesn't make sense. Actually, the symbol is also used as an operator for list concatenation: [1; 2] @ [3; 4] [1; 2] @ [3; 4] = [1; 2; 3; 4]
By default, ctags doesn't have support for F#. The best I've found so far is using [Exuberant Ctags' user-defined language feature](http://ctags.sourceforge.net/EXTENDING.html) and copying [kongo2002's fsharp fsharp definition for ctags](https://github.com/kongo2002/dotfiles/blob/master/ctags). Pasted here if you don't want to follow the link. --langdef=fsharp --langmap=fsharp:.fs --regex-fsharp=/^[ \t]*let[ \t]+(rec[ \t]+)?([a-zA-Z][a-zA-Z0-9_]+)/\2/b,binding/ --regex-fsharp=/^[ \t]*let[ \t]+inline[ \t]+([a-zA-Z][a-zA-Z0-9_]+)/\1/i,inline/ --regex-fsharp=/^[ \t]*type[ \t]+([a-z]+[ \t]+)?([a-zA-Z][a-zA-Z0-9_]+)/\2/t,type/ It's not perfect, but it does a good enough job for me.
Thanks for posting this. I was really stuck badly for the last few days in my library until this post bubbled to the top of my consciousness. I have no idea what I would have done had I not seen it. I was sure that the problem I had either required metaprogramming or GADTs neither of which F# has, but it seems that [TypeShape](https://github.com/eiriktsarpalis/TypeShape) might fit the bill. Today was the only day I actually seriously considered moving from F# to Racket.
Oh, right. This actually returns number, so you can just make roll this: open System open System.IO let random = Random() let roll x = let number = int (random.NextDouble() * (float x) + 1.0) printfn "Your roll was: %A" number let rec selection () = printfn "Select which Die you want to roll: \n \n D4 - '1'\n D6 - '2'\n D8 - '3'\n D10 - '4'\n D12 - '5'\n D20 - '6'" let select = Console.ReadLine() match select with |"1" -&gt; roll 4 |"2" -&gt; roll 6 |"3" -&gt; roll 8 |"4" -&gt; roll 10 |"5" -&gt; roll 12 |"6" -&gt; roll 20 |_-&gt; failwith "fail" selection () [&lt;EntryPoint&gt;] let main argv = selection () System.Console.ReadLine() |&gt; ignore printfn "%A" argv 0 // return an integer exit code
Working, brilliant! Thank you very much. &amp;nbsp; Just before you replied I did manage to replace |_-&gt; failwith "fail" with |_-&gt; selection(x,y) Which allowed the program to restart if I was to say hit a number other than 1-6. I tried re-adding it and unfortunately it doesn't work, is there another way that you know of to stop a program from closing with hitting another number? It happens in another program I have to. 
`selection` no longer takes args, so instead of `| _ -&gt; selection (x, y)` do `| _ -&gt; selection ()`.
Thank you! It works perfectly now!
Adding an .fs file to your project will, SOON, get better in VS Code. There's a new feature in VS Code Insiders edition (which will become the official release in February) that allows plugins to create arbitrary tree representations of whatever they want, and the Ionide guys are watching the feature and working on a tree representation of your F# project. So once the February release of VS Code happens, start watching for Ionide updates: at some point very soon, you'll be able to *visually* add an .fs file to your project and move it up or down in compilation order. That should help a lot with the complaint in your last paragraph (which I also find to be one of the few remaining annoying things about working in F#: XML files like .fsproj are a pain to work with).
Thanks for the heads up!
Normally, you would do something like this let num3 = match num1, num2 with | Some num1, Some num2 -&gt; Some (num1 + num2) | _, _ -&gt; None
You can write a function that will translate any two argument function to work on optionals. let lift2 f a b = match a, b with | Some x, Some y -&gt; Some (f x y) | _ -&gt; None // val lift2 : f:('a -&gt; 'b -&gt; 'c) -&gt; a:'a option -&gt; b:'b option -&gt; 'c option Where "lift2" in this instance means "take a 2 argument function that works on a's and b's and make it work on Optional&lt;A&gt;s and Optional&lt;B&gt;s". You can then do: &gt; lift2 (+) num1 num2;; val it : int option = Some 3 &gt; lift2 (-) num1 num2;; val it : int option = Some -1 &gt; lift2 (*) num1 (Some 8);; val it : int option = Some 8 &gt; let concat a b = System.String.Concat(a, b) lift2 concat (Some "hello ") (Some "world!");; val concat : a:string -&gt; b:string -&gt; string val it : string option = Some "hello world!" Some [more info at fsharpforfunandprofit](https://fsharpforfunandprofit.com/posts/elevated-world/).
You're awesome. Thanks dude, big help.
None. 
You are entirely right. Should've tested it. Fixed :) 
optionSum a b = match (a,b) with | (None,_) -&gt; None | (_None) -&gt; None | (Some a, Some b) -&gt;Some( a+ b) from my phone so not totally sure that will compile :)
From the title looks promising. Is it to deploy functions firm the REPL or to trigger them from there? Could you add some info on the readme?
It only takes about ten lines to implement ;)
What does this do?
Super article! Written with clean words.
IronPython has had a lot of activity lately. I thought it had become abandonware but the project is now under new ownership and have requested to join the .NET Foundation. The last release was very recent, that's probably your best bet for integrating with F#. Interop can be a bit patchy (at least that's been my experience) and I tend to avoid.
If you are interested in ML, the [CNTK .NET Beta](https://github.com/Microsoft/CNTK/releases/tag/v2.0.beta8.0) bindings were released like just yesterday, so that might be a good bet. I haven't tried it. Apart from that, just for linear algebra .NET has its own libraries like [Mathnet](https://numerics.mathdotnet.com/).
I see what you mean. I noticed on R interop. That 's the problem when you like one language but the other has the libraries. I'll take a look at IronPython.
[removed]
I knew about Mathnet but nothing on CNTK. It seems it is a toolkit usable from Python or BrainScript. The only .Net interop features I was able to find were for using a trained model. Thanks a lot!
What an awesome little library. Awhile back I had taken [Midi.NET](https://github.com/jstnryan/midi-dot-net) to make a simple little app for drilling random chord practice on the piano... This F# library has all the knowledge of music baked in and would make it easier to expand that practice within Keys and modes, etc. I'm nowhere near as knowledgeable on music as the author, I guess we would just need to validate the truth of the code + tests, lest I use it to practice something incorrectly for years ;)
[removed]
Take it one step further and send the notes to supercollider! https://github.com/lefthandedgoat/bachfs
FSharpx.Extras provides a maybe builder exactly as you outlined above: http://fsprojects.github.io/FSharpx.Extras/reference/fsharpx-option.html It also implements lift2, and many other functions for working with Options. 
If you want to do numerical computations (al la numpy), then I think FsLab (https://fslab.org/) has bindings for R, so you could take a look at that perhaps.
It's not tags, but I use the vim-fsharp plugin, which gives proper ide type capabilities. 
Thank you for the suggestion I will have a look. No promises though :)
WebSharper is not just a compile-to-JavaScript solution, it also handles the server side (although it still needs to be hosted on top of OWIN or ASP.NET). [Check the docs here.](http://websharper.com/docs)
I've been enjoying Suave.DotLiquid lately. There's also a Suave.Razor package for using razor templates (from asp.net). https://suave.io/dotliquid.html 
Yeah, the issue to which you linked is a real bummer. However, you could always take this opportunity to teach them how to use various modules to build their work or, more simply, just put various functions into `*.fs` files and use the `#I`, `#r`, and `#load` functions to read everything in. Not being able to send &gt;1300 lines (isn't the actual number something like 1347?) is a bummer, but there are ways around that. I'd argue that the ways around it would be better for learning anyway. Also, good on you for adding a bounty with some value!
I've tried making a Cuda compiler in tagless style in F#, and it turns out you were right. Not just that HKTs were needed; if it were only that, my ideas could have worked, but it turns out that F#'s structural typing support works worse in practice than I thought, especially for nested polymorphic method calls with inlined functions. I ended up running into some compiler type inference bugs on the F# side - enough times to trigger my stop and declare the approach as non-viable even if in theory F# could do it with the feature set it has. I've argued in the past about F# not needing HTKs or typeclasses, but the experience of the past few months has really gone a long way on changing my mind on advanced type system features. Well, I guess whether the language needs them depends on the domain and it is really quite painful when you need and don't have them. Agh.
I have, and currently it is a pain to use. Async Actions are [not supported yet](https://github.com/aspnet/Mvc/issues/5570), so you have to use `Async.StartAsTask` everywhere. And Entity Framework migrations produce C# code which you have to manually translate to F#. You can use a separate C# project for EF, though. Furthermore, the [current F# compiler Nuget Package](http://www.nuget.org/packages/dotnet-compile-fsc/1.0.0-preview2-020000) is from June 2016, so pretty outdated and unstable. It can only be used with .NET Core 1.0, not the latest release 1.1. In the end, I gave up and used C# instead.
[removed]
Thank you, by the way.
I'm using it for trivial suave applications at the moment, but not relying on it for anything in production. Adding to NuvolaGrande's answer, there are still quite a few things not ready yet. Another big one for me is type providers. I prefer this method for database access with PostgreSQL and am currently looking for an alternative. Here is the related issue with a discussion by core people https://github.com/Microsoft/visualfsharp/issues/1496#issuecomment-244315047 It looks like since there is still ambiguity on wth is even happening with dotnet core (dnx -&gt; dotnet, project.json -&gt; msbuild, netstandard 1.X -&gt; 2.0) that people are waiting to see what the C# guys decide on finalizing on before throwing in a bunch of effort just to have to rework things later. It's funny to see how these projects change and see that it's not that different from places I've worked before. There is a lot going on and they're doing it in the open which is cool though. I imagine when things get settled, a lot of projects will migrate over to dotnet core. It _is_ the future.
Yeah, no problem. Is it working out for you? I haven't been doing much F# work lately, so I'm not sure if it's a viable long-term solution.
I would say that allPrimes is right. You just need to adjust a little bit your workflow. Your big code put into another file, make just import and call function you need. You dont need paket for this if you use scripting FSI directives as indicated. Actually, I dont think that your current way is something I would recommand to students :) 
What about ASP.NET MVC 5?
I think this is what we're going to end up doing quite soon. Thanks for the recommendation.
I am glad you were able to understand my English. It seems I had a bad day when I wrote that stuff :) Good luck.
A more functional approach would be to use a recursive loop. This way you are avoiding the mutable variable. Something like this: let private slowEquals (a: byte[], b: byte[]): bool = let isLess i = i &lt; a.Length &amp;&amp; i &lt; b.Length let rec loop i (diff) = if (isLess i) then diff else loop (i+1) (diff ||| (a.[i] ^^^ b.[i])) let diff = loop 0 (byte(a.Length) ^^^ byte(b.Length)) diff = 0uy There might be an F# function similar to Seq.initInfinite, that in addition to i receives the previous state. This would allow us to avoid the recursive call, which creates a somewhat confusing syntax. However, I am not aware of one, and since F# supports tail call optimization, the recursive call is not expansive at all.
Use `Seq.zip` to join the sequences then `Seq.fold` to reduce them.
ooooh, i like this, thanks for your help!
&gt; There might be an F# function similar to Seq.initInfinite, that in addition to i receives the previous state. There's `Seq.unfold`, although it doesn't pass the index so you would have to do it yourself. But I don't think it's a good way to go here anyway; I don't think it's a good idea to build a sequence just to iterate on it at the end. In the end it's just a more expensive way of doing the same thing as the recursive call. That being said, there is a function that _almost_ does exactly what we need here, ie. to iterate through 2 arrays together: `Array.fold2`. With it, we don't even have to bother with indices. This is what the code would look like with it: let private slowEquals (a: byte[], b: byte[]) : bool = let init = byte a.Length ^^^ byte b.Length let step diff ai bi = diff ||| (ai ^^^ bi) Array.fold2 step init a b But the problem is that it throws an exception if the 2 arrays have different lengths, instead of just stopping at the shortest like /u/buttlickk's problem requires. To work around this problem, we can just write a more lax variant of `Array.fold2` and use it in the function above: module Array = // It's generally ok to use dirty mutation in a helper function like this // as long as it's contained and invisible from outside (and well tested! :) let laxFold2 (f: 'c -&gt; 'a -&gt; 'b -&gt; 'c) (x: 'c) (a: 'a[]) (b: 'b[]) : 'c = let mutable res = x for i = 0 to min a.Length b.Length - 1 do res &lt;- f res a.[i] b.[i] res let private slowEquals (a: byte[], b: byte[]) : bool = let init = byte a.Length ^^^ byte b.Length let step diff ai bi = diff ||| (ai ^^^ bi) Array.laxFold2 step init a b Or we can use the more general `Seq.fold2`, which has the behavior we expect but might be a bit slower due to being more general and using iterators (I'm not sure how well it gets optimized by the compiler).
&gt; let delimiter = Array.init 1 (fun _ -&gt; ':') could be &gt; let delimiter = [| ':' |]
[removed]
Thanks for the info. While I enjoy the ability of type providers and what can be done with them, I've always felt more comfortable when I can predict the sql that will come out for complex queries. Dapper seems pretty stable, and provides just enough on top of ADO.NET/npgsql so that I can write type-safe queries, and still use database functionality like auto-prepared statements via npgsql. So far it has been working well for me.
I'm not entirely sure what is going on, but if I had to guess, I'd say that the normal Windows event loop isn't getting executed during the evaluation of helloSleep, so nothing is getting updated/repainted. You can achieve what you want using a Timer instead: open System open System.Windows.Forms let form = new Form() form.Visible &lt;- true form.Text &lt;- "F# Forms" let label = new Label() let message = "HERE YOUR TEXT" let timer = new Timer() timer.Interval &lt;- 500 let onTick (e : EventArgs) = match label.Text.Length with | n when n = message.Length -&gt; timer.Stop() | _ -&gt; label.Text &lt;- label.Text + string message.[label.Text.Length] timer.Tick.Add(onTick) form.Controls.Add(label) timer.Start() [&lt;STAThread&gt;] Application.Run(form) There might be a better way to build up the string in the onTick method.
Very thanks!
I just love how clear and concise this blog series is.
Thank you very much! :)
 let helloSleep = String.iter(fun c -&gt; label.Text &lt;- label.Text.Insert(0, c |&gt; string); System.Threading.Thread.Sleep 500) "HERE YOUR TEXT" This is all running "right now" before the label has even been added to the form. I find that using async is the easiest way to do things like this: open System open System.Windows.Forms let form = new Form() form.Visible &lt;- true form.Text &lt;- "F# Forms" let label = new Label() form.Controls.Add(label) form.Shown.Add(fun _ -&gt; async { for c in "TEXT TO APPEAR" do label.Text &lt;- label.Text + (string c) do! Async.Sleep(500) } |&gt; Async.StartImmediate ) [&lt;STAThread&gt;] Application.Run(form) This runs the label updating on the UI thread starting when the form first appears, but relinquishes the thread during the sleeps so the normal event loop can do its thing during that time.
&gt; When you inject impure operations into an F# function, that function becomes impure as well. I'm not so sure about this. The resulting function after partial application will be impure, yes, but the original function is still pure. It's not the original functions "fault" that an impure function was injected into it. You could theoretically inject CreateFileOnDesktop() into any function which accepts a unit -&gt; unit. Does that make it impure?
You can leverage `Seq.zip` and `Seq.fold` to make this a bit neater and more idiomatic e.g. let equalsIsh a b = let diff = Seq.zip a b |&gt; Seq.fold (fun diff (x, y) -&gt; diff ||| (x ^^^ y)) 0uy diff = 0uy To break this down: 1. `Seq.zip` pairs up the items in order from `a` and `b` and creates a new sequence of tuples. 2. We can pipe the result of the zip into the `Seq.fold` function, also passing to the fold function the arguments: `folder`, which is a function; and `state`, which here is a byte with a value of zero. 3. The `state` (initially zero) is passed into the `folder` function along with the first tuple (the first item from sequences `a` and `b`. The arithmetic is performed in the function and the result returned. This result is then the new state. 4. This new state (the result of the combination of the first item of each sequence) is then passed into the function again, but now with `x` and `y` being the values of the second item from each sequence. 5. This is repeated until the source sequences have been iterated to completion and the final state is returned and assigned to `diff`. 6. We then check if diff is equal to zero. If you're actually wanting to check if the sequences are equal, you can just use the following: let equals a b = Seq.zip a b |&gt; Seq.forall (fun (x, y) -&gt; x = y) Here, the `forall` function will exit early as soon as it finds a pair which are not equal, which is a handy performance improvement. Note: Seq.zip will throw an error if finds that one sequence is empty, but the other still has more elements remaining. If you want to verify the lengths are also equal, then you'll need to do that separately e.g. let equals (a : byte[]) (b : byte[]) = a.Length = b.Length &amp;&amp; (Seq.zip a b |&gt; Seq.forall (fun (x, y) -&gt; x = y)) 
Ah that makes sense. Sort of a forced way of marking the function as having side effects. Thanks!
Since none commented on this, rather than write let form = new Form() form.Visible &lt;- true form.Text &lt;- "F# Forms" you can set properties during initialization like so: let form = new Form(Visible=true, Text="F# Forms") 
Two courses for a major online training provider: * Automated testing in F# * Visual Studio 2017 and F# 4.1: First Look A talk called *A Gazillion Ways to Test With F#* for [F# eXchange 2017](https://skillsmatter.com/conferences/8053-f-sharp-exchange-2017-the-only-conference-in-europe-dedicated-to-f-sharp) Plus my day job which I can't go into in detail. :-)
Easy to follow example. Would like to see screenshot of the different file location in the folder and result of the test. Am I suppose to see the string at the end of the assert statement like "must be the same as basket total" because I don't see it in the test result whether it fails or passes. Took me a while to understand what you're doing with transforming the lines since I didn't see you dealing with multiple lines with the same product until I realized that you make sure that the basket can't have multiple lines with the same product to begin with. Also, you forget to add in the part where change the update function. Looking forward to the next part!
On a side-note and just for fun, you can change (fun (x, y) -&gt; x = y)) to ((&lt;||)(=)) Not that you should. You could, but you shouldn't.
Anything that calls impure stuff is impure. Offhand, I don't really remember needing to do di for pure stuff anyway. Injected stuff always needs to read or write something from the environment. Pure stuff can be done with statics
Quick take: It says on top that F# has "tens of thousands of user" (for comparison, VB has 100's of thousands). MS strives to be a data driven company, so they probably can't justify a "banking big" on F# before they have around 100k+ You know, "show me the numbers, then we'll talk" - never mind how good a pitch an F# fan can make for the language. I'm optimistic that F# is on the start of a good growth ramp. Not through any recent improvements in the language itself, but for increased validation .net overall will get when dotnetcore evaluations start outside MS loyal shops. Loyalists will likely stick to tried and true C#, for better or worse. Currently, we are in a bit of a lull, stuck between the old stuff slowing down and new stuff not being fully up to speed yet. MS current commitment level seems appropriate (or generous, even?) for this phase. 
Yeah, there is large thread (150+ comments on [hackernews](https://news.ycombinator.com/item?id=13544491) about this). Almost half of the thread mentions F#. I'm intrigued by this line in the post, &gt; We will make F# the best-tooled functional language on the market That's a pretty bold claim. I wonder how long it will take to pan out.
I hope they do. The language design is great compared to Scala, which I see as the main competitor.
Work: Nada F# I'm stuck supporting the older generation of our software and still have to use non .NET technologies. :( CTO saw my lambda calculus t-shirt which made for interesting conversion. Home: Trying to figure out some ETL code for dealing with dirty, wide, "CSV" files. Most examples and code I've found are toys. I need something that can handle 200+ fields in a text file that has been neglected by generations of uncaring government ungulates. 
I just began learning F# with the hope of creating a toy language+compiler that targets the CLR with the help of fparsec. Coming from Rust the `'a` syntax threw me for a loop (not F#'s fault, nor am I implying anything needs to change), but I still don't quite understand it. Is that denoting some anonymous type? If so, what is the structure of said type, what members does it have, etc? The repo can be found here: https://github.com/Phrohdoh/fs-toyparser Currently I am walking through the [FParsec tutorial](http://www.quanttec.com/fparsec/tutorial.html) so any suggested reading material would be highly appreciated!
Try the "F# for Fun and Profit" link in the sidebar. Also checkout the "Expert F# 4.0" book, it's quite enlightening. 
Fable is good. VS Code plugin for F# is compiled using it. Also, you can use [Bucklescript](https://github.com/bloomberg/bucklescript) for frontend code generation. It's not F#, it's Ocaml, but it's not bad and pretty fast.
When was the last time you tried? The compiler certainly has had working exhaustiveness checks for a number of years now.
If you build it they will come. Better tooling will bring more users. As someone pointed out it would be cool if it was possible to mix in f# code within an existing c# project.
&gt; Fable is good. VS Code plugin for F# is compiled using it. That's good to know. &gt; Also, you can use Bucklescript for frontend code generation. It's not F#, it's Ocaml, but it's not bad and pretty fast. By Bloomberg no less. What happened to `js_of_ocaml`? 
JSOO is alive and well, but it generates JS from Ocaml bytecode, while Bucklescript translates Ocaml into very good, readable JS code.
Working on porting a form/popup building application from Python to F#. My cranium just reasons about things better in FP. Also exploring the possibility of using Fable on the front end.
So far, Id say that Fable is hands down the best iteration of F#-&gt;Javascript compilation yet. It's certainly not perfect, but compared to the previous options I have tried it's certainly the best so far.
Hm. Yes. I've used both (F# and Scala). I'd say VS with Power tools is more or less on the same level as with doing Scala with IntelliJ, in every aspect although automatic pattern match generation is missing from IntelliJ. Hard to say which one is more fun to use. The JVM library ecosystem is slightly bigger, but the compiler is a tad slower. For concurrency mechanisms I'd rate both equally. Syntax wise, I think F#'s ML syntax is nicer, but its type system isn't as rich as Scala's. Pros and cons to both, for their respective ecosystems they're the best thing out there. FWIW, JVM is getting value types and reified generics in version 10, dubbed Project Valhalla.
&gt; MS strives to be a data driven company, so they probably can't justify a "banking big" on F# before they have around 100k+ You know, "show me the numbers, then we'll talk" - never mind how good a pitch an F# fan can make for the language. Chicken and egg. They want it to be popular before they've built it or they won't build it. 
What I know of the current Java development is that there's higher priority in projects like Graal (an aggressively optimizing hybrid AOT/JIT compiler) and Valhalla, the implementation of which are sort of prerequisites for implementing proper tail calls. As for Scala, you can do tail recursion in Scala, but you need the `@tailrec` annotation, much like in Clojure. With the scala-native LLVM backend, this will be automatic, but it's a different world altogether. Still, it's obviously inferior to `let rec`, but I tend to eschew recursion until there are no alternatives. A good example where I really needed it was to implement a loop elegantly and I didn't want to use labeled breaks.
I think a production ready solution that is allows F# to be used in the browser thats still easy won't happen until web assembly becomes a thing
Thank you! That seems much better, you're right. As a side note: I don't have any issues editing the Paket files, they are very direct and simple. But editing those big XMLs is terrible, hehe. That's probably the largest problem in the developer UX in F#, in my opinion. 
&gt; What I know of the current Java development is that there's higher priority in projects like Graal (an aggressively optimizing hybrid AOT/JIT compiler) and Valhalla, the implementation of which are sort of prerequisites for implementing proper tail calls. Last I looked the high priority seemed to be `dynamicinvoke` because they were optimising for inherently-slow dynamically typed languages. &gt; As for Scala, you can do tail recursion in Scala, but you need the @tailrec annotation, much like in Clojure. That only handles the rather uninteresting special case of self-recursive functions. You can just use a loop. When you have functions tail calling each other things get much more interesting (and useful). &gt; With the scala-native LLVM backend, this will be automatic, but it's a different world altogether. That would be nice but does the LLVM-based Scala use the same boxed data representation that makes the JVM so slow? &gt; Still, it's obviously inferior to let rec, but I tend to eschew recursion until there are no alternatives. A good example where I really needed it was to implement a loop elegantly and I didn't want to use labeled breaks. Extensible state machines is another place I use general tail calls a lot. I've sometimes needed [CPS](https://zbray.wordpress.com/2011/11/02/solving-the-0-1-knapsack-problem-using-continuation-passing-style-with-memoization-in-f/) too and I appreciate the fact that this all just works in F#. I was also disturbed last time I looked at Scala that, despite everyone from the Scala community telling me I was an idiot for wanting tail calls, over 30 of the known bugs against the compiler were stack overflows caused by broken tail call elimination. 
Silverlight was great. Such a shame Sinofsky killed it. I'm facing the problem right now. I just hired a CTO who does F# and I have a lot of projects to do internally. One is a database containing raw data and calculations and most of the people who use it will want import/export to/from Excel. That's easy with WPF but he's inclined to make web-based everything. How do I do Excel interop from a web page? 
&gt; That would be nice but does the LLVM-based Scala use the same boxed data representation that makes the JVM so slow? To that, a cautious yes, since they're using LLVM primitives with a Boehm GC, but the mutual tail calls optimization is definitely a thing. https://github.com/densh/talks/blob/517b20c30dd4aaf390785039cdd002f623eaa91e/2016-05-11-scala-goes-native.pdf Could you give an example of your state machines? I assume you're calling some state transition from another state transition? edit: actually, the point of Graal is to create an optimizing compiler, including, but not limited to, dynamic languages. I'm dabbling with a R7RS (small) Scheme compiler with it. They built a JS backend called Graal.js that rivals V8 in performance http://www.slideshare.net/ThomasWuerthinger/graal-truffle-ethdec2013
&gt; To that, a cautious yes, since they're using LLVM primitives with a Boehm GC, but the mutual tail calls optimization is definitely a thing. Boehm's GC?! Will people never learn... &gt; Could you give an example of your state machines? I assume you're calling some state transition from another state transition? Sure, lexing an `int`: let lex f (s: string) = let rec inside n (s: string, i) = if i = s.Length then f n else let c = s.[i] if '0'&lt;=c &amp;&amp; c&lt;='9' then inside (10*n + int c - int '0') (s, i+1) else f n outside (s, i) and outside (s: string, i) = if i &lt; s.Length then let c = s.[i] if '0'&lt;=c &amp;&amp; c&lt;='9' then inside 0 (s, i) else outside (s, i+1) outside (s, 0) or a recursive descent expression parser written using active patterns: let rec (|Atom|_|) = function | INT(n, t) -&gt; Some(Int n, t) | IDENT(x, t) -&gt; Some(Var x, t) | KWD("(", Expr(f, KWD(")", t))) -&gt; Some(f, t) | _ -&gt; None and (|PApply|_|) = function | Atom(f, PApply(fs, t)) -&gt; Some(f::fs, t) | Atom(f, t) -&gt; Some([f], t) | _ -&gt; None and (|Expr|_|) = function | PApply(fs, t) -&gt; Some(List.reduce (fun f g -&gt; Apply(f, g)) fs, t) | KWD("if", Expr(p, KWD("then", Expr(f, KWD("else", Expr(g, t)))))) -&gt; Some(If(p, f, g), t) | KWD("fun", IDENT(x, KWD("-&gt;", Expr(f, t)))) -&gt; Some(Fun(x, f), t) | KWD("let", IDENT(x, KWD("=", Expr(f, KWD("in", Expr(g, t)))))) -&gt; Some(Let(false, x, f, g), t) | KWD("let", KWD("rec", IDENT(x, KWD("=", Expr(f, KWD("in", Expr(g, t))))))) -&gt; Some(Let(true, x, f, g), t) | _ -&gt; None &gt; edit: actually, the point of Graal is to create an optimizing compiler, including, but not limited to, dynamic languages. I'm dabbling with a R7RS (small) Scheme compiler with it. They built a JS backend called Graal.js that rivals V8 in performance http://www.slideshare.net/ThomasWuerthinger/graal-truffle-ethdec2013 Optimising compilers for dynamically-typed languages make no sense to me. Its Lisp's sufficiently-smart compiler myth revisited. And performance comparisons with V8 don't make sense to me either. From your last link: &gt; "...spend a long time implementing runtime system, GC, ..." FWIW it doesn't take long to implement a runtime system and GC. I wrote [this](http://www.ffconsultancy.com/ocaml/hlvm/) in a matter of weeks. 
Couldn't figure out Slack :/
Can't at the moment as the courses aren't announced yet. Rest assured I will do plenty of self-promotion when they are ;-)
http://up-for-grabs.net/#/tags/F%23
In what way are you trying to authenticate? Do you have a command line/GUI app that you wanted to interact with the Discord API? Do you have a traditional web application where you wanted to authenticate users via their Discord profile? Do you have a Single Page Application or Mobile Application which you wanted to have users sign-up/login with their discord? Each of these three situations (most common situations) has a slightly different approach in how they are handled. Let me know which and I'll try to provide some more info.
Hi and thanks for replying. I just have a command line project that I want to use to: * Log in * Send a simple message
[ClosedXML](https://github.com/closedxml/closedxml)
Does that run in the browser?
Thanks! I'll take a look.
I'd recommend using the library. It will save you time and you'll still have to write some F#. If you decide not to, I would google for ".net oauth2 client" and look for libraries. Although most oauth2 servers are the same, some have slight differences in how they handle refresh tokens and other subtleties. You could also use the discord library for just the authentication part as well.
I will check out Discord.NET, hopefully I can use that to gain some F\# knowledge. Thank you. :)
For me it has been the most helpful resource in learning F#. Even if I don't have anything to ask or answer just reading and following along with the discussions there can be enlightening for a beginner.
no, server-side only
Right. I'd need a web client interoperating with Excel running on the client. 
Was it the vague, overreaching wording of the Code of Conduct for the Foundation? It's my only concern about joining during this hyper-political era. 
No. I have no opinions on that matter. But I do think that requiring someone to create an account with your foundation just so they may get help for the language is unnecessary and to no-one's benefit (except maybe the foundation's to say "we saw N new members this month!").
There is another active slack at 'functional-programming' or whatever. Downside is that it's less exclusive as it accepts non-foundation members ;)
The naming here is unfortunately ambiguous, at first I thought this had to do with Microsoft's Universal Apps concept...
Yeah operator overloading is always causes unnecessary cognitive stress. In this instance I took it from the javascript community calling full-stack javascript as "Universal Javascript" after they moved away from misusing the term "Isomorphic". I do see how it could cause confusion in the .net community though.
There's a pretty big twitter scene. Just look up #fsharp and you'll find tons of people to talk to.
"Full stack"?
Perhaps this is a good term to switch it to. I chose 'Universal' simply because it was what I have seen used in other "full stack" communities (javascript, clojure(script), scala, go, etc). I do agree that full-stack sounds better to me as well. Not sure why people found the term full-stack confusing in the first place. If there is no reason, it's probably better to just switch back to that. Thanks for the input!
Cool, sounds like a fun project! I'd recommend checking out [Phil Trelford's](https://twitter.com/ptrelford) [FunBasic project](https://bitbucket.org/ptrelford/funbasic). It's a fully-functional language that's built using FParsec and he's also written [a few](http://trelford.com/blog/post/FunBasicPreview.aspx) [supporting articles](http://trelford.com/blog/post/compiler.aspx) around the project.
Also, the `|&gt;&gt;` operator is documented [here](http://www.quanttec.com/fparsec/reference/primitives.html#members.:124::62::62:) in the FParsec reference manual. If you don't already know what you can do with it, that documentation wouldn't clue you in -- but once you've started to understand how the various parser combinators work, then that reference manual is a great help for finding the one that you need.
If you're using Suave, there's https://github.com/OlegZee/Suave.OAuth which you could check out. If you're not using Suave, it might not be as useful to you, but you might still be able to learn from what it does.
I've been using Dapper for a couple of years (though with MySQL and MSSQL) with no problems. It's very mature and stable. I personally prefer it to EF as I always found myself fighting against it and performance issues often came up - I understand EF Core is supposed to be much better but I'm pretty happy with Dapper at seen no urgency to change.
.NET bindings for Tensorflow are in development and CNTK are in [beta](https://github.com/Microsoft/CNTK/releases/tag/v2.0.beta8.0). A little known F# library that I have not tried is [DeepNet](https://github.com/DeepMLNet/DeepNet). It seems to be in active development. I was also working on a ML library on my own and was hoping to release before 2017 came around, but then the Cuda compiler submodule of it consumed me and right now I am studying type systems in order to do it right. Mastering that kind of subject will take me months (or more) though and is kind of a risky, drastic measure. I am actually considering making my own language that compiles to F# (for CPU code) and C++ (for Cuda code.) If it was not for the damn GPU aspect of the library, I think I would have been done half a year ago. The difficulties with making a good ML library always seems to revolve around the GPU - the actual deep learning aspects of it are not much more complex than parser combinators in my opinion.
I've started using dapper for the current project and it's working pretty well. I too like the performance that comes with the default method of using the library.
Incidentally, you can target UWP using most of the same toolchain. This Navigation sample works on iOS, Android and UWP: https://github.com/fable-compiler/fable-elmish/tree/master/samples/react-native/navigation 
Thank you for this! I had not considered using `pipeN` with an anonymous function that skips certain parser output.
It is possible to use MxNet through the R type provider as well, but way back when I tried it, MxNet on R did not come with GPU support.
While I've greatly enjoyed using Suave, WebSharper, and the like, it is rather nice to see a framework built on leveraging all the work that went into ASP.NET Core . Thanks.
Isn't this what [Freya](https://freya.io/) is?
The shebang is supported [since mono 3.2.8](https://twitter.com/dsyme/status/507883383213805568) so you can use `#!/usr/bin/env fsharpi` to run any system that has at least this version (which is pretty much every system even remotely up to date; for example it's the version on Debian stable).
I'm just trying to build a bit more F# content on the web with my blog [codesuji](http://www.codesuji.com/). It's nothing Earth-shattering, but it's a fun little experiment. 
Thanks :-) 
Maybe switch to OCaml? http://mathiasbourgoin.github.io/SPOC/ Or look into how fable generates JS from f#? Could probably use it as inspiration for generating cuda from F#
Yeah, I will definitely have to look into Fable when I am done studying type related stuff. I forgot about that; I'll keep this suggestion in mind from now on. The difficult part with all of this is that I am being pulled in different directions regarding how to do this, and resolving this will take me time and some serious study. I'll admit that last month was the only time I seriously considered moving to Haskell due to it having HKTs and typeclasses, but decided against it as I do not want to deal with laziness issues. Since I am considering drastic things, I am quite interested in trying out [Turnstile](http://www.ccs.neu.edu/home/stchang/popl2017/). I've never seen entire type systems being implemented as DSLs via macros and that is quite attractive to me at my current juncture.
Yeah, the name will be entirely ungoogleable due to C# devs talking about their AWS lambda issues (which happens to run in .Net core VM)
&gt; "Although the idea of writing small classes and methods are familiar to you in C#" Actually, writing small classes in C# is hell. By usual convention, all the classes go in separate files, and something that should be a simple task turns into massive enterprise bloatfest where you can hardly find the actual business logic. Small methods are OK, especially w/ the expression bodied functions in C# 6
Funscript is pretty much dead (AFAIK), so really it's just Fable vs WebSharper. I have used Fable and it's pretty nice, although if you point it at an fsproj instead of just an fsx it doesn't seem to be able to generate code maps properly. I've read a tutorial on fable-arch (or was it fable-elmish?), and it seems really good for SPAs. For WebSharper, my only experience was trying to decouple the JS generation from the rest of the framework, and I wasn't entirely successful. I've heard that WebSharper is pretty nice, but only if your server also uses WebSharper as its framework.
Have you gotten VS to resolve the fable namespace? I used VS Mac and it didn't and I don't understand enough about .net stuff to figure out why. 
&gt; For WebSharper, my only experience was trying to decouple the JS generation from the rest of the framework, and I wasn't entirely successful. I've heard that WebSharper is pretty nice, but only if your server also uses WebSharper as its framework. That's a pity. I think modularity and reusability will certainly benefit the software here. Without truly understanding the architecture, my gut feeling is that this tie-in is not necessary. 
I was able to get full Visual Studio to do it but not Visual Studio code. Haven't tried VSMac/Xamarin/MonoDevelop yet.
I used NPM to download the Fable compiler, then in VS I just added a DLL reference to Fable.Core.dll, which was inside the NPM package. I'm away from my computer so I can double check in a bit.
Ah. Cool. Will try that when I can. 
&gt; absolutely not documented. I really like making things with Fable but damn is it hard to find documentation (and 0.7 changes didn't help either). I'm getting started with fable + react and it's hard finding good info. Most web/blog content isn't up to date with current version of the react helpers so it's taken me a lot longer than it should have to get something running from scratch.
Not sure if this will really help you but I'll take a stab at it. I don't know F# so I doubt I could have written the function but I have enough experience with other languages that I thought walking through my thought process might be interesting. 1 let rec group ns xs = 2 let rec combination n xs = 3 match n,xs with 4 | 0, xs -&gt; [([], xs)] 5 | _, [] -&gt; [] 6 | n, x::xs -&gt; 7 let ts = [ for ys, zs in combination (n-1) xs do yield (x::ys, zs)] 8 let ds = [ for ys, zs in combination n xs do yield (ys, x::zs)] 9 ts @ ds 10 match ns,xs with 11 | [], _ -&gt; [[]] 12 | n::ns, xs -&gt; 13 [ for g, rs in combination n xs do 14 for gs in group ns rs do 15 yield g::gs ] # Step 1 ---- `group` is a recursive function (with an inner recursive function `combination`). Ignore `combination` for now and look at what `group` is doing first. I guess `ns` is a list of numbers and `xs` is a list of some other type # Step 2 ---- **lines 10-12** : `group` **line 10**. look at the _values_ of `ns` and `xs`. **line 11**. If `ns` is an empty list, ignore `xs` and return a list with one value - an empty list. a) This is the base case for recursive calls b) `group`'s return value is a list of lists **line 12**. Non base case. Decompose/deconstruct `ns` into its first element `n` and its remaining elements - confusingly called `ns`. Once you've used lists for a while it's second nature to do this though - decompose a list `as` into its head and tail called `a` and `as` respectively. # Step 3 ---- **lines 13-15** - a list comprehension whose values are constructed from `g` followed by `gs` To understand what `g` and `gs` are, we _now_ need to understand what `combination` is doing # Step 4 ---- **lines 2-9** `combination` **line 3**. look at the _values_ of `n` and `xs`. Your spidey sense should be tingling now telling you we're dealing with the recursive base cases. There are two: a) `n` is zero: return a list made of a single tuple (empty list, `xs`) b) `xs` is empty: return an empty list. Here I'll make an educated guess from the name `combination`, the type of `n` (a number) and the return type a list of 2 element tuples with each element a list. I guess this gives combinations of `n` items taken from `xs` and attached to each combination is the remaining (non `n`) items of `xs`. Symbolically `combination 2, xyz = xy z, xz y, yz x` **line 6**. deconstruct `xs` into `x` followed by `xs` **line 7**. `ts` is made by prepending `x` to each combination of `n-1` items from `xs` by calling `combination` recursively (remember `xs` is now the original `xs` without the head `x`) . In other words `ts` is made by putting `x` at the head of all `n-1` combinations from `xs` **line 8**. `ds` is made by using `x` as the head and the tails taken from all the remainders (which remember are paired with the `n` combinations obtained (again) by calling `combination` recursively this time with `n`). Symbolically (from before) `combination 2, xyz = xy z, xz y, yz x` So `combination 3, wxyz` gives ts = wxy z, wxz y, wyz x ds = xyz w In other words `ts` is all combinations of `n` items _with_ the head and `ds` is all combinations _without_ the head. So the result (_all_ combinations) is obtained by appending `ts` and `ds` together. `combination` gives a list of all the combinations of `n` items taken from `xs` - each combination is paired with the untaken items from `xs` # Step 5 ---- Now we understand what `combination` is (and how it works) we can return to Step 3 to fully understand `group` Recall **lines 13-15** is a list comprehension whose values are constructed from `g` followed by `gs` What are `g` and `gs`? **line 13**. `g` is one item from _all_ of the combinations of `n` items taken from `xs` (`n` is the first item in the list of numbers passed to group `ns`). `rs` is the remaining untaken items from `xs` **line 14** `gs` is a one item from the recursive call to `group` using `rs` (the remaining items not taken from `xs`) and the remaining `ns`. Put another way `gs` is a list containing lists (of the appropriate size) taken from the remaining items after removing the items of `g` from `xs`. One trick to writing and understanding recursive functions is to just assume that the recursive call gives the right results in the right format. **line 15** One result of `group` is therefore given by making a list with `g` (`n` items from `xs`) as the head and `gs` as the tail. The comprehension starting on **line 13** gives _all_ the resulting combinations taking a `g` and a `gs` due to being a nested comprehension. 
Featured =). Always love these posts.
Dumb mistake. I should have done the following: let expression = (&lt;@ Func&lt;Workflow,bool&gt;(fun w-&gt; w.ReferenceData = "Name") @&gt;) 
So can I just add this package into my existing .NET 4.5.1 project and enjoy the new features, or it's not so simple?
[removed]
None of my main work is in F#, but I have some minor F# scripts checked into our repo.
Starting a new job soon. Asked to learn f# before I start because they do everything in f#.
Build Scripts with FAKE
I try to push f# at my work but so far I haven't been successful. I think only one other person knows functional programming (ocaml) so it's understandable to have the resistance. I'll keep espousing f#'s virtues though!
Yes, 100% F#, full time - except for a little bit of codegen'd C#. Optimising water networks.
[removed]
Don't talk about FP. Talk about 1/3 the code size compared to C#
I wrote one FAKE script.
[removed]
I'd love to see some new content from Scott. His website is great but I've burned through all the articles and am craving more.
[removed]
[Suave](https://suave.io/)
https://fslab.org/ might be of interest.
Well if you think so, [maybe I should](http://stackoverflow.com/a/42344227/) ;) to be fair they're all good answers capturing a variety of angles on the topic --- http://stackoverflow.com/a/42341743/ shows the way to go really for examples such as yours, except leaves out *handling* (and that's really the coder's choice depending on context/requirements etc)
Most of our codebase is C#, but as an experiment we implemented a 2 level caching system for our web application in F#. It manages the asp.net in memory cache, and redis, so that the web app can get data from the fastest available location before resorting to hitting the database. 
Looks like a job for a mailbox processor to me: https://fsharpforfunandprofit.com/posts/concurrency-actor-model/ Everything can be immutable and the locking is handled for you by the MailboxProcessor.
Look at the `MailAddress` class. Everything that expects an email address can trust that the address is at least formatted correctly. 
None the less, seeing how people use `MailAddress` in real life is useful for this conversation. 
I wouldn't advise actually doing this but maybe something like: type ValidEmailChar = | A | B | C | AndSoOn type EmailAddress = ValidEmailChar list * ValidEmailChar list * ValidEmailChar list let printEmail (e:EmailAddress) = let (name,domain,ext) = e //and so on 
&gt;By usual convention, all the classes go in separate files I just go ahead and ignore that. But there is still a lot of boilerplate! 
It's a good example still. MailAddress won't ever be in an invalid state (where invalid is defined as having a Address that passes the regex). It does this by throwing exceptions in the constructor. In F# you'd be more likely to see see returning an Option or a discriminated union instead of throwing exceptions but the idea is the same.
Do you have any tips for how to get familiar with the HOPAC paradigm? Would it be useful for me to first play with the built in MailboxProcessor to get familiar with it, then grab the Concurrent Programming in ML book and delve into Hopac? 
&gt; exceptions-as-control-flow abuse Exceptions are control flow. &gt; since code that throws is necessarily impure Eh? Provided your signature captures the exceptions that might be raised I don't see anything impure about exceptions. 
Why is that impure though? Surely if the mapping is pure and the result is thrown away it doesn't matter if zero or all of the list is consumed?
Calling a function changing control flow (I.e. what else gets called) instead of returning a value is impure as hell. I'm not saying that's necessarily a bad thing, but it's impure. 
It could be seen as an optimization. Only situation when it's not is when calling impure functions. That's my point. You're arguing that something that by definition can never ever be seen except as faster code is "impure". I don't see it. 
Explicit error handling while reading database would drive me up the wall. I'd rather let the exception happen and give http 500 to user (in case of web request)
I'm sure your users will appreciate that. But the point is that with Result.Error, you can capture and propagate error cases (and not just exceptions) back up the call chain in a controlled manner, and they must be explicitly handled in the code (or explicitly referred on to the next level) at compile time. The problem with Exceptions is that they hide information about the behavior of the code from the programmer, and are frequently used to crash a system where a crash is inappropriate. 
&gt; Calling a function changing control flow (I.e. what else gets called) instead of returning a value is impure as hell. Then Continuation Passing Style (CPS) is impure. Which it isn't. 
They moved the F# stuff to a new editor based on Roslyn Workspaces, this effectively requires them to rebuild a lot of functionality. I assume the automatic formatting will be back in soon.
Thank you. that might be a sufficient workaround.
&gt; and are frequently used to crash a system where a crash is inappropriate. I guess that is the case for data validation. I've seen many codes that throws an exception when there is an invalid data. For this case the result type is better.
May I ask where you work?
[removed]
Maybe this helps: [Fable REPL](http://fable.io/repl.html)
* [.netfiddle](https://dotnetfiddle.net/) has F# support. * I also love [glot.io](https://glot.io/new/fsharp) for snippet hosting and running.
It seems that is a good job for the F# compiler services. It also has a sandboxed pseudo file system for security purposes. Check out: - [Interactive Service: Embedding F# Interactive](https://fsharp.github.io/FSharp.Compiler.Service/interactive.html) - [Compiler Services: Virtualized File System](https://fsharp.github.io/FSharp.Compiler.Service/filesystem.html) 
[removed]
Is F# not production ready? 
F# is production ready. I wouldn't say that any version of EF has ever been production ready though. ;) Edit: Also, I wouldnt say that .NET Core is production ready yet. Microsofts marketers certainly seems to want people to say and think that it is. But I wouldnt feel safe recommending anyone to use it in production yet (although some people do).
Fable has been compiled by the Fable compiler, allowing Fable to exist as JS and compile F# client-side in the browser. Edit: To be clear, you do have to download the Fable JS at least once before you can do anything offline, obviously. Luckily it does that on page-load since it forces a compile of the default F# script. Check out the minimized code [here](http://fable.io/repl/bundle.min.js).
Unfortunately, I don't think this would be sufficient as running an external tool would modify your document, and VS would then pop up that your file was modified externally, asking if you wish to reload. You could enable auto-reload on external changes, but this can be a dangerous option. Instead, perhaps you can check out this extension that seems to allow you to configure any external code formatter: https://marketplace.visualstudio.com/items?itemName=MariuszBrzeski.CodeBeautifier
I also work in the games industry. Does everyone know or learn F# at your place? I suppose anyone who works on tools must. How did this happen? Training?
Still learning it myself tbh. The Hopac library just provides alternatives to the built-in task/async but with less overhead etc. If you're just wanting to learn about actors, then stick to MailboxProcessor as there will be less of a learning curve. For learning Hopac, the [main docs site](https://hopac.github.io/Hopac/Hopac.html) is very comprehensive, but a little dense &amp; academic feeling. There's also good examples inside the repo: https://github.com/Hopac/Hopac/tree/master/Docs
This is basically what I was looking for!
Not everyone, it took a lot of convincing, and mostly with examples to show how simple and straight forward the code was. If it was for web, no one would have ever dare to touch it (the Monad word should be kept secret). Once 2 or 3 key programmers are convinced, the rest will follow. Personally I learned F# in my previous Job at work, for the rest, it depends: personal/work.
Yeah I've been through the hopac docs. Is fairly impenetrable to me. Will require much time! 
There's a very good post on this exact subject: https://fsharpforfunandprofit.com/posts/designing-with-types-more-semantic-types/
Alright, not an expert, but I hope that I do not have many wrong answers, also I don't intend any of those answers to be comprehensive, some would require a full hour course to explain properly 1. #r directives are intended for use in fsi, not fsproj. Nuget should properly add a reference in your fsproj file, then you just need to use open to import the namespace. 2. afaik, #r = fsi, adding references in fsproj should not be manual, either nuget, paket or ionide commands should handle that for you, obviously you always can do it manually, but you shouldn't, thats package managers job. 3. if you want a comprehensive answer to that, you have to read every single .net and fsharp release notes. honestly just use whatever version is the default, only look up versions if you encounter compatibility issues with some packages. 4. I cannot tell you what you want, that's on you unfortunately, but: * console : good old console application * classlib : class library, aka dll * expecto : unit test with the expecto framework * fsunit : unit tests with the fsUnit framework * pcl259 : a specific version of portable class libraries, used for xamarin interop if my memory serves right. 5. You need those features in large complex projects. app folder is called a solution in the dotnet world. 6. You do not need to "worry" about them, ionide should handle them for you. 7. Depends on your target platform/build toolchain. For basic stuff you shouldn't have much to change in them. 8. As a beginner I would say no, fake is a build toolchain, paket is a package manager like nuget 9. that's r# for fsproj 10. first one is a generic type, second and third are equivalent function calls, parenthesis are optional, except when order or type matters, last one is an attribute, that's metadata for your code, many many other things can be attributes, you can even write your own. 11. No, for automation, you just have to call fsi.exe from the comand prompt with your fsx file as parameter. 12. https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/modules You do not have to indent declarations in a top-level module. You do have to indent all declarations in local modules. In a local module declaration, only the declarations that are indented under that module declaration are part of the module. 13. By default yes, a file creates an implicit module. But you can have multiple module hierarchies in a single file (not recommended though) 14. Wpf, WinForms, Entity Framework and Asp.net, for me. 15. I don't think so. The only tip I can tell is learn c# too. 16. Usually, build just transform your source code in executable, Deploy does additional stuff to put that exe or dll somewhere useful. 17. Its possible but rather complicated to do in VScode, you'd better install VS community which includes debugging out of the box. 18. I don't know. 19. Build as often as I can. Only use integrated terminal. 20. You can use https://msdn.microsoft.com/en-us/library/system.diagnostics.process(v=vs.110).aspx#Examples 21. .net core is a multi platform rewrite of .net. it may or may not matter to you depending or your target platform. Sorry if some answers seems short, sometimes when one lives only in the dotnet bubble it's difficult to gauge what is obvious and what is not. Do not hesitate to ask for clarification. 
You should get on the [F# Slack](http://fsharp.org/guides/slack/). You need to be a member of the F# Software Foundation, but membership is free. They have a #beginners channel that's great for questions like yours.
While this would help f# language design, it would come at the cost of what makes f# great. Namely easy interop with .net and good tooling (by being tied at the hip to .net). I'm just not sure it's worth it. Functional languages have a hard enough time gaining traction and it seems wrong to take the language away from aspects that increase traction
Thank you very much, that's so helpful. &gt; Sorry if some answers seems short, sometimes when one lives only in the dotnet bubble it's difficult to gauge what is obvious and what is not. .NET seems very cohesive, but it's very different from what I'm used to (JS and Python). Not just in the tooling, but I think even in documentation and discussions. I wouldn't say it's harder for me to learn, because the answers always seem simple and obvious afterward, but harder for me to find out -- perhaps because it's so easy, it doesn't get much attention. Contrast this with JS where tooling is endlessly complex with hundred of variations and articles.
I can't register to fsharp.org with Facebook, I get [an error](http://i.imgur.com/gKC03Kq.png).
Interesting idea. Though one issue that this doesn't address (and probably isn't meant to address) is how to continue to co-evolve the .NET languages in a compatible way. If both F# and C# get type classes, but they have some semantic differences, then they might not be compatible without special marker attributes or shim APIs. Your solution somewhat encourages these distinctions, which can be said to be good for each language (the differences would likely be to make them work best for their languages) but ultimately it would be a hindrance to the concept of a common language runtime. A similar issue is how to make F# compatible with languages which already have fundamentally different mechanisms. Suppose that we have F# running in a VM which allows multiple inheritance, and needs to consume an API which utilizes it?
If you read Don Syme's comment [here](https://github.com/fsharp/fslang-suggestions/issues/243#issuecomment-282480054), they are deliberately holding back on adding typeclasses to F# in order to make sure they are compatible with C#'s typeclasses. Key quote: "I am extremely loathe to add a version of this mechanism [typeclasses] that is incompatible with any future C# mechanism."
It is a good call, I think. Shapes and extensions seem to be a likely feature in a near future version of C#, but there is still a lot of discussion on fundamentals which would certainly affect interop. The emitted IL (under the current proposal) would translate them to interfaces and structs along with hidden/implied type parameters, which is all valid MSIL today but would need to be exposed to consumers as shapes/extensions either using an attribute or by convention.
Thank you so much! Especially for #18 which I can't live without. This didn't actually come from you, but reading your answers helped me realize the answer to my biggest problem with package management, and I was able to get through it. I had been using "Paket: Add NuGet Package", which gets the package but automatically change the .fsproj file to create the reference. Instead, I should have chosen "Paket: Add NuGet Package (to this project)", while having the .fsproj file open. This will add the package and create the reference. I had tried using this menu option, but didn't have the .fsproj file open. The error says "project file needs to be opened", so I tried it again with paket.dependencies open, again with paket.lock open, and again with paket.references open, and paket.targets open, mistakenly thinking that since paket was the package manager, it should be one of these. When none worked, I tried "Paket: Add NuGet Package", saw the files being created in the ./packages directory, and assumed I was successful. I realize it's an incredibly silly error and a simple solution... but in other languages I've used there isn't a separate step between installing a package and enabling it (or at least there isn't most of the time), so it never occurred to me what was wrong. It was just "I installed a package and it doesn't work!" and I wouldn't even know how to ask that without seeming like one of those people on GitHub that create an issue saying "xyz doesn't work". Thanks again!
You'd either add a whole lot of complexity or lose a whole lot of interoperability. Neither is a particularly good option. Like I said, if you want independence from the CLR, there are languages for that. F#'s strengths come from its interactions with the CLR, taking that away makes the whole thing pointless.
What do you mean by "script-like" if you care about performance? (Or if it's functional or statically typed for that matter)
I love a language that I can write a small amount of code in, while still getting a lot done. Ideally, it’d abstract over a lot, compile and execute fast, not require an IDE as much as some languages (Java), have a good cross platform ecosystem and nice libraries, have some sort of repository system, and overall just be convenient to work with. Lua with LuaJIT does this and it does it really well. I’m one of the few people that absolutely adores Lua, and honestly, it hasn’t let me down. It just sucks for cross platform stuff because of a near non-existent Lua community on Windows and a relatively small community everywhere else. Besides that, it’s very close to native speed in most cases. This shouldn’t be surprising since a lot of what Lua does takes place in calls to and from C. I’ve heard a lot of cool things about Nim trying to match similar goals, but it’s definitely not for me. I care about functional programming because it’s a lot more fun to write and lool at to me. I like static typing (including optional static typing) because it helps catch errors and improve editor suggestions.
What are you trying to build? Web applications, desktop applications, mobile apps, intensive computational applications, AI, embedded systems applications, OS utilities, etc? At this point pretty much any language can do anything. Try F#. If you like it and it can mostly do what you want, keep using it. Functional programming is a paradigm that many languages can exercise. It doesn't have to be a dedicated functional language to be functional. You like Lua; I'd recommend sticking with it despite your grievances with it. Other languages you may consider: Haskell, Elixir, Haxe. Even languages like JavaScript or PHP or Python can be written in functional style and are very good for fast prototyping.
Yeah, I guess I’ll never really know until I try. The thing about Lua is that I really can’t stick with it for some things. When it comes to stuff involving disk IO or multithreading, it loses out to other languages *fast*. For example, on Windows, if you want to read and parse json you need to manually fix and compile the library for Windows. In Scala, any library can be added to my build configuration and it’ll download and install during builds for any platform. It saves hours. God forbid you want to use https with luasocket on Windows. Python definitely isn’t for me. I’m okay with heavier and compiled languages since most of my projects are over 200 lines anyway.
Using requests as an example is weird because it's generally regarded as having a super nice API. What is it you don't like with it? If you can't deal with significant white space then F# isn't for you right there. 
That’s really good to hear. Can you explain how F# handles builds and dependencies? In Java, Maven pulls all dependencies in the pom.xml from the Maven repos at build time. This is super convenient. How do things work with F#?
It’s *really* opaque. In Java you can abstract or extend as much as you want. For example, the AsyncHttpClient library lets you have an anonymous class that handles request scheduling, one responsible for processing a response as as it streams in, etc. Or you can just do client.execute(new HttpGet(”https://google.com”)); If the client or server is expected to drop connections from time to time, you can account for that and have reasonable certainty that you did things right. Want to know if your request will follow redirects? It’s in the builder. Want to know where the connection goes to as it follows redirects, or want to set how many to follow at max? It’s completely doable, really easily readable, and clear. Want to add a form but need it URLEncoded? Use a UrlEncodedFormEntity instead. Exactly what is going on is exposed to you, but only if you want it to be. It integrates really well with an IDE since it can look at symbol information. In requests, figuring out just how I could do things, if I could do things, and what is the right or wrong way was just weird. Figuring out what a failure case was had to be tested manually. My internet drops out anywhere from once every two days to 5+ times per day (nothing I can do about it either) so having something that behaves predictably is nice. I ended up just using urllib and then just transferring everything to Java. 
Sounds like you are just a newbie at Python but know Java. That's a good reason to use Java but it doesn't say anything about Python or requests really. 
From discussing with you I think F# absolutely isn't for you because it has significant white space and you seem to really really hate it for some reason. 
&gt; That said, I don’t like the idea of being tied to Microsoft technologies without knowing how well supported they are in Linux. There is no motives to worry about this be a MS technology. F# runs on .NET Virtual Machine (specifically CLR virtual machine). On Unix-like system like Linux, BSD and Mac OSX its relies on Mono that works well despite not all .NET features be available on Linux like COM (Object Component Model), WPF - Windows Presentation Foundation - GUI and Silverlight. In addition to that MS is now a member of Linux Foundation. For GUI libraries Mono provides GTK Sharp that is a cross platform toolkit and also there is the Eto.Forms library that works on multiple platform, it is actually a layer over WPF, Windows Forms, GTK sharp and so on. Windows Forms works on Mono, but it is not fully implemented. &gt; My main goal is writing script-like applications with performance better than Python and with multithreading, static typing, and functional programming. Yes. F# can be used as script language and be compiled. F# scripts can be compiled to *.exe files with a simple command line. $ fsharpc myscript.fsx --target:exe --out:myscript.exe (Mono) $ fsc myscript.fsx --target:exe --out:myscript.exe (Windows .NET) &gt; Will most libraries be useless? If the library relies on WPF, COM or native shared libraries only available for Windowss and etc. Yes, it is not going to work. But there are lots of cross platform libraries. &gt; Will it be less capable than Scala on Linux? I guess IMO it is more capable because the .NET Foreign Function Interface in .NET (C# or F#) is for more easier than Java. It is just a matter of writing an FFI wrapper to an existing library like QT, ncurses .... I guess the main problem of .NET (Mono) on Linux is the prejudice against .NET. &gt; Is there anything like SBT or Maven? Basically, what am I missing out on? Yes there is the NuGet repository. The building system is far more simple. The .NET building tool is msbuild or (xbuild - Mono). The package mangers who fetches and install the libraries on the repository are nuget.exe or paket.exe. Every F# project has a XML file .fsproj with the building instructions like Java that is run by xbuild (.NET Mono) or msbuild (.NET - Windows). If you hate XML you can just compile manually, calling the compiler directly with a Makefile. - NuGet web site: https://www.nuget.org/ - Nuget.exe - package manager- https://dist.nuget.org/index.html - https://fsprojects.github.io/Paket/ - Package manager. &gt; IntelliJ IDEA’s Scala plugin is world class. I love it, but god, IDEA is just so heavy for some projects. I love that it can handle project creation with Play, ... There is the Monodovelop IDE that works well for C# and F#. F# plays well with editors like Emacs and Vistual Studio Code thanks to compiler language service. &gt; I have zero experience writing C# or any other .NET languages and I’ve read that this is a huge handicap. No, it is not a limitation. It is possible to learn .NET platform API from F#. If you know Java it is easy to learn .NET. You can play also with the .NET platform interactively in C# using the Mono's repl invoked with $ csharp. Many C# codes can be easily be translated to more compact and concise F# code. .NET is a blessing !!
You're probably right. 
F# uses the a similar same indentation based scoping system to Python. It might not be for you. If you're looking for: - a strongly typed language - in Linux - using Emacs or VsCode as an editor - that doesn't use "indentation as syntax" - with good compilation and runtime performance, then Ocaml may be for you. It has the added benefit of not requiring you to learn the dotnet ecosystem. The main downsides of it vs F# are the threading model (Ocaml programs tend to use processes and IPC instead of threads for parallel computing) and the relative lack of ready-made libraries to use (JVM &gt; DotNet &gt;&gt; Ocaml in this regard, unfortunately).
I know your feels man, and what you are looking for, it doesn't exist. You want features and simple and safety and speed and everything all at once! Hasn't happened yet. The search can be fun but at some point you just got to do the work and no language is going to make it not be work. 
Not super familiar with Nim, so not exactly sure what you mean by &gt; indentation based syntax is funky but F# *is* white space sensitive. 
Interesting project! I'd just suggest to apply some consistency to naming and avoid multiple variations: FsFix, FsFIX, fsFix...
I should qualify my statement that I found F# easier than C#: my previous experience was with PowerShell scripts (mixture of imperative and functional styles) and playing with Clojure (very functional), so I was already into the functional mindset. However, even after 2 years mainly working with C#, I still find most OO concepts overly convoluted and completely trumped by immutability. As others have mentioned, NuGet is the standard .NET package manager and package repository. Paket is a package manager that improves on NuGet package manager while using the NuGet repo as one of its sources, and it gets used a lot in F# projects.
I know, but I like the idea that you can use verbose mode whenever that syntax would otherwise make things awkward.
thanks digitalsorcery, let me know if you have any questions or if there is any code changes that might help your use of FsFIX.
I didn’t know about Paket, so that’s good to know. Hopefully I’ll survive, and thank you.
Hi insulanian, i will sort out the name cases, thanks
Just to offer another option, check out ReasonML. It wraps up OCaml in a more Java/Script-y syntax and offers some nice tooling and editor support. Might also fit your needs.
in FsFIX/fsFix/MonthYear.fs, on line 49 you have let inline private validate_yyyyMM (yy, mm) = yy &gt;= 0 &amp;&amp; yy &lt;= 9999 &amp;&amp; 1 &gt;= 0 &amp;&amp; mm &lt;= 12 Pretty sure that should be **mm &gt;= 1** instead of **1&gt;= 0**
Wow, that is a gem! Backed by Facebook and everything too. The tooling looks great and everything. I’m actually really pleasantly surprised. I like how simple it makes basic OO stuff without turning things into a mess.
Closure looks really cool, but I don’t think it’s worth learning another JVM language. I’ll have to try it some day though.
[removed]
Suave also supports those, but they're very barebones. it has just the protocol implemented, and you have to implement any logic like sending to all connected clients. But there's several patterns out there that solve that specific problem, or you can use a library such as SignalR. The problem with SignalR is that it's not very "functional", and has a hard dependency on JQuery. There might be other libraries out there that I haven't heard of yet
At moment I am using phoenix framework for develop web services. But I really like F# the language, because of type safety. How is your experience with F# and web services?
[removed]
They SqlDataConnection and SqlEntityConnection type providers allow you to use a dynamic connection string after you specify the one when creating the type provider: type internal db = SqlEntityConnection&lt;"Data Source=somedb;Initial Catalog=somecatalog;Integrated Security=True",Pluralize=true&gt; let dynamicString = ConfigurationManager.ConnectionStrings.["someconnection"] then later you can do db.GetDataContext(dynamicString) as an example. For SQLLite I am not sure if the same applies since I have not tried it yet.
I am new to F#, I have been coding professionally in C# for 4+ years. So I am creating a simple student crud app to get my feet wet. One of thee best way to learn is by doing.
Why do you want websockets?
Usually websockets are used for push notifications to the clients. They're more efficient and faster than long polling with http requests.
Thanks for the info. I think I will mainly use it on a windows stack, but I agree that not this could be a big no for some of us if it doesn't work all the same on other OS. Out of curiosity, when did you try it for the last time? They might have fixed it in the meantime.
I have been trying for the past month. 
[removed]
You deserve place in my RSS reader. Keep writing post like this! I have got just background from asp.net mvc 3. (4 years ago??) and I remember these thing were much more painful... I am interested if you can build large web apps with websharper. 
I have a laptop running Linux at home, I might give it a try later somehow and write a post about it if it's conclusive.
Hi venkuJeZima, thanks for your feedback, I appreciate it. The thing I know right now is that you can build large scale applications using F# as the backend, due to the very nature of the language. I believe WebSharper should do just fine as well. I'll keep this in head for future posts!
Excellent writeup, love the use of CLI and the dispatch loop graphs!
Indeed, damn even MS is into reposting stuff now. 
For added amusement, also read the comments ;)
Oh this is hilarious -- whoever wrote this article probably uses the cloud-to-butt browser extension, because in the contributors Jared Hester links to https://github.com/buttroutine.
Congratulations and amazing work! You are all superheroes.
We should just recreate the hacker news discussion here :)
### The easy way to install the latest Visual F# Tools Setting up the tooling on an [experimental instance](https://docs.microsoft.com/en-us/visualstudio/extensibility/the-experimental-instance) of VS is the easiest and safest way to get VFT setup * Clone or Fork https://github.com/Microsoft/visualfsharp.git - Pick a name for your hive, I use `Master`, and switch out `FSharpDev` for your chosen name @ https://github.com/Microsoft/visualfsharp/blob/master/vsintegration/Vsix/VisualFSharpOpenSource/VisualFSharpOpenSource.csproj#L47 - run `build.cmd vs release` Once the tools have been built they will be automatically installed to the Experimental instance that you can access via your chosen name - `git stash "install to hive"`(or some other note) so you can easily reapply the change you made to `VisualFSharpOpenSource.csproj` in the future Every time you build the VS tooling it will clobber the set currently installed on the experimental instance with the newer version - setup a shortcut or alias to make it easy to launch the instance with latest F# tools `posh` is my shell of choice so I use - function fsdev15 ($proj) { &amp; "C:/Program Files (x86)/Microsoft Visual Studio/2017/Community/Common7/IDE/devenv.exe" $proj /rootsuffix Master } ### Why do it this way? - The F# Tooling is setup as a Visual Studio language component which makes the uninstall process via VSIX and the VsInstaller panel a real chore. - The version number for the tooling extension you're installing is static accross builds, which means that to install a fresher build you need to uninstall the experimental tools and then install the new version because you can't just update it - If the build you install happens to have introduced a regression or new bug, you haven't wrecked all of your F# tools This way you'll always have a working vanilla set on the main VS instance -- -- -- ---- enjoy ;)
I keep saying that same thing - fsharp feels like what future will be like. Also it's depressing using anything else as it feels like going back to the crappy past.
Honestly I think that everyone is happy to see another person using F# and succeeding. Its a multi paradigm language so people have their preferred ways but there isn't a 'right way'.
Thank you for answer although it is something I completely disagree. Fsharp needs some philosophical background because it deserves it. For instance: *1. Functional first.* This is nice proof of that there is something deeper in language design. But you can discover much more than you might expect. What about: *2. Paket is better than Nuget.* Or am I wrong when I consider paket to be preferable way how to manage your packages in Fsharp? Next ones: *3/ Pure prevails impure and immutability beats mutability.* Arguably, this is something common for all functional languages, so lets try something specific *4/ Ubiquitous shines more than specific.* And what about something like: *5/ From all sites you always quote fsharpforfunandprofit?* 
Yes, F# is a Functional first, multi paradigm language. Paket is better than nuget for all .net languages, and it is important to not tie it directly to F# to prevent language wars etc. F# language features are immutable by default so I think that part is settled by design. F# is not a pure language and striving for purity is an individual's choice. Many of of the helper functions I write are pure, but the purpose of the applications I write are very far from pure. Haskell made purity a language design goal and F# did not. Unsure of your meaning on #4 For #5 I would suggest that you quote the best article on the specific topic you are talking about. 
:)
Yes, the original blog post is much more precise about the attributes. It does not mention anything about C# honouring them. Perhaps whoever authored the component design guidelines misunderstood this. To your point that I'm trying to promote idioms the creators did not intend: exactly--I am. In my view there are certain parts and usage patterns in F# that lead to easier code (to read and maintain) than others. I've read a lot about people coming from OOP and trying to figure out how to write idiomatic F# while still accessing all the power of the BCL and .NET libraries. Others have presented their opinions on how to do it; this is simply mine.
&gt; Now what about who is F# for? This is bugging me from the start. F# is certainly not for beginners. Why do you think it is not for beginners? And what kind of language, in terms of feature, do you think a beginner should learn/need?
This post is good, and I agree with almost everything. 2 issues: 1) Using records is great, but exposing them in a public interface can be problematic at times, because if you need to add or remove a field, you will break a ton of call sites, which would not necessarily happen if you added a property to a class. Changes you make to records are less likely to be backwards compatible than changes you make to classes. 2) I don't agree with using .fsi files. I think this is a barbaric practice that should be purged from all modern programming languages. Encouraging duplicate definitions that need to be manually maintained is not good. I get that it can give people a nice overview of public types, functions, etc, but to the degree to which that is helpful, it is an editor UI opportunity. We shouldn't encourage people to maintain duplicate definitions and check it in for something that would be so simple to handle in an editor.
Thank you for the thoughtful review. I agree exposing record fields hampers future-proofing, just as with exposing DU cases. Much better to expose accessor functions instead. As for .fsi files, I understand your argument. What can I say, I just really like the idea of a simple, low-tech way to control visibility and provide an overview while also forcing the programmer to think about changes they make to their public-facing API.
Also the `build.cmd vs release` line must be run from the Developer Command Prompt for VS 2017 and as Administrator, or at least that's the only way I got it to work.
Thank you. My 5 points were just examples. From the start I had no intentions to make such Zen by myself, on the contrary, I would prefer to know suggestions of the others. You dont need to dig into my 5 points too seriously. I would like to know your points not mine :)
Obvious unhelpful solution - upgrade from .NET 3.5? I tackled that recently for an old Winforms app and it was worth the effort.
Unfortunately, there's a hard requirement to target at least Vista SP2, so a minimum of .NET 3.0 is needed. I can probably move back to C#, but wanted to better understand what might be going on here.
.NET 4 should meet a "minimum of .NET 3.0" requirement. What am I missing here?
doesn't need to be dev cmd prompt, just an admin shell
I'll try again but I think I had an error when running in a normal admin shell. I might just be missing something from my PATH.
Why do you care what's included? .NET 4 is supported on Vista.
True, but I want to make it clear to people that they really shouldn't.
Well 4.5.2 is fine. Better than targetting 3.5.
I would guess that you can probably make it work by manually editing the .fsproj file.
This seems to work: &lt;TargetFrameworkVersion&gt;v2.0&lt;/TargetFrameworkVersion&gt; and then I had to go into the Project Settings and change the Target F# runtime to F# 3.0. This then changed the FSharp.Core.dll reference to /v2.0/2.3.0.0/, which seems all and good. I'm still uncertain if the FSharp.Core installed on the system or the one via the NuGet package is the appropriate one to use. The Target Framework listed in the list drop down in the project settings is blank, which is a bit odd still, and I still don't particularly like it - mainly as it seems a bit brittle and confusing to developers.
Knowing your way around .xxproj files is unfortunately an almost mandatory skill in .NET world as soon as you do any real work. I guess that's why some F# folks like to work entirely with scripts.
The usefulness of .fsi files depends *dramatically* on the size of the project, and on the complexity of the individual files. Open up a large F# codebase on github and those signature files will be an invaluable navigation guide. That said, I agree that having to write them by hand *is* barbaric. It would make far more sense to put some kind of annotation over the actual definitions and have a tool generate the signature files automatically.
I think in the next couple of years, we'll see languages like F# and Bucklescript/ReasonML grow in popularity. At least... I hope so.
Didn't know that! To get what I described we'd also need a flag that made `let` bindings be `internal` by default, but this is still very useful.
Nice article! I'm curious for the size of this app (and probably how it may be reduced by the Google Closure JS compiler).
I loathe to veer into REST area here, but POSTing a PropertyChangeAction { newValue: 12121 } is a perfectly valid alternative to PUT.
Assuming I only use the API from xhr's, what issues can the non-idempotency cause? I got nothing :)
The basic issue is that correctly configured clients will not retry a non idempotent request, and will warn the user if it tries. You need a great deal more fault tolerance in a non idempotent request. On top of that, being RESTful is more than just using http requests. It's using the language of http to provide your services. Using POST for what should be a PUT is incorrect. It will lead people to make incorrect assptions about your code and cause systems to behave incorrectly. There's a reason for having both.
Typically, API endpoints are called with XHR. Those are not magically retried based on HTTP verb, it's all done by explicit calls (e.g on history navigation)
How does Akka.NET compare to just using the built in MailboxProcessor?
History navigation on POST will not run. More importantly, once again. A RESTful API as opposed to one that merely uses REST assigns meaning to the REST verbs. That's how it works. If you use POST for an idempotent request you are misusing those verbs and telling your users something about your API which is a lie. It's wrong.
Except the verbs for REST are well defined and documented. Deciding you can ignore them and still claim to be RESTful isn't debating the colour of a bikeshed.
I've not delved massively into the MailboxProcessor yet! That said, here's my initial impressions: * Akka.NET has a lot more... *stuff* out of the box (the TCP actors being a prime example of that). It's a full framework, whereas the built-in API is a bit more bare-bones. * On the other hand, MailboxProcessor feels a lot better integrated with the language, as you'd expect. For example, it uses `async` computation expressions, whereas Akka.NET has its own `actor` one. Also, actor references in Akka.NET are untyped (i.e. there's no way to have a function/record take in 'an actor that accepts `MessageType` messages'). That last point has really thrown me for a loop while trying to write part two of this series - if I wanted to be that loose with types, I wouldn't be using F#. There's third-party addons like [Akkling](https://github.com/Horusiath/Akkling) that provide proper static typing, but it makes me sad that it's not part of the main API. I'm actually kinda considering restarting this series just using MailboxProcessor, if I can find an easy way to link up the TCP side of things. Need to play around with it some more.
But why is c# extension methods extra code? As far as I could tell its one F# function = one c# extension method.
Yes, computation expressions incur overhead costs and if they are used everywhere can significantly impact performance. 
Noted. Is there any way you manage side effects?
Yeah, agreed! In general, I find the operators in F# to be a lot more understandable at a glance than in other functional languages - e.g `$` and `.` in Haskell vs `|&gt;` and `&gt;&gt;`.
I'd advise against using the `IO` monad in F#. It's made necessary in Haskell by the non-strict evaluation strategy, and made ergonomic by the presence of higher-kinded types, monad transformers, etc. F# has none of those things. I suggest using F# like a better Erlang. Or, code the pure stuff functionally, and tie everything together with a minimally stateful object-oriented layer.
Whoops, yeah, you're right.
Maybe it should be said explicitly: The IO Monad is a very elegant solution to a problem that does not exist in any other language. 
&gt; but you should be aware that your program can end up several times slower than necessary just by using computation expressions That's fair. I'm mostly "F#-curious" coming from Haskell and knowing monads only as a general FP principle (that is, "monads are just 2 function signatures, bind and return, and a couple laws"). Don't know enough about F# "computation expressions", are they like C#'s LINQ in that they are essentially code-generating metaprogramming (ie in theory "just mostly a compile-time cost")? &gt; than the old convention not to modify observable state in a function that doesn't return void Which is certainly good enough in my book (aka for realistically my sorts of use-cases)!
Computation Expressions are Monads plus some mechanisms for syntax that allows you to implement stuff like query { for student in db.Student do where student.Age.HasValue sortBy student.Age.Value thenBy student.Name select student } as a library without changing the language. I think this demonstrates the difference between the use cases in Haskel and F#. In Haskell, Monads are a necessity to get stuff done. In F#, they are mostly used for creating tiny DSLs. 
Separate the pure functions from impure functions and write the maximum of pure functions you can or just separate functions that computes from functions that does IO or deals with mutability. Haskell uses IO actions to do it, but in F# and OCaml the developer that have to enforce that.
Don't classes cover a full superset of the functionality of ML-style functors? I have yet to find a functor-dependent construct that can't be mimicked with them, and I've found plenty of use cases of classes that can't be mimicked (or at least not without hacky workarounds) with functors. And yet it seems common for FP style programmers to lament the lack of functors in F#, but will consider it a codesmell to use classes. Am I missing something here? What does a functor do that is so taboo to do with classes?
Official 1.0 beta announcement here: http://fable.io/blog/Introducing-1-0-beta.html
`Async.StartAsTask` doesn't create a new thread. It instantiates a new `Task` object, which could then be awaited by some C# `async` code. Whether or not that leads to a new thread being created is up to the C# code. &gt; Also, is there a way for me not to repeat the function parameters for the C# version of the function? It depends. If you structure your code properly then you can omit some parameters and make use of partial application. What I see in the above doesn't look like it could be reasonably reduced in that way unless you put another layer of abstraction around it. There's probably some monadic pattern you could use that makes it more "nice". You might be able to write your own operator for this, though I wouldn't necessarily recommend that unless you find yourself using it a lot. &gt; In general, is this a good approach? It's a perfectly suitable approach to learning F#, though diving into the interop between C# and F# async is definitely going to be more difficult. C# and F# have different asynchronous programming models (C# is a hot-task mode and F# is a cold-task model). This leads to some frustration in bridging the gap. I also curse a little when I must interop with a C# async method returning the non-parameterized Task object.
Thanks for your reply. So I went ahead and started writing more F# code and things are going well. I have one more question regarding passing null values to C# libraries. Right now I'm using record types (because of their strictness and simplicity) for my Entity Framework models, but sometimes I need to pass null in them. I wrote this little function for that: let unsafe option = match option with | Some value -&gt; value | None -&gt; Unchecked.defaultof&lt;'T&gt; Whenever I have to create a new model with null I just do something like this: let thing:Thing = { Id = 0; Name = name; Foo = unsafe foo } where foo is an Option. I googled a bit and couldn't find anyone discussing this problem and as far as I can tell this approach is pretty clean?
Interfaces are great for when you need open types, such as for pluggable systems. However, you do not need classes in many cases even though you're using interfaces. Often you will want to define an interface, and then implement it with a record whose fields are private. This allows us to achieve the additional level of open abstraction while remaining pure. I go into detail on how to do achieve this in F# here - https://vimeo.com/128464151
What does the 'Lu' stand for?
I'm guessing but Lightweight Utilities?
Here is a cross platform GUI I wrote in F# using vscode https://github.com/kaeedo/cursed Note the project references in the fsproj files, added there by paket
BTW is there any way to use Qt with f#?
Haven't tried it, but there are C# bindings: https://github.com/ddobrev/QtSharp Should be usable from F# as well.
Can you expand on this? Because C# classes can contain type definitions, right? Does that help us? Isn't it "just" a syntax thing?
That must be it!
Oops, right, I forgot all F#-created types are non-nullable by default.
[This.](https://xkcd.com/927/)
[Image](https://imgs.xkcd.com/comics/standards.png) [Mobile](https://m.xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini\-USB\. Or is it micro\-USB? Shit\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/927#Explanation) **Stats:** This comic has been referenced 4391 times, representing 2.8591% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_dfjsmtu)
Remind me again: which characters do you use for S-expressions? This blog entry uses [] but most lisps user ()... what gives?
"Can Beat" at what? The only real quality of XML and JSON is their planetary widespread adoption, *meaning*: they belong *entirely* to the category of data-file formats summarized as "wouldn't ever use it except I need to interop with it and/or there's a ready parser sitting in my programming language". Both down to nothing but network effects. In isolation, one can (&amp; usually does &amp; has for decades) freely use whatever random custom formats are deemed "best", this doesn't "beat" json/xml's only real quality as I outlined it =) &gt; Don’t even think about doing this type of thing with XML or Json Seriously wondering whom this lengthy piece is even addressing here? Who ever *would* want to in the first place? Some kid who wants scriptability and write their own interpreter but not their own parser?
As a scheme guy since forever I welcome you all to the land of Lisp. We always look in envy at all the cool things going on in ML-land. Sometimes we try ourselves, but after some time we go back to the deceiving comfort of dynamic typing. Btw: sxml is a thing. Serialising sxml to XML is easy-peasy.
Is you use VS and target .net framework on windows i would use WPF with [FsXaml](https://github.com/fsprojects/FsXaml) and [FSharp.ViewModule](https://github.com/fsprojects/FSharp.ViewModule), it integrate with VS's Xaml tooling there are good. If your target are not the .net framework on windows, i would use [fable](http://fable.io/) to generate JS (with react+the rest of the JS stack as the gui) and use node.js to run it. It has the pro of not require .net on the target (but only node.js and only .net cor on the build machine. 
Got excited, and clicked through the nuget link: https://www.nuget.org/packages/Prime/ ... and was greeted with this: &gt; An F# code library for hardcore pure functional programming, and much more! I don't want hardcore pure functional programming, I want a succinct yaml replacement, damnit :). Folks using this already?
Just F# programmers. This article attempts to make a general case as why s-expressions can be superior to XML and Json. The library is just one instance of this more general phenomenon in F#. However, I do have a partial port to C# with better support for object-oriented constructs such as Dictionaries and HashSets, but it's missing some features, including the scripting language - https://github.com/bryanedds/Sigma
This came to my mind before that one: https://en.wikipedia.org/wiki/Greenspun's_tenth_rule
Ah, that's good, because this part of the library isn't 'hardcore' pure functional - it's just plain old F# / .NET coding. However, to support more normal C#-style coding, I'd have to add serialzation routines for Dictionary, HashSet, and who knows how many other C# collections... Not a super small task.
Clojure is a lisp that uses (), [], and {}. I personally use [] because when you have to type a lot of them, it's much much easier than () since the latter requires a shift key hold (where the shift often contorts the wrist / hand a bit).
Aye, even in F# where () aren't used for everything, typing them out is somewhat painful and tedious.
Ah, I did not consider German keyboards! Wow, that really sucks, actually. I could make the reader allow both () and [], but the problem is that there's no way to know which to write it back out as. Plus, I'd really like to keep the () syntax reserved in cases it's needed for something else. It's frustrating tho, that German keyboards are so different :/ Damn...
It is hard to replace xml and json due to the network effect. But for an embedded scripting language, configuration format, extension language like Lua or custom build scripts s-expressions are much better. Example of a bad xml usage are the verbose msbuild build scripts and Java ant build scritpts. A successful example of s-expressions usage as extension language and configuration format is Emacs. 
Good or bad is largely irrelevant, it's about people being able to read and work with the config. Emacs is built in lisp, s expressions in lisp are a good match, it's hardly a standard.
I'm working on writing Azure functions with F#. I've been working on it for a week and haven't used F# previously but have functional programming experience from Elm and Elixir. What I'm noticing is that docs from .NET libraries are hard to understand because the examples aren't in F#. Understand async is also challenging. Other than that, my time is going into understanding how Azure Functions work. Luckily, there's a lot of example functions that I can work off.
I'm working for a solar power plant monitoring company. Past weeks I've been working on building an svg with the logical diagram of a solar power plant. It shows the different logical nodes that represent different industrial components (solar panels, inversors, etc) color coded following several thresholds for energy and power. I'm using data trees to represent the information of the plant, operating on those trees to filter levels with too many nodes, or select sub trees to zoom into some detail. Lots of Seq.fold and Seq.map, lots of recursion. Pretty basic stuff. 
I'm working on a puzzle game for mobile. The puzzle generation code is working in F# and will be hosted on Azure. I'm just getting into the xamarin side. Will likely do that in C# because....docs, examples, etc. F# was great for this task. Lots of recursion and I just can't tolerate OO anymore. This is my first F# project. I like the language so far, but the syntax is a lot more complicated than Clojure (from my perspective). I do like tail recursion and match/with and discriminated unions. The list comprehensions are also ultra powerful.
Let me know if you need a hand.
I'm trying to port create react app (CRA) to use Fable compiler. I think it will help people get up and running quicker with Fable! If any of you want to try it, you have to have .net core and create-react-app ( https://github.com/facebookincubator/create-react-app ) installed, and then type: create-react-app --scripts-version fable-react-scripts myfableapp Repo: https://github.com/lucasmreis/create-react-app
This sounds absolutely fantastic!
I was wondering what libraries / frameworks you were using to display these diagrams. 
Yeah, well known idioms can be pretty clear with point free style. Same applies e.g. to Suave webpart composition - people learn how it works, after which it's just expressive instead of being cryptic (albeit with longer learning curve)
Speaking from experience, you may want to start a lot smaller than you want to. Learning programming by starting with such a (relatively) complex task is a great way to get burned out. Try learning by doing the easy challenges on /r/dailyprogrammer so that you can get a basic grasp of how programming works. Don't feel bad for peeking at the experienced programmer's answers either. 
Hi, thank you for replying. Yes so i want to create a program which will answer using pre defined answers? so if i were to type in hi in the console, i'd want the pogram to reply with a predefined answer. hope i have made myself clear lol
Why not make a super simple chatbot, where: if the input string from the user contains "hi" or "hello", then print some appropriate response. And then do the same thing with other user inputs. That's pretty straight forward.
lol is there any guides on how to begin with this? (total noob at programming im sorry haha)
I can give you a tiny framework to start with, and you can go from there :) Put the following in a `chatbot.fsx` file: module ChatBot let respond (input : string) = match input with | _ when input.Contains("hi") -&gt; "Good day to you :-)" | _ when input.Contains("hello") -&gt; "Why, hello there." | _ -&gt; "Not sure what you mean buddy." Then, to play around with it open F# Interactive: type `fsi` into a PowerShell on Windows, or `fsharpi` on Linux or OSX in a terminal. To load your file, simply type: #load "chatbot.fsx";; open ChatBot;; respond "hi there";; From there, you should be able to extend and play around with the idea :-). Try and have a look at https://fsharpforfunandprofit.com/ for more help, and when you are ready to take on some more advanced features, active patterns may increase the readability of your code, [this example on StackOverflow may help](http://stackoverflow.com/questions/5062377/problems-with-pattern-matching-in-f/5062466#5062466).
I thought it [already is usable](https://github.com/dotnet/netcorecli-fsc/wiki/.NET-Core-SDK-1.0.1)?
I really like that effort !
Yea, I figured that F# developers would see that feature, go "ok cool", and quickly move onto the next one. So in that section I was pandering a bit to the C#/Java devs who are more casually learning about F#.
By the way, is the Fixed keyword actually new? In some places it looks like it was in F# 4.0, in others 4.1. 
Yes, Entity Framework was disqualified for not supporting Oracle. Type Providers were disqualified for a variety of reasons. Mostly to do with ease of debugging, performance, vast complexity / "magic". Most of the queries are over types not known at compile time too. I don't know if Type Providers support .Net Core either, running there is a long-term goal of dropping NHibernate.
I'm using EF with​ Oracle in production since years. Is it some specific requirement / version combination that you couldn't make work?
From what I know the new version (6) doesn't support Oracle, older versions don't support .Net Core. If that is the case I believe it is still not suitable for us for other reasons but I'm not the one who makes these decisions, just the drone who implements them :) 
I'm using EF 6.0 on .NET 4.5.1 with Oracle's ODP.NET Managed Driver and Oracle 11g. Time to talk to your decision maker. Making your own ORM is rarely a good idea. But it can be fun indeed ;-)
Might want to point out a * b is a tuple type signature, instead of 'fields' annotation
THANK YOU SO MUCH FOR THAT! You're awesome x
I think the worst part is async in F# - overall it just seems worse in every way compared to C# async. * An order of magnitude [worse performance](http://stackoverflow.com/questions/35762747/performance-of-async-in-f-vs-c-sharp-is-there-a-better-way-to-write-async) * The performance problem mentioned above creates further problems, because then you have to make a [decision](https://github.com/haf/Http.fs/issues/110) about whether it is good enough for your use case, or if you should try something else like Hopac. And when you are making a library, you have to make the decision for the person who will use your library, which is a huge bummer. This is a dilemma that people who use C# async do not have. * Workflow syntax is not intuitive. For example, this code prints out `"Launch Missiles"`, but most people would not expect it to print anything: let threatLevel = 1 async { if threatLevel &lt; 5 then return () System.Console.WriteLine("Launch missiles") } |&gt; Async.RunSynchronously You can work around this by converting it to `if then else`, but that does not scale, so people have to resort to other custom computation expressions like `asyncMaybe`, which has its own problems. ([Here](https://github.com/Hopac/Hopac.Extras/blob/856f7a429e2d292100daf21fd246019a40df289c/src/Hopac.Extras/Control.fs#L38) is one for `job` in Hopac (alternative async library). Similar ones exist for async. In C# you would just use the `return` keyword and return early from the function, which is simpler. - Some of the gotchas that people [point out](http://tomasp.net/blog/csharp-async-gotchas.aspx/) for async in C# have been [fixed](http://imgur.com/a/bcew5). (For example, you get a warning now in C# for tasks that you do not assign to a variable or `await`.) 
Microsoft's lack of commitment to providing the manpower to keep F# relevant and up to date.
Anything that has to do with interoperability with other systems, especially data access hits hard. You design a great model that enforces you business logic during compile time, and than find out that you'll have to cast to something way worse whenever you wrote all that to the db, get it from an api, etc.
That's why I'm working on an ORM that actually understands things like immutable objects and collections. I'm tired of ORMs that force everything into the fat entity model.
Isn't async a monad? In that case I'd expect return to work like that. 
It had not occurred to me to do so. Would you suggest I do? If so, where do they usually hang out? To be honest, I do not really see what they could help in this regard. The monorphisation issue in higher order functions is there because F# lacks higher ranked functions, and a smooth integration between the Cuda backend and the main library would require either some kind of dependent typing or metaprogramming both of which F# lacks.
Since you've posted this in the F# subreddit, I assume you're interested in using F# to write your game. In which case, I'd recommend two resources: 1. The excellent http://fsharpforfunandprofit.com/ website (linked in the "Learning Resources" that you can see in the right sidebar here), and 2. The following Youtube playlist: https://www.youtube.com/playlist?list=PLEoMzSkcN8oNiJ67Hd7oRGgD1d4YBxYGC Unfortunately, the guy making that series stopped after five videos, and videos 4 and 5 contain some concepts that could have really used a bit more explanation in video #6. But it's a great introduction to F#, and it even uses a simple text adventure game as the example! BTW, the tools I'd recommend you use are: * An installation of F# on your computer. See http://fsharp.org/use/windows/ (or /mac or /linux depending on your OS) for how to get that. * Visual Studio Code * The Ionide-fsharp plugin for VS Code If you have more questions, especially of the "how do I get F# or these other tools installed?" variety, the first person you should ask is the professor who assigned you the homework. Then ask here, or on Stack Overflow. Good luck, and have fun!
It is a computation expression, which need not follow monad laws. Here is an example of "imperative builder", which implements early return. http://tomasp.net/blog/imperative-i-return.aspx/ From that page, this: let test() = imperative { return 0 printfn "after return!" return 1 } Turns into this: imperative.Run (imperative.Combine (imperative.Return(0), imperative.Delay(fun () -&gt; printfn "after return" imperative.Return(1)))) Which means it is a matter of implementing "Combine" correctly in your builder. 
Nice! Another demoscene tool written in F# is LLB's [Shader Minifier](https://github.com/laurentlb/Shader_Minifier/).
Constructing record instances without specifying a type of the record. (It is possible to specify it, but completely inconvenient) e.g. returning {x: 1; y: 2} gives you an error, when you have a Rect type, where some properties coincide with a Point type. Typing { Point.x: 1; y: 2} seems odd, { Point.x: 1; Point.y: 2} seems redunant.
Mandatory explicit up-casting. You can not return MemoryStream, if function must ruturn Stream withou up-casting. 
If MS doesn't put some power behind F# soon its going to have a hard time competing with Scala and then ultimately the Java echo system. C# has a smaller community than Java and F# has a much smaller community than Scala. C# is going to grow in popularity thanks to .NET core but if MS want to attract the best developers they have to put more effort in to F#. Ex: Make F# a first class citizen of .NET and visual studio. Pay JetBrains to bring F# support to their IDE. The fact that the F# templates for *dotnet new* in the 1st version of dotnet core were broken says it all. Its like the first happy case test you should make and even that didn't work. **Microsoft**: .NET Core is awesome but to attract the best programmers you have to put some more effort in to F#!! Or make Scala a 1st class citizen on .NET.
Agreed. A smarter syntax would have been to just put the record name first. For example, in Elixir, they do `%Point { x: 1, y: 2 }`, which is friendlier both for humans and for tooling.
&gt; its going to have a hard time competing with Scala Scala is a language for disgruntled people stuck on the JVM to jump ship to. So F# doesn't compete with Scala. &gt; if MS want to attract the best developers they have to put more effort in to F#. I don't think "MS" are unified enough on this to have a view. &gt; The fact that the F# templates for dotnet new in the 1st version of dotnet core were broken says it all. Its like the first happy case test you should make and even that didn't work. Oh yes. That is a disaster. Visual Studio 2017 shipping with horribly broken F# support is another disaster. That's exactly what you do if you want to kill the language. WinRT having no support for F# was also a disaster (I had to advise one of the world's largest insurance companies to buy 10,000 iPads instead of Surface tablets because iPads had better support for F# than Microsoft's own tablets). &gt; Or make Scala a 1st class citizen on .NET. Scala is so grim I cannot see it ever attracting quality developers. Just read what [the authors of the Scala compiler say about Scala](https://www.slideshare.net/mobile/extempore/keynote-pnw-scala-2013).
&gt; F# is pretty damn state-of-the-art when it comes to metaprogramming F# doesn't even have decent support for parsing. I wish F# had decent support for metaprogramming but... &gt; type providers You can use type providers for metaprogramming but I'm not sure they constitute metaprogramming in and of themselves. &gt; quasiquotations F# has poor support for quotations. You cannot even quote type definitions. There is no built in quotation compiler (just an incredibly slow interpreter that only works on a tiny subset of the language). You can do reflected definitions but they're grim for other reasons. &gt; computation expressions They're just monads so not metaprogramming. &gt; Reflection.Emit Pretty useless IME. When performance isn't important I just write an interpreter. When performance is important I don't want to be limited by the CLR so I'll use something like LLVM (except F#, .NET and Windows have poor support for LLVM). &gt; and I'm probably forgetting a bunch more. Macros except F# has no macros. Parser generators like lex and yacc except fslex and fsyacc were distributed as a sideshow called the PowerPack that died and they were never finished as tools (i.e. feature parity with ocamllex and ocamlyacc) because they were only ever built to compile the F# compiler itself. Within the MetaLanguage family I'd say F# was far and away the worst language for metaprogramming and the main reason is that F# makes parsing really hard. Just to give you some idea of what I am talking about [here is a compiler I wrote in 100 lines of OCaml code using LLVM](https://groups.google.com/forum/#!msg/fa.caml/i6IgSFX8XkY/4khF8z1V7loJ) that has an inline parser in just 15 lines of code: expr: [ [ "if"; p = expr; "then"; t = expr; "else"; f = expr -&gt; If(p, t, f) ] | [ e1 = expr; "&lt;="; e2 = expr -&gt; BinOp(`Leq, e1, e2) ] | [ e1 = expr; "+"; e2 = expr -&gt; BinOp(`Add, e1, e2) | e1 = expr; "-"; e2 = expr -&gt; BinOp(`Sub, e1, e2) ] | [ f = expr; x = expr -&gt; Apply(f, x) ] | [ v = LIDENT -&gt; Var v | n = INT -&gt; Int(int_of_string n) | "("; e = expr; ")" -&gt; e ] ]; defn: [ [ "let"; "rec"; f = LIDENT; x = LIDENT; "="; body = expr -&gt; LetRec(f, x, body) ] ]; prog: [ [ defns = LIST0 defn; "do"; run = expr -&gt; defns, run ] ]; What is the F# equivalent of that parser? That's a rhetorical question because I just wrote the same program in F# and the parser (using my own parser combinators) weighs in at almost 1,000 lines of code, i.e. almost 100x longer. You can pull in FParsec instead but [it still requires 50 lines of F# code and it is unintelligible compared to that OCaml](https://gist.github.com/jdh30/8289c160ff29ff3d19e2e4eecbabe3de). You can do it in 100 lines of non-F# code using [fslex and fsyacc](https://gist.github.com/jdh30/de3c157c12396830f439ffbfc7b9ec1a) but that requires multistage compilation which Visual Studio doesn't support so it grinds development to a halt. Or you can do it in [57 lines of vanilla F# code using active patterns](https://gist.github.com/jdh30/38ea9080aa8088364cf5e195600ff234) which is at least comprehensible but still objectively far uglier than it needs to be and it doesn't give you any location information so you don't get the nice syntax error messages that OCaml gives you for free. IME parsing is the single most common metaprogramming task that I find myself solving. Decent parsing tools are vastly more practically important to me than `Reflection.Emit`. As these examples show, F# requires 3x more code to do the same thing. I've actually been thinking about this a lot lately and studying how other languages do it. OMeta is an interesting alternative. But the fact that OCaml already got this right really kills me because I'd like F# to be as good as OCaml in every respect. Now, if you look at what is needed from a language design point of view and generalize to not-just-text then I think the problem boils down to the limitations of ML pattern matching which works great on constant literals, tuples, records and unions but it sucks on sequences. Constant-time patterns on arrays like `[|x..|]` to mean `xs.[0] when xs.Length&gt;0` and similarly `[|..x|]` would be a start but parsing requires a lot more. I'd like pattern matching over regular expressions that is properly optimised. Today you can write an active pattern to match a given regular expression and you can even memoize the compiled regular expression thanks to .NET but F# makes no attempt to share commonality between different regular expressions in different match cases so it is extremely slow because the same prefixes are rematched over and over again. So you need at least: let myLexer = lex | "[0-9]+" as s -&gt; Int(int s) | "[a-z][a-zA-Z0-9]*" as s -&gt; Symbol s | ... Then I'd also want the ability to use such patterns (and patterns in general) to match sequences. Finally, I want the Kleene `*` and `+` to match many values in a sequence. And this all needs to work with on-demand sequences like file streams. Reading the recent work on [parser derivatives](http://matt.might.net/articles/parsing-with-derivatives/) makes me wonder if that might not help. **EDIT**: I had to move my F# solutions to Github gists because they are too long for Reddit to handle, which underlines my point! 
The SQL type provider is useless for SQLite, where you don't have a static connection string. The best would be using something like a [DBML](https://msdn.microsoft.com/en-us/library/bb386987(v=vs.110\).aspx) type provider, but I'm not aware of anything similar which is currently maintained.
&gt; this code prints out "Launch Missiles", but most people would not expect it to print anything: Fair point. That should be read as: if threatLevel &lt; 5 then () System.Console.WriteLine("Launch missiles") And if new languages restrict consideration to what people who only know Algol will think then they'll never get anywhere. F# async is incredibly slow (250x slower than ordinary code last I looked) but I just opted to use it as little as possible which is fine. C# being 10x faster is still uninteresting to me because it still falls into the "fall too slow to be generally useful" category. 
Here is my take on it: 1) The type system. Yes, that. It's hard to consume F# code from C#, F#types are alien to the rest of .NET. This has been especially true for serialization. e.g. when we built Akka.NET F# support, the F# type system was always a problem because it was hard to anticipate what was actually going on under the cover. Serializing F# types is a pain, they are not designed for that so you end up with a lot of hard coded rules on how to serialize those. 2) The community. Yes, that. A lot of F# projects are one man shows. There is a sense of move fast and break things in the F# community. Taking dependency on F# libraries have cost me quite a few hours as things are redesigned from time to time. 3) Integration with the rest of the .NET ecosystem. Again, much of this comes back to the typesystem, but also the functional aspect of F# is best used with duh, functional API's. In order to fully support F# for your own API's , then you pretty much need a dedicated F# API wrapper. I was planning to add that to Proto.Actor, but, it turns out there is no decent way to use ProtoBuf from F#. There is no ProtoBuf to F# types generator or mapper (AFAIK). There is FROTO, but it seems to be just generating plain vanilla mutable POCO's. 
&gt; Especially under VS Code On Windows I recommend WPF. Elsewhere I've heard GTK# is good. 
&gt; Why did FSharp.Formatting not work for you? Unfortunately, it is crashing and it is seems that its development is halted. I am running it on Linux with Mono. &gt; But it apparently didn't do what you want, since you're still asking this question. What was it lacking? Here what is happening. I am trying to generate the documentation for a single-file library, but I am getting trouble. I tried to use this: - https://www.nuget.org/packages/FSharp.Formatting.CommandTool/ - [F# Formatting: Command line tool](https://tpetricek.github.io/FSharp.Formatting/commandline.html) Project Structure: $ tree . . ├── apidocs ├── build.fsx ├── build.sh ├── fxgtk2 │ ├── AssemblyInfo.fs │ ├── bin │ │ └── Debug │ │ ├── FSharp.Core.dll │ │ ├── fxgtk2.dll │ │ ├── fxgtk2.dll.mdb │ │ └── fxgtk2.XML │ ├── Component1.fs │ ├── fxgtk2.fsproj │ ├── fxgtk2.zip │ ├── obj │ │ └── Debug │ │ ├── fxgtk2.dll │ │ ├── fxgtk2.dll.mdb │ │ └── fxgtk2.fsproj.FilesWrittenAbsolute.txt │ ├── packages.config │ └── Script.fsx ├── fxgtk2.sln ├── fxgtk2.userprefs └── packages File: build.sh #!/usr/bin/env sh fsformat=/home/archbox/Projects/fxgtk2/packages/FSharp.Formatting.CommandTool.2.14.4/tools/fsformatting.exe templates=/home/archbox/Projects/fxgtk2/packages/FSharp.Formatting.CommandTool.2.14.4/templates $fsformat metadataFormat \ --generate \ --dllFiles /home/archbox/Projects/fxgtk2/fxgtk2/bin/Debug/fxgtk2.dll \ /lib/mono/gtk-sharp-3.0/atk-sharp.dll \ /lib/mono/gtk-sharp-3.0/cairo-sharp.dll \ /lib/mono/gtk-sharp-3.0/gdk-sharp.dll \ /lib/mono/gtk-sharp-3.0/gio-sharp.dll \ /lib/mono/gtk-sharp-3.0/glib-sharp.dll \ /lib/mono/gtk-sharp-3.0/gtk-sharp.dll \ /lib/mono/gtk-sharp-3.0/pango-sharp.dll \ --xmlFile /home/archbox/Projects/fxgtk2/fxgtk2/bin/Debug/fxgtk2.XML \ --outDir "apidocs" \ --layoutRoots $templates \ --parameters "page-author" "Your name(s)" \ "page-description" "A package for ..." \ "github-link" "http://github.com/yourname/project" \ "project-name" "your project name" \ "root" "http://yourname.github.io/project" Errors: FSharp.Formatting Error: 0 : Error while building member-name for fxgtk2.App.runWith because: not a named type FSharp.Formatting Error: 0 : Error while building member-name for fxgtk2.App.withThread because: not a named type FSharp.Formatting Error: 0 : Error while building member-name for fxgtk2.App.invoke because: not a named type FSharp.Formatting Error: 0 : Error while building member-name for fxgtk2.Draw.DrawCmd.forEach because: not a named type FSharp.Formatting Error: 0 : Error while building member-name for fxgtk2.Draw.DrawCmd.forRange because: not a named type FSharp.Formatting Error: 0 : Error while building member-name for Atk.ComponentAdapter.GetExtents because: the type 'byref`1' does not have a qualified name FSharp.Formatting Error: 0 : Error while building member-name for Atk.ComponentAdapter.GetPosition because: the type 'byref`1' does not have a qualified name FSharp.Formatting Error: 0 : Error while building member-name for Atk.ComponentAdapter.GetSize because: the type 'byref`1' does not have a qualified name FSharp.Formatting Error: 0 : Error while building member-name for Atk.EditableTextAdapter.InsertText because: the type 'byref`1' does not have a qualified name FSharp.Formatting Error: 0 : Error while building member-name for Atk.IComponent.GetExtents because: the type 'byref`1' does not have a qualified name ... ... ... FSharp.Formatting Error: 0 : Error while building member-name for Pango.TabArray.GetTab because: the type 'byref`1' does not have a qualified name FSharp.Formatting Error: 0 : Error while building member-name for Pango.TabArray.GetTabs because: the type 'byref`1' does not have a qualified name FSharp.Formatting Information: 0 : Starting razor engine FSharp.Formatting Information: 0 : Generating: index.html FSharp.Formatting Error: 0 : received exception in MetadataFormat.Generate: System.Exception: Could not find template file: namespaces.cshtml Searching in: ["/home/archbox/Projects/fxgtk2/packages/FSharp.Formatting.CommandTool.2.14.4/templates"] at FSharp.MetadataFormat.RazorEngineCache+resolve@148.Invoke (System.String message) [0x00001] in &lt;5750b8002a458525a745038300b85057&gt;:0 at Microsoft.FSharp.Core.PrintfImpl+StringPrintfEnv`1[TResult].Finalize () [0x00012] in &lt;5584aad2904cf4daa7450383d2aa8455&gt;:0 at Microsoft.FSharp.Core.PrintfImpl+Final2@235[TState,TResidue,TResult,A,B].Invoke (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] env, A a, B b) [0x0005a] in &lt;5584aad2904cf4daa7450383d2aa8455&gt;:0 at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3266-1[T2,T3,TResult,T1].Invoke (T2 u, T3 v) [0x00001] in &lt;5584aad2904cf4daa7450383d2aa8455&gt;:0 at Microsoft.FSharp.Core.OptimizedClosures+Invoke@3253[T2,TResult,T1].Invoke (T2 u) [0x00001] in &lt;5584aad2904cf4daa7450383d2aa8455&gt;:0 at FSharp.MetadataFormat.RazorEngineCache+resolve@148-2.Invoke (System.Collections.Generic.IEnumerable`1[T] arg20) [0x00001] in &lt;5750b8002a458525a745038300b85057&gt;:0 at Microsoft.FSharp.Core.FSharpFunc`2[T,TResult].InvokeFast[V] (Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] func, T arg1, TResult arg2) [0x0001f] in &lt;5584aad2904cf4daa7450383d2aa8455&gt;:0 at FSharp.MetadataFormat.RazorEngineCache.resolve (System.Collections.Generic.IEnumerable`1[T] layoutRoots, System.String name) [0x00027] in &lt;5750b8002a458525a745038300b85057&gt;:0 at System.Collections.Concurrent.ConcurrentDictionary`2[TKey,TValue].GetOrAdd (TKey key, System.Func`2[T,TResult] valueFactory) [0x00037] in &lt;f712f98eb8e445c8918edaf595bbe465&gt;:0 at FSharp.MetadataFormat.RazorEngineCache+templateManager@156.RazorEngine-Templating-ITemplateManager-GetKey (System.String name, RazorEngine.Templating.ResolveType resolveType, RazorEngine.Templating.ITemplateKey context) [0x00014] in &lt;5750b8002a458525a745038300b85057&gt;:0 at RazorEngine.Templating.RazorEngineCore.GetKey (System.String cacheName, RazorEngine.Templating.ResolveType resolveType, RazorEngine.Templating.ITemplateKey context) [0x0000b] in &lt;9167e862ba7847e3b6f275d4ad0c7f26&gt;:0 at RazorEngine.Templating.RazorEngineService.GetKey (System.String cacheName, RazorEngine.Templating.ResolveType resolveType, RazorEngine.Templating.ITemplateKey context) [0x00000] in &lt;9167e862ba7847e3b6f275d4ad0c7f26&gt;:0 at RazorEngine.Templating.DynamicWrapperService.GetKey (System.String name, RazorEngine.Templating.ResolveType resolveType, RazorEngine.Templating.ITemplateKey context) [0x00000] in &lt;9167e862ba7847e3b6f275d4ad0c7f26&gt;:0 at &lt;StartupCode$FSharp-MetadataFormat&gt;.$Razor+ProcessFileModel@259[b].Invoke (Microsoft.FSharp.Core.Unit _arg1) [0x00001] in &lt;5750b8002a458525a745038300b85057&gt;:0 at FSharp.MetadataFormat.RazorRender.handleCompile[a] (System.String source, Microsoft.FSharp.Core.FSharpFunc`2[T,TResult] f) [0x00002] in &lt;5750b8002a458525a745038300b85057&gt;:0 Tooling version: $ mono --version Mono JIT compiler version 4.8.0 (Stable 4.8.0.495/e4a3cf3 Mon Feb 27 08:30:18 UTC 2017) Copyright (C) 2002-2014 Novell, Inc, Xamarin Inc and Contributors. www.mono-project.com TLS: __thread SIGSEGV: altstack Notifications: epoll Architecture: amd64 Disabled: none Misc: softdebug LLVM: supported, not enabled. GC: sgen $ fsharpi --help F# Interactive for F# 4.1 
What makes you think in this way? Is the language support? .NET framework documentation? Tooling? IDEs? Most of C# code can be easily ported to F# without much effort and many times with less and shorter code. Despite Java platform has many languages like Scala, Jruby, Jpython, Clojure and etc, the core language is Java and most of JVM libraries are documented in Java. The same thing happens for .NET and C#.
&gt; The fact that the F# templates for dotnet new in the 1st version of dotnet core were broken says it all. The ones that were broken for .NET Core SDK Preview 1-buildwhateverthefuckingnumber? Or was it Preview 2-build010128137194? I remember that time as well, and I remember dealing with the absolute disaster that was _.NET Core_ at that point, where a runtime was shipped but tools were unusable...and there was a blog post saying that the tools would be completely rewritten again. Not that F# should be broken on that, but perspective matters here. Anyone jumping on that ship at the time was due for a lot of pain.
I mean that SQLite databases are typically constructed at run-time, so there's no pre-existing instance to provide your types.
Linux also primarily has a self service community fixing and patching as needed.
And that's cool for hobby purpouses. But if you expect anybody to use this "professionally" you will have to put in the money. That's the problem I'm pointing out. MS doesn't put in the money to maintain the this as for example the The Linux Foundation pays Debian developers to create deterministic builds packages for both LLVM + GCC. I don't hear of MS doing anything like this given the tools the Community provides ...
&gt; For x a class with member a = ..., writing x.a re-evaluates every time. This initially confused me too. You can use the `member val a = ...` syntax to initialise a get-only property. I made a suggestion that the compiler should warn in some situations [here](https://github.com/fsharp/fslang-suggestions/issues/549).
&gt; Scala is so grim I cannot see it ever attracting quality developers. Just read what the authors of the Scala compiler say about Scala. That it's an example that means nothing. It's a rounding problem with the JVM. Scala could be a bit more verbose than F# and missing something, for me nice, as auto-currying or modularization, but it's more advanced in meta-programming, generic type programming and a better interop with the other JVM languages (not to mention a more established and better community, more effective OSS projects and more in production code, starting with Twitter, but also Linkedin, Airbnb, Netflix, most of the newspaper and media company at least here in UK, banks, and so on). The better support for meta-programming allows Scala to have a better and more extensible type system, support better Haskell-like construct like type classes, ADTs, HKT and (still don't know why all this fear to embrace the concept) monads: Scala doesn't have native support for that too (it doesn't enforce by default a strict compliance to the monad laws), except for some "monadic" data structure like Option, Either and Future, but libraries like Scalaz (that I liked from the start cause it's implementing the same forward pipe operator like in F#, something I was missing in Scala), Cats, Shapeless and so on prooved quite well the flexibility and the power of the language (with, perhaps, some performance concerns when overused). It's true that a lot of people is still using Scala like a "better Java" but it doesn't mean this is a problem with the language itself.
&gt; whoever implemented the async builder in F# made a bad decision - they could have made it actually return early That would be a bad decision because it diverges from expression-based code which is the foundation of F# (and ML). The only "problem" I see here is that `return` doesn't mean the same thing in F# as it does in C# which might be confusing for people who only know C#. Changing the semantics of F# code in async but not outside async would be even more confusing... &gt; And there is no good way to rewrite this in F# Like this: async { let! threatLevel = getThreatLevel() if threatLevel &gt;= 7 then let! nsaRecommendation = getNsaRec threatLevel match nsaRecommendation with | Stop -&gt; () | _ -&gt; let! decision = getReptilianOverlordDecision threatLevel nsaRecommendation match decision with | Halt -&gt; () | _ -&gt; printfn "Launch missiles" } &gt; are starting to get competitive benchmark results I don't follow. They seem to be comparing with things like node.js that are notoriously slow. At first glance it looks like ASP.NET Core is competitive with Scala but then it turns out they're loading Scala with 4x more connections and still losing. &gt; Imagine if they instead used F# async - it would be straight up idiotic and irresponsible. FWIW, I wrote some high performance servers in OCaml on Linux and F# on Windows and found OCaml to be 10x lower latency. That's probably in part because Linux does a much better job of async IO at the OS level. Also .NET seems to be really bad at serialization. 
&gt; doing `[&lt;CompilationRepresentation (CompilationFlags.ModuleSuffix)&gt;]` gets old, but that will be implicit soon Really? That's good news. I hate that. :-) 
Your code block is the "nested if" that I was talking about, which doesn't scale well with # of conditions. If it doesn't already look problematic to you, imagine adding a handful of more conditions. &gt; That would be a bad decision because it diverges from expression-based code which is the foundation of F# (and ML). If normal F# code had `return` all over the place, like `let x = if foo then return a else return b`, then I could see your point. But since the only time we use it is in computation expressions, I don't see why there would be a big preconceived idea about exactly how it should work, other than the imperative meaning. And it wouldn't really diverge from anything, because `return` is a special keyword, and each computation expression builder is free to interpret it however it wants. [Here](http://tomasp.net/blog/imperative-ii-break.aspx/) is an example of a computation expression builder that implements early return. Since one normally does not use the `return` keyword in F# at all, only in computation expressions, I don't think people would be shocked / disappointed if worked as in C# and other imperative languages in F# too. In fact, I've seen even seasoned F# devs be surprised by the behavior I described. This comes up sometimes in other expression based languages too, where people solve it with [macros](https://github.com/aphyr/dom-top/blob/59cb7c9e43364913bb54286a0d6d59e77d1da00a/src/dom_top/core.clj#L126-L192) or monadic interpreters. It makes me wonder why F# decided to go against the meaning of the keyword, when the right answer was right there. &gt; I didn't find that when writing high throughput low latency servers for the finance industry in F# using async over Infiniband. I'm sure you can make *applications* that are fast enough (in some cases) with F# async, or even fast in an absolute sense with technology like Infiniband. But if you were making a *library*, a generalized solution where it is hard to know how often things will be called and so forth, deciding to use something an order of magnitude slower would not be responsible.
Hi, if you're new to programming in general you may want to start small. Your idea of implementing a chat bot is a great one, however I would start by creating a simple F# console application with a main while loop where you enter some text, process it and make your bot answer. Good luck with it!
Thanks for sharing! I'm still fairly new to F# so any feedback is welcome :)
[removed]
I know it's only one serialization form, but have you checked out FSharpLu.Json? It handles F# types very well, and comes with some good, quick functions which fit with the rest of F#. Won't help any cross-language concerns, but it's quite nice and very simple.
I dunno, it all worked out pretty well for me. I've since adopted the nightlies because the official word in the announcing blog post was to use them, and little pains I did have (perf mostly) were all gone. I guess almost all of those improvements are going to be shipped officially in a month with another VS update, so that's good. The tools look like they're moving very fast and getting features added like crazy. The fact that it uses the same UI as C# is going to be big for the language I think. I hated how C# got all this new UI stuff in Visual Studio 2015 and F# ended up looking exactly the same as before.
&gt; Uhm, no the presentation doesn't go in more details and also the video show a little bit better the context of the presentation and where the critics came from (focusing MAINLY on the compiler... and it was 2013!!!). ALL the platforms have bugs or design implementations that could lead to bugs if we are not aware of them (check about .Net and the hashing problem, again, something that in a way or another almost all the platform have). Scala is not bad (at all) as a language, even better as a functional language (it has also a quite steep learnin curve, so using it just a bit I don't think is a good case, IMHO). About metaprogramming: let's make it simple. Just take a look at the string interpolation in Scala and you should be able to see something pretty powerful, and it's just the beginning. Anyhow, I thought this was a group about F#, so, I don't argue with personal taste, I just say I would like to see some more advanced functional feature in F# and a stronger support for multiplatform development. If you don't like Scala, fine. It's not perfect and I;m not (and I don't like) fan boy(s). Looking for that kind of bugs/presentations to prove.. .what?? it's just something that I'm not into and still not understanding why you have to say it here, go to the Scala group and try to make your point there, if you are able. A concept (like could be HKT, ADT, monads, etc, etc, etc) it is right or wrong just because someone is delusional (or excited) about Scala or Haskell or F# or whatever. You said that Scala is "more advanced in meta-programming" but I still don't understand what you were referring to. Surely not just string interpolation? 
&gt; That it's an example that means nothing. It's a rounding problem with the JVM. I do not think the problem is the rounding in the example, but the fact that a 64-bit signed integer (Long) can be subtracted from a 32-bit signed integer (Int) and then implicitly converted to a float. Scala probably does this for backwards compatibility with Java, but for a language that in presenting itself as very safe language, it would be nice if the compiler at least put out a warning for cases like these. Besides, this example was a bit tongue in cheek by the author.
Also &gt; If a function takes in an object you know that function doesn’t modify the it. Remove "the" in "... modify the it."
Thanks for reading guys! Just seen the email, will fix these typos now.
F# is much better than C#. Even for OO programming the syntax is more clean and lightweight than C#. IMO For me OO code is a spaghetti, it is hard to spot the control flow and most of OO design patterns are just hacks used by OO languages because they don't have first class functions. F# is also better to learn about the .NET API faster and interactively. See: [Functional Programming Patterns](https://fsharpforfunandprofit.com/fppatterns/)
Have you looked at using fsharplex/fsharpyacc from facio? I've never quite had a chance to finish them up to what I'd call "production-hardened", but they're similar to fslex/fsyacc and include some extra features and performance optimizations. If parsing is a pain point for you, give these tools a try and open up Github issues if you run into any problems (or feel free to send a PR with a fix - I think the source code is relatively easy to work with). Notably, the algorithm used to implement fsharplex could be merged into the F# compiler itself to allow for 'match' expressions on regexes built right into the language (with both | and &amp; cases). If that seems like it'd be a useful feature, let's chat - maybe it's worth putting together an RFC about it.
Corrected, thanks!
Haskell: does not scale for different skill levels -&gt; no hope of using it professionally in any kind of team setup. Ocaml: can't parasite on a bigger lib/tooling ecosystem (like F# does on C#'s). If OCaml doesn't 'pick up', you are stuck with what's out there. On F#, even if I was the last F# programmer on earth, I would have a healthy stream of up to date libs coming in. Also: I'm on Windows, and we are doing enterprise development on .net. Would be pretty insane to use anything else, when you have all the VS goodness at your disposal. 
The newtonsoft json converters are really handy and improve the serialization of fsharp types like DU's tremendously.
both lack good tools for editing/debugging and a unified package management system that doesn't involve building the whole universe. It bites the hell out of low end machines! 
One small tweet for Jetbrains, one big ocean of happiness for the community
Its F# for those unfamiliar with the language syntax.
I guessed python by the shape. I had to zoom in a lot before I recognized the F# syntax. (Man, I need a new phone)
I was inspired to watch this and read a few of his blog posts. In the comments the two complaints that came out that Mark Seeman couldn't properly address: 1) the function composition ends up capturing some of the domain logic. The example is very simple but I don't think it takes much imagination to define some more difficult business rules. Say a reservation check for a 7pm dinner needs to check the number of tables from 7-8.30pm so that logic forms the query. If the goal is to move impurity to the boundaries then I would say using this kind of implementation doesn't achieve it. 2) conditional requests to IO (ones that are called in specific cases in the domain). I think Mark skips over the semantic difference in the F# to Haskell conversion. To be honest I don't have a clue how Haskell handles laziness and I0 but from what Ive seen in Mark's posts the conditional requests just get handled lazily in Haskell. If that's the case then the F# example is just passing a dependency which has side effects. I think there are some fundamental issues with what he's trying to achieve and this distinction he's making.
I cannot contain myself. Been using Ryder for Unity/C# for a while and it's a great tool. (Use at least four of their other IDEs too including IntelliJ.)
This is why I come to the comments section first.
HOLY FUCKING SHIT IT'S HAPPENING [How things have changed!](https://www.reddit.com/r/fsharp/comments/4fr9bc/jetbrains_employee_on_why_project_rider_likely/)
What else is nice is that they're using FCS rather than something custom, which means we'll probably see some PR's as they work issues. Community members have been doing great work to keep the dream of cross platform F# tooling alive, but unpaid individuals can only do so much. That said, F# users will have to put money into this and remain vocal about the fact it's why they're buying Rider to make it a priority for JetBrains. I posted a diatribe on the voting system JetBrains uses (YouTrack?) about how the F# community was more likely to embrace a third party IDE than C#/VB devs. Hopefully I'm not completely wrong ;)
Also, worst case, Microsoft tends to do better work with competitors. I wouldn't be shocked if Visual Studio suddenly takes F# support much more seriously...
Haskell: * It makes it harder to reason about performance, which is one of the most important things ever to reason about. I'm constantly annoyed by slow programs, so I definitely do not want to invest in a platform that makes you less sure how your program will perform at runtime. This is a fatal flaw in itself for me. * In programs I work on, I'm rarely surprised by IO happening - it tends to be obvious from function names, context, etc, so I don't want any extra complexity when I would get little to no benefit from it. * A lot of focus on the superficial distractions of functional programming, like making operators, removing parentheses, etc, instead of the important things like persistent data structures * Community seems to think extremely highly of itself, but I don't think there is enough awesome Haskell software to justify it OCaml * 2017, no multicore. This was embarrassing 8 years ago, now I don't even know what to say. * Still not viable cross-platform. 
How much does it cost?
Rider is in the public EAP program currently. There's no cost at this point to use the software. Once the product leaves EAP status I'd expect the product to fall in line with the Resharper/IntelliJ pricing model.
I have the JetBrains "All Access Pass" already so it has zero marginal cost for me. Frankly, I was skeptical when they first announced subscription pricing. Then, they added "permanent licenses" to it, and that sold me. Then, in the last year, their releases have been steady and new products galore - so I'm now a convert to JetBrains's model of software acquisition and love them.
&gt; so I'm now a convert to JetBrains's model of software acquisition Nice try, Adobe
If Adobe used this model (and I used their software) I would buy it. However once your CS subscription expires you have nothing! So I have years old CS6 versions of their software that I won't ever upgrade and are already more than I need. 
There is a tendency in the community, especially among the less practicing and more academically-inclined to underplay the nuanced complexities of DI and most of the samples you'll find on github are mickey-mouse stuff that completely side-steps the issue, but Scott Wlaschin has written an [in-depth series](http://fsharpforfunandprofit.com/posts/13-ways-of-looking-at-a-turtle/) on DI, with over a dozen (!) of ways that would be appropriate given the circumstances. I highly recommend reading through that instead of this populist nonsense.
I seem to constantly get the 12 second timeout...
Thanks. What kinds of features make their IDEs amazing? 
They're stable, completely cross-platform, and generally mature and full-featured. IMHO they're not *quite* as good as Visual Studio, but this is well made up for by the fact that they run on Mac and Linux.
I will also add though, I really want to see the text editor plugins improve a lot as well. I mentioned this on here and twitter, but I would happily pay some money for Ionide or the emacs plugin (or all of them really) to markedly improve. Sublime Text is a one time cost of $60, and I feel like that would be a reasonable ballpark for something with a decent set of abilities.
I use it for a chrome extension: https://chrome.google.com/webstore/detail/canopy-companion-css-sele/jehfnloleecojodohcdfpbhjahhaplje The learning curve of webpack (or whatever I ended up getting working) sucked, but once I got it compiling, it was a real pleasure to work with.
Why do you say that? I'm wondering myself whether to use F# in production
To be pedantic, F# can do WinRT (Win8+) but not UWP(Win10+). It's still a huge problem and we are stuck on WinRT on Windows, while many modern components require UWP. VS2017 is less of a disaster I think as most people are risk averse enough to wait a while before jumping on to a new version. Based on my reading, I'm expecting it to be usable in April (for the next VS update), or now (for insiders who know about VSIXes).
Nice story, hope you don't mind I linked it in Twitter: https://twitter.com/vivainio/status/856139057965019137 Longer form blog post would be an interesting read as well
No, unfortunately there's no IDE support. I started working on a VS extension for it at one point, based on the old fslex/fsyacc VS extension, never got around to having anything usable. I'll open up an issue to remind myself about it; at the very least, I'll upload what I have done on the IDE integration so far. I'll have to ask Don why he thought compilation would take much longer with this feature. fsharplex is pretty fast -- IIRC, it'll compile the F# compiler lexer in &lt;1 second and something ~70% of that compile time is related to converting fsharplex's compiled DFA into the tables needed to produce fslex-compatible code. If you have multiple active patterns you're using within the same ``match`` clause, does the compiler optimize the pattern matching if you inline the active patterns? (I.e., ``let inline (|Foo|_|) = function``, or ``let inline (|Foo|_|) x = match x with ...``) I thought I read a paper at one point about some SML-based experimental language that had built-in regex pattern-matching. I'll dig around and try to find it again, it could be a good starting point for the (potential) design of an equivalent F# feature.
Would you mind adding that to the [F# testimonials](http://fsharp.org/testimonials/) page? Or alternately, could you give me permission to quote your story when I do a presentation later this year? I'm planning to suggest F# to my co-workers, and I'm putting together a presentation to outline its advantages. Having real-life testimonials like yours will be a BIG help to convince my colleagues who've never known anything but C# that yes, there is a better way to develop software.
I'm pleased with the progress and it is needed. Nice work F# devs!
You can have a perfectly working program, then add some type with interfering properties names, and now all you program suddenly can't be compiled. (Or some library maker can add such type). But thank you for {x=5}:A syntax.
Uhh haha I think you may have made an error in formatting here :/
Ok, thanks - and would you say Fable has better documentation to ease in newbies such as myself when compared to the likes of Websharper?
Been struggling to get Fable and Node.JS to work together (using an example straight from Mastering F# 3.0) for the past 3 hours, can't say it's been a great experience so far - error after error with little to no documentation to help me troubleshoot.
Depending on how much truly functional you want, Giraffe is an F# micro-framework layered on top of ASP.NET Core. It's about as simple as you can get and then any ASP.NET Core knowledge is transferable: https://github.com/dustinmoris/Giraffe And there's also the Kriasoft starter kits which provided ready-to-go development: https://github.com/kriasoft/fsharp-starter-kit
Don't feel bad about being overwhelmed by Websharper. Some F# "rockstars" have also failed to climb the learning curve. IMO they should stop changing it and spend a year on documentation/tutorials - ones which aren't based on long-dead frameworks.
Hi, WebSharper dev here. We've been quite busy working on WebSharper 4 lately, so documentation has unfortunately taken a backseat. But we will definitely be coming back to it in full force very soon. /u/thx1138a is absolutely right that it is our weakest point right now. In the meantime don't hesitate to hit us up at https://gitter.im/intellifactory/websharper with any questions you have!
I would suggest cloning and starting from this repo: https://github.com/fable-compiler/fable-suave-scaffold It has a very thorough build script that handles a lot of corner cases, and it's been the smoothest experience I've had with the ecosystem yet. Note that since Fable 1.0 is a .NET Core project, you'll need VSCode + Ionide, it won't work in Visual Studio for a few months yet. (You can convert the server project to .NET/Mono, just not the client project.) In several ways this setup is not as well-integrated as WebSharper, eg. you cannot directly call server-side functions, you need to write and invoke your REST endpoints, although [there are workarounds](https://medium.com/@zaid.naom/statically-typed-client-server-communication-with-f-proof-of-concept-7e52cff4a625#.2ltqlajm4). And of course, it's still in beta while WebSharper is nearing v4.0. However, JS interop is a lot nicer in Fable (except for the JS libraries supported by WebSharper's extensions), and I find Fable's web development libraries, which are mostly based on React and Elm, to be a lot simpler and more conducive to functional programming than Websharper's reactive databindings.
Understood, hope the day comes soon! The thing is, without a solid foundation/appendix for me to start with I'd just end up spamming the Gitter with incessant questions, because for every tutorial I find I see 20 new pieces of syntax to learn. Is there a relatively up to date appendix (I know you said Doc is taking a backseat but just in case) that I can look through as a starting point so I can get a super simple project up and running? Also, how would you recommend I practice for some of the more complicated aspects of Web Development as it seems I need to use a lot of piping and what practice I've had so far in that aspect has been minimal. Thanks! 
Hi TTBDV, I am currently blogging about my adventures with WebSharper here: http://www.ybouglouan.pl/tag/websharper/ It it written with beginners in mind, as I was one myself not a long time ago (and probably still are :) ). Hopefully it will help you with some aspects of the framework. Cheers and good luck!
Some criticisms: 1. Microbenchmarks don't make much sense for languages with [tracing JIT](https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation) runtimes. (I thought I had a writeup about this lying around but I don't.) 2. The F# code is unrepresentative of what idiomatic F# code looks like in the wild. It's basically C# written in F#. 3. Let's be realistic - most of the time, F# is going to be slower than C#. Functional code is harder for a compiler to make fast than imperative code, and vastly fewer engineering hours were spent on F# than on C#. The truly important question is how much slower is F# (&lt;2x), and whether it's worth the price (yes).
Hi Banashek, you are right, the goal here was more to compare approaches encouraged by the languages rather than the languages themselves, as mentioned here: *Obviously, I wrote the C# and F# samples using different approaches. Therefore: The C# sample uses good ol’ for loops, mutable classes and standard lists. The F# sample uses recursive functions, immutable records and immutable lists.* We could indeed write F# in a more imperative way and achieve performance similar to C#, as your benchmark shows, and it makes sense. At the end of the day F# is compiled down the same IL and will use similar constructs. 
&gt;What could I do to make the F# samples more idiomatic? If necessary I'd be willing to rewrite those samples and run the benchmarks again. I think the ideal would be something like: 1. Avoiding mutable variables and classes; 2. Using pattern-matching on a tagged union. For example, you could benchmark an immutable red-black tree against a mutable one. See e.g. Okasaki - *Purely Functional Data Structures* for a reference implementation.
Yeah if taken as a pragmatic C# vs F# then this does totally make sense.
If you want to see what a real performance benchmark looks like comparing F# and C# - [Implementing a persistent hash map](https://gist.github.com/mrange/d6e7415113ebfa52ccb660f4ce534dd4#background)
Oh, I definitely wouldn't dive into Fable before I was pretty slick with F# syntax and idioms. If you have access to to PluralSight (or are willing to sign up for a trial) there are several good courses on there including Kit Eason's F# Jumpstart. Likewise there is at least one on Lynda/LinkedIn Learning. There's one called 'Develop Financial Applications in F#' which might be about right for your level. Some of these courses have exercises. Also you could set yourself some simple exercises like 'find all the files below a directory that are over a given size' or 'find the average file size of files in a directory'. There is some good F# stuff on HackerRank I think.
Yeah, HackerRank lets you do their 30 days of code in F#. Maybe not all the exercises but many.
&gt; Avoiding mutable variables and classes; The mutable variables and classes were introduced here purely for the needs of the benchmark framework itself. The core of the implementation however doesn't use any of them. It uses immutable F# records and an immutable F# linked-list. &gt;Using pattern-matching on a tagged union. True, I probably could have chosen a tagged union to represent the customer state instead of the IsVip boolean. Thanks for the suggestion! 
I really hope that they end up releasing a Community Edition of this.
Hope so to and let us who work as developers pay for advanced features.. Its good if they get money for their product but also allow people like students to use it for free or people who work with opensource.
[deja vu](https://www.reddit.com/r/fsharp/comments/66b3jj/a_certain_other_net_language_is_going_to_be/dghp2tf/)
F# Support in R# would be the real deal. We already got R# and MSDN Subscribtions. But I have no hope for that one. Last time I checked they had the audacity to say "no, but there is a community plugin" - [which is for R#6 and 6 years old](https://github.com/citizenmatt/FSharper) And convincing the Boss to get Rider for F# only? not likely (it has no MSTEST/VSTEST support, thus we cannot use it for most of our C# projects - sandcastle support would be also required). Concerning F#, VSCode/Ionide is the real "competitor".
Unless you are on Mac or Linux and LINQPad doesn't work on those. 
This makes me happy 
Good point. I haven't done much F# on non-Windows so far, and when I did it was remotely from Windows machine with an open LINQPad session.
videos should be available after conf..
Can you please be a little more specific about what you want to do, what you've tried so far, etc.
Thanks! I might get around to it at some point.
I thought they don't believe in fsharp... Anyway, this is great news!
Ok, thanks. 
That's brilliant, thanks for sharing!
I'm not sure how to do what you need, but if there are nugget libraries, maybe you can look in their source code and understand how they work?
There's a typo in the first para - "Thunderome" should be "Thunderdome". ;-)
I'm writing educational mathematics software.
I did this years back in C# using only the standard System libraries. It shouldn't be too difficult to do the same in C#. Of course, I wasn't using mailboxes, though. It was fun in C#. I bet it'd be even more fun in F#. You should just go for it!
have a look at fredis.net (https://fredisnet.org). Which uses async workflows and a mailbox. Full disclosure, I wrote fredis.net. The github url is on the site.
Anything that helps me learn about F#
What makes https://www.jetbrains.com/rider/ great? Why use Rider instead of Visual Studio, VS Code or Atom? Edit: some answers here: https://www.reddit.com/r/fsharp/comments/67wjg0/f_support_arrives_in_project_rider_jetbrains_ide/
The article post tries to answer these questions "Why do we have to write F# differently depending on what language is consuming it? What happens if you just write F# code without following the guidelines and then try and use it from C#?" I am a novice at all this F# stuff. Calling C# libraries from within F# is almost unavoidable and easy. All of tiny programs have been the end state. How often are F# libraries used from other .net languages? Is this generally easy to do, given the notes in this article, or do F# libraries have to be written with reuse from other languages from the outset? 
Engineering doing marketing :) fixed - thanks!
Comments and constructive criticism is welcome and appreciated!
yes. The function "takeAction" takes a current game state and and action and returns the game state caused by these two. It doesn't have any side effects, nor rely on anything not provided to the function. I.e. the function takeAction always provides the same output given the same inputs to the function. There is a mutable variable holding the game state and a loop for user input, but that is required and is only at the highest level.
It is not strictly required. You could write it as a tail recursive loop and preserve state by simply generating a new state and passing it to the recursive function again. Or save it in a list and be able to rollback :) Disclaimer: I just speed-skimmed the source.
Break everything down into little steps, each taking you a little closer to the end goal, to avoid being overwhelmed. I see that happen a lot to people I coach. Maybe focus on having a grid represented that the player can move it round first. Then add feature little by little.
That is hopefully the plan. Thank you for your advice!
What does your dockerfile look like? Binding to 127.0.0.1 doesn't really work because it tries to use the hosts port. Try passing `-p 61225:61225` when running.
Fable 1.x compiler runs as two components: - server, started by `dotnet` that listens on 61225 and - a client, invoked by webpack loader that sends files to the server The whole chain is kicked off with `dotnet fable npm-run build`. 
The Dockerfile that I used to create the image is [here](https://github.com/DonRyuDragoni/dotfiles/blob/master/Docker/images/nodedotnet/Dockerfile). Binding the container port caused the exact same error when running `npm run build`.
EDIT: see the other responses, they're better There are ways to customize the view in the debugger. Here are a few quick links, both of which are old and may be outdated: http://blog.paranoidcoding.com/2008/09/10/debugging-f-list-s.html https://blogs.msdn.microsoft.com/jaredpar/2010/09/10/improving-the-display-of-f-seqts-in-the-debugger/ If you have trouble anything something working, reply to this and I'll try to cook up something that works later today.
Enable "use legacy expression evaluators" under the debugging page in the options!