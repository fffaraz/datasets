Everything he wrote in this blog (and in general, most Scala code) comes across as perfectly understandable to me. I don't consider myself special in this regard, so I assume that most other programmers find the code understandable as well, assuming they know Scala. There are examples, such as ScalaZ, of code which can be difficult to understand upon first reading. However, I don't really think you can fault Scala for this, and often such examples are of things which could not be accomplished, in a typesafe way, in many other languages.
Wrote the following as a comment on the blog. It's awaiting moderation. You should probably mention in section 2 (Avoid creation of instance variables) that you can recreate the java getters and setters with the @BeanProperty annotation: import scala.reflect.BeanProperty class Shape(@BeanProperty var width: Int, @BeanProperty var height: Int) Also, note how the brackets are missing in the class definition. In this case, you don't need them unless you're doing other stuff in the class.
I think a lot of the complaints come from people who simply don't know / understand functional programming. They seem to get the object-oriented aspects of Scala but not the functional aspects. 
I wrote a MUD about 10 years ago when I was learning Ruby. Teaches you all kinds of important concepts about how the language handles networking, threading, file I/O, complex data structures, etc. Don't disregard it as a valuable learning tool just because MUDs have "old man smell" all over them!
in all fairness; parts of that code **could** have been made more compact in Java also, but Scala an extremely expressive syntax
I don't really understand, what is the point of this work. Scala already has lazy evaluation, message-passing concurrency (Actors) and declarative concurrency (http://www.scala-lang.org/api/current/scala/concurrent/SyncVar.html).
I hope this helps noobies like me to get going. Once it's all together it's pretty straightforward :) 
As far as I know, Scala does not provide declarative (deterministic) concurrency and lazy declarative concurrency. Scala's lazy evaluation is purely sequential (it does coroutining). Regarding message-passing concurrency, Ozma provides a simple and powerful form that is completely integrated with declarative concurrency.
Yes, we were very impressed by the modularity and good design of nsc. It's what made the Ozma project possible. What Ozma offers is **declarative concurrency**. The point is to make it as easy as possible for Scala programmers (and maybe some Java programmers too?) to understand this and see why it enormously simplifies concurrent programming. It's much better than Java's synchronized objects (monitors). Ozma integrates declarative concurrency with message passing (using ports), and this is the best form of concurrent programming I know of. We had to add ports to Ozma because it was not possible to integrate declarative concurrency with Scala's existing message passing model.
Sorry but I despise spreadsheet based testing solutions. Things like FitNesse should be burnt at the stake. Developers should be implementing the tests that the QA specify so why the hell should we use spreadsheet. If you want parametrised tests, the parametrise them in the test or better yet use something like TestNG.
+1 with petervanroy (of course) &gt; Not sure if Ozma brings static typing to Oz which might be one of the most interesting gains? Yes it does. I think it is also very important.
&lt;3 , scala noob here, but one of the thing that I was afraid of was scala being stuck with Oracle's JVM. Oracle been really douchey to the open source movement. 
Scalatra looks interesting. I've worked with both Sinatra and Play:Java. I fooled around with Play:Scala and it's a nice extension of the Play framework, but it does tend to dictate a lot of design decisions to the developer - plus as you mention it is tied to a specific version of Scala, which while not a deal breaker by any means kind of sucks still. I'm still going to check Play:Scala out again though when it hits 1.0 and has Akka support. 
Question: Why was Java chosen for the runtime if Scala was chosen for the compiler?
I would guess that the decision was made so that the redistributables you have after compilation don't depend on anything beyond what's in a standard JVM install.
Ah, that makes sense. I was worried that it meant that Scala was somehow lacking in some respect :P
How are the go routines handled? Mappen on to java threads_? 
http://www.reddit.com/r/programming/comments/incpv/impressions_over_scala_f_python_c_and_clojure/ Original post credit.
I don't see much benefits in Scala to Javascript translation. How is jQuery going to work? Front end with Scala? Then someone have to create a library to somehow translate certain keyword to jQuery no? So they're adding an extra step of scala to javascript. Where as I usually do javascript/jquery and refresh the browser and see if it's working correctly. Now I have to translate scala to javascript and then some; while coding scala I have to integrate jquery in scala, then translate it before I can see any result in the browser. I just can't see it. I mean javascript is moving serverside, node.js, and Scala is competing in this area of concurrency. Competing in front end seems like a huge task. 
This is actually a useful cheat sheet if OP made it well done and thanks if he found it than just thanks.
Thanks!
http://stackoverflow.com/questions/1332574/common-programming-mistakes-for-scala-developers-to-avoid
Wrong link. Which one was this supposed to be? This one ( http://www.parleys.com/#st=5&amp;id=2184 ) is from 2010...?
I really like the good/bad examples you don't find on most sheets. Thanks
yep, it's from 2010.
Goroutines are not handled yet, but when I add them, I plan to implement them using threads, at least initially. Later, we'll move to ThreadPoolExecutors/ForkJoinPools, etc.
Yes. That's exactly it. Also, but less significantly, I am more familiar with the mapping from Java source code to JVM bytecode than that from Scala to bytecode.
http://www.malhar.net/sriram/kilim/ can be useful for you
After Scalathon, it looks like there's a possibility of using Anti-XML as an alternative to XML literals in the stdlib. https://twitter.com/#!/djspiewak/status/92999014294880256
(1) Is there any good argument for why XML literals should be removed? A good argument shouldn't take the form of "because XML is ugly" or "because XML is tedious to write/read/edit." I read Odersky's thoughts on it in the link, and while he doesn't seem to believe it is an essential construct to the language it does not change the reality that a huge amount of data is wrapped in XML currently and in the foreseeable future. Leaving XML as a first class citizen in the language makes a lot of sense to me. (2) Isn't type erasure a JVM problem? (3) It's not great, but it's not terrible. I doubt it changes since too much Scala code exists now to make the change easy. If it does change it would be in the form of alternative syntax and maybe two or three major versions down the line you remove the current form. (4) This could probably be solved with much improved documentation. 
The new language Kotlin by JetBrains fixes some of these, and is being discussed on the scala-debate list right now. But I don't see #3 at all ; if you are talking about the underscore, you don't have to use it, but it's very convenient for trivial functions. Kotlin uses "it" instead, but only for the first instance, so you can't write simple binary functions without naming the parameters.
As for #4, you can write hard to read code in any language. But go looking for hard-to-read package definitions using lots of curly braces in actual Scala code and I don't think you'll find it.
Type erasure is a JVM problem, but because it affects the things you can and can't do with types/overloading in scala, it is also a scala problem. The manifests are baked in at a compiler level, and provide only a rudimentary hackish solution to some of the issues type erasure causes.
It runs on the JVM. Which is mostly good but can be bad in some cases.
Why this kind of thing gets downvoted is beyond me. This is a great talk.
Upvote for the import system. Importing static members from one class into another makes for some really tricky code.
&gt; Is there any good argument for why XML literals should be removed? I'm a Scala newbie, but I really don't see the point of this. It must add a lot of complexity to the parser -- just to avoid putting the XML in a string? It seems like triple-quoted strings as in Python are sufficient.
The claim that C# brought generic programming to the masses is not very well backed up by reality. Otherwise I think it's kind of an interesting introduction to Scala.
No! I would argue it's the other way around. :)
What's up with the null check in the hasUppercase example? One of the biggest conventions in Scala is the non-use of null. Do not pass null to functions. Do not return null. Do not use null as a signal value for value-not-found, etc. Use Option[T] instead, which explicitly indicates the possible lack of a value and requires that the recipient handle the "nullability" or pass it on. Do not check for null or produce null unless you are interfacing directly with Java code that requires it. Bye-bye, NullPointerException!
Actually, Anti-XML is a proposed replacement to the scala.xml *library*, which suffers from some design problems. It's not a movement to remove XML literals from the language, or to change them. The name's a bit confusing, I admit.
Yeah, I agree, the lambda expression syntax can be a bit ugly. I am particularly annoyed by the need for _ after function names, but I understand the necessity for them in the face of function overloading. Also, I find it really irritating that composition doesn't work properly with PartialFunctions (i.e., it should, but does not, result in a PartialFunction). Apart from the fact that type constructors (or types of kind other than *) are second-class citizens in the type system, these are the only complaints I can think of about the language itself. Scala is really well designed. The libraries, though, are in need of extensive documentation and some expansion.
What do you mean by "static members"? On a broader note, I think that Scala's more powerful and general import system is a good thing. Like any other language feature, there are ways to abuse it, but that doesn't mean that it is intrinsically bad, just that abusing it is bad.
Thanks for the suggestion. Kilim looks quite interesting!
May be because the talk is about Cassandra unlike what the title suggests??? 
As much as I love Scala, looking at this as subjectively as I can, this is a very naive comparison. [What Scala has that Kotlin has not](http://confluence.jetbrains.net/display/Kotlin/Comparison+to+Scala) FAQ, have a lot of stuff that Scala doesn't offer. Type Erasure is huge on my list. But in my personal belief, one of the reason why PHP is so popular, other than it was one of the first purpose built language for web domain, is it's simplicity. I know people that's aren't CS major that code PHP for a living. And Kotlin takes keeps the C syntax and doesn't have the function hybrid so it's easy to pick up. And not only that, the IDE is probably going to be amazing. Kotlin is only in its infancy so it's not fair to judge it yet. We haven't seen any real code, library, etc.. of it yet. Only time will tell which one will be the victor. Hell they might not even compete if they target different problem domain to solve. But if it's going to try to compete with Scala in concurrency then it's probably going to lose, Akka and Scala is teaming up, but if it manage to find a domain that it can solve and specialize in, oh boy... 
"Type Erasure is huge on my list." I'm not sure I understand this claim. Type erasure happens at the JVM level. Type erasure occurs in generics; period. The only way around it on the JVM is to explicitly pass around type information. Scala solves this with manifests and Kotlin solves this with the implicit inclusion of TypeInfo fields. I think it's a misleading characterization to say that one of these languages has type erasure and the other doesn't.
Scala has an implementation. Most developers doing actual work appreciate little stuff like that.
Manifests suck -- they don't scale, they cause you p ita and in the head, it clutters your source, and you never get it right. The problem is a sort of inversion of control, you need to annotate all potential library functions with manifests in order to able to have the manifest inside some inner context when you need it. I'm not exactly sure how Kotlin solves this, but storing that information automatically with each instance of a type so that you can just use that information (let's say in pattern matching) makes the type parameter usage transparent, so even if somewhere in the machinery the JVM looses the types, you don't notice as a user of the language. I think this is a huge benefit. It's IMO where Scala breaks its promise of treating all types equal, that is no distinction between higher kinded types and basic (non generic) types.
This it true, and I don't disagree. However, I just think that its a mischaracterization to say that Kotlin doesn't have type erasure and Scala does. C++ doesn't have type erasure, JVM languages do, unless they perform compile-time code generation for all used used types of a generic. There's a tradeoff between the loss of runtime type info (JVM erasure) and code bloat (C++ templates). However, my point was that both Scala and Kotlin deal with the JVM type erasure in a similar way; it's just more explicit and therefore a bit more onerous the way Scala currently handles it. However, I'm not sure manifests were ever meant to be Scala's final solution to this problem but I won't speculate on that here.
IntelliJ IDEA 10.5 with the Scala plugin. It's the best option right now. Don't use it for builds: use SBT with the ~compile option to compile files as they're saved, or use ~prepare-webapp with the JRebel SBT plugin if you're working on a web application.
IntelliJ seemed to be the best, but I also enjoy using Emacs very much.
Huge benefit for what exact scenario? Inspecting the exact type doesn't sound very good general practice to my ears in this context.
Definitely give the new Eclipse plugin another try. It is far better than a few months ago.
Weird. I just copied &amp; pasted the URL. Thanks...
jEdit.
I second this. The spurious error messages in code have gone away as well as the mysterious problems that would sometimes prevent me from running Scala code at all. I'm using Indigo with Scala 9 and it's been pretty good.
I agree with the previous posts: IDEA CE 10.5 with the sbt plug-in is a great combination. Occasionally buggy versions of the Scala plug-in emerge, so you need to be conservative with updating the plug-in (I'd just stick to a 'running system' and check the IDEA Scala online forum to make sure there are no issues before hitting the update button in the plugin manager). I just recently discovered that IDEA is also phantastically integrated with ScalaTest, so if you write your tests in an sbt managed project in ScalaTest, you can quickly add individual run configurations for your test suites which allows also to run them in a step debugger. Very useful. The plugin has also been constantly improved, code completion and especially refactoring options are quite amazing now, as well as 'smart mini refactorings' (they are called inspections)
In pattern matching. The erasure in pattern matching is an annoying exception case of the type system's capabilities.
I'm pretty happy with Emacs + ENSIME these days. I'm a dirty Vim user so I use Vimpulse with Emacs to get modal editing. IntelliJ IDEA with the Scala plugin is pretty good and, most importantly, very frequently improving. You can follow one of the developers of this plugin on Twitter here: https://twitter.com/pavelfatin The main reason I don't use IntelliJ these days are that IntelliJ itself (even without Scala) has some performance problems on my laptop that I can't figure out. Also, IdeaVIM has some pretty annoying behaviors.
Indeed, one of the reasons I settled on Intellij is because the development seems to be quite active, although the plugin is still officially in beta. Is it possible it's the compilation that is slow with intellij? Compilation used to take a while, but they now use fsc. It certainly is much faster for me than it used to be. 
Eclipse isn't bad. 
Yea, I tried it as recently as a three weeks ago. The IDE just has some annoying pauses that I can't figure out what they are. Even when I'm doing just plain Java work. I believe it's not necessarily IntelliJ's fault and possibly some systemic issue with my machine. I also get an annoying lag when saving a file in Vim. This is one of the main reasons I picked up Emacs+ENSIME...it doesn't seem to have this particular problem.
Emacs + Ensime is magic. At Twitter, we wrote our own .ensime generator. (.ensime is the file format that tells ensime where to find your source, library jars, and tests) https://github.com/twitter/standard-project/blob/master/src/main/scala/com/twitter/sbt/EnsimeGenerator.scala 
IntelliJ IDEA 10.5 + Scala Plugin + SBT Plugin. 
I guess you're right and I'm wrong about erasure. Thanks for pointing that out.
Wow, you're admitting what was misunderstood and willing to learn? Unexpected but awesome; have an upvote ;-P.
I was using Vim + sbt + browser, but ENSIME looks like worth trying. The IDEA plugin is nice but I didn't really need an IDE for smaller projects.
I can't follow you on several occasions: &gt;And Kotlin takes keeps the C syntax and doesn't have the function hybrid so it's easy to pick up. How can this the be true if Kotlin and Scala have almost the same syntax? **I also wonder where people got that "simplicity" thing from.** Is there any actual fact to base that opinion on? Or do people just repeat what some others have written on their website? 
Scala devs are working on exactly that, as far as I have heard.
Kotlin is simple because it's only imperative, the most popular paradigm. Learning one paradigm is easier than learning two. 
Have you actually looked at the language? Isn't that just the next unfounded claim made on the website?
Neat! Looking through the changelists, I love Paul Phillips' stream-of-consciousness commit messages. Also looking forward to one compiler bug being fixed that bit our team recently and a passel of performance improvements.
SBT has just become awesome with the 0.10 release. I use that as the basis for all by projects. I use plugins to generate ide project files for Eclipse and/or Idea from the SBT project definition.For mixed language projects (Javascript) i use Eclipse and Idea for pure scala projects.
"MO: One of the things coming up is Scala for JavaScript."
What do you mean do not pass and do not return ? Unlike haskell scala does not guarantee you that a function someone else wrote (in java or in scala) will not return null. So you HAVE TO check for it. &gt;Bye-bye, NullPointerException! On the contrary, if you are not checking for null but rather relying on everyone to follow the non mandatory guidelines, then you are the one creating NullPointerException minefield. You cannot get rid of implicit nulls in a language that allows them. 
I realize my tone above may have been somewhat provocative. Nevertheless, based on my experience with Scala, I disagree. Linguistic enforcement is not necessary; avoiding null is a very strong convention. Can you find a method or constructor in the Scala library that returns null or admits it as an argument? (I know of only two.)
&gt;Can you find a method or constructor in the Scala library. That's not an argument. First of all ANY scala (or java) function that does not explicitly return a value of type Option, can return a null value. There's no way around it, no guarantee that the author of function made sure the null will not pass through. Second, you are not going to use ONLY standard Scala library. That will make scala itself pretty useless. The power of any language is in the ecosystem of thrid-party libraries available to its users. And that's another huge field that is completely out of your control. And finally look at the return types AND the argument types of most scala functions. They are not of type Option. So that means authors of those functions MUST check their arguments for null. Are you sure that even half of them follow that rule ? Do you have ANY guarantees of the sort ? Btw i tried a small tutorial in scala code and it was very easy to introduce a null pointer exception. &gt;Linguistic enforcement is not necessary; I think i heard this argument before. Oh yeah, "We do not need a garbage collector. Just follow the guidelines for creating and disposing memory pointers." 
My personal issues include lack of implicit currying, hideous currying syntax, and half baked type inference (which isn't likely to get better due to the complexity of its type system), I also find the syntax to be somewhat quirky. That said, overall it's a very nice language and hands down the best choice for statically typed JVM offerings.
The main attraction of Scala is its focus on immutability and concurrency, Kotlin provides nothing over Java in this area. 
It also runs on .NET, and there's [work being done](http://greedy.github.com/scala-llvm/) to make it run on LLVM. It certainly isn't inherently tied to the JVM.
Having a compiler who guarantees that invalid XML can't exist at all at runtime isn't something you can do with Strings (Scala has triple-quoted strings, too).
Of course the literal support has to be made pluggable too, so that the different languages can use different constructions and types for the literals. Making the XML literals fully optional isn't very far away from that. 
&gt; First of all ANY scala (or java) function that does not explicitly return a value of type Option, can return a null value. Options can also be null, so I don't buy that. &gt; Second, you are not going to use ONLY standard Scala library. That will make scala itself pretty useless. The power of any language is in the ecosystem of thrid-party libraries available to its users. The whole ecosystem works that way. Actually I can't remember one library which uses null. If I have to use some Java library, I can wrap the return in an Option. &gt; And finally look at the return types AND the argument types of most scala functions. They are not of type Option. So that means authors of those functions MUST check their arguments for null. Are you sure that even half of them follow that rule ? Do you have ANY guarantees of the sort? Well, the rule pretty much is: - If you think of passing a null as an argument, why don't you just throw a NPE yourself? - If a library returns null, the library is wrong. &gt; Btw i tried a small tutorial in scala code and it was very easy to introduce a null pointer exception. Maybe you should actually look at how the language is used in the real world. NPEs and null are a complete non-problem.
We use IDEA 10.5 with scala plugin + maven w/ scala plugin. The reason for maven over SBT in our project was existing plugin support.
What are the odds? I was about to parse a csv file in Scala. It never even occurred to me to look for a csv parser. Thanks OP!
A few days old, but … &gt; I also wonder where people got that "simplicity" thing from. Is there any actual fact to base that opinion on? Kotlin is clearly simpler than Scala — a function not of its syntax (which definitely *is* Scala-derivative) but rather its choice of features. Extension methods rather than implicates, reified generics instead of manifests, no self-types, no existential types … I don’t consider that a controversial thing to say. Which isn’t to say that Scala is *too* complex; I don’t feel that to be the case at all; I am amenable to its tradeoffs. But there is something to its having a bit steeper learning curve than other languages.
Well, a language without compiler, library or specification appears always to be simpler than one where people do actually work with. I'm pretty sure that with Kotlin's already existing feature set they will be more complex than Scala as soon as they hit reality e. g. people trying to implement some libraries in it and hitting the wall because some language contructs are not general enough in Kotlin. Imho Scala made the right decisions to have fewer, more general constructs in the language instead of more specific special case features like Kotlin. Let's see how it all works out. I don't think Kotlin/Gosu/Ceylon will ever catch up to Scala in terms of stability, maturity, sophistication, tooling and third-pert library support, but only time will tell ...
DDJ: I think that most people, once they leave emacs, do so permanently. MO: Yes. But there will be some people who will not be happy with you for saying that. 
That is exactly my setup. Nice to know there are other people here that arrived at the same conclusions. :D
Better then IntelliJ ?
That I can't speak to as I don't not have much experience with the IntelliJ plug in.
&gt; I'm pretty sure that with Kotlin's already existing feature set they will be more complex than Scala as soon as they hit reality Maybe. But I’d make a distinction between complex features and complex code; I don’t see any particular reason that Kotlin *must* have more complex features than Scala. Java certainly doesn’t. The price may be paid in terms of the quality of written code — good Java code makes my eyes glaze over in ways that good Scala code doesn’t — but I think it’s far from a given that Kotlin’s features will be as difficult for newcomers as Scala’s can be. They certainly seem a bit simpler overall. (I'm still wrapping my head around some stuff, although I’m a comparative newcomer.) &gt; I don't think Kotlin/Gosu/Ceylon will ever catch up to Scala in terms of stability, maturity, sophistication, tooling and third-pert library support, but only time will tell … I’d agree with all of that except tooling and library support. There’s some portent behind the fact that (at least IMO!) the only really useable Scala IDE is done by JetBrains. I don’t think Kotlin will suffer there. (Also — “implicates”? WTF? Implicits. Need to turn off automatic spelling correction …)
&gt; [...] I think it’s far from a given that Kotlin’s features will be as difficult for newcomers as Scala’s can be. They certainly seem a bit simpler overall. Why and how? I really wonder where these claims come from...
Of course I haven’t seen the finished product (which doesn’t exist); no one can say for certain what Kotlin 1.0 will look like. But to the extent that we’re allowed to use the currently-written documentation as a guide, I don’t feel it very controversial to claim that Kotlin will be in some respects simpler than Scala. I get the impression that “simple” seems rather lower-hanging fruit for me than for you — to someone with a background in C, I think it would be easier to explain (say) Java or Python than Scala. To someone coming straight out of Java, without considerable experience in other languages, would you rather explain the intricacies behind Scala's implicits — their use, their resolution, the implications for API design — or Kotlin's extension methods? Further: It is undeniable that beginners are taken aback in first attempts to understand Scala’s collection library, a thing of beauty but *certainly* more complex than the Java-like libraries that Kotlin will probably sport. Existential types? Typed self references? The monadic underpinnings of for-comprehensions?
IMHO, the biggest flaw of Scala is its **documentation**. On many subjects, the online free books and tutorials aren't enough. Even buying a book doesn't help much once you've learned the basics. Many official libraries have no documentation except an API list where each method is described in a few words. When faced to this lack of doc, I've seen some people go and read Scala's source code. I'm too lazy, so I prefer to ask for an advice, but that's sometimes quite annoying.
Is there a video of Martin's Akka presentation? I've looked around the web and haven't had any luck finding it.
As I am now doing my first scala project, I am feeling the truth of this. Ouch. Sun's Javadocs were always great and complete.
Is it just me or are all the videos set to private?
I am not affiliated with Scala exchange in any way and yet I am able to see the videos fine. It's a little confusing that they are on the right hand side and not shown prominently though. At first it looks like an ad to an article.
Your question is unclear. Perhaps you could provide more detail, or ideally, a code example of what you have in mind?
It's not a question. It's a tip, or an idea for a more haskell-like library.
Ah, thanks. But I still think it's a little unclear the way it's currently stated. Would you mind elaborating on it a little bit more?
Usually, the map function looks like this: `def map[U](f: T =&gt; U): M[U]` However, if you change it to this, it works like flatMap: `def map[U](f: T =&gt; M[U]) = flatMap(f)` When you have done that, you can use the for-comprehension in the same way you can use do-notation: `//If lists had it defined this way:` `for {` ` x &lt;- List(1, 2)` `} yield List(x + 1, -x - 1)` Which would be the same as this, in haskell: `do x &lt;- [1, 2]` `.. [x + 1, -x - 1]` (where the starting dots are spaces, ofc)
Aaaand why the downvotes? It's a useful tip (maybe esp. for the scalaz people)
Thanks tehz; that's an interesting tip!
why not code like this ? for { | x &lt;- List(1, 2) | b &lt;- List(x+1, -x-1) | } yield b 
Because it's less like do, and requires a map function defined.
If you're having problems with terms like this, please read a basic book on functional programming, like [Bird](http://www.amazon.co.uk/Introduction-Functional-Programming-Prentice-Hall-Computer/dp/0134843460/ref=sr_1_1?ie=UTF8&amp;qid=1312846028&amp;sr=8-1).
I think because while it is an interesting tip it would have been better to explain it a bit more. A code example never hurt anybody. Neat trick none the less.
I use Textmate + command line, as i don't like IDE's as well as scala is very succinct.
Just skimming through this and saw a few thing that I like from other languages. algebraic sum type &amp; recursive type seems too verbose compare to the other languages. And it seems some of the other language can infer perfectly fine with out the type declaration such as a function's parameter? Overall, pretty neat.
Semicolon-semicolon inference seems to be missing in ocaml.
Why this: import System printArgs args = do if length args == 0 then return () else do putStrLn (head args) printArgs (tail args) main = do a &lt;- getArgs printArgs a instead of the much more elegant: import Control.Monad import System main = getArgs &gt;&gt;= mapM_ putStrLn
Because the author does not know of mapM_ Also, [do notation considered harmful](http://www.haskell.org/haskellwiki/Do_notation_considered_harmful)
&gt; Also, do notation considered harmful The same arguments apply for any syntactic sugar. If our baseline standard is "could this language feature potentially confuse new programmers" then we may as well give up trying to design programming languages.
That one is filled with errors.
For example, if println("Hello world") is a hello world program in scala, then putStrLn "Hello world" is a hello world program in haskell.
Any chance that there's a new version in the works? No new branches seem to function with sbt 0.10.0 and 2.9.0.
Will this be the last one?
Is there a summary of what 2.9.1 is bringing to the table? There's a big list of bug id links, but it would be nice to have a high level, human readable overview.
I agree. 
Here is [the commit log](https://codereview.scala-lang.org/fisheye/changelog/~br=2.9.x,startDate=2011-08-04,endDate=2011-08-16/scala-svn/?max=30&amp;view=fe&amp;@asv=fe) for changes between RC2 to RC3.
I think he's aiming for the changes between 2.8 to 2.9
Oh. In that case: maintenance release (see listed bugs) - hehe
&gt; Well, the rule pretty much is: &gt; If you think of passing a null as an argument, why don't you just throw a NPE yourself? null doesn't necessarily mean something went wrong, just like None. &gt; If a library returns null, the library is wrong. That's what 99% of the libraries do, so they're all wrong? Like the poster above said, look at the Scala API's: very, very few of them use `Option`, so even the authors of the Scala libraries are not following your guidelines. I'll follow their guidance over yours. 
&gt; Like the poster above said, look at the Scala API's: very, very few of them use Option, so even the authors of the Scala libraries are not following your guidelines. That's pretty much wrong.
I love the new startup time of the REPL. 
* Actors and Akka is going to merge in the future. * Scala STM coming soon * Improvement over current Parallel collections * Distributed collections coming soon * Parallel embedded DSL (researching) * Actors mailboxes wasn't a good idea in real world practice (junk mails) 
This is scary. I always assumed that Scala under the cover would create something much like the CostClass in this example. Does anyone have more insight into this?
If you [follow the ticket](https://issues.scala-lang.org/browse/SI-4920?focusedCommentId=54523&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-54523) there is a comment there that describes the issue. OP is passing a 2-argument function which in Scala is generic. There is currently no specialized version included in the standard library for (AnyRef,AnyRef) =&gt; Int which is the type signature of the function being passed. Function2 is currently only specialized for all permutation of {Int,Long,Double} =&gt; {Unit,Boolean,Int,Long,Float,Double}. AnyRef was also just recently made available for specialized so it should be possible to optimize. There is an issue though with classfile bloat from all the permutations that must generated for the standard library.
This seems like a very weak reason to stick with Java - as he pointed out himself you can get equivalent performance by passing a class instance as you would in Java. If performance is an issue for your code I would suggest implementing the code in Scala then profiling to find the hotspots where a function could be replaced by an object implementing the same functionality. You would still get all the other benefits of Scala, and probably finish a lot sooner than if you implemented the code in Java. 
&gt; And finally look at the return types AND the argument types of most scala functions. They are not of type `Option`. So that means authors of those functions MUST check their arguments for null. Are you sure that even half of them follow that rule ? Do you have ANY guarantees of the sort? I am absolutely sure that all of them follow the convention of not returning null, or tolerating null arguments. Let me reiterate this rule: * If you are calling a function *written in Scala* which is not explicitly implementing a Java interface that mandates use of `null` (this case is very rare, and if it happens, you will be warned in documentation), `null` is neither returned nor permitted as an argument. Period. The only two exceptions are: 1) The `apply` method of object `scala.Option`, whose purpose is to take a perhaps-`null` argument (e.g., as returned from a Java method) and convert it to an `Option`; and 2) The `orNull` method of class `scala.Option`, whose purpose is to convert `Some(x)` to `x` and `None` to `null`. If you are writing a Scala function that calls a Java method, you must consider the possibility of a null return from that method or the necessity to pass null to that method, *and you must shield these nullability considerations from the caller of the Scala function*. If you do not follow this rule, you and your software will be shunned by the Scala community. You will fail technical interviews for Scala jobs. I don't mean to be harsh, but it's the truth. &gt; &gt; Linguistic enforcement is not necessary; &gt; I think i heard this argument before. Oh yeah, "We do not need a garbage collector. Just follow the guidelines for creating and disposing memory pointers." I fail to see your point here. The kind of "linguistic enforcement" we are discussing here is *static* (done at compile-time). A garbage collector is a runtime consideration. Very few, if any, languages provide static linguistic enforcement of proper pointer usage, since the requisite analysis is often prohibitive. Those that do (I'm thinking of Rust) don't provide complete enforcement and constrain you to certain patterns of development (which is not necessarily a problem, but is distinct from sole "enforcement"). Also, the "guidelines for creating and disposing memory pointers" are *really complicated*. And dynamically allocating memory isn't something you can just avoid. *In contrast, in Scala, using `null` is something you can avoid most of the time, and there are very simple rules regarding proper `null` usage.* I hope this helps. If you are still unconvinced, you can take a look at one of my Scala projects: [JGo](http://jgo.googlecode.com/). Grep for `null`. You'll see it in Java code, of course, and where I interact with ASM, a Java library for JVM bytecode generation, but little elsewhere. Anywhere else null occurs (I can think of only one such place), it is to check for initialization errors and pinpoint where they occur for debugging purposes. You'll also see some discussion of NPE's as indications of bad initialization in the comments. 
I disagree. Assigning a function to a val is a fundamental aspect of functional programming. Scala encourages functional programming. Where else in the Scala libraries do they assign functions to a val and pass it around. Its not like this was currying or partially applied functions. Pass a function into a function and you run slowly. I personally would not give up on Scala, but sure hope it gets fixed. Its one thing to have to profile your own code, but I would hate to have to profile the entire scala library.
He made my eyes bleed. JAVA ... SCALA ... WTF?
REPL starts very quickly, and the compiler is much faster. Those two things alone make it worth it for me.
Remove the width: 60%; of the article so the readers don't have to scroll like idiots. the comments have nearly twice the width.
I really wish the bug fixes where given in more of a summary form instead of forcing people to read through every ticket to see what they are.
Same here. I really wish someone can put together a list of key features and bug fixes for 2.9.1, e.g., something like [PostgreSQL release notes](http://www.postgresql.org/docs/9.0/static/release-9-0-4.html)
I wanted to submit this link: http://eric_rollins.home.mindspring.com/scalaAnt.html But reddit kept on complaining, "You should check that link" 
How does it compare to Akka's STM?
It seems like they do it to official releases and not the RC ones. source: http://www.scala-lang.org/node/9708 
Ah okay that makes sense -- still pretty new to the scala community so I should have checked that!
Seems rather good, I'll have to go it a go.
I wouldn't be surprised if a lot of the language designers for Scala read that book personally.
Are you shure you were in right directory at point "Command Prompt - 2"? I'm talking about this tutorial - http://www.scala-lang.org/node/310.
yep, that was the guide I used. It fell apart at the very bottom where I was setting the path. Those last two steps just wouldn't work and I can't figure out anything else to do. 
Use the installer? Just run the .jar installer, let it install it and bam you're done. Can use the REPL in cmd straight after that.
 There's like 6 .jar files... EDIT: make that 11. And none of them say "installer" or anything I can make sense of. 
The installer from the website, it's a separate download. There's the .zip and the .jar installer. The lzpack installer, http://www.scala-lang.org/downloads/distrib/files/scala-2.9.0.1-installer.jar
Seems to me like you didn't set your PATH correctly. I know you followed that guide, but could you tell us exactly how you set it?
If this works... I love you. Downloading it now. 
Um, well, here's the transcript of what happens. C:\Users\(my name)&gt;cd "C:\scala-2.9.0.1" C:\scala-2.9.0.1&gt;set PATH=%PATH%;scala-2.9.0.1\bin C:\scala-2.9.0.1&gt;scala 'scala' is not recognised as an internal or external command, operable program, or batch file. I don't know if that helps at all.
You're using a relative path. Try with an absolute path, ie the entire path which would be c:\scala-2.9.0.1\bin In your case
What university is this?! I'm jealous, maybe I can work there.
What university and what's the name of the professor? :)
Trinity University in San Antonio. I'm hesitant to give the name of the professor...
Trinity U in San Antonio. :P
Okay, I did that, and it gives me this. ' "java" is not recognised as an internal or external command, operable program, or batch file. I guess I have to go download java now? :/
That's a Windows guide, probably not what you want.
Well I have windows. :P And it worked well right up until the end with the PATH var. 
I guess I have found your problem, dude. :-) If you plan to invest more time into programming and related topics, I would recommend using some Linux distribution: It might take some time to get used to it, but at least it doesn't constantly throw these kinds of obstacles at you. Using Linux and learning Git can save you a lot of trouble.
Yeah this is my first official foray into any sort of programming. It's pretty exciting. The computer lab where I have my class (the whole reason I was installing scala) has a linux dual-boot with windows. I guess we'll be getting into that as the semester goes on? I have no idea. But we'll see how it turns out. Despite all my hiccups, I've finally got the damn thing working and messing with commands is pretty fun. :)
You would be correct. Usually you would start with Java because Scala uses the JVM. From memory, on Windows the installer sets the path for you so you should be fine after that. Make sure you download the JDK. If you still struggle with it I could try to install it on a Windows machine a little bit later and give you a step-by-step guide. I've never actually used Scala on a Windows machine.
Interesting choice of Scala for an introductory course. Good luck.
Yeah, I downloaded the java package and it works fine now. Couldn't have done it without reddit. :P
Ok, nice! Which IDE do you use?
Umm... It's like the 2nd day of class. So right now we're just using basic windows command prompt. The prof did tell us to download Notepad++ however, which I will be doing in the next day or so. And we are going to get into linux, just in a couple weeks after we get comfy in windows. 
Glad it worked. Hope you enjoy the class, it's a fun language. Don't forget to set your path permanently in Windows so you don't have to set it at the command line every time.
I wonder if they are looking into areas where Scala can improve performance/memory usage. Not that I find Scala particularly slow, mind you, but I am trying my hand at game development and faster is better. For instance see this [feature request](https://issues.scala-lang.org/browse/SI-1338).
Have a look at the current 2.10 trunk, most work is happening there. I guess things like this will be considered in combination with the staging/GPU collection support.
Standard while loops and arrays works quite fine for low-level stuff. For everything else you shouldn't really be concerned with performance when using collections, for-comprehensions, and closures. It it usually quite easy to do a manual update to code that need performance tuning retroactively.
Are you saying "don't worry if it's slow, because it's easy to hand tune later"? I don't think most language users agree with this attitude as optimal.
No, I'm saying it's fast enough unless you really need optimal performance. :)
One of the link in the article is messed up it's : http://lamp.epfl.ch/~michelou/android/emulator-android-sdk.html
It'll be interesting to see if this language takes off as an alternative to Scala, Groovy or Java. Also, [Ceylon](http://en.wikipedia.org/wiki/Ceylon_Project).
&gt;..type signatures are just plain frightening Yes it is, I'm currently on chapter 19 of Programming in Scala by Odersky et al. Wow the +, - are just crazy. There might be a subset of features people are going to use and other that people are going to have to learn later on or never (if they're lazy). But it's very rewarding to learn new stuff such as infix, covariance, and contravariance. Other stuff such as generics and type parameters are very rewarding too. 
I would just like to express my displeasure and disappointment at the fact that this system has nothing to do with rogue-like games in general and Slashem in particular.
This language really comes off to me strongly as basically being just "Scala with the stuff we didn't like removed!", which I suppose was exactly their intention...
Couldn't they have modified the scala compiler to not compile the 'stuff they didn't like'? Make it a subset of scala rather than a competing language?
This was the executive version apparently.. Going to get my feet wet in Android this weekend and there is no way in hell I will use Java with it. EDIT: Holy hell that was a lot of work to get the ball rolling. I'm a bit overwhelmed with all of the new stuff and a lot of it still needs to sink in. It took about 10 hours total to get everything up to the point where I can start Idea and sbt and just code, code code. All of the SDK stuff, sbt (relearning after 0.10 made things entirely different) and Idea configurations took 95% of the time to get to hello world. Now I just need to start learning the Android way of doing things.
Told by the person whose code looks totally gibberish...
I formulated plans and rules to remember what covariance and contravariance mean, yet I've not found a single use for them yet. &lt;: has been quite sufficient
&gt; Your company has speakers at JavaOne, OSCON, Strangle Loop, QCon Nope. &gt; Lunch-time discussions involve the criteria for moving from a developer to a senior developer Nope. &gt; Your developers can write code in NotePad if they have to Nope. &gt; Your developers stare blankly or say 3 "Hail Marys" when they hear the name "Zed Shaw" Er, what? Nope. &gt; Developers all follow Dean Wampler on Twitter Who? Nope. &gt; Your developers come in at 9:15 and leave before 6 and don't check work email at night Er, most of them fit that description roughly. Certainly no one checks their work email at night. Judging from the criteria here, my organisation would find Scala hard. In reality, they would find scala easy, seeing as the majority of their code is written in Haskell, ML, and C.
I think Scala's OO and FP support works just fine. FP is obviously going to be a multi-year learning experience, but its really an educational gap (my college education was strictly imperative OO, even missing Discrete Matematics). If you keep FP in the Standard ML realm, thinking transformational, higher-order functions, closures, type members, recursion, currying, and pattern matching, are fairly tangible concepts. The highly generic programming techniques from Haskell isn't the only alternative to FP. The type sytem of Scala is obviously ad-hoc and accounts for the largest bulk of bugs in their tracker. From what I've read on the mailing list there seems to be ongoing work to unify and improve the type system. Maybe this will also improve the IDE situation which has been an especially sore spot since 2.8.0. I'm not worried about Eclipse though. They have knowledgeable people working on it and made good progress on it. Scala's collection library is amazingly useful. I don't really care if the type signature is scary. What it need is a good introductory tutorial to show you the whole breath and depth of it. There are a bunch of scattered blog posts which will get you acquainted with it, but it really needs a central documentation. Maybe that'll get resolved somewhat by those at EPFL recently put in charge of documentation. Now for fun, imaging if this blogpost had been about Lift and David's response to it. :)
David sure does keep the hype factor of Lift up
Many think that IntelliJ's Scala plugin is the best of the bunch. Looking on the web page, it appears that the plugin is being developed by Jet Brains itself. I wonder if they will allow it to languish now that they will be pushing Kotlin. EDIT: I accidentally a word
&gt; Your developers come in at 9:15 and leave before 6 and don't check work email at night Exactly how is that relevant in determining whether Scala would be easy or not?
So far...I like what I see in Kotlin.
I found reading the book scary and nightmarish (not because it's a bad book, but because there's *so much* and it's complex). I have since moved on to writing Scala, and it's been a joy, and that *despite* the IDE support sucking and the scaladocs sucking.
I use the nightly build for eclipse and update it everyday to see their progress. I just don't feel like learning a new IDE for it.
Mmmm Ceylon seems vaporware ish right now. I have to wait and see, I do love Linux and Redhat though. I don't think Kotlin can be an alternative to Groovy since Groovy is dynamic type. I also don't think it can be exactly be an alternative to Scala since it doesn't have much FP in it like Scala. But, it seems like a better Java though, like an evolution that Java is taking forever to get to (I don't believe Java have closure yet...). But I think this point is debatable. 
For those who aren't familiar with all the cloud terminology: Heroku is PaaS (Platform as a Service). What does this mean? Well Heroku runs on top of Amazon Cloud services as a foundation. What PaaS enable user to do is to skip the tedious system admin part and let the developers develop their app and put it on a PaaS and it'll take care of most of the system admin stuffs for you, yes it host it and everything. Note: Please correct me if I'm wrong. 
That 9-6 one really irks me. I've been programming computers for nearly 25 years. There once was a decade where I'd put in crazy hours, but now I've mellowed and matured and I know how to keep a life balance to avoid burnout and maximize productivity. Apparently this guy thinks that disqualifies me from using my current go-to language.
http://www.reddit.com/r/programming/comments/k2i8r/scala_is_for_drivers/ &lt;-- original post, i dunno how to x-post or whatever.
Why wouldn't you be able to write code in NotePad?
We use theorem provers which would technically make NotePad possible but proof-state would have to manually figured out which would take literally hours longer than writing it in the correct ide for the theorem prover.
As pointed out in the comments he seems to miss the point of the original presentation. The beauty of Clojure is in its simplicity and regularity. There's practically no syntax, and there's only a handful of data structures. Clojure makes what's going on obvious and explicit. While Scala certainly can be concise and has lots of great abstraction, it's also very complex and a lot of syntax can be surprising and takes time to master. 
Can you set it up to click on the poster?
Hate this argument as an indicator whether somebody is a good programmer. OK, it does show if someone is willing to push a project forward. But it should never come this far. This argument can only come from somebody who never really had to work extensive overtime over a longer period. What it does to you is not making you a better programmer but making you an aggressive, low-productive train wreck that will immediately have to go on holidays after the project is finally done.
For comparison, here's the equivalent (if I understand what the Scala code does correctly) Haskell code: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) &gt; takeWhile (&lt; 100) fibs [0,1,1,2,3,5,8,13,21,34,55,89]
Showing the equivalent haskell code just emphasizes how ugly is scala syntax.
Ok, give me 5 classes or methods where you don't like the documentation ... I'll have a look.
1. TabbedPane - where's the method "add" in the [scaladocs page](http://www.scala-lang.org/api/current/index.html#scala.swing.TabbedPane)? Recently tried to figure this class out, how to use it. It's not like the other swing panels where you add elements with contents+=... I was at a loss till I searched and found an example of usage on stackexchange. In general, examples of usage at the top of a class docs is a great thing to do. But the entire method shouldn't be missing. Other classes also have available methods missing too - I think maybe *protected* methods don't show up? 2. FlowPanel constructor can take an alignment. ie, new FlowPanel (alignment: Value)(contents0: Component*). So, what exactly is the type of that alignment object? It simply says it's a "Value", but that is not really true. One might guess that the Alignment object, with it's center, left, right values might serve, but that'd be wrong. The correct answer can only found (as far as I know), but reading the source code for FlowPanel.scala: class FlowPanel(alignment: FlowPanel.Alignment.Value) Ah. Of course. 3. In Reactor, what is the mysterious "Msg" type? It doesn't link to anything. I have no idea. There are many many examples in the docs of types that don't link to a definition, so one sees reference to a type in the docs, but no way to find out what that type is or how to use it. Another example is reference to "StringBuilder" in scala.collection.immutable.Vector.addString. Why doesn't it link to the StringBuilder definition? 4. It would have been nice if the docs had made it clear that calling listenTo(someSwingComponent) doesn't get you the mouse and key events from that component, that instead you have to use listenTo(someSwingComponent.mouse) or .keys. I'll stop there. Maybe when I'm at work and I run into something, I'll send it to you.
Ok, the problem child scala.swing, I can see your problems. Oracle's more or less complete deprecation of the whole Java SE Graphics/GUI stuff hasn't been a good reason to further work on scala.swing :-/ 1. The method you are looking for is `pages`. But in general you are completely right. Every class should have _at least_ one usage example. 2. This is already filed: https://issues.scala-lang.org/browse/SI-3314 I'll have a look if I can ping some people about it. 3. Msg is just a generic type, like T. I guess the confusing thing is that everyone expects type variables to have only a single letter. :-) I have already written a patch which enables support for arbitrary third-party documentation, so not only all classes should be linked, you should be able to jump directly to e. g. the JavaDoc of a underlying class hosted at Oracle, Apache, Google, ... 4. I'll document that. The next DocSpree is in two weeks, I'll set the whole scala.swing package on the todo list. Expect to see some improvements soon. Thanks!
Thanks! In relation to #3 and third-party docs, even if linking isn't practical, at least provide the fully-qualified name of the type in the docs. That would go a long way to cluing me in what was going on.
Isn't he abusing the term "syntactic sugar"? Seems like he uses it for any syntax.
I think this part from the lecture is quite good: &gt; And run it… &gt; error: polymorphic expression cannot be instantiated to expected type; &gt; found : [T(in method apply)]Example1OpsExp.this.MatrixNew[T(in method apply)] &gt; required: Example1OpsExp.this.Rep[Matrix[T(in method matrix_new)]] def matrix_new[T:Manifest](x: Exp[Int], y: Exp[Int]) = MatrixNew(x,y) &gt; &gt; What the hell? &gt; Debugging is painful – we’re working on it
in class Property, add 'val' before the name of the fields you want to access from the exterior. Or define the class Property as a 'case' class: case class Property (name:String, ... 
 Property (val name:String, ... didn't work Property( name: String ) { val name: String = ""; returns an error "... already defined" If I remove ( name: String ) from the previous snippet, it will not work as a constructor, and will not assign any value to it.
I'm pretty sure by default it's val if not stated. I think case class would do it. Bit sleepy and lazy. edit: I think the code should work I have no idea why it isn't accessing the property. Very curious now, try stackoverflow? There are very smart people over there.
You didn't understand. Declare your Property class like this: class Property ( val name: String, val length: Int, val default: String, val empty: Boolean, val unique: Boolean, val primary: Boolean ) { def to( datatype: Datatype ) = { datatype.add( this ); } } Without the 'val' (or 'var' depending of what you want to do) the name is not declared as a real field, and is just seen from inside the class. Another solution is to declare a "case class" like this: case class Property ( name: String, length: Int, default: String, empty: Boolean, unique: Boolean, primary: Boolean ) { def to( datatype: Datatype ) = { datatype.add( this ); } } And I suggest you have a look at this on-line book: Programming in Scala, First Edition http://www.artima.com/pins1ed/
I am one dumb motherfucker.
No, without the 'val' the field can only be used from the class and is not seen as a field from outside. It can be seen as a private field. If you add the 'val' your field becomes a public field. The exception is the case class where all the field are defined as 'val' by default. 
oh, thank you.
Another: In BoxPanel (and other containers) how does one use xLayoutAlignment and yLayoutAlignment? It's a double that some layout managers use? Ok, *how* do they use it? What values mean what? Trial and error yields strange results, I'd like the docs to simply states what the contract for these values is.
&gt; A RESTful, action based framework How can a framework be RESTful? Surely that can only be the property of an application.
yeah, It would be more accurate to say it's restful like or partially restful. But calling it that does describe how urls are modeled and resources are accessed. 
I felt that way until they released the [Scala 2.8 Collections documentation](http://www.scala-lang.org/docu/files/collections-api/collections.html) last September. Did you feel that it wasn't readable enough?
I like Play! I used it a few years ago to implement a PHP/Java bridge so that I didn't have to start stop the JVM every time I needed to access a class located in a jar.
Yes, that is what I had in mind with scattered posts. Combined with [Scala 2.8 Architecture documentation](http://www.scala-lang.org/docu/files/collections-api/collections-impl.html#) those are good in-depth references but isn't something I would point a beginner to. I would prefer a more gentler introduction like the [Code Commit](http://www.codecommit.com/blog/scala/scala-collections-for-the-easily-bored-part-1) posts.
I just hope they listen to reason and abandon the Anorm SQL engine in its current form. I would much rather use a type safe DB access library than a non-type safe one and get the added safety of type-checking at compile time. If they don't do this then I hope they keep the option to switch out DB access libraries in a relatively painless manner. 
&gt; I hope they keep the option to switch out DB access libraries in a relatively painless manner. I agree -- ANORM looks pretty atrocious. Thankfully, the project lead [has stated in the discussion thread](http://groups.google.com/group/play-framework/browse_thread/thread/8cdca8216bffc464/6a9fdce9aa581a51#msg_2a806297b565c685) that it is a priority to keep alternative DB access painless.
Sounds pretty cool. I might try to apply this to some of my simulation and modeling code.
It seems like an interesting approach to game development as well. There have been people trying this in Haskell with Yampa.
Please complain at the scala usergroup so we can finally get virtual classes in Scala &gt;_____&lt;. No I'm serious, this makes me miss C++. edit: No, I don't want any workaround. Workarounds are ugly smelly codes that Scala suppose to do away with. edit2: Sorry, I don't think C++ have this type of virtual.
Just use something else like Squeryl - no problem at all.
Actually, I find the explanation on the wiki article way better: http://en.wikipedia.org/wiki/Virtual_class#Purpose Way more concise and to the point.
That is what I plan to do. I'm just not sure I understand how a framework which is aiming for strong type safety - enough to warrant a typesafe template engine has decided to make the database access layer not typesafe. 
I find the existence of a null fallback troubling. In fact, I find it downright wrong and counter to the philosophy of Scala (assigning fields to _ is considered bad form as well, incidentally). If a user attempts to get the default value of a type for which none is defined, he or she can (and should!) get a compile-time error. In fact, the API designer can customize the error message with the @implicitNotFound annotation. If these issues were to be resolved, however, I think this would make a worthy addition to Predef!
An explanation would be good. Did you redefine or restrict Any, or are we seeing a compiler problem?
Something like this happened, which lead me to confusion: object Test { def add2(x:Long,y:Long): Long = x + y def add[Long](x: List[Long], y: List[Long]): List[Long] = if (x.isEmpty || y.isEmpty) Nil else add2(x.head, y.head) :: add(x.tail, y.tail) } ----------------------- error: type mismatch; found : Long(in method add) required: Long(in package scala) else add2(x.head, y.head) :: add(x.tail, y.tail) ^ one error found I guess is even funnier for [Any] :) .
I assume add[Long] is creating a new type with the name "Long", just like add[T]. Then you call add2 with your own type, where x and y are of type T (that you named unfortunately "Long"). Your "Long" is not a scala Long. 
Just change your add[Long](...) to add(...)
Scala sure is a great language, but blog entry is a complete circlejerk. Matlab and R are established in the ML community as scientific workspaces. It is what you use when you analyze data in the first go. They have REPL-like environments and what's more important, they have all the libraries in place. *That* is their strength. I don't think anyone would use R in a production environment, because everyone knows that R's performance sucks donkey ass. It's not R's job, and everyone knows R isn't meant for speedy computation. As for "Matlab": saying to compare against Matlab and then comparing against *Octave* (which we all know to be slower than Matlab) is a complete and utter joke.
Interesting part of the chat (by Sean Corfield): &gt; so the scala actors add much more overhead than the clojure equivalent? The main problem is that the current implementation of actors in Scala suffers from known memory leaks and performance problems - problems that are completely addressed by Akka, which is why they're going to incorporate it and replace the current implementation. 
I think this part is much more interesting and relevant: &gt;Scala code totaled about 1,000 lines. The Clojure replacement is just under 260 lines Reduction of code 4 times (!!!) is nothing to sneeze at. 
He stated that he also refactor along the way when he rewrote it in Clojure so rewriting stuff a second time tends to do that. Clojure is a dynamic language too. I'm not entirely sure if those two factors would result in 4x less code though. Scala is faster but the memory leak is something they should address. 
&gt;Scala is faster but the memory leak is something they should address. Actually clojure is OPTIONALLY typed :) Which means that when you need speed, you can easily get it by simply peppering types in slow places and getting rid of reflection. See for example [here](http://groups.google.com/group/clojure/msg/e42a0709499bedb4) &gt;Average run times to load 69,000 records: &gt; Java = 2.67 seconds &gt; Clojure = 2.72 seconds 
Troll is a bit extreme but you have a point in that too much definitely shouldn't be read into it before seeing the code.
I noticed this happening a lot in 2.9.0. Have you upgraded to 2.9.1? Fixed it for me.
Is it me, or it's a little too easy to shoot yourself in the foot while using Scala .
The trouble with writing command line clients in Scala is that you have to load the JRE every time you want to run a quick command. The CLI for ec2 is written in java and every time I run ec2-describe-instances I curse the author while I wait 3 seconds for the JRE to load.
You can always use something like [nailgun](http://www.martiansoftware.com/nailgun/) to solve this problem.
Seem like you are looking for [Argot](http://software.clapper.org/argot/). Also don't forget you can use any java library, such as: * [Apache Commons CLI](http://commons.apache.org/cli/) * [args4j](http://args4j.kohsuke.org/) * [ArgParser](http://www.cs.ubc.ca/~lloyd/java/doc/argparser/argparser/ArgParser.html) Finally, any time you hear the words "scala" and "parser" in the same sentence, you should think about scala's excellent parser combinators. Here's some [documentation](http://www.scala-lang.org/api/current/index.html#scala.util.parsing.combinator.Parsers) but you're probably better off googling a tutorial. (edit for formatting)
I wrote a tiny command line parser function for my use. This doesn't look like what you are looking for. But you can use it to parse individual subcommands. You will have to provide the top level command tree parsing yourself. http://pastie.org/2560492 
You can take a look at http://jcommander.org. This is targetted at java, but there is a section about scala in the documentation (http://jcommander.org/#Scala).
Argot is probably what is the closest to my need. But, still, I can't see how to handle these sub-commands things (maybe something to add to Argot). In Python, there is this 'argparse' API that allow to define sub-parser for each sub-command (see: http://docs.python.org/dev/library/argparse.html#sub-commands). I am just a bit surprised that nothing similar has been done in Scala. Thought, 'sbt' is working with sub-commands. So, I will try to take a look at its code.
Thank you for this. I've only begun to browse it, but I'm liking what I see so far.
Please let us know if you have any feedback. Pull requests and issues welcome!
Great stuff! I wonder if you considered using a current version of [SBT](https://github.com/harrah/xsbt), along with a build.sbt file that includes Finagle as a dependency? I've started to work on something like it, e.g., name := "Scala Example" version := "1.0" organization := "org.you" scalaVersion := "2.9.0-1" // Add multiple dependencies libraryDependencies ++= Seq( "com.twitter" % "finagle-core" % "1.9.0", "org.scalatest" %% "scalatest" % "1.6.1" % "test" ) // Add twitter's maven repository resolvers += "twitter.com" at "http://maven.twttr.com/" 
I know, image quality sucks for most non-keynote talks...
Since the completion of the collections api, I'm sure I read somewhere (though I can't recall where) that Martin Odersky said the OO features of Scala were instrumental in providing its flexibility. Whether or not that was just a dream, the collections api was a significant piece of work, and I wonder if Martin's perspective has been clarified since this thread. In my experience, though not entirely relevant to the discussion, functional languages don't deal as well as OO languages as regards mutual recursion across module boundaries (as in types referring to each other, where each type is defined in a separate module/package/compilation unit/etc). It can often be done but it can require some more thought. I don't think this is a particular deficiency of the paradigm, but perhaps implementation. This is related to some of Harrop's comments about polymorphic variants and objects in ocaml (though inference of object types is often ambiguous) - they help since the types don't need to be defined at point of use. 
we're not yet using sbt 0.10 at twitter or scala 2.9. maybe in a few months.
Speaking of timing, I just noticed the problem with Scala 2.9. However, Finagle seems to work well with sbt 0.11. I've documented a setup that will compile and run the EchoExample [here](http://www.fisharefriends.us/blog/2011-09-21-scala-plus-sbt-plus-finagle-plus-scalatest-plus-spring/). 
I gave up on SBT recently when a build broke because a plugin disappeared from github. The amount of symbols and syntactic tricks also make it really really difficult to understand. That and the fact that SBT 0.10 basically made all prior documentation on SBT invalid is just too much to take. I'll just wait for it to mature.
Yeah, sbt 0.10 (xsbt) is very different, and I stick with sbt 0.7x for my biggest project. But that's mostly because I haven't had the time/desire to port the build file. sbt 0.10 is definitely learnable and I'm using it for other projects. Maybe it's just me, but I haven't stumbled upon anything much much better than 0.7. serpix, what tool are you using now in sbt's place?
I ran back to maven. I'll get back to xsbt once it is slightly more mature and when every new release doesn't brake things up so much. I'm doing bleeding edge Android + Scala + Guice (RoboGuice) development on my free time. It is looking really promising. There are some really nasty gotchas with annotations and the way mixed Java and Scala sources need to be compiled. It took me slightly over one day to port the SBT build to use Maven. Which in itself does not demonstrate anything since I am quite fluent with Maven and not so much with SBT. Interestingly SBT's android plugin does ProGuard slightly faster than maven-proguard-plugin. I'm looking into getting the exact command out from what it does but at the moment the entire SBT android plugin is not working. Mainly it comes down to IDE integration. Dependencies stay up to date easily and I automatically get the sources as well. I like the fact that maven has good conventions to it, there is a consistent project file layout and once you have learned the basic build commands they apply to every project with any kind of technology combination.
MixMl addresses this very issue actually. 
I like Scala and Clojure, but I have to admit that I've only worked with Akka for actors and steered clear of the default actor library in Scala. Is there really that much of a headache to migrate from Scala's actors to Akka's actors, such that re-writing an app in Clojure makes it worth it? I understand the number of lines is much less (I'm thoroughly impressed here!), but I have to wonder if the re-training, etc, required to use Clojure was worth it.
Very interesting, I hadn't heard of it. Thanks.
This template project is now available on Github at https://github.com/jlcheng/hello-finagle
I am currently reading this [free book](http://ofps.oreilly.com/titles/9780596155957/index.html). It's ok for me . The other great book is called [Programming in Scala (A comprehensive step-by-step guide)](http://www.artima.com/shop/programming_in_scala_2ed) . 
Have read and love the latter at least
I've read both. As an experienced developer you'll get what you paid for form the free book. It's pretty weak. [Programming in Scala](http://www.artima.com/shop/programming_in_scala_2ed), on the other hand, is excellent, and IMO essential reading if you want to understand Scala.
"programming in scala" by odersky is like reference manual. one of the best programming books.
I've learnt more programming concepts from that book, than from the whole CS course at my university.
I hope you're exaggerating. Otherwise, you should ask the university for a refund and tell everyone not to go there. It's a good book but it's not that good.
Are we reduced to commenting on language confusion using motivational posters? How about a real comment.
What is the problem?
I tried the Pragmatic Press scala book and also "Programming in Scala" by Odersky et al, and the Odersky book is better by miles. I wouldn't recommend anything else.
Can someone explain this to me?
I like the 2nd edition by Odersky but it is moderately technical. I'm not entirely sure if having a CS background helps but it doesn't hurt with all the technical stuff it goes through. Then again of course there are very smart people out there that would think that this book is cake. &gt;___&lt;
Same. Higher kind? Type annotions. Wow that's just powerful but crazy shit. Head blow off often when I read this book. Not only that but the use of design patterns. Singleton and loan pattern was pretty neat.
OKAY.
I got the degree years ago, been working with JVM languages for the better part of 6-7 years now. It's just the next thing that I'd like to have on the resume. My book has shipped so we'll see how it turns out. 
Yeah, I found that to be strange. I'm really unfamiliar with Scala, and I have no frickin' idea of what's happening here and yet I have no fear that if I just looked into it, I could understand what's written here. No need to freak out and run for your life. Intellectual laziness...
Two things: (1) The documentation for Scala's standard library is good, mainly because it is very explicit. (2) However, its explicitness can be a hindrance to just getting a good enough idea of what something does to actually use it - which leads to wasting time having to go figure out what all of that stuff means. It's a problem, and it has been pointed out before. I think they're working on a making two-levels of documentation, one that is very detailed such as what is posted and one that is a bit more human-friendly. 
Oddly enough, manuals for programming languages are some of the best books about computer science. Borland Pascal's and C++'s manuals went into the nitty gritty of how OOP works on an assembly code basis that other books just don't. And yeah Programming in Scala is fab.
i've also read the book by the lift guy, i think it was "beginning scala". well, beginning is only in its title. the book was terrible and poorly written.
By adding a .g8 suffix to the project name it could have been a giter8 template. But maybe it's only me being lazy to write git clone. 
Have you seen the scalatest documentation?
well, that's kind of nice. I'll put it on my todo list.
The most interesting part for me would be the bind operator for time-varying values and expressions. I wonder what the difference though is between ScalaFX bindings, JavaFX bindings, Scala.React signals, and the same from other FRP implementations (FrTime, Flapjax, Fran, etc).
The blog post is pretty good and the author has done his homework, Scala does address a lot of the issues mentioned in Effective Java. However, not only is saying that "Java is left behind" laughable, but it's pretty clear now that Scala won't be its replacement The practices that Scala helped popularize live on in the recent crop of languages (Kotlin, Gosu, Fantom, Ceylon) which have the advantage of being much more pragmatic and simpler than Scala, but until one of them clearly takes over, which doesn't seem to be likely in the next few years, Java will remain the indisputable king of the hill. 
Yeah, definitely the best book on Scala.
I'd also recommend the #scala channel on freenode - there are really helpful people on there who can help you if you get stuck somewhere. As for books, of course "programming in scala" by odersky.
How does Vim compare to IntelliJ's Scala support? Especially refactoring, code reformating, syntax and error checking, sbt support, etc
The scaladoc should not be read by anyone who hasn't read through the Scala type system -- it's very powerful, and very hard to understand. The single best book to read on the subject is the [Programming in Scala](http://www.artima.com/shop/programming_in_scala_2ed) book. It's readable, but it doesn't try to be cutesy or to brush over the underlying architecture, which I've seen some other books do.
So how does fab compare vs sbt?
The crude analogy would be that sbt is more ant like and fab is more maven like. I haven’t used sbt since about version 0.9 so I can’t say what has changed. When I tried Sbt, it was strictly a build tool, and configured with a scala script. Fab is domain centric, it’s configuration is a declarative application configuration file in yaml, and the build is derived from that. My original goal was to have one configuration file for the whole project, no logging.properties, no persistence.xml, no web.xml, etc. all that is generated from the one central configuration. I tried using sbt early on but couldn’t reach that goal using it, so that’s why I created fab.
Not mine, though fairly interesting and I think it deserves some extra community love.
An important question is: are your Scala functions tail or head recursive?
It doesn't compare. Vim has syntax highlighting and that's about it. With that said, I've found it to be very productive when combined with sbt running in another console with ~test running. I use Vim because I prefer to edit text in Vim though, not because it has great Scala support. If you're not already sold on Vim then I don't think using it for writing Scala will ease adopting...you'll always be thinking that IntelliJ would have caught this syntax error or provided useful auto-complete here, etc. I've also used Emacs with ENSIME for Scala work (with Viper mode/Vim emulation of course). There it's much better...you get auto complete, type inference hints, syntax checking etc..
A language and its documentation written by academics for academics. 
I'm not an academic, yet I understand it easily.
python and now scala? The people at heroku are working at breakneck speed!
Why do all the Scala people have unfortunate names?
A good interview from a couple of experts on Scala. There are some good bits to take away: * David argues the logic "Scala is a superior computer language to Java and programs written in Scala are superior ... than those written in Java" is flawed if you are considering using Scala in a large organization. His focus has been on the point "the cost of institutional change to Scala is very high". He asserts ignoring the cost and focusing on the benefit is a logical flaw. * To be concise, the biggest hurdle a Java developer has to overcome learning Scala is not falling back on their Java mutable ways. But there are plenty of other hurdles (the type system, the documentation, lack of well defined patterns, etc.) * [Scala developers] won't be cheap (average cost $250/hr plus whatever markup I add.) They won't be local. But they will be excellent. * I think Scala is technically superior to Java, but it's not superior enough to overcome the predictability of using a known solution * If it makes you feel better to think, "I like Scala so I must be in the top 5% of developer" knock yourself out, but I would advise against believing your own press on that one. I have a bigger problem with people deciding that others are not smart enough to learn a particular language. * I think that there are people in the Scala community that do groove on intellectual bullying. But that's a significant minority, although they are pretty vocal. * A shoutout to GridGain. * one great way to try out Scala with a minimum of risk is to use it to write your tests for an existing Java project. Testing code doesn't go out to production, and libraries like ScalaTest, ScalaCheck and Borachio can greatly increase your productivity when writing tests. * Groovy is the worst of all possible worlds. It exists because JRuby wasn't quite up to snuff when Groovy was born. But Groovy is ugly (like Java), has inconsistent syntax, has weak meta-programming, weak performance, junk for a type system, etc. ... I think that Groovy is in the space of, "Well... there's nothing better. It's not something to get excited about, but it's better than nothing." Kind of like plastic garbage cans. They dent less than metal ones and have very little else to get excited about. * learning Scala will familiarize you with the features you will probably see in other modern statically typed languages that will be released in the next few years, so what have you got to lose? * Will Scala be the next Java? Unlikely, but it seems like it has a shot at being a tier one language like Ruby or Python. It just may take fifteen years. Scala, with its strongly typed, modern programming language features, and few legacy warts, is perhaps inspiring a bumper crop of new competitors (eg Ceylon, and Kotlin) and some retooling of olds ones (Groovy++ and Gosu) 
"Let me first say that I am a Scala lover [...]" but &lt;insert generic language bashing&gt;. I wonder what the hell happened with him in the last few weeks ... I don't know what his strategy is, but it is not constructive. There are many things which annoy me in Scala, you know what? I sit down, write a patch and fix it (and I'm not the guy who even remotely understands Lift). I wonder what prevents a language champion like him in sitting down and fixing the things he doesn't like...
I do not think you can write a patch to fix availability of scala developers regionally, outside of such technological hubs like Silicon Valley, New York, Seattle (say somewhere in Kansas in a middle of nowhere) I love haskell no less than you love scala. But i do recognize that its adoption will never go in mainstream. Why is admitting the same fact for scala is such a big problem for you ? 
Well, if you base your strategy on nay-sayers, every project will fail. It is critical that every project has a focus and a goal. Is there any benefit saying "We write a language, but we have no motivation at doing any real world impact"? I think that's pretty pointless. Scala is well after that point as a project already. I think the fact that many people disagree with your notion of "There will be always Java and nothing else" is a sign that not everyone shares your pessimism. Sure, there is always room for failure, but if the next generation uses JavaScript and PHP we - as a generation - have failed. And pretty every thing you claim has been said about Java, too.
Java is a better C++. It never questioned not tried to overthrow an imperative status quo. And as such it never run against adoption resistance. Functional programming though is entirely different matter. Granted, it already succeeded, already won its place under the sun. But that place always gonna be a small niche. And the reasons are in our human nature. For every doctor there are thousand nurses, for every engineer there are thousand mechanics. And for every functional programmer there will be thousands java/c#/vb programmers. 
I think it is completely hilarious how one group bashes Scala for being functional, while the other group does the exact opposite and bashes it for being object-oriented. At the same time these critics seem to love F#, which has tried to also cover both parts, but does a much worse job, because it puts the religious stuff front and center instead of being a helpful tool to developers. Actually seeing how Oracle tries to put as much stuff from Scala back into Java shows that the "functional" parts are not considered a problem for Java developers, even by Oracle.
Just you, and your poor foot.
I'm (was?) a long time JEE developer like you. Odersky's one it the best, Wampler and Payne's "Programming Scala" is very good too (and you can read it online). Once you get comfortable with that, I seriously suggest something like ["Learn you a Haskell for Great Good"](http://learnyouahaskell.com/) to get a better understanding of the functional part.
Thanks. Noted. I'm finding I'm still not quite grasping the functional aspect of programming. I am using Scala to augment some existing projects I am working on (JEE, Spring, Hibernate) and am finding I haven't quite used it to it's full capability, aside from using the parsing features which are very powerful to defining a simple grammar that you can use. 
Sure, no pressure :) Scala as an augmented Java is still an awesome language.
Compared to Java code actually most syntax is "syntactic sugar".
http://days2011.scala-lang.org/ ?
After clicking a link that is given for a search result, I get page not found for http://www.scala-lang.org/api/current/scala/scala.html
TL;DW anyone please?
Which of these openings is targeted to scala developers?
Meh. Not the best interview. The interviewer basically let Martin talk about Scala, a bit about the parallel research that they're looking at, and then chat briefly about the start-up scene in today's economy. Overall I'd give this a 2/10 for content.
I'm in this magical land called Boston.
Would you accept someone with extensive java and haskell experience, but no scala ?
LOL. You are kidding right ? I do not even know how are you going to judge the learning capability of someone who already told you he is using haskell of all the things. 
I don't think he(?) took it as an insult. Given the steep learning curve of Haskell, I'd think that Scala is relatively simple by comparison to pick up, especially with a Java background.
The tone of vagif's post made neufelry's response an appropriate and professional one.
I don't see how Scala is simpler than standard Haskell (98). Just looking at the structure of standard libraries tells quite much. Or take a look at Scalaz. Do you think it's simpler to make abstract programs in Scala? Subtyping, implicits, higher kinds, type variance are quite hard to grok when used in combination of a large program. But maybe you tried to emphasize 'pick up' which might be true, as you can restrict yourself to write Java-ish code in Scala.
I can see Canada from my office's window. Does that count?
Agreed, but I was trying to show a hopefully lighter side of his comment. I agree that neufelry's response is more than warranted.
I was more or less referring to the learning curve for functional programming rather than saying that Scala is simpler than Haskell. To be an expert in Scala does take a lot of patience and such, but having a background in functional programming does help. Let me put it another way, I think vagif *should* be able to pick up Scala faster than someone who has only been exposed to Java.
Hello fellow Bostonian!
I guess the real joke is that no one uses standard haskell, but GHC with proprietary extensions. And if you look at the complete „spec“ then some of these extensions alone are more complicated than the whole Scala spec.
No, you didn't offend him. He just tried to show you his superiority by starting an useless language war...
I intentionally left extensions away, as there is no consensus what is "adhoc standard" and it's hard to compare Scala against unspecified target. But if you include all of extensions, then you should include also external Scala libraries. Though, I wouldn't like to compare them anyway.
&gt; But if you include all of extensions, then you should include also external Scala libraries. That doesn't make any sense.
Here's some examples: http://lamp.epfl.ch/~phaller/readme_uniqueness.html http://www.scala-lang.org/node/140 http://blog.richdougherty.com/2009/02/delimited-continuations-in-scala_24.html
LOOOOL. http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
Ok. So you are intentionally interpreting me in a way that suits your needs. *blonk*
No, you just try to make up stuff and I call your bluff.
They're working on DSL for certain domain, Machine Learning,Genetic,Physic and apply optimisation to it where it will created a data flow representation and take in account available hardwares such as cpus, computers, and gpus before running. Initial trial shows that the code is faster than C++. He mentions about this before in previous interviews that they're doing DSL with Stanford but nothing more. This gave a small detail how it is going, like a mini update.
This. Odersky blows away the other books on Scala, not just from the comprehensive coverage, but also in ease of use and language. It takes the magic out of things like Scala implicits and higher kinded types and makes them seem, if not simple and obvious, at least comprehensible.
only in... second read.. :) i'm reading the book again and things are more clear for me now.
Doesn't work, at least not with my Firefox 7. Whatever I type, when I hit enter (I suppose that's how you commit a query?) the page stays blank.... Do you see anything when you open http://scalex.org/?q=map ?
These _are_ not the things coming in 2.10. This just false. These are proposals, which will (hopefully) be abandoned, and already completed improvements.
&gt; These are not the things coming in 2.10. This just false. The SIPs indicate some of this may be in 2.10: &gt; "In Scala 2.10: Introduce..." [SIP-12](http://scala.github.com/sips/pending/uncluttering-control.html) 
Some things may be **proposed** for 2.10. This is exactly the thing I said above ...
I really hope that string interpolation makes it. That's one of my most desired "little" features.
I would be against the string interpolation proposal because * It breaks literals in existing code * All your strings are already in resource files, right? Edit: Ok, scratch the first point, since it uses an escape. But I don't like the syntax, and don't think the language should be encouraging something that is arguably bad practice - if you are doing enough text formatting, to be bothered by the extra typing, maybe you need to rethink.
I disagree (partially). Scala is designed to be a "scalable" language; suitable both for small-scale "scripting-type" tasks as well as for large-scale software. I think this feature could be very nice in the kinds of small scripting tasks for which one may want to use Scala. The desirability of this particular syntax is debatable (but ultimately subjective).
Yes my wrong, I misunderstood what SIPs are.
There are lots of use cases where having strings in resources is overkill. I use Scala for prototyping research code. Any working piece of code will be rewritten from scratch... String interpolation is also useful for handling log or exception messages. If you don't translate/internationalize the scaladoc, there is no reason of translating the former.
Stuffing all you can think of into a language does not make it "scalable". I prefer a different approach: Haskell has quasiquoting/template haskell and there are a lot of libraries that implement all kind of string interpolations. My personal favorite: hamlet. 
at least a motivational poster with a real comment. 
Regarding SIP-12. DAE find code with parentheses easier to scan?
Syntax highlighting makes a big difference -- without it, I find code without parens hard to read. With it, it's fine.
I feel your pain. About the only language I know where you have vi mode is haskell. I could swear there is some utility written in ocaml that allows their repl to have a vi mode, but I can't find it.
You're looking for [rlwrap](http://utopia.knoware.nl/~hlub/uck/rlwrap/). Also, to get the desired vi-like behaviour, create a file named .inputrc in your home directory that contains the line set editing-mode vi After that, you typically invoke stuff like rlwrap &lt;whatever-console-application&gt;
Do they both produce immutable results? Why not an IndexedSeq instead of Seq?
http://aperiodic.net/phil/scala/s-99/ http://projecteuler.net/
http://blog.tmorris.net/scala-exercises-for-beginners/ http://stackoverflow.com/questions/tagged/scala+homework?sort=newest&amp;pagesize=50 Others have done Tower Hanoi, N queens, sieve of whats his name, tennis and Bowling scoring, ROT-13/Caesar's cipher etc. You can google for them after you've tried your hand
Those who enter Project Euler are never seen again.
&gt; sieve of whats his name Eratosthenes
[scala labs](http://scala-labs.github.com/)
Thanks for the info! I found this recipe worked on my Mac. * Download and install [MacPorts](http://www.macports.org/) * From the terminal type: *sudo port install rlwrap* * Invoke scala: *rlwrap scala -Xnojline*
buf ++= xs :: Append all elements in xs to buf -&gt; :: map to, as in val myMap = Map(1 -&gt; "a", 2 -&gt; "b") &lt;= :: LTE, except in Lift... _._ :: I believe applies a noop to both params? I'm pretty sure I got _._ wrong. Regardless, I recommend Programming in Scala 2nd Edition as a good reference for 85% of questions.
Derp. Considering that -&gt;, &lt;-, and =&gt; are all arrows, I'm not surprised I made that mistake.
Oh god, I feel your pain so much. SBT is especially guilty of this. The scaladoc is [here](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.List), but that only helps if you can understand the incredibly terse Scaladocs. There is a more casual reference [here](http://www.scala-lang.org/docu/files/collections-api/collections.html), which gives a good overview. All of the operators have a "long form" method equivalent that may be easier to scan as well, at least in the beginning.
I took the liberty to re-post this on Stackoverflow, because indeed a central document is lacking. http://stackoverflow.com/questions/7888944/scala-punctuation
Here's my own answer on Stack Overflow: http://stackoverflow.com/questions/7888944/scala-punctuation/7890032#7890032. I don't explain each of in detail (_._ looks like a typo anyway), but I explain how to find information for each of them.
Those can be methods or combination of assignments and methods, so the meaning depends on the class defining the methods. Without context here is the most likely interpretation: -&gt; is utility method creating a tuple: those are the same: 1 -&gt; "one" Tuple2(1, "one") (1, "one") ||= is most likely apply the || method (such as boolean or) on a var and reassigning the result to it like in scala&gt; var b = false; val a = true scala&gt; b ||= a scala&gt; b // Boolean = true This is similar to Java's int i = 0; i += 1 but generalized. Same for ++=, where ++ most of the time concatenates Traversable (a collection) scala&gt; var arr1 = Array(1) arr1: Array[Int] = Array(1) scala&gt; arr1 ++= Array(2) scala&gt; arr1 // Array[Int] = Array(1, 2) &lt;= is likely less than equal scala&gt; 1 &lt;= 1 // Boolean = true scala&gt; 1 &lt;= 0 // Boolean = false \_.\_ is likely using placeholder syntax in an anonymous function. The first underscore is the object, the second the method being called. I'll have to think of an example. Edit: most likely this is invalid scala code. Can you post a larger context on this example? :: is most likely use for adding (really prepending) an element to a list or pattern matching: scala&gt; val l = 1 :: Nil l: List[Int] = List(1) scala&gt; l match { case a :: Nil =&gt; a case _ =&gt; -1 } // Int = 1 :+= is most likely applying :+ to an object and reassigning to the var, where :+ appends an element to a collection. scala&gt; var v = Vector(1) v: scala.collection.immutable.Vector[Int] = Vector(1) scala&gt; v :+= 2 scala&gt; v // scala.collection.immutable.Vector[Int] = Vector(1, 2) 
A couple other resources Staircase first edition index http://www.artima.com/pins1ed/book-index.html#indexanchor Scalex, like hoogle, search by method/function signature, and n-gram indexing for e.g. &lt;:&lt; http://scalex.org/?q=%3C%3A%3C ------------ There's also an effort to load searchable terms into google, like "scala colon colon" http://groups.google.com/group/scala-internals/browse_thread/thread/413dbc691542f76f/ 
Scalex doesn't find anything for underscore/period/underscore. This is a good field guide to underscore/wildcards http://www.slideshare.net/normation/scala-dreaded http://agileskills2.org/blog/2011/05/01/revealing-the-scala-magicians-code-expression/
I found [this cheat sheet](http://jim-mcbeath.blogspot.com/2008/12/scala-operator-cheat-sheet.html) a while back. It's a bit out of date at this point but you could probably use the script at the bottom to generate a new one (and potentially incorporate operators from nonstandard libraries as well). 
Well, you have to look at the class which defines those methods. None of those above are part of Scala's syntax. You know http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html#index.index-_ right?
Highly recommend getting Programming in Scala 2ed from Artima http://www.artima.com/shop/programming_in_scala
_._ is not possible. The dot is used to indicate method call, and methods are not values, so they cannot be passed as parameters. Functions can be passed as parameters, sure, and methods can be turned into functions, sure, but functions cannot be invoked with the dot notation.
This is beyond me. How do I improve my skills so I can understand this stuff? Seems beyond the usual books I have - Programming in Scala, etc.
Is this your work? If so I have a couple of questions.
You don't need to really. Scala is not a functional language. It's a OO language with functional features. You can judicially use functional features "in the small" like working with sequences and transforming them via chains of map, fold, filter. If you really want a language where all these scary monads actually do payoff, then try haskell. I use it in production (web framework yesod) and am very happy with it. 
There are a couple of different things going on here, that you can probably look at independently. I would first look at tail recursion, then trampolines, and save monads for later. Monads are probably the hardest part to grok conceptually. Monad tutorials are a cottage industry and the best thing to do is to just google *monad tutorial scala* and start working your way through them. [Here is a decent monad tutorial](http://www.codecommit.com/blog/ruby/monads-are-not-metaphors)
Nope, it's not my work.
Wow. That is a fantastic website! Truly, it fitting for a language of Scala's stature to have such an excellent documentation hub. Kudos to whoever designed it! There are a few minor tweaks that need to be made; in particular, the formatting of the code examples in the Cheatsheet is way off (also a few instances of incorrect style -- using `(x:T) =&gt; x` instead of the stylistically correct `(x: T) =&gt; x`. Other than that, this site is amazing.
Exactly.
I think what ohdeno and smcj are pointing out is that most people will gladly take the hit in compile time CPU and Memory usage in exchange for better runtime characteristics.
&gt;Compiling simple Hello World (including tests) yields the following results: &gt;* OpenJDK Client VM: 100–113 s (at 100% CPU the entire time); memory 40 MB just SBT, 150 MB after compilation * OpenJDK Server VM: 5 s ; memory 36 MB just SBT, 99 MB after compilation These numbers seem to favor the server VM quite heavily. Maybe a typo somewhere?
I suggest using Client VM for development and Server VM for deployment. This is meant to be the default behavior, but oftentimes — for various reasons specified in the post — is not the case. Someone evaluating Scala may be discouraged by the compile times or by the Eclipse performance for this very reason, while not realizing that there’s a relatively easy fix available. If the eager optimizations constitute a several magnitudes increase in resource utilization, while the tasks are run for only a short periods of time (which is usually the case for the purposes of development), the optimizations are not just useless, but actively harmful. 
~~... using both for development?~~ Parent fixed typo. ETA: Again, why should I use the client if it takes 100s to compile whereas server takes 5s? Plus lower memory usage.
Looks like ohdeno just edited the text, reversing the two.
Uh crap. I’m getting angry at why people won’t read the damn thing, when in fact I’ve myself made a mistake. The 5s should be for Client, rather than Server. Sorry, everyone! EDIT: Though that it was a mistake should have been rather obvious from the context… I guess it was for whomever upvoted the thing. EDIT2: Have I mentioned that I mod /r/adhd ;-)
I put the labels first, then added the numbers. Somehow got it mixed at some point. Sorry for the drama :) 
Looks like ubuntu 11.04. Have you tried IDEA with openJDK? When you try to specify that JDK, IDEA barfs up all kinds of dire warnings that you should only use sunjdk.
It’s Fedora 15 both on EC2 and my desktop. As far as I know, Ubuntu doesn’t ship with Client mode in 64-bit version either. As I understand it, OpenJDK 6 *is* SunJDK 6 for all intents and purposes, except the JavaWS launcher (replaced by IcedTea). Which means OpenJDK 6 actually inherits this issue from SunJDK 6. EDIT: I’ve just checked SunJDK 6 and OpenJDK 7. Sun/Oracle don’t include Client mode in their x64 binary packages either. The default behavior with 2GB+ seems to be the same as well. I wonder if it’s any different with their Windows binaries and whatever Apple OSX ships?
Well, it seems important to Jetbrains. Man, i had all kindsa problems last 24 hours, the 32-bit JDK6_29 binary off Oracle's download page wouldn't self-extract, IDEA wouldn't recognize any SDK installed under Win7, plugins.intellij.net is up and down. But it all works fine under Snow leopard... (I wasn't really trying to hijack the thread)
It’s probably because of the font rendering and stuff. It’s replaced with FreeType in OpenJDK. The actual runtime and JIT are the same. &gt; IDEA wouldn't recognize any SDK installed under Win7 I didn’t know OpenJDK 6 is even getting packaged for Windows. 
sunjdk6 for win32. IDEA finally picked up on it after 3 reboots. I will try the eclipse plugin sometime soon, it's just that i have so much invested in Textmate, vim and IDEA. And i need to learn emacs. And here's the incantation to swap JDK's in ubuntu sudo update-java-alternatives -s java-6-sun
I love the new website, but when are we going to see this become the default landing page when you click on the Docs link on scala-lang.org?
I'm not getting anything near these numbers. 100s to compile a simple HelloWorld app is crazy. Something else is wrong. I see some disparities between client and server profiles but basically negligible. I could post my results if you'd like, but I assure you that you must have something wrong.
Hmm. Ok, 100s is STILL too long, but when I fix my sbt launch script to actually use client then yea...I am seeing a noticable benefit.
The difference is smaller on my desktop, but it is still substantial. I’ve made the benchmark on EC2, so that anyone can reproduce it, and to show what happens when someone without $10K dev box wants to try Scala. Remember, this is *just* HelloWorld. It only gets worse as the complexity increases. BTW. When you’re reproducing results, remember that this test is with testing. It’s Widget.scala *and* TestWidget.scala
I’ve tested it on EC2 m1.large and the speed results are indeed negligible. However, the memory usage peeks at as high as 344 MB. Apparently, the Server JVM can behave itself with 7GB of memory to crunch on. So does this latency problem manifests itself with more complex workloads, like Eclipse? I don’t know. However, please do not misunderstand me. I don’t mean to bash on Server JVM. All I’m saying is, if you do have performance issues with developing for Scala, try switching to Client mode and it might just be the thing that helps. The JVM behaves a little bit more like CPython in Client mode and this seems just fine for running Eclipse and ScalaC. The included benchmark is only meant to illustrate the worst-case scenario with default settings. 
Did you say what hotspot switches you'res using? http://groups.google.com/group/jvm-languages/browse_frm/thread/3052f5cdb929e9ee# http://groups.google.com/group/clojure/browse_frm/thread/33f80f1bb8277351# http://blog.headius.com/2009/01/my-favorite-hotspot-jvm-flags.html
Adding these switches: java -server -Xmx512M -XX:CompileThreshold=1500 -XX:-Inline -jar `dirname $0`/../sbt-launch.jar "$@" [success] Total time: 80 s, completed Nov 8, 2011 7:21:53 AM sbt test 14.24s user 1.11s system 16% cpu 1:30.54 total I haven’t tested OpenJDK 1.7 at all though. I should probably also test using the small instance (1.7 GB)… Anyway, I just wanted to put info on how to get Client mode somewhere visible. I don’t really want to defend my analysis of JVM performance too much, since I don’t consider myself an expert. It’s just that default settings are really bad in certain circumstances and there’s really no penalty for switching to Client mode on what is clearly a “Client” environment. That’s all. If Server mode is working for y'all then that’s fine. I could only use VIM to code Scala with Server mode though, and even then it was annoying compared to lighter runtimes like CPython, PyPy or even Mono. Enforcing Client mode was a life-changer. 
This was the post i was looking for: http://blog.headius.com/2010/03/jruby-startup-time-tips.html Anyway, I appreciate your doing this, a non-trivial % of folks starting scala are not familiar with all the hotspot options, this'll save some time.
I just tried it on a couple SBT projects I had. My mistake was the sbt script specified -server in its JVM arguments. I took that out and then noticed a difference (not a 100x difference but definitely substantial).
Singletons have there place in the programming world, and dismissing it whole heartedly because of the potential for abuse is just absurd. You can write bad getter/setters, but that doesn't make it an anti-pattern. The article seems a bit preachy and academic to me.
I thought the continuations were used for the control flow language in Ingos' work, while this post seems to be about the pure FRP part which, AFAIK, doesn't require continuations to be implemented.
It took me forever to figure out how this worked. Damn continuations! The article would be improved by throwing in some code and explaining what's going on. Does anyone know of libraries that do similar? fruit/signal is not a very descriptive interface.
How does this differ from binding?
The linked pdf on [deprecating observers](http://lamp.epfl.ch/~imaier/pub/DeprecatingObserversTR2010.pdf) was much more interesting, in my opinion...
***codeeval***: &gt;&amp;#91;2011/11/17&amp;#93;&amp;#91;23:23:40&amp;#93; &gt;[&amp;#91;Translate&amp;#93;](http://translate.google.com/#auto|auto|@codeeval now supports solutions in scala #scala #programming 'google translate this tweet'): [*@codeeval*](https://twitter.com/codeeval 'twitter user profile') now supports solutions in scala [*&amp;#35;scala*](https://twitter.com/search/%23scala 'twitter tag search') [*&amp;#35;programming*](https://twitter.com/search/%23programming 'twitter tag search') [&amp;#91;This comment was posted by a bot&amp;#93;&amp;#91;FAQ&amp;#93;](http://www.reddit.com/help/faqs/tweet_poster 'tweet_poster FAQ')[&amp;#91;Did I get it wrong?&amp;#93;](http://www.reddit.com/message/compose/?to=tweet_poster&amp;subject=Error%20Report&amp;message=[Oops!](http://reddit.com/r/scala/comments/mgj0p\)%0d%0dPlease leave the subject and this link unaltered, but feel free to add a description here. 'report an error')
Jim (the company founder) was great. I worked with him today to get Scala 2.9.1 support up and running on the site. Great props to him, and a great site overall.
Are you kidding me? Singleton objects in Scala are used as first-class modules. All you're doing is ripping on mutable variables in modules.
SBT is a lot simpler than you think. You could probably get away with simply a .sbt file. I find the doc a little on the spartan side, however I was able to get going with just using a .sbt file. Once you figure this out, the rest starts making sense.
So Gradle looks like being sort of a better Maven? And I ought to persevere with SBT? I'll give these two a go and let you know how I feel in a while or two. Thx.
I wrote an [article on tail calls and trampolines in Scala](http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html) which you could find helpful. My article covers a lot of the same material as Rúnar's (he references it) but he takes things a lot further.
If you ask questions here, I'll do my best to help. 
http://stackoverflow.com/questions/tagged/scala
Thanks! I've posted to http://stackoverflow.com/questions/8188959/r-the-meaning-of-in-scala
[Scala API](http://www.scala-lang.org/archives/downloads/distrib/files/nightly/docs/library/index.html) can answer a lot of questions. But it won't help your example since split is for java.lang.String. If you look there you will find split takes a regular expression. Googling regular expressions would answer what "\r?\n" is doing. It is optionally matching cartridge returns [edit: should be carriage return. (thx kkrev)] followed by a required line feed: line endings in Windows and Unix. Sorry if you already figured out as much. Following all the implicit conversions, like from java.lang.String to scala.collection.immutable.WrappedString and back, can be tricky but if you look at scala.Predef you will find the most used ones. 
FTFY: "cartridge returns" is a typo for "carriage return". Don't go googling cartridge return. Just so you understand the issue, different platforms have different ideas about what marks the end of a line in a plain text document. The file you were parsing was presumably generated by a Windows program. "\n" would have worked fine on a file made by a Unix program. "\r\n" for windows. "\r?\n" for either. And internet protocols use a subtly different endline marker.
I agree. The brilliant folks at EPFL put a great deal of work into that paper. Fruit, on the other hand, was just a weekend project for a little challenge and fun.
The benefit that this approach gives me (which I can't find a way to do without continuations) is the ability to compose signals: println(signal(combo1) + " " + signal(combo2)) There are two calls to shift which will cause the re-evaluation of the continuation, println, when either of the two signals are triggered.
Can you give an example?
oh definitely - I'm going to see if I can work out some of the whitepaper in Javascript for fun. 
Sounds interesting!
My Scala+Android environment comprises SBT (with jberkel's android-plugin), IntelliJ, Specs2, RoboSpecs. **sbt** It's worth acknowledging that SBT does have a steep learning curve HOWEVER the distance from confusion to productivity is not as long as the curve makes it seem. This helps a lot and is rather new, https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome **RoboInstaller** Once thing to ease the pain that you may want to check out is this: http://android-argentina.blogspot.com/2011/11/roboinstaller-install-roboguice.html This lets you install dexed versions of the scala standard library on your device so they can be referenced as dependencies in your AndroidManifest.xml in the same way you'd reference the Google Maps API. This saves a lot of time during when building and deploying your app to a device during development. You have to use build using proguard including the scala standard library when making an APK for redistribution or the market though.
Ditto. There is also the /r/learnprogramming that can be used. If you tag it with [Scala], you may help find answers faster.
Hello, We are an offshore custom software development company and now we have recently started offering Scala development services and currently we have two senior 8+ years Java developers who have got good hands on the same. One of our recent case study was published on our website: http://www.spaceotechnologies.com/scala-lift-extjs-case-study.html Incase if you need any of our Scala / Lift development Services do let us know about the same. 
Stackoverflow and the scala newsgroup over at googlegroup is pretty helpful for me. The google group have 2 scala group, one of them is for newbie. I usually lurk here for general scala news.
Sweet thx u. I'll save this comment for later ^_^.
This is so what I need. I wish I lived in SF! I had no problem learning Python, PHP and JavaScript... but I've hit a bit of wall with Scala in part due to unfamiliarity with the tooling one needs just to be productive - sbt, an IDE, etc. Sounds like a nice night.
http://technically.us/code/x/oauth-here-she-comes/ and if you want something more fully fleshed out you can try: https://github.com/ben-biddington/Coriander.OAuth 
It's my impression that java 7 addresses a lot of these issues and tries to bring best of both worlds to the jvm.
That’d be great. I’ll give it a go, now that OpenJDK 7 is included with Fedora 16. 
I have a little OAuth client in my work-in-progress [Pedro](https://github.com/ishmal/pedro) lib. Tested on Twitter and Facebook. It's not doc'd, but if you look in the tests, there is an example showing how simple it is. 
I found [Scribe](https://github.com/fernandezpablo85/scribe-java) to be pretty [simple to use](http://www.earldouglas.com/consuming-the-twitter-api-in-scala-with-scribe/).
Here's a summarization by tenshi (original post http://hacking-scala.posterous.com/new-features-in-scala-210): * New reflection framework - it looks very nice (see photo) and 100% Scala. No need for Java for reflection API in order to work with Scala classes anymore! * Reification - it would be limited * type Dynamic - something similar to .NET 3 * IDE improvements * Faster builds * SIPs: string interpolation and simpler implicits 
perhaps the fear of the "evil singleton" is the reason why Java language designers avoids a centralized event dispatch loop. I'm surprised this has not been addressed by the concurrency or nio apis.
A second vote for Dispatch (http://dispatch.databinder.net/Dispatch.html), which is what the OAuth here she comes article references. The documentation is pretty sparse, but I just wrote a little app to populate a Vimeo account and once I got the basics down it worked great.
Really fascinating. The current trunk builds are just impressive.
A pity the slides only go into the new reflection framework and duplicate lots of things from slideshows I've seen before (the part about concurrency and parallelism). -- The most interesting bullet point seems to be Reification. I can't find any details on this one. Has anyone more information about what Scala 2.10 brings in terms of type reification?
Mmmh... No matter how you slice and dice it, what I take away is: - One job in thirty in the UK (probably worse elsewhere, I assume they pick the best stat). - Ranked below 50 in the TIOBE. Also, they need to stop showing this graph from indeed.com which 1) mysteriously stops in January 2011 and 2) shows that Scala grew from 0.01% to 0.02%. Yes, it's a 100% growth (not 10x by the way), but... come on, seriously? Overall, I'd say the picture is pretty bleak for Scala. 
I love the points brought up by Daniel Spiewak (comment #13). And T. Morris came along to civilized it again. Both are pretty much well known Scala programmers, well at least to me. Anyway, was curious at Cylon vs Scala did some research and end up with this interesting post. So I thought I would post it. 
I don't know what you see in that graph from Indeed but I see scala growing from 0.01% to about 0.03% in 2011. About 3.4% of the jobs on Indeed are java related, so about 1 in 110 java developers use scala, that's not bad at all.
Hehe, I remember that one. Gavin King threw some jabs at Scala and received a couple back. I personally think these languages are way too late. By the time they come out, Java will have reduced its major deficiencies, and Scala will have grown more solid with benefits from its parallel computation project.
In the end, I don't think there will be any place left for some “better Java”. Who cares about the promises of a slightly improved Java (Kotlin, Ceylon, Gosu, Fantom) competing against Java 7? When those languages got enough bug-fixing and releases to be called “mature” (probably somewhere around 2020) the will have to compete against Java 12, not Java 7. Either people decide to take a modern languages which is mature, stable and years ahead of Java, then they will choose Scala. Or they stay at Java and get some of Scala's improvements 10 years down the road.
Ha ha, ok, 0.03% and not 0.02%. Pretty much any marginal language such as Groovy [shows a similar curve](http://www.indeed.com/jobtrends?q=groovy&amp;l=) (although Groovy is at 0.04%). Overall, I'm suspicious with indeed.com's numbers, starting with the fact that they stopped measuring in January 2011 (why? Maybe because Scala went under the margin of error threshold?). As for your other claim, not exactly: you can say that for each Scala job, there are more than 100 Java jobs. Again, not exactly glowing numbers for Scala. 
I feel bad for Gavin needing to participating in this flame war. I'm giving him the benefit of the doubt, at least until he has a compiler implemented so we can play around with the language.
*Cylon*: robots/replicants/toasters from Battlestar Galactica *Ceylon*: Portuguese imperial name for the country now known as Sri Lanka, a major producer of tea (known as Ceylon Tea). Programming language. I was honestly confused for a while, I'd heard of Ceylon... thought Cylon was a new language.
http://www.indeed.com/jobanalytics/jobtrends?q=scala&amp;l= They didn't stop measuring in jan 2011, I think you have problems reading the graph. The scale on the x-axis is 1 year, the next mark will be jan 2012, we're not there yet so the graph is cut off and we can safely guess that the end of the graph is nov 2011. If you compare with other jvm languages Scala does very well, it shows very consistent growth, if they can keep this up, next year it will be 1/50. http://www.indeed.com/jobtrends?q=scala%2C+fantom%2C+clojure&amp;l=
I thought it was going to be another BSG joke =(
&lt;shrug&gt; Yeah, the Linux crowd has been using the "growth" metric for decades now, it's still not very convincing when your mind share is less than the margin of error. Considering all the exposure that Scala has received these past two-three years, the fact that still has less than a 1% mind share today is probably a sign that it's not the replacement of Java we're all looking for. 
A couple more graphs: - [With Groovy](http://www.indeed.com/jobtrends?q=scala%2C+fantom%2C+clojure%2C+groovy&amp;l=) (growing much faster than Scala). - [With Java](http://www.indeed.com/jobtrends?q=scala%2C+fantom%2C+clojure%2C+groovy%2C+java&amp;l=). I think the latter one speaks for itself.
Flame wars are seldom useful, and also this post is quite old. The more interesting question is how are they going to deal with the development. Judging from https://github.com/ceylon/ceylon-spec/issues it seems pretty much a bumpling around without clear thinking.
As a person who likes to fiddle with Scala's type system, I still would choose a language like Kotlin over it for professional work.
&gt;If you compare with other jvm languages Scala does very well, it shows very consistent growth Not really. Compare scala, language that does everything to achieve success and recognition with enterprise java developers with clojure, language that tries to avoid success at all costs (lisp syntax, the HORROR!!, immutable data types!, LAZY sequence functions) Clojure [adoption](http://www.indeed.com/jobtrends?q=clojure&amp;l=) is at whooping 0.05%. Again, this is for a language that is completely alien for java programmers. If scala cannot catch up with a god forsaken lisp, despite all the "enterprise" massaging, i'd say something is seriously wrong with it. 
Closure adoption is at a whooping 0.005%. I hope you're not representative of the clojure cowd, reading graphs really isn't that hard.
I don't expect scala to to replace java, nobody does (I hope), it also doesn't need to overtake java to be successful. If 10% of all java developers switch to scala it will be a huge success. And about that mindshare, 2 years ago almost nobody had heard of scala. Now, most java developers have heard of it, maybe 10% took the time to take a look at it even less have actually used it. Scala still has a long way to go. Getting into the enterprise takes even more time, and I'm sure many developers (like me) are waiting for the right time to introduce it. 
Touché :) 
feel bad for him? he *started* the flame war by intentionally baiting scala people.
That's not how I see it. He doesn't even mention Scala in the blog post. The first time he talks about Scala, it's in a comment response to Daniel asking him "I'm interested why you think Scala isn't quite the language you were looking for." and his answer is littered with emphasis that everything he says about Scala is merely his personal opinion.
Gavin dissed Scala in presentations he gave on Ceylon, that was what started it.
It's interesting to look at the Thoughtworks Technology Radar - trying to read the tea leaves... * [Jan 2010](http://www.thoughtworks.com/sites/www.thoughtworks.com/files/files/technology-radar-jan-2010.pdf): functional languages are lumped together in the *Assess* zone near the *Trial* line. * [April 2010](http://www.thoughtworks.com/sites/www.thoughtworks.com/files/files/tw-radar-april-2010.pdf): they break out 3 languages all in the *Assess* zone, Clojure, F# and Scala, with Clojure ahead *really* near the *Trial* line, while Scala is back *really* near the *Hold* line, because Clojure is *"the one they like the most"*. * [August 2010](http://www.thoughtworks.com/sites/www.thoughtworks.com/files/files/thoughtworks-tech-radar-august-2010-US-color.pdf): Clojure and F# near the *Trial* line, but still in the *Assess* zone; They say *"at the moment we believe F# and Clojure to be better suited to most organizations for assessing than Scala"*. * [January 2011](http://www.thoughtworks.com/sites/www.thoughtworks.com/files/files/thoughtworks-tech-radar-january-2011-US-color.pdf): Scala upgraded right in the middle of the *Trial* while Clojure and F# remain in *Assess* zone. **"we have witnessed great successes in the adoption of Scala. Consequently we have moved Scala into our Trial category"**. * [July 2011](http://www.thoughtworks.com/sites/www.thoughtworks.com/files/files/thoughtworks-tech-radar-july-2011-us-color.pdf): Scala in *Trial* a tiny bit closer to *Adopt*. Clojure and F# still in *Assess*. So it looks like even though they like Clojure, they *witnessed* successful Scala adoption, had to recognize that fact and just placed Scala ahead of Clojure and F#. If you ask me, I think Scala has a bright future...
Although the main article is just ruminating the incontinent jerk-off of stephen colebourne, I think the picture that the comments paint if very informative. Good vibes in the bottom line...
I'll throw in another graph because it just makes me laugh: [Cobol is at 0.2%](http://www.indeed.com/jobtrends?q=cobol&amp;l=), so ten times as more popular as Scala (and Fortran is at 0.04%, so twice as much). 
So would I. I have some fairly modest feature requests (traits, properties, first class functions and a few others) and Scala is giving me way, way more than I need. And I'm not willing to pay the complexity tax that comes with it. 
Any evidence to back this up? Because there is no mention of Scala in his presentation. Anyway, it's not hugely important: it's pretty obvious that anyone who creates a JVM language today is unhappy with all the languages that exist on it. 
They just released an [early version of their Eclipse plug-in](http://ceylon-lang.org/documentation/ide/), which contains the compiler (I haven't tried it, it's probably very buggy, but kudos for releasing an IDE plug-in before a standalone compiler, which means they take tooling seriously). 
I would love to see this kind of study from an organization that doesn't have a conflict of interest in reporting them. 
I keep really wondering ... isn't that pretty much the opposite of being pragmatic? Betting on a language without compiler, documentation, books, community, libraries, ecosystem ...
kindly explain the conflict of interest, afaik Thoughtworks has nothing to do with Typesafe
What do you mean by betting? I will make a decision to use, or not to use a particular tool at each appropriate time, i.e. when Kotlin is mature enough (whatever that means), I use it if there is no better alternative (or I feel like it). Until then, I pick a language from existing ones. Currently I use both Java and Scala. It just seems that there is hope that I don't need to be stuck up with those alternatives in the future (or even now, e.g. Clojure).
I think people should stay realistic. Scala is available, has a stable compiler, a language spec, broad tooling support, an experienced community, commercial backing and the greatest minds behind it. Scala *now* is years ahead of Java. Kotlin/Ceylon is not usable at all at the moment and I seriously wonder how many Java developers will switch from Java 12 to a slightly improved Java 7 competitor.
Thoughtworks does consulting and software development. I'm sure they meet with a variety of customers or prospect customers and therefore they are in a good position to see industry trends. Whether they have on interest on pitching Scala, I don't think that's the case as they specifically said they were recommending Clojure or F#. 
[This real critique](https://gist.github.com/1406238) is way better. * The number of concepts I had to explain to new members of our team for even the simplest usage of a collection was surprising: implicit parameters, builder typeclasses, "operator overloading", return type inference, etc. etc. * In addition to the concepts and specific implementations that Scala introduces, there is also a cultural layer of what it means to write idiomatic Scala. * In hindsight, I definitely underestimated both the difficulty and importance of learning (and teaching) Scala. * We looked at using 0.10, but we found it to have the exact same problems managing dependencies (read: Ivy), two new, different flavors of inpenetrable, undocumented, symbol-heavy API, and an implementation which can only be described as an idioglossia. * Cross-building is also crazy-making. I don't have any good solutions for backwards compatibility, but each major Scala release being incompatible with the previous one biases Scala developers towards newer libraries and promotes wheel-reinventing in the general ecosystem. * Performance problems with for-comprehensions, collection library, closures.
The problem that they were obviously facing was that they didn't have any Scala programmers (they hired "one" which has prior experience). So they like started off doing big projects and the whole team needed to learn a new language. Also it seems they didn't send the team members to professional coaching and classes, but to a google group and stack overflow, then being frustrated that "the community" didn't fix their problems :-/ Doesn't sound like a very robust approach to me. Most of the bullets you have here stem from newbie problems it seems (e.g. being afraid of the collections library, not knowing how to operate sbt, and so forth). I mean, they went back to maven and ant, stopped using scala's collection library and instead java's mutable collections, went back to while loops, removed closures -- no wonder they are happy to go back to java. probably their code base in the end was literally already swallowed by javac.
Every new technology is an opportunity for Thoughtworks to sell more consulting.
I like this bit: &gt; The most vocal — and thus most visible — members of the Scala community at large seem to tend either towards the comic buffoonery of attempting to compile their Haskell using scalac or towards vigorously and enthusiastically reinventing the wheel as a way of exercising concepts they'd been struggling with or curious about. [...] at some point a best practice emerged: ignore the community entirely.
Too bad for you vagif they didn't "go back to haskell". I don't understand why people use this reddit to diss the languages they don't like, seems a strange sort of remedy to me. Why would I go and fart on reddit clojure or reddit haskell (better: cross post!!) ? We should all be happy that the world is polyglott. Get yourself a life.
I'm still using Ant because I find sbt too obtuse. :)
As someone who uses Scala professionally, he has a point, but many of Scala's problems are chicken and egg. Still, it seems my language could well have a bright future.
Nothing wrong with that. But they were new to sbt, which definitely takes a while to learn. (By the way, when I first encountered ant it was like a what-the-heck to me, and I was always happy I didn't need to learn Maven). And then the first thing they wanted to do is write plugins for it, and resurrect Maven inside sbt :-p
His critique of SBT is right on. The documentation and DSL really don't make it "simple" once you start getting into plugins.
You say "the" critique. Maybe "a" is better. It's only Yammer. Having worked in a Java shop this Spring, I must say that I never want to work in such a mind-numbing, idiot-infested culture again. A Java place is a sweatshop. Far too much time is spent trying to overcome the verbosity of it, statefulness, and the requirement of templates and idioms to get things done. Scala's business model is that talented programmers cost more than hardware, and you need to optimize *them*, not the code. So you lose a few CPU? Install more cores. Dime a dozen. But the code is clean, concise, and maintainable. You save a fortune in developer costs. And the containers will get better. And both scala.xml and scala combinators need massive rework. And modularity and version safety? Yes, they are needed. But until they arrive, let's not allow Scala's runtime to be overly burdened by the inertia of backward compatibility. It's still young. It needs to develop a clean and well-designed model. Don't let it fall into the Java hell of deprecated things never really going away. I agree that scala.collection.mutable has got to go. Scala should only have immutables with temporary in-scope builders. You want to have a threadsafe mutable container? Then *you* suck. Disclaimer: I've used Java since it was released as "Beta" with javac only available on a Solaris box. 
Are you sure you're not confusing the verbosity of Java per se with the verbosity of Java written by a typical Java programmer? I mean, if you spend the same effort hiring a Java programmer as you do hiring a Scala programmer, maybe you'll end up with much better Java than you describe. Also, Java's light-speed compilation and excellent IDE support certainly add to the productivity and eliminate a huge part of the impact of the verbosity - however Scala's IDE support has been quite good too lately, but compilation is still very slow.
I voted you up, because those are good questions. I think the answer is "no", not because the Java person with those skills is not worth hiring, but because that same person could take the initiative to learn a new language that addresses Java's faults. That's what I did. (like in my post) I've been a Java guy since Java existed ('95). Nobody paid me to learn Scala. I downloaded the PDF's, printed, and read them during lunches, and taught myself. Here's the thing: The fruit of less verbosity is less potential for buggy landmines in your code. Almost by definition, you write bullet-resistant (note that I didn't say bulletproof) code. 
As I understand it tricks with manifests are being use to provide reification. I'll pass on using it for now, seems to add complexity; for me reification is about cleaner, smaller, and safer code; so we may get those but have the complexity of another thng, manifests, to deal with.
At scale, cores are not a "dime a dozen". Power starts to become a real issue, costing serious dimes.
I agree that Scala mutable collections could use some optimizing. I benchmarked Scala's HashMaps and they were 2 times slower than Java's. And I agree binary compatibility would be nice and for-loops should be optimized.
Feedback is not dissing. Writing that took a long time, and it shows that the writer spent time making it readable and coherent. If that's dissing, I'd love it if people were dissing the product I work on more, so I can improve it. Your attitude is not helpful to anyone...
I used Scala on a project for ~1.5 years, from 2009-2011. There are features of Scala that I really like, and other ones that are equally annoying. 1. Implicit conversions/parameters are a powerful concept but incredibly prone to abuse. They make code hard to follow (where is this value coming from? Where is the method "foo" on class "Bar" defined? Oh it's not. WTF.). Maybe this will be less of an issue once debuggers and IDEs can show which implicits are in scope, but it is a headache trying to read through code with lots them in play. 2. The fetish with facilitating DSL creation serves to bring out the worst in developers. SBT is prime example of this. Entities with names like =:= are simply absurd. What the hell is that anyway? Call me square but I prefer something "foldLeft" to "/:" or "prepend" to "+:" any day. Nor do I give a shit that Haskell/ML/Foobar did it that way first. 3. The "cake pattern" sucks. Maybe I'm just dense, but I fail to see how it improves over simple delegation. And it scatters functionality all over lots of little classes. 4. The compiler is just too slow. Nor does the "use SBT" response satisfy if you have decided (rationally) to not use it in your project. 
Good. The fact that the note was put up on an anonymous gist leads me to wonder why it was done that way as opposed to a blog entry, etc. Not that this matters much. I hope that this post will get some more attention to it as well, but I'm also curious to see what the response to the original email will be. Scala is gaining critical mass now, so I'm sure that a number of the issues identified will be resolved moving forward. But it's nice to see that the email was taken out of context.
Not understanding your point 2. foldLeft exists and prepend can be accomplished with :::
As a C++ guy who is teaching myself scala (and lift), your critique is right on. Especially this: &gt; Here's the thing: The fruit of less verbosity is less potential for buggy landmines in your code. Almost by definition, you write bullet-resistant (note that I didn't say bulletproof) code. It pains me the amount of code I have to write now in C++ compared to what I would write if I were doing it in Scala.
I agree 100% with you. I'd also like to add that most "non-verbose" Java libraries need XML, annotations, reflection and/or compiler plugins. Most of the time you either have to choose that or go with a much more verbose but type safe approach.
I love this response. It addresses the points in the Yammer leaked email without directly mentioning it. Combined with Yammer's official response, I think this goes a long way to help Typesafe's reputation.
&gt; The fruit of less verbosity is less potential for buggy landmines in your code. Almost by definition, you write bullet-resistant (note that I didn't say bulletproof) code. Not always. Conciseness is not always synonymous with bullet-resistant code (much less readable one). Perl and Brainfuck come to mind. There is a point of diminishing return in conciseness, the debate is whether Scala crossed it or not. 
Brainfuck isn't concise. Perl is quite readable. A better example of 'terse + incomprehensible' would be idiomatic Haskell, which compares unfavorably with APL (which is extremely terse, and which requires a high initial investment to read - but after the initial investment, you have a well-designed vocabulary that applies intuitive operations to intuitive data.) Scala *allows* [shit like this](http://scalaz.github.com/scalaz/scalaz-2.9.1-6.0.2/doc.sxr/scalaz/example/ExampleArrow.scala.html); so, just be quick to dismiss that as "something that the Haskell weenies are doing" if you want to sell the rest of the language.
&gt; Brainfuck isn't concise. Yeah, sorry, I meant APL. I guess I had a... &lt;puts on sunglasses&gt; Brainfuck! &lt;YEAAAAAAAH&gt; 
Oh man I watched this during bed time. So awesome, it also reinforce my learning of some of the quirks of Scala inference. Totally forgot about the recursion inference gotcha. Now what was the other one.... was it the conditional if else? 
Awesome talk with good examples. Also interesting questions and answers at the end.
From the original mail: &gt; If we take even the strongest of JVM engineers and rush them into writing Scala, we increase our maintenance burden with their funky code; if we invest heavily in teaching new hires Scala they won't be writing production code for a while, increasing our time-to-market. I would love to start using Scala at work, however amongst all the other reasons (immaturity of tools support, toolchain etc.), none of which are in themselves deal breakers, this is the one thing that worries me. If I were to start using it, I know that the more talented members of my team would start writing "funky" advanced Scala idioms, trying out every new feature. Whereas those less confident might find it difficult to follow. I've had this happen before with C++ - one guy went and wrote loads of template code, his own mini-boost. The rest of us don't want to touch it. Luckily we haven't needed to yet. 
I agree that there is probably a point of diminishing returns WRT conciseness in programming languages, but Java is in no danger of reaching that point.
This needs to be fixed, yes. But not in the Java way. The Java way of dealing with evolving APIs is this: 1)never change old APIs, only add new, and 2) simply mark things as deprecated without *ever* removing them. Loadable modules are the way to deal with it. Do not prevent an API from learning by experience and evolving. Scala is still a relatively young and dynamic language. Don't stifle its creativity by accumulating the bloat and inertia of Java. 
I suspect that rhetoric like this, while justified, is one of the reasons Play was selected for Typesafe's stack instead of David's Lift framework. I love Lift, I think the design is great. But I also help design APIs for a living, and I know how much of a pain binary compatibility can become. Sun's model was originally sound, namely deprecate the code and remove it. It's easier said than done however. My suggestion for the Scala masters would be as follows: 1. Stop breaking binary compatibility between every releases. If you are going to break something, do it at a major release point, i.e. 3.0, 4.0, etc. 2. Deprecate **only** when you have a replacement, and then keep the deprecated method for 2-3 minor releases, i.e. deprecate in 2.7.x but remove in 2.9.x. Bug-fix releases (at least that's how I refer to them, namely the 3rd number in the version number) don't count. 3. Try to do better than offering a tool that checks for binary compatibility. It's a great start, but not perfect by a long shot. Stability in the core libraries is what is needed, so David's point here is sound. As for David's rant, he often goes to paint himself as one of the original people who started using Scala outside of Martin himself. That's great, and I don't mean to belittle him at all. I've used Scala for roughly a year now, so I don't claim to know nearly as much as he does. David is likely right when he says things like he's written more Scala code than anyone else in the world. Yet complaining publicly in a blog isn't going to help anything. Maybe he has spoken with the Typesafe guys about this, I honestly don't know and I don't want to hazard guess. However something about this plea just seems wrong; it seems more like whining and asking for others to back his opinion rather than trying to offer suggestions on how to fix the problem. Typesafe seems to be hiring, perhaps he may want to consider working with them on the inside to instigate change. But again given that Typesafe went with Play, I can't see that happening. As an aside, I haven't worked with Play myself, but I can understand the reasoning behind Typesafe's decision to use it. Namely if you want to get someone who's using RoR or Django for their web app (hell, even JSF) then Play is a natural stepping stone. Lift needs some forethought and a whole lot of thinking things through in a different way. Scala is enough of a challenge for those coming from these other languages and frameworks, combining that with Lift will likely lead to frustration and abandonment.
I agree with your idea of API breakage only with changes in major version numbers. In fact, that's the definition of how they should work. But I also think that those changes need to be fluid. Java has been 1.x since the time of Queen Victoria. Release often? That's the Google and Mozilla model. So yes, we need a VM code loader that can handle frequently-changing APIs. 
About what he has done about it other than blogging (it's in the blog post): &gt; What have I done about the issue? Over the years, I've raised the issue privately and it has not been addressed. I have tried to organize a project to address part of the issue, but haven't had the volunteer uptake for the project. I have had discussions with Paul Phillips about what could be done and Paul, Jevgeni and I even worked out a system that could be integrated into the Scala compiler to address the issue in 2010 when we were at the JVM Language Summit. The best answer so far is the Migration Manager, a closed source tool that may address some of the issues (I haven't tested it because I'm not going to use any non-OSS software for compiling or testing Lift to avoid any legal issues.) That migration manager is a tool by Typesafe, and Paul works for/is co-founder of Typesafe.
Kotlin's bytecode format is way more simplier and it will not have such issues :-)
Good analysis
The easy thing about non-existing software is that it has - no users who could complain - no problems with backward compatibility
Even more interesting is the starting point, a [long thread](https://groups.google.com/forum/#!topic/scala-debate/xYlUlQAnkmE/discussion) on scala-debate regarding the pros and cons of using the IO monad in Scala. Since I guess not everyone is following scala-debate, I thought it would be interesting to link it here. Also note that there is [part 2](http://etorreborre.blogspot.com/2011/12/pragmatic-io-part-2.html) to the blog.
Thanks for your thoughts. 1. 2.8, which is often cited as the release “which broke everything” was intended to be called 3.0. But people wrote books about “2.8” and it was seen as more damaging to change the official name to 3.0. I still think the decision was wrong. 2. Exactly this is being done. Some stuff deprecated in 2.2 still existed in 2.8. And often @bridge methods and other stuff is used to keep compatibility for much longer than the typical “deprecate — don't touch — remove” cycle. 3. I agree with that. In my opinion, major releases are those called 2.x. The naming might be unfortunate, but I'm not sure there will ever be a 3.0 in the future. I agree that the whining is not constructive. Compare that with the constructive criticism from Yammer. They spelled out 5 points and except `private[this]` (which is a feature) they will be fixed.
It seems to me that there isn't much point in using an IO monad in a language other than Haskell for the following reason: in Haskell there is a huge amount of infrastructure built around monads in general and the IO monad in particular, including a special form of notation ("do") for making it easier to work within monads. If you don't already have all of this infrastructure available to you, then monads seem like they would be more trouble than they are worth. So it really isn't at all surprising to me that people in ML and Scala are not that impressed with the IO monad; there simply isn't the same level of infrastructure built up around monads to make using them pleasant, so why bother going to the extra trouble?
notice the verbal tense: "will not" as opposed to "does not".
That's indeed a point that's often misunderstood. For Scala the first digit in a version means a major, backwards incompatible _language_ change. We hopefully don't do that very often ;-). So it's the second digit which represents a major release. A good comparison is with Python. Python 3 is incompatible in significant ways from the Python 2 series. You have to rewrite your code to port it to Python 3. Scala's version numbering scheme is the same as Python's. 
and ... [part 3](http://etorreborre.blogspot.com/2011/12/pragmatic-io-part-3.html) ----------- related: http://www.casualmiracles.com/2011/11/22/a-little-scalaz-magic/ http://hseeberger.wordpress.com/2011/01/31/applicatives-are-generalized-functors/
Well? How did it go?
Can you give statistics for other languages for comparison, please?
Check out the [thread](http://www.reddit.com/r/geek/comments/n8pnz/my_friend_made_a_tool_to_test_how_nsfw_a_phrase/c3756d1) linked by op.
see the thread link.
Lisp is more pornographic.
good find. doh!
Re 1, I believe IDEA's Scala mode shows implicits.
A friend of mine is developing a game called ScaWar which is due to hit the market any time now. It is done in 100% scala + maven. EDIT: You can follow their progress [here](http://scalandroid.blogspot.com)
What is wrong with scalaz?
Scala is not for everyone and every project, and that's OK. Even better when my competitors decide not to adopt it. :)
I've done it. Here's a [tutorial](http://www.tylerlesmann.com/2009/dec/04/integrating-scala-android-ant/) I wrote two years ago about integrating scala compilation into android ant rules. So it definitely does work and I've even used it to build a language learning application for my personal use. The big thing is that scala is big. You'll need to use Proguard to shake off anything you aren't using or even the smallest example, like the one in this tutorial, will not install and run. I suggest researching sbt. I think there are plugins and whatnot now that will make android development much less of a headache than it was for me.
I will try it. Thanks!
Using a marginal language is a two-edge sword. Maybe you're being more productive with it than your competitor, but they will be able to out hire you very quickly while your language of choice will become your growth bottleneck. 
I wrote [Ballero](https://market.android.com/details?id=com.cldellow.ballero) in Scala. The code is [available on Github](https://github.com/cldellow/Ballero) and compiles under sbt 0.10.1. A fresh checkout may not build until you hack in some dummy constants for private keys for APIs. It's a niche ecosystem. I'd use SBT, not maven/ant for building. This goes against the grain of Android development, but will fit more nicely with Scala development. Use jberkel's excellent [android-plugin](https://github.com/jberkel/android-plugin) to support ProGuard, signing, etc in sbt. There is a [Google group](https://groups.google.com/forum/#!forum/scala-on-android) for general Scala on Android discussion. Once you have Hello, World working, hack your emulator to have the [Scala jars preloaded](http://lamp.epfl.ch/~michelou/android/emulator-android-sdk.html). You can then omit them from the ProGuard step, which speeds up your compile/test iterations. Good luck!
riiiight... "in scala"... got it... (or were you actually referring to the comments?!)
Lots of good links, but after a day I still have the same question: does no one know of a scala app already in the market? But your links are invaluable. I can't fully appreciate them as a noob, but I promise that (hopefully) in the next month or so, these links will make much more sense.
Upvoting because the comments actually have the correct solution. Just because you can port java directly to scala doesn't mean you should.
Kim's got it: 1 to 1000 filter { x =&gt; x % 3 == 0 || x % 5 == 0 } sum 
Colin's demonstrates the use of functions and anonymous. Kim's uses the most "features" of scala.
Thank you all for your feedback. I greatly appreciate it. However, the urge to criticize overcame the urge for constructive criticism. I don't remember stating this is the "correct solution", best solution, or it uses best practices. I do remember stating this is a solution. One that will evolve overtime. I have an idea, next time figure out a constructive way to provide advice. More people learn that way. You may have a great understanding of the language, but can you show others how to use the language? Troll like behavior doesn't work in the real world. Try to use your real world manners online.
What about using a view: (1 to 1000).view.filter{ x =&gt; x % 3 == 0 || x % 5 == 0 }.sum That way the sequence is only traversed once.
HOW IS THIS FUCKING RELEVANTT
That is actually a nice one liner. I found issues when you use a number larger than 1000. See below for details. (1 until 100000).view.filter{ x =&gt; x % 3 == 0 || x % 5 == 0 }.sum There is an overflow problem because and int instead of a long is being used. I have another revision that I am posted to revision to deal with this.
1 until 1000 instead of 1 to 1000. You are adding an additional 1000 to the sum that way.
You can use (1L until 100000L) to create a sequence of Longs. Then the sum will also be a Long.
Not sure if view will work, since view is used to combine functions which transform the list, e.g. Any =&gt; Any. Sum I believe has the form (Any,Any) =&gt; Any.
You were criticized because you posted a solution in a language that you did not take the time to understand. It's akin to solving the problem in C, and then posting nearly the same solution in C++ (int main changed to void main). If your blog post was something along the lines of, "here's my imperative solution, but since scala is a functional language, there should be a better way", it would show that you had taken the time to understand the pros and cons of the language, and were interested in more about the language, rather than just hacking something together. Your "solution" is now on the internet, and will be found in searches. People will read it, and wonder, "why would I do this in scala instead of java". A solution that properly utilizes Scala will push you out of your comfort zone into functional programming, and will demonstrate to others reading, what Scala brings to the table.
Thanks for stealing my thunder, but yes, that would work.:)
It works. I tried it in the REPL. The view methods in the collections api are used to proxy a collection and can be used to lazily apply collection operations (filter, map,...) [Scala 2.8 Collections](http://www.scala-lang.org/docu/files/collections-api/collections_42.html)
Nice. Since sum is probably implemented with foldLeft, it does make sense that it would work, since foldLeft works on list rather than pair.
I am glad you understand my intent and the amount of time I took to research. You are entitled to your opinion, and I will leave it at that.
It's technically in Scala.
Hmm, maybe your definition of app is different than mine. Is my app (Ballero) not "a scala app already in the market"?
Oh! ... please hold ... brb.. I found it in the market. I misunderstood somehow. But when I did a search for Boca Raton, FL, it didn't come back with a place I know down the street. Michael's Arts &amp; Crafts‎ 3701 W Hillsboro Blvd, Ste B Deerfield Beach, FL 33442 Deerfield Hills Plaza‎ (954) 571-7627 michaels.com Cool app, though! This is exactly the kind of application that I want to write. Simple, but to the point. Thank you for sharing. Can't wait to check out your code. Thanks again.
Yeah, the database only includes "real" yarn stores. I'll avoid the flamewar about what constitutes a real yarn store, as I'm not myself a knitter. :)
Poor documentation. For example, about 70% of stuff has no scaladocs, and most of the remaining has short, non-explanatory scaladocs.
How is that different from scala's standard library?
Touché.
To the other commenters in this thread: there was a time when you didn't know Scala inside and out. For me, civility and gentle correction is much more valuable than downvotes and OP-bashing. epearson's first attempt was an atrocious solution for Scala. But you know what? I didn't even share my Scala Project Euler solutions with anyone, because they were garbage. I missed out on an opportunity to learn; epearson didn't.
They're not mine, I'm just one of that guy's subscribers. I thought that these are better than the recent purely imperative solution to only one problem.
Yep, watched through the first solution, and it was really well done. Commented on a few things I saw in the first video and some in the second, but he had nearly addressed all of them by the third video.
This is awesome. 
I've used scala on a large commercial Android application (alas - can not name). It works well. We used sbt and the android sbt plugin. But for recreational programming I recommend you try "Treeshaker" it is an eclipse plug-in and it is the bomb. 
I don't think is that straightforward... learning the particular tooling and codebase takes time even with popular language X, and I claim learning a particular Scala codebase can be easier than in X at leas just because of the expressivenes there's less code to understand. So, if you take into account the productivity gains, it may be possible that your competitor can barely catch up even outhiring you. Not saying that is always like that, but you can make a case, specially when you're not doing trivial things in a non-trivial domain.
Thank you very much. I will look into it. I was having all kinds of problems with Eclipse and moved over to IntelliJ (Jetbrains), but I am certain to need to use Eclipse again. 
It would probably help the backwards compatibility if the JVM got traits.
Probably not, [due to many reasons](http://www.scala-lang.org/node/9346).
It's hard to use the latest and greatest with Scala. Scala libraries depends on the version of Scala they are compiled with, so you might be held back to a previous version. Scala-IDE is only compatible with Eclipse 3.6 Helios (we will soon see a 4.2 release of Juno). At some point the trade-off becomes too great and you'll just have to dump Scala and go with pure Java.
I wrote help, not fix.
*Brace yourself, the Project Euler solutions are coming*
Man, I'm not sure if a solution to Project Euler Problem 2 really deserves being posted on Reddit.
From the slides: Scala 2.10 1. new reflection framework 2. reification 3. type dynamic 4. more ide improvements: find references, debugger, worksheet 5. faster builds 6. SIPs: string interpolation, simpler implicits ETA: Early 2012
Thanks for commenting. Do you have useful feedback? The idea that I shouldn't post solutions isn't very useful.
Excellent!
I've been using Scala with Eclipse and have been getting pretty happy with it. The new site is a beautiful refresh over the old one. Great work guys!
I am raging a little bit, because the 5 people that voted to close the question have absolutely no contribution to the Scala tag. I guess I'm hoping a few more people see value in this question (if only to make it more googlable) and vote to reopen. Anyways, apparently the Italian pronunciation is the correct way to say it: SKAH-lah, and the redneck-American pronunciation "SKAY-luh" is incorrect. "SKAY-lay" is, of course, also incorrect, although if the language's name were solely derived from the term "SCAlable LAnguage", then perhaps that's how we would say it.
SBT is just too much. Every time I write an SBT build configuration a little piece of me dies. I've been thinking about looking into the Gradle scala plugin. 
I'm sorry but the question is really off-topic. It's not a question related to programming. There's a better stack exchange for that... (DISCLAIMER: I have contributed to the Scala tag).
Just watch Martin Oderski at devoxx (the video is online) and you will know. 
which one? Programmers StackExchange? I wouldn't mind if the question was moved to a more appropriate location, but just a plain close vote is irritating.
I think *programmers* is more appropriate. SO is really about programming itself (see the faq). I understand your irritation, you should delete your question and repost it on *programmers*.
&gt; "SKAY-lay" is, of course, also incorrect, although if the language's name were solely derived from the term "SCAlable LAnguage" I pronounce the "LA" in "LAnguage" like "lah" more than "lay". "lahnguage" vs "lainguage".
I usually scream "WHAT THE HELL IS THIS"
This is great, the background noise is very distracting though.
This is very odd code. I'm fairly new to Scala myself, but are you really jumping in to template meta-programming on your first day? What's the intention of the program?
Thanks. It might look a bit odd, I'm able to code Java, so i wanted to start with the Scala specific stuff, and this functional approach was a way of learning how it works. (To be clear it's not my first day of coding, it's my first day of Scala, the coding part I do already 28 years) The program has two intends, first to print 3 and 2 (it does the 3 part already) and second to learn me what and how Scala works.
Without spending considerable time investigating, the first non-scala thing I see is repeated returns of null when expecting a return object of a Mul or Add. I'd have to see what effect that is having, but I doubt it's having the effect you intend. Also, Scala Option is preferred to null.
I don't fully understand what you mean. At first I made Add work, it could easily live with the null returning and still do recursion. So I didn't pay a lot of attention what it means, I'll try to look it up with google, most probably I'll learn something and hopefully I get the program to work :)
True, but you're possibly coming at things from the wrong angle. Monads have more to do with sequencing than with state management. That they can be used to manage state within a system composed of otherwise immutable data is a happy accident. (There's an interesting, if somewhat basic, discussion about this [here](http://labs.scrive.com/2011/12/why-monads/).) My biggest problem with monads is that relatively few problems that I run across in my programming life require strict sequencing for their solution. And when I do run across one that does -- e.g., selecting three items at random from a set without resampling -- there's a good chance that someone else has already rolled a better monad than I could have done. All of this pertains much more to Haskell than to Scala. The entire Scalaz library strikes me as a solution in search of a problem. But that's possibly due to my relative inexperience with Scala. 
I remember that article, as I remember the discussion that took place upon it on [/r/haskell](http://www.reddit.com/r/haskell/comments/ntox2/why_monads_what_i_learned_about_monads_working_in/). I think everybody has a different view on them based on their prior knowledge. For me so far they still are a way of boxing computation (think Maybe), but further down the road sequencing may be the way I will more closely see them. 
(when asking about error messages, performance, refactorings) It's customary to list: 1. scala version, how you installed it (Typesafe or scala-lang.org installers, linux package manager), JDK release (shouldn't matter, except 7 not yet supported, and once in *very great* while somebody hits an issue with openJDK and font rendering or a graphics library (these issues have nothing to do with scala, you'd hit them from java code or clojure or jruby too) 2. OS (Windows benchmarks are pretty different) 3. the error messages/exception
You probably need more printlns. It only prints for add0.
I have a compile error in the code listed above, the exact error is: Multiple markers at this line - could not find implicit value for parameter m: Numbers.Mul[Numbers.Succ[Numbers.Succ[Numbers._0]],Numbers.Succ[Numbers._0]] - not enough arguments for method mul: (implicit m: Numbers.Mul[Numbers.Succ[Numbers.Succ[Numbers._0]],Numbers.Succ[Numbers._0]])Null. Unspecified value parameter m. That is with the two slashes on the second line in main removed, as listed the code runs fine for me. I don't understand why It claims Mul[Nat, Nat] is not declared, but Add[Nat,Nat] does just work... Don't think it should matter, I'm using Scala 2.9.1 from Eclipse Indigo and have the same issues on a Mac and windows PC.
add0 is my stop condition printing the result :) Like this: Numbers$Succ[Numbers$Succ[Numbers$Succ[Numbers$_0]]] Tata, 2 + 1 equals 3 (for a difficult way of writing 1, 2 and 3, but without using arithmetic :) )
Wow, Tony Morris comes off much more reasonable when speaking. I added him to my killfile a ways back, and it made reading the Scala mailing lists *a lot* less stressful.
That it is a different word as OO :) You are right, it's called "Logically" I believe? Like prolog does, that's the one I'm trying to name.
Thanks a lot. I understand the remarks and now I'm trying to make the classes of the proper types for this construction to work. A patch is meanwhile posted as edit 2. Real solutions seem to become quick more complex as hoped for, still searching... It was already the forth of today, and indeed after some serious stuff I felt like playing :) I was trying to push the language I guess, it's quite flexible I must say.
Interesting, you went straight to type level programming :) Turns out type multiplication is not very easy, take a look at this : http://michid.wordpress.com/2008/07/30/meta-programming-with-scala-part-ii-multiplication/ You might want to look into http://stackoverflow.com/questions/4415511/scala-type-programming-resources
I asked around about your code fragment, and got the suggestion that it was something one might see on [Apocalisp](http://apocalisp.wordpress.com/2010/06/16/type-level-programming-in-scala-part-4a-peano-number-basics/).
Oh god, it's not just me then. I didn't even click the link because I saw "Tony Morris" in the title: I just wandered straight into the comment section to see if redditors had distilled something useful from him. Simply reading his blog (which shows up unfortunately often when googling for Scala-related things) is painful. The mailing list posts are even worse.
So, is the 0.3 version "officially" released? (I don't see any activity on the github page).
Cry me a river.
Pedantic: reified generics cannot be done on the JVM without extra effort and the loss of Java integration.
Yes, they can. 
&gt; Oh god, it's not just me then. Not at all. Every once in a while, when Tony Morris would engage in a particularly toxic flamewar on the Scala lists, I'd email the other participants off list to gently suggest adding TM to their killfile, and share my positive experience after doing so. There are plenty of people who find him very unpleasant. TM's mailing list persona is easily avoided, but it's still unfortunate for Scala. New users getting chewed out on mailing lists leaves people with a bad impression of the Scala community. As someone who likes Scala and wants more opportunities to use it professionally, this is a drag.
I'm new to Lift, but I have to admit that I was surprised that after all the work that must have gone into Lift 2.4, nobody cared enough to put a blurb up on the site, but just buried it on a remote blog
Neat, I have a project in progress using lift 2.3 right now. 
Ohhhhhhh snap! I can't wait for them there reified generics!
For those who like me hate logging into Google Groups just to read a single post, all the information in the post about the release can also be found at the following link: http://www.scala-lang.org/node/12250
dpp has been working for free for the Scala community for years, this is a pretty douche way of thanking him. 
Where is Complex??? 
I didn't think so. People, don't download it.
It's worth sharing this again. I'm firmly one of the 'pragmatic ducks' that David talks about, it will be interesting if people like me will make the shift.
Um - what is the critical challenge facing the Scala community? I can't find it on the linked page.
See the video on the top right.
See the talk in the link, Dave Pollack outlays where Scala needs to go next in order to bridge the adoption chasm
Since this is 27 minutes video, is this (from Dec 2011) a good TL;DR ? http://lift.la/scalas-version-fragility-make-the-enterprise
&gt; if you think his quote verbatim makes him look any better it certainly doesn't Well, I'd like to be be my own judge of that -- which is why the actual quote and context are important.
What is with the bizarre google groups fetish in the scala world? It is painful and stupid trying to find answers or as questions. Why does everyone use a shitty web version of mailing lists instead of just mailing lists?
The lift community is an absolute cesspool, I have never witnessed such an arrogant and user-hating group of people before. No wonder play got picked as the standard scala framework even though it isn't very good, at least the play devs want people to use their software.
&gt;It's actually really good now My assessment was based on the current state of the community, not how it used to be. I think it has actually gotten worse, not better. There is a reason lift is shunned by the greater scala community.
Oh great. So we have deliberately crippled function application in order to allow for creating DSLs using the stupid method call syntax: obj method arg This was done specifically so scala didn't need macros. Now we're getting macros anyways as MO realized that yes, it really is needed. But now we're still stuck with a crippled function application syntax that doesn't support currying, so you have to Function.curried all over the place. A relatively new language like scala should not be this ugly, especially when much older languages like ocaml that inherited lots of old cruft manage to be much more elegant and concise.
http://www.assembla.com/wiki/show/liftweb Also, if you have a bug with record, posting example code verifies the bug, then they can open a ticket for it. Do you have a link to your original question about it?
Sigh. http://groups.google.com/group/liftweb/browse_thread/thread/5854f2dd08f1c9ae/22f6300b03a5cb83?lnk=gst&amp;q=record+status#22f6300b03a5cb83 http://groups.google.com/group/liftweb/browse_thread/thread/dbf217e750e84d11/43fb3767776fc05d?lnk=gst&amp;q=record+status#43fb3767776fc05d
I don't see why this is "better" than the OP's post. Could you explain the difference please? If you want to express Sub &lt;: Num's increment as returning its own type, you could say "def increment: this.type", could you not?
Did you by chance notice the dates on those posts? A year and a half ago it was experimental but "totally the future and everyone is so switching to it for real". And all this time later, it is still "experimental" to the point where it is unusable, completely undocumented, virtually unmentioned even in the brand new book that was just written. The only difference is that nobody will admit it now. They also won't say it is production ready either of course, they just won't answer at all. The whole point is "it was experimental but almost ready a year ago" says nothing about the current state of it.
As the second post mentions, MongoRecord shows how to use Record. And MongoRecord has been used in production.
&gt; Neither of things things are themselves a problem, the problem is the deliberate refusal to be upfront about it. Nobody will say "record is production ready" because they know it is bullshit. It still comes back to, MongoRecord is based on record, and MongoRecord is used in production. Therefore, if you have problems with Record, it would be best to post example code showing what is wrong with Record, so the bugs can be fixed, rather than saying "it is very much unfinished, full of bugs, and is not ready to be used". This isn't a breakdown of the community, this is you feeling that there are issues, and not sharing those perceived issues with the community. So it's hard for people to answer the question in the manner you want, when MongoRecord extends Record and is used in production.
See the original code. The num trait defines its derived type, via "type Repr &lt;: Num". The derived class IntNum, then specified that derived type with "type Repr = IntNum". As it is, you're defining increment to return an IntNum, while the Num trait defines it to return Num. [edit]Just realized you're responding to hellochar
&gt;It's a generic trait. That's how it's meant to be used. Your ability to repeat what I said is impressive. Your choice to exercise that ability is bewildering. &gt;Right. It's a generic trait. That means that unless you're implementing a database connection other than what is implemented, you don't need to use Record. Impressive mental gymnastics. Obviously using squeryl-record or mongo-record is using record. The fact that you are deliberately trying to argue semantics demonstrates very clearly what I am talking about. Go back to the google group, your bullshit is not welcome here. &gt;What exactly are you trying to do that you feel that Record is broken? Considering it's a trait, it doesn't exactly have a lot of room to break. Why do you think traits have magical immunity from being broken? You do realize traits can contain code right? It isn't an interface. Even the most trivial shit doesn't work, like toForm.
I've tried to remain polite, but this is ridiculous. Are you mentally handicapped? I am not looking for help, I don't have a problem. I explained this very clearly for you because you were confused. Yet you remain confused. Is this deliberate? I do not need help, I simply explained that no, the lift community has in no way improved, and my assessment of it as a cesspool is not based on past experiences, but the current community. And *I* don't understand scala? That is pretty amusing coming from someone in the camp of people who are outcasts because they make scala look so bad. Please, be specific. In what way am I ignorant of scala's workings?
&gt; And I don't understand scala? That is pretty amusing coming from someone in the camp of people who are outcasts because they make scala look so bad. Please, be specific. In what way am I ignorant of scala's workings? You claimed a trait was broken that has almost no code of its own, that references MetaRecord, which is also a trait, largely dependent on setting a template variable by whoever derives from the trait. So either you can't read Scala, or you didn't bother to actually look at Record/MetaRecord. You claim the community is a cesspool because no one answers your questions, but you can't even provide a concrete example to defend your claims. As far as I can tell, you've never even asked the question, you so vehemently claim is the reason you think the community is a cesspool.
&gt;You claimed a trait was broken that has almost no code of its own No, I claimed record was broken. The persistance framework. Not Record.scala. I explained this twice. Given that you can only use record through one of the classes implementing it, you would need to be either retarded or deliberately trying to be dishonest to respond as though I meant someone is trying to instantiate a record object. When it is explained to you anyways as if you were retarded, and you still persist in acting like some absurd scenario is being discussed when it clearly isn't, you are obviously not trying to participate in a good faith conversation. Deliberately pretending to be incapable of understanding clear explanations does not make the basis of a compelling argument. &gt;You claim the community is a cesspool because no one answers your questions No I do not, and I have explained that several times as well. How is it possible to be so obnoxiously self-absorbed that you refuse to actually comprehend the words I write because it would interfere with your ability to act like a moron? I do not have any questions. I do not have any questions. I do not have any questions. Seriously, none. I was one of the people answering questions. I was one of the people trying to make the community work, and getting chased away by assholes who insist that berating users is better than helping them. If you can't manage to respond to what I say, then there is no need to respond at all. Go make a second account and argue with yourself. It is easy, and you look like less of an idiot since that way other people see the posts you are replying to, instead of them seeing totally different posts and you replying to imaginary ones.
&gt; No, I claimed record was broken. The persistance framework. Not Record.scala. Record isn't the persistence framework. The record trait attempts to genericize some of the attributes of the individual persistence frameworks, but at the end of the day, the persistence framework is Mongo, Squeryl, Couch, etc. So do you have a problem with one of those? Or do you wish that somehow Record worked as a general persistence solution across all persistence mechanisms? Record is ready for production, since it's used by Mongo, which is used in production. Does that mean it is perfect, will never need to be refactored, and accomplishes everything under the sun? No. No such code exists. &gt; Seriously, none. I was one of the people answering questions. I was one of the people trying to make the community work, and getting chased away by assholes who insist that berating users is better than helping them. So if no one was answering questions about whether Record was production ready, and you're one of the people answering questions, then who is to blame?
Well that suck, he contributed so much to Scala. I hope him the best with Haskell and hopefully he's wrong about the Scala community.
Does this have anything to do with Play being picked over Lift as the official Typesafe web application stack?
Really great article, but: &gt; Both are clearly multi-paradigm, it’s just that on an FP to OOP scale of 0 – 9, F# feels more like a 4, and Scala feels more like a 6. Am I the only one who thinks that OOP and FP don't exclude each other?
Well, that's not really what he's claiming though; he just says scala feels more OO-y than F#.
Excellent and thoughtful writeup.
The only reason I see in this behavior is wasting everybody's time, breaking a lot of things during migration and pissing off _everybody_. Forcing tons of people — of which 90% never heard of him and 99,999% never did anything to him — to rewrite their documentation, POMs, configuration and rename packages, IDs, artifacts, etc. because of nothing but ego ... great move! I hope he stays away from Scala, I certainly don't want him to be near any responsibility as long as he hasn't proven to behave like an adult.
Well in fairness, * There was a Scala plugin to Play that was receiving a bunch of attention even in Play 1.2.4 * Play's homage / similarity to Rails goes a long way to pulling in Rails developers. If you've seen Rails, you know 90% of the concepts behind Play. * Play 2.0 stays very clear of impenetrable method definitions (what Coda Hale calls ideoglossia) and uses standard Scala out of the box * Play is backed by a company in France, much closer to EPFL * Lift 2.0 uses the Scala XML extensions heavily, to the point where I think there were serious problems trying to render a page as anything other than XHTML (and Scala's XML API was notably described as "weak" and "something to stay away from") * Lift uses explicitly stateful sessions, something that Play avoids Apparently cloud services don't like stateful sessions either because it doesn't let them redirect the service internally. So I understand Typesafe using Play over Lift, even if it seems to have caused a rift.
He deserves a little more respect than a simple write-off. I don't agree with his handling of scala-tools either (or that it's worth blogging about), but the man has obviously been going through a rough patch. I think he's been a good influence on Scala these recent years, and he may very well return, so I wish he would be given some consideration.
I understand where you're coming from, and I'm not writing him off in perpetuity. However, this is far from the first thing he's done that's been more harmful than helpful to the scala community. Furthermore, his desire to garner as much attention as possible about these issues is the part that's most disappointing to me.
They don't exclude each other in a language, but compromises need to be made to allow them to co-exist, and generally those compromises favor either OOP or FP. Scala certainly falls more on the OOP side, everything is an object, there's no such thing as an operator, just methods, etc. A result of that is that FP gets shoved aside a bit, like how functions aren't curried by default, how GADTs are a OO style cludge, etc. F# being largely ocaml on .net does fall more on the side of being a FP language with OO tacked on, rather than an OO language with FP tacked on like scala.
One of whom is david.
He isn't leaving scala, he is just using haskell for his current project because there's no scala for iphones.
Unfortunately, he'll probably be back. The haskell community is already too big and too established for someone of his level to get any attention, and that's the most important thing to him. If we're lucky scala will be too big for his nonsense by the time he decides to come back, and the poor ocaml folks will get stuck with him. I think dpp is going to be another harrop, wandering around trolling functional languages for attention.
My general impression is that the “tacked on” feeling is a bit stronger in OCaml, though.
I honestly don't understand why so many people in this thread attack David this way. In my case, I got good timely replies from him both in the list and in stackoverflow. So did other people. He isn't a warm, fuzzy kind of guy but he is polite when you address him in a polite way. And he goes straight to the point in, either giving you the answer you need or in telling you where to get it. If you're giving a suggestion about how thing should be done he will reply to you the same way. There are times when he will assert himself on a thread but that's usually after you break the quite reasonable [community rules](http://liftweb.net/community).
Maybe this helps: http://stackoverflow.com/questions/69192/how-to-implement-a-queue-using-two-stacks
Haskell community has a very good repellent for the likes of Pollack: Avoid success at all costs :) And i hope we stay this way. 
Great, just what Scala needs, more features. Esp compile-time code transformations to render your already impenetrable code utterly indecipherable.
Does it mean I can finally roll out my optimized version of `for` loop for integer ranges, that does not rely on creating unnecessary objects (like Ranges or =&gt;Units), without resorting to creating `while` loops and manually incrementing the counter? I'm in.
The use case for Type Providers shows an example written in F# and the one for Integrated Queries comes from LINQ. So let me get this straight: Scala, widely considered a complex language to the point of being to Java what C++ is to C, is gaining additional functionalities coming from Lisp, F# and C# combined... Seriously? This is pure craziness, don't the authors of the language understand that each additional functionality adds not just one level of complexity but n levels of complexity, where n is the number of features already present in the language? If anything, Scala needs less functionalities, not more. 
Umm, do you happen to have links to the debunkings too?
Ahh "zak_david", the language expert again, who has so much experience in language design that he can easily tell Odersky et. al. what they are doing wrong. Ah wait ... not really. Just some self-obsessed, self-proclaimed "expert" who has not invested 5 minutes to actually understand what he is talking about. I was very critical of macros in the beginning, but after actually doing my research and seeing that people in charge are well aware of potential issues, I'm confident that they will deliver the right thing.
For loops are already optimized, but yes!
Scala macros isn't something user-facing. It will be used as a foundation for stuff like type providers and database access, e. g. to make usually horribly verbose stuff easier and more readable, as well as providing more information at compile time. E.g. telling the user that `"Foo".toInt` *will* fail _at compile time_. Looking at the implementation, it is really a very restricted approach, e. g. no syntax changes, no literal copying, etc. Basically all the bad stuff of macros is left out, while being more general and versatile than C#, where they did something similar in a very ad-hoc way.
I'm not an expert on compiler plugins, but thinking about it, I wonder if it's not that the compiler plug-in infrastructure should be improved by allowing plugins to introduce new keywords. I think currently you are forced to work with annotations (cf. continuations, autoproxy). If a plugin could introduce new keywords, and there was some sort of integration into IDEs, then Scala-Macros could just be a compiler plugin, an additional functionality that you can switch on and off for certain projects. I recently read about EScala ( http://www.stg.tu-darmstadt.de/research/escala/index.en.jsp ). Apparently they also had to fork Scala to add their new keywords (`event` and `imperative`). That's rather sad, and it would be so much better if it could be just realised as a compiler plugin.
Or, what can you trade away in exchange for macros?
Yes. With macros you could basically connect to a random database (or WSDL service or ODATA service) in a fully statically typed way, without any boilderplate, code-generation or annotation orgy. Basically `val db = DB.connectTo(db"hostUserNamePassword")` where `db""` would be the String interpolation feature which would hook into the macro system. Then use `db` just like a fully typed model of the database.
Some of the stuff from Scala virtualized was already merged, as far as I know. There is some overlap with other features, so people make sure that the right choice is made.
Oh c'mon, it gets boring that you keep repeating the same old, sad myths used to bash the language. I won't even bother debunking them, but if you think that IDE support and Maven integration (which is the main focus currently) is an academic research project, I can't help you. Additionally, one of the main reasons for the introduction of macros is better tools for working with databases, something which never really worked in Java. If you ever worked with databases in Java you probably already know how horrifying the experience is. There are dozens of languages for the JVM which are “statically typed, support type inference, a nicer syntax for closures [...] and a few additional features [...] such as native support for properties.” You know what? Nobody of the “JVM community” gives a damn about them. If this is what the “JVM community” needs, then why is Scala pretty much the most successful language with these requirements? The “JVM community” lives in a bubble of self-absoprtion and pretty much everyone outside is amused about this level of backwardness. Especially the C#/F# people are probably laughing off there asses, because either they are just magnitudes more intelligent than Java developers or the myth that Java developers can't handle a modern, powerful language is just not true.
&gt; Call me when they have the worst bugs fixed by 2020. You must be confusing it with something else, Kotlin hasn't been released yet. 
I don't know how your response is even related to what I said, but here you go: http://kotlin-demo.jetbrains.com/
Well, it's a demo, there is no public release yet, so talking of bugs makes little sense. Would it make sense to you to say that the Scala macro implementation has a lot of bugs? Well, of course it has bugs, it hasn't been released either. And even when it gets released, it will have bugs. Are you a developer? Just wondering, because you seem to not be quite clear on what the various stages of software releases are. 
&gt; I'll carry on the discussion with other people ... I haven't seen any discussion coming from you so I would be surprised If you solved your own problem by choosing different people to talk to. &gt; ... who are more open minded and intellectually curious about what's out there. Why should they bother talking to you, considering that you seem to have the habit of not spending even one second to actually verify your claims? Won't you be wasting their time, like you wasted mine?
Mine is already using 2.4. I did a search and replace and everything **Just worked**^TM
Despite all the negative comments about D.P., everyone seems to be in the same boat for a smooth transition: http://goodstuff.im/the-transition-of-scala-toolsorg Also, scala-lang.org ( http://www.scala-lang.org/node/12437 ) is not a company blog, so it wouldn't have done any harm, to add at least one line of thanks to scala-tools.org -- and also, saying that "all Scala projects required a little bit of extra configuration to point to a custom repository" is not right. scala-tools.org has always been known to sbt, so for the majority of projects there was in fact no extra configuration required at all. Why not stick to the facts?
Isabelle/HOL also has a code generator for Scala. See [this paper](http://isabelle.in.tum.de/dist/Isabelle2011-1/doc/codegen.pdf) for details (it doesn't mention Scala, but it is a possible target besides SML, Haskell and OCaml).
However, one of the nice things about Coq as compared to Isabelle/HOL is it lets you express data structure invariants and write programs that use dependent types (using the Program commands, and the experimental Equations extension). And not the mere dependent method types that Scala gives you, either. [Full-blown dependent types](http://reddit.com/r/dependent_types).
I'm SO glad this kid won't get into the workforce for next 10 years. Because he makes a helluva competition for the rest of us.
He's just repeating code he already wrote and probably took him more than 7 minutes. But it's still impressive, he's a good teacher!
This kid is gonna bank.
Check his "Game of Life" presentation out too: https://www.youtube.com/watch?v=6RwrT6N43lY Amazing!
I was wondering too but I think the answer is that scala virtualized is limited to expressions (and thus does not encompass things like class declarations).
The example he starts with: You could also do that by catching a NullPointerException and returning null. Is that bad style? Of course, some other NullPointerExceptions might get hidden by that catch. EDIT: I see that he starts talking about exceptions in example 2. As a student, what we usually do in our projects is not allow Bar and Baz to get into this state of containing something of type null. We usually just don't allow something like that to exist, because it often doesn't make sense. EDIT: I feel like I learned something *really neat* with this video. Thanks for posting.
You forgot to mention that was for Java SE 6. A version several years old. But way to ham up the drama in the title. Hope you get tons of sweet sweet karma from people overreacting over basic everyday business.
It's cool.
They made Range.sum O(1), from O(n). Math - it works, bitches!
http://groups.google.com/group/scala-debate/browse_frm/thread/cf33d47984e59e92/ Why virtualized and macro's? See M Odersky's posts startg #28
:-)
That's what's up!
Upvote for the ScalaCL library. Definitely looking forward to trying that out later.
Things I have learned from this post:
&gt; The functional style is short, readable and safe. It is only 3x slower than the procedural style. *Only* three times slower, ugh. I wish we didn't have to choose between functional purity and performance that much.
That third point is really fairly critical. In this case, the operations are so cheap that these take only a small portion of the overall time. The costs of functional style would likely become almost insignificant if the task being performed was more intensive, at which point you'll be glad to have proper functional style to maintain! Out of interest though, does anyone have links to benchmarks that seem to support this?
Could probably do with a bit more detail to see how worthwhile this might be?
I'm not sure how to run properly such benchmark, I will try to think about it. What kind of task do you have in mind ?
Not working for me... com/ideacolorschemes/ideacolor/ui/IdeaColorSettingsPanel : Unsupported major.minor version 51.0: com/ideacolorschemes/ideacolor/ui/IdeaColorSettingsPanel : Unsupported major.minor version 51.0 java.lang.UnsupportedClassVersionError: com/ideacolorschemes/ideacolor/ui/IdeaColorSettingsPanel : Unsupported major.minor version 51.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClassCond(ClassLoader.java:631) at java.lang.ClassLoader.defineClass(ClassLoader.java:615) at java.lang.ClassLoader.defineClass(ClassLoader.java:465) at com.intellij.util.lang.UrlClassLoader._defineClass(UrlClassLoader.java:124) at com.intellij.util.lang.UrlClassLoader.defineClass(UrlClassLoader.java:120) at com.intellij.util.lang.UrlClassLoader._findClass(UrlClassLoader.java:96) at com.intellij.ide.plugins.cl.PluginClassLoader.d(PluginClassLoader.java:102) at com.intellij.ide.plugins.cl.PluginClassLoader.loadClass(PluginClassLoader.java:63) at java.lang.ClassLoader.loadClass(ClassLoader.java:247) at com.ideacolorschemes.ideacolor.ui.IdeaColorSettingsConfigurable.createComponent(IdeaColorSettingsConfigurable.scala:44) at com.intellij.openapi.options.newEditor.OptionsEditor$Simple.&lt;init&gt;(OptionsEditor.java:1243) at com.intellij.openapi.options.newEditor.OptionsEditor.b(OptionsEditor.java:425) at com.intellij.openapi.options.newEditor.OptionsEditor.access$2500(OptionsEditor.java:66) at com.intellij.openapi.options.newEditor.OptionsEditor$8$1$1.run(OptionsEditor.java:400) at com.intellij.openapi.application.impl.ApplicationImpl.runEdtSafeAction(ApplicationImpl.java:991) at com.intellij.openapi.options.newEditor.OptionsEditor$8$1.run(OptionsEditor.java:394) at com.intellij.openapi.application.impl.ApplicationImpl.runReadAction(ApplicationImpl.java:851) at com.intellij.openapi.options.newEditor.OptionsEditor$8.run(OptionsEditor.java:392) at com.intellij.openapi.application.impl.ApplicationImpl$6.run(ApplicationImpl.java:425) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:441) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:680) at com.intellij.openapi.application.impl.ApplicationImpl$1$1.run(ApplicationImpl.java:140) 
https://github.com/sirthias/BlueForest
Release candidates for 2.9.2 will be published next week as far as I know. The x.y.z.µ releases are meant for quick fixes (2.9.0.1 was a but bigger though) to very specific problems. I'm not a fan of that versioning scheme but maybe the additional information encoded into the version helps some people ...
I've found [squeryl](http://squeryl.org/) to be a nice library for SQL interaction in Scala. Haven't tried any others though, so I can't offer any comparisons. 
Unfortunately Squeryl doesn't support SQLite, as far as I can gather.
This had a very interesting way to approach the problems - without planning I would have just used collections with transforms on them, but an approach of defining a Distribution seems much more intuitive now.
Anyone know of a good one for Python? We're thinking of spinning up a transition sometime soon.
Unfortunately, this article does not take into account any of the more robust forms of iteration. For non-exhaustive example: * comonadic reduction e.g. of a rose tree * traversable [F[_]: Applicative](A =&gt; F[B]): T[A] =&gt; F[T[B]] The performance figures would be wildly different with a non-trivial case and sound methods of iteration.
Out of curiosity, could you list some of the biggest reasons you are considering transitioning to Scala?
Would you care to elaborate?
I guess these are rare because scala has so many more abstractions, di dyou see: http://code.google.com/p/py2scala/ http://pyvideo.org/video/681/polyglot-programming-with-python-pythonscala-in
Oh, so to speak more directly to your question.... If Play has LDAP authentication support, and your AD has the right ports open and services running, you shouldn't have to write any code, it should be a matter of configuration. Beware, though, that AD builds groups differently from all other LDAPs I've seen, so if you need to do group authorization after authenticating, you might be in for some learning. Let me know if you get stuck, I remember a few things here and there. :) 
&gt; OCaml programmers are typically over 10x as productive as Java or C++ programmers for a wide range of practical tasks. I stopped reading after that. 
for some reason in lift, your snippets cant be named like java. ie UploadFile must be Uploadfile. I know its weird. good luck!
Regarding that type inference thing, there's a nice (yet long) [video of a talk](http://screencasts.chariotsolutions.com/webpage/2011/10) given by Daniel Spiewak on that topic. He also explicitly deals with the different capabilities of the type checkers and explains why that is so. At the bottom line, I don't see Harrop's point when the problem isn't caused by Scala but by the underlying virtual machine.
I don't think that performance figures would be "wildly different" witha a non-trivial case. Using expensive computations in iterations will just equalize the results. The ranks will be the same, but the difference less significative. The purpose here was to measure the "looping machinery" itself. But I am really open to benchmark other forms of iterations. Since everything is on github (see the end of the article), could you provide some implementation ? I am particularly interested about "comonadic reductions".
The problem I have with [this](http://i.imgur.com/dqleg.png) example is, the OCaml version isn't verbose enough. Sure it's shorter, but I just can't really understand what that's even doing, whereas the Scala one is far far easier to understand. Sure I haven't ever touched OCaml/F# and I have done Scala, so I am more familiar with the syntax and the Scala one is a little bit more verbose then needed. But sometimes verbose is good, I can take in the Scala example in a glance.
&gt; The problem I have with this example is, the OCaml version isn't verbose enough. Sure it's shorter, but I just can't really understand what that's even doing, whereas the Scala one is far far easier to understand. Sure I haven't ever touched OCaml/F# and I have done Scala, so I am more familiar with the syntax and the Scala one is a little bit more verbose then needed. But sometimes verbose is good, I can take in the Scala example in a glance. Let's just have a look at the OCaml code: let rec d f x = match f with | `Var y when x=y -&gt; `Int 1 | `Int _ | `Var _ -&gt; `Int 0 | `Add(f, g) -&gt; `Add(d f x, d g x) | `Mul(f, g) -&gt; `Add(`Mul(f, d g x), `Mul(g, d f x)) The first match case says that the derivative of a variable with respect to itself is one. The second says that the derivative of any other variable or any integer is zero. The third says that the derivative of a sum is the sum of the derivatives. The fourth is the chain rule. Can you please explain how this "isn't verbose enough"? For example, what is the advantage of also having to write `abstract`, `case`, `class` and `extends`? Here's the complete Scala for comparison: abstract class Expr case class Lit(f: Int) extends Expr case class Var[T](x: T) extends Expr case class Add(f: Expr, g: Expr) extends Expr case class Mul(f: Expr, g: Expr) extends Expr def d[T](f: Expr)(x: T): Expr = f match { case Var(y) =&gt; if (x==y) (Lit(1)) else (Lit(0)) case Lit(_) =&gt; Lit(0) case Add(f, g) =&gt; Add(d(f)(x), d(g)(x)) case Mul(f, g) =&gt; Add(Mul(f, d(g)(x)), Mul(g, d(f)(x))) } To me, the second half of the Scala program (the definition of the `d` function) looks just like the OCaml but the first half of the Scala (the definition of the `Expr` class hierarchy) is not only superfluous but even ugly. Even if the language cannot infer the sum type (as F# and Haskell cannot, for example) I still dislike the Scala class hierarchy compared to the ML variant type: type expr = | Lit of int | Var of string | Add of expr * expr | Mul of expr * expr or the Haskell variant type: data Expr = | Lit Integer | EVar String | Add Expr Expr | Mul Expr Expr Finally, let's have a look at the same thing written in Mathematica, a language that was specifically designed for computer algebra: D[x_, x_] := 1 D[_Symbol | _Integer, x_] := 0 D[f_ + g_, x_] := D[f, x] + D[g, x] D[f_ g_, x_] := g D[f, x] + f D[g, x] Being able to write `a+b` instead of `Add(a, b)` is an improvement but OCaml gets pretty damn close to the DSL in this case without sacrificing the advantages of static typing. F# and Haskell are next best, having to define an `expr` type up front. Scala is the worst of the functional languages in this case because it forces you to define a superfluous class hierarchy using a baroque syntax and then requires you to annotate the type of the `d` function because it is incapable of inferring them. 
I have not watched the video but in ocaml and haskell, types are almost completely compile time constructs and the languages compile to untyped code so I don.quite buy it being a runtime issue. 
Check the google group for more information. Most likely, html5 is turned on, which will convert everything to lower case. You will want to use the following for defining snippets: &lt;div class="lift:UploadFile.speak" /&gt;
&gt; The main reason Scala is not functional enough is compatibility with Java. F# does not share these limitations yet it is compatible with C#. &gt; Full type inference? Impossible with overloading, implicits and inheritance. Personally, that no big deal me. Was a big deal for me. I use type inference all the time. I rarely use overloading, implicits or inheritance and when I do it is only to consume an existing C# API. &gt; I often use type declarations in Haskell, because without them the inferrer goes crazy if I mistype something. Absolutely. Same goes for polymorphic variants and objects in OCaml. But, to me, that is an argument for the programmer to be selective with them rather than for the language designer to ban them completely. With Scala, I found I had no choice. I have to write out type definitions and annotations or even the simplest function (e.g. factorial) won't even compile. Then I would have to maintain them. My code will be considerably longer. I would have to sacrifice a core benefit I had come to appreciate from OCaml and F#. I anticipated that most of my customers would not be willing to make this sacrifice so I chose not to use Scala. 
I have several lift snippets that use camel case, for example: class MyLiftSnippet In my xhtml, I use lift:MyLiftSnippet and it works fine. Be sure to modify Boot.scala to tell it which package contains your snippets: LiftRules.addToPackages("org.foo.web") This would tell Lift to look for MyLiftSnippet in the org.foo.web.snippets package, and comet classes in the org.foo.web.comet package. 
Here is a basic project to get you going: https://gist.github.com/2037578 build.sbt goes into project root, Main.scala into src/main/scala. [Install sbt](https://github.com/harrah/xsbt/wiki/Getting-Started-Setup) and run it with `sbt run`. To learn more about ScalaQuery check out [wiki](https://github.com/szeiger/scala-query/wiki), [this blog](http://szeiger.de/blog/category/scala/scala-query/) and tests. Oh, and there is also a [google group](https://groups.google.com/forum/?fromgroups#!forum/scalaquery).
Thanks. That looks like precisely what I needed. I'll play around with it as soon as I get home.
Well, for the low-level JNDI stuff, [this]( http://mhimu.wordpress.com/2009/03/18/active-directory-authentication-using-javajndi/) should get you started. As for plugging that into Play, is there already an enhancement ticket for LDAP support? 
There is an enhancement ticket in there, but the project I'm working on is on a ridiculously tight timeline. I did manage to get something working this morning using the LDAPConnection SDK from unboundid.com though, so if anyone else is interested in this you might start there. Unfortunately I'm going to have to put aside the Scala for now and finish this project in Rails and get back to Scala when I have more time.
If you are planning on using kerberos, on windows it should work magically IIRC, but on a unix/linux box you'll have to get a working kerberos config and at that point you're better off also having java use the native kerberos library - the java kerberos library was far from complete last time I tried something like that. A working example of a java app that I've seen do AD auth is jTDS, in the 2.x branch. There is gssapi/sspi auth code in there.
i'm the op btw (i cant make threads on this account anymore). my issue was the html5 being on.
Would be interesting to do a comparison of programs that use features that are substantially more concise in one or other language...
I'm looking forward to macros practically with drool my lips. The ability to easily generate code at compile time has the potential to solve all sorts of problems. I'm especially interested in using it for data binding for `scala.swing`. Consider a macro method that analyzes the two expressions you hand it, automatically generating appropriate event listeners or whatnot to keep them in sync. Full type-safety, no reflection at runtime, elegant syntax&amp;mdash;that would be amazing. Scala macros: oh *hell* yes.
Inaccurate. If you declare the base class in the variant-type pattern to be sealed, you get OCaml-style exhaustiveness. This design pattern (used non-pejoratively in this case) is not as attractive as Ocaml's offering, but at this point we're talking about style rather than substance. Also, his claim that you need to create a HelloWorld object with a main(args:Array[String]) method to print a line to the console is patently false. Typically people write classes in Scala because that's the Java Way Of Doing Things, but you can write short, classless scripts just fine. This is "Hello world" in Scala: &gt; println("Hello world!") On a side note: for the Love of Lambda, we in the functional-languages community need to Just Fucking Stop slamming other good languages over small differences. When Ocaml and Haskell and F# and Clojure and Erlang and Scala languages start bashing each other over minor differences among great languages, we People Who Care About Programming Languages make ourselves appear fractious and the end result is that we end up having to use C++ and Java, because the People Who Don't Care About Languages got into those camps years ago. 
My god. This is the greatest article I have ever read on this site.
Having recently picked-up Scala (and still learning) I seem to share a lot of the sentiment in the article. The main "problem" I have with Scala at the moment is that it's *so* stylistically flexible (if that makes sense) that many libraries/frameworks/examples become so convoluted that I find it hard to read the code and figure out what it does. This freedom of expression is most definitely a good thing, but I can't help but feel that in some examples and articles, it's working against me rather than with me.
Same feeling here. I just learned about Kotlin and it feels like a breath of fresh air: you get most of the power of Scala without all the bizarre and arcane features. I'll keep an eye on it. 
Oh crap :-( Brain fart. Really sorry about that. reddit, y u no let us edit titles? 
The Scala community is quite fond of taking ridiculous crap seriously and serious crap ridiculously. This is sad :( You don't get to misunderstand a subject, make ridiculous comments on it and get to be taken seriously. Try again please.
 - eliminate two classes of types in Scala, so that only a simple core remains - avoid unnecessary repetition of parameters in mixin compositions - introduce least upper bounds and greatest lower bounds of types as type constructors yes to all! sip-18 should still be deleted and rewritten :)
Unlike Vertex, I will start: * Ruby is given a yellow for Process.fork achieving concurrency. Really? * Tooling: Scala can use Intellij or Eclipse. Is he trying to say that Intellij and Eclipse are weak? Should be at least a yellow. * Deployment: SBT. But since it got a yellow for packaging, I'm guessing that he doesn't know how to use sbt. * Testing: Maturing? What in the world does that mean? * Frameworks/Libs: A high library count is a good thing? It doesn't need Python's billion libs because the language can accomplish so much already. A high library count should be a bad thing. * Readability: Just because he comes from a highly imperative background doesn't mean scala isn't readable. It's extremely simple to read scala if you understand FP. * Happiness/Productivity: He likes Ruby and Python, but not Scala. We get it. * Propensity for Magic: Implicits provide an explicit way to do conversion. Don't want magic? Don't implement implicits. If he's talking about set conversions for map-like functionality, I refer back to that, not understanding FP point. * Hiring: Steep learning curve? I picked up scala in half the time of python, and without having an FP background. Pre-conceived notions from imperative programming make learning Scala hard. The only point on the whole comparison is the maturity/stability, due to scala's binary compatibility issues. I also love the fact I can't read the perf charts, and the job trends go from '05. Scala didn't really come onto the scene until about '09.
Here's the URL if you're on a phone or iPad: https://groups.google.com/forum/?nomobile=true#!topic/scala-language/PV4q6O1qIh8/discussion You'd think Google would make their own sites work with Android.
Why do you say that? I don't think there is a minimum 'smartness' threshold required. the curve is bumpy (has shallow and steep bits), but it definitely starts at zero.
Me too frustrated by Google Groups inability to display full site url in mobile site automatically. I sent them a contact us email, guess no one is reading.
I wouldn't dream of forcing the philosophy on others, but I generally feel that if I'm including enough XML in-line with functional or imperative code for me to *care* about the escaped strings being too bulky or ugly, then I'm doing something wrong. (But, quietly, yes, that would be very nice. :P)
I'm definitely less clever than some of the people who make scala and most of its libraries. I'm not stupid either. I'm a regular developer. But I did learn some scala and, while I won't lie to you and say that it was all easy, it was well worth the effort for me.
Hm, did I read this wrong perhaps, or does the code really read a single file from the disk in parallel? Unless you have a SSD, won't this actually *decrease* performance, as opposed to reading the file sequentially? Disks don't really like random access of the same huge file. 
Love the fact that the discussion got sidetracked to more important stuff such as tabs vs. spaces.
Scala already is in version hell considering that whenever a new version comes out, all the dependencies need to be recompiled with the compiler of that exact version, which is why we're seeing so much drift already in projects that can't or don't have the time to upgrade to the latest version of Scala. Java doesn't have this problem and you still have countless companies still using 1.5 and 1.4, which should give you an idea of the kind of uphill battle Scala is facing in this area. 
I don't get it, I was reading this thread on Android and I first clicked your link which led me to the non mobile version. Then I clicked on the post's link which led me to the mobile version, that I can read fine with my android phone (I'm using chrome beta, maybe that's the difference?). What's the issue? Is it i-* specific?
&gt; considering that whenever a new version comes out, all the dependencies need to be recompiled with the compiler of that exact version No.
When will we see Scala for the Suicidal?
I don't get it
Kind of whiny, and the dramatic headline is *not* justified.
This is _so_ not what I'm looking for when I check out /r/scala
The author tries to be more conciliatory in the second post ( http://zeroturnaround.com/blog/scala-sink-or-swim-part-2/ ). In the end, he only reveals his own problem. He states he would like to see "a more symbiotic co-existence and further bridge the functional / OO gap", but he is exactly part of the problem and not of the solution. In his worldview, the following attributes go together: "functional/theoretical and OO/pragmatic". He goes into the we-they trap. Those = "Some people" whose existence is purely theoretically founded. We = "the larger group", people who are sane and pragmatic, who get things done in a maintainable way. Give me a break! So wanting to see a symbioses of functional and OO style is a blunt lie. "I think what the Scala community needs most at the moment to make Scala an even better Java alternative is to bring in more pragmatic programmers who would write solid libraries that don’t overuse symbols, avoid some of the more complex type system features, maybe even stay more imperative than functional (while still preferring immutability), and don’t go overboard with the type safety." He cannot be more wrong. What the Scala community needs is indeed to develop a culture that is proud of Scala standing on its own feet, proud of a language which mixes functional and OO style, proud of being pragmatic and theoretically founded. We don't need a Scala that defines itself as a function of how successfully Java developers are attracted. I have been working with a computer music language, SuperCollider, for many years. SuperCollider has a community which is very pragmatic -- because they are all sound artists who want to get stuff done. SuperCollider programmers mix OO and functional elements all the time, much of its pragmaticity comes from the functional constructs. And nobody cares or tries to fight the other side, because they are not poised by trying to recruit from a crowd that is hostile towards either feature. 
I understand it's an example, but I would still make case class Grade( letter : String, passed : Boolean ) something a bit more like sealed abstract class Success case object Passed extends Success case object Failed extends Success case class Grade(letter: String, passed: Success) Then the checks would instead be grade match { case Grade(letter,Passed) =&gt; printf( "You have passed with grade: %s", letter ) case Grade(letter,Failed) =&gt; printf( "You have failed with grade: %s", letter ) } and the the types reflect the logic a lot more. If the author doesn't want to do this then the example is bad, if you excuse my bluntness. (Then there could be another discussion on wether `letter` should be a `Char` or a `String`, but in my school at least, you can get multi-char letters, so I kept it a string.)
Holy boilerplate, batman!
Motivation for using Anorm, can be found in Play documentation: http://www.playframework.org/documentation/2.0/ScalaAnorm (see Overview)
I have to agree with igorrumiha, squeryl is just plain broken. You get all sorts of generic runtime errors like "unable to load class" when trying to do anything beyond the most trivial queries. And in the cases where you can convince it to work, it generates some absolutely terrible queries, often getting confused and joining the same table multiple times. Scala-query is much better, but it doesn't let you do more than one outer join, which again makes it basically useless.
You have opened my eyes!
Scala Query has a very rigid structure with bloated table definition. I generate my objects together with database classes, and for these purposes squeryl is very good. Though, I do not use any of the advanced techniques. I think I will be looking more into Anorm now.
I read about Squeryl, but decided to first attempt persistence with the provided framework. The link paradigmatic provides sold me on giving it a try. Anorm actually provides descent static typing by way of the RowParser, which is a reusable object that can be thrown at any SQL response. I like the idea of Squerly, might give it a shot eventually. Although there doesn't seem to be much love for it on this page!
No magic in IntelliJ IDEA -- implicit calls are underlined, and if you select the receiver and choose 'Implicit Conversion' from the menu, you get a list of all the conversions in scope, where the highlighted item corresponds to the currently used conversion.
Yes. For instance, IDEA underlines the method in question in light grey.
Filed as https://issues.scala-lang.org/browse/SI-5617 Thanks.
Awesome, I will have to check that out. I tried the eclipse plugin, can't say I loved it.
&gt;Scala Query has a very rigid structure with bloated table definition I don't know what you mean here? We created our database before we touched code at all, and other than the outer join limit scala-query was able to use our schema just fine. It doesn't make any sort of assumptions about your database schema. Squeryl does actually, if you use the typical serial primary keys in postgresql, squeryl can't do inserts because it stupidly tries to select the id value itself from a non-existent sequence.
It is still maintained, but it is only one guy and he's not very responsive to bug reports. It will almost certainly get abandoned in the future though as typesafe is working on an official integrated query language for scala right now.
Anorm isn't really a query language, it is for parsing the results of queries. I'm not sure if anyone at typesafe has much to do with play other than just saying "this is our officially endorsed framework". I believe [this](http://code.google.com/p/scala-integrated-query/) is what they used as a base and are working on finishing up. But it could just be naming confusion over multiple "scala integrated query" implementations.
XML only resembles line noise if whoever designed the schema was an idiot. To be fair, many, many XML schemas are, in fact, quite idiotic. Not the fault of XML itself, though. I don't much like the idea of configuration files being written in a general-purpose programming language like Scala. While I can see the allure of the syntax and semantics being basically the same as the programming language you're already familiar with, these creates several problems: 1. The syntax is not necessarily simpler. It can easily get much worse, especially if the designer feels like coming up with bizarre symbols like `&lt;~=` instead of names for things, or bizarre requirements like a blank line between configuration items. This is of course the fault of the designer of the configuration format, not the language itself, but the same is true of XML. I remember taking a look at SBT, being horrified, and noping all the way back to Maven like my life depended on it, partly because of this. 2. It's a *programming language.* If you need the full power of a programming language in a configuration file, you're probably doing it wrong. Configuration files should have just enough expressive power to describe something, without saying a word about implementation. 3. Making tools for it is harder. If you try to write a GUI to edit your configuration file, you'd better hope the configuration file didn't have any comments in it, because they won't be there when you write the new one. Since it's a full-blown programming language, you won't be able to make a generic editor for configuration files like it, like you can if you have XML or an INI plus a schema. 4. Parsing configuration files written in a full-blown programming language can create a security risk. Granted, this often isn't a problem, since configuration files are usually trusted, but if they're written in a full-blown programming language, they *must* be trusted. You can't even parse them to do a simple sanity check or something if they're not. 5. Unhelpful error messages. Programming language compilers are designed to emit error messages appropriate for programming mistakes. If you have to write something like `250.milliseconds`, but the part before `.milliseconds` is of the wrong type, you get a message like "no such method: milliseconds", bewildering the hell out of whoever's writing the config file. Note that this is a problem with internal DSLs in general. Anyway, just to prove a point about XML not being as horrible as the author claims, let's take the example configuration snippet: port = 22133 timeout_msec = 100 log { filename = "/var/log/kestrel/kestrel.log" roll = "daily" level = "info" } And make clean XML of it: &lt;server-config port="22133" timeout="100 ms" &gt; &lt;log filename="/var/log/kestrel/kestrel.log" roll="daily" level="info" /&gt; &lt;/server-config&gt; Looks almost the same, and completely avoids the problems I described.
I love the example: trait ServerConfig extends (() =&gt; Server) only Scala could be so left-handed :-)/ 
Well, then JSON is just as valid. If the point is that the config file must be consistent, testable, and verifiable, then neither XML nor JSON can do it. If you layer schema onto either one of them, then the argument is: you have complicated something that should not be complicated. Why not just go all the way? 
I recently went back to a project written in Scala way back in 2009. It was using Configgy. I considered switching it to this new incarnation of config for a bit and realized that there is no good reason the configuration needs to be a full language, it kind of negates the purpose of having the configuration in a file in the first place. I ended up just using the existing Configgy configuration file and refactoring ALL of the config reading into different traits, with defaults, which could then be mixed in to the classes that require them. This produced the best of both worlds, defaults and a human readable configuration file. 
Isn't that in a way what sbt does with the `.sbt` files. They look like config files, still they compile and thus allow verification. I was for a while unsure about beauty vs. ugliness in `.sbt` files, but I think in the end the solution is quite appropriate. I wonder if there is not a sub module of sbt that could be used as general purpose configuration?
As a dissenting voice here, I use Squeryl daily and love it. I prefer not to have to write SQL except the 1% of the time when I'm tuning a problem query. I found Anorm's DSL bizarre and difficult to understand, though maybe it's changed over the last 6 months.
I'll have to try it again sometime. Unfortunately, when I tried it a few months ago, it just failed to understand my code (which wasn't very complicated at all) and thought that perfectly compilable code was erroneous, which basically screwed everything up. I'm back on Eclipse now, crappy though it is.
Would love IDE support for this too. I begin to type "override protected def" and wish IntelliJ would jump in and autocomplete method name and params.
No issue. I think the syntax quite cool, but in a quirky way. More fun than Function0[Server] 
It's called "you ain't funny dude"; surely you have heard of it? :P
I'm not saying a testing microframework is a bad thing, but what's exactly complex or difficult with specs2 or scalatest? 
OMG chapter 20. Stream processing and incremental I/O i wonder what is incremental IO
(from a novice Scala user) Both scalatest and specs2 are very easy and useful unit testing libraries, being more emphasized on integrating software specs into test cases. Usually, new instance of class is initialized in each spec in scalatest and specs2. However, my pet project requires testing against one class instance, rather than having a different class instance in each test case. Also, in my case, each test case needs to modify the instance slightly for the consecutive "test steps" to carry on, and I do not wish to revert the modifications manually for the consecutive test cases (not steps, this time). Thus, I created this micro unit testing tool to suit exactly what I need. TLDR: MUT helps with executing test cases against (usually one) instance, rather than multiple instances of one class. MUT allows the instance to be modified during each test spec without carrying the changes onto the next test spec. BTW I've updated the README on Git to express my idea in more details.
Which Google guys?
Great, and easy to follow talk. I don't know much about macros and what is possible to achive with this implementation, but this minimalistic approach seems neat. Quasiquotes did not get included (in part because of reify?). That feature looks like a can of worms, even with promise of deprecating the current xml implementation. :) I wonder what opinions Gilad Bracha has about Scala. The Dart language he's involved in seems extremely conservative in comparison. Classes and interfaces for abstraction. If-else, for, do-while, and switch as control flow. Damn, even Javascript with prototype-based inheritance is more exciting!
Thanks for digging up the link. A bit old comment but I he seems to commend Scala on improving OOP. I was curious because he seem to dislike type-systems which is a major part of Scala.
Why the hell do you have to shorten everything?
I'm still new to scala, but couldn't/shouldn't you make the return type of the block a type parameter, and make when's return type the same thing?
Tried your code inside scala REPL (:paste mode FTW). As guessed, the when block yields Unit when the condition evaluates to false :) &gt;//For curious &gt;scala&gt; :paste &gt;// Entering paste mode (ctrl-D to finish) &gt; &gt;def when[T] (condition : =&gt; Boolean)( block : =&gt; T) &gt;{ &gt; if (condition){ block } &gt;} &gt; &gt;// Exiting paste mode, now interpreting. &gt; &gt;when: [T](condition: =&gt; Boolean)(block: =&gt; T)Unit &gt; &gt;scala&gt; when(true == true){ println("I'm true!") } &gt;I'm true! &gt; &gt;scala&gt; when(true == false){ println("I'm true!") } &gt; &gt;scala&gt;
To my surprise this actually works. implicit def `when for function0`[A](f: =&gt; A) = new { def when(cond: Boolean) = if(cond) Some(f) else None }
Cool! I'll post your solution to the gist as well!
ENSIME seems like a pretty cool idea, it's a separate process that communicates back to your text editor. However the only full implementation of the ENSIME protocol seems to be emacs. I tried Sublime and it would stop working periodically.
I've gone through this and it looks interesting but I am having trouble grasping the subject matter. Is there some background material or any simpler explanations that someone could to recommend to an old (37!) imperative/oop programmer?
&gt; Inaccurate. If you declare the base class in the variant-type pattern to be sealed, you get OCaml-style exhaustiveness. Eh? You say "inaccurate" and then reiterate exactly what I wrote, which was: "...in which case the Scala compiler will try to check patterns for exhaustiveness of redundancy but this is only available for sum types and not all types as all MLs do" And I gave an example showing that Scala did not do exhaustiveness checking over a tuple of booleans. &gt; On a side note: for the Love of Lambda, we in the functional-languages community need to Just Fucking Stop slamming other good languages over small differences. Type inference, variant types and pattern matching are seriously cumbersome in Scala compared to SML, OCaml, F# or Haskell. To me, that is a big difference because they are the foundation of ML's productivity. Big enough that I chose not to take my company into the Scala market. 
I don't know much about F#, but I would assume that one of these things are true: * F# isn't as compatible with C# as Scala is with Java. * F# uses structural typing * F# requires you to name the .NET-native functions you're going to use, along with their types, and requires you to rename any duplicates. * F#'s type inference becomes unreliable in some of the more complicated cases. However, it could also be something else, as I don't know a lot about F#.
The last one. F#'s type inference stops in the event of ambiguities (e.g. overloading) and requires type annotations. 
Ah, looked it up. They are using some tricks that are pretty incompatible with Scala. One example is ¦&gt;.
I've written a somewhat more introductionary(*) text starting at: http://blog.zilverline.com/2011/02/01/towards-an-immutable-domain-model-introduction-part-1/ The last entry (http://blog.zilverline.com/2011/02/10/towards-an-immutable-domain-model-monads-part-5/) contains links to the other four parts. This basically describes how immutable, event-sourced domain models could work. Regards, Erik *) Except part 5, which deliberately goes into "advanced mode" :-)
Excellent! I will check these out.
[Here it is generalised to run in any pointed monoid](https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/syntax/std/BooleanV.scala#L240), not just for side-effects.
PS: You want to remove the by-name annotation on the Boolean argument.
Sweet! So it's part of scalaz core, isn't it? Just as well :P
Yes, it is part of scalaz, along with other closely related combinators.
Stop downvoting this. This person had a real-life experience with Scala and is sharing it. If your experience is different, instead of suppressing his view by downvoting him, make a post of your own. Perhaps we'll have an interesting discussion.
I have read Twitter's best practices and those say to avoid implicits unless it absolutely cannot be avoided for expressing your intent concisely. [This] (http://twitter.github.com/scala_school/) was a good resource for their experience and how they deal with Scala day to day as well as for learning good scala programming. EDIT: Sorry, [This] (http://twitter.github.com/effectivescala/) was their best practices, the former was a learning guide.
Except he didn't actually share jack shit with us - he just appears to want to bad-mouth Scala with baseless claims.
I looked at it briefly, but I'm more interested in the Reddit hivemind opinion. I'm trying to get as large a sample size as I can.
I run a ~5 person team at work and we've developed software in both Java and Scala. The team is composed of 3 experienced and thoughtful engineers and two younger but still sharp developers. We really like scala, but there are drawbacks. We still actively maintain both a Java codebase and a scala one (different projects), and everyone clearly prefers working in scala and whines when they have to go back to Java. The main drawbacks, imho, are: 1) You get a lot more rope to hang yourself with. If you have a small or above average team you can manage this just fine. If you have a couple of cowboys or easily confused engineers this will hurt. 2) Binary compatibility (or lack thereof) will make it difficult if you need or want to use large numbers of scala based open source toolkits. If you're happy to stick with a version for a while, and use only a handful of toolkits (so you don't have to coordinate all the upgrades at once) it's fine. We're using squeryl and a couple of other small libraries and that's it. 3) Build times are longer. Sbt can help but it's not "simple" in my opinion. TL;DR: works great for small/experienced teams with limited dependencies. 
My experience has been excellent. I wrote a distributed streaming update computation framework at my job using Scala. This was a complete rewrite of previous work in Perl and Java and the code size reduction is anywhere between 1:7 or 1:10, depending on how you measure it. The new system is also an order of magnitude faster. However, I did have prior (non-professional) functional programming experience. In general for a first project, don't be afraid of being as close to Java as possible i.e. it is OK to use Scala as Java without semicolons. Some of the earliest trouble and lack of productivity stems from programmers trying to write "authentic" functional programming code, which slows them down tremendously compared to Java. The best way to avoid this is to start using Scala as a syntax improvement over Java. The functional aspects can be acquired bit by bit. Some tips for a beginner Scala project: 1. Preferably start by writing test code in Scala, 2. Use maven, instead of sbt. Avoid ant! 3. Ship with scala library jars to avoid the binary compatibility issue 4. Set expectations low, use Scala as syntax clean up of Java with access to a REPL 5. Improve the teams functional programming expertise via code reviews. 6. Make sure your IDE setup works well. Eclipse is harder to setup than IntelliJ but both work well. Java IDEs make devs very productive. It is important to have a similar setup for Scala. 7. Avoid too many dependencies on external Scala libraries. Stick with java libraries for the most part. As for the feedback from the Yammer folks, I feel like there are deeper design issues with the Yammer code base To repeat his points 1. Don't ever use a for-loop. 2. Don't ever use scala.collection.mutable 3. Don't ever use scala.collection.immutable 4. Always use private[this] 5. Avoid closures If you accept these 5 points Scala's effectiveness is reduced by 90%. Scala makes heavy use of closures and the JVM is not as optimized to deal with closures as compared to for loops. You should expect around 2X-3X reduction in performance from using a functional style. However, most code is bottlenecked on DB access or some tight for loop (which can be written in imperative Java style in Scala itself). Not having any information about Yammer's code base I would guess that they have serious design issues with their implementation. Probably, algorithmic (O(n^2) computations) or excessive layers of abstraction over their performance critical component. This can explain why they had to peel out all the closures and use low level imperative code. For my application, I did have performance critical parts, but I used netty async and imperative Java style code in those portions and kept any kind of abstraction and closures to a minimum. Just good design/common sense. So, as a general design guideline, assess where the CPU bottleneck in your system can arise and keep that part really thin and simple and free from layers of abstraction. In the worst case Scala can slow down the CPU bottlenecked portion by 2X to 3X. You can rewrite those portion in an imperative style easily, unless you have layered in too many abstractions. 
Thanks for the insight. We'll most likely be taking a Guardian approach (as defined below by zohebv) and start by writing more Java-ish Scala code and then migrating over as concepts become familiar. Hopefully as more people come on and the project gets handed-off, we can continue to maintain it easily.
I have set up a maven, m2eclipse, scala-ide, eclipse based prototyping environment and things are going well so far. What about more complicated build/deploy scripts? More than likely we'll need to do more than just build jars for the build/deploy and I'm curious how well that works. Thanks
I write scientific apps on large biological data sets. I have not had much trouble optimizing hotspots in my code to remove the problems of scala performance, while still benefitting from scala style in 99% of my code. Large scale refactorings with the eclipse plugin, on the other hand, oi.
Why avoid ant? Works fine for scala, as far as I can tell.
I'm not crazy about the prevalence of DSLs in many Scala libraries because they can make source code in different files look very different, which I don't think is a positive thing. Python is known for being easy to read because pretty much all code looks the same, DSLs have the opposite effect on Scala code. More importantly, these DSLs sometimes seem very arbitrary or unnecessarily odd. I realize one of the goals of Scala is to enable DSL creation, so perhaps this is just my personal taste. However, when I read code like: foo #&gt;= baz &amp; It means nothing to me. I'd much rather have meaningful method names, even at the expense of more verbose code. I don't think all Scala DSLs are bad. In fact I think the XML DSL is particularly good. It's a great example of a very good reason to use a DSL. I also share the dislike of implicits that others have expressed here. We've had several cases where implicts from different libraries conflicted in a given file. In this case it was necessary to write the code explicitly, and doing so made the code in that file look different from code in other files that used the same library where the conflicts didn't occur. This inconsistency can confuse readers of the code who aren't aware of the reasons behind it, and that seems like a language misfeature to me. Don't get me wrong, this is criticism from a fan of Scala. You can write very terse and elegant code without using implicits or DSLs. I'd prefer to be working with Clojure, but I'll take Scala over most other languages in a second.
Probably because of my inexperience with ant and Java itself. A work colleague set up the ant build for scala and it was a huge pain. I tried to do it myself and struggled too (I was new to Java and ant). Eventually, we had an ant set up (via the scala-ant plugin) that would not always compile incrementally. I am sorry, I never got a good handle on the issue. Moreover we were deploying our jars stand alone (i.e. without the scala library) which caused all kinds of binary compatibility issues when upgrading from 2.7 to 2.8. I did not know of any any good way to deploy the scala library apart from checking in the library jar file into source control. Also, I never quite got Eclipse set up correctly for auto-complete etc when using ant. When we switched to maven, it was like moving from hell to heaven. With IntelliJ, I just opened the pom.xml and everything just magically worked! This is probably my inexperience with the Java ecosystem showing, but I would never attempt an ant based scala project again, when maven seems better in every respect. 
Although I don't program in Scala at work, I have a set of guidelines involving implicits for my code: * use implicit parameters only for expressing type constraints * use implicit conversions only for adding new adequately named methods to “basic” types (value types + strings); the only method I added this way so far is `times(f: =&gt;Unit)` method for Int I haven't ever had a need to deviate from this guidelines.
if you write Scala as you would write Java youshould just stay with Java. you'll never rewrite the Scala bastardisation anyway. 
I see. I am the opposite. Been using Java and Ant since both began and so they are second nature, whereas Maven, which wants to dictate and control everything confuses me. YMMV! Also, Ant has nothing to do with whether Eclipse auto-complete would work properly or not.
No doubt. I am happy with it, and I keep up with the eclipse plugin nightlies. That said, it has a long way to go to catch up with all the support available for base Java. And I think Kotlin will surpass Scala in this type of tooling too. I like Scala, would never willingly go back to Java, but I'm not sure it's complexities vs something like Kotlin are truly warranted and useful. My jury is still out :-)
The Scala plugin for IntelliJ IDEA will underline methods from implicit conversions and offer a 'navigate to implicit conversion'. 
In the next few weeks, I guess. (But upgrading from 2.9 should be painless.) They are more or less finishing up the reflection/compiler/macro parts and wait for Eclipse/SBT/... to catch up. Not all talks from Scala Days are up yet ... some of the missing ones could be really interesting for you, e. g. the one from Odersky, the SLICK or the macro ones. The takeaway is that Scala will get cleaner, more stable and compatible, with huge improvements to tooling support. But also that it will keep being decades ahead of Java, while shipping state-of-the-art technology to make developers more productive, so that the JVM remains a viable target platform.
Late response here, but I disagree. Code is ever-evolving in large projects and writing more idiomatic Scala code will happen both in new code and when old code gets fixed.
Well, I work with PhD students and postdocs, so I know what kind of code *they* write ;-) But, interesting, thanks for the tidbit! Also, for Kotlin, I was referring to IDE tooling. I really will be surprised if Kotlin IDE support in IntelliJ doesn't surpass Scala IDE support in Eclipse within a year.
I guess it is a plus for Scala that people have switched from claiming it has no IDE support to “a different language might have better IDE support than Scala has now within a year”. :-) Competition is good, but I don't believe JetBrains can just throw 40+ fulltime people on Kotlin to catch up with Scala. 
I am very hesitant to start using an IDE I have to pay for in order to write either Scala or Java code. I know there's a "free" version of IntelliJ, but Eclipse gives you SO MUCH out of the box for free. It's a huge win for the community and likely will be for a while. Kotlin looks interesting, but it's years behind Scala and not production ready according to JetBrains. Also, I like the fact that Scala is so flexible, we can code how we want. It's almost like C++ in that way. There are almost no restrictions on number of ways to do the same thing
I'd agree with that completely.
I am only talking about the IDE plugin. Scala the language/runtime is way ahead, of course, and probably will always be so, unless Kotlin gets majorly adopted by industry, which seems unlikely. Java 8-9-10 might kill Kotlin dead. I am happy with the progress being made on the Eclipse plugin for Scala. It is slow, but it is progressing. 
&gt; And I think Kotlin will surpass Scala in this type of tooling too. From what I can tell, it already has in terms of IDE: the IDEA plug-in for Kotlin is already infinitely more robust and more advanced (refactorings, auto completion and browsing) than either of the Scala plug-ins. Very impressive for an early beta version. As for Kotlin itself, time will tell if it can break through, but I'd say it's off to a good start. 
&gt; practically no one sees the value proposition of Kotlin. Scala early adopters don't see the value proposition of Kotlin... shocking. To the original poster: give Kotlin and Ceylon a look, you might like what you see, even if both these languages are still at the very early stages of their life. 
&gt; What's a feature flag? A very bad idea that I really, really hope the Scala team will drop. It's a compiler switch that enable various features of the language. Without that switch, your code won't compile if it tries to use these features. I'll let you imagine the kind of support and maintenance nightmare that it represents... 
&gt; if you write Scala as you would write Java youshould just stay with Java. Even if you just do one thing differently like not writing boilerplate getters and setters, or using vals everywhere, that's still a win.
Implicit parameters are useful for passing through "configuration"-type-things needed by multiple methods, without having to pass them explicitly and without using global or instance-level state. Although having said that, you can also add implicit parameters to a primary constructor for a similar reason. As for implicit conversions, the pimp my library idiom is really useful for wrapping legacy libraries and shouldn't be discounted.
True. I'm using the milestone release and it's working great. You can even toggle showing implicit conversions. Pretty cool 
very sound article
Even with scripts enabled it breaks if you actively reject cookies. *Sigh*
This is 2012. Turn on cookies and javascript. 
Nice, hope there are a lot examples when 2.10 is released!
TIL you can write things like `val Literal(Constant(s_format: String)) = format.tree` (i.e. use extractors in the LHS of a `val`). Anyway, looking forward to it, even though it looks like it'll take a good bit of thinking to wrap my head around it.
I think it's pretty unreasonable if it breaks the site. Even if you want stats using Js is not the only way to do it, it can be quite easily be done server side if they're so determined to have them. 
I haven't tried it (as I'm not exactly interested in Kotlin). But refactoring, auto completion and browsing work very fine for the Scala plug-in, so I don't know what you try to say here?
But Scala *does* allow method name "overloading" on different classes. (Contrast with Haskell.) "Overloading" just means that the same name can be used to refer to different things; don't confuse this with "Overriding" which refers to a subclass changing its own behavior from the parent class's default behavior for a given method. The topic of the post is called "operator overloading" because in C++ you can only use certain operators, which are already in use, and the article does point out that Scala is better in this regard.
I think that's a very uncommon definition of overloading. I see where you are coming from (considering methods as tuples of name, arguments and types) ... but I disagree with it. Following that logic, every method definition would be an overload, because someone might have or has the same method already defined on a completely unrelated class. Overloading requires that a method already exists in the same class, either by declaring it right there or by inheritance. Comparing to languages which have a global namespace for some things doesn't make much sense, imho.
wow, I really like that - will save me so much typing :) btw, would $list(1) also work?
Put it in curly braces like this: ${ list(1) }
do you need the space or could ou do ${list(1)} instead?
Should work.
I'm currently working together with the team of a smallish startup in the financial domain and they're developing the whole product in Scala/Lift. Except myself, none had previous Scala experience, but so far we don't have any complaints (except building times with IntelliJ ) We're using it as a "better java" OO mostly, heavy use of traits (I guess it shows the Ruby heritage of many here) and the bottom line is: is working for us (great performance/high productivity) We're going live next month! 
Yes to all observations, nice post. --- Minus 'Rust' and 'ATS' maybe... fun fibats {n:nat} (n: int n) : [r:int] (FIB (n, r) | int r) = let fun loop {i:nat | i &lt;= n} {r0,r1:int} ( pf0: FIB (i, r0), pf1: FIB (i+1, r1) | ni: int (n-i), r0: int r0, r1: int r1 ) : [r:int] (FIB (n, r) | int r) = if ni &gt; 0 then loop {i+1} (pf1, FIB2 (pf0, pf1) | ni - 1, r1, r0 + r1) else (pf0 | r0) // end of [loop] in loop {0} (FIB0 (), FIB1 () | n, 0, 1) end // end of [fibats] Cheeze, no...
I realise this is a bit basic for the general reader of this subreddit but thought getting some comments or feedback might be useful.
I really hate Play. It's not much better than friggen JSP. There's so much boilerplate code to create html elements it's just..., so 1997.
Maybe just unfamilar, true. But the above actually omits the FIB part which is, from what I understand, the compile time verification part, the distinctive feature of the language: dataprop FIB (int, int) = | FIB0 (0, 0) | FIB1 (1, 1) | {n:nat} {r0,r1:int} FIB2 (n+2, r0+r1) of (FIB (n, r0), FIB (n+1, r1)) // end of [FIB] The syntax is just awful IMO. Quoting from the tutorial ( www.ats-lang.org/DOCUMENT/TUTORIALATS/PDF/main.pdf ): "The syntax of ATS is highly involved, which can be a daunting obstacle for beginners trying to read and write ATS code." Well you could say syntax is not important. But then, what does the language add in terms of semantics and functionality? I think I'd prefer a combination of unit testing and compile time assertions aka macros in Scala 2.10 over this. All the three languages mentioned in the original blog add to the low-level instead of the high-level. They re-introduce pointer arithmetic, C(++) constructs, remove the VM in favour of compiling to binaries. I understand there are scenarios where you might want to explicitly control garbage collection. So what can be learned from those languages? I'm not sure. I prefer the compiler and VM dealing with heap allocation optimisations, I really don't want to clutter my code with that. I don't think this is the future (I hope).
Great news to see better tooling. I've been going back and forth between emacs with scala extensions and scala-ide but looks like its finally starting to mature enough to stick with it.
Well this certainly looks more interesting then the Google AI challenge that I tried. I shall try this out.
Your answer to the question "what makes a programming language powerful" is really your own definition of "power". I agree with your definition but I'd hasten to add that power is very different from productivity. C++ has a very "powerful" type system because its template sublanguage is Turing complete but it is not a very productive type system. Parametric polymorphism (generics in Java and .NET) are much more productive precisely because they are less "powerful". Specifically, the restrictions they place make errors in generic code far more comprehensible than errors in C++ template code but without sacrificing much useful functionality. If you pursue "power" then you end up with extreme languages like Haskell and Lisp. Laziness by default is very "powerful" because the language takes care of the nitty gritty of evaluation for you and you are free to write declarative code but it is unproductive because that renders time and space consumption unpredictable and real code must often satisfy limitations on both time and space. Lisp-style macros are very powerful because they allow programmers to completely alter the language but they are unproductive because projects that make any serious use of macros are, consequently, written in an obscure dialect of Lisp. In both Lisp and Haskell, power tends to result in awful performance. In fact, I'd say that Lisp is perhaps the most compelling counter example to your assumption that power is good. Lisp macros are often used to Greenspun static type systems and pattern matching. Would you really prefer macros over a language that provides those (very complicated!) features built-in? Another counter example is printf in OCaml. Unlike C and F#, OCaml leverages static type information to optimize calls to printf to invoke the appropriate underlying functions directly instead of dissecting the format string at run-time. This is many times faster. I'd say that power very quickly becomes a purely academic curiosity. I don't want template metaprogramming, non-strict evaluation or macros everywhere. I want the kinds of pragmatic trade-offs that F# provides. I also want OCaml's printf, cross platform, a CodeDOM, a higher-order module system... 
I've never read Venkat's book, but the book on the right (co-written by Odersky himself, and better known as "The Stairway Book") is very good. It tells a gripping tale from start to finish: The Elegant Power of Scala.
The Venkat's book is not bad, but covers Scala 2.7.x Collections where completly redesigned in 2.8, so I would recommend reading the other one first.
Both are awesome (and I'm a HUGE Venkat fan) but I prefer the Odersky book. It's extremely comprehensive.
Programming in Scala is the reference book. It's written by Martin Odersky the main designer of the language and with great co-authors Lex Spoon and Bill Venners. It covers Scala 2.8 where some big and relevant to current (2.9) changes were introduced. Especially the big rewrite of entire collections API. Along with being the reference book, it's not just focused on the language but covers many topics like combinator parsing, actors &amp; concurrency, monadic usage for for expressions, a few but very important functional patterns. It's all around a great book with a dream deck of authors. Unfortunately Venkat Subramaniam's book is both outdated due to pre-2.8 coverage and has a somewhat frustrating inconsistent style. Some chapters are stub-level short even missing important concepts which should definitely be in programming language introduction book. After you finish the stairway book, if want to go deeper and learn how to use Scala with proper functional idioms and increase your depth of knowledge in the language, you should definitely check out Scala in Depth from Joshua Suereth. (http://www.manning.com/suereth/) I finished this book a month ago and still go back and read portions as a refresher. Although I got it from Manning Early Access Program (MEAP) and actually was able to read the chapters as they were written, having the final version handy a year ago would be really awesome. Now I go back to my old code and beautify + harden it. If you are into functional programming, another very promising book is coming from Manning and it's available through MEAP. Functional Programming in Scala by Rúnar Bjarnason, Paul Chiusano, and Tony Morris http://manning.com/bjarnason/
Yes, they are. Unfortunately I also need an implicit parameter to abstract over numeric types, so they currently don't fit the bill because value class are milited to one field.
uhm, i just wanted to say http://24.media.tumblr.com/tumblr_m3f9fdOhLh1qmmqpso2_500.png .. but congratz for discovering D.
Doesn't it get boring to repeat this stuff in basically each and every post about Scala? :-) Did you consider a more efficient and constructive way like contributing patches or writing tickets? I'd be glad to offer any help.
I never understood why people whined about the tool chain. I think people who do that are just using the excuse as a crutch, and are probably never really that productive.
I love theirs weekly scala's updates. Just wanted to add that since they're getting 0 vote points &gt;___&lt;.
I don't know why there are so many downvotes. The job offer is interesting and the company participates to the community via an interesting blog.
Hi runT1ME At each instance, there are around 500 actors running which are distributed across 2 m1 small EC2 instances. Heap memory usage of each JVM average around 400Mb. I have not encounter any problem with the GC as yet. Maybe perhaps because each of the actor are short lived, with an average lifespan of around 5 mins each. Therefore most of the objects would be instantiated on the Eden Space on the heap where GC is faster. Nope, I have not seen an actor stalling as yet because each event only deals with a subset of the data. Therefore the complexity of the operation is significantly reduced and in addition the data structure used to aggregate the data are designed such that the operation would not be too expensive, for example, using a Red Black Tree to store the sorted elements. In addition, all the data needed are local in the Actor. There is no shared memory so therefore eliminating any possibilities of a deadlock due to locking :) 
There is already an alternative to SBT. It is called Maven, and it is the *correct* way to build a project.
Please. Maven is great for dependency resolution but to build anything please use ANT or make (if you don't need cross-platform capabilities). Make is actually very good. Maven is not.
Yes, please, yes. It's 2012, we deserve a build system that's intuitive, makes easy tasks fast to accomplish while keeping Scala's compilation times down to a reasonable level. 
Is this a joke? Maven POMs are strictly declarative, as they should be. They serve as a high-level description of a project and how to build it. Code for actually *performing* a build (or other project-related tasks) goes in plugins, where it should be. Maven has warts, sure (in particular, the XML is far more verbose than it needs to be&amp;mdash;and no, that's not a fault of XML itself), but it is still far superior to any other build/reporting/description/comprehension system I have seen. It keeps the important stuff (what is this project, what is it called, what does it consist of, where are its sources hosted, etc) separated from the boring details (which compiler to use, etc). So no. I've dealt with the likes of Make and Ant, and witnessed the horrors of SBT ("Lol, `&lt;~-`? What the hell is that supposed to mean?"). Fuck that. Project descriptors should *not* be written in general-purpose programming languages, ever. You can pry Maven from my cold, dead fingers.
That must have been a joke. I agree with you on Maven. I don't believe I've ever heard anyone using Make with JVM projects. Every ant project ever has always been a total fucking mess to work with. Ant + Ivy together is the real joke - try to set up unit testing together with ant + ivy and laugh manically as you descend down to insanity. The only build system that seems to not be a fucking joke seems to be leiningen or atleast the people in my company using it have nothing bad to say about it. 
And present real use cases. Overloading and implicit conversions should be considered complementary in this case---trying to put them together this way clearly doesn't make any sense.
Just bullshit blogging amongst programmers who tend to play intellectuals. 
A typical build file can do with the simplified `.sbt` format which for standard cases like assigning values to keys is not much different than XML or JSON, in my opinion. One can argue that `libraryDependencies ++= Seq( ... )` indeed looks less declarative and introduces Scala types. Still, it is very readable and clearly after getting used to it, it is a relief just to keep writing in the same language. Also, the ability to create task dependencies, map values and import plugin settings-keys is very powerful and straight forward. For instance, creating the parameters for the publishing repository by mapping the version information depending on whether you work on a snapshot or a stable version. Show me how you do that in Maven! Clearly you won't want to write a plugin for those cases.
Still you persist in not getting it. I don't know what more I can say to get through to you.
If you *need* to "create task dependencies", you are doing it wrong. Maven got rid of that nonsense years ago and replaced it with the lifecycle system it has now. Task dependencies are an implementation detail that should be left to plugins to figure out. Creating the parameters for the publishing repository based on release vs snapshot is unnecessary in Maven because Maven supports that on its own. I have no problem with switching languages. I *do* have a problem with imperative clutter in what should be a declarative project description.
I still think that's the wrong approach. Rather, writing a plugin to provide custom build behavior should be really easy, in order to minimize the cost of a "plugin all the things" approach. Sadly, Maven misses this mark rather badly, due in my opinion to a combination of very sparse documentation and an API that bends over backwards to fit into their IoC system at the expense of programmer-friendliness. 'Course, Maven isn't written in Scala, which could have helped with the API problems.
Although I posted this link, I am fully satisfied with SBT. It is very simple to use with most simple projects (just drop a basic build.sbt, and it works). The continuous compilation and cross-build is far better than anything I tried before (in any languages). For more complex builds I always found a suitable plugin working out of the box... I don't like the "hieroglyphic" syntax but it is still better than the xml verbous nightmare of maven...
I think you are still missing the point. While SBT is certainly harder to learn than just copying and pasting some xml snippets into POM files, as soon as you have understand the basics of SBT it is trivial to do things Maven people would need to use third-party Maven plugins. In SBT, there is no dichotomy between "users" and "plugin writers". And btw ... there is no "imperative clutter". You are attributing trees. 1st year compiler class. This is as declarative as it can get (for this use case).
The world is not black and white. The thing is that getting things done in SBT is more straightforward, because you can tell it to do what you need to do, instead of hunting for Maven plugins, where basically the plugin author decides what you are supposed to do. Compared to Maven, SBT is a build tool and no religion, which is the only thing I remotely care about. I see that you have made up your mind, and no friendly hint to actually look at stuff can change that. I'm not a big fan of SBT and I don't feel the need to defend stuff neither I nor you care about, so I guess I'm wasting my time here. 
&gt; is a relief just to keep writing in the same language. Uhh, I'd argue it's not the same language at all, it's actually a DSL written in Scala. I'm not in love with Maven the way 'argv_minus_one' is, but I probably hate SBT as much. I just don't think you should have to write a plugin to do something as simple as copying files around during a build... Whereas that would be trivial in ant or maven. 
Last time I tried to package a zip in ant is was literally hell. I needed to find a plugin for that (and people running my build file regularly knocked at the door saying it doesn't work, because ant doesn't manage plugins at all by itself), and then in XML to specify which files should go in the zip was pure pain, etc.---no way, never again. Ant doesn't scale at all to anything beyond trivial. The good thing of sbt is that indeed it provides a continuum from pure declaration to process logic to get stuff done like a customised Zip task.
Is there much reazon to use akka futures instead of the built in ones? 
Nice work. I'm doing a semi-game in android (language learning thing) and I was about to post about the typesafe (reflectionless) object property animator I wrote for my application.
Thanks! Do definitely post about that.
Nice post, didn't know about the object `package` possibility. In the last case, why not just `object Main extends App with yeller.Implicit`?
Was psyched to see this today: "Your Amazon.com order of "Scala in Depth" has shipped!" How nerdy is that!
It's four lines of code in Java as well and pretty much any language I can think of, what's the big deal? Something more idiomatic would be to use pattern matching for regexps in Scala but your code will then be longer and not necessarily clearer than the one you have right now. 
The first line defines a class with 5 read-only fields, along with getter methods, default values, equals, hashcode, and copy method. If you follow the recommended style in java. You will need to write about 30 lines for the same result. Case classes are a language feature. Java lacks a nice syntax to define regex (triple quote) and forces you to double the backslash which results in barely readable expressions for any complex pattern. The pattern matching itself relies on extractors (a language feature) which is idiomatic and similar to what happens in pattern matching. If you want to give a clear and readable name in java to each match, you will need another 5 lines. Finally the option class is part of the Scala standard library, but if you want to do that in Java, you will need to roll your own implementation or import an external library which will throw a couple of more lines.
&gt;params: Map[String, Any] = null I once had a talk with a fellow consultant on a train where he promised to personally strangle every programmer who ever uses null in place of an empty collection.
This has been a problem for me with Scala in general. We're finally getting a Django-&gt;Play transition off the ground, but the lack of quick, functioning examples for people to play with has making it a hard sell. If you're not interested in learning about the language features that make Scala cool just yet, and just want to get a feel for coding, there's not much for people who want to start as beginners. Then you go to StackOverflow and see people trying to define the Scala equivalent to "Pythonic", and the complex, sometimes not even right, answers make eyes glaze over. 
Yes - unfortunately though, I think I may have asked this meta-question in the wrong place. Meta Stack Overflow's users are not a representative subset of StackOverflow's, and many of them will not have any interest in or knowledge of Scala.
This answer is both a joke and also serious. Like the best jokes it has an element of truth. In this case the code works. It's also didactic if you are into hard core functional programming. If you spend some times you can actually follow the answer. The first comment is "+ 1 because lol" and has been upvoted 7 times. So I don't think there is any doubt that the answer is not meant to be funny.
Curiously I find it much harder to read the partially unscrambled text (where there was ambiguity as to what the source word might have been) than the completely scrambled version. I suppose having most of the words correct might make the remaining errors more jarring, because I have to shift into a different mode of processing—i.e. disambiguating over many words rather than just one or two at a time. Additionally the remaining words are now *real words* rather than garbage, so I will initially try to parse the sentence with that real-but-wrong word in place, whereas if it is not a real word to begin with then I will immediately try to unscramble it into something contextually appropriate.
Actually, no your proposed Java solution will not be sufficient. In fact, Java is incapable of expressing a solution as general as the one given. For example, the solution given will operate on binary trees as well as lists (and I omit the enormous number of other possibilities for brevity only). Java is unable to abstract on the type constructor to allow this function to even exist as is. The given solution is satisfactory is all respects -- it is a good challenge to come up with a more suitable solution -- try it. The paper that discusses this further, which Runar did not allude to, is The Essence of the Iterator Pattern. Also, Eric Torreborre has written an entire article on this paper alone using Scala for explanation. It cannot be successfully argued that there is insufficient or inaccessible learning material on this subject. There is a reason to know what "strong lax monoidal functor" means -- that reason is *because it is useful* and not for any other reason. Many Scala users are invited to learn what this means and why it might be useful, but please do not expect pandering. So yes, the language is better and more productive because it can do everything precious Java can do, but significantly better (in this case, more general), quicker and correctly. There is no downside, only complaints such as "you might have to know some stuff" -- deal with it. The "joke" that Runar is referring to, if it is to be called a joke, is that "idiomatic" is non-existent and so can only be dismissed, which is an invitation to substitute for something that does exist, such as applicative programming. This question is less about scaring off "beginners" and more about scaring off those who afraid of suspending disbelief in order to acquire higher understanding. It is in nobody's interest to entertain the illusion that it is beneficial to those afraid to learn to pander to that fear. Unfamiliar subject matter does not "scare off beginners." It scares off "people afraid to explore" -- which is not a great loss anyway. Popularity is overrated -- quality not quantity. 
I'm building a project using play 2.0 and Scala right now. I like the emphasis on type safety. And since the use traits with implicit implementations everywhere (i.e. type classes) its really easy to extend the framework to work with other/your own types. Examples: Extending Anorm to know about UUIDs implicit def rowToUUID: Column[UUID] = Column.nonNull { (value, meta) =&gt; val MetaDataItem(qualified, nullable, clazz) = meta value match { case uuid: UUID =&gt; Right(uuid) case _ =&gt; Left(TypeDoesNotMatch("Cannot convert " + value + ":" + value.asInstanceOf[AnyRef].getClass + " to UUID for column " + qualified)) } } Letting the Form validation library know about Enums def enumFormatter[A &lt;: Enumeration](enum: A): Formatter[A#Value] = new Formatter[A#Value] { override val format = Some("format.enum", Nil) def bind(key: String, data: Map[String, String]): Either[Seq[FormError], A#Value] = stringFormat.bind(key, data).right.flatMap { s =&gt; Exception.allCatch[A#Value].either(enum.withName(s)).left.map(_ =&gt; Seq(FormError(key, "Not one of " + enum.values.mkString("/"), Nil))) } def unbind(key: String, value: A#Value) = Map(key -&gt; value.toString()) } def enum[A &lt;: Enumeration](value: A) = new play.api.data.FieldMapping[A#Value]()(enumFormatter(value)) And this is used everywhere. But at the same time i still feel that the API can be a bit too verbose at times. As an example, here is my implementation of getting a http param (querystring, form). def getParam(req: Request[AnyContent], name: String): Option[String] = req.queryString.get(name).flatMap(_.headOption) .orElse(req.body.asFormUrlEncoded.flatMap(_.get(name).flatMap(_.headOption)) .orElse(req.body.asMultipartFormData.flatMap(_.dataParts.get(name).flatMap(_.headOption)))) In the end i still feel it was a good decision to go with play, especially when you consider the reactive nature and constant space guarantees of Iteratee/Enumerating IO. 
I didn't like it, for a few reasons. First, the template engine is awful. It frequently barfs on what should be perfectly valid code, and you have to guess how to come up with a semantically equivalent alternative that works syntactically, as the error messages you get from the confused template compiler aren't relevant or useful. Second, development mode is so slow it hurts. If I have to wait 5 seconds from hitting refresh to getting a result, I get distracted. And large play projects end up taking closer to 10 seconds every time you make any change. This had very bad effects on our productivity. Third, the documentation for using it from scala is poor, and the community is very java focused. This means simple things like "how do I submit an array/list/whatever through a form are documented in java, not documented in scala, don't work as expected in scala, and nobody can tell you how to do it in scala, you just have to figure it out for yourself (the answer is you have to get the results as a java list and then convert it into a scala list yourself). That's just an example obviously, but that happens constantly when trying to use scala play. We evaluated both lift and play, and everyone preferred lift, although nobody was particularly impressed with either. As a result, we ended up using haskell instead.
No, I don't expect anyone to understand anything. I do expect any software engineer who is interested in professing expertise to understand what monoidal functor means. This is because it is quite elementary, fundamental and useful. If you do not know what monoidal functor means, then you are indeed completely crippled when it comes to software engineering. I don't expect you too believe me, until you do indeed know what monoidal functor means, in which case, it is obvious. Runar's answer is actually quite simply and elementary. You might argue it is above "L3 Scala (Odersky)", but that's yet another problem altogether. If you cannot handle some simple algebra, preferring instead to express irrational resistance, then software engineering is not for you. Alternatively, if you are interested in gaining a thorough understanding of your profession, and do not know what monoidal functor means, you have some work to do. Regardless of your chosen path, the expressed proposal -- that some pandering is required -- is not in the interest of *any party*. The proposal rides under the assumption that it won't "scare beginners off" -- there never was a beginner, only potentially curious minds. You should try teaching this stuff some time. The proposal is an artifact of anxiety neurosis, not rational thought. Finally, replace "monoidal functor" with any of the fundamentals of the profession and it still holds true. 
I see what you did there. 
FYI, "swaggler" is actually "dibblego", aka Tony Morris who's been banned from pretty much every mailing-list in tech circles because of his inability to communicate with fellow humans who disagree with him without insulting them. [Read this to see who you're dealing with](http://comments.gmane.org/gmane.comp.lang.scala.debate/5915) (and note that Odersky himself had to step in to ask him to shut up). He keeps trying different pseudonyms but his inimitable style always gives him away. The #scala channel has even created a game in his honor called ["the dibblego bingo"](http://i.imgur.com/OqehU.png). 
Still doesn't hold a candle to the awesomeness of Java `enum`s. Maybe with macro types…
"who's been banned from pretty much every mailing-list in tech circles" This is simply not true. There was one mailing list whose moderator couldn't stand being corrected in public. Argumentum ad hominem. 
I agree. Java enums are awesome. They are like a micro-DSL — explicitly designed to not suck — embedded into Java. One of the core Java guys — I think it was Josh Bloch — called them one of the better parts of Java. Enums with constructor arguments, implementing methods of an abstract method defined in the enum itself: public enum NumOps { Plus("+") { @Override double apply(double x, double y) { return x + y; } }, Minus("-") { @Override double apply(double x, double y) { return x - y; } }, Mult("*") { @Override double apply(double x, double y) { return x * y; } }, Div("/") { @Override double apply(double x, double y) { return x / y; } }; NumOps(String opName) { this.opName = opName; } private final String opName; abstract double apply(double x, double y); } Pure awesomeness!
There are quite a few more 'scala'-tagged bits, small useful memory-aid chunks. And also a PDF version of the sbt docs: http://www.devdaily.com/scala/scala-sbt-documentation-pdf-file-format
I don't have scala on this system, and I'm still learning. Can you describe why it's better, and what led you to this rather than the code in the blog? Thanks!
I hope you have taken into account Scala's compile time as well?
and VM warm-up. also to put the special case for i = 1 into the function that runs every iteration (in the parallel case) is, erm, suboptimal.
Right, I looked at the gist, the second paragraph is what was missing. Thanks!
Not really; he clearly hasn't written much Scala but his "slow" version still only takes a fraction of a second which for practical purposes is the same as instantaneous. The only major thing he did wrong was to not let the JVM warm up for his time measurement. For a much larger calculation, it would have warmed up so it would still have been very fast.
Would this not be JITed away? Also wouldn't this performance hit be more or less negliable?
Just something I found, which looks very similar to a Haskell library I'm currently working on.
Can you summary that for me? I'm always interested in learning to concurrency paradigms (since I don't think any of the current ones are perfect...) I only have a rudimentary understanding of Haskell's recommended concurrency model... but I do understand how the STM monad works conceptually...
Resistance is futile. You (and especially your functions) will be assimilated.
Get "Scala for the Impatient". It's an awesome book. Make sure you work through the exercises.
Ooh, I read about that one. Right now Im going through the ScalaByExample.pdf thats on the Scala site. Its pretty good so far. Just noticed in my pdf folder I have the free e-book with the first 9 chapters. I'll check it out ASAP.
What are you exactly referring to? Are you saying that there's something wrong with 0 to 10 foreach println ? 0 is an Int. `to` is a method on `RichInt`, so the compiler finds the implicit conversion from `Int` to `RichInt`. `to` takes a single `Int` parameter, 10 in this case (it can also take an additional `step` parameter of type `Int`). Since a `Range` is a collection and `foreach` is a standard method which most Scala collections have, you can use it on the newly-constructed `Range` object. `foreach` takes a single parameter, a function that takes a single `Int` (the return type of the function doesn't matter as it is discarded). Such a function is `println` - it can take a single parameter of type `Int`. So, TLDR: A `Range` (0 to 10) object is constructed, the `foreach` method is called on it with a function parameter, `println`. The code outputs the numbers 0 to 10, each in its own line, to stdout since `println` has side effects. Easy and consistent. There's nothing wrong with `(0 to 10).foreach { num =&gt; println(num) }`, either, if you want some verbosity.
what comment are you replying to ?
Exactly my point: the sooner these features become mainstream, the better.
&gt; Scala is simply superior in almost every aspect Considering the mixed reaction that Scala keeps receiving from Java developers trying it (a lot of people love it, a lot of people hate it), this claim is obviously a big exaggeration. 
I think the constant controversy that surrounds Scala drives a lot more traffic than mundane articles about Java. That's probably the extent that InfoQ "has it with Scala". 
&gt; Are you saying that there's something wrong with 0 to 10 foreach println ? English like hardly is expression this.
It would nice if you would explain your suggested connection between subjective reactions and the quality of the language in more detail. I don't think it is an exaggeration. The language was designed by the guy who wrote the `javac` which you're probably using right now. With that experience and the full awareness of Java's flaws, I don't see a reason why any balls should have been dropped when designing Scala.
Trust me, "Scala for the Impatient" is better for beginners. Stop reading other books until you read this one. The first 9 chapters are indeed available by downloading it from Typesafe. The other chapters are available by buying it from InformIT or by getting a Safari Books subscription. Also, don't buy it from Amazon because I noticed the version published on Amazon has formatting issues. 
&gt;Big companies will always prefer languages like Java. I'm not sure that is the case. Twitter and LinkedIn are both 'bigger' internet companies that seem quite happy with Scala. I don't see it becoming the defacto language at some companies like Unisys or Computer Associates, but are those guys producing good software or basically running the consulting long con with java as a smoke screen? I've certainly been frustrated at Scala in my journey, but I love this quote from Tony Morris: "If you're incapable of using a more proficient programming language, you're not going to be more capable with a less proficient language." &gt;The DSL exposed is an abomination of taste and common-sense. The devs that created it probably have operator fetishism or something, but I've never used an API that's so awful. +1 
Well it seems they are just in the process of putting all sorts of videos online that were all shot during Scala Days back in April; http://www.infoq.com/interviews/walton-scala
&gt; sbt bashing also doesn't add anything to the discussion First of all, sorry for my rant, as I said I love the Scala language. I currently work for a startup and we are migrating pieces of our project over to Scala. These are just my views - I'm a developer that worked a lot with dynamic languages like Python, Ruby and Perl and one thing I saw when working with powerful languages is that the developers need to show restraint. The greatest advantage of the Python language is not the language per-se, but the community that follows a set of consistent rules for designing and coding their libraries. See [PEP 20 - The Zen of Python](http://www.python.org/dev/peps/pep-0020/) I added the rant on SBT because it represents a serious barrier to entry for beginners, while being the symptom of a practice that really needs to stop. Being the de-facto standard, every Scala library has a HOW-TO use with SBT straight in its README. But it gets worse than this - some libraries either don't integrate well with Maven or the integration is undocumented. And I really don't get why this is the case. Maven has flaws but SBT fixes none of its issues, but it's in fact worse. And when beginners get exposed straight off the bat to operators such as "&lt;++=" which aren't used in the standard library or searchable on Google, they either (a) start thinking that Scala sucks and/or (b) start cargo-culting bits and pieces found on the Internet until giving up in frustration. The fact that the Getting Started guide on SBT has 15 pages does say a lot about it and "simple" ain't it. This is regretable because there's lots to learn from other languages and communities. The combination of Bundler, RubyGems.org and Rake is like a summer dream for Ruby developers. Also, SBT was just an example. Other libraries that give me the shivers are the new breed of libraries for building servers based on Akka and async I/O, libraries such as Spray. I'm sure that the internals of Spray are pretty sweet, but when looking at those code samples my eyes bleed and then I start wondering what's the point of all these DSLs, when libraries such as Jasper (JAX-RS) or [Atmosphere](https://github.com/Atmosphere/atmosphere) prove that you can have a nice API by just using plain objects and methods. And Scala is supposed to encourage functional programming. One important trait of functional programming is to allow for better composition of modules. I see it happening within Clojure were to build a web app you use like a dozen libraries that play well with each other. But in Scala the frameworks are monolithic and one reason for this is the emphasis on these DSLs, most of them being inherently non-composable.
The whole process is confusing ... as far as I know, `Try` was added for the new Futures and Promises API, but they changed that API to `Either`. Now there is `Try` with a broken API (`scala.util`) and no real use case in the libraries.
I think you are exaggerating on sbt. I don't think any plain user will come across much more than setting/overwriting (`:=`), adding single (`+=`) or multiple (`++=`) entries, and `+=` and `++=` are operators used across the standard collection library. The sbt documentation has substantially gotten better, for example [the index](https://github.com/harrah/xsbt/wiki/Index) gives you all you need to locate those obscure symbols, should you ever come across them. I personally have never seen or used `&lt;++=`, and the furthest I got was needing to understand mapping using `&lt;&lt;=`, and certainly a beginner doesn't need to deal with these. Also you assume Maven knowledge without remembering that you had to aquire that knowledge at some point. You need to learn at some point what a group or artifact identifier is. Well, in sbt it's `group % artifact % version`. So if such a line is in a README, you should be able to write the appropriate statement for a maven build file dependency? I can't comment on your observation regarding composability of libraries and whether they suffer from DSL usage. Perhaps that's true, I don't know. I think there is an increasing awareness that you should be careful in introducing symbol operators in DSLs.
It's difficult to talk about subversion. The author is just trying to cope with erasures, by using the type system to safely store the missing information. You can have a look at Joshua Bloch's Heterogeneous Container discussion in Effective Java.
sorry I went off the handle with my hating of the already dead horse of erasure. I'm somewhat far into converting to Clojure and the amount of unnecessary waste one needs to satisfy the type system is just sticking out even more than it used to. I won't even go into the concurrency issue provided in that example, immutable data types would have made all that a nonissue. 
Why not a typesafe cache by just parameterizing the class NaiveCache and skip putting the type in the key? Further, if it's a web service cache, wouldn't you just use Map[String, Array[Byte]]? That may be going overboard for your examples though. For thread-safe cache, why not an Akka actor-based cache with an API that uses asks and returns promises? Would make an interesting example I think ;)
do an ls -l in that directory and verify group and other have read permissions on all the right files.
thank you. but as mentioned in the stackoverflow post, I have used scala in many other distributions, and have only encountered this problem in OpenSUSE. Even setting permission 777 on everything still doesn't help to solve the problem.
thank you. I never used SBT before so I followed its tutorial and installed sbt, then discovered that I do not wish to use sbt: I would like to use a scala REPL.
Have you tried any other JVM aside from openjdk? I've had trouble with openjdk in the past. Maybe temporarily install the Sun/Oracle JDK and see?
Hi, did you manage to launch the scala REPL via sbt? It's a useful resource to launch different scala versions repl (as they have project scope) and I thought it would fix your problem easily (but not permanent as you shouldn't experience the problem you reported). For curiosity I found a mavenized solution: http://www.scala-tools.org/mvnsites/maven-scala-plugin/usage_console.html In case you fix your issue it would fantastic if you can post the solution. Best.
Can you try to run scala from your home folder? Uninstall scala package for suse to clean the environment, and download scala from scala-lang.org, then you should be able to run scala without changing permissions. Additionally, can you run 'java -version' or 'javac -version' with no issues? Regarding scala versions repl, I meant there are different versions of scala (2.7, 2.8, 2.9). I apologize for my poor explanation.
thank you. after I did not succeed to run scala REPL in /opt/, I downloaded other scala version (all of 2.9 and latest 2.10 milestone), uncompressed them and ran them from my home folder, the same error occured.
maybe try using dtrace to see what it's doing?
actually, better idea tell me what shells each user runs
Ummm, strange indeed. I'm not an opensuse user, so I cannot test it anyway. If you get scala from here (http://software.opensuse.org/package/scala) I recommend you to contact the package maintener. But before that I'd discard you don't have problems with your java installation. Can you run clojure/groovy/jruby or any other repls for the jvm on your machine? Can you see further messages in your log system (dmesg, /var/log whatever in opensuse) ?
thanks a lot for your help. yes I'm a clojure and groovy user, I can run clojure 1.4 and lein 1.7 (but lein 2 previews don't run on opensuse)... I didn't know that scala is available in opensuse's repo, I'll try to install it by zypper, thank you.
that's very helpful! I did not specify -f, this time I have many more info on sys calls. it produces about 1MB text file haha... now's the time to digg in..
Thanks for everyone's help. I have found the solution: A closer examination of the output of "strace -f scala" as normal user yields an interesting output: [pid 11919] open("/usr/lib64/jvm/java-1.6.0-openjdk-1.6.0/jre/lib/ext/gnome-java-bridge.jar", O_RDONLY) = -1 EACCES (Permission denied) Soon follow that, is the system call to inform user that scala REPL failed to initialize: [pid 11919] write(1, "\nFailed to initialize compiler: "..., 260 The gnome-java-bridge.jar has permission 400, I changed it to 444 and problem is solved!
thanks a lot, this is really helpful. I have figured out the solution by using strace -f!
Opensuse has a bug, a jar file has wrong permission which makes it only readable by root. It's a confirmed bug in opensuse bug tracker.
FYI, `Try` is a specialisation of the `EitherT` transformer with `Option` on top or `OptionT` with `Either` on top. They happen to be isomorphic since, algebraically, 1+a+b == a+1+b == a+b+1, implying that stacking in any order changes nothing -- this is a desirable property when it arises.
This is incredible! Thanks so much for posting. It's great that there is so much contribution like this to the community. Keep it up!
Shut up and take my money! Wait, it's free?
Posted this to learnprogramming. Also signed up. :)
I will be there as well. I taught myself Scala basics, but I'll be curious to see if there are any holes in my knowledge.
Video's are great.
Looks cool. Have you done any benchmarking? I assume this should speed up runtime and slow down compile time a little bit.
Concise and well reasoned. Hits the nail on the head. People should stop wasting effort to optimise while-loops, that's the job of compiler improvements in each incremental Scala version. Write idiomatic code.
There are definitely a few things in scala 2.10 that will raise performance, one of which being value classes. As for on par performance with java, scala is definitely pretty near java in terms of performance. According to alioth, Scala's median performance compared to java is 85% of java's speed. It's absolute worst case performance compared to java is 33% of java's speed. I have a feeling that 2.10 will definitely improve the worst case performance, and I have been working hard on benchmarks that bridge the gap between scala and java in the worst case.
Yes, surely, but I'm mostly interested in making for comprehensions. I'm too tired of this "OMG... PEOPLE NEED TO USE WHILE INSTEAD OF FOR!!!!!!!". :-) I hope that in the future some _very_ limited form of effect analysis and/or better inlining can prevent the need to build so many closure instances in loops. I hope Java 8 makes this stuff at least cheaper.
Anyone who tells you to use while instead of for is a terrible idiot and deserves to be bludgeoned to death. **NEVER PREEMPTIVELY OPTIMIZE!** Only use while if a section of your code definitely needs a speed boost, and only if that speed boost works out to some non-trivial amount of time each time the loop is run (IE: 0.2 seconds), otherwise forget about it. Even then, according to the benchmarks I've done, a recursive loop matches the speed of a while loop exactly, while being safer and useable in functional contexts. 
This is a really poorly designed benchmark. No warmup. Not enough work in the test loop (you really think you can accurately time 0.7 ms?). Elidable work in while loops (compute a sum or something, eh?). No test case for fast work, only object creation which is ~10x more expensive than integer arithmetic (if you test carefully), except in the context of a for loop which is being examined for slowness anyway. Replacing a so-so benchmark (original post) with a lousy one (this post) is not a good way to come to reliable conclusions, especially not when deciding whether to recommend using while loops in some cases. The blog's advice is quite sensible in this regard. (Don't do it routinely; be aware that you can if you need it.) FWIW, with -optimise and a light workload per iteration, for is only about 2x slower than while in 2.9.2.
Indeed, I just found confusing results because `x = new Object()` gets completely optimised away by the JVM under uncontrollable circumstances. E.g. if you add a result variable `res` incremented as `res += x.hashCode` the first while loop may become 100 times slower.
I'm getting around 6 times slower when I replace new Object() with x = k.hashcode(). Also, the for loop is around 2x slower in that case, though I don't know how much that has to do with an increased workload making the for loop cost look tinier.
Your benchmark is too poor to make that conclusion for the reasons I stated. In particular, you can only possibly show that loops are not as slow as someone says if you use an approximately equivalent load within the loop. You replaced addition with object creation--which is elidable as well, I might add--and the latter is ~10-20x slower. (In fact, this is why the blog comes up with its 17x number--one object creation to box the index integer in the for loop vs. no object creations in the while loop.) All I'm looking for is a benchmark of sufficient quality to justify the claims you are making. This is presumably reasonable, since otherwise you could replace your benchmark with a quote from War and Peace or pictures of kittens and it would be equally relevant to your claims. 
&gt;but because I just don't understand the typical C/C++/Java style for loop You don't understand it? What don't you understand about it?
&gt; In particular, you can only possibly show that loops are not as slow as someone says if you use an approximately equivalent load within the loop. With all optimization disabled, I get between 10 - 12x speed loss between for and while for pure math loops. With optimization, that speed loss spikes to 800x faster. With optimization and with the introduction of non-arithmetic workloads, that speed gain is reduced to 6.5x faster. With that under consideration, it becomes painfully obvious that large portions of the while loop being benchmarked are subject to elision when you only load them with math. This becomes even more obvious when you rerun the benchmark and get an average time of 0.09ns per million iterations. My versions of the benchmark, while overly simple, does not allow the loops to be completely optimized away, and that is why it is a better indicator of general loop speed. TL;DR: His benchmark certainly shows a pure math while loop is much faster, but it is not a good benchmark of while loops because the loop is at least partially optimized away. 
You're still doing it wrong in various ways. Here's a framework that is adequate. object ProperBenchmark { // Note: use () =&gt; A to be extra-clear what we are passing on // and what we're evaluating final val N = 100000 final val M = 1000 def time[A](f: () =&gt; A): (A,Long) = { val t0 = System.nanoTime val a = f() (a, System.nanoTime-t0) } @annotation.tailrec def repeat[A](n: Int, a0: A)(f: () =&gt; A): A = { if (n&lt;=0) a0 else repeat(n-1,f())(f) } def whiler = { var i,s = 0 while (i &lt; N) { s ^= i i += 1 } s } def forer = { var s = 0 for (i &lt;- 0 until N) s ^= i s } def bench[A](title: String, a0: A, k: Int)(f: () =&gt; A) { def ns(l: Long) = l/(M.toDouble*k) println("Warming up "+title) repeat(10000,a0)(f) // Warmup println("Warm. Testing.") val ats = Array.fill(100){ time{ () =&gt; repeat(M,a0)(f) } } val times = ats.map(_._2).sorted println("Results for "+title) printf( " %.2f average\n %.2f median\n %.2f minimum (ns/iter)\n", ns(times.sum/times.length), ns(times(times.length/2)), ns(times(0)) ) println } def main(args: Array[String]) { val tasks = List( (whiler _, "While Loop"), (forer _, "For Loop") ) for (i &lt;- 1 to 3; (f,t) &lt;- tasks) bench(t,0,N)(f) } } Compile it with scalac -optimise ProperBenchmark.scala and run it with scala -J-XX:+PrintCompilation ProperBenchmark and believe those runs not interrupted by JIT compilation messages. This gives 0.38 ns/iteration for while and 0.62 for for on my machine (reliably!) with optimization, and 0.38 ns/iteration for while and 1.16 for for without. If I change to a three-layer loop (reducing M to 10 to compensate, and lowering the warmup to 100 so I don't get too bored, and using all three loop variables in math so they can't be elided), I get 0.35 ns/iteration for while and 1.27 ns/iteration for for (~4x slowdown); without optimization the for case is actually 1.05 or so (~3x slowdown). (The slight speedup from 0.38 to 0.35 in the while loop is probably because I typed constants in directly instead of defining final vars in the object.) This is close to the bare minimum you need to do to get anything like sane results out of microbenchmarking. If you don't do at least as much as I did--and the blog came closer than you did to this--then you are unlikely to have numbers that tell you what you want to know. (All results with Scala 2.9.1.final.)
&gt; If you don't do at least as much as I did--and the blog came closer than you did to this--then you are unlikely to have numbers that tell you what you want to know. Actually, if I modify it to use functions that resemble my benchmark functions (no return, generates objects), I easily reproduce my results (while being 6x faster). Also, the same effect I showed in my benchmark happens when you plug in functions that are true to the original post's (no returns, incrementing by one). As in, the while loop is almost completely optimized away. Likewise, plugging your functions into my bench (return values, ^= ) makes my bench get similar results to yours. No, my bench isn't as accurate, but it was never meant to be a very accurate bench, rather a simple demonstration that for is no where near as slow as the blogpost makes it out to be. The fact that I can still reproduce my results with your bench framework indicates that my methodology was no where near as bad as you claim. The big thing your bench showed me is that having the end result of the loop being a return value is a much better guard against the loop being optimized away. That closes the gap between while and for a ton. In any case, we have both proven that the OP's estimate of 17x slower was faulty, and I am glad my estimate of 6x slower does not hold for real use cases, and that while's speed improvement on basic fors is basically a non-issue.
I agree that if you plug silly things into the loops in my tests, you'll get the same nearly-meaningless answers that you do in your test. If you get the same results as I do with your simplified framework when you create a sensibly microbenchmarkable loop, that's great--but since you can't tell from your "simple demonstration" that it's actually true, it's worth the effort to warm up, do multiple trials, and so on, so that you can reasonably assert that your results are meaningful.
This is not a link, but I have chosen Scala for an "Enterprise" level (I hate that word, but what are you gonna do?) site I am developing and it's awesome. My main reasoning was that since it has seamless interaction with Java code you don't give up the massive Java ecosystem. And learning how to write Java-like code in Scala takes about a day. Seriously, if you don't use any of the features of Scala that are not in Java then it's just (very minor) syntax and a few little bits like realizing == and .equals() are reversed. So there are really no downsides to using Scala for a seasoned Java developer. Some people complain about the time to compile, but that is nonsense since any build system that a reasonable person would use does partial compilation anyway. So, given the near lack of risk (obviously I am glossing over the possibility of bugs in the compiler or core libs, but these are pretty few and far between these days) it's a no brainer - coding in Java is foolish if Scala is an option. This is, of course, ignoring that MANY benefits that Scala has to offer which I will let everyone else's links address.
Is he technical? Bruce Eckel's articles are always a good read, with a lot of short code examples of why Scala is so awesome: [Scala: The Static Language that Feels Dynamic](http://www.artima.com/weblogs/viewpost.jsp?thread=328540)
I gave a presentation at work with how much boilerplate scala cuts down on. How it's inter operable with java and all java libraries. And showed them akka. Also mentioned that companies like Twitter use it. He was pretty convinced after that.
I'm using play. I like the fact that it works well with Java as well, and works well with akka. I tried lift for awhile. I like its architecture more then play, but they went WAY overboard with crazy operators and it tends to read like perl.
We use Scalatra http://www.scalatra.org/ which is obviously very similar to the popular lightweight Ruby framework; Sinatra. We chose it because we didn't want something very opinionated. Obviously that has it's drawbacks but overall it's a nice and simple framework to develop with.
This is a very good presentation: http://prezi.com/07yqjyfcotn6/top-10-reasons-java-programs-envy-scala/ 