Thanks for linking those slides. I've seen people mention this correspondence, but never found where it was described. Lovely.
LLVM would be a better choice. Better still if it gets a very good general purpose parser and a VM that can execute the parse tree as mentioned in a prior presentation. In this case this can be converted into other formats also easily. Also Scala compatibility can be maintained at the source level using Scala Virtualized.
&gt; But what’s the use of the delimiting if monads don’t really make your program easier to analyze or safer? In fact, they don’t. If we go by the plain English interpretation of the above, runT1ME's complaint stands up perfectly well, requiring no further investigation, at least by anyone else who's spent any time working with monads.
I love Guy Steele's comment about ["Carl Hewitt's brilliant but impenetrable Ph.D. thesis."](https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CC4QFjAA&amp;url=http%3A%2F%2Fwww.cs.unm.edu%2F~eschulte%2Fclasses%2Fcs550%2Fdata%2Fmiddle-hist-lp.pdf&amp;ei=Gg-FUpvNMYfJiQLguIDAAg&amp;usg=AFQjCNFpLuUZX5Ksbuyc1TYFBLwh5kaeUA&amp;bvm=bv.56343320,d.cGE)
I also wonder what the author would make of [Oaklisp](http://en.wikipedia.org/wiki/Oaklisp).
SBT doesn't mandate blank lines unless you're using simple build files (.sbt files), which you probably don't want except for the simplest projects. Coming from non-JVM land (C++, Haskell) I think SBT is absolutely brilliant. Haven't tried Gradle.
It seems TypeSafe would disagree; they're backing the Eclipse plugin, when they could have supported an IDEA Community Edition plugin instead. I wonder why.
They also back the abomination known as SBT. Typesafe isn't always right.
I work for walmartlabs in San Bruno. We use scala internally for US dot com. Checkout https://github.com/walmartlabs/mupd8
Only 3 down votes here, we may be in Minority but we are gona RULE THE ROOST.
What does *backing* mean? We really should stop thinking less in terms of footbal matches and sports bets, as such mentalities aren't doing us any good. True open-source projects happen organically. Some people thought a Scala plugin for Eclipse would be a good idea. Those people happened to deliver good results and now they are a part of TypeSafe. They believe in Eclipse and thus they continue building on top of Eclipse. However, if you talk to the TypeSafe folks, you'll see how happy they are that IntelliJ is also building that Scala plugin. And you know, it's actually good that both IDEs support Scala. Many people use Eclipse, not all people want or can switch to IntelliJ IDEA. I support IntelliJ IDEA's development by buying their product. I started doing that after they released their community edition with many goodies included. Buying the Ultimate edition is my way of rewarding them. If people like me keep doing that, it means they'll get compensated for their work and thus IntelliJ will thrive. So far they seem to be doing OK. I'm also not interested in footbal.
 WHAT BULLSHIT ADVISE BLOODY BASTARDS JAVA PROGRAMMERS
Wana give more examples without showing Client side ? REALLY YOU SICKOS ?
What the fuck are you talking about? And this title is horrible.
Why don't you go use a different programming language. Perhaps you find one with a similar mindshare.
?? The play framework is very nice. You can debug in the play console and also in the play console you can do invoke scala console to debug. I've done a bit a lift but that was a while back so I don't recall it being as easy to debug as play (hopefully I'm wrong). I deep respect for David Pollak.
what's the point of this post? i guess every scala coder know about this.
there are no other programming languages good enough for me.
This is how they kill good tools and Api's.
-1 because of the title despite the article being interesting...
Can anybody comment on how this differs from [Spark](http://spark.incubator.apache.org/)?
Its BULLSHOT, with no head or tail, and it means you are a moron.
Spark is built on Shark, so it might get getter performance (by leaning more heavily on in-memory caching). More generally, Spark is part of an ecosystem developed by UCB's AMPLab, so it has some other AMPLab-developed software as dependencies. Stratosphere also appears to either borrow or independently implement some of the data flow concepts from Cascading. There appear to be many similarities between the projects, but I wouldn't call that a surprise given the huge number of Hadoop ecosystem projects in the wild today; many of them do basically the same thing but with different syntax or integration options. As an aside, I wonder how long it will be until graphical data flow editors become popular for Hadoop ecosystem projects, ala Max/MSP, Simulink, or more recently NoFlo.
There is a quick weekly round up on the [Cake Solutions blog](http://www.cakesolutions.net/teamblogs/), called "this week in #scala".
I've always meant to look into understanding what the heck is going on with LMS. That post kind of made it half clear for me. Digging a bit further, I think the following is an excellent tutorial understanding step by step _why_ you want LMS and _how_ you would go about using the LMS library to implement an optimised vector multiplication as example: https://github.com/julienrf/lms-tutorial/wiki Basically you allow the succinct definition of algorithms on a type `A` by wrapping that type as `Rep[A]`; the staging mechanism then kind of "compiles" the algorithm down to an efficient form which takes a flat `A`. It kind of reminds me of juggling with `Expr[A]` in Scala macro programming. The overall purpose, as I understand it, is to either just generate optimised code that is as fast as hand-tuned imperative style while still allowing you to write stuff in functional style (`ScalaGenBase` will give you back Scala code), or to target specific processor platforms. Usually you get emitted source code, but there is tool to compile inside the running process, similar to an embedded Scala interpreter.
Oh london. I wish I could be there for the conference. alas, no. I just will have to hope for videos.
AFAIK all of the 4 airports are pretty much the same. It'll take about an hour (give or take a couple of minutes) to get into the city centre, that is King's Cross which is also the area the conference takes place in. I'm staying at a hostel not far from there for 20 pounds a night. If you want your own room and bathroom you're gonna have to pay quite a bit more than that. Generally it might be a bit late now to still get an affordable hotel room in the vicinity.
Thanks for the info, only ever fly into Heathrow or Stanstead. 20 pounds, wow, that's impressive ;-) I need a room/workspace with internet so will go the hotel route, assume at least 80 pounds/night.
Yes, well you can get cheaper than that further out. There was also student accommodation available for less where you'd have a desk and wifi. But you have to book that well in advance. So nothing free before 14th of December.
would be great if it can generate Unit Test code, so that the Unit Test proponents for writing it will be permanently silenced.
Yeah ! And imagine if it could generate a better eclipse plugin specially designed for super programmers.
Change your `evidences` object to this: import UnionTypes._ sealed trait evidencesSuperLow { implicit def toTrdOf3[T &lt;: Req](x: T): Any3[Nothing,Nothing,T] = TrdOf3(x) } object evidencesLow extends evidencesSuperLow { implicit def toSndOf3[T &lt;: Req](x: T): Any3[Nothing,T,Nothing] = SndOf3(x) } object evidences extends evidencesLow { implicit def toFstOf3[T &lt;: Req](x: T): Any3[T,Nothing,Nothing] = FstOf3(x) } You can then rearrange the conversions to control which ones have priority; the last matching one will always be chosen. --- This is almost certainly not a great idea, though. If you have no good reason to impose a specific unambiguous priority order, then it is usually a sign that your conversions' inputs are too broad. Remember that explicit conversions can sometimes be more readable than implicit conversions, depending on the case and the context. Test out any such system and check that you can easily "read" the use-case code without ever referring to more than the doc-comment(s) of the thing(s) you're testing.
Thanks for letting know that you too are an fucking HUMAAAAN, poor remnants of evolution.
Now imagine an DSL for generating Unit Tests. Actually its already being created, that would be a final Nail in the COFFINS of proponents of those retards that force their programmers to write tests; LOSERS !
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: http://www.reddit.com/r/Serendipity/comments/1r1edc/is_it_possible_to_specify_how_to_disambiguate/
Wat
Not really much of a manifesto.... 
Yes but, NOOO!
Proof that you are a sexist asshole
Really, JVM BASED ? Did you notice AOT without a VM ?
See also http://pnwscala.org/schedule/ where this and all the other talks are available. 
[Tiark's thesis(pdf)](http://lampwww.epfl.ch/~rompf/thesis_120716.pdf) is single-handedly the most important document regarding LMS. 
whoops, didn't see that. but I can't find an 'edit' link anywhere here :(
Is ordinary recursion then dysfunctional?
Don't waste your time, see http://www.reddit.com/r/programming/comments/1qjcvy/first_production_release_of_ceylon_language/cde4fhm.
Looking at the code, it seems for Scala practice Scala newbies should be First taught Slick instead of anything else.
The idea was not to produce the most dense and cryptic code like the K or the Python example commentators put. The idea was to introduce a concise and readable way of formalising problems using an elegant logic programming DSL. Imagine you wanted to add another rule, like sum of diagonals.
The only (real) alternative is the Scala plug-in for eclipse. It handles some Scala corner cases a bit better, but Eclipse is such a horrible IDE, that I would rather leave Scala than using Eclipse. I feel more productive with NetBeans and Java than with Eclipse and Scala. But IntelliJ IDEA is a good tool to work with Scala. My dream is that Typesafe would base their Scala IDE on NetBeans. But it is a dream ...
I find [Squeryl](http://squeryl.org) a bit more appealing. At the very least there are no Table[(Int, String, String, String, String, String)] definitions in Squeryl...
 Squeryl was made by the same guy,this is its replacement 
You can just pass the case class instead of that. And then in your projection just do &lt;&gt; and apply unapply
why not use Machine code and write everything in one line then ?
Nice. Did they fix the problems with the generated code size?
They did.
From https://github.com/scala-js/scala-js/issues/4#issuecomment-20937230: &gt; Hello world is now 2.63 KB, and the Reversi is just under the MB with 1,004 KB! But that is from 5 months ago, I'm sure they improved it even further. 
So i guess this will also work with AOT And if they create such an AOT compiler for NaCl, we can use High Performance Scala Apps on Server without a VM. Oh wait , you all are humaaaans, Damn.
LULz Client side Type unsafe Scripting gets 34 Votes, Poor HUMAAAAAANS !
You could do Native SQL instead, why give up so much for two problems ? May be you are a Java programmer actually.
"Scala.js compiles Scala code to JavaScript, allowing you to write your Web application entirely in Scala!" It allows you precisely to write type safe code. Furthermore, it invalidates the only justification of existence for languages such as Kotlin and Ceylon, which in a side-by-side comparison could merely score with their to-js backend. So that is that. 
And now the blog post is deleted.
His post is gone, he may have rethought it.
While it has some nice features, Scala is insanely complex language so one should be careful about what features are introduced. The author illustrates functional features with a `map` method but problem is, its signature is incomprehensible for people who "never written a line of code in their lives". I guess even seasoned programmers who dealt with generics will have trouble understanding it. These problems could be seen in courses taught by Odersky himself. They basically go like this "so, we will be studying a completely different approach to programming, and along the way I'm gonna use all the cool features Scala has - traits, implicits, partial functions so good luck understanding what the hell is going on"
agreed on just about all counts. the REPL in scala is indeed very nice. it makes python's default REPL look awful, positively prehistoric by comparison. but that's not quite a good reason to adopt the language for a CS1 language. 
I had C for CS1, which a lot of students complained about but I think is probably the best choice, since it's possible to understand what's going on down to a hardware level (given a few somewhat unrealistic assumptions these days, i.e. a real-mode single-threaded CPU), but nonetheless a better idea of how computation actually happens. 
The question is whether you really want to start with a language that is at the machine level. Some people feel that way and go so far as to start at assembly. However, many others go to the opposite extreme and start with something completely functional. I think the latter is based on the idea that "Computer Science is no more about computers than astronomy is about telescopes." I think this motion becomes even more true as the nature of computers changes. Does learning to do sequential C close to the machine really help you that much with multicore processors or GPUs? Shouldn't you focus more on solving problems and algorithmic thinking?
The signature of map is complex, but CS1 students never need to see that. They just need to know the concept, which isn't very complex. Map applies a function to every member of a collection and produces a new collection with the results. That isn't really very complex, is it? Comparing a 15 week CS1 course to the 7 week MOOC is a bit misleading. That MOOC was built for people who had significant programming background, most of it being imperative.
I think the second language I learned (by myself) was assembly. That really taught me how the machine... the particular machine (68k) worked. That didn't teach me much about how to think conceptually about structuring thoughts, algorithms and so on. In high school I learned Pascal, that was a bit better at that. While we probably all agree that the more languages you learn the better, the argument of modelling how the computer "really works" is not convincing. More so, because in ten years computers may work very differently. It could be equally or more useful to understand what a virtual machine is, for example.
&gt; Map applies a function to every member of a collection and produces a new collection with the results. That isn't really very complex, is it? Precisely, it is very simple, so why does Scala make it so complex? Just compare the signatures in Haskell and Scala and you will see why Scala is a poor choice for an introductory course of this kind, because it will obfuscate the simple concepts with layers of unnecessary syntax. 
Forget the x-posts, I have given up on /r/programming, it's just a shitty heap of PL wars. If you post "Scala sucks", you get 50 upvotes, if you put your defense, you get downvoted instantly. If put "JavaScript XYZ", you get 100 upvotes straight away. Save your energies. There is /r/ProgrammingLanguages/ which seems not yet to be infested with imbecility.
I'm rather surprised at the anti-scala circle jerk going on in /r/programming over this topic at the moment. So many misinformed posts completely missing the point.
I'm actually wondering if there's a bot downvoting posts there. Every upvote seems to be getting met almost immediately by a downvote, which makes you wonder...
I did a talk at a meetup with a colleague last week called "Just enough rope to hang yourself"; which was about our experiences with Scala. We basically talked about a lot of the mistakes we made with Scala. This is because Scala is a very powerful and not very opinionated language (hence the title). It's incredibly flexible which is a double edged sword. In a world where people seem to demand programmers must be generalists and learn lots of languages; this can paint Scala in a bad way because Scala *isn't easy*. However if you invest some time into learning it, you can be very productive and it is very enjoyable. When I read the post this one is referring to I immediately thought about the lessons we had learnt and how his team has hung itself. He tried to dive in and had a bad experience. 
The concept is easily forgotten unless people use it (i.e. there are some assignments involving it). And they won't understand the signature if they have to look it up.
I think the operators are a valid problem. They make the code almost look like some encrypted text :-) Like (thingy &lt;&lt; "other thing" ~ asd.map( _.toString ) :: List(1, 2))(3) And the compile times could be faster, but when only compiles what is needed it is good enough (a play app on a 2 gen i5 laptop:): [info] Compiling 90 Scala sources and 2 Java sources to /project/target/scala-2.10/classes... [warn] there were 49 feature warnings; re-run with -feature for details [warn] one warning found [success] Total time: 50 s, completed Dec 2, 2013 11:29:50 AM 
&gt; Question things - “The functional way” is not a catch-all argument winner. Leveraging Scala’s power is great but readability is the most important factor in code for us. There's no such thing as generic readability - readability greatly depends on the reader. There's some code that's unreadable for everyone (see: spaghetti code), but a Haskellnik, a Javanik and a C-nik will generally consider very different approaches to be the most readable.
Absolutely. I think over the past few years our "style" has evolved as we have appreciated more of Scala's features. I guess the point I am trying to make is to ensure you spread knowledge of these features through your team by code review, pair programming, etc. 
What's complex about map? Looking at the scala doc for List: def map[B](f: (A) ⇒ B): List[B] And for arrays: def map[B](f: (A) ⇒ B): Array[B] What could be simpler than that? That's all a CS1 student sees. Sure there is a more complex signature underneath which you can uncover by looking at the sources. Why have that signature? It's so that Scala can have one uniform map that works for all collections. If it did not have that, we would have to have many different maps which would be a pain to keep in sync, both for the implementations and the docs. Try this out in any other language and you will find that, you need a map, and an fmap for functors, and then again a pmap for parallel collections, and probably a fourth map for arrays. Which is simpler? Having one map that does the same thing for all collections or having an alphabet soup of specialized maps? I believe designs like these are precisely why Scala is a very suitable language for beginners. 
I'm no scala pro, just taking the coursera classes. To me the difference is Try turns the exception into data. It becomes an object you can pass around, that is, data. Say you were mapping a function that could throw over a collection. It might be better to get back a collection of Successes and Failures. But for the direct case where you're immediately handling an exception, sure try/catch is better and simpler.
Shorter examples using convenience methods on `Try`: val s = "123" val i1: Option[Int] = try { Some(s.toInt) } catch { case ex: NumberFormatException =&gt; None } val i2: Option[Int] = Try(s.toInt).toOption val i3: Int = Try(s.toInt) getOrElse 0
I'm amazed that such an ill-informed blog post flew straight to the top of /r/programming.
&gt;are these people afraid they'll eventually have to learn something new If you ever browse around in the Java sub.. I think that may just very well be the case. Most of the posts in the area boil down to "Don't worry guys, Java is still relevant. No need to update your skills yet!" It is, by far, the most miserable and grumpy programming sub that I've ever found on Reddit. &gt;anti-Scala is trendy right now I haven't been on /r/programming in a long time. Is it specifically Scala hate, or functional programming in general? Cause I see a *ton* of the latter on the web. Hell, at my local Python user group when talking about FP, you'd think that the functional paradigm murdered a child in cold blood the way people were ranting and bitching about it. &gt;"It's all state anyway, so FP is academics blowing smoke up their ass! It doesn't work in the real world." &gt;"You can't accomplish shit in a pure FP language. That's a fact. I mean, some people just go crazy over the idea of it. That said, in some way, I think FP is partly to blame by making itself too hard -- not in the programming or syntax sense, but in the descriptive one. It is *very* laden in Jargon. I personally stalled on my first attempt at Scala when I got to Currying. Jesus Christ, what an absolutely terrible non-descriptive name for what's actually a simple concept. But I didn't realize that in the beginning, and was intimidated away when I didn't understand what the hell it was. It was only later when someone explained it to me in *plain English* that I realized what the hell it was -- and that it was actually something simple. I understand honoring the guy who came up with it by keeping his name, but... I mean, it's about as useless of a term as you can get for someone completely new to this sort of thing. 
&gt; They make the code almost look like some encrypted text :-) Like (thingy &lt;&lt; "other thing" ~ asd.map( _.toString ) :: List(1, 2))(3) Which library is that? &gt; And the compile times could be faster, but when only compiles what is needed it is good enough (a play app on a 2 gen i5 laptop:): https://gist.github.com/jroper/6374383
&gt;There are only two kinds of languages: the ones people complain about and the ones nobody uses. – Bjarne Stroustrup
Hey, do you know if there's an open source implementation of Carbon =&gt; Diamond that doesn't involve gigapascal pressure and 3000 degrees temperature?
[May help](http://tersesystems.com/2012/12/27/error-handling-in-scala/).
You learned how a particular machine worked, but also how machines in general work, because you learned how a real, physical machine worked, not some abstraction of a machine - regardless of the fact that modern computers don't really work that way.
I am specifically thinking about dispatch http lib &lt;:&lt; operator. With &lt;:&lt; you can add headers to your http request and squeryl boolean to query boolean converter: val fls = false ; ... where(s.is_deleted === fls.~.?) Anyway, I don't think it is good that I have to memorize these operators instead of something like addHeader or something. I know that is makes the code shorter and when I learned the meaning it will be easier, I just think, maybe it does not worth it. (I am just a hobby scala programmer) Interestingly I think maybe on Options it would be better to use apply instead of map. Edit: I am using sbt 0.12.2 with play and it has incremental, the compile times are good enough but not "instant". When you are used to something like ruby or php it feels really slow. But you catch type errors, which is nice. :) 
I do but only with the `Failure(e)` case implemented :p
&gt; They're just names, if you have never seen them, they will always look alien. But not all names are the same. Some are more descriptive and seem less alien than others.
&gt; I'm rather surprised at the anti-scala circle jerk going on in /r/programming I'm not. :\ I think it's a similar situation to why and a lot of the default subreddits are dominated by cat pictures and catchy headlines. It's much easier and faster to react to a cat picture or incendiary headline than it is to read an informative, long-form article, so people upvote the former types of things a lot more. /r/programming is dominated (usually) by incendiary headlines and non-programming web-dev stuff. Everyone likes a loaded headline, and all the fluffy web stuff appeals to the large number of people for whom web programming is all they know and all that's accessible to them. I don't want to argue for a snobbier subreddit, but I unsubscribed from /r/programming after the 10th non-programming-related post about this or that CSS web design trick.
I'm not sure if this is appropiate to post here, but I don't have a twitter account to tweet my slides or any other way of making them available. Hope people enjoyed the talk!
Everyone agrees symbolic method names should be used carefully, but definitely it's good to have them in Scala. Martin Odersky mentioned on a current scala-debate thread on the topic of Scala bashing an interesting idea: To require that there be always aliased methods with alphabetical names. I'm not sure whether one should really, from the compiler's side, enforce this. After all, Scala is generally a non-opinionated language, so this just seems a bit like an additional complication of the spec. On the other hand, I could well imagine this as a strong style guide suggestion.
What exactly is the "insight" pane on the right for? It seems to be generating random code that's loosely based on the code I write on the left side.
Theoretically it's supposed to give you information on your code. For example *edited* https://codebrew.io/shmed/0ymyw2GwTPuCDhdoIiZt7w This is a really simple example. It's actually much more powerful than that, but there is still a lot of room for improvement.
The title may be a bit misleading
This post has really knocked my opinion of /r/programming. It's an extremely low quality post which was voted up like crazy.
*This week-end's edition is called 'Scala - 1 Star - would not program again', and it's by someone who from reading his post seems to have written Scala all of two weeks after coming form Javascript. I think the interesting bit is not so much that these posts are written, but that they are upvoted so much.*
Be sure to vote up: https://news.ycombinator.com/item?id=6838836
This looks really cool, thanks for sharing! One small suggestion for improvement: I noted that while I type a function definition, the editor gives me syntax errors because the definition is not yet complete. I would prefer if I could type the line in full before seeing errors. There's an incompleteInputError in Parser which signifies that the error appears at the last character. Maybe that can be used. Alternatively, one could simply mask errors on the last line, as long as the cursor has not left it.
Are there any Browser issues? Because I just see an empty white page. I did allow scripts to run.... I tried Firefox and Safari, no luck. Perhaps the problem is that my OS X 10.6 has client side Java plugin disabled, and I am not able to run Software Update from this machine because of some stupid broken configuration proxy. Also this has Java 6, so maybe that's the problem? --- __Edit:__ It starts in Chrome. This is actually only my Google-can-set-cookies spam browser. Any reasons why it wouldn't work in FF?
Do I need to do something for my script to actually run? EDIT: had to toggle the output pane so that it was visible.
Such suckers.
There is one monthly [Scala news](http://us7.campaign-archive1.com/?u=447751361cefa48e69edd740d&amp;id=79fa3d51ac&amp;e=1356801141). You can subscribe it and monthly new is delivered in the mail box. 
There doesn't seem to be any code in that example.
It should work on Firefox. To be honest we didn't spend that much time yet testing comp abilities between browsers, but we do heavily depend on recent web technologies (css3, websockets, etc.), so there might still be some disparity between browsers. But then again, I have been using it on firefox without issues since the beginning. Also, you don't need Java to run the application, so the problem is probably elsewhere. If you have a minute, we would appreciate if you could fill your bug on github (if you have an account) https://github.com/CodeBrew-io/Issues/issues/new Else, tell me more about the issue and I'll fill it myself! Thanks!
I think there was a good point made in a few comments to Martin Odersky's post that got kind of lost. What we're seeing here is the effect of scala starting to actually get some adoption and moving from being used by enthusiasts on personal projects to the enterprise. More adoption is overall good news. However this also means that there are more and more developers who did not choose scala or the libraries used on the specific scala projects their company is working on. Think of senior developers who are proficient with more than one language and are expecting to pick up the parts of scala they need to do their job on this one project in a few days (like they may have done with Python or Ruby). Having an answer for these developers is important if scala wants to sustain its growth. And "choose simpler libraries" or "use just the parts of scala that you understand" are not a good answer for somebody who did not set the coding conventions or choose the libraries by himself.
Just spoke to people I know at TW and they say the main issue is that they need to be able to "ramp up" really fast when people move from one project to the other. So it's very likely this guy was moved from one project and ended up at this Scala project without any previous Scala experience and he obviously couldn't ramp up at the same speed he did for other tools/languages they use (TW is mostly Java/C#/Ruby with some Clojure/Scala here and here) and then we have the blog post. So, there clearly is a higher bar to get productive with Scala, not something new and I'm not sure if this is something fixable given what the language proposes to do.
&gt; Having an answer for these developers is important if scala wants to sustain its growth. And "choose simpler libraries" or "use just the parts of scala that you understand" are not a good answer for somebody who did not set the coding conventions or choose the libraries by himself. Actually, that is very much an answer in an enterprise setting. The same thing is currently happening with C++11. Developers are being told not to use the crappy parts (often through coding standards), and that for certain projects, certain libraries will be used. Developers then have to lobby for changes to which language features can be used, and which libraries can be used. Java makes it so these decisions don't have to be made, but also makes it so you have to build software a certain way. C++ forces you to make those decisions, but also makes it so you can apply the language to a wide variety of problems. Scala is taking the C++ road, and applying a little restriction to its use would benefit any enterprise using it.
I agree with Martin's comments in general, but it's worth pointing out that the IDEs are emphatically not fixed. The Eclipse plugin is much better than it was when Typesafe took it over, but it's still far behind the Java tooling. My IntelliJ-using colleagues say basically the same thing from their side.
Any support or plans for importing libs? Or at least bundling in the latest Akka? I could imagine this totally replacing Gists for me (at least if I can link them) and as an awesome presentation tool in meet ups. Scala + Akka is currently what I'm into heavily at the moment though so without being able to import akka._ I'm scratching my head thinking of cool things to test drive at the moment. Speaking of, another default lib that would be awesome would be ScalaTest, and ScalaUtils. Oh, and spray-json (all of Spray really). And Dispatch for quick examples. I mean, those things would cover 99% of the library code I use at the day job. Also, any chance of multiple windows? Getting a Ping/Pong Client/Server Akka example going would be really slick.
Oh, totally also need support for setting tab-size. The tab-size 4 is killing me. ;-)
Where is the original post?
http://www.reddit.com/r/programming/comments/1rvltx/scala_1_would_not_program_again/
It's like an assembly line in that regard. You can plug in any worker regardless of skill, but it may be soul crushing in its monotony.
'Soul crushing' for me is that I've yet to have a full time job where I wasn't forced to deal with someone else's mess.
I can't imagine how one comes to believe that programming doesn't require skill, even if it's using a language you don't personally care for. What a fucking joke of an opinion.
This. I started leaning Scala a couple of years ago, and while I agree that it's not easy to grasp at first, I really don't see any more difficult than learning some other programming language. Thanks to it, I read and learned some Haskell, and starting to understand the FP paradigm. However, if there's something I can complain about Scala (well, not the language itself) it's the IDEs. I use Eclipse now, and although it has gotten much better, it still lacks the necessary stuff. I have used IntelliJ in the past, but basically was the same.
I'm all for ignoring the rant! :) Paul's points are very difficult to address though; and Java interop, for all its horrible costs, is a major vector of Scala adoption. That's cold comfort to Paul in the compiler mines, I know, but there's more than one way to view the issue.
You are just wrong. Whatever experts you've met apparently weren't.
I addressed Martin's response [in the earlier thread about the whole controversy](http://www.reddit.com/r/programming/comments/1rvltx/scala_1_would_not_program_again/cdrp7hh), and the bottom line is that I am very much disturbed that Martin thinks the IDE situation is resolved. 
You probably don't realize it but the condescension that you are displaying throughout this entire discussion is disturbing, but what makes me really sad, is that it's quite widespread in the Scala community. Basically, people who write Java code are average developers while Scala developers are great. And anyone who refuses to see the light with Scala is either stupid or feeling threatened that their skills are going to be obsoleted. The Scala community needs to recognize that there is a third category of people who reject Scala: senior, mature professionals who have given Scala a fair shake but who have come to the conclusion that it's not the right tool for their job. Ignore and mock this segment of the developer population at your own risk. 
yep that's a good idea. https://github.com/CodeBrew-io/Issues/issues/1 you should also take alook at scala check :-) (http://www.scalacheck.org/)
I attended both days, and it was good. It was the first conference I've ever been to, so everything was quite new. Everything apart from the content in some of the talks, anyway. As someone who has been programming in Scala for a while now, and reading around the subject, I found some talks were aimed at people with less knowledge than I have. I'm not sure I can complain though. I just picked the wrong talks to attend! All the talks are online now, so I'm going to go through the ones I missed in the next couple of weeks. The second day was much better in that regard, as I went to talks I had no knowledge about, and therefore couldn't help but to learn things. The only downsides to the second day (for me) were the keynotes, as they again covered topics I was familiar with. Still, I enjoyed it overall. I might even sign up for next years this week, to take advantage of the early-early-bird tickets.
&gt; "Why should I sign in to read Quora?" Good question.
People need to stop posting anything from Quora
&gt; Basically, people who write Java code are average developers while Scala developers are great. Are all Java developers this defensive? Or do you not understand the whole point of your language? Again, it's not that all Java developers are average, it's that Java allows you to plug in an average developer and still get results. Because of that, it is much harder to distinguish between average and very good, and the very good developer will require much more effort to distinguish themselves. Compare this to a language like C++, where you will quickly see differences in skill level because it is very easy for the average developer to shoot themselves in the foot. &gt; And anyone who refuses to see the light with Scala is either stupid or feeling threatened that their skills are going to be obsoleted. People think differently. Different languages for different people. But people that say that Scala is bad because it is different are stupid or feeling threatened. Scala is more expressive than Java, and can often write the same program in fewer lines of code. But it also is easier to write unreadable, unmaintainable code because of this expressiveness.
Do you work in anything other than Java?
For those that don't care to sign into Quora, the answer posted basically just refers to these four links: * Quote from James Gosling: http://www.adam-bien.com/roller/abien/entry/java_net_javaone_which_programming * Java language designer Neal Gafter's foreword here: http://www.artima.com/pins1ed/index.html#front1 * JRuby's creator post here: http://blog.headius.com/2009/04/future-part-one.html * Groovy's creator post here: http://macstrac.blogspot.com/2009/04/scala-as-long-term-replacement-for.html
I mostly work in Scala for the past 3 years. I've worked in C++, R, Python, &amp; Javascript and a smattering of odds and ends type of things.
Yes, SBT support is awesome! It's not just for Play like the title makes it sound.
So if you haven't worked in Java, how can you say I'm just wrong?
Believe what you want, but expert code and average code should be similar for the majority of the code base. If you have a complex problem in that code base, then that part of the code base may see some differentiation between an expert and an average coder, but usually only if the "expert" has seen that problem. Most differences in code come from an architecture standpoint, between an average architect and an expert architect, who may have more tools available to them. Part of that toolset is the language. Java limits the architecture. But please, enlighten me in how you think expert code will differ significantly from average code, given similar architectures.
Last time I used IDEA with Scala the worksheets compiled really slow. Has this been fixed yet?
&gt; Are all Java developers this defensive? Or do you not understand the whole point of your language? I find it fascinating that you immediately assumed I'm a Java developer, which proves my point even better than I could have. I've been writing Scala code full time for the past two years (disclaimer: Haskell too). &gt; Scala is more expressive than Java, and can often write the same program in fewer lines of code. But it also is easier to write unreadable, unmaintainable code because of this expressiveness. Totally agree here. 
&gt; Not arguing complex vs simple or suggesting Scala for anything, but do you understand CBF? Yes, I read Martin's paper on the subject when it came out and I reread it again a few months ago (and still learned a few things). It's a great paper which I've been recommending left and right to many coworkers and in many forums. 
&gt; But please, enlighten me in how you think expert code will differ significantly from average code, *given similar architectures*. Move goalposts much? Was it not my point that the difference between expert and average has little to do with irrelevancies like the particular language used? Java, Python, Haskell, Scala, whatever. Expert code will be better *designed*. The chosen architecture will be better. They will both use for(Object x : myList){...}, but one will be more robust, more easily understood, better documented, more maintainable, and more extensible. &gt;Java limits the architecture. Give me a break. 
&gt; I find it fascinating that you immediately assumed I'm a Java developer, which proves my point even better than I could have. You're defending Java. Therefore, for the point of this discussion, it is your language. And one of the original purposes of Java was to make a language that was easier to use than C++. Something essentially idiot proof. But it also brings us to the point of, if you're not writing in Java, then how the hell do you know what it is or is not capable of?
&gt; Expert code will be better designed. Move goalposts much? &gt; They will both use for(Object x : myList){...}, but one will be more robust, more easily understood, better documented, more maintainable, and more extensible. If they're both using the same code, how is one more robust, maintainable, or extensible? Oh right we're talking about design not coding now. Expert code also doesn't mean it immediately has more documentation and is more easily understood. That would be well written code. A lot of documentation in "expert" open source systems is not done by the original coders. &gt; Give me a break. Okay, show me Java code that maps to this: myCollection.map( v: Value =&gt; new OtherValue(v)).foldLeft(0.0)( (v, agg) =&gt; agg + v.value) and show me how it is different than: myAggregator.aggregate(myTransformer.transform(myCollection)) But then, if it didn't limit how you do things, then people wouldn't be clamoring for generics, lambdas, and inventing other languages on the jvm would they?
The second way is called the "Cake Pattern," and it's the usual way to do things in Scala. The most thorough introduction is the [original paper](http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf) co-authored by Odersky. I prefer the cake pattern because it doesn't dictate how and when the implementation is mixed in. I frequently find that I want to define the mix-in traits at a much finer level of granularity than I want to implement them, and for that reason I much prefer the cake pattern. You can split the injected items into small, well-factored units, and then you can inject the implementations using a smaller number of objects that each implement multiple traits. Take a look at the "Hierarchical organization of components" section of Odersky's paper for a concrete example.
&gt; The second way is called the "Cake Pattern," and it's the usual way to do things in Scala. Yeah I've heard of the cake pattern, but every time i see examples it seems way more complicated than normal constructor DI and I haven't really seen a practical benefit. Do you have some code examples of your own? It sounds like you've had some good times with it :) I'll definitely look at the Odersky paper too though. How do you unit test these things? I haven't really seen an easy way to mock traits. Granted you can make a test implementation of your trait, but it means a new implementation per test potentially, as opposed to something like val myDependency = mock[Dependency] val classBeingTested = new Blah(myDependency) it("should do something sensible"){ when(myDependency.whatever(xxxx)).thenReturn(testData) classBeingTested.doit should be(blah) } etc... Thanks for your reply.
I'm not sure I would call the first version DI. After all you might typically want to declare dependencies not just in a strict unidirectional manner. In your first case, `MyTrait` wouldn't be able to require a `Foo`, for example. As soon as you have mutual or circular dependencies, you need something like the Cake pattern (second case). For example you could add the requirement that a `MyTrait` implementation has interface `Foo` present: trait MyTrait { _: Foo =&gt; def say: String def bar = someFooFunction } A disadvantage of Cake AFAIK is that compile times can suffer with large objects with many traits mixed in.
[This talk on the Cake Pattern](http://www.youtube.com/watch?v=yLbdw06tKPQ) by Daniel Spiewak helped me understand what this pattern is for (not just dependency injection, either). He touches on how it works with testing too.
&gt; but every time i see examples it seems way more complicated than normal constructor DI and I haven't really seen a practical benefit. This was my experience. On the Scala project I work on (~20kloc) we started out using constructor DI, then tried out the cake pattern on a couple of modules before switching back to constructor DI. The reasons we switched back were: lots of boilerplate code for all the mixins, a *major* compile-time increase (3-4x at least, for a build that already takes minutes), and no easily-discernible benefits. A couple of things were a little cleaner when we used the cake pattern, but lots and lots of things were more obscure. Maybe the cake pattern is "the usual way to do things in Scala", and maybe if we'd needed to do something more heavy-duty I would have noticed some advantages, but as things were, I didn't find the cake pattern compelling in the least. 
That's generally what we've done, but sometimes I feel we might be missing the point in terms of Scala's features; so I was just curious to see other people's opinions were. 
If you depend on something, take it as an argument. It really does not need to be more complicated than that. If you want to abstract away the plumbing there are all kinds of monads that can do this; the simplest is called Reader. This talk by Rúnar Bjarnason introduces these ideas http://www.youtube.com/watch?v=ZasXwtTRkio 
Mixing in a trait isn't always seen as a traditional OO "is-a" relationship. In many cases it's more like attaching something, like you'd attach a wheel to a bicycle. class Bicycle extends Frame with Shifters with Seat with.... // A bicycle is not a bike seat When a trait has no state, mixing it in is just like importing the symbols into the scope, and the self type is (by very rough analogy) like an assertion that any concrete subclass must import those symbols with certain types. 
&gt; 12 years of experience writing code with it. So you are a java developer. But yet not a java developer. You would rather identify as a scala developer (two years) than a java developer (12 years). Why is that? Also, what made you leave java for scala?
I realize that that's the idea, but I'm not really feeling it. I still see an "is-a" relationship where there shouldn't be one.
It was a great talk *claps* 
Are the slides available somewhere where I don't need to register to get them?
Those who know FP can read FP.
Now imagine compiling that using AOT, Native performance VM. ;-)
"What can we do about it?" Show the Losers the Results, make tons of money, bankrupt them, take them out of Business ;-) btw, beware of corporate kotlin / intellij idea, those Guys dont want Scala to succeed, their shareholders will vote up against Scala for Future Monetary profits PS. Dont be shocked if this comment is deleted from here, they will report me to Reddit mods.
Yeah, the registration requirement is obnoxious. It won't even let me register with a mailinator.com email address. It's too bad, I was interested in the talk.
We use it this way: trait ConcreteComp { lazy val concrete = new Concrete class Concrete { def say = "concrete" } } trait FooComp extends ConcreteComp { lazy val foo = new Foo class Foo { def demo = "Hello, " + concrete.say } } object Main extends App with ConcreteComp { println(foo.demo) //Hello, concrete } trait MockConcreteComp extends ConcreteComp with Mockito { override lazy val concrete = mock[Concrete] } class Test { object Assembly extends FooComp with MockConcreteComp import Assembly._ "test should" in { concrete.say returns "testing" foo.demo mustEqual "Hello, testing" } } 
Do you have the same problem as me, with automatic slide synchronisation of InfoQ being broken since a while? In theory the slides should go along on the right hand side with the video. You open them by hand: http://www.infoq.com/resource/presentations/scala-idris/en/slides/sl1.jpg sl2.jpg etc. Quite annoying
Yeah, I've never seen the slides advance with the video. Thanks for the link to the slide images. I don't have time to go through them manually like that, but it's good to know that you can.
Nice work. Demonstrates the power of matching, actors and routing. Tutorial wise, it would probably help to explain the object vs class, and why events (the case classes) get defined in the object, rather than in the package or in their own files. Coding wise, you can probably use sender in PageParser instead of contructor with an actor ref. As a follow up, you should demonstrate how to test the actors. 
Ha! Got it. It fails with the 'HTTPS Everywhere' plugin. Disabling the plugin brings back the slide markers and flips slides.
For reference, here's a similar argument from years ago, but with Java: http://codemonkeyism.com/never-never-never-use-string-in-java-or-at-least-less-often/
Nice one, thanks for the write-up.
The write up is indeed very nice, but are there any advantages of Scalaz type tag over Scala Value classes ? For instance: case class CustomerId( id: String ) extends AnyVal { override def toString = id } def func(a: CustomerId) = a + " is a CustomerId" def hello() = func(CustomerId("Hello")) // Works! There is less boiler plate and type-safety is also achieved.
Thats exactly what I thought when reading the blog post. Why use an additional library for something that can be achieved easier with plain language Features? Scalas value classes are pretty much the equivalent to Haskells newtype projected into the OO world.
I think the tagging `@@` was discovered by Miles Sabin before Scala got value classes. But I had exactly the same thought when I read the article.
All Strangeloop 2013 slides. https://github.com/strangeloop/StrangeLoop2013/tree/master/slides/sessions
It was and it was. Value classes are almost always a better answer in Scala 2.10+.
http://en.wikipedia.org/wiki/Binary_space_partitioning http://en.wikipedia.org/wiki/Kd_tree http://en.wikipedia.org/wiki/Akka_%28toolkit%29
Why you shouldn't use Futures for concurrency: good luck controlling that. Using futures for concurrency in a cloud environment (read: anemic) where you can't predict user load is a good way to crash. Imagine you're concurrently handling user requests using futures. In order to compute the result, you asynchronously fetch data from S3/Mongo/whatever and process it in Future.map. Fine, easy to read and understand. Now do 1000 of those at once. All of them returning an unknown amount of data and all of them processing at once. You *will* crash. Hello, OutOfMemoryError! Or, even more fun, Linux's memory killer just terminates you and you wind up with no error in your logs. Don't use futures for concurrency. Use actors and pull work. Drop your requests into a queue and let actors ask for work as they're ready. Now, controlling concurrency is as simple as setting the size of the actor router in your config file!
i see, so there is no web element in this example, a fake example. And why post that instead of this ? http://www.infoq.com/presentations/scala-idris
Woah... SPOILER!!! :-)
I would like to see those five grammar documents, though, to get a better idea.
[videos are available](http://skillsmatter.com/event/scala/scala-exchange-2013)
Once upon a time, Odersky [posed a challenge](http://www.scala-lang.org/old/node/1637) claiming that he had written a Scala solution better than any ML solution could possibly be. When I posted my ML solution he stopped responding. Four years later and I'm still waiting for him to provide his superior Scala solution... In this case, I want to know why Brainf*ck was omitted because it clearly trumps all of these other languages on this spectacular metric for language comparison? 
And how long is the F# grammar, Mr Harrop? (ca. 1000 lines)
Given that one of the authors is Aleksandar Prokopec from EPFL, and namespace `scala.collection.par` is used—is this just the "front page" for standard Scala parallel collections, or the factoring out of it into a separate library? ---- __EDIT__: The [Scala Exchange Podcast](http://skillsmatter.com/podcast/scala/macro-based-scala-parallel-collections) explains where Blitz departs from Scala Parallel Collections, beginning at 1:30"
&gt; Once upon a time, BTW, very instructive reading that thread ;)
Yep, they are making this exact mistake where I work.
Super funny video BTW
I want to play too! Here are a few other grammar line size count: 1 12 13 35 302 Answer: 302: Scala 35: Pascal 13: Lisp 12: APL 1: Brainfuck I think this settles once and for all the debate about Scala's complexity. More seriously, this kind of post by the creator of the language is one of the main reasons for the growing anti-Scala sentiment. This "challenge" doesn't feel just defensive and silly, it makes you wonder if Martin actually understands what makes a language complex. 
I think your list is very good, and helps show Odersky's point. Its order is generally right, in that Pascal, Lisp and APL are much simpler than Scala to implement and maintain. Brainfuck, the clear winner, is by far the simplest and easiest to implement and maintain. It also shows that Scala has a lot more features and kitchen sinks than the other languages in the list. In this case, I think the metric "number of lines of the official grammars of the language" is a pretty accurate measure of how simple a language is to implement and maintain, as well as how many kitchen sinks it has.
So? Pascal and Lisp are substantially more simple in terms of their language definitions than Scala. These also happen to be quite _regular_ languages. I think the point Martin wanted to make—besides having fun, an important aspect of Scala IMO ;)—is that all the talk about how impenetrable the syntax of Scala is (people prefer to talk about the syntax than the grammar), and that there is never "one way" to express things, stands in contrast to the actual conciseness of its design. Even if it has a much more advanced type system than for example Java or C#, the rules are rather succinctly expressed. I am looking very forward to the future developments in terms of "dotty" unifying type parameters and type members. Perhaps that even shoves a few lines off the spec?
Thanks! About sender vs. constructor with an actor ref - as I know it's better to avoid using sender inside Futures, good article http://helenaedelson.com/?p=879
&gt; When I said .NET, I meant any of the .NET languages. C#/C#/VB, since I'm restricted to the platform (in the external, business requirement sense), not the languages. F# is a .NET language and it has HM type inference (Scala does not). 
Yes. I started using the ScalaTest plugin yesterday, and on half of the lines in the stack traces, double-clicking on them to go to the line didn't work.
I'm surprised Pascal has so little. It seems about the same as C, but with longer tokens. lisp, I understand... something parens. APL is awesome. J might be even shorter.
Looks like he learned not to feed the trolls just in time. :-)
&gt; Two points to keep in mind: &gt; &gt; 1. The grammars are formatted differently, so don't take this too literally. Up to a factor of two could be due to formatting &gt; &gt; 2. I am aware that grammar size alone is not a very precise measure of language complexity, but it should give a ballpark figure. If people have other measures, it would be great to look at these also. But hey, nothing should stop you from making stuff up about people you don't even know. :-)
While you are at it, lets compare a phone book to the length of "Relativity: The Special and the General Theory" and then make conclusions based on the length of both books which one is more complex :)) 
Booooooooouuuuuuuuu to SKillsmatter for not allowing us to download the videos, MAY they go Bankrupt and be replaced by p2p Tech.
Why not use the Future from within an Actor and Achieve both ?
&gt; 2. I am aware that grammar size alone is not a very precise measure of language complexity, but it should give a ballpark figure. If people have other measures, it would be great to look at these also. 
Is there anywhere one can download the video? I find it remarkable that you can neither download it nor watch it on vimeo (it's marked as private.) And what is it with that website, the owners seem to be aware that it's 2013 and yet they seem to be living in the 90s. EDIT: Turns out [youtube-dl](http://rg3.github.io/youtube-dl/) already supports downloading from pages like that.
I agree with you wholeheartedly. You can download them with [youtube-dl](http://rg3.github.io/youtube-dl/). Just feed it the URL of the page on which there's an embedded video.
As I said in the post, if you want to control database usage, the connection pool is already a great place to do that. Though if your connection pool doesn't handle that (i.e., you are connecting to something with less mature libraries), building one on top of an actor pool is a very reasonable way to go - use Actors to control access to state (in this case, each individual connection). If you wish to limit the number of threads, you can configure this in the dispatcher. http://doc.akka.io/docs/akka/snapshot/scala/dispatchers.html By doing it this way, you've separated *what* you want done from *how* you want it done. You can also do this by playing with actor pools, it just makes your code a bit more convoluted. 
You're missing the point. None of what you've suggested with avoid the problem of trying to do too much work than you can handle. If you use futures for concurrency, you run the risk of trying to do more work than your system can handle. You probably won't notice this locally but go into production on an EC2 m1.medium and you *will* run in to problems. Fetch 30 megs of JSON from S3 asynchronously and do some CPU-intensive processing in the .map() function. Do 100 of those at once and see if you don't crash. If you use actors and pull work you can contain the amount of work done at once.
I agree with you; I would rather use Akka actors as dumb serial execution worker units than spawn futures and overload them. The only difficult thing with this approach would be to decide the actor pool size to ensure you don't overload yourself or are idle most of the time.
I think as long as the actor doesn't accept another work unit before the current one is complete, it would make much more sense to do break down actor tasks and run them asynchronously using futures but not send the response until it's complete. class FooActor extends Actor { def receive = { case (x:FooRequest) =&gt; { sender ! (for { res1 &lt;- future { executeStep1() } res2 &lt;- future { executeStep2() } } yield compute(res1, res2)) } } }
Yeah, that's exactly what I said! The 'def receive' is the defining method of an Actor so I'm suggesting effectively what wot-teh-phuck has demonstrated - though he hasn't shown how the future lets the Actor know its finished, which is where the closure comes in. EDIT: I didn't read wot-teh-phuck's code properly - I'm not suggesting that! I'm suggesting something more like this: def receive = { case (x: Req) =&gt; { future { expensiveOperation() } onComplete { case Success(x) =&gt; self ! x case Failure(err) =&gt; self ! ... } }, ... } EDIT 2: Change sender ! to self ! and move to onComplete EDIT 3: Just point to out, eigenfutz hasn't updated his comment below so I don't know if he still thinks this is bad code or not. Either way, it's code recommended by the Principles of Reactive Programming course on coursera.org, which is given by Martin Odersky, Erik Meijer and Roland Kuhn. Roland Kuhn is the Akka team lead.
Configuring the thread pool limits the number of concurrent requests you will run, same as using a collection of actors. In both cases future requests to be run will be stored as objects - in one case a message in the queue, in the other case as a future waiting to run. Actors don't prevent you from loading too much data from s3. That can happen even in a single threaded system. If you want to ensure that large objects are pulled and immediately processed and gced rather than waiting in an unevaluated future, you can accomplish it pretty straightforwardly: Future { pullFromS3Synchronously.map( myFunc ) } Much the same as you would need to do with an actor. If your thread pool has 10 threads then at most 10 of these will run concurrently. If you fetch asynchronously with actors you run the risk of having N x 30mb objects in your mailbox, same problem as if you asynchronously pulled N x 30mb with futures. 
Oh my. How could I miss that? +1
No, let's compare language grammars with language grammars. Also please note the two points pasted by /u/not_cbeust as background information, before playing the game of troll /u/number__6
i am an Anonymous Fan, that said, but who is to say you are not one of him trying to make yourself MORE FAMOUS?
Actually, looking at the submissions, you are right. There is very little doubt Cynthiaj _is_ Cedric Beust. How embarrassing, is he not ashamed at all? And what is his agenda? ---- __Edit:__ What is also remarkable from those [old threads](http://www.reddit.com/r/programming/comments/e5x14/scala_is_unfit_for_serious_development/): It seems that we have suffered from the nuisance of Jon Harrop (jdh30), Cedric Beust (cynthiaj) and others literally _since years_. I would say, the Scala community deserves at least a price for being very enduring and patient ;) __Edit:__ Shrink my brush
My Scala posts here are DELETED By Over Jealous moderators, most probably by scripting languages fans, so Yes we all are set to take the world by storm.
You can do reactive programming in almost any language, the question is just how expressive it is. I saw a tweet recently pointing out that Smalltalk had "reactive" libraries in the [late 1990s](http://jeffsutherland.org/oopsla98/nakamura.html). Anyway, I agree with you that the buzzing is annoying. Let's hope for a new fad in 2014 which is coming soon :)
LOL. I hope you don't seriously believe that. :-)
Judging by his sock-puppets, blog pimping, love-Scala/hate-Scala posts and apparently writing his own Wikipedia page, I'd say he has no shame whatsoever. Scala does seem to attract more than its fair share of fanatical programming language trolls.
WARNING! BAD CODE ABOVE! Closing over sender() in the receive function will lead to unpredictable behavior. It's such a huge problem that there's an entire SIP dedicated to it: http://docs.scala-lang.org/sips/pending/spores.html
You should use pipeTo if you want to do this, otherwise you just send the entire future back to the sender.
Reminds me of: "Nothing will ever be attempted if all possible objections must first be overcome." — Samuel Johnson 
Eh, what you have against /u/yogthos? It's seem you are painting with a pretty broad brush here.
Argh, sorry about that, it's supposed to say self ! ... - I'll fix it. I'm doing the Principles of Reactive Programming course on coursera.org and they offer this as a good Actor/Future pattern.
I agree. The only recent Scala-related comments I found in his comment history are [two](http://www.reddit.com/r/programming/comments/1s3h8n/streams_vs_collections_whats_the_difference_in/cdtt313) [comments](http://www.reddit.com/r/programming/comments/1qj6et/benchmarking_codswallop_nodejs_v_php/cddwsme) recommending Scala.
&gt; let's compare language grammars with language grammars Why? 
I apologise if this wasn't clear. I was just looking at these first Scala threads that Cedric Beust was posting to, and could immediately make out these different camps. I tried to make the distinction clear by putting a period between the sentences. I just found it remarkable to see that back in the days we already have the same persistent people either "reminding" us that their favourite language also exists or ranting about Scala. In no way did I intend to discredit yogthos, nor any language, be it Clojure, Haskell, or whatever. Indeed I am very sorry for including yogthos in this list, as I can see that he is actually a thoughtful person who is happily using Clojure _and_ Scala, so this was really a faux pas.
Because it is interesting to see how complex the formulations of languages are?
i dont care what you believe, but one thing is for sure, the ERA of MORONS is OVER.
Its so funny to know things before the rest of the programing world hears about them ;-)
This should be very interesting. David Pollak did some good things for Scala, but honestly working with Lift for the short time I did was abysmal. It's interesting that the problems I had with Lift as a framework are largely related to the topics he'll be discussing with Scala in relation to Clojure. Lift tooling? Nonexistent. Lift documentation? Abysmal. Lift stability? Not great. Lift ecosystem? Nonexistent. Lift philosophy? Very sound, and took the best ideas from all frameworks. Play! is a huge leap forward for Scala web frameworks. Lift never really found a voice (unless you work for Foursquare). It will be interesting to see what David does with Clojure.
Well.. Play's "reactive" properties are certainly interesting as a strength as well.
Yea.. if you are implying what you think you are implying, I agree (iteratees / enumeratees being too complicated for the common case). Play is pretty pleasant to use otherwise from my experience.
&gt; David Pollak did some good things for Scala, but honestly working with Lift for the short time I did was abysmal. Yet, Lift was extremely popular and pretty much the only game in town in Scala in that area for quite a while. I wonder if the same fall from grace will soon be happening to Akka, Slick or whatever Scala framework is popular this month. 
This is complete nonsense, the title is link bait; if you actually watch the talk (or were at the _Scala_ conference as I was) David Pollack has: 1) Not moved away from Scala 2) Is still one of the primary contributors to his baby, Lift 3) Has started a consulting company that offers a variety of services, Scala _and_ Clojure backed development included. Actually _watch_ the video and then see if you would describe David Pollack as an "ex-scala" user -- it's an absurd claim.
&gt; Because it is interesting to see how complex the formulations of languages are? What does this metric have to do with the complexity of the formulation of the language? 
&gt; Within my company there is a small anti-scala sentiment and a lot of it is around the perceived complexity of the language; so whilst this rather contrived, it is kinda funny to see this. I'll wager this will be counter-productive because it is obviously flawed in so many ways and people would assume that if a decent argument existed it would have been proposed instead of this. 
&gt; (ca. 1000 lines) &gt; &gt; Where did that number come from? https://research.microsoft.com/en-us/um/cambridge/projects/fsharp/manual/spec.html
&gt; is that all the talk about how impenetrable the syntax of Scala is (people prefer to talk about the syntax than the grammar), ? &gt; and that there is never "one way" to express things, stands in contrast to the actual conciseness of its design. Here's some more data: EBNF Parser Scala 302 3,171 OCaml 395 720 Although Scala's EBNF is shorter than OCaml's its actual parser is several times longer. How does that relflect on "conciseness of design"? &gt; Even if it has a much more advanced type system than for example Java or C#, the rules are rather succinctly expressed. Quantum chromodynamics can also be expressed succintly in a language that few people understand. 
Is Scala's the only grammar that is incomplete in this comparison? For example, `SimpleExpr` refers to the undefined `XmlExpr`. 
Very interesting work. Will definitely look into using this :) I wish they could make Scala's mutable.map faster in general.
&gt; Future { pullFromS3Synchronously.map( myFunc ) } Could you explain how this achieves the goals of getting pulled, processed, and then gc'ed right away? New to scala here, so I'm not totally getting how this line achieves that? 
Strictly speaking, I do not believe that either example is DI. This is a semantic difference between IoC and DI. See Fowler's discussion about DI: http://martinfowler.com/articles/injection.html#FormsOfDependencyInjection There is no separate "Assembler" object in the above examples. However, if you look at this example of "cake", you can see that the "bootstrap" object is intended to act as the "assembler": https://gist.github.com/wfaler/3932552 As long as you are creating maintainable code and your solution fits your case you are doing the right thing.
cool, that was actually a really simple explanation! 
Martin's reply with the solution (to save you a few clicks if you are done guessing): https://groups.google.com/d/msg/scala-debate/fE8w9pi-hbQ/NTUdtSzBQvAJ
They have, scala performance expert Rex Kerr has made a new mutable HashMap implementation that's on par or better than java, it will be a part of Scala 2.11. https://github.com/scala/scala/commit/992b90ebcc8cd3415c288a7258015ec35ed9098e https://github.com/scala/scala/commit/05aedd936e7e7bcf0fa2443abd58b39732f173a9
Good points. I'm not an expert on the subject, so my understanding was just that DI has to to do with mutual dependencies, because otherwise you have plain unidirectional composition.
ERA of MORONS/Programmers is OVER.
Note that jdh30 went back and extensively edited his post after you replied, so unfortunately now your post looks kind of out of place :(.
Yes, I decided to give up on him, he's obsessive and is very creative in producing "facts", half truths and distortions. The only remedy is to ignore him.
I'm a bit confused - did you mean to use *ask* in the below example? Or am I missing something? Your calls to ! return unit, yet you're writing a for comprehension on them? val r1 = fooActor ! request1 val r2 = fooActor ! request2 for { result1 &lt;- r1 result2 &lt;- r2 } yield (combination(result1.asInstanceOf[FooResponse], result2.asInstanceOf[FooResponse]))
Not a syntax feature, but I just want mixins and the ability to make operators generic (i.e. generic math functions). The syntax enhancements listed in that post don't fundamentally make writing C# easier/faster/easier to understand. In fact, I specifically hate the constructor syntax in scala because it's confusing, though it is implied that the "constructor body" is any code written in the class definition itself, which is not something that C# supports. So I doubt it would be as effective.
Probably because many C# programmers come from a Java background or at least learned it, and until you reach delegates, events and lambdas, you're pretty much on Microsoft's Java. 
Late to the party, but I thought that was a pretty interesting talk. Most striking to me was the prospect of leaking memory or filehandles becoming a type error rather than an extremely difficult to figure out runtime error.
Yes, this! Mathematica has been highly original and ahead of the curve on some of these non-standard programming concepts for ages. (Full disclosure: I used to work there.) [Here are two lines of Mathematica code](http://imgur.com/CTgVrpc) that are the tip of the iceberg. The first line is a specific example of what we are calling "non-string-based" programming in this thread. jdh30, I know what you mean about showing people amazing things that point to the possible future of programming, and seeing them somehow shrug it off. I think there is an instinct to think it's all a trick or special cases. IPython is coming along well and I've been both excited to see that community catch on, and frankly shocked that it has taken literally 20 years to happen. I want to take this opportunity to point out that Bridgewater (some hedge fund) has been working on a [Scala version of the IPython notebook](https://github.com/Bridgewater/scala-notebook). I haven't had a good look at it but I think it is promising. I'm interested to hear any opinions from people who have tried it. And I'll also voice my agreement with the last thing you said: there is such exciting scope for really new ideas on touch-based interfaces ... languages that even more non-string-based than Mathematica. There are already languages which, while text-based under the hood, are fully intended to be solely or mainly programmed via some kind of drag and drop interface. E.g. [check out this Modelica "program"](http://simulationresearch.lbl.gov/modelica/releases/latest/help/Buildings.Examples.Hydron1b16ecb3e399659eorageD.png) that is a simulation of the temperature control system in a building.
Has eclipse really "never worked" ? 
Good catch, should have been ?. Will fix when I return to computer.
&gt; Full disclosure: I used to work there Me too. I consulted for them in 2004. :-) &gt; frankly shocked that it has taken literally 20 years to happen Agreed. &gt; I want to take this opportunity to point out that Bridgewater (some hedge fund) has been working on a Scala version of the IPython notebook. I haven't had a good look at it but I think it is promising. I'm interested to hear any opinions from people who have tried it. Interesting. Bayard Rock (another hedge fund) are doing the same thing with F#. There are some challenges though. One of the big advantages of statically typed languages is the ability to do Intellisense but that might not fit well with the out-of-order evaluation that a notebook is capable of. 
IMO, the Scala plugin for Eclipse definitely didn't "work" 3-4 years ago, where it crashed regularly and hanged on simple code examples, as well as other issues including performance. However, the bugs I filed has been fixed since then, and it has continually improved over time, and my impression these days is that it generally does not crash or hang, and that it "works" pretty well in many ways. I don't know why David Pollak thinks it still in 2013 "never worked", though I could imagine it has to do with the performance of the plugin. I have not worked with large Scala projects in Eclipse, and given that both Eclipse and Scala compilation can have issues with performance, it wouldn't surprise me if larger Scala projects in Eclipse can be problematic.
I can see Akka going down if someone else can come up with a Quasar implementation for Scala. Actors based on Quasar (http://blog.paralleluniverse.co/post/49445260575/quasar-pulsar) in Scala would be great.
The question was why you can assign a 64 bit long value to a 32 bit float value—which is a lossy operation, no doubt. This is a property of Java which is likely the reason that Scala behaves the same. I think the remark was whether this should be implicitly possible or requiring an explicit conversion call.
Interestingly, he says that Scala is still the best tool out there. I think the real trouble with "fixing" Scala is building a consensus on what needs to be fixed. I'm reminded of Rich Hickey's talk, "Design, Composition, Performance" where he uses the analogy of musical instruments to demonstrate how well designed limits foster creativity. A Saxophone can't generally play more than one note at a time. A piano cannot alter the volume of a note after it is played. Why isn't there an "any-phone?" Because a good set of limits in a tool allows a performer to master it. Creativity is relative to a set of limits, whether those limits are those of a tool (for a performer) or self-imposed (for a composer, especially in modern classical music). As Paul Phillips says in his talk, "There is no General Purpose." All purposes are specific. But which limits are useful? That is a much harder question. And the difficulty of answering that question is what will likely prevent Scala from being "fixed." From a historical perspective, many people consider Java to be a "fixed" version of C++. Indeed, I am one of them. Odersky is already working on a new language called Dotty that simplifies Scala's type system. There is no silver bullet. Just as the creation of the electric guitar and synthesizer did not eliminate all other instruments, we will always have many programming languages, each with their own elegant aspects and warts that make them better or worse depending on the application.
F# is used as a proving ground for new C# features. Given that both F# and Scala are functional languages, with varying degrees of other ingredients, it really isn't that C# is getting inspired by Scala, it is just moving in a functional direction because of successes in F#.
Out of curiosity, how common or difficult is it for a US citizen to get a temporary or permanent work relocation to London as a software engineer? 
Given most of these are verbatim F# features, in a few cases down to the syntax, that is vastly more likely than them borrowing from Scala. F# might borrow from scala, but honestly, it's more likely they are borrowing from a common root (Haskell, ML). Nothing in Scala is particularly unique or innovative as far as I know, basically every feature (singleton syntax aside) both abstractly and by syntax has a near identical realization somewhere else (usually ML or Haskell, but there's some other stuff). Admittedly things like patterns have been adapted to the JVM and Java, but there's still a clear lineage on where the idea came from.
C# will never get mixins since they replicate the behavior with extension methods. I would be curious what about mixins you want that extension methods don't have, and no cheating and violating encapsulation (ala friend functions). For the most part I am mildly annoyed by these changes, they seem superflous, although ?. has been bandied about for a long time as something people want.
Or a Canadian, for that matter?
Oh, Yeah.... I dunno, feels like you would rapidly be able to end up violating LSP. In general that's the issue (or the one I run into), when I sit down and analyze "how do I add this field safely," the answer is "you can't." Although, yes I am certain there are times when that would be desirable (and why there's such a debate on extension properties).
Fun stuff
I have not looked at Kotlin, but Ceylon certainly looks like a non-starter.
Why would one want to move from Canada to UK, I'm curious? Not that there's anything wrong with UK, but being european myself I guess I have an idealized view of Canada.
I guess if you already have an offer from a company willing to go through the paperwork, not that hard. 
Indeed. The emperor has no clothes!
Most developers using Scala use IntelliJ, so it wouldn't make much difference either way.
&gt; Most developers using Scala use IntelliJ Do you have a source for this? Where I work, we're evenly split, and the couple of times the question has come up at my local Scala users' group, neither IDE was used by a big majority. But who knows. For the record, I use Eclipse, which kind of sucks for Scala. My colleagues who use IntelliJ report similarly annoying, but different problems.
&gt; I have not worked with large Scala projects in Eclipse This may be why you haven't seen many problems. The Scala project on work on most often isn't big, but it has tens of thousands of LOC, split into 18 modules. Sometimes, Eclipse/ScalaIDE works great, other times it goes comepletely off the rails. Yesterday, on one of my work computers, Eclipse just went nuts, compiling the world (regardless of actual code dependencies) on every save, blocking the UI for tens of seconds if not minutes. This is on a high-end i7 with an SSD and 16GB of ram. When I write to the scala-ide-user list with problems, I usually get some version of "works for me" from the devs in response. My IntelliJ-using colleagues have similar problems, just different ones. The Eclipse plugin, and IDE support for Scala generally, is *much* better than it was when Typesafe took over ScalaIDE two years ago. But I'm with David Pollak; things definitely don't "work" currently.
&gt; Has eclipse really "never worked" ? Yes. It's *much* better since Typesafe took over ScalaIDE a couple of years ago, but the situation is still not very good.
Using macros and implicit validation functions for this is a mistake. You can do this better by using Scalaz's Applicative/ApplicativeBuilder and regular validation functions. Macros should almost never be used.
"What Java calls dependency injection in other languages is known as passing variables"
I don't quite understand why things like this are necessary. Isn't the whole point of the type system to enforce constraints that accord provides? Isn't it the case that if you set up your types properly and use the proper combinators to combine your data then the enforcement of the constraints falls out for free from the design of the library?
The main question is: why would a company offer to go through the paperwork? Let's assume I apply to a US job from UK, won't it make more sense for them to just find someone from US (i.e. with US work permit) as opposed to taking the trouble of moving me there?
That's true of you apply for a job at Walmart, but for a job as a software engineer for example each applicant is different so they may want to hire you specifically. Plus if the salary is high enough the legal fees become marginal compared to the money the company invests in the hire. That's often the case in Silicon Valley, where companies are used to hire foreigners they sponsor for a visa. 
Scalaz should ~~almost~~ never be used.
I'll look at this later, but if you want feeds of scala, there's also pinboard and delicious (pretty low volume now) https://delicious.com/tag/scala/recent https://pinboard.in/t:scala
You can do that with a `FirstName` value class whose constructor throws an exception if the wrapped string is empty.
Which is exactly the same kind of validation, just informally / poor-man's. You can generally live a life based on `require(...)` and not use validation libraries.
What is the problem with using macros in this case?
A string that enters the program at run time can never be checked at compile time, because it doesn't exist yet.
1. Fix formatting. To get code to be displayed on Reddit as code, all lines have to be indented by at least 4 spaces. 2. Use Eclipse's/IDEA's autoformat (Alt-Shift-F in Eclipse, Alt-Shift-K in IDEA) so you know what is contained in what. Also, what Martin said. 
Sure, for some things you need dependent types and pretty much a full on theorem prover but for many other things you should rely on the type system as much as possible and design the abstractions in a way that guide the user to use them properly to enforce whatever invariants you want enforced. The problem I see with libraries like accord is that they encourage sloppy programming and not fully leveraging the existing type system to enforce the constraints whereas the opposite should be true. If you have a type system as powerful as Scala's then you can push it pretty far before things like accord become necessary.
Good to know. I guess the situation is different with niche technologies/languages like Scala/Clojure because I have had little luck with making a switch using Java.
Pollak , LULz, the guy who tried his best to Screw Scala using inside Job.
I'd suggest taking a look at the official documentation, which includes a nice tour of the language as well as a tutorial specifically geared for people coming from Java http://docs.scala-lang.org/tutorials/ Twitter's [Scala School](http://twitter.github.io/scala_school/), also linked in the sidebar is a great resource from my experience.
I took this course by Martin Odersky (creator of scala): https://www.coursera.org/course/progfun It's a great start to both scala and functional programming
I like to think of typeclasses as "programming with types". That is, defining a typeclass (i.e. the trait) is like saying "this is some property that might be true of some type", and defining the implicit object is like saying "this property is true for this type". And since you can use implicit methods instead of / in addition to implicit objects, so you can do all kinds of fancy "if the property is true of THIS type, then I can tell the compiler to infer it for THAT type", which is pretty awesome.
Only really tested under chrome and firefox. There are some odd bugs with firefox that go away after refreshes (???), and it doesn't work under IE or similar, but that's more just from lack of time*effort spent on compatibility rather than any inherent properties of ScalaJS. Not perfect, but probably already much further than what most people think is possible using ScalaJs. Work in Progress!
A few points to consider: 1. The Accord transformation macro does exactly two things: it enables one to write a block of validation rules in a straightforward syntax, and wraps them in a single And(...) rule (so you don't have to write p.firstName is notEmpty and p.lastName is notEmpty and... which becomes unwieldy very quickly). Second, it adds descriptions to expressions at compile time, so that a violation on "p.firstName" can then be described at runtime as "firstName" without having to specify any strings or use reflection. You can't do either without some sort of compile-time AST transformation/introspection. 2. Macros can provide perfectly legible error messages as long as you actually use the abort() error/logging facilities you're provided with. 3. Macros (and especially def macros, which is the flavor used) are here to stay. They're experimental because Typesafe aren't comfortable declaring the current API as stable, not because they might decide "hey, this was a bad idea". I'm fine with having to rewrite the transformation for future versions of Scala given the amount of power this gives me at the library level. Finally, what exactly do you mean by "don't compose well"? 
You can, but validation is typically used where objects are constructed dynamically or on-the-fly (e.g. DTOs), and you want to accumulate and expose errors as opposed to fail-fast via exceptions. You can't really validate an object graph where nodes can't be constructed because they throw (via `require`) in the constructor body.
Nice from what I can see for the first four seconds, but then it crashes Firefox unfortunately (in the JavaScript garbage collector, woops) :-( __Edit__ When I started interacting in time, it works. Nice!
I would love to hear more... As a scala developer who actually doesn't know much java-- this would be a swell way to get into android land.
This was tweeted recently: https://github.com/pkukielka/stronghold-defense Admittedly I only tried to run it on the desktop and commented out the Android stuff, because I didn't have an Android SDK installed. So I don't know which Android version it targets. I had to make the following two adjustments: Add sbt version to `project/build.properties`: sbt.version=0.12.4 And also got a compilation error, probably due to a change in the libgdx snapshot. The following helped: --- a/common/src/main/scala/com/pkukielka/stronghold/StrongholdDefense.scala +++ b/common/src/main/scala/com/pkukielka/stronghold/StrongholdDefense.scala @@ -48,7 +48,7 @@ class StrongholdDefense extends Game { if (!isLoaded) { if (Assets.update()) { - animationManager = new AnimationManager(renderer.getSpriteBatch, camera, map, "test") + animationManager = new AnimationManager(renderer.getSpriteBatch .asInstanceOf[SpriteBatch], camera, map, "test") val inputCamController = new InputCamController(camera) val gestureCamController = new GestureDetector(new GestureCamController(camera, animationManager.hit)) 
It target API Level 8, which is 2.2 Froyo, which is fine for this game, because the android part consists of only one class which initiates the libgdx class. I want to do general Android stuff with the newer 4.xx versions.
It would be great if android app was an option in typesafe activator. I too suffered from what you did and gave up on trying. 
Okay, the first build failed. I made the two changes that you suggested, it now crashes with this error [error] Android SDK not found. You might need to set ANDROID_SDK_HOME or ANDROID_SDK_ROOT or ANDROID_HOME [error] Use 'last' for the full log. I have encountered this error multiple times with the other tutorials that I tried! `echo $ANDROID_HOME` does return the path to my SDK, so it should have worked.
Sorry, as I said, I didn't try that, just ran the game on the desktop. But I am sure if you ping the author, he will be able to help, the project was just recently updated.
I also tried the Maven template. `mvn clean package` stops with this error [ERROR] Failed to execute goal com.jayway.maven.plugins.android.generation2:android- maven-plugin:3.7.0:generate-sources (default-generate-sources) on project hello-scaloid- maven: Execution default-generate-sources of goal com.jayway.maven.plugins.android.generation2:android-maven-plugin:3.7.0:generate- sources failed: A required class was missing while executing com.jayway.maven.plugins.android.generation2:android-maven-plugin:3.7.0:generate- sources: Lorg/sonatype/aether/RepositorySystem; I have Maven3 installed, per the prerequisite $ mvn -v Apache Maven 3.1.0 (893ca28a1da9d5f51ac03827af98bb730128f9f2; 2013-06-27 21:15:32-0500) Maven home: /usr/share/maven3 Java version: 1.7.0_25, vendor: Oracle Corporation Java home: /usr/lib/jvm/java-7-openjdk-amd64/jre Default locale: en_US, platform encoding: UTF-8 OS name: "linux", version: "3.11.0-14-generic", arch: "amd64", family: "unix" EDIT: So I found this https://code.google.com/p/maven-android-plugin/issues/detail?id=395 It says that it is a bug in 3.1.0, and to install 3.0.5 . I'll try that.
sometimes you need to define several iirc (all my android work is fuzzy). Try pointing ANDROID_SDK_HOME to the same location (or go for all four). Scaloid looks good, but I also need the compat libraries to consider it for full android dev (targeting android 2.3 and modern devices) see [the roadmap](https://github.com/pocorall/scaloid/wiki/Appendix#roadmap). I really want to use since it gets rid of all that annoying layout xml with super simple functions.
There is a lot to learn in Android. You would save a lot of time learning Android first and then learning how something like Scaloid saves you a lot of time and typing.
Here's an Activator template for Android: http://typesafe.com/activator/template/hello-scaloid
what about setenv?
I assume that's a command to set environment variable? Terminal says "command not found"
Sweet! Nice one
... why would you use Play Framework just to serve JSON data? Play is such a heavy ass framework for that. You can use Spray but it's not really stable and fragmented. But I'm sure there are other modular and smaller framework for it. Hell, I'd do it erlang if it's just a restful service. There are a few REST service framework in erlang and they're pretty lightweight. edit: Well at least I have an example of JSONP for play if I ever need it. 
I'm not disagreeing. I'm just making a philosophical argument more than anything. I'm trying to make the case for designing the program with the type system in mind so you get the most bang for your buck and only later layering the validation code instead of relying on the validation code from the beginning.
We looked at several options when picking a tech stack (Erlang was not among them although I have always been interested in trying it out.) Our reasons for choosing Play! are a few fold: 1) We wanted something that was good a async, while Play! and Scala are certainly not the only options for this, having Akka baked in was a big plus for us. 2) We wanted something mature but modern. Play! is not totally stable but it is a lot more so than many "trendy" technologies. Being able to upgrade versions without going crazy is nice. 3) The collection library is Scala is amazing, easily one of it's best traits, and this was very important to us. 4) Decent JSON support. Although it is nowhere near as good as Node, or even PHP or Python, Play! has the best JSON support we have encountered in the Scala ecosystem. Play! certainly was not the only option for a JSON backend, but it is far from the worst. I assume when you say it is "heavy" you mean performance overhead. While it does have more overhead than Spray it is still faster than things like Sinatra or Flask, which would be the big competitors (I never much cared for Scalatra although I suppose I could be convinced.) P.S. I actually didn't cover JSONP in this post, although I might write one about JSONP in the future.
spray-json is one of my favorites, and it mixes wonderfully wth the spray.io (non)framework :)
I might have to check that out. When I start this project Spray didn't look very mature, but maybe it is time I gave it another chance.
I've been using [pfn/android-sdk-plugin](https://github.com/pfn/android-sdk-plugin) with much success; I also troll #scala on IRC, and pfn actually hangs out there and (sometimes) offers help to noobs. The one great problem with building Android apps in Scala, or Clojure, or Python, or whatever language, is that you need to know how to build an Android app the _normal_ way, e.i. Java, first, since all the Android libraries are written in Java and must be interacted with just how you would in Java, regardless of the language you throw on top. I would not have been able to build an Android app in Scala if I hadn't already built one in Java.
[Unfiltered](http://unfiltered.databinder.net/Unfiltered.html) would have been a good alternative. It doesn't prevent you from using play-json nor Akka.
I can't find any reference to exactly when it will happen, but the akka/spray integration press release does mention that spray-can is going to be available as an alternative to jetty server in play at some point (as akka-http). I think the acquisition of the spray project will propel its popularity and stability by leaps and bounds. I can't wait to see it. EDIT: As a side note, akka with spray-can seems like an awesome lightweight stack for a REST API.
Shameless plug: if anyone will be at the upcoming CodeMash in about 3 weeks, I'll be giving a talk on this topic.
Nathan Dotz? =) Do they put up the vid online, for people who can't travel to Ohio?
Interesting, I'll try to download it and build from scratch today, and upgrade code where necessary. Thanks!
Spray's actually been production quality a lot longer than most frameworks its age. I first started using it on the job in April of 2011, and at no point did it seem not up to the tasks I was throwing at it.
Yea, I don't know what the video situation will be like, but I imagine if it's there it will be InfoQ
We looked at Unfiltered. It is extremely different than what many backend developers are used to. Additionally we ended up making use of a wide range of the functionality of Play!: play-json, iteratees, web request stuff, the router and the mvc stuff (well mc in our case, we have no views). The biggest parts that we didn't utilize was the templating library, we are even working on some new functionality using web sockets. Edit: Or the asset pipeline stuff, we are not using that either.
Yes - easy to migrate, and yes, lots of Jr. positions. Feel free to ping me at ben.rogan@oxfordknight.co.uk and i'll see if I can help you out! 
Typo here: C[T'] is a subclass of [T] should be C[T'] is a subclass of C[T]
http://ktoso.github.io/scala-types-of-types/#unified-type-system-any-anyref-anyval case classes don't extend AnyVal
Sorry, I just did assume you were on Linux. Have you found a solution? 
Yup, thanks for pointing that out! Fixed. It's still very much work in progress, seems the site "boomed the internets" a bit early :-)
Or, perhaps a simpler solution would be to make sure you don't type broken email addresses in to your code! Seems like serious overkill ...
I wonder what email validation he uses? Email validation is notoriously hard - to do it "properly" you need something like [this](http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address/1917982#1917982)! I'd also like to know what the impact is on compilation speed of checking this sort of thing at compile time. Still, I guess the goal was to show the method. It might have been better to demonstrate it with something a bit more realistic though.
That's with regexs which is a really dumb way to check it. In practice not all tools in the mail infrastructure support the complete spec so "it looks right" is good enough. 
What's really awesome about this is you could pass in the domain to javas InetAddress for compile time domain checking as well! Very cool link predef thanks!
&gt; I'd also like to know what the impact is on compilation speed of checking this sort of thing at compile time. One thing that should be noted is that this, for obvious reasons, only works with literals, and so in probably most cases you won't have e-mail literals but read them as strings from somewhere, so you will need runtime verification. As you said, I think it was probably just used as a case to demonstrate the general idea of macros.
It's nice to see some macros in action but the examples (validation of email address or file existence) are a bit silly: if you have an email address at compile time, you already know whether it's valid or not, and as for the existence of a file, just because it exists on the file system at compile time doesn't mean it will be there at runtime, so it's really an example where you should *not* use macros. 
My thoughts exactly. There are definitely better examples out there. One I heard at the Scala eXchange was printf (or String#format) where the macro would check if you pass in the correct types at compile time. I.e. floats for %f, strings for %s etc.
I do like the `printf` example a lot better.
I agree. I've been waiting for this book for a long time, and I'm interested in buying it. Does anyone have any personal experience or links to good, **actual** reviews?
Well, I think it's a very good book. It will be challenging if you're new to FP, and very helpful if you understand FP but not the quirks of encoding familiar structures in Scala. You can download a sample here http://manning.com/bjarnason/ and if you want to purchase today, it's half off with code dotd1223 (as explained on the Manning homepage).
simultaneously the most challenging and rewarding book on programming I've *ever* read. 
I happen to agree with you on all of those points. I also think the book does an excellent job of selling functional programming. I also actually didn't mean to come across as hating on Scala in the review. Perhaps that came across a bit more heavy-handed than intended. I wanted to highlight the difference between the perspective of Paul and Rúnar on functional programming compared to the "object-functional" views that are put forth by other members of the community. That necessitated me descending into a description of why there is a problem. My view is that Scala may not be the best language for doing functional programming, yes. That said, it is still in many ways the best option for doing functional programming when you are constrained to work on the JVM.
I like books I can skim through while riding the train home, or at night before sleeping. This book requires you do the exercises. If you like that, it might be a great book. Since I didn't want to do the exercises, I found the book unsatisfying.
I use scala for data/ Machine learning work. I agree that the language itself is well-applied to the field, I am less enthused about the selection of available libraries.
I didn't do most of the exercises. I did read it multiple times, and supplement with some good blog posts. 
voted down for mentioning SBT
&gt; I also actually didn't mean to come across as hating on Scala in the review. Then why do you keep doing it? In the past, relations between the Scala and the Haskell community have been very good with an respectful, excellent exchange of ideas. Things have become considerably worse in the last few months and I think a large part of that comes from the way you treat people using Scala. These people are not all just idiots needing to be reeducated because they value some things differently from the way you would like them to. Can we go back to a more constrcutive dialog and concentrate on bigger issues again, please? Bashing Scala doesn't mean more people using Haskell, it means more people which will keep using Java, JavaScript, PHP and friends. Loss for everyone involved.
Nothing I said in that post or in my other writings has ever been intended to disparage the _users_ of the language. If I came across as condescending, that was not my intent. I happen to believe it is possible to disagree with someone without believing that they are stupid. However, I do think there is room to talk about what languages features work well together and which do not objectively rather than throwing up our hands and saying it's all puppies and rainbows. There are aspects of Scala I like. There is the omnipresent ability to interoperate with the JVM. I'm actually a much bigger fan of subtyping than the rest of the scalaz types. The new macros are quite interesting. I'm impressed by the work on tagging. There are aspects of Haskell I dislike. Fine grained class hierarchies are actually more difficult to scale than in any other language with multiple inheritance. There are things in Haskell that make it hard for library authors to balance between support for pre-existing libraries of making users supply orphan instances. The aspects of Scala I happen to dislike make _functional programming_ in Scala difficult to sell. The combination of language features that are present, which are made present to serve perfectly legitimate needs for other purposes, tends to make functional programming in Scala hard to make scale up. The decisions here are perfectly rational given the other pressures on the ecosystem. No language is perfect. Scala is a perfectly good programming language. It is a much better Java. If you have to work on the JVM it is hands down the best thing we've got. I actually write a significant portion of the code I write today in Scala because of these advantages. There is a difference between that and selling it for pure functional programming. Scala may be a perfectly good programming language, but that isn't to say it is a perfect programming language, no language is. Monads in Scala are forced to be either slow via trampolining or they don't scale. The whys and wherefores of this situation are a simple consequence of perfectly rational decisions about what scenarios scala can support tail call optimization. I happen to think that Scala probably has chosen the right path in this regards given the other pressures on the language. Does Scala have to be good at Monads? Perhaps not, but scalaz puts them pretty much front and center, so it being bad at them reflects poorly on their use in FP. People take away that FP only works for small toy examples, and that pains me. Haskell on the other hand is pretty darn bad at FFI. The whys and wherefores of this largely center on how it deals with the stack, the difficulties of talking to C++ libraries from other languages, etc. Scala is a perfectly good programming language. I just don't think it is a very good _functional_ programming language. For that matter, I don't happen to think Haskell makes a good systems programming language, and I don't happen to like doing web development in C++. YMMV.
seems like only Mobile users should read the article. what an stupid layout they have.
I use macros to generate typesafe css for scala.js
I think there already is one, but object compatibility seems limited. http://cran.r-project.org/web/packages/jvmr/index.html
jiva-ng and encog probably.
The “Registering a URL Scheme” part could use the `-i` switch of `sed`.
I happen to believe that many of the classes should be covariant. trait Monad[F[+_]] extends ... We've gone back and forth trying to make this work better in the past. It has the benefit of removing many many type annotations from user code. However, there are some stumbling blocks that have led to us rolling it back each time we've attempted it, due to some complexities in and around `Free`/`Trampoline`. Inference works better in my experence, but it also takes many of the classes farther from their Haskell roots, and the types become more complex looking, because you have to use a lot of bounded polymorphism.
Those who voted this master piece down, consider them DOOMED. :-)
This is wonderful.
The link to the raw data is at the end. &gt; Sign in to continue to Google Drive Anyone know how to review this _without_ having a Google account?
[jsFiddle link](http://jsfiddle.net/LeLzZ/); look at the bottom right pane.
I have write 2 apps for my company in Scala, and Scala is not widely used in China. It is just much better than Java, and I am trying to use RxScala the next time. But by all means you cannot write fully functional style code. It is just client side developing... haha About dependency... use sbt-idea for android branch, https://github.com/molikto/android-plugin and this android-plugin works for sbt 0.13, I usually use sbt 0.13... And API level 19 seems broken with scala now. So I use sdk version 18... I am pretty sure everything should work fine because I just write some Android-Scala yesterday... This link is pretty up to date http://fxthomas.github.io/android-plugin/ If you need. I can upload a example repo for scala-Android on github
This is really cool stuff, thank you for sharing!
its a bloody PDF, dont click, MORONS who can write programs use PDF
There is a "sect" of Scala users who critique Scala properly and have fun and interesting disagreements. Within this context, Ed is a dissenter where most others have given up trying to make Scala's subtyping do any practical work.
Be sure to vote it up on HN: https://news.ycombinator.com/item?id=6966173
Your last 3 scala related posts are great. Very clearly explains stuff, much better than everywhere else I have read so far. PS: I think there is a typo in the last [post](http://mauricio.github.io/2013/12/25/learning-scala-by-building-scala-lists-part-3.html): &gt; And while we're at getOrElse, he idea behind it... 'he idea' should be 'the idea'
Thanks, fixed the typo now :) And thanks for the feedback as well, I think we (the Scala community) need to invest more on material explaining how simple this stuff really is to stop all this "Scala is too complicated" trend.
There are quite a few projects scattered which combine Scala and Processing. Using a quick search, I could find the following on GitHub: - [GameOfLife](https://github.com/shadaj/GameOfLife) - Conway's Game Of Life using Scala and Processing - [scalaton](https://github.com/fdb/scalaton) - A skeleton application for combining Scala + Processing - [improScore](https://github.com/snopeusz/improScore) - experiments in live music notation (scala + processing) - [physarum](https://github.com/nvanderw/physarum) - A slime mold simulation using the Processing library - [SPDE](https://github.com/jccarrasco/SPDE) - This project contains different pieces of software that show the features and easy ways of creating graphical interfaces using Processing and Scala together. - [sbt-template](https://github.com/hmirin/sbt-template) - simple template with scalatest, sbt-idea, ensime, processing2.0b8 - [FieldKit.scala](https://github.com/field/FieldKit.scala) - Modular library of essential utilities and frameworks for developing audio-visual interactive and generative applications. Designed to work well with Processing sketches and also in standalone projects. - [scala-processing-examples](https://github.com/valyard/scala-processing-examples) - This is a repository with Processing sketches ported to Scala - [processing](https://github.com/pearsonca/processing) - sbt plugin to use scala code with processing framework - [processing-tweet-stream](https://github.com/mccv/processing-tweet-stream) - A Processing library for the Twitter Streaming API - [spde](https://github.com/n8han/spde) - Spde extension library for Processing http://technically.us/spde - [scala-processing](https://github.com/alphaneet/scala-processing) - [ProcessingTest](https://github.com/Sciss/ProcessingTest) - Simple setup with Scala and Processing-Core - [scala-processing](https://github.com/stnly/scala-processing) - Template project for developing Processing in Scala with IntelliJ IDEA and SBT. - [spde-examples](https://github.com/n8han/spde-examples) - Example projects in Spde, a Scala toolkit for Processing.org http://technically.us/spde - [Scala-Processing-Libs](https://github.com/felixmc/Scala-Processing-Libs) - Scala libraries for the Processing development environment. - [processing-scala-bootstrap](https://github.com/hkrish/processing-scala-bootstrap) - Bootstrap project definitions (sbt) and sources for "sketching" in scala using the processing library - [scala-hackason-2011](https://github.com/qtamaki/scala-hackason-2011) - Processing examples - [Scala-libs](https://github.com/hellochar/Scala-libs) - Custom Scala/Processing libraries http://p5wscala.wordpress.com
pretty cool stuff, thanks for sharing!
Concerning the "JVM" argument, I think that [Frege](https://github.com/Frege/frege) must be mentioned.
You could look at the documentation of Play or Scalatra frameworks. Not sure of using Rails / Node as front ends as they themselves are server side / backend technologies. You could use Backbone / Angular / Ember as the front ends on the other hand with the Scala backend just serving JSON.
Google for typsesafe activator, it's a great way to start a project 
Even easier, it's on the subreddit sidebar.
If you are planning on using Akka actors and are looking for the simplest way to add a web services interface to an actor-based system, check out [spray](http://spray.io/). 
Looking into socko this seems to be exactly what I need to play around on, thanks!
This will be an awesome resource to learn all these frameworks - especially with all the already made apps
I've written a tiny concurrent web based game in Scala to show how to quickly get started with scala and functional programming. I'm planning on writing a blog on this, but for now you should be able to take away the basics of my web server/websocket code. https://github.com/vmarquez/PureBomberMan
As an existence proof, yes. It'll be interesting to see whether there's an exodus from Scala to Frege by referential transparency fans or the Scala community (further) splits in two à la C++. My money's on the latter.
wouldn't it be better to just create implicit conversions for such cases? that's what I did then I needed it.
Probably. I liked the solution I mentioned, because it was extremely esay, elegant and "just worked".
I had that thought, too. But then again, this is not an important question. The parser will give you the `Argument` value and that's it, just don't think about the mutability any more. It reminded me that sometimes things shouldn't be over-engineered. I guess it had to do with decision to support ["nested" arguments](https://github.com/quantifind/Sumac/wiki/Nesting), where traits are used. Probably it also simplified the macro implementation a lot... ----- __Edit__ Another thought: Wouldn't you normally just use an _object_? Like object Arguments extends FieldArgs { var name: Option[String] = None var count: Int = _ } Your main method isn't reentrant under normal conditions, right?
Finally, don't repeat yourself: http://www.reddit.com/r/scala/comments/1u9vtl/scala_job_requirements/, http://www.reddit.com/r/scala/comments/1u9v96/requirements_for_scala_job/, http://www.reddit.com/r/scala/comments/1u9v7x/requirements_for_scala_job/
Not being a douche, like you.
Paper: http://infoscience.epfl.ch/record/169879/files/RMTrees.pdf 
In all fairness, when I tried submitting I got 503 and 504's so was not sure if the submissions actually went through. Anyways deleted the previous posts .
I was fortunate enough to have met him at a clojure conj a few years ago. He was a very humble and exceedingly charming gentleman. Was truly sorry to hear of his passing. 
My team basically looks for people who don't suck, and are able to grasp functional programming.
This is a very good question. I'll break it into two parts, case classes &amp; vals initially I thought of using case classes also. The major reason I moved away from them is because we really like to have components of the args defined in various traits, and then mix them together. This is a *huge* help in a big org. Mixing them into a case class is kinda pointless -- you either need to repeat the args in the constructor, or you don't get a copy constructor. And, case classes have some really weird behavior if you do repeat the names. see this from paulp: http://stackoverflow.com/a/20700508/1442961 that being said, I *think* you can use case classes with vars if you really want ... though we haven't used it in a long time, can't promise it still works / will continue to work. vals vs. vars is trickier. The honest answer is, its easier to implement as vars. The vars need to get modified in two places: (1) by the parser and (2) by user code when composing multiple "main" methods together. Eg., if you want B to call A, B can just programmatically build up the args for A, and then directly call its main method. That's a lot easier to do w/ vars. An alternative would be for sumac to automatically supply a copy-constructor, but that's a ton of work, and would really just be an academic excercise, from my point of view. If (2) doesn't matter to you, you can actually use vals right now. B/c the parser uses reflection under the hood, it can side-step the "val-ness" of vals. You just need to tell sumac to include fields that are vals. extend FieldArgs and override "isValidField": https://github.com/quantifind/Sumac/blob/master/core/src/main/scala/com/quantifind/sumac/FieldArgs.scala#L36 But, I think you might start off thinking (2) is unimportant, until your project grows, and then its super-handy. **EDIT** vars also get modified by users in [validation](https://github.com/quantifind/Sumac/wiki/Validation). and I should have said that mixing in traits is useful in a big _project_ -- we're not really a big _org_.
on why we don't use objects: one of the philosophies of sumac is to stop thinking of your main method as being some magical thing. Its just a method, which can get called lots of ways, one of them just happens to be from the command line. for example, we have some tools which let a developer easily integrate into a web server. the developer can develop as if its just a main method -- run it, test it out, etc. But then it can just get dropped into the server, which exposes it over a rest api. so, yes, you could use an object if its only getting called from command line, but that stops working if the args get used elsewhere
this world is no good place for intelligent guys to live in anyway.
Its not about being Douche, its about not hiring MORONS.
That is the worst (and probably the dumbest) thing I've heard in a long time. As an observation, a world without intelligent guys would be far worse, wouldn't it? Or are you advocating suicide?
+1 to the Coursera course. There is also a new follow up course called "reactive programming" I'd like to try...
 "person.name" i am still looking for good DTO representation code in Scala, like C structures in C#
What do you need from it?
something for data structure, val only type, but unlike Tuple with tup._1 Big data with small memory footprint.
A case-class?
 // imagine we defined cities to be a Person person match { case LivesIn(cities) =&gt; // here cities is a strictly-created list of city names } // imagine we defined cities to be a Seq[String] cities match { case Istanbul() =&gt; // here matches if and only if the list `cities` contains "Istanbul" } So back to what's going on in the article, but for clarity without using `collect`: person match { case LivesIn(Istanbul()) =&gt; X case _ =&gt; Y } is equivalent to: person match { case LivesIn(cities) =&gt; cities match { case Istanbul() =&gt; X case _ =&gt; Y } case _ =&gt; Y // never happens, LivesIn(_) always matches because `unapply` returns Some } and inlining the definitions gives us: val cities = person.residence.map(_.name) if(cities.contains("Istanbul")) { X } else Y As you can see, there's a `map`, so it's not an efficient implementation. Edit: I think I skipped a step, and an important one. One step before the final version, you can think of the code as: LivesIn.unapply(person) match { // `LivesIn.unapply` returns an option, so it's processed as such case Some(cities) =&gt; if (Istanbul.unapply(cities)) X // `Istanbul.unapply` returns a boolean, so it's processed with an if else Y case None =&gt; // other `Something.unapply(person)` would be processed here if we ever got here Y // never happens }
Well, I'm mostly selling my own library here, but for MySQL, you can go really async with an async MySQL driver - https://github.com/mauricio/postgresql-async
I'm curious, besides Haskell, what other language that's mainstream (as in popular enough to be useful) is better for functional programming? F# or Ocaml do not have higher kinded types, or type classes. And that pretty much sums up all mainstream FP languages that are statically typed. You're then left with Erlang or Scheme or Clojure. I don't have experience with Erlang and LISPs are indeed great, however they are also different. People aren't modelling monads or applicative functors or what have you in LISP. They aren't too concerned about doing side-effect free I/O either. They don't think in terms of types or algebras defined for those types. Dynamic typing in combination with macros afford a lot of flexibility, so modularity and reusability look a lot more different in an architecture built on top of LISP. You can see this mode of thinking in action by just looking at the approach the Clojure folks have taken with "core.async". When you're saying that Scala is not the best language for functional programming, I really think that you're saying that no other language is better for functional programming, if it's not Haskell that is. And while it's true that Haskell is awesome, there are always multiple ways of skinning a cat. LISP is not Haskell and Scala is not Haskell either. If you're using Scala as if it were Haskell, of course it looks ugly. And I think this is the biggest problem with Scala - it doesn't have its own culture yet. People approach it as if it where a better Java or some kind of Haskell variant that runs on the JVM.
thats not a val type and is very heavy too we need something that can be copied across threads and processes and hence should be light weight. 
Ocaml offers ML-style functors, which takes you in a different direction that provides comparable results for code organization to those of type classes. I personally happen to prefer typeclasses over ML functors because I find typeclasses lets me repeat less, but I freely confess that the I'm jealous of the ML module layer. Sadly this is the very thing ripped out by F#, but I happen to feel that the most serious contender in this space is Ocaml -- or even SMLNJ/Mlton. Agda doubles down on the functional side of things and loses the "Prolog in the type system" that are type classes in exchange for real dependent types. Mainstream? Not really. Idris keeps the stuff you'd need for typeclasses in exchange for shakier foundations at the dependently typed level. Haskell isn't perfect. There are things in Haskell that drive me nuts with regards to code reuse and typeclass instantiation. I have to write asymptotically more code than is ideal due to the way typeclasses work and there is no "superclass default" mechanism on the horizon that will save me from myself. This means for instance that Haskell favors much shallower type hierarchies than can be supported in Scala or Ocaml or even F#, though the latter lacks the vocabulary for quantifying over higher kinds, preventing anything from being written abstractly over a monad/applicative, etc. I've also implemented proper monads using Scheme macros. There I can still avoid the trampoline mess. We even spent some time working up how to teach a compilers class that way. This project ultimately fell apart for non-technical reasons. I don't happen to agree that my opinion is simply a consequence of the fact that Scala hasn't evolved its own culture. I did used to think that was the case, until a number of us have tried to learn to speak Scala without a Haskell or Java accent. Scalaz is definitely "Scala with a Haskell accent". But Scala has developed quite its own personality. If you look at Miles Sabin's Shapeless as an attempt to take Scala for Scala and push it as hard as you can. He's really embracing the language he's in and not trying to take it for something else. Personally, my previous attempts at doing the same thing, embracing Scala for Scala and pushing in the direction the language wanted to go, well, mostly led to me finding bugs in the compiler. I spent 4 years making a go of it before deciding that Scala isn't very good at functional programming. In that time we've shipped production system after production system in Scala, but that said I find it kind of sad that to actually get usable performance I have to rip all the monads out of the type checker for our functional language in the implementation in Scala and take the unsafe path with mutable state. YMMV. It would be a lot easier for me not to speak up about these things, as I risk being labeled and discounted, but I feel I would be doing the community a disservice if I didn't try to open the discussion about these issues.
&gt; Or are you advocating suicide? No, but its a curse to be alive among such non sentient beings 
I am using a similar build with packer + vagrant to setup dev boxes for Play!/Akka and AWS AMIs. nice write up
Hmm--I'd like to hear more about that ninja_coder. Thanks for the kind words about the write up.
Case-classes usually don't have to be copied, they're usually immutable. Passing an instance of a case class from one thread to another is just passing a single reference. If you have a case-class: case class Person(id: Int, name: String) then it holds only an int and a reference to a string. You can't go lower than that on any platform. Both those fields are `val`s. It's small, it's fast, it doesn't have to to be copied. In other words, it's lightweight.
No author? :(
http://infoscience.epfl.ch/record/191239 Miller, Heather; Haller, Philipp; Odersky, Martin
I have a question: why def black = s"$BLACK$str" and not def black = BLACK + str
Thanks! :)
&gt; The popularity of the rationale behind this viewpoint (immutable data transformed by function application) has even lead to a number of object-oriented (OO) pro- gramming languages adopting functional features such as lambdas (functions) and thereby function closures. Closures are a feature that is *not* "owned" by FP. Having closures does not make your language functional. For instance: http://en.wikipedia.org/wiki/Smalltalk#Code_blocks
I'm curious to see whether Akka IO can compete performance-wise with Netty 4.0 and the upcoming 5.0. Also, there doesn't appear to be any ssl support yet :/
Yes, considered using Puppet but using a Bash script seems more general purpose and more reusable. I mean Puppet seems like a tool with one use and one use only whereas Bash can be used for lots of little chores on Ubuntu. Is there a good reason to use Puppet or Chef other than the fact that they're really built for provisioning? 
The very first known implementation was in Scheme, SmallTalk was the first OO language to implement closures.
Yes, but since SmallTalk is also the first language to really implement OO...
I don't know if there's a difference to the compiler in this case, but it's probably a stylistic thing. I like to use the interpolation methods in Scala, like in Ruby. Doing string addition like in Java always just rubs me the wrong way :)
How is this better than [scallop](https://github.com/scallop/scallop)?
&gt;Doing string addition like in Java always just rubs me the wrong way :) What about the sequence concatenation operator? BLACK ++ str Looks almost like Haskell.
its not a good idea to reference data objects from one thread to another, that will cause locking the threads while data is accessed using Marshaling. Memory operations are very fast so better would be to copy the data first to do loop operations, C structures by default make copies on assignment, so C# wins on multicore.
&gt; "these girls" This is totally inappropriate.
What locking? You don't have to lock immutable objects. There's simply no reason to. Can you provide a use case? An example?
Agreed, that alone stopped my from reading the post
What the hell does this description even mean, what's Scripting TypeUnsafe and what does the sex of people have to do with anything?!? Edit: looking up the history of OP confirms he's better ignored. 
you never dealt with real Multi threaded programs, right ?
Scala.js does indeed look interesting. I hope it doesn't get a bad reputation due to /u/AAAplus posting incoherent spam for it. But GWT has let you compile Java to Javascript for some time, so I don't think scala.js existing will cause everyone to stop coding in javascript. There's already typed languages that compile to javascript. Now if they get it to work really well, and if Play! gets good support for it, and if you add something like Ember.js or Angular.js for it, perhaps it could be a "killer app" for scala web development.
That you find this criticism encouragement is a mental illness.
Please AAAplus, I prefer type-safety over the alternative as much as you do, but your confrontational and mocking tone does not help the cause. Be more diplomatic man! Also know that dynamic / scripting languages *do* have their place and adherents (even if you and I are not among them). The world is full with developers which are *very* productive with these, and do incredible stuff with them.
And not only web-development... ;-) Think of all the products and frameworks targeting mobile-app development (Android/iOS) based on HTML/JS/CSS... Think of flash-based online games...
why be Diplomatic instead of getting there first and bankrupting the competition that should not had existed in the first place ? imagine if Java was used FOR Flash instead direct Action Script in 1999
JSScala and JScala should join hands with this to create the Ultimate client side JS replacement NOW instead of in 2018
Try some crash course in cross process marshaling 
I'm sure there are more reasons, but what I can think of off the top of my head: Puppet will only run what you need specifically now and in the specific order. i.e. it will copy server config files only after a server is properly installed and only on first VM boot.
&gt; imagine if Java was used FOR Flash instead direct Action Script in 1999 It did, and it was terrible. 
see http://stackoverflow.com/questions/2224932/difference-between-trait-inheritance-and-self-type-annotation
How are these different? trait FooService trait FooRemoting { this : FooService =&gt; } trait FooPersistence { this : FooService =&gt; } object Services extends FooService with FooRemoting with FooPersistence --- class Service trait RemoteService extends Service trait PersistService extends Service new Service with RemoteService with PersistService
From the answers: Self-type allows to define cyclic references My answer: Self-type doesn't leak "implementation" details. From the outside `FooRemoting` doesn't exhibit the API of `FooService`. trait Foo { def foo: Int } trait Bar { _: Foo =&gt; def bar: Int = foo } // can call into Foo def test(b: Bar) = b.foo // error: foo not a member 
A self type declares a dependency that needs to be met for an object to be instantiated: trait Wedding { self: Bar =&gt; This means that an instance of Wedding needs to have a trait or class extending Bar mixed in. It doesn't matter what kind of Bar; anything that extends Bar will do. The choice of exact type is deferred. This is great for dependency injection. Maybe you normally instantiate a Wedding using FullCashBar but every once in a while you mix in FreeBar instead, and when you're catering a Mormon or Muslim wedding you mix in a subtype of NonalcoholicBar. The important thing is that a self type *requires* you to mix in an implementation before anything can be instantiated. When you specify a type to inherit from, that concrete implementation will be used if no other type is mixed in. For example: trait Wedding extends FullCashBar { You don't need to mix in an implementation later. FullCashBar will be used as the implementation type. FullCashBar is just the default, though; you can mix in another type if you want. If FullCashTikiBar extends FullCashBar, Scala lets you do this: trait HawaiianWedding extends Wedding with FullCashTikiBar { This is an example of [diamond inheritance](http://imgur.com/YYOgBni). Scala solves the "Diamond Problem" by linearizing types, so the implementation type ends up being FullCashTikiBar. Note that if FullCashBar is abstract, it cannot actually be used as the implementation type, so inheritance is no different from using a self type (EDIT: except in member visibility, [as explained by /u/predef](http://www.reddit.com/r/scala/comments/1uqpo6/what_is_the_difference_between_selftypes_and/ceks9o8)) and diamond inheritance *must* be used to provide an implementation. **tl;dr** Self-typing or inheriting from an abstract type requires that an implementation type be mixed in elsewhere. Inheriting from a concrete type allows you, but does not require you, to mix in an implementation type elsewhere. 
Greater answer. Love the examples, thanks.
now we need a Library compiler that generates Jar from existing JS libraries like Dojo or EXTJS, so that ENTIRE GAMUT of JS can be shifted on to Scala and thus just KILL all JAVAScript ecosystem, FINALLY.
They are not different in sense of final behavior. They are different in sense of design intentions. Traits FooRemoting and FooPersistence expect to have FooService implemented for them. RemoteService and PersistService provide FooService implementation for their children. 
wow, I got interested in Scala and now I see something this incredible. It shows how powerful this language really is. - regards from a professional Python programmer by day. 
This gives you: - Code complete - Inline docs - Error highlighting and a bunch of other nice things =) 
If you use [an IDE that isn't complete crap](http://www.jetbrains.com/idea/), you get that with interpolation, too.
No you don't. You don't even get good syntax highlighting for inline XML yet. Source: I use that IDE you linked to, every day =) 
Looks really cool, feels like HAML.
Not sure if this example is nice, you should make this an Either[String,Int], not turn the number to string.
I'd love to see Scala language injection work for Scala expressions interpolated within the XML attributes and values. Is there a way to do that? Scalatags gives you that out of the box.
IDEA language injection in a Scala string interpolation always understands Scala expressions inside of it. That includes if the language being injected is XML. So yes. You can see this by hitting Alt+Enter inside an interpolation, choosing "Inject Language", and then "XML".
we need a tags DSL , not so many brackets
Mainly because that would involve global (or threadlocal) mutable state, which I'd like to avoid as much as is possible.
Salary?
I've noticed self-types are also good way to define a class across multiple files, or at least you can think of it that way. Its really awesome.
How many current full-time employees are there, and what is the split between people who are technical and those who are paper-pushers?
Hello CTO, Why did you decide on Scala? Just wondering.
What does your social networking startup do? Where is your web site?
Define brilliant.
Note that at version 0.2.0, everything is still in flux and up for debate or change, if anyone is interested enough to give me their opinion =)
Define 'define'
24 hours since posting the job advert, and no response to any questions. This startup - or at least the CTO - does not seem to have the same sense of urgency that I am used to at other startups I have worked with.
This is great work, and some of the most sorely needed for the Scala community. Currently jdbc + anorm is preventing me from really using async programming style with my Scala project. It kills me to have so many threads running, hurting performance when under load. Anyone know if I can use these async drivers with slick?
Not yet, last time I spoke with them they were planning to have an API ready to hook for the 2.x series, as soon as they have that I plan to write the integration.
Yes unary ops are restricted: implicit class Deref(x: Any) { def unary_~ = "unary_~" def unary_* = "unary_*" } ~"xyz" // works *"xyz" // not You could use an object with apply: object * { def apply(x: Any) = "de-reference" } *("xyz") 
The ERA of programmers is coming to an END, the era of Nerds has began, revenge of the Nerds will devour those voting me down here.
I thought my account was configured to e-mail me alerts to any replies. Believe me, I've been doing plenty of work over the weekend!
Currently there are just 3 full-time employees. I'm technical, the other two aren't. 'Paper-pushers' is a bit of a pejorative term - just because someone isn't technical they can't provide value to a business, and the other two employees are certainly contributing a massive amount. 
1. Do you use source control? Github 2. Can you make a build in one step? Yes, it's easy with one artifact! 3. Do you make daily builds? We have a Jenkins server we're using for continuous integration. 4. Do you have a bug database? I'm using kanbanize/a post-it wall to manage work tasks. Though there shouldn't be any more than a handful of bugs at any single point - either a bug is worth fixing now, or it can be considered part of the product and doesn't need to be tracked. I don't believe in bug debt. 5. Do you fix bugs before writing new code? See answer to 4. 6. Do you have an up-to-date schedule? Yes 7. Do you have a spec? No! As I said, almost all the criteria. We have stories on a JIT basis rather than a spec, though we do also have documentation/wireframes/user flows around our vision. 8. Do programmers have quiet working conditions? We've got a lovely little office which is quite quiet. 9. Do you use the best tools money can buy? I'm using IntelliJ and would buy a license for the developer. I can't think of other commercial tools that are better than the free alternatives. 10. Do you have testers? All developers are testers! Ok, maybe we technically fail on this one. 11. Do new candidates write code during their interview? Yes, pair programming exercise 12. Do you do hallway usability testing? Certainly, we're located close to other startups that we can grab them for hallway usability testing. 
The cop-out answer is you know it when you see it. To me a brilliant dev: - has a natural affinity and passion for technology and programming - enjoys programming and problem-solving in of itself, not just a way to get their salary - is constantly inquisitive, wanting to learn new stuff all the time - has pride in what they're creating - is concerned about delivering value to the business - is a good communicator, both with the business and other developers
We're currently still in stealth mode I'm afraid, though only for another few weeks. It's related to place discovery.
around the £55k range, with options in the picture too.
Stealth mode is bullshit. If you're so scared that someone might copy you now, you're saying that you have a product that is trivially executed. If that's the case, there's nothing to stop someone with more marketing money doing so after you launch.
Images of a running Gitbucket site here: http://takezoe.blogspot.com/ 
Thank you. That is a great description.
Looks cool. Thanks for sharing.
i grabbed it for evaluating in place of other tools and was pleasantly surprised by both how easy it is to get running (at least as a standalone daemon, i have not yet tried to get it as an Apache server component) and how well it works. nice stuff.
Hello Inside, What do you think about working remotely?
Had it up and running within 5 minutes. This is really nice looking, looking forward to deploying in our dev environment in the AM. 
Great tool, works as promised.
SBT should be banned by Typesafe.
Agree. What a horrible build system. Maven is bad, but SBT is *atrocious.*
Needs more Mercurial. Also, use a build system that isn't completely terrible.
What's wrong with SBT?
Well, SBT/Maven/whatever already do isolate projects pretty well, which IMO makes Vagrant mostly useless.
Examples of what SBT/Maven/whatever can't do: * OS independence (one dev uses Linux, another uses Mac - both have same env) * Database (i.e. Mongo on one project vs Oracle on another) * Frontend server (nginx 1.4 on one, nginx 1.3 + varnish on another) * SASS/LESS/JS compilation via node.js * Any other project specific external library or you can think of...
&gt; * OS independence (one dev uses Linux, another uses Mac - both have same env) Java is mostly OS-independent anyway. The stuff that's left should be handled properly, not swept under the rug with virtualization. &gt; * Database (i.e. Mongo on one project vs Oracle on another) Fair enough. &gt; * Frontend server (nginx 1.4 on one, nginx 1.3 + varnish on another) No need to do caching during development. &gt; * SASS/LESS/JS compilation via node.js Play handles this automatically anyway.
Whilst there are teams that make communication work between people in multiple locations, I believe there are less challenges when people are co-located and given that there are plenty of Scala devs in London I'd like to find someone who can work locally.
its a SIMPLY BULLSHIT TECHNOLOGY, what we need instead is an Standalone DEPLOYMENT SYSTEM (SDS). TO HELL WITH CLOUD BASED CENTRALIZED TYRANNY.
lets hope Jonas Bonér will be part of this.
Not sure if the button syntax would work (can you assign to vars that you imported?) but this would work too: object Button { def apply(fun: (import Button) =&gt; Unit): Button } Button { text := "foo" enabled := false } 
I haven't tried it but it should work, because you can write object Button { def apply(fun: Button =&gt; Unit): Button = new Button { fun(this) } } class Button { var text = "foo" } Button { b =&gt; import b._ text = "bar" } There are no "vars", it's just `def text` and `def text_=`.
This looks really promising; I'd love to see this incorporated into Scala mainline.
try to find how to use Scala without those round brackets, use indentation to compensate the closing tags.
That actually worked! Learn something new everyday...
Wow, awesome, the withSession example in particular looks pretty tasty for Slick users. Now, if groupBy/sortBy boilerplate could be cleaned up, I'd be sold on the direction Slick has taken in moving to pure Scala collections syntax...
This was very valuable for me as a person just getting started in Scala. Thank you. 
the docs dont imply that Sumac prints usage text. Scallop certainly does that.
I wonder if the scala devs are planning on moving to the same sort of implementation as Java 8, or if it makes much of a difference performance-wise.
More great exercises. One thing: `game.score()` is not recommended style. It should be `game.score` Another thing is there should be more encapsulation here. The players should be objects with their own score and name slots. This code is not correctly coupled if you ask me. We could (should?) go even further and have the points be their own class too.
I believe you should have a better grasp of what's percieced as "idiomatic" functional Scala before you try to teach new people, who would later have bad practices.
lambda expressions don't have to be an object, they are because it was the most sane way of implementing it given the JVM constraints. now that we are going to have the JVM itself supporting this kind of construct the Scala solution can just use that as well.
There was some discussion of this on scala-user a way back. It was a controversial topic. As I remember, there are no plans to move to using invokeDynamic because doing so would require a 1.7+ JVM. While Java 1.6 is past EOL, requiring a 1.7 JVM would mean Scala apps couldn't run on Android, or at more conservative organizations that haven't upgraded their JVMs. Of course, people would be free to use Scala versions from before any future 1.7 JVM requirement. And there was talk of a compatibility switch that would emit non-invokeDynamic bytecode if needed, but I don't know where any of this went, if anywhere.
If something is an object on a language level, it doesn't necessarily have to be an object on the VM level. Case in points: integers.
this is over my head
What do you think of what he says: Scala is too complex. True, false? Why do you think so?
how do I get the audio and or video?
Good luck to Paul reinventing the Scala collections library. I for one am very happy with the actual `map` method and the possibility to drop in `collection.breakOut` quite frequently. ------ Next: // Um... (BitSet(1, 2, 3) map identity)(1) Really? His examples disappoint me very much. That "problem" goes for any implicit argument list. Then use BitSet(1, 2, 3) map identity apply 1 ----- val x = Map[Int, Int]() withDefaultValue 123 x contains 55 // false x get 55 // None x apply 55 // 123 Arguably this is the behavior you want. At least I have always understood default values to work that way. ------ &gt; A universal size method must be SAFE and CHEAP I disagree with cheap. If I have small lists or sets, I don't care that `size` takes O(N). If I have big stuff, I use a collection which has fast size. The `sizeInfo` idea is not bad, though. Another solution would be that infinite streams if it is _known_ that they are infinite—e.g. `Stream.continually`—throw an exception upon calling `size`. On the other hand, there is no way to prevent you from defining a recursive stream. You would need to disallow `size` on `Stream` altogether. I don't see how the `Foreach` solves this. ------ What I tend to agree with is that the common interface between `collection.mutable` and `collection.immutable` is too large. The overlap can be minimal IMO.
I think you're right. Creation of Player object seems clearer. I modified the post. Can you take a look and send additional feedback?
I'm just sharing my solutions to different katas and some people seem to like them. I have no doubt that the way I solved this one is not the best possible. It can always be better. Would you mind posting the alternative solution? I'd really like to see it.
map is supposed to be the honey badger of functions. Got your data in a List? A Set? A SortedSet? Honey badger don't give a shit, it'll transform them data no matter what. Except here, where map will transform the data and then take a dump all over the container of the data, somehow transmogrifying it in the process. The compiler could see that there's no comparator in scope for Tuple2[Int, Object] and throw a compile error rather than returning a Set. Sure -- if he explicitly demanded that he wanted a SortedSet[Tuple2[Int, Object]] through type ascription, he'd get that behaviour. But why, dear reader, would the user think that's necessary given that this is the method signature in the documentation for [SortedSet.map](http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.SortedSet): def map[B](f: (A) ⇒ B): SortedSet[B] I can understand why you think the example was OK. Downgrading from a SortedSet to a Set seems perfectly cromulent. Reasonable people can disagree about what a collections library should do. But for God's sake, at least the docs could tell the fucking truth. Except they can't, because the truth (in the form of a complete type signature) is frightening.
Love the honey badger metaphor, have an upvote :) 
Just a suggestion, perhaps curate your jars manually instead of relying on SBT. At least the offending library. If I understood correctly I'm assuming this would avoid having SBT pull down conflicting dependencies.
Hell no, implicits aren't unnecessary. Implicits are awesome! So is the type system. I dove into it, and not only did I emerge, I emerged with frigging glowing eyes and superpowers. Metaphorically, anyway. :)
This isn't the same functionality. Creating a view into a collection is different from creating a new collection. It's a pretty important distinction when you filter ten elements out of ten thousand and have to worry about whether the elements that are now "reachable" are the only ones you're holding in memory. So now the user has to worry about calling "force" in exactly the right places (surely a nontrivial thing to figure out when writing library code) or you can try to make it magic. In both cases you're trading one set of problems for another. 
False. Absolutely false. Scala's complexity is well worth it for the power it offers. Implicits, for instance, gave me something I'd spent *years* wishing for, back in my Java days. No way in hell am I giving that up! Unless you mean the collection library. That thing is in dire need of cleanup. That's not the language's fault, though.
m and force are there because SortedSet already defines map. It is trivial to arrange things so that "SortedSet(1 to 10: _*) map f map (_._1)" - this being the expression which results in an unsorted set in the collections - returns a sorted set. It's not "wrong" or "impossible", it is done. But I guess a guy who leads with "I'm not taking the time to understand this" can safely be expected to latch onto irrelevant details and miss both the forest and the trees.
Why is he forcing a connection between woes of internal workings of one specific part of a language and problems a typical user of that language will face? I can appreciate the work he has done and after looking closely at his examples I can understand ~~most~~ some of them, but they don't seem to bother me as much as they do him... Moreover, I wish he would end his talk with real proposals on fixing the problems or if that's not possible, then alternatives. What is that holy grail of PL that he has found that is perfect in every aspect so we can all finally switch to it and stop arguing?
&gt; But for God's sake, at least the docs could tell the fucking truth. The docs are wrong on the return type of immutable.SortedSet.map and mutable.SortedSet.map, but it isn't because there's an institutional resistance to telling the truth, as the slides imply. The [Scaladoc for collection.SortedSet](http://www.scala-lang.org/api/current/index.html#scala.collection.SortedSet) correctly says that map returns a Set, not a SortedSet: def map[B](f: (A) ⇒ B): Set[B] When the conversation goes to things like how long it takes to fix documentation bugs, that's getting into deeply practical stuff about how to prioritize work on the language, and the author's principled outrage seems out of place. For me, the two things just don't mix. Practical questions are judged by practical standards. Since Scala is an essentially practical language that doesn't shy away from compromise (it's built for the Java ecosystem, after all) I don't think it makes much sense for the author to summon so much angry self-righteousness over issues without asking how much they really affects users (as opposed to implementers.) Not to say that his perspective is wrong. I'm well aware that while I am happy to overlook minor inconsistencies that don't materially hinder my work, the state of the art is pushed forward by people who refuse to make "reasonable" compromises. It just rubs me the wrong way that the author is so convinced of the primacy of his own point of view that he directs anger and derogation towards people who act from a different perspective. (If any single perspective on Scala should be elevated above all others, it should be the point of view of working programmers who care about how Scala helps or hinders them in their day-to-day work. That's the kind of language Scala is. But I don't think that even that point of view would come off well if presented in this tone.) I guess that is more of a general observation than a response to what you said, but this is as good a place as any. 
Why not simply do the same as what javac does, add a -target $VERSION option for those targetting older vms.
I am using my own sbt-appbundle for OS X desktop and sbt-assembly for Linux and Windows. Hadn't had any serious problems with that approach. I don't know what `xstream` is, but it sounds to me that you should try to solve that problem of duplicate classes, and then the rest will fall into place. sbt-assembly can be configured how to react when there are merging conflicts. Also sbt `libraryDependencies` entries can be specified with [exclusions for transitory dependencies](http://stackoverflow.com/questions/10958215/how-to-exclude-commons-logging-from-a-scala-sbt-slf4j-project).
Great, I have been waiting for this for years.
That was more or less one of the options discussed. Anyone interested should look up the discussion on scala-user; I don't remember all the details. The subject line was something about Scala 2.11 and Java 7.
How did you find Scalatra?
It's also worth mentioning [ValidationNel](http://eed3si9n.com/learning-scalaz/Validation.html) from [Scalaz](http://scalaz.github.io/scalaz/). When you use it, you either end up with something that you can use to call a function on a bunch of things that successfully validated or a list of all the errors that happened. If you had used Either or Option, your code would have quit upon reaching the first error.
Maybe Scala's standard library is ugly to hack, but I enjoy using it. I must be a masochist, because I regularly use scalaz, as well.
Great post, but if anything, it adds fuel to the fact that in Scala, there are many ways to do the same thing. This is not always a bad thing but in the case of handling errors, it's quite problematic. This area keeps changing, too. `Try` is pretty recent, `Either` has a solid competitor in Scalaz's `\/` and the net result of all this mess is that there is no clear answer to the simple question: "How do I handle errors in Scala?". 
Google's and Apache's collections are not anymore very interesting as Java 8 introduces lambdas and default methods. http://zeroturnaround.com/rebellabs/java-8-explained-applying-lambdas-to-java-collections/
As a professional Python programmer, all I can say is Scala is faster and better than Python in all ways except _size_ of user community. I'm very impressed with Lift, ScalaTags, and the helpful kata tutorials. Nothing in Python or any other language can compare with Lift for webapp development in my opinion. But I'm open to suggestions to look at other things. And a day spent programming Scala is better for me. I grok Scala. I never could get over the hump with Haskell. 
Extremely subjective and shallow comparison. The only valuable point is 7 (assuming it's poorly stated first-class function support).
Having done the reactive programming course on Coursera recently, I think the current advice is for any part of your program which is functional and which might fail, use a `Try` (or `Option` if `None` isn't really an error condition which needs to be handled separately). `Try` might be newer, but it's definitely being pushed as "the right way".
&gt; Try might be newer, but it's definitely being pushed as "the right way". You obviously don't hang out in #scalaz :-) (and the people in #scala will disagree with both). 
&gt; Scala is new generation JVM language, which is generating popularity as alternative of arguable one of the most popular language Java. I stopped reading after that. 
I agree. Scala's power comes at a reasonable cost of complexity. For some applications this power is really needed, e.g. for the Scala compiler itself. 
You can use QubesOS to open PDFs in a disposable VM, or just use a separate VM for reading reddit, if you care about that kind of thing.
Thanks!
After years wasting my life writing Java code I've been coding primarily in Scala for a year or so. Yes, Scala is complex but every hurdle you overcome makes you a better developer. You have to approach it with a "bring it on" attitude. I shook my head while reading these slides. The signature of the map method is complex? Who cares... it's easy and intuitive to use. Java interop isn't perfect? Is that an actual problem in the real world? I've certainly never encountered it. 
&gt; Arguably this is the behavior you want. At least I have always understood default values to work that way. Yes, java.util.Properties works in an analogous way with its default properties. You just have to know the right method to call for the behaviour you want.
But garbage collection isn't an irrelevant detail. It's a very important practical concern. Not a functional correctness concern, which you mostly seem to be focusing on, but a non-functional concern.
&gt; Google and Apache did it for Java... As did [Goldman Sachs](https://github.com/goldmansachs/gs-collections).
i wont be shocked if the same guys vote up some JavaFX version that uses Applets in the Future, Poor sheeple! So predictable.
The original version - fixed space formatting is usually annoying when you have to edit the code, people might forget to reformat etc. 
Can't stand #2 at all, I have trouble reading the param names. #1/#3 are both fine. I'd probably take #1 over #3, but it's not a big deal.
Hmm, I'm surprised you prefer the original. Part of the motivation to work on this is to match some of golang's gofmt alignment in structs, which I'm quite fond of: type DaemonConfig struct { Pidfile string Root string AutoRestart bool EnableCors bool Dns []string EnableIptables bool BridgeIface string BridgeIp string DefaultIp net.IP InterContainerCommunication bool GraphDriver string Mtu int } The compactness problem could partially be solved by having a length limiter, so that the formatted code might look like this: // Method Call Rewrite #1 object.writeHiddenTokens( builder = Builder(321), hiddenTokens = "", instruction = PlaceAtColumn(1), nextTokenUnindents = False, includeBufferBeforeNextToken = True , True, tokenIndentMap = Map(), positionHintOption = 20 ) but I'd rather not complicate the algorithm just yet.
The sbt-scalariform plugin takes care of people forgetting to reformat -- it reformats files on compile. It's definitely still an issue if people are manually running the CLI scalariform though. 
For viewing class params without coloring, I prefer them in this order: #3, #1, Original, #2. I'm accustomed to seeing the ":" next to the type. "ragged left" is the least appealing. Now, if you are going to give the types a distinct color , then my evaluation may be different because it would greatly improve the readability of the Original formatting. For the method call formatting, #1 looks best to me, followed by Original, then #2. (again, don't care for ragged-left). And as with class params, coloring would make the appearances of #1 and Original equally appealing.
All of those are fine to me. Since we're talking about code formatting, however, I recommend using tabs for indentation. That way, people can configure their editors to use whatever indentation width they want. Make sure to still use spaces for alignment, though!
I'd really like to see better Enumerations in Scala. The syntax is confusing, every time I use it I end up looking it up. There is also still no efficient equivalent of EnumMap and EnumSet. Without EnumMap and it's performance Scala enums sadly fall well short of Java's.
Related discussion: https://groups.google.com/forum/#!topic/scala-sips/Bf82LxK02Kk/discussion
Editing a line with a bunch of spaces for alignment is going to make for some pretty awkward editing.
If your team can't even figure out how to indent properly, why are they allowed anywhere near the code?
Hi, What do you think about working remote? We are an experienced Scala team in Istanbul and working with foreign product companies remotely. (using distributed scrum)
Are the 1.x releases available anywhere? The official site has only up to 2.5.0: http://www.scala-lang.org/download/all.html EDIT: it seems some of them are available as as git tags on Github. [This is the very oldest tag I found – v1.0.0-b5.](https://github.com/scala/scala/tree/v1.0.0-b5) `NOT SERIOUS MODE ON` Also, it seem Scala experts were already needed on the job market only 23 days after its creation: http://article.gmane.org/gmane.comp.lang.scala/88 :)
All it takes is one person to use a new editor that's misconfigured and it to go unnoticed for a while. It's got very little to do with ability to code. The only projects that ever manage to get this consistent are tiny/one person teams with little churn. Not a luxury everyone has.
Anything but #2.
The original formatting is perfectly readable to me and I don't have to bother typing it out all the same - even if there were some "funny" keystroke that I have to press to get this *magic* reformatted sprinkles. Unless I'm going for presentation (say on-screen or something), I'd just prefer original (especially if I don't have syntax highlighting on)
The original, with syntax hilighting.
We are considering remote workers and will be hiring a few from odesk, but we really wanted to integrate someone into our existing team directly, potentially moving them to our office. I'll shoot your idea out to the others. Do you have a site? edit: autocorrect changed odesk -&gt; ideal
Original Scalariform guy here -- just thought I'd say that while Scalariform was definitely bordering abandonment in 2013, my New Year's ambition is to get active on it again for 2014. We'll see - I'd love to rearchitect it to make it a bit more straightforward to implement various styles -- I think the current codebase is weak in that regard. Let me know how you get on!
Can't talk about formatting without mentioning [scalariform](https://github.com/sbt/sbt-scalariform) IMO. Very useful plugin. 
This is awesome. I prefer def #1 and call #1.
I've sent you a message
Hey, thanks for writing Scalariform! I'm using it in every one of my Scala projects. It's good to hear you're looking to continue it's development. I'd be interested in hearing your ideas for rearchitecting the codebase -- I managed to implement "Def / Class Rewrite #1". It took me about 2 weeks worth of free time (outside of a full time job) to implement it. There was a lot of trial and error, thankfully the test coverage for Scalariform is quite thorough. IMO that isn't too bad, especially since it'd take much less time for me to implement new features -- most of the time during the 2 weeks was familiarizing myself with the codebase. One thing that I was thinking about was a [quasiquote](http://docs.scala-lang.org/overviews/macros/quasiquotes.html)-like DSL for source code rewriting, to help visualize what's going on. I think trying to translate the formatting instructions in my head to the actual rewriting behavior took me the longest to figure out.
https://news.ycombinator.com/item?id=7089565
Depends, sometimes original, sometimes #1. I can see how some people would like #3, and cannot see how anyone would like #2 ;-)
Thanks for the help porting AIFH to Scala. Several contributed to it and if you want to see the Scala port of AIFH, it is here. https://github.com/jeffheaton/aifh/tree/master/vol1/scala-examples
&gt; Martin apparently isn't a fan of Java's Enum Very unfortunate, it's pretty much the only thing I miss from Java. 
It would be better if OP gave it a better headline, seems more like a discussion about beginners and the Scala ecosystem.
Hi, I'm a developer of Stratosphere. By now, we have a documentation for the [scala api](http://stratosphere.eu/docs/0.4/programming_guides/scala.html) on our website. Some general remarks regarding the system (because HELOSMTP had some inaccuracies in his answer): Stratosphere is a new runtime that is build from ground up (so its not like Cascading or Scalding running ontop of Map Reduce). However, if you have Hadoop 2.2 with YARN, you can use that to start Stratosphere in your cluster. Stratosphere is fully compatible to the existing Hadoop ecosystem, so we support hdfs, the standard input formats, hbase etc. You can see Stratosphere as the next logical step after Map Reduce. For example, our system has a "native" implementation of join algorithms (so you do not have to piggyback map reduce for that). This leads to much better performance. One note regarding Spark and Shark: Shark is a Hive compatible SQL interface ontop of Spark (not the other way around). **How does Stratosphere compare to Spark?**: This is a thought question. Here's my opinion: * Spark is designed as an *in-memory* system (e.g. you need to have a lot of memory available in your cluster). Stratosphere on the other hand uses the memory that is available in the cluster, but if the data does not fit into the memory anymore (which tends to happen with Big data) we start using the local disks to keep running. I have to say that Spark is working on this, but I think its not yet released. * Secondly, Stratosphere has a *build-in optimizer*, similarly to traditional database management systems. With the optimizer, Stratosphere is able to choose the best available execution strategy for your program. * Both systems support iterative algorithms in distributed cluster computing. Iterative algorithms are needed for machine learning, graph processing and so on (basically, when you need to loop over the data over and over again). Stratosphere's iteration support is integrated into the system more deeply than with Spark. The optimizer can choose better execution strategies and we have a unique feature called delta iterations. Have a look into this [scientific paper](http://vldb.org/pvldb/vol5/p1268_stephanewen_vldb2012.pdf), it describes the background. Please write to our [mailing list](https://groups.google.com/forum/#!forum/stratosphere-dev) if you have further questions or want to use Stratosphere! 
Regarding making Scala a welcoming environment for newcomers, I think we are lacking a certain kind of vibe/personality as a whole at the moment. The loudest people tend to make the biggest impressions - there's a few people who make the Scala IRC an uninviting place (maybe it's just one, I'm not sure). For example, about two days ago, a newcomer joined the channel and asked about ~"techniques for creating updated copies of immutable objects". The reply he got was a very condescending, "The technique is called Functional Programming" (may as well have said the technique is called programming or typing) Similar incidents happen frequently. It's saddening. Contrast with the helpful people in #go-nuts (say what you will about the language, this is about the community).
scala programmers are resentful haskell programmers because they don't have ph.d scala is hard because it's multi-paradigm. and compiler doesn't guide which paradigm to use in what situation, nor paradigm selection falls naturally to new comers. only the most experienced and the most resentfuls get it right. but once you get it right, you can be really productive. just like you can be really productive in PHP and C++. 
That's unfortunate, of course. I think if you become aware that the resentful voices are only a small minority, you will find that the community is much more welcoming. You might have to exploit the alternative channels. I think the scala-user mailing list should be fine, plus Reddit and StackOverflow.
That happens to nearly every Internet community. The only way to stop it is a concentrated, coordinated effort to discourage that behavior and also provide friendlier alternatives.
I had the same experience with Scala IRC, and I find it amusing that I know exactly who you are referring to. Most of the discussion there was very PLT / Haskell-style programming related -- I ended up leaving since I was looking for more help on things like "How do I use this HTTP library to do Oauth?" kind of discussions.
* [Press release](http://www.marketwired.com/press-release/-1871072.htm) * Blog post: [Slick 2.0 GA - Functional Relational Mapping Made Easy](https://typesafe.com/blog/slick-20-ga-functional-relational-mapping-made-easy)
This is awesome :)
Take a look at http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.StringOps. 
&gt; The reply he got was a very condescending, "The technique is called Functional Programming" I used to see similar replies on scala-user somewhat regularly until I added 2 or 3 names to my killfile. Now it's better. 
&gt; I ended up leaving since I was looking for more help on things like "How do I use this HTTP library to do Oauth?" kind of discussions. I know the feeling. I remember once on scala-user when someone asked for advice on making SOAP calls. The first couple of responses were from very well-known posters and amounted to "don't use SOAP". Well, duh, but ignoring real-world cases where one might be, say, porting a legacy app with dependencies on SOAP services that you don't control is very off-putting.
That works on a case by case basis. I would love for us to become a noob friendly community which is inclusive rather than exclusive. We should be striving to explain things in as simple terms as possible to newcomers to help them get productive ASAP and let them feel comfortable and welcome - rather than confused and scared to ask questions lest they be belittled. Here's hoping :)
Me too. I didn't mean that just ignoring the more abrasive voices was enough. I was saying I've also seen the behavior you described, often enough to make me killfile someone for the first time in 10-15 years.
I understand :) I tried to do the same in the IRC, but my simplistic client doesn't seem to support it. 
Please excuse me, my statement was not justified; next time better I hope. I had meant the language sec, not the collection library. But even then the Scalac code does not seem to use the most complicated Scala features, so it would not need those either. I have quickly browsed the greater part of the Scalac sources. It is a big monster with 27 phases; the typer and some transformers impressed me, but at the bottom the code looks clear and it consists mainly of quite simple language constructs. The typical Scala features used in Scalac are: cases classes, match statements, traits, objects. There is already some string interpolation in use. There are slightly more than 1000 calls of map, fold, foreach, forall etc. There is only little other functional style, which I would consider more complicated. The used collection types are mainly List, Map, Set and Array; also HashMap, LinkedHashMap and ListSet. I guess in Scalac no strange inferences etc occur that you address in your presentation.
Case objects are fine for my purposes.
sent you a message
The question now is whether it has become easy enough to read to see what's wrong with these defaults: onStart: =&gt; Unit = () =&gt; (), onComplete: =&gt; Unit = () =&gt; (), "Unit" paraphrases to "I wish I was programming in an untyped language." You can pass anything to =&gt; Unit, even a Function0[Unit] which will never be applied. Not that it matters much in this case - but that's no reason not to draw the relevant lesson, which matters with frequency. I'm the guy who opened [that scalariform issue](https://github.com/mdr/scalariform/issues/61) so I guess you know how I'd like that sort of code formatted. But only the way I justified it - any form of justification which introduces wide expanses between name and type quickly undoes the benefits. 
It's funny that #2 arouses such ire, though I shouldn't be surprised. Unfamiliar == bad. There is a strong objective case for #2, certainly stronger than that for the others, as it minimizes scanning. Strong that is except for "what I'm used to" which generally trumps all other considerations by a wide margin. Especially among programmers. 
It's not that I (or others I know) don't care, I just can't think of any features I'm wanting for, Scala already has more than enough "stuff". I really just need what we already have to be less patchy, but I fear these kind of dev tasks aren't going to happen: * Unfuck/rewrite the collections library, less shared elements between mutable/immutable, remove .par (and roll in blitz) * Write a decent HashMap implementation (I shouldn't have to be reaching for Trove so much). Why bother coming up with @specialization if it can't be used in most of the situations it'd be useful (one of the many half baked features). * Unfuck the compiler (just for performance from my perspective) I use the language most days of the week for around 8-10 hours a day, so I'm not a hater and I'll be using it for the next couple of years, but it just seems a little late to fix/reduce things. 
&gt; IDE support is now on par with Java that's an absurd request -- Java IDEs (like Eclipse and IntelliJ) have had likely millions of developer hours thrown at them, while ScalaIDE for example has a team of 2 with community contrib here and there. &gt; compilation now goes twice faster than 2.10 With sub projects I really don't get the compilation gripes. Sure, full builds are slow, but whatever, daily dev is far more ~run than ;clean;compile. Incremental builds and sub projects largely mitigate the "scala is slow" notion. Scala 2.11 and latest performance enhancements to SBT will improve compilation further still. As for bug fixes and overall trimming down of the kitchen sink feature set, agreed; that's where Scala's success or demise lies.
&gt;&gt; IDE support is now on par with Java &gt; &gt; that's an absurd request -- Java IDEs (like Eclipse and IntelliJ) have had likely millions of developer hours thrown at them, while ScalaIDE for example has a team of 2 with community contrib here and there. I don't know about absurd. Last time I did larger Java projects was a few years ago using Eclipse. With the current Scala support in IDEA I must say this is tons better experience than my previous Java experience. The amount of highlighting, warnings and refactorings you have is impressive already. I wouldn't think a split second about doing another Java project, even if IDEs kept putting in new features. I sometimes dig into Java libraries as I use them and need to fix something, etc.; it gives me the creeps, I try to get "out of there" as fast as possible. Doesn't help that IDEA shows SAM interface calls as `-&gt;`, and any other niceties.
Just going to say that it's REALLY strange having a co-worker that moonlights as a super awesome conference speaker as well! I would also highly recommend checking out Jessie's blog http://blog.jessitron.com/ Jessie has been a HUGE help convincing the devs on my side of the shop to move from svn to git, and she has a lot of great blog posts and videos that are amazingly informative on git, scala in general, akka, etc. 
Work in Scala daily and have been on ScalaIDE since its inception. Things have improved hugely, am thankful for the advancements, but still, compared to working with Java source files, ScalaIDE is pretty laggy. Code completion for example is instanteous in .java sources; this is not the case with .scala sources. The presentation compiler will also lag far behind SBT at times (it has been suggested that one disable automatic builds in the IDE, but then you're always running behind current application state). Semantic highlighting is truly awesome...until it isn't; once gone awry, it doesn't return, usually not without a restart or a ;clean;compile/project clean contortion. Looking forward to Scala 2.11 + SBT 0.13.2 + whatever comes down the pipe with ScalaIDE (in the latter it's ironing out the rough edges vs. a couple of years ago where things were comparatively rather broken)
I've had the opposite experience as you on #scala or #scalaz on freenode. People are blunt, but correct and intelligent. I suppose it matters what someone values when looking for a community. I much prefer blunt, correct, and intelligent to coddling, welcoming, and incorrect. 
are you still looking? I'm part of a NY tech company doing a few scala/play apps. We may need some extra hands
2.11 features sizable reductions in spec, language, libraries, compiler, memory usage and compilation time.
Well now, that's interesting. Scala collections are infamously *slower* than their `java.util` counterparts, but I'd never heard anything about their memory usage. It doesn't look like their published code is anywhere near complete. Notably, there is only one test of any Scala collection, and it's a no-op (i.e. not implemented). I'm not sure where they got their numbers, but it sure isn't the code they pushed out. Another thing: Scala `ArrayBuffer` could be modified to perform closer to Trove `TIntArrayList`. The Trove collection is specialized to hold `int`s, which avoids the overhead of boxing them. Scala supports [automatically generating such specializations](http://www.scala-lang.org/old/sid/9), but `ArrayBuffer` doesn't receive this treatment. If it were modified so that it did, and the specialized version used in the test, how would it stack up?
I wrote a blog post about it: http://tech.simplyoverkill.com/2013/12/british-library-releases-fascinating.html Scala/Spray code is here: https://github.com/ctcarrier/bl-rest AngularJS app is here: https://github.com/ctcarrier/bl-web I would love any feedback.
I submitted a PR bringing the play-slick examples up to date with the 2.0.0-RC1, I should review and see what's needed for 2.0.0 final.
Thanks for posting this, very interesting. So is the corpus / database with the tags you've collected also publicly available?
I am trying to build Spray/ReactiveMongo app on my personal time, and I miss open source projects to learn from. There are introduction tutorials, a couple of nice articles on Cake Solutions blog and some documentation on the Spray site, that's it. I am eager to check your code learning from it :) Thank for your work! 
If you want people to actually tag: please add keyboard shortcuts ;)
The biggest thing you need to understand about `Route`s in spray-routing is that they are `PartialFunction`s of type `RequestContext =&gt; Unit`. That means they don't return anything (but do return, vs. `Nothing`, which means the function never returns, i.e. always throws an exception or calls `System.exit()`). So spray-routing uses CPS, or "Continuation-Passing Style," for flow control: each `Route` ultimately calls `complete()`, `reject()`, `failWith()`, or some variant on the `RequestContext` it receives, and that determines what happens next: other subroutes get a shot after `reject()`; a success response is sent after `complete()`; an error response is sent after `failWith()`; etc. `Directive`s like `get()` and `path()`, then, examine the `HttpRequest` in the incoming `RequestContext`. If there's no match, the `Directive` calls `reject()` on the `RequestContext` so the next subroute, if any, gets a crack at it. If there is a match, the `Directive`'s body—typically another subroute—gets control. Hope this helps!
Great! We need more open source projects that show how to use Scala's web stack. I liked your code but I dislike structure. Creating a separate dir for a single file seems like an overkill for me and it makes skimming through the code a little bit harder. Anyway, great work, thanks!
Oh yeah they already exist! 'y' and 'n' should work. I don't have any tooltips for that though so I'll add that.
Spray and ReactiveMongo are an amazing match. Since most everything understands Akka futures now there are no more pain points converting between different Future implementations or libraries that don't understand Futures at all. And it takes so little code to get it all up and running. Feel free to shoot me any questions if I can help I've been working with Spray for quite awhile now.
Right now the app is hosted on Heroku with MongoDB backing. My point is to definitely expose all the tagging data in a nice way to make it interesting to poke around. I was looking at Neo4J for that mostly because it come with some cool visualization tools. This is probably the next feature I'm going to work on so it's not just a black box.
Yes, that's what I mean. I know Java style that sometimes turns into package-orgy ;). Creating packages is indeed a good thing but I tend to do it 'on-demand' (no planning for future). I start by putting things in a root directory and as I notice files that should be together I create a package. Of course that's not a good idea for libraries that should be backward-compatible but that's a different case. Anyway it's a minor issue and anyone with a decent editor/IDE with project-tree can handle it. Carry on with a good work!
If you're interested in just learning DSLs in general and not specifically spray's, Finagle's Path has pretty nice syntax for matching as well https://github.com/twitter/finagle/blob/master/finagle-http/src/main/scala/com/twitter/finagle/http/path/Path.scala
&gt; Scala supports automatically generating such specializations, but ArrayBuffer doesn't receive this treatment. If it were modified so that it did, and the specialized version used in the test, how would it stack up? Scala collections will never be specialized, at least not using the current `@specialized` mechanism. The problem is, a class such as `ArrayBuffer` mixes in dozens of traits which would all need to be specialized. I think the Scala team decided that this is not feasible because the standard library would immediately grow by a large factor... The only solution right now is to use a dedicated collection class outside the standard collections hierarchy, which directly stores `Int` or any other primitive type without boxing.
This would be more useful if it was a complete list. It misses at least [Play JSON](http://www.playframework.com/documentation/2.2.x/ScalaJson) and [Argonaut](http://argonaut.io/).
It also misses [lift-json](https://github.com/lift/framework/tree/master/core/json). I think a feature matrix would be cool as well, since these libraries are different in other ways than just performance.
10 years, and Java still has majority market share. However the biggest improvements are seen statistically from indeed.com. Each year more and more jobs require Scala knowledge, which is a step forward into more enlightened programming. Hopefully with the rising popularity in differentiation between client code, and server code. More tech leads will commit to opening more opportunities to bring in Scala as a major player in the market.
Yep. Argonaut is principled (functionally pure, no reflection) and also happens to be faster than hell.
http://www.artima.com/articles/dci_vision.html
Out of pure procrastination I've just spent 20 minutes performing micro optimizations. I can make it run in approx 1/4th of the original time. Optimizations are as follows: * BKTree, replaced Map used with a TIntObjectHashMap (from trove). At this point I realized Levenshtein was the main culprit. The gains were minimal but became more significant as I put Levenshtein on a diet. On Levenshtein: * Used scalaxy loop optimizations (just a neater form of while loops) to avoid closure allocations * Preallocated array used in Levenshtein to a square array of side length of the maximum word length + 1 (30 for this word set) * Part of preallocation requires me to clean the used portion of the array each time (small cost) Init time to construct the tree ignored for both versions while benching (my benchmark practice is crappy, but I can't justify spending more time). Both are run in separate JVM runs, so are at least independent. Old version (1000 times asking for 'spell' distance 1): [info] ArrayBuffer(spell, pell, sell, shell, skell, smell, snell, spall, speal, speel, spelk, spelt, spill, stell, swel) [info] 3.4109493160000004 Old version (1000 times asking for 'spell' distance 2): [info] ArrayBuffer(spell, pell, sell, shell, skell, smell, snell, spall, speal, speel, spelk, spelt, spill, stell, swell, Nell, aswell, bell, bespell, byspell, cell, dell, dwell, ell ....) [info] 27.278181967000002 New version (1000 times asking for 'spell' distance 1): [info] ArrayBuffer(spell, pell, sell, shell, skell, smell, snell, spall, speal, speel, spelk, spelt, spill, stell, swell) [info] 0.791772444 New version (1000 times asking for 'spell' distance 2): [info] ArrayBuffer(spell, pell, sell, shell, skell, smell, snell, spall, speal, speel, spelk, spelt, spill, stell, swell, Nell, aswell, bell, bespell, byspell, cell, dell, dwell, ell ....) [info] 6.691533594 New Version #2 - Without the square matrix (1000 times asking for 'spell' distance 1): [info] 0.689171521 New Version #2 - Without the square matrix (1000 times asking for 'spell' distance 2): [info] 7.770038131 Edit: Added two row array version at tonosoytu's suggestion. It also avoids the needless copy through alternating rows. I've tried implementing the alternate rows through a few approaches (if/else as well as an encasing 2 element array and modulus), none of them get faster than the huge square array. I mean it's not crazy that the square matrix is faster, it's only 3600 bytes. I have 32KB of L1 cache on my sandy bridge. Edit 2: Swapped scala.math.min for a simpler version out of curiosity (without NaN handling etc.), gained another 10% (only did this to new version #1). 
I don't know if you will get some boost, but you can calculate Levenstein with only two rows of the array: http://en.wikipedia.org/wiki/Levenshtein_distance (at the bottom). At least you’ll not waste n^2 memory for that matrix. The recursive version is not tail recursive, but it can probably be changed a little to be one. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; *Here's a bit from linked Wikipedia article about* [***Levenshtein distance***](http://en.wikipedia.org/wiki/Levenshtein%20distance) : --- &gt;In information theory and computer science, the **Levenshtein distance** is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other. The phrase **edit distance** is often used to refer specifically to Levenshtein distance. It is named after Vladimir Levenshtein, who considered this distance in 1965. It is closely related to pairwise string alignments. &gt; --- ^Interesting: [^Edit ^distance](http://en.wikipedia.org/wiki/Edit_distance) ^| [^Damerau–Levenshtein ^distance](http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance) ^| [^Vladimir ^Levenshtein](http://en.wikipedia.org/wiki/Vladimir_Levenshtein) ^| [^Levenshtein ^automaton](http://en.wikipedia.org/wiki/Levenshtein_automaton) [^(source code)](https://www.github.com/acini/autowikibot-py) ^| *^(/u/yonosoytu can reply with 'delete'.)* ^| *^(Summon : Wikibot, what is &lt;something&gt;)* ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/allinonebot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/scala/comments/1wckqw/using_bk_trees_for_spelling_correction_in_scala/cf0skme)
Like I say at the end of the article, I will introduce higher order functions in my NEXT post... 
You don't need to copy one vector into the other, if you keep changing which one is v0 and which one is v1. Rewrite every instance o v0 and v1 as v[i % 2] and remove the final copy. I think it will work.
I thought that as well when I reviewed it, and you're right, it doesn't read from the current row past where it's already written to. I've removed the copy through alternation and updated my results. It's ended up being a smidge faster than my last two array version, but it's still slightly slower than the square matrix on distance 2. Past this point my benchmarking methodology doesn't really cut it.
Smaller functions. Move the try catch to its own Def. Also the catch clause doesn't return string. Shouldn't it? 
After getting close to 5 years of Scala, I have no idea what idiomatic scala is, but I have a couple of questions before I can try to recommend constructs/styles. As a sidenote, you should construct the regex outside of the map block. You only need to build it once, and it's a static construct. Catching the exception without returning anything is hosing your return type. Pasting this in to my editor tells me the map expression returns Seq[Unit] (just mapping over a Seq[String] to get it to work). I'm not really sure of your intent? If there's no match against the date pattern, is "" really appropriate? Do you really want to continue the computation if you get a invalid date at the parse stage, or should we error out? The style I'd change it to would just be slightly heavier use of option, I'll do a code sample once I understand your intent. 
&gt; As a sidenote, you should construct the regex outside of the map block. You only need to build it once, and it's a static construct. This is important. I don't know if Scala piggybacks on Java's regex engine, but I think Java `Pattern` objects are not super lightweight; you definitely want to construct them as infrequently as possible.
Oh, and for the lazy (hey, we're all programmers after all; we should be lazy), here's the contents of the gist: val dateParser = new java.text.SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss") val dateOutput = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss") // Map through the list of emails .map(el =&gt; { // How would you guys avoid this val date = """(?s).*Date: ([\w\d\s,:]+)""".r.findFirstMatchIn(el) match { case Some(m) =&gt; { try{ dateOutput.format( dateParser.parse(m.group(1).trim()) ) }catch { case e: Exception =&gt; println(e) } } case None =&gt; "" } })
Not sure if this is exactly what you want, but to me if you're returning an empty string in the case of an exception, you really just want to return nothing val someDates = List("Date: Wed, 5 Jul 2015 12:00:00 -0500","bad date") val dateParser = new java.text.SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss") val dateOutput = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss") val regex = """(?s).*Date: ([\w\d\s,:]+)""".r for { item &lt;- someDates firstItem &lt;- regex.findFirstMatchIn(item) parsedDates &lt;- Try(dateParser.parse(firstItem.group(1).trim())).toOption formattedDates = dateOutput.format(parsedDates) } yield formattedDates In this case, this will yield List(2015-07-05 12:00:00) Hope that helps! For comprehension is nice when you're transforming and parsing data as it makes it easier to follow. Plus you can still do exception handling with the Try monad. edit - for readability you might want to extract the line that feeds into parsedDates into a function, as it's quite a lot to parse at a glance
So I really like spray.io, and I learned it on my own and suffered through it I guess. It's not the simplest thing, but the DSL isn't really all that bad, chained partial functions. I understand it after tinkering with it for a bit. A reasonable explanation behind why spray is suffering from "engineering ineptitude" would be nice, especially since spray is going to be [added directly](http://www.marketwired.com/press-release/Typesafe-Reactive-Platform-Acquires-New-High-Performance-HTTP-Foundation-1841738.htm) to the Akka project you espouse as being excellent.
I'll try to stay positive and say I'd appreciate that explanation, too, but the judgement against scalaz and spray is so wildly off the mark I'm not sure I have any reason to trust such an explanation.
What top-tier libraries come with massive caveats? To be honest, what I see here is one person offering an opinion with literally nothing in the way of justification. FWIW, I've been using spray, scalaz, and SLICK, to name three examples, in production for almost three years among them, and while I'll be the last person to deny they have a learning curve, "massive caveats" is, quite simply, false.
My personal view is that DSLs and operator overloads in libraries are often well-intentioned, but usually misplaced. It's fine if it's a core competency for your project - e.g. you're doing a DNA modelling program and you have a DSL that makes sense to people who know a whole hell of a lot about DNA. Otherwise, it will often make the code harder to read and increase the learning curve for new engineers. Similarly, unless you are doing academic CS or coming from a Haskell background, the majority of Scalaz's operator overloads are not going to make sense.
...okay? So what are the massive caveats?
Scalaz is great in moderation. For example, let's say you have some instances of Map[String, BigInteger] that you need to merge, such that Map("a"-&gt;5, "b"-&gt;2) + Map("a" -&gt;5,) = Map("a"-&gt;10, "b"-&gt;2) Scalaz has semigroup instances for Map and BigInteger (semigroups are mappings (T, T) =&gt; T). That means that you can perform the above operation using map1 |+| map2. It's a small thing, but it drastically reduces boilerplate.
Why not use the built-in `++` operator on the maps?
Looks like there's some implicit Option to List conversions happening here. I really don't like that it happens by default, but overal lvery nice. 
Look back at void_fraction's example. ++ won't add the BigIntegers in the resulting map.
I guess easier said than done but why hasn't there been an impassioned individual that has written an alternative to sbt or whatever?
It seems to be adding the values *in addition to* merging the hashes.
Like ll_cool_james says, ++ won't add BigIntegers with the same key. What's cool about |+| is that it will also work for Map[String, Map[String, Int]].
Some of the Twitter's stuff, e.g. Cassie (Cassandra client). It uses it's own implementation of Futures, doesn't have current versions in repositories and can't be compiled out of the box. It's easy enough to add a wrapper to Java client but still.
Sbt is what will kill scala. It's a complex DSL which makes no sense most of the time. Most of us only copy recipes from others, but to so anything non-trivial takes way too long. And most of the time is spend is finding some arcane setting. 
I don't think Scalaz has a negative effect on adoption of Scala. As I looked over it and it quickly became apparent that it was made to show off Scala's capabilities and intelligence of its creators so I quickly brushed it away and never looked back. Maybe I'll look into into if I somehow acquire a taste for category theory, so probably never.
Here is Dispatch tutorial: http://dispatch.databinder.net/Dispatch.html I don't see any operator overuse (except "/" for chaining part of url). And I don't think that it is more opaque that: https://github.com/AsyncHttpClient/async-http-client which is praised among java devs.
I'm perfectly happy with SBT. There is just no better build tool available, both on the JVM and probably outside of it, too.
&gt; I don't think Scalaz has a negative effect on adoption of Scala. I think it did, because a lot of its code was [shown around to see how impenetrable Scala can be](https://github.com/scalaz/scalaz/blob/scalaz-seven/core/src/main/scala/scalaz/Apply.scala). I bet this turned a lot of people off Scala. The scalaz people started scaling down the symbols and adding English aliases to common functions but I can tell you from hanging out in #scalaz that a lot of committers are unhappy about this trend and wish they could retain the original style. I like some parts of scalaz myself but it's become huge in size and scope (it even has character converters now) to the point that it's beginning to be to Scala what Spring is to Java. The irony is that it now has long identifiers (e.g. "StateTEffectInstances0"), which used to be a cause for ridicule in Spring. 
Well, I know two kinds of people who consider using Scala. Some of them see it as "Java with `map` and `reduce`" (that's me and some of my friends going from C# background) and some of them see it as "Java with monads". I tend to focus on good parts and just ignore the bad ones. Even the most hardcore category theory fans I know never suggested using Scalaz. I really don't consider Scalaz an essential library, if someone is starting with Scala, the first libraries he would probably use are sbt, Akka, Play, database drivers and something like this.
So these aren't caveats that these frameworks come with: they're _your_ opinions about them. That's fine, I guess, but I feel like the "I don't get sbt! Too many operators in dispatch and scalaz!" stuff has been done to death. Some people can handle it, some people can't, and there doesn't seem to be much give in either direction. But just to be clear: there's nothing here that indicates anything _wrong_ with sbt, dispatch, scalaz, or Lift; there's just an indication that you don't _like_ them.
you can still use maven :D
Option is a type of sequence - it contains either 0 or 1 elements, so no fancy conversions are needed. If you have a List[Option[T]], flatMap can be used to get a List[T]. For example, you can expand the above to: val someDates = List("Date: Wed, 5 Jul 2015 12:00:00 -0500","bad date", "Date: Wen, 78 Jul 2015 12:00:00 -0500") val dateParser = new java.text.SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss") val dateOutput = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss") val regex = """(?s).*Date: ([\w\d\s,:]+)""".r someDates.flatMap(regex.findFirstMatchIn(_)).flatMap(m =&gt; Try(dateParser.parse(m.group(1).trim())).toOption) 
Pretty much nobody outside of academia has any idea what "applicative functor" is.
I use them in production code to combine monads. Your move.
Are you a Ph.D?
I was a Java dev at $BigCo until September, now I work at a Scala shop. I taught myself Scala for fun starting early last year, and now I'm doing the same with Haskell and some basic Category Theory.
&gt;Option is a type of sequence It's not. There's an implicit conversion. 
&gt; you can still use maven :D That's what we do at my workplace. No one likes Maven, but we like SBT a whole lot less. I often see newcomers on scala-user advised that "SBT is what you use to build scala projects", or some such, implying that SBT is *the* way to do it. I have to imagine that when some of those newcomers are turned off by SBT, they'll be turned off by Scala too, since Scala and SBT were strongly associated by (I presume) well-meaning posters.
I'm not entirely sure if you're correct. I dont think the Option is used as a sequence here, simply Map and FlatMap; using For is syntactic sugar for those methods. 
Don't forget scala regexes implement unapplyseq (haven't tested the code but it's something close to this): // If you call this function a lot, consider moving this val outside the function so it isn't continuously re-building the regex val dateRegex = """(?sx) .*? # Match everything up till the first... (the '?' makes this 'non-greedy' so it will match up till the first Date bit) Date: # Date with a colon \s* # Optional spaces (make this '+' if you really want, but no reason to do so) ( [\w\d\s,:]+ # Capture all words, digits, spaces, commas, and colons ) .* # Everything else in the line (so the regex matches) """.r // The real magic! val dateOpt: Option[Date] = el match { // The scala regex class implements the unapplyseq method which means you can use it to "destructure" regexes in case/assignments // All "variables" inside the parens are assigned to each capture group case dateRegex(date) =&gt; Try{ dateParser.parse( date.trim ) }.toOption // Regex didn't match case _ =&gt; None } /* * Format the output, returning a blank string otherwise * * You probably should consider returning Option[String] (drop the `getOrElse ""` part). * Then in your calling code you can decide if you want a blank string or whatever else, since Options are amazing! */ dateOpt map dateOutput.format getOrElse "" You could probably put the dateOutput.format bit inside the Try as well but I personally find this cleaner... and that should never really fail...
I agree that SBT is overengineered and unstable. I tried recently to port a plugin I used from SBT 0.12.x to 0.13.x. Copy-paste didn't work. After diving a bit I learnt that SBT contains two undocumented and complex implementations of type-level heterogenous lists... And I just wanted to launch a new Java process...
I think Scalaz could use some modularisation. For example, moving monad transformers to a new package, most concrete types to another, and so on, leaving scalaz-core with only basic typeclasses and sugar.
I think that [was yanked](http://docs.scala-lang.org/tutorials/tour/regular-expression-patterns.html). In the API docs, I don't see an `unapply` on [`object Regex`](http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex$). There are, however, extractor object [`Match`](http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex$$Match$) and [`Groups`](http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex$$Groups$)
This, so much this. "Java with map and reduce" is a bit narrow, higher-order functions and closures allow you to reuse a bunch of code that is impractical in Java, and the simpler syntax for case classes is a huge shortcut, and pattern matching... Collection manipulation is awesome but it stalls if you have to keep hitting java libraries very often. The idea is that lots of Java developers want Java++, not Haskell. Something like scalaz is a bit of a problem as its mere existence causes adoption in projects where developers are wholly unprepared to handle the design patterns scalaz requires you to understand. You only need one developer dumping a few days' worth of code that is effectively unreadable by the rest of the team to sour the whole team to the Scala experience. 
At least for me, it really has to do with the amount of symbols used. So many symbols simply causes me to not remember what the code does when I revisit it after a period of time. It's the same reason I don't like Perl. Scalaz, Spray, Dispatch, and SBT all suffer from this to a certain degree.
I'm personally hoping people start using Gradle instead of SBT. It's not perfect, either, but I still prefer it.
I literally used it yesterday so I'm pretty sure it wasn't removed. Also it's not unapply it's unapplyseq. *edit* Also it's not on the Regex object it's on the regex class because you call it on an instantiated regex object, not via the companion. Proof: adam@hades ~ % scala Welcome to Scala version 2.10.3 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_51). Type in expressions to have them evaluated. Type :help for more information. scala&gt; val r = "1(2)3".r r: scala.util.matching.Regex = 1(2)3 scala&gt; val r(num) = "123" num: String = 2 scala&gt; num res0: String = 2 scala&gt; 
&gt; The idea is that lots of Java developers want Java++ Which is why we also have Kotlin and Ceylon, both trying to be a Java++ but with slightly different scopes and ambitions. I'm curious to see if any of these will become popular. 
I think you're a member of the set "pretty much nobody". E.g. you'd have to demonstrate -- ballpark figure here -- maybe 10'000 people who do know what applicative functor is, before we'd violate the "pretty much" modifier?
He's like a drug addict, hooked on Scala -- can't kick the habit ;-) In the end it's a good thing that Paul P and others point out deficiencies in Scala as that _may_ result in actual Scala language reform (Dotty + sane collections) or the creation of an entirely new language that gets it right-ish from the start. From the outside looking in I've rarely been bitten by inconsistencies in Scala collections as demonstrated in the presentation; however, it's hard to argue against a lean and mean Scala from the ground up.
This is a step that comes after we have solved the problem of JAVASCRIPT PROGRAMMERS, First Focus on replacing the JS with Scala, specially dom events, then we go here. Yes we can !
If he thinks he can create a better collections framework then good for him, and I'd gladly use it if it is genuinely better somehow (I'm not holding my breath since I still often need the performance of mutable collections). Publicly trashing the work of your former employer does seem in bad taste though. I honestly have never bumped into any of the issues he complains about, and I've been using Scala for years. If he comes up with something even better than the Scala collections framework I'll be impressed, until then less talking/whinging and more doing.
I think C# can be considered a success for Microsoft. But the reason is that they poured a lot of energy into creating great tools for the language. That's why Kotlin has slim chances of becoming popular and Ceylon has even less: Java has a lot of mature, stable, brilliant tools that alleviate the problems with the language itself. When I code in Java, I surely have to type a lot and then read a lot, but when it comes to refactoring, testing, packaging, everything just works. Scala has problems with that, but in turn gives lots of features so I can save time on actual coding. Both Kotlin and Ceylon have worse tooling than Scala, are little bit less expressive, and offer less interesting features. Unless they get a "killer app", they will fade into obscurity. 
they voted me down(some posts were deleted, even my accounts get deleted, i get banned all over the internet) when i did voice against SBT, that discourages Critics and keeps Scala in dark ages. About SBT, we dont need it, no one does, many are Baffled to the hate about SBT, its plain and simple, Titans who want to do LARGE PROJECTS CANT Rely on SBT, we cant have things on CLOUD, No. we need MORE Sutff in IDE (portability for developers), thats how things work for SUPER LARGE PROJECTS. When proponents claim holiness about Scala and they are Right, they need to ignore the academic fans (like those who vote down SBT bashers) and focus on need of the real Developers, us the SOFTWARE ARCHITECTS, Since if we cant bash SBT we are out of choice and we will have to BASH SCALA. The writer (Nikita )of the article is a PRO, if you cant respect his views, Scala deserves a DEATH, that should serve a lesson to future language creators.
That's an argument for learning what they are, not against having/using them. [Functional Programming in Scala](http://www.manning.com/bjarnason/) does a great job explaining them.
Exactly! Scala allows you to do things you can't easily do in Java, with a lot less whitespace and brackets. Functions, predicates, comprehension, partial functions to name a few. I do agree that some people love to fit 100 lines of code into one. However, I have started to see that change. Writing bad, unreadable and hard to follow code is possible in any language. 
The talk is 80% rant; 20% substance, I was hoping for something better. The breakup is clearly still too fresh. I was hoping for an indepth look at these PSP collections &amp; the tradeoffs he made but we got ~3 snippets where he showed his collections do better... so where is it worse or want can't be done? Scala collections are eager by default because the JVM is _very_ bad a optimizing lazy operations. How do PSP collections perform when you do a simple map operation with no chaining? 90% of all collection operations are simple maps, filter &amp; flatmap with very little or no chaining and most of the time we work with tiny collections. If you have very big collections and/or many chained operations scala still offers you the tools to do lazy/streaming operations. Of course a new collections framework could find a new tradeoffs but it seems like paulp was more interested in ranting about the current state of affairs.
&gt; Unless they get a "killer app" It's interesting that the only functional language that has actual *products* written in it is Erlang. (Product is something you can `apt-get install` and use not caring about what is going on under the hood). A killer app for a new language could be a framework for modern (single-page, push-based) web applications which is long overdue.
He seems to have some sort of fascination with parallel collections, which In my experience have few useful applications.
Try IntelliJ IDEA and sbt-idea plugin that generates IDEA project files. Though I don't know how it will behave for complex projects, I've only used it for simple ones (basic Scala module and basic Play app).
Because we don't need a Scala specific build tool in the first place. We only need Scala plugins to the popular general JVM build tools Maven and Gradle (and to a lesser extent Ant).
Many of the people who are complaining about SBT haven't used the latest 0.13 version which has cleaned up the syntax majorly. Many of the people who are complaining about Dispatch's operator overloading haven't realized that that syntax was cleaned up years ago after immense backlash, and there are many alternatives - including all the traditional java http clients. Judging Scala as if these, or any, of its 3rd party libraries are required is unfair. And while I wouldn't personally use scalaz on my projects, I won't bash it as an indirect way of stroking my own ego like so many people seem to do (e.g. "this thing that I don't understand must be stupid! Everyone has to agree with me that it's stupid!") I simply understand that: * For now, I don't have the time or patience to learn and memorize the category theory and operator overloading it utilizes * I'll never have the patience or charisma to convince my co-workers to learn it as well And despite that, I still use Scala, build good software and enjoy the elegance it affords me.
I don't know about strictly *on* the JVM, but if you're including things *off* of it, then I would **strongly** disagree with the assertion that SBT is the "best" built tool available: take a look at Haskell's `cabal` or `shake`, for example.
That's a nice example, thanks
I believe the explination given is that he left because of the issues mentioned in this and his other "why i left" talk. However, he still sees Scala as the best tool available for the programming he does. If someone were to makes a new language inspired by Scala, but with the changes he mentions, he would use that.
&gt; If he's leaving, why the hell is he writing a new collections library? He's trying to change things he's complaining about, a concept which seems hard for you to grasp. It's much easier to just criticize, isn't it? If the world was made entirely of people who think like you, we would never make any progress. 
`cabal` ... really ... REALLY? You must be joking. I think even most Haskell people agree that it is terrible in some of its core functionality (not something superficial like "I don't like SBT's syntax").
Fix the IDE?
Please get help for your mental health issues.
Why would I use something terrible, if SBT just does it better?
Thanks, but all the other times I've tried IntelliJ, it's just sucked differently, not less. :\ And the fonts look bad on Linux.
&gt; this is the real problem with SBT, not the DSL itself; if we were able to click through and interactively discover the library, not only would we save HUGE amounts of time (so much wasted time, painful to think about), we'd be able to utilize more fully the power of the library. Hear, hear. I'm actually really interested in tools like SBT that take a hybrid approach that's part procedural and part declarative. I've used procedural build tools (Ant, make, shell scripts, etc) and it sucks to have to write the same code over and over to collect class files, jar them up, etc. Maven improved on this by going fully declarative, at the expense of making situations like integration testing, where I'd really like something procedural, suck really bad. I'd love something that's what SBT is in theory - a tool that allows me to describe most builds declaratively, while still allowing me to write little snippets like *start app server, run tests, stop app server* without endless XML- and lifecycle-binding hell. Hopefully we'll get there someday.
Or you could institute basic coding standards.
&gt; Many of the people who are complaining about SBT haven't used the latest 0.13 version which has cleaned up the syntax majorly. But it's still awful anyway. And documentation is still a mess. &gt; Many of the people who are complaining about Dispatch's operator overloading haven't realized that that syntax was cleaned up years ago after immense backlash According to the current source code from Github - no, it wasn't. Here is an example: https://github.com/dispatch/reboot/blob/master/core/src/main/scala/requests.scala &gt; and there are many alternatives - including all the traditional java http clients. This is actually true. Also there are traditional Java libraries for parsing JSON, as well as traditional Java libraries for data persistence. Hell, there are several traditional java library for everything. Given this, there is more incentive to program in Java, than in Scala, right? In my personal opinion, a language without a good set of native libraries is essentially a dead language. 
SBT is nice, and I use it, but you at least have to admit having two types of 'build' files and having a weird DSL isn't what makes SBT good...
That's grand, but he's not going to make that happen by creating drama.
If he was trying to solve problems, why in fuck's name did he pull that dramatic exit bullshit?
Someone explain what you gain using subtype polymorphism for a collections lib over implicit conversion + pararametricty? (Aside from a tiny amount of code reuse). 
Sure, it was confusing to me too. But so was recursion when I first learned it. Or pointers to pointers. Or lambdas. I didn't come out of the womb knowing much at all about programming. I've banged my head against the wall quite a bit all through my career learning new concepts until they sunk in. The #Scalaz chat on freenode are some of the most helpful programmers I've ever encountered. Their vocabulary may not be the same as those coming from an imperative background, but same could be said for the GoF for someone who hasn't done OO. 
The issue with the `f` function that is used is that it is not referentially transparent. If it was referentially transparent and had no side-effects, the computations would evaluate to the same result. "Pure" languages like Haskell solve it by guaranteeing that all functions are referentially transparent and have no side-effects. In Scala, I would personally just use referentially transparent functions with no side-effects whenever I call `map` or similar higher-order functions. That way, you can also safely convert the collection to its parallel variant. Delaying calculation of the results or carefully reasoning about the evaluation order are other solutions. One potential solution is to incorporate an effect system in Scala. There seems to have been done some work in that direction by Lukas Rytz: [github.com/lrytz/efftp](https://github.com/lrytz/efftp). EDIT: `f` should be `g`. EDIT2: It turns out that an extra assumption is necessary for the equality to hold, namely that for elements used in the set, `x == y =&gt; f(x) == f(y)` must hold. See [this](http://stackoverflow.com/questions/19177125/sets-functors-and-eq-confusion) for more information.
i'm not going to lie to you and say that reading Scalaz code is as easy as reading most other scala libraries. What you have to keep in mind though is just how 'abstract' Scalaz is. What this means is once you invest in learning a couple of the type classes, you start using them *everywhere*, no matter the domain or the application. This lets you write an awful lot of code one level 'up' from where you might be used to coming from java/C++/C# land, so the investment pays off tenfold. I'd be happy to explain what some of the type classes are, though I'm far from an expert. 
What I said is not circular reasoning because you ignored the bulk of my point: the reason for why Java++ will never happen is because a language has to be different enough to outweight the dissatvantages that come from adopting a new language. Plus, Java is fundamentally broken and so if the purpose is a better Java, there's nowhere you can go. In fact, everything that's wrong with Scala comes from its Java inheritance.
You must be new to the tech scene. Most advances have happened because of drama and noise. 
Yeah, the next big language shouldn't run on JVM. It doesn't need direct interoperability with Java libraries, it just need good enough facilities to use external libraries like interpreted languages have. People don't call C functions directly from Ruby code but they still can use C libraries.
It is true that g (not f) is not referentially transparent. But I don't think this is what is causing the bug though.
I would remove implicit conversion from that list as well
I'm not. I arrived on the scene as a little kid in the early 90s. I've observed plenty of drama and noise being generated by *marketing* types, but when drama and noise are generated by actual coders, shit doesn't usually seem to get done.
Thanks for the correction, I have edited my reply. Ensuring that both `f` and `g` are referentially transparent and have no side-effects will fix the issue in question. For the first case, val f: Int =&gt; Int = _ % 3 Set(3, 6, 9) map f map g , with `g` being some arbitrary, referentially transparent function with no side-effects, the first `map` would result in `Set(0)`, and the second map would transform that into `Set(g(0))`. In the second case, Set(3, 6, 9) map (f andThen g) , we would get `Set(g(f(3)), g(f(6)), g(f(9)))`, which evaluates to `Set(g(0), g(0), g(0))`, which due to referential transparency would evaluate to `Set(g(0))`, which again due to referential transparency would yield the same result as in the first case. EDIT: It turns out that an extra assumption is necessary for the equality to hold, namely that for elements used in the set, `x == y =&gt; f(x) == f(y)` must hold. See [this](http://stackoverflow.com/questions/19177125/sets-functors-and-eq-confusion) for more information.
Hard to believe you've been around for so long and you don't know about famous dramas such as rms/jwz (which led to the creation of modern emacs), or Linus on C++ and git, or DHH's frequent outbursts on stage or in blogs, etc... 
&gt;rms/jwz (which led to the creation of modern emacs) Lol, Emacs. &gt;Linus on C++ Meh. It's all glorified PDP-11 assembly to me. Pointerless VMs or GTFO. &gt;and git Git is garbage. &gt;DHH's frequent outbursts on stage or in blogs I wouldn't know; I don't pay attention to Ruby.
I think it is possible that users of the collection libraries have encountered the issues in more indirect ways. A lot of his perspective seems to be from an implementation point of view. And several of the issues he mentions (such as the very high number, 556, of `asInstanceOf`casts, the suppression of variance checks, the lack of `final` and `private`, etc.) are rather serious in my opinion from a maintenance and improvement point of view. And these in turn makes it difficult to change the collections, optimize, detect and fix bugs, add new collections, etc., which again affects users in an indirect way. I still personally like the collections library and the many nice features it offers, but it is not without issues, and I think a better collections framework could be interesting and useful, especially if some of the collections have better performance than the corresponding collections in the standard library.
You just set a new record in terms of missing the point of a post. 
Absolutely! I would really prefer if they just got rid of the DSL one. What I wanted to say it that these are all superficial issues, while the core functionality is rock-solid; unlike some "tools" which still have issues with dependency management, versioning, resolving artifacts etc.
Listen, SBT is used by the damn ACADEMICS, Real Software development needs IDE and that needs portability of the code Directories, SBT removes the Jars form the loop, that breaks everything. We must get back at adding our Jars manually, and zipping up our code projects Directories. About the down voters here, these kids have no BRAINS, they are just there to get their certificates and think they are pros, these REPL scripters are the source of all problems in Scala, just as they screwed Linux in the 90s.
After some months of having deleted my reddit account, couldn't resist commenting on this. This seems to be all the rage lately in the Scala sub-reddit. As someone who has written a fair amount of production Scala code, I feel I have to chime in. As a user of the language I have not had any (major) problems because of the collections library internals. If Paul Philips, as a Scala internals developer feels that it's all gone to shit, then that's ok, but don't make such a drama to call Scala useless and horrible, because that it is not. That's like saying a race car sucks because under the hood there's a bunch of ugly wires and grease. I (mostly) don't care. The original designers of the language put practicality above purity and in my opinion that is the right thing to do. I can do stuff with Scala, I've used it before, I'd use it again. I have no interest in touching Haskell for example (not talking bad about Haskell, just comparing Scala to a "pure" language). Paul Philips seems to be from a school of thought that says that languages should at all cost make you do the right thing. This is debatable, and again, for me, I prefer languages that give me flexibility (Scala, C) rather than languages that bind me to their paradigms (Java, Haskell). Also, it's easier to judge a thing after it's done, and say this sucks, and that everybody sucks. Which is what Paul is doing. He should know better that things are rarely designed right the first time around. If he just shut up and says "I'm going to make a better collections library" then fine, good on you, and good for everybody. Just because the "steering committee" for the language decided that it would be better to spend resources elsewhere (practicality over purity), then you don't have to get all fussy about it. And that's what I have to say about it :) 
Again? This slide deck has been discussed already [two weeks ago](http://www.reddit.com/r/scala/comments/1vdlui/paul_phillips_i_quit_a_dream_job_because_i_lost/) Oh, he replaced xkcd with Dilbert, that's new. I like this guy, I like Scala-the-language. I don't kike drama. I will be happy if he writes a new collections library that is better. Remember Scala Actors? Remember 2.8 collections? All gone. Where there any drama? So why now?
This is just so incredibly confused ... you realize that you can add your jar files to lib/ and SBT picks them up automatically?
Scala gets a bad rap for producing not so readable code. I believe we can pick up some things from Python to make Scala more readable. Thoughts? Source: This [hacker news](https://news.ycombinator.com/item?id=7151433) post.
AAAplus is just a strange troll, it's not worth thinking about what he writes.
Don't forget the other idioms that are not listed on these slides: - Mixing `underscore_case` and `camelCase` and `PascalCase` and `flatcase` rocks #assertEquals #OrderedDirect #frozendict - It's ok if the standard library doesn't work, just work-around/monkey-patch it #urllib #urllib2. - Special-case syntax that you are advised not to use in the real world is perfectly fine #assert-vs-self.assertEqual #type(x)-is-y-vs-isinstance(x, y) - Global mutable state is the way of the future - `eval(str)` is great, we should do more of it. #enums #namedtuple
Just a few nitpicks: * You don't really have list comprehensions in Scala. * Everything is always "enumerated" * Use values not variables, don't assign things more than once. * Scala's Truth and Python's Truth are very different. Eh, I'm not sure this brings a lot of value to Scala, personally.
Monads are applicative functors (in the same sense that a java.lang.Integer is a java.lang.Object). Futures are monads, and they are therefore also applicative functors. I think you are confusing the operation |@| that is defined as part of the applicative functor API (but here I am using the term "API" informally), with the functor itself. Specifically, applicative functors define two operations (in addition to any operations that were already defined by functors -- an applicative functor IS-A functor). One of them lets you "wrap" a value into your applicative functor (e.g. a constructor/factory-method for Future which, given a constant, returns an instance of Future which immediately returns that constant would satisfy the contract for this operator). The other operator takes a wrapped function of type **A**-&gt;**B**, and a wrapped value of type **A**, and then "somehow" produces a wrapped value of type **B**. There is nothing inherent about applicative functors that say that they bypass ordering, or anything like that. That may be a specific property of the way the Future class implements its applicative functor operators, but it certainly isn't a property of applicative functors themselves. (Which makes sense, if you think about it: Applicative functors are a concept from purely functional languages, and in a purely functional language, the order in which functions are evaluated can always be done in parallel). TL;DR: Maybe the set of people who don't have any idea what an applicative functor is is larger than we initially thought. E.g., maybe it includes me!
It's true, everyone hits a variation of List(1,2,3) contains "your mom" at some point, and the compiler stays silent. For the most part the compiler has your back...until it doesn't, which can lead to surprising bugs. At any rate, until there's a better alternative (whether it's Scala Next or some other language like Kotlin, Ceylon, etc.) I'll continue on happily with a language that is, IMHO, head and shoulders above any statically typed alternative on the JVM, warts notwithstanding.
Yes, I agree while the guide by itself does not bring much value. I was hoping posters would pitch in with 'idioms' that do work in improving Scala readability.
Well, that sounds nice in theory, but it's near impossible in practice. 
Yes and no. Yes for idioms, no for "like these". These ten examples are very silly (sorry) and very specific to the way Python evolved I guess. - prefer immutability over mutability - prefer composition over inheritance - prefer functional style over imperative loops - use the standard collections where possible - use meaningful names; use symbolic names only if they make life easier or code more readable - use standard naming practices (single upper case letters beginning at `A` for type parameters, lower case camel style for methods, etc.) - adhere to standard Scala style formatting (indentation, scaladoc comments etc.) - ... __Note__: "prefer" doesn't mean "must". There are good cases where you want to use mutability, inheritance or symbolic names.
- don't write another JSON library. Use one of the twelve that already exist
Well said, and worth reactivating your account :)
I guess this is just how you get the last bit of performance out of the JVM. See the recent scala-internals discussion about whether it's necessary to be able to extend and override things in `mutable.HashMap`. Martin Odersky is clearly of the opinion that saving "another closure" is worth this construction. Personally, I am not sure that this is the best approach. But then, I also don't think it's worth getting into a religious war about it.
Alvin Alexander is also the author of the O'Reilly Scala Cookbook, which is one of the best Scala books I own.
&gt; Wow, this subreddit has some terrible people If your long history of downvoted posts is anything to go by you're top of that list.
1. Not relevant for Scala. 2. Not possible in Scala since it has strong typing and don't allow implicit conversion of diverse types to Boolean. 3. Use collection.contains(element) for contains and collection.foreach { block } for iteration. 4. Not directly possible in Scala, and for a good reason since Scala favor immutability. If you need to swap values like that, you should reconsider your design. 5. collection.mkString() 6. Not so important for Scala since we have static typing, and I wouldn't recommend it as a default practice in Scala in for cases the static typing doesn't cover. 7. collection.zipWithIndex 8. The important thing is to do it functionally, and avoid the explicit imperative collection building. Then you can also use Scala's for expressions if you like. So either: data.filter { _ &gt; 10 } map { _ * 3 } or: for (i &lt;- data; if i &gt; 10) yield i * 3 9. Map(keys.zip(values):_*) 10a. Not directly possible in Scala. You can emulate it with *return*, but it is usually not a good idea. Try to be functional instead. 10b. Scala's collections and for expressions. 10c. a) Good for Scala also. b) Sometimes yes, not always. 10d. Good for Scala also. 10e. Not sure this is a good idea. 10f. Not sure this is a good idea. 10g. Can be done in Scala with sequence.sortBy() 
Yes.
Briefly. It fits the same hybrid declarative-procedural category of build tools as SBT, but Groovy has always been off-putting to me.
Its been two years since I've programmed scala. Never had too many problems with the language in my own use, but then I never ventured too far in the type system as Paul did. He of course has been on the receiving end as the main maintainer of the compiler and library - so I can certainly understand his agitation, working tirelessly on keep pace with bugs. It never occured to me to question the scala collections with the [redesign in 2.8](http://www.scala-lang.org/old/sid/3) at the time. Looking at the inheritance hierarcy I have to agree with him that it got out of hand. I don't think its worth it if some generality could be shed in exchange for simpler interfaces and inheritance model. One thing he didn't mention, which I and countless others have reported bugs on, is Enumeration. Not only has it usage quirks but been plagued with bugs its entire existence. Despite its flawed design there is an unwillingness to deprecate it. I have a hunch this is where Paul biggest quarrel lies. The unwillingness to alter bad designs in the library while being very acceptant to new designs in the language. Scala is the work of academia. A lot of features are built by academics doing research projects. This causes problems though when they move on and no one is left to maintain their work - like actors, specialization, macros etc. There is a lot of risk involved in including their work into the language. Not many are qualified maintaining it. None are redesigning and evolving it. I don't know how this compares to other languages and their standard libraries in this regard. Last note. Its hard judging the type system when you're unqualified. Regardless, to me it seems too ad-hoc. I have no idea what a better system might look like but the future is certainly not the current state of scala's full type system. I recon it's an open research problem but I hope significant simplifications are possible so ordinary users can make better use of it.
Option has its own flatmap flatMap[B](f: A=&gt;Option[B]): Option[B] 
Most of these are not idioms, unless Python has redefined the term to mean something to do with idiocy.
Can you explain this one? "abc" map (_.toInt.toChar) "abc” "abc" map (_.toInt) map (_.toChar) Vector(a, b, c) Both toInt and toChar are referentially transparent, yet the law does not hold in this case because the type of the container is different
&gt; Mixing underscore_case and camelCase and PascalCase and flatcase &gt; rocks #assertEquals #OrderedDirect #frozendict The lack of consistency in core library is really annoying there, I find myself trying to remember if the function I want to call has underscores or camelcase or flatcase. I'm quite fond of both Python and Scala though, even with their flaws I think they are best in their class for dynamic and static languages.
&gt; inheritance Respectfully disagree on this one. Unless necessary for implementing a Java API that's required... 
That is actually a really good question. String, from the Java side, is not a functor, and is not defined as a collection with a type parameter. Scala reuses Java's String, and uses various implicits and the like to make String more flexible and convenient to use. This does not change that String does not have a type parameter. Thus, while String supports `map` in practice, it is not a functor. However, at this point things get funky. String (as far as I can tell) is typically implicitly converted to a WrappedString or a StringOps when using `map` or similar operations on String. Those types both inherit from StringLike. [StringLike's method signature for `map`](http://www.scala-lang.org/api/current/#scala.collection.immutable.StringLike) looks like this: map[B](f: (A) ⇒ B): String[B] This is wrong, since String does not have any type parameters. The full signature looks like this: map[B, That](f: (Char) ⇒ B)(implicit bf: CanBuildFrom[Repr, B, That]): That Which seems more plausible. I don't know how or where the "short-hand" signature was created or written; I cannot find it in the sources for any of the traits. While this means that String is clearly not a functor, it does still provide `map` and other useful utilities using Java's String class, which is useful to have in practice. However, it is definitely not a clean solution. I think a cleaner solution would be to create a new String-type not based on Java's String, possibly similar to how Haskell implements strings, namely by defining the type simply as a list of characters. However, I could imagine that solution would have some issues in regards to operating on the JVM and interfacing with Java libraries and code.
Agreed sbt at its core is pretty solid. It does do well most of what it says it does. It's just difficult to tell it what to do. 
Academia doesn't automatically mean not caring about practical use and maintenance. Macros and the underlying reflection API have been constantly evolving since their inception in 2011 and through their inclusion in Scala in 2013. Helping people use macros (in production and research alike) and making macros better and easier to use has always been my number one priority even though I'm just a PhD student.
I dont think anybody intentionally creates unmaintainable code though might unintentionally. :) All new features have good intentions. I made extensive use of specialization and actors for instance, and actors was the only one I encountered bugs with. I'm aware that the inclusion of macros has been conservative. I don't think anybody prefer a separate codebase for research. The new mechanism for marking code as experimental and using language imports seems to me like a better solution. I mention it though wrt. the next 5-10 years. Just to note. I appreciate the hard work being put into scala by all and for pushing the boundary.
Few tweaks: * Use nscala-time * Use .parseOption instead of Try(...).toOption * Fix last clause before yield (dateOutput.format doesn't return a monad) * Fix date parser and regex to recognise time-zone offset Updated code: import com.github.nscala_time.time.Imports._ val emails = List("Date: Wed, 5 Jul 2015 12:00:00 -0500", "bad date") val inputFormat = DateTimeFormat.forPattern("EEE, d MMM yyyy HH:mm:ss Z") val outputFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss") val regex = """(?s).*Date: ([\w\d\s,:]+ (-?\d+)?)""".r val dates = for { email &lt;- emails date &lt;- regex.findFirstMatchIn(email) parsed &lt;- inputFormat.parseOption(date.group(1).trim) } yield outputFormat.print(parsed) println(dates) **Note**: Add to your build.sbt: libraryDependencies += "com.github.nscala-time" %% "nscala-time" % "0.8.0"
/u/runT1ME is correct, something akin to .toList is getting applied to the result from .findFirstMatchIn, which is an Option[Regex.Match]. Whilst flatMap can modify the type of the item within the mapped container, it cannot change the type of the container. It's easier to see de-sugared: emails flatMap { email =&gt; regex.findFirstMatchIn(email) flatMap { date =&gt; inputFormat.parseOption(date.group(1).trim) map { parsed =&gt; outputFormat.print(parsed) } } } The 1st flatMap here expects a lambda with return type List[B]
That sounds pretty nice. I should definitely try it. Although I wonder: Why no CSS selectors instead of Class(), Id() and so on?
I wish Paul had elaborated on his more general concerns with the state of the language and the compiler, rather than focusing as much as he does on the collections library. As it is, one might get the impression that he'd be mostly satisfied with a new, better collections library. But he also alludes to other deeper problems afflicting the language: * the "co-dependence" of implicit selection and type inference * as a result, the type inferencer may end up becoming frozen * documentation lies, variance is used too accomodatingly, etc The questions I'd really like to know: * Does Paul think that the problems described in the collections library are characteristic of other libraries and symptomatic of deeper problems in the language? * Could he elaborate on examples outside the collections library of some of the problems he describes? (e.g. that implementation details infest everything) * Could one solve these problems hypothetically by forking the compiler and changing some things? Is the point that the collections library is an example of deeper problems with the language, or is most of the problem with the design of the collections library?
Alternatively, is it that he feels Scala deserves a better collections library. And his real challenge is that such a library needs to be built into the core Scala library in order to be adopted? One could create a new collections library outside of the core, but then it might be difficult for users to adopt since collections are such an integral part of the language. And is the hidden subtext here that he couldn't successfully push to get a redesign of the collections library into the core Scala libraries? 
Ahem ... (2) Welcome to Scala version 2.10.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_45). Type in expressions to have them evaluated. Type :help for more information. scala&gt; implicit class Truthy[T](value: T)(implicit truth: T =&gt; Boolean) { | def toBoolean: Boolean = truth(value) | } defined class Truthy scala&gt; implicit def numToTruth(num: Int): Boolean = num &gt; 0 warning: there were 1 feature warnings; re-run with -feature for details numToTruth: (num: Int)Boolean scala&gt; if (5) { println("5 is true") } 5 is true scala&gt; I'm not saying that's a good idea, though.
This is just wonderful. Does anyone know why it's not a SIP?
Nice, but I rather use Scala Test Selenium DSL. I can't find even what is running under the hood of this thing
I am always happy to discuss alternatives. Scala collections are a huge success for almost everyone using them. On the other hand, they do have some warts that we might be able to fix in the future. Any alternatives have to be real, so we can evaluate them. Armchair arguments don't cut it. 
Thanks for the pointer to that thread! My guess is that much of the complexity in the current collections library arises from supporting mutable collections. I think many programmers would prefer to keep some kind of mutable option in the core collection classes. So it seems like a major challenge is to find a better design for the mutable collections. Paul doesn't explicitly suggest one.
hmm, create Android specific apps and loose out to the platform neutral developers, hats off to such awesomers ;-)
no we dont , there is no way to do it, since thats only possible in an IDE, or Maven on JVM, you Java guys are rotten to the core nuts, SUN ORACLE creation/ Zombies.
&gt; There's good-enough, or even just plain good, Scala support in both Eclipse and IntelliJ today. I'd say that the Scala support in IntelliJ is not just "good" or "good enough", it's a pleasure to use. 
Foursquare twitter and etc are few websites, i was talking about actual application development for real world, not few mind manipulators using sheeple for their own profits lone.
"_4. Scala's already made it."_ ;-) So did C++, Java and C#, Oh wait, but none of them took ten years to reach where Scala is. :-p
This is user is known for being provocative for the sake of it (a.k.a. trolling). It's posts seldom have any real content other than bashing some language or another to invite useless debate.
&gt; _Update: oh, I didn't notice this was from AAAplus. Nothing to see here; carry on._ &gt; posts seldom have any real content other than bashing some language or another to invite useless debate. I can easily create a new login account every time i post, but the truth is i want you all to vote me down, every time you vote me down, its proof of my success and why it will be so forever. You 99%ers are best at Nitpicking, because you dont have anything with you. 
Even Rust is not in the same ballpark. Rust is lower-level (and requires you to keep track of object lifetimes else the code won't compile), it does not integrate with the JVM (which excludes a large number of scala users that use subscribe to "Scala is Java++") and it's not going to be released (even a 1.0 version) before the end of the year. Expect a couple of years before it's usable by the common denominator programmer (like me). Having said that, I have high expectations for Rust :-)
Did we watch the same presentation? Where does he say that his main gripe is lack of purity? He is complaining about *bugs* that exist in the standard library; pointing out that the goal of using common interfaces for a variety of mutable and non mutable collections doesn't make sense. Do you disagree that the examples he picked are bugs? If not, then this has nothing to do with pure/impure and everything to do with correct vs. incorrect code. I have no idea if his lib will be 'better', but it seems silly to ignore valid criticism of something, even if it's already better than many other alternatives. 
a) I'm not a Java guy. b) Get medical help, please.
&gt; I have a hunch this is where Paul biggest quarrel lies. The unwillingness to alter bad designs in the library while being very acceptant to new designs in the language. Your hunch is very very good.
He had plenty of technically valid criticisms in the video, but to be honest they were all pretty minor issues. Having used Scala in production extensively, I've come across some of the issues. I consider them warts, but every language has warts - minor issues that occasionally add complexity, but you rarely if ever notice them. Mind you I've never used the mutable collections library, but as he says, keeping the same API for both is silly when you factor in variance. I'd have to agree there. Frankly if these were the only things a pissed off angry rant by a jaded former employee can come up with, then Scala is doing pretty well. He spent a considerable portion of the video, for example, picking apart the implicit CanBuildFrom aspect of the collections library. This is complicated. It's hard to understand. it uses a lot of the deeper and more complex parts of the language to work properly, and it's magical voodoo for anyone not familiar with all of those things. ... and it's absolutely unnecessary for anybody other than an internal collections library developer to have any idea it exists. It effectively boils down to hinting for the type inference system, and is *needed* for type inference to work properly. The public API does not list this part of the API. Not to try and pretend it's simpler, but because it's simply not part of the public API. You literally never have to know it exists, and wouldn't if you didn't dig into the internals. Haskell does not need this complexity because it has a simpler type system - specifically, it doesn't implement OO inheritance, whereas Scala does. (Some developers consider Haskell as better language because of this, whereas others consider Scala better for exactly the same reason. But that's another argument). 
&gt;He had plenty of technically valid criticisms in the video, but to be honest they were all pretty minor issues. Ok, so maybe his tone and liberal use of hyperbole is worth questioning, but let's not ignore his criticism either. I agree there are a lot of great things about scala, but there are some bad things too. Let's be honest, and I've been asking this of the community for a while, what do you *gain* by having a collection library based on subtype polymorphism vs. parametric polymorphism with implicits? 
&gt; what do you gain by having a collection library based on subtype polymorphism vs. parametric polymorphism with implicits? Like you can write `def foo(xs: Seq[Int])` and pass in a `List[Int]`. Do you want to have `def foo[CC[_]](xs: CC[Int])(implicit bar: StuffIWantToDoWithCC[CC])`? Or am I missing something about your question?
errrr, he is walking his talk, you know that, right? https://github.com/paulp/psp-view He very likely knows better than anyone what the Scala compiler looks like under the hood, and presumably left Typesafe knowing that the direction he'd like the language to go in was not going to happen (with Martin in charge). Personally I'd love to see something closer to the "ideal" Scala manifest by 2017 (where ideal includes better collections, streamlined type system, and vastly improved tooling). In the meantime looking forward to Scala 2.11
&gt;Do you want to have def foo[CC[_]](xs: CC[Int])(implicit bar: StuffIWantToDoWithCC[CC])? I think that's definitely one way it could work. I write a lot of .NET code professionally too, and while they don't have a type class based approach, they use extension methods to go back and fourth between an IEnumerable and concrete data structures, and while it's a bit annoying to have to call ToList or ToDictionary whenever you want to go back to something concrete, it doesn't try to expose a bunch of maybe mutable maybe immutable 'add' like operations to the generic interface. My point isn't that .NET did it write, it's that even in the mutable world of C# developers are OK with putting up with the minor annoyance of having restrictions on how much you can generalize a collection if it buys you safety. 
&gt;Can you elaborate on how you'd see this working? (Genuinely interested, not being sarcastic). See predef's comment below. 
Given the noise people make about the incomprehensibility of the `map` signature, that is not a realistic proposal for the standard library. I also haven't understood to date why sub-typing is so bad. It's a challenge for the compiler design and especially type inference, but from a user's perspective, what is exactly the problem?
It means that if you can't figure out that my claims about scala figure to be true, then stay out of vegas. &gt; It has worked so far for most features that went into Scala. That's funny only because you have no idea the extent to which that is true because of me. If you did have any idea you wouldn't adopt the attitude you have adopted.
I've heard good things about all those languages but all of them but arguably one attacks completely different use cases and users. Julia is going to help the scientific computing industry. Rust want's to replace C/C++. R is also scientifically computing based but it's been around for awhile and has a very narrow focus on statistical computing, if anything Julia is a threat to taking R users away, neither are competing with Scala. Elixir is the only one that in some ways target things that Scala wants to do well, and a lot of that has to do simply with being linked with Erlang. If you were interested in Scala for the actor based/distributed/ fault tolerance of Akka, then Erlang (and now Elixir) has always been another choice. But the pro with Akka is you get a much larger ecosystem with many more libraries and a more vibrant community. But of course, Elixir is a dynamic language and most people who would adopt Scala probably are looking for a compiled language. Paul Phillips is pretty right when he says there really aren't a lot of credible options to fill in the space that Scala has filled. Sure there are plenty of other good languages to use and if anything it seems that new great options are popping out all the time, but for a lot of the things that people who are using Scala really care about, there really isn't a credible competitor yet, other then just going back to Java.
That @switch annotation trick is cool, thanks!
Java Started as an Applet, while PHP and ASP were Ruling. so tiny imagination you got.
Does this mean you need to know the data structure before parsing it?
I happen to like the current collections framework, and only hope that mutable maps could be faster, and that we could have something that could come close to to the performance of EnumMap and EnumSet for Scala enumerations.
I updated the repository with a more elaborate [README](https://github.com/paulp/psp-view/blob/master/README.md).
SecureSocial is all that comes to mind for me. I'm actually also just starting a project and going to be using SecureSocial for the auth module. My current hurdle is to try to create a DB that will be able to persist users. Their [in-memory user service](https://github.com/jaliss/securesocial/blob/master/samples/scala/demo/app/service/InMemoryUserService.scala) is good for development, but obviously you need to persist users in production. So that's the next step, and I don't think their user model is very simple. I've also had one not so great experience w/ them. During one of the play! version upgrades (maybe from 2.1 to 2.2), SS took a very long time to release a new version. I needed one of Play!'s new features, so it was a struggle waiting for SS to catch up. Perhaps we can stay in contact so we're able to bounce questions off of each other if this is the road you choose.
https://github.com/wsargent/lunatech-securesocial-poc
SecureSocial looks good to me except for the fact that it doesn't support OpenID (i guess I could use oauth but I'll have to educate myself on what are the differences between the two). I'm just starting with Play and SecureSocial so I don't know if i'll be of much help, but feel free to contact me, I promise I'll do my best.
(Edit: Misinformed post) OpenID has been set to shut down for a while, I think scheduled for this month.
really?! well... that changes everything :) What are the recommended alternatives? edit: do you have any sources for that? Wikipedia doesn't have any info on this and I can't find any references for that.
I really agree on the comments on spray. I *really* want to like it, it's goal is mine, a simple lightweight way to make a non-blocking HTTP server. You look at the one off snippets and think "cool". But try and put it all together and you're either met with a sea of dead letters or you've forgotten some odd import to get some implicits to do.. stuff I just want to be able to churn out HTTP micro-services quickly. My current attempts have been met with a lot of frustration. And dont get me started with the typesafe example. It looks like a glorified Spring project where instead of messing around with XML you arbitrarily make 20 traits to accomplish nothing. tbh, I might go back to Scalatra as it feels so much easier to use. 
&gt;the guy who has written the most scala code in the history of the world &gt; if you can't figure out that my claims about scala figure to be true, then stay out of vegas. &gt;you have no idea the extent to which that is true because of me You might find people more receptive to your comments if you dialled back the ego a bit, even if your claims are true. A little modesty would go a long way... 
Is this lib. going to have a Map which is as fast as or faster than mutable.Mapor java.util.HashMap? For developers actually using Scala out in the wild that would be the only win which would we'd actually care about.
I recommend using one of the Activator templates to get started. Spray is wonderful, just not well polished for beginners yet.
As with *any* piece of code there are a few warts (see Martin Odersky's comment in the other thread), but by and large it works very well in practice. I've been using it for years without any major issues.
&gt; see Martin Odersky's comment in the other thread Which other thread?
Martin's comment: http://www.reddit.com/r/scala/comments/1wjoay/scala_collections_why_not/cf5efda The whole thread: http://www.reddit.com/r/scala/comments/1wjoay/scala_collections_why_not/
Having drunk the cool-aid of functional programming, I could never go back. I can confidently say that FP has single handedly resulted in the biggest improvement in the quality of my code in 20 years of developing. Of the FP languages available to me today, there's only a few I'd consider commercially viable (Stable and supported enough to feel confident staking my career on, and throwing hundreds of thousands of dollars at) - Haskell, F#, Clojure, Erlang, and Scala. Erlang and Clojure are great, but I like static typing. F# is fantastic, but I'm less of a fan of the .NET ecosystem. Haskell is the sexiest lady in the club, and she's just begging me to come back to her place for the night - but I'm not sure I could handle her pure idealism every day, and I'd have a hard time finding developers. Javascript is not a functional language in any remotely useful sense of the term. Scala encourages functional purity, but lets me cheat occasionally. (More specifically, they let my Junior devs cheat while I train them up, so there's a shallow learning curve instead of a cliff). The collections library may not be perfect, but honestly it's still pretty damned good in real world use. I can't think of any real problems I've had with it, and even if I did - java.util.* still exists. It sits within a very large, stable, trusted, mature ecosystem (Java). I can sell "Java" to my investors. I can sell "Java" to my customers. I can run Java on my servers. I can integrate with my vendors APIs via their Java bindings. I can fallback to Java if I find a genuine limitation in Scala (I haven't yet). tl;dr Of all the languages available today, Scala is the "least worst". I can definitely imagine a better language coming along one day, but until that happens I'll continue being immensely productive in Scala and writing the best code of my career. 
At the very least the benchmarks alone are pretty compelling (hopefully Martin et al take notice).
I may have to figure out this "give gold" thing. :-)
possible reasons: - All haskell programmers have 'free hands' in academia, and like that. - They already have a haskell, so why go for a lesser tool? - If you have a java job, many in comp.sci would wish for a scala job. - Professional Haskell guys are few in numbers (compared to the army of java ppl). Kinda obvious points but... :) I'vet yet to see a scala/haskell job posting in copenhagen for instance. Thus, i'd have to relocate. 
It tries to unify mutable, immutable, lawful and unlawful collections in one hierarchical (OO) design. Looking back, this was not a good decision and using OO locks you into a contract in a way that having a variety of implicit typeclass conversions don't. 
There's a small but vibrant Haskell community in my city, but I haven't been able to poach one yet - they are all comfortably employed. For Java developers I have a problem weeding out the "Babies first Java" candidates. About half of the "Senior Java Developers" that come across my desk can't write FizzBuzz, which really concerns me for the state of the industry. In the end I've pretty much settled on finding candidates that show promise and training them up. I presume if I lived in a larger city, the developer pool would be better and Haskell might be easier to hire for, as well as being a great filter for good developers. 
Hey Nikita, Spray is tough to start with but as we go along it makes sense about each of it directives, but Lift is another ball game, its is even harder, it was like someone slapped me and forced me to follow everything as if we dont have a brain. The problem is with the Specie, these guys do nothing to fight against their slaves generating education system, a system that forces them to follow everything blindly, Question NOTHING, and then praise only those who followed the instructions best, such a lifetime of brainwashing cant die. HENCE, Frameworks like Play, Lift and every convention over brain Framework out there survives and thrives. Long story short, guys like us we need to use this fact for our advantage, by creating our own framework(Like Gridgain does), showing way to these loonies will only get us down votes, So we should create our own Frameworks and DSLs, thats what Scala is all about, its a Language for the Architects. use them and get rich i.e. Promote Scala. :-) 
&gt; half of the "Senior Java Developers" that come across my desk can't write FizzBuzz Thats a huge advantage of hiring seniors for a new language, since it automatically eliminates terminators, terminators that can and will terminate your organization.
&gt; But try and put it all together and you're either met with a sea of dead letters or you've forgotten some Create your own Api for the purpose
&gt; 100% Scala doesn’t need any defending from anyone Indeed, but the point of these exchanges of criticisms and defenses is for language designers and user community to defend, explain, and understand the reasoning behind decisions, so that everyone can learn from mistakes and/or verify that those decisions are made based on sound reasoning. &gt; APIs should be simple and usable first before they are functional and composable. What a terrible piece of software design advice! It's the same mentality behind the adoption of jQuery and Drupal, two epidemics that have wasted so much finite human life in debugging and refactoring – and often the inevitable eventual migration to saner tools – it's not even funny. &gt; Clojure is a modernized Lisp – but I’m not in 70s anymore I'm not a fan of Clojure, but "I’m not in 70s anymore" is a bullshit non-argument. *Especially* in the programming world, where every other year we realize we've been *ignoring* great ideas from decades ago (with precisely the 70s being a key decade). You don't like things from decades ago? Don't use the fucking Actor Model then, or CSP, or ML type inference, or etc, etc... &gt; We don’t develop software in text editors and command lines either… it’s 2014, you know You really need to do yourself a favour and stop using the *"it's not the 70s"* / *"it's 2014, you know"* sound bites. Get real arguments instead.
Thanks! Looks really cool.
With friends like the OP, Scala sure doesn't need enemies.
&gt; We don’t develop software in text editors and command lines either… it’s 2014, you know The sad thing is that programming tools evolved almost nothing since Emacs and Vi{,m}. So, yeah, it's 2014, and the best tools we've got for programming are the ones written back in the 70's.
Are you talking about "programming tools" as text editors for programming/IDEs, or programming tools in general?
Mostly text editors and IDEs, but plenty of other tools are kind of in the same boat. Cool things like QuickCheck and Hoogle are not widespread.
Ah, ok. Hoogle does seem really cool to me. I think it is not more widespread because it is difficult to implement well for a lot of languages, especially dynamically typed languages. As for QuickCheck, I agree that QuickCheck (ScalaCheck in Scala) ought to be used more, it is really useful in a lot of cases. That said, both of those tools are relatively new, and there are also some newer tools that are very useful, such as distributed version control. And typical programming tools like compilers, optimizers, linters and the like have seen considerable improvements over the years. And while I agree it is curious that Emacs and Vi{,m} are still some of the better editors out there, there have been some interesting developments for IDEs, such as live worksheets and code that is evaluated and analyzed and given feedback for as you write it. So, I do think programming tools in general have progressed a lot since the 70's.
To repeat what predef has said, you joke about grammar size and your metric of contribution is LOC? Really? And when did you start contributing - 2009? The very fact that you think "written the most scala code in the history of the world" is some sort of qualification is hilarious. Let me introduce you to some sorry folks who have written over 1M lines of Java. It is nothing to be proud of and you are probably better off hiding that statistic. No matter how much library code or compiler bug fixes you might have contributed, you never had and never will have the impact that Odersky had on scala, he built it in the first place. Let me guess - your new Collections library is also written in scala. Some comments on your new collections. You have the benefit of starting from scratch and it look like it is essentially a view-based lazily evaluated collections library, so it can provide better algebraic semantics. It is interesting but I can see why TypeSafe wouldn't want to be distracted by it - it is of limited utility, there are other more important projects pending. If you want pervasive laziness may I suggest a language called Haskell? Also good on you for dropping the silly rant about Scala automatically casting Float to Int. It is obvious that you had a fallout with Odersky, because I can barely see anything wrong with the Scala or the collections library from your slides. Get over it and be more graceful when you try to sell your new collection library to developers.
I watched another version of this talk yesterday. Definitely worth watching. 
Yes, compilers have evolved. I wouldn't say that text editors/IDEs have evolved much though. The interesting ones today are Light Table and Lamdu, with the other interesting stuff being Smalltalk VMs.
This version is a bit more energetic and includes the Q&amp;A, so if you're going to pick one or the other I recommend this one. 
I just pushed a [2.11.0-M8 branch](https://github.com/lihaoyi/utest/issues/3), for anyone who wants to use this while living on the edge
Holy shit, you weren't kidding about energetic.
i took crap yesterday, now not ready for more crap by this Paul. If he is reading, i would recommend him to focus on AOT and NaCL, do something revolutionary there; instead of just BASHING things.
It would indeed be nice to have AOT compilation, but this is a topic absolutely on the other side of the spectrum.
Awesome presentation, particularly the Q/A at the end, epic. Interesting that he feels Scala and Typesafe will do well despite the issues he's bringing up in his eviscerate-scala tour 2014. Also, my assumption has been that paulp would get on the Haskell train due to his myriad frustrations with Scala, but that seems not to be the case. I love that he wants a language that is both accessible and sound -- vs. "having to climb the mountain" in order to attain proficiency in the language (which, as a Haskell beginner, is its biggest weakness). Personally I have gotten the former with Scala (wonderfully accessible), but apparently not the soundness bit (assumed it was there until paulp went on tour). Hope he sticks it out with Scala, influencing the language from the outside-in with his collections library and whatever other creations his "sick perseverance" brings into being ;-)
Why is the recursive implementation so much slower?
At a glance, the imperative version uses raw arrays, shuffles everything in place, and has zero allocations apart from setting up the initial arrays. The recursive version is allocating 10 million intermediary collections, and the collection elements are the Complex case class, meaning a further level of boxing/indirection. Every map, filter or zip constructs complete intermediary collections. If you could see the quantity of garbage produced (by running a decent profiler), you'd be amazed at the difference. 
The good thing, IMO, is that you can and should start with the functional version, because that is actually readable code. Then finally you can switch to the Java/C style code for performance. Sometimes I'm faced with C implementation of algorithms, and it's a complete disaster, they might be fast, but it's virtually impossible to correctly translate them to other language (except of course, if you keep the imperative style, but you don't understand what is actually going on).
https://github.com/paulp/psp-view http://thread.gmane.org/gmane.comp.lang.scala.debate/12801
Wow. The camera has to constantly pan to keep him in view.
Slides?
It's like Scalatra, but not, and then the other thread opened by the OP is like Rails, but built on Scalatra ;-) Probably because it's what I know, but Play has IMO really nailed it with their stateless MVC approach. Routing in Finatra and Scalatra is interesting (i.e. method declaration vs. in separate routes file), but otherwise not seeing much to make me jump ship. Anyone with experience in these frameworks care to share the awesome?
Finatra is great if you use and love Futures. Plus it's dead-simple.
Well this is an awful idea.
I'd like to hear why you say this.
I actually saw this a few weeks ago and thought it was pretty cool. I really like the idea of taking really good components like scalantra and merging them together. One day I'm going to give it a try.
for those who will get pissed off not seeing any code in the link, here it is https://github.com/twitter/finatra seems like based on Spray ;-)
Good these guys are using Scaffolding / Generators, it means we are closing in on Macros era, once we reach there all those scripters and testers will be a thing of the past. We will then move on, this one is a little preview of that. btw, dont count on those Frameworks that dont have "hello world" code in the first page for newbies, these are only for super rich corporations, which themselves create and promote such crap. Ok, its not crap but its not for general public either, mostly its just for generating hype or impressing their investors. *And for that you all are being used as scapegoats.*
Slides are in another Video, this is for those who watched the previous, now imagine how sick cheap retarded the cameraman and the Entire Video team there must be. Garbage people trying to make money just like scripters and testers here voting me down, its this sickness thats gona kill these psychos, i will get rid of these sickos. Just wait for my Scojo Framework to be release and then watch these baboons die out. ;-)
There exists another project, [Scoverage](https://github.com/scoverage/scalac-scoverage-plugin), that is based on SCCT (the one that's posted by OP). It seems to be active. It also has an [SBT plugin](https://github.com/scoverage/sbt-scoverage).
I apologize for such an abrasive initial comment. If you are the author of this framework then I think you did a great job building something and releasing a working product to the world as open source. I really, really dislike the Scalatra framework. I've used it in production in a medium-volume website, and it was a mess. We moved to Play and never looked back. Servlets are old and antiquated and Scalatra does little to hide that from you. But there are plenty of reasons why you might need to use a Servlet-supported environment, so I won't harp on that. Scalatra's typing is fairly weak. You can return anything from a controller. This WILL get you into trouble. It subverts the notion of using a language with a sophisticated type system. json4s, the preferred json library, is just all around awful and very unsafe (which is the opposite of what you want out of a json framework when dealing with the oozing insanity of the web), especially when you examine the alternatives play-json and spray-json. Scalatra's support for async is fairly half-basked and strapped-on. And don't get me started on Scalate or the dumb things you need to do to render Scalate templates outside of a Servlet. The sum of it is that Scalatra is pretty low on the list of quality Scala web-frameworks, of which there are many. While I really enjoy working with Play, there is also Spray and Blueeyes which are great minimal choices. Heck, if you really want something 'skinny,' why not go with Unfiltered? My other criticism is very weak and kind of flat. Why does Scala need a Scala on Rails? Truly, write the tools that you want to use -- and if a Railsian approach makes sense by all means use it. All the same, there are numerous MVC frameworks for Scala that don't even need to bring up the word Rails. They stand on their own in MVC opinions and methodology. Personally, I think ActiveRecord is awful and that ORMs need to be designed with care since objects simply don't map to database relations except in the most simple of cases. There's no reason to bring Rails into this. :) The validation and email frameworks look neat though! 
[Slides](http://www.slideshare.net/extempore/a-scala-corrections-library).
It's been fine. It's probably not the speediest framework out there, although it's certainly not a slow boat. I can't give you any hard numbers because we haven't really stress tested it on any of the applications I've been working on. What I have seen is that for a mostly CRUDish app we spend the vast majority of our time in SQL. So I don't think as much about performance on the JVM. Play lets you be really async though. So if making multiple db or service calls concurrently and then orchestrating them into a single Future response is your thing, it can happen pretty seamlessly. 
No doubt, It's generally how I work. Start with whatever I find the simplest solution, for me it's usually functional, no shared mutable state etc. etc. If YourKit is telling me it's taking 40% of my cpu time (all of the Scala code I'm cutting at the moment has tight resource constraints), I implement a nasty imperative, c/java style, allocation free, while loop having bastard ... and in return get a 3-10x speed up :-/
Faster than most of us will ever need -- James Ward of Typesafe did a benchmark of a non-blocking app that did close to 1,000 req/sec. I haven't been able to get anywhere near that, however, fastest I got was 280 req/sec for non-blocking. Play is designed for non-blocking apps, so JDBC dependent high traffic apps need to have thread pool tweaked; i.e. bump up the thread count significantly from default of 20 or whatever it is.
I think if I was teaching someone to code I would go with Scala and just stick to the basic concepts that Java also provides before moving onto Scala specific concepts.
I broadly like that idea. What do they want to make, and how serious about learning concepts and design, as opposed to just hacking a game together, are they? For example, Javascript has most of the advantages that Scala does, plus allowing interaction with webpages, plus easy graphics. It's the teaching language I've had most success with. However, JavaScript inheritance just gets *nasty*. Java has an unpleasant amount of boilerplate. I had real issues when I first started learning programming ("public static void main..."...what does all of that MEAN?!). Not sure whether I didn't explain it well, but Python's lack of brackets added unnecessary complexity when I used that. Scala has neither of those problems, there's plenty of room to grow. I can totally see a world where your friend is disappointed most programming languages don't come with filter and map! If you're trying to give them a taste of programming, enough to spur them on to learning themselves, I'd recommend JavaScript. If you're genuinely teaching OO concepts, I reckon Scala would work out very well indeed. Edit: Just thought - one thing I didn't discuss was Scala's habit of steering you towards immutability. Whilst it's great for avoiding a myriad of issues, it really helps to know *why* immutability is so great, without being forced into it. But having to explicitly declare mutable lists etc. may just create confusion.
The REPL is kind of slow... Perhaps an interpreted language like Python / Ruby might be better suited
Although in isolation I think Scala could be a decent first language it would be much easier for him to learn a language that has abundant tutorials for new programmers, even if you're playing teacher. I'd stick with Python or Ruby.
&gt; Java has an unpleasant amount of boilerplate. Java might have an unpleasant amount of boilerplate for a Scala developer, but for a beginner, both are intolerably noisy. The type system itself is guaranteed to turn people off and I suspect the compilation times won't help either. If you're trying to teach programming to a complete beginner, you need to go with a dynamically typed language, and I think Javascript is the most rewarding (write some code, modify a web page instantly) and easy (nothing to install, you probably already have a full IDE and debugger installed) language to start with. 
Check out the Atomic Scala book: http://www.atomicscala.com/ I've not read it, but I believe it's aimed at beginner programmers, so it's probably worth a look.
I learned Scheme as my first language, which is a functional language and has a REPL. actually, everyone who takes Indiana University's intro class programming class learns scheme, so they seem to think it's okay to have a functional language be your first
What's up with all those bullshit "learn Python first" comments?
As a introduction to programming, I'd start with Python. It's as simple as it can get. From there on, Scala sounds like a great choice. The only problem with Scala is that the pupil will not want to go to something like Java afterwards. Java looks "undeveloped" after working with Scala.
I don't think scala it appropriate for starters. Scala allows you to code in different styles and it will definitely confuse people who just started learning how to code. I agree on Javascript, node is also allowing you to have a cmd tool and it's also more fun to play with the browser.
&gt; The only problem with Scala is that the pupil will not want to go to something like Java afterwards. Why is this a problem?
There's an idea that somehow a language with a dynamic type system is easier to learn. I really don't understand that, other than people that learn a dynamic system first with def fooBarAwesome(x, y, n) think that is somehow easier than def fooBarAwesome(x: Int, y: Double, n: String) Maybe they think a 1 minute explanation of types is too long? I'm also guessing that they don't know that both Python and Scala support function calling in the form of fooBarAwesome(n = "yes", x = 4, y = 5.67) 
&gt; There are way too many compsci concepts that must be understood before you can do anything significant in Scala. Can you elaborate? The only compsci concept I can think of that you must understand is the basic types in scala. That takes about 1 minute.
Interesting you bring that up since one of the top posts in r/programming today is about school's teaching debugging when they're teaching programming. Glad to see that Kojo has program tracing, which is a great first step towards debugging.
Please post your troubles to stack overflow. I do agree that spray could use better beginner documentation.
I don't know that there is enough information here to make a good recommendation. For example, my wife has expressed an interest in programming. I know she isn't really interested in it beyond being able to maybe a) make/manage her own blog website b) have a greater understanding of the kinds of things I do at work. So, would I start her on Scala? Nope. Not a chance. Scala has an elegant and simple syntax, but its all the underlying complexity that wouldn't work for her. That being said, I would make the same recommendation that I do to anyone that wants to learn programming -- http://www.codecademy.com/. It has the instant feedback and several easy to understand lessons for everything from javascript to python and ruby. Also, she'd be able to learn CSS and HTML. So without any context, the best recommendation that I can make to anyone starting out in programming is codeacademy. Also coursera isn't a bad choice either since it mimics the structure of a university course.
My aim in teaching my friend about programming is to give him enough coding skill and exposure to programmatic problem-solving so that he can make a reasonable assessment of whether it is something he enjoys. If he does enjoy it, that's great, and we can take it in any number of directions. If he doesn't enjoy it, I don't think there is a reason to continue. Great point about immutability in Scala! Mutable variables would probably seem strange to someone who learned Scala first. But maybe that's not so bad. Thanks for your reply!
Thanks for your reply. What is your personal opinion about learning a functional language first? Was it hard to work with imperative languages later on?
Our current plan is to go with Python, which I'll actually be learning for myself as well, so hopefully that will help me see from the perspective of a beginner. Thanks for your reply.
Thanks for your reply. Our current plan is to start with Python. Do you mind if I ask where you are employed that you are lucky enough to work in Scala? I don't think there are any employers using Scala in my city, though I might be using it on a freelance project later this year.
I had a chance to use named arguments in Scala recently and was pleased with the increase readability. Thanks for your reply.
Our current plan is actually to start with Python. Do you think that wouldn't be a good choice for a first language?
&gt; ("public static void main..."...what does all of that MEAN?!) The great thing about java is that each word does mean something, and it's very straightforward what it means. That's computer programming laid bare, which in some ways is nice for a beginner. (I trust I don't actually have to explain those 4 words to you, that you were being rhetorical). Scala, on the other, is nice, but can also be a frustrating exercise in getting the compiler to agree with you about what types your objects are. With the type inference, that can be a confusing mystery, because it isn't laid out so simply. 
Thanks for your reply. I'll take a look at codeacademy.
Our current plan is to start with Python. When you say that the REPL is slow, do you mean that it is slow compile and execute commands, or just slow to work with, or both?
Thanks for your reply. That would be my plan if I were starting with Scala. But I don't know if I could resist getting into some of the higher-order functions like map and filter.
I think you can go pretty far with that if you're willing to be hands-on and available during the teaching process. The Scala documentation is pretty intimidating for a beginner, and most of it assumes you know Java. If you're actively teaching your friend and providing materials for them, I think you can avoid Java long enough to enable them to do some really fun things. Bonus points if you set them up to do Processing in Scala. 
There's also an amusing Scala debate going on in http://www.reddit.com/r/programming/comments/1xloc6/java_8_performance_improvements_longadder_vs/
&gt; &gt; The type system itself is guaranteed to turn people off &gt; &gt; Can you elaborate? We are talking about beginners, the goal is to get them to write a working program as fast as possible in an attempt to create the initial spark of interest. Types get in the way of that and they open the door to a lot of questions you don't want to answer just yet ("What's the difference between Long and Int?") in much the same way that you don't want to have to explain what "public static void main" means to someone who just wants to write a "Guess the number" program. 
My main point is that to write the very basic "Hello world" application in Java, you have to introduce strange concepts that are a barrier to confidence. You don't want to be explaining what statics are initially - you just want *something* to ping up on the screen so the student feels empowered to continue, not confused about what they just wrote. "Lets write something to generate fibonacci numbers", is a much more fun first lesson than "let me explain statics, return types and public/private methods to you. In Scala, public and private, statics and return types can be taught after you can make basic things, which I like. Totally agree about the compiler though. A helpful IDE can get you most of the way, but I suspect dynamically typed languages might be the way to go for beginners.
One of the nice things about Scheme as an intro language is that it's not pure functional, and it's easy to do imperative things. I'd lean to teaching someone Scheme before Scala, because Scheme's syntax is fundamentally simple, and Scala's is fairly complex, particularly with all of its syntactic sugar, semicolon inference, multiple ways to call a function, etc. [Racket](http://racket-lang.org/) has diverged from Scheme, but has some good intro materials and a good environment.
&gt; Types get in the way of that and they open the door to a lot of questions you don't want to answer just yet ("What's the difference between Long and Int?") I'd prefer to take a minute to say, here's some basic types and what they mean, rather than try to help a beginner debug their program that is printing "1010" rather 20. Obscure bugs due to dynamic typing will more quickly stomp initial interest than a 1 minute intro to types.
From my experience when I was learning Scala the REPL was slow to evaluate pretty much anything and for me personally it was annoying.
&gt; I really don't get on with how Python manages its dependencies. $ pip install foo \&gt;\&gt;\&gt; import foo \&gt;\&gt;\&gt; foo.bar()
I suggest looking up problems that have been used for programming contests (e.g. ACM-ICPC) in the past. They don't qualify as "real" projects, but they are designed to focus on "core" stuff and yet also to be solvable in a short time. You obviously would not want to enter a contest using a language you don't know well, but without the time limit, working out such problems is a great way to learn a new language. And there's also a wide variety of types of problems to choose from, so you can pick the ones that require you to exercise whichever area you are weak in.
Here are two blogposts by someone who is teaching Scala as a first language in university. I found the discussion quite balanced and insightful. [benefits-of-scala-in-cs1](http://dynamicsofprogramming.blogspot.ch/2013/11/benefits-of-scala-in-cs1.html) [more-benefits-of-scala-in-cs1](http://dynamicsofprogramming.blogspot.ch/2013/12/more-benefits-of-scala-in-cs1.html)
A lot of the contests on [Kaggle](http://www.kaggle.com/) are fun, and some are worth real money. The [Santa sled packing contest](http://www.kaggle.com/c/packing-santas-sleigh) is already finished, but it is an easily graspable bin packing problem that you could probably have fun optimizing a solution for on your own anyway. They also have some standing "getting started" contests if you want to just try your hand at some machine learning as a problem to chew on. 
IntelliJ 13 + scala plugin. You'll thank me. 
It really is that good. And it does not require the paid version. Sbt support is also quite excellent. 
Ensime is not really that bad, but having some knowledge of how sbt works is helpful. I used Intellij for about 6 months but am now back to an ensime+emacs setup and prefer it. I think intelliJ can end up as a sort of crutch, but milage may vary. 
Intellij Idea is perfect for Scala. @MUDrummer is right, you will thank :)
Just tried the latest and can get it to reliably freeze importing any SBT project. 
-A super-efficient Map implementation -A tool for processing GC logs -Also, look through some of the apache commons libs for Java for some inspiration. There's lots of solid java-centric stuff in there. -A library for file I/O
I am using emacs + ensime + sbt for 2 years and sometimes IntelliJ I am pretty happy with emacs. I am sure IntelliJ is great, but it is too fancy for me. For kickstarts of little mid-sized projects emacs+ensime is great. However, refactoring is not good with ensime. You have to use IDEs for that. 
Great ideas ... I really like the one about processing GC logs as it gives me reason to read more about GC in general.
and this as well https://www.youtube.com/watch?v=TS1lpKBMkgg and this https://www.youtube.com/watch?v=uiJycy6dFSQ just to give the whole picture
I actually take it back--when I compile and run my code on the command line using "mvn scala:run" everything works fine but in IntelliJ there's some weird issue with scalatest ("object scalatest is not a member of package org"?) No idea what's going on, hate spending time trying to figure this stuff out (do you know how much Python I could have written by now...)
&gt; A super-efficient Map implementation Before starting off with this, is there a writeup which shows the problem with the current Map implementation? 
There's some ongoing work here: https://groups.google.com/forum/#!msg/scala-internals/Fw37NmUUiqs/k9jxMXDYEhYJ I also remember seeing this a while back: http://capecoder.wordpress.com/2012/07/29/scalamapbenchmark/
I think what beginners need the most is help in how to think about programming in general: in terms of expected input and desired output. Everything else follows from that. Giving them a language which neither cares about this (number, string, list? who cares?) nor helps them to document their expectations in a way in which the compiler can support them in their reasoning smells kind of insane to me.
The blog post seems to have confused Programming in Scala 1st Ed. (http://www.artima.com/pins1ed/) with Programming Scala (O'Reilly book from 2009)
Here's another excellent list of 24 books (though not necessarily free) on Scala: http://capecoder.wordpress.com/2013/09/01/many-new-scala-books-being-published/
Sure. I work at UAMS in Little Rock, AR. I supervise all of the IT staff in my division. A lot of the stuff we do is best supported on the JVM, and I made a decision to use Scala instead of Java.
I was mostly confused when I saw my first for-loop, but now that I'm off working with people who don't know any functional programming languages, I feel like not being afraid of complex recursion is pretty nice
You might want to offer full disclosure if you are going to use quotes. For example: &gt; I can honestly say if someone had shown me the Programming Scala book by Martin Odersky, Lex Spoon &amp; Bill Venners back in 2003 I’d probably have never created Groovy. Since then, James moved on from Scala and he's now [a committer to Kotlin](http://blog.jetbrains.com/kotlin/2012/03/contributing-to-kotlin/) (although he might have moved on from that as well). 
Location?
It's not that I'm under a rock lol it's that I don't want to make any of my code public. It's all on bitbucket as private repo's. They are all business ideas of one sort or another.
No. It's only a matter of time before everyone involved with Bitcoin gets a visit from the men in blue, and I don't want to be anywhere near your company when it happens. Governments do *not* like threats to their sovereignty, including their currency. *Especially* their currency.
Let's hope this is a troll! This is one of the goonier things I've read in this subforum. Tens (hundreds) of millions of respectable US VC dollars have gone into BTC. Innumerable well-respected US companies have started accepting BTC, which means that they have BTC holdings and pay taxes on BTC. It's not going anywhere.
I think they are in Palo Alto
Its nice to see Scala getting attention in this space. Are you using Akka/Spray or Lift? 
from https://news.ycombinator.com/item?id=7231473
Wow! You aren't a troll after all! Your initial comment suggests that you will be arrested for participating in Bitcoin transactions or writing Bitcoin-related code. I listed numerous reasons why that is very, very not likely the case (9Heck, they would have to arrest high level executives at Wells Fargo, the largest and most powerful commercial bank in the US, for their Bitcoin explorations. And the numerous congressional hearings about Bitcoins never suggested anyone would be arrested). You haven't given me anything but unfounded paranoia. I certainly empathize with your dim views of the government's control over the economy, but I have evidence for my opinions. 
I'd love to hear more about their tech sack too!
Probably "having a job." 
Sorry dude, the same old tired slogans we've all heard before don't count as evidence. I do agree that Congress is likely too old and crotchety and out of touch to understand Bitcoin either way. It's too late to ban it outright. But it could certainly be regulated to death. That's a far cry away from the gustappo kicking down your door in the middle of the night and branding you an enemy combatant.
Play framework is written in Scala 
Correct spelling of Gestapo is: http://en.wikipedia.org/wiki/Gestapo
&gt; it really helps to know why immutability is so great, without being forced into it. But having to explicitly declare mutable lists etc. may just create confusion. Why would he ever need to know about mutability when he's learning? 
I'm not quite sure what Chris is asking for here. Is he asking for something like a corecursive server?
I phrased that badly - a learner shouldn't have to deal with concepts like immutability at all. I should have probably bracketed the "immutability is awesome" section. To clarify: I don't think you should be using immutable collections unless you know *why* you're using them. Which makes me think Scala might not be such a great beginner language, as they're hard to escape. 
The whole groupBy/sortBy collections approach in Slick is a boilerplate PITA. I really like that parameterized query snippets are now composable (could only apply parameters on final query pre-Slick), but Slick has taken a step back in the boilerplate/readability _._1, _._4 department, IMO. JOOQ and Squeryl look like nice LINQ to SQL options in Scala. Nothing nails it yet, however. Quick (JOOQ + Slick) would be a nice combo. 
i am a dummy
&gt; Quick (JOOQ + Slick) would be a nice combo. How could the two profit from each other, according to you?
Good question. JOOQ's syntax is clear, but not as concise as one would like. For example, table aliasing would be nice, so instead of: select {T_BOOK.oh, T_BOOK.my, T_BOOK.fingers} from T_BOOK select {t.oh, t.yes, t.wonderful} from T_BOOK t I'm sure with some Scala (macro) sugar, we Scala users would then benefit from the concision we crave (and must have!) ;-) On the other hand, Slick has gone all-in on FP so while for{} comprehensions are supported, clearly the direction they're pushing is Scala collections based, with map, flatMap, filter and friends (and arggghh, groupBy(_._3)/sortBy(_._1)). To be fair I haven't given JOOQ a deep look, have been on the fence here waiting for Slick to mature, or JOOQ to become SOOQ; neither are there yet, thus the Quick hybrid notion.
&gt; {T_BOOK.oh, T_BOOK.my, T_BOOK.fingers} ;-) &gt; For example, table aliasing would be nice If you're using the jOOQ code generator, you can leverage aliased tables as [documented here](http://www.jooq.org/doc/latest/manual/sql-building/table-expressions/aliased-tables/). That's not exactly like SQL, because in Java, variables have to be declared before they're dereferenced. &gt; or JOOQ to become SOOQ Yes, that would indeed be very nice. 
As everyone seems to follow the duckling, Scala seems to do a lot things right. Compare it to some languages which started with huge promises years ago, but failed to ship with anything useful and are now getting beaten by Scala at their own game (JavaScript backend, union/intersection types, ...).
Once again, with that [awesome rule about questions asked in headlines](https://en.wikipedia.org/wiki/Betteridge's_law_of_headlines), I have the answer for you: No.
Not sure why you are being downvoted, as it is very common for linkbait articles to use inflammatory questions in the title where the answer is obviously 'no'. Not saying the article is linkbait, but just saying.
I find that I generally agree with this article. I had no idea that now there are so many Java certs. I don't have any, heh.
Agreed. I'm a little bit tired of these articles which have nothing productive to add. Looks like we're in a Scala criticism is trendy cycle. 
This blog post has a really stupid title which has nothing to do with the blog content (which is largely pro-Scala). Obvious linkbait.
_Enterprise applications are the ones to focus on_ Many try to shut up Genuine questions about Scala by pointing at Twitter and other such mega websites, well, they may be great but their greatness is not helping solve our problems with scala, or is that they want only websites to use scala, in that case Scala will remain a Niche language for 10 more years, or until its replacement succeeds.
in that case the Scala production team should stop being self creative and start addressing developer requirements instead
I'm not sure about that, the issues are pretty much well known and people are working to fix it. If you look at most of the advancements made at scala 2.10 (like the new futures/promises library), it was a cross pollination work between Typesafe, Twitter and many other people to come up with the final result we're using today. So saying that they're not helping (with the amount of OSS projects and community leadership they provide) is definitely a wrong statement.
THEY ARE HELPING IN THAT WAY but is that limited user/ developer base Scala is targeted at ? Do you work for twitter ?
You can't look at it as a beginner if you know some programming language already because you are familiar with all the concepts - variables, types, conditionals, loops etc. I would suggest JavaScript as a first language. I really don't like it as a language for production software but for educational purposes it's fine. * Decent syntax * "Hello, world" is just one line * REPL * Can be used to make some fun stuff
I wish Scala had actual union types. `Either` is ugly.
especially union types that don't have a ridiculous amount of object overhead.
Chris said "A lot of the talk about functional programs specifies composition of referentially transparent expressions: thus I/O becomes something to be evaluated 'at the end of the world'. What about long running programs that must both take changing input (from multiple sources) and be constantly emitting side-effects (to many places)? What would such a process look like, if written in a purely functional way? I'd love to see a demonstration of something like this, maybe using scalaz-stream"
That would be great :(
I don't work for them. But what do you mean by limited? Limited in what sense? Where do you think Scala should be?
I've also posted it to /r/programming http://www.reddit.com/r/programming/comments/1y8irk/scala_at_netflix/
That's why there's an "other discussions" link.
Thanks :)
How big is the impact of circular dependencies on the compile times? Are clean builds faster or only incremental builds?
Yeah, like [this](https://github.com/scalaz/scalaz-stream/commit/b3dbe6c38dbc238029c57253b0dcb2bdc671a8f3) maybe?
And then, half of the comments on reddit are about the title, linkbait, how everything is wrong in the Scala production team, etc etc. But not about the article content... Oh wait, it's reddit :-)
I don't think it'll have any impact on clean builds, but avoiding cycles helps greatly in keeping incremental builds incremental; a cycle means every file in that cycle needs to be re-compiled together, and a few large cycles can easily turn a small incremental re-compile into a re-compile-half-the-world adventure.
And the recent announcement at scala-internals by Martin. [Dotty open-sourced](https://groups.google.com/d/msg/scala-internals/6HL6lVLI3bQ/IY4gEyOwFhoJ)
I'm playing with Ceylon these days and the native support for union and product types is really nice.
you could use the language for anything, but then you would have to build all the specific bits yourself. just like Ruby, you can use Ruby for anything, but most of the community gravitates towards webapps so it's what most people use it for.
Wow what an active project, shows that they got excellent Response, may this one become the foremost project in Scala. Looking forward for some video tutorials for this one.
Yeah, Ceylon is a nice language for playing around with that kind of stuff; I miss higher kinds a lot when working in it, though.
That does look nice. I don't think I'll be using Ceylon, though. It drops several features that I won't part with without a *damn* good reason, such as operator overloading and implicit conversions. Ceylon's [relevant FAQ](http://www.ceylon-lang.org/documentation/1.0/faq/language-design/) fails to adequately justify these limitations.
Be sure to vote for the post in /r/programming. The usual haters are voting it down like crazy.
[Direct Link](http://www.reddit.com/r/programming/comments/1ybjwd/why_we_love_scala_at_coursera/).
This could be construed as against reddit's rules.
Old news. Zzzzzz.....
Is it a substitution to SBT? Please, please pretty please!
Nice work! Any updates coming to Chalk too? :-)
Is there a users guide for the new syntax? Or examples?
FTA: &gt; dbuild, or distributed-build, is a build and debugging tool based on sbt
Updated it to 0.1.1, notable because you can now declare *packages* acyclic in addition to files. I feel that that's a pretty big use case, and I make use of it in all the projects I'm using Acyclic in.
Are you willing to work with remote developers?
&amp;#3232;_&amp;#3232;
Whats the point of lens library in a language that has native classes? 
Classes are an orthogonal concept to lenses. If you mean why do you need them when you have vars, well, unconstrained mutability is bad, always. case class StreetAddress(number: Int, sname:String) case class Address(sa: StreetAddress, zip: Int) case class User(name: String, addr: Address) How can I generate a new User (again, because immutability is better) that only changes the street name? Scala gives us copy methods for free, but that doesn't help too much. user.copy(addr = user.addr.copy(sname = user.addr.sname.ToUpperCase)) That's just ridiculous. 
In practice this is a non-issue, but if deeply nested cases classes are a requirement (deeper than the example here), then sure, can go down lens lane. Otherwise, I know your example is contrived, but this isn't really _that_ horrible: user.copy(addr = user.addr.copy(sname = fooStr)) 
Sure, but keep in mind, user might be in a larger structure, which may be in a collection, in a structure...
Sorry, for me as a Java developer this was new and confusing.
Sorry, I was hoping that reddit would gave me an exception ala 'link already existed' in that case :)
I think there are multiple versions of the same presentation at different URLs, and he's given the same talk with minor variations multiple times, so URL deduping didn't catch it. Oh well.
Lenses become more useful when you need to use modify and lift. * Modify avoid the need to do get, apply your function and then set the result back. Even if the goal of Monocle is not speed, it is more efficient. * Lift does the same job but on top of that you don't need to map the result of your function e.g. let's say you want to get all the neighbors for a given address (+ or -1 of street number), with lenses you can do: val myAddress = Address(StreetAddress(10, "highstreet"), 12550) val streetLens: Lens[Address, StreetAddress] = ... val streetNumberLens: Lens[StreetAddress, Int] = ... streetLens compose streetNumberLens lift(myAddress, n =&gt; List(n-1, n+1) // List(Address(StreetAddress(9, "highstreet"), 12550), Address(StreetAddress(11, "highstreet"), 12550)) And this is applicable to any Functor, not only List
Please don't feed this troll.
Okay, that actually makes sense. I guess my question then is where does the TrieMap behavior come in? Does the returned generic Map have overriden TrieMap methods?
Yes, the returned value is actually a legit (`Par`)`TrieMap`. You probably shouldn't cast the value, though, even though it would almost certainly work.
what are you trying to say (with the heavily opinionated title)? and why did you post that here, in /r/scala ? can you at least add a comment explaining your position?
Good for them. What does this have to do with Scala?
You're saying they bought it for the technology? Are you kidding? 
Application source is available [here](https://github.com/lihaoyi/workbench-example-app/blob/todomvc/src/main/scala/example/ScalaJSExample.scala). Whether its beautiful or terrible is a matter of taste!
But Facebook's chat backend is already written in Erlang and undoubtedly already processes more than 50 billion messages a day. (Does "across seven platforms" mean seven servers, or seven types of servers?) I don't see what that has to do with the acquisition. Even if WhatsApp's code is an order of magnitude more efficient, 70 servers is a drop in the bucket at Facebook's scale. Also, not clear what this has to do with Scala.
Interesting, I'm curious as well. Although practically, at this point you might want to use some sort of DB? :)
it means Scala proponents are looking the other way, instead of working on real deal projects that address this market.
`List` is limited only by memory. `Vector` runs into the same limit as arrays, but only in the base-32 logarithm (*i.e.*, it can hold up to roughly 32^2147483647 elements). There are others out there with similar properties, but they're usually more specialized.
use array of arrays
While this is, like your ScalaTags library, an interesting approach to generating markup, I'd like to see more focus on the JS end in terms of working with the DOM a la JQuery + Coffeescript, except with Scala running the type safe show. Also, generating markup in the TodoMVC approach only makes sense if highly modularized (e.g. header, footer, etc. are their own source file), or heavily commented; otherwise the code may be cleanly presented but have almost no benefit over pure XHTML markup in terms of readability (for me at any rate). Saying that, ScalaJS is looking pretty awesome here in its infancy, looking forward to seeing how it evolves.
I was actually considering doing some processing of data pulled from a DB. It just seems that all of scala's collections are bound to the size of Int....
I feel the interesting thing about the code presented is that it's about as hard to read as plain HTML, but *it also does reactive data-binding* which plain-HTML doesn't! Comparing the-code-presented vs plain-HTML-with-piles-of-javascript-behind, I think the-code-presented wins: the backbone version of TodoMVC has an addition 400LOC of javascript, for example, which is not a small quantity! Lots of work to do w.r.t. making it work nicely with other Javascript libraries/idioms, but my personal feeling is that "idiomatic" global DOM mutation with jQuery selectors always ends up as a mess. 