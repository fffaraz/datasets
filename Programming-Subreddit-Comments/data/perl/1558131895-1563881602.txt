The shim doesn't necessarily have to be a top level namespace. You could use another name in the Device::Firewall:: namespace or even a subnamespace of the current module.
I also don't think it was really expressed as a concern so much as explaining what happens.
&gt; What is the best way to determine if you're inside a one liner? Not sure if this is "best": say 'one liner!' if $0 eq '-e' It's possible to assign to `$0` and break this. &gt; I want to automatically export an object into main:: if we are in a one liner to reduce the code ... If something in your module is marked for export e.g., `@EXPORT_OK`, etc... you can import it using `-M`, note the `=auth` part: perl -MDevice::Firewall::PaloAlto=auth -E'auth-&gt;op-&gt;system_info-&gt;to_json'
I've been trying to put together this guide for a while, as a modern introduction to the philosophy and inner workings of Dist::Zilla. Please let me know if there's anything unclear or missing, it's hard to know what people don't know.
https://metacpan.org/pod/HTML::HTMLDoc
Thanks for putting this together. I'm going to have a close look at it and see if my author bundle can benefit from this information.
Something like this: https://perlmonks.org/?node_id=1222347
Chrome has its entire rendering engine and printing interface at its disposal. It's not surprising that that task is much more complicated when you're starting from just the HTML. You can use [WWW::Mechanize::Chrome](https://metacpan.org/pod/WWW::Mechanize::Chrome#$mech-%3Econtent_as_pdf(%25options)) to leverage that same engine.
The trick is to control Chrome programmatically instead of trying to recreate what it does. You can run it in a [headless mode](https://developers.google.com/web/updates/2017/04/headless-chrome) (which is what [WWW::Mechanize::Chrome](https://metacpan.org/pod/WWW::Mechanize::Chrome) does).
TIL Perl developers still exist.
I think extreme late binding sucks, it pushes the failure to the literally latest possible moment. I think better rule is to fail as early as possible. It simply produces more robust software because you have the opportunity to catch bugs before some hapless user runs into them. &gt;When was the last time you changed the behavior of a program and didn't have to stop it and restart it, often waiting hours for a complex recompilation? Every day. Quite a large number of statically typed compiled languages support this, e.g. C#, even C++ in Visual Studio, I'm told. For me, this is a standard thing you can get with java and some suitable IDE, though you generally can only change method definitions post start, not object data. I expect that the story could be similar in other VM-driven languages, where part of the compilation is deferred to runtime. &gt;In essence, objects should be able to announce that they did things and other objects can ignore them or say "hey, that's cool. Here's what I did in response." Yeah, this sounds like it would present difficulties in maintaining software. Let's say you have place A sending a message, and place B that's supposed to receive it in correctly-functioning program. In language such as objC which kinda does something like this, you can in fact send a message to object that it doesn't know how to receive, and it just silently falls to the floor. I think something like this would require serious IDE help, because you really actually want to know all possible places that can be sending or receiving a particular message just to know what all places need to be changed when you add new parameters or change existing ones. It is possible that I completely misunderstand this point in some horrible way, but again, I'd reiterate my prior sentiments and state that static validation of expected behavior is more important than flexibility of late-bound dynamic behavior. The latter allows easier evolution, sure, but evolution also becomes messy after a short while, with dead ends and strangely repurposed vestigial features reused for new things ‚Äî sounds like a recipe for spaghetti code to me! The former, again, permits having some basic assurances about your program like "every message sent is at least received by someone", which seems pretty damn useful guarantee to have.
TIL I am insane.
If using Perl means I am insane then I must be the most productive insane person ever.
&gt;"every message sent is at least received by someone"... seems pretty damn useful guarantee Any such guarantee is a lie.
Insane people get their stuff done. :)
In releasing my first CPAN module, I was stuck for some time as `$ milla build` gave me the error: Changes has no content for 0.01 at inline delegation in Dist::Zilla::Plugin::CheckChangesHasContent for logger-&gt;log_fatal which resulted because I had simply written a line of text in my Changes file, with no indentation (and no leading dash). I went through Dist::Milla::Tutorial and found under the section `Making the first release`: &gt; Now, make sure you have Changes file ready and have a new entry under {{$NEXT}}, which will be expanded to the next version of your module‚Ä¶ But what format does that line in the Changes file need to have? You might include a link to CPAN::Changes::Spec, particularly the part under `Required Elements`: &gt; Change lines have no specific format. Commonly, authors will use a dash - followed by a space to start a new change, and indent subsequent lines for multi-line changes. A complete example, showing exactly how to deal with "Next Version" placeholders, is [here](https://metacpan.org/pod/CPAN::Changes#DEALING-WITH-%22NEXT-VERSION%22-PLACEHOLDERS). Even a pointer to these things would help us first-time authors. Thanks for the great work!
What it actually requires in that case is probably best documented by the plugin doing that check: https://metacpan.org/pod/Dist::Zilla::Plugin::CheckChangesHasContent. It's actually much more lenient than the CPAN::Changes spec suggests, though of course following it is helpful to ensure your changes show up nicely on MetaCPAN. This is somewhat Milla-specific because Starter for instance doesn't use CheckChangesHasContent at all, though it is suggested. But I will see if I can add a mention to Changes format in there.
Event dispatch systems seem to fit nicely with the messaging paradigm. Some Perl examples are Event::Distributor, Beam::Emitter, Mixin::Event::Dispatch, and Mojo::EventEmitter. Mojolicious of course uses the last one to great effect.
Not sure what ‚ÄúLinux registry‚Äù is, but if you know what process name it has, you could use ps and grep to get list of processes that match ‚ÄúLinux registry‚Äù process. Or... Found this on stackoverflor [How can I check if a Unix process is running in Perl?](https://stackoverflow.com/questions/3844168/how-can-i-check-if-a-unix-process-is-running-in-perl) You could use Proc::ProcessTable to avoid having to launch an external command and parse its output. Something like use Proc::ProcessTable; ... my $t = Proc::ProcessTable-&gt;new; my $is_running = grep { $_-&gt;{cmndline} =~ /^dtllst $myNode/ } @{$t-&gt;table};
&gt;you could use ps and grep or use pgrep
Discovering pgrep and pkill changed my life.
I know. I read the man page the other day looking for some details, and lo and behold - turns out the author works in the office next to me. Didn't need to ask him - the man page explained what I was looking for. Classic Kjetil.
Show us what you've tried, and explain what isn't working.
How so?
Showing minimum required version, limiting to a specified level, and showing/hiding core dependencies (all in the table view) would be useful. Those are what I usually look for.
You know. ---- To be clear, I don't mean that as a dismissal of your comment. Quite the reverse. I write it because it distills the answer; hints at the unlimited potential of the knowledge of our reflections in indra's net (which I hope is of interest over and above all things computational); and rhymes with "How so?". ---- You'll note my reply has gotten some upvotes, without comment. This, despite my assertion being a very black-and-white absolute contradiction of a phrase from a comment that itself got similar upvotes. How so? ---- I think, as a next step, I will try turn this around. Can you conceive of asserting such a guarantee? If not, why not? If you can, what sort of thing would you provide to back up the guarantee? Cast iron mathematical logic perhaps? Common sense? Perhaps a test suite and results of running the suite many times?
(I didn't write the original comment btw) The reason I asked is that it seems to me that a strong statement like that is unwarranted without any nuance and context.
Very cool. Is this on MetaCpan as a button?
These are good suggestions, thank you. The first one is deceptively complicated though. Remember that these are the distributions required, and dependencies only care about versions of modules.
The "Dependency Graph" in the right panel will go to this graph, from which you can select the Table style from the dropdown. A direct table link would also be possible if they want to do it.
OK so if I put in module X and your result shows a dependency on module Y‚Ä¶ * Can I get a data structure of Y's requires/recommends/conflicts module list? * Given such data structure, or a single entry therein, is there an existing function/method to match cpanfile lines like `requires 'JSON', '&gt;= 2.00, &lt; 2.80';` against e.g., `{JSON =&gt; '2.70'}`? The result would be perhaps one of (OK, needs upgrade to latest, needs upgrade to version __, or conflicts with error). * Is it possible to input module X with version x.xx ? I know there are such bits inside `cpanm` and `cpanfile-dump` but could those be broken out so all the toolchain could be consistent? If we can solve a dependency graph thusly, it will be possible to update our smokers with minimum-redundancy tests, or to write an install-in-parallel cpanm, for example.
I've just been passing everything to weasyprint via the shell with IPC::Run3. Obviously spinning up a Python interpreter for every PDF isn't too efficient, but weasyprint seems to handle the job better than any other tool I've tried.
1. Yes, from MetaCPAN statically like the graph does (imprecise because it does not resolve dynamic dependencies for your system), or by running Makefile.PL/Build.PL like a CPAN installer does and then reading MYMETA.json. 2. https://metacpan.org/pod/CPAN::Meta::Requirements#accepts_module 3. https://metacpan.org/pod/cpm can install dependencies in parallel.
I opened https://github.com/Grinnz/cpan-deps-graph/issues/5 for discussion of the core dependencies option.
Why when you have perlbrew? And leave system Perl to the ops. Build your own.
Another nice interface to compiled libraries is [libffi](https://metacpan.org/pod/FFI::Platypus), which can be used with C++ as shown [here](https://metacpan.org/pod/FFI::Platypus::Lang::CPP), similarly you need to build the C++ code into a shared library.
Hey, something I've done before! Yay, upvote party!
This is great! I could never get SWIG working right when I was integrating a C++ library with Perl, so I ended up learning how to do it with XS (and gave an [Intro to XS/C++ talk](http://preaction.me/talks/Perl/Intro-XS-CXX.html) to Chicago.PM a _long_ time ago). I, too, had heard the advice that I needed to build a C API for a C++ class in order to get XS to work, but the `-C++` option to `xsubpp` works surprisingly well.
Has my added nuance helped? (As for context, I considered my original reply to have the implicit context of audioen's comment about a guarantee of message delivery, which in turn was in the context of increasingly broad topics -- his overall comment, ovid's OP, messaging-based sytems, unreliable distributed systems, cybernetic systems, and, most broadly, laws constraining the behavior of physical reality. That seemed to me like a whole lotta context.)
Ah, just realized that you are showing dependencies to *distributions*. Why do you want to do this?
[cpm](https://metacpan.org/pod/cpm) already installs CPAN distributions in parallel, BTW.
Patches welcome!
The answer to that question is a close variant to the answer why people buy RHEL.
Are they? ‚ÄúHi, here's a patch that complicates the code to make a redundant and undocumented feature work a little better in an extremely rare use case.‚Äù If it were my module, I'd probably say something like ‚ÄúThanks, but how about if you just call the function the way the manual says to?‚Äù
How about preventing programmers from screwing up?
" I don't know how anyone gets anything done. " we try until it works, then we spent the rest of the available time trying to understand why it does ;)
Oh hey, my favourite hobby. The key thing to remember is that if you're used to compiled languages, your intuition about fast code doesn't work in Perl. The bottleneck in most operations is the overhead of ops, scopes or the stuff that's necessary to be well-behaved. For example, I don't even have to run tests to know that a character parser will lose to a regex based one simply because all the extra ops will make most of the time spend be in the op overhead of shifting values around. The same applies to very quick integer algorithms where you repeatedly do adding, bit-shifting or similar things. Perl will do loads of checking in every single operation and will end up slower than a less sophisticated algorithm that simply uses less ops. The really painful thing is how much scope entry costs. In hot paths the fastest optimization is at times simply to go against every accepted software wisdom and to inline everything. Also: "map" should not be slower than "for" if the array already exists. The reason why it is in this case is the 1..10mio gets expanded into an array first and that's unnecessary work. It's tricky to measure stuff like that.
5.30.0 docs now available on perldoc.pl: https://perldoc.pl/perl5300delta
It is a visual representation of what you will actually need to install from CPAN - one installs distributions, not modules.
It's a balance. If you aim to prevent every screw up, your argument handling will be longer than your actual code, and you will have to maintain that every time you fix bugs or add features, and if you document all those options to indicate they're supported it will be more confusing to the user since they all have the same result. Instead I would aim to provide one useful documented API, and try to handle only the most common user failures gracefully (either by DWIM or throwing an error).
Nothing earth shattering jumps out at me. Anything worth-while that I missed?
Regarding the "hash key vs regex" section, the first loop is incrementing `$count` by 1 each iteration, while the second loop is adding `$i` to `$count` each iteration, which will have a significant impact in a loop with 100,000,000 iterations. The conclusion of the "hash key exists" solution being faster is still accurate, but the margin isn't quite as wide. Also, using a `index('read', $str) &gt; -1` check is faster than either of the other options. Here are my results: # ~5.9 sec for my $i (1..100_000_000) { if ($str =~ /read/) { $count++; } } # ~2.67 sec for my $i (1..100_000_000) { if (index('read', $str) &gt; -1) { $count++; } } # ~3.9 sec for (my $i = 1; $i &lt; 100_000_000; ++$i) { if (index('read', $str) &gt; -1) { $count++; } } # ~3.7 sec for my $i (1..100_000_000) { if (exists $info-&gt;{'ReadCall'}) { $count+=$i; } } # ~3.2 sec for my $i (1..100_000_000) { if (exists $info-&gt;{'ReadCall'}) { $count++; } }
Also, in the "Regexes are faster than string comparisons" section, `@chrs` isn't getting reset every loop, so the author isn't testing exactly what they think they're testing. And using `shift` to "consume" each character is much slower than just iterating over all of the characters with a `for` loop. It doesn't seem like the comsumption is strictly necessary, and if not, there's a significant speed increase to be had there as well. # ~ 7.8 sec for (1..500_000) { my $word=''; my @lchrs = @chrs; while (@lchrs) { my $chr = shift @lchrs; if ($chr ne ' ') { $word.=$chr; } else { push @words, $word; $word=''; } } push @words, $word; } # ~5.6 sec for (1..500_000) { my $word=''; my @lchrs = @chrs; for my $chr (@lchrs) { if ($chr ne ' ') { $word.=$chr; } else { push @words, $word; $word=''; } } push @words, $word; }
Sadly if I wanted faster code I became aware that I would need to use Python or PHP. I love Perl and it's depressing how the other scripting languages are getting faster while Perl doesn't improve it's performance. In any case it gets worse, Rakudo for example is even more slower.
For kicks I was playing with a regex version, and it was speedy, probably because it does the split and search with no intermediate, but interesting either way: use strict; use warnings; sub main { my $cnt = 0; my $re = qr/((?&lt;=^.{1})|(?&lt;=\t.{1}))bc((?=.{3}+\t)|(?=.{3}+$))/; while (&lt;&gt;) { tr/A-Z/a-z/; s/$re/++$cnt/eg; } print "$cnt\n"; } main(); Future me would hate me for that regex though.
No shiny features other than the limited variable length lookbehinds (which is quite nice). Unicode 12.1 and the performance improvements are nice if not exciting. I am glad for the fatalization of sysread on :utf8 handles as it was just another completely broken aspect of file/layer handling.
Rakudo has nothing to do with Perl. The latest release of Perl 5.30 just came out today and has [several performance improvements](https://perldoc.pl/perl5300delta#Performance-Enhancements), just like the last several major releases.
I'll test and report back. But I don't expect much. Hopefully I'm wrong.
Linux does not have a registry like the windows registry. Indeed, many of the things you find in a registry are found in files inside /etc/ others are in in hidden files and directories in the users home directory. What aspect are you looking for? Generally Perl can execute shell commands, and return the results to your program, rather than interface directly with operating systems internals.
That's how I see it too. I wrote a blog article last summer about how, if your function tolerates all sorts of erroneous argument formats, you're actually making things harder, not easier. [https://blog.plover.com/prog/perl/do-not-2.html](https://blog.plover.com/prog/perl/do-not-2.html)
So I was particularly fascinated to have hit Ovid's article mentioning this talk and listened to it raptly. Thing is, I have been working for years on a system (prototyped in perl) whose purpose is the asynchronous processing of messages using what amount to *independent computers* - because each business rule is entirely segregated (outside of agreeing on message passing formats) from all of the others. I call my multitemporal event assembled rule processing and reporting framework 'Replay' after what I consider one of its critical features - the ability to replay the events received and reconstruct the state of the system on demand. So many elements of Kay's design/ideas are in here - not because I was aware of his expression of them but because they make sense to me. Lets see if I can explain how this fits in some ways. Kay describes such a system as 'virtual computers cooperating' A Replay Rule Version is a particular code configuration that operates on a set of state atoms. Every rule gets an opportunity to inspect and transform for its use every event on the bus in the domain. This meets Kay's description of a system that can discover information and respond to it. Rules will typically recognize state transitions say Rule Alpha-four recognizes (A then B means state transition C) and it'll emit a new event such as 'Transition-C (from Rule Alpha-four at event stream serial X)' which will be tossed out on the bus. The source information would permit the rule to emit a message that might say semantically "Beta-three to Alpha-four: event C state transition received". The interesting part about 'discovering' is (though i don't conceptualize of a rule being AI enough to recognize the interest in a rule) that a programmer will proactively emit 'interesting information' out on the bus so that other rules can collect and use it later. Thanks to the replay capability of Replay, when you create a new instance of the domain (by configuring a new rule to be effective back at some point in time) the state of the system backs up to that point and all of the events replay - so that your new rule (or version of a rule) gets full opportunity to observe and react to all of the events in the system. Anyway, if you care to read more about it, ask me, or, look it up on my github! I will wax verbose. I've been working on this for years and I think it is a REALLY good idea that could really go far as cloud computing grows. https://github.com/DavidIAm/Replay Skylos
why the fuck is this showing up on notifications im not even subbed to this
The script I used is a O(n!) algorithm: `Perl-5.24.0` `time perl` [`permutate.pl`](https://permutate.pl) `real 0m16.247s` `user 0m16.142s` `sys 0m0.085s` &amp;#x200B; `Perl 5.31 (It was easier for me to install this version)` `time perl` [`permutate.pl`](https://permutate.pl) `real 0m15.931s` `user 0m15.865s` `sys 0m0.060s` `Improved but there's a long road ahead:` `PHP 7.2.17` `time php permutate.php` `real 0m4.249s` `user 0m3.975s` `sys 0m0.273s` `Python 3.6.7` `time python3` [`permutate.py`](https://permutate.py) `real 0m9.821s` `user 0m9.690s` `sys 0m0.124s`
Explain "code is updated" and "parts of the code are reloaded". Provide a [SSCCE](http://www.sscce.org/).
You should provide the python and php versions too. How's this one do compared to yours? #!/usr/bin/env perl use warnings; use strict; use feature qw/postderef/; sub permutate { # $a shouldn't be used as a variable name outside of sort blocks my $s = shift; my $s_len = @$s; if ($s_len &lt;= 1) { return $s; } $s_len -= 1; my @r; for my $i (0 .. $s_len) { my @v; for my $j (0 .. $s_len) { if ($j != $i) { push @v, $$s[$j]; } } my $s_i = $$s[$i]; for my $k (permutate(\@v)-&gt;@*) { push @r, $s_i . $k; } } return \@r; } my $r = permutate([split('', 'ABCDEFGHIJ')]);
I can't really provide a SSCCE given the rarity of such occurences. I don't know how to force that error. &amp;#x200B; Code updating. My project is stored in git. All my servers have that folder checked out and all the code runs from there. So code updating is a git pull. &amp;#x200B; Parts of the code are reloaded. What happened today. Yesterday I defined a new function in one module and started using it in another (in one commit). Restarted fcgi processes, they worked fine. Today workers of some daemon started to die with a compilation error because they reloaded second module - which imports this new function - and did not reloaded first module, resulting in a `"new_function" is not exported by the First::Module module` error. Daemon restart fixed that.
Btw I'm not asking for a fix. "How in the hell that can be possible" is more what interests me.
You mention fcgi in passing. Without more details I can only say that this all sounds like a common failing of mod_fcgid for apache.
That error never occured in a fcgi, always in a daemons. I'm not sure about terminology here, English is not my native language. By daemon I mean a standalone script that forks some childs and do some work (usually jobs from a work queue in my case) in a background without ever exiting (unless its stopped or fails for some reason).
PHP: &lt;?php function permutate($a) { $s_len = count($a); if ($s_len == 1) { return $a; } $r = array(); for ($i=0; $i &lt; $s_len; $i++) { $v = array(); for ($j = 0; $j &lt; $s_len; $j++) { if ($j != $i) { array_push($v, $a[$j]); } } $p = permutate($v); for ($k = 0; $k &lt; count($p); $k++){ array_push($r, $a[$i] . $p[$k]); } } return $r; }; $r = permutate(str_split('ABCDEFGHIJ')); Python: def permutate(a): s_len = len(a); if (s_len == 1): return a; r = []; for i in range(s_len): v = []; for j in range(s_len): if (j != i): v.append(a[j]); p = permutate(v); for k in range(len(p)): r.append(a[i] + p[k]); return r; r = permutate(list('ABCDEFGHIJ')); &amp;#x200B; Rakudo: sub permutate { my @a = @_; my $s_len = @a.elems; if ($s_len == 1) { return @a; } my @r = (); loop (my $i=0; $i &lt; $s_len; $i++) { my @v = (); loop (my $j = 0; $j &lt; $s_len; $j++) { if ($j != $i) { push(@v, @a[$j]); } } my @p = permutate(@v); loop (my $k = 0; $k &lt; @p.elems; $k++){ push(@r, @a[$i] ~ @p[$k]); } } return @r; }; my @r = permutate('ABCDEFGH'.comb);
The forked children will only have preloaded whatever has been loaded before it was forked. If some code is not loaded until after they are forked, then that worker is cleaned up and a new one forked from the parent, it may then load that code again seeing the new version. But it will still have the old version of any code that was preloaded by the parent because that was not restarted. So one possibility is that some component is being preloaded and another is not.
 Using Perl 5.31: time perl permutate2.pl real 0m11.289s user 0m11.190s sys 0m0.069s time perl permutate.pl real 0m14.580s user 0m14.464s sys 0m0.116s But I think is not fair to do much optimizations. I made a common code to test and I think I made it for all the other scripts (no script specific optimizations)... Sadly Perl is last place in all my tests. Funny thing is, I remember doing some tests years ago and I don't remember Perl being in last place. Seems popularity of the language does influence :-/
Not to discount the usefulness of this benchmark if this is the sort of thing you are doing, but you can create a benchmark for any language to do poorly based on whether you use better optimized parts of the language. There are even benchmarks where Rakudo outperforms Perl 5 because of this. Just to say, don't try to make any conclusions of a language's performance based on a single script.
I agree. But I think the algorithm I made uses 'common' things most people would do to process data but in this case using the worst time complexity.
The main way that such things are possible occur when you and the computer disagree on what is happening.
It's not so much optimized as rewritten to use more idiomatic loops.
Fair enough, specially when I didn't posted the other scripts for comparison. Compare with PHP and the PHP version I have is not the most optimized one... I envy them :-(
Hmm, that sounds very likely... Aaand second module is actually loaded at runtime! ü§¶‚Äç‚ôÇÔ∏è Too bad I can't review previous cases of this error with different modules, but most likely reason is the same. &amp;#x200B; Thanks!
&gt; The really painful thing is how much scope entry costs. In hot paths the fastest optimization is at times simply to go against every accepted software wisdom and to inline everything. I'm one of those rare people that recently started my first professional Perl position. Could you expand on this and/or provide further reading?
Take a simple loop like the one in the other comment chain and experiment with the following (assuming you know about B::Concise, also look at the generated optree): 1. How much slower does it get if you put the loop body into a sub, and anonymous sub in a scalar or into a method of an object? That's function overhead, perl is notoriously atrocious with it. 2. How much faster does if get if you use post-or notation instead of the usual block notation? It turns out that this is not trivial. On a simple 100mio increments that's more than 10% of the runtime. My choice of words wasn't that careful I admit. But what this means is: If you have a complicated piece of perl that needs to run in the to millions of times, you want to: - make sure it doesn't use objects (because method calls are really slow) - ideally want to use as few function calls as possible as well - and if you really need the last percent as well, reduce small unnecessary scopes like from if/for/while etc. And these are desperate (not quite as desperate as rewriting those parts in C at least) measures because that's exactly what you don't want to do as a software dev to make code readable and maintainable. Obligatory cautioning about premature optimization yada, yada, you know the drill. This is not something to do in everyday code, but I had to apply this quite a few times.
That's what I meant in my own top comment. Perl is rarely good at converted C-style algorithms like this one. Perl gets stronger once you use the builtin list operators to avoid those fiddly loops and usually keeps up pretty well with them unless hard number crunching is required. For starters you'd avoid all that loop stuff and write something like this (while keeping the algorithm as it is): sub permute { my ($a) = @_; return $a if 1 == @$a; my @r; for my $i (0..$#$a) { my @v = @$a; my $ai = splice @v, $i, 1; push @r, $ai . $_ for permute(\@v)-&gt;@*; } \@r; } Then you'd throw out the algorithm and use a proper Fischer-Krause permutation, which is even supplied as a sample in the perlfaq4 man-page. And then you'd just fire up cpan, install Algorithm::FastPermute and be done with it.
My original complain was that perl scripts are slower. Your argument here is that you need to write them in a specific way to make them stand their ground against other scripting languages and finally suggest using a module that does the heavy weight stuff in C code. You ignore the argument I'm making that the other script languages are faster without such OPTIMIZATIONS. The argument you're making can be done for all programming languages in existence, hence why the scripts I show look as close as possible to each other, to take out language optimizations from the equation. If you look at the scripts I made and say "but you should have done this to make it faster", you're making a language specific optimization. In my experience Perl is currently the slowest. I love Perl, it is my preferred language but it is what I've experienced.
Btw, I tested the script you supplied and it took about 11s to complete in the same environment it took 4s to complete the PHP script.
When benchmarking Perl against Perl, the Benchmark module can be very handy. This comes with Perl unless the downstream packager of your choice has been to aggressive about what "ought" to be core Perl (it happens!).
Very nice. &amp;#x200B; I had a need to create a wireless USB stick. I install Linux on different devices and I use different sticks. Some of these devices are purpose built and I have a special bootable USB stick for them. I had USB sticks strewn across my cart. &amp;#x200B; I searched for a "wireless USB flash drive" that would be USB storage on the USB side, but ISCSI on the other. No luck. I used the PI Zero W to accomplish this task via NBD. I created a blank file and told the W to use that as the "flash drive". I then created a config file that would be used at boot to select the correct NBD image. Even though the blank file was 0 bytes the W did not complain and after boot it would appear as a USB mass storage device to the device I was booting. I guess you could have a 32G USB stick, but walk too far from my home you now have a 0G USB stick. LoL.
&gt; The argument you're making can be done for all programming languages in existence Yes, and it should be made. If you ignore the peculiars of the language, then all you're testing is how similar the language is to C.
&gt;If you ignore the peculiars of the language, then all you're testing is how similar the language is to C. If I follow your suggestions, sure I end up with performance close to a program written in C. Which is why I think making the code as close as possible between languages is better. If you're implying the reason the code performs bad is because it's coded in a C style, I think you need to re-read the post I made in which I ran your 'perl' optimized code and it took 11 seconds vs the non-optimized PHP code I wrote and took 4s (without JIT), almost 3 times slower then PHP. So even with the Perl style you theorize runs slow. [https://www.reddit.com/r/perl/comments/brn70e/writing\_faster\_perl\_code/eondm7s/](https://www.reddit.com/r/perl/comments/brn70e/writing_faster_perl_code/eondm7s/)
&gt; I mean using a pretty complete computer just to enter a password into another computer. I completely understand what you mean. I live in an area that has crappy power lines so we get issues all the time, so I have a bunch of UPS units strewn all over my house. Last time power went out, a few of them straight up died because I couldn't monitor the units without a computer attached to them and most of them where no where near a computer. So I got a bunch of Rasp Pi Zero W units and using them with nut to provide wireless stats for each one not with a PC, and am working with perl to aggregate that data in a nice way on my central server. Basically using the Pi as a wireless relay for the UPS data, which seems kinda silly for what they can do. But hey, they were $5 a piece so why not.
Cool! :) The right thing to search for was the blocker for me for the longest time :-/ Originally I wanted ready to go solution. I imagined myself a dongle with WiFi, or a keyboard with WiFi :) or some similar device. I searched online, I asked sales reps in electronics stores. Another thing I envisioned: one of those Bluetooth dongles used with wireless keyboards, a generic one, not proprietary, like Logitech's. Thought to control it from Pi Zero W via Bluetooth (which it also has). But for some reason I just couldn't find any examples of how to programmatically control those dongles -- again, was probably using the wrong search terms. Then I slipped into stream of though if there are solutions involved mobile apps. Turns out there are ton of mobile apps to control desktop PC remotely, but all of them require software running on the PC, so it was useless for me. But this led me to find an app that was working with a device, not a piece of software, was talking about USB keyboard, and communicated with it via Bluetooth. It sounded like exactly what I needed! (except for having a mobile phone instead of $5 Pi, and the device also costs $40 itself). As I was reading more about it it sounded like it's was a Raspberry Pi based device, which made me think -- wait, what? can Pi just be configured as USB keyboard by itself? Quick search about Pi, USB HID keyboard, and woah! I couldn't believe how long this took me to find this and the path it took ))
Exactly! :)
Exactly, and that is a result that I think is way more interesting and noteworthy than copy&amp;pasting code between languages. Just to be clear: I'm not saying that Perl will beat the other languages in this setting, I'm saying that it's useless to compare code that plays to the strength of one language without adapting it. Perl loses on number crunching, as I wrote. Perl usually wins at string manipulation and in anything you can pull from CPAN because last time I checked PEAR sucks balls compared to CPAN. I'd love a JIT perl, because it would address exactly these kind of shortcomings. And until we get one, all that is left is using a better algorithm or a CPAN module that implements the algorithm in C.
Ingenious. I would suggest such a setup can have many uses, specially if as well as keyboard activity, mouse activity could be delivered from the pi. Both legitimate and malicious possibilities exist though... Imagine a pi-in-the-middle attack
\*cough\* Redhat \*cough\*
A fake Twitter account in my name prevents me from updating my **[MetaCPAN](https://metacpan.org/author/MENTIFEX)** profile, but anyway I am too busy **[coordinating](http://medium.com/p/fa7ebe035831)** my Russian-speaking Perl AI **[software](http://ai.neocities.org/perlmind.txt)** with my Russian **[JavaScript](http://ai.neocities.org/Dushka.html)** software.
I was under the impression that inlining everything in the bottleneck was standard practice for optimizing; it's against standard wisdom in that in many cases, performance is good enough, so standard optimizations like inlining hit legibility for no real gain. Now, if performance does need to be better, then inlining bottlenecks is a straightforward way to go, no matter the language. (GCC -O3 inlines very heavily.)
It has a disproportionate benefit in languages like Perl with a (comparable) lot of subroutine and method call overhead, due to its scoping and abstraction features. But yes, it is still unnecessary optimization in most cases.
thanks! well, I'm not sure if most such uses require physical keyboard &amp; mouse vs say "software keyboard &amp; mouse". there are a lot of applications out there that are desktop "kbd/mouse emulation software" + application to control that remotely (a lot of mobile apps on Play store for this, for example). they wouldn't work for me, as I needed something before OS boots, but for other uses ... but yes, one must be very brave or very competent in developing secure software. or very insured :-)
The article points out that the author was able to get this code to speed up from 45 seconds to 2 seconds runtime, just by doing some profiling and changing a few structures. Before you go ditching the whole codebase and rewriting in something else, there are often plenty of tricks to squeeze more from what you already have.
If you haven't used [Devel::NYTProf](https://metacpan.org/pod/Devel::NYTProf) before, you're really missing out on a fantastic bit of software. The flame graphs are incredibly helpful and the information captured is comprehensive and useful. I used it on a Sudoku solver I wrote, and managed to cut processing time by a huge margin with its help.
The faster string interpolation looks like a nice under-the-covers feature.
I do a lot of binary file hacking, so this ends up getting copy-pasted into practically everything now as a wrapper for `read()` use carp; #### # helper: safe read # params: fp, length sub _rd { my $bytes_read = read $_[0], my $buffer, $_[1]; croak "Short read on file: expected $_[1] but got $bytes_read: $!" unless $bytes_read == $_[1]; return $buffer; }
You'll probably have a better chance of getting some help by asking r/perl6
Actually, [https://stackoverflow.com/questions/tagged/perl6](https://stackoverflow.com/questions/tagged/perl6) may give you an even better chance.
You know your worth when your enemies praise your architecture...
Tried Python. Language named with snake as a name gives me the creeps; significant spaces give me FORTRAN4 dropped-card-deck nightmares. Nope. Tried Ruby. Zero is true! (Because zero is an object and objects are true.) Nope. Back to Perl, huzzah!
Don't be fooled, distros are quite busy rewriting all the Perl out of their tools.
I live and work with perl everyday. But Octoprint... for remote 3d printing... nothing but python... Updated it today and failed, but the update had a workaround built in to try a second way... Fun times were had.
Python's strictness about white space is a non starter for me.
Perl is far and away the most important language for **[Artificial Intelligence](http://ai.neocities.org/ConJoin.html)**.
Your slash is backwards, it should be \`\\n\` and \`\\s\`
That's right. A few months ago I saw a video of q guy who was rewriting build tools, currently perl, into bash (IIRC). Wait, I think he mentioned "ash" in the same video. (ash is the rather primitive shell you get when you ssh into vmware, for example.)
\s will match [\ \t\r\n\f] I might try return (defined $1 ? ‚Äòspace‚Äô : ‚Äòenter‚Äô ) if $key =~ /(\ )|\n/; return undef; but I typed this on mobile, so I haven‚Äôt tested it.
With an editor that auto-indents, it becomes automatic in no time at all.
I can live with the whitespace honestly. Python fails for me because of the PHP insanity that is scoping, ++$i not even giving a warning, and lambdas being restricted to expressions because everything else would be "unpythonic".
I had to write a CLI tool in an interview. Freaked out for a bit, then realized I could write it in five lines of Perl...
The internet [doesn't agree with you](https://www.geeksforgeeks.org/top-5-best-programming-languages-for-artificial-intelligence-field/).
It might be easier to use ascii values; use Term::ReadKey; ReadMode 4; my $key = ord ReadKey 0; ReadMode 0; if ( $key == 27 ) { print "Escape pressed\n"; } elsif ( $key == 32 ) { print "Space pressed\n"; }
I went through a rewriting from Perl to Python, then went through another rewriting from Python back to Perl dynamic languages are on their way to the museum, generic programming Dlang-style is finally going to do them in
It's a [known troll](https://www.nothingisreal.com/mentifex_faq.html). Just ignore it.
Probably even less in Perl 6 :)
Honestly, I like that it soft-forces you to factor out functions. If you hit six tabs, you're way overdue for a refactor.
What do you mean like that? As far as I know D is still not widely used after two decades, while Javascript is the most popular and fastest growing programming language at the moment...
Perl has always been my go to for automating something. Started learning it before i ever took a good look at bash scripting. Still my go to today.
it does not have to be D, only to have as sane and and as powerful templating/generics, then nobody will bother with dynamic languages. C++ has powerful generics but I understand debugging is unpleasant, while it is easy for D. Here is a good tutorial for using the Dlang style of generics/templates [https://github.com/PhilippeSigaud/D-templates-tutorial](https://github.com/PhilippeSigaud/D-templates-tutorial) . I started learning D a couple of years back, not putting too much time into that but already can do more and write a lot less code than I used to do in Javascript or PHP or Perl or Python. I don't really care if it is popular or not, tough it became a lot more popular since about 2017, with generics it is the only statically typed language I do not despise.
 Every time I hear "Perl is dead!" it's some guy (rarely gals, they have more sense) who knows only one programming language. I started hearing "Perl is dead" when Scheme was all the rage, and that was before year 2000. Perl5 is still alive today despite all the shouting and cajoling.
Oh, I know who he is. I'm not sure it's accurate to call him a troll. He's just a kook.
Books are still written in Latin but that doesn't mean it's still a living language.
More specifically, ash is the Almquist Shell, intended to be more like the Bourne shell, meaning no Bash enhancements. It's frequently used as the default shell for speed and so-called "limited surface area of attack", meaning fewer features implies fewer opportunities for exploits and failures.
Did you try Rust? Just mentioning it because it has generics (and will soon have const generics) and macros and is heavily focused on static guarantees and optimisations. It does not have templates as powerful as C++ or D though.
this is a good solution
I switched from Perl to Ruby just over a decade ago. Ruby just *feels* right in areas where Perl is weak (sigils, weird data structures, bad exception handling, weird variables) but matches it in areas where it's strong - especially string manipulation. Not to mention the quality of libraries and pace of development in Ruby is very nice.
&gt; message queues His point has nothing to do with message queues, as you correctly point. Going into that amount of detail would violate encapsulation, in fact. It might be implemented like that, but it's certainly not something people should use unless they have requirements that warrant it. Perl 6 has the simplest implementation I have seen that allows for what Alan Kay asks for, let me show it: If the standard way of resolving a method name fails, P6 will call a method named [FALLBACK](http://docs.perl6.org/language/typesystem#index-entry-FALLBACK_%28method%29) as a last resort: class Magic { method FALLBACK ($name, |c(Int, Str)) { put "$name called with parameters {c.perl}" } }; Magic.new.simsalabim(42, "answer"); # OUTPUT: ¬´simsalabim called with parameters ‚åà\(42, "answer")‚åã‚ê§¬ª To get an Alan Kay Object, the only method implemented in a Class should be FALLBACK. Of course, Perl 6 doesn't even look at object structure until runtime (extreme late binding). That's not accidental: it allows for things you cannot do with any earlier binding, see [this answer](https://stackoverflow.com/questions/56011589/why-is-adding-methods-to-a-type-different-than-adding-a-sub-or-an-operator-in-pe/56013889#56013889) by Jonathan Worthington: &gt; [...] a method call is a verb to be interpreted in the target object's language. This is the dynamic, late-bound, part of Perl 6. While the most immediate result of that is the typical polymorphism found in various forms in implementations of OO, thanks to meta-programming even the manner in which a verb is interpreted is up for grabs. For example, a monitor will acquire a lock while it interprets the verb and release it afterwards. Other objects might have been constructed based on things other than Perl 6 code, and so the interpretation of a verb doesn't mean invoking code written as a Perl 6 method. Or the code might be somewhere over the network. Who knows? Well, certainly not the caller, and that's the point, and the power, and the risk, of late binding. [...]
Another example: Unix kernels have a subsystem called VFS, for Virtual File System. It stands in for a File System and delegates any file I/O to real filesystems, which one to delegate a certain operation is decided by a 'mount tree'. It's architecture is object-oriented: filesystems are built as objects in which VFS will call methods such as open(), read(), and write(). Filesystems might not even be in the kernel, and may execute code that's developed elsewhere by someone else, and the VFS developers might not even be aware of. That's extreme late binding. How is a language supposed to bind a method call to code it will won't ever be able to get in contact with?
Perl is now 32 years old, making it older now than FORTRAN (1957) was when Perl was first written in 1987. FORTRAN is still going strong despite having been "dead" since the popularization of Pascal by UCSD in 1978.
Bold move... IT WORKED! &amp;#x200B; Thanks again...
Noted. What's the point of the whole colon-symbol thing? That seems a pointless over-complication and over-optimization versus just using strings.
Yep, Ruby isn't perfect and symbols vs strings is an ongoing debate. Essentially, symbols are just immutable strings. They have a few specific uses that mainly revolve around being used as unique identifiers (keys in a hash). But compared to the horror of trying to explain to a new programmer the differences between references and values, I'd take symbols and strings any day.
And it could easily be the default when distributions link the editline library for history recall. As it aims to be posix compatible it should at least have the vi bindings available.
Though I don't know it nearly as well as Perl personally, I consider Ruby to be pretty close in terms of usability. The one feature it's missing is the equivalent of `use strict 'vars'` for variable typo checking - preventing variables from magically existing by using them, even by assignment. As discussed [here](https://www.ruby-forum.com/t/why-no-perl-style-use-strict-in-ruby/109339/5), it may be because there's no syntactic distinction between variables and methods.
I'm really confused ever since perl6 came to be. When i heard it was a new language i thought why call it perl then. Then i wondered if i should start to rewrite things. And then i felt annoyed because i didn't really want to and maybe another language would be better if i needed to rewrite anyway. I'm glad perl5 is still here and i hope it's not going anywhere. I wish perl6 was called something else because i think i'm not the only one having these issues.
They should've settled on tabs instead, now it's a mess. Now how could that be avoided... euhmm... ;)
I agree and kind of wish it was included in a command-line viable way. At least in Void Linux, dash (very similar to ash -- maybe even a derivative, I forget and lack the time to research) is the default primarily for non-interactive scripting. Since its purpose is primarily init scripts and other stuff running non-interactively as root, fancy things like editline and fc are not included; this helps reduce the size and reduce the attack surface.
Yes, same here on debian. Tbh, editline isn't that big and is fairly well audited afaik. It started in tcsh and is still used in the default shell on freebsd and netbsd.
You're not alone. This is why the [Raku alias](https://github.com/perl6/roast/blob/master/docs/announce/6.d.md#language-name-alias-decision-raku) was created.
Remember: You are writing the legacy software of tomorrow.
Yes, I miss this too. Ruby's flexibility can be a hindrance as well as an advantage, and it can be easy to abuse. I've written quite a lot of Go over the last few years and wouldn't hesitate to use it for things where being correct is *vital*.
Insert "big knob" joke here
That's system-perl, nobody touches that anyway. :D AFAIR the meme was started by Python folks aggresively pushing their doctrine back in the early 2000s. I was tired of it then. It's a pitty people bought into it, since Python is such an inferior language :D (even by scoping rules alone, as already mentioned elsewhere in here), but that's what a fashion driven industry will give. But, avoiding the normal progression of gradual improvements, Perl6 actually brought the meme to fruition and threw Perl in limbo, except for some small peaks of resurrection (Moose, release-schedule-post-5.8, blogs-cca-2007-2014), there's hardly new blood in it, graybeards starting new projects with Perl notwithstanding. :) I die a little every time I write python code for ML on some remote 3-hops-away box and I have to eventually remember to `:set list`, or when it dies in some rare path because of a misspelled var. "but it's so readable, is it not ?!" :( oh, ffs... I'm glad Go eats its lunch, and Julia and R and others, even JS, anything is much healthier than the lies Python sits upon. I wish all languages had at least the lexical scoping, coderefs, shell-outs and evals of Perl. IMO, Perl6 is not yet practical - hence it may be ERL not PERL :) - speed matters a lot. A reasonable upgrade path matters a lot too, but speed trumps even that. I don't think it's likely that Perl6 will ever deliver the impressive speed required for it to succeed. Widely. So there you have it, stuck on 2 fronts.
&gt; Ruby's flexibility can be a hindrance as well as an advantage, and it can be easy to abuse. Also something it shares with Perl. Strict 'vars' may not be type strictness like those other languages have, but it manages to catch a lot of common errors, and it's nice that [JavaScript thought so too](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode#Converting_mistakes_into_errors).
&gt; It's sad to see it fade away The language has not and is not fading away. Perl 5 still has yearly major releases. I haven't been following Perl 6 releases, but I gather they're coming out regularly too. There are certainly far fewer people programming in Perl than there used to be, and there are far more programmers overall. Perl makes up a considerably smaller part of the programming language ecosystem. But the language itself isn't disappearing. Nobody is prevented from producing new software in Perl, and for some (including myself) it's still the most expedient language available to do so in many cases. Why be sad about it?
[This right here](http://blogs.perl.org/users/damian_conway/2019/05/why-i-love-perl-6.html) is making me fall in love with Perl again.
For some new fun with Perl: Take a peek at [Mojolicious](https://www.mojolicious.org/) and jump back into things.
The community has diminished. The marketability has definitely diminished. I guess those are just two reasons to be sad. Back in the day if I needed an extra $K I could easily pick up 10 hours of contract perl coding on the side. No longer. At my current job, on my first day, the CTO (who knew I was a perl guy) told me that his one request was that I not commit any code written in perl. This is a company of extremely bright young coders, with a codebase containing about 20 different languages. But perl is verboten.
Mojo and Minion changed my world.
This is a command intended to be run in shell. The user is embedding variables and using concatenation. \‚Äù is how you escape a ‚Äú in a string. $temp starts with ‚Äú, signifying the start of the string. On the line after, do print $temp.‚Äù\n‚Äù; To see what it contains.
"The Forbidden Language" - Now it has all the more appeal!
A few things to explain here: * The backslash (\\) is an escape character. * In Perl, double-quotes (") mean that anything inside that looks like a variable will be interpolated into the stringified value of that variable. If you don't want interpolation, you would use single quotes ('). * If you are using double-quoted strings, and want to include a double-quote inside them, you can escape the double-quote. This tells Perl that you're not ending the string quite yet. * The author of your snippet engaged in (imho) bad form by breaking out the variables and concatenating them (the dot (.) operator) rather than just using interpolation.
Could be better written any of these ways: #Double-quoted with interpolation $temp = "xe snapshot-list name-label=\"$name-$day\" | grep \"uuid\""; #Single-quoted with concatenation $temp = 'xe snapshot-list name-label="'.$name.'-'.$day.'" | grep "uuid"'; #Sprintf formatted $temp = sprintf('xe snapshot-list name-label="%s-%s" | grep "uuid"', $name, $day); #Using the qq operator for string interpolation without needing to escape double-quotes $temp = qq{xe snapshot-list name-label="$name-$day" | grep "uuid"};
**[Dushka](http://ai.neocities.org/Dushka.html)** Russian AI recruits Netizens for bilingual **[artificial intelligence](http://ai.neocities.org/perlmind.txt)** in **[Perl](http://strawberryperl.com)**.
1. If your string has ANY quotes in it, use q{} (instead of '...') or qq{} (instead of "...") to quote it - then it never matters what quotes are already in the string. 2. If your string does NOT have any quotes in it, use q{} or qq{} anyway because some day, it very well may. :-) 3. Remember that you can use a variety of characters as the delimiters. I tend to use () instead of {}. If your string has those characters in it, choose another set of paired characters, like \[\] or &lt;&gt;. You can also use the same character on both ends. Typically I see /../, but I don't like that because it makes me think regex. 4. If you pathologically do q'' or qq"", turn in your CS degree. :-)
 [https://metacpan.org/pod/Term::ReadKey#ReadMode-MODE-\[,-Filehandle\]](https://metacpan.org/pod/Term::ReadKey#ReadMode-MODE-[,-Filehandle]) This table has string synonyms. You're better off with `ReadMode 'raw';` so you'll have a better idea in six months from now what you were trying to do.
How about `q""`?
so nice, im currently building a new project in them.
 DB&lt;2&gt; print $temp.‚Äù\n‚Äù; Unrecognized character \xE2; marked by &lt;-- HERE after int $temp.&lt;-- HERE near column 108 at (eval 9)[/usr/share/perl/5.26/perl5db.pl:738] line 2. at (eval 9)[/usr/share/perl/5.26/perl5db.pl:738] line 2. eval 'no strict; ($@, $!, $^E, $,, $/, $\\, $^W) = @DB::saved;package main; $^D = $^D | $DB::db_stop; print $temp.‚Äù\\n‚Äù;; ' called at /usr/share/perl/5.26/perl5db.pl line 738 DB::eval called at /usr/share/perl/5.26/perl5db.pl line 3135 DB::DB called at -e line 1
And given your string contents, consider using the last option here: `qq{}` since that leads to the least amount of clutter. Note that the delimiters `{` and `}` can be replaced with other things if you so wish, e.g. if the string contains any of those chars. These all work: `perl -E 'say qq|hello|; say qq&lt;world&gt;; say qq"etc."; say qq/etc./;'` Read more about this in `perldoc perlop` (search for "qq").
&gt; The author of your snippet engaged in (imho) bad form by breaking out the variables and concatenating them (the dot (.) operator) rather than just using interpolation. I'm inclined to agree, but in their defence variable interpolation only works when the variable name can be distinguished from surrounding text, and to a beginner that might seem flaky. This works: my $file = "$prefix-$base-$suffix.$ext"; my $fullpath = "$dir/$file"; But this probably wouldn't do what you want: my $file = "$prefix_$base_$suffix.$ext"; ("Global symbol "$prefix_" requires explicit package name")
You can use the `${foo}` form of a variable to distinguish it from surrounding text. It's technically the symbolic dereference form, but with a bareword it is just another way to write the variable. my $file = "${prefix}_${base}_${suffix}.${ext}"; (the last two aren't necessary, just for consistency)
This is why git blame exists.
GP did not use a programmer's text editor to type his answer. Instead some software interfered and replaced the proper `"` straight quotes with `‚Äú‚Äù` typographic quotation marks and he did not notice the defect.
GP? I'm sorry I don't know what you're saying. Thanks
Oh wait, I see now. I typed it with " and it worked. Thanks! What's GP though?
grandparent
I've heard that MacOS annoyingly does this in text input boxes.
&gt; magic deck analysis Nice, I'm not the only one! I actually wrote a perl program recently to scrape magic card prices and analyze them.
Yep. WTF was wrong with the original quotation marks that we needed new unicode fancy ones? This happens all the time when people copy hostnames with hyphens from excel spreadsheets into web forms. The longdash excel loves becomes a unicode character, which invalidates hostnames. Thanks Unicode.
They are good for use in prose, and Raku code. Not so much anything else.
To help understand the mathematics underlying this perl script, please see the repository file '[COMPOUND.md](https://COMPOUND.md)'. The same result can alternatively be obtained via the gui ccrate.html, supported by javascript and css.
&gt; Is it in some way similar to how anonymous functions work? No, not really it "merges" the 2 dictionaries. &gt;&gt;&gt; x = { 'sn': 1, 'attr1': 'val1' } &gt;&gt;&gt; y = { 'sn': 1, 'attr2': 'val2' } &gt;&gt;&gt; { **x, **y } {'sn': 1, 'attr1': 'val1', 'attr2': 'val2'} So in your code there is `if l['sn']==c['sn']` This suggests there are 2 dicts with different key/values that they want to "merge" when there is a matching `sn` value. There's a full explanation of the syntax here: https://stackoverflow.com/a/26853961
For the record, this looks interesting, but the repo I am pulling down tonight is [https://github.com/NYgramps/dirtree](https://github.com/NYgramps/dirtree).
I don't trust the calculation, it uses floats (mislabelled in the documentation as real numbers).
It'd be nice to have links to this from the interesting places. Like Metacpan and perl.{org,com}
Have you tried jobs.perl.org?
Thanks. I will try it. Hoping to find one company instead of 10 individuals, but maybe the right person will see it.
Evozon in Cluj, Romania. Probably guys in the Ukraine and Poland too. Try Linkedin.
I'm not sure what your project is, but 10 man years of development in perl might not be the best investment. Sadly, perl is in decline. Languages like Python and Go and Javascript are much better supported by the current workforce, and you'll be more future proof with those languages.
Yeah, more for support on a site to buy time.
I used and quite enjoy [Statocles](http://preaction.me/statocles/) for my [blog](http://blog.wlindley.com/) and had even written a little [converter](https://github.com/lindleyw/wp2statocles) to pull the oldest bits out of (ugh) WordPress. In an ideal world, a little group of us could displace WordPress itself with Mojolicious, Mojo::Pg, and Yancy‚Ä¶ any venture capitalists out there? *grin*
&gt;Thanks
&gt;I'm not sure what your project is, but 10 man years of development in perl might not be the best investment. Language is a fickle thing. Presumably you'd agree that 10 man years of development in perl might be the best investment, right? &gt;Sadly, perl is in decline. [OpenHub](https://blog.openhub.net/about/)'s stats show ***Perl's*** ***relative*** ***share*** *among the languages used in all the projects they track has remained* ***roughly stable since 2014.*** Here are their charts comparing [C#, Go, Haskell, Perl, Rust, and Scala](https://www.openhub.net/languages/compare?utf8=%E2%9C%93&amp;measure=commits&amp;language_name%5B%5D=csharp&amp;language_name%5B%5D=golang&amp;language_name%5B%5D=perl&amp;language_name%5B%5D=haskell&amp;language_name%5B%5D=rust&amp;language_name%5B%5D=scala&amp;language_name%5B%5D=-1&amp;commit=Update) and [C, Perl, PHP and Python](https://www.openhub.net/languages/compare?utf8=%E2%9C%93&amp;measure=commits&amp;language_name%5B%5D=objective_j&amp;language_name%5B%5D=c&amp;language_name%5B%5D=perl&amp;language_name%5B%5D=php&amp;language_name%5B%5D=python&amp;language_name%5B%5D=-1&amp;commit=Update) commit activity over the last decade **for around 25 billion lines of open source code**. &gt;Languages like Python and Go and Javascript are much better supported by the current workforce, and you'll be more future proof with those languages. Unless you go bankrupt because you're stupid enough to cavalierly abandon a great language (perl) perfectly suited to your project (who knows given that we haven't heard what it is?) with a working codebase (working now is worth almost infinitely more than "let's rewrite!") all because someone ignorantly repeated the two decade old mantra "perl is in decline". I didn't downvote you because I presume you sincerely meant what you wrote. But please reflect on your lack of wisdom.
As someone with 21 years of experience writing and using Perl, I‚Äôve had difficulty finding quality Perl coders in the past 8 or so years. Finding 10 of them is a fools errand, in my opinion. No one is more disappointed in this fact than me. I love Perl. It has served me well. I believe it still stands on its own with the likes of python and go, but I just can‚Äôt convince anyone to develop with it. It‚Äôs gotten so bad that I‚Äôm routinely asked to rewrite my Perl based tools in python or nodejs so other members of the team can help support them. Expanding the training of other team members is less cost effective than having me rewrite it in a language they know.
I also like \[Statocles\]([http://preaction.me/statocles](http://preaction.me/statocles)), but recently I've been excited about the potential of \[Yancy\](http://preaction.me/yancy) with \[Yancy::Backend::Static\]([https://metacpan.org/pod/Yancy::Backend::Static](https://metacpan.org/pod/Yancy::Backend::Static)) reading Markdown files and \[Mojolicious::Command::export\]([https://metacpan.org/pod/Mojolicious::Command::export](https://metacpan.org/pod/Mojolicious::Command::export)) providing a static export. Indeed the next version of Statocles will use that stack and add a "deploy" command that does all the git repository work and a bunch of plugins to do all the other things Statocles does. This greatly simplifies Statocles and makes it easier to use \[Mojolicious templates\]([https://mojolicious.org/perldoc/Mojolicious/Guides/Rendering](https://mojolicious.org/perldoc/Mojolicious/Guides/Rendering)) to generate additional content (instead of the hacky way I'm doing it now...)
PAWS (Perl AWS) is an impressive undertaking and I'm sure glad other people are willing to create such things.
Finding 10 quality coders in any language is a problem, though. I'm at a gig that doesn't care which languages you come in knowing because we'll teach you everything. We still look at a couple hundred r√©sum√©s before even finding people to ask to an interview. But, I'm also working in a team where everyone is writing in about five different languages on most days, because that's how DevOps is.
I'll return to what you've said in this latest comment in a moment. But first I want to be clear that imo posting here in /r/perl to say Perl is in decline and suggesting to a random stranger that they don't hire Perl folk regardless of what their project is is not remotely OK. For projects tracked by OpenHub, commit activity for Haskell has been at about 25% of Perl's level of lines changed per month and Scala at about 50%, *for about 5 years*. Does that mean Haskell and Scala are in decline to the point it's appropriate to declare so in /r/haskell and /r/scala and tell random people considering hiring 3 to 5 such devs to avoid these languages? I think you'd get a very hostile response and with good reason. Dealing with anti-Perl prejudice is challenging. Recent SO stats showed that these days only 4% or so of devs are willing to mention Perl on their r√©sum√©. But even this, in combination with other stats suggesting there are about 20 million devs worldwide, means that in the order of 100K to a million devs would list Perl on their r√©sum√©. It may not be enough to go around but please think twice and twice again before repeating extreme doom and gloom stories to strangers about Perl. &gt;I‚Äôve had difficulty finding quality Perl coders in the past 8 or so years. Sharing your story is painful but helpful. Thank you for providing these details. Is the difficulty primarily a worse ratio of quality to non-quality among Perl applicants than the ratio of quality to non-quality among python and nodejs applicants or is it primarily a quantity thing? Did something in your circumstances in which you sought coders change about 8 or so years ago? Have you looked at the graphs to see if they trigger some intuition about why they show relative stabilization over about the same period you're mentioning?
I‚Äôm not trying to gainsay Perl. I love Perl. It‚Äôs the fifth language I learned and the only one I ‚Äúthink‚Äù in. In the company I work for, we use in house recruiters. Putting Perl as a requirement reduces the applicant pool to zero in most cases. And this is for a pretty big company, publicly traded, with a 100k+ salary and bonuses, awesome benefits, and great year over year profits. And in the Northern Virginia area, there are tons of companies that used Perl in the 90s, and 2000s, like AOL, so there should be people who know it. Perhaps I should revise what I said, and say Perl programmers are in decline.
[plerd](https://github.com/jmacdotorg/plerd) is pretty. converts markdown &amp; can work with dropbox
I still love ikiwiki, and choose it by default for new sites unless there‚Äôs a specific reason to choose something else. It‚Äôs static if you don‚Äôt enable the CGI. It has some dynamic features if you do. Here‚Äôs me live-coding an ikiwiki plug-in at Pittsburgh Perl Workshop some years back: https://schmonz.com/2014/11/15/pittsburgh-perl-workshop-2014-web-architecture-for-unix-lovers-with-ikiwiki/
Was not aware of PAWS, but am very interested now. Thanks for posting!
I think there's a more general point to be had, there. A language might produce tools that are incredibly powerful and those tools might go on for decades after the language is functionally dead (*vis.* FORTRAN and the long tail of its higher math libraries for scientific modeling). The existence of those tools should not be used as a metric of the health of the language.
Really blow their mind with a few lines of self-documenting, fully parameterized command-line tool: $ cat foo.p6 sub MAIN( #= Print a string a lot. Str $thing, #= The thing to print Bool :$verbose = False, #= Increase verbosity Int :$count = 10, #= Number of lines of output ) { say "Printing $count copies of {$thing.perl}" if $verbose; say $thing for ^$count; } Which does: $ perl6 foo.p6 --help Usage: foo.p6 [--verbose] [--count=&lt;Int&gt;] &lt;thing&gt; -- Print a string a lot. &lt;thing&gt; The thing to print --verbose Increase verbosity --count=&lt;Int&gt; Number of lines of output $ perl6 foo.p6 --verbose --count=2 thang Printing 2 copies of "thang" thang thang
&gt; Putting Perl as a requirement reduces the applicant pool to zero in most cases. Apart from the conclusion "there are next to no Perl applicants to be found", what reasons have the in house recruiters come up with for this problem? What have they tried that's Perl specific to understand or fix the problem? &gt; Perhaps I should revise what I said, and say Perl programmers are in decline. Would you classify yourself as a Perl programmer? If you're in decline, or if you just mean the number of folk who are like you, what do you think explains the decline?
Recruiting says its most likely that it isn‚Äôt in high enough demand to warrant space on applicant resumes. People want to put things on there that hiring managers want to employ. Additionally, Perl has slowly been phased out of default Enterprise OS images. While there are still a bunch of Perl modules in EPEL from Redhat, they aren‚Äôt well supported. I‚Äôve heard the RHEL 8 wont have it in the default kickstart. My first instinct when handed a new project is to write it in Perl unless otherwise directed, so yes, I consider myself a Perl programmer. Sadly, I‚Äôm generally asked to write it in python. In that regard, yes, my Perl skills are in decline.
I wrote a Mojolicious.io blog post about making a static site generator with Yancy: https://mojolicious.io/blog/2019/06/02/yancys-static-backend/
Business Analyst / PO here. It seems that being polyglot seems to be on the decline as a virtue among developers (I, too, consider me one, but with a specialisitation on requirements and stakeholder management). People rarely write code, say, both in C# AND TypeScript. You need a frontend specialist for the latter, they say.
Hey !! Now Check new &lt;a href="[https://www.sweepstakesnew.com](https://www.sweepstakesnew.com)"&gt;List of current online sweepstakes 2019&lt;/a&gt;
The link to "Obiective Romanos grammaticam ‚Äì Perl weekly challenge, week 10" is incorrect: it should be [https://rage.powered.ninja/2019/06/02/obiective-romanos-grammaticam.html](https://rage.powered.ninja/2019/06/02/obiective-romanos-grammaticam.html)
Python and PHP conquered the internet \*before\* they were faster than Perl 6 is now. So I think it's a fine choice in areas where it fits. No, I wouldn't write a web browser in it. :D
Thanks for information on Webster. Fascinating history indeed.
Another option of using dictionaries offline is using the StarDict console version (sdcv package in Debian/Ubuntu/LinuxMint). There is a StarDict format of the dictionary at [https://s3.amazonaws.com/jsomers/dictionary.zip](https://s3.amazonaws.com/jsomers/dictionary.zip). It's also easy to compile a plaintext to StarDict format.
An alternative approach to blog is to just use WordPress like everybody else, and: 1. generate a static site from your blog site when needed/wanted. There are WordPress plugins to do this; and/or 2. create posts from another format, like Org or Markdown. There are tools to do this, e.g. \[org2blog\]([https://github.com/org2blog/org2blog](https://github.com/org2blog/org2blog)). I myself create some CLI scripts like \[org2wp\](https://metacpan.org/pod/org2wp).
It'd be interesting to know tha nature of the project (maintenance? new project? startup? what field?).
Paws and the botocore sources that most of it is generated from are impressive feats. Above all it needs real world testing because the official AWS tests only go so far, and there's far too much for the author to test. Please [send feedback](https://github.com/pplu/aws-sdk-perl) for anything that doesn't work right!
I think this answers as to why it's sad. Even if it's the right or best language for the job it's a non-starter, yet all these 'other' languages are considered perfectly fine. And I still believe it's a better language than Python by a million times... yet python is just the de-facto for certain workloads where I'm at now. &amp;#x200B; For kicks I did a search on Perl jobs on dice. This is kind of the state that I see: *The Senior Software Engineer will be an integral part of the development team which will re-engineer parts of our application to be portable and cloud ready. This includes removing dependencies on physical servers (local file storage), NFS filesystems and perl*
This looks really cool... thanks!
Very cool. I still have some scrapers. I feel like I invented Zillow as I have a scraper decades old that parses local MLS listings... if only I had the vision.
[MIDAS](https://mid.as) is written in Perl
This. I've used Perl on a daily basis since 1997, IIRC. Since then I've worked for companies in Norway, Germany and USA who _had_ software written in Perl. All of these companies - six in total - has rewritten their software in something else than Perl, _**because it's too damn hard to find Perl developers**_. As you, I _love(d)_ Perl, but all good things must come to an end. I no longer see a future in Perl. I remember when Perl 6 was promised in 2000-or-so. It was sooooo interesting; "yeah, it'll beat the crap out of this new thing called Java"-etc-etc. I don't remember when Perl 6 was "released" (is it done yet, btw?), but it was at least 15 years later. You can't wait that long for a new version of a programming language. And, it's not a new version either, it's more like a totally new language. /u/raiph can show to statistics as much as (s)he likes, but I can't believe he has ever tried to recruit any Perl developers. I tried that in three countries over a period of four years. It was impossible. So my assumption is then that all the Perl developers don't live in these three countries (even though we tried to recruit from abroad.) I wish the Perl community all the best, I truly do, but go up to a newly graduate and tell him to work with Perl when there are so many other "main stream" options? Nah. Won't happen.
You need to look at [_this_](https://www.openhub.net/languages/compare?utf8=%E2%9C%93&amp;measure=commits&amp;language_name%5B%5D=perl&amp;language_name%5B%5D=-1&amp;language_name%5B%5D=-1&amp;commit=Update) graph, and [_this_](https://www.openhub.net/languages/compare?language_name%5B%5D=perl&amp;language_name%5B%5D=-1&amp;language_name%5B%5D=-1&amp;measure=contributors) graph; the latter showing monthly _contributors_. As you can see, the number of contributors is in a sharp decline. This means that there are less Perl developers out, or at least less people contributing to Perl code. This, in turn, means that companies can't risk having software made in a programming language that requires non-existent people to maintain. I wish it was different, but this is the reality.
Hello, perl noob here. I've literally just picked it up at work because it was available and I'm kind of falling in love with it. HOWEVER I have no idea what the difference between Perl's 5 and 6 are other than from my lurking that they are very different and that the change is controversial. Is there a good video guide or similar that could bring me up to speed?
&gt; But the language itself isn't disappearing. That is true. &gt; Nobody is prevented from producing new software in Perl [...] That's also true, but it's not real life reality. No _individual_ is prevented from producing new software in Perl, of course, but _companies_ are prevented from doing the same because the dimishing number of people who use Perl.
&gt; Every time I hear "Perl is dead!" it's some guy [...] Every time I say (and have said) "Perl is NOT dead!", there are guys _and_ gals asking me what Perl is. Kind of sad, as I've been using Perl since 1997-ish, but that's reality.
there's probably enough Python code out there that it becomes another "Perl 5" and lives for ages..
by 2020 employers will be tired of Python-trained programmers who cannot learn anything else because they don't grok blocks and scope and Python will become the next Pascal. Perl is competing with Go, Rust, Java, D, OCaml, F#, C#, Kotlin etc., not with Python, and no language will become as popular as Perl 5 was in 1999, all will be minorities in an ever growing pool of DSLs.
that's a good attempt at trolling :) By now it's clear that Python2/Python3 and Perl5/Rakudo Perl6 are *not comparable*. * Python 3 is just a bunch of backwards-incompatible changes to remove cruft. The difference is so minimal that (with some effort) it's perfectly possible to write programs that run under both versions. That's how the Python ecosystem managed to *transition* to Python 3. * Rakudo Perl6 is a fundamental redesign of the ‚ÄúPerl‚Äù concept. That brought some seriously cool features like MOP or grammars. That also means it's a completely separate language from Perl5. There is very little ecosystem overlap. I just think there is more than one way to do Perl. No need to transition to the new shiny, no need to kill of one variant. Rakudo will never *replace* Perl5, it's sufficiently awesome as a standalone language. Please stop treating it as a successor.
Perl 5 is Perl. Perl 6 is a different language that has some of the same flavor and, unfortunately, most of the same name. Rakudo is an implementation of the Perl 6 language specification.
Cool thanks. I'll look up rakudo.
And why it has aliases such as `git slap` :-)
vendors are committing to support Python 2 to at least 2026. Someone should also tell the Python folks that their NumPy package is built on mostly Fortran-77 code. only users can make a language popular again
It is a different language. You might as well be telling most Perl programmers that the language should be replaced by JS (which is actually more accurate to current reality).
Python 2 will be around forever. It should be obvious that a large part of the Python community has absolutely no intentions on moving to Python 3.
Better idea, don't emulate the fascist Python community.
I think its more apt to say that Perl 6 is to Perl 5 what VB.net is to VB 6.
VB 6 became legacy and unsupported as VB.net was a clear successor, so not quite. If you want to make that analogy, C and C++ (or C#) are a better fit.
Well I meant more about the languages themselves, not their lifecycle.
&gt; To make Perl popular again. I think you're sorely mistaken if you believe that renaming the language will make Perl popular again.
&gt; To make Perl popular again. It will take far more than a renaming to make Perl 5 popular again, and to make Perl 6 popular in the first place.
Floral ecommerce site. We just acquired the company from another and are only getting minimal support so we need to build up the Perl developer team at least for the short term. Probably just maintenance, but i'm not fully up to speed on any issues they may have. I was hoping to find a company that we could contract it out to but stay very involved in meantime.
Maybe [https://allaroundtheworld.fr/](https://allaroundtheworld.fr/)?
I just did [a google](https://www.google.com/search?tbs=cdr%3A1%2Ccd_min%3A2017&amp;q="sponsors"+yapc+tpf+"perl"+workshop) that catches consultancies and recruitment companies that have sponsored Perl conferences. Companies like Eligo, Evozon, ShadowCat, AllAroundTheWorld, PerlCareers, etc. Contact those folk and I imagine they'll either be able to help you out or forward you to those who can.
IMO Perl 6 contributed significantly to the last decade's perl marketing disaster. Most people think Perl 6 is intended to supersede Perl 5, and thus Perl 5 is obsolete, and Perl 6 has zero market share. Ergo Perl is dead. There is a lot I like about Perl 6, but it's not backwards compatible (Python 3 isn't either, but far moreso than Perl 6). They really should have named "Perl 6" something else entirely. Maybe if they'd called it "Python 3" instead of "Perl 6" we'd be in a much different world today.
I sent a message to you yesterday.
**[Artificial Intelligence](http://ai.neocities.org/AskUser.html)** will make **[Perl](http://strawberryperl.com)** popular again.
Although Inline::Perl5 does provide a reasonable path for transition, for those who wish to. One thing Perl has always been good at is working with other languages, especially it turns out languages from the same family. I have a lovely Perl 5/6 hybrid in production, it works a lot better than people give it credit for.
That is percentage data. perl is having a smaller share in a ever growing world. I wonder if there is data for absolute number.
those guys and gals: can they program in something else besides Python or Javascript ? :)
Good idea, thanks!
Perl 6 is a non starter. It was stillborn. The people behind it made two critical mistakes: 1. They spent WAY too much time jacking around with theoreticals when designing the underlying virtual machine. They should have concentrated on getting a usable language in the hands of developers quickly. 2. They wanted to address all of the shortcomings of perl as a language and decided to completely forego backwards compatibility as a means to this end. This is in and of itself OK, but they assumed that naming their new language "perl 6" would give it instant traction. They were wrong. Since it wasn't perl, perl programmers by and large want nothing to do with it, and by the time it was actually usable, "perl" had long been a legacy language and as such, non-perl programmers want nothing to do with it. IMHO, two things need to happen: 1. There needs to be a new perl. A real perl. Perl 5.5, or perl 5++, or perl 5#, or whatever you want to call it. It needs to address the shortcomings of perl 5 (built in threads and thread safety, better object syntax, etc) while being as backward compatible as possible. 2. Everyone needs to forget that Rakudo was ever associated with perl. At this point, the perl association does nothing but hurt Rakudo. If Rakudo is positioned as a new, modern language, it has a much better chance of gaining followers. Actually, there is a good window of time for Rakudo to pick up market share. Java and Python are becoming legacy languages. The Python community is split between Python 2 and Python 3. The Python users are frequently at odds with the maintainers. The current darlings of the development world seems to be go and powershell. Go, being compiled, will never be as nimble as an interpreted language. Powershell is a reasonable, powerful language, and is building a vast amount of public domain libraries. But it will always be associated with Microsoft, and as such, many developers not use it. There is a window for a new, open-source language to sneak in and win hearts. I don't know if Rakudo can do that, but one thing is for sure - it certainly can't if it keeps the perl association.
Everything you said is right, but I don't think it addresses OP. OP is saying, and they're not alone, though I think it's still a minority view, that the perception that "perl code" means "Perl 5 code" by the general public is harming adoption of Perl 6, and without that adoption Perl as a language family is doomed, so we should make the transition explicit and non-optional (much in the way Python is doing, e.g. by having Perl 5 announce its own deprecation, at least when used interactively and maybe in subsequent versions, always). I'm of two minds, here. I think that Perl 5 definitely has seen its day and deserves a graceful sunset. But I also feel as if the instant Perl 5 is deprecated, many distros will simply migrate off of it to Python for whatever remains in Perl and never default-install Perl 6. This is a serious problem and I don't see a good answer. Perl 5 is boat-anchoring Perl 6 in the programming culture. No one talks about Perl 6 in terms of Perl 6, they talk about it in terms of Perl 5. Go suggest a project should use Perl 6 on /r/programming and all you get is "line noise lol". No one talks about infinitely lazy arrays. No one talks about lexical variables as formal parameters (e.g. `foo(:$thing)`). No one talks about grammars as an extension of the class. They talk about how ugly Perl is and how primitive it is.
&gt; By now it's clear that Python2/Python3 and Perl5/Rakudo Perl6 are not comparable. That's not true in terms of the perception, though, and I think OP is talking about the perception, not the language details. &gt; Python 3 is just a bunch of backwards-incompatible changes to remove cruft. As someone who works professionally in Python 2 and 3 these days, I can definitely put this one to rest. Python 3 is a huge step for Python. It's not as huge as the Perl 5-&gt;6 gap, but it's not just a bunch of cruft removal. Again, in terms of what the average user does, sure, it's cleanup. But the low-level data handling, type system, extensibility system and uniformity of the grammar have all been drastically improved (well... I think the data handling is only a theoretical improvement and a practical detriment, but it's still a huge change). &gt; No need to transition to the new shiny So, what happens to the Perl community when the new shiny doesn't gain critical mass (as it's not now) and the old dusty begins to be deprecated off of most platforms (as is happening right now)? What happens when there are more COBOL programmers world-wide than Perl programmers (at a guess, circa 2030)? Perl 6 is the only thing that's going to bring users of the language back in sufficient numbers, and that requires removing the stigma of Perl 5. "Perl 6 ***is the latest Perl***" is the message that's going to eradicate that stigma. We all know the caveats and specifics, there, but what is the message to the non-Perl guy that gets them to overcome the stigma and come back... "Perl 6 is a cool language, but that thing you think of as a downgrade on line noise is its peer"? Good luck with that marketing.
That's nice, but not really relevant to Perl 5, which is not being retired in the foreseeable future.
&gt; Perl 6 is the only thing that's going to bring users of the language back in sufficient numbers, and that requires removing the stigma of Perl 5 That's not bringing people back to the language, though: it's bringing them to a new language which shares some syntactical and developer history with Perl5. To use an analogy from another comment, it's like teaching people C# and claiming you've brought them back to C. There are other ways to expand the Perl5 community, such as: more visibility, applications written using Perl5, feature parity with the direction other languages are going - https://metacpan.org/pod/Future::AsyncAwait is my current favourite example there. Huge new features or a rewrite of the core to advance the technology to the next level would be nice, but not the only way to persuade a few people to give it a try and maybe find it useful enough to stick with it. The stigma of perl is overrated, IMHO - you think any of the next generation of developers have ever even heard of "perl" before? =)
A lovely little tool!
Thank you. :)
Enter is `"\r"` not `"\n"` or `"/n"`.
My personal preference these days is just use v5.14; It gives me strict, it gives me say, it's shorter.
 use Mojo::Base -strict; https://mojolicious.org/perldoc/Mojo/Base
I like [strictures](http://p3rl.org/strictures) best.
My editor inserts use warnings; use strict; into any new empty Perl file I open. `common::sense` is too opinionated, `Modern::Perl` is not explicit enough. I hate the situation I can't run a script written by someone because it states `use v5.28` only to discover later it's because `use feature 'say'` which works pretty well in my 5.18.
Using strict and warnings is the only thing we can get almost everyone to agree on. common::sense which disables uninitialized warnings - certainly an opinionated choice. I generally use strict and warnings directly, or for Mojo projects, Mojo::Base enables a nice set of unopinionated features listed in its docs.
&gt; That's not bringing people back to the language It's bringing them back to the Perl community and the Perl language family. Do we really need to be so pedantic, here? &gt; To use an analogy from another comment, it's like teaching people C# and claiming you've brought them back to C. Except C# wasn't developed by K&amp;R... &gt; There are other ways to expand the Perl5 community There are not. I'm sorry. I love Perl and have since the early 1990s. It's a great language to have started my career on, but there is so much hate out there for the language that unless it comes up with a way to prove everything that's said about it wrong while at the same time retaining its nature, it will die. We could even argue that that's really already happened, it's just in the long tail of curiosity status at this point. &gt; feature parity with the direction other languages are going Grabbing features from other languages doesn't solve any of Perl's problems. &gt; The stigma of perl is overrated, IMHO - you think any of the next generation of developers have ever even heard of "perl" before? =) Yes. I work with a bunch of recent grads. They all use "Perl" the way I used "COBOL" when I started off. I'd never really learned or worked with COBOL, but I knew enough to poke fun at it for being what only old semi-programming-literate business types wrote code in. I was wrong, of course. There were very good programmers who wrote very important code in COBOL, but that wasn't part of the cultural narrative that, today, Perl is caught up in.
I find `common::sense` to be annoying because in my opinion the author's opinion is wrong. And I think calling it `common::sense` is needless namespace pollution. `Modern::Perl` isn't as offensive from that perspective, but it's not a core module and there better be a darn good reason for using non-core modules. I don't think saving a few lines of code is a good enough reason. But that's just, like, my opinion, man.
Thanks. Yeah the forward slashes were typos only in my post but not actually in my script.
For the most part I just use the version I'm deploying and warnings, and if I can, signatures and postfix-deref: &amp;#x200B; \`\`\`perl use v5.30; use warnings; use experimental qw( signatures postderef ); \`\`\`
And Go *performs much better than C# -* [https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8](https://hackernoon.com/go-vs-net-core-in-terms-of-http-performance-7535a61b67b8)
**[Perl](http://strawberryperl.com) is fast enough for **[artificial intelligence](https://ai.neocities.org/perlmind.txt)**
Yeah there's a massive difference here that the perl version is a simple raw tcp server that only reads the first header, whereas the go http server reads all the headers and implents the full http spec. Not exactly apples to apples. I'd like to see it compare to a tcp version in go
To anyone reading this, this person is also known as /u/mentifex and /u/ArthurTMurray. [Please don't waste your time with him](https://www.nothingisreal.com/mentifex_faq.html#x1-20001). I would try to be more gentle, but this man has been posting this stuff since the 90s. He's mad as a hatter and no one has ever been able to make him stop. Thus, I'm being blunt so you don't get sucked down this rabbit hole without fully understanding what's going on. And my apologies for such a brutal post.
[techempower benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&amp;hw=ph&amp;test=json&amp;l=ziiz25-1) for C#, Go, Perl
\&gt; Before he had regular access to the Internet, Murray used the US postal system to spread his ideas by mass-mailing prominent AI researchers, computing authors, and sometimes even entire university departments. He boasts that he mailed seven thousand letters in 1989 alone I'll award a few points for grit.
"Who says Perl is slower than compiled language?" Everyone who has basic knowledge of how perl internals work. You can even use XS native code library that will boost performance, but go/c#, even js will always be faster when optimized(you can use native code libraries in those languages as well).
At $work we expand the Perl5 community by hiring developers and teaching them Perl 5. Works pretty well for us. We also don't feel the need to prove everyone wrong - except perhaps by continuing to use the language and getting good results from doing so. Perl6 is a different language, different community - and has zero relevance to us. It'd likely take just as much work to cross-train someone from a Perl6 background as ES6/Python/Rust, so we don't specifically look for Perl6 developers, although we wouldn't turn them away. Also, if other languages have features that Perl lacks, and that causes development to be significantly slower or harder, then that's very much a problem - and at that point I would start moving to a different language. As it is, Perl works very well for our domain, and we have no current plans to replace it. I'm sure there are other companies in a similar position.
Very cool!
Please don't use DBD::mysql for any new projects; use the DBD::MariaDB fork, which despite the name supports both MySQL and MariaDB, but fixes several fundamental issues, of which the unicode problems [can't be fixed for backcompat reasons](https://github.com/perl5-dbi/DBD-mysql/issues/197).
brew install perl
Also: apple sucks.
That's fine, I deprecated Apple a long time ago.
Are you insinuating that Perl developers are superior to other developers?
That‚Äôs stupid, I can think of so many scripts I‚Äôve written to do XYZ that I‚Äôve passed around that won‚Äôt work now, since most of these people don‚Äôt have sudo access to install brew.
Homebrew isn't the only way to get perl. Recognizing the obvious potential for confusion because of the similar name, Perlbrew is specifically designed to work without the need for superuser access. I don't really have a problem with this decision; if the underlying operating system does not require a tool, then there isn't any need to ship it. Trying to manage the various conflicts between "system perl" and a local copy is enough of a pain in the ass as it is. The same goes for python or ruby or shells.
I suppose that‚Äôs fair, just there are quite a few tools I‚Äôve written that don‚Äôt require the latest and greatest and also didn‚Äôt require additional libs, so it worked fine. This is just more of a reason to write new tools in languages that can create statically linked binaries.
Thanks for replying. &gt;Recruiting says its most likely that it isn‚Äôt in high enough demand to warrant space on applicant resumes. People want to put things on there that hiring managers want to employ. If I'm understanding you correctly, that's kafkaesque. Recruiting knows that applicants put things on their resume that hiring managers want to employ. But Recruiting fail to mention they want Perl devs. So applicants don't put it on their resume. Then Recruiting says there are no qualified applicants... &gt;While there are still a bunch of Perl modules in EPEL from Redhat, they aren‚Äôt well supported. I accept that one has to deal with RH's decisions regardless of whether they're good ones technically or open source stewardship/governance wise, but, to be clear, the Perl community generally does a great job of supporting the Perl ecosystem. &gt;My first instinct when handed a new project is to write it in Perl unless otherwise directed, so yes, I consider myself a Perl programmer. Sadly, I‚Äôm generally asked to write it in python. In that regard, yes, my Perl skills are in decline. Right. Hmm. What Enterprise Perl Support companies/associations/networks etc. do you know of? ActiveState obviously, but which others are you aware of?
Yeah, this title is hyperbole, it simply states they won't be included by default, but can be installed manually. I typically prefer my OS to be minimal and let me install what I want/need now what they think I need
You cant build anything with C either until you install XCode, most likely they will just push everything into the CLI tools bundle you can get separate to the IDE. The current experience for that is if you attempt to use those tools in the terminal it will prompt a graphical flow to download and install the extensions. At least this would be my hope/expectation for what the deprecation means.
Is something like the [PAR Packager](https://metacpan.org/pod/pp) no good to you?
&gt; I don't remember when Perl 6 was "released" (is it done yet, btw?) No language is done. The second major version of P6 was released last year. &gt;You can't wait that long for a new version of a programming language. P5 has had yearly releases for about a decade. As for P6, you certainly can wait that long. Haskell took 10 years just to get to Haskell 98 and another 10 to gain a toehold. What turned into Python 3 was started in 2000. &gt;And, it's not a new version either, it's more like a totally new language. If you're talking about P6 again, the first official compiler was released in 2016. The second major release followed in 2018. &gt;/u/raiph can show to statistics as much as (s)he likes, but I can't believe he has ever tried to recruit any Perl developers. I tried that in three countries over a period of four years. It was impossible. You're right that I never tried. I can't believe your companies ever tried to recruit at a Perl meetup, physical or virtual, or workshop or conference. Why not? These have always been the heart of the Perl community. Why weren't your companies there? &gt;So my assumption is then that all the Perl developers don't live in these three countries (even though we tried to recruit from abroad.) My assumption is your companies did not go to where Perl developers congregate. &gt;I wish the Perl community all the best, I truly do, but go up to a newly graduate and tell him to work with Perl when there are so many other "main stream" options? Nah. Won't happen. Imo that's really an entirely different issue.
&gt;As you can see, the number of contributors is in a sharp decline. The graph shows about a 10% a year drop in count of *all* contributors *as a percentage relative to all other programming languages*. If the number of all contributors to all open source projects is increasing at 5% a year then Perl's contributor stats show an absolute decline of about 5% per year. If the overall growth is 15% per year then it's an absolute increase of about 5% a year. Due to the long tail effect, one line changes will be the lion's share of commits, and it'll thus be the growth in these tiny commits that will drive the overall growth in contributor counts. In this age of Udemy and GH pull requests what's your estimate of the yearly growth of those contributing a single line change to open source projects? Do you think Perl garners more of these one line changes or less than other languages, or about the same? Over the last 6 years, the stats for the *relative* percentage of *lines of code* change has been stable, suggesting a constant *increase* in absolute lines of code changed, which may be due to an *increase* in absolute numbers of *significant* (more than one line of code) commiters. Indeed, Perl shows *growth* in its projects-with-monthly-activity relative to PHP and Ruby. So while the count of contributors of one line commits is an important statistic that proxy's how "hip" a language is, I do not consider it to necessarily be relevant to someone seeking to hire experienced devs to work on an existing codebase, which is the context of this exchange.
I never "precated" them in the first place. Apple has always sucked balls.
no, I am not insinuating anything I am firmly stating that practical experience only one language or only one programming paradigm are the root of all evil and these days Python and Javascript are the most likely to be the first languages one learns.
what are "Apple" and "MacOS" ?
Check out the sort built in. I‚Äôm on my phone but something along these lines: my @lines = split /\n/, $text; my @sorted_lines = sort @lines; my $sorted_text = join ‚Äú\n‚Äù, @sorted_lines; These operations can be combined into one line by skipping the intermediate assignments.
 #!/usr/bin/perl use strict; my $file = "./sigs.txt"; open my $in, "&lt;:encoding(utf8)", $file or die "$file: $!"; my @lines = &lt;$in&gt;; close $in; chomp @lines; my @sorted = sort @lines; my $names = join "\n", @sorted; print STDERR $names; # This is where you would write them back out.
I'm using Windows 10 :-)
1) Please learn to format code before posting to any programming subreddit. &amp;#x200B; Here's your script formatted: &amp;#x200B; my $text = read\_file("myFile.txt"); my $textSorted = \`cat $text | sort\`; print "\\n\[INFO\] Sorting Signature Files...\\n"; my @txtFiles = \`ls \*..txt\`; my $out; my $sortedTxt; foreach my $txtFile (@txtFiles) { open $out, '&gt;', $txtFile or die "Can't write new file: $!"; #creates new file to write $sortedTxt = \`cat "$txtFile " | sort\`; print $out $sortedTxt; } print "\[COMPLETE\] Sorted.\\n"; The way you're doing it isn't really based in perl. It might as well be a shell script. Here's how to do it in a shell script: [https://geek-university.com/linux/sort-lines-of-a-text-file/](https://geek-university.com/linux/sort-lines-of-a-text-file/) so it looks like your $sortedTxt = \`cat "$txtFile " | sort\`; should just be something like $sortedTxt = \`sort "$txtFile"\`;
The rule, "All real O/S come with Perl installed" continues to be true.
If my google alerts don't mislead me Perl is growing nicely in India, China, Russia and Germany while Python is almost always like "we need people who know Python/PHP/Ruby". I can testify to growth in Romania, based on the pressure the HR people are putting on me to recruit people from the places I worked before. I mean, from one side I'm getting the vibe that "keep your head down and be content you have a job because Perl is dying", and from another side I'm getting "If you could just go ahead and do our job and headhunt from where you worked before, that would be great".
PHP conquered the internet because it was very easy to deploy. Python only conquered the CompSci 101 courses and the sites where you can get your homework done for little money if not free.
Ubuntu for me.
Oh man, you must've not been around in the early 80s. The Apple was pretty cool. I coveted the II GS.
So?
&gt; So while the count of contributors of one line commits is an important statistic that proxy's how "hip" a language is, I do not consider it to necessarily be relevant to someone seeking to hire experienced devs to work on an existing codebase, which is the context of this exchange. Really? Are you _that_ ignorant? Don't you understand that the decline in Perl "attributions in general" also leads to lack of people who _knows_ Perl? Or, more importantly: people who _learns_ Perl? I'm sure that there are 10 or more experienced Perl developers out there, as it is 10 or more experienced Cobol developers. You do the math.
The perlbrew installer is written in bash, which is why the above fails. However, once installed I'm pretty sure it should be possible to use perlbrew from zsh.
&gt;&gt; I don't remember when Perl 6 was "released" (is it done yet, btw?) &gt; No language is done [...] That is _very_ true, and I apologise for that. What I meant was rather: when is Perl 6 supposed to take over from Perl 5? It's an impossible question, because it won't happen. They are two different language. Either way, P6 is outdated, IMO. &gt; I can't believe your companies ever tried to recruit at a Perl meetup, physical or virtual, or workshop or conference. Why not? These have always been the heart of the Perl community. Why weren't your companies there? Before I answer that question: can _you_ tell me where in the world Perl is being taught as the #1 language? Maybe I want to move there. ;) &gt; My assumption is your companies did not go to where Perl developers congregate. It doesn't matter as long as the Perl developers doesn't exist!
the next version of macos will switch the default shell from bash to zsh and not come with perl installed, so this will probably affect more people soon.
Oh... gotya.
Interesting that there is no C# under IIS even in that list. Anyone knows why not a single Windows based web server on that list?
There is a [follow up post](https://dev.to/suntong/simple-web-server-in-perl-and-go-revisit-5d82) now, just for this very reason...
&gt; when is Perl 6 supposed to take over from Perl 5? Supposed is an interesting word. What is it supposed to mean? Nothing is "officially" supposed about their respective positions. They are two distinct languages in the Perl family. P5 continues to do its own thing, whatever you think. P6 too, building upon P5's existing ecosystem and culture and occasionally contributing too. The two languages get along like sibling languages can be expected to get along. As Larry said in 2000: "Many commercial interests will guarantee that Perl 5 continues to be well-maintained and stabilized". And so it is. Of course, he supposed things would pan out differently in other regards, but that's supposition for you. It might help to compare this with the "official" Python position which is to have an official EOL for Python 2 at the end of this year. There are pros and cons to both the Python stance and the Perl stance. But Perl's is that both Perls live on as long as anyone wants to work on them. If, rather, by "supposed" you mean what individuals have supposed, well, there are millions of those, and I don't suppose I know a millionth of the variations. But I think many nowadays suppose something consistent with the "official" view. &gt; It's an impossible question, because it won't happen. I think the realm of what is supposed and the realm of what actually happens are almost entirely distinct, and one can never know what overlaps there will be as time rolls on. A few years ago Larry Wall said he supposes that more P6 code might be being written than P5 code in around "40 years". I'm not as sure as you are that he'll turn out to be wrong. Of course, that might be because 10 lines of P6 code get written in 2055 and 9 lines of P5. Who knows? I know I'll love P6 coding till the day I die, and will also cheer on those who love P5 coding till the day I die. &gt; They are two different language. Yes. &gt; Either way, P6 is outdated, IMO. I'm curious to hear about the basis of your opinion. In mine, it's ahead of its time. For example, Apple have strategically adopted the Unicode notion of what a character is. Their take on things is that this matters. Of course, Apply may have made the wrong bet. But what if they are right? Do you think Unicode matters? If so, alongside Apple's Swift, P6 is one of the most forward thinking languages in existence as it relates to text. As another example, these days a lot of devices have multiple cores. Many older languages have weak language design elements in relation to this hardware reality. In contrast, P6 has a forward thinking design. Perhaps you think multicore isn't that important, and if that is so, perhaps you are right. But if it matters that hardware is more and more multicore, then P6 has a forward thinking design that is maturing nicely. &gt;&gt; I can't believe your companies ever tried to recruit at a Perl meetup, physical or virtual, or workshop or conference. Why not? These have always been the heart of the Perl community. Why weren't your companies there? &gt; &gt; Before I answer that question: can you tell me where in the world Perl is being taught as the #1 language? Maybe I want to move there. ;) I'm not following. What does the principle of going to where Perl folk congregate to hire Perl folk have to do with it being taught as the #1 language, whatever that means, anywhere in the world? &gt;&gt; My assumption is your companies did not go to where Perl developers congregate. &gt; &gt; It doesn't matter as long as the Perl developers doesn't exist! I went to Glasgow last fall. Hundreds of Brits and other Europeans in one building. Perl meetups happen year round world wide. Some meetups in asia have thousands. You might think they don't exist but I had a wonderful few days connecting with smart, capable Perl devs.
&gt; Don't you understand that the decline in Perl "attributions in general" What decline? The US population is growing, but is in decline as a percentage of the global population. Are you calling that a decline? &gt; lack of people who knows Perl? StackOverflow's most recent stats shows 4% of devs choosing to list Perl on their resumes despite global peer pressure to leave Perl off their resumes. Assuming widely accepted estimates of 20m devs worldwide that can reasonably be take to suggest around a million devs. How is that a lack? How would even a tenth of that be a lack? &gt; Or, more importantly: people who learns Perl? Imo that's the #1 issue. And that's where P6 comes back into view when considering Perl's future. As Larry said in 2000: &gt; It is our belief that if Perl culture is designed right, Perl will be able to evolve into the language we need 20 years from now. It‚Äôs also our belief that only a radical rethinking of both the Perl language and its implementation can energize the community in the long run. P6 is a radical rethink. You say you think it's outdated. I've no idea on what basis you think that, but my guess is it's because you don't know P6. Because if you did, you would pick some other complaint, given that P6's biggest current problem is that it's ahead of its time.
I can't recall the name of it, but I'm fairly certain that if you look through the archives of the Perl Weekly newsletter you'll probably find some gems.
Having learned back in the days when actual books were still a thing, I recommend "Perl and CGI for the World Wide Web" (Peachpit Press) I also had a book that is apparently now available online: https://learn.perl.org/
I was around. You probably wanted the II GS because that was their first 16-bit model, created in 1986. Everyone else has 16-bit chips in 1978 Apple was pretty much the last one out of the gate for every major hardware paradigm shift. They were also last for multi-tasking. Every time they would play catch-up, they claimed to have invented something that was a decade old already and then just marketed the hell out of it to rich suckers and fools who were bad with money. As a successful business strategy, it is unparalleled because there is no shortage of suckers and fools in the world.
Oh, I liked the Apple before the II GS. They had good software, were hackable, and not terribly expensive. The //e was as fast, in practice if not raw hz, as the XT of the time. They used to be good machines at a reasonable price. Now the best I hear about them is that they have good quality at a high price, with an ecosystem lock in
https://www.reddit.com/r/perl/comments/bxpud9/who_says_perl_is_slower_than_compiled_language/
This is a nonsensical comparison. The Perl code does little more than read the first line of the HTTP request. It does not handle malformed or invalid requests correctly. The Go code, presumably, does HTTP properly.
There are a few projects out there called "Learn X the Hard Way" (for ex, http://www.greenteapress.com/perl/perl.pdf ) that really aren't that hard. It really isn't for beginners/novices though. You're expected to know another language already (of course, that's true for learning almost any language).
https://metacpan.org/pod/File::Find::Rule https://perldoc.perl.org/5.30.0/functions/sort.html
Has anyone done this? Is it as simple as pointing some perlbrew file at my \~/.zshrc ?
This sounds like a bad recommendation. CGI is no longer a best practice in web development.
For a start, Please see: https://www.reddit.com/r/perl/comments/aembaz/perl_module_development_from_the_ground_with_step/
What can I say? https://www.perl.com/article/an-open-letter-to-the-perl-community/
I want to make clear by posting this, I have no hard feelings if perldoc.pl is not used as the official Perl documentation site. I (along with everyone I had conversations with about it, despite multiple attempts at contact) was only vaguely aware that there was a project somewhere to refresh perldoc.perl.org until a few days ago when I learned of the beta instance of the refresh by OpusVL. JJ and those at OpusVL assigned to this refresh additionally were apparently not aware of the existence of perldoc.pl until a few days ago. I had a discussion with one of the implementers of the refresh and we will be happy to share ideas, and they are looking for feedback at [the new repository](https://github.com/OpusVL/perldoc.perl.org/issues). While perldoc.pl's search implementation cannot be used for the current vision of perldoc.perl.org due to the hard requirement for static HTML export, they are to my understanding looking to implement a rudimentary search as the site previously had. Though I personally believe perldoc.pl is more useful as web documentation due to this, I am grateful at least that the "official Perl documentation" is no longer showing a two year old version of Perl.
https://github.com/OpusVL/perldoc.perl.org-engine/issues/2
Why are the subheaders seem like they are 2px smaller than the header preceding it? Is that a bootstrap thing? When I was reading perldelta it was like everything ran together and there was no easy way to tell when it was a new section while scrolling. I like the layout of the page and menus - I just hope they clean up the text formatting a little to make it clearer what is what.
I actually like the *central* idea of "common::sense" a lot-- and far be it from me to bitch about someone else's silly jokes-- the trouble is the secondary idea: yes, 'uninitialized' warnings are more often just annoyances, so silencing them by default might be good policy. The trouble is that it turns all other warnings into fatal errors, and the list of warnings is *not* fixed, the perl-porters reserve the right to create new ones. So your production code can break on perl-upgrade, which is Not Good. At the very least, develop with common::sense if you want, but delete it before you ship.
The perl code I write myself is originally created from my own templates, so at present I just do a: use 5.10.0; use strict; use warnings; (Along with a big block of "use" lines for modules I seem to use all the time.) Adding another cpan dependency for Modern::Perl isn't worth saving a few lines for me, because I don't ever type them myself.
Somebody messed up. Due to the CSS I see the title on the site as follows: &gt;Welcome to &gt;Perldoc - the &gt;official &gt;Perl 5.30.0 &gt;documentati &gt;on site
This section in the [Perl 6 Wiki](https://en.wikibooks.org/wiki/Perl_6_Programming/Perl_History) gives a good overview. The tl;dr version is that Perl 6 was considered as a redesign of Perl (meaning, Perl 1-5) and a probable replacement for it. However, during the process, Perl 6 ended up being a total different language to Perl 5 along with the fact that it took roughly 15 years for its [first stable release](https://docs.perl6.org/language/faq#When_was_Perl_6_released?). To make sense of this, I think it's better if you think of both Perl 5 and Perl 6 as languages that belong to the same Perl family of programming languages. Although they're undeniable different, they share the same Perl philosophy. Fast forward to now, Perl 5 and Perl 6 (also known as **Raku**) are two programming languages with their respective communities which work to make them better languages. As /u/drzowie points out, Perl is Perl 5. I know the thing with the same names (which is why [Larry Wall created the Raku alias for Perl 6](https://github.com/perl6/roast/blob/master/docs/announce/6.d.md)) might be confusing at first but one's get over it quite quickly. As stated in the [Raku's Wikipedia page](https://en.wikipedia.org/wiki/Perl_6), there have been several implementation of the language throughout the years but nowadays only [Rakudo](http://rakudo.org/) is in active development. If you have more questions about [Raku](https://docs.perl6.org/language/faq), this FAQ might have some answers to them.
I use zsh and I always install perlbrew on a new machine just following the directions on perlbrew.pl. Notably: ``` \curl -L https://install.perlbrew.pl | bash ``` As you can see, that uses bash since the installer is written using bash. Then I put `source ${HOME}/perl5/perlbrew/etc/bashrc` in my `~/.zshenv`, which is what the message I get after running the above command usually tells me to do.
I thought about doing this, but I didn't see that message after the install. Also, even though I am a heavy zsh user, I do not currently have a \~/.zshenv file, only \~/.zhistory, \~/.zsh\_history, and of course \~/.zshrc. Should I simply create a one-line \~/.zshenv just to source perlbrew?
Honestly, I would just try it out and see :). I didn't have a \`\~/.zshenv\` the first time either. Now I think all of the machines I did this on have that and a few other env vars set there as well. I think for zsh that is the most appropriate file for perlbrew. Someone else might be able to correct me if they are zsh power users.
Perl 6 is my favorite language but I don't have a particular dislike of PHP, Python, or Perl 5. Everything has their quirks and annoyances. You are willfully misrepresenting how much Python gets used in real projects. Meson, Ansible, Saltstack, DNF (replacement for YUM, which uses Perl 5), TensorFlow, Blender, Ceph, Django, and almost all of the long list of subprojects in OpenStack. Perl is a fine language and I'm not happy that it gets so little use these days. But it's a lie to say Python is just an academic toy.
I thought CPAN was out and METACPAN was in? Yet the link to CPAN goes to the old version?
CPAN still exists. MetaCPAN has now completely replaced the old CPAN search engine.
The old search was not CPAN. CPAN is the set of mirrors that you download perl modules from, it is still visible as always at https://www.cpan.org/. MetaCPAN is just a new search engine for it, the old one was search.cpan.org.
It is interesting that JavaScript used the `/u` flag to solve a somewhat similar but different issue from Perl's.
Thank you! To answer the originally posed question: I made Plerd because I wanted a weblog with "no interface": You publish articles by adding them to a directory, and update them by editing the text. No web-based interface at all. It still does that! Over the last year or so, I've started to drive Plerd, for good or ill, in the direction of IndieWeb, baking in support for Microformats and Webmentions. This is all still quite experimental, but it's very exciting. (If you are me.) I smell the future of the open web wafting from this direction, and I want Plerd to serve as an exemplar. It ain't there yet, but I'm working on it. I hope to complete a proper Plerd Book this year. In the meantime, I invite folks to visit http://plerd.jmac.org!
Without rancor, hopefully as advice: The OpusVL site is pretty and these days, "pretty" does count. Good work. But until I can type "perlre" on page 1 and get to the perlre page, I have to stick to [perldoc.pl](https://perldoc.pl). I would concentrate on "search" as the main thing needed for the OpusVL work.
They didn't just update the documentation to a newer version, they completely redesigned the site? New layout looks horrible compared to the old one. Wonder if existing links to specific functions etc. broke...
My only interaction with Python programmers was of the sort "Perl 5 is dead, get on with the program". Also was caught into a rewrite from Perl 5 to Python, then back to Perl 5 because Python was too slow even compared to the 1990s uber-oop-ized inheritance-all-the-way-down Perl 5 framework used originally. I can agree that I tend to be less than graceful when it comes to Python fanboys but I never said it is an academic toy, only that it is preferred only by people who have no real experience with other programming languages. Of course, there might be some who actually have said experience and still prefer Python, but then I will question their judgment without apologizing and in a true "no true Scotsman" manner :-) . TensorFlow actually _is_ an academic toy (despite being written in C++ not Python, it only has Python bindings) and Django is a catastrophe waiting to happen, and pretty sure Blender is not written in Python. The others I had no contact with so I don't know. I am certain that you can write useful software in Python, I did debug one of them, but I would not do it only because of the pain of not having real scope, not having blocks and having to count spaces. Why not mention WSGI as a good Python thing (which it actually is)? ... though at least you did not mention numpy as being written 100% in Python like one of those patronizing fanboys was telling me last year. I'm tired of taking the high way and be defensive while the overhyped alternative proposed to Perl 5 is a language which does not have blocks and the concept of scope because it was easier to write the compiler that way. BTW, I'm an OCaml fanboy :-). OCaml is the perfect language, not Perl 5, though Perl 5 is, depending on the requirements, rather good when compared to the rest of the dynamic languages. Want to make me lose it, answer saying that OCaml is not good, then I'll lose all inhibitions ;) .
Let's see if your expectation based on nothing but your opinion was right, or [completely wrong given data](https://insights.stackoverflow.com/trends?tags=go%2Crust%2Cjava%2Cd%2Cocaml%2Cf%23%2Cc%23%2Ckotlin%2Cperl%2Cpython&amp;utm_source=so-owned&amp;utm_medium=blog&amp;utm_campaign=gen-blog&amp;utm_content=blog-link&amp;utm_term=incredible-growth-python)...
=)) there are lots of Python questions on the site for free homeworks ? :) I'm awed, I shall polish my tab key presently yes, I know Python is popular with universities, but Pascal was too, and there was a lot of software written in Pascal too, and lots of programmers who could not learn anything else after they spent a few years with Pascal Perl was not perfect but at least it answered to what the market was needing when the Web started. PHP was not perfect but at least it was super easy to deploy. Python is popular with "educators" who don't have enough imagination and teaching skills to actually teach something tolerable but useful such as OCaml or Erlang or even Go or F# and who instead of blaming themselves believe that their students are too mentally retarded to learn C++. Please, send me statistics from the "CV-driven projects" site called github too :) I can hardly wait.
Yeah sure all data is meaningless, and only fits your assumed narrative. No. Python is popular with the entire field of engineering and science, replacing most closed source solutions there. Especially in [data science and machine learning](https://businessoverbroadway.com/2019/01/13/programming-languages-most-used-and-recommended-by-data-scientists/). These newer titled roles also confer a lot better compensation to someone who can call library functions, so unsurprisingly everyone is learning the main language of that field. It has little to do with education. In the same way R has seen a huge growth in the last five years too. That many large companies use and support Python is a major reason for its defacto status, similar to what Java used to enjoy. That this is also all backed up with formal education in the language means the code quality is far higher than anything Perl has ever enjoyed historically, it's not a trivial "homework coding" matter.
It's too late for perl6 to be a 'new' language. I don't see it happening.
&gt; data science and machine learning. right, slow-as-molases is popular with data science etc. How about blas, atlas, lapack etc. are popular with data science and machine learning, and those who did not get to the C++ intro flood the stackoverflow with questions about the python bindings If you had wrote that Fortran is popular with data science types it would have been credible, but our subject is popular only with postgrad students. If you had wrote that Java is popular, that I can see personally. OCaml is popular with data science companies. Even D is more popular with high performance/numeric xxx/data science guys. It seems you invested a lot in python and I'm sorry for you. Java was the last language to rule them all, and it lost that position, and there will be no other language to replace it unless the US or China decide to enforce one by fiat. We're in the age of DSLs.
If perl6 wants to kill perl5 they really need to replace perl5 subsets. Latest python2 has lots of python3 features back-ported, so unless your software hasn't been touched in many years it is not that hard to port to python3. the only issues I've faced are low level unpacking, bytes vs strings and utf-8. There is not enough critical mass in perl6 to replace all the legacy stuff in perl5 with perl5 modules.
Thanks!
For legacy code intended to be replaced or never touched, yes. But you are stuck if you need a recent pypi module.
No experience with Square but I implemented Stripe a while back for work in Perl and it was a pleasure to work with (especially after PayPal).
The correct answer to the question: 'Is Perl 5 a compiled or interpreted language?' is Yes. The Perl compiler compiles Perl to an internal OPCODE graph that is then interpreted by the Perl Interpreter. This question dates back to when Perl was being used for things that were previously done in C, and hardware was much slower. It is rarely heard these days, particularly when actual Interpreted languages are in wide use and are far slower than Perl. I suspect the fact that Perl 5 is so fast is why the language gets left out of speed comparisons between different interpreted languages lately. I can just imagine Executive types asking 'Why aren't we using Perl' after seeing how Perl blows Python and Ruby out of the water. Of course in reality though, that would never happen.
I haven't interfaced with Square, but when there aren't existing CPAN modules, I find [Mojo::UserAgent](https://metacpan.org/pod/Mojo::UserAgent) is a real pleasure to work with when dealing with APIs, and I just wrap those calls in a module of my own.
That depends, if the scripts use anything MySQL specific, then those MySQLisms would need to be converted to their Oracle SQL equivalents
So besides the MySQL specific statements, the DBD is generally the only thing that needs to be changed correct?
UGH. Despite all the fancy overhaul and appearance, it STILL has the link bug where one page (say, [`pack`](https://perldoc.perl.org/5.30.0/functions/pack.html)) has a link to another function (e.g. `unpack`) that is BROKEN.
Yes. But note that much SQL syntax is not portable between MySQL and Oracle. Even things like LIMIT. You should assume that you will need to rewrite every query.
Thanks for the response. Do you know if there is some sort of documentation that describes these technical differences? I really need some assistance on this thing here
http://www.sqlines.com/mysql-to-oracle has tools and info that may be helpful. Otherwise Google is your friend. I am sure many have had this task.
I dont think many have had this task. This database is a very very complex and large database. We're talking hundreds of thousands of records with thousands of scripts interacting with it.
Why do you need to migrate it, then?
Good question, business needs to bc the database is expanding. Oracle is "better" bc of its scalability.
Not square but Paypall etc - [this](https://metacpan.org/pod/WebService::Braintree) makes paypal a bit less painful. It has feature parity with the ruby implementation (or did when we finished the work a few months ago).
I wasn't aware of that, but you set me looking, and I guess you realize you can made your own html documentation, eg; # perldoc -o html -d ~/pd.html perldoc will give you the perldoc documentation in html format. Not sure if of any interest for you, but was a "discovery" for me.
If you haven't had to recreate a table because your autoincrement primary key overflowed the integer type used to hold it, your database isn't large yet :)
You could grab the export for each version from [this repository](https://github.com/OpusVL/perldoc.perl.org-export).
I thought SQL was a standard. I'm sure I've seen or even used a tool, but the memory has long gone, sorry.
Dude, I've got some bad news for you, and it involves COBOL, Fortran, Ada and others.
Sorry it exceeds your intelligence and capabilities. Now be so kind and buzz off
You are doing it wrong. There‚Äôs a reason it‚Äôs still used.
Fair enough. I get defensive when Python fans attack Perl 5 too. And Perl 6, as I probably mentioned above, is my favorite language. I haven't gotten to use it much outside toy scripts, but the feature set is just spectacular. (Edit: I just try to be careful not to attack Python back because I fear it alienates the audience the Perl community should be trying to reach.) I didn't mean to assert that everything I listed above was written in Python. I was just responding to the "dependencies of every build tool/helper" bit - most of the projects I listed chose Python as their plumbing language and work fine. One of my younger brothers is doing graduate research work in climate modeling, and some of the research facilities he's worked at use Python + numpy (or maybe pandas? I don't remember) for their work. (Edit: I forgot to mention that he actually doesn't like Python. Heh.) I really think the biggest problem faced by the Perl community is a marketing one, not a technical one. We have two excellent languages and CPAN is the granddaddy of dependency management systems, we just have to get the message out to more people that we have a good, useful tool here and a welcoming community.
This is a really great collection of snippets for Emacs. Thanks for sharing!
What does `my (|) = @_;` do?
As explained in the previous sentence: &gt; | is the cursor (or "point" in Emacs parlance)
It's kind of like defining aliases in bash :) except for the editor.
Inspired by https://github.com/Grinnz/perldoc-browser/issues/13 I threw together this instance to show some CPAN module docs. Task::Kensho seems as sensible a starting point as any, and I also installed [perlsecret](https://cpandoc.grinnz.com/perlsecret) as its MetaCPAN rendering [currently has issues](https://github.com/metacpan/metacpan-web/issues/1228). Let me know [here](https://github.com/Grinnz/perldoc-browser/issues/15) or send a PR for cpanfile-cpandoc if you want any other modules rendered there.
Did you literally mean the last (as in there will be no further newsletters), or the latest?
The conference will take place in a few days, so I guess there's no need for more **2019** Perl Conference Newsletter issues.
Oh, gotcha! :-) In this same vein, I present a programmer's joke: *"A wife sends her programmer husband to the grocery store for a loaf of bread. On his way out she says 'and if they have eggs, get a dozen'. The programmer husband returns home with 12 loaves of bread."*
[Mojo::Payment](https://github.com/jhthorsen/mojo-payment) has PayPal and Stripe. Adding Square shouldn‚Äôt be much of a challenge.
It's impossible to know without the build log.
I agree, this does not seem possible.
Okay, here it is. [https://drive.google.com/file/d/1yzMuAiBq79Z3DudFCytu77snB-e9PzIX/view?usp=sharing](https://drive.google.com/file/d/1yzMuAiBq79Z3DudFCytu77snB-e9PzIX/view?usp=sharing)
i guess because you give it list of lines... the documentation says `info()` emits [message event](https://mojolicious.org/perldoc/Mojo/Log#message), which in turn is documented as $log-&gt;on(message =&gt; sub { my ($log, $level, @lines) = @_; ... }); where I assume $log is your $screen, $level in info, and @lines is your list of two strings: `'found: '` and `join( ',', @ary )`. you can replace a comma between them with a dot to join then into a single string, though. should work: $screen-&gt;info( 'found: ' . join( ',', @ary ) );
meanwhile &gt; `say LIST` is simply an abbreviation for `{ local $\ = "\n"; print LIST }` and `print LIST` is &gt; The current value of $\ (if any) is printed after the entire LIST has been printed. all from perldoc
I guess you're right. :) Wish I'd thought of that prior to posting.
it's literally 6 lines from the end, surrounded by exclamation marks: ERROR: Can't create '/home/bluemanedhawk/localperl/lib/site_perl/5.30.0/x86_64-linux/auto/Tk' mkdir /home/bluemanedhawk/localperl/lib/site_perl/5.30.0/x86_64-linux/auto/Tk: Permission denied at /home/bluemanedhawk/localperl/lib/5.30.0/ExtUtils/Install.pm line 489.
Ok. I'll try sudoing.
Great to know!!! Thank you!
np! thanks for posting, I didn't know any of it myself, dug in a little and learned something new :)
Doing that is probably what got you in this situation in the first place. By running `sudo cpanm` you created a bunch of root-owned files/directories in your home directory. You should fix that with `chown -R`.
Nevermind, I just took the package and compiled it myself
The substitution is not recursive. It is replacing every two underscores with a single underscore, so you end up with a string of half the length at the end. Something like the following will replace any number of contiguous underscores with a single underscore. $str =~ s/_+/_/g
thanks.
I recommend at least 2 underscores in the match: $text =~ s/__+/_/g;
 $ perldoc -f int int EXPR int Returns the integer portion of EXPR. If EXPR is omitted, uses $_. You should not use this function for rounding: one because it truncates towards 0, and two because machine representations of floating-point numbers can sometimes produce counterintuitive results. For example, "int(-6.725/0.025)" produces -268 rather than the correct -269; that's because it's really more like -268.99999999999994315658 instead. Usually, the "sprintf", "printf", or the "POSIX::floor" and "POSIX::ceil" functions will serve you better than will "int". I guess the internal representation is something like 3815.999999 then.
Neither 36.16 or 36.17 are free from rounding error as a float, 36.16 just happens to be slightly less than "36.16", while 36.17 is slightly higher. $ perl -e 'printf "%.*f\n", 46, 38.16'; 38.1599999999999965893948683515191078186035156250 $ perl -e 'printf "%.*f\n", 46, 38.17'; 38.1700000000000017053025658242404460906982421875
This is the explanation I was looking for. Thanks!
Just to clarify, it's not a perl issue, it's a general problem in computer science. You may want to read ["What every computer scientist should know about floating-point arithmetic".](https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf) Essentially the floating point numbers computers use are only an approximation to the real numbers humans use in our everyday lives. It's not uncommon to find difficulties in some boundary cases, like you have found.
Or s/_{2,}/_/;
why fork/exec or proc::reliable not an option?
You may find [IPC::ReadpipeX](https://metacpan.org/pod/IPC::ReadpipeX) handy for this. To quote a command for the shell like the quotemeta and sprintf examples attempted to do, use [String::ShellQuote](https://metacpan.org/pod/String::ShellQuote).
\`readpipe\` (the underlying backtick function) should accept more than one argument and treat the arguments like \`system\`. That would've been nicer and more orthogonal. So when I don't want to invoke shell, instead of the more awkward: use String::ShellQuote; my $cmd = "cmd ".shell_quote($filename); my $result = `$cmd`; I can just do: my $result = readpipe($cmd, $filename);
is this on Windows? `Installing modules to /Users/nikhil.p/perl5` sounds like it is... if it is, make sure you set up environmental variables [as described](https://metacpan.org/pod/local::lib#Differences-when-using-this-module-under-Win32) in the docs.
Try a `wget` of that path and see whether it works. Perhaps you are behind a proxy?
is your internet connection On? can you manually download the archive via that URL on that machine?
You can also write `my $cmd = shell_quote('cmd', $filename)` which I find handy. I also think a list readpipe would make sense, IPC::ReadpipeX as mentioned in my other comment is my copy pastable implementation of this idea.
Permissions. My Mac is knotted like that and I have to sudo cpanm. Oh, install local::lib like it says.
if i click on the link it opens browser and starts doenloading the fire immediately
yes sir
will do
&gt; Installing modules to /Users/nikhil.p/perl5 I dunno about perms.. it appears to be Windows, and Users folder won't need special permissions (unless `nikhil.p` is not current user account, which would be strange). If it is Win indeed, he can try running `cmd` in "as Administrator", and give is a shot again. But for now I like the proxy theory from above more.
it maybe proxy environment variables are set, which would affect cpan/cpam, but not non-Perl applications. if you on Windows, type `set` command in CMD, and see is there's `HTTP_Proxy` variable listed. I think in Linux `printenv` command should do the same.
So we're trying this experiment with Perl.com where we accept pull requests to fix things. I'll see about adding examples of those too, but if you wanted to get there before me, I can approve/merge/adjust things that people submit. This goes for older articles too. If there are things that are out of date (and we have content back to the mid 90s), we invite people to help us update things.
They might be, but I didn't set out to highlight every way someone might do this. Would you be interested in writing an article about those two? You can fork tpf/perldotcom from GitHub and follow the new article instructions. At some point we have to figure out how to link articles.
All those recent blog posts are re-igniting my live if Perl again and making me want to learn Perl 6 finally!
Where's the Perl?
ZipRecruiter does a lot of Perl and employs a number of Perl folks you may recognize.
I can recommend the following for a fairly immediate in your browser start &gt;;3 https://perl6intro.com/ https://glot.io/new/perl6
You're trying to install modules to a global (system-wide path) with out the privelege to do so. You need to either install as root via sudo, or you need to install the modules to your home directory via local::lib. The output of cpanm tells you exactly what to do.
It's not Windows. It's Darwin. `/Library` is the clue.
Things can get much deader than Perl. I used to mess around a lot with something called DIV Games Studio. There's not even an English wikipedia page for it. It's a language specifically made to make games, in the DOS era. It completely lacks support for text mode. It's proprietary, but there have been open source clones of it.
Scheme is my favorite dead language I remember the hype from 1998-2001, Scheme was supposed to be the be-all-end-all. According to the Scheme lovers Perl was ... resting, since 1999 at least. I did buy into the hype, started to learn Scheme, but switched to Perl because in the Scheme book I/O was after chapter 20 while in the Perl book I/O was in the first lesson and I wasn't doing it for the sake of the art, but because I needed some data parsed and sorted.
The issue was resolved guys. Problem was with the network.
I was a full-time Perl Developer 3 or 4 years ago and even gained a couple of professional certs in Perl Dev, quite enjoyed it but mostly did web stuff rather than fun exciting Fintech style applications that I keep reading about people using Perl for. I like the idea of taking part in an open source project in Perl, simply because Perl was such a simple language to program with that it allowed a lot of creativity.
At least Perl 6 is not one of the options :-)
You have to start before you can die
Perl is definitely not dead [https://securityintelligence.com/news/outlaw-threat-group-using-botnet-to-distribute-monero-miner-perl-based-backdoor/](https://securityintelligence.com/news/outlaw-threat-group-using-botnet-to-distribute-monero-miner-perl-based-backdoor/)
I guess they should have titled it "What's your favourite undead language" :-)
This article is pure garbage. How could C conceivably make this list, much less Perl?
Scheme is hardly dead.
Of course it is not. I was begging for somebody to tell me that Scheme is not dead, despite not being as popular as it was 20 years ago :-) ... not even GW-Basic is dead, probably the only dead languages are the assembly languages for CPUs which no longer exist.
I'd vote Perl... but Perl isn't dead. So....
Somewhere a basement full of government programmers is maintaining a fleet of programs in IBM 1401 machine code. If they are lucky, they actually get to *use* a language.
What's dead may never die
It was never really popular outside of academia, unfortunately - I've never found a strong dynamically typed language that's better. SICP should be a mandatory part of CS curriculums.
There‚Äôs always emulation.
Latin.
If you absolutely must use Windows, Strawberry Perl with notepad++ or vscode are your best choice for a setup. I use Strawberry and Neovim at work where Win 10 is required. There are no, to my knowledge, Perl specific IDEs.
Is Perl one of those languages that isn't supported very well on Windows?
Vscode with some plugins
It's just that Perl comes out of the box on *nix systems whereas on windows you have to find, download and install an interpreter and put in your environment variables and all that faff
I use Perl often for Windows administration tasks, it is well supported through the Strawberry Perl distribution. That being said, I would assume I'm in the minority. Most Windows admins are using PowerShell these days, which is a perfectly fine scripting language if you're in a Microsoft-only shop.
Geany is quite good lightweight cross platform IDE, or if you're willing to learn something new use vim
I would say that most languages are not supported very well on Windows; Perl's support is probably average in that respect. [perlport](https://perldoc.pl/perlport) has a lot of information on problems you may run into with your code.
VSCodium with some plugins!
If you do Java get the Perl plugin for Eclipse maybe? Or travel back in time and use emacs, less an editor, more an operating system.
Perl is well supported on Windows. Use it all the time and dockerise to deploy in Linux. No issues, other than creating a variable for slashes and use that or use/ all the time and /c:/ is you need the drive
&gt;&gt; Don't you understand that the decline in Perl "attributions in general" &gt; What decline? The US population is growing [...] Ah. So this is all about Perl in the US and A? In that case. Good luck with that as well. In the rest of the world, things might be (read: are) different. &gt; P6 is a radical rethink. Yes. &gt; You say you think it's outdated. Lie. Where do I say that?
Absolute reference your script, the console it's using may not be pulling in your environment
I don't use eclipse but it turns out there is a plugin for Netbeans. I'll try that out.
Sudo su - Cpanm ... saves all the hastle with location spreading
&gt;Ah. So this is all about Perl in the US and A? No. It was originally about someone looking for Perl staff. Then someone claiming to care about Perl trash talking Perl. Then about growth or decline, which can be looked at as a relative percentage (as it is in the stats you linked) or in absolute counts of humans (which is what matters to a community). I was just providing an example illustrating the difference because you seemed to be ignoring that difference. &gt;\&gt; You say you think \[P6 is\] outdated. &gt; &gt;Lie. Where do I say that? In this thread: "Either way, P6 is outdated, IMO."
Nice Mojolicious demo at 20 minutes to show some real Perl. Remember accessibility in your websites: use HTML5 to make things work as they seem. If the JS and CSS seems too hacky, it's probably way worse without a keyboard and mouse.
It's a hard life. You must be strong to survive.
Komodo Edit is OK, I even bought the IDE version VSCode works well Eclipse with EPIC ( [http://www.epic-ide.org/](http://www.epic-ide.org/) ) should be enough if they have it installed
Where is perl.exe installed? The NPP says it is supposed to be in `C:\strawberryperl\bin`. Verify this.
[Camelcade/Perl5-IDEA](http://redd.it/9yjs3m)
I think another cool feature to add would be templating... example, certain code block constructs are so similar. Why not say some like Use Template X and fill in the blanks and then when one is all done... Say End Template Realistically, I think the main solution will be an AI of some kind.
Really fascinating how complicated it is to just "say" things in a programming language. Macros, phonetic alphabets, shorcuts, jargon... you really have to combine a lot to make the system workable and even then it would be tuned to a specific individuals prefrences to such a degree as to be almost unusable by others.
It would be interesting to see a programming language that was designed for voice input so as not to require as many workarounds.
Or the reverse, trying to voice input obfuscated perl.
There was a live demo of that early in the video, it actually seemed easier than words ;)
I made my own poll about "dead" languages: [https://twitter.com/preaction/status/1141715201072476160](https://twitter.com/preaction/status/1141715201072476160)
What does your regex do? it substitutes double '\_' char into single one. In the other words, you're halving number of underscores in variable. Probably you're after something like `perl -e '$text = "_____________"; $text =~ s/_{1,}/_/g; print $text'`
Not super familiar with GTK, I just took a glance at the docs to try to help out. Feel free to disregard. It looks like format_secondary_text is basically just a printf that updates the `secondary-text` property of the MessageDialog object. So I guess the question is, would it be possible for you to set the `secondary-text` property of the MessageDialog directly as a workaround? I think the argument that they're making in the thread you linked is that perl's string manipulation is better than whatever gtk cooked up, so rather than implementing gtk's markup, they're expecting you to format the string as you wish in perl and then update the property directly. Weird that they didn't bother implementing that function, but it might be more of an intentional design decision rather than being 'incomplete'.
I've got quite a bit of Gtk2 code in daily use (mainly too lazy to update), mostly on Ubuntu 18.04 based distros. Though it's a bit hit and miss with the docs...
&gt;would it be possible for you sure, `$dialog -&gt; set (secondary_text =&gt; 'chujowy link');` works as it should, but my main concern is fact that i was not aware of `set` method of object. I mean, yeah, i could figure this out, but i could be `update-property` method or name-it-as-you-like. Dunno, maybye i am too dumb to read the docs thoroughly, maybye i am too lazy to check if any parent object uses `set` which GTKMessageDialog inherits. Sigh, quirks like these really can clib one's wings. &amp;#x200B; &gt;Not super familiar with GTK So maybye you're able to recommend any other graphical toolkit usable with Perl? At the moment my main goal is to be able to create clickable apps, one of sub-goals is to create "frontend" to instagram photo downloader for my girlfriend.
Do you run any public repo? I am eager to see how others do it, was searching for "perl based software" but not much graphical stuff came out.
I'm afraid not, it's all a bit intertwined and undocumented at the moment. I'll send you a link for something, might be useful.
&gt; any other graphical toolkit usable with Perl The best supported ones are stdin/stdout, and html via cgi/fcgi/psgi :)
Yes, it did solved THIS problem, but on the other hand i did not found mitigation to segfaults after dialog's destroy. Also i suspect that there will be more problems like this, which i am looking for common solution. My main complaint is that having only Gnome's docs about GTK3 and knowledge that difference between docs and perl's implementation is naming scheme ([gtk\_message\_dialog\_format\_secondary\_text](https://developer.gnome.org/gtk3/stable/GtkMessageDialog.html#gtk-message-dialog-format-secondary-text) () -&gt; Gtk3::MessageDialog -&gt; format\_secondary\_text()) i am unable to actually write anything more complex than single window.
I honestly do not get it. This is seriously a request to do absolutely nothing and framing it as a new idea.
It's important to remember everyone is doing their best here, and there are many perspectives that have been well hashed out. But this does not practically change or solve anything. Perl is Perl 5 -- there is no changing that outside of our echo chambers, unless Perl 6 replaces Perl 5, which does not seem to be the immediate plan of either set of developers -- maybe it will happen in 20 years, but trying to do it now has the expected effects. 'Raku' was presented as a start of a solution -- it was not decided under duress, unless you count that Larry clearly dislikes all this contention. And there is no reason Perl and Raku cannot continue to share resources and community aspects, like the history they share.
*you know, you could use Perl for that glue and data munging you need there, rock solid* *huh which one, the old or the new, i heard they changed it?* *erm, the old, the new one can't really handle these things yet, it's like 30x slower with 50x memory usage on average, but i hear in the past 10 years its gotten like only 20x slower* *yeah, ok, we'll use JS then*
Right..., that‚Äôs why no one uses C and C++ anymore ‚Äî because apparently everyone works with co workers who are too stupid to make an educated decision. /s
&gt; It's important to remember everyone is doing their best here with all due respect, if this is their best... i've been trying really hard to understand this need i've seen with various P6 folk to displace Perl5 as Perl, but i am failing miserably. they want the 1999 Perl popularity instantly ? well, flash news, not even Perl5 has that anymore. can they truly replace Perl5 in everything it does right now, with the same speed or better, on every architecture Perl5 runs on and every OS ? eg. can you be /usr/bin/perl on solaris/sparc64 right now, ensuring nothing breaks ? far from it, as you said, they don't even want to ! so, what are we talking about, can anyone enlighten me ? Common Lisp, Scheme (Racket, Chicken, etc), Clojure are all Lisps. Emacs has another custom Lisp. All Unix shells (Bourne, Bourne Again, C, Korn, etc) are Unix shells. Delphi is still Pascal at core, just an OO dialect. There is no ambiguity, they share a domain, an ancestry, a history, a culture, but different things have different names. I knew naming is hard in computers, but this is way past unreasonable at this point, IMHO. it bothers me that this should not have been that hard, 1. define a list of things a Perl language adheres to (see the Zen of Python, etc) 2. define Raku as a Perl dialect, of the 6th descendancy (see Lisp 1, 1.5, 2, etc) 3. profit?
I reworded the opening sentence to hopefully better convey my intended meaning, as this idiom does not seem as obvious as I thought.
Stupidity is generally not the issue, though we jest. This is a likely thought process of many well educated programmers who aren't practiced in Perl of any sort.
To me the most obvious step to end this problem, with all parts winning, would be renaming Perl 6 to something else. The two languages share very little, and the naming problem is harming both. I don't know why is it so difficult to make this change. For an example, a few years ago MZScheme changed is name to Racket and I don't think there was this kind of opposition (but I'm not part of that community so I don't know for sure). From the outside it seemed there was zero drama about it. And nothing important was lost; the name change implied the two languages (Racket vs Scheme) had diverged enough to warrant it, and that was that.
The sad thing is, this naming issue forces us in the Perl community to ever repeat the "they are sister languages, both are evolving separately, perl 5 is still maintained and improved, yada yada yada" to anyone who asks. It would be so much easier if they didn't share the Perl name...
lol idk why it formatted that ugly, hope it's readable
Is the -init automatic calling an issue? What happens if you call Gtk3::init by hand every iteration?
Did not tried that, but init is called once. Program is either sitting in Gtk's main event loop or in mine 'pobierz' procedure.
Why won't you ask questions here? Try to solve any problem by yourself and turn to us with anything what does not work. Also perldoc explains many quirks, 'coping with scoping' explains most begginers problems. Imho - best way to learn is to constantly hitting the wall ans asking 'how come that this wall stands here' :)
&gt; (clicked =&gt; sub {$dialog -&gt; destroy()}) This might be a reference counting issue. You'll need to dig into memory management on the GTK3 side though, since I'm not all that familiar with it.
sigh, Pythonists are doing that much easier. But ref counting sounds reasonable. Thanks anyway, i'll try to take a look into that.
Yeah, well, you got to pick and choose the tools that make your life easier. And there's a learning curve with everything. THANKFULLY, pretty UI's are for someone else to deal with for me...
Try http://perlmonks.org/, the most friendly and knowledgeable perl community online.
Starting around min 40 to the end he's talking about a possible future for Perl5 and it sounds amazing. I'm not sure how to voice support for it though, what repo to go star, or issue to comment on.
This is good. I've left this industry but I love perl.
Great presentation.
&gt;&gt; when is Perl 6 supposed to take over from Perl 5? &gt; Supposed is an interesting word. What is it supposed to mean? This is _exactly_ the problem: "what is it supposed to mean?" Or. "When will it happen?" Or. "Will it ever happen?" Or. "Are they two different languages?" The thing is: normal people, trying to learn a new language, doesn't know the answer to these questions. Hell, people who has been "in" Perl for 30 years don't know the answers either. With all those questions unanswered, people (and certainly businesses) will shy away from Perl. That's the problem with Perl; it has nothing to do with the language itself. &gt; As Larry said in 2000: "Many commercial interests will guarantee that Perl 5 continues to be well-maintained and stabilized". And so it is. Is it really? Can you document that claim? It's 20 years ago... &gt;&gt; Either way, P6 is outdated, IMO. &gt; I'm curious to hear about the basis of your opinion. Part of my job(s) is to find the right people to the right job. In Norway, there are _no_ companies wanting Perl developers. You have a misunderstanding that "a good language" leads to (good) developers. Unfortuntaly, there are _no_ Perl developers out there for hire. The quality of the language is _extremely irrelevant_ as long as no one wants to use it. &gt; I went to Glasgow last fall. Hundreds of Brits and other Europeans in one building. Perl meetups happen year round world wide. Some meetups in asia have thousands. You might think they don't exist but I had a wonderful few days connecting with smart, capable Perl devs. Read that again. Twice. Third time with David Attenborough's voice.
&gt; To me the most obvious step to end this problem, with all parts winning, would be renaming Perl 6 to something else. Actually, Larry created the alias Raku ([1](https://github.com/perl6/roast/blob/master/docs/announce/6.d.md), [2](http://blogs.perl.org/users/zoffix_znet/2018/11/announce-raku-perl-6-diwali-6d-language-specification-release.html)) in response to this [request](http://blogs.perl.org/users/zoffix_znet/2018/10/a-request-to-larry-wall-to-create-a-language-name-alias-for-perl-6.html). Unfortunately, adoption has been quite slow and the main proponent for the alias left the community. Although the name can be used interchangeably with Perl 6 or in conjunction with it (e.g., Raku Perl 6), my hope is that Raku replaces the name Perl 6 organically by "its sheer amount of use", as stated by Zoffix. However, this can't happen if it's not used. &gt; I don't know why is it so difficult to make this change. For an example, a few years ago MZScheme changed is name to Racket and I don't think there was this kind of opposition (but I'm not part of that community so I don't know for sure). From the outside it seemed there was zero drama about it. You're not alone. I understand that some community members have reasons to want to stick with the name Perl 6 but languages that belong to the Perl family of programming languages are Perls, regardless of their names. If that's true about Racket, then it's been renamed twice (it also used to be known as [PLT Scheme](https://www.plt-scheme.org/)) without much drama about it. [This page](https://racket-lang.org/new-name.html) even goes into the details behind the rename, highlighting that "the Scheme part of the name PLT Scheme is misleading...". I honestly find this kind of approach refreshing and it shows a certain level of awareness from the people behind it. &gt; And nothing important was lost; the name change implied the two languages (Racket vs Scheme) had diverged enough to warrant it, and that was that. Likely, nothing will be lost when the name Raku is embraced. Will myriads of users adopt Raku when it happens? I doubt it, but then it'll be less of a hassle for those few people who decide to use it. They won't have to dive into what might be called the called the obligatory complete history behind the language for any newcomer, unless they want to. I mean, even blogpots discussing particular Raku features submitted to different forums devolves into a discussion about Perl 5, its decline, its write-only syntax, etc. But I guess it's to be expected, *why does it have Perl on its name then?*
I see we agree on pretty much everything regarding this issue. As for Racket, I was writing from memory and I think I was sort of right and wrong at the same time... MZScheme was only a piece inside PLTScheme and got renamed to Racket the same time as everything else. Regarding Raku, I think it's a step in the right direction but, since it's only an _alias_, to me at least it feels like a half measure. Maybe that's why it's had less traction than it should. I think they should be bold and go all the way with the name change. The language would still have the same philosophy and heritage but the separation would be absolutely clear to everyone.
&gt; Either way, P6 is outdated, IMO. &gt; Lie. Where do I say that? When a normal person does something like that, and gets caught, they typically apologize. &gt;&gt; "Many commercial interests will guarantee that Perl 5 continues to be well-maintained and stabilized". And so it is. &gt; Is it really? Can you document that claim? When a normal person asks for proof of some claim, it's not normally for proof of something so bloody obvious the whole world can see it. Perhaps you live in Norway and are basically ignoring the rest of the world? Ever hear of booking.com? Or do you never use hotels? Amazon? BBC? Craigslist? Duckduckgo? You hire folk; ever hear of Ziprecruiter? Do you know why I'm mentioning these companies? I thought not. Go *find out about* Perl *before* spouting about Perl. I don't know what on earth you're doing posting messages on /r/perl but you'll need to engage with others because I've had my fill.
Options I‚Äôve seen from easiest to most difficult: Use Perlthanks and mention it. That‚Äôll get sent straight to p5p. Contribute money to the Perl5 core fund and/or get your employer to do the same. Contribute code to implement tests or docs for some of these features or the features themselves. Contribute time and energy organizing a hackathon to pull together people to work on these features (see also the Perl Toolchain Summit that happened recently).
"poor IDE support" requires a definition. And there is a comfortable GUI debugger.
I can give at least my expected definition. There is no good support for third party commercial IDEs, not written themselves in Perl. So things like a full JetBrains based IDE, something akin to Comma for Perl 6. The more successful IDE to ever exist, by functionality, is Padre which is a bit limited by the quality of GUI support in Perl itself, as well as the much smaller volunteer backing. That's not to say Padre isn't good, but it doesn't benefit from a large cross language ecosystem with a lot of commercial backing. Its also not familiar to people using or coming from myriad other languages. I'm not sure if anyone has tried it recently, but the full ActiveState IDE (not the cut down editor version) of Komodo just didnt really work (about 4 years ago). It also looks like ActiveState is a lot more concerned with other languages as a focus in recent years too. Im sure my problems were probably config related or not knowing how to use features. But its telling I dont have these problems in other languages or other vendors.
Have you tried perl5 support in JetBrains IDEs?
Yup sorry just edited to say that. Its not IDE level support, assuming you mean camelcade. Its about as feature rich as my vim setup, with none of the advantages of a cli editor.
Should probably give a shout out to cperl for ideas on what something more futuristic out of core Perl 5 could look like: http://perl11.org/cperl/perlclass.html http://perl11.org/cperl/perltypes.html
1. Not really familiar with vim, so hard to authoritatively compare capabilities. Can say for sure it's better than EPIC/Komodo/Padre. 2. Plugin provides you a mechanism of annotations, which help with type inference. 3. Doubt that vim may support everything described in https://github.com/Camelcade/Perl5-IDEA/wiki (wiki misses updates from last version) 4. Sure it does not support all language-agnostic things IDE provides for all languages 5. Current EAP (development version) has much better type inference without annotations. 6. Doubt that any IDE development company will try to build a commercial perl IDE atm, becase market is too small. The only disadvantage I can see - missing possibility to work remotely using just a terminal. Also, it's important to understand, that purpose of IDE is to ride a large, well-structured complex project, not just a few perl scripts. In compare with comma IDE - it's free and works on ultimate IDE too. Lacks profiling capabilities for now though. All other - running, debugging, coverage, refactoring, completion is all in there.
These days most IDEs support the [Language Server Protocol](https://langserver.org) for providing language specific features. Perl simply needs to ship with a language server, like [Go](https://github.com/golang/go/wiki/gopls) and [Swift](https://github.com/apple/sourcekit-lsp) for example.
native LSP support would be nice to have, true.
Since youre not going to, Ill point out youre the author of Camelcade. Ill try it out again and leave some properly informed and detailed feedback of the functionality that is necessary for me with a typical IDE workflow. The bigger issue is Perl 5 the language, especially existing legacy code lacks anything sane to accomplish most of it. Not your project.
&gt;your project. Atm - you can't. However, you could check how those parameters were used inside the method and infer type from usages. Any custom types or data model requires manual attention from my side, I should teach the plugin that \`use constant ...\` is not just an import, but declaration of subs. As far as plugin know some perl, some other stuff. But it's not a human and can't build a model from the raw perl (until it can interpret perl completely, and it won't still be able to refactor everything properly). The problem with this statement is lack of definition of decent support of perl5 from the IDE. I doesn't make sense to state something like 'I'd like to have java IDE capabilities from Perl IDE.'. Perl is perl, with all it's freedom and IDE unfriendliness. Some plugin flaws can't be resolved fundamentally, because of nature of language. And some of them could, but it's not possible without a feedback. And I'm not getting a lot of it. Inspite of about 10k active users. Usually users reporting only broken stuff and expects that i'll add more necessary features myself. But i'm not writing in perl for almost 4 years and this project is more like a puzzle to me - how to make what some ppl think impossible.
Yeah I completely agree, the issue is Perl 5 itself, how it stands right now, is the actual issue for progress in tooling like this. It shouldn't take human level intelligence to do this level of modelling of someone's code. Not only a human but a well trained human who knows Perl really well. But that was sort of the theme Sawyer was eluding to I assume in the presentation? The core language itself needs to nail down a supported way of doing a bunch of language level things so this can become possible. The main IDE support isn't IDE tools but support in the language to make an IDE possible. Python 2 vs Python 3 with type annotations and mypy for example, the latter is massively more useful with an IDE like PyCharm. Just the error messages are more useful. That you can do all of these in Perl is why IDE support sucks: ``` sub thing { my ($thing, $stuff, %others) = @_; } sub thing($thing, $stuff, %others) {} sub thing { }
This would be better as a top level comment.
Looks like someone needs to do this, I am going to look at this closer during the week see if its something i can help start / contribute back to the Perl community.
Oh, and I saw this only now. A bit late, but fixed now. Thanks.
Why did you leave, if I may ask? And which industry are you working in right now?
I.D.U.M.B. I'm a physician now: I'm Doing Unother Meaningful Blahblahblah. In short? cuz I made a mistake - motivated by a desire to do more good - and I'm paying the debt that incurred.
i wish i could understand these math syntax :C
Ironically in the recent couple of years I often imagine what my life would be if I had studied medicine. The greener grass effect, most probably.
Having experienced both: stay a perl munger.
The punchline, is of course, the 100 kB file `keeper` in &lt;http://www.ibiblio.org/pub/Linux/search/keeper-1.54.tar.gz&gt;. The code is so eyewateringly bad, it **crashes** Perl::Critic::Policy::InputOutput::ProhibitBarewordFileHandles. esr made a career out of bashing Perl, always blaming the language, never his own lack of skill.
But we have to admit that writing spaghetti code in Perl is easier than in competitors like Python or pure Shell. Just to name a few foreach my $key ( keys %{$hashref}) { do_things_with($key) } or my $keyval=$hash{'key'}{contant_key}; While it might be confusing i found it rather being like simple test for JAPHs - are you able to write readable, pretty looking code while being constantly tempted by sin of spaghetti? Maybye this is reason Perl's not so popular nowadays. But hey, looking at node.js tons of shitty packages being wrappers to wrapper's wrapper and comparing to CPAN's collection, i choose to stay with my efficent, expandable swissarmy chainsaw :)
Please take a look at some of the solutions already submitted. https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-014/dave-jacoby/perl5/ch-1.pl https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-014/rob-van-dam/perl5/ch-1.pl https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-014/simon-proctor/perl6/ch-1.p6
Can you explain the spaghetti? The concept is expressed no differently in the languages you named, plus a few others. # python for key in adict.keys(): do_things_with(key) value = adict['key'][CONSTANT_KEY] # bash for key in "${!aarr[@]}"; do do_things_with $key; done value="${aarr[key,$CONSTANT_KEY]}" # comma subscript trick # es6 for (const key of Object.keys(o)) { do_things_with(key) } const value = o['key'][CONSTANT_KEY] # perl6 for %h.keys -&gt; $key { do_things_with $key } my $value = %h&lt;key&gt;{$CONSTANT_KEY}
Okay I looked... I'm tickled that `use strict;` was commented out :&gt;
This article is 19 years old.
okay, these examples convinced me :)
Finally old enough to vote.
... "use vars" in a single file project ... block contents not indented despite making the effort to align the "=" signs all over the file &amp;#x200B; all functions work on globals instead of sending and receiving parameters ... good thing esr is deader than Perl 5 is, if that's his standard of good code
Thank you kindly, i'll check it for sure as:)
```js # ES6 using for...in for (const key of o) { do_things_with_key(key); } const value = o.key[CONSTANT_KEY]; ```
TypeError: o is not iterable btw, [triple backticks are buggy](http://redd.it/8vrdhs), use indentation for code
I love Perl, and use it quite frequently for small to small-ish projects. Its pretty ubiquitous on the machines near me, and can be very expressive. However, much like the author said in this article, after 100-300 LOC (depending on the complexity of the problem) it becomes very cumbersome. Higher level things feel very bolted-on. As much as I've used OOP, I pretty much refuse to use it in Perl because it feel unnatural (for reference, I was a fan of Ada95, where the OOP constructs felt like a natural extension to the language, not an add-on). The natural successor to Perl, for large LOC, IMHO should be Python. I never really fell in love with Python, although I've used it a couple of times productively. I think it's because I rarely need a scripting language on that scale. For large projects, I will tend towards a more traditional language like C++ or Java (not a fan of Java either).
which plugins would you recommend? also any guides out there to set them up or are they install and ready to go? VS code supports syntax highlighting out of the box, but if you could point me in the right direction to get as much as feasible done inside code that would be great!
This is a less than awesome request for help. * It does not describe the problem adequately. Show a malformed email as a whole message/rfc822 file, not just an excerpt, or try dumping the `$EmailMessage` variable. You can censor private data. * It does not show the problem in a way we can repro. Provide either a [runnable minimal test case](http://sscce.org/) or the full code, not only the part you think is relevant. Also provide the OpenSSL version (hint: run the `openssl version` command). * Asking for help in diagnosing a bug, but refusing the responsibility of modifying the code in order to fix it does not win any sympathy. I don't think sendmail is relevant, I bet the message is already malformed before it's handed off to the sendmail process.
I'm a huge fan of Perl as well. So much so I've written devops, test harness and etl in a single script. no the first or last time I'll have 20k+ lines in a script. Don't agree with people and the perl complexities of on larger pieces of work. It's all down to how any language is written. I tend to put a lot of effort into handling and debug messages in line, doing that means the code is documented, and highlighting against what I don't want. The rest should be easy to read and if it's not then learn the language. It's all to easy to criticise Perl, it is a language like any other, the fact that it's the interpreted C is not a fault it's actually an advantage. And good programmers lay it their code well, I for one don't need or want a language that forces me to do something to standards that tend towards a lowest common denominator way. Oh and yes, I'm no great fan of java either.
Thanks for your constructive comments oh great programmer. If I knew more than this, I probably could have figured it out myself. I showed you the relevent parts of an email that is acutally received by my customers. Signature headers are being seen in an email when they are usually hidden or attached. Seems simple enough that someone might have actually run into this and know of the openssl switch or sendmail configuration that needs to be used. Lets see, I showed what my issue was, I showed the two commands that are the most relevant to the conversation. Trying to streamline this so you aren't overkilled with information. You don't need to see anything else. And if there is something that I missed, can you be more specific to what I should be looking at than acting like a condescending asshole? its not a bug but a feature since the code worked on HPUX 11 but not on a current version of Solaris. Since my Solaris machine was just built, assuming that you can assume that the latest versions of OpenSSL and Sendmail were used is on me, I guess. And quite frankly, the openssl command and the sendmail commands are all there is. Sorry I removed some blank lines, but maybe my variables will help. They are as follows: &amp;#x200B; To: You From: Me Priority: High Importance Message: Go fuck yourself
"Perl 5" and "Perl 6" - unfortunately sounds like two successive versions of the same software to the outside world. This causes needless friction in getting our message across and worst of all confusion. Internally within the Perl community the fact that the number 5 &gt; 6 is a problem too. We need to be clear in marketing Perl internally and externally. Both languages have different stories to tell (albeit within the same Perl family) - they deserve two clear distinctive sub-brands. Larry nominated "raku" as an alias for Perl 6 - and in my opinion this was a positive first step. Since then I've been collecting potential sub-brands for Perl 5 too. You can check out the list here: [https://nigelhamilton.com/perl-branding-proposal.html](https://nigelhamilton.com/perl-branding-proposal.html)
Very efficient way to ensure nobody wants to spend their time helping you for free.
I've stated this before: If Perl6 becomes known more as Raku, then Perl5 can start using a year based versioning scheme as an alias to the existing versions. Perl5.30 could also be called Perl2019 then. use v2019; # use v5.30 --- This would reduce the need for a different name for Perl5. It would also show that Perl5 changes and improves every year. (Also since Perl5 is largely a superset of the earlier languages it makes a bit more sense for it to have the name.) --- I of course only want this to happen if Raku as a name takes over from Perl6. I don't expect that to happen anytime soon as there is a vocal minority that is dead set against that.
My understanding was that a 1401 simulator was written for the IBM XYZ, so the old programs could be run, which resulted in an IBM XYZ simulator being written for the IBM ABC ... ad nauseum. &amp;#x200B; Banks and insurance companies are still running COBOL programs, because they insist the replacement programs display absolutely identical behaviour, including known bugs.
&gt; And many of the features that were later patched into Perl to address the complexity-control needs of bigger programs (objects, lexical scoping, ‚Äúuse strict‚Äù, etc.) had a fragile, jerry-rigged feel about them. Mate, all these features were released with Perl 5.
&gt;Part of my job(s) is to find the right people to the right job. In Norway, there are *no* companies wanting Perl developers. You have a misunderstanding that "a good language" leads to (good) developers. Unfortuntaly, there are *no* Perl developers out there for hire. There's so much wrong here, it's embarrasing to read this. You need to update your facts. Your inability to see the talent market as it is just shows how far out of the loop you are. If you would like to update yourself, then the best way to do that is to get in touch with your nearest Perl community and have a proper chat with the people there. They know both prospective employers and empolyees, they have the network to help people solve their hiring problems, and they have the updated knowledge to get you to reach "Level 2019". Furthermore, if you're in a business that's looking for talent regarding any Open Source technology (Perl, or otherwise), there's really no better way of finding it than **actually interacting with the people in that community.** The day you show up at a Perl Mongers meeting in Oslo, saying "I can't find developers, can you help?", that's the day when you're worth listening to. Until that day, you (and your peers) aren't more than a bunch of clueless dillettantes. If you would rather stick with your own gut feeling (no matter how misguided and/or uninformed it is), then at least please stop spreading stupid FUD like you've been doing in this thread. You're not helping anyone with this.
Yeah, you are probably right. I apologize for being crass. However, a lot of information was put into the original post that I would have had to explain anyways. I show the simple command used and the output. There isn't any other configuration in code, other than switches in the commands themselves, for openssl or sendmail. And, it isn't looking for sympathy noting what my constraints are. Either ignore it or help. I can live either way. But, my problem statement still holds as above mentions. I use the openssl command (which is shown) to receive the output (which is shown). I use the output and send it via sendmail to receive the same output - its just that is was wrapped up as an email. There isn't anything simpler than that. The varibles used will be unique to each system as they are paths to files - text, pem, and key files. The sendmail code seems non-standard but it is extracting the appropriate fields (to, from, subject, message) from a hash varible. I receive the results via email. That works, but why isn't the signature seen as an attachment? Thanks.
Crossposted to [PerlMonks](https://www.perlmonks.org/?node_id=11101868).
&gt; The code is so eyewateringly bad, it crashes Perl::Critic::Policy::InputOutput::ProhibitBarewordFileHandles. Thanks, I've filed a ticket: https://github.com/Perl-Critic/Perl-Critic/issues/878
I'm using perl-outline: [https://marketplace.visualstudio.com/items?itemName=hitode909.perl-outline](https://marketplace.visualstudio.com/items?itemName=hitode909.perl-outline)
Also to [Stack Overflow](https://stackoverflow.com/questions/56754676/verify-loginpassword-in-perl-via-saml).
Yeah, it was the last of the pre-conference newsletters for 2019. Now for the post conference newsletter and we start 2020.....
Just add the space before the `'`: system( "$iptables -A ${chain}_BLOCK -j LOG -m limit --limit 10/minute --limit-burst 5 --log-level 4 --log-prefix 'DROP_$chain ' " ) == 0 or ...
&gt;Once we got on the right topic, the most common responses were Pascal, C, Assembly, and Perl. However, it's still a little fuzzy as to if those languages are truly dead. &amp;#x200B; It's not at all 'a little fuzzy' that C or Perl are dead unless, of course, you have something to sell.
OCaml is not good.
I forgot to mention what I already tried. I did this modification again but this time I rebooted the system and not only the application. Now after an iptables -L I have the space in the log prefix like the others: limit: avg 10/min burst 5 LOG level warning prefix "DROP\_CIARMY " But the syslog sent is still : Jun 26 08:10:20 x.x.x.x kernel: DROP\_CIARMYIN=red0 OUT=green0
It seems like maybe the log-prefix is being stripped of trailing or leading whitespace before being part of the string that's written to the log file. Is it possible to surround **DROP_$chain** in brackets or some sort of delimiting character(s) and then adjust your report software accordingly so that it's parsed correctly?
These blogs of his makes me happy.
This isn't really perl specific. SAML is explicitly designed to eliminate this mode or authentication. I would strongly discourage any effort to shoehorn it; you could get caught passing credentials in a way which is not secure. The most obvious solution is not to use SAML; implement a token service which authenticates against whatever backend mechanism SAML is authenticating against: LDAP, Kerberos, etc. But if you have to ultimately auth users against a SAML backend what this problem really boils down to is how you will implement transparent UX between the SP and IdP, and this depends on features offered by the IdP that are unrelated to SAML itself. If the IdP offers a suitably robust forms-based authentication method, often all you really need to do is slap a nice template on it so that it looks like the rest of your site, and maybe put it behind a reverse proxy if you want to keep it all in the same namespace. Another solution is just to proxy an IdP-initiated signon. TLDR: SAML has no mechanism for this; there is not enough information given about the environment to determine what alternative might be best.
Are you referring to the perldoc command line utility in your shell? If so, what OS/version? My perldoc on CentOS7 literally puts me in vi, so this might be more of a system question than a perl question.
`export PAGER=less` has j, k, arrow keys. https://en.wikipedia.org/wiki/Less_(Unix) ---- If you want the real vim instead, install https://github.com/rkitover/vimpager
I think Perldoc uses "less" to display the text, but you can change the pager to whatever you want by setting the PAGER environment variable. If the arrow keys don't work you might be having the pager set to more install less if you don't have it then try export PAGER=less
Excellent work by GeekUni, getting a little bit more publicity on this post :-)
I wonder if my boss will let me go to to Europe for this.
This is cool, and I hope we can plug something like it into Perl. One thing to keep in mind is that this is just implementing an NFA. Perl's "regular" expression engine has never been "regular". It's more powerful than that. Perl6's patterns are explicitly designed to be capable of context-free parsing, though I believe Perl5 can now get to that level if you don't mind the syntax. Just something to keep in mind when considering the 68x speedup. If you had a complete Perl-compatible CUDA regex engine, it won't be 68x faster. But it might be 10x faster, and that will be nice.
Is... is that a pooping cat logo?
The links to github from this are all broken. I would like to have been able to duplicate their results.
https://github.com/bkase/CUDA-grep ? The 'REFERENCES' links are broken too, one has to not click the link but instead copy the link text to get to destination. &gt; http://swtch.com/~rsc/regexp/regexp1.html as a reference. We used http://swtch.com/~rsc/regexp/nfa.c.txt as starter code.
Found the heraldry ignoramus.
Word. As the comments indicated it was supposed to be for...in, not of. Brain farted.
Fantastic presentation as always by Sawyer. I like his pacing for talks...some funny stuff here and there but keeps things moving. If I were to decipher this, I feel like he has a general feeling that Perl5 needs to up its game, polish up, and put on a better face. I'm glad he's not just shrugging and letting Perl5 become a maintenance project with Perl6 alone being the "future". Frankly the Perl6 efforts could stand to have the competition and I say if Perl5 can put out a better story, then let the users decide what the future really is.
Given that he seems to want a bit more of a top-down strategy, you probably don't need to do anything at all. I'm not ripping on the idea of a top-down strategy either...its worked out very well for other tools.
The Raku thing was stupid. Perl6 has so little momentum that changing the name would basically kill it. Do we really want to spend the next few years answering HN and reddit posts like "*hey I went googling for perl6 and it looks like it died, no more mention of it after blah blah"*. No. That is an awful waste of time. Perl6 is barely alive, it doesn't need any more roadblocks.
Keep getting mcafee security spam loaded instead.
all three deps have native ubuntu packages, fyi
how do i translate the names from per module form to ubuntu package form?
apt-cache search net::pcap, for instance.
dude, use Perl^TM Build an array of pkgs with dpkg -l, then walk the array with dpkg -L in a foreach loop if the pkg name =~ /^lib(.*)-perl$/ , then look for the unique files under /usr/lib/x86_64-linux-gnu/perl5/(.*)/(.*)/(.*) etc....
nothing found for netpacket::ethernet
 j@host:~$ apt-cache search netpacket::ethernet Curses, you're right. But will that stop me? Nay, for I have the wisdom of the gods, the determination of warriors, and the strength of ten, no, twenty vikings! Aye, am I not a man? ARE WE NOT MEN? Let the creativity flow..... j@host:~$ apt-cache search netpacket libnetpacket-perl - modules to manipulate network packets at the protocol level There you go.
thanks much!
Where are you getting stuck on? There is a lot of documentation out there so if you describe what you're struggling with you can get some quality help :)
Single step by running it with ``perl -d``, then use ``s`` for step, ``n`` for stepover, ``p`` to print a variable.
[Perl commands to list the i stalled modules](https://www.cyberciti.biz/faq/list-installed-perl-modules-unix-linux-appleosx-bsd)
Hi, hard to understand what exacly this thing doing but I modernize/clean the code and add some comments here: [https://pastebin.com/tgFRe4Ut](https://pastebin.com/tgFRe4Ut)
Nice, I like the alternatives. I'm lazy, I just do this: &amp;#x200B; cat &gt; [hello.pl](https://hello.pl) \#!/usr/bin/perl print "Hello World"; \^d chmod +x [hello.pl](https://hello.pl) ; ./hello.pl
so those eyedrops examples leave even Malbolge looking comparatively readable: (=&lt;`#9]~6ZY32Vx/4Rs+0No-&amp;Jk)"Fh}|Bcy? `=*z]Kw%oG4UUS0/@-ejc(:'8dc ... but maybe this article is not intended to encourage new practitioners! (`say`, `print for`, `warn`, variables, syswrite... there are plenty of almost-useful alternatives available, and a typical question on this topic is more likely to be more along the lines of "how can I display this text on a webpage" rather than "how can I make my code look like a coarsely-grated camel")
Making it harder than it needs to be. Just install cpanminus then you can use cpanm. A lot easier to work with
When pasting code on Reddit, it helps to use the Code formatting ("`&lt;/&gt;`" button in the editor - or if using Markdown, you wrap it in `\`\`\`` at the start and end) - this will preserve indentation and use a monospaced font.
&gt;&gt; Either way, P6 is outdated, IMO. &gt;&gt; Lie. Where do I say that? &gt; When a normal person does something like that, and gets caught, and decides to continue to post, they first apologize. I agree, and I apologize sincerely; it was a way too strong statement from me. When I wrote it, I meant in the context of getting (new, young) people to work with Perl (6), not that the language _itself_ is dead. &gt;&gt;&gt; "Many commercial interests will guarantee that Perl 5 continues to be well-maintained and stabilized". And so it is. &gt;&gt; Is it really? Can you document that claim? &gt; Ever hear of booking.com? Or do you never use hotels? Amazon? BBC? Craigslist? Duckduckgo? You hire folk; ever hear of Ziprecruiter? Do you know why I'm mentioning these companies? I thought not. Go find out about Perl before spouting about Perl. I think you misunderstand my point completely. I'm not bashing Perl; I'm a big fan of Perl. My complaint is that it's dying out because no "new people" are using it. It's great that the companies you mention uses Perl in one way or another, but the people at those companies are already employed at those companies, and are probably not after changing jobs. _Which is my point; it's almost impossible to find Perl developers._ I'm not saying that there are no developers out there. Pointing to a recruitment site is also irrelevant. Those are a list of companies _wanting_ Perl developers, not the other way around (which I'm discussing).
I'm not trying to help anyone. I'm just stating the fact. And I'm happy to give you details for _my situation_ as it is in Norway: **I'm _IN_ the local Perl community, and _ALL_ the Perl developers are already employed. There is _literally impossible_ to find "new" Perl developers.** This leads to companies drifting away from _using_ Perl. That is logical, and unfortunate for the Perl community. Do you understand these simple facts?
&gt;I'm not trying to help anyone. I'm just stating the fact. And I'm happy to give you details for *my situation* as it is in Norway: That would be lovely! Next time Oslo Perl Mongers are having a meetup, let's talk! :) &gt;**I'm** ***IN*** **the local Perl community, and** ***ALL*** **the Perl developers are already employed. There is** ***literally impossible*** **to find "new" Perl developers.** Great! Let's meet at [Oslo.pm](https://Oslo.pm) next time. Since you're IN the local Perl community, I wouldn't be surprised we've already met a bunch of times, so it'll be great to meet again! :) With that said, I know of at least 3 competent Perl devs in my local community that recently have been looking, or currently are looking for new opportunities. In addition, I know a bunch of people abroad who would \*love\* to work for a Norwegian employer. Now if you only accept "new" devs (meaning, students or other junior developers), then there's a couple well-tested and documented ways for finding those, which Perl shops I know in both .NL and .UK have used with good success. If you want to learn the details, let's exchange notes at the next [Oslo.pm](https://Oslo.pm) meetup. &gt;This leads to companies drifting away from *using* Perl. That is logical, and unfortunate for the Perl community. Sure, I see the results you're talking about here too, but it seems you're missing the point. The problem is very much rooted in misinformation and ignorance about what options a Perl shop has when it comes to finding talent, and when people like yourself choose to perpetuate the misinformation you aren't really helping anyone. &gt;Do you understand these simple facts? These are not facts, but your limited notion of what's going on. Let's call them "opinions", shall we? ;-)
This is a very frequently asked question. http://www.cpan.org/misc/cpan-faq.html#How_installed_modules https://stackoverflow.com/questions/115425/how-do-i-get-a-list-of-installed-cpan-modules https://www.perlmonks.org/?node_id=868141
&gt; With that said, I know of at least 3 competent Perl devs in my local community that recently have been looking, or currently are looking for new opportunities. You are _still_ missing my point. Do you know of any _companies_ that are looking for these people? Also, do you know of any companies that base their future on _three_ developers? Because, let's face it, the number of new Perl developers isn't growing. There are so many Perl developers - with jobs _as_ Perl developers - who lives in their own little world where they think that "as long as I exist, and I create Perl code, there's a market for people like me." Maybe it used to be like this, but companies are shifting their focus to technologies with a strong people backing behind it. Because programming has become so "easy", there is no longer need for extremely good developers. You only need developers. (Yes, I think most Perl developers are above average developers...) &gt; The problem is very much rooted in misinformation and ignorance about what options a Perl shop has when it comes to finding talent [...] That might be true, but it's also extremely irrelevant. Maybe I'll join the next Oslo.pm. It's been a while since last time. But only if you think Perl will increase in usage by companies over the next year, _and_ can argument why. ;)
There's [Perl &amp; LWP](http://lwp.interglacial.com/) and also [Web Client Programming with Perl](https://www.oreilly.com/openbook/webclient/), both of which are freely available online in their entirety.
&gt; Perl6 has so little momentum that changing the name would basically kill it. From my point of view, I think this is for the better. If Perl 6 is so barely alive, then if the community were to disappear tomorrow nobody would bat an eye. Thus this plays to the advantage of the rename since almost nobody talks about P6 anyway and all the discussions that arise from time to time in the different forums don't focus on its merits but whatever negative connotation its name carries. &gt; *"hey I went googling for perl6 and it looks like it died, no more mention of it after blah blah". * This would make sense because people would be searching Raku instead. &gt; The Racket renaming was very much a top-down effort that was helped by the fact that the previous name (PLT) also had no bearing on the source community (Scheme). I'm not following you here. What would be the source community in the P6 case?
&gt; I agree, and I apologize sincerely That was sufficient to get me to post again. But be aware my patience is shot. I again expect this to be my last post. &gt; I meant in the context of getting (new, young) people to work with Perl (6), not that the language itself is dead. We're collectively working on that. If we're still making no progress in 10 years then I'll grant you have a point. In the meantime I buy the forecasts that there will be more Indian developers than US developers within 5 years. A significant percentage of those millions of devs will want to be able to process Devanagari text. As of right now there is only one programming language available that provides O(1) indexing operations for Devanagari text. A significant percentage will want non-coloring (no `async` keyword), structured concurrency, atop scoped (multi prompt) continuations, that's easy to use (they don't need to know it's those things underneath). A significant percentage will want to be able to glue together modules from disparate languages using inherently high performance polymorphic representation -- and again they won't care one whit about how it does it, just that it does it. &gt; I think you misunderstand my point completely. I'm not bashing Perl; You are, or at least were. You might not think you were. You might think you're just writing facts. But you've mixed up facts, misinterpretation of facts, opinion, and outright bashing even if you don't realize you've been doing so. The facts are great. The rest is at least dubious and has in some instances been egregiously false. &gt; My complaint is that it's dying out because no "new people" are using it. How do you know? Based on what I see I'd guess that there are more new people picking up Perl worldwide every day than all other programming languages in existence today *combined*, with the exception of the top 40 or so. If I'm right then Perl's momentum remains tremendous. &gt; It's great that the companies you mention uses Perl in one way or another You make it sound like they use Perl as a minor activity. They have thousands of full time Perl devs. &gt; but the people at those companies are already employed at those companies And those companies constantly train up new Perl devs. &gt; it's almost impossible to find Perl developers. I'm not saying that there are no developers out there. I asked before but you haven't answered. How many Perl conferences, workshops, or meetups have you attended? &gt; Pointing to a recruitment site is also irrelevant. Ziprecruiter isn't just any recruitment company. They are a global leader with about a thousand employees, with a big percentage of those being Perl devs. And as their site says, as of today: &gt; Based on recent job postings on ZipRecruiter, the PERL Developer job market in both London, GB and the surrounding area is very active. Are you claiming that's just demand, no supply?
My limited experience tells me that nowadays a webcrawler needs a JS engine, as it is so common with pages that load their content with JS. Simply downloading a single page app‚Äôs starting page without executing its scripts wont get much. WWW::Mechanize::Firefox used to solve this problem in a great way, as a crawler could run through a full blown browser, but afaik it‚Äôs not working anymore since mozrepl stopped working. I wonder how people are tackling this problem now?
Depends on the page surely? Everything I‚Äôve scraped has been html.
Selenium https://www.perl.com/article/spidering-websites-with-headless-chrome-and-selenium/
One of the most famous Perl authors, brian d foy soon releases the book called "Mojo web clients". Some time ago he said on twitter that he will give a free ebook in exchage for comments ( [https://twitter.com/briandfoy\_perl/status/1140769897166901258](https://twitter.com/briandfoy_perl/status/1140769897166901258) ) Maybe it is not too late to ask him for a free copy. Or, maybe, it will be worth buying this book when it releases.
Not quite a book, but for a more modern approach than LWP, the [Mojolicious documentation](https://mojolicious.org/perldoc/Mojolicious/Guides/Cookbook#USER-AGENT) should contain enough information to get you started.
Indeed, that's my goal for today. :)
I'm not sure if continued development is planned for it, but jberger's Mojo module for interfacing with Chrome's DevTools looks pretty cool: https://github.com/jberger/Mojo-Chrome It would be nice to extend it or build a higher level interface to provide syntactic sugar for some common operations, a la puppeteer for nodejs: https://github.com/GoogleChrome/puppeteer
For the time being [Test::Mojo::Role::Selenium](https://metacpan.org/pod/Test::Mojo::Role::Selenium) is probably a better choice.
those could be alternative options : 1. [https://metacpan.org/pod/WWW::Mechanize::Chrome](https://metacpan.org/pod/WWW::Mechanize::Chrome) 2. [https://metacpan.org/pod/Firefox::Marionette](https://metacpan.org/pod/Firefox::Marionette) 3. [https://metacpan.org/pod/Selenium::Chrome](https://metacpan.org/pod/Selenium::Chrome) 4. [https://metacpan.org/pod/WWW::WebKit](https://metacpan.org/pod/WWW::WebKit) 5. [https://metacpan.org/pod/WWW::Mechanize::PhantomJS](https://metacpan.org/pod/WWW::Mechanize::PhantomJS) 6. [https://metacpan.org/pod/WWW::Scripter](https://metacpan.org/pod/WWW::Scripter) &amp;#x200B; or you can still able to use it with installing Firefox v54
I never loved RT, but it's a bit sad to see it abandoned. That being said, there's no way that this is the wrong decision, and I commend the team for making the right call!
I used Mojo::UserAgent many times, its really fun to work with it specially getting the results as DOM,XML and JSON pointers and all the async stuff , it really rocks . issues i could suggest to consider on the future addint those features : 1.adding this functionality like www::mechanize [https://metacpan.org/pod/WWW::Mechanize#$mech-%3Esubmit\_form(-...-)](https://metacpan.org/pod/WWW::Mechanize#$mech-%3Esubmit_form(-...-)) like by form number ,form name etc.. &amp;#x200B; 2.adding an option to the new method to use headless chrome as backend which will great option for handling javascript stuff . &amp;#x200B; 3.if the scrapped file is csv to parse it out of the box like the DOM and don't need to install additonal modules like Text::CSV
Regarding the reply by Achim Gratz: https://gitreports.com/
There are also many other solutions like https://fire.fundersclub.com/ or just monitoring the existing email address to open issues.
Brain d foy , i am interested on free copy for exchange comments :) how can i contact you ?
An email would be fine.
Also: Somebody will always be unhappy about something. It is not necessary to make everyone happy. I'm not saying that the point brought up isn't valid. I'm just saying that it doesn't necessarily need to be addressed simply because someone said it.
Python is also moving to GitHub for issues : https://www.python.org/dev/peps/pep-0581/
At last!
What can you say, it's the network effect. I personally never have problems using RT. But perhaps pull request is so convenient.
It's a well-known [symbol of Riga](https://en.wikipedia.org/wiki/Cat_House,_Riga).
&gt; But perhaps pull request is so convenient. I never understood how it could be thought as convenient, considering how convoluted and cumbersome the PR process is, compared to making a simple diff on a working setup and mailing it together with a few explanations (or simply mailing mostly explanations without a real clean patch, because anyway the patch would be rewritten by authors who know the code around in a cleaner and more consistent way than you could ever have done). Stockholm syndrome, or growing up in a closed culture without knowing anything else seem the two most plausible explanations. But it's a matter of principles too: I will never register an account on the "Facebook+Tinder for young webdevs", the basket where every FOSS project find clever to put his eggs in these days; I will rather spend hours looking for any very indirect side channel to get in touch with authors (last bug report I made, I waited for 6 weeks to get validated on an abandoned mailing-list...).
&gt;Hi Brian , &gt; &gt; &gt; &gt;i send you to the email account whcih found on this link : [https://www.oreilly.com/pub/au/1071](https://www.oreilly.com/pub/au/1071) , i will be glad to help with this .
So much difficulty navigating this sight. Maybe it's via mobile but I can't even find any of the actual challenges. And I get a warning that the sight is infected with viruses. I am using Android chrome.
Thanks for the answer both of them good books , i already read Perl&amp; LWP before some years , i was wondering if there are a Perl version of something like this book: &amp;#x200B; [https://www.amazon.com/Web-Scraping-Python-Collecting-Modern/dp/1491985577/ref=sr\_1\_1?crid=3ROTBOGB5RJZE&amp;keywords=python+web+scraping&amp;qid=1561849078&amp;s=gateway&amp;sprefix=python+web+%2Caps%2C297&amp;sr=8-1](https://www.amazon.com/Web-Scraping-Python-Collecting-Modern/dp/1491985577/ref=sr_1_1?crid=3ROTBOGB5RJZE&amp;keywords=python+web+scraping&amp;qid=1561849078&amp;s=gateway&amp;sprefix=python+web+%2Caps%2C297&amp;sr=8-1)
Sorry to hear that but here I list all the challenges made public so far in descending order. https://perlweeklychallenge.org/blog/perl-weekly-challenge-015/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-014/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-013/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-012/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-011/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-010/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-009/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-008/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-007/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-006/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-005/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-004/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-003/ https://perlweeklychallenge.org/blog/perl-weekly-challenge-002/ https://perlweeklychallenge.org/blog/a-new-week-a-new-challenge/
Thank you!
Linus managed the kernel that way for years. After the fallout from BitKeeper, he made git.
I have the opposite perspective: I never understood how mailing a patch can be considered convenient, compared to pushing a branch and clicking a button, or in simple cases typing in the browser then clicking a button. It's compounded in this case by the Perl infrastructure issues that often result in that mail going into the void. But try to remember people have different perspectives and there are good explanations for them.
Why do you need to run a 32 bit version of perl on a 64-bit platform?
I think your best bet is going to be a VM. Running an older i386 based OS in a container like bochs or libvirt will allow you to host the VM on a 64 bit platform. This will allow you to build a service around the module so that you can push data in and out. Depending on the use, it might be easier to take the inputs and outputs and just reverse engineer the code.
can you post the full error ? " it complain about architecture mismatch " have you copied the compiled module code to another machine and are you trying to run it there ?
Yes i tried. it seems it read the platform param form perl
Because somebody thought it would be really great to compile this module .pmc and be sure to run it on an old ubuntu version (12.04). Long story short : We have server that run perl software . Those servers are running ubuntu 12.04 and need to be upgraded. We can't upgrade those server because of all testing beeing done on that specific binary and perl not supported. So we decided as we're stuck on that platform for some of the binary, why don't we use docker for at least remove dependcies on those lib. but docker only support 64bit and perl provide i386 version of perl inside container but not to 5.8. So we're stuck.
Since the pmc file is Perl Bytecode, it might be possible to use the B::Deparse module to turn it in to something resembling Perl 5 source code. Then you'd be able to use a different machine to run it (after debugging it a bit of course).
Glad you like Mojolicious. 1. This comes up every now and then, and we are not opposed to the idea. It's just that nobody has found the right API and implementation yet. There were a few attempts at expanding [Mojo::DOM::val](https://mojolicious.org/perldoc/Mojo/DOM#val) to extract whole forms, but none were good enough in the end. Feel free to open a GitHub issue if you want to push this forward. 2. For `Test::Mojo` there is already [a very good role](https://metacpan.org/pod/Test::Mojo::Role::Selenium) on CPAN. 3. CSV does not come up very often, i think you are the first to request that. :)
you can't just copy binaries and expect them to work Ubuntu 12.04 is not really that old ... or else I am really old :-D try adding i386 support like this [https://www.unixmen.com/enable-32-bit-support-64-bit-ubuntu-13-10-greater/](https://www.unixmen.com/enable-32-bit-support-64-bit-ubuntu-13-10-greater/) you might need to do a "readelf -d yourcompiledscript" to guess at which other libraries you might need to install or like this [https://www.lifewire.com/find-shared-libraries-ldd-command-4017941](https://www.lifewire.com/find-shared-libraries-ldd-command-4017941)
&gt; We're collectively working on that. If we're still making no progress with P6 in 10 years then I'll grant you have a point. Let's talk in 10 years, then. ;)
 git hub clone user/repo cd repo git hub fork user/repo --remote fork git fetch fork git checkout -b fix # do fix and commit git push -u fork fix git hub pr-new
&gt;&gt; I meant in the context of getting (new, young) people to work with Perl (6), not that the language itself is dead. &gt; We're collectively working on that. If we're still making no progress with P6 in 10 years then I'll grant you have a point. I misspoke. New devs are picking up both P5 and P6. Despite the fact that P6 is just 3 years old, and has so much built in it doesn't need modules for much, and can use not only P5 modules but also those of other langs like Python, there are already 1400 P6 specific packages. So we're making progress, though there are things sharply slowing adoption, with performance being the #1 issue despite constant progress on that front. What I meant was if in 10 years we've *stopped* making progress, then I'll grant you have a point about getting new devs on board. That all said: &gt; Let's talk in 10 years, then. ;) Sounds like a plan.
Do you not have access to the source code?
Yes
Coolest thing I've seen all year.
&gt; pioneer (in/of something) ‚Äì a person who is the first to study and develop a particular area of knowledge, culture, etc. that other people then continue to develop This is giving too much credit. [Tavis Rudd is the pioneer.](http://redd.it/1atz8d)
No idea where that HTML comes from, but the error message says "mismatched tag". And the HTML is indeed invalid, because the `&lt;head&gt;` element has the `&lt;body&gt;` element inside it instead of next to it.
You receive some unexpected HTML, not the SOAP XML you want. Just to make sure that's not the fault of SOAP::Lite, try accessing the service with [XML::Compile::SOAP](http://p3rl.org/XML::Compile::SOAP) instead.
This is not a good idea. Not for any particular reason, but because every time the Perl community relied on a corporation instead of outsourcing the service to [NOC](https://noc.perl.org) or other volunteers, we got dicked over. The bigger the corp, the bigger the dick you end up with rearshafts. Now, if you've been paying attention, Github is Microsoft. Anyone but them ‚Äì they are the world champion of shafting their users. I strongly advise the decision makers to: * not do any action before making a technology assessment for the proposed solutions * move RT instance from Best Practical to NOC if BP's willingness to do the needful is not up to snuff * raise more money for NOC so they can keep the software up-to-date * advertise alternative bug submission avenues, e.g. the Web form at https://rt.perl.org/m/ticket/select_create_queue (valid after log-in) * drastically lower the sensitivity on spam detection; it's better to let a few spam mails through and delete them afterwards than having a valid bug submission repressed Pump- and porter-kins, are you receptible to the posts in this thread here? Or are you just going to listen to one mailing list? ---- Grinnz: your presentation so far removed from observable reality, I have to wonder whether you have a hidden agenda or something. Please explain. &gt; The current bug reporting process requires a working mailserver This sounds like a bug submitter needs to run a local mail server. This is not true. Any working email account suffices, can be hosted anywhere. Every software developer has email. I never had a public bug tracker that did not require to sign up first, all of those accepted email, so RT is not more onerous than any other. Github also requires email for sign-up. Hint: when perlbug asks `Action (Send/Display/Edit/Subject/Save to File)`, answer `F`, type "mybug.eml", then * if local email client, double-click the file and press send * or if using Web mail or the RT Web form, paste the body from the file. &gt; persistence to find out if your bug report actually worked There's nothing to persist to speak of. RT sends a confirmation receipt (search mailbox for perlbug-followup@perl.org). The Web form will also show a confirmation. The ticket also appears in the most recent bugs queue. https://rt.perl.org/Public/
My agenda is not hidden: I want people to be able to easily report bugs. This is not currently the case, and self hosting has been deemed insufficient, with years of evidence that it has not worked. Despite you believing you know exactly how to work around the flaws in the system, this does not help random people who do not have the motivation to do so. Additionally, there is no web form for submitting bugs: this was disabled on this instance of RT years ago.
Then just copy the source code to where the binary doesn't work and just run it??? What am I missing here?
\+1 from me. If GitHub/Miscrosoft goes douchebag, we just clone the repo and move to another service. Easy Peasy. Go for it.
OP just said they do not have access to the source code.
Some examples of cases where the RT submission has *not* worked, or the results were inconsistent: - http://nntp.perl.org/group/perl.perl5.porters/254885 - http://nntp.perl.org/group/perl.perl5.porters/254915 This has been raised on the perl5.porters list several times in the past. There are various other benefits from using a proper system rather than the archaic RT interface, such as direct hyperlinks to lines of code or commits and from commits back to the issue. I'm no great fan of github, but moving issues to that system would increase the visibility and availability significantly, and that's a clear benefit for new users.
Also, your URLs look like this `'`[`https://online.gls-slovakia.sk/`](https://online.gls-slovakia.sk/)`'` which looks like a markdown link with extar quotes sprinkled over it. Should just be `'https://online.gls-slovakia.sk/'`.
Consider using the `Text::Glob` module. Manually converting a glob to a regex isn't particularly hard either.
Depends on how you read it. One of those weirdly phrased questions. WIthdrawn.
Other than the good advice already given, to answer your question specifically, just wrap it in a map. perl -MFile::Glob=bsd_glob -le 'my @f = qw(*.wmv *.cfg *.pl *.xpi *.doc); my @m = map { bsd_glob $_ } @f; print for @m'
Thanks. I'm just a little concerned about inconsistency in behavior since I won't be using bsd_glob directly, but I'll test out this option since it should be relatively easy.
Looks like I need to learn `map`. (‡∏á„ÉÑ)‡∏ß
Update: Now that I understand map, I can tell this won't work. `map { bsd_glob $_} @f;` will just return a list of whatever on the current path matches glob patterns found in @f. I really need a function that looks like `list_glob($posix_pattern, @filenames)`
I believe what OP is looking for is something like `matches_glob_pattern( $pattern, @list_of_filenames )` and would get back a list of filenames that match the pattern.
Well I‚Äôm glad I inspired you to read the pod ;-) You were s little light on requirements in your description; I merely answered the question posed *‚ÄùHow do I accomplish this using function y in package x‚Äù*.
Cool. I just visited after a long while and notice all the new "build out" stuff.
I know it's a different language, but have you tried doing it in Perl ^^^^^6 ?
Can you elaborate on what \`Getopt::Long\` doesn't do that you want it to? It's probably my favorite module, and damn near perfect.
Checking afterward if a "required" option was provided makes perfect sense to me, and most of the time it really should not be an option but a regular argument in that case. Getopt::Long removes all options from `@ARGV` (or with the passthrough configuration, only the options it had configured) so that you can shift standard arguments off `@ARGV` afterward. There are lots of alternatives or higher level modules building on Getopt::Long like [Getopt::Long::Descriptive](https://metacpan.org/pod/Getopt::Long::Descriptive) but to me Getopt::Long is already as concise as you can make this sort of general logic.
I usually use Docopt (yes it's a port of python's docopt to perl) for simple CLI. IMO it's better than Getopt::Long::Deacriptive. For complex CLI, like if I need multiple levels of subcommands, MooX::Cmd is very good for that.
Getopt::Long is simple and is in core, that is good. But today's modern CLI libraries allow the developer to easily manage subcommands and options help messages and more.
I have yet to run in to a scenario that `Getopt::Long` didn't handle, but my needs may be more simple than yours. Can you give me a real world example?
Have you ever looked at MooseX::App? It gives you a lot of power validating you command args (including required args and sub commands). For larger command line apps it gives you some nice structure as well by moving code into classes instead of having everything in a pl file (makes writing unit tests much easier as well)
There‚Äôs [Applify](https://metacpan.org/pod/Applify) which a more declarative method of specifying *options*, which can be **required**, have **defaults**, and object types (though the object must be instantiable from a string). Support is also there for subcommands which can take there own set of options as well as globally defined. Documentation is automatic and includes the content of the synopsis section of POD found.
My favourite module to do this kind of things is [Getopt::Lucid](https://metacpan.org/pod/Getopt::Lucid)
here's one: perl somescript.pl somecommand here's another: perl somescript.pl help somecommand
&gt; Also, the pod2usage calls seem unnecessary to do when I always want the same behavior every time I write this. I know I could write this as a module myself, but I'm hoping something already exists. [Pod::Usage::CommandLine](http://p3rl.org/Pod::Usage::CommandLine)
Any program which has commands which support a varying set of options for each one. `App::Spec` does this quite well.
To the person who religiously marks these posts as spam every week: You are wasting your time. None of the moderators will ever act on your reports. These posts are not spam and are very welcome in this group.
&gt;Checking afterward if a "required" option was provided makes perfect sense to me, That makes sense to me, too and is kind of part of the module's name itself. An "option" is, by definition, not required.
Command-line options have evolved to become "parameters", and it's perfectly valid for programs to require certain parameters. The terminology hasn't kept up and made "required option" an oxymoron, that's all.
This is not really "real world", but I encountered this once. I needed to have an option with names like --foo.bar. Getopt::Long doesn't allow it.
Perhaps if you had mentioned that Perl 6 has a built-in command-line option &amp; argument parsing, people would have seen your point?
It's in the link.
I'm with you here, always treated them as switches, ie how it was designed. They are just switches with a payload. I'd rather take it in and handle it so I can control the handler and user experience.
As you say not real world as you are not so much interested in the parameter as much as it's payload. Your example looks like you would be using the payload as the parameter and that will never end well.
This sounds like a great idea to me. I fully support this. The only argument I see against is that it requires a non-anonymous account to submit a bug. That seems REALLY corner case to me. GitHub is the gold standard in OSS hosting. This will be a good move going forward.
FWIW, the link is nearly invisible on oldreddit so I didn't even really understand your comment at first.
Given past discussion and the ratio of upvotes, "very welcome" is a stretch.
Actually I'm not attaching payload to the parameter. The parameter name is structured/hierarchical (\`foo\` &gt; \`bar\`). The value is something else (\`--foo.bar val\`). I had to settle with \`--foo-bar\` and do the mapping manually.
Maybe I meant "very welcome as far as the moderators are concerned" :-)
So... the line noise jokes become sneezing and coughing jokes?
duplicate of http://redd.it/c81pd4
This looks promising, thanks! Do you ever find that this is overkill for simple command line apps?
Wow, this looks very powerful. From the documentation, it looks like this module doesn't allow you to require that an option is passed?
Oh, never mind. Looks like this is covered with the validate method and requires. Thanks!
This looks great. Thanks!
That is a very good find. Thanks!
For me the big one is not being able to specify required parameters. I have to check myself after parsing the parameters that I actually received a value. The process of documentation is also more manual than I would like.
So when you suggest that it should be a regular argument, how would you represent that? You just mean bare arguments on the command line? &amp;#x200B; perl script.pl arg1 arg2 --option1 value1 --option2 value2 &amp;#x200B; Or is there a way to have required named options? Personally, I think that 'option' is a bad name, and really what I want is required arguments or optional arguments. &amp;#x200B; That being said, it looks like [Getopt::Long::Descriptive](https://metacpan.org/pod/Getopt::Long::Descriptive) does treat required this way.
Why doesn't `body` return what you want? All of these objects have documented interfaces.
You can use MooseX::App::Simple which doesn't handle sub commands, but it is still wrapped in a module. I like that for testability. If you really want everything in a single script, and you want to use this module, you can do something like this: ``` #!/usr/bin/perl use strict; use warnings; use v5.12.0; package MyApp; use MooseX::App::Simple qw(Config Color); parameter 'param' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str', documentation =&gt; q[First parameter], required =&gt; 1, ); # Positional parameter option 'my_option' =&gt; ( is =&gt; 'rw', isa =&gt; 'Bool', documentation =&gt; q[Enable this to do fancy stuff], ); # Option (--my_option) has 'private' =&gt; ( is =&gt; 'rw', ); # not exposed sub run { my ($self) = @_; # Do something } package main; MyApp-&gt;new_with_options-&gt;run; ``` That is based on the doc example, and running it with no options gives this: ``` Required parameter 'param' missing usage: test_options.pl &lt;param&gt; [long options...] test_options.pl --help parameters: param First parameter [Required] options: --my_option Enable this to do fancy stuff [Flag] --config Path to command config file --help -h --usage -? Prints this usage information. [Flag] available subcommands: help Prints this usage information ```
[App::Spec](https://metacpan.org/pod/App::Spec) can do that. It was already mentioned but I wanted to add, the documentation is a bit scattered and still incomplete. It only requires one specification and can do subcommands (nested), shell completion, pod generation, help output and validating of options/parameters. But it does not yet support options that depend on each other. disclaimer: Im the author ;-)
http://rperl.org
Nice post.
lolnope. I mean, yeah, there probably is production use of rperl (why else go through all that effort of maintaining it?). But should *you* use rperl in production? Most likely, not. Using niche technology can have awesome benefits, but you pay for it with alpha-quality software, sparse documentation, and a tiny community. For example, there are only two posts on Stack Overflow that even [mention](https://stackoverflow.com/search?q=rperl) rperl. Note also that rperl only translates a Perl subset, and this subset may be too small for your purposes. The easiest way to make Perl programs fast is to profile them (‚Üí [Devel::NYTProf](https://metacpan.org/pod/Devel::NYTProf)), optimize bottlenecks, and possibly port critical sections to C/XS. That path is much better documented, though XS is still difficult enough.
This sort of post is the reason most perl projects continue to be niche and alpha. [Numba](https://numba.pydata.org/) in Python started out quite similar to RPerl, but now has a reasonable user base. But the use case is quite niche generally. Someone had to take that risk and contribute back in production first. Id take something that looks like Perl and only needs documentation for setup, than have to read the XS documentation and learn C to "optimise" my Perl program. Even if RPerl goes tits up the code you have left is viable normal Perl 5. Hiring in the future is the real prod maintenance issue with Perl, not lack of documentation. How many XS and C familiar Perl people exist to hire in any given city in the world? Ones who could make sense of the docs? Id guess the average is less than one. Probably at least one who knows just Perl though.
All the time Perl sucked for me it was because of a couple of nested loops. Perl, like most other interpreted languages, sucks at creating callframes. It is not easy to make a program like that, fast, not even using C/XS. Sometime you will just end up giving iron to your script: use a computing cluster or the cloud to parallelize your calculation.
Look at \b.
You're looking for something like: s/\b\$cat\b/\$dog/g
There's a bit of a difference between ‚Äúshould we experiment with this cool technology?‚Äù and ‚Äúshould we use this fairly experimental technology in production?‚Äù. I don't want to shit on RPerl because the idea of it is fantastic, but if someone thinks they should use it in production then they need a dose of reality. I looked at the Numba website, and it seems to have more corporate backing than Perl itself. My comment is not what keeps RPerl niche, it is rather that RPerl is a niche of the niche that is Perl. That's a bit of a dilemma with all of the Perl11 projects like rperl and cperl, that they are a bit forkish and don't have a path for bringing their cool tech into core Perl. I understand why, but the overall result is a bit rotten for the ecosystem.
I had initially thought something like this might work, but it doesn't work when there is no other text around the variable: my $string = '$cat'; $string =~ s/\b\$cat\b/\$dog/g; say $string; This prints $cat
Actually, even with text around it it doesn't work. I think it's because `\b` matches a non-word character followed by a word character, and `$` is not a word character?
`\b` matches at word boundaries, so there needs to be a word character on one side. `$` is a symbol and not a word character. The regex `/$cat\b/` should work in that case.
When viewing this with javascript disabled I see this: https://i.imgur.com/gujDWmC.png (it seems cloudfare is doing the syntax highlighting?) I thinks it's related to `overflow` on the `&lt;pre&gt;` - I'm not much of a web design person though. Just thought I'd let you know, thanks for the posts.
`"quote " should work too"` is not a valid string value in JSON. The inner double quote must be backslashed.
I know, did you read my whole post?
When passed, the target program won't see the backslash. The backslash (in this case) just says "interpret the next character as a literal part of the string". It gets stripped out before the executed program sees it.
You have to pass a valid JSON object in $env-&gt;{arguments}. This means you have to quote only the inner ": $env-&gt;{arguments} = qq({"text":"quote \\" should work too"});
&gt; The inner double quote must be backslashed. he means you have to do it by yourself b4 passing JSON, there's no other way
I know, but that JSON is generated, I cannot easly modify it. So I cannot modify only inner quote.
Then you must fix the generation. There is no alternative.
Looks like that does work. Thanks!
If it's that way in the generated "JSON", then you need to fix the generator, as it's \*not\* valid JSON.
You've really just got two possible options: \n1. Fix the source so that it outputs valid JSON \n2. Write or modify a JSON parser to allow for invalid formats Getting #2 to work in any safe, reliable, or predictable fashion is going to be incredibly difficult (bordering on impossible).
Compiler::Lexer is not loading. Did it pass tests? Did you get the latest version from cpan or GitHub? There‚Äôs a note in Perl::LanguageServer pod about it.
Ah, I missed that in the documentation. Thanks! Installing from GitHub seemed to fix the issue: cpanm https://github.com/goccy/p5-Compiler-Lexer.git
https://news.ycombinator.com/item?id=20374633
But what if you also have an array called `@cat` (and code that uses expressions like `$cat[1]`). Or a hash called `%cat` (and code that uses expressions like `$cat{foo}`)?
Downvoted for lack of Perl content.
About 30 years ago I wondered what dictionary word contained the most U.S. state abbreviations as substrings. It turned out to be ‚Äú[convallamarin](https://en.wikipedia.org/wiki/convallamarin‚Äù.
&gt;Everyone had some complaint about the oper staff. And absolutely everyone wanted to tell me about it. We held a BOF that ended up mostly being about one person having been banned years prior for behavior that was also banned in the new code of conduct. Reddit electronically delivered folks who don't use the network who wanted to bitch at me about the network. No one really wanted to contribute to the document or the process. Everyone just really wanted to rant at me and/or blame me for years-old grievances. This is not surprising at all to hear, and those are **real** grievances: this level of toxicity is inevitable in any community in which a singular (three char nicknamed) subject is elected to moderate discussions and end up using that power to vent personal frustrations on anybody who not agree with his "latest truth" or some implicit "coc/law of the moment". If confusion and frustration are put in charge of moderation blaming and grievances are the inevitable results for the user community.
&gt; Oh, perl community. Oh boy... Perl community != people attending irc.perl.org.
Sungo. Thanks for doingnanthankless job. You did an amazing job of it. Good luck with the next thing. I will miss you.
The regex can of course be adapted to cover more complicated versions as well, e.g.: s/ (?&lt;sigil&gt;\@) cat \b (?!\{) | (?&lt;sigil&gt;\$) cat (?=\[) /$+{sigil}dog/xg to replace the array @cat with @dog, also taking into account the hash slice `@cat{qw/ a b /}` of `%cat` that should not be renamed. But that's already quite close to the point where regexes are no longer appropriate.
With Perl so rarely in the news these days, it's a pity that such a juvenile diatribe got there, Perl6 continues to discredit itself, also hurting Perl in the process, but we got used to that, haven't we. As for the rant itself, no, there's no "hate", people just don't care, you still haven't proved why they should care, the language is not ready for anything besides blog posts showing off its expressiveness, mad syntax gymnastics, and (hateful) straw-man sarcasm. Apart from this, the language is unable to bootstrap itself to industry requirements, such a completely specced language that can not be made to perform reasonable is rarely useful in the industry. It can continue to be a magic oddity in some academic circles and for people interested in language design, but that's about the whole user base. No, stealing another language's brand for this bootstrap does not work, it just kills both, as seen in the past decade+.
When I tried using post( $endpoint )-&gt;res-&gt;body last week, I got an error stating that the method 'body' either wasn't valid or wasn't found, which sent me on a wild goose chase. No idea what was happening. Today post( $endpoint )-&gt;res-&gt;body is working fine so I guess I was having a mental breakdown last week. Thanks for your reply.
Considering the network has been entirely pleasant for the past several years, and said "three char nicknamed" person is still in charge, it does imply there is more than one side to this story.
No, but people on irc.perl.org are part of the Perl community.
Sungo, thank you. I left for similar feelings a few years back. Thank you for voicing it as well as continuing for so long.
If people genuinely don't care, why have so many gone out of their way to leave ranty comments on HN? I have a pretty good idea of why, but I'd rather not get flamed by HN people. Exactly what "(hateful) straw-man sarcasm" are you talking about? I've seen very few inflammatory blog posts written by Perl 6 users, and all of those are responses to the apparent "split" in the Perl community over Perl 5 vs. 6. I, too, wish that a decision was made earlier to drop the name "Perl 6." It's confusing and angering everyone, and I totally agree with you there. But there's just no changing the name now, because that would cause even more confusion and probably totally destroy the wonderful language entirely. The problem with Perl 6 is people like those on HN being so unwilling to give it a serious try and let go of the "programmers are terrible and should be restricted" mindset of Rust and Python. If it's hard to find Perl 6 developers, you're obviously not going to see many companies adopting it. Which is a shame, because it really does bring an awesome concurrency model to the table, and of course grammars as well. And first-class support for rational math. And best-in-the-world Unicode support. And improved Regexes. And sane OO. All the things the industry will need moving into a concurrent and Unicode-enabled future. But I digress.
Does RT stand for [Request tracker](https://bestpractical.com/request-tracker)?
Yes. Instances of it are used for the [Perl core](https://rt.perl.org) and as the default tracker for [CPAN](https://rt.cpan.org) distributions; this is just about the former.
Oh, and if you're alarmed that the accusations aren't stated I'll save you the time: at 34:00 of [https://www.youtube.com/watch?v=ZM-KHZJpy84](https://www.youtube.com/watch?v=ZM-KHZJpy84) he mentions the long ago abandoned Pugs project and cites the Pugs authors name as "Autrijus Tang or Audrey Tang" in a manner not dissimilar to the wikipedia entry: [https://en.wikipedia.org/wiki/Audrey\_Tang](https://en.wikipedia.org/wiki/Audrey_Tang). In all fairness to Will the author went by Autrijus Tang during the time of the Pugs project and he said nothing inaccurate. This is not different than saying "Bruce Jenner" won an Olympic medal. &amp;#x200B; I am disgusted by TPC's hysterical over reaction to a complaint made weeks after the original talk by some internet rando. That Mr. Braswell's good name be besmirched by TPC's post in which the accusations are not even listed for objective evaluation by the reader is disgusting and he is owed an apology.
Although I seldom frequent the IRC channels, thanks for all the work you put in.
https://youtu.be/ZM-KHZJpy84?t=2037 "Audrey Taaang, Autrijus Tang, also depending on who you ask or how you pronounce it. Mister... Miss Tang had...." FWIW, knowing Will a little longer, it feels like an insensitive attempt at humor, expanding on /repeating what he said just before that about Haskell: https://youtu.be/ZM-KHZJpy84?t=2031 . Insensitive, yes. Showing ignorance about what it means to be transgender, yes. Worthy of removal from the play list? That's up to the organizing committee. I can understand this decision in the light of the current LGTB+ unfriendly policies of the US government. Had this not been the case, I personally would have left it in, because if anything, it shows the ignorance of the speaker in how to deal with people deciding to follow up on their true gender. And as such an example of how **not** to do it. Personally, I find the usage of "Saint Larry" much more offensive. Sainthood is only given to people who are dead, and Larry is not dead. The use of "Saint" in this context, to me implies that he is. And **that** I do find very offensive. Especially since Larry was actually attending this presentation. So all in all, I'm not sorry this presentation has been removed. But I feel it has been removed for the wrong reason.
lol no. saint does not mean "dead" (it's very much alive even in religious terms where's there's no distinction between the dead and the alive). but just google for saint ignucius. it's a form of flattery, i can't imagine the depth of this alternative reality where "saint" is pejorative. no comments regarding the required punishment of subjectively identified insensitivities, which are by *necessity* of bad intent, that's even more ridiculous.
lol no. saint does not mean "dead" (it's very much alive even in religious terms where's there's no distinction between the dead and the alive). but just google for saint ignucius. it's a form of flattery, i can't imagine the depth of this alternative reality where "saint" is pejorative. as for the required punishment of subjectively identified insensitivity, which is *by necessity* of bad intent, that's even more ridiculous. but the US government policies! ok, nevermind. :)
saint | se…™nt, s(…ô)nt | noun 1 a person acknowledged as holy or virtuous and regarded in Christian faith as being in heaven after death: a place dedicated to a seventh-century saint | figures of apostles and saints. ‚Ä¢ a person of exalted virtue who is canonized by the Church after death and who may be the object of veneration and prayers for intercession: Innocent III stressed that only the Pope had the authority to declare a saint. ‚Ä¢ (Saint) (abbreviation St or S) used in titles of religious saints: the epistles of Saint Paul | St Mary's Church. ‚Ä¢ (Saint) a member of the Church of Jesus Christ of Latter-day Saints; a Mormon: Smith began to cast around for uninhabited territories where the Saints might build their Kingdom. ‚Ä¢ (in biblical use) a Christian believer: the poor saints which are at Jerusalem. 2 informal a very virtuous, kind, or patient person: she's a saint to go on living with that man. I'm pretty sure Will referred to the first meaning.
did you ever call someone a "saint" ? did you ever think along the lines of *oh, that person is a saint, i swear* !? did it mean dead ?
Maybe just work with Will to do some light editing, put the edited presentation back on YouTube and remove that blog post?
Yes, I have. But I have never called someone called Joe, "Saint Joe" all of the time. Unless that person was actually determined to be a saint in the religious sense. So I find the usage of "Saint Larry" to be at least a showing of really bad taste, with Larry being a deeply religious person. And Larry is saint enough to never make that an issue, but I think he is definitely not happy with the "saint" designation.
Yeah, the "Saint Larry" thing always seemed very strange to me. Either you're religious, in which case there's a good chance you'll be offended by the misuse of the word or you're not, in case it's just a pointless title to use. And it seems dangerously close to making the Perl community sound like a cult.
Almost ten years ago, having not been on #perl for years prior, I popped in to say hi. I was immediately banned, for literally just joining the channel. Sungo supported that ban, and it has remained in effect since. I have a hard time accepting the finger-pointing at ‚Äúother people‚Äù for problems with the ‚Äúcommunity.‚Äù \*shrug\*
Also considering, to my knowledge, Larry _IS_ religious, it seems in poor taste.
This is the standard of conduct working. Since you want to focus on what this means about Will: This is not a moral indictment of him. He made a mistake. Sometimes people make mistakes. There's no reason to keep the video up displaying that mistake to the entire Internet. Me, I'm more concerned with what this means to Audrey Tang. For that reason, the video should remain down. Listing the exact issues with the video is spreading the problem, not fixing it. It doesn't matter that you want to be able to use exact words to discredit the reasons for the video's removal: The point is de-escalation (and here you are escalating). You do not get to decide whether the reaction is appropriate or excessive. That is the job of the standard of conduct. The standard of conduct explains what an infraction is (and this clearly qualifies, despite your opinion) and what actions will be taken in the event of an infraction. From a broader standpoint, since you care about the Perl community (your comment here is, I assume, an attempt at demonstrating this): Leaving the video up would be telling transgender people that they may be misgendered or otherwise treated insensitively if they come to The Perl Conference. It would be telling them that they are not welcome at The Perl Conference. For that reason alone, it has to be removed.
So you're saying that the community is not allowed to discuss the details of the accusation? You can't be serious!?!? Further, you somehow believe that the SoC is some immutable all powerful entity? That once set in place cannot be questioned or even refined? I don't think I will be responding further to your posts. You're clearly some sort of autocratic imbecile.
He didn't say any of that; obviously the community is allowed to discuss whatever it wishes and the standards of conduct can be refined. That doesn't really have anything to do with this incident. It is funny that you end your post that way after diatribing about allowing discussion.
I've removed a post because it contained a personal attack, along with the reply to it that would lack context but was otherwise acceptable. Keep things civil and polite.
Sainthood is a Roman Catholic thing and I don't think (though I could be wrong) any other Christian religion votes people to sainthood. The Bible calls EVERY believer a saint.
Sounds very reasonable to me.
For the record, I think it‚Äôs acceptable. I‚Äôm post-gender (my gender is officially ‚Äúwhatever‚Äù) and the speaker did include both feminine and masculine forms. While I can see the ‚Äúdepending on who you ask‚Äù part may be construed as disrespectful by the Perl Foundation, considering I still hold the [AUTRIJUS](https://metacpan.org/author/AUTRIJUS) cpan account (which is dormant but not exactly dead), I‚Äôm fine with it getting re-published on YouTube.
Reading through the comments, you seem pretty confident about what's going on in other people's minds. Pretty sure that "Will referred to the first meaning". Think that Larry ¬´is definitely not happy with the "saint" designation¬ª. It might be interesting to hear from first sources. I didn't see the removed video but looking at the slide in the other video that you linked (thanks for that by the way, gives more context to this whole thread!) my personal reaction was that he tries to celebrate Mr. Wall for taking the burden of coalescing a lot of "previous" tools into a legacy that goes under the collective umbrella of Perl. At the end of the day, this whole thread and discussion teaches me time and again that things that would be "fine" for me aren't necessarily OK with other people, and that the contrary might apply as well.
What if a category or property contains quotes?
they wont, thats guaranteed in input
Why must it be a one liner? Writing this as a short Perl script would not be especially hard and would be much easier to maintain than "&lt;someNextLevelRegex&gt;".
I agree. A script could have been written in the time it took to write this post. I appreciate "code golfing" from a theory standpoint but if it's something you are actually using it's better to have something more maintainable.
Tried some years ago. My experience was that the tool chains work for something like 80% of the modules I encountered. CPAN is full of TMTOWTDI, yo. Anyways, with docker and CI, you can just install the latest and greatest using cpanm in the Dockerfile and then run your test suite on the image to make sure everything works together.
Alternatively, Carton is a step higher which can pin versions and bundle tarballs which works well in docker-type deployments.
I know this probably isn't what you're looking for, but for the most part we've automated most of this using yum.
I did this and it works about 95% of the time, but I had to pay a steep price to get from 80 to 95. Don't open up the code in an editor unless you want to vomit.
Ugh. I'm not really very happy with how this turned out because it is really inelegant and awful looking. I think if anything it demonstrates why u/grantmnz was right -- it really should be just a short and simple script, as a one liner it's just too awkward: perl -a -l -n -e 'BEGIN { our $line = "" }; sub p { $line =~ s/^\s+//g; print $line; $line = "" }; p() if ($line &amp;&amp; $F[1] eq "CATEGORY"); shift @F; pop @F if $F[$#F] =~ /^\s*;\s*$/; my $j = sprintf qq{ %s "%s"}, shift(@F), join" ",@F; $line .= $j; END { p() }' file.txt
Plus, a script is a lot easier to step through in the debugger when the output is *almost but not quite* right, to watch how your assumptions meet your realities.
Echo what everyone else says ‚Äî don‚Äôt do this as a one-liner. But if you must, here‚Äôs my version: % cat in.txt | perl -lanE ‚Äòshift @F; if ($F[0] eq ‚ÄúCATEGORY‚Äù) { push @o, ‚Äú‚Äù } else { $o[-1] .= ‚Äú ‚Äú; pop @F } $o[-1] .= sprintf(qq{%s ‚Äú%s‚Äù}, shift(@F), ‚Äú@F‚Äù); END { say join(‚Äú\n‚Äù @o) }
Or, riffing on /u/hacklinuxwithbeer 's suggestion which use of a sub is a bit more elegant: % cat in.txt | perl -lanE 'sub p { $l &amp;&amp; say $l; $l = "" }; shift @F; if ($F[0] eq "CATEGORY") { p() } else { $l .= " "; pop @F } $l .= sprintf(qq{%s "%s"}, shift @F, "@F"); END { p() }'
https://twitter.com/perlcon/status/1149258863880867840
TIL Perl6 can be written san sigils! Punctuation free Perl for the win (though I am a fan of sigils not requiring them is a big deal.) Would be nice to have a pragma? to turn off sigils instead of using '\' before each variable declaration.
This feels more like a Slang to me. However, making sigils completely disappear would be difficult, e.g. in a class definition: class A { has foo = 42; # is this a public or private attribute? }
There are currently 720 "Saints" shown on perlmonk's [Saints in our book](https://perlmonks.org/?node=Saints%20in%20our%20Book), Most of them are alive. Can we possibly ask Larry himself or at least other religious persons instead of assuming that he/they might be offended?
We did have a repeated ban/k-line evader for a bit with an original nick of 'markoong' and assorted variations on it that pretty much always preserved 'm' 'k' and 'g'. You may remember him from such hits as "utterly derailing #perl-help with an extensive rant about how evil McDonalds is". Or not. I'd tried to forget, tbh. -- mst
Salute, and good hunting. I'll try not to be a completely incompetent replacement. With a bit of luck and a following wind, I might occasionally even succeed. -- mst
Here's an approach that does a temporary chdir() inside perl and then uses Capture::Tiny to avoid needing to go via the shell in the first place. use File::chdir; use Capture::Tiny qw(capture); my $output = do { local $CWD = '/home/user/system/!project/_addons/Ext/PHPtest'; capture(qw(docker run --rm -v), "${CWD}/app", qw(-w /app PHP PHP), $env-&gt;{arguments}); }; -- mst
I have enough problems with Windows and \ as it is, if they wanted to go that way why not declare with a sigil then usage can be either with or without, errors for misuse and out of scope would be as easy as today. If the compiler can lose a variable that easily with or without a sigil we are all in trouble. My pennies worth would be to keep them though, for me it makes for a better read but that is no more than personal preference, if it's a pragma fine I just wouldn't use it
Looks like the Europeans have more sense than the Americans these days.
Especially these days
&gt; However, under no circumstances should non-technical staff ever ask technical questions. This is simply unacceptable. They don‚Äôt have the knowledge to evaluate the answer. And if you do this eventually [someone will write a really scathing blog post mocking your company](http://www.gwan.com/blog/20160405.html) that will [be shared on Hacker News and everyone will make fun of you](https://news.ycombinator.com/item?id=12701272) and you‚Äôll be sad. I laughed myself silly at this because it's oh, so true.
My final thoughts on this matter: [https://liztormato.wordpress.com/2019/07/13/on-crime-and-punishment/](https://liztormato.wordpress.com/2019/07/13/on-crime-and-punishment/)
Bravo! Well said, by someone who understands these situations better most.
I appreciate the clarity provided to the situation. But there is one thing missing. Andrew Shitov made a mistake. We all do it, and I don't think it was malicious. I believe he knew it was a mistake as it was subsequently removed. But he refused to acknowledge it for days afterward, deflecting and attacking those who pointed it out. This reflects poorly on the conference as this series of dialogues involved official communications. I don't think anyone involved wishes Andrew to suffer for his mistake. I just wish for him to acknowledge a mistake was made and show willingness to understand why it was a mistake.
Tau Station - https://taustation.space/
Not disagreeing but a few things to consider Most languages are heading towards a lowest common denominator of letting anyone code through well structured code, not a bad thing but you are never going to attain greatness. Code needs to be smart and efficient as Moore's law is dead so making code run faster is the name of the game, most frameworks are more focused on stability. Perl is a language like any, it's more of a language that is learned than taught, that's a big reason why it's not taught and as such it if favor. Speed is a relative thing, if it does what it needs to in the timeframe acceptable then it's right. It just needs to be fast where it needs to be fast. I'm in the process of writing a devops, test harness and etl system all in Perl, all fast enough and all doing things that the commercial systems it is competing with can only dream of. Not bad for a dead language. As for readability and supportability, if you can't read it and work it out with today's ide, debugging and profiling tools then you have a choice, learn how to program or find another job. Everyone can drive a car but only a few can do formula 1. Code is the same Yes I'm looking at Perl 6, no it's not there yet but I'm starting to use it
Could we have something other than lousy internet drama (be it the new SJW style, the (never getting) old personal rancour style, or a mix of both) posted on this sub or is it going to continue on the last path as the previous posts and be like this all summer long?
That's a big player. And Ovid's talks on their development are very interesting too. Thanks!
It's incredible sad that Liz feels the need to write such a personal and vulnerable post to defuse a situation that completely grew out of proportion. Fantasy will fill in unknown facts and no one will feel safe, just the opposite. Did Andrew made a stupid and insensitive joke? Yes. Did he target anyone or a specific group of people with it? No. Was he the original offender of the SoC violation? No. Did Andrew immediately acknowledged the SoC violation at an *other* conference and presented a plan of action? Yes. Could Andrew's and TPC's communication have been better? Yes. Would it have been more effective to talk friendly and privately to Andrew instead of talking about boycotts and defunding the conference by lobbying the sponsors? What do you think? I don't think the Perl community realizes in what state it is today and how a possible departure of people like Liz and Andrew will have repercussions that you don't need to be clairvoyant to foresee. (PS: loved the Dostoevsky reference)
https://www.nationstates.net/
&gt; (PS: loved the Dostoevsky reference) I think it's unfortunate. A CoC violation isn't a crime, and a poorly considered response isn't a crime. No one is seriously accusing the violator or the Perlcon organizer of a crime. Claiming they are derails the whole situation. Andrew's not being persecuted and he's certainly not being prosecuted.
Frozen Bubble is written in Perl.
FWIW, to me that *was* the reason for choosing that title. Because people were ready to persecute it as a crime.
The Lacuna Expanse [https://github.com/plainblack/Lacuna-Web-Client](https://github.com/plainblack/Lacuna-Web-Client) [https://github.com/plainblack/Lacuna-Server-Open](https://github.com/plainblack/Lacuna-Server-Open) [https://github.com/plainblack/Lacuna-Assets](https://github.com/plainblack/Lacuna-Assets) [https://github.com/plainblack/Lacuna-Mission](https://github.com/plainblack/Lacuna-Mission)
This is something I wrote a gazillion of years ago :) http://di.unipi.it/~nids/docs/minesweeper.html Let me know if you find it useful!
&gt; people were ready to persecute it as a crime Can you give three specific examples?
That game has wicked depth. Not what I expected at all.
Keno Antigen now, but development frozen
Yes, but I won't.
Oh, this actually looks really cool. Took me a while to find confirmation that this was written in Perl, but I found it here: [https://maxbarry.com/about.html](https://maxbarry.com/about.html) &gt; All the code behind MaxBarry.com and [NationStates.net](http://www.nationstates.net/) is in Perl. Thanks!
This is great. Fully-finished personal projects sometimes feel like a rare find. Thanks a lot!
Yeah. I learnt perl to help build that site and contributed code to it for somewhere around a decade.
Indeed! The first game I ever played written in Perl, that's for sure. Thanks!
Happy to hear that you're digging into this. Feel free to ask any questions you like. The only questions I won't answer are those that given away secret gameplay elements. (Unless I get too tired and need to head to bed) :)
Oh, how can I pass up an opportunity like this? :) Is Tau Station your first attempt at writing a game in Perl? How has your experience been? From the examples mentioned on this thread (other than Frozen Bubble), the most successful ones seem to be browser-based role-playing games. Why do you think that is? And were you aware of these other ones when you started?
Impressive. I had never heard of this one, but it seems like it was pretty big. It even had a table-top board game at one point it seems: [https://www.thegamecrafter.com/games/lacuna-expanse:-a-new-empire](https://www.thegamecrafter.com/games/lacuna-expanse:-a-new-empire) Thanks!
I met him twice. He was old. Eclectic. I never was an autograph collector, but I could see him doing it at a signing event. In person, I suspect a sharpie. Then again, the last time I shook his hand was 2002.
I only met him once and he avoided me when I tried to talk to him. He didn't seem friendly :( Maybe he was friendly and I'm an idiot, no idea.
"No estamos obligados a castigar a los que nos ofenden, sino a aconsejarles la enmienda de sus delitos". Miguel de Cervantes. (We are not obliged to punish those who offend us, but to advise them to amend their crimes)
Tech celebs like Larry have a lot of people vying for their attention... I think they can get a little harried sometimes.
I suppose. I live really close to him and I still code heavily in Perl. I've always secretly wished I'd run into him at the grocery store or at the mall or something so I could just say hi again ;-)
&gt; Is Tau Station your first attempt at writing a game in Perl? Nope. Years ago when I wrote [AI::Prolog](https://metacpan.org/pod/AI::Prolog#AUTHOR), a Prolog interpreter written in Perl, it included [sleepy.pro](https://metacpan.org/source/DOUGW/AI-Prolog-0.741/data/sleepy.pro) and [spider.pro](https://metacpan.org/source/DOUGW/AI-Prolog-0.741/data/spider.pro), two small text adventures written in Prolog, but that you could run in `AI::Prolog` (I ported them, not wrote them). I also wrote [scott.pl](https://github.com/Ovid/scott-adams-games), a pure-Perl driver for text games written in the Scott Adams format. [I bundled many games with it](https://github.com/Ovid/scott-adams-games/tree/master/games) (with Adams' permission). Unfortunately, [there was a showstopper bug I encountered](https://github.com/Ovid/scott-adams-games/issues/1) and never quite had the time to solve. My intent was to fix that bug and start refactoring the awful code (it was a straight port of the C code), to something modern and extensible, but still backwards-compatible. Never had a chance to finish that. &gt; How has your experience been? It's been fantastic. I work with an awesome team and I've learned huge amounts about scaling, [writing cleaner code](https://blog.taustation.space/blog/on-writing-clean-code/), and new approaches to maintaining large-scale codebases. We've also given back by [releasing some code as opens source](https://blog.taustation.space/blog/building-a-universe-with-open-source-code/). One of my favorite parts of Tau Station is the code we call "economic exchanges" (needs a rename) that I would love to be able to open source and give to the Perl community because it's made it much easier for us to write code for [DBIx::Class](https://metacpan.org/pod/DBIx::Class) that is heavily scalable, easy to read, and even easier to write. Sadly, it currently uses too much of our internal business logic, so this is likely not possible any time soon. However, here's an example: my $exchange = $self-&gt;new_exchange( Preamble( 'deposit' =&gt; { amount =&gt; $amount } ), Steps( Money( $self =&gt; remove_from_wallet =&gt; $amount ), Money( $self =&gt; add_to_bank_credits =&gt; $amount ), ), ); I don't think think I need to tell you what that does, even if the syntax is unfamiliar. It's easy to read, declarative, locks everything in the correct order to avoid database deadlocks, handles transactions transparently, handles sending messages to players behind the scenes If it fails, it knows how to do the right thing, including sending error messages.. In short, it's a powerful tool for writing reusable logic. I just wish it wasn't so tightly integrated into our code or else we could release it. &gt; From the examples mentioned on this thread (other than Frozen Bubble), the most successful ones seem to be browser-based role-playing games. Why do you think that is? Many (probably close to 20) years ago, I asked P5P why Perl didn't include a native GUI module. I was told (iirc) that it was because nobody wanted to maintain it. Python has long included [tkinter](https://docs.python.org/3/library/tk.html#tkinter) by default. You also have Gtk, Qt, and wxWidgets as major options, and [many lesser-known options](https://wiki.python.org/moin/GuiProgramming). Java back then was also a popular tool for GUI programming (well, it still is), so if you needed to write GUI applications, especially for the enterprise, Perl was simply not an option. It never has been (I've always found our GUI tools clunky and hard to install). However, Perl is very strong in text manipulation and that is the overwhelming amount of what the Web is. Thus, games for Perl will likely play to its strengths: text. &gt;And were you aware of these other ones when you started? I was aware of those other games. However, when I created [Tau Station](https://taustation.space/), I wanted to build a universe people could "live" in. Even people who like chess would never think of living in the world of chess because there's no world there. However, plenty of people who play World of Warcraft would love to live in Azeroth. So that's what drove me: creating a rich universe with a detailed story that many people could live in at the same time.
The title of this article is incorrect. The syntax under discussion (`my $foo = 1 if 0`) has been deprecated since Perl 5.10 (in 2007). After twelve years of warnings, this syntax now generates a fatal error.
I've definitely seen him do this. I'm pretty sure he was still doing it last year in Glasgow.
And the article itself is old (and I think already posted on this sub previously).
Google images pulls up some results for "larry wall signed book". Here's one that shows the camel stamp and the "There's More Than One ..." stamp you mentioned: http://xahlee.info/UnixResource_dir/writ/wall_stallman.html I typically carry silver, gold, blue, and green sharpies for book signings. I never had a stamp. I've seen Larry's kit a few times and it had various colors in it. O'Reilly used to give out book plate stickers that authors could sign then send to people. For [Effective Perl Programming](https://www.effectiveperlprogramming), I extracted a page from the PDF, added a signature, and would send that to people so they could replace that page in their PDF.
&gt; Did Andrew immediately acknowledged the SoC violation at an other conference and presented a plan of action? Yes. A plan of action that doesn't acknowledge the harm done is not something to be celebrated (or even, really, a plan of action). &gt; Would it have been more effective to talk friendly and privately to Andrew Andrew's communication was not only public but official communication in the name of the conference he is helping to organize. Private objection to a public statement is, to an audience, exactly the same as no objection. &gt; I don't think the Perl community realizes in what state it is today I think we're all well aware what state the community is in. I hear about it all the time, largely from folks who admit they aren't doing anything about it due to various reasons. Which do you think will help the community more: Being as inclusive as possible or keeping people who make inclusivity more difficult? Is exclusive the opposite of inclusive? Should the community weigh the contributions of members of the community that will not tolerate anti-trans remarks against those that will to decide whose contributions are worth more? Is this really how the community should make decisions about whose behavior is to be tolerated in community spaces? I'm still learning how to be a better person. I believe we all are, always. But, in situations like this, we all need to make extra effort to demonstrate that we're learning. We need to show what we've learned. Without that, we can't start to move on. Someone involved needs to show that they understand what the problem is and what they are planning on doing to prevent it. Without that, what is a community supposed to do?
[https://imgshare.io/image/img-1122-2.avHa5](https://imgshare.io/image/img-1122-2.avHa5)
\&gt; I have been using this deprecated syntax liberally Should have never used it in the first place, it's an antipattern.
I'm curious why I can't reproduce this.. I'm pretty sure I've used this pattern at some point, though I can't find the code now. But: $ cat test use strict; use warnings; print "Perl version [$^V]\n"; my $foo = 1 if 1; my $bar = 1 if 0; printf "foo is [%s]\n", defined($foo) ? "defined" : "undef"; printf "bar is [%s]\n", defined($bar) ? "defined" : "undef"; $ /usr/bin/perl test Perl version [v5.18.4] foo is [defined] bar is [undef] $ /usr/local/Cellar/perl/5.30.0/bin/perl test Perl version [v5.30.0] foo is [defined] bar is [undef]
It only covers certain cases, namely without the assignment, as mentioned here. https://rt.perl.org/Ticket/Display.html?id=133543#txn-1599917
It's good to see this awesome tool being used in a post-mortem of a major tech company.
About time. KDE's konsole has been supporting 24bit color since what, 2007-2008?
[http://blogs.perl.org/users/lets\_code\_perl/2019/07/tpf-perl-deserves-better-please-do-better.html](http://blogs.perl.org/users/lets_code_perl/2019/07/tpf-perl-deserves-better-please-do-better.html)
Great write-up. War stories, diagrams, textbook material, citation to a journal article, visualization (ft: Regexp::Debugger)... it has them all.
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
[2006](https://cgit.kde.org/konsole.git/commit/?id=f34d82034281a6a2eeef1b1a809f092f72d2b2de)
An anonymous rant full of opinions being presented as facts is barely worth replying to.
This is an advertisement pretending to be a useful comparison.
Here's the offending regex (PCRE in Lua), which the author reduces to the core problem of pathological backtracking with those `*` quantifiers. PCRE used to mean, at least in my mind, that other languages could use Perl's regular expressions. Since Perl has moved much further in its own patterns, PCRE now means that Perl will understand the pattern. More on that latter: (?:(?:\"|'|\]|\}|\\|\d|(?:nan|infinity|true|false|null|undefined|symbol|math)|\`|\-|\+)+[)]*;?((?:\s|-|~|!|{}|\|\||\+)*.*(?:.*=.*))) And, here is is expanded with insiginificant whitespace. It's that last group of interior parentheses that hold that problematic backtrackers: (?: (?: \" | ' | \] | \} | \\ | \d | (?: nan|infinity|true|false|null|undefined|symbol|math ) | \` | \- | \+ )+ [)]* ;? ( (?: \s | - | ~ | ! | {} | \|\| | \+)* .* (?:.*=.*) ) ) Because I don't know why they wrote this or what text they were trying to match, but I think this probably doesn't match the target text exclusively. For example, I don't think that the first set of interior parentheses (with the long alternation) intends to match several consecutive quote characters. Maybe is does, but it sure looks odd. The alternations are odd because much of them collapse into character class. Initially I thought that the regex author didn't know about character classes, but there's a trivial character class (`[)]`) to match zero or more closing parentheses. Inside the alternations, the regex author escapes special characters, so they know how to do that. (?: (?: ["'\]}\\\d`-+] (?: nan|infinity|true|false|null|undefined|symbol|math ) | \` | \- | \+ )+ [)]* ;? ( (?: \s | - | ~ | ! | {} | \|\| | \+)* .* (?:.*=.*) ) ) I started writing this thinking I'd tighten up the regex, but halfway through it I think it's hopeless. Here are some strings that it matches: "= ""= """""= "'"= nullnullnullnull= ')));= You need something from the first alternation and at least the `=` from the last interior parentheses. The regex might cover the interesting input, but it does quite a bit more. How likely are you to match `)=` in acceptable text, for instance? These might be part of a larger pattern they haven't shown, but who knows? I'd be surprised if any of these matching strings are meaningful to the problem. However, they also mention that they are reacting to attacker tools that are fuzzing things.
Here's the offending regex (PCRE in Lua), which the author reduces to the core problem of pathological backtracking with those `*` quantifiers. PCRE used to mean, at least in my mind, that other languages could use Perl's regular expressions. Since Perl has moved much further in its own patterns, PCRE now means that Perl will understand the pattern. More on that latter: (?:(?:\"|'|\]|\}|\\|\d|(?:nan|infinity|true|false|null|undefined|symbol|math)|\`|\-|\+)+[)]*;?((?:\s|-|~|!|{}|\|\||\+)*.*(?:.*=.*))) And, here is is expanded with insiginificant whitespace. It's that last group of interior parentheses that hold that problematic backtrackers: (?: (?: \" | ' | \] | \} | \\ | \d | (?: nan|infinity|true|false|null|undefined|symbol|math ) | \` | \- | \+ )+ [)]* ;? ( (?: \s | - | ~ | ! | {} | \|\| | \+)* .* (?:.*=.*) ) ) I don't know why they wrote this or what text they were trying to match, but I think this probably doesn't match the target text exclusively. For example, I don't think that the first set of interior parentheses (with the long alternation) intends to match several consecutive quote characters. Maybe is does, but it sure looks odd. The alternations are odd because much of them collapse into character class. Initially I thought that the regex author didn't know about character classes, but there's a trivial character class (`[)]`) to match zero or more closing parentheses. Inside the alternations, the regex author escapes special characters, so they know how to do that. I started writing this thinking I'd tighten up the regex, but halfway through it I think it's hopeless. Here are some strings that it matches: "= ""= """""= "'"= nullnullnullnull= ')));= You need something from the first alternation and at least the `=` from the last interior parentheses. The regex might cover the interesting input, but it does quite a bit more. How likely are you to match `)=` in acceptable text, for instance? They also mention that they are reacting to attacker tools that are fuzzing things. These might be part of a larger pattern they haven't shown, but who knows? I'm guessing they don't match against an entire HTTP request. Still, I'd be surprised if any of these matching strings are meaningful to the problem.
There's something to be said for training and preparing staff to handle complaints about harassment or abuse. There's much more than simply designating the chain on people who will handle your event. It's not something you can just make up and iterate. You tend to think that handling them should be simple (how hard can it be?) until you actually handle your first one. No matter what you do you, someone thinks you are doing it wrong.
I don't know the details on this story (because they have been concealed) and won't comment on that. But I agree with everything Liz said, especially that the facts must be made public, so that anyone who cares can make her or his own opinion based on facts and not on hearsay or gossips. And I agree that the names of SoC committee members should be known in advance, so that any potential offender will not be lynched or judged in absentia by a self-appointed anonymous group. Any defendant has the right to a fair trial and the assistance of lawyers. Thank you, Liz, for your blog post.
This is a weak article, full of speculation and hyperbole. &gt; The speaker is removed from speaking at other Perl conferences Exaggeration. &gt; Given that no one in the audience, and no one who was mentioned in the talk was offended Assertion without evidence. &gt; issuing a public statement that is almost certainly defamatory Incorrect. &gt; advocating for the removal of individuals from subsequent events Exaggeration. &gt; Regarding expulsion Irrelevant distraction. &gt; As TPF and TPC organisers have acted outside the SoC that they have provided Assertion without evidence. Confusing TPF and TPC with PerlCon. &gt; it's impossible for anyone to attend a future event without fear of arbitrary actions and retributions by prominent community members. Exaggeration. I suspect that's the point of this post. &gt; Participants now risk being defamed Assertion without evidence. &gt; It is unclear who made the complaint in this incident I think this weakens the argument, this far into the post. It's a shame the anonymous author posted anyway, after admitting the lack of evidence for their suppositions. &gt; Especially when no harm is intended. Mostly irrelevant. &gt; there is much opportunity to make mistakes that will not only reflect poorly on the Perl community but also open the TPF and individuals to risk of legal action. Exaggeration. I suspect this is the point of the post. &gt; Is the outcome to evict a speaker or attendee from the conference, then drive them from the perl community? Exaggeration. I suspect this is the point of the post.
&gt; the facts must be made public This seems like a bad idea. Imagine if we were talking about some sort of assault here. Making the details public without the reporter's consent (or pushing the reporter to make the details public) seems like a very bad idea. &gt; any potential offender will not be lynched That's an exaggeration in very poor taste. No one is being physically abducted, assaulted, and murdered here. &gt; Any defendant has the right to a fair trial and the assistance of lawyers. While Code of Conduct violations may be reported to law enforcement, many aren't. Please read this [Code of Conducts 101 FAQ](https://www.ashedryden.com/blog/codes-of-conduct-101-faq).
Here's the key: &gt; any "real-world" expression ... that ask the engine to "match anything followed by anything" can lead to catastrophic backtracking.
IMHO it should be a fatal error, because it has never behaved in a sane way. If you have a program with ‚Äúmy $x= $value if $false‚Äù, then you probably have a bug.
We are speaking here about a talk given in public in front of several hundred persons, not about some form of assault or harassment (as far as I can tell). Since the video has been suppressed (please note that I'm not making any judgment on that suppression), we cannot know what happened exactly. And it is a pity that there is so much turmoil on an event where we cannot know the facts. As for the word "lynched," it was used metaphorically, you might feel it is an exaggeration, I can certainly understand that, but I prefer not to comment about your perceptions of good or poor taste. In French, the expression "lynchage m√©diatique" (literally "media lynching") means "trial by media". The Wikipedia page on "trial by media" has this sentence: "The media are often accused of provoking an atmosphere of public hysteria akin to a lynch mob." That's exactly what I meant. But perhaps Wikipedia also has very poor taste? Again, when I said that any defendant has the right for a fair trial, this was also metaphorical, I wasn't speaking about any official trial by law enforcement authorities, but about the fact that an internal TPF sentence has been enagainst Will Braswell apparently without any opportunity for Will to defend his case, and that a social network judgment has been made by a number of people, presumably without knowing the facts for many of them.
&gt; I think that a fair public trial is almost always far better than secret police action. It doesn't work to have the public deciding whether someone was harmed in a specific case, especially if that someone is a member of a protected group. That's why protected groups exist. &gt; I think the fact should be made public, so that everyone can make one's own mind. I think you're arguing against yourself here. You don't want someone to be punished in public opinion, so you want this issue to be made public. How about *don't* make the issue public, so it's handled privately? &gt; perhaps Wikipedia also has very poor taste? Wikipedia isn't making an analogy that someone being bad-mouthed on the Internet, rightly or wrongly, is equivalent to someone being murdered. There's a difference.
Coolness.
I'd been meaning to write about this for [The Effective Perler](https://www.effectiveperlprogramming.com), so here's [No more false postfix lexical declarations in v5.30](https://www.effectiveperlprogramming.com/2019/07/no-more-false-postfix-lexical-declarations-in-v5-30/).
Codes of conduct are not courts (criminal court, civil courts, or courts of public opinion.) Nobody is on trial, and there's no such thing as a right to legal counsel. Every re-publishing of eyewitness accounts is spreading the problem, which is why care is taken to choose which things to make public. Codes of conduct are not democracies or popularity contests: You can't override the code of conduct by getting enough people to disagree with it. It's not up to anyone who cares to make up their own opinion based on their interpretation of the facts. It's up to the people enforcing the code of conduct to enforce the code of conduct.
It's not a [character escape sequence](http://p3rl.org/rebackslash#Character-Escapes), but lives on as a [regex character class](http://p3rl.org/recharclass#Backslash-sequences). ‚Ä∫ perl -Mwarnings -E'say sprintf "U+%05X", ord "\v"' Unrecognized escape \v passed through at -e line 1. U+00076 ‚Ä∫ unichars -a -u '\v' ---- U+0000A LINE FEED ---- U+0000B LINE TABULATION ---- U+0000C FORM FEED ---- U+0000D CARRIAGE RETURN ---- U+00085 NEXT LINE ---- U+02028 LINE SEPARATOR ---- U+02029 PARAGRAPH SEPARATOR
As an outsider this story is creeping me so much that I am considering this community as fundamentally screwed. As a normally conspiratorialist random human being, I suspect that Perl is an extremely poorly funded project promoted by multimillionaire-stingy Soros open society.
Given that, basically programming Perl in comparison to Python for instance (that is transparently funded by opulent tech multinationals), put me in the infernal cycle of people supposed to work for cheap/free and under constant treat of being fucked
Faulty generalisation fallacy, much? Perlcon switching one keynote speaker for another makes no implication on the whole community.
This kind of fallacy is what dumbies always do, and for very good reasons! The reply was not meant to be intelligent, but to highlight a general message about a timely subject that pervades our society
Anon BPO moderator greyed out the article. &gt; The post [linked from here] argues that Perl's most central governing body should not stand up against bigotry. I will not accept that on [BPO]. Please do not attempt to continue this discussion in the comments or elsewhere. I presume the BPO audience is made up of adults who can make use of their cognitive and thinking faculties, so that mod sort of getting to decide for all readers/participants what's a strong and unreasonable belief or opinion, and what's not, is culturally tone-deaf and makes me feel put-off. Trying to control what one might say or write *elsewhere* is the dictionary definition of toxic. It's well past time I make my own blog, with üÇ´ &amp; ‚ëÄers.
A lot of this also applies to the separator characters (FS, GS, RS, and US). In theory, you can and should use them instead of commas in CSV files. I tried it once, and they just caused a bunch of weird issues. Text editors don't handle them well, and compilers aren't used to seeing them. Quickly ran away back to commas.
Another proof that Perl is actually "more recent" than Python 3. :)
Yes, of all the control characters (ASCII codes below 32) less than 25% are still in actual use.
As the moderator is only speaking about BPO, I presume they meant creating new blog posts as "elsewhere". Obviously any other website is not in their purview and does not affect what's presented by BPO. It is exactly the job of a moderator to decide what content is acceptable on the site.
Someone also removed my comment on that blogs.perl.org article asking who the moderator was.
&gt; About blogs.perl.org &gt; blogs.perl.org is a common blogging platform for the Perl community. Written in Perl and offering the modern features you‚Äôve come to expect in blog platforms, the site is hosted by Dave Cross and Aaron Crane, with a design donated by Six Apart, Ltd.
I understood Liz's proposal to say that *many of* the facts must be made public *under certain circumstances.* When she says, "If you don‚Äôt like him, or think he‚Äôs doing things wrong, tell him so. Then, IF he persists in doing things wrong, THEN decide to do something about it," that seems to advise against immediately taking everything public. And in the case where the offender doesn't make it right personally, then you go to a community authority, the Standards committee in this case. I understand this bit to be talking about the community authority taking action, also: "If a report of a violation results in an action towards the accused, then everything about the accused, the accusation, and any proofs, should be made public." That is, if the Standards committee punishes somebody in the community's name, members of the community get to know why, and get to form their own opinion of the accused, which may or may not agree with the committee's opinion. u/mr_chromatic makes an excellent point about victim privacy. Disclosure may be different for a mild offense committed in public than for a very intrusive one committed in private. Standards of conduct exist for the community's benefit, and it does not serve the community if you have to humiliate yourself in front of everyone to get a threat to the community addressed. Trials by courts of law have guarantees of a lawyer's counsel, the presumption of innocence, etc. because the state can enforce the judgement with physical coercion. There are no such guarantees when I decide whether to invite the shouty distractible guy to join my chess team, because I'm not using physical force there. Community standards are somewhere in between those extremes, so some guarantees may be appropriate, but not necessarily all of them. About the term "lynched." Lynching is when a person is kidnapped, usually tortured, and murdered for no other reason than skin color. It is much more deadly and inhumane than trial by media. Using it as a metaphor for trial by media is at best counterproductive. It weakens the argument in the same way any gross exaggeration weakens an argument, by undermining its credibility. But moreover, using lynching as a metaphor for trial by media is cruel to people who were and are in danger of suffering the real thing. It is an offense against their basic human dignity, and treating it lightly is treating their human dignity lightly also. That's true for all the accusations reported by Wikipedia, and it's true for all the uses of the expression by French speakers.
Some of the talks look interesting. I hope there will be some slides.
Godspeed to all who boycott that one. #BDS
"use English;" just kidding.
First Amendment FTW. Vote with your $.
&gt; A lot of this also applies to the separator characters (FS, GS, RS, and US). In theory, you can and should use them instead of commas in CSV files. Doesn't using unprintable characters for a plain text file format kinda defeat the purpose?
I'd say that $string2 goes out of scope when the block exits. But I really can't think of any reason you'd be using 'our'. without it being in a module. https://perldoc.perl.org/functions/our.html "our makes a lexical alias to a package (i.e. global) variable of the same name in the current package for use within the current lexical scope."
Thanks for the reply. &amp;#x200B; I haven't explored on packages yet and so don't know how packages works. Only thing I know about packages is that you can use the content in the packages using use keyword. &amp;#x200B; What I am getting right now is that; 1. when I use strict, whatever is in-between the brackets, remains within the brackets and when not used strict, it ignores the brackets 2. defining variables with our does not make variable global if its inside the brackets when using strict (don't know the reason why)
The manual gives a clear explanation: &gt; "our" makes a lexical alias to a package (i.e. global) variable &gt; of the same name in the current package for use within the &gt; current lexical scope. &gt; &gt; "our" has the same scoping rules as "my" or "state", meaning &gt; that it is only valid within a lexical scope. Unlike "my" and &gt; "state", which both declare new (lexical) variables, "our" only &gt; creates an alias to an existing variable: a package variable of &gt; the same name. &gt; &gt; This means that when "use strict 'vars'" is in effect, "our" &gt; lets you use a package variable without qualifying it with the &gt; package name, but only within the lexical scope of the "our" &gt; declaration. This applies immediately--even within the same &gt; statement. So basically "our" is not as much as "making a variable global" or "declaring a [package] global variable" as it is about **making an alias to an (always existing) package variable**. If you do: our $foo = 1; you are basically requesting to alias `$main::foo` (or if you are in package `Bar::Baz`, `$Bar::Baz::foo`) to the lexically scoped `$foo`. Since it is lexically scoped, if you put it inside a block then you are no longer able to access it outside of that block.
&gt;when I use strict, whatever is in-between the brackets, remains within the brackets and when not used strict, it ignores the brackets From the documentation link I provided before: "our has the same scoping rules as my or state, meaning that it is only valid within a lexical scope. " Those braces, they define a "lexical scope". And yes, "strict" makes "our" really, really respect that "lexical scope"... &gt;defining variables with our does not make variable global if its inside the brackets when using strict (don't know the reason why) tl;dr: Don't use 'our' until you need to. You'll know when you need to.
&gt; But I really can't think of any reason you'd be using 'our'. without it being in a module. It depends. If you define classes (which are basically packages) in your main script, then `our` might make sense too there.
CSV does not meet the RFC 2046 definition of plain text.
&gt;It's well past time I make my own blog Please do. I'd really like it if everyone was to do that. Given what a pile of crap the current version of BPO is, I'm astonished that anyone still uses it.
Except I always thought one of the features of classes is that you don't expose any internal variables, but rather use getter/setter methods. e.g.: $instance-&gt;foo(q{Some value.});
There are also class variables (instead of class instance variables). Sure you can also use setter/getter for those too. Aside from declaring classes, sometimes I also embed tiny modules into the script itself, for deployment or other reasons. There might be other uses of using multiple packages in a script. And aside from dealing with multiple packages, \`our\` also lets you add attributes. Haven't used it myself.
That is all true. Which is why I concluded my comments with the "Don't use 'our' until you need to. You'll know when you need to." bit.
You get a similar problem when you declare $string2 with `my` instead of `our`. Last paragraph in perlancar's explanation also applies to that case. &gt; you can use that variable anywhere in the scrip? That's a huge mistake. When you have global variables, any place in the code can modify it. That makes it very difficult to reason about the program once it surpasses a certain size. The answer is not "I'll be careful", but "I won't use this practice and enforce the ban with http://p3rl.org/Perl::Critic::Policy::Variables::ProhibitPackageVars". This should scare you straight: https://duckduckgo.com/?q=toyota+killer+firmware+"global+variables" AFAICR I haven't needed `our` in the last ten years. Structure the program in a way that you do not have variables that are visible everywhere in the first place: 1. Beginners often like to declare all variables up-front, but very often this is not necessary at all. Declare variables where they are needed in the smallest scope possible. 2. When a subroutine needs data, pass it in explicitly with parameters. Pass out computation results with `return`, not by assigning to variables that were declared outside. There exists a trap: a variable declared before a subroutine is visible inside the subroutine. (This is by design and needed for something else, but you won't encounter that in the next year or so.) So to keep yourself from falling into that trap, declare subroutines early in the code, and variables only after all subroutines. This way, it becomes very easy to reason about the program. Because "action at a distance" is eliminated, you can easily see and follow where the data flows and variables are only modified in small, manageable places.
Noted. Thanks for the facts. :)
&gt; The Perl Foundation√¢‚Ç¨‚Ñ¢s this brave new Unicode rebranding is a bold choice, let's see how it works out for them
Adivce: Even if you are a newbie at Perl, if you step back and think about it, you are trying to use a "global" construct in the middle of your code inside of an enclosing scope. Even if it "worked", it would sure confuse anyone trying to read your code. Put globals at the top. When starting a new language, there are still basic comp sci principles to follow. When confused, don't let the new language confuse you on old principles. Now, if this is your FIRST language, then, ok, you have plenty to still learn.
Some useful reading: https://github.com/mvanwinkleias/perl_tutorials/blob/master/MyOurLocalTutorial.pod
Yes, this is my firs language. I did this with curiosity to learn how it behaves and get my mind clarity that order of things is important here.
Dist::Zillow.
?
Zilla. There‚Äôs another project starter out there. h2xs is for C code I believe.
Sorry, you said **Dist::Zillow**, not **Dist::Zilla** and I couldn't find anything about that. I read [here](https://www.perlmonks.org/index.pl?node_id=158999) and in some articles about using **h2xs**. In that link they mentioned **Modules::Starter**, but during installation I got error related to failed tests, so I gave up.
h2xs tries to help when wrapping C libraries as Perl modules. It is not useful for your usecase. Also, don't stick to tools only because they are part of core Perl, the good stuff is on CPAN. For a pure-perl module, the most advanced authoring tool is Dist::Zilla (dzil). It has innumerable plugins for autogenerating files, testing your module, managing version numbers, packaging the module, and uploading it to CPAN, and so on. It's pretty complex, and your second CPAN module will likely be your personal plugin bundle :) But you do not need all that. To get started with a minimal CPAN distribution, first write a bog-standard [Makefile.PL](https://metacpan.org/pod/ExtUtils::MakeMaker). That makes your distribution installable via CPAN, but requires you to do a lot of manual steps. If that gets tedious, look at Dist::Zilla again.
Damn you autocorrect. I‚Äôd like a Perl dictionary.
Thanks. Do you know is there any good tutorial of writing basic Makefile for Perl module, so I won't have to use any external tools ATM?
I was going to mention this but as per usual my insecure self thought it was too nitpick-y. &amp;#x200B; Unrelated, but would the names listed on [https://www.perlfoundation.org/whos-who.html](https://www.perlfoundation.org/whos-who.html) be worth contacting about the current [https://perldoc.perl.org/](https://perldoc.perl.org/) fiasco? I can't imagine a version of events where they were aware of the issue(s) and let the switch happen, especially when [perldoc.pl](https://perldoc.pl) exists in an perfectly stable/usable form.
[Module::Starter](http://p3rl.org/Module::Starter) is simple and clean.
Thanks, I will take a look at it.
For Dist::Zilla, see [Dist::Zilla::Starter](https://metacpan.org/pod/Dist::Zilla::Starter). It comes with minting profiles for creating distributions and plugin bundles for releasing them. [Dist::Milla](https://metacpan.org/pod/Dist::Milla) is a similar minter and plugin bundle which does much more by default. [Minilla](https://metacpan.org/pod/Minilla) is like Dist::Milla but without using Dist::Zilla. It's therefore not as configurable but it is where I point a significant amount of new people as it's the lowest barrier of entry to do things right. For minimalism, see [mbtiny](https://metacpan.org/pod/mbtiny). For minimalism where you first have to read the entire documentation, then search online, then read the entire documentation again, and still get confused, use [ExtUtils::MakeMaker](https://metacpan.org/pod/ExtUtils::MakeMaker) directly.
Thanks for answer. I really appreciate.
[ExtUtils::MakeMaker::Tutorial](https://metacpan.org/pod/ExtUtils::MakeMaker::Tutorial), as well as the module's main documentation. With caveats as mentioned in my other comment.
Far from eliminating bigotry, they are eliminating any discussion that questions them, even when it‚Äôs not bigoted. They are proving the point of the original post.
Yes, the difference is essentially "square brackets create an anonymous array" vs. "round brackets just affect precedence". Use the square ones when assigning to a scalar (`$x`), use the round ones when assigning directly to an array (`@x`). With this: my $x = (1,2); the comma operator is in scalar context, so it will evaluate then throw away whatever's on the left, returning the expression on the right (in this case, 2). The result is then assigned to the scalar `$x`. If you turn on warnings and use (3,4) as your example, you should see a message about a "useless constant". Without the brackets: my $x = 1, 2; you have the `my $x = 1` assignment (probably in void context, depends on what the rest of the code looks like!), so `$x` ends up containing the value 1. In both cases, you're only assigning a single value to `$x`, there aren't any arrays yet. With this: my $x = [1, 2]; the comma operator constructs a list, since it's in list context, and the content of that list is assigned to a new anonymous array (created by the `[]` "operator"). The reference to that (anonymous) array is a scalar value which is assigned to `$x`. Some links that might help: - http://altreus.blogspot.com/2011/08/lists-and-things-made-of-lists.html - http://perldoc.pl/perlop - http://perldoc.pl/perlreftut (note that the value 1 doesn't give a warning in that first example, because it's often used as a dummy expression when you don't really want to do anything, like: 1 while process(); this is of course completely irrelevant to your original question!)
`[1, 2, 3]` creates an array reference. `(1, 2, 3)` creates a list. If you assign the list to a variable like so `my @a = (1, 2, 3)` you will have an array. If you assign that array reference to a variable you will have a pointer to that reference: `$x = [1, 2, 3]`. Note the user of a scalar (`$`) variable for the reference vs an array (`@`) for the list assignment. See this: https://learn.perl.org/faq/perlfaq4.html#What-is-the-difference-between-a-list-and-an-array
Ok, what about these to codes: foreach((1,2,3)) and foreach([1,2,3]) Does it make any difference?
Yes, they are different. `foreach((1,2,3))` loops over a list of three numbers, `1`, `2` and `3`. `foreach([1,2,3])` loops over a list one array reference, `[1,2,3]`.
Ok, now I understand the difference. Thanks.
Nice read. Considering memcached can be distributed/redundant too, it's not clear why you moved to Redis.
Maybe to store more complex data structures than just simple KVPs? Just a guess.
I use `@our` sometimes as a way of including data in an external file, without it being a full-on module. main.pl: #!/usr/bin/perl use strict; require 'list_of_things.pl'; our @fruits; foreach(@fruits){ print $_,$/; } list_of_things.pl: use strict; our @fruits = qw(apple banana cherry); this is just a quick-and-dirty method of using a big array without it cluttering up the main file. If you use `@our` both files are still able to use `strict`. It's probably really hacky.
Excellent write up!!
Parentheses don't create a list. Having values in list context anywhere creates a list. For example, `push @foo, 1, 2, 3;` pushes a list of three elements onto @foo. While `my $foo = (3, 2, 1)` evaluates the scalar commas to return `1` and assign it to $foo, never creating a list because of the scalar context. Parentheses are just used for precedence particularly in assignment, since assignment has higher precedence than the comma operator. Confusing matters are a few special cases where parentheses do affect behavior: `($foo) = ` creates list context, while `$foo = ` creates scalar context; `($foo)x3` repeats $foo 3 times as a list (in list context) while `$foo x3` string-repeats $foo into "$foo$foo$foo"; `(LIST)[#]` does a list slice, which operates similarly enough to array slicing to be useful and confusing; and `function()` doesn't require the symbol "function" to be known at compile time while `function` does.
There is no reason whatsoever not to make it a "full-on module". require (and even do EXPR) searches `@INC` the same way as use would. The lack of namespace separation and clarity of intent will very quickly make your code unmaintainable; this is why Perl 5 introduced modules to begin with. Also, `our` can be substituted by just fully qualifying the package variable. If you haven't declared any packages, it would be `@main::fruits`.
&gt; If you haven't declared any packages, it would be `@main::fruits`. So I require the second file, but *don't* have `use strict` in it, then refer to `@main::fruits`?
The question was: &gt; ... is there any difference if I will use square or round brackets when creating anonymous array? Delving into the nuances of Perl of could be helpful but maybe they just want one [to get to the point of their question](https://www.reddit.com/r/perl/comments/cfffsp/square_and_round_brackets_for_anonymous_arrays/eu9migx/). ü§∑‚Äç‚ôÇÔ∏è
If it is entirely your code, how you license is entirely your decision.
Thanks. I saw that most people uses GPL license from Perl website, so I wanted to make sure.
I suspect most Perl modules use the "under the same terms as Perl itself" license, which makes sense since the module tends not to have much use without also using Perl. Perl has multiple licenses. You can accept the Artistic License, or version 1 or any later version of the GPL.
&gt;I suspect most Perl modules use the "under the same terms as Perl itself" license, which makes sense since the module tends not to have much use without also using Perl. This is why I'm confused about license that I can use. Why people are not using e.g. Python license for Python programs? There is the same case, program doesn't have much use without the interpreter. &gt;Perl has multiple licenses. You can accept the Artistic License, or version 1 or any later version of the GPL. But I still can use MIT license if I want to?
&gt; This is why I'm confused about license that I can use. I removed the second half of that sentence you quoted because it's misleading. The Artistic License nor the GPL are _redistribution_ licenses. They do not restrict the _use_ of Perl. &gt; But I still can use MIT license if I want to? It's your code, you can do whatever you want. If I wanted to distribute Perl-plus-your-module, I would need to accept the MIT license as well as one of Perl's licenses.
Ok, now it makes sense for me. &gt;However, if I wanted to redistribute Perl-plus-your-module, I would need to accept the MIT license as well as one of Perl's licenses. That could possibly make me less likely to want to redistribute your module. Can you explain why you wouldn't accept MIT license? AFAIK MIT license means something like 'do what you want, but include copy of my LICENSE file' and GPL is the same, but it has to be open source, when MIT doesn't have to. Am I right?
&gt; Can you explain why you wouldn't accept MIT license? I thought my use of "could" and "possibly" would suggest that it was unlikely. But since you ask: perhaps I value FSF-style "software freedom" so highly that I would find it repugnant to distribute code that could be used in non-free software.
&gt;I thought my use of "could" and "possibly" would suggest that it was unlikely. Ok, now I understand what you meant. &gt;But since you ask: perhaps I value FSF-style "software freedom" so highly that I would find it repugnant to distribute code that could be used in non-free software. What is wrong with free module that can be used in non-free software? I mean you can use it in your own free software as well if you want.
&gt; What is wrong with free module that can be used in non-free software? Given there's a whole ecosystem of software that has precisely this characteristic, the situation shouldn't seem too implausible. &gt; I mean you can use it in your own free software as well if you want. Remember, "use" has nothing to do with any of this. I can use your module whether I accept the MIT license or not.
&gt;Given there's a whole ecosystem of free software whose raison d'√™tre is that it cannot be used in non-free software, the situation shouldn't seem too implausible. Ok, its your opinion, I don't want to argue with you. IMO MIT license is better because it can be used in both free or non-free software. &gt;Remember, "use" has nothing to do with any of this. I can use your module whether I accept the MIT license or not. Sorry, by 'use' I meant using in your module that you want to e.g. publish on GitHub.
&gt; Ok, its your opinion, I don't want to argue with you. You don't have to. I don't actually hold this opinion.
is the \`/bin/bash: q: command not found\` in the overview section a bug or a joke i don't understand?
I was the moderator in question (I‚Äôm named in the footer on every page, which hardly seems ‚Äúanonymous‚Äù to me) and I meant ‚Äúelsewhere on the site‚Äù. I have no interest in debating whether refusing bigotry or defences of bigotry in the interests of allowing readers to ‚Äúmake use of their cognitive and thinking faculties‚Äù is ‚Äúculturally tone-deaf‚Äù. Dave and I put actual money and time into hosting blogs.perl.org, and my opinions over the years have moved very much in the direction of ‚Äúmy house, my rules‚Äù when it comes to the content I‚Äôm willing to host on the site. I strongly encourage people to create their own blogs elsewhere. That's the case in all situations, and most especially for those who don‚Äôt want to be subject to my rules.
I apologize, I was really just correcting the one statement; but I think it's an important nuance, as one can very quickly make a mistake of thinking parentheses matter for more than precedence.
To echo the other comments: it's entirely your decision, but the two most common licenses used on CPAN are [same as Perl](https://dev.perl.org/licenses/), which is (GPL 1+ or Artistic 1), and [Artistic 2.0](https://opensource.org/licenses/Artistic-2.0), which fixes some problems with Artistic 1 that make it more acceptable to some like FSF. A business may need to vet any unusual licensing you use before using your software. Just make sure to specify whatever license it is in [metadata](http://blogs.perl.org/users/neilb/2017/04/an-introduction-to-distribution-metadata.html) and ideally also include a LICENSE file, which can be generated by dzil or [Software::License](https://metacpan.org/pod/App::Software::License).
`use strict` would make no difference, fully-qualified package variables are always strict-safe.
Hi, thanks but no need to apologize! But yes, nuance is important in programming; especially in Perl.
You can use the simple names: [] are brackets, () are parentheses, {} are braces. No need for adjectives like "curly" or "round."
Oops! That was a booboo on my part. I've fixed it and pushed the change. It will show up shortly.
Definitely needed more complex data structures and a number of other features Redis offers. I've glossed over a lot of detail.
[duplicate](http://redd.it/cbu3im)
I thought thar Reddit checks and warns for duplicates? It never warns in the Perl forum
So either flavour of the functions has a footgun to be aware of, and you have to write some conversion code to step around a trap regardless of which flavour you use, which is barely different between the flavours. It‚Äôs also easy to encapsulate this line in your own local wrapper function which *removes* the footgun (so you don‚Äôt have to memorise it or keep looking it up or re-derive it every time). So the only difference it makes to use the new functions is that your code gains a non-core dependency on non-latest perls.
Or if you're using it from human-input numbers, the modern function is easier to consistently use. But in that case, I would be using Time::Piece or Time::Moment or DateTime anyway.
Glob a = subroutine reference b means only sub ref b is mapped into a. $a-&gt;() will call &amp;b(). Glob a = glob b means the entirety of b is mapped into a, and &amp;a() will call &amp;b().
So it is better to use `*a=\&amp;b` because it won't copy whole thing, so it will be more efficient?
Eh. I‚Äôm not sure of the use case, so can‚Äôt answer. Using a and b are generally bad in Perl since functions like sort create local variables of that name. In principle, *a = *b should be faster, since it‚Äôs just changing the pointer to the *a references. In the other, b is dereferenced, then the pointer mapped to the scalar of *a, which requires dereferencing a.
&gt;Eh. I‚Äôm not sure of the use case, so can‚Äôt answer. Ok, thanks for answer anyway. It helped me. &gt;Using a and b are generally bad in Perl I think its bad in any language, but it was just example, don't worry. &gt;In principle, \*a = \*b should be faster, since it‚Äôs just changing the pointer to the \*a references. In the other, b is dereferenced, then the pointer mapped to the scalar of \*a, which requires dereferencing a. Thanks for that.
You need to understand what a typeglob is. Your latter example aliases all slots, your former example aliases only the coderef slot. Examine the output of: perl -MDevel::Peek=Dump -e' %bb = (5,6,7,8); @bb = (2,3); sub bb { "bb" }; *aa = *bb; Dump %aa; Dump @aa; Dump &amp;aa; ' perl -MDevel::Peek=Dump -e' %bb = (5,6,7,8); @bb = (2,3); sub bb { "bb" }; *aa = \&amp;bb; Dump %aa; Dump @aa; Dump &amp;aa; ' ---- &gt; constant argument Use currying. Aliasing does not help. use experimental 'signatures'; my $multi_arg_times = sub ($x, $y) { return $x * $y }; $multi_arg_times-&gt;(5,20); # 100 my $single_arg_times = sub ($y) { return sub ($x) { return $x * $y } }; $single_arg_times-&gt;(20)(5); # 100 my $curried_times = $single_arg_times-&gt;(20); $curried_times-&gt;(5); # 100
Thanks for answer.
&gt; I think its bad in any language, but it was just example, don't worry. It's specifically a problem in Perl and shouldn't be used in examples, because if someone copies that example to code they can actually break it. But this is just `$a` and `$b`, subroutines named `a` or `b` aren't special to anything.
Would using `foo` and `bar` be better in example? I saw many people doing that.
They are certainly better example names in general. For variables where you still want to keep it concise, I use `$x` and `$y`.
Thanks for that advice.
Here OP, a post from months earlier: [https://www.reddit.com/r/perl/comments/aembaz/perl\_module\_development\_from\_the\_ground\_with\_step/](https://www.reddit.com/r/perl/comments/aembaz/perl_module_development_from_the_ground_with_step/)
Thanks, I'll take a look at this.
I confirm this happens on Linux, too. &gt; Any suggestions? You need the experts to figure out what's wrong. Try the PAR mailing list and UPX github issues.
No. Both forms assign the `CODE` slot of `a` and both forms allow calling as `a()`. Neither one makes `b` callable using `$a-&gt;()`. The difference is whether or not the other slots of `a` are overwritten.
You are correct. I incorrectly assumed that the glob assignment wouldn't respect the type, and would store it int he scalar.
Perl6 solution for Task #1: sub substrings($_, \len) { gather for 0 .. (.chars - len) -&gt; \offset { take .substr(offset, len); } } sub MAIN(*@strings where .so) { for @strings&gt;&gt;.chars.min ... 1 -&gt; \len { my @common-substrings = keys [‚à©] @strings&gt;&gt;.&amp;substrings(len); if @common-substrings { .perl.put for @common-substrings.sort; last; } } }
Totally different Perl 6 solution for Task #1: ``` sub MAIN(*@strings where (.so and .elems &gt; 1)) { # sort the strings @strings = @strings.sort({$^a.chars &lt;=&gt; $^b.chars}); # pick the shortest my $champion = shift @strings; # get all its substring sorted by length my @substrings = flat (1..$champion.chars).reverse.map: { $champion.comb.rotor($_ =&gt; $_ - 1).map: *.join }; # print the longest in common with the other strings TEST: for @substrings -&gt; $i { for @strings { next TEST unless .index($i).defined; } say $i and exit 0; } say "Not found" and exit -1; } ```
What is this about? What video exactly?
Seems to be a problem on the Gmail side, not the CPAN side. You could create a filter that never marks these mails as spam, but that's counterproductive when you do receive a spam mail. It's also impossible to avoid these forwarded mails from looking slightly spammish.
Filter rule "never classify as spam" works for me.
I know they will go to spam, but I'm looking for some filter that is also looking for email in spam. For now I found that I could add `in: anywhere` to filter, but it doesn't work for incoming emails, only for that I already got.
I couldn't find this anywhere, but I found other solution: [https://support.google.com/mail/answer/1366858](https://support.google.com/mail/answer/1366858) I found email that is in spam and clicked **Not spam**. Now everything works as I expected, thanks.