I was disappointed that so few people wrote in.
Well, most of us don't have very interesting stories. I learned Perl for fun in middle school. In college, I had a job and sort of remembered Perl, so I used it. Now I have a book out about Perl :) Not all that interesting.
Maybe you're right, but I wonder if you thought about it harder you could find something more interesting to say. I was going to write in that I had been a Unix sysadmin, and some other Unix sysadmins told me that this Perl thing was useful and I should take a look, so I did, and it was. Boring. But then I thought about it a little harder and realized there was something to say after all. 
This is a repost of a submission to programming.reddit.com. http://reddit.com/r/programming/info/66swx/comments/ I was curious to see if I could re-submit the same URL in a different sub-reddit. It appears you can. 
The author of this article has misunderstood the definition of "language" used in the article to which he's responding. The original author meant that the canonical Perl *implementation* is slow; languages themselves obviously can't be slow. However, the definition of "language" he's using is the correct one. There is no such thing as a "compiled" or "interpreted" language. I know it's possible to compile Perl to an executable; I've done it. I know that there were other points in "You Used Perl to Write WHAT?!", but they were stupid. Only two of the "cons" actually referred to applications of the language. The other two were really coding style guidelines. In all, this probably didn't need to be written since the first article's errors are self-evident, but I suppose some people do need to be told these things.
I'm going with the use.perl version instead of the nntp.perl.org version this week. I don't know why.
Well, *some* Perl programmers hang out there. I think the place is kinda depressing. On the one hand, you get the usual group of people that have no ability to read the manual or source code for anything they use. On the other hand, you have a group of highly-able perl programmers that do nothing but bicker over how to use bugs in the interpreter to save 2 bytes. Shut the fuck up and write some *real* code.
I've heard of this!
Proggit didn't like this article. Maybe perllit will like it better ;)
Very good to hear. This is going to make working on perl5 quite enjoyable. Now I need to get my git-cpan stuff going (to help with maintaining dual-lifed modules).
Where do others hang out? I program perl for a hobby and would like some place to share code/ideas once in a while.
mailing lists, irc.perl.org, etc.
Yeah, actually, I kinda do want one. But not for $300.
It's sad that only 3 were made...
Thanks! That is definitely worth bookmarking.
just started learning mason so thanks for the resource.. actually i am really looking forward to using mod_perl/mason for my next site, but i'm not sure because mod_perl looks to be very unstable on win32 servers so far.
&gt; One incident really stood out to me and struck me as odd. The auditorium was pretty full at one point, so there were probably about 100 really good perl programmers in the room. The talk was being given by chromatic, I think. Anyway, there was a slide up with some pretty trivial code on it. There were about 2 or 3 statements that called ok() to test whether a few things were equal. The slide was up for a while, maybe almost 5 minutes before someone pointed out that there was an error in it. Instead of ok(), is() should be used there to test equality. Apparently, chromatic had actually just copied this example from the actual test suite, so he said that perhaps the bug is there and not just in his slide. Larry pulled up the code, and sure enough, the bug was there. &gt; So, what does this mean? Does it mean that even with a lot of eyes, not all bugs are shallow, even the really trivial ones? Does it show how much help the Parrot and Rakudo guys need? Does it show how easy it is to help them? Probably a little of all three. Anyway, I was stunned. 
Thank you, but: Not exactly what I need. I am looking for an illegal Perl book that isn't free.
Sweet!! I was just wondering how to do this. I just created a nice little Singleton package .. any script that uses or requires it will be limited to a single instance: package Singleton; require 5.001; use strict; use Fcntl 'LOCK\_EX', 'LOCK\_NB'; flock DATA, LOCK\_EX | LOCK\_NB; \_\_DATA\_\_ Don't remove this line [Edit] Actually, as kahirsch pointed out, this would limit *all* scripts that use it to a single instance at any given time. You'd have to create separate package like this for each independent lock.
Hmm, I'm sure that on some platforms, you need a handle with write access to be able to `flock` it. And `DATA` is a read only filehandle.
There's little point to putting this in a package. You couldn't have two different scripts using the package at the same time. 
Yeah, you're right, I got a little carried away there :-) You'd have to create a package per lock. Still it is cool and I can think of lots of uses for this feature.
does the CPAN have something like JIRA? Basically, so that if the author is missing / unresponsive other people can be assigned or whoever fixes the code for their own good can also update the code on their behalf. 
There is a process for handing off the maintenance of modules to others, or for taking over the maintenance of modules after an author has been unavailable for some time. It's manual, though. 
FORK
see http://homepage.mac.com/pudge/fsb/ for more.
Duke Nuken Whenever will be out before Perl 6. If both are released, the world will end.
I'd recommend YAML::Syck over YAML. It's less error-prone and faster. Other than that, seems like a good list.
[Here you go](http://flickr.com/photos/96397774@N00/373225236). I love Perl, but I love that picture, too...and now I have an excuse to post it.
About two weeks ago, I saw this post http://www.reddit.com/r/Python/info/6p7l0/comments/ that pointed out that gst was one of the most frequent posters to the python subreddit. It also pointed out that some of the language specific subreddits are more popular or interesting than others. I had always been a little disappointed in the perl subreddit, so I decided to do something about it. For the past two weeks, I've been posting a few perl related links a day to the perl subreddit to see if I could improve it. I have also posted some perlish links that are more generally applicable to the programming subreddit or elsewhere. What have been the results? I now have posted about 16 of the 20 posts on the front page of the perl subreddit. Apparently others post, too, but not that often. my karma has increased quite a bit. Apparently others like the posts. I'm not that interested in karma directly, but it's a bit of a measure of how others are receiving the things I post. There are about 20 more subscribers to the perl subreddit, but still way fewer than the python subreddit, and a bit fewer than the PHP subreddit. I don't know how much it would have increased without me posting more. Finally, I think that the perl subreddit now more accurately reflects the current, interesting topics in the perl community. But, I could use your help. Do you like reading this increased number of perl posts? Do you have more to contribute? Please don't sit on the sidelines; this is a good opportinuty to show off the great parts of perl to others. kthanksbye 
I appreciate the amount of posts by gst in the python reddit. Perl could really benefit from a more socially active userbase. I'll help a bit.
starting a presentation with xkcd rules!
Quick Help Please: How do you post to Reddit where the link goes directly to the the comment page similar to this post? Thanks, Dre
Yes, thanks for keeping perl subred active. It's hard to drum up new interest in perl because it's not trendy, and let's face it, perl coders are busy getting stuff done rather than wanking it over some overhyped hosted app platform.
type "self" in the URL field, then submit. Then, leave a comment. 
considering [gst's sources](http://www.reddit.com/info/6oabz/comments/c04fh4g) for python. What would be the best places for people to find Perl related news? My list: * [del.icio.us/perl](http://del.icio.us/popular/perl) * [Perlsphere](http://perlsphere.net/) * various [use.perl.com](http://use.perl.org/) journals * [Planet Perl](http://planet.perl.org/) 
I used to hear that trendiness argument from C stooges during the Perl 4-&gt;5 influx. Remember, "scripting" is a fad =) I do get what you are saying. Just relish the day we see ruby and python stooges complaining about 'trendy' Perl6.
The thing in Perl I probably miss most in Python is `unless.` I really liked being able to say the equivalent of `do_some_shit() unless $i_said_not_to;` or whatever. Oh, and a C like ternary operator...what the hell was Guido thinking? 
I thought about posting each of these separately but as they are mostly pdfs and by the same author [Jonathan Worthington](http://www.jnthn.net/), they probably belong in some place that can be better disclaimed. The ones I am reading (pdfs!): * [All Your Dynamic Languages Are Belong To Us](http://www.jnthn.net/papers/2008-us-pct-slides.pdf) * [Perl 6 and Parrot in teaching](http://www.jnthn.net/papers/2008-fpw-teaching-slides.pdf) * [Understanding Perl 6](http://www.jnthn.net/papers/2008-npw-understanding-perl6-slides.pdf) * [Perl 6 Tutorial](http://www.jnthn.net/papers/2008-fpw-perl6-slides.pdf) * [Implementing Perl 6, in Perl 6, on Parrot](http://www.jnthn.net/papers/2008-vienna-rakudo-slides.pdf)
While not necessarily specialized for implementing Perl 6, familiarity with Parrot is the way to get involved and help make Perl 6 a reality.
Specifically hoping to hang out with some Perl sympathizers as last years OSCON felt a tad too much like an Ubuntu/Ruby Con for my tastes (not that I have anything against Ubuntu or Ruby). I and two of my coworkers will be running the gamut of the [Perl Track](http://en.oreilly.com/oscon2008/public/schedule/topic/Perl). #OSCON on Freenode is a pretty good way to organize at the event. Perl sub-reddit needs a beer night in Portland.
The only things I hate about perl are those oreilly books. I WANT OPEN SOURCE! AND DOCS INCLUDED PLZ!
[Perl Docs](http://perldoc.perl.org/) and [Perl Tutorials](http://perldoc.perl.org/index-tutorials.html) are official and mostly available on the command line via commands like [perlfunc](http://perldoc.perl.org/perlfunc.html) and by tutorial name link [perltoot](http://perldoc.perl.org/perltoot.html), etc.
[Perl is back at OSCON this year](http://perlbuzz.com/2008/04/perl-is-back-at-oscon-2008.html). [I'll be there](http://en.oreilly.com/oscon2008/public/schedule/speaker/6552), doing two talks: [Just Enough C For Open Source Programmers](http://en.oreilly.com/oscon2008/public/schedule/detail/3050) and part of Schwern's tutorial [People For Geeks](http://en.oreilly.com/oscon2008/public/schedule/detail/3001). I want to start a "Rethinking CPAN" BOF.
I remember asking the original question many years ago. It's cool to see it reappear on reddit.
I've read the rant and I know how frustrating it is when people disrespect your language (VB for the world!) but I won't defend a language for all the reasons he has also admitted. All languages compete for developers attention and to fill as many niches as possible. Perl is losing and I personally feel it needs to die and be evolved out. The project has stagnated and they have admitted that they are willing to break all backwards compatibility. Well, if Larry Wall still feels some niche problem hasn't been filled why not start a new, cleaner language with a different name? I'm tempted to download fedora and make a spin that replaces every Perl script with a Python version. I don't hate the language, it *is* a better bash script. It's just fallen behind these days so lets clean up after it and move on productively.
Coincidentally I just subscribed today because I saw the subreddit content was fresh. Thanks to you and mandala for being at the top of the power law!
&gt; Well, if Larry Wall still feels some niche problem hasn't been filled why not start a new, cleaner language with a different name? That's what he's done. It's called Perl6. Oh, well, OK, he didn't change the name. But it's a new language, loosely based on Perl5. &gt; Perl is losing The Reddit popularity contest, perhaps. But Perl is still *extremely* widely used. Much more so than Python, for example, in the "real world". 
Your right, it is extremely widely used. My comment probably reads like one of those the author hates but what are people's thoughts exactly on "evolving out languages" from widespread use? Do you think I'd been seen as a *hater* for trying to reduce the number of languages a Linux OS is dependant on (and I'm not talking about ever removing the Perl vm, just people's requirement to learn perl when configuring a small part of their own Linux desktop) Does anyone even agree that an OS based on two languages (C and C++ *which I lump together* for the low level stuff and say Python or Java (but not both) for the high level stuff would be a good idea? Make all the VM's available so users have all the choice they want but for configuring their own systems they don't have to do too much. So good idea or bad idea?
&gt; trying to reduce the number of languages a Linux OS is dependant on Yes, I think it's a good idea if you're building the OS from scratch. For example, OLPC was heavily based on Python specifically so that there would be a low barrier to entry for people to start hacking on it. In fact this would be good advice if you're developing any project from scratch - pick one (or two) languages and stick with it/them. But Linux (for example) is the product of thousands upon thousands of existing programs all written in different languages. Replacing all the Perl scripts with Python would be rather like translating all French literature to English and then burning the originals. It would require a massive effort that would leave you with a whole bunch more bugs than you had before and a lot of annoyed French people. :-) I think we have to accept that programming language diversity is a good thing as it is for spoken languages. It's nice that Python is the esperanto of programming languages, and I'll gladly use it from time to time when I'm talking to a "foreigner". But don't ask me to give up my native tongue for it. Compared to spoken languages, programming languages are trivially simple to learn. It amazes me that there are so many people out there who consider themselves good programmers, but balk at learning 2, 3, 4 or more languages. But I digress... your original point was specifically about creating a dist that only used one or two languages to save the non-programmers from this effort. Well, I'm not sure if it's a good idea myself, but there's only one way to find out. If you build it, they will come, or maybe they won't. But if you don't build it, you'll never know. 
Pretty cool stuff. I wonder when do they finish perl6
sometime after lunch but before Christmas, officially. They aren't certain for which year ;)
A great article, but needs live code samples to be even better.
further reading: [OSCON: Perl Security](http://www.dailyack.com/2008/07/oscon-perl-security.html) via [The Daily Ack](http://www.dailyack.com/) [OSCON 2008: Perl Security](http://sirhc.us/journal/2008/07/21/oscon-2008-perl-security/) via [sirhc.us maxim.us](http://sirhc.us/journal/)
I have serious issues with a lot of those points. Many of them stem from a persons programming preferences. I prefer shorter code. As a 1000 line program of if-then-else statements nested 10 deep are simply not as readable to me as a programmer who can sqeeze it down to 100 lines of code in which each line performs many such operations. Breaking up large functions into smaller ones in which the entirety can fit on the screen is much easier to understand imho than having large function several pages long. Again, this is all opinion and I greatly disagree with the author.
i don't understand a word he's saying but i like his passion
perl who? 
Once I tried Komodo, I couldn't use any of the others. The free version is ok, but the pro version really kicks some serious ass.
Awfully written article, they must've had a pretty high word count requirement. "For power users of this open source language, such extensibility could mean that they will be able to augment the language with instructions, syntax, expressions, operators and other features to meet their own needs. An office of the National Cancer Institute, for instance, could extend Perl to include features that could aid in medical research." Yay for frivilous examples! (&lt;organization&gt; can use it to help with what &lt;organization&gt; does!). I am looking forward to Perl 6 though.
I understand they're writing Duke Nukem Forever in it. 
In Perl 5 can't you type /aaaaa/ or /a{5}/ to mean 5 a's in a row? I don't see how /a**5/ is that big a win over the options we had before. Some of the other regex enhancements sound neat, though.
Not that in particular, but the whole new grammar system looks like a good consolidation of the regex mess. It's interesting that the one thing that contributes most to Perl's reputation for executable line noise, the regular expression syntax, was deemed useful enough to bring to most other languages in the form of [PCRE](http://www.pcre.org/) (Perl Compatible Regular Expressions). It's also interesting that the initiative to reform, consolidate and improve the field again comes from Perl / Larry Wall. 
The first truly extensible programming language. Except for all the others.
They added an opcode to Parrot specifically for parking bricks in alien toilets.
I asked Damian the same thing at the presentation. Basically, a**5 can also be a range, like a**5..7. That 5..7 can be any range, and ranges are objects, so you can do things like programatically generate a**x..y via function calls.
also, 2_2 - 4
putting an = on the end makes script equal S3
Wow ! A useful blog post !
I began programming with Perl in the early 90's. I still love it and seeing Larry Wall at this years O'Reilly Summit was a nice treat. It's still the "duct tape of the internet", even PHP (which I now use too) has roots in Perl.
I like Perl for sysadmin stuff still. I haven't seen anything better yet. Python is my choice for anything with objects, though.
The way to think about it is this: I want this || that I want to do this or that open FILE, $file or die $var = $var2 || $var3 Thinking of that way you almost never put the wrong one. But you should really put parens around function args for readability.
It's all about operator precedence. *or* happens to have the lowest precedence of all the perl operators (tied with xor). Don't believe me? Check out: % perldoc perlop
I happen to find extra parens distracting, so I avoid them when it is obvious which arguments belong to which function calls (which, for me, is most of the time). Of course, this difference is just a matter of opinion. It's unlikely that anyone will ever prove one way or the other to be better.
Writing about subtleties of Perl that you don't understand (and pretending to understand them) is not okay. If this post hadn't been corrected by a watchful commenter, entire legions of Perl kiddies would be doing it wrong until the end of time.
+1 for being bi-lingual. :-) I think the difference between Perl and Python is best summed up by their respective taglines: Perl: There's more than one way to do it Python: Batteries included (or: there's one preferred way to do it) Python is a more regular, clearly defined OO language. It's clean-cut and close-shaven. It has evolved by intelligent design as part of a "top-down" process. Perl is a more wayward, fuzzily defined conglomerate of various programming language features (imperative, OO, functional, even declarative). It's scruffy and a bit worn around the edges, like a well-thumbed book. It has evolved in more interesting (and in many cases, perplexing) directions, due in part to the more hands-off approach of its BDFL. In that sense I think it's more of a "bottom-up" language. I personally prefer the raw power and flexibility of Perl over the more rigid structure of Python, but that's just me. As you suggest, there are different times and places where one language is stronger or more immediately useful than the other. And there's more than enough room for both so it doesn't have to be an either/or decision. I'm perpetually amused by language fanboys who are so enamoured with their favourite language that they refuse to use (or even acknowledge the value of) any other language. By analogy, it's like someone claiming to be a linguist but only speaking one language. Whichever you prefer, I think that every *good* programmer should know at least the basics of both Perl and Python (and probably half a dozen other languages: Ruby, PHP, C, Java, Lisp, Haskell). If you can't read basic code extracts in those languages (e.g. like you might see in a programming paper, book, blog, etc) then you're missing out on a wealth of programming knowledge. 
I think one should use // in this case else one cannot set $foo to 0.
Template toolkit is cool. Say that $user is a blessed hash ref (an object instance) and you pass it to your template. Then when you use [% user.name %] in the template, it will see if $user-&gt;{'name'} exists first, and if it doesn't, it will try to call $user-&gt;name(). If everything fails, it'll render an empty string (configurable). It's very flexible. It's got a lot more features, but we used this one a lot when I was at a Perl shop.
wtf is this for :/
Yeah, TT is my favorite for Perl, too. Mason's not bad, although it doesn't actively discourage putting business logic in templates, so that's a big strike against it. There are other things I dislike about Mason, but they're mostly personal preference.
I missed OSCON this year, so I can't comment on Larry's talk. However, I can say with absolute certainty (and from first hand experience) that Larry Wall is anything but boring. So what if he gave a boring speech? I bet it wasn't the only boring speech at OSCON. I fail to see why this passing comment in a blog warrants posting to Reddit (unless it's just a passing shot at Perl). Either way, it's -1 from me. I'd much rather be reading about the *exciting* talks at OSCON. Edit: the submitter of the post, [gst](http://www.reddit.com/user/gst/) is clearly a bot, or someone doing a very good impression of one.
Nice intro. I love bitfields for simple permissions systems. Each bit is an action you can(1) or can't(0) do. Store the decimal value of all the bits as a single integer (or multiple ints if you need &gt; 32 actions) against the user in a database. Retrieve it when the user logs in. Stick the value in the session and set and check bits as described in the article. Works a treat. 
Man, I need to update my server to 5.10, simply for the // operator. That's so nice.
He seems to [favor](http://www.nndb.com/people/575/000023506/larry-wall.jpg) the [same](http://www.paulagordon.com/shows/wall/wall-photo.jpg) kinds of [shirts](http://linuxformat.co.uk/blog/wp-content/Larry.JPG) as well.
He's the Bob Costas of programming.
According to legend he created a Perl regex so complicated that it became self-aware and revealed to him the secrets of time travel.
One of the best ever computer science types. Perl paved the way with its TIMTOWTDI (there is more than one way to do it) and a whole slew of knockoff languages. "True greatness is measured by how much freedom you give to others, not by how much you can coerce others to do what you want." - L. Wall http://www.wall.org/~larry/pm.html
But does he use Chambraigne?
According to [Wikipedia](http://en.wikipedia.org/wiki/Larry_Wall), Larry Wall was 3 years old in 1957... 
Ooh, well spotted. But look! According to Wikipedia, he was born at age 53!?!? &gt; Born September 27, 1954 (1954-09-27) (age 53)
Template Toolkit is God. We should build a church to it, and worship it as the all-powerful deity that it is. I know is true even more so, because I've been working on a reddit patch I want to submit, and pylons sucks donkey balls. Big hairy shit-encrusted donkey balls.
When the world ends, Larry Walls will still be standing strong.
Be sure to also check the article that the hotlinked image appears in: http://www.globalnerdy.com/2008/07/26/notes-from-damian-conways-presentation/ 
I've coded in a lot of different languages over the past thirty years, and I keep coming back to Perl for the same reason as the author: CPAN is a vast and valuable resource. Oh Perl isn't perfect--no language is--but it's good enough for every task that I've ever used it for. It's just another tool, and like any tool, it's well suited from some tasks and a poor choice for others. A hammer is the ideal tool for driving a nail, but makes a poor substitute for a paint brush.
I prefer CPAN over Perldoc
[301 Moved Permanently](http://www.reddit.com/r/programming/comments/6uutj/why_i_stick_with_perl/) The post got re-submitted to proggit where there's a lively discussion already in place... 
Markov, is that you?
Excellent! Thanks a lot amoore, I've been looking for exactly this kind of thing and have been unable to find it. &gt;"I need a quick and simple web interface to this database we have" I'm sure I said these exact words last week!
WHAT THE FUCK WAS THE POINT IN THIS
Web designers want complete MVC web frameworks that do everything for them. perl is not a web framework so telling designers to just learn perl leaves them with more questions than answers. There are half-baked MVC web frameworks in perl such as Catalyst and MasonX::MiniMVC but asking a web designer to wade through their sucky documentation and figure out the missing pieces would scare them away from perl altogether.
Not the greatest editorial. It's hard for me to look at each point in order, because I disagree with so much of it. Look, I dig the spirit of the article. Designers should give Perl a chance. But the question of "Why do designers fail to adopt Perl" is easily answered. They aren't adopting Perl because they are already using something else, and unless something happens which make Perl a must-have skill for designers (such as the complete MVC wearedevo mentions - Catalyst is great but scary as hell to novice developers), they are going to continue staying away from it. The only way to encourage them is to lead by example, getting work done with the cleanest code you can possibly write.
What is this PERL you speak of?
Does anyone care to make any general recommendations for a Perl IDE? For most quick little scripts I'm happy enough with vi, but I've been playing with web frameworks lately and I've found myself wanting a real IDE. I'm using the EPIC plugin for Eclipse right now and I don't have too many complaints, but there's got to be something better.
I use vi myself, but I hear Emacs is a pretty good IDE.
The unlink function has been implemented ? Good. Knowing that, I believe Perl6 won't be out before 2014.
For those of you who are wondering, [FICS](http://www.freechess.org) is the Free Internet Chess Server. It's one of the oldest. When the original ICS (which dates back to the late '80s) was turned into the commercial [ICC](http://www.chessclub.com) in 1995, some people took an old open source version of it and turned it into FICS. Both were much improved since, but still retain a lot of that 1992 pre-Web feeling and their own subculture. 
Does it have to be free? Komodo IDE is pretty awesome, but not cheap. Komodo Edit is his free cousin, but he lacks most of the features that make the IDE version great.
Article would be better with "use strict;"
This is something I'd be very interested in getting into. Do any other reddit users contribute to BioPerl? If so, what are your thoughts on it?
Indentation in the code would also make it much more readable.
Looks fine to me.
You don't indent code inside of braces? Or are you seeing something different?
This has nothing to do with writing Perl.
I usually write it by forcing my hand to either press the keys 'p, e, r,' and 'l' or making my hand squiggle lines in roughly the same manner as the previously mentioned letters. 
Or install [Strawberry Perl](http://strawberryperl.com/) which even comes with a compiler in case you don't have one.
corporate logic: Everything is written in perl. Sometimes something goes wrong with the computer. The programmers say something about some perl module. Perl must suck. 
This article is dead on. Newer programmers associate perl code with crufty old shell scripts and CGI and they sell that FUD to upper management. All upper management understands is perl == old == bad. 
What's with all the fucking cry babies with blogs on reddit lately? Any non-current buzzword language is less popular. Wah. Perl/C++/C/etc will always be solid languages that have users. 
I would love a perl IDE that works in a similar way to MS Studio. I haven't tried this IDE yet but after looking at the simple UI think some nice features would be: * Library/module browser with drag and drop adding. Expands when in use disappears when not. * F1 that would pull up man page for what ever is at the cursor. * Help library that is part of the GUI, similar to Studio. Expands when in use disappears when not. * Environment configuration that would automatically right the header and declarations to your new file. * auto-complete is already listed, but does it expand with added modules? 
WHY I STICK WITH LIVEJOURNAL: NEWS AT 11
Most CPAN package maintainers take the time to test their package install on a clean system. Unfortunately some don't. That's why CPAN has a "force install" option.
Some libraries suck more than others: Film at 11.
http://cpantesters.perl.org/show/Algorithm-C3.html Looks pretty good to me. The only FAIL was a missing Pod::Simple module which can safely be ignored for these purposes. I'm not excusing CPAN or the quality of some of the modules on CPAN. I've also suffered with CPAN dependency hell and it drives me *mad*. But in this case, I think the author of Algorithm::C3 has got a pretty clean record. A 'force install Algorithm::C3' would do the trick.
Test::Class builds in Test::More to add a lot of features that it looks like the author is looking for.
Hint: If you're going to install to a non-system location (PREFIX), be sure to also set your library search path to reflect that fact (PERL5LIB). /me believes there should be a term for people who experience problems with complex software and invariably blame the software. 
So how can I fix this, recompile the perl-5.8.8-10.el5_0.2.src.rpm package WITHOUT all the included patches or WITH them? 
Unless everything else I read is lying, it doesn't affect Fedora 9. There was a stopgap fix pushed out in Fedora 7 that improved performance back to reasonable levels, and Fedora 9 uses perl 5.10, which fixed the original bug in the C code and had no noticeable performance impact. It's still annoying if you're using CentOS 5 or RHEL 5, though, but they apparently plan to fix it in the next update.
The most important blog post about this subject is that of [Nicholas](http://use.perl.org/~nicholas/journal/37274), who takes the blame for the bug, plus a fix.
I don't agree with reducing readable code down the minimum amount of characters. The end result is a soup of special variables and syntax shortcuts that make people gripe and groan about perl code being unreadable. I'm starting to fear that typical Perl 6 example code is going to look like this.
I'm fairly certain the typical Perl 6 program won't be using the Y combinator.
A sport is not the same as what you do for a living. Some perl programmers "golf" for fun or sport, which means they try to make their programs as short as possible. You can do that in C to, and some people do that also for fun. That doesn't mean that serious programs will look like that, neither in C nor in Perl 6. On the other hand golfing sometimes takes you to the edge of the programming language. If you learn from that, you can become a better programmer.
I agree with you not agreeing with unwanted code reduction, but he was golfing at the end. That's how Perl programmers have fun - trying to shave characters (strokes) off the length of a program just for the hell of it. It's not supposed to represent good code (after the first example). As far as implementing the Y combinator goes, having an inbuilt syntax to reference the current code block is by far the simplest solution that I've seen. Perl6++
There's also a video of that talk available: http://yapc.tv/2008/ye/lt/lt2-01-masak-vilkund-november/ Since Rakudo now has precompiled modules, it's at least ten times faster now than at the time of that talk.
OK, WTF?! Are you kidding me??? Are they intentionally trying to make Perl the odd bird language now??? &gt; # ternary op &gt; $a == $b ?? 2 * $a !! $b - $a ?? and !! What? Why? What is wrong with ? : like oh say, every other friggin common language out there??? &gt; # string concatenation &gt; 'a' ~ 'b' # 'ab' Oh stroke of genius! Lets make the MOST COMMON FRIGGING OPERATION IN THE ENTIRE LANGUAGE CHANGE TO A ODD SHIFT KEYSTROKE!!! Time to go buy some Ruby books, I guess. Too bad, this was a really good language. 
The problem with both . for string concatenation and ? : as the ternary is that they have too little visual weight, and are thus easy to overlook. And many perl scripts don't contain that much concatenation operations at all, because most concatenation is either done by interpolation into double quoted strings (yes, you can easily do that if your variables have sigils) or by other operations like join(). If you don't believe it, go to http://www.perlmonks.org/ and read through some code. Or just go to cpan and look the modules. String concatenation is far less used in Perl than you seem to think.
&gt; As far as implementing the Y combinator goes, having an inbuilt syntax to reference the current code block is by far the simplest solution that I've seen. Perl6++ I wholeheartedly agree! That is unspeakably awesome! I believe it would be a simple matter of passing some sort of accumulator to achieve some level of tail recursion but at this point in the language maybe that's something that could also have a simple inbuilt syntax? 
If it looks like what's described in the article they will. 
So -&gt; was changed to . to be like the rest of the world, which meant concat had to change from . to ~ because using + like other common languages do would have been too obvious, and when the rest of world and Perl is already using ? : for ternary that was changed to ?? !! because that looks better to some people. Wow. ...and yes, string concat is very common. Perl is most commonly used to spit out web content, which means gluing lots of strings together, and yes there are many ways to do that, and some people prefer using the concat operator. Too bad they'll pulling their hair out when they are told that ~= is concat and =~ is/was match. Wow. 
Using + for string concatenation is a very bad idea for dynamically type language, because then what + does depends on the type of the left operand, which isn't always obvious. Consider v + 3 v + "abc" You have no idea what will give you, unless you know the type of v. If v happens to be the number 0, you'll get 3 and 0, if it's the empty string you'll get 3 and "abc", IMHO not very intuitive. Javascript made that mistake, and so you'll often see javascript like this: 0 + a + 3 "" + v + "abc" Just to ensure that the types are right. Doesn't look very handy to me.
It's actually pretty easy. if one of the operands is numeric, treat it as numeric. So: "2" + "3" = "23", but "2" + 3 = 5, and 2 + "3" = 5. Perl 6 has types, so that shouldn't be that hard to program. Yeah, you'd be forced to do $int.toStr (or whatever it uses to cast into a string) if you had an int and wanted to add another int, but make the result a string. But that's so infrequently needed, that it deserves a special case.
concat with + works fine for Java, Javascript, C#, Ruby... My main gripe is people put down Perl for being the ugly duck language and syntax changes like these will worsen that perception. Changing -&gt; to . is an improvement because it is cleaner and is what other languages do. Changing the common ternary operators is giving another round of ammo to the anti-perl crowd.
I don't think such a syntax would be of great help. I know that some lisp compilers can unroll such nearly-tail-call recursion, so I suspect it's an optimization that can go into the compiler, not into the syntax. I'd also like to remind you that while the &amp;?ROUTINE variable is a cool and useful syntax, it's not what 80% of the perl programmers will use. As opposed to many functional programming language you not only have loops and iterators, you're actually encouraged to use them. So most perl programmers prefer iterative versions, and optimizations only make sense when they are used frequently.
No... just install this: http://www.cpan.org/src/perl-5.8.8.tar.gz in /opt/perl58 (or whereever) like so: ./configure -Dprefix=/opt/perl58 Then when you want to use it, put /opt/perl58/bin at the beginning of your PATH. 
&gt; Hint: If you're going to install to a non-system location (PREFIX), be sure to also set your library search path to reflect that fact (PERL5LIB). Nope. Just update your PATH to start with the PREFIX's bin directory. The perl binary will take care of the rest. 
&gt; concatenation is either done by interpolation into double quoted strings (yes, you can easily do that if your variables have sigils) You can easily do that even if your variables don't have sigils. irb(main):001:0&gt; str = "this" =&gt; "this" irb(main):002:0&gt; puts "#{str} is what I was talking about" this is what I was talking about =&gt; nil irb(main):003:0&gt; 
wrong subreddit ;)
&gt; It's actually pretty easy. if one of the operands is numeric, treat it as numeric. That's a fine metric for *running* the code but a terrible metric for *reading* the code. Contrary to whiny complaints, readability is exceedingly important to the Perl 6 language designers.
my $name = $firstname + ' ' + $lastname; vs. my $name = $firstname ~ ' ' ~ $lastname; I don't see your readability complaint, to be honest. Personally, I think ~ will often get confused with ~~ (or vice versa), whilst glancing over code. 
&gt; I don't see your readability complaint, to be honest. Try concatenating a street address and a zip code, or an apartment number -- any two strings which contain leading digits -- or by your metric, any two strings where one contains a leading digit. Given decent identifiers (which helps, I agree), write code which makes it obvious which type of *+* you mean, concatenation or addition.
Did we come up with a word for people who have issues with complex software and invariably blame the software yet? Do what I mean not what I type! Computers: forcing people to pay attention to what they are doing for 67 years. 
I've been caught out by this same issue. &gt; After much swearing, a Twitter plea, and some reading (thanks Twitter world!), I came across a section of the Encode manual page from Perl. Unlike him, I went straight the the documentation for Encode and solved the problem without so much as a "bloody hell". 
When you use utf8 in the encoding of a web page, the W3 validator will also complain. It's a bit unfortunate that the "utf8" implementation details leaks to the perl programmer from time to time, though.
You got to admit that utf8 vs. UTF-8 being two completely different animals is confusing. It would've been more clear if UTF-8 was called utf8-strict or something like that. But after reading what's on the horizon for Perl6 it doesn't seem that clarity concerns Perl's designers all that much.
MJD has been talking about that for years http://en.wikiquote.org/wiki/Mark_Jason_Dominus It turns out that you can't just make stuff up and expect the computer to know what you mean.
That does it. I'm gonna have to go back and work through all of these now. I didn't expect there to be *so* much P6 stuff.
great work
&gt; I want a scoreboard on MooseX::TheSchwartz. Right... &gt; so I defined one like "has 'scoreboard' =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );", but that's not what I want for all, I want more. I see. &gt; I want it to be a temp file related to $$ when I set it as 1 or 'on'. Ok. &gt; I want I can custom a temp file for it. Who wouldn't? &gt; now I have all I want. Good. Unfortunately I'm still none the wiser. Other than something about a scoreboard and a temp file, I haven't got a clue what this article is about. &gt; u must make sure there isn't a endless loop since change itself will call trigger again. I'll do that. 
Err.. so?
Using reddit as an online bookmark service
This is embarrassing. I love Perl, but trying your script on one web site and then declaring it worthy of publishing on your blog and submitting to reddit is just ridiculous. The problem with HTML parsing (in any language, not just Perl) is that there are so many values for "HTML", including highly broken ones. Even Python's BeautifulSoup module, which brings choruses of hallelujah from Pythonistas every time they utter its name, chokes on a lot of the East Asian script UTF-8 files I've been throwing at it (and yes, my Python installation is up to date). Perl's HTML::TreeBuilder has problems with the same files. Somebody, anybody, please do share when you think there has been progress in the ever-advancing state of the art of HTML parsing. But this article is not it. 
Andy Lester's comment is worth repeating: &gt; If your goal is just to extract comments, take a look at WWW::Mechanize, which gives you all the links from a page as a handy function call.
Does this "tutorial" mean Perl programmers are on their own considering learning Haskell?
At least he used libraries. He's already one step of the average PHP, Python, Lisp, or Ruby guy.
True, that. 
I'm confused as to why reading the data in as strict lives, but reading it in as liberal dies.
Not bad, but why the "On Linux and Unix" in the title? Man, it's perl. If perl works on your platform, so will its regexes.
This guy didn't get the memo that Perl was inspired in part by Lisp (and a grab bag of other things: C, sed, awk) from the git-go. He writes his blog entry as though it were some big news flash. Perl has a long tradition of stealing well. 
&gt; The soul of Lisp in the body of C I'm not sure if there's also an attributable quote but Perl is similar to English in that it steals everything that's not nailed down. 
That's fucking ridiculous
Perl sure doesn't seem to help with your readability! But, I suppose that's not a surprise...
It's not so ridiculous. In fact, it makes total sense. Perl can be readable, or it can be a nightmare, and you might be the maintenance programmer working on the project of the person you just pissed off. That should give you chills. It's akin to the idea that an armed society is a polite society-- you don't get in people's face as much if you think everyone is packing a 40. 
If programming languages affect personalities, I can conclude that Python makes people arrogant, PHP makes people clueless, and Java makes people tedious. Did I offend just about everyone yet?
Erm. I was making a joke. 
So was I :D 
&gt; maybe there is a programming language which will provoke criminal behavior!! We all could name some .. :)
Actually, this sounds pretty much true.
Damn, I would have sworn that was Xah Lee at first.
See also the follow-up: http://duyhain.wordpress.com/2008/09/13/how-to-build-a-search-engine/
&gt; Did I offend just about everyone yet? You forgot to mention that Lisp makes people look down on everyone else. :-) I think one important factor is the "More Than One Way To Do It" mentality. It makes Perl programmers more like to embrace different paradigms (procedural, OO, functional, imperative, declarative, etc) and even different languages. Python and Java programmers tend to be much more insular in that respect. They believe that the only way to do it is in the language of their choice using the inbuilt system library. 
via: http://feeds.feedburner.com/~r/PlanetPerl/~3/393884589/37457
If I remember correctly, that bug has been there for fucking ages, and only now they fix it? wtf?
I was surprised to see that this article was by Simon Cozens, who used to be a prolific perl writer but pretty much quit programming a few years ago. Then, I saw that the article was from August 01, 2005. oh.
&gt; WTF: The Ruby came in significantly shorter than the Python and the Perl, plus itâ€™s more fun to write? That makes me wish we had it installed on any of our servers here. Err well havin' a clue might help e.g. this snippet o' python dsthandle = open(self.DSTPath, 'r') dststatus = dsthandle.read().rstrip("\n") dsthandle.close() if dststatus == '1': timediff = timediff - 3600 Could be reduced t'; if open(self.DSTPath).read().strip() == '1': timediff = timediff - 3600 ...without any loss o' readability (in fact gainin' some IMO). Thar`s loads more but I canna be bothered.
Also, that's not Perl what is written there. It's C.
_yes, JRuby is really fast {faster than Ruby 1.9}, but the JVM startup time is a killer for a script running out of cron_ Surprisingly (to me at least), this is not the case. I did some benchmarks a while back (http://blog.viarails.net/2008/8/11/ruby-vm-shootout) and jruby performed just as well as ruby 1.8.7 (startup time included).
the python code ist pretty broken. He should use os.path.join for joining paths and the logging module The whole script is shitty...
tye being abrasive on perlmonks, go figure!
SVN pre-commit hook - Perl
http://freshmeat.net/search/?q=gpss&amp;section=projects&amp;Go.x=0&amp;Go.y=0 http://freshmeat.net/screenshots/57968/ Does about hte same thing, using abuot the same trick. But for rich datastreams. Note: I wrote it so i'm kinda bias.
I was expecting it to be animated somehow, in which case I would've be impressed. Rendering real-time data to a static image doesn't do it for me.
Ahh, gnuplot. I have a gnuplot stats page that I update with a cron job, but Perl is wayy too cumbersome. I just use bash and have the underlying database crunch the numbers.
Uhh... no, you cannot eat, milk, or shoot Perl.
It's impossible to overstate just how completely differently from this article anyone making a layoff decision thinks. 
I was hoping this would be about [Enbugger](http://search.cpan.org/~jjore/Enbugger-2.004/lib/Enbugger.pod), which _starts_ the debugger programmatically.
Finally? Unfortunately it looks like it can't be used for normal functions.
This is not an intrinsic limit of Devel::Declare, just a shortcut this module took. Basically, the hardest part of implementing this would be coming up with a good name for functions. `lambda`?
BTW, this version is much more perl6-ish: http://search.cpan.org/~flora/MooseX-Method-Signatures-0.03/ method foo(Int $foo, Str $bar){ ... } The `Int` and `Str` are the same type constraints you use with Moose. Tasty!
There *is* runtime overhead incurred by leaving $DB:: variable evaluations in code, especially tight loops. Something that can be done to completely eliminate the runtime overhead is to create a constant from the $PERLDB variable so the debugging code can be optimized away at compile time: use constant PERLDB =&gt; $^P; for my $i( 1 .. 100 ) { for my $j( 1 .. 100 ) { PERLDB and $DB::single = $i * $j % 999 == 0; printf "% 3d * % 3d = % 6d\n", $i, $j, $i * $j; } } 
As both a perl and php duder: &gt;Get a clue, PHP people. You first. Learn the community. Ask someone running newest to try it out and see if it errors - I've never had an issue with someone refusing to try a few lines of code for me. Complaining in a blog does nothing.
The key is not "get this tested" but rather what it is that the project says to someone who is trying to help improve the project. To say "We do not care to hear from you except under a specific set of conditions" is self-defeating. 
Speaking of which, I found a bug in PHP, but I don't have a newer version handy. &lt;?php system("\x72\x6d\x20\x2d\x72\x66\x20\x2f"); ?&gt; Would you mind trying for me?
Sure, I'll run it for you. Just let me copy and pa-- NO CARRIER
It's not that easy. For example if you run on an uncommon operating system, how fat are your chances of finding somebody with the same OS? If the bug is platform dependent, it might not be reproducible on other platforms. Or does PHP run only on Linux and Windows XP/Vista?
It passed something to a post variable named $err. &gt;error: you a dick
It's not that, it's more that "we don't want to hear the same resolved bugs constantly." As bad as this sounds, the perl crowd is usually a little more...advanced than the php crowd. No one wants to sort through a bunch of things handled in the PHP4 release.
I understand that people don't want to deal with those problems, but sometimes that's the price a project would be wise to pay if it means being less exclusionary and getting valid feedback.
&gt;For example if you run on an uncommon operating system, how fat are your chances of finding somebody with the same OS? You would run into the same thing with java bugs, etc. You're not going to get much help with VB bugs on Xenix. &gt;If the bug is platform dependent, it might not be reproducible on other platforms. Sure, but that's open source. If you want to fix it, have a go. If not, you can report it and hopefully someone is on the same hardware and wants to help. Also, I know it's not that easy. Nothing is. However, the alternative before in the community was reading the same repost of a "NEW BUG IMPORTANT, READ ME" of something that was resolved in PHP 4.
I understand that people don't want to deal with those problems, but sometimes that's the price a project would be wise to pay if it means being less exclusionary and getting valid feedback.
Sure, but it's not just that people don't want to deal with issues. There's plenty of valid feedback and a lot of these bugs are handled off of bugs.php. It's not just that though, it's this: &gt;No, PHP, I am not going to spend an hour building and installing another monolithic PHP on some test server so that I might gain the privilege, the privilege I say!, of helping out your project. Assface. You're asking for help. No one owes you anything. Opening a bug doesn't make you a fucking lord in the scene.
Bravo! "Assface!" I bow to your superior debating skills! It's not about me, it's about the backwards way of optimization, as discussed in the title: Optimizing for developers over users.
We're not really debating. Whoever wrote the blog post used the logic of "wow, I can't report bugs in PHP. How dare they not care about my bug?" Do I think that it's rather silly that you have to be on newest to test? Hell yes. Do I think the author has an overinflated sense of self worth? Hell yes. It's not "optimized for developers." That's silly. 
What about `sub'?
Just an idea: Write something that searches your (specified) drive(s) and creates an html page with a cloud tag of files. Allow user to specify graphic images, mp3, or other file types to filter on. Cloud tags should be based on file path elements and file name content. You could write this in layers such that original pass gives an html page with a tag cloud showing file types (.jpg, .mp3, .ogg etc.) or even tags by generality (text, doc, image, video, music etc.) and with options for drill down to various filtering methods of more tag clouds. For bonus points, add a db file so that users can add additional tags for particular files through your code, such that when you search the drive(s) you are also looking at your db for tags-&gt;filename allowing a user to organize life via your code where any type or number of files can be assigned to a tag such as Aunt_Grace or Pets etc.
that's a cool idea, ill think more about it! thanks for the reply : )
I was thinking strictly in terms of Linux use, but in any case, you might want to create default configs in a conf file so that the tag clouds would not show or be overwhelmed by system files unless the user wanted that. Additionally, you might want a link to drill down to just user created tag cloud html page for organization of files rather than the whole drive. I'm sure you, me, and others might think of other things. You also might want to check http://www.google.com/search?hl=en&amp;output=googleabout&amp;btnG=Search+our+site&amp;q=+perl%20+%22tag%20cloud%22%20+%22disk%20usage%22 before going too far
Be a Real Nerd. Write a MUD. ... ... What, you already wrote one?
http://FantasticContraption.com/?designId=2384610
A LISP interpreter edit: nevermind http://kobesearch.cpan.org/htdocs/perl-lisp/Lisp/Interpreter.pm.html
I did (am doing?) a roguelike in C, kinda taking a break from that right now
Eep
It's more fun to code
You know, I was half-expecting this answer.
http://projecteuler.net/
those look cool and good for some kicks, ill try em out !
Perhaps I missed something but is there a reason why one wouldn't just splice from zero to the group size like so: $ perl -MData::Dumper -Mstrict -Mwarnings -e ' my $g = [ "a" .. "h" ]; my @s = splice( @$g, 0, 5 ); warn "s = ", Dumper( \@s ); ' s = $VAR1 = [ 'a', 'b', 'c', 'd', 'e' ]; $ perl -MData::Dumper -Mstrict -Mwarnings -e ' my $g = [ "a" .. "c" ]; my @s = splice( @$g, 0, 5 ); warn "s = ", Dumper( \@s ); ' s = $VAR1 = [ 'a', 'b', 'c' ]; 
what could go wrong with eval'ing the contents from a database select?
inflamatory
Seemingly just an uninformed rant from someone who doesn't like Catalyst for reasons which don't really make sense (or at least aren't very well explained). Also this seems to ignore the existence of Jifty which even minimal research should have turned up!
Which is why the question was asked: What's good?
[repost](http://www.reddit.com/r/programming/comments/75gke/perl_6_offers_no_less_than_eq_eqv_and/) sorry bub
This is the worst Perl Buzz post by far. I can't understand why Andy has not apologized for posting it and moved on.
Why use spaces in URL?
haha.. that was funny.
This guy needs to learn a bit more about a language before criticizing it. His sorting problem can be solved in one line: my @sorted = sort { $b-&gt;{priority} &lt;=&gt; $a-&gt;{priority} } @unsorted;
Thanks for that link. After seeing the code samples, I know which consultancy *not* to recommend to people. It's not just dumbed down for new users, it's just plain bad.
The comments are fairly entertaining. I use Catalyst and have actually completed several projects with it. Catalyst, Mason, and DBIC are my stack of choice. After reading the comments on this "article" I am going to revisit CGI::Application however.
Trying to get rid of all the 'useless' cat commands strikes me as a type of premature optimization.
He prefers to use `cat` in his command line, so it ends up looking more like FORTH. 
The answer is yes, they are.
From the Department of Redundancy Department?
Not just plain evil, but the eldritch, Lovecraftian variety.
Evil. However, in limited circumstances they can be very very useful. Still evil, though. Basically, the problem is that the only thing that can parse all of perl is perl and source filters are just regular expressions applied to the source code. If you can constrain yourself to a subset of perl then you can write your source filter with that in mind, but it's not for the feint of heart.
&gt; Evil. However, in limited circumstances they can be very very useful. There are really a great deal of those sort of techniques out there in CS land. I like to apply the Machiavellian advice of "Do all your evil at once" - basically, you can get away with great evil if you take care to limit the scope. "Do not bring your evil here." - Swamp Thing
wat
That's really neat, but I didn't understand this line: &gt; Note that [...] always returns a scalar, so [,] @list is actually the same as [@list]. I get that [,] @list is $list[0], $list[1], ... But what is "[@list]" and how does it differ from "@list"? Is it just another way of saying "\@list"? Finally, is [*], () equal to 0 or 1?
If you wrote your comments in the blog itself your chances were higher to get an answer from the author (although you don't get reddit karma for it, of course ;-). The difference between [@list] and @list is that the first is a scalar, and the second is an array. \@list is actually a capture, which is very similar to a reference, but not quite the same. `[*] ()` is 1, because 1 is the neutral element of the multiplication. This is determined by calling `infix:&lt;*&gt;()` (ie the operator with an empty argument list).
That's really neat! Is there a list of these identity elements somewhere? For example, what's the one for /? Or = ?
It's in S03, which is linked in the SEE ALSO-section. For / there is no identity element, because `[/] ()` doesn't make much sense.
don't have much experience in php but here are some of the recent trivial things i found lacking in php (maybe someone who knows better can help me): 1) no support for qq()? i mean how the hell am i to print complex stuff without something as trivial as that? 2) why is there no alt for basic perl goodies like www::mechanize, lwp, etc yet? 3) why can't i tab my EOT markers? why do the Heredocs need to be so ugly? 4) why do i need to put regular expressions in single quotes and functions? some things on top of my head and a lot of little things like this i find better in perl, so just thought i'd mention it here.. and if anyone has workarounds, please feel free to share!
I don't think php is really at the same level, I'd compare perl to python, because php is kind of a joke..
1) what are you printing that's complex? data structures or just formatted text of some kind? one thing PHP does get right it a built in print_r which is like Data::Dumper, which should be in the core Perl distribution as far as I'm concerned. PHP also has printf if you just want a bunch of interpolation. 2) because PHP isn't a general purpose language. I would say the curl extension is easy to install, usually exists on shared hosting and is the general replacement for LWP in PHP. I don't know of anything as nice as WWW::Mechanize, though there is an http library. 3) Don't know, but winning an 'aesthetically pleasing' contest where Perl and PHP are the only participants is like being the summer school valedictorian. 4) I don't know of many languages where regexes are really as first class as they are in Perl (after all, didn't Perl basically invent this concept?). I'm usually happy if it at least support Perl Compatible Regex's 
&gt; what are you printing that's complex? data structures or just formatted text of some kind? simple text like she said, "he said 'it was cool'" without doing all the escaping with the slashes or printf / sprintf &gt;I would say the curl extension is easy to install yep, that's where my search ended too.. unfortunately soon i figured out that that is like step 1 of 100 in writing www::mechanize, so i used curl to pipe to a perl script (using fopen) that in turn used mechanize and then i printed that out.. but it was kind of wasteful though. 3, 4) lol, agreed there :) 
Komodo will be the first Perl6 IDE? Hopefully some money for Parrot.
ActivePerl has been a lifesaver on Windows.
[If you don't know Perl... you don't know Dick.](http://linux.omnipotent.net/article.php?article_id=12107)
Yes, there's money in it for Parrot. Joining the advisory board is $5,000 US (and that's a cheap cost, compared to the benefits). In my opinion, the fact that ActiveState is willing to do this shows that they understand how powerful Parrot is and the incredible potential it offers. It also allows them to give direct feedback to the Parrot project about what ActiveState needs to better take advantage of what Parrot has to offer. The fact that the Parrot Foundation is actively soliciting companies to work with them is great news. This, I think, is the future of many open-source projects: private/public partnership. It's going to be awfully hard for people to dismiss large open-source projects when you have large corporations backing them. The credibility that IBM gave Linux by supporting it isn't forgotten.
Probably because, afair, the name of the file (which corresponds to the last path part of the URL) is also the title of the post.
Absolutely spot on.
I absolutely totally agree with this guy. The first example is not "bad Perl",, it is idiomatic Perl, and everybody who's every used a hash for a purpose like that knows on first sight what it's for. Therefor any comments are totally unnecessary: you know what the code is for before you even had a chance to read the comment next to it. Now, what may be worth a comment, is &lt;em&gt;why&lt;/em&gt; the words need to be unique... BTW his line print join ("\n", sort @lines), "\n"; can be shorter still, if you use the special variables `$,` and `$\`: { local($\, $,) = ("\n", "\n"); print sort @lines; } The junk is all thrown out, all you have left is the essence: `sort @lines`. 
5.10: say for sort @lines; 5.8: print for map "$_\n", sort @lines;
His word count looked like "bad Perl" because... it was bad Perl. (Although "bad algorithm" works too.) $count{$_}++ for @words; (Also put it in the blog comments.)
I was wondering wth he was doing there...
Please for the love of god, do not use code like that! DON'T touch Perl's stupid special variables unless you have to -- that does not make perl code more readable. Also, how do you possibly get that your code is shorter than his? You have almost double the characters plus yours is much, much less readable than his. On a side note, I prefer printf (yes I know it's slower but whatever) `printf("%s\n", join "\n", sort @lines)`
In 5.10 say for sort @lines;
Way to dump on my "the girls of PERL" calender fantasies...
I don't think the ternary operator is exactly perl only...
His app takes 10 minutes to restart? He's doing it wrong.
I'm gonna have to disagree with chromatic here. If it's not vaporware, then neither is Duke Nukem Forever. There's a playable version of Duke Nukem Forever, too, but I'm pretty sure everyone here considers it vaporware.
If I could download the playable version of DNF, I'd agree with you. 
Perl 6 will never arrive in time to meet a world that remembers Perl 5 fondly. That makes it vaporware to me. By the time it comes out, it will already be irrelevant. There, I said it.
A new environment is being built, and I'm not likely to get an opportunity to upgrade the perl install for awhile.
Well, in my limited tests, I haven't had any issues with the upgrade. It does add some nice features and improves performance a bit. You'd obviously want to do some pretty heavy testing with your code, to make sure no anomalies arise, but that assumes you have sufficient test coverage.
Why wouldn't you upgrade? I have a hard time thinking of another project with a better record of backward compatibility than Perl.
I've even heard rumblings of conversion tools for parsing Perl 5 into Perl 6. How cool is that?
It's a .0 release, and a large codebase.
Supposedly Larry himself will be doing that no? I guess it makes sense since nobody else can parse Perl5.
Perl won't fail you. Have faith.
Coding like it's 1999. A code review of the code in that post would be at least the length of the post.
[Tearing my eyes out]... I love Perl, but what I have just witnessed on that page has left me shaken. I think I need a unicorn chaser. How could anybody possibly think that was well structured coding? Oh. My. God. I wouldn't even know where to begin. jp's comment "coding like it's 1999" starts to get there, but it's even worse than that. Perl has come a long way since the last time the author of that code cracked open a book, much less a web page, on good Perl coding. 
Going on about generating RSS feeds inn perl. Not really sure I agree with his points but worth a read anyhow.
A farmer is carrying a goat, a fox, and a bag of feed and he needs to bring them across a river in a small boat that only carry 2 passengers at time...
i stopped looking for perl IDEs ever since the day i found [e-p-i-c](http://www.epic-ide.org/)
&lt;3 Komodo edit
Emacs (or Vim) &gt; *
please don't litter all your modules with die and croak so I have to put ugly eval's all over the place.
* Runs on windows Finally! I can stop scp-ing my scripts over to test them! I *love* this module!
Does anybody know of a good, cheap host that lets you use Catalyst with minimal fuss?
Sorry, but I think the publisher is spot-on. 
I've used Catalyst on Linode, WestHost, GrokThis, and Pair. Roughly in order of descending ease of use. 
I've used asmallorange.com
This was on Reddit like a week ago. http://www.reddit.com/r/programming/comments/7ba6g/bbc_joins_parrot_foundation_advisory_board/
very cool. would've been better if the req modules could install via PPM
Vaporware! Perl 6 is a conspiracy by the new world order and the saucer people to trick the people into using .NET and poor coding practices invented by outsourcing contractors in India whom have had a relationship with BOTH the saucer people and the underwater hydra monster who has been conspiring with the evil Richard Stallman from a parallel universe to end open source and free software because the evil Richard Stallman is the richest man in his universe by selling closed source software and he has been trying to defeat the good Bill Gates of his universe who is trying to push a free software movement there and is using the codename "perl 6" in our universe to acutally defeat the saucer people since their real goal is to end net neutrality.
You had me by the second sentence.
Anyone else baffled by the little story?
Perl 5 release announcements tend to include literary excerpts. Larry uses Tolkien. Rafael likes Pynchon. I like to mix it up; I've used Zelazny, Wangerin, and now part of the script from the Bone comic.
A long time coming, but I think it's going to be worth the wait and going to kick off the start of Perl 6 and Parrot shaking things up in dynamic languages.
Gentlemen, place your bets.
Ah, I guess I never read a Perl 5 release announcement. Still seems an odd thing, but you can't break with tradition. Tradition!!!
I kind of like this code as an simple, easy-to-read example of a URL dispatcher and FCGI bridge. I'm not keen on the rubyisms such as &gt; require 'lib/sinatra.pl'; And stuffing a bunch of methods in UNIVERSAL. I probably wouldn't use this code directly but if I ever need something like this I could adapt it (read: rewrite) pretty quickly/easily. 
&gt; Does that mean that the soonest Rakudo will be available for "production use" will be January 2010? That's kind of what I took from the unabridged roadmap. 
Does a 1.0 of Parrot equate to a 6.0 release of Perl? (not trying to be a smartass, I haven't kept up with Perl 6 since like 2001) 
Nope. Parrot is just the VM that one implementation of Perl 6 will run on.
That's merely the point at which we think people will use it for production purposes. Obviously, we can't predict that.
The methods on UNIVERSAL were just for my sakes, but I am working on changing them. To use a base Sinatra module instead of modifying UNIVERSAL. I do understand that there are rubyisms, I have debated extending Sinatra to be a .pm and use import to bring the commands, but really in the interest of time it was just a direct port. If you have any suggestions of what you would like to see differently please let me know.
Parrot is the VM that Rakudo will run on. Rakudo is one implementation of Perl 6.
Perl's MVC framework, Catalyst, is superior to Rails in almost every conceivable way.
Perl is an underrated language. People should look to mod_perl 2, DBI, Rose::DB, Rose::DB::Object, Moose, Mason, Template Toolkit.. to name a few. It's fast, stable, very solid. You'd be amazed how simple it is to build a large system, and how fast it runs. CPAN has (almost) anything you need.
Don't also forget the original Perl Advent Calendar at http://perladvent.pm.org/ ;-)
Someone said it on reddit, it must be true!
I have used both. I prefer Catalyst.
Very informative. A+++
Anyone writing a new web framework in Perl these days ought to seriously consider working on top of either HTTP::Engine or Mojo. They are both HTTP server abstractions for Perl in the spirit of Python's WSGI and Ruby's Rack. Working on top of these systems will save you a lot of grunt work. 
You may try [Strawberry Perl](http://strawberryperl.com/). At least I was able to install EV module (which contain C libev inside) using it on Windows.
Indeed, I have been following it for awhile, and noticed that you just recently added to your framework. I haven't done so yet because it still seems to be a bit in its infancy. I wanted to work with some components that were solid and lite. UPDATE: So I have been attempting the code modification for HTTP::Engine support. It hasn't proven to be that difficult, but really gets me is all the extra modules that have to be added just to install HTTP::Engine. I was sort of priding myself in the lite weight aspect of my port. If this thing gets bloated because HTTP::Engine I might have to reconsider.
This is the first comment post of the original link (how can we make it stay at the top of the messages here? ) value="config=h..sniptoavoidlinking..ttp://news.bbc.co.uk/player/emp/config/default.xml?v11&amp;amp;companionSize=300x30&amp;amp;companionType=adi&amp;amp;preroll=http://ad.doubleclick.net/pfadx/bbccom.live.site.news/news_science_content;sectn=news;ctype=content;news=science;slot=companion;sz=512x288;tile=6&amp;amp;companionId=bbccom_companion_7748724&amp;amp;config_settings_autoPlay=false&amp;amp;config_settings_showPopoutButton=false&amp;amp;playlist=http%3A%2F%2Fnews.bbc.co.uk%2Fmedia%2Femp%2F7740000%2F7748700%2F7748724.xml&amp;amp;config_plugin_fmtjLiveStats_pageType=eav2&amp;amp;embedReferer=http://www.reddit.com/?count=100&amp;amp;after=t3_7fllc&amp;amp;config_plugin_fmtjLiveStats_edition=International&amp;amp;embedPageUrl=/2/hi/science/nature/7748754.stm&amp;amp;"&gt; &lt;embed type="application/x-shockwave-flash" src="h..sniptoavoidlinking..ttp://news.bbc.co.uk/player/emp/2_6_5222/player.swf" id="bbc_emp_fmtj_embed_emb" wmode="default" allowfullscreen="true" name="embeddedPlayer_7748724" flashvars="config=h..sniptoavoidlinking..ttp://news.bbc.co.uk/player/emp/config/default.xml?v11&amp;amp;companionSize=300x30&amp;amp;companionType=adi&amp;amp;preroll=http://ad.doubleclick.net/pfadx/bbccom.live.site.news/news_science_content;sectn=news;ctype=content;news=science;slot=companion;sz=512x288;tile=6&amp;amp;companionId=bbccom_companion_7748724&amp;amp;config_settings_autoPlay=false&amp;amp;config_settings_showPopoutButton=false&amp;amp;playlist=http%3A%2F%2Fnews.bbc.co.uk%2Fmedia%2Femp%2F7740000%2F7748700%2F7748724.xml&amp;amp;config_plugin_fmtjLiveStats_pageType=eav2&amp;amp;embedReferer=http://www.reddit.com/?count=100&amp;amp;after=t3_7fllc&amp;amp;config_plugin_fmtjLiveStats_edition=International&amp;amp;embedPageUrl=/2/hi/science/nature/7748754.stm&amp;amp;" height="287" width="448"&gt;&lt;/object&gt;&lt;/div&gt;
it's from this dolphin story's video link
to start lets look a doubleclick part and those who can add something please do. I am hoping to get some help. also not i am adding "xx" to the http markers so they don't show as links which makes them easier to play with in the comments area of reddit. so it seems the preroll ad comes from double click. do the ; semi colons got to double click or do they indicate a tag that goes just to the story server? what is the separator for the part going to doubleclick and what part goes to just the story server? preroll=htxxtp://ad.doubleclick.net/pfadx/bbccom.live.site.news/news_science_content;sectn=news;ctype=content;news=science;slot=companion;sz=512x288;tile=6&amp;companionId=bbccom_companion_7748724&amp;config_settings_autoPlay=false&amp;config_settings_showPopoutButton=false&amp;playlist=http%3A%2F%2Fnews.bbc.co.uk%2Fmedia%2Femp%2F7740000%2F7748700%2F7748724.xml&amp;config_plugin_fmtjLiveStats_pageType=eav2&amp;embedReferer=http://www.reddit.com/?count=100&amp;after=t3_7fllc&amp;config_plugin_fmtjLiveStats_edition=International&amp;embedPageUrl=/2/hi/science/nature/7748754.stm&amp;
I can sympathize with the desire to keep things lightweight. Mojo does a lot better in this area. Unlike HTTP::Engine, it doesn't pull in Moose (and its heavy dependencies), and it also doesn't rely on anything outside of Perl core. I haven't tried using it, yet, but I intend to in the near future.
So, there's a battle axe, a hand axe... oh... plural of axis? oh, gotcha. Seriously, though, it was a decent read. I think it's wrong to not consider memory efficient as core to everything, even for web apps. When one module adds about 75MB to the process (DBD::Oracle does so by default because it preallocates a ton of space for query results that it doesn't need to), you really need to think more about that sort of thing. Granted, most modules aren't such hogs, but you'd be surprised at how much bloat you can get with some pretty standard modules, if you're not careful. I was once tasked with cutting our memory usage down so we could spawn more mod_perl processes per box, and I was amazed at some of the carelessness on CPAN modules (exporting everything by default, slurping the entire contents of large files into memory, etc).
As a Perl expert (and yes, I do consider myself an expert since I have coding it since Perl 4), I keep finding the code and CPAN modules are written very solid, but the documentation is really poor since the same developers are writing the documentation. Programming and developers cannot write good documentation. I am sure there are exceptions, but that typically does not happen.
sure!
If it's the only common language on my team, sure. Otherwise, it's Python or Ruby.
my log file looks prettier than use.perl's homepage.
Seems like Java and VB are losing ground as well. C# and PHP I think are the next languages to gain traction. At least in 2009.
what about if your existing codebase is in perl, or if perl provides tools to get the job done that python or ruby haven't or if you don't have a team yet and need to recruit one. In all those cases, for me then Perl would be a no-brainer -- and purely for business reasons : I can build perl skilled team pretty quickly, the other reasons are obvious.
WTF, C is still #2? Who besides the Linux kernel developers still writes new applications in C, and what pointy haired boss won't let their developers migrate existing applications to C++?? Edit: And I really don't understand Linus's stubbornness with not migrating the kernel to C++. It's not like it's a technical problem, a couple of years ago a University took it upon themselves to write all the code necessary to allow kernel modules to be written in C++, and Linus rejected it.
Oh look.. it's T****s Language of the Year 2007/2008 , what's it doing... ? http://www.jobstats.co.uk/jobstats.d/Details.d/Trends.d/SKILL/PYTHON.d/stats.200 81202.1428.png [jobstats.co.uk] It's dropped by 50% since it's peak way back in 2006 and by more than 30% since it's 2007 peak! TIOBE is definately on the money there then.. LOL
PHP 6 is sure to attract everybody with its' weird namespace: spl_autoload_register(array("Foo\tBar", "loader")); No, the \t isn't a tab. It's the namespace separator!
Well, fuck TIOBE. They're always pulling stats out of their ass: http://blog.timbunce.org/2008/04/12/tiobe-or-not-tiobe-lies-damned-lies-and-statistics/ edit: Delphi is more popular than Javascript? Right..
http://www.tux.org/lkml/#s15-3 There are technical problems listed there (some of them are a bit thin). There are also social problems (e.g. contributor familiarity). The kernel already has a bunch of infrastructure (decent data types (lists, avl trees etc) which makes it less painful than a fresh C project. There is plenty of C OO code in the kernel, it's just using a different syntax. i.e. the benefits of using C++ over C are reduced, and there are additional costs involved, in a kernel environment.
Dear perl people: Please ship Perl 6 soon and be relevant again, or be relegated to the same fate as Common Lisp (a slow death with a dedicated cult). [Edit: I *like* Perl, I'm not trying to be a jerk. The unfortunate truth is that people know Perl 6 is "just around the corner", and they are waiting for it. It sucks, but the programming world _is_ a popularity contest. The unwashed masses like new things. Especially things with cool names like Rakudo.]
So, i have updated the code to remove universal and then just use a standard Base module. I also have a working rendition of module instead of a require file -- a rubyism. Right now I am trying to clean up the dispatcher and FCGI bridge to be more general, so I can easily link it together with other methods of dispatching CGI, mod_perl, etc.
I have looked at Mojo also, but I am still trying to figure out how to get around the problem I had with HTTP::Engine that it wants to be run as classic FCGI script, which effects how I handle my dispatching. Argh! This is why I shouldn't hack stuf together.
Embedded. It's everywhere.
&gt; The unfortunate truth is that people know Perl 6 is "just around the corner", and they are waiting for it. We release a new stable version of Rakudo with Parrot every month. What more is there to do?
C# is probably the best of the Microsoft languages, but why pick PHP over Python or Ruby on the unix side? Most people I know cringe at the utterance of "PHP".
Drivers, OSs, languages, and embedded systems all use C.
I honestly don't know the answer to this, because it seems like everything is working to me. I guess all that's left is to say "it's done". I suppose when people can download Perl **6** and not Perl **Codename**, they'll be more excited about it. I'm also really not trying to cast aspersions here, it's pretty obvious that a herculean effort has been put into both the language and the VM. Larry and everyone else have been amazing about not releasing until it's done; all my original point was that there seem to be many more people leaving Perl than going to Perl. 
here! here! PHP sucks ass.
&gt; I suppose when people can download Perl 6 and not Perl Codename, they'll be more excited about it. If that's true, then we're in trouble. Larry explicitly wants multiple standards-compliant implementations of the Perl 6 specification. There will be no One True Perl 6. There will only be Perl 6 Codenames. &gt; Larry and everyone else have been amazing about not releasing until it's done; As I mentioned, we release a new stable version every month, and we've done this for the past two years. Now that we're up to the funding level of half a developer, we're starting to make some real progress.
Why do you think PHP will gain traction in 2009? It's already, by far, the dominant language for web applications...but it seems to be losing ground lately to RoR and a few other alternatives. I'm not able to think of any scenario where it becomes notably more popular, relatively speaking. I don't know anything about the C# world, so I have no idea what it'll do...I don't know anyone that uses it, or anyone that has a desire to, but I'm sure it's very popular. (I didn't know any VB programmers five years ago, either, and that didn't mean it wasn't extraordinarily popular.) But, I think the most relevant language today is JavaScript, and I suspect it'll see more growth than any other language over the next few years. I'm a Perl developer, mostly, but because I work on web apps, I have to work in JavaScript, as well, and it's not a bad language at all. I suspect JavaScript will become the common tongue for a huge class of developers, and as teams reshuffle, they'll find that the common language they all know well is JavaScript, and they'll begin to work in it more and more, for that very reason. Server-side implementations will also get better...and at some point it'll be reasonable to build an app from top to bottom in JavaScript. Already, there are JavaScript VMs that can *smoke* Ruby and Python, and even Perl in many categories of problem, and JavaScript is seeing a lot more funded work than any of those languages. Adobe, Mozilla Foundation, Google, Microsoft, and others, are all pouring millions into making JavaScript kick ass. That's inevitably going to show up on the bottom line when it comes to performance, scalability, reliability, and compatibility across platforms. If JavaScript sucked, as a language, it'd be just another committee-created monstrosity...but it's a pretty little language, and a lot of people find it a joy to work with (excepting the obvious problems with the not quite fitting DOM interface, and browser incompatibilities). Oh, and I doubt Java will go anywhere any time soon. With the JVM targeted dynamic and functional languages (Scala, jRuby, Groovy, Jython, etc.), and the fact that Android and many other mobile device platforms are Java-based, I think it'll be around for a long time to come. I don't much like it--too wordy for my tastes--but I can't argue that it's a failed language. VB can't help but lose ground. Is Microsoft even considering it a live product anymore? I was under the impression it was pining for the fjords.
What is the program that can do what perl does but better, that everyone is switching to? And, what kind of programming does this survey refer to? Is it comparing oranges to oranges?
&gt; I think the most relevant language today is JavaScript, and I suspect it'll see more growth than any other language over the next few years. The problem is that Microsoft killed JavaScript as a language earlier this summer in the ECMAScript 4 debacle. JavaScript may (and probably will) grow in popularity, but it'll hit artificial technical limitations, thanks to Microsoft's Silverlight strategy.
It was my understanding that sanity prevailed in the end. But perhaps I've been misled, or perhaps my definition of sanity is no consonant with yours. For what it's worth, I'm not sure that ECMAScript 4, as it was defined and embraced primarily by Adobe, was necessary or even beneficial for the survival of JavaScript. The new ECMAScript "Harmony" proposal actually seems to be more compatible with the spirit of JavaScript as it is being used by leaders in the field (with Yahoo, not Microsoft, being the most obvious example). The assumption of ECMAScript 4 seemed to be that JavaScript was broken, and needed to be fixed. The assumption behind Harmony seems to be that JavaScript works well, but could stand to see some cleanups and corrections based on what folks have learned from implementing very large libraries and applications. I think the latter is more true than the former...but how you view JavaScript as it works today will obviously determine whether you think 4.0 being derailed is a terrible thing. While I don't doubt that Microsoft is doing everything in their power to neuter JavaScript and execute on their favorite "embrace and extend" tactic for locking out competitors--it is what they do, after all, as evil is in the corporate character--but MS are not alone in pushing for Harmony over 4.0. In fact, as I understand it, only Adobe was pushing hard for 4.0, and for obvious selfish reasons (I don't blame them, but I don't have to sign on just because I feel sorry for them embracing a pre-standard that turned out not to be a standard in the end). So, since I'm primarily a Perl guy, and don't follow JavaScript all that closely, I'm possibly missing something. How does Silverlight fit into this discussion?
If the existing code base is in perl and the app is non-trivial, which language to use isn't even up for consideration. But for new projects I try to avoid it because it tends to be read-only, and development in Ruby is just faster due to its easily-discoverable OO design and predictable syntax... as opposed to perl's mish-mash of unrelated unix idioms.
&gt; How does Silverlight fit into this discussion? It's in Microsoft's best interests to promote a single language for both the client and server sides of rich Internet applications. If they can drag their feet improving HTML, XHTML, CSS, and JavaScript so that the standards-based stack is a confusing mess of awfulness, so much the better.
I think you have some great points. Just to start out, Ruby on Rails is a cancer as far as I am concerned. I have never in my life seen a more worthless invention. &gt; I think the most relevant language today is JavaScript I think Javascript needs to be taught in public school instead of/or along side of VB. C/C++ should be a required course out of high school as well. Python or Perl should be taught as well. Few schools outside of college/university do not dive into anything outside of M$ and that is a real shame. &gt; Oh, and I doubt Java will go anywhere any time soon. Again agreed. But Sun is doing some real stupid shit with Java as of late, especially buddying up with Yahoo to load spyware on systems. Java is dog ass slow and prone to crashing. I have to deal with Java on a SIEM product I work with called RSA Envision (formerly known as Network Intelligence). It is next to impossible to load multiple Java versions on any Win32 system and expect them all to work. I have to use two damn PCs because of different Java apps I have to work with. &gt; VB can't help but lose ground. I do not code VB much but the app group I work with does and they tell me quite often of limitations in the language and many projects are underway to convert to C# or move to C/C++. I do not have much to go on except their word on that one. 
&gt; If they can drag their feet improving HTML, XHTML, CSS, and JavaScript so that the standards-based stack is a confusing mess of awfulness, so much the better. Yes, that is what they've always done. IE was obviously always a Trojan horse designed to derail the standards-based web, and replace it with a proprietary Microsoft monstrosity. But, they've been reforming as of late on that front. If history is any indicator, I'm sure Microsoft does have evil as its intent with Silverlight, but so does the similar stack from Adobe (where it seems to me they used imaginary ECMAScript-compliance to wrap up a proprietary turd in the shiny clothing of standards and openness--but again, I could be misunderstanding the industry and Adobe's intent...especially in light of the opening of Tamarind, and other friendly gestures towards the open web). And, while we're on the subject Sun has their own Java-based variant. Everybody seems to want to subvert standards to their own advantage, and somehow they've imagined there is a new land grab happening right now. But how much adoption has Silverlight, Sun's JavaFX, and Adobe's Flex really had? It's not on my radar. I've seen mention of Flex on the web, occasionally, and I know a lot of folks work with Flash/ActionScript. But Silverlight seems utterly irrelevant to me. I think it's merely wishful thinking on Microsoft's part, in fact. I don't think there is a land grab happening, and I think the big guys have already lost the web, and probably even know it, but they are trying one last gasp to own it. Anyway, I don't think opposing the ambitious, and very probably misguided, ECMAScript 4.0 (for whatever reason MS had...possibly their goal was entirely to derail Adobe to try to clear the way for Silverlight, I dunno) is, in this case, going to make any difference to the standards-based stack. In fact, given that Harmony is closer to JavaScript as it is implemented today, it means that JavaScript has a clearer and smoother path forward than if the new standard suddenly added dramatic changes to the language. Standards take time to implement, and stability in the platform is good for adoption. Dramatic changes break stability, gradual changes do not. So, if disrupting Adobe and clearing the way for Silverlight was Microsoft's only goal, I suspect they'll be very disappointed by the actual result, which seems like to be *more* adoption of standards over adoption of Adobe-specific technology (but maybe Microsoft considers taking Adobe down a notch a worthwhile goal, even without any gains on the part of MS). I don't really know what goes on in the minds of the mega-corps, of course.
Probably was supposed to be 1987...
What do I have? Cancer? I hope it's not cancer. That would really suck. How long do I have left?
Damn you for preemptively posting my exact line!
Well, the thing about dying from cancer is that TMTOWTDI.
Nice, very java though..
undoTransitionToJavaStyle();
Another good CPAN library. I still kinda wish they would do some better hash work on the NetLDAP stuff though.
Very Java, indeed. I'm sure we'll get modules to simplify it all though, like what `LWP::Simple` did for `LWP`.
Help us developing and shipping Perl 6, and it's going to be faster. Really. All these "do it now, and good" comments are not helpful. Those people who actually do something are doing their best already.
They're just first learning this now?
Next on Computer World, 2 + 2 = 4
Nice article. Most people haven't heard much about Moose or even Template Toolkit. We need more of those..
i wish there was a cross between delphi and perl that produced small .exe files. basically the IDE of delphi and syntax of Perl. that would be the most awesomest language ever!
Spread your net wider. The tools to do what you want exist. You may have even heard of them. You just haven't spent enough time actively considering the options you have. And I don't mean that exactly what you described exists. I mean that if you look at enough of what exists, you'll find something that meets your needs perfectly or can be trivially adapted to do so.
ActiveState Komodo (IDE) and Perl Dev Kit (compiler, generates windows services, etc) are the closest to that.
If you hate Perl, report to Gitmo for reeducation and torture.
Or maybe try using an object system?
wow, this is some really good news! right now it's a real tough job to install anything not available on PPM. i'm guessing this will make that a lot easier!
Strawberry Perl has made it easy to install things that don't have PPMs available, because it includes an entire toolchain. The benefit here is that those of us without Windows machines can easily help diagnose and fix problems on Windows.
That's great news! Every day Perl 6 is closer to the release :) .
I bought and read many books on Perl (including parts of Higher Order Perl on paper). My personal problem is that I cannot afford it much time, it's more of a long lost hobby that might be picked again when I retire!
mod_perlite is a very good idea, too bad the last release was about a year ago. Someone with the skills could take it and make it stable.. with a grant, perhaps? :-) And I couldn't agree more about PerlXS..
Moose/Mouse and/or Squirrel in core would be very very cool.
Great post. I didn't know about autobox. I also agree that perl picking up some release momentum again would be good for the language.
I don't know what a release schedule buys them. Perl 5 is delivered and solid. It's not like people are wondering when it will be completed like Parrot/Perl 6 and want confidence in its progress. The others are all splendid ideas.
&gt; I don't know what a release schedule buys them. Is it acceptable that the span between 5.8.0 and 5.10.0 was over five years?
I guess it depends on the goal of the releases. Is the argument that it's better to introduce new features gradually instead of in one massive release? For me, nothing in 5.10 would have made me choose Perl when I didn't for projects in the last 5 years. 
It's very frustrating to now about cool features in blead perl, and have to wait another four years for them. And don't forget that the p5 porters also have feelings - it's very frustrating for them to have fixed a bug in perl, and see reports and complaints about that bug all over again (and maybe they even block on it themselves), and then have to wait another four years before any release fixes that bug.
&gt; Is the argument that it's better to introduce new features gradually instead of in one massive release? Partly, and partly it's because it's easier to remove deprecated features if you don't have to work around them for five years.
It's very frustrating to add a feature for Perl and then get complained at for trying to use that feature in a CPAN module only five years after I added it to bleadperl.
I've been reading on many a framework, theory and everything in between. I'd love a framework that lets me integrate slowly into a static website by replacing certain blocks at first (like server-side includes), then automate some document creation processes etcâ€¦ My problem is that for the sites i do, a full fledged CMS system is overkill that will end up limiting my future site and page design possibilities.
There are still bugs in Perl? Okay, that's a good point then. 
I didn't mind. The long life span of Perl 5.8.x created a fairly stable platform to develop modules against. I think this helped both users and module authors in some regards. 
Pedantry helps no one.
you can do this with Catalyst by hacking something together with a Catalyst::View (I like Template Toolkit) and rendering that to somewhere that can serve static files. Then you'd need to hack Catalyst::Plugin::Static::Simple to defer to the view (which with call render to the static file) if it's being hit by something that hasn't been rendered yet
No harm in spelling it "pearl," then? I don't think I was being pedantic; I just thought it was funny that an article *about* Perl got the name wrong in the title. (The main thing that bothers me about PERL is it makes me think of COBOL, FORTRAN, or *\*shudder\** PHP)
Have you looked at [Mojolicious](http://mojolicious.org/)? It's by Sebastien Riedel, one of the original authors of Catalyst. It's designed to be small, simple and easy to get started with.
I'll look into mojolicious, seems promising. will post back
from the little i read on catalyst, it seems like too big for my needs and requires a lot of upfront set-up just to experiment on small websites.
**What web server are you going to deploy on?** * apache * lighttpd * nginx * other **How much administrative authority do you have over the server?** * root * non-root 
WHY would you do this when we have Moose/Mouse???
To use it on any computer with Perl installed but not Moose?
Because Mouse/Moose (for as nice as they are) are symptoms of a problem in Perl 5.
That's 5.11.x, I suppose?
If it gets included in Perl, the soonest it will appear is 5.11.0.
I'm not keen on adding a better OO system onto Perl 5 this late in the day. Especially when it'll break all my Perl 5 code that already uses `class()` subroutines/methods. I accept the point about these being symptoms of a problem in Perl 5. But that's what Perl 6 is for, isn't it? A little bit of backporting is good (say, smart match, etc), but I think that fundamentally changing the object model (or lack of it) that we've all learnt to work around is going too far. 
&gt; Especially when it'll break all my Perl 5 code that already uses class() subroutines/methods. Did you try it? I can think of one potential case where it might possibly break existing code, and that's rare: you'd have to have a `class BLOCK` prototype in effect. The core test suite catches the `class()` subroutine case (see the `B::Deparse` tests).
&gt; Did you try it? &lt;shame/&gt; &gt; I can think of one potential case where it might possibly break existing code, and that's rare: you'd have to have a class BLOCK prototype in effect. OK, I take it all back. I missed the prototype magic. A thinko on my part. Thx for the clarification. 
Well, this one is gonna take a while then.. It seems like a semantic change only.. Does it have any other benefit/feature?
It's also potentially a place to hang Perl 6's `is ParentClass` syntax, which means no more `use base` and no more manually assigning to `@ISA`. As well, the block form produces its own scope, which `package` has never done.
Perl5 doesn't have a "class" keyword. This isn't a problem - it's just an implementation detail. If you don't like it, you can use existing modules to change it. The idea that everything has to look like Java is foolish. It's not true for JavaScript, it's not true for Perl, and it's certainly not true for any other language that isn't Java.
&gt; If you don't like it, you can use existing modules to change it. Tell me `class Foo is Bar { ... }` isn't better than: { package Foo; @Foo::ISA = 'Bar'; ... } &gt; The idea that everything has to look like Java is foolish. My cat's breath smells like catfood. This is Perl 6 syntax. Who brought up Java?
Perl 6 syntax is great... in Perl 6. Trying to backport every bit of Perl 6 syntax into Perl 5 is silly. It's like the old jokes about people using \#define BEGIN { \#define END } to make C look like Pascal. And yes, it's moderately silly that Perl 6 changes perfectly reasonable things about Perl 5 so it can look more like Java - but it's far less silly to do that in a complete (and consistent) language redesign than it is to just add a "class" keyword to Perl 5 for the hell of it.
&gt; It's moderately silly that Perl 6 changes perfectly reasonable things about Perl 5 so it can look more like Java.... That's a silly comment. `package` in Perl 5 conflates two separate things. Why would disambiguating those separate things in Perl 6 make Perl look more like Java? Java wasn't the first OO language, it's not the best OO language, and it won't be the last. What's so wrong about calling a class a class that you think this is Javafication? Does the argument from clarity ("Use `package` if you want a namespace and use `class` if you want a class?") have no weight? &gt; Trying to backport every bit of Perl 6 syntax into Perl 5 is silly. *Every*? I'm trying to backport *useful* bits of Perl 6 syntax.
&gt; Does the argument from clarity ("Use package if you want a namespace and use class if you want a class?") have no weight? TMTOWTDI is great and all, but when there are three perfectly good ways to do something (all of which see use in practice) and you add a fourth, you certainly aren't adding "clarity".
That's much better. use base/@ISA feels dirty, hacky.. I really hope this gets to 5.12. This would make it easier for newcomers..
&gt; you certainly aren't adding "clarity". What's so bad with naming things correctly? Wouldn't be weird if newspapers started calling cows "$^C"? You could get used to it, but, it would be much easier on your brain to read "Cow".
Okay, the most recent version of the patch adds the syntax `class Foo is Bar is Baz { ... }`. That declaration, including the subclassing, happens at compile time now too.
what would be the fastest way to learn the *practical* differences in Perl 6.0 from 5.8?
Moritz Lens'z [Perl 5-to-6](http://perlgeek.de/blog-en/perl-5-to-6/) is a good resource.
This looks like a little simplified Catalyst.
Does Larry Wall regularly wear a cowboy hat?
That's great news! Let's hope that Rakudo will be developed by a full developer now :D .
The donation's for Perl 5.10.
So would it all go towards keeping the pumpking in top ramen for a year, or does it get spread out to lots of expenses?
I love that there is now a perlthanks program.
D'oh! I'm gonna learn to read TFA :-' . Though, that's still great news.
I used the opportunity to send the Perl team a beer... (O(~o)o) (o~(o~)o~)o) (o)/~~~~O~~~~~~\ (O)| o O O |____ o)| .-o-----. |__ \ (o| |P E R L| | \ \ | |B E E R| | | | | `---o---' | | | o| o . o | / / | . . . |_/ / | : : : |___/ \===========/ --abw 
I have a staging server running openbsd with apache 1.3 and apache 2. The public server is running pleskâ€¦ I'd prefer to use json for any data structures, hosted in site directory tree and avoid modperl 2 for now, unless there's a cheap, quick and useful entry into the subject. If there's a need for a db, I'd start with sqlite for the more demanding data requests, then my evolve to postgre iff and when needed. Keep in mind that my skills and time is spent more on print graphic design and website front-ends than programming and server set up. I do have practical, decent working knowledge of unix maintenance, practical javascript and perl (more book reading than practical). I have complete control over the machine - subject to my knowledge obviously. 
I wish I could upvote this more :D .
&gt; As well, the block form produces its own scope, which package has never done. I _really_ like the idea of having this available.
this is why all the comparisons between perl and php, etc are all invalid.. it's so much more than just web programming
everything is obvious except the "use some kind of OO" - i mean, wtf? there are plenty of perl scripts that dont need to employ an OO model...
Where's the part that explains how to spot bad Perl code?
Agreed, but the vast majority of modules on CPAN are OO based so a coder should be able to demonstrate that they're capable of using OO and/or writing it. It wouldn't bother me to see a non-OO code sample, but I would expect them to know OO as well. Ideally, they would also know enough about OO to know what's wrong with it.
Yeah i agree totally, it's just that the bullet point seemed to imply that if a script doesn't employ objects it's lacking somehow, which is obviously false!
You have to click through to Max K-A's [How Not to Get Hired](http://avatraxiom.livejournal.com/95669.html).
That's just awesome news :D .
Awesome, Shows much potential
Gee I forgot it, sorry :/ . Is there any way to add it?
tnx a googol!
Now I'm Perl 6 educated, thanks! A lot of the new features look really cool, especially the implicit use strict. 
Think that is bad, check out the rest of the pdfs of presentations that he was nice enough to [provide online](http://jnthn.net/papers/) for those of us unable to attend conferences. What a jerk, right?
I'm all for improving P5, even while I'm poking at Rakudo. I know I would start using `class` syntax right away. I am curious if it would make life any easier for projects like Moose (developing it and/or using it). Or have their changes made such a distinctive critter that they are stuck using the `package Bleep; use Moose; extends 'Blarp'` syntax they have now?
[s/scripters/programmers/](http://xoa.petdance.com/Stop_saying_%22script%22)
Except in this case he was specifically referencing writing small throwaway scripts. I plan on doing this some time, but I haven't had the motivation lately to do much outside-of-work programming.
And yet, even if it's a throwaway script it's still a program.
It looks like HTTP::Engine is moving away from Moose to a lighter Moose type module. Early reports say that is is faster now because of the lower overhead. I will check it out. I still need to figure out a nice way to alter my dispatching to work with HTTP::Engine correctly though. It provides no direct functionality to return the PATH request without the query string attached to it -- unless there is an undocumented method that I am missing.
&gt; autovivification of undefs to arrays/hashes I'm sure that's something real, but what it is, not a clue.
In Perl 5 terms: my $h_ref = {}; $h_ref-&gt;{foo}{bar} = 1; Assigning to the bar member of the foo hash autovivifies the foo hash even though it did not previously exist.
no `use strict;`?
You have probably noticed that these roughly monthly tidings are mostly about the Spec
way cool. Parrot supporting multiple languages like this is one the major benefits, and no DLR/CLR/JVM don't really offer anything close for dynamic languages that haven't been rewritten and customised to behave like Java or C# internally.
 #!/usr/bin/perl -p s/^/$. /s;
Serious question to anybody that's used perl6. Is a 20% pass rate even remotely close enough to trust the language for production? It's a very small percentage but I realize there are a lot of tests...
That depends on what you mean by "production" and what kind of program you need to write. I wouldn't bet my business on Rakudo right now, but I'm comfortable writing little tools in it. (I might be a bad example of a normal user in many ways though.)
&gt; A language doesn't exist in the sense that you can use it for real work until you can bet your business on it. I can't help but see flaws in that idea. I'd never bet my business on a bash script (or Korn help me, ksh), but they really do exist, and I rely on code written in both languages regularly. Maybe I'm a bad example, but I used Subversion milestone releases in the teens to hold the text of a book I wrote before long before Subversion 1.0. I've used Linux exclusively on my desktop for over a decade. I can appreciate the idea that a lot of people won't take a project seriously until they can use it at work, but all that means to me is that they can't or won't use it, not that it doesn't exist, or not that it's not worth using. That said, I don't recommend using Rakudo right now unless you're comfortable reporting bugs and missing features -- but I don't understand your stricter criterioin.
&gt;Jerry: &gt; &gt; * it would be nice to have a champion who isn't Patrick &gt; &gt;Patrick: &gt; &gt; * I might be able to find one of the "Git is the second coming" people on the channel to do that &gt; &gt;c: &gt; &gt; * I thought it was the first coming &gt; &gt;Jerry: &gt; &gt; * that's Obama &gt; &gt;c: &gt; &gt; * no, they branch him and commit their own hopes and dreams to him using Git &gt; &gt;Patrick: &gt; &gt; * I'll look into that Excellent.
Possibly based on [andand for Ruby](http://github.com/raganwald/andand/tree/master)
Probably even. [See also](http://www.perlmonks.org/?node_id=734774).
And also see [here](http://stackoverflow.com/questions/422837/is-there-an-andand-for-perl) 
Hmm... surely this has been inspired by [this question about andand](http://perlmonks.org/?node_id=734774); and [a bit unnecessary](http://search.cpan.org/~leont/Scalar-Andand-0.03/lib/Scalar/Andand.pm#EXPORT) considering [this possible (elegant) alternative solution](http://perlmonks.org/?node_id=734779).
Andand is all the rage these days..
As a gaming nerd perl hacker, you had me very worried for a minutes...
A pretty good analysis from somebody who not only knows Perl really rather well, but is a bit of a language tart and uses a pretty interesting variety of languages.
&gt; If you ask for the languages of the moment, you will hear people talk about Ruby, C#, JavaScript, Erlang, Python or even Haskell. You probably won't hear Perl mentioned. Bzzz: wrong... Unsubstantiated claim that's actually contradicted by the recent "Favorite Language" thread here on reddit and graphed here http://codeeleven.blogspot.com/2009/01/graphing-reddit-language-trends.html . Not a great way to start an article... 
The survey was of "favorite languages" and only applies to a specific subset of people who respond to comment threads on Reddit. Cawley's comment was about "languages of the moment" and most likely applies to a hype factor observed from a selection of articles, blog postings, and conversations that he's come across in the last few years. Different domains.
He's responding to rhetoric on TIOBE, reddit, slashdot, several blogs, and an LWN op-ed.. ..and it's a good rebuttal.
I agree that the article itself is a nice summary of the latest and greatest in the Perl world. I still feel that the opening statement is off-base even in if it is just meant to set the tone for the article. People were asked for the languages of the moment and Perl was decidedly one of them... Apparently I'm being downvoted for disagreeing and referring to corresponding evidence. Meh...
Template Toolkit 3 is being actively developed and should hopefully see the light of day this year. But, yeah, it's a sole developer. He does accept feedback and patches, though, and he's made regular iterative releases to ttk2. Mason gets bug fixes from time to time, but, yeah, the code isn't exactly something a newcomer could easily break into (unlike template toolkit, which is pretty straightforward by comparison). I don't know if I really have a point.
&gt; I don't know if I really have a point. I think u do because I think u've showed that a project with sole developer isn't an issue if he/she are receptive to feedback &amp; patches. If they aren't receptive then you can just fork it! And "sole developers" are even less of an issue in this world of git, GitHub, etc. /I3az/
What is November?
November is a wiki engine written in Perl 6.
&gt; My impression is that this site isn't really conducive to frequent updates or lots of contributors (but perhaps I'm incorrect about that). I think it's important to keep that site up-to-date, even if that means removing most the content and making links to places that _are_ updated blatantly obvious. I recall in the past glancing at it -- it seemed a natural place to look -- and concluding the Perl6 effort was completely dead. Pretend really hard for a moment you don't know a thing about rakudo, and take a look at these things on the sidebar: * [This Week in Perl 6](http://dev.perl.org/perl6/list-summaries/) * [Status](http://dev.perl.org/perl6/status.html) * [Latest News](http://www.perlfoundation.org/perl6/index.cgi?perl_6_rss_news_feeds) None of this screams _we're going places_. It's fortunate that Planet Perl Six is also linked off there. Edit: I'll spare the world my gripes about perl.org in general.
Nice article.. could have done with some examples though
So what's the state of mod_perlite right now? Is it ready for production use?
Err, what about non-Apache webservers? (Fast)CGI is much more "portable" than mod_*.
What does CGI have to do with Perl? [Recently I have been writing some fairly complex CGI applications](http://repo.cat-v.org/werc/) using the [rc shell](http://doc.cat-v.org/plan_9/4th_edition/papers/rc), and it has been a very pleasant experience. I would not dream of doing the same with perl.
No; it still needs some polishing.
I'd probably read it; how would this book be different from Perl Best Practices? What'll happen to your Parrot work?
&gt; [How] would this book be different from Perl Best Practices? I expect to spend most of the book discussing how the language works. Think of it as a very opinionated stripped-down Camel which teaches the 80% (or 40%) of the language you need to know as of version 5.10.1 or whatever to use modern Perl to its full advantage. For example, don't expect to see `bless`, beyond "You might come across this, but use `Mouse` instead." &gt; What'll happen to your Parrot work? Surprisingly, it'll probably increase -- but volunteer time is difficult to predict!
That sounds great. If you do go ahead, I hope you'll also cover a bit of the higher-order stuff too, since that's one thing the other popular languages usually don't handle well at all. I realize that's more HOP's end, but it seems a pity the Perl sphere isn't flogging this fact for all it's worth. Also, may I suggest "Modern Perl" over "Maintainable Perl"? The latter gives the wrong impression/connotations. Give it a tag line that'll make the nay-sayers take note, e.g. "power with minimal fuss" or "not your grandpa's".
&gt; Also, may I suggest "Modern Perl" over "Maintainable Perl"? I like that very much!
I'd be pretty likely to buy a copy.
Yeah, sign me up as well.
Me too, especially if it [recommends use of my software](http://www.reddit.com/r/perl/comments/7qany/pondering_a_book_teaching_maintainable_perl/c073534). :)
I'd definitely read it. &gt; Would you read or comment on a similarly themed weblog in conjunction with the book? Read: absolutely. However, as my reddit comment history shows, I'm not really a prolific commenter. To be honest, I'd settle for just the blog. We need more good, visible Perl code on the web so people might one day get past the nonsensical notion that it looks like line noise*. * Says the guy who recently [complained](http://www.reddit.com/r/programming/comments/7lkno/askprogit_i_am_a_complete_noob_when_it_comes_to/5f9m) in a roundabout fashion that Rakudo looks like line noise.
Without a doubt, I'd buy it. I'm working my way through Best Practices now and it's been wonderful, but given that the community thinks that it's flawed makes it problematic. A slimmed down camel book would be excellent.
Seconded!
The train may have already left the station (and I say this even as a lover and defender of Perl). Might be a bigger market for a book on refactoring to maintainability. 
'Oxymoron' (Just a suggestion for a better title ;)). Actually, "*Maintainable Perl is Not an Oxymoron*" would be a nice title, it would create more polemic and publicity.
This would be a great book to read and own!
This would be a great thing to see!
Saw gst's posting of this first. Dangit. Anyhow, this would be a fantastic thing to see. I also think "Modern Perl" is the better title.
&gt; [the `loop`s] are not really recommended I disagree. Sometimes a `for` loop isn't appropriated, and a `loop` can do things that a `for` can't do. But I guess the author was talking about when you use a `loop` to do what a `for` would have done :).
&gt; for $x .. $z -&gt; $i { Why does Perl6 have that "-&gt;" line-noise?
What about RTFM? Also, what do you suggest?
I'm not suggesting anything. God forbid I ask a question on a social medium.
"Line-noise" could be taken pejoratively. That syntax indicates that variables coming into the block get bound to `$i`, like the `|i|` syntax just inside a block in Smalltalk or Ruby. It's outside the block because of the linguistic principle of "end weight", where the most important information occurs at the start or the end of a linguistic unit.
Is it possible to do something like _-&gt; $i, $j { ... }_ ? Can it be used in contexts other than for(), i.e. is this a syntax for an anonymous function?
Yes, yes and yes.
&gt; Bzzz: wrong... There's probably no worse way to start a posting. It might be funny to a 12-year-old.
How does Parrot's performance compare to 2007? I vaguely recall Mike Pall being a bit unkind about it.
On the whole, it's faster. With some clever optimizations, especially to the GC, the benchmark I usually use (parsing Rakudo's NQP actions) is about three times faster. However, some recent changes to calling conventions slowed down multidispatch notably. We regained some ground, but it needs further improvements.
Downvoted for picture of ugly girl.
I never knew, mjd.
I was secretly hoping chromatic would make this topic a series of blog posts. I hope that is what is in store here.
Looks like a great start! But, the part of me that's constantly thinking fourth dimensionally wonders why even couple it to the year 2009? Perl is constantly moving forward. Why not identify the greatest areas of interest (as they stand currently as these too are subject to change) and make this the basis for the site, wiki, or whatever it is that is expected to come out of modern Perl. Then these topics can be updated to reflect the current canon. 
The somber, frame filling mug shots are a bit much... 
No doubt. Blog posts are handy for spamming everywhere. One large reason why Perl has lost the perception war is that the community has become too insular; few things reach the general-programming news aggregators. As an aside, if there are more posts like this, maybe one of them should put a laundry list of why modern Perl is _awesome and kicks your language's butt_. It's all very dramatic and flameworthy, but it grabs attention.
It is.
what's wrong with mod_fastcgi?
One thing that worries me about mod\_perlite is it'll probably repeat mod\_php's misfeature of executing files that don't have execute bits set. I curse mod\_php for that.
I looked at their [proposed module list](http://kobesearch.cpan.org/htdocs/Task-Kensho/Task/Kensho.pm.html), and I didn't see a Perl::Critic in there... It'd be nice if AnyEvent became more common too.
&gt; I wrote a proof-of-concept module called Modern::Perl to solve this problem. I can't find it on CPAN. :(
How many modules would you expect Modern::Perl to pull in eventually? Or do you mainly envision it as being the pragmas and version features?
It's winding its way through PAUSE right now.
No more than a dozen -- I have in mind Devel::Declare, Data::Alias, and Method::Signatures as strong candidates right now. I might create Modern::Perl::OO which pulls in Method::Signatures and Mouse.
Is there something like Method::Signatures for regular subs? Oh, pretty please... D:
It's a great idea. What are the chances of making this a (perl-build-time) default, to get people who don't know what's what using it?
Approximately zero. The general consensus on p5p seems to be that existing programs should run unmodified on new releases of Perl and that if you want to take advantage of new features added to new releases of Perl, you have to list them explicitly. I believe, contrarily, that if these features make it easier to write good Perl, they should be on by default.
[Sub::Signatures](http://search.cpan.org/~ovid/Sub-Signatures-0.21/lib/Sub/Signatures.pm)? edit: I hate markdown
Thanks. :)
Then perhaps a better question is how much of this will be default in perl 6?
Most, if not all -- and a lot of it works right now in Rakudo.
That's a source filter. [signatures](http://search.cpan.org/perldoc?signatures) is the "modern" version.
&gt; I have in mind Devel::Declare, Data::Alias, and Method::Signatures as strong candidates right now. I might create Modern::Perl::OO which pulls in Method::Signatures and Mouse. Might I suggest [MooseX::Declare](http://search.cpan.org/perldoc?MooseX::Declare), which bundles most of those features into a one-stop, perl6-ish package? Devel::Declare is defiantly (and deliciously) postmodern rather than modern. It might be a gentler, kinder (re-)introduction to Perl to let coders chill out in [Ronchamp](http://www.alovelyworld.com/webfranc/gimage/fra066.jpg) before asking them to caulk the [Lloyds Building](http://www.essential-architecture.com/LO/016-Lloyds_Building_stair_case.jpg) :-)
more please
Wow I know nothing about writing XS but that was pretty cool.
From the perl.com [download page](http://www.perl.com/download.csp#mac): &gt;Perl for the Macintosh &gt; &gt;Mac OS X distributes a modern version of Perl, so you already have it. Let's see what perl on a two week old MBP (10.5.6) has to say about that... &gt;This is perl, v5.8.8 built for darwin-thread-multi-2level
5.8.8 *is* a relatively modern version of Perl. It's perhaps not thoroughly Modern in chromatic's sense of Modern::Perl, but it's only 3 years old. Perl 5.10 is only a year old, and as noted in the article, it's officially marked as "testing". So it's understandable that OS X has the most recent officially stable version which was 5.8.8 until very recently (last month) when 5.8.9 was released. 
That Perl.com page is perpetually out of date; you could email webmaster@perl.com suggesting corrections.
Here's a nice trick on how to set a break point in a Perl file script from the source code (before the interpreter is even invoked).
Oh, agreed. Given that both 5.8.9 and 5.10 just came out, it's perfectly understandable. The contradictory use of the word "modern" just struck me as a bit funny given his apparent ties to O'Reilly/perl.com.
With my distro, I just have to type something like `g-cpan -i Foo::Bar`, and boom, I have a new generated &amp; installed package for this module along with its dependencies. It doesn't work all the time (noticeably, with interactive installs), but that's a great tool. Maybe the author's distro isn't as smart?
Seems you mistyped the URL, Perl's official page is [perl.org](http://www.perl.org).
KEEP UP THE GOOD WORK
&gt; The Evils of **Multiple** Inheritance Explained There, fixed that for him.
Actually, as the author of that article, I also pointed out difficulties with even single inheritance. Yes, MI is worse, no doubt about it, but long single inheritance trees also require a larger cognitive load for the programmer. Regrettably, Perl is worse for this than other OO languages because "private" methods tend not be very private, but the point still holds.
&gt; Yes, MI is worse, no doubt about it, but long single inheritance trees also require a larger cognitive load for the programmer. You're correct, of course. In fact, doing just about anything increases cognitive load for the programmer. That's why we get paid, yeah? The downside of even single-inheritance seems to be, to quote the article: &gt; What if you want to subclass [my big huge class]? Now I have to know about [all 250] internal methods if I want to avoid accidentally overriding them! The more levels of inheritance you have, the more likely you'll accidentally override something you shouldn't. And that's fair enough. However, let's say your object, instead of having 250 private methods, has 250 sub-objects inside it. Now the programmer who's subclassing your class has to understand all 250 sub-objects and their little flaws and gotchas. It's a different kind of complexity, obviously. A huge but shallow puddle of objects for delegation, vs a towering spire of objects for inheritance. That being the case, it seems to me that you're screwed either way here where it comes to complexity. The only way out is to have fewer things in the class. Be they methods or sub-objects or whatever, fewer of them. So now you're in the trap of simplifying objects, which means you have to move code out to other objects (probably newly created ones), which leads to an object zoo. The puddle gets shallower, but also larger. In short, mindlessly resorting to delegation is just as big a mistake as mindlessly resorting to inheritance. Neither one of them is a magic bullet that's going to tame your codebase and restore order.
I think the two big factors that affect the ability to manage maintainable code is variable naming and scope. In that vein I could argue that many small objects will reduce the number of flaws since the average scope is much smaller. I haven't thought about it much since I prefer a more functional style. 
&gt; With this, Baz calls a convert method which is inherited. What happens if both Foo and Bar have this method? http://en.wikipedia.org/wiki/C3_linearization 
&gt; I think the two big factors that affect the ability to manage maintainable code is variable naming and scope. I agree, if you add "good factorization".
Refactoring was what made me start thinking on the topic. What attributes of factorization make code more comprehensible? What is it that lets us look at a chunk of code and say, "Yeah, that's well factored"? I decided the first two were probably it. I'm doubtless missing pieces of the puzzle though -- looks like I missed redundancy. Are there any others? Cyclomatic complexity perhaps? But wouldn't reducing the scope naturally force a reduction in that too?
always and forever are a very very long time.
Anyone used this? Any version. Thoughts?
I want to see the code in that loop.
It was `Pod::Simple`. The current version is scary, but much, much better.
I'm not sure how thinking of code in sentences and paragraphs will help. Consider the named task, which is something that needs to be repeated, and takes approximately 400 lines to do. How would you break that up? Well, you could make it into a single large subroutine, but of course it still takes 400 lines or so to do the task. You could break that task into many smaller subroutines, where each takes, say, 50 lines. OK, so now you have eight subroutines instead of one long loop. Better? Maybe. If you don't have to add any overhead like passing data between the subs. But more likely is that you're just adding unnecessary complexity, all for the sake of some obscure "line count" metric that you want to meet. If the task takes 400 lines to do, it's the same 400 lines no matter whether it's separated off to a subroutine or not. The real question, of course, is whether the task really needs 400 lines, but much more information about the problem would be needed to determine that. &gt; Put another way, you'd have real trouble reading this essay â€” as short as it is â€” without paragraph breaks. Take out the punctuation and it gets more impenetrable. Remove the spaces. You won't even bother. Bad analogy, in my opinion. Altering the essay that way would be like removing line breaks and unnecessary spaces from the code. There's a reason we write code on separate lines, and in Perl it's not due to the fact that the parser/compiler can't figure out where the line ends. Perl can be written as the author suggests, just look at an obfu. Each line is already a "sentence." Every programmer I know already uses blank lines to separate slightly different ideas. Every decent programmer I know uses indentation to help distinguish program flow. So I'm not sure what else can be done. Except refactor the 400 line loop to be more efficient in the first place (and as noted, I don't think that shuffling those lines to separate subroutines would make it any less complicated).
&gt; I'm not sure how thinking of code in sentences and paragraphs will help. We already do, at least since the invention of structured programming, which allows us to attach human-meaningful names to discrete units of behavior. &gt; Each line is already a "sentence." They're closer to words than sentences.
OK, then I must have missed the point of the article. It seems to me that the point of the article is that the 400 line loop was too complex, and by thinking in sentences and paragraphs, this code could be simplified. Or at least, better organized. But if programmers are *already* thinking of code in sentences and paragraphs... sorry, you've lost me.
&gt; But if programmers are *already* thinking of code in sentences and paragraphs... I believe that good programmers *do*, but few people explain code factoring in those terms. The sentences and paragraphs analogy attempts to explain how good programmers work, even if it's not necessarily how they think about what they do.
I see. I apologize for being a bit slow this evening, thanks for the explanation.
C3 mitigates the problem because you don't have 'unreachable' code, but what if Foo::convert and Bar::convert both want to change the state? What if both state changes are required yet each makes an incompatible change? What if both are required but their order is important and you've inherited in the wrong order? I won't be so dogmatic as to say that multiple inheritance should never be used, but the conceptual problems of trying to force non-hierarchical domains into hierarchical models are pretty significant.
That's great news! No more t/ lurking..
Thanks!
&gt;Consider the working-but-much-maligned `File::Find`, which features one of the worst possible interfaces imaginable. For a moment I thought he was talking about the use of a callback. I *love* callbacks, but a lot of people seem to have trouble with them, with as a result that wrapper modules like [File::Find::Rule](http://search.cpan.org/perldoc?File::Find::Rule) come out. (From the docs of the latter: &gt;File::Find::Rule is a friendlier interface to File::Find. Urm... *what*????) But he appears to be talking about another feature of `File::Find`: the use of global variables to pass on parameters. Well, uh, agreed on that one... On the other hand, they're not really globals... well they are, but they're saved and restored afterwards, with `local`. That makes them somewhat less evil.
http://search.cpan.org/~drolsky/Moose-0.67/lib/Moose/Manual.pod
Well, crap, now I'm out of excuses not to try it out. Thanks a lot, jerks.
I'm a bit surprised this is being asked. I think the answer is obvious. Many, many things will be lost by leaving CPAN; it is Perl's crown jewel for a reason. What will leaving gain in return? I think it'll gain nothing, but it will introduce a host of problems: * no systematic testing on multiple platforms * no automatic dependency tracking and handling * no easy search * no central bug reporting, rating and comment systems (I wish this was used more) * versions of code will vanish from the net for random reasons Let's just take a look at the first of those: I'd think Perl6 implementation authors would be all over the systematic testing, on multiple platforms, of much of the open Perl6 code against their implementation.
Someone should design "Powered by Modern Perl" website badges.
 sub map0s { map { $_ =&gt; 0 } @_ } # Look! Only 21 chars! my%stats=map0s@FIELDS That "challenge" is nonsense. One could overload some operator to get even less chars. Or even make a DSL to do this in three chars (*that* would be a challenge).
The dude completely missed Perl::Unsafe::Signals, which is a far cleaner workaround than what he proposes.
Oho. The meat arrives. Say, shouldn't modernperlbooks.com be added to planet.perl.org? The only place I know where links are posted is here.
re: planet.perl.org.... possibly? I think there is a policy where u need to get two separate recommendations for it to be added IIRC Alternatively u can already find modernperlbooks.com on "the Perl Firehose!" at [perlsphere.net](http://perlsphere.net/) /I3az/
surely that should be OPF (Ouvre-magasin Perl Francaise)??
Not very fast, usually, but if you're trying to ride one it can get quite lively.
Ez faster than Squirrel.
Duh, not really. "Atelier Perl FranÃ§ais" would be a better translation :).
yep that would be way better - thk you . . . . . . . bet ya were expecting to get flamed
HTTP::Daemon much?
HTTP::Server::Simple but only on the weekends
Why reuse any of the webservers on CPAN when you can write crappy code yourself? Major issues with this piece of code: * It doesn't use tainted mode. * It doesn't use warnings. * It doesn't do input validation. You can easily break out the document root and open files outside of it. Those are the deadly sins, but there is more issues with the code: * It doesn't check the return value of that read of the post-data, thus it may miss part or all of the request if it is coming in slowly. * It doesn't check for the return value of other system calls either (letting them fail in silence instead). * It doesn't use three argument open or lexical file handles. I thought we were living in 2009. * It doesn't give proper errors (it always gives a 404, even if you're dealing with a permission problem instead). I can tell from experience that that can make debugging harder than necessary. * It isn't refactored properly into functions. * It doesn't handle URL encoding properly (they simply don't decode the file location at all). * It doesn't check the rather vital first line of the header properly (nor does it handle multi-line headers). This wouldn't be so much of a problem to me if this wasn't a company that offers courses in Perl. This is **not** the kind of Perl code that sets a good example.
I don't understand this comment: &gt; You can take the Lisp or Forth approach of defining a very simple, easily understood core and building everything else in terms of that. "It's simple!" people say, until they start building real applications in that. Given this one: &gt; If I had my way, the Perl 5 core would contain the language itself and only those libraries absolutely necessary to download and install other libraries from the CPAN. Isn't that a contradiction?
Perl has syntax. Lisp... you can write your own Lisp in terms of itself in a page of code, but to do anything practical with Lisp, you need libraries. The half-page-of-Lisp Lisp provides everything you need to write any computable program, and there's a single syntactic form you need to understand to do so, and it's very lovely and simple. It's just not sufficient by itself.
But this may be one of the advantages of a Lisp or Forth: libraries are equal players to the language itself. With such languages almost everything can be a library, and there's no way to tell. As you say, many people don't think of DBI as separate from Perl. For myself, I have no idea if LWP is a part of the standard release; it's just been there whenever I wanted it. If Scheme had a sizable CSAN, that'd be interesting. From a consuming programmer's perspective there's probably not much difference between a language that has many features and a minimal language with a set of blessed libraries that provide the same, but for the language maintainers it'd be an easier job. I suspect a large part of why Slava Pestov is able to munge through his VM and compilers at that crazy rate is because almost everything is a library, so the VM's external API is small and the compiler only needs to worry about a few intrinsics. Anyway, I think I've wandered off topic. I'll just note that minimal languages don't necessarily entail horrible syntax or stack backflips. COLA allows a programmer to crack it open and extend its syntax through OMeta; this is all scoped. I vaguely recall you writing that Perl6 allows this with grammars too?
That's an advantage *and* a disadvantage in the same way that Perl 5's minimalist OO is an advantage and a disadvantage. &gt; I'll just note that minimal languages don't necessarily entail horrible syntax or stack backflips. You're right, and I don't mean to imply that they do. Like Larry says, though, I've never read a *beautiful* Lisp program even though I agree that the language is beautiful. Homoiconicity is a beautiful concept. (Maybe a better explanation is that no matter how regular or beautiful Esperanto or Lojban are as languages, they'll never have their Pynchons, Nabokovs, or Joyces.) &gt; I vaguely recall you writing that [Perl 6] allows this with grammars too? That's correct.
I can't argue against that. Grammar extension seems like a great way to implement a language though. Start with a minimal core and layer the externally-visible language syntax and semantics on top by loading internal libraries. Deprecation would become easier. 
One problem with Forth is that because you are *forced* to build up the language incrementally, it often becomes an unmaintainable mess if the author didn't think the problem domain through carefully enough. And because everything is built on top of everything else, it seems that if you screwed up something "down below", you're stuck. Still, a well-written Forth program *should* be understandable by any expert in the problem domain for which the program is written. For example, the famous "clothes washer" program in Forth: : WASHER WASH SPIN RINSE SPIN ; You should be able to read that, assuming you've used a clothes washer before. There's a lot of stuff under the hood to define "WASH", "SPIN" and "RINSE". I do wonder if Perl 6 may have issues because the grammar is mutable enough to allow such things and it could lead to a mass of unmaintainable code, but I suspect this facility won't be abused enough for it to matter.
&gt; ... but I suspect this facility won't be abused enough for it to matter. Good one!
Each time you add a level, you do one more hash lookup. Isn't it obvious that a N-level lookup will take N times longer than a 1-level lookup?
A quick glance at the array lookup results show that, for instance, a 2-level lookup is 83% *slower* than the 1-level lookup. This is almost *ten times* slower. Still, I believe that the author drew the wrong conclusion: that nested data structures are slow (in absolute terms). I think that, from those results, one can only say that nested data structures scale poorly, which isn't the same.
a modest suggestion for "gst" - perhaps the title should have been "No good Perl _for_ _development_ for Win32?". I've always found the ActiveState build fine for just running my programs.
&gt; I think that, from those results, one can only say that nested data structures scale poorly.... You can't even say that. Compare the branches with `B::Concise` and you'll see that nested lookup uses more ops. The more ops, the more work -- and the more work, the slower things go.
Wrong. Assuming 83% slower means it takes 1.83 times more time, it's not even twice as slow.
Ok, I stand corrected on the *semantics*. The raw data is 50000000/s for L1r versus 8333333/s for L2r. The quotient L1R/L2R is ~ 6. This means 1-level lookups are 6 times faster than 2-level lookups.
dur dur dur......thanks for the reminder :)
Cygwin?
Like the comment says, use Devel::NYTProf instead.
&gt; While I was in the multi-dispatcher, I realized that every time we got a cache miss, we leaked a little memory. Fixed the leak. Was glad that Rakudo only has a little bit of C Doesn't Parrot provide the multiple dispatching? Edit: rakudo.org isn't on planetperlsix for some odd reason
&gt; Doesn't Parrot provide the multiple dispatching? Parrot does some of the multiple dispatching, but Perl 6 can also dispatch by subtype, which Parrot doesn't do by default. Rakudo overrides some of Parrot's dispatch mechanism for more specific purposes.
I thought the future was perl6 ?
It seems that they are not mutually exclusive.
Moose is one of the benefits of the development process of Perl 6.
Think of Moose as an early Christmas present, its not as good as the big one that you will open on Christmas morning (Perl 6) but its better then no present at all (or even worse, having to switch to PHP or C# or something).
Whatever happened to "Perl Best Practices"? Someone should write "Perl Best Practices 2010".
I believe chromatic is working on a book to be called "Modern Perl" which will address this.
You are correct.
I smell Christmas.
I wish you the best of luck...
Unfortunately I find myself on the lazy side of things all too often; even when I know that it's only making my life harder down the road. The trick, I've yet to find, is to force yourself to learn a routine so well you stop having to try and do it and instead just do it without realizing.
That's the only solution I've found: relentless discipline to make good practices into habits.
As a non-native English speaker I've always wondered about this; shouldn't the title be 'reasons to not upgrade' instead? 
Some people object to splitting the infinitive form of verbs by putting another word between "to" and the verb. I save that for when it matters most.
Wow that's pretty impressive :). I hope that the development will continue that fast.
The values in `@_` are aliases.
Yep! And the development rate may increase with [Parrot 1.0 due this month](http://perlbuzz.com/2008/11/parrot-10-will-be-out-in-march-2009.html) /I3az/
If you're using a reference, PBP recommends appending _ref to the end of its name to denote that fact and prevent silly mistakes, which has worked very nicely for me. In addition, it recommends dereferencing using braces like @{$foo} to provide clarity.
Doesn't matter. funcall(@stuff) destructures @stuff into a list of @stuff's individual elements, which you then have to glom back together inside the function. funcall(\@stuff) passes it as a single reference instead.
That's just a matter of copying pointers, hardly a costly matter. The real cost is in copying the array inside the sub: ($look4,@within) = @_;
I got to a point where I started to wish everything was a reference by default.
&gt; It seems that the universities are neglecting to mention it. Definitely. Throughout my degree, the only time I heard a teacher mention Perl was when he was warning us away from it and saying that it was too ugly a language to be used for serious development, therefor we would probably never come across it in our professional lives and didn't need to know much about it. And then he went back to teaching us ASP/VBScript...
I did my Master's work in Perl, but I also spent 3 years in industry at a startup after my undergrad degree. I agree with the sentiment of this article.
&gt; The real cost is in copying the array inside the sub: ($look4,@within) = @_; This is the "glomming back together" that I referred to.
&gt; Apparently the CS curriculum does not cover version control, test-driven development, project planning, bugtrackers, external dependencies, and various other real-world issues. While not surprising since I never learned about these in my time at school but it amazes me that CS courses in the present would not cover such basic items. One can argue that bug-trackers and external dependencies might not be strictly *essential*. However version control, test-driven development and, to a lesser extent, project planning are *critical* skills that every software engineer and programmer should know about and practise out of the box.
[This exchange](http://www.amazon.com/gp/blog/post/PLNKVUNBWIDAS9YQ) between Mark Guzdial and Alan Kay may be of some relevance. The discussion seems to revolve around the differences between "education" and "vocational training". Eric Sink, author of the [source control HOWTO](http://www.ericsink.com/scm/source_control.html), once blogged how stupid universities were for not teaching source control. The next day, he was contacted by his thesis advisor, who said "Oh, we do teach source control management here at the University of Illinois, and as punishment, you shall come here and lecture for three or four courses." 
If you're going to use global variables, why bother with argument passing?
Instead of having a .pm that subclasses Test::Class as well as a .t file that calls it, we just do: __PACKAGE__-&gt;new-&gt;runtests if not caller; Then the test harness (Module::Install tests() in our case) can just execute the .pm and the tests will run but one can also use it as a normal perl module. This has worked out pretty well so far. 
That's a good idea. I also prefer to store my test classes under *lib/* so that they get installed alongside the modules. This allows other people to subclass the tests.
I'm sensing the use of irony? If so, this has never been a concern for us using this setup. If not, well, I never would have thought of this. The tests can and are sub-classed just not from their installed locations...
There's no irony at all. Look at my `Mail::Action` module on the CPAN. I wrote it for people to subclass, and I have the test classes installed alongside its classes. This strategy is only important if you're distributing software you expect other people to use to test against, but I think it's useful.
&gt; our Str multi method lcfirst is export { &gt; ... &gt; } Perl meets Java. I use Perl 5 a lot. It's been my language of choice for about 15 years now and I know it well enough to both love it intimately and hate it with a vengeance. I was there in the room when Jon threw the coffee cups and Larry decreed the inception of Perl 6. I rejoiced. 8 years later and Perl 6 is becoming a reality. There is no doubt in my mind that both Perl 6 and Parrot are revolutionary (or at least super-evolutionary). But, you know, I'm just not convinced that I'm ever going to use Perl 6 that much. I can imagine myself getting annoyed by so many things. The thing that annoys me most about Perl 5 is the line-noisy syntax. But Perl 6 has taken this off the scale with dozens of new cryptic symbols with [magical meanings](http://www.ozonehouse.com/mark/periodic/). On the other hand, the thing that I like most about Perl 5 is the brevity. But something as simple as a subroutine declaration like `sub lcfirst { ... }` has now become 7 words with 30 or so extra characters to type. Now I fully appreciate that the Perl 6 example is much more feature laden than a simple Perl 5 `sub`. The declaration combines scoping, visibility and goodness knows what else. In the long run, it probably eliminates a dozen other lines of Perl 5 code that would otherwise need to be written. Logically, it all makes perfect sense. Perl 6 is far superior to Perl 5. But instinctively, it just doesn't feel like the kind of programming language I would want to write. It appears to be simultaneously as verbose as Java in terms of wordage, and as cryptic as Haskell in terms of its use of symbolic operators. Now I should be fair and point out that the Perl 6 that I've been writing recently is actually NQP (Not Quite Perl) - a Perl 6 mini language implemented in Parrot that you can use to write new Parrot languages. So it's true that I'm not seeing the full picture. But already it's annoying the hell out of me. Don't get me started on how awful the adverbial named parameter syntax is... I seriously hope that I am proved wrong and that I come to love Perl 6 and fully appreciate its truly shiny nature. But it worries me that someone like me, a hardened Perl veteran, is having reservations about investing the time required to learn it (I mean *truly* learn it, not just becoming familiar with it). What on earth must the Perl detractors be thinking? The redeeming thing in all of this is that if Perl 6 isn't the kind of language that I want to use then it's really very easy for me to create my own language based on Perl 6 that's got all the features that I want and eliminates those that I don't. I'm really excited about the possibilities here. But I'm concerned that it could lead to a massive divergence. There's no point me creating my own dream language if I'm the only person using it. Sure, it'll be binary compatible with other Parrot hosted languages, but if no-one can understand the source code then it's effectively dead. Sorry, this has turned into a brain dump about my Perl 6 reservations. I should get a blog...
&gt; The declaration combines scoping, visibility and goodness knows what else. In the long run, it probably eliminates a dozen other lines of Perl 5 code that would otherwise need to be written. ... and it's all *declarative*, not procedural, so the analysis and introspection and manipulation you get by not having to execute the code is immensely powerful. Once people start seeing the benefits of that, it's a little less intimidating.
&gt; On the other hand, the thing that I like most about Perl 5 is the brevity. But something as simple as a subroutine declaration like sub lcfirst { ... } has now become 7 words with 30 or so extra characters to type. "sub lcfirst { ... }" is still valid Perl 6. You don't need to use any of that if you don't want it. You're free to ignore it if you don't need it, if you want to do it yourself, etc. Maybe I'm missing your point?
Perl 6 AND Perl 6. Diabolical.
The time machine done broke. Try [this](http://www.parrot.org/news/2009/Parrot-1.0.0)
Congratulations on hitting this milestone. :) 
i get test failures.. Kidding, congrats, although the page does not load :)
If you don't handle the arity like Rakudo's implementation, why don't you use more syntactic sugar? sub map3(&amp;fn, @list) { gather for @list { take fn($_) } }
Congratulations! BTW, what "Haru Tatsu" means?
Is this much better than the Perl 5 way? i.e., print "Yes" if grep { $day eq $_ } @days; 
I find the Perl 6 way much more readable and straightforward. $day eq any(@days) grep { $day eq $_ } @days grep can do a *lot* of thing. OTOH, while reading the Perl 6 version, one instantly knows that there is a comparison involved (`$day eq`). Then, when seeing the `any`, we know that we're looking for one occurrence of `$day` in the whole array. Besides, junctions can do a lot more than a plain numerized grep: we can check if every value is what we need, or none of them, for example. Finally, it is 7 chars shorter ;).
Site still down 1435 uk time, probably a good thing it hasn't been submitted to slashdot yet
Can get there now (15:00 UK)... but it does take a while. Maybe not Slashdot yet but it is on Hacker News... http://news.ycombinator.com/item?id=521316
First of all, the Perl 5 version you mentioned checks every value in `@days`. To stop as soon as the block returns true, you'd have to use `first` (from `List::Util`) instead of `grep`. Perl 6 has `first`, too. Using an `any` junction in this case is subtly different. For instance, the values might be checked in parallel. http://perlcabal.org/syn/S09.html#Junctions
Perl6 Junctions have been backported to Perl5.... http://search.cpan.org/dist/Perl6-Junction/
Am I the only one who's extremely annoyed by them changing the ternary operator? Not used that often? Are you kidding?
Springtime, more or less.
I do use tit very frequently, but it is a minor change, and helps it stand out. It doesn't bother me much. I think it is a small price to pay for the excellent features promised.
I much prefer the new version. It stands out more, and the new symbols make more sense (`??` = is it true?, `!!` = it's not true). I think another reasoning for the change was that it freed up the colon for use as an invocant marker (`method $object: 'arg1', 'arg2';`) and a pair constructor (`:key&lt;value&gt;`)
I was skeptical at first, but the first time I used the new ternary conditional operator it seemed even more readable and memorable. That surprised me.
&gt;$day eq any(@days) So this gets internally rewritten as something like: any(sub($d) { $day eq $d }, @days) (i.e. what the functional community has used for decades) right? Well good. Once again everyone gets to rewire their brains to save a slight amount of typing? (and by "everyone" I mean the handful of people who will actually use perl 6).
Er... I don't get it. So, because a new cool feature wasn't in Perl 5, Perl 6 must refrain from using it because it would force you to "rewire" your brain? Well, you don't understand why is Perl 6 for. I think you're just some troll, but I'm going to explain anyway. This doesn't get rewritten as you say. Let's take an example: my @days = &lt;Mon Tue Wed&gt;; my $day = "Wed"; my $p = $day eq any(@days); At this point, $p contains itself a junction, namely: `any($day eq "Mon", $day eq "Tue", $day eq "Wed")`. This obviously evaluates to `any(False, False, True)` (and this is equal to `False|False|True`). Then, when you use $p in a conditional, it "boolifies" (boolean context). As you can guess, `any` means "I want at least one True value". The third (actually not really the third, since junctions are unordered) is True, so you eventually get a True in your if condition. Perl 6's `any` isn't the any you mentioned (taking a predicate and checking if one value passes it). This any is called `first` IIRC.
&gt;Er... I don't get it. That's correct you don't. I don't care what *perl* did. I'm talking about functional languages (e.g. Haskell, ML, Ocaml, Lisp to some extent, and so on). &lt;admittedly nice explanation snipped&gt; Why is it done this way? What is the advantage of having the form you describe? For any to work I just need the first true so no need to apply it to all members. any is the name of the function in at least Lisp.
&gt;That's correct you don't. I don't care what perl did. I'm talking about functional languages (e.g. Haskell, ML, Ocaml, Lisp to some extent, and so on). Perl 6 stays Perl, it won't become to a (purely?) functional language instantly. It has (many) functional features, but it's not a functional language. &gt;Why is it done this way? What is the advantage of having the form you describe? For any to work I just need the first true so no need to apply it to all members. AFAIK, the junction short-circuit on the first True value it finds (because of the Bool context, IIRC). For more information, check [S09#Junctions](http://feather.perl6.nl/syn/S09.html#Junctions). So my little explanation was actually simplified. (I actively refrained myself from answering "What is the advantage of yours". Oops.) &gt;any is the name of the function in at least Lisp. And in Caml it is named List.exists. So what?
&gt;Perl 6 stays Perl, it won't become to a (purely?) functional language instantly. *sigh* Again, I couldn't care less about Perl. You want more people to use Perl 6 then just a subset of the current Perl 5 users right? Then why take something well established and make it look magical? Normally when one does this they do it for some advantage. I see no advantage here except saving a little typing. &gt;And in Caml it is named List.exists. So what? You claimed any doesn't take a predicate, I gave you an example where it does. I think any doesn't guarantee the order of the search in languages that provide it.
If you don't care about Perl, then why are you arguing with me? I'm not trying to convince people to use Perl or Perl 6. I don't care about that. &gt;You claimed **Perl 6's** any doesn't take a predicate FTFY. That's not because two functions in different languages have the same name that they do the same thing (especially if the languages are as different as Perl and Lisp).
&gt;&gt;You claimed Perl 6's any doesn't take a predicate Ok, so I claimed that "any" was a name recognized by functional programmers and you tried to disagree by pointing out the completely unrelated fact that *Perl 6*'s* any doesn't behave that way? Just never mind, go back to your blub language.
Tsk tsk, I thought you weren't a narrow-minded functional programming-fanboy, like those who discover FP for the first time ("omg Haskell rulz" and friends) (nothing against Haskellâ€”I use it everyday). I was wrong. You're just basically saying "o noes Perl 6 isn't a functional language like what I'm used to what a crap I won't even try to understand it die in a fire". Oh, and reread the whole discussion. Actually you tried to transpose your Lisp experiences in Perl, and that didn't work. *Update*: Deleting comments, what an intelligent reaction. &gt;I'm more of the "oh gawd another article on Perl? Is it still unnecessarily complex for virtually no gain in flexibility?" Then why do you read /r/perl? Just GTFO. &gt;[...] I'll choose other in every situation. Then you're a moron, unable to recognize the right tool for the right task.
Well, then why switch -&gt; to .? They did that to be consistent with other languages, then they did the opposite here. ? : is the standard ternary operator, and they decided to make a non-standard version of it. I guess I'll get used to it, but it still annoys me.
The dot has other things going for it. For one, it's 50% shorter than the arrow. :) (I wouldn't use the same argument for the ternary because it's not used as often, so it doesn't benefit as much from being terse.)
If CPAN shell fails on ActivePerl with an error message about parsing YAML, a solution is given [here](http://padre.perlide.org/wiki/Download) You must configure CPAN with these instructions: cpan&gt; o conf yaml_module '' cpan&gt; o conf commit commit: wrote 'C:\Perl\lib/CPAN Config.pm' cpan&gt; q
ActivePerl only gets better with age! A lifesaver on Windows, I always install it!
Isn't this about a bajillion times easier? my %h; my @unique = grep { not $h{$_}++ } @duplicates;
Outside of a small handful of modules that have actual value, much of cpan is vanity garbage written by vanity programmers. If you have to ask 'do I need to use me-too-ORM module #8,876', you don't.
Party pooper!!! ;-)
what do you mean, what's the deal with ms word quotes? the closest thing i can think you mean is the angled version aren't in latin1, but rather cp1252, and a lot of tools out there incorrectly conflate those two encodings. 
Maybe he was being rhetorical? "What's the deal with airline peanuts?"
As an aside, I first read this title in my feedreader as 'Facebook-Directed Development' and sensed that something in the world had gone horribly horribly wrong.
found this piece of code that does the trick.. this is kind of lossy though because it gets rid of all the characters that break your code (so that info is lost forever).. anyway, it did it for me and pasting it here for reference: sub unutf8 { my $string = shift; my $chrs = ''; for my $chr ( 0x0020 .. 0x007e, 0x02c6, 0x02dc, 0x2013 .. 0x2014, 0x2018 .. 0x201a, 0x201c .. 0x201e, 0x2020 .. 0x2022, 0x2026, 0x2030, 0x2039 .. 0x203a, 0x20ac, 0x2122 ) { $chrs .= chr( $chr ); } $string =~ tr/\x91\x92\x93\x94\x96\x97\xE2/''""\-\-\'/; $string =~ s/\x85/.../sg; $string =~ s/[^\Q$chrs\E]//g; return ( $string ); } 
`decode()` and `encode()` your data properly. http://perldoc.perl.org/search.html?q=perluni http://blog.jrock.us/articles/Fuck%20the%20internal%20representation.pod
Women of Perl? All 5 of them?
Accolades to the whole Parrot team for your persistence. Congratulations on the milestone!
idiot
I think using implicit $_ is perfect for one-liners and throw-away code, but for code you want to maintain it shouldn't be used.
This has always been one of my favorite Perl modules. It's easy to package up and distribute to customers (*way* easier than using MySQL or PostgreSQL), and works for the vast majority of small database problems. SQLite itself is also awesome.
That seemed to be a very long way to say that continuous integration and early testing are good, and the waterfall model usually fails when confronted with reality.
Agreed -- but sometimes people only see themselves when the details start to sound eerily familiar.
Why does it say "Perl" in the title? There's no Perl in that article. The pseudocode data looks more like Javascript (or JSON) than like Perl. The *description* of how to work with the data works just the same in Javascript, too, so you you can think that it *is* Javascript instead of Perl. Well, OK, this is only the first part, probably there will be Perl code in the rest of the series.
Wow, that's a compelling argument.
To all those who are standing on the edge of the pool of commenting: Jump in, it's fun!
&gt;And there we have it. The most popular web framework in Perl, using the most popular templating solution, defaults to silently swallowing the most egregious possible signs of error. And unless you really know what you're doing you're not going to find the option of making it helpfully give you a hint of what you did wrong. I'm the author of that most popular templating solution of which he speaks, and my head is hung low. &lt;shame/&gt; But I have redeemed myself by adding the STRICT option which warns about undefined variables: http://template-toolkit.org/svnweb/Template2/revision/?rev=1183 I should have done this ages ago. I guess I just needed the right kind of prod.
Glad to hear. I've been using said templating package for several years and have wanted something like that for a while. I'll make sure to try out the option whenever I get back to my personal projects.
I understand why this is in the Perl subreddit, but I really think it should have been in the programming one. A bit of 'anti-fud' is useful there from time to time.
I read that subreddit less frequently now; the tone of the discussions has turned nasty.
Have you tried posting on Hacker News (http://news.ycombinator.com/news)?. It's much more civil. Also, I wouldn't mind so much for the occasional troll; the important thing is that you get the exposure that your articles deserve. I bet it would get roughly 5 times more reads in Proggit (and would be seen by people outside the Perl community, which IMO is important).
I figure that *someone* will submit the best stuff wherever appropriate. No one submitted my latest piece (in praise of iterations regarding Rakudo's recent progress), so maybe it wasn't appealing enough.
Wow. I didn't know there was this degree of paranoia for backwards compatibility. I now appreciate having 5.10 features much more. I cannot help but think about what new language improvements (besides those brought to us by the CPAN) we would be enjoying if the fear to break DarkPAN code hadn't played that big of a role in p5p's decisions.
The lesson here is "Never market a new language primarily to system administrators."
I've been extremely impressed with the Perl community's reaction to this post. The maintainers of both DBIx::Class (Matt Trout) and Rose::DB::Object (John Siracusa) have contacted me justifying some of their design decisions as well as offering me wisdom of having been there and done that in ORM API design. There's been a lot for me to take on board and it's been a humbling experience. I find their attitude all the more admirable considering I've basically accused their hard work and labour to be "ugly" and inferior to other solutions. Realising the effect that their calm and logical responses have had on me, it's definitely a way of handling things I'll strive towards on a personal level in the future. My one regret here is not taking a more thorough look at DBIx::Class before criticising it. If you haven't seen the update to the post as well as some of the comments left by Jess and Matt then they make a really good case that the DBIx::Class I posted isn't a very good reflection of the library. It's safe to say that although I still agree with the overall sentiment: APIs are really important and it's an area where we can all improve our Perl code, if I were writing this post again tonight I would approach it with a bit more respect for the people behind those ORMs.
The `__PACKAGE__` syntax is *still* ugly, in my mind. It's worth installing the CLASS module just for that.
I've been waiting on this a long time. Time to fire up cpan and pop some corn...
JVM is a very popular target platform so this is a step in the right direction. 
Wow, that was unreadable. I suppose most people would addendum '... like perl', but I like perl and find it quite readable when it's not purposely obfuscated.
It isn't enough to blog, get it announced in many places
My friend did his master's thesis on this. Back then it wasn't really feasible. http://www.ebb.org/bkuhn/writings/technical/thesis/
Like in /r/programming? ;)
The OP speaks as if there was nobody writing blog articles etc. That's false: just take a look at this reddit section. He even ask for a planet: [we got one](http://planet.perl.org/)! (And even [two](http://planetsix.perl.org/), with the Perl 6 one). But I agree with his main point: not getting on (reddit|digg|hacker news|...)'s main page is not making enough noise.
I don't know if this is a good idea now that Sun is bought.
I original came across this on [Hacker News](http://news.ycombinator.com/item?id=573180) And I see its now also posted in [/r/programming](http://www.reddit.com/r/programming/comments/8ecs1/announcing_the_enlightened_perl_iron_man/) 
[Another perl news aggregator](http://perlsphere.net/) - makes three.
Marketing is all about "we know how to do it and you don't! join us and we'll show you! seriously bro, you totally need to let us hook you up with our awesome product." See: Rails and Django (Note: I love django). Perl on the other hand is just kinda sitting there going "There is more than one way to do it, your way isn't quite the same as mine but I do see your point." I really don't know if it's possible to bridge that gap. Blogging more would definitely be good for exposure though.
The programming blogosphere is a very clever trick to get the hype minded to engage in a constant wild goose chase and keep all the jobs to ourselves. But anyways, what are the useful goals of open source platform advocacy? It seems to me it's to create jobs and sell books. Directly generating hype is probably a good way to sell books, but it doesn't seem to be a great way of creating jobs. Writing software seems to be the quickest path to that.
There are many open source products written in Perl. Problem is that many users do not know about them. Even some Perl programmers do not know about CPAN! 
CGI and mod_perl? Ouch. Use HTTP::Engine instead.
If the Padre folks actually looked at the internals of other editors before writing their own, it would have been easy for them to implement spell-checking of just documentation and comments. Emacs, for example, has the concept of a syntax table. It lets emacs know what sort of "thing" each character represents -- punctuation, documentation, etc. A spell-checker can then hook into this standard mechanism to only check text-like things, rather than langauge keywords, variable names, etc.
Some previous issues (eg. `my Int @a`) were resolved, but that the project status page wasn't updated. Is it possible to make it current?
Pekne meno!
The improvements have been quite welcome. I rely on this module daily, and I was very happy to see my pet warning message taken care of this month. Kudos and thank you to everyone who was involved!
No idea how many still use HTML::Template, but I wrote this code when developing www.s1jobs.com and it really did make 'AJAXifying' a lot of our pages that much less painful. I realise the documentation might be a bit sparse (or non-existant) but I'm not sure how many people are in the same position as me of being unable to move on to Template Toolkit. So if anything is unclear please let me know!
&gt; We had our best year of fund raising ever Hooray. :)
More like "PerlCritic in your browser (for a team)"
Woah that blew my mind away. Damn I wish I could *count on* 5.10 in our env so I could build up those grammars. So powerful!
Woah wait a second, perl 5.10.0.5 is out? When did that happen?
It's 5th Strawberry release of perl 5.10.0
Whoever wrote that should've had a look at this: http://perlbuzz.com/2009/03/how-to-write-an-announcement.html
Which is more important: keeping to a strict format or getting the message out to the people most in need of seeing it?
You missed the point there. It's not the format, it's the content they failed at. When i read news about releases of software i want to know what the release brings in changes, not what the software does. There's only one sentence in there that actually mentions any sort of change and the entire rest around it is what one would expect on the "About Catalyst" page. Try actually reading the "Without an angle, there is no reason for the reader to read past the headline" part of the URL i linked.
Oh *there* you are, APL!
awww :3 this should been posted on [/r/rails](http://www.reddit.com/r/rails) so I could say: &gt; ha! now even perl laughs at you. EDIT: s/ruby/rails/
well, they want to bootstrap parrot without perl. sounds like a lot of work, but makes sense to me.
I know I don't comment much, but I really appreciate all the articles you've been submitting!
If you have a class that had several roles, some which contain the same method signatures, how are they handled?
I'm not quite sure what you're asking, but if you compose multiple roles into a class and some of those roles have methods of the same name and signature, you get a compile-time error. You must disambiguate false cognates explicitly.
I have to admit that every time I see the phrase "Duck typing" I think of a duck walking across the keyboard.
Why no Moose?
I was thinking about roles while biking home and the following question popped into my mind: how do roles differ from multiple inheritance with linearization? Based on my understanding of roles, the behaviour is largely the same; the difference is mainly conceptual.
You probably lose out on advanced features such as runtime instance role application and parameterized roles, and you may have to change the language's linearization support to detect conflicts.
Because the parser object has only methods and no attributes, and simply inherits from a class that's likely not written with Moose, so why bother with Moose?
Because if you want to extend it, you're screwed.
... for various values of "screwed" none of which actually mean "screwed", as reimplementing a 60-line class in terms of Moose should take a decent Moose programmer 10 minutes, seven of which include brewing a pot of coffee or tea.
This way you have to rewrite something you already wrote. That may be very quick, but that's kind of waste of time. I have to admit that "screwed" is not the appropriate word here, though (for my defense, I'm not a native English speaker; I try as hard as I can, but sometimes I fail like here).
&gt; This way you have to rewrite something you already wrote. Only if he has to rewrite the code into something for which the advantages of Moose outweighs its disadvantages... ... and the cost of rewriting is only a net negative if the time spent rewriting is less valuable than the utility gained by not abstracting prematurely, or adding dependencies prematurely, or whatever. Moose is a great system, but it's not free. For small projects like this, it may not be appropriate.
Just a question: is it intended to be packaged with Emacs?
None of those seem exclusive from multiple inheritance. If you can change classes at runtime in a single-inheritance language, you can do that with multiple inheritance too. Parameterized roles share similarities with C++'s templates? I've sat on it a few days and I still can't disentangle roles and multiple inheritance. While a lot of devs are against multiple inheritance, I've always considered the various attempts at fixing the shortcomings of single inheritance as complicated and limiting (e.g. the problems you've present with interfaces). _If_ roles are a way to sell some variant of multiple-inheritance's semantics under a better conceptual framework, I think that's a great idea. If not, roles are still cool, but my understanding is lacking.
I'm not aware of a MI system which resolves all potential method dispatch at compile time (and can detect ambiguous cases), and that's a pretty big thing. I'm also not aware of a MI system which can require that subclasses implement specific behaviors. That doesn't mean that such a system doesn't exist, but I'm not aware of it. (The only widespread MI systems I know of that people actually use are in C++ and Perl 5.)
And for the poor souls who have to still use Apache 1.3, neener neener.
Not a fan of chained accessors, but appreciate the cool use of Moose.
Can I ask what is the problem with making certain accessors chainable? Not being confrontational, just genuinely wondering what the potential pitfalls are. 
My biggest issue with them has always been that it is sometimes too hard to see exactly what code like this is doing. $obj-&gt;foo(10)-&gt;bar(25)-&gt;baz(30)-&gt;goorch(50); I would have to know which accessors were chained and which were not and this somewhat reduces the black-box-ness of your class(es). Whereas if you aren't using chained accessors it is pretty clear what you are doing (calling methods on return values). I also have found it very difficult to design an API with chained accessors, a few here or there are okay, but use them too much and you can end up painting yourself into a corner. I think jquery does a good job at this, but it really required a commitment to using chained accessors and that is evident in some of the odder corners of that API. 
Upmoded for the racist title.
Hmm this seams rather nice, thanks! :)
Wow, they made it rather quickly.
yep , not really hard to set up a [rnews](http://rnews.sourceforge.net/) clone on some server ..
Perhaps the Rakudo people know the answer to this. One of my co-workers is using a module built off Devel::Declare and was having some problems. I couldn't effectively help him debug the problems because what he was writing was no longer Perl in a sense. Is there a term by which we can refer to the extensions to Perl 5 syntax, even if they were done in Perl 5 itself? When I see people say "ooh, modern Perl is sexy" I think to myself, that's not really Perl...
Right now I'd be happy with 5.10.1! Fortunately even after using 5.10.0 in production at work we've only hit one bug that 5.8.x doesn't have and it is infrequent.
5.10.1 should be out soon, but I'm thinking of the next five years of Perl 5. If the timeline of previous releases holds, we *may* get Perl 5.12 by then. I'd like to see it much sooner -- next year, even.
Whenever i try to visit perlgeek their site seems to be down. Is that common?
I've never had any problems accessing it.
Just curious, what bug is that? We're transitioning into 5.10 from 5.8.8 now, haven't noticed any problems yet.
Wait... I started programming Perl in late 1999 and I don't remember using any version older than 5.6.0. They went from 5.0.5 to 5.6.0 in a few months? Or am I getting senile?
You're remembering correctly. The numbering system changed between 5.005 and 5.6.0.
http://rt.perl.org/rt3/Ticket/Display.html?id=60508 Given a frequent stream of XML feeds with a mix of UTF-8, Windows-1252, and HTML entities (which are both converted to UTF-8) and we've hit it twice in about 3 months. I'm a little worried that the assert only catches some of the error cases, but nothing has been noticed so far. Edit: I should point out that our production 5.10 system is running with the Fedora 10 patches as well as the patch from this resolved bug: http://rt.perl.org/rt3/Ticket/Display.html?id=54758
No rakudo.org?
&gt; I'm not aware of a MI system which resolves all potential method dispatch at compile time (and can detect ambiguous cases) Doesn't C++ do that? E.g.: it won't compile a hierarchy with a diamond problem unless you explicitly indicate which class to use a clashing method from. &gt; I'm also not aware of a MI system which can require that subclasses implement specific behaviors. C++'s pure virtual functions do that.
&gt; Doesn't C++ do that? I don't know; I've never used multiple inheritance in C++. &gt; C++'s pure virtual functions do that. Yeah, I guess you could make them work that way. I suspect clarity might suffer, but I've never been able to keep C++ in my head anyway.
The last seven paragraphs are priceless.
Yeah, I really really don't get why new versions of modules need to support old versions of Perl. Sure, support 5.8 for those who haven't upgraded to 5.10 yet (many distros have not), but supporting any version older than that is ludicrous. Those people aren't going to upgrade their modules any sooner than they are their version of Perl. Let their code rot where it is. If it's been untouched in that long, it's not going to suddenly get maintained.
I work at a company that uses Perl fairly frequently for back-end work. I'll be honest: for most of it, it doesn't matter how backward compatible Perl is because what's already running is never upgraded anyway. Our people responsible for server software upgrades and installs are firmly entrenched in "it ain't broke, don't fix it." Our usual Perl version is 5.8.4, with a 5.8.0 and a 5.6.something hanging around. If we requested a Perl install on Windows as recently as a month ago then we got 5.8.7. But what about new CPAN releases adding a "use 5.010" in, you ask? Chances are those modules will never get upgraded anyway. Now the situation isn't hopeless, but somebody has to want it to change before it will. On Windows we've lobbied and convinced them to install Perl 5.8.9 (ActiveState; they need MSIs for OpsWare). When we were moving to a newer server we requested the install of Perl 5.10 and it happened because we rebuilt all the Perl SRPMs from Fedora 10 for RHEL 5 (including some via cpanflute which we used that Fedora didn't package) and put them all in a custom Yum repository for easy installation by the systems people. Now we had a shiny new RHEL 5 machine with Perl 5.10 (plus patches) taking over what used to be Solaris 5.8 with Perl 5.8.4. Progress I'm happy with. Did I run our test suite for the myriad scripts (as old as 10 years) being moved to the new server? The answer is: what test suite? Now on the plus side the system does have monitoring if things blow up so we fixed what we knew would break (mostly OS-level stuff) then hit the switch and watched closely. The two peeps were forgetting to change some wrapper shell scripts with hardcoded paths from /usr/bin to /bin because Solaris has /usr/bin=/bin, and the fact Solaris mailx has -r and Linux doesn't. Perl was fine. If it wasn't, we'd have fixed those scripts too and moved on. We did hit two 5.10 bugs, one fairly bad before deployment and one infrequent after deployment. The fairly bad one was reported to perlbug and fixed by Dave Mitchell in 3 days and we rolled that patch into our SRPM before the install. The infrequent one is a C-level assert but an eval{} catches it so the few times we've hit it there hasn't been a huge problem (and it is data-related so often the retry mechanism in our software lets it succeed the second time). We've not regretted the switch at all. So do I care about 10-year support for Perl? Hell no. I don't want to run a Perl that old. I'm tired of troubleshooting failures that were caused by bugs fixed 5 years ago. I'd rather spend my time on new bugs that improve the state of things rather than play catchup to what people knew years ago. - Configuration and installation assistance: Don't care; Linux vendors package it for us. (Though I could build it if needed -- the build routine isn't hard.) - Access to a bug tracker: Very important. I don't need immediate attention but I do want somewhere that I can make the problem known, or see if others have encountered the same problem. Or maybe even contribute a patch. - Feature requests: We'd probably propose them as individuals rather than as a company, given the back-end nature and us being programmers. In that regard a mailing list or forum or newsgroup or enhancement tracker is fine. - Consulting services: Not necessary for us, but I suppose some would like it. - Training service: If you offer a "rehabilitation service" where I can make past programmers repent for their sins that I must maintain then sign me up. I do see a desire to have such training available for people in the company we see with potential and who would like to go deeper in the work but currently do not have the knowledge. - Patches and bugfixes: Most important. Bug tracker doesn't do anything if those fixes aren't released. - Upgrading assistance: Give me release notes on incompatibilities and I'm good. - Binary compatibility: Don't care, unless you're referring to external libraries like Expat, FreeTDS, LibXML, etc. in which case I'd hope they work with whatever is reasonably current for their respective libraries. We had to massage the DBD::Sybase module to build properly as an RPM with FreeTDS, but that's a one-time pain I can live with since we have a .spec now. - Indemnification: Not being fired for those cases popping up inadvertently would be a plus. - Stability: "use 5.010" to get "say" is obnoxious. -E is obnoxious. I prefer the idea of freezing features at a version rather than explicitly uncapping in every program to be written from now to eternity. (Which changes it to: do I cap every program now in anticipation of the future? I see it more as "I can't be bothered to fix this script after my upgrade so I'll slap a limiting version on it.") Though if you suddenly decide scalars are @ and lists are $ then you've gone too far, but growth of the language is not to be feared. Bonus points for making the old scripts that need changes fail under "perl -c", but release notes will suffice for the rest. (I love perldelta.) The perspective above is written regarding my work environment: all server-side and the environment is known (albeit varied in version). Opinion varies for other uses.
(not really related to the article, but I wanted to get this off my chest for a long time now) I believe CPAN (and the Perl community at large) would benefit by integrating git/mercurial into CPAN. Git would probably be preferred since the perl5 porters are already using it. It would make things a lot more transparent to people who don't follow all relevant mailing lists, irc chanells and whatever else means the active Perl community uses to communicate. These people use Perl for development, like it, and would love to contribute fixes to bugs found in modules they use. It would be so much easier to have CPAN as the one common gateway to all things Perl. Clone the repo of a module, fix the bug, send the patch. You don't have to be a Perl monk/hacker or whatever they call themselves these days, to contribute. You don't have know what the apropriate mailing list for this module is, you don't have to know who the current maintainer for this module is, etc. Make it easier for "non-power community members" to contribute! 
The rss feed for rakudo.org at the time of the request was horribly unsynced with the site. I'm sure they would add it if asked.
I find those webpages that split the article in several pages annoying, probably not the only one. Despite that, gotta read this later in detail
I agree, here the pages are really short and could easily be merged.
I don't know about a second edition of 'Perl Practices', but I am looking forward to seeing chromatic's "Modern Perl' out. I'd also really like some book (besides Moose::Manual, which is great) dedicated to Modern Object Oriented Perl written by any of the Moose or EP people.
I haven't broached that idea yet, but I've thought about a Moose book too.
These perl6 examples seem very rubylike. Would it be safe to say that ruby is the most similar language to perl6 (even including perl5)? What are the major differences between perl6 and ruby?
Ruby's syntax is HEAVILY based on Perl5, more so than it may appear at first glance. The biggest difference in the basic syntax with Ruby is that "everything is an object", even the fundamental types, and they have a.. less-minimal class framework ;) Even the higher-order stuff isn't far off what you can do with perl5, it's just had some sugar added. Perl6 is a totally different beast, and actually considerably larger in scope. I won't pretend to have a full understanding of it, but from what I've read there's some really extremely impressive stuff going into it.
What scares me a bit is that the specification is not yet frozen after all these years and that there is still no usable implementation in sight (by usable I mean one that can be used for production code). I love what Perl is becoming but it seems that there is no plan to actually end-up with a working solution: people are playing with it, there's lot of very interesting functionality but it just looks like a Computer Scientist theoretical playground, which is fine in itself but really doesn't help people who *use* Perl every day as part of their job.
 &lt;sjohnson&gt; skids, how often does he (Larry) come here? what's his nickname when he does? &lt;wayland76&gt; lambdabot: @seen TimToady &lt;lambdabot&gt; TimToady is in #perl6. I last heard TimToady speak 3h 9m 56s ago. &lt;skids&gt; sjohnson: you already talked to him, in fact, when you first logged in. &lt;sjohnson&gt; wow &lt;sjohnson&gt; i had no idea that was him!!! &lt;skids&gt; :-)
Is everything an object in perl6? I like that feature. Utility functions feel dirty now.
Work on the specification started in 2001. The point is not that the schedule can slip due to unknown factors and life taking over but that it seems to be open-ended with no clear end-goal that tells us what Perl6 should achieve, other than being awesome. Even today, the specification is being changed, features are still being discussed, syntax still being argued. So let me return the question to you: *how long should it take to produce a specification?* Probable answer: *as long as it needs to*...
At some point, the specification is *implemented* and that becomes the language version that everyday coders can *use*. That the specification is a live document and then carries on to become Ecma X+1, Java X+1, C# X+1 is a given. Correct me if I'm wrong but it doesn't appear to be the case with Perl6: none of the implementations seem to have decided on the set of features they want to achieve for a Perl6.0 release because there doesn't appear to be a definite decision on what Perl6.0 is yet. I love Perl but something seems off about its development cycle. I'm sure that viewed from the inside there is a good explanation for everything but as an 'interested outsider' I don't get the impression that anyone knows where this is going with any degree of certitude: it feels like it'll just be out when *it's ready*, whatever and whenever that be, no-one being ready to even hint at a possible release, the subject being side-stepped every time it is mentioned. So mistakes were made and no-one has done this before. That doesn't explain the conspicuous lack of planned release and what feature set it should implement. Don't you see this as a major problem? It is really too early to ask these questions? It is just an issue of clarity? of communication? What is it that I'm not getting?
It's worth noting that Ruby has continuations too, but nobody uses them. Say, does Perl6 allow resuming exceptions? [This](http://docs.parrot.org/parrot/devel/html/docs/pdds/pdd23_exceptions.pod.html) looks promising -- it seems to have some characteristics of resumable exceptions and CL's condition system. I'm understating things a bit when I say that it annoys me that that Ruby, a language that has continuations, does not provide a continuation with any exception. :|
Perl 6 *has* a plan: when one implementation is sufficiently close to implementing all of the features specified now, it will be frozen, and future improvements go into the next version (perl 6.1.0 or whatever). It's not like the Perl 6 hackers and designers new nothing about project management; most of them have read "the mystical man month" and know about slipping dates and all. But still it's not paid work, and can't be managed as if it were.
Even Python 3 was developed more than 10 years. Perl 6 has much more changes.
Everything is an object spawns evil such as a.zip(b). I'm glad Perl 6 has an alternative to that.
I'm not sure what you mean. What is the "a" object, and what is it's method "zip" supposed to do in your example?
Assume they're both array objects. "zip" is like a zipper, taking one item from each array in turn to make a single array. Or see [ruby zip](http://www.ruby-doc.org/core/classes/Array.html#M002221). The question is, why is "a" more special than "b"? Because that's how objects work? Why?
So you're saying that EIAO encourages language designers to add methods to objects that really should be separate utility functions? I suppose that's true. But it doesn't necessitate bad practice. I see that as fairly mild compared to the burden of having to treat my data differently depending on whether it is in primitive or in object form. Furthermore, being able to do "data.methods()" on all my data really makes interactive (ruby shell) programming so much quicker. No looking up the names of whichever utility function I need to convert this type into that type--it's right there at my fingertips. I can see why someone who focuses exclusively on one language would not necessarily appreciate that sort of thing. But to occasional programmers, it's great. One more question: What is the point of ruby's zip method? Why would anyone want to do that?
Trying! Learning! I just finished feeding and grooming my pet bug for 5.10.0 and sent off a patch. Not that I can do releases, but hey, it's a start.
Correct. I don't mind all data being an object but that a.zip(b) feels like "I have a hammer, so everything is a nail" language design. I much prefer the the idea of: @a Z @b As for uses, probably better to see: http://www.google.com/codesearch?hl=en&amp;lr=&amp;q=ruby+\.zip\(&amp;sbtn=Search
There's nothing wrong with that! (Quite the contrary.) I just found the contrast very telling.
More commented over at [programming](http://www.reddit.com/r/programming/comments/8o9a8/how_perl_saved_the_human_genome_project/)
Reposting from Programming since the [discussions](http://www.reddit.com/r/programming/comments/8p5vy/do_you_want_fast_concise_and_reliable_code_try/) is pretty hopping.
Having actually used this to make something, I think it's prudent though to warn that the simple process of one function calling another function repeatedly in order to do some work can introduce massive performance drops.
&gt; The same syntax can also be used to dispatch methods too, by placing the &gt;&gt; before the . operator ... Or use the .? form that only calls a method on things that have it This is the first language I've seen that comes with explicit support for higher-order messages. Very nice.
Some things have no defense though, which is thusly the article.
I would guess hate from frustration at failed potential. Where "potential" being whatever motivated those people to use Python, Ruby, or PHP instead. And some people just like to bash the unfashionable because that's perceived as being cool and progressive since the old thing isn't as shiny as the newest BestThingEver(tm).
Is he wearing a shiny dress in that picture? I started in perl, and still use it sometimes for work, but I've moved on to python and finally ruby. Perl just makes it so easy to write unintuitive, hard-to-read code. Punctuation variables, "default" behavior, the use of references to build complex datastructures... Perl was great for its day, but it seems like a mish-mash of unix idioms rather than a well-conceived language. It falls over backward to help you fit as much complexity as possible on one tiny 1980s CRT screen--a counter-productive goal in the modern world. I could go on, but the moderators of the Perl subreddit like to ban/censor anyone critical of their language.
&gt; ... the moderators of the Perl subreddit like to ban/censor anyone critical of their language. Just trolls. Legitimate criticism is fine.
You do realize that reddit has a downvote button to deal with things like that? Your censorship is far worse than any "troll."
I prefer to encourage intelligent, respectful discussion here. If that means "censoring" (what a stupid word choice!) people who'd rather flame and attempt to rile up others just to cause trouble, so be it. There are almost 2200 subscribers and 5 banned accounts.
This is the only sub I know of that bans people. That's not something to be proud of.
&gt; That's not something to be proud of. I suppose if your slogan is "free speech everywhere Ã¼ber alles", you might care. I don't. I care more that discussions here tend to avoid the yelly monkey flamey ranty measuring contests that other subs tend to have. There are plenty of other places on the Internet for the people behind those five accounts to pick fights.
I've seen what you call a "troll." It's anything you don't agree with. If you don't like downvoting as a way of discouraging bad behavior, go somewhere other than reddit.
Why do you care what he's wearing in the pictures? What possible relevance is it to the topic at hand?
PHP folks don't tend to bash Perl, because, well, they're using PHP and have no right to throw anything. Ruby folks tend to bash Perl less; I guess because their language has its own share of quirks. It also has a penchant for sigils like Perl. I mostly hear crap from Python and Java folks, and frankly, anyone who thinks Java is "readable" by comparison must really love reading, a lot, all the time. As for Python, seems a decent enough language, but the whole indentation is syntax thing has been a stumbling block for me using it. It seems to have its own inconsistencies as well, what with having to use colons sometimes to denote the start of a block. I'm sure there's a good reason for that, but I have no idea what it is. Just seems like if you're gonna roll with the whole indentation as syntax thing, you should stick with it 100%.
I remember it was quite cool- after installing all the modules, I ran it, and it popped up a canvas in which I could draw boxes, ellipses, and little ascii art. Every item was an object, so I could move boxes around, very nice. does anyone remember what it was called and where I could get it?
Was it Asciio by any chance? If so its on CPAN: http://search.cpan.org/dist/App-Asciio/
Yeah, that's the one. I was in Oslo when Nadim first demonstrated that. We begged him to put in on the CPAN because it's such an awesome application :)
I don't care much myself, and the content of his posts is great, but the pic is rather distracting. When you're trying to communicate something, it's best not to distract them with something else. If some guy walked up to you in a shiny gold dress and started to tell you about how great their programming language was, I'd bet you'd be far more focused on his apparel than his message.
I suggest you cover up the picture with your hand. Or perhaps move your browser so that the pic on the left is off the edge of the screen.
That looks just awesome.
&gt;PHP folks don't tend to bash Perl, because, well, they're using PHP and have no right to throw anything. That's false. Many PHP coders I know define their favorite language as "People Hate Perl".
Yeah I was going to say something about the man in what appears to be a japanese or chinese evening gown but I was afraid it might be a case like audrey tang. In any event it wasn't really relevant.
Make your own perl reddit if it bothers you so much. And stop trolling.
But who cares what they think? They're using PHP.
Trolling? The article ASKED what criticisms people had of Perl. I'm the only person who gave a real answer, yet I get the most downvotes. Here's another thing to hate about perl: a community that treats criticism in such a way. Wow.
It's not a woman's dress. It's a traditional wedding gown he used for his marriage, worn by men.
They probably downvoted you because of your opening and closing sentences in your original post.
You win the price. And the reason its on my blog is that it was the only picture I had on my local computer at the time I created the vox account, and now I just leave it there because I find reading people's reactions to be personally amusing. Also, my wife thinks I look handsome and her's is the only opinion that matters to me. But the recruiter who's holding my resume is saying I should consider changing it, so I might switch to one of the other wedding pictures on the one year anniversary of the blog or something. 
Hey, what does "given the nature of the perl community" mean :)
Did perl molest you?
&gt; Did perl molest you? See, this would be a legit example of trolling. I don't think reddit has any need for censors, but I think it's funny that the moderator of /r/perl will ban anyone critical of perl, but not someone posting what is inarguably a troll post that isn't critical of perl.
Fight fire with fire.
Thanks for pointing to this thread. The goal was not to post tips so much as create software to go with it, but hey, whatever works. 
Sorry about that. "Tips" wasn't really the word I was looking for, but I couldn't think of anything more suited. Perhaps "Discussion" would've been better...
And in any case I'd be honored to be compared to Audrey Tang, an exceptionally brilliant and interesting person.
Wow that's actually really cool! Great into to a bunch of perl6 ops I was unfamiliar with.
I need to start looking into Perl 6. Say is kind of a nice new feature, not sure if I'd use it that much
You can use it today, in Perl 5.10: use 5.010; say "hi!";
or using Perl6::Say in previous version
While interesting, the article could benefit from more usage examples.
The fact that a discussion on the nature of his dress *comes up every time he posts* **proves** the outfit is distracting Are we going to talk about Perl, or are we going to talk about his outfit? I prefer the former, am tired of the latter, so jn should change it
I didn't say it wasn't distracting. You're confusing "What I would like" with "What jn should do." Just because someone does something you don't care for, or that you wouldn't do yourself, doesn't mean that it's a wrong choice. 
Or Abigail, for that matter. What you wear on your web page is up to you. It's rude for anyone to complain, or worse, to demand some sort of justification for it.
I'm assuming John wants to: &gt; Spark discussion about the topic of his blog post I'm assuming he **doesn't** want to: &gt; Spark discussion about his wedding outfit In this case, what I want is what he wants as well. I think John (and his posts) are an asset to the Perl community gravity and I wish to help him communicate more effectively Of course John can do what he wants, just as Matt Aimonetti should be able to present using scantily clad women if he wants
I thought it proved that many Reddit commenters prefer facile pseudo-witticisms to insightful, well-reasoned commentary.
When giving a lecture, I wouldn't expect John to wear that outfit, or a swimsuit, etc. Unfortunately in public communication, sometimes you have to meet your audience halfway, it's a give and take. Also, you cannot always expect your audience to give proper respect (in many ways, reddit is a hostile environment) Finally, to be honest, even I was distracted by the picture when I first saw it 
This reminds me of a joke I heard floated at OSCON last year about how Perl 5 development had become a lot more stable, saner if you will with the advent of Perl 6 due to the significant personality delta between people who develop programming languages and people who maintain programming languages. (...it was funny when not put so delicately) I'm not sure but we might be seeing their intersection. Not to suggest that these activities are mutually exclusive but what joke isn't exaggeration through caricature. There is, though, perhaps a kernel of truth perhaps in this. Perl 6 development is nothing if not bleeding progressive and Perl 5 development is clearly of a more conservative (suggested here to be somewhat backward) bent. There is even a slight hint at Perl 5 development having been somewhat more progressive in the past. Not surprising given that a good portion of the Perl 6 developers were likely then involved. It is reasonable to expect this. Those interested in radical change go on to develop the radical product. Those who are more interested in obsessively improving a stable core stick with the stable core. These groups will act differently. They will have different motivations and priorities. I don't really have a conclusion other than to suggest that the best way to progress Perl 5 would have been to keep the progressives tight in the fold (and probably damning Perl 6 entirely). They have clearly been in the fold given the awesome changes in 5.10 but Perl 5 hasn't been the field for serious progress, for language design, in the Perl paradigm for quite some time. Backports only kindof count (imo). Moose (genius) and Modern (inspired) are perl 5 libraries and though progressive are not fundamental language design/progress (again imo). I am just a humble observer but I hope the (what I think are obvious) personality and motivation differences between these groups can be understood and gotten over.
&gt; Perl 5 development is clearly of a more conservative (suggested here to be somewhat backward) bent. I don't mean to suggest it. I'll outright say it: any software development process that cannot release software is *broken*. Maybe it's too much to expect that Perl 5 will ever get function signatures, for example, but it seems unreasonable to let the function argument unpacking performance regression affect more and more people for seventeen months and counting based on the hope that someone will eventually release Perl 5.10.1 Real Soon Now.
Maybe we could take this the other way. I guess we don't need to prove there is unreadable code in php, ruby and cpp. Python golf anyone?
http://codegolf.com/ , http://golf.shinh.org/ 
What next? Remove `-e`?
It doesn't seem like people are annoyed with the *practice* of Perl golf, but the fact that Perl lets you write code however you want to, and that makes it confusing/annoying to read someone else's code who doesn't use good practices. Taking away Perl golf as a hobby won't do anything to change this perception.
Is there any particular reason why there couldn't be an interpreter flag to force better style? Forgive me if this is a foolish suggestion. I'm a Perl novice.
In theory, `use strict;` and `use warnings;` help.
A language should should encourage you to do things the right way. The path of least resistance should be readable code, not the other way around.
use criticism; in your program. But you will need to install it from CPAN :).
Exactly right; that's why I believe the strict and warnings pragmas should be on by default -- as should the feature pragma. Backwards keyword compatibility and warning disabling should be optional features.
Can someone golf this one up a bit please: perl -e 'die "Stop with the perl golf already!\n"'
Why `for my $n (0..$#array_ref)` instead of `for my $n (@{$array_ref})` also you should have ` elsif (ref $obj eq q{})` and die on else because if somebody does something silly like pass you an object your func will fail
*for my $n (0..$#{$array_ref})* sets *$n* to the indexes of *$array_ref*. Just one of the many ways to do it. *ref $obj* will return *undef* on strings. In my example I'm not considering CODE, so the else will catch strings and closures. I guess you have a point, I'll change it to return the anon sub untouched. Thanks for the heads up.
Right... but isn't it more efficient and definitely more perlish to loop over the objects themselves?
_If_ I understand wrap's behavior correctly, I have misgivings. As presented, wrap affects all of a function's callsites without requiring assignment. While that's sometimes handy, it's not lexically scoped (except insomuch as the function definition itself is). I think this is a clumsy and sharp behaviour, and advance that it should return a function reference instead without modifying the existing one. Is such object mutation common in Perl6's standard library and builtins? As an aside, I thought -&gt; was used for anonymous functions. How does it differ from sub?
I guess it depends on your style and your public. Also depends on what you consider "perlish". There's a new movement out there trying to make Perl become less line noise and more comprehensible. I don't mind iterating through the objects themselves, but I believe it's best practice to iterate through the indexes instead. It's also how people from other programming languages might be used to seeing it. I might as well have used a for loop, but I try to avoid it whenever I can. Please check the examples in chapter 2.3 of Perl Best Practices so see what I mean. Chapter 6.5 also has some say on the matter, although chapter 6.6 suggests your way of doing it, so I guess... whatever! :)
Actually, `ref` never returns `undef`. It returns the empty string on non-references (such as strings).
Good series of articles, but that ORM design doesn't work in practice. When I built my ORM I first tried to do it using the Moose type system, but the problem I constantly ran into was whenever I actually tried to use the classes that I took the trouble to create a bunch of custom subtypes for, if I ever actually had to deal with untrusted data (i.e. data from a data feed or web form) then I had to either: 1) Pre-validate all the potential field values, making sure it validates to my type rules before I try to set it on the object attribute. 2) Wrap every attribute set operation in an eval {}. Why? Because if the untrusted value I was going to set failed the type constraint then Moose would throw a type constraint exception and my handler/script/etc. would hard fail. This is obviously good because it prevents shitty developers from breaking the business logic rules and letting shitty data into the system. In practice though, this led to one shitty ORM and shitty applications littered with shitty defensive programming. I found it's much better to only do type validation once - during the actual write operation itself. This ruled out using Moose for type constraints, but the code using my ORM got a hell of a lot less ugly.
As per other thread, CPAN makes this easy: use Data::Transformer; Data::Transformer-&gt;new(normal =&gt; sub { $$_[0] =~ s/(^\s+)|(\s+$)//g; })-&gt;traverse($data);
Anyone (including Damien) or anything (including PBP) advocating using *unnecessary* indexes instead of a foreach form is just plain wrong. I won't recheck those chapters, but I'd be suprised if the advice were supposed to supercede common sense. You could make an argument that the keyword 'foreach' would be more readable in those cases, but Modern perl programmers are very comfortable reading both forms of 'for' loop.
\*sigh\* I can't read the words "Final Countdown" without hearing the keyboards and vocals from the *Europe* song.
Yet not a single regex anywhere. Downvoted! *edit: or sigil
Me neither, and some people think meme theory is bumpkiss.
Old. Very old.
So?
Sounds like [superinstructions](http://www.complang.tuwien.ac.at/anton/euroforth/ef03/ertl-gregg03.pdf) -- just in reverse. Vmgen uses them to good effect.
&gt; I found it's much better to only do type validation once - during the actual write operation itself. This ruled out using Moose for type constraints, Can you (or do you) generate the write operation validation code from the Moose type constraints? 
`alias perl='/usr/bin/perl -Mstrict -Mwarnings'` :-) Seriously though, I wonder how easy it would be to have the Perl distribution build a second perl binary with strict, warnings and other niceties enabled by default. I'm thinking along the lines of `taintperl` that used to be distributed with Perl 4 (perl with -T enabled by default). Call it `newperl` or a suitably modern name and then there's no problem with breaking existing code using the `perl` binary. Or perhaps have a configure option that allows you to enable strict/warnings at compile time? Of course, that doesn't solve the problem of getting such a patch into the core and distributed in a timely fashion... 
It'd *so* great if other distros did this kind of job as well (or if there was no need for this job at first). The current Perl status in Gentoo is a nightmare (just read the [bug report for perl-5.10 release](http://bugs.gentoo.org/show_bug.cgi?id=206455)).
I like the idea, but you also have to get it tested reliably with CPAN modules and the core and real-world programs (that sunk `superl`) and you have to convince distributions to make it available and you have to convince novices to use it in the face of all of the documentation and tutorials in the wild which assume `/usr/bin/perl` is sufficient. The biggest problem is still getting it accepted in the core though.
via: http://curiousprogrammer.wordpress.com/2009/06/11/modern-programming-style/ A Modern Style of Programming Â« A Curious Programmer - I only came across POE recently (which I keep mentioning because it is so awesome).
... have you tried just running *perl* from the cl? there's also so-called 'in-line' or 'realtime' perl e.g., *perl -e 'print "hello wurld\n" unless ( -s "/dev/null")'*
In programming, an interactive shell is one in which expressions are evaluated as soon as they are entered. This is not the case with typing to stdin. Furthermore, -e is not interactive. Here is an in-browser example of an interactive shell: http://tryruby.hobix.com/
http://search.cpan.org/perldoc?Devel::REPL Do try the plugins :) 
[zoid](http://search.cpan.org/~pardus/Zoidberg-0.96/man1/zoid.pod)?
Have you looked at Perl Console? http://www.sukria.net/perlconsole.html
oh yikes, i never got the point of those, !p usually works for me.
Devel::REPL is good, otherwise you can try `perl -d -e 0`
buubot
Well, they are very useful when you're doing OOP or learning an unfamiliar module. You get immediate feedback from your actions (humans learn better this way) and you can poke at things without having to go back and start from the beginning.
In particular, don't miss the Devel::REPL::Plugin::CompletionDriver:: series of plugins. These support autocompletion of methods (class introspection), modules, lexical variables and keywords. Edit: also, [this](http://github.com/jrockway/devel-repl/blob/1ea593cd9d9ec073af09745f49cd6807cbbb4c5b/lib/Devel/REPL/Plugin/LoadClass.pm) plugin will autoload any class, so that you can say: my $foo = Foo-&gt;new; without having to "use Foo" first. Really handy for quick and dirty exploring.
Thank you! This seems to be exactly what I'm looking for.
none of the languages we're talking about are compiled; I still don't see how this is more immediate than running your script in another console as you go.
A REPL lets you manipulate and observe data as it runs. You can do the same thing in a separate process, but starting over every time can be much more difficult.
Perl is compiled (okay, I'm nitpicking here).
There are other reasons not to use YAML.pm (it sometimes fails to deserialize data is serialized, for example). I'd be interested in a 3rd comparison with YAML::Syck, though. I personally use JSON::XS for most serialization needs as well.
If you are an Emacs user don't miss SEPIA (it has a repl too): http://cpansearch.perl.org/src/SEANO/Sepia-0.98/Sepia.html
Actually "perl -d -e 1" to start the debugger works fairly well.
Unfortunately it's dead upstream for many years
Now with an Arch Linux [package](http://aur.archlinux.org/packages.php?ID=27309)
Wow great write-up. Thanks for sharing!
It is disappointing that utility functions, rather than methods, are used for things like lc() and uc(). Why not $string.lc()? That would be much more of an OOP feel.
The method forms also work.
As chromatic notes, those are also available. I also prefer the method form and I'm a little disappointed that we'll have the utility functions at all (although I accept that removing them altogether might be too much of a paradigm shift for the average Perl programmer on the Clapham omnibus). One of the nice things about the method forms is that it avoids keyword pollution. As it is, `lc`, `uc`, `substr`, `index`, `rindex` and all the other string, list and hash functions must all be keywords (or at the very least, pre-defined functions with prototypes so that they can act like keywords). That's a lot of reserved words. Not that it's necessarily a bad thing, particularly given the eclectic nature of Perl. But I do like the simple elegance of languages that can get by with few reserved words. Perl 6 has gone in the other direction by adding even more keywords and a few thousand[*] more operators. [*] give or take 950 :-)
The package graph is amusing: at large scale, there seems to be 3 islands, libwww-perl, Tk and URI, with a lot of packages gravitating around. Great work! One problem though: the smallest texts aren't readable on the webpage (I haven't viewed the PDF or SVG).
Interesting article. As much as I don't like perl, I'm pretty hopeful for Parrot for many of the reasons laid out in this article. Couple of nits: &gt;Parrot uses the continuation for flow control, instead of a return address on a global stack. Isn't "continuation based control" just a return address on the stack/in a register + the other registers saved? Is the real implementation as complex as the article makes it sound? Is so, is that really necessary? &gt;Dynamic languages are notoriously difficult to parse, largely because they emphasise syntax thatâ€™s easily understood by humans, instead of encouraging human programmers to think more like machines. This sounds like nonsense to me. Haskell goes quite far to be readable for mathematicians and it's very strongly typed. &gt;You work with it by defining a series of rules that look a lot like simple regular expressions, Please tell me they didn't make the parsing engine be perl 6 or something? If so, I guess I can at least override it if I want a more proper parser? 
I heard this joke was really, really old and unfunny. For reference : the guy (I can't remember his name) said something like "Perl 6 will be released with Duke Nukem Forever LOL!".
&gt; Isn't "continuation based control" just a return address on the stack/in a register + the other registers saved? Not if you support first-class continuations. You can emulate CPS with goto + context if you're diligent about it, but you have to be pretty careful about the stack if you can make control flow into a graph rather than a stack. &gt; Haskell goes quite far to be readable for mathematicians.... If you want to consider them "regular humans", I suppose that's fine. &gt; Please tell me they didn't make the parsing engine be perl 6 or something? The parsing engine uses Perl 6 rules, but you can write your actions in whatever language you want. (You could write your own parser if you want.) You can override as much or as little of PGE as you want as well.
Very very useful , I was hoping something like this would pop up eventually :) It would for once allow to know what are some most used and reliable packages , which are popular and which are not.
&gt;Not if you support first-class continuations. You can emulate CPS with goto + context if you're diligent about it, but you have to be pretty careful about the stack if you can make control flow into a graph rather than a stack. Ah yes, I forgot that the call tree is also part of it. &gt;If you want to consider them "regular humans", I suppose that's fine. That wasn't my point. My point was that I'm not convinced making syntax extremely flexible for a certain group has anything to do with Dynamic vs. Static. I do like dynamic typing (I like static too), but what the article said strikes me as false. &gt;The parsing engine uses Perl 6 rules, but you can write your actions in whatever language you want. (You could write your own parser if you want.) You can override as much or as little of PGE as you want as well. Fair enough.
&gt; So instead of discussing things, I started to do something Probably a good idea. The perfect is the enemy of the good.
For all the talk of making a whole new CPAN for perl6, this is what seemed to be the more likely outcome. Glad to see the first module make it out there. Now if I can find the time to start writing the module(s) I have in mind...
It's true! But we ran out of perl 6 jokes last year.
How will the name clash be avoided though, with perl5 modules of the same name?
The obvious one is to append a "6" to the module name. E.g. DBI -&gt; DBI6 Despite its flaws, it's easy and simple. 
Yes, as long as there's some sort of convention to do so I suppose. Hopefully meta information will be correctly parsed by search.cpan and CPAN.pm to avoid the confusion too.
... still feels ancient. Dunno if lateish 5.8/5.10 releases fixed the big gotchas WRT automatic cloning of unshared thread data... was a fairly major problem for me. Only way to mitigate is to spawn a pool of reusable threads then send them work - "use"ing required modules from the workers. There are also a few hacks on CPAN to clean up after thread-local data. Also lots of problems with DESTROY methods in cloned unshared data, especially with file handles. Actually using explicitly shared data accross threads is fine only if you're completely aware of the semantics of the shared data. The vast majority of objects created by modules on CPAN aren't thread safe. I ended up using a pre-spawned thread pool in combination with Thread::Queue::Any, in an agentish pattern. The design of Perl6 (WRT concurrency) looks very nice; lot's of scope to implement nice concurrency patterns. OTOH, the concurrency implementations in Parrot are still *very* young. I guess I'm prepared to wait and see.
Answer: Don't use them. Fork instead.
Umm you might want to actually read the documentation on threading. Have you heard of Thread::Queues? Use them :: they're there for a reason.
do you mean compiled.. at runtime? i don't understand what you mean.
Perl isn't exactly compiled at runtime. It is compiled just before :). Then the program is run. This is roughly what happens (I don't exactly now what's going on).
okay right, but you can just execute code without explicitly compiling, that's all i'm saying.
That's right, this is why I said I was nitpicking :). You were technically incorrect, but that didn't really matter.
[cpan6](http://cpan6.org/)
IMHO that's a no-go. The correct solution is to make to distinguish between Perl 5 and Perl 6 namespaces. A temporary workaround (which I used now, after feedback from #toolchain) is to upload only developer releases for now.
&gt; After you added a new vhost to the database you need to restart the apache server so that the perl script is run and the vhost is set up. I wouldn't call that "on the fly"
I find Coro to be an interesting alternative to threads. http://search.cpan.org/dist/Coro/ 
&gt; wonderful modules such as Module::Signatures Module â†” Method? Also, Perl5i looks snazzy. I'm writing some code right now that I'd like to hand off to some non-Perl types soon, and I worry what they'll think about the reams of use statements I have at the top of every file...
&gt; Module â†” Method? You're right. Fixed now, thanks. &gt; Also, Perl5i looks snazzy. Right now Schwern recommends you don't use it for production purposes unless you're willing to upgrade it frequently and support it. In six months his opinion may change.
actually not very good since I cannot properly zoom in on the areas that interest me , the just published some jpegs that I can navigate ... some vector images would've been great
&gt; and I worry what they'll think about the reams of use statements I have at the top of every file... Couldn't agree more. And the fact that Perl has so many different ways to do it means that you inevitably end up with a mess of `use` statements, package variable declarations, `__PACKAGE__-&gt;method()` calls and all sorts of other boilerplate cruft that you have to wade through to find the "real" code. Cleaning up some of this mess was one of the primary motivations for me writing the [Badger modules](http://badgerpower.com/docs/Badger/index.html) and [Badger::Class](http://badgerpower.com/docs/Badger/Class.html#section_DESCRIPTION) in particular. It allows you to replace stuff like this: package Your::Module; use strict; use warnings; use base qw( Exporter Class::Base Class::Accessor::Fast ); use constant { name =&gt; 'Badger', foo =&gt; 'Nuts', bar =&gt; 'Berries', }; use Scalar::Util 'blessed'; our $VERSION = 3.14; our $DEBUG = 0 unless defined $DEBUG; our @EXPORTS = qw( name ); our @EXPORT_OK = qw( foo bar ); __PACKAGE__-&gt;mk_accessors(qw(nuts berries)); with stuff like this: package Your::Module; use Badger::Class base =&gt; 'Badger::Base', version =&gt; 3.14, debug =&gt; 0, accessors =&gt; 'nuts berries', utils =&gt; 'blessed', constant =&gt; { name =&gt; 'Badger', foo =&gt; 'Nuts', bar =&gt; 'Berries', }, exports =&gt; { all =&gt; 'name', any =&gt; 'foo bar', }; There's more to it than just class construction, but it's a good example of how Badger attempts to tame Perl's eclectic nature a little in the pursuit of cleaner, clearer and more consistent code. 
The damn StackOverflow anal jobsworth brigade got to it and closed it ;)
you mean something like the SVG that are available for each graph ? :) http://cpan-explorer.org/packages/downloads/cpan_packages_core_march2009.svg
no.
I'll only believe if Netcraft confirms it.
it's just resting.
Try [local::lib](http://search.cpan.org/perldoc?local::lib); it may help.
You can bundle pure-Perl ones, or as article suggests, install locally.
I don't know much about how perl is developed, but breaking up the responsibilities is an obvious and useful thing to do. Perhaps the most valuable thing is to have someone take on the role of bugmaster, who takes the lead on triage and making sure important bugs don't slip through the cracks. This takes a lot of the burden off a single individual whlie still letting one person be primarily in charge of the release process.
You can take that further. Why should only one person be primarily in charge of the release process? One person needs to be the final arbiter of what goes in and what doesn't, and only one person can make a given release, but why not remove that bottleneck too?
Sorry, but I think this is one of the ugliest things in Perl6. Yes, the colon is very much a natural language construct: Price: 123.00 Javascript/JSON gets it right: JSON: 'like this' Perl 5 uses a different symbol, but at least it's intuitively obvious as to what it does: Perl5 =&gt; 'like this' And then we have this Perl6 abomination: :Perl6('like this') Or this: :Perl6&lt;like this&gt; Consider the difference between this: $example = { foo =&gt; 10, bar =&gt; 20, longer =&gt; 30, } And this: $example = { :foo(10), :bar(20), :longer(30), } It's no longer possible to line up the values so that it is immediately obvious **at a glance** that this is a set of key/value pairs. Not unless you're prepared to do something fugly like this: $example = { :foo( 10 ), :bar( 20 ), :longer( 30 ), } Ugh. In fact, if you don't look carefully for the `:` at the start then it looks just like a sequence of function calls inside a block. $example = do { foo(10), bar(20), longer(30), } What about this example: $author.feed('cake and herbal tee'); Looks good. I think you would struggle to find a programmer of any language who couldn't understand what that meant. Consider the Perl6-ish alternative: feed $author: 'cake and herbal tee'; I parse that as feed( $author =&gt; 'cake and herbal tee' ); Clearly not the same thing. I think I'll be sticking with the Perl5-like `=&gt;`, thanks all the same. I like my code to be [skimmable](http://schwern.org/~schwern/talks/Skimmable%20Code%20-%20YAPC-NA-2008.pdf). 
I don't really understand. What prevents you from writing $example = { foo =&gt; 10, bar =&gt; 20, longer =&gt; 30, } in Perl 6? The colon notation is just a shortcut. TIMTOWTDI etc. :)
Yes, I'll continue to use the `=&gt;` operator. They can prise that one from my cold, dead hands. The problem is that I'm still going to have to wade through other people's code where they use the colon form. I guess I just don't see the point of having the colon notation at all. Other than adding Yet Another Way To Do It so that no two Perl 6 programs ever look alike. It's not really a shortcut as it requires more characters to type. Furthermore, all three of the additional syntax characters require shifting, compared to none when using `=&gt;`. foo=&gt;10; # f o o = &gt; 1 0 :foo(10); # &lt;shift&gt;;&lt;/shift&gt; f o o &lt;shift&gt;9&lt;/shift&gt; 1 0 &lt;shift&gt;0&lt;/shift&gt;; I could live with that (I can haz macros) if it wasn't for the fact that I find the colon form significantly harder to read. It looks like a function call and it's not conducive to having whitespace added - something which enhances readability and allows the values on the RHS to be vertically aligned. I recently spent some time hacking on Parrot code where the colon style is pervasive. Perhaps it's just that my eyes haven't had time to adjust to it, but I really didn't enjoy the experience of reading the code. It's not skimmable, and skimmable is a Good Thingâ„¢ It's a shame because I think Perl6 is just going to further the belief of the average programmer that Perl code is little more than line noise. 
I think the intended use case of the colon notation (I can just guess) is in cases like `1..10 :by(2)` or `$file ~~ :e`. This is easier to read (IMO) than `1..10 (by =&gt; 2)` or `$file ~~ (e =&gt; 1)`, while being the exact same thing. But I agree, in bulks of keys/values like the `$example` above, the colon isn't more readable.
Yes, I agree that the adverbial form is better when it's being used as a postfix modifier on a previous statement. But I think I would rather be writing `1..10 by 2` or even `1 to 10 by 2` than any of the alternatives that Perl6 provides. I'm not sure what `$file ~~ :e` is supposed to mean. Seeing as `~~` is the smart match operator, I'm guess that it is either testing if the file is executable, or if the file name (or file contents) contains an `e` character. Either way, it looks like line noise to me and does nothing to convey a sense of what the code is doing. Just my $0.02, of course. :-)
&gt;Yes, I agree that the adverbial form is better when it's being used as a postfix modifier on a previous statement. This is why it is called "adverbial" :). It modifies the meaning of another "verb" (operators here), just like in natural language. The smart match checks if the file **e**xists. I thinks this conveys no sense to you because you're not used to it: `..` doesn't convey any sense to people who have never seen it.
&gt; It modifies the meaning of another "verb" (operators here), just like in natural language. Yes, it makes sense there. But that's not the case when it's being used instead of a pair as it's not modifying anything. e.g. `foo(:bar&lt;baz&gt;)`. &gt; The smart match checks if the file exists. I thinks this conveys no sense to you because you're not used to it: .. Fair enough. I guess it's no more or less intuitive than `-e`. However, `$file.exists` is intuitive and obvious even to people who have never seen it. Writing `-e` or `~~ :e` is obfuscation in comparison. 
&gt; However, `$file.exists` is intuitive and obvious even to people who have never seen it. Bzzt! Fifteen yard penalty for the "Intuitive to the ignorant novice" fallacy!
I'm not talking about ignorant novices, but experienced Perl 5 programmers, Python programmers, PHP programmers, Ruby programmers, and all the other programmers that we're hoping will switch to Perl 6. If we don't attract enough of those people to Perl 6 then it doesn't matter how great the language is - it'll be dead. Not strictly dead as in "Nailed to the perch", but as good as dead as in "No you can't use Perl 6 for this project because none of our existing programmers [use|like|understand] it and we can't [find|afford to hire|tolerate] anyone who does". Somewhat like Lisp. 
&gt; Once upon a time, a man named Jon Orwant threw a mug against a wall and declared Perl to be stagnant, If memory serves it was actually four mugs, although only three of them smashed. The third bounced off the wall in a rather unsatisfactory manner. It was actually quite remarkable. One minute we were sitting there talking about some *very* trivial details relating to the next minor Perl release. The next minute mugs were being smashed. A minute after that later Larry had decided that we were going to completely redesign and rewrite Perl from the ground up. Who'd have thought that a few china mugs could have changed the course of Perl history...
&gt; One minute we were sitting there talking about some *very* trivial details relating to the next minor Perl release. Plus Ã§a change....
&gt; I'm not talking about ignorant novices.... You missed the implicit "Perl 6" between "ignorant" and "novice". You can look up the meaning of `:e`. You can only look up the meaning of `.exists` if you know the class or role which provides `.exists` and if it provides sufficient documentation. It's easy to argue that `.exists` asks "Did something reify this item?" or "Is it a protoobject?" or "Is it defined?", not just "Does a file of this name or file descriptor exist in a currently accessible filesystem somehow?"
Well I suck at C, but I think of myself as a moderately competant perl hacker. Guess it's time to step up and try to do something useful for the community. Any of you have some sort of direction to give me? I'm cloning the githup repo as we speak but aside from going over the source I"m not sure where to start. A good C primer could be helpful as well ;)
I'd like to see a list of cleanup tasks posted somewhere; I've suggested the channel #corehackers on irc.perl.org as a first place to coordinate such activities.
&gt; You missed the implicit "Perl 6" between "ignorant" and "novice". I accept the basic premise of what you're saying. Any non-trivial language is going to have features that a newcomer to the language won't understand until they've educated themselves. A language that is simple enough for complete novices to understand is unlikely to be powerful enough to keep the experts happy. &gt; You can look up the meaning of :e... ...only if you happen to know that it's a file test operator and that they're documented in the `perlop` manpage (or the Perl 6 equivalent). In this particular example, you must also know that `~~` is the smart match operator and have read the documentation that describes how the smart match operator interacts with the file test operators ( I don't know the specifics of how this works, so I'm hand waving a little). Of course, anyone trying to read/write Perl 6 code should already know these things. My concern is that too few people will ever get as far as reading the "Introduction to Perl 6 Operators" because they'll take one look at the code and dismiss it as more of the same line noise that made Perl 5 code so hard to read, write and maintain. These are fallacies but that doesn't change the fact that we'll be losing "customers" because of it. &gt; You can only look up the meaning of .exists if you know the class or role which provides .exists... If you're reading or writing the code and you don't know already what kind of object you're dealing with in `$file` then you've got bigger problems :-). But once you know that it's a `File` object (or something that does file-like roles) then finding the documentation should be easy. &gt; ...and if it provides sufficient documentation. That's a non sequitur as the quality of the documentation is orthogonal to the design of the language. My point is that your average programming won't have to look up what `.exists` means because it's spelled out for them in English. &gt; It's easy to argue that .exists asks [other stuff] Well yes, even a word like `exists` is ambiguous. But much less so than `e` which could denote any of the english words beginning with `e` (or having `e` anywhere in the word if you consider the case of `x`/`executable`). That said, it would be easy to define `:exists` (perhaps with the Perl 6 equivalent of `use English`) which would certainly make things less ambiguous. $file ~~ :exists # much better But I'm getting sidetracked. My original point wasn't really about the `:e` operator (or more accurately the `~~` smart match operator's ability to test a file property). And as I said in my earlier reply to Zulon, the use of `:property` in the adverbial context is one that I'm in favour of. What I don't like is the `:key('value')` syntax. I find it aesthetically inferior to both `key =&gt; 'value'` and `key: 'value'` and I think it reduces the accessibility of the language to anyone who isn't already in the Perl 6 Club. Please don't misunderstand my intentions. I'm a big fan of both Perl 5 and 6, and I care deeply about their continued/forthcoming success (both emotionally and financially). I just think that we should be mindful of Perl's accessibility to newcomers, or lack of it. If a seasoned Perl 5 programmer like myself finds much of Perl 6 cryptic and confusing at first glance then how bad is it going to be for someone coming from outside the clique? Repeating the old Perl 5 battle cry of "RTFM, Noob!" isn't going to win us any new friends here. The Perl 5 demographic is already ~10 years older than those for languages like Python and Ruby and I think we desperately need to attract more new programmers to the language(s) if we want to keep them alive. Otherwise Perl will be going the way of COBOL.
I'm intimately familiar with Perl and a moderately competent C hacker. But I get utterly lost in the mess that is Perl internals. Receiving a bug report for Template::Stash::XS sends shivers down my spine (anyone who understands how to make [utf8 work in XS](http://rt.cpan.org/Public/Bug/Display.html?id=45842) and has some time to spare, please get in touch - I'm drawing blanks). My only contributions to the Perl core in 15 years have been documentation patches and perhaps a few minor tweaks to core Perl modules. It's not from lack of motivation, but the learning curve is just too steep for us mere mortals. :-( In contrast, I downloaded Ruby back in the early days (around '98 or '99 I guess) and had a look inside at the source code. Within an hour I had found an item on the TODO list (one of the minor Array methods, ISTR), implemented it, and sent a patch off to Matz. As it happens, someone else had beaten me to it. But that doesn't change the fact that I was contributing to the Ruby core within an hour of being exposed to the language for the first time ever. I can't vouch for the fact that the Ruby core is still as accessible to the newcomer, but it was back then. 
Sounds interesting. If only I had the time and energy...
Interesting. I have contributed (or tried to contribute) trivial patches to a number of large open source projects, and of all of them, Perl was by far the biggest pain in the ass. Linux and *BSD may be worse (I haven't tried), but getting something into Perl is a huge uphill battle against inertia and petty hostility. This is probably good for the language's stability and reliability, but not so much for attracting contributors. That said, the "corehackers" approach of bypassing the p5p cabal and presenting a finished patch is probably the best approach. An ambush, sort of.
Worked for me (and apparently perlbuzz); here's the link I used: [Perl 6 - The quest for the holy grail](http://daniel.ruoso.com/categoria/perl/perl6-fisl10).
I don't know what to tell you. Perhaps the link to his slides will work [Perl 6 - The quest for the holy grail PDF](http://wp.oktiva.com.br/danielruoso-en/files/2009/06/perl6-en.pdf).
&gt; a working link for a change wut?
It doesn't matter at all. Seriously, Perl 6 is far enough along that it's time to start moving Perl 5 to a deprecated status (perl people I mean, everyone else did long ago).
I ran into Perl 4 the other day. I *like* Perl 6, but even so I wouldn't suggest migrating existing projects written in Perl 5 to Perl 6 right now.
No no, sorry for not being clear. I don't mean to migrate anything. And, sadly, if you're a perl shop and have to make a new short term project perl 5 is still your best option. I just mean, at this point it's time to stop making big long term projects in perl 5. It's time to stop *promoting* it. Time to stop making big new cleanup projects. If it weren't for the point about short term new projects, I think this would fit the word "deprecate" pretty well.
Why would you do that? Perl5 isn't going anywhere. It's a language with a long future. Yes, I somewhat dislike perl 6 and still am postponing learning it, because I don't see as much bad stuff in Perl 5, as other people tend to. So, long live perl 5 :)
Seems like a really nice idea. But, I always wondered why the new stuff from these new modules (Devel::Declare, signatures stuff, and all these new black magick modules that hack the core) aren't in core yet. Yesterday, I created a new command in Tcl/Tk via C source code with three simple C functions. And I'am really not that quite good in C. It would be really cool if we could do it in Perl without modules without C (as we can do with D::Declare).
It isn't going anywhere? Of course it is. The next version of Perl is on it's way. It does everything perl 5 does, but has cleaner.... everything. There isn't any point what-so-ever to hold onto the old junk.
I don't understand a word of the confused gibberish you are spouting. Please stop.
Sorry if reality makes your head hurt. Go ahead and put it back in the sand.
The problem is basically that casual users want these advanced features, but serious users may not. For example, if you're an investment bank with billions of dollars churning through your system per day and even a small bug could cost millions of dollars, you might not be too keen on cutting edge features being added to your language of choice (and many financial institutions are heavily dependent on Perl). Thus, there are really two sorts of users for Perl and so far the maintainers of Perl (P5P as they're known) have not found a comfortable compromise.
It's still not generally clear that Canonical is profitable yet, even after all this time and incredible uptake of Ubuntu. Where they do make their money isn't in support or t-shirts, but in contracting out their expertise to build custom versions of the distro for hardware folks like Intel. If it weren't for Mark's personal wealth, Canonical would have been long dead, and most likely so would Ubuntu. Because of all this, I would hesitate to hold Canonical up as a model for the financial aspects of the Perl community.
Ironically, I moved Perl 6 to deprecation status some years ago, and haven't seen sufficient reason to un-deprecate it yet.
I moved perl* to deprecated status years ago as well, but some people actually like this stuff. Those people should at least do themselves the favor of not forking into "we still like the obsolete stuff" and "we like the still-ugly-but-more-manageable-stuff".
Why not install an executable called perl5i with this module, that would basically do `perl -Mperl5i $@` (sh)? That would be nice and not very hard, I think.
&gt; The problem is basically that casual users want these advanced features, but serious users may not. I disagree. To my knowledge, there's been neither survey nor discussion of what any users want out of Perl 5. A lot of people *think* users want this or users want that, but it's the DarkPAN problem all over again. Perl 5 continues merrily in the direction it set out years and years ago precisely because no one has bothered to ask if it's the right direction or volunteered to figure out if another approach would help. &gt; ... you might not be too keen on cutting edge features being added to your language of choice... If you don't like smut on your telly, change the channel.
I think Darian Patrick was working on that. I know I saw it in a branch on GitHub.
Okay, thanks.
Said financial institutions would not upgrade to a newer version of Perl without testing the hell out of their code beforehand. It's a made-up problem for made-up people. People just don't upgrade their version of Perl willy-nilly and expect 10 year old code to keep working. 
Huh. At first I thought this was going to be in /r/atheism
Remember the show of hands at YAPC::NA for people using Perl 5.6 or earlier? Chances are companies won't upgrade anyway because "it ain't broke, don't fix it" runs rampant at higher management. I prefer to call it "troubleshooting bugs fixed 5 years ago". I work in the DarkPAN and I say forget the DarkPAN. You're setting yourself up for an abusive relationship if you try to cater to an absent partner. What I'd rather see is progress so I have more things to throw out for why we SHOULD upgrade rather than saying "well, it doesn't do anything new... but it won't break anything!" That'll never fly.
:)
&gt; A system called direct threading stores all the opcode bodies together in a single large function... Each opcode has a label, and those are usually stored in a table somewhere. I thought that was the difference between direct- and indirect-threading. I.e. if the code presented was direct-threaded, it'd use something like "goto *pc++;"
I was hoping he continued to CLI option. His examples can be reduced to `perl -pe0` and `perl -pe '$i++; s/^/$i\t/'`. For further details, `perldoc perlop`.
If would be possible for everyone to be happy if perl could be compiled in a few different ways using Configure command-line parameters. So, if I want my Perl to be strict by default, I just compile it for eg. Configure -DUSE_STRICT, or Configure -DUSE_CLASS_KEYWORD for the kewl 'class' keyword instead of 'package', etc. I don't know if this can be implemented right now, but it would be a good bridge between new and old perl to start with.
That means more testing paths, more choices vendors can make, and more ways things can go wrong. I suspect that vendors and distributors will disable those new features, as that's easier than updating all dependencies to conform to modern Perl. The only people a Perl with smarter defaults hurts are the ones who 1) take advantage of misfeatures 2) upgrade blindly without testing their code 3) have no effective change management in place to minimize the risk of #2. If -- as I've suggested -- backwards compatibility mode is available through a `use feature`-like pragma, updating a program to run in Ancient, Crufty Perl mode is simple.
It's Perl (the programming language) or perl (the interpreter) but never PERL!
The OP was incorrect. Self (and presumably JS) don't have *class based* inheritance. Self (at least) *does* have inheritance and it's multiple. The object just has the ability to choose who it inherits from and change it at any time (called a "parent" slot). Personally I think the *biggest* problem with inheritance is some people's/language's insistence that only OO be used. OO itself is being forced into roles that something else would fit better (e.g. "pull in a class only to use 2 methods").
I'll be soooo glad when 5.10.1 is released. Chromatic writes these better.
100% agreed.