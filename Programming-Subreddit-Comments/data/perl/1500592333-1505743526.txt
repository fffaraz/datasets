Array elements must be scalars, you can't store a hash to an array. See [perldata](http://p3rl.org/perldata): &gt; Perl has three built-in data types: scalars, arrays of scalars, and associative arrays of scalars 
&gt; Virtual machines are expensive to start up doesn't perl5 also run its own vm? it's not java, but its the perl vm. 
Few things are probably true about this test: 1) the program probably won't be running long enough to get a good benchmark. To do that you'd need to wrap this in a loop that runs about 1000 times to get the JIT a chance to warm up. 2) This is not idiomatic Clojure at all. I write clojure for a living and I can't understand what this code is doing or what it's supposed to accomplish. 3) There's some pretty big inefficiencies in this code, mostly dealing with the way strings are being built and how the collections are being iterated. So in the end there's not much of any conclusion you can draw from this.
"Google engineer" - what the *fuck* does that even mean? Some piss poor half-wit programmer got a job with a company that expects him/her to slave away day and night for bugger all pay? We're supposed to worship people stupid enough to fall into *that* trap? Fuck off with the hero worship of a profiteering mega corporation.
Note that the JVM is optimized for long running processes and uses the JIT to optimize performance over time. If you're looking for quick running tasks, such as scripts, I recommend using ClojureScript with [Lumo](https://github.com/anmonteiro/lumo) or [Planck](https://github.com/mfikes/planck) instead.
if you're interested in a perl6 version of this, here's my more-or-less translation and timings for all three impls: #!/usr/bin/env perl6 sub huzza { "Tiplizz inet $^text!" } sub huzzatok { map &amp;huzza, @^names } my @files = sub { my $starttime = now; return dir("/usr/bin"); LEAVE note "reading dirs: elapsed: " ~ (now - $starttime) ~ " seconds" }(); my @sorted = sub { my $starttime = now; return huzzatok sort @files; LEAVE note "sorting and huzza-ing: elapsed: " ~ (now - $starttime) ~ " seconds" }(); sub { my $starttime = now; .say for @sorted ; LEAVE note "everything: elapsed: "~ (now - $starttime) ~ " seconds"}.(); (of course i would write it very differently myself, but i wanted it to resemble the original somewhat closely) perl5: "Elapsed time: 12.6399993896484 msecs" perl6: everything: elapsed: 0.05560485 seconds clojure: "Elapsed time: 113.171316 msecs" and time says: perl5: 0.02user 0.01system 0:00.07elapsed 52%CPU (0avgtext+0avgdata 7072maxresident)k perl6: 0.42user 0.03system 0:00.46elapsed 98%CPU (0avgtext+0avgdata 88944maxresident)k clojure: 9.86user 0.17system 0:03.24elapsed 309%CPU (0avgtext+0avgdata 164192maxresident)k if you're interested in "starting up reasonably quickly", you might find this interesting: $ time perl6 -e '' 0.08user 0.02system 0:00.11elapsed 98%CPU (0avgtext+0avgdata 63756maxresident)k Of course compared to perl5 which starts up and shuts down so fast that time can't even measure anything, it's still rather slow. But to me, it starts up fast enough for anything i might want to do. It's quite likely that I translated the program in some way that makes the comparison unfair, please feel free to point out specific problems
Don't downvote, folks. Answer the question instead.
wikipedia at least has an article "perl virtual machine": https://en.wikipedia.org/wiki/Perl_virtual_machine
For things like CGI scripts (frequent executions) start-up time is an *essential* metric. Though you're right that a long running program may well be faster in a JVM-compiled language - for the particular task set by the OP the fact is Perl 5 is faster. &gt; So in the end there's not much of any conclusion you can draw from this. If one wanted to discuss performance differences between Perl and Clojure then, I agree, this thread hardly begins to delve into the topic.
"proper cgi" should not have start up time besides calling a class/function. Almost everything has middleware nowadays (maybe except php) which loads up code and executes code already in memory.
note that a bare bone perl6 has the likes of Moose and some other modules at start up (since they are part of the language).
I agree, this does more harm than good. As a comment on the blog post mentioned http://perl-tutorial.org/ is a decent place to point newcomers. Another one is http://learn.perl.org/ though that's not a tutorial itself.
I've been writing web services for over a decade and a half, and I think it's been 10 years since I saw a CGI service. Everything runs on long running processes these days. Why pay the startup cost of any language on every invocation?
Those are some interesting timings. Thanks for doing them. But I can't handle these insane levels of parenthetical / symbolic density! &gt; (of course i would write it very differently myself, but i wanted it to resemble the original somewhat closely) First the code made my eyes bleed. Then this. Upvoted for extreme dry humor. I know this is pointless, but here goes nothing: sub huzza ($text) { "Tiplizz inet $text!" } sub huzzatok (@names) { map &amp;huzza, @names } my @files = sub { my $start-time = now ; return dir("/usr/bin") ; LEAVE report 'reading dirs', now - $start-time }.(); my @sorted = sub { my $start-time = now ; return huzzatok sort @files ; LEAVE report 'sorting and huzza-ing', now - $start-time }.(); sub { my $start-time = now ; .say for @sorted ; LEAVE report 'everything', now - $start-time }.(); sub report (\text, \time) { note text ~ ': elapsed: ' ~ time ~ ' seconds'; } That's blown it up from 5 lines to 25 lines but it's soooo much ~~prettier~~ less ugly. :)
Does one just replace the first line of the Clojure code to make it valid ClojureScript? Does anyone know of a free online eval service that supports both ClojureScript and Perl 5 (at minimum), and maybe P6 and Clojure too, so we can easily get vaguely comparable timings? How long did it take from someone beginning work on ClojureScript to it being popularly considered ready for serious use?
This does not look like Perl at all. Is this the new language called Rakudo? :)
Actually I didn't want to concentrate on the startup times that much, but I had to mention it. Please note that the Clojure program is run this way: clojure foo.clj So it includes compilation. I'll post times with running compiled classes later, that should drop the Clojure overhead I guess. And yes, I may try Lumo or Planck. But why is the JVM's IO so much slower than Perl? What are your suggestions to make the comparison of the CPU-intensive stuff more relevant? Sort and shuffle the list 1000 times?
&gt; Does one just replace the first line of the Clojure code to make it valid ClojureScript? Not quite. ClojureScript is not run directly, but instead transpiled into JavaScript. You can't access Java libraries from ClojureScript (obviously) and you can't access JS libraries or the DOM from Clojure (obviously), but otherwise they are basically the same language with just a few added complexities during compile time for ClojureScript.
I just checked, first two digits of the year on calendar are not 1 and 9. What's up with CGI?
No one uses traditional cgi seriously anymore. 
I've had to debug a few in the last 2 years that the client didn't want to replace. Usually they are non-public facing administrative utilities that workflow has relied on for a decade. 
You're only partly correct. What you wrote used to be accurate, but now you also have the aforementioned Lumo and Planck if you want to run ClojureScript directly, without the whole transpile phase. They're standalone tools that can run cljs directly, with no need for Java or Clojure to be installed. Planck's completely standalone, whereas Lumo requires node.js to be installed, but can also import and use node modules, and using either allows you to run cljs scripts via shebang just like you would Perl, Ruby, Python, or even Clojure. In fact, if you restrict yourself entirely to Clojure and avoid calling out to the host (JS or Java), it really is as simple as replacing the shebang and calling it a day. The caveat there is that Clojure (and thus Clojurescript as well) is made to interop with the host platform heavily, so the more complex your program, the more likely it is you'll have to resort to interop. (Though there is [a way to define functions so that they run different code depending on platform](https://clojure.org/guides/reader_conditionals), which means you can write mostly shared code with a few wrappers.)
put in another way, in perl6 you always have to pay the overhead of the likes of Moose and some other modules even if you do not need them (since they are part of the language).
&gt; But why is the JVM's IO so much slower than Perl? My initial guess would be lack of buffering and, to a lesser extent, Unicode.
I'm actually curious why your times are so much slower for the JVM as well, because I'm not seeing it at all. Just did it on my system and for Clojure, the read time was about 10ms, as was the sort time, compared to Perl's 7ms and 5ms, respectively. The bulk of the time was spent printing, but even that only took about 86ms with Clojure and 50ms with Perl. It's still slower than Perl, but not nearly as much as your test suggests. I realise that your system's slower, but it's strange that the JVM is affected so heavily. Can you actually give some specs on it? 32bit vs 64bit, how much RAM, what CPU it is, etc.? There may be something going on here that's specific to whatever hardware you're running.
i'd also have replaced `sub { ... }.()` with just `do { ... }`
Anecdotally, I've once struggled very much to beat perls performance in simple grep-like usecase using golang. Perl was faster. Point being - perl was designed and optimized for basic in operations for decades and i choose clojure not based on this criteria.
The Fitlet has a quad-core 64-bit AMD SoC. I've got 8 GB memory. http://www.fit-pc.com/web/products/fitlet/ Now I'm running a modified benchmark on a quad-core Xeon Linux VM with 16 GB memory. I've increased the load for the CPU-intensive part, it now shuffles and sorts the filenames 10000 times before applying `huzzatok` to it. [ms] Clojure Perl read dir 7.2 2.7 calculate 8913 1230 print 230 0.4 The JVM may be very good. But Perl seems to be even better. I hear there is a much faster `java.nio` package, but there seems to be no `clojure.java.nio`. BTW, I'm using Java 8 with the Clojure 1.8 libs.
See my other comment, I've blown up the CPU intensive part of the test case. It shuffles and sorts the list of filenames 10000 times. Perl is 7 times faster even here, which is not your typical grep-like use case. I'm actually quite in shock how fast Perl is. I didn't expect this.
Lack of buffering very likely. Redirecting STDOUT to a pipe accelerates Perl even further, as it goes from line-based to page-based buffering. And the JVM gets even slower... Weird.
In this particular case it's apparent that: - it's basically language bootstrap benchmark (and it's no secret Clojure starts slower than Perl, Python, Bash, TCL, etc.) - it's also a benchmark of JVM getting up to speed in a program that doesn't work long enough - the Clojure program doesn't look like Clojure. `def` is for defining, not from side effects. Clojure has rich sequence composition facilities. (threading macros, reducers, transducers).
As I mentioned I'm a Clojure noob. The real question is whether my (time (def files (seq (.list (clojure.java.io/file "/usr/bin"))))) evaluates reading the directory straight away or not. If not, the picture is even more grim for the JVM, as this measures the time of the JVM doing nothing. Which is slower than Perl reading a huge directory. I'm also very curious about how to write this in an idiomatic Clojury way. Also see my new comments about drastically increasing the load during the CPU-intensive part of the test case. Does shuffling and sorting a list of 3000 strings 10000 times warm up the JVM enough?
**Perl** ./test.pl "Elapsed time: 0.580072402954102 msecs" "Elapsed time: 0.665903091430664 msecs" ... "Elapsed time: 2.14815139770508 msecs" **Clojure** $ lein try criterium (use 'clojure.java.io) (use 'criterium.core) (defn huzza [x] (str "Tiplizz inet " x "!")) (defn huzzatok [files] (map huzza files)) (defn files [] (file-seq (file "/usr/bin"))) (defn sorted [files] (sort files)) ; mesure time for listing files (time (files)) "Elapsed time: 0.028759 msecs" ; Perl: Elapsed time: 0.580072402954102 msecs ; proper benching (bench (files)) Evaluation count : 819687780 in 60 samples of 13661463 calls. Execution time sample mean : 67,842536 ns Execution time mean : 67,918476 ns Execution time sample std-deviation : 8,779953 ns Execution time std-deviation : 9,051188 ns Execution time lower quantile : 61,149580 ns ( 2,5%) Execution time upper quantile : 88,830587 ns (97,5%) Overhead used : 11,127538 ns Found 5 outliers in 60 samples (8,3333 %) low-severe 2 (3,3333 %) low-mild 3 (5,0000 %) Variance from outliers : 80,6887 % Variance is severely inflated by outliers ; mesure time for huzzatok (let [files (files)] (time (huzzatok files))) "Elapsed time: 0.011635 msecs" ; Perl: "Elapsed time: 0.665903091430664 msecs" ; proper benching (let [files (files)] (bench (huzzatok files)) Evaluation count : 2331763560 in 60 samples of 38862726 calls. Execution time sample mean : 14,537588 ns Execution time mean : 14,535645 ns Execution time sample std-deviation : 0,317784 ns Execution time std-deviation : 0,323563 ns Execution time lower quantile : 14,041995 ns ( 2,5%) Execution time upper quantile : 15,238831 ns (97,5%) Overhead used : 11,127538 ns Found 2 outliers in 60 samples (3,3333 %) low-severe 2 (3,3333 %) Variance from outliers : 10,9513 % Variance is moderately inflated by outliers ; mesure time for sorting files (let [files (huzzatok (files))] (time (sorted files))) "Elapsed time: 7.268705 msecs" ; Perl: "Elapsed time: 2.14815139770508 msecs" ; proper benching (let [files (huzzatok (files))] (bench (sorted files))) Evaluation count : 392400 in 60 samples of 6540 calls. Execution time sample mean : 154,782727 µs Execution time mean : 154,854255 µs Execution time sample std-deviation : 6,559350 µs Execution time std-deviation : 6,763116 µs Execution time lower quantile : 147,969123 µs ( 2,5%) Execution time upper quantile : 171,054432 µs (97,5%) Overhead used : 11,127538 ns Found 6 outliers in 60 samples (10,0000 %) low-severe 4 (6,6667 %) low-mild 2 (3,3333 %) Variance from outliers : 30,2976 % Variance is moderately inflated by outliers **ClojureScript** Didn't had time to play and search for a nodejs module to iterate over files in a directory, I'm using *planck.shell* to run *ls*. I doubt that with a proper nodejs module it would be slower than perl or clojure. $ cat foo.cljs (ns foo (:require [planck.io :as io] [planck.shell :as shell])) (defn huzza [x] (str "Tiplizz inet " x "!")) (defn huzzatok [files] (map huzza files)) (defn files [] (clojure.string/split-lines (:out (shell/sh "ls" "/usr/bin")))) (defn sorted [files] (sort files)) (time (files)) (let [files (files)] (time (huzzatok files))) (let [files (huzzatok (files))] (time (sorted files))) $ ./foo.cljs "Elapsed time: 16.112440 msecs" "Elapsed time: 0.348504 msecs" "Elapsed time: 7.972669 msecs"
See my [response](https://www.reddit.com/r/perl/comments/6ojrau/perl_vs_clojure/dkirf0i/) in the thread. It would be: (def files (file-seq (file "/usr/bin"))) You're measuring compilation + virtual machine startup time, and the JIT doesn't have time to kick-in. This is not how we usually benchmark JVM code, it needs proper benchmark tooling. In my response I used criterium, you'll see that the time are drastically lower. If you need to have fast startup time, you need to use ClojureScript with Plank or Lumo as said by yoghtos.
With the sorts of request load that would make any of this discussion vaguely relevant? Or is it one person in a back office doing one request a day hanging on POST for ten minutes?
 $ time perl -MMoose -E '' real 0m0.222s user 0m0.192s sys 0m0.020s $ time perl6 -e '' real 0m0.228s user 0m0.173s sys 0m0.029s 
I would say this is the a JavaScript programmer who has read his first Perl book. 
That's cool, did not realise ClojureScript had come that far.
I thought this would let me switch between Strawberry and ActivePerl, but it doesn't. Is there anything like that?
It's not true, see [perlnumber](http://perldoc.perl.org/perlnumber.html#Storing-numbers) for reference. Probably you're confused because perl upgrades integers to floats on overflows.
Yeah, but then `return` is disallowed, so then I removed the `return` keyword... but then the returned expression wasn't the last line in the block so `Nil` was returned instead... so then I tried `leave`, but that was NYI... so then I moved the `LEAVE` line up top, but of course then `$start-time` wasn't defined in time... so then I tried `LEAVE report 'everything', now - ENTER now` but that seemed to confuse the code generator... so then I considered putting the `LEAVE report 'everything', now - $start-time` as the *middle* line of the code, and then I decided that what you had written was just awesome and I should just throw my nonsense away... and then I looked again at the clojure and perl code in this thread and decided I should post anyway to try and staunch the eye bleeding at least a *little*. :) But yeah, posting what you did was (ETA: *more than*) 1,000x more useful than posting what I did. Which, perhaps, isn't saying much... ;)
Much closer. BTW, which Perl6 VM are you using?
This isn't really a great benchmark. You have a lot of inefficiencies in your code, and you're only taking a single measurement. To give you an idea of the difference this can make, let's take the intermediate "sort then map" benchmark you have: Test | Time on my machine ---------|---------- Original | 32ms Idiomatic sort and map | 2.9ms Idiomatic with Criterium | 0.21ms Optimised with Criterium | 0.11ms (Criterium is a benchmarking tool for Clojure that warms up the JVM and times the code many times in order to get an accurate average.)
 timo@schmand ~&gt; time perl -MMoose -e '' 0.14user 0.00system 0:00.15elapsed 98%CPU (0avgtext+0avgdata 20328maxresident)k 0inputs+0outputs (0major+4004minor)pagefaults 0swaps timo@schmand ~&gt; time perl6 -e '' 0.08user 0.01system 0:00.10elapsed 102%CPU (0avgtext+0avgdata 65260maxresident)k 0inputs+0outputs (0major+11511minor)pagefaults 0swaps not sure what the difference between our systems is, but on my machine perl6 starts up faster than perl5.
99% sure it's MoarVM
well, if we were to throw out time reporting and write it in idiomatic perl6 code it'd just be say "Tiplizz inet $_!" for sort dir("/usr/bin") but it'd be similarly short in clojure and perl5 i'm sure. Except now the perl6 code is another 0.1s faster :)
Thank you. :) Are any clojurists reading this? What would the idiomatic cljs equivalent be? It's great to know the P6 language design addressed issues relevant for million+ SLOC codebases but I think *extremely easy to read* **one-liners** and their ilk are a critically important use case. .oO ( King of Unicode, Queen of Concurrency, Jack of All Trades .... Ace of one-liners.)
Probably the most interesting result I've gotten so far: $c8lH6'Pet&gt;12;$9 Deparses as: $c8lH6::Pet &gt; 12; $9;
If we are talking archaic services that clients don't want to replace, then seems even more out of touch for being re-written in somthing like clojure
It's not true; SVs can hold IVs (integers) or NVs (floats). The rules for promoting IVs to NVs aren't always obvious in user space, but they exist.
I simplified my Clojure functions according to your recommendations. But however hard I try `(file-seq (file dir))` does not seem to produce a list of strings of filenames in `dir`. `(seq (.list (file dir)))` does. But it takes 166 ms, as opposed to Perl's 9.5 ms.
Thanks.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/clojure] [Perl vs Clojure - Reloaded](https://np.reddit.com/r/Clojure/comments/6or9n4/perl_vs_clojure_reloaded/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
You aren't actually timing anything when you write `(time (map f xs))`, because `map` is lazy. It returns almost instantly, regardless of the size of xs or how long f takes to run, without actually calling f at all.
How do you force evaluation then?
Clojure is just so much more readable.
&gt; (def files (file-seq (file "/usr/bin"))) That may be idiomatic but it's also producing incorrect results, at least for me. I noticed it taking *far longer* to do its job, so I counted the entries: user=&gt; (count (file-seq (clojure.java.io/file "/usr/bin"))) 229109 user=&gt; (count (seq (.list (clojure.java.io/file "/usr/bin")))) 5585 What seems to be happening is `file-seq` is getting hung up on `/usr/bin/X11` because my Debian install has it symlinked to `/usr/bin/`, causing `file-seq` to keep running until it hits the filesystem recursion limit, whereas the `list` method doesn't because it's only reading the given directory. Here's a a semi-randomly chosen file from the `file-seq` list for an example: user=&gt; (str (nth (file-seq (clojure.java.io/file "/usr/bin")) 70000)) "/usr/bin/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/X11/patchelf" Even ignoring the recursion issue, using `file-seq` probably isn't the right choice if you *don't* want to walk the directory structure. `(seq (.list (clojure.java.io/file "/usr/bin")))` is probably the cleanest option that still does what's wanted here. 
&gt; The real question is whether my [...] evaluates reading the directory straight away or not. It's not generating a lazy sequence, so yes, it's evaluating eagerly. If you really want, you can also force `file-seq` to evaluate by coercing it into a vector, such as by doing `(into [] (file-seq (clojure.java.io/file "/usr/bin")))`. I wouldn't do that on a directory that has a recursive symlink, though. (note my comment below this)
読みやすさは主観的です
Use `(doall (map f xs))` or use mapv instead, which is strict.
Yeah, that seems likely. It gets even worse if you use the Clojure REPL, because you normally use `rlwrap` to get line-editing features. When I initially ran your Clojure code, that's how I did it, and the output time for printing was absurdly high, at least 5x higher than running it as a script or invoking the REPL via `java -cp clojure-1.8.0.jar clojure.main` and giving up the rlwrap niceties. 
The Xeon number for the read dir looks about right for an SSD. Can't compare the calculate since you're doing something entirely different there. The print is really slow still, though. It's possible there's something else limiting it there, like how I mentioned elsewhere that I noticed `rlwrap` was adding significant overhead to my first tests. Something else I considered: are you clearing the filesystem cache between tests? e.g. `echo 3 &gt; /proc/sys/vm/drop_caches; sync`. I tested your read/sort functions on a non-SSD copy of /usr/bin and, when the filesystems are cached in RAM, I still get read times of ~10ms for Clojure and ~5ms for Perl. If I run one and then the other on that disk without clearing cache between, the one I run first is slower, but when I clear filesystem cache between runs, the non-SSD reads take a couple hundred ms for both. As for the fitlet, looks like it's single-channel RAM. Clojure, as I understand it, creates a lot of short-lived objects that get garbage-collected frequently. That means it relies heavily on the quality of the host language's GC, and presumably also is affected a lot by the system's memory speed. Your testing (including the disk read one) may primarily be showing the limits of your fitlet's single-channel memory. As for java.nio, you can interact with it directly, same way you used Java interop to call the `list` method in yours. That's really all the `clojure.java.io` functions do; they're wrappers that do the interop for you to make it a little nicer to use and read. One way of using nio (no idea if it's the best option, I haven't really used nio) would be like this: (-&gt;&gt; (new java.net.URI "file:///usr/bin/") java.nio.file.Paths/get java.nio.file.Files/newDirectoryStream seq) Not sure how much benefit there is to doing this vs. using the older java.io.File stuff, though. Also note that you could shorten the code some by using `import`s to move the `java.foo.bar` stuff out, but I chose to name everything explicitly so it's self-contained here. For the curious, though, you'd do `(import java.net.URI '[java.nio.file Paths Files])` and then just refer to `Paths/get`, `Files/newDirectoryStream`, etc. directly.
You're still not doing a very good benchmark. You need to use something like Criterium to properly test the performance of your code. JVM languages just don't run fast on the first pass.
For perl, I would use Sort::Key and Array::Shuffle for better performance. And do the clojure functions operate in-place or return copies?
Clojure is immutable, so nothing ever happens in place. Though, it doesn't return "copies" either, as they use persistent data structures. It's a very interesting topic, but would take awhile to explain here, so I'd suggest reading up on it.
Yes, but now `map` is a negligible part of the 3rd test case. On second thoughts, using the lazy `map` makes the next text case, printing, slower. And indeed, `mapv` drops the time of printing by about 50ms. Thanks!
Not for me... perl -ne '$x+=s/spam//ig;print"\r$x"' &lt;(curl http://www.montypython.net/scripts/spam.php 2&gt;/dev/null | html2text)
No, it's very simple I guess. Imagine a list, implemented by a singly linked list. You insert a new element at the head. (def foo (list 1 2 3)) ; (1 2 3) (def bar (conj foo 0)) ; (0 1 2 3) Behind `foo` there is a pointer to the first element `1`. When inserting `0`, you allocate memory for a new element, storing `0` and link it to the original first element. Now `bar` is actually a pointer to this. But there was absolutely no change in the original 3 elements. The object store powering Git works exactly the same way. Nothing ever is changed there, just new objects are added. That's why fetch/push is so fast, they just copy a few new objects.
BTW, it's was a bit painful to discover that Clojure does not flatten tail-recursion automatically. The resulting `loop` `recur` stuff is not really easy to understand. Especially when you read their official docs, it's like WAT?! :) If Scala can do it, why can't Clojure?
I mentioned it in the other thread, but it's worth mentioning here as well: those read dir times look like you're running your test first with Clojure, then running the Perl one after, so that the filesystem has the directory information cached in RAM for faster access. If I do the read part of the tests on a non-SSD disk, whichever one I run first *usually* takes 100-200ms, and the one I run second takes 4-8ms. If I drop the caches and reverse the order, the numbers stay about the same, except it makes the *other* language look slow at reading. You need to be dropping your caches between tests with `echo 3 &gt; /proc/sys/vm/drop_caches;sync` as root if you want anything remotely comparable here, and even then the results can vary wildly depending on other factors. Doing it against an SSD after a cache drop is more consistent, but still varies a bit depending on circumstances. Taking that into consideration, Perl *does* still seem to come out slightly faster if I let both take advantage of filesystem caching, but the difference is tiny — 4-7ms range for Perl vs 7-11ms for Clojure — and dwarfed by the difference in FS cache vs SSD vs traditional disk. Output is a different matter entirely. Although I don't see as drastic a variation as you do, it's *definitely* noticeably slower to output, and it's something I've noticed before. Replacing `println` with `#(.println System/out %)` to use Java's print directly doesn't improve the time noticeably (if at all), so it looks like Clojure's not doing anything wrong here. No idea how to improve the situation, though. Maybe change `*out*` to a different writer? 
Instead of another rehash of this topic, you can read it from the man himself here: https://groups.google.com/d/msg/clojure/4bSdsbperNE/tXdcmbiv4g0J Also worth a read: https://gist.github.com/reborg/dc8b0c96c397a56668905e2767fd697f
Depends on what you want, but there's a bunch of options. In addition to /u/CinnamonHeart's mention of `doall` and `mapv`, you've also got `filterv`, coercion via `(vec my-lazy-seq)`, `(into [] my-lazy-seq)`, `run!`, `dorun`, `doall`, `doseq`, maybe others. You usually avoid forcing evaluation until you absolutely need it, then you use whichever method fits best with what you're doing when you need it.
&gt; It's a very interesting topic, but would take awhile to explain here, so I'd suggest reading up on it. For anyone interested, [this post](http://hypirion.com/musings/understanding-persistent-vector-pt-1) ([part 2 here](http://hypirion.com/musings/understanding-persistent-vector-pt-2)) is a pretty good explanation. The TL;DR is Clojure uses a shallow [tries](https://en.wikipedia.org/wiki/Trie) with 32 children per node to get immutable structures with good perfromance.
&gt; The resulting loop recur stuff is not really easy to understand Functions have implicit `loop` points for `recur` to jump to, so there's usually no reason to put `loop` at the top of a function definition like you did. You're already using a multiple-arity function definition, so it makes more sense to `recur` to that. Actually, I'm a little confused by what you did and how it works at all. You've got a `loop` of six arguments and you're calling `recur` with three, and...what. Why not do this instead? (defn shufsort ([n xs] (shufsort n xs 0)) ([n xs i] (if (= i n) xs (recur n (sort (shuffle xs)) (inc i))))) You don't seem to need it here, but if you needed a second list (say, to build it up as you tear down the first) you could add a another `xs` to the second arg list and pass it an empty vector `[]` when called with two arguments (e.g. `(foo 100 xs)` would translate to `(foo 100 xs 0 [])`)
You're right.
As a perl old-timer that picked up Clojure much later, I actually agree, but it took me a bit to get to that point. Perl sort of tricked me into getting about halfway to functional programming without realising it, but there was still a hell of a learning curve to get the rest of the way there.
The thing that confuses me is that it still seemed to work despite that. It looks like Clojure was ignoring the extra `loop` and doing what you meant to do despite it, but I'm not certain, and if so I'm a bit surprised that it did that instead of complaining about the loop/recur mismatch. lol 
I'm running this one after the other many times, so `/usr/bin` is always in the dir cache. And it's an SSD. Clearing directory caches is not something anybody does in the real world. And my results are quite consistent anyway. You must have a much faster CPU than I, so on input you mainly notice the time for SSD IO. But my slow CPU highlights the vast difference between Perl and Clojure. Or is that rather the GNU C library vs the JVM?
I think `loop` binds the input parameters to local ones, hence the 6 symbols, the three originals and the three locals. I was working with thee local `ii` `nn` and `xss` inside. That's why it worked. But it was unnecessary.
&gt; Clearing directory caches is not something anybody does in the real world. No, but they also don't run the same thing dozens of times in a row to time it, and I'd argue that reading fresh, without cached data, is closer to real-world usage. &gt; I'm running this one after the other many times, so /usr/bin is always in the dir cache. And it's an SSD. &gt; You must have a much faster CPU than I, so on input you mainly notice the time for SSD IO. But my slow CPU highlights the vast difference between Perl and Clojure. Or is that rather the GNU C library vs the JVM? Oh wow, I figured it was a normal disk with the times posted. That delay is ridiculous for an SSD, and I have no idea why. I don't think it's as simple as "slow CPU" either, because I forced my CPU to minimum frequency (1.5ghz) by turning off frequency stepping and then ran Clojure on a single core (`taskset -c 1 java -cp clojure-1.8.0.jar clojure.main`), and it's *still* nowhere near the times you've posted for reading. Single core @ 1.5ghz and it still completed in under 30ms for the SSD and about 300ms for the non-SSD. (Perl did did the SSD test in ~10ms in this scenario, didn't try non-SSD) Might be related to memory speed, or maybe there's some other factor with the CPU that's affecting it. No clue, but it's *weird*.
Whatever I do, `Sort::Key` makes it slower. And `Array::Shuffle` is not packaged for my Ubuntu, and this combined with my strong resistance to exotic dependencies, erm... Nope.
My CPU is *very* slow. Slower than my 7 year old Core 2 Duo laptop.
It's likely that Perl's I/O performance when accessing the local filesystem exceeds that of the JVM (though on my machine, only by a small percentage). If we're primarily measuring how quickly files can be read, my guess is that Perl is going to come out on top in most cases. Regarding the code itself, it bears repeating that you're going to get different performance results depending on whether the JIT is warmed up: | function | using `time` | using `quick-bench` | -----|-----|---- | sort | 3.60ms | 9.93µs | | shuffle-sort | 497ms | 333ms Notice that the time for shuffle-sort doesn't change by much; the act of iterating 1000 times warms up the JIT. However, the time for a plain sort takes over **300** times longer when tested using `time` instead of Criterium's `quick-bench`. Incidentally, you can write your `shufsort` function a little more concisely in Clojure: (defn shufsort [n xs] (if (zero? n) xs (recur (dec n) (sort (shuffle xs))))) Notice we can do without an index and explicitly loop if we just count down from `n`.
All those ( and ) make my rsi ache just looking at it.
380 times? That's what I call warming up! :D And thanks for the free Clojure classes!
Scala can't do it. It fakes it by detecting self-recursive calls and turning those into a goto, or perhaps via some sort of (ugly) trampoline. What you see in Scala is all smoke and mirrors. Scala doesn't have true, not transforming, mutual tail recursion, because it's impossible on the JVM. So Clojure simply takes tail recursion and makes it explicit, adding to code clarity. 
Can you be so kind to post your code for the idiomatic and optimised version?
I think Mojolicious has a module for it.
I'm trying to follow along.^1 &gt; Actually, I'm a little confused by what you did and how it works at all. You've got a loop of six arguments and you're calling recur with three, and...what. I'm more than a little confused because A) I've never focused on Clojure and B) while I know subogero says "you're right" and I can see they changed their OP I can't tell if they changed the code in question. Ah, mutability! :) But maybe it's better this way so I and other readers can gain deeper understanding thru dialog (me using my general Lispish and Perlish knowledge^1 and you and/or others explaining Clojure)? &gt; Functions have implicit `loop` points for `recur` to jump to Does `recur` look back up the (notional or real) run time stack of lists for the nearest one that has a matching number of (space separated) atoms, and then recursively call that function / list? If that's about right, which list in your "instead?" code does the `recur` call back into? &gt; You're already using a multiple-arity function definition Does that mean a definition of a single function with a fixed arity of two or more, a single function with variable arity, or multiple functions each with a different fixed arity, or something else? &gt; the second arg list Does that mean the second indented list (i.e. `([n xs i] (if (= i n) xs (recur n (sort (shuffle xs)) (inc i)))))`, the second list (`([n xs] (shufsort n xs 0))`), or another one? &gt; and pass it an empty vector `[]` when called with two arguments (e.g. `(foo 100 xs)` would translate to `(foo 100 xs 0 [])`) Perhaps a response to my questions above will make this obvious to me. Here's hoping. :) ^1 For context I used a Lisp (Metacomco) during the 80s; Perls (up thru Perl 5) thru the 90s; and have for years been trying to wrap my head around P6, a relatively new language in the Perl family (somewhat like Clojure is a member of the Lisp family) first officially shipped in 2015. Perls have always tried to steal from lisps, eg. CLOS has long been *very* influential, but instead of being m-expressions, as I imagine Clojure to be, P6 is Perlish.
Idiomatic was just to do away with the extra fluff in `huzzatok` to get: (doall (map huzza (sort files))) Optimised was to fall back on Java's array handling methods: (let [n (alength files) fs (java.util.Arrays/copyOf files n)] (java.util.Arrays/sort fs) (dotimes [i n] (aset fs i (huzza (aget fs i)))) fs) In both cases `files` is an array of strings. If you want to squeeze out the last drops of performance from Clojure, you can frequently drop down to working with arrays or primatives, but most of the time it's not worth it, and when it is, it's best applied selectively.
Thanks!
There are some things you can understand intuitively about the performance characteristics of each language: * Perl will be faster for shorter programs, because it starts up very quickly * Clojure may be faster for long-running operations, because the JVM will JIT-compile the code (and perl 5 is never JIT-compiled into native code) * An already-running Clojure application running a routine which has been called thousands of times before will be much faster than the same clojure application having just been launched. Given that, what's actually being benchmarked in these tests, and are there tests where the above differences are accounted for and both languages are playing to their strengths?
&gt; I'm more than a little confused because A) I've never focused on Clojure and B) while I know subogero says "you're right" and I can see they changed their OP I can't tell if they changed the code in question. Ah, mutability! :) In this case, the OP hasn't been edited, so you can (presently, at least) see the same thing I was referring to. There's a `(loop [ii i nn n xss xs] ...)` that's entirely superfluous, and what surprised me was that the `recur` (which jumps back to a loop, either explicit or implicit) didn't give an error due to arity mismatch. &gt; Does recur look back up the (notional or real) run time stack of lists for the nearest one that has a matching number of (space separated) atoms, and then recursively call that function / list? If that's about right, which list in your "instead?" code does the recur call back into? `loop` and `recur` is something of a kludge to work around the JVM not being able to do proper tail call elimination. `recur` rebinds the bindings of a previous recursion point and then jumps back to it, giving you a way to do avoid stack overflows for certain types of recursion, without violating the rules of the JVM in the process. You can explicitly name a recursion point with `loop`, and it jumps back to then, but usually you don't need to, because function definitions act as implicit recursion points. For example, here's a pointless, trivial bit of self-recursion: (defn countdown [n] (if (= n 0) (println "Done") (do (println n) (countdown (dec n))))) Works fine for smaller numbers, but if you try something too high, such as `(countdown 99999)` the JVM will belch a `StackOverflowError` at you. That's where recur comes into play: (defn countdown [n] (if (= n 0) (println "Done") (do (println n) (recur (dec n))))) Since the code was already tail-recursive, the logic stays the same, you just have to replace the function call with `recur`. Now your countdown doesn't blow through the stack. This is basically how the OP was using `recur`, but added an explicit `loop` in the function unnecessarily. You usually want to jump back to the function instead of creating a separate recursion point, because it's more concise, clearer to read, and also matches how tail recursion is used in Scheme so it's more generally understandable. There are cases you might prefer a `loop`, though. Maybe you set up a bunch of `let` bindings and want to jump back to the point *after* they're bound, for example. (Though in that case perhaps using a closure would be more readable?) It's also possible that the explicit loop/recur feels more comfortable to some, though I personally favour the more Scheme-like look of `recur`ing back to functions. &gt; Does that mean a definition of a single function with a fixed arity of two or more, a single function with variable arity, or multiple functions each with a different fixed arity, or something else? Something else: a function that executes different code based on the number of arguments it's given. Normally, a function is defined like so: `(defn foo [n] (println "foo"))`. It can accept a single argument, which is bound to `n`, and will give an `ArityException` error if you attempt to past any other number of arguments. Clojure allows defining functions that accept multiple arities, however: (defn foo ([n] (println "foo")) ([n i] (println "bar"))) Now it accepts one or two arguments only, no more and no less. This can be a nice way (one of several) to set up sane defaults for missing arguments, and also a clean way to provide a friendly "user facing" function call that does some setup and then calls itself again with a different number of arguments. You see *that* in my `shufsort` above: the user-facing (so to speak) `shufsort` is the two argument form, which then calls the three-argument form with 0 as the last argument. Clojure also allows variadic functions, for cases where you don't want to be as strict about the arities you accept. `(defn foo [&amp; args] (println "foo"))` accepts any number of arguments, including none, and puts them all in a list named `args`. This can also be combined with required arguments, e.g. `(defn foo [n &amp; args] ...) would accept one or more arguments, but not zero. &gt; Does that mean the second indented list (i.e. ([n xs i] (if (= i n) xs (recur n (sort (shuffle xs)) (inc i))))), the second list (([n xs] (shufsort n xs 0))), or another one? I was talking about how to set up recursion in similar, hypothetical situations where you build a new list as you simultaneously shrink a given one. I mentioned it because the OP's `loop` had bindings set up for two lists, which was possibly an indication that he was at some point considering creating a new list by manipulating the one passed to the function. For a simple example of what I was talking about, a naive implementation of `take`: (defn take' ([i l] (take' i l [])) ([i l n] (if (or (= i 0) (empty? l)) n (recur (dec i) (rest l) (conj n (first l)))))) (take' 3 [1 2 3 4 5 6]) ;; =&gt; [1 2 3] You pass it two arguments (a number and a collection of of some kind), and it returns a new, shorter list, by recursively shrinking the original and adding to the new, originally empty one. &gt; For context I used a Lisp (Metacomco) during the 80s; Perls (up thru Perl 5) thru the 90s; and have for years been trying to wrap my head around P6 I picked up Perl in the mid '90s and its flexibility ruined most languages for me. Never got along well with OOP, and everything I tried seemed so rigid in comparison to Perl. Eventually got the itch to check out functional programming languages and realised that's where Perl had been leading me, I just didn't know it until then. Haven't spent any time with Perl6 yet. Seems interesting but have lacked the motivation so far.
Exactly. You should use criterium for proper benching, not (time). As shown in [your previous post](https://www.reddit.com/r/perl/comments/6ojrau/perl_vs_clojure/dkirf0i/).
&gt; [explanation that recur explicitly marks recursion of some (loop) or all (no loop) of a function body] Thank you for the clear explanations. :) &gt; [explanation that Clojure supports arity based function overloading] Again, thank you! Simple enough. (On the one hand, I imagine all Lisps support this, and, on the other, I don't recall ever using that feature. I didn't write a *lot* of lisp but it feels odd that I don't recall this at all.) I don't recall using `[ ... ]` syntax in my lisp either. I'd noticed before that Clojure was using them and assumed they're a Clojure thing. I see they're used here for a list of args. Would ordinary parens work too? The end result looks pretty sweet to me. Listing the various arity definitions one after the other is natural. And then, building on that, redispatching with additional arguments is a breezy read, especially if the various arity'd definitions are listed from lowest to highest (I presume that's just a universal convention rather than strictly enforced?). &gt; [explanation about variable arity / rest args] This brings back memories of reading about &amp; rest or &amp;rest syntax in CL but I don't recall Metacomco Lisp having them but again, surely it would have had something like them? Wow, those synaptic connections seem to be just totally gone. Use it or lose it I guess. &gt; I picked up Perl in the mid '90s and its flexibility ruined most languages for me. Yeah. Oddly that happened to me despite encountering Perl *after* getting a bit into lisp and thinking CL was the bees knees. &gt; Never got along well with OOP Maybe that was Perl's fault? :) I remember reading the 1985 Byte magazine issue dedicated to Smalltalk cover to cover and being blown away. (I also remember thinking CLOS seemed awesome around the same time or maybe a few years later.) &gt; Eventually got the itch to check out functional programming languages and realised that's where Perl had been leading me, I just didn't know it until then. :) &gt; Haven't spent any time with Perl6 yet. Seems interesting but have lacked the motivation so far. Sure. If your current tools are doing what you need, why bother? Some folk pushed P5 quite a long way in FP directions. (Did you ever read MJD's HOP?) P6 has pushed that a bit further again. But P6 also bought the CLOS vision. And its metaprogramming is OO. So, even if you weren't happy with Clojure, it sounds like P6 would not be an attractive option for you to choose as a general purpose language. That said, P6 is actually designed as several interwoven sub-languages that call into each other. One of these sub-languages is a new parsing "Rules" sub-language. If you ever want a specialized parsing tool with nice declarative grammars that support parsing of any class of grammar, consider P6. I recently wrote [an answer to an SO question: "Extracting from .bib file"](https://stackoverflow.com/a/45181464/1077672) demonstrating what this looks like in P6. It doesn't show the turing complete aspects that mean one can parse literally anything using a nice predominantly declarative grammar. But it can. And one day it might actually be fast enough that P6 Rules, and the NQP engine that implements them, might do for P6 and other langs what regexes did for P5 and PCRE did for other langs. Ya never know. Thanks again for your excellent explanations.
&gt; I don't recall using [ ... ] syntax in my lisp either. I'd noticed before that Clojure was using them and assumed they're a Clojure thing. You're correct that it's a Clojure-specific thing. In addition to the ubiquitous lists in parens, Clojure has reader literals for other complex data types, such as `[ 1 2 3]` for vectors (arrays), `{1 2 3}` for sets, `#{:key value, :key2 value2}` for hash maps (associative arrays), and even a regex literal (`#" "`). You can still create them all in a more traditional Lisp fashion, e.g. `[1 2 3]` is equivalent to `(vector 1 2 3)`, but it's usually clearer to use the literals when possible. &gt; I see they're used here for a list of args. Would ordinary parens work too? No, they would not. As a side note, that *is* how Racket (a Scheme dialect/superset) works; in Racket `( )`, `[ ]`, and `{ }` are interchangeable as long as you pair them correctly, allowing you to (optionally) get similar readability as Clojure, though you still have to quote the forms like you would with `'(1 2 3)` That said, back to Clojure: in many places, such as function definitions and `let` bindings, Clojure expects vector literals. The general rule is that if the first entry of a list isn't a form to be evaluated (e.g. the body of a function definition), then Clojure probably wants a vector, which doesn't treat the first element any differently than the rest. This is a good convention when writing your own Clojure code as well, so you tend to use `[ ]` in places you'd use `(list foo bar baz)` or `'(foo bar baz)` in another lisp &gt; The end result looks pretty sweet to me. Listing the various arity definitions one after the other is natural. And then, building on that, redispatching with additional arguments is a breezy read, especially if the various arity'd definitions are listed from lowest to highest (I presume that's just a universal convention rather than strictly enforced?). Agreed, I tend to like the mingling of vectors, maps, and lists, and it makes reading Clojure (or Racket to some extent) more comfortable to me. As for arity dispatch, you're correct that the low-to-high is unenforced convention. You can sort it however you feel is clearest, but I've found I usually end up going in order of arities. Regardless of the order you use, I've noticed that dispatching on arity like that cuts down a lot of conditional code and branching, much like pattern matching does in the likes of Haskell, Ocaml (and other MLs), and Erlang. (Though if you like pattern matching, there's the [core.match](https://github.com/clojure/core.match) library; it's not as integrated but still useful sometimes) &gt; I don't recall Metacomco Lisp having them but again, surely it would have had something like them? Possible. Emacs lisp and Scheme do it as well, so it seems likely. I'm not too familiar with the ins and outs of CL, though; I've found I prefer the lisp-1 (shared namespace for variables and functions) side, where the Schemes and such live. Seems like the natural way to do it for any language where functions are first-class, whereas elisp and CL's separation feels like something of a historical quirk. Not that single vs. split namespace matters much in the end, I just happen to have a preference for one. Luckily for me, modern lisps tend to favour Scheme and the lisp-1 side. :) I've also noticed that some Clojure ideas are leaking into other ones, like the awesome [threading macros](https://clojure.org/guides/threading_macros), or [Urn](https://squiddev.github.io/urn/) (a lisp that compiles to standalone Lua) having `{ }` literal for tables, Lua's complex data type. &gt; Maybe that was Perl's fault? :) Most likely. Perl's bare-bones, build-it-yourself OOP was my first introduction to it, and while I usually hated dealing with it, everything else seemed rigid and inflexible in comparison. &gt; I remember reading the 1985 Byte magazine issue dedicated to Smalltalk cover to cover and being blown away. I haven't really used Smalltalk for anything other than poking at the language to see how it works, but it's one of a few exceptions to my not getting along well with OOP. Maybe because of its message passing emphasis? Ruby's flavour of OOP, which is pretty clearly inspired by Smalltalk, didn't seem so bad either. Saying this is basically heresy to some, but I also kind of like prototype-based OOP, like Lua and Javascript uses. I still prefer FP to OOP, but prototypes make sense to me. &gt; Some folk pushed P5 quite a long way in FP directions. (Did you ever read MJD's HOP?) P6 has pushed that a bit further again. I'd only heard about *Higher Order Perl* after I'd quit using Perl as regularly, so I haven't read it, but I've skimmed it a bit. It seems like the logical next step for where I had been going with Perl, though. I learned Perl from the camel book (second edition) and *Advanced Perl Programming* (first edition), and the combination taught me things about how Perl's dynamic nature could be used (and abused) that were mind-blowing at the time. I knew nothing about functional programming and sneered at lisp and its funny parentheses, but I was unknowingly halfway there the whole time thanks to Perl. Perl made it easy (and tempting) to do things like stuff anonymous subs inside variables and arrays, or pass subs to other subs, and on top of that I'd picked up other FP habits like always taking and returning values instead of dealing with globals, etc., without ever realising that's where I was heading. &gt; P6 is actually designed as several interwoven sub-languages that call into each other. One of these sub-languages is a new parsing "Rules" sub-language. If you ever want a specialized parsing tool with nice declarative grammars that support parsing of any class of grammar, consider P6. I recently wrote an answer to an SO question: "Extracting from .bib file" demonstrating what this looks like in P6. That sounds like another way that Perl is inching closer to the lisps. One of the strengths of lisps is the ease of creating DSLs with macros, essentially extending the language to fit the problem, and it appears Perl is taking a similar approach. Racket even lets you write entirely new languages that can be declared by startinga file with `#lang language-name`, which allows you to turn whatever custom syntax you design into s-expressions. Even if this stuff is often situational, it's awesome when a language makes it accessible. :) &gt; Thanks again for your excellent explanations. Hey, no problem. I try to give clear answers with examples when possible. It makes my comments really long sometimes, but I generally prefer avoiding writing short "RTFM" type answers with links and no explanations. 
&gt; I am sure there are plenty of people who would be happy to argue that Perl is safe over at /r/perl/ Why feed the trolls?
Actually, I wanted to hear how someone who knew more about programming would answer this.
You can write vulnerabilities in any language. That said, it's certainly possible to write secure code in Perl. Carnegie Mellon's Software Engineering Institute publishes [rules on how to write secure programs in Perl](https://www.securecoding.cert.org/confluence/display/perl/SEI+CERT+Perl+Coding+Standard). I don't think they would bother if it were an impossible task.
What is safety? Let's imagine you have a brand new Volvo vehicle. Say it is a [truck with automatic braking](https://www.youtube.com/watch?v=ridS396W2BY). Would you call that a "safe" truck? What if you turned off the safety features - is the truck still "safe"? Now how about if you were driving along at 60mph/100kph and then quickly jerked the steering wheel towards the car besides you, before the automated protection systems kicked in - crushing the vehicle. Is the truck still "safe"? A good driver/programmer can manipulate their truck/script to do whatever they want it to do. A bad driver/programmer can encounter problems when they don't know what they're doing. A "safer" language arguable protects a bad programmer from bad decisions - but even "safe" languages permit both poor programmers and expert programmers to do damage. You have to start out by defining what you consider is "safe".
I don't see anything *to* answer. The original statement is vague and mentions bash and other "glue stuff." You've not seen their code; it could well be a pile of hacks. I don't understand why you commented on that thread at all, much less felt it needed the attention of r/perl
The previous thread said people shouldn't use perl( and other languages) because it wasn't safe. I guess I should have shared the previous comment.
You can't convince every hater on the planet that what *you* like is good. To my ear, your comment just makes you sound like you're desperate. Let the Python folk trash Perl from ignorance; it's not a bad way to get more Perl programmers.
interesting...
I just answered it. Took a few jabs at python too. https://www.reddit.com/r/Python/comments/6ozf9d/the_2017_top_programming_languages_python_jumps/dkmnkv1/
That was an interesting reply.
I figure you can be stupid in whatever language you decide to code in, but I fail to see any inherent deficit in Perl, unless you choose to be stupid. 
The other day I inquired about finding a script that allowed me to run a simple web server and allowed basic interaction on a Linux host. The funny thing I, of course, looked at Python but this was something also ideal for Perl. There are still plenty of systems out there supporting Perl and at my work, I still see Perl scripts deloped for production use. 
This is the kind of comment I wanted to avoid. I KNOW that Perl is still used in places, and I KNOW that Perl is ideal for many things. The issue I hoped to address is that it's very clearly dying. It's falling on every single list of programming languages that I've come across (not just the two I posted about). Python is being taught at most Universities. I'm affiliated with a few Universities and I don't even think Perl is offered as an elective anywhere. Why would the next generation of software developers have any reason to learn Perl unless they had to support legacy code? Hence the question - "What can stop the hemorrhaging"? 
Perl will not go away anytime soon. It's a robust, proven language, it does what it was designed to do very well, and it's still very well maintained. I don't think Perl needs saving. Personally, I don't care if it's not popular anymore. Many more languages will have to be declared dead before I start worrying about Perl. I still use it for all my personal projects, and will continue to do so. Ninja edit: But, to answer your question: Perl could be "revived" if a project written in it is suddenly to become hugely popular and profitable. Any ideas, OP?
In your analogy a truck with tamper proof safety features is safe. So that you aren't at the mercy of highly variable skill for what a code comes out. A truck with all the wheels the same shape is also safer.
Name Perl 6th anything but "Perl"
&gt; I'm affiliated with a few Universities and I don't even think Perl is offered as an elective anywhere Follow the ["perl" tag](https://stackoverflow.com/questions/tagged/perl) on Stack Overflow for a few days. You'll soon see people asking for help with their Perl homework. Unfortunately, it's usually some horrible CGI program based on Matt's Script Archives. The colleges that do still teach Perl don't appear to have updated their courses for twenty years. And why would they, it's not like Perl has changed in that time. The last new version of Perl was released in 1994 :-/
&gt; not doing a very good benchmark That depends, not everyone is using Clojure to write long running services, or is that the only use case for the language? (I know it isn't, but for JVM, I'm not so sure). But calling it "not so good" becuase the JVM is not primed, is too much.
There really is no such thing as "safe", if " safe " was a thing, CVEs wouldn't happen and the entire field of security research could be retired as redundant. There is only safe-*er*, that is, one strategy has more layers and more known classes of threats it defends against.
&gt; What can be done to make Perl5 great again? 1. Rename "Perl 6" to something without "Perl" in it, so it can market its own strengths under its own brand name, instead of flopping under a brand it can't represent. 2. Release next stable release of Perl 5 as Perl 7, reiterating on all the strengths people who love Perl use it for. The Renaissance of Perl. 3. Stop wasting time on "killer app" approaches to marketing. No one gives two shits about a Wordpress clone. Focus on language's strengths instead of copy-catting successful projects. 
I have a google alert on "Perl". Since the spring of 2016 the majority of links sent to me in are Perl jobs all over the world, so I don't think Perl 5 really needs saving. though it would help a lot with the public image of Perl5 if the old-timers would stop stomping on people asking questions about Perl and CGI ... there is a lot of CGI code needing to be maintained, so there are very legitimate reasons for the noobies to learn about it. 
Write more Perl code. Blog more about writing Perl code. Upload more code to CPAN and github and blog about that. Tweet about using Perl. Advertise jobs for Perl. Go to non-Perl conferences and talk about using Perl. Run Perl workshops and get togethers and blog about that. Buy Perl books. Embrace shiny new social media to highlight that [Perl is very much alive](https://www.instagram.com/perl_events/). In other words, [stop reinforcing the frame](https://chrishardie.com/files/framing-lightning.pdf). On TIOBE: Look properly at the historic figures (i.e. the graph below the table) and you'll see that the trend is towards no dominant language. This makes sense, the landscape is massively fractured compared to what it once was. Perl will never be as popular as it once was, nor will any one language. Java, C, and C++ are a little bit ahead but the rest are fighting it out in the area of rounding errors. The difference between perl being outside the top 10 and inside the top 5 is about 1%, top 3 about 3%, and really I don't think that matters. Edit: You know, there's a meta-blog post in the TIOBE figures: "How long until TIOBE is irrelevant" (not that it was ever relevant) and why the days of a dominant programming language are coming to an end. You could probably get a bit of traction on the tech blogs and aggregators if you wrote it well enough.
+1 on stopping reinforcing the frame. The incessant pessimism and crying that something is dying is enough to drive people away. As for TIOBE being crap: look up Delphi's rank and how it got that high.
MoarVM. I wouldn't use anything else right now, unless you have a very particular requirement for the JVM. Startup will be dog slow if you include the JVM overhead ontop.
@6timo I'm using two local builds from source: * Perl 5 v5.24.0 * Rakudo version 2017.07-10-g2f5a6cd9a built on MoarVM version 2017.07 On my 2016 Core m7 Macbook the timings are roughly comparable since there is a reasonable amount of variance. Im not sure Perl 6 being faster or slower is something I'd comment on from what I can see. The point is they are highly comparable and Perl 6 is faster given feature parity. Loading all required modules in Perl 5 Im not even sure what you'd include since you get more than just Moose'like out of the box with P6.
I'm a total noob to Clojure and the JVM, so I was just curious, that's all. My conclusions so far: * the JVM sucks at IO * the JVM sucks at anything short-lived * the JVM may be somewhat faster than a slow interpreted language like Perl when running repeated stuff in a long running process * the JVM consumes horrendous amounts of memory (top RSS 424 MB vs 2 MB in my case) * Clojure is *still* cool
I wasn't aware we were talking about security? My point was that in Perl a novice programmer can read a shit tutorial from the 90s, pump out a load of crap and do insane things like change array indexing or default split character globally etc. A "safe" language is a less powerful and dynamic language. It doesn't necessarily have to be more secure. There are a lot of things in Perl 5 that were put in for doing quick foo on the command line for one liners and shell script replacement, that as a language make it far less safe. There are ofcourse work arounds and fixes. The issue is that by default Perl is not especially safe, why is there the mantra of "use strict;" for example. It's to provide new people with safer defaults that prevent them from going into corners and semantics of the language that are not appropriate for professional code reuse or reliability.
There's an easier way to do this with [Device::Firmata](https://metacpan.org/pod/Device::Firmata). You load the [Firmata firmware](https://www.arduino.cc/en/Reference/Firmata) on the Arduino, and then control it over serial. Any computer with USB will work (well, I've never tried it on Windows, which can be finicky with serial ports), which is a little easier than tapping into i2c lines on regular desktops. (There are lots of i2c buses on modern computers--on Linux, do `ls /dev/i2c*` to take a gander--which are mostly for temperature sensors and such around the motherboard. It's not easy to physically tap into them, though. There is one on VGA/HDMI/DisplayPort connectors. You may or may not be able to hack it to take control.)
But skipping an ill fated 6 numbering and jumping to 7 is just copy catting PHP &gt;:3 Pretty much agree with this sentiment. But I'm not convinced Perl 7 will do any better than Perl 5 without some actual changes. If the proposed concept for Perl 7 was a backcompat breaking set of Perl 5 defaults i.e. all the currently modern/experimental features on by default, strict/warnings on by default etc. Inclusion of a stronger object system with nice keywords in core, again on by default. Then you can probably claw back Perl looking far more like the modern language it can easily be if you know what to do. The nice thing is you can sort of maintain a 5/7 release cycle with the only difference essentially being the setting of default pragma/modules loaded.
Even then, that is not "safe" in any sense. It's simply more predictable at expense of being less powerful, having more sensible defaults. Otherwise by extension you find "cat" is the safest programming language because you can't do anything that will amount to at least a maintenance headache later. But you also can't actually do anything useful either. 
If someone wants a language with a strong object model that's "on by default", they can get it without Perl. In Perl, they can choose when, for which, and how much to pay for one. No backcompat-breaking changes in Perl 7. That can be done in Perl 8. Perl 7 and Rakudo are strictly a marketing move away from the Perl 5/Perl 6 confusion for both languages.
Long-running applications are the only real use case for JVM languages (unless, of course, your users are very patient). Java 9 *may* help to solve this problem, but right now that's just how it is. I hear people have had good success with clojurescript and Node, but I have no experience with that. 
As someone who wrote PERL professionally in the 90s myself, I'd always (98% of the time) choose to write a script in PERL and I'd always (98% of the time) choose to write a service level program (or greater) in clojure. Different tools for different tasks. For fun, try CLJS vs PERL. :D
There's also ParrotVM (original VM for Perl6), hence the question.
You obviously are unaware of the (wonderful) features available in modern Perl, eg 5.26. Mostly compatible with 23 year old Perl 5, for some definition of 'mostly.
I totally agree with those points.
&gt; You obviously are unaware of the (wonderful) features available in modern Perl, eg 5.26. I hope that was gentle sarcasm!
In the IRC channel on freenode at least, I think we are doing better at this. While still vehemently recommending the use of modern solutions for new projects that obviously don't need CGI or at least can run in a modern framework under CGI, if the person says "I am trying to maintain this legacy code" or "I need to run this on shared hosting" then that's fine. Sometimes it takes some work to get them to admit that part though.
I learned Perl about 1 year ago. to do more than possible in shell scripting. Interestingly shell is 17th, HTML 16th, i cannot see these going anywhere. Why did i choose Perl over python etc? mainly because it has rules from C and Java; which i picked up at university. Perl is also supported on almost every Linux/UNIX platform out of the box. Furthermore, Perl was flexible. However, many at university were not keen on heavy programming. I can see why they would prefer a language like python. An inflexible syntax which takes away creativity but allows a "canned" answer to problems. True techies IMO will never prefer this, but as more people who are non-techies take up programming and computer science a simpler language is required to cater for them. 
Might I recommend a more ergonomic keyboard?
I use a mechanical keyboard. The issue is pressing shift constantly wears out my pinky finger
A *more* ergonomic one then? I have a couple of mechanical keyboards with a) shift as a thumb key and b) symbols that are arranged mnemonically rather than tied to arbitrary numbers.
Linky ? I use keyboard macros for copy, cut and paste and that helps heaps.
&gt; I'd always (98% of the time) choose to write a script in PERL For something standalone sure, but the convenience of running dev tasks from my already open REPL is pretty nice, even if it's slow (mainly reseeding databases).
Well making anything "great again" starts with red hats.
I agree with your sentiment, but not necessarily the specifics of #3. A Wordpress clone would easily fall within Perl's strengths, and I see people looking for such a thing in Perl all the time (only people already using Perl of course) but nobody has written/marketed one good enough yet.
So you're saying we need to get Fedora (thus by extension RHEL) to switch their tooling from Python to Perl...
Nice to see that the top comment in the thread has been downvoted to oblivion, as it should be.
Yeah, I thought of the RHEL connection when I clicked "Save" :)
yes but.. ( :) ) the perl5 vm is fast/small-as-hell. the JVM (java -jar helloworld.jar) is relatively fast when you compare it to the *crazy* startup overhead of clojure. As an example, my job has a chatbot written in clojure that takes something like 45 minutes (yes, minutes) to restart. It's a massive turn off to a language with otherwise has some really interesting stuff (STM is mind blowing to say the least). You can probably destroy perl5 startup times compares to even smaller stuff like lua, but I haven't tested this outside of the millions and millions of crons I've written | perl -ane 'if $F[1]...'
&gt; dispatching on arity like that cuts down a lot of conditional code and branching Indeed. [Multiple dispatch](https://docs.perl6.org/language/functions#Multi-dispatch) is core to P6. I'd guess well over half of all routines written in P6 are "multis". &gt; much like pattern matching does Fwiw P6 has powered up [ML style pattern matching](https://perlgeek.de/blog-en/perl-6/2013-pattern-matching.html). &gt; I've found I prefer the lisp-1 (shared namespace for variables and functions) side If P5's a perl-1.9 (not perl-2, cuz lvalue routines) then P6 is perl-1.8 or less, because one can "slash" out the usual sigil when declaring a variable: my \look-ma-no-sigil = 43, 44; say look-ma-no-sigil[1]; # 44 &gt; some Clojure ideas are leaking into other ones, like the awesome threading macros I've just read [Threading Macros Guide](https://clojure.org/guides/threading_macros). If I interpret things correctly, P5 has equivalents to at least some of these (though not as macros) and P6 has equivalents to all of them (again, not as macros). I think P6 guarding is too different to make it worth comparing the guarded variants but use of `.` and "method chaining" in P6 correspond to Clojure's `-&gt;`; use of `-&gt;` in P6 corresponds to Clojure's `as-&gt; ... v`; and use of P6 "feed" operators (`==&gt;` and `&lt;==`) correspond to Clojure's `-&gt;&gt;` (but P6 feeds have parallel semantics that Clojure's perhaps don't). &gt; { } literal for tables, Lua's complex data type. Heh. Despite P6 using `{ }` all over the shop to delimit blocks of code it *also* has some [unloved and kinda corner-casey support for using `{ }` literals for data](https://stackoverflow.com/questions/44101411/is-that-a-perl-6-hash-or-block). &gt; Perl's bare-bones, build-it-yourself OOP was my first introduction to [OOP] Yeah, one kinda wants something at least as coherent as CLOS. Fortunately, around 2006 or so, P5 and P6 began converging on CLOSish solutions which have since stood the test of wide deployment. &gt; Smalltalk [is] one of a few exceptions to my not getting along well with OOP. Maybe because of its message passing emphasis? "Since I grasped that the messages are the important thing in OO, however, the way I design objects has changed dramatically." ~~ quote from [Perl 6 is biased towards mutators being really simple. That’s a good thing.](https://6guts.wordpress.com/2016/11/25/perl-6-is-biased-towards-mutators-being-really-simple-thats-a-good-thing/) &gt; I also kind of like prototype-based OOP Er, guess what? :) &gt; FP habits like always taking and returning values instead of dealing with globals P6 has dynamic variables that are kinda local globals, as it were. Their semantics in the context of P6's concurrency constructs are... interesting. :) &gt; One of the strengths of lisps is the ease of creating DSLs with macros, essentially extending the language to fit the problem, and it appears Perl is taking a similar approach Larry read Paul Graham's [The Hundred-Year Language](http://www.paulgraham.com/hundred.html) and took it seriously. &gt; I try to give clear answers with examples when possible. It makes my comments really long sometimes, but I generally prefer avoiding writing short "RTFM" type answers with links and no explanations. Likewise and I really appreciate our meeting of minds. As someone who considers themselves part of the Perl family but plans to play again with [Ipso](https://github.com/masak/ipso) may I wish you ever growing delight in your relationship with the Lisp family as Perl grows ever closer too. :)
That's right. I don't follow Perl releases at all. I never ever run [courses like this](http://act.yapc.eu/lpw2016/talk/6877). I thought my sarcasm was obvious. I'll try harder next time :-)
It's a great review, thank you for your work
How about "I hope to get a job writing Perl and most jobs that hire noobs are maintenance for 20 years old CGI apps ?" :) why do they have to justify anything ? :) 
I specifically meant attempting to "come up" with a "killer app" for "marketing purposes" that will make significant number of people want to learn Perl just for the sake of being able to work on that "killer app". [I see these suggestions](https://irclog.perlgeek.de/perl6/2016-01-13#i_11882998) come [up all too often](https://irclog.perlgeek.de/perl6/2016-02-11#i_12023219) (including on [this very thread](https://www.reddit.com/r/perl/comments/6p6026/can_anything_save_perl5/dkmyd1t/)) whenever marketing comes up. A [slight variation on that theme](https://irclog.perlgeek.de/perl6/2016-08-05#i_12972199) is wanting to write just enough API implementations for arbitrary services. There are two flaws with attempting to make the language more popular by making software for the sake of "marketing." First, the innate assumption is this software hasn't been written yet, so even if you come up with a good idea, it'd have to be written from scratch. However, if it's really a "killer app", someone else is already writing it in another language too, so you're not getting any headstart. The second flaw, is the fact that you're writing that software for marketing purposes alone means you have little interest to see its development through. It doesn't matter if your "Perl TensorFlow API" is great; if you're not there to stick around to fix bugs and provide support, it ain't winning any language favourites. &gt; A Wordpress clone would easily fall within Perl's strengths Sure, but "everybody knows" Wordpress is better than [Pearl Bee](http://pearlbee.org/); it powers more websites, so it has to be. No CMS in the world will do to Perl what Wordpress did to PHP. Yet the "killer app" for "marketing" that people keep proposing involves some sort of CMS system at least half the time.
It's not the job of a chat channel full of volunteers to teach someone how to code bad Perl. There's plenty of outdated google links for that.
thank you for making my point for me :) happy stomping on noobs 
I think releasing Perl 5 as Perl 7 would end up harming both brands, because of the confusion it would cause. It would make Perl 6 seem like a failed experiment to some, and that feeling would likely remain once a person found out it was now named something else. Which would harm the new branding in their eyes, and they would tell others to stay away from it. (You have to realize we are dealing with humans, and humans regularly come to the wrong conclusions and keep them far too long in the face of contradicting evidence) It could make Perl 5 seem like it's grasping at straws trying to remain relevant. It also might hurt the branding that Perl 5 tries to remain backwards compatible; which is one of its strongest selling points. There is a reason this particular idea was dropped the last time it came up.
I agree that it's not a good move to make unless/until Perl 6 manages to rebrand itself in the public eye.
All good points.
Notice that I said "teach", not "help". What you describe is not someone looking for help with a problem.
There is no implementation that runs on Parrot that passes the spec tests. Rakudo dropped support for Parrot before the official release of Perl 6. It was dropped because it was deemed the best way to support Parrot in the future would be to reimplement support for it almost from the ground up. As of now nobody has to my knowledge even tried to do that. I think NQP still supports Parrot, so anyone attempting it wouldn't be starting completely from scratch.
on IRC you're not required to do anything, neither teach nor help ... nor stomp on noobs who ask questions about something that is no longer fashionable for new projects but used in _a lot_ of projects still under maintenance and the main reason Perl got out of the sysadmin niche 
&gt; What you describe is not someone looking for help with a problem. Helping someone understand the problem isn't what they think it is is indeed helping someone with a problem.
&gt; There is a reason this particular idea was dropped the last time it came up. Perl programmers don't understand sunk costs? &gt; You have to realize we are dealing with humans, and humans regularly come to the wrong conclusions and keep them far too long in the face of contradicting evidence Heh.
[/s,](http://blogs.perl.org/mt/mt-cp.fcgi?__mode=view&amp;id=2390) [right?](http://www.perlmonks.org/index.pl?user=raiph;node_id=6364) 
* [Keyboardio](https://shop.keyboard.io/) * [Ergodox EZ](https://ergodox-ez.com/) * [Kinesis](https://www.kinesis-ergo.com/shop/advantage2/) * [Maltron](http://www.maltron.com/store/c34/Dual_hand_keyboards.html) Searching for "thumb key" may turn up some others.
Thank you very much for this very thorough review of my book, which I saw only today. 
thank you kind redditor.
Let me (as a newcommer) tell you what I think Perl lacks: Good up to date documentation! It's an amazing programming language. It has features that some successful languages have tried to replicate (powershell). This is what I felt after reading a few tutorials on Perl. However, after those tutorials you're on your own! Tutorials generally tell you how Perl works, and how some common modules are used, but newcommers need a bit more. As an example, I read some tutorials and books on Perl last year. Now, I want to try out a project with WWW::Mechanize::Firefox. I head on to cpan to see documentation on it, and unfortunately, all I see is a listing of common functions, and some examples from people who know the module really well.. To me it's showing off, not good documentation. I think Perl will still be active 10-15 years from now only if people active in developing it and modules also produce quality documentation. Maybe it's just my fault, I might be dumb and unable to understand some proper documentation, but if not, it would be a shame for such an amazing language to be lost. I would say if you know Perl well enough, contribute to the community with easy to understand examples, which then lead the way to more complex ones, good documentation, maybe even scripts that you use in some form or another.
and the Perl script should be using XS and a C library for anything time consuming ... I mean, that is the right way to use Perl, it is a glue language, Larry says so.
Yes, I think the problem is your inexperience. The library actually has great examples: * http://perltricks.com/article/138/2014/12/8/Controlling-Firefox-from-Perl/ * https://metacpan.org/release/WWW-Mechanize-Firefox#examples If you can clearly articulate where these are falling short or why in particular you have trouble understanding an example, then they can be improved. A generic complaint solves nothing.
I see what you did there 😀
Death of COBOL predicted.
I've always believed that Perl had great documentation. But it's been about twenty years since I learned Perl and it's possible that either people's expectations of programming language documentation have changed or I had previous experience that made the Perl docs particularly suited my use case. If you can explain what you think is missing, then I'd be happy to get involved in improving the situation.
COBOL is dead: (indeed trends) https://www.indeed.com/jobtrends/q-cobol-q-perl-q-python.html Perl is following.
All of programming jobs are way down in the noise. If you want to train yourself for something where there are lots of opportunities then pick sales. https://www.indeed.com/jobtrends/q-cobol-q-perl-q-python-q-Sales.html
&gt; It's in a slow death spiral. I find repeating such things to be self-perpetuating and doesn't help anyone. Please, cut it out. How about instead asking "how has Perl managed to be so successful, well into its third decade and still often touching the top 10 list in albeit-dubious ranking systems?" That would be a much more productive conversation.
avoiding what is actually happening by ignoring every single metric helps even less. Perl is downwardly trending - there is no avoiding this truth. My post was to have an honest discussion on how the perception can change. 
Some programming languages are further down than others. https://www.indeed.com/jobtrends/q-cobol-q-perl-q-python-q-go-q-java-q-C.html this isn't a discussion on training. Its a discussion on how to move the direction of the slope upwards. 
Read the above posts about how *every* language is trending down, because there is no one dominant language anymore. My point was that opening with "Perl is dying" is just making things worse by repeating a false narrative.
That's... actually pretty convincing. I'm a little too scared/aware that I'm on the internet to run that code though. 
Haha, I didn't write the blog review. I'm sorry if I didn't make that clear. I was just saying while flipping through the book I was really impressed with the quality. The exciting part for me was that even though I primarily code in Python (a little Perl and other langs), I felt right at home with Laurent's writing style, code, and Perl6, so I'm sure people with a background in Python and Ruby will find it quite easy to jump into if they so please.
Too bad that m:n threading involves two-level scheduling, which is known to be a bad idea.
Oyst. Short for Oyster.
You have `$file`, which is scoped outside of the loop - could be that holding onto references causing a leak. Could also be trying to create 15,000 DateTime objects every iteration. Could also be something in your Table class holding onto references. Try inspecting some of those with [Devel::Cycle](https://metacpan.org/pod/Devel::Cycle) to find any circular references, which are generally the cause of memory leaks in perl.
code like this: my %details = ( access_level =&gt; 'very limited', user =&gt; $cgi-&gt;param('user') ); request like this: /script?user=someone&amp;user=access_level&amp;user=administrator effectively doing this: my %details = ( access_level =&gt; 'very limited', user =&gt; 'someone', access_level =&gt; 'administrator', ); # $details{access_level} is 'administrator' here 
It would probably help if you explain what part you don't understand. Parameters can contain multiple values, and if called in list context `param()` returns all of them. To take the example given in the documentation: my %user_info = ( id =&gt; 1, name =&gt; $q-&gt;param('name'), ); Suppose the user provided parameters like: name=John&amp;name=authorized&amp;name=1 Because `param()` is being called in list context, it will return an array of the three values, `("John", "authorized", "1")` which gets flattened into the list being used as the hash initializer. The end result is a hash that acts as if initialized by: my %user_info = ( id =&gt; 1, name =&gt; "John", authorized =&gt; 1, ); If you weren't expecting that, and your code makes decisions based on the presence of an `authorized` key that your code expects to control, then the user has just owned you. This isn't specific to CGI, it's the basic nature of how arrays work. Simplified testcase: #!/usr/bin/env perl use warnings; use strict; use Data::Dumper; my @params = qw/one two three/; my %some_hash = ( foo =&gt; 1, bar =&gt; @params, ); print Dumper \%some_hash; Prints: $VAR1 = { 'foo' =&gt; 1, 'two' =&gt; 'three', 'bar' =&gt; 'one' }; If this is still confusing, remember that the `=&gt;` is really just a glorified comma that automatically quotes a bareword on its left. The hash is initialized by a list, and all the normal list flattening rules apply. 
The following code is vulnerable under ancient CGI.pm. Suppose you have: my $otheruser = Bugzilla::User-&gt;create({ login_name =&gt; $login_name, realname =&gt; $cgi-&gt;param('realname'), cryptpassword =&gt; $password}); The code looks up the value associated with the `realname` key in the request. What happens if you create a request with several keys named `realname` and some sneakily constructed values? The CGI.pm would return a list of the values, I'll manually substitute them in the code: my $otheruser = Bugzilla::User-&gt;create({ login_name =&gt; $login_name, realname =&gt; ('Mighty Bugzilla Abuser', 'login_name', 'Administrator', 'email', 'admin@bugzilla.org'), cryptpassword =&gt; $password}); Because the `{}` operator takes a list of alternating keys and values to create the hashref, and lists are generally flattened in Perl, the above is functionally equivalent to: my $otheruser = Bugzilla::User-&gt;create({ login_name =&gt; $login_name, realname =&gt; 'Mighty Bugzilla Abuser', login_name =&gt; 'Administrator', email =&gt; 'admin@bugzilla.org', cryptpassword =&gt; $password}); The security relevant problems here are that the duplicate `login_name` silently overwrites the first one, and the `email` key and associated value was injected from the outside. Do you understand this now? Please give me feedback. The vulnerability occured due to the confluence of sloppy programming, incorrect input validation, and less than awesome initial design of the CGI.pm library.
Parrot was the original VM of Rakudo not Perl 6. It sadly hasn't been officially supported for several years now, and is unlikely to be resurrected given the progress in MoarVM on performance and unicode handling.
I mean thats simply not true. Removing your ability to accidentally use a string as an array reference isn't really removing any functionality a *sane* individual attempting to write a safe program would do. Certainly not warning about it happening is a really stupid idea. Ultimately predictable is safety, formal programming being the absolute "safest" example. There is a lot of power in predictability, even in dynamic languages it means you JIT whatever is happening etc.
Yeah, there's some mystery around `$file`. We don't know what kind of object that is, right? It's running `$file-&gt;download` every minute. We don't know how how big that file is, or how it's being dealt with in side that class. Also, in my experience, when a Perl script does because it's out of memory, it usually specifically says "out of memory." I also assume that's what it is, but if it doesn't say so, then I'm left unsure of that. Another thing I do sometimes is run any command where you can see the free memory on the system, in a `while true` loop, with no sleeping, because you really want to see it as it changes (you could also use `top` or `htop` or something for that). If there's a memory problem with this script, you should see it there. Also, I would reduce the sleep, just to speed up the process. Sleep for 1 second instead of 60, so it can fail every 20 seconds or so, rather than every 20 minutes or so.
I'd look at both open3 and Expect (https://metacpan.org/pod/release/RGIERSIG/Expect-1.15/Expect.pod) 
Thanks! I'll check out `Devel::Cycle`
Guy who's new to Perl here. I'm going to be learn Perl because it's existed for awhile now, and there's a lot of Linux scripts written/can be written in Perl. I'm more of a Clojure guy, but with any aspiring dev you have to have more than 1 language in your toolkit. So at the moment (since I barely know anything) I'm not entirely sure about the 5 vs 6 controversy. Is this like a Python2 vs 3 thing?
ELI5 why you would even consider using CGI, seriosly...
Thanks! I can't really do 1 second checks, because there's a limit to the number of API call I can do. I guess I should setup something locally, and see if there's a problem with my Table class. The `$file-&gt;get_last_update`, which runs every minute, is very simple: calls API via `REST::Client` (gets a string), converts it to DateTime object via `DateTime::Format::DateParse-&gt;parse_datetime()`. The `$file-&gt;download` is actually runs a lot fewer times, only if files updates (manually by someone somewhere). Sometimes it gets updated several times in 5 minutes, but most often it's sits not updated for hours. The `Table` class, though, utilizes `Spreadsheet::ParseXLSX` to parse the file. It reads the whole thing into memory (it's under 900kb, 13+k rows of data (7 columns). The `$records` is actually not all of those rows, just around 200 (I initially incorrectly stated its all). I just tried `top` while it was downloading-&gt;parsing-&gt;updating DB. During parsing part %MEM for `perl` process went up to 12.7%, stayed at that when updating DB, then disappeared from `top`'s output (as if memory got cleared?).
Couldn't hurt to rein in some of the more overzealous Rakudo advocacy, such as: &gt; "[having fun with P6, which is specifically designed to be readable, maintainable, composable, refactorable, etc. is fundamentally different from having fun with a language like P5](https://news.ycombinator.com/item?id=14858570)"
The problem here is an important case of semantics. When you say "safe" in the context of an entire language, you imply "there's no way you can make any mistakes" and that wording makes people careless and not bother to think about what they're writing. "Safe" is thus a statement in *absolute* terms. "Safer" and "safest" however are relative terms, 'x is safer than y' and 'of set Z{}, Z{n} is "safest". Encapsulating this reality in your language is to discourage you from lazy programming, only assuming language designers did their best, but there are still some pit falls you can stumble into and you'll still have to think at some level what you're doing and programming blind folded is not yet viable. The over arching idea being that no tool or rule can absolve you of the responsibility of thinking. They can make it *easier*, and more *efficient*, and they can express complex low level problems in convenient high level interfaces. But there will still be problems that leak through all the abstractions that you may have to one day deal with, the deepest being things like cosmic particles causing silent memory corruption. I dare say few programming languages even attempt to guard against that sort of risk. But if that's a problem that matters for what you're developing, you may have to take steps based on those sorts of things: e.g. most file systems don't have good detection on data corruption, but ZFS has a lot of sensitive code to detect and report these sorts of issues where other file systems do not. And I still wouldn't call those lengths "safe", only "safer". You can still lose data to fire or literal physical theft, so you should also have off site backups. The number of layers you can add to improve safety are many, and how many you employ will depend on budget and requirements. But you will still never be "safe", only asymptotically approaching "safe"
Experiment and see if you can execute 1 or more commands consecutively to your shell program by piping them through STDIN. Like so: echo some command | shellprogram Edit a text file and put multiple commands in it, each on their own line then: cat yourfile | shellprogram If you can do that - it makes this easy - open(my $IO, "| shellprogram") or die("A horrible death: $!"); print $IO "commands you want to pass to shellprogram\n"; close $IO; 
It will depend on how the program interacts with the terminal. I'm not a Perl guy, but I do have the answer! Does it simply read standard input? Use `IPC::Open3`. Does its behavior change when it's used in a pipe and `open3` doesn't work? That means it's detecting whether stdin is a TTY. In this case, you'll need to either use `expect` to automate it, or invoke it with `IO::Pty` to create a pseudo-TTY for it to interact with.
&gt; because my script gets paused With Rakudo, you can use core [`Proc::Async` type](https://docs.perl6.org/type/Proc::Async) that'll let you interact with your program asyncronously, so nothing will get paused. react { my $proc = Proc::Async.new: :w, 'hexdump', '-C'; whenever $proc.stdout { print "Program's STDOUT:\n$_" } whenever $proc.stderr { print "Program's STDERR:\n$_" } whenever $proc.start { say "Program exited with code {.exitcode}" } await $proc.print: 'Message to the program'; $proc.close-stdin; # we're done sending messages to the program } You can find more doc's on Rakudo's concurency stuff here: https://docs.perl6.org/language/concurrency
&gt; `whenever $proc.start { say "Program exited with code {.exitcode}" }` That's not a typo? The event is `.start` and not `.stop`?
No, it's not. It's not an event but a method call that returns a [Promise](https://docs.perl6.org/type/Promise.html) that's kept when the process finishes, which is when the `whenever` block will run. It's does read a bit weird when using the `whenever` construct instead of saving to a variable and then `await`ing, but `¯\_(ツ)_/¯`
Pre-existing code base is the typical answer.
First, let me thank you guys, as I truly had the feeling that you replied with a sense of trying to help. I'm afraid it's hard to say what I don't understand when I feel I'm like a blind man walking on the dark. Probably an example would be best. (Very often, while using new modules like this one, I'm getting objects, but I have to spend a lot of time experimenting with them to see what I can do with them, how can I explore: I've got some code here, which is simply part of my experiments: https://gist.github.com/CatalinSoare/6c22997a25c3642089570185d813d3c3 My code is obviously not working as expected. Basically trying to explore things, by starting to list the names of torrents from qBittorrent webUI. What I generally mean is that there is documentation, but my feeling is that if you have no previous experience with it, it's really hard to read, so you spend a lot of time playing with what you get from the objects/functions.
The main problem with your code seems to be this line: my %torrents = $mech-&gt;selector('tr.torrentsTableContextMenuTarget'); Whereas the [documentation for the module](https://metacpan.org/pod/WWW::Mechanize::Firefox#$mech-%3Eselector(-$css_selector,-%25options-)) has: my @text = $mech-&gt;selector('p.content'); So `selector()` returns a list of nodes which should be stored in an array, not a hash. Your code should probably be: my @torrents = $mech-&gt;selector('tr.torrentsTableContextMenuTarget'); foreach my $torrent (@torrents) { print $torrent-&gt;text . "\n"; }
I suspect I will learn python before perl6/rakudo... When perl5 stops being useful. edit: Thank you for the explanation, though. :D
 react { my $proc = Proc::Async.new: :w, 'hexdump', '-C'; whenever $proc.stdout { print "Program's STDOUT:\n$_" } whenever $proc.stderr { print "Program's STDERR:\n$_" } my $promise = $proc.start; await $proc.print: 'Message to the program'; $proc.close-stdin; # we're done sending messages to program await $promise; say "Program exited with code {$proc.exitcode}"; } Than this should work? shouldn't it? (((it fails)))
You should be one of those people that think that perl6 is too different from perl5
The event-loopy portion of the react block will only kick in once the block has finished, which it won't because inside the block you're waiting for the program to finish. Also, you need to call `.exitcode` on the value you get from the promise, not on the proc object. try this instead: react { my $proc = Proc::Async.new: :w, 'hexdump', '-C'; whenever $proc.stdout { print "Program's STDOUT:\n$_" } whenever $proc.stderr { print "Program's STDERR:\n$_" } my $promise = $proc.start; whenever $proc.ready { whenever $proc.print: 'Message to the program' { $proc.close-stdin; # we're done sending messages to program } } whenever $promise { say "Program exited with code {$_.exitcode}"; done; } } 
Nah, you moved `.exitcode` from my example to call it on `$proc` (which is the `Proc::Async` object), but my code calls it on the return value of the `.start`'s `Promise`, which is a `Proc` object :) Your last two lines should be replaced with: say "Program exited with code {(await $promise).exitcode}"; so that you're calling `.exitcode` on the right object, but that'll give you the exit code message in the wrong place 'cause stdout/stderr whenevers will run after your message. Of course, you can just `.tap` the stdout/err instead of using a `react` block: my $proc = Proc::Async.new: :w, 'hexdump', '-C'; $proc.stdout.tap: { print "Program's STDOUT:\n$_" } $proc.stderr.tap: { print "Program's STDERR:\n$_" } my $prom = $proc.start; await $proc.print: 'Message to the program'; $proc.close-stdin; # we're done sending messages to program say "Program exited with code {(await $prom).exitcode}"; Or, if that's all you wanna to do the program, you can just use the synchronous `Proc`: with run :in:out:err, 'hexdump', '-C' { .in.spurt: :close, 'Message to the program'; if .out.slurp -&gt; $_ { print "Program's STDOUT:\n$_" } if .err.slurp -&gt; $_ { print "Program's STDERR:\n$_" } say "Program exited with code {.exitcode}"; }
Not a problem :) After you learn Python, don't forget to learn Rakudo too :)
Learn P5 if you want to be able to read and modify existing P5 scripts (I'd guess more than 99.999% of all extant Perl scripts are P4 or P5) and/or participate in P5's vast ecosystem / community / marketplace. Learn P6 if you want to see what happened when a few hundred P5 folk joined with a few hundred programming language design fans to spend nearly two decades fixing the things P5 folk had been complaining about and adding some major new features. Learn some of both if you like the way they feed off of each other (eg each can call the other and make it seem like a module in one is as if it were written in the other).
The most common way (although not always the best way) you will see shell interaction in Perl is with backticks. The qx operator is synonymous with backticks. my $output = qx/ls/; Here's a great Stack Overflow article that discusses the differences between common ways to interact with the shell via Perl: https://stackoverflow.com/questions/799968/whats-the-difference-between-perls-backticks-system-and-exec
&gt; I'm getting objects, but I have to spend a lot of time experimenting with them to see what I can do with them, how can I explore You need a [REPL](http://p3rl.org/Devel::REPL::Overview), install [Devel::REPL::Plugin::DDP](http://p3rl.org/Devel::REPL::Plugin::DDP). Then: › re.pl $ use WWW::Mechanize::Firefox () "" $ my $mech = WWW::Mechanize::Firefox-&gt;new WWW::Mechanize::Firefox { public methods (89) : add_header, agent, allow, application, autoclose_tab, autodie, back, base, by_id, clear_current_form, clear_js_errors, click, clickables, click_button, content, content_as_png, content_encoding, content_type, cookies, current_form, delete_header, DESTROY, docshell, document, do_set_fields, element_as_png, element_coordinates, eval_in_page, events, expand_frames, field, find_all_links, find_all_links_dom, find_link, find_link_dom, follow_link, form_id, form_name, form_number, form_with_fields, forms, forward, get, get_local, get_set_value, highlight_node, is_html, is_visible, js_console, js_errors, links, make_link, make_progress_listener, new, on_event, post, progress_listener, quote_xpath, reload, repl, reset_headers, response, save_content, save_url, select, selector, set_fields, set_visible, signal_condition, signal_http_status, status, submit, submit_form, success, synchronize, tab, text, tick, title, unsafe_page_property_access, untick, update_html, uri, value, wait_until_invisible, xpath, xpathEx, xpathResult, xpathResultType private methods (12) : _addEventListener, _addLoadEventListener, _custom_header_observer, _default_limiter, _extract_response, _field_by_name, _headerVisitor, _initXpathResultTypes, _install_response_header_listener, _option_query, _sync_call, _wait_while_busy internals: { app Firefox::Application::API40, autodie 1, current_form undef, event_log [], events [ ⋮ ⋮ ⋮
Expect is the [teflon tape](http://perl.plover.com/TPC/1998/Hardware-notes.html#Teflon_Tape) correct answer. Thread should be over here.
maintaining stacks of legacy code, written by someone else, for which there is no budget currently to re write
It is? \*shrug\* Just like perl5 was very different from perl4. However perl5 had a long time to become defacto, and rakudo is a better name to distinguish the two.
I think that the documentation for Proc::Async is missing, in the sense that I cannot find anything on that page if I search for the word "exitcode" or "exit code". Also, cannot guess from that page that the Promise will return a Proc object. I like the stile of man pages, where have a code snippet as an example for most of the C functions.
Gotta wonder how if feels to write a module, and then `brian d foy` comes along and re-writes it. :-) That being said, there's some code I don't quite get, here: # If it's any sort of Numeric, we'll handle it # and dispatch further elsif $ds ~~ Numeric { self!Numeric: $ds, $depth; } # If we have a method name that matches the class, we'll # use that. elsif self.can: $ds.^name { my $what = $ds.^name; self."$what"( $ds, $depth ); } # If the class inherits from something that we know # about, use the most specific one that we know about elsif $ds.^parents.grep( { self.can: $_.^name } ).elems &gt; 0 { my Str $str = ''; for $ds.^parents -&gt; $type { my $what = $type.^name; next unless self.can( $what ); $str ~= self."$what"( $ds, $depth, "{$ds.^name}.new(", ')' ); last; } $str; } It seems like this could be collapsed, but also that prefixing the formatting method could avoid some auto-conversion that would be unintended. [Warning: *all untested pseudocode*] elsif ($ds, |$ds.^parents).grep( { self.can: $_.^name } ).elems &gt; 0 { for $ds, |$ds.^parents -&gt; $type { my $what = "formatter-" ~ $type.^name; next unless self.can: $what; return self."$what"( $ds, $depth, "{$ds.^name}.new(", ')' ); } } This has the advantage that a type which derives from `Numeric` could still have its own formatter, e.g. if I wrote a `SciNumeric` which always formats its value as scientific notation, then PrettyDump could have a formatter for that. Am I missing something? 
Perl 5 will never stop to be useful, in general at least
&gt; Rename "Perl 6" We've had this conversation every year for about 12 years, now. I think it's time to accept that even if it happened tomorrow, it's never going to happen in the minds of the people who use the two languages as the situation stands today. I think the real problem is the cognitive inertia caused by numbering one thing and not the logical successor. We just don't work that way. What *might work* is to rename both languages in their next iterations. If there were a "Lrep" that was almost entirely back-compatible with Perl 5 (because it's "Perl," backwards), but turned on all of the "experimental" features from 5.latest plus made the smallest amount of back-compatibility sacrifice necessary to pave the way for the next 10 years (e.g. those changes needed to make signatures less wonky and possibly smooth Unicode a bit... I'm sure the Perl 5 literati could identify the things that would improve more than harm, especially if "use" had a compatibility mode), then rename Perl 6 to "Pardes" (a play on the translation of Rakudo as "paradise", Pardes being an initialism used in Jewish exegesis, meant to alliteratively suggest paradise... though this is just an example name). Now, with two new languages, one which is almost entirely back-compatible with Perl 5 and one that has all the modern-language bells and whistles, we can declare, "they're both members of the Perl family, but you have to use their names to be specific." You could even stress this by having the primary Web resources for both languages at `perl.com` with `lrep.perl.com` being specific to that version and `pardes.perl.com` being essentially a copy of what's at `perl6.com` today (probably redirecting the latter to the former so that people start to get used to the renaming). But as long as we keep referring to Perl 5, I think we'll continue to also call Perl 6 just that. 
There's the [method reference](https://docs.perl6.org/type/Proc::Async) as well as [the concurrency tutorial](https://docs.perl6.org/language/concurrency#Proc::Async). The method reference for `.start` has `Returns a promise that will be kept with a Proc object` You can [create an Issue in the doc repo](https://github.com/perl6/doc/issues) if you think something's missing (or make a PR).
&gt; it's never going to happen So you claim renaming one language is impossible and propose a solution that is attempting to rename two languages (one of which existed for decades)? Feels contradictory to me. &gt; we'll continue to also call Perl 6 I don't. Several of those who [read my original post](https://rakudo.party/post/The-Hot-New-Language-Named-Rakudo) and agreed don't either. And making a decision on the official naming is on the agenda for the next language release. &gt; We've had this conversation every year for about 12 years, now You can have a million conversations for a century and nothing will ever happen if you don't involve the right people. &gt; `lrep.perl.com` and `pardes.perl.com` That just increases confusion and accomplishes none of the goals.
&gt; So you claim renaming one language is impossible and propose a solution that is attempting to rename two languages That's one way of saying it, and yes, renaming everything in this case has less cognitive load than just renaming one thing out of the set. Is that so shocking? Would it be easier to move the US to the metric system or just to refer to lengths of 1-2m in metric? &gt; That just increases confusion and accomplishes none of the goals. Agreed, if you clip out the point I made about the primary site being the gateway to all things Perl (Perl still being a thing, just no longer being any specific language, but the whole family). 
&gt; Learn P6 if you want to see what happened when a few hundred P5 folk joined with a few hundred programming language design fans to spend nearly two decades fixing the things P5 folk had been complaining about and adding some major new features. Did you mean to post this from a parody account?
Back in the day, many devs who weren't security conscious when they wrote web code not only failed to sanitize input from random users but compounded that terrible mistake with the more understandable one of assuming that `param`, a singular word, would return only one parameter even if they didn't explicitly tell Perl to only expect one. The simplest rules to fix this problem, are: * Always sanitize input; * Don't use the CGI module, or, if you want to use the CGI module, either use `multi_param`, or ensure `param` is called in scalar (aka singular) context, not list (aka plural), context. The blog post you linked explains this in some detail. It has a "you gotta blame something" tone but the comments at the bottom of the blog post clear that up. From a prog lang design perspective, some folk find processing code according to context, in a manner that accords with human intuition, awesome. This is why Perls support context sensitive processing. But spelling a routine designed to process multiple parameter*s* using the singular word "param", coupled with devs both failing to read the doc and failing to sanitize input, coupled with the hostile environment of the Internet, is a potent argument against context in the language design, or at least for reconsideration of context sensitivity. Fwiw, Perl 6 retains context sensitivity but resolves known classes of failure of this sort at the language design level.
I meant it to be mostly P6 deprecating unless the OP or a reader was curious.
&gt; I meant it to be mostly P6 deprecating It goes over the top. "A few hundred"? How are you measuring that? Does a drive-by mention in IRC count? You'd have to make the same claim about anything else developed in the past 17 years -- Go, Swift, Rust, Python, Ruby, PHP, Perl. "Nearly two decades"? On its face this is silly; so much of that time was spent spinning wheels. "fixing the things P5 folk had been complaining about"? Also applies to Perl 5. "adding some major new features"? Also applies to Perl 5. The main problem -- as always -- is that Rakudo advocacy all seems to be built on the assumption that "look at the hard work we put into making this big list of features" is good advocacy. It's not, for at least two reasons. Number one, *no one but you cares* that it took so many people so long to deliver something marked as "stable", whatever weasel-worded definition of "stable" that Christmas release was. (I don't even remember what's marked stable, the spec perhaps, and parts of the implementation, and I worked on the project for 9 years.) Number two, *no one but you cares* about a laundry list of features, because the question "Do I have to install a BigFloat library to get fixed precision math" is so much less important than "Can I hire programmers?" and "Can I train programmers?" and "Will I have to support the language myself in five years?" and "Will I have to write the other libraries myself?" and "Will I have to write the documentation myself?" I suspect that the world will continue to yawn at Rakudo until you collectively figure out why your advocacy is so misguided and start promoting it based on the very real problems you should be fixing.
&gt; Read the above posts about how every language is trending down Look around and see how many people *used* to use Perl in their jobs and now don't. I could name a dozen top-tier CPAN authors.
This is true, but how many more authors have replaced them? You could count me among them, for while I've used Perl professionally for over 20 years, I've only been publishing to CPAN for 8 (and also taken over maintenance of many of those top authors' modules).
You've done and continue to do amazing work! I'm not talking about CPAN contributions though. I've personally done *zero* paying Perl work in almost four years now, and of the eight people on my last team, only one of them is doing paid Perl work. You'd recognize their names too. Maybe we've priced ourselves out of the market too. I'm not taking a contracting gig at $40 an hour, but if that's the market for Perl jobs without moving to Amsterdam, well, there's a reason I haven't had a paying Perl gig in almost 4 years.
&gt; Devel::REPL::Plugin::DDP May I ask you how you got to that? I mean how you listed the public and private methods? Or even better for me, could you please recommend a code editor/IDE that can autocomplete function names, attributes from imported modules? Thanks,
&gt; It goes over the top. Sure. &gt; "A few hundred"? How are you measuring that? Does a drive-by mention in IRC count? I don't think so. Iirc the 2015 announcement listed 800 or so names from the top ten or so Perl 6 related github repos. &gt; You'd have to make the same claim about anything else developed in the past 17 years -- Go, Swift, Rust, Python, Ruby, PHP, Perl. Sure. I'd imagine they had more. I don't understand why that's an issue. &gt; "Nearly two decades"? On its face this is silly; so much of that time was spent spinning wheels. Sure. As you note, I was being kinda OTT. (You spent 20 *years* on that thing!?!) &gt; "fixing the things P5 folk had been complaining about"? Also applies to Perl 5. Sure. &gt; "adding some major new features"? Also applies to Perl 5. Sure. &gt; The main problem -- as always -- is that Rakudo advocacy all seems to be built on the assumption that "look at the hard work we put into making this big list of features" is good advocacy. If that's the main problem, and always has been, then that's great news. We can just move away from such poor advocacy and we'll be making progress. &gt; no one but you cares about a laundry list of features I don't think I listed *any* features in this thread. More generally I don't much care for laundry lists of features. They seem appropriate in some cases, especially if someone has asked for such a list. But it seldom comes up. But perhaps your "you" wasn't meant to include me? &gt; I suspect that the world will continue to yawn at Rakudo until you collectively figure out why your advocacy is so misguided and start promoting it based on the very real problems you should be fixing. Oh, I suspect the world will continue to yawn long *after* that too. Speaking of which, *yawn*.
&gt; I'd imagine they had more. I don't understand why that's an issue. "Here's a reason I think you should care about a thing! It's no different from a handful of other things! But I'm going to bring it up as if it's some sort of USP!" &gt; I don't think I listed any features in this thread. But perhaps your "you" wasn't meant to include me? Look at the front page of perl6.org, specifically the box labeled "Many new features greatly advance our tradition of expressive and feature-rich programming". ... or continue patting yourself on the back that your grammar-based pedantry allows *you, Raiph, personally* to keep avoiding the point (notwithstanding the fact that you, yourself, personally create a lot of threads and comments on Reddit and HN saying "look at all these features for writing compilers" or "look at all these features for Unicode handling" or "look at all these features for fixed precision number handling", as anyone who clicks on your username can see for themselves).
Could you not use some form of weather API and parse the JSON response? What do these modules provide for you? ( I'm being curious since I've never used a weather module ) 
They just scrape something at Weather Underground - a webpage, I think. What you recommend or something like it is probably going to be the way I'm going to go. I can pull down METAR in plaintext from NOAA and there is a Perl Module to decode METAR, but it is missing a few things (like relative humidity). In theory I should be able to calculate relative humidity from the dewpoint and temperature if I can figure out the math, but what I found online is beyond me because I am math stupid because I am one of those annoying assholes.
I use the Dark Sky API directly. https://darksky.net/dev/docs The JSON returned is really easy to work with, but there's a Perl wrapper for it here .. http://search.cpan.org/~martyloo/Forecast-IO-0.21/lib/Forecast/IO.pm .. if you can't be bothered to parse the data yourself. The module really doesn't do very much. Example data returned by the API .. { "latitude": 51.4764332, "longitude": 0.002573, "timezone": "Europe/London", "offset": 1, "currently": { "time": 1501304924, "summary": "Partly Cloudy", "icon": "partly-cloudy-day", "nearestStormDistance": 95, "nearestStormBearing": 146, "precipIntensity": 0, "precipProbability": 0, "temperature": 13.39, "apparentTemperature": 13.39, "dewPoint": 12.71, "humidity": 0.96, "windSpeed": 4.3, "windGust": 9.3, "windBearing": 258, "visibility": 15, "cloudCover": 0.49, "pressure": 1008.34, "ozone": 318.09, "uvIndex": 0 }, .. followed by forecasts by the minute, hour and day (up to 5 days IIRC)
Actually, "thank you" emails might be the kind of 'spam' some people would like. Great idea!
Thank you. Will give this, specifically, a shot now.
Sure, see [feature](https://metacpan.org/pod/feature). But I prefer listing the features explicitly (and not only features, see my module [Syntax::Construct](http://p3rl.org/Syntax::Construct)).
Are features the same as polyfills in Javascript?
There is also `perldelta` e.g. https://metacpan.org/pod/distribution/perl/pod/perldelta.pod , https://metacpan.org/pod/distribution/perl/pod/perl5100delta.pod
No. `use feature` cannot be used to add support for a feature to an older version that didn't support that feature. It's only for enabling things that are supported but aren't enabled by default. 
Is Larry still involved with perl?
Not sure if there's a tidier version of this, but assuming you're using Planck to execute the script, I'd do something like `#!/use/local/bin/planck` `(require '[planck.core :refer [file-seq]])` `(-&gt;&gt; (file-seq "/usr/bin") (map str) sort (map #(str "Tiplizz inet " % "!")) (mapv println) time)` Not sure how you read the dir structure otherwise. I guess you could do something with Google closure directly but it's probably gross.
He [still helps out with rakudo code](https://github.com/rakudo/rakudo/commits?author=TimToady), especially [giving advice and decisions](https://irclog.perlgeek.de/perl6-dev/search/?nick=TimToady&amp;q=) to other core devs on how some features should work. Not sure about The Perl.
Hi there! How did you install it? I just tried using cpanminus and it installed OK. If that doesn't work I'm sure I can package it for you when I'm not on my mobile. Let me know! 
Thank you. :) Notes from trying to follow the code: I'm guessing Planck combines a Clojure interpreter with some assists such as a library of code. Like all P6 importing constructs, [P6's `require`](https://docs.perl6.org/syntax/require) imports (both explicitly exported and explicitly imported symbols) directly in to *the current lexical scope*. It looks like Clojure's, in contrast, imports a namespaced package and requires explicit symbol mapping from the namespaced package scope in to the current lexical scope (the `:refer ...` bit). [`require` as doc'd in clojuredocs.org](https://clojuredocs.org/clojure.core/require) says "Use :require in the ns macro in preference to calling this directly." My wild guess is the `ns` macro is tidier, able to do something more sensible with problems in someone's attempt to import symbols from multiple modules than if they'd specified multiple importing instructions, and able to provide better error messages. I'm guessing Clojure's `-&gt;&gt;` isn't designed to execute its arguments as a concurrent pipeline. (Afaict, `-&gt;&gt;` in Clojure is similar to [`==&gt;` in Perl 6](https://docs.perl6.org/routine/==%3E) except that `==&gt;` has concurrent pipeline semantics.) P6's [`dir` routine doc](https://docs.perl6.org/routine/dir) notes that "a dir call opens a directory for reading, which counts towards maximum per-process open files for your program. Be sure to exhaust returned Seq before doing something like recursively performing more dir calls." This reflects P6's lazy list processing nature. I'm guessing the Planck file-seq isn't lazy, i.e. the `file-seq` call immediately reads all of the directory in one go. By default, P6 uses [`cmp`, a "smart" compare routine](https://docs.perl6.org/routine/cmp) when comparing values for ordering purposes. This presumably removes the need for an equivalent of the `(map str)`. There are still two more `map`s. One is presumably equivalent to the `for` in the P6 code but why are there two? Perhaps this reflects a fundamental difference between the Perl and Lisp takes on how best to wrangle between singular entities (scalars in Perls, atoms in lisps) and plural entities (associatives/hashes and positionals/lists in Perls, lists in lisps). Again, thank you very much for posting. Imo, apart from homoiconicity, Perls and Lisps share a lot more than most folk realize, and each family can show the other a thing or two. :) 
I just tried through cpan. Also went to the cpan site and its not listed anymore. 
Thanks for the detailed response. Couple more things: The sort can be done before the string conversion in clojure too (cuts out a step in the pipeline) - I just want to make the desired comp a bit more explicit As far as Planck goes, that's for running this in clojurescript - in pure clojure it's slightly different (you, say, use Java io and pipe a script via Grench to a running clojure instance instead, to avoid the startup cost). Actually I had to spend a bit of time figuring out the clojurescript version because I wasn't familiar with file io in it) Also the pure clojure version is faster -- about 8ms vs about 40ms 
Sorry, not a very helpful reply. Running Centos7, CLI mode only. Installing via running cpan and then install Spreadsheet::Reader::Format and getting a message back saying cpan doesn't know what that is. Spreadsheet::Reader::Format is not listed in cpan.org either. cpan install Spreadsheet::Reader::ExcelXML (which is actually what I'm after) fails with four dependency failures. This is the first one. I've just installed cpanm. Looks like this will locate the missing bits! Thanks for the hint...
Hi! Author, here. I've been working recently on this pet project, both for fun and for my company. I would like to present to you my little library for Dependency Injection based on Moose roles. I've built a web site to explain how to use the library, some DI concepts and the like to try to make the experience of using the library pleasant. It's still a very early release (I was actually convinced by my boss to set it free long before I felt I was ready to do so, XDD), and as such, I'm sure that quite a good amount of bugs and terrible code will be revealed. I'm working hard to improve both the library and the documentation when I find some time, so please do not doubt to PM me with suggestions and bugs. Actually, filling issues on github would be still better :) The repository is: https://github.com/loic-prieto/moosex-dic There's a first version CPAN distribution, of course: https://metacpan.org/pod/MooseX::DIC Thanks!
Thanks for following up. &gt; The sort can be done before the string conversion in clojure too (cuts out a step in the pipeline) Are you saying that the code would have done the same thing if written as: (-&gt;&gt; (file-seq "/usr/bin") sort (map #(str "Tiplizz inet " % "!")) (mapv println) time) ? &gt; As far as Planck goes, that's for running this in clojurescript Ah. Is planck.core part of some ClojureScipt core, officially, de facto, or otherwise? In other words, can ClojureScript devs write `(require '[planck.core :refer [file-seq]])` as you did and be confident that their code will work in almost any ClojureScipt environment? &gt; Also the pure clojure version is faster -- about 8ms vs about 40ms Interesting. Is that using an evalserver to avoid JVM startup overhead and/or Criterium or somesuch?
A comparison with the already-existing [`Bread::Board`](https://metacpan.org/release/Bread-Board) would be nice.
Yes, no, yes, in that order. For your first question, I hope that's clear enough already. As for the second, Planck is one of the two (along with lumo) main runners for people wanting to do 'scripting clojurescript' (if you will). Ordinarily in a project you'd probably build with something like leiningen. It's all about the context in which your code is gonna run, I guess. As for the the third q - that's exactly what Grench is. It's just a local eval server you can spin up and send your code to to be executed. Though normally if I'm doing a scripting thing I'm probably just in the leinengen repl to begin with (or using perl6 :)) 
Yes, that would be a good idea when I'm finishing the documentation, to put a comparison option. I first wanted to let the library stand on it's own and then compare itself to others. The first reason I made the library (other than because it seemed like fun) is because when I looked for DI libraries in Perl I saw that most were oriented to map names to services. Bread::Board has a typemapping feature, although IMO it doesn't feel as integrated as the rest of the library. And even though Bread::Board can map types to services, I wanted to map Moose Roles (Interfaces) to services instead. More like how you usually see DI in Java (which, as can be seen from my username, is my background). I would say that the main difference between MooseX::DIC and other containers is that the latter starts with the idea of mapping types/roles to services, rather than names. Also, I wanted to make the library as config-less as possible, by using traits and roles to mark service implementations and mark injection points. Later during the development phase I saw a good case to also allow a configuration file, but it is not yet implemented. Still, as of now, the other DI libraries are far more feature complete than MooseX::DIC.
IMHO renaming Perl 6 to something else could do harm in a way that the "Perl" brand, although disliked by many, is still a big well-known one, without it Rakudo would have to compete on the same ground with numerous other languages. And it's already too late that people already widely know Rakudo is/was Perl 6. 
AFAIK Perl 5 is still used at universities, especially in bioinformatics. It's somewhat retreating in recent years though. Today people are using Python and R for numerical computing and data analysis. Perl has PDL but that has too small market share. I don't know much about bioinformatics, but with my experience with R and python, I think Perl misses two key parts here: It lacks a sophisticate library to support data frame, like what's in R and Python's pandas. And it lacks a high quality plotting library like R's ggplot2 and Python's matplotlib. A few years ago someone started a topic http://blogs.perl.org/users/lhermida/2011/03/hi-everyone-as-a-bioinformatician.html but unfortunately there's not much progress in this area. Another thing I thought of is that, because Python is taught to many people, and because Perl and Python are actually highly similar (once your are familar with both). Maybe someone can write a "Perl for Python programmers" ebook, and market Perl as "Python but another flavor"?
IMHO "precise math" is far from enough to attact people to Perl 6 for numerical computing. To attract more people to Perl 6 it probably need to catch the big data / ML buzz, and it needs a whole bunch of decent libraries like Python's numpy/pandas/matplotlib, or R's data frame features and ggplot2. 
&gt; although disliked by many, is still a big well-known one That was the hypothesis I heard on Christmas 2015, the first stable release of Rakudo language. I claim that hypothesis has now proven to be false. As [I attempted to explain in my full write up](https://rakudo.party/post/The-Hot-New-Language-Named-Rakudo), the "Perl" brand to Rakudo is a deadweight. Sure, it's more well-known than a new brand name, but what does that matter, if the product is not anything that brand represents? Even such basics as sigils are different in Rakudo. The only similarity is the vague "perlish" TIMTOWTDI feel of the language. It's like naming your *Coconut Healthy Milkshake* "Coke 6". Those who want "a can of Coke" likely won't get what they wanted, and those who know "Coke" as a teeth-rotting liquid candy will stay away from your health-shake. &gt; And it's already too late that people widely know Rakudo is/was Perl 6. The point of the rename is *not at all* to hide Rakudo's origins. We're not trying to hide some sort of a terrible secret. The point is to present Rakudo as a product of its own, rather than ["the next version"](https://github.com/github/linguist/issues/3637#issuecomment-319026186) of Perl, which it isn't. &gt; without it Rakudo would have to compete on the same ground It has to compete just the same with it or without it. Except *with it* it also has to explain that it's a brand new language and not just a new major version, so if you didn't like "Perl" before, you might like it now; it has to explain why it has a baby ecosystem; it has to explain why [performance and stability work](http://news.perlfoundation.org/2017/07/grant-extension-approved-perl-.html) is of high priority; it has to explain how an old-school language many think to be antiquated could possibly be a leading language in Unicode support and concurrency. In short, it has to explain why it's not Perl, after supposedly using the Perl brand name to attract a prospect. Yet those questions are automatically answered by having a unique product name: whether you like "Perl" doesn't matter; the language is new which is why: ecosystem is small and there's a lot of work still to be done; and we built it with Unicode and concurrency in mind from the start, so that's why we're good at it.
I regret that I have but a single upvote to give.
The same things I do in any other language to keep my code clean. There's nothing particularly special about Perl that makes it easier or harder to write clean code than one would in other comparable languages. Some common things include: * Sensible use of whitespace * Consistent naming/styling conventions * Quality comments * Break up functionality into appropriately sized (and named) subroutines
&gt; I always use return at the end I don't use the *"always return at the end"* and *"always used named variables instead of $_"* tips, as I believe often that simply adds more code to read instead of clarity and more variable names to typo. &gt; What do you do I... * Avoid "clever" code. * Avoid braces and parentheses when they're not required. They're just more visual symbols to process. * [Align related stuff to make visually-easy-to-parse columns of information and separate code into related groups by adding empty lines around them](https://github.com/perl6/roast/blob/cbb730238890db754ed00ce56e6253a138649e3c/S32-io/indir.t#L65-L144) * Write code that's easy to throw away * Avoid featuritis: adding all sorts of features on a whim, just because you can. An easy way to make a routine unreadable is make it accept dozens of options. That applies to all languages I write in, not just Perl, which I don't find particularly write-only-er than any other language. You can mash on your keyboard and write crap in any language. At the end of the day, I'd say what you pick as a style matter less than **consistently applying that style.**
I missed [this example](https://www.reddit.com/r/programming/comments/6pn9b5/why_im_learning_perl_6/dktv9ep/) the first time through, especially the part where [someone else calls Raiph out for the same thing](https://www.reddit.com/r/programming/comments/6pn9b5/why_im_learning_perl_6/dkuyvct/) -- probably because that discussion happened about the same time this one did.
I use return hashrefs, named input arguments (needs some boilerplate, but it's readable), and generally ModernPerl standards. A strict styleguide is a necessity for any team. 
Documenting code with comments. Perl is "write once" because in the early 2000's there were a lot of new coders that picked up Perl because it was widley used on the web and easy to learn, resulting in very poor coding practices.
It appears DNS is misconfigured. $ host -tns strawberryperl.com ns1.dreamhost.com Using domain server: Name: ns1.dreamhost.com Address: 64.90.62.230#53 Aliases: strawberryperl.com name server ns1.dreamhost.com. strawberryperl.com name server ns2.dreamhost.com. strawberryperl.com name server ns3.dreamhost.com. $ host strawberryperl.com Host strawberryperl.com not found: 3(NXDOMAIN) $
I like to use a package namespace for strings: package myStrs { sub myS1 { return "myString1";} sub myS2 { return "myString2";} }; I can then refer to the string using the package namespace: if( $myval eq myStrs-&gt;myS2 ){ #more fine logic 
&gt; Stevan Little - "Hold My Beer and Watch This!" - the talk i enjoyed the most, let's hope for UNIVERSAL::Object to get into core soon and for us to have interoperating object systems. That talk was amazing. It's such a simple idea, and yet the stuff he builds on top of it... dag.
&gt; two-level scheduling Why do you think that's not a good idea?
This specific issue could be "solved" (by some definition of solved) by very closely examining every place where -&gt;param is used, and, if there's any usage of that method in list context instead of scalar context, triple check it's doing what you want... and throw a "scalar" in front of it otherwise. A faster solution might be to modify your local copy of CGI.pm so that the param method has "die if wantarray" inside of it, and see what breaks. Any breakage can then be given an explicit "scalar", or changed from "param" to "multi_param" 
Some features of Perl 6 do look mouth-watering, particularly grammar and concurrency. For me personally, when I really need those two features, I'll write it in Perl 6. But generally, Perl 5 has served and still serves me well for now. It's nice to be able to choose. 
I mostly write web stuff. One of the biggest problems for me has been finding adequate libraries for web applications in Perl 6. Unfortunately it doens't seem to be up to scratch as what's in Perl 5 or Python, even if you're just looking for a raw FastCGI library or whatever. I've found an old PSGI interface and I managed to make it work with some help from great people at #perl6, but still things like file uploads are out of reach. I really want to use Perl 6 but what I need isn't quite there yet. One of my big draws is consistency of array addressing, the new way of declaring functions, multi-dimensional lists and stuff that looks cool that I haven't had the chance to use yet (macros, grammar). I would be using Perl 6 if the libraries were there, Perl 5 if using arrays wasn't just too damn awkward for me and I'm currently using Python because it's the easiest of all to Get It Done Quick.
Probably not. Giant legacy Perl codebase with most new stuff being written in Python. 
I'm new here and I'll learn both. If I could ask those of you who've worked with Perl for awhile; what makes concurrency difficult for Perl 5 and do you ever find yourself needing it for what you do with Perl 5? 
Same, Perl 6 performance is still slow and modules and libraries are basically not there. Perl 6 is also a completely different language. At this point, Python is much more mature than Perl 6, so if anything we would move that direction. Possibly sooner rather than later as some of our favorite modules have not seen maintenance in a few years.
Some good thoughts!
Depends on what sort of concurrency you're after. Async I/O already works reasonably well in Perl5 (see https://metacpan.org/pod/IO::Async or https://metacpan.org/pod/Mojolicious for example), although the forthcoming async/await keywords would help (https://metacpan.org/pod/Future::AsyncAwait). It'd be nice to have proper threads for distributing CPU load, but in practice I don't find that to be a problem: when I need more than one CPU, it's likely to extend past the limits of a single server too, so I tend to use something that provides job queues and worker pools.
Nah.
I've read [Beginning Perl](https://www.perl.org/books/beginning-perl/) , is it also worth reading [Modern Perl](http://modernperlbooks.com/books/modern_perl_2016/index.html)? is much different?
Surely this makes it harder to read because you have to keep going back to myStrs package? 
I'm billing out at more than that and still getting paid Perl work. The six people on my team are still doing Perl as well. It may all change tomorrow but ... Anecdotes are anecdotal.
I've said some negative things, but they have not been about this new language called Perl 6, per se. Rather, about the name, which I think it is a burden that cannot be overcome. _However_, I assume I'm eventually going to hear about some killer feature of this awesome new language that will make me sufficiently curious, such that I will jump in. But it will probably be years from now. It's more important for me to get more comfortable with the other languages that will pay the bills for me. I have to get more comfortable with node (its asynchronicity, mostly) and python (its whitespace peculiarities, mostly), specifically. Probably brushing up on my Ruby and maybe even some C#. And all this while still coding in Perl every day. There is _plenty_ to keep me occupied. Perl 6 is no more on my radar than any other language that's not got a ton of adoption behind it.
Apologies, I forgot the [configuration file](http://p3rl.org/Devel::REPL#Run-Control-Files). use utf8; $_REPL-&gt;load_plugin(qw( Colors DDP DumpHistory FindVariable History Interrupt LexEnv MultiLine::PPI OutputCache Packages Peek PPI Refresh ReadLineHistory ShowClass Completion CompletionDriver::Globals CompletionDriver::INC CompletionDriver::Keywords CompletionDriver::LexEnv CompletionDriver::Methods CompletionDriver::Turtles )); $_REPL-&gt;term-&gt;Attribs-&gt;{do_expand} = 0; The REPL plugin shows the methods etc., you can also [dump stuff directly](http://p3rl.org/Data::Printer#SYNOPSIS). Try the software listed on http://perlide.org/ or ask on Perlmonks, Stackoverflow or in this subreddit for up-to-date information.
Definitely not.
I get my news about developments in Perl from the great Perl Weekly newsletter and occasionally from conferences. Perl 5 is under active development and vibrant. Everything good from Perl 6 will come to Perl 5 eventually. So, why get lost on unknown grounds if your toolset is up and running?
For what it's worth I haven't fully read modern Perl, but it is worth a skim just to get a feel for the style recommendations.
It's worth pointing out Perl and "Perl 6" ([or Rakudo](https://rakudo.party/post/The-Hot-New-Language-Named-Rakudo)) are different languages, both actively developed. Asking if people plan to "move to Perl 6" is not much different than asking if people plan to "move to language X". There's a third option your question omits: using both (or more) languages. I tend to write all the new stuff in Rakudo because it's much more concise than Perl. However, it's not even 2 years old yet (first release was December 2015), so mature and well-designed libraries are tough to come by. Recently, I had to deliver a largish web app on a very short deadline, so I wrote it in Perl and the extremely well-polished Mojolicious/Mojo::Pg, simply because I didn't have time to yak shave or risk uncovering some critical bug (my last Rakudo web app leaked a lot of memory with one of the thirdparty modules being suspect). At the same time, I have a ~110,000 line Perl web app that I'll be slowly converting to Rakudo, to reduce its size and I've been using Rakudo for all the smaller stuff for awhile now. The One Language To Rule Them All is a flawed ideology IMO and you'll notice people who learn only one often have lengthy discussions about employability merits of language X and will defend it to the death, flaws and all.
&gt; modules and libraries are basically not there Can't see how this would stop anybody. There is Inline::Python and Inline::Perl to use Python or Perl 5 modules from Perl 6. &gt; Perl 6 performance is still slow Could be so, yes. Do you have any examples? A lot of the times you can simply use native ints and your code will be much faster, well, if you really need it. Also, “slow” by how much? And what rakudo version are you using?
As a long time P5 and P6 (since 2010ish) user I'd gently suggest that "moving" to P6 is both a false dichotomy and a dangerous precedent to set. Perl 6 is largely about interoperability at its core. The age of one language to rule them all, is very much over. There's a reason "web developer" has now become "full stack developer", beyond companies just cheeping out. There are languages you cannot easily get away with ignoring like JS, simply because of use case. But I'd say Perl 6 among many other languages around right now, including P5, will be one of the ones many will choose to not ignore, just as an additional useful tool in the box. For their own sake, not for any other. Many people digging heals in from the P5-only 4eva camp are stubborn enough they didn't already move into other languages that had something to offer and teach them, such as Python or Ruby. Many even refuse those lessons back ported, things like Moose for example. Asking for their opinion is like asking a troll what he thinks of the underside of a bridge vs what's on the other side. Obviously the beautiful buttressed gothic architecture under the bridge is under appreciated, but the colourful and diverse party that goes on every Friday over the bridge is slightly more engaging. If you like anything other than just gothic buttresses and gargoyles at least. The people at the party also have no idea about gothic architecture or how cool gargoyles are, because the trolls never venture out. I've written more P5 than anything else until about two months ago when I switched to doing Python daily. This wasn't some sudden switch, or an active choice of replacing P5. I already learnt Python and used it a lot for data science and plotting tasks. My new job involves almost 100% data science and analysis. Python simply has nicer libraries and community support for this. I still write P5 scripts, including recently a quite useful recursive descent parser to convert CQL into Python model classes for Cassandra! I might eventually port this to Python simply because thats the target language of the output. Quibbling over language primacy is like fighting over what's better screws or nails, when your attitude is a sledge hammer. If all you care about is smash it out corporate style programming, the language is fairly unimportant compared to culture and tooling. We need to stop thinking as if a programming language has some absolutist measure of "goodness", rather than fit and purpose. Perl 6 fits many of the same spaces as P5 -by design- but its gone there deeper and more consistently in specific places such as Grammars. You can even get most of that functionality back ported to P5, you just lose some syntax and sugar. If its a task you do once in a blue moon, then sticking in P5 with some clunk is a good idea. If you do it daily as your main work P6 is worth a look etc.
1. A well-designed database module. 2. ??? 3. Profit! [`Mojo::Pg`](https://metacpan.org/pod/Mojo::Pg) is just pleasure to work with. While Perl 6's only offering is `DBIish` and I have [concerns](https://github.com/perl6/DBIish/issues/77) about its mere installation, never mind its interface.
In general, I miss a good integrated debugger, in the way the Perl debugger interacts with Emacs and other editors. That would go to number 2 and 3 also. Or maybe number 3 would be a good book that explains how to write web appications with perl6. ;-)
A killer app. Some big, revolutionary framework that draws in new people, gets them to fill in all the gaps in Perl6's module list, and starts a virtuous cycle of drawing yet more people in. That said, after banging my head against the desk trying to explain floating point errors to my coworkers ("it's just 1 / 10, why can't Perl5 do simple math correctly?"), I'm ready for Rationals.
Have you tried `perl6-debug-m`? It comes with standard Rakudo installation and needs [`Debugger::UI::CommandLine` module](https://modules.perl6.org/repo/Debugger::UI::CommandLine) installed.
perl6-debug-m does work, as advertised, but it's clumsy. Most importantly, you have to quite the program to restart a run. It's purely stand-alone, no interactino with emacs ... perl5 debugging under emacs is a joy.
So, how do you attach the debugger to a running perl program? I am not able to find anything in the help from `perl -d`.
The inner values are hash references, you need to dereference them first: #! /usr/bin/perl use warnings; use strict; use Data::Dumper; my %all = ( 'urls' =&gt; { 'successUrl' =&gt; 'success.pl', 'failureUrl' =&gt; 'fail.pl', 'cancelUrl' =&gt; 'cancel.pl' }, 'data' =&gt; { 'id' =&gt; '19', 'title' =&gt; 'life of brian', 'description' =&gt; 'Monty Pythons best movie' } ); my %urls = %{ $all{urls} }; my %data = %{ $all{data} }; print Dumper \%urls, \%data; 
my %urls = %{$all{'urls'}}; my %data = %{$all{'data'}}; $all{'urls'} and $all{'data'} are hash refs - single scalar values. You need to convert a hash ref into a full blown hash to assign to a hash. And that's probably not the right technical explanation because I feel the word "list" needs to be in there someplace, but logically, that is what's happening.
Perfect, thank you!
$all{'urls'} is not a hash, it's a hash reference; use $urls = $all{'urls'} or %urls = %{$all{'urls'}}
In emacs, type M-X perldb (M ==&gt; esc, sometimes you can use the Alt key) Emacs will offer the full path to the current file ... or the command line from last time, if you've already run an the debugger from under emacs in this session ... In that case, you have to edit the line to the current desired path. Emacs will remember and you can up-arrow to earlier command lines. You need to include the command line options on this command lines
To add to others' comments. Newer perls offer nicer syntax for dereferencing: use 5.026; my %urls = $all{urls}-&gt;%*; my %data = $all{data}-&gt;%*;
I've not read Beginning Perl, but I did read Modern Perl and I liked it, so I'd recommend reading it ([digital version](http://onyxneon.com/books/modern_perl/index.html) is even free to read).
Inline does work, but then we have to manage two languages. We tested Rakudo in Fall of 2016 and there were lots of performance gotchas all over the place. At the end of the day we will are transitioning to Python. Python is not my favorite language, but the performance hit of Moose in Perl5 is getting annoying, whereas OO in Python is much better. Not that Python is perfect, but it is not able to take over 95% of our need for R, so we can do just about everything in Python instead of Perl and R.
(Disclaimer: I'm not up to date with the Perl6 tools, so those things might exists): 1. A well-designed database module (DBI works for me) 2. A good Dependecy Injection Framework (like Bread::Board) 3. PSGI (I remember some tries to port it / come up with something better, but don't know if anything already exists) I don't need "Web Frameworks" (like Catalyst, Dancer etc) because "web" is only a part of the apps I write. I need "App Frameworks" (hence DI-tools like Bread::Board) edit: here's a longer write-up: [https://domm.plix.at/perl/2017_08_what_i_expect_from_a_web_framework.html](https://domm.plix.at/perl/2017_08_what_i_expect_from_a_web_framework.html)
Don't think you can do that.
Where "newer Perls" means 5.20 (if you don't mind jumping through all the `use experimental` hoops or 5.24 for the non-experimental version. (Felt it was worth clarifying as your `use 5.026` slightly implied that was the required version.)
Plug: for starting a debugger session in Perl 5: if you're not just using a simple script in the current working directory, PerlySense makes it more usable by running from the correct directory and setting up @INC. https://metacpan.org/pod/Devel::PerlySense#Debugging-Code 
&gt; the performance hit of Moose in Perl5 is getting annoying It is. "use Moo" unless there's a particular reason to "use Moose". 
What benefit is there to this? What downsides? (I can see one benefit, but I'm curious about your perspective)
Newer versions of the module warns. So a cpanm or manual install of the pure-Perl module could be useful.
I'm excited about Perl 6 but it really really needs some GUI library. 
I already tried Perl 6 as a toy and I enjoy programming in it. I use Perl 5 to analyze multi gigabyte ASCII text files for work, I would move to Perl 6 when it will be fast and practical to treat text as ASCII (vs Unicode) and execute the most simple regexes on it at least as fast as in Perl 5.
&gt; &gt; &gt; Many people digging heals in from the P5-only 4eva camp are stubborn enough they didn't already move into other languages that had something to offer and teach them, such as Python or Ruby. Many even refuse those lessons back ported, things like Moose for example. Asking for their opinion is like asking a troll what he thinks of the underside of a bridge vs what's on the other side. Obviously the beautiful buttressed gothic architecture under the bridge is under appreciated, but the colourful and diverse party that goes on every Friday over the bridge is slightly more engaging. If you like anything other than just gothic buttresses and gargoyles at least. The people at the party also have no idea about gothic architecture or how cool gargoyles are, because the trolls never venture out. Unnecessary.
Does anyone know of problems (preferably known actual practical problems, not theoretical ones) when using these P5 packages in P6?
I would like to see ORM for perl6. Like RDBO (Rose-DB-Object) or DBIx::Class. And think that currently there's no web framework similar to p5's Mojolicious... It's real omission.
FWIW a P6 ASCII module: https://github.com/ronaldxs/Perl6-US-ASCII/
&gt; Anecdotes are anecdotal. Definitely. I'm not suggesting there's no market for Perl, but I've noticed it much easier to get paying work for other languages.
Haven't used these particular modules, but overall, I somewhat wish Inline::Perl5 didn't exist. It's a hackish solution in production app context: putting all eggs in one basket (and mainly relying on its single developer) while adding a whole 'nother language to the app's dependencies and requiring the developers of the app would be somewhat fluent in Perl as well as Rakudo. There's also a very real risk of encountering something that Inline::Perl5 doesn't support that makes a feature of a module unusable, which could be show-stopping. I recall being unable to pass a regex object to WWW::Mechanize, for example, rendering large portion of its API out of reach. Yet because *some* things are possible to do via Inline::Perl5 route, there's lesser motivation for developers to make proper Rakudo solutions, which IMO stunts the ecosystem.
I'll try to be constructive here. I've stopped looking at Perl 6 because the last few times I have I've come away thinking it's too complicated for me. For example, I recall being stuck on Arrays vs List vs Sequence vs Slip, plus `$arr` vs `@arr`, and flattening. I can't recall what else, but I recall feeling like there was a lot to be confused about. I get the impression that lots of people friendly towards Perl 6 feel this way, and yet still most of what I see online about Perl 6 is yet another golf solution. It's funny; one of the stated goals of the project has always been to provide easy on-ramps, and yet **there's no authoritative rock-solid tutorial**. I'd always thought that maybe the project leaders were waiting to create one until performance was there, but now I wonder if maybe the language is too complicated to boil down to a definitive tutorial. And, if so, it's not the language for me. **Edit:** Really, the longstanding attitude I've seen about an official tutorial is that there currently isn't one. There's always been an invitation for newcomers to write one. The Perl 6 road is littered with past attempts at writing one. I've seen many Perl 6 *examples*. Lots on rosetta code. The previous (older now, defunct) Perl 6 book wasn't a tutorial either, but rather a "project" book. There's lots of videos floating around. But I can't imagine how a project that actually *wants new users* doesn't have an official (as in, written by the dev team) bottom-up high-quality written tutorial that explains how the thing works. Larry is an amazing, thoughtful, and humorous writer. TheDamian is an extremely talented writer, and is even occasionally on this end of the galaxy. Yet no tutorial. It boggles my mind. 
I'd love to see if Bailador could provide you the features you need for the app development part. I'd love to work with you to define the needs there.
&gt; I've stopped looking at Perl 6 That's too bad. Have you seen [Perl6Intro](http://perl6intro.com/)? I was under the impression that was the "official" intro tutorial. It's the one being shipped with Rakudo Star distribution. The other "official" tutorials are in the [`Language` section of the docs site](https://docs.perl6.org/language.html). And there's [a bunch of current books](https://perl6book.com/). Compared to 2015, in 2017 I'd say we're much closer to the finish line than to the start line, as far as documenting/tutorialing everything the language offers. &gt; For example, I recall being stuck on Arrays vs List vs Sequence vs Slip, plus $arr vs @arr, and flattening. Yes, that's a common stumbling block. I feel the cause is people try to over-explain these, yet often fail to mention the very important missing link: containers. &gt; Perl 6 examples. Lots on rosetta code. Those are shit. The code is often deliberately mutilated to demonstrate as many "cool" features of the language as possible. &gt; maybe the project leaders were waiting to create one [...] official (as in, written by the dev team) No, no one is waiting. It's more of a everyone-helps-out-a-little effort, with the materials being available on [the docs site](https://docs.perl6.org/). If you feel something's missing, you can [open an Issue on the docs site](https://github.com/perl6/doc/issues) so the volunteers are aware of what needs improvement. &gt; now I wonder if maybe the language is too complicated to boil down to a definitive tutorial No, it's not complicated—I'd dare say it's simpler than Perl—however it is *big*. For example, what Perl ships in separate modules like `Moose`, `List::UtilsBy`, `Mojo::Collection`, `Math::BigRat`, `Mojo::IOLoop`, `Future` and a dozen of others in Rakudo are all included in core, as a hierarchy of core types. A Perl language tutorial won't go into details for all those modules, but would you expect a *single* Rakudo *tutorial* to go into all those details? Not every program needs grammars; not every program needs concurrency; not every program needs to know how to make custom Iterators. IMO the correct approach to learning Rakudo is not to seek The "Official" tutorial that teaches you absolutely everything in one go, but read [the Language tutorials](https://docs.perl6.org/language.html) gradually, while accompanying them by [the type reference](https://docs.perl6.org/type.html), while looking at [others' blogs](https://rakudo.party/) that explain how to fully use those types and techniques. Treat the features of the language same as you'd treat those modules in Perl: Learn `Moose` when you need OO; learn `Future`/`Mojo::IOLoop` when you need futures/concurrency, etc. &gt; It's funny [...] yet there's no authoritative rock-solid tutorial [...] Yet no tutorial. It boggles my mind. Well, come [join our dev team](https://webchat.freenode.net/?channels=#perl6-dev) and help us out, maybe? :)
sane syntax. perl6 is perl5 on steroids in terms on unreadability. why ? this is the reason python ate perl's lunch.
&gt; in terms on unreadability. why ? It's very readable, once you know the language, as there's a lot of consistency throughout the syntax. The argument that a language is more readable if it uses long alphabetic strings instead of short non-alphabetic characters is a red herring, as in the former case the person unfamiliar with the language would still need to learn the meaning of the function and how it operates on the arguments to correctly read the program. And my programs are way more often written by a programmer who knows the language than read by one that doesn't, so I much rather the language optimizes for the former case. Python looks as much a line-noise to me as any other language I'm unfamiliar with. Just as Rakudo did, before I learned it. I much rather type `.map: *²` to write a lambda than `.map(lambda x: x**2)`. I don't care if someone who doesn't know the language doesn't know that `*²` in that context is a [`WhateverCode`](https://docs.perl6.org/type/WhateverCode) closure. Those people aren't reading 99% of the code I write; but I write 100% of that code.
You know, this was not the question I asked, but if you feel the urge to troll us, enjoy!
There was to be a tutorial book released concurrently with Rakudo Star (the first official Star release), but it stalled out at 60% of a first draft. That's probably my biggest disappointment about Rakudo Star. I wanted a solid tutorial we'd have been proud to publish as a printed book. Years later, Rust would get this very right. Writing good documentation is difficult and keeping it current is time consuming, but it helps get and keep users even if library support, performance, platform support, and community size all need improvement.
Thanks. Nevertheless I misread your post. I thought you were talking of jumping into a running script, as it is done with `gdb`.
Is it just that the DBI is "too big" and "Perl 5" to port to Rakudo? I would say: * solid DBI layer * solid web or application framework (big fan of Mojolicious) * solid "learning" docs 
It's more of a "too many cooks" issue and looking at module's age, it's not surprising (it's about 5 years older than *first* stable language release of Rakudo). So you have a purely Perl-ish interface that was later mutilated to support more of Rakudo's features and you have this Frankenstein at the end. The module can't even decide whether to use `snake_case` or `kebob-case` in its method names. As for the installation issues, when I reach for a module to handle my SQLite database, I don't want it to be creating and dropping tables in my Pg and MySQL databases just because I have them installed. This practice already allegedly [damaged user's production database](https://github.com/perl6/DBIish/issues/77), and one of the authors' replies to that was simply blaming the user for everything.
&gt; Have you seen Perl6Intro? I was under the impression that was the "official" intro tutorial. Yes, I've seen it, and I like it. But it only briefly touches on many aspects of the language that would need more coverage in a full tutorial. Like it says in its name, I think it's more of a quick intro than a tutorial. &gt; The other "official" tutorials are in the [Language section of the docs site](https://docs.perl6.org/language.html). There are good articles in there with good content. And I know that, over time, substantial effort was made here and there on various articles to get knowledge written down (I think I recall Moritz putting lots of time in). That said though, it's not a tutorial. &gt; And there's a bunch of current books. Yes. I haven't read them, but my understanding is that none of them serve as an authoritative rock-solid Perl 6 tutorial. I don't want to attempt to do any armchair reviews of these books but I do know that writing good tutorial content is very difficult. I've known many devs over the years who were fanstastic programmers but who had a very difficult time writing good tutorial content. &gt; Compared to 2015, in 2017 I'd say we're much closer to the finish line than to the start line, as far as documenting/tutorialing everything the language offers. But that's the thing; no one fired the starter pistol, and the runners don't have a map of the course. &gt; &gt; maybe the project leaders were waiting to create one [...] official (as in, written by the dev team) &gt; No, no one is waiting. It's more of a everyone-helps-out-a-little effort, But that's not how tutorials work. If I create a complicated project that I want people to use, I write a tutorial. The creator of the project has all the inside knowledge, all the reasons *why* things are the way they are. They know how the parts fit together (because they had a hand in writing them) and also have the big picture. You can't expect a good writer from outside the project to come along, study the source code, study the existing docs, and then spend countless hours on IRC trying to determine all that aforementioned stuff which the creators already know just so they can have the privilege to write the tutorial. &gt; No, it's not complicated—I'd dare say it's simpler than Perl—however it is big. That's good to know, but the perception (IMO) is that it's complicated. My perception is that it's complicated. &gt; Not every program needs grammars; not every program needs concurrency; not every program needs to know how to make custom Iterators. IMO the correct approach to learning Rakudo is not to seek The "Official" tutorial that teaches you absolutely everything in one go, but read the Language tutorials gradually, while ... An "official tutorial" doesn't attempt to teach everything in one go. What it does is lead the reader to understanding, while also pointing out along the way "you'll use this all the time" and "this part you probably won't need for a while, so we're skipping it". When I finish a good tutorial, I feel like I not only know the basics, but know what I know and what I don't know. The official Perl 6 language docs are a big pile of documents, of varying quality, written by various authors, unordered, with little context about what's everyday basic need-to-know stuff and what's stuff that can be skipped for now but you should konw it's there. &gt; Well, come join our dev team and help us out, maybe? :) Thank you for the invitation. I've tried in the past, but found that it turned into me spending lots of time on IRC asking questions and being told to read the docs, read the design docs, read the tests, and painstakingly learn the language without the tutorial so I could be the one to write it. This doesn't work. I have no idea why Larry et al would want someone to follow that course and produce a half-baked tutorial when it's their project and they could do a much better job themselves. Sorry if that's ranty, or a wall of text. Writing is hard! 
The account got suspended. http://strawberryperl.com/ now works again (although https is b0rked). We're working on getting it onto more reliable infrastructure seeing as the domain owner is no longer really active in perl-land.
&gt; Sorry if that's ranty, or a wall of text No, I think this is very useful feedback. Thanks. Lots of good points and I'll be sure to keep them in mind as we move forward. 
I read that ticket thread. Yikes. That should never happen.
&gt; &gt; sane syntax. perl6 is perl5 on steroids in terms on unreadability. why ? &gt; It's very readable, once you know the language, as there's a lot of consistency throughout the syntax. I've seen this question and response many times over the years wrt Perl 6. Unfortunately, it's not very helpful to the person who made the quip about wanting sane syntax. You're asking them to take your word for it. What's missing from the reply is, "Here's the [official tutorial] -- give it an evening/weekend and then see what you think.". By the way, one way to score a tutorial is to have a new user read it and record the number of times they think, "Wait, what? Hold on. Why does $x mean that?" or, "Wait, but what about $y?". If there's more than a couple of those moments, you'll lose the reader. The perls6intro, while a very nice intro, has too many of these (of course, not a bad thing, since it's not really a full tutorial). 
&gt; By the way, one way to score a tutorial is to have a new user read it and record the number of times they think, "Wait, what? Hold on. Why does $x mean that?" or, "Wait, but what about $y?". If there's more than a couple of those moments, you'll lose the reader. Noted. Thanks.
Don't be so quick to dismiss though. sergeykolychev is telling you that the syntax looks unreadable. I see comments about Perl 6 like this a lot. If Perl 6 is to survive, it's going to need a better answer than "you're just trolling" or "it makes sense once you learn it". 
I work with perl5 for 19 years. I love the language though recently I find it hard to express some of the python ideas as succinctly as python does. Sorry, Perl 6 syntax is just a line noise: who thought having this: $*foo $!foo $?foo $.foo $\^foo $:foo $=foo $~foo to denote different meaning is a good idea ? No intention to troll you though, but I do not believe there's a bright future for Perl 6.
Suggest having those wtf sessions be pairs, novice and expert, and *tape them* (i.e. microcassette, podcast-recorder, whatever). Collect a few of those. After, have writers listen to those tapes and derive doc-backbone and -extensions from the commonalities.
Mouse faster than Python though.
I've only spent a few days discovering Perl 6, but the big problems I have with it are Rakudo performance (startup time especially) and lack of _coherent_ introductory documentation. Just one example: it took me a long time to find out how to write to stderr. After a long time on Google I eventually just tried something that turned out to be correct. There aren't language features that I'd add. In fact, I think the language is rather bulky as it is already. I'd much prefer a simpler language that still has the core innovative features that have always made Perl stand out. Grammars are great! Sigils? Twigils? Three different ways to make a closure? Not so much... I'll paraphrase Rob Pike, who in a talk about the Go programming language outlined why they wouldn't add new features. He gave the example of the cartoonish Gopher logo, which is also very simple. Adding new features, he said, won't make it a better mascott, it'll just add hair. _Perl 6 is one hairy language..._ So: improved performance, coherent documentation, and a razor.
I do not really think this trolling. Syntax is usually one of the top complaints from prospective new users. The fact that there is an effort to move away from the Perl name, should show how important syntax can be. Don't get me wrong, I really like Perl and it's expressiveness and try to use it whenever I can. Its just hard for me to understand some of the Perl 6 decisions. Getting rid of backticks and the diamond operator, while keeping some things and adding others is weird to me. Admittedly I have not done, much more than run a couple simple things and read some documentation, but what is Perl 6 going to look like in 5 years? How many more special variables and other things are going to be added. Scripting and calling system commands is one of the best things about Perl. It is so much nicer to write Linux scripts in Perl than Python. Perl has sane system function defaults, its terse, and the text parsing makes things a breeze. Perl 6 just does not seem like it will be a viable Linux scripting tool for me :( Ruby seems closer to Perl 5 in this regard. Honestly what is really holding me back from making the plunge is the attitude given to anyone who brings up their concerns.
In a nutshell, scheduling policies aren't composable. Practical upshot is that threaded programs will exhibit different flavours of nondeterminism (or "clang") depending on how the kernel scheduler ends up interacting with the threadlet scheduler. For current examples, see various VM solutions' hacks to prevent poor scheduling from guest kernels being scheduled as applications. I don't see userspace hacks being the proper solution to threads eating up a kernel stack each, causing a systemwide upper limit somewhere. It's like recycling waste that shouldn't've been created.
If you try to have multiple schedulers working at the same time like in your example, I can see it. But in the case of M:N threads, I don't see how does it apply because the application scheduler just moves things in and out of the pool based on them being blocked or not.
The author has some really good points here that I've also heavily struggled with since ~2015 and one reason I'm not writing a lot of Perl6 at the moment. Perl6intro is fantastic, but is kind of like perl6 basics from 20,000 feet. We have great books now (Think Perl6) to name one and more on the way, but those are also not a true tutorial /doc site. I'd write them myself, but like the commenter said, I have to learn it first and don't have the time to do so in the same manner as the rock stars on the core team have gone about it. That's why I was trying to convince someone in the community with significant perl6 skills to start a YouTube tutorial channel with each video covering core parts of the language (branching, subroutines, concurrency, grammars, macros, custom operators...etc) that link to the perl6 site. I do know of the major drawback that said contributor would have to then give up valuable time on the language itself. I think it would help greatly with adoption though which later helps with libraries and documentation...etc. Thanks for all your hard work btw. There's a lot of great new languages out there at the moment, so I'm currently keeping tabs on a few that I like to see which end up at critical mass. I hope perl6 gets there.
What about something like this one (just came out): [Think Perl 6](http://greenteapress.com/wp/think-perl-6/) : How to Think Like a Computer Scientist
The whole "but perl6 has Inline::..." argument baffles me. If 50% of my p6 code is going to Inline::Perl or Inline::Python, why not just write it all in Perl5 or Python? Besides, Perl5 and Python is already installed everywhere by default - you know how hard of a sell to a manager it'd be to justify rolling out Rakudo to thousands of systems so you can run inline python code? 
Tidy and neat? [PerlTidy](https://en.wikipedia.org/wiki/PerlTidy) or at [PerlTidy](http://perltidy.sourceforge.net/) for new code and [Perl::Critic](http://search.cpan.org/~petdance/Perl-Critic-1.130/lib/Perl/Critic.pm) for old code. Also, a snippets file of idioms I frequently use, extracted from a large steaming pile of old code during an overhaul, all formatted with PerlTidy and that pass Perl::Critic cleanly. Getting all the framework and boilerplate out of the way, and in the same way for every script or program lets you concentrate on the parts that are different, and on choosing good names for variables :-)
I use the Weather Underground API directly in my [irc bot](https://github.com/Grinnz/maverick/blob/master/lib/Bot/Maverick/Plugin/Weather.pm). I may spin out that webservice functionality like I did with twitter at some point but the [API docs](https://www.wunderground.com/weather/api/d/docs) are useful.
I can't think of any practical benefit, but an immediate downside is that these subroutines are not constant-folded as a literal string would be, and thus result in an unnecessary subroutine call. If given the empty prototype `()`, they would be, though. In this case it's the same as using the [constant](https://metacpan.org/pod/constant) pragma. However, method calls also can't be constant folded (and are even slower than a regular subroutine call because they need to do method resolution), you'd need to call it as `myStrs::myS2` to avoid the overhead. Another downside is that someone reading your code has to go look up what the hell these constants are, instead of just reading them in the code. Constants like this are useful to avoid "magic number syndrome", where you have unexplained integers littering your code, but strings are usually self-explanatory.
Like most words people use to express themselves. I'm not programming here. I think it's a relatively fair criticism of the entrenched Perl community there is a stalwalt group of people who have little to no experience of a wider world of programming. But proclaim forcefully and loudly it must be worthless. It's a toxic echo chamber. When you bring something harsh to the table chromatic, I try to really listen to it, because you've been through the ringer of Perl 6 and you work in other langs. When I see the majority raising a criticism on another language in this subreddit... the commentor usually demonstrates immediately they're not speaking from experience. Or from a place of even having an open mind. It genuinely destroys me. But I think it is worth raising, because I'm tired of the formulaic way discussions go about anything otherly. I guess its in the name /r/perl and I should adjust my expectation. The OP is soliciting almost directly this sub community though. Without necessarily being aware. They're certainly outside of it, given they're coming back from Python and playing in P6 enough to find the rough edge. Which Perl 6 certainly has, but is rarely used in criticism by but a few, which sadly some P6ers slam for fear of the trolls, and thus the circle is complete. I include myself in the misbehaving sixers too. I'm tired of my own behaviour as much as anyone's.
That's what I use, but there's no good integration with emacs. Or no integration at all. 
I was talking about Perl6; I use perl5 debugging in emacs and it works pretty well. Will try this one, thanks for the recommendation. 
Yeah it would be nice to have a perlish Swing equivalent both in P5 and 6. In the P6 ecosystem there are bindings to a couple of lesser known widget libraries. As well as a GTK3 binding https://github.com/perl6/gtk-simple A little bare bones though.
I should start a mailing list. This is where I've been at for about a decade 😆 The IO has recently improved though, and is perhaps worth another look. Zoffix recently overhauled almost everything IO related and jnthn optimised one of the IO iterative bits of code I think `for lines()`. If you tried in the last month that's the improvement though. Multi gigabyte is still quite slow to just iterate through discarding lines compared to P5. Ruby sits between P6 and P5 speed though. So "acceptable" doesn't necessarily mean as blistering as P5 in the eyes of the dev gods. Perl 5 is actually fairly incredible on raw IO perf compared to other langs. P.S. set the fh encoding to something like latin1 'ISO-8859-1' then you avoid the overhead of normalisation per line. Jnthn pointed this out during my benchmark. I think it saved around 5-10%
Namespaces are a good thing. String maintenance is easier. The advantage of doing this becomes clear when you need to maintain a large number of strings, or do localisation. These are concerns for large codebases. The syntax doesn't use a sigil, so there is less "line noise". Another benefit is that Geany (my preferred Perl editor) does code completion for the part following the arrow -&gt;. 
&gt; how do you attach the debugger to a running perl program? http://p3rl.org/Enbugger
I don't see anything compelling enough in Rakudo to pick it over Perl or other widely used dynamic languages. If I was going to transition to another dynamic language, it would be for more engineering effort and library availability. So javascript wins there. But I'm more interested in transitioning to a non-dynamic language like Rust.
Every single time I set aside a block of time and want to get things done, I encounter a hurdle I cannot overcome on my own. Most of the time, it was broken or insufficient tooling. I ask around for help, file bugs, but the turn-around times are atrocious. This is super frustrating, my attempt is wasted, and I suspect the problem is systematic. Newbie friendliness is lip service, afaics there is no culture of uplifting the non-experts because only masak ever championed for me.
I was looking at some tasks in the area of machine learning and bot writing. There was no perl version of the APIs, only Python. If Perl6 really makes it easy to use Python APIs/libraries from Perl, that just might be enough to win me over. Particularly if I can make some kind of automated import. I remember how h2xs made it easy to use C libraries from Perl, and I am convinced that was a major factor in it's adoption. So I'm hoping history will repeat itself in a good way.
&gt; We're not in the top 10 of the Tiobe index anymore So what? 
Having been both in the in and outgroup with P6, I feel keenly aware of how much "it's just trolling" is used to ignore outgroup opinions, unless there's a fun technical workaround (optimization, rewriting a feature, starting a new project). Someone mentioned this idea in another thread about documentation, that newcomer impressions can be valuable if you're willing to dig for what they mean. For example, a really old Perl book from the late 90s says something like "If you assign an array to a scalar, you'll get the count of the number of elements in that array. Hopefully this bug will be fixed in a new release of Perl." That sentence rattled around in my brain for at least a decade until I was writing Modern Perl, which is why the book explains context as a distinct design concept so early.
It's being used less, hence fewer new projects. Jobs will become just supporting legacy stuff in an environment. Think Cobol. Remember the last hot new Cobol project being developed? Me either.
&gt; We're not in the top 10 of the Tiobe index anymore &gt; It's being used less These two things are not the same.
My bad. False alarm. More and more people are using Perl everyday. There are no problems.
You can both be right. And you are.
Wonderful! It is amazing!
You can use python libraries from Perl 5 as well with [Inline::Python](https://metacpan.org/pod/Inline::Python). I've used it once a long time ago and it worked decently. I think I ended up just rewriting the python library in Perl though. You are always going to have additional complications when you want to use a whole other interpreted language, the easiest external libraries to use are actually those that compile to machine code via [libffi](https://metacpan.org/pod/FFI::Platypus). This is even a way simpler way to interface with C libraries, no XS code is required. I believe Rakudo Perl 6 also has libffi support.
Though I am biased, I believe [Perl::Critic::Freenode](https://metacpan.org/pod/Perl::Critic::Freenode) is a much more worthwhile policy set for "clean" perl coding. The core perlcritic policies are based on PBP and many of them recommend outdated, harmful, or unnecessary practices. Perltidy configuration is much more specific to the preferences of the project owners, but it is a very useful tool to keep a consistent formatting style.
Well, then... Thank God I'm an atheist.
I updated [chocolatey Rakudo Star](https://chocolatey.org/packages/rakudostar) to make it easy to [install Rakudo on AppVeyor](https://www.learningperl6.com/2017/04/02/rakudo-star-on-appveyor/).
Oh come on. "PERL"?
I thought that was by the Babylon Bee.
A special note that using `$_` sparingly is a good idea for more reasons than just tidiness. `$_` like other punctuation variables is a superglobal, which means that anything that accesses or modifies it is using the same variable. This is usually not a problem as for example `foreach` loops localize their changes to `$_`, but any manual assignment to `$_` will mess up any following usage of `$_` which may not even occur in the same file. A particular offender of this is a while-readline loop, also known as `while (&lt;&gt;)`, which assigns to `$_` on each iteration but does *not* localize that change. Somewhat contrived example, but this issue is very easy to encounter in real code: sub get_file_lines { my $fh = shift; my @lines; while (&lt;$fh&gt;) { push @lines, $_; } return @lines; } foreach (@handles) { my @lines = get_file_lines($_); print @lines if -s; # oops, $_ is now undef from the while loop } print join ':', -s foreach @handles; # oops, all of these are undef now Easily fixed by changing the while-readline loop condition to `my $line = &lt;$fh&gt;`, but the foreach loop can also defensively use a lexical loop variable to avoid the issue.
I'm just not sure what was the point of bringing this up here. It needs to be noted also that many in the Perl and Rakudo communities are not this way.
I don't think you're missing something. Code tends to expand then contract as you realize some things don't need to be special cases.
If perl 6 is going to survive it may be in the analytics space. Perl 6 grammars and m:n threading will hopefully lead to a killer app. dsl's or libraries in this space would play a role similar to CGI back in the day. What the language really needs is an evangelist equivalent to Randal Schwartz in the early days. 
The deadly sin is actually spelling Perl that way.
Exactly.
Exactly.
&gt; Does anyone know of problems... One short-coming of Inline::Perl5 is that - as far as I can tell - there's no way to access the underlying data (typically hash) of an object. (eg. `$obj-&gt;{slot}`). Unfortunately some modules have designed their API around pointlessly returning a blessed HASH ref, but providing no methods to access those slots. The one I most recently encountered was [Spreadsheet::XLSX](https://metacpan.org/pod/Spreadsheet::XLSX). Of course there are alternatives to that module, such as [Spreadsheet::ParseXLSX](https://metacpan.org/pod/Spreadsheet::ParseXLSX) or [Spreadsheet::Read](https://metacpan.org/pod/Spreadsheet::Read), though that may not be the case for every module you encounter like this. Alternatively you could write a P5 wrapper module, maybe use `sub AUTOLOAD` to punt unknown methods to return the slot of the same name... but not everyone would bother.
Eighth way to win
Pope-Excommunicated Report Language 
Someone gave Flash some break with this article.
* Speed * universal availability * a better mascot /s I admit I haven't checked in a year or so, but even simple algorithms would run an order of magnitude slower than perl5 (even excluding startup time), and that's unacceptable for things that actually get used in the wild. That may be a problem on my end, since I've spent over a decade building an intuition for what is fast and what is slow in perl5 and don't have that in perl6 yet. But if it turns out that all the cool features that actually make the code more idiomatic are slower than writing C in perl6, then that's a problem. Universal availability is important because simply whipping up a script to do useful stuff is what filled my knowledge back then. There's always a /usr/bin/perl. This is not something that's easily fixed of course. But it sure contributes. Oh and I'll just say it: I never liked Camelia. To me the mascot is a giant image damage. It looks like a toy. The language is not a toy and some of the concepts are pretty awesome. Grammars alone should be a killer feature for every application that needs parsers. Half of the security issues out there are buggy state machine parsers. Type hints should make it possible to write integer crunching that approaches python speed, something where perl5 always struggled. That's not what Camelia looks like though. Not if you come from an O'Reilly book cover as your mascot.
[Yes!](http://backpan.cpantesters.org/authors/id/J/JM/JMCNAMARA/Acme-Inline-PERL-0.01.readme)
Could you point me at something you consider a good tutorial elsewhere? I'm familiar enough with P6 to perhaps give it a go as a first pass translating the semantics of another perceived good tutorial into Perl 6. I'd have said Perl6Intro is pretty good if you already know how to program quite well. Are you after specifically insight into programming alongside P6 simultaneously. Such as advice on *why* you would perhaps use a Bag rather than a Hash etc.
"sitting through four microbiome lectures" that sounds interesting and if the university finance committee will explain how the university finance work I might volunteer for punishment
I hear the ninth is hijacking scroll behaviour.
That one scrolls you down directly to the bottom-most pit of hell! 
I'd rather laugh with the sinners than die with the Pythonistas...
Funny, I was just looking at Perl swag. I used to have a Perlmonks hoodie. Couldn't find anything. 
Python programs have invisible problems (significant whitespace). 
There were Perlmonks hoodies? Maybe that should be my next retro Kickstarter!
This would have made sense with the previous Pope, but Pope Francis would counsel compassion and inclusion. :)
Works for me on linux. Maybe it's a windows issue? The documentation says "NOTE that if the OS does not provide any known mechanism for non-blocking reads, then a ReadKey -1 can die with a fatal error." but it sounds like it's instead ignoring the option.
I had one. I think it was on CafePress at one point. It had the following logo on the front: http://news.perlfoundation.org/perlmonks.jpg 
Do I need to pledge there to get one? Not sure how it all works.
It works better if you pledge at Kickstarter. Beyond that I may be able to sell some shirts at the same price outside of Kickstarter. People interested in that should email me (brian.d.foy@gmail.com) to inquire about prices and payment methods. I will also have a few shirts at The Perl Conference in Amsterdam next week.
Thanks, I will try kickstarter. :) Edit: done! 
Hi, I ran into the same problem installing on Mac OS, and couldn't find it when I searched for it in CPAN. While I was searching for a thread like this one, the following link popped up, and seemed to be what we're looking for: https://metacpan.org/pod/release/JANDREW/Spreadsheet-Reader-Format-v0.6.0/lib/Spreadsheet/Reader/Format.pm I've downloaded it, but haven't had a chance to install yet to check it out, but will amend this when I do. Thought I would at least pass on what I have. I'm not sure what the differences are in the CPAN repository locations, but this one appears to be the author's.
OK, got it installed and seems to be working now. I initially ran into versioning issues, and discovered that the link I posted before was for an older release. This is the latest I could find, and appears satisfy the requirements. https://metacpan.org/pod/release/JANDREW/Spreadsheet-Reader-Format-v0.6.4/lib/Spreadsheet/Reader/Format.pm Just download, gunzip, tar -xvf, and then: perl Makefile.pl ; make install Hope this helps.
I remember liking an older edition of the Learning Perl book (by Randal Schwartz). The Python Django tutorial docs are very good. As chromatic points out elsewhere here, the Rust book (2nd ed) is very good (note that their chapter 2 on the guessing game was originally written as an *alternative* to the regular track of the book, but that's no longer mentioned). The Programming in Lua book is excellent (the first parts of the book are pure tutorial, with later parts covering more advanced topics). That said, here's how to write a good tutorial: 1. Get a rough idea of what you want covered in the tut. Say, the 80% of the language that you'll be using most of the time. 2. Assume the reader is a beginner, and start with the basics (like how the perl6intro does). 3. (This step is the hard part for many people.) As you write, you need to keep a record in your head of what the reader already knows, having read this far in your tutorial. As you cover new material, the temptation (or habit) will be to use lingo for (or skip over) things that you already know and have already internalized, but that the reader doesn't know. Catching yourself doing this can be difficult, and you may need help finding these bits. You need to explain these bits --- the reader is not going to pick them up by osmosis. If there are too many of them, the reader will leave. 4. Stay concise. Your jokes may be funny, but they also use up your reader's limited time that they've set aside for learning about your project. 5. As you write, keep the reader informed of overarching design themes, or why things are the way they are (usage-wise, not implementation-wise). It's difficult to come up with a good example here, but so much careful design has gone into Perl 6, the reader should see that beauty and coherence as they go. And anyway, reading a pile of facts to remember is hard, but when design notes are sprinkled in, you provide a lot more a-ha moments which the reader can anchor understanding to. 6. Where you omit advanced topics, consider providing footnotes that tell the reader what's being omitted, and why. 7. And, of course, re-read what you wrote. Have others read it and provide feedback. Ideal is if you can find new users to read it, to more easily spot those holes mentioned in step 3 above. I should add one more Perl-6-specific step here: Step 8, since this is a *tutorial*, resist the temptation to dazzle the reader with fanstastically dense syntactic wizardry. You should only stray from basic everyday Perl 6 if you have a very good reason to do so. What is obvious and neat to you may be confusing linenoise to a brand new user seeing Perl 6 for the first time. Users can start golfing-down their code later, *after* they've learned to love Perl 6 and want to seek out ways to tighten up their code. Good luck! 
Solid points. Also decide if you want to teach "people who are new to programming" or "people who are new to your language". I chose one of those for *Modern Perl*, even if it doesn't look like it superficially.
Err.. what the fuck?
Tested on: * Windows 7 Strawberry Perl (64-bit) 5.22.0 * Cygwin Perl 5.20.2 * Linux Perl 5.26.0 All are working fine.. Not sure why it is not working on yours.
If the author monitors these submissions, could s/he please elaborate more on this? Thanks.
This is a pretty bold claim, and I don't see any stats to back this up. Don't get me wrong, it sounds cool, but we need more information.
it is a module for doing math faster than it goes with normal Perl scalars you could also use PDL or Atlas or Blas or any of the many other XS math libraries to do calculations faster but this looks it will make some nice and Moo(se)-ish looking packages to bless things in loved the reference to Perl11 :) 
Even if it's 6x faster than perl, it needs to be able to do significantly more to be interesting. If we're just adding two ints together, we might as well use C::Blocks or XS and be even faster.
Any chance this has better syntax highlighting for Perl itself than the stock support?
If I understand correctly you should be able to just add '1&gt;my_script.log 2&amp;&gt;1' (or something like it) to the end of the call to the shell script. This should direct the output and the errors to a log file, which you can tail -f. You can put 'set -x' in the script itself if you really want verbosity....
The remaining 7 sins: - food - sex - money - crave - laziness - impatience - hubris Such an invitation to indulge! No wonder Perl is the 8th. Damn me Father for I have sinned.
Going to need some sample data. With only one capture group, you won't ever get a $2. So there's no point in even trying to do that. But you can capture into an array if you have multiple captures: my ( $key, $value ) = 'key-value' =~ m/(\w+)-(\w+)/; print "$key $value\n"
Well, to start with, $content never gets assigned, I suspect it should be $line. You need a closing paren ')' after the regex, before the opening curly. I would suggest a space after 'print', before the argument. You obviously are not using "use warnings; use strict" ... use them, they are your friends. Each time you run the regex, $1 gets assigned the value associated with the first capture. $2 would be the value for the second capture in the regex, but there isn't a second one. Try printing the line before you test it, and see what happens. #!/usr/bin/env perl use warnings; use strict; my @lines = `cat Provider1.txt`; for my $line (@lines) { print "Testing -&gt; $line"; if ($line =~ m/MIA(.*)/ ) { print " $1\n\n"; } } generated the output ... Testing -&gt; Origin,Departure Time,Destination,Destination Time,Price Testing -&gt; LAS,6/23/2014 13:30:00,LAX,6/23/2014 14:40:00,$151.00 Testing -&gt; YYZ,6/15/2014 6:45:00,YYC,6/15/2014 8:54:00,$578.00 Testing -&gt; MIA,6/23/2014 19:40:00,ORD,6/23/2014 21:45:00,$532.00 ,6/23/2014 19:40:00,ORD,6/23/2014 21:45:00,$532.00 Testing -&gt; YYC,6/12/2014 11:00:00,YVR,6/12/2014 11:24:00,$379.00 Testing -&gt; LHR,6/21/2014 11:05:00,BOS,6/21/2014 17:06:00,$975.00 Testing -&gt; YVR,6/18/2014 9:10:00,YYZ,6/18/2014 19:47:00,$1093.00 Testing -&gt; LAX,6/19/2014 8:45:00,YYC,6/19/2014 12:45:00,$356.00 Testing -&gt; MIA,6/20/2014 7:45:00,ORD,6/20/2014 12:36:00,$422.00 ,6/20/2014 7:45:00,ORD,6/20/2014 12:36:00,$422.00 Testing -&gt; As you can see, I matched two flights, different times, different prices. Learn to use the perl debugger : perl -d programname. type 'h' at the DB&lt;1&gt; prompt, and you'll get a summary of all the available commands. type 'h l' to view a more detailed description of the 'list' command. 
Are you blocking and waiting while the child script executes? If so, use the backtick to execute it. It returns stdout. Just try print `ls`; in a simple script to see what I mean. 
If he's not blocking on the child process that would definitely be the way to go.
&gt; However, if i print $1, it will only print the first line with that pattern many times. It sounds like you don't understand what $1 is. **Each time** your regular expression matches, $1 takes the value of the first capture group. Each time your loop finds a (presumably) different line that matches your pattern, it will print the text it found **in that line**.
If I understand your question correctly, it sounds like you're trying to rebuild [squid](http://www.squid-cache.org/) ... as opposed to just downloading and installing it.
running within a qx// is usually what I do. E.g.: my $var = qx/ls -al/; print $var; 
Hi, I understand that. However im using perl to launch a program that runs in terminal. for example: linux/user&gt; /tools/tool1_shell tool1_shell&gt; some_tool1_shell_cmd_that_linux_doesnt_understand_but_the_tool_does tool1_shell&gt; cmd_output tool1_shell&gt; exit linux_user&gt; Now im using my script to call that tool and run its commands, however, linux doesnt show me the output of it unless i run it manually and not from within the perl script. does this make sense? the backticks are for linux stdout. this is another shell's cmd and stdout.
One of us doesn't understand the other one and I'm not sure which it is.
There's a new variable you can use for this in Perl 5.26. https://metacpan.org/pod/distribution/perl/pod/perlvar.pod#@{^CAPTURE} So instead of $1, $2, ... you can check `${^CAPTURE}[$i]` to get the $i^th match. (zero-indexed, unlike the individual vars) As mentioned though this isn't really needed for the OP's problem anyway.
I expect you want [Expect](https://metacpan.org/pod/Expect).
My random thoughts: * put the searches into a database and fetch them out again * run a script in a `while(1)` loop which sleeps for 20 seconds then sends the searches
IntelliJ IDEA plugin does :)
Hmmm, i've never tried it much but i think intellij is quite a heavy editor?
Well, it's not an editor, it's IDE. And no, it is not.
Ok, might give it another try
&gt; I do not really think this trolling. Syntax is usually one of the top complaints from prospective new users. By definition those aren't prospective users at all. Thats kind of the point. If they want a different language or a language /like/ Python its fairly simple. Python exists they can use that. Perl 6 is the language it is, the designs done the compiler implementation is essentially mature now. If you want some other syntax the time for giving your $0.02 in a constructive and meaningful way was about 15 years ago. Anything else, you can have fun learning how to make a Slang and patch the Perl 6 language to be how you want it. For example https://github.com/FROGGS/p6-Slang-Tuxic &gt; How many more special variables and other things are going to be added. Perl 6 has /waaay/ less special variables than Perl 5. I have absolutely no idea what you're getting at here??? Ultimately there are only 3 lexically scoped ones $_ $/ $! Then some dynamic ones like $*PERL for things like the language version, these fit on a single computer screen https://docs.perl6.org/language/variables#Special_Variables &gt; Perl 6 just does not seem like it will be a viable Linux scripting tool for me :( Ruby seems closer to Perl 5 in this regard. Backticks were purposefully left for the user to claim! A deliberate design decision. I've already made use of them myself in my own Slang so I could have a special literal. If you want to do something akin to backticks in Perl 6 it's as easy as qx `qx{ ls -lR | gzip -9 &gt; ls-lR.gz }`
With [latest boost of ~17%](https://twitter.com/zoffix/status/893829363443146752) coming in this morning, thanks to jnthn++'s [TPF-sponsored work](http://news.perlfoundation.org/2017/07/grant-extension-approved-perl-.html#comments) that saw a lot of changes in MoarVM's dynamic optimizer.
Nice! I need to revisit some code I was tinkering with IO stuff, see how much it's improved. Still very much in a Perl 5 headspace thanks to work though.
I have played a lot with Perl 6 this week, trying to port my home-made web framework from Ruby to Perl 6. Perl 6, the language, the syntax: I absolutely love it. It's a beautiful language I would love to use. However, Perl 6 is currently damn too slow for a web use. I am not a VM guy, but I know there is this wonderful technology: https://blog.plan99.net/graal-truffle-134d8f28fb69 Maybe you could try to contact this guy to help: https://twitter.com/chrisgseaton
Nice! where is the code used to build the benchmark?
This is a great addition - thank you. The LOG_ANY_DEFAULT_ADAPTER feature could be useful, but I was slightly surprised that this does not generate any output: LOG_ANY_DEFAULT_ADAPTER=Stdout perl -e'use Log::Any qw($log); $log-&gt;info("here")' Far as I can tell, it ends up with the Null proxy since it does not check the env variable. edit: raised as https://github.com/preaction/Log-Any/issues/59
Don't know about all the chart-making stuff, but the bench itself is: cd $(mktemp -d) git clone https://github.com/Tux/CSV . for i in $(seq 1 10000); do echo 'hello,","," ",world,"!"'; done &gt; hello.csv time perl6 -Ilib -MText::CSV test-t.pl &lt;hello.csv At least that's what I use. There are other scripts in the repo for testing other langs/modules.
don't forget that that will include the time it takes to precompile the text::csv module; perhaps you'll want to run the last line twice to get the difference
I think everyone can be prospective user. No language is ever going to fit everything that you want. But listening to people and making well balanced compromises is good way to appeal to more people. &gt; If you want some other syntax the time for giving your $0.02 in a constructive and meaningful way was about 15 years ago. Should we tell some 22 year old, hey don't raise concerns or opinions because you had your chance when you were 7? Saying it is too late for constructive criticism is a bit unfair. Languages change over time. Python has changed their external command functions many times over. Personally I think the os approach is how Perl6 should have approached it. Short and terse but easily understandable. The Slang approach I think is just going encourage more Perl messes. I just don't understand why backticks weren't kept. Perl6 already has synonyms and more one ways to do things. Backticks I feel like are more universal as they are used in PHP, Bash, Perl 5 and other languages. Honestly I think the less synonyms the better and they're not really that descriptive, but qx? Admittedly I am a new Perl user, I enjoy writing in it more than Python. But looking at more advance code, I am often feeling like I deciphering hieroglyphics. I spend so much time trying to decode something someone thought was clever. I guess maybe Perl isn't for me. Or maybe I am not smart enough for it :( But how is Perl 6 ever going to appeal to a younger audience or be taught in schools? This whole approach of "Hey once you learn it, its easy" "Or I guess its not for you" is the most problematic thing for Perl 6 at the moment. Why would anyone want to learn it? I am not saying it should be a Python clone. I still stand by the variable comment, but is nothing compared to the issue with operators. https://www.reddit.com/r/programming/comments/6iu8jh/perl_6_seqs_drugs_and_rocknroll/dj9pj27/ I appreciate your examples, and your time to respond to my concerns. But honestly I am looking to go back to using Python at work and at home. I am not happy about it, I much prefer writing scripts and jobs in Perl. But as someone who is a system administrator, I don't have the time to learn 20 different ways to do things and 20 different edge cases. It is also getting harder to justify writing things when Perl is missing simple things as a SSH core module and doing a "yum search perl" still cannot find an SSH module whereas "yum search python" can. CPAN is typically the response to this, but this is not an option for regulated secure/offline environments. Perl 5 isn't going to be gone anytime soon, but as someone who is not a real programmer, it just makes more sense to work with Python when it is going to be around longer, has better documentation, is predictable and has better Linux support. Perl is not even in a minimal install these days :( It sucks trying to to advocate for Perl in hobbies and at work, when support and documentation is dwindling, getting ridiculed by people inside and outside of Perl. The only reason why I learned Perl in the first place was because its a pain to manage multiple *nix servers with multiple different versions of Python. The Python version issue is going to be fixed over the next couple years. I don't even see Perl6 being in a default RHEL/CentOS install anytime soon. EPEL is not an option, neither is compiling. Its a bummer I thought it would be really cool to learn a "hot" new language. But being told, "Hey too late to voice your concerns" knowing full well Perl 6 is going to tack on bunch of other stuff to be ridiculed on /r/programming is silly. edit- I said Perl6 in a default install, I meant to say I don't see it being a default repo anytime soon. second edit- I am not really hung up that much on backticks, its more I am seeing a pattern of things that are going to make it harder for adoption.
My simple solution. Adopt a release cycle where perl5 branches are odd numbers. Perl 6 are even (rakudo) Release perl 7. Turn on all cool stuff in perl 5, do a clean up of core INC and done. Keep perl5 alive as backport branch. In say another 12 years when perl 6 is more than an experiment release it as perl 8.
&gt; Anything else, you can have fun learning how to make a Slang and patch the Perl 6 language to be how you want it. This is not a good argument. Operator overloading is still a controversial feature for a reason -- designing good interfaces is difficult, especially when the semantics is not obviously different because the syntax is re-used.
If you recently downloaded Strawberry Perl I don't think you have 5.18 as noted in your `perl -v` output. It looks like there is another perl on your system. Also, note the The _C:/Program Files (x86)/get_iplayer/lib_ is suspicious. I think something else bundled `perl` and Windows finds that one first. Also, the '.' in `@INC contains` is suspicious. I don't think the latest Strawberry Perl has that. A vendor distributed version of `perl` that they don't expect you to use would eschew parts of the standard package that it doesn't need. This includes the bits to install additional modules. They wouldn't want you to mess up what should already work. You've already discovered this. Copying random files is unlikely to help. Try running `perl` with it's full path: `C:/Strawberry/bin/perl` (or whatever it is) to see if you get the same results. You can also adjust your PATH so Windows finds Strawberry Perl first.
Hmm... &gt; One of the biggest challenges Shutterstock faced was dealing with the limitations of Perl, which it had used as a primary programming language for web pages and other assets since the company's inception. &gt; "It was a great language, particularly as a startup, but the introduction of cloud computing and more advanced IT infrastructures required us to move to a more cloud-aware, fault-tolerant architecture," Brodbeck explains. "We wanted to build a next-generation platform that could help propel Shutterstock into a billion-dollar company." Where are we going wrong if people think you can't do all of that in Perl?
&gt; educational web app […] they submit a search to an external service […] a classroom of students doing the same search You are going to deterministicly know beforehand what the request looks like, right? Then you don't need a buffer or accumulator. Just use a featureful caching software, [CHI](http://p3rl.org/CHI) is fine. Simply prime the cache once before the students start their work, the response will be delivered instantly from the cache.
I suspect there's more than the article says to the CTO's decision to switch to Node.
indeed, perl is both cloud-aware - https://metacpan.org/search?q=weather - and fault tolerant - http://perldoc.perl.org/functions/eval.html - so this doesn't sound like great reasoning so far. &gt; adopt a programming language that could support ultrafast downloads Why is the programming language even involved? Wouldn't you offload that to something like nginx? Last time I did async file transfer benchmarks between perl and node.js (using sendfile in both cases) the peak difference was about 10% in favour of node.js. In both cases it was not too difficult to saturate a gigabit link. Either they're doing something new and exciting or that definition of "ultrafast" was borrowed from one of the more excitable cable/internet providers out there... &gt; Using a 12-factor app approach, Brodbeck says that speed and performance are up, but, equally important, the business can tap microservices, reusable containers and components if you're going to TAP something, wouldn't Perl be the obvious first choice? &gt; We leverage scripts to improve predictability and overall software quality. People have been leveraging scripts since before Matt's Script Archive. Does writing scripts magically provide those benefits? If so, Perl might be worth a look, I hear it also has support for scripts. Entertaining article, anyway. Thanks for sharing.
Did a little digging and found this: https://github.com/get-iplayer/get_iplayer/wiki/windows &gt;The path for the embedded Perl distribution (perl subdirectory) and the path to the included atomicparsley and ffmpeg utilities (utils subdirectory) are not permanently added to %PATH%. They are temporarily prepended to %PATH% only when get_iplayer batch scripts are running. Looks like Strawberry Perl *should* work as expected if get_iplayer is not running, so make sure that's closed and give it another go /u/reddit_user33
TBH the signal to buzzword ratio in TFA is ridiculous and the CIO/CTO isn't going to reveal the fundamental issues that (effectively?) lead to a rewrite. I suspect crippling technical debt, and nobody wanting to touch it was the primary reason. The bit about moving to a "cloud-aware, fault-tolerant architecture" is a bit weird as AWS is essentially language agnostic when you consider most of the scaling bits are behind trivial RESTful APIs and there's a load of dists on CPAN to make this easy if you don't want to write your own.
haha, what could go wrong. Perl 5 and 7 will be one kind of Perl and versions 6 and 8 will be a completely different language. Nope, there will be no confusion there. The right answer is rename Perl6 to something else, and release the next version of Perl 5 as Perl 7 
My solution doesnt prevent yours. 6.x would continue to be the experimental Lang. 7.x would remain the main and 5.x can transition to legacy. And then ideally perl6 becomes so appealing to perl5 devs we have no issue it becoming perl 8 in due time. But for now call it perl6.rakudo or something. Ideally yes just drop all references to perl6 and become its own language and if in time it runs all perl5 with all main and common optional cpan libs then sure, become perl 8. I agree, what ever the reasons given 12 years ago it has proven detrimental to both projects. Acknowledgment of a branding issue isnt a technical issue and we need a way to move forward from this mistake. 
If everyone knows Perl6 was a branding mistake - why isn't anything being done about it?
get_iplayer wasn't running when i attempted to do this. Not even a background process. Edit: I've fixed this. Mentioned it in my reply to briandfoy.
My guess, based on reviews I saw on Glassdoor, is that they ran through most the good Perl devs and had trouble finding people to bring on board.
If i set the directory to the Strawberry installation, when i run perl -v, it shows that it's running a different version. The one in get_iplayer is version 18 and the Strawberry is version 26. get_iplayer is the program that i mentioned that installs its own stripped down version of perl. EDIT: I looked the path in environment variables. I simply lowered the get_iplayer directory below strawberry perl directory and everything appears to work as expected.
Stubborn people afraid of admit failure
&gt; `my $request = HTTP::Request::Common::POST($url, Header =&gt; $header, Content =&gt; $content); ` That part is wrong. You don't pass the HTTP::Headers object with the 'Header' key -- the `POST $url, Header =&gt; Value,..., Content =&gt; $form_ref` example is intended for you to *pass all the headers as a list*: POST($url, 'Content-Type' =&gt; 'application/json; charset=utf-8', 'Accept' =&gt; "application/json", ..., Content =&gt; $form_ref, ); Since the authorization header is built up in a more complicated call, you can't use the `POST` shortcut here -- you'll need to create an HTTP::Request object manually, and then pass that to the LWP::UserAgent object. 
You may wish to check out [Mojo::UserAgent](https://metacpan.org/pod/Mojo::UserAgent) There are examples for JSON POST and basic auth in the [synopsis](https://metacpan.org/pod/Mojo::UserAgent#SYNOPSIS).
When you GET the page you need to extract the `__VIEWSTATE` and `__EVENTVALIDATION` values and pass those along with your request. They are located inside `&lt;input&gt;` tags e.g. &lt;input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUKMTg2OTE2NTg2N2RkQOtVpgiV971Op80o6V7buyjuRC0=" /&gt; From some trial and error it also appears the request fails if you do not send the `__SCROLLPOSITION` values. I'm not sure if `WWW::Mechanize` supports *"parsing HTML"* it just seems to have link and image extraction methods. You could of course use a HTML parser to extract the values but here is some example code using [Mojo::UserAgent](https://metacpan.org/pod/Mojo::UserAgent) which does the GET, extraction and then the POST. It also extracts the names of each result. use strict; use warnings; use feature 'say'; use Mojo::UserAgent; my $url = 'http://find.pitt.edu'; my $query = 'Barroso'; my $ua = Mojo::UserAgent-&gt;new; my $html = $ua-&gt;get($url)-&gt;result-&gt;dom; my $viewstate = $html-&gt;at('input[name=__VIEWSTATE]') -&gt;{value}; my $validation = $html-&gt;at('input[name=__EVENTVALIDATION]')-&gt;{value}; say $viewstate; say $validation; $html = $ua-&gt;post($url, form =&gt; { __VIEWSTATE =&gt; $viewstate, __EVENTVALIDATION =&gt; $validation, __SCROLLPOSITIONX =&gt; 0, __SCROLLPOSITIONY =&gt; 0, 'ctl00$ContentPlaceHolder1$btnSearchAll' =&gt; 'Search', 'ctl00$ContentPlaceHolder1$txtSearchAll' =&gt; $query, })-&gt;result-&gt;dom; my @names = $html-&gt;find('td.ResultsFullName a')-&gt;each; say $_-&gt;text for @names Also take note of the the CAPTCHA message on the page. You can use this form to find people at the University of Pittsburgh. Enter the username or the person&amp;#39;s full name or last name to perform the search. You can view details of the person by selecting the name link. Please note that after 3 searches from outside the university network you will be required to complete a CAPTCHA challenge phrase. 
They have their own language specialist already working on it. Larry says that the speed improvements related to the parser are almost ready to be released.
I recognise that you're the creator of the get_iplayer program. How frequently do you put out updates? I feel like i only downloaded my current version a few months ago. EDIT: I have version 3.00. I notice that your latest version is 3.01. Nothing in your notes states a change regarding the PATH?
[removed]
Are you a bot or a person? Either way, your comments cluttering up Reddit. 
Thanks! This works and I greatly appreciate your efforts. About the CAPTCHA, it should not be a problem because the host on which I need to use this code is within the University network. Admittedly, I do not fully understand the code but will try and understand it better.
At this point, I'd be ecstatic to get my company into Object Oriented Perl programming. Maybe an actual web framework. Something past 5.8.8. (I had Dancer up and running for a brief time. The old Dancer. Not the Moo-based one. But some of the better modules for it wouldn't work without modules we couldn't install...) And the company is sponsoring Python training now. It's almost like the writing is on the wall....
I've always used the executable that you package up. I've used the program for a few years. Maybe it's an older version still lurking. I once used that forum a few years ago, some arrogant person persisted to argue with me about semantics even though i clearly illustrated that he was incorrect. I'd prefer not to use it, even if i do come across an issue. Anyway, this isn't a get_iplayer issue. This is me wanting to utilize perl and your program has configured my computer to use your stripped down version of it. EDIT: Interesting that dinkypumpkin deleted his account
&gt; Admittedly, I do not fully understand the code Well the `submit_form` in your code is just sending a `POST` request which is what we do *"manually"* with `$ua-&gt;post()` The rest of the code has to do with extracting certain values or *"HTML parsing"*. For that you may want to look at https://metacpan.org/pod/Mojo::DOM#at and the linked CSS Selector docs: https://metacpan.org/pod/Mojo::DOM::CSS#SELECTORS I'll try to explain it here though: `$html-&gt;at('input[name=__VIEWSTATE]')` finds the first `&lt;input&gt;` tag whose `name` attribute has the value `__VIEWSTATE` e.g. &lt;input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUKMTg2OTE2NTg2N2RkQOtVpgiV971Op80o6V7buyjuRC0=" /&gt; To extract the contents of a particular attribute from the returned object we can use hash syntax so here we use `-&gt;{value}` to extract the `value` attribute. [find()](https://metacpan.org/pod/Mojo::DOM#find) is like `at()` except that it returns a collection of all matches whereas `at()` returns the first match. The `find()` call is: `-&gt;find('td.ResultsFullName a')` If we take a look at the HTML of the results page we can see: &lt;td class="ResultsFullName"&gt; &lt;a id="ctl00_ContentPlaceHolder1_rptUserList_ctl02_NameLink" href="..." style="margin-right:30;"&gt;Barron Jr, Edward L&lt;/a&gt; So the names we want are the text content of `&lt;a&gt;` tags that are contained with `&lt;td class="ResultsFullName"&gt;` `td.ResultsFullName a` uses the [E.class](https://metacpan.org/pod/Mojo::DOM::CSS#E.warning) syntax which is like doing `td[class=ResultsFullName]` combined with the [E F](https://metacpan.org/pod/Mojo::DOM::CSS#E-F) syntax which means the `&lt;a&gt;` tag must be a descendent of the `&lt;td&gt;` tag. So we then have all of the matching `&lt;a&gt;` tags and we use the [-&gt;text](https://metacpan.org/pod/Mojo::DOM#text) to give us the text content i.e. the name. Hope that helps.
It looks like you have mixed the embedded Perl from an obsolete get_iplayer release that didn't use system path with a newer version that does. The simplest way to clean up would be to uninstall get_iplayer, delete `C:\Program Files (x86)\get_iplayer` completely, then install latest release. That should give you a clean installation of get_iplayer that will coexist with Strawberry Perl no matter where it is system path (as explained earlier by /u/Mienaikage). I've used them side-by-side without any problems. The installer should also present you with a link to [these additional notes](https://github.com/get-iplayer/get_iplayer_win32/wiki/cleanup) about cleaning up obsolete versions.
So I should use the Header-Field like this? my %header = ( 'content_type' =&gt; 'application/json; charset=utf-8', 'authorization_basic' =&gt; ([$acountUsername, $acountPassword]), 'accept' =&gt; 'application/json' ); my $request = HTTP::Request::Common::POST($url, Header =&gt; %header, Content =&gt; $content); 
&gt; That code writes the SVG document is written to STDOUT, so you’ll probably want to redirect that to a file. I was wondering how to easily redirect STDOUT, so I found this excellent article: https://perltricks.com/article/45/2013/10/27/How-to-redirect-and-restore-STDOUT/
Learn both! It's not a Python 2 vs. 3 thing. For one thing, it's possible with some care to write code that is portable between Python 2 and 3; it is not possible to write code that is portable between Perl 5 and 6 (without resorting to what is essentially polyglot trickery). Larry Wall translates a trivial Perl 5 program to Perl 6 here: https://www.youtube.com/watch?v=E-viHFlBjHg , and the changes are about as large as if he'd been translating to Python or Ruby. That's the main reason people keep saying "re-name Perl 5 / re-name Perl 6 / etc.". My personal guess is that, once Perl 6 gets some optimization work out of the way, greenfield projects in Perl will be done in Perl 6 (despite what I said earlier, your typical Perl 5 developer can probably pick up Perl 6 on the fly, and it's enough better, in my opinion, that I think Perl 5 devs are going to start realizing they want to switch). There are projects to allow you to mix Perl 5 and Perl 6 in a project: https://metacpan.org/pod/Inline::Perl6, https://github.com/rakudo-p5/v5. So it's possible that even large legacy projects will start using Perl 6. But right now there are millions of lines of legacy code in Perl 5 that will probably never be converted over to Perl 6; it's doable, but it's just not enough of an improvement to justify the cost. So my advice would be: learn both! They're similar enough it's not really like learning two different languages, and they both have quite a bit of value to learn. Perl 5 for using existing code and maybe for immediate use; Perl 6 because it will actually change the way you think about programming (in the same way Lisp does).
Why not release the next version of Perl as Perl 28? Tell people "we've been calling it Perl 5 version 20/22/24/26 for a while now, but people don't seem to be picking up on it, so we decided to drop the '5' part of the version number". And, like someone else said, re-name Perl 6 to Pardes just for clarity.
Java did that (Java 2.8 is called Java 8). Perl releases come out too fast to support that. 
&gt; 'authorization_basic' =&gt; ([$acountUsername, $acountPassword]), Everything except that bit is correct. That header has a special mechanism for construction, so you need to do that bit first.
You don't want that literal 'Header' in there. my $request = HTTP::Request::Common::POST($url, %header, Content =&gt; $content);
Id agree more if we didn't already have the situation where to actually work on a single web application you might have to use and abuse three languages sometimes even in the same source file. People manage that context switch. Having slangs and operator extension in Perl 6 feels like if anything a positive use for that kind of context switch. Instead of being forced to because of language, you're choosing to take on the context of what you're doing where appropriate. I agree working out the good interface and boundaries for that are probably hard though. But Perl in general has an issue of making things easy that should probably be hard, or at least thought about. If things like grave accents imply user side magic quoting constructs, you know its at least not part of the language. The bigger issue is people learning the language, where there is already so many operators to know if you come to some code you can't be sure. 
Of note, it's not just the 255 status of a `die` to watch out for. The number of failed tests is reported as an exit code, so if you got more than 125 failing tests, the same issue will occur even with things that don't die with 255 (like Rakudo's `die` that dies with status `1`)
To summarize (and oddly, I never heard him say this in the video, but maybe I missed it): Damian implements Lisp macros using a single 1k+ line regex to parse all of Perl 5. He then re-implements a Moose-like and highly performant "class", "method" and "has" using this tool, along with several other cool features including a more flexible version of inline-C and inline-Python, a variation of "my" ("your") that traces changes to the value, etc. Oh, and it's hilarious. PS: The link is time-cued because I think most of us know who Damian is. If you don't, go back to the start of the video and watch the quite long intro that he refers to as his own eulogy. ;-) 
Yes. https://perldoc.perl.org/5.8.8/perlop.html#Quote-and-Quote-like-Operators The `q` quote functions like single quotes with arbitrary delimiters, and doesn't interpolate Although I would suggest instead - inline it as \_\_DATA\_\_ and slurp it into a string instead. E.g. my $stuff = do { local $/; &lt;DATA&gt; }; And at the end of your code: __DATA__ Stuff with special characters here. But you can use heredocs in perl too. There are plenty of options. 
can you elaborate more on the __DATA__ thing? where can i find more info about this or what is this feature called?
I've been trying to use Dios, which I love and it helped me greatly understand OO concepts. I was always stumped with Moose trying to get it to work (despite taking a class on Moose with Dave), but I had no problems with traditional Perl OO. However, after using Dios for 2 days I was able to go back and use Moose without too many problems, all of a sudden things just started to make sense. The only thing I'm struggling with currently with Dios is getting the BUILD to work (I'm referring to submethod BUILD). For example, as far as I can tell from the documentation and using it, you are not able to have a parameter list, but only labeled parameters for BUILD, of course other methods can have either or a mix/match of them. Besides that the only other odd thing is methods and function signatures don't work exactly like how the Perl new method signatures work, where it is the same as using my $variable = shift or @_. For example, if I have an attribute $.user, but I also have I method with a signature of $user, then the method $user will still be reading the attribute. In fact, if you use warnings it will complain. So I am not sure if that is attended or not, since the documentation says that if you create an attribute, then that variable is basically global. Besides Dios, I do really hope that the Keyword stuff comes to fruition. For example, imagine if 'get' is now a Keyboard for Mojolicious instead of the reference that it is. Lastly, I hope in general that these new tools succeed without dying. Recently at work we wanted to switch over to a more OO setup for all our Perl code and I gave a talk of the differences between the four that I was selected to look at Moose, Moo, Moops, and MooseX::Declare. MooseX::Declare is officially dead, and the site says don't use it, use Moops. Moops says it is early beta and don't use it until 1.0, but that was years ago. That leaves Moose and Moo only, unless you want to go outside the standard box of things and none of the non-Perl people are happy with those two options since MooseX::Declare and Moops feel/look more comfortable to them. Stevan makes new an improved MOPs each and every year, which means you can't use the ones out there because it will be declared dead in 6 months. So I hope Dios will get a lot of support and Keyword for a backend to create extensions for Dios, because frankly I'm tired of great projects being created, released, and then left for dead left and right. Moose is great, Moo is great, but they are similar but not the same thing in how they function, it would be great to see something else just as popular and supported but that is different. The only thing that needs to help get pushed through in agreement is something to do with the internals, so that hopefully we can get something in Perl itself that different OO modules can all tie into and work, which I think is what Stevan is hoping for.
https://stackoverflow.com/a/13463541/2566198
Single quote it. Or `use uft8; print q♥ stuff goes inside ♥` it :) Since this reddit is for more than one language, it's worth noting in Rakudo, single quotes actually not entirely non-interpolating. They allow special escapes that make part of the string more interpolatory: my $var = "meow"; say 'just $var \qq[not just a $var] just a $var again'; # OUTPUT: just $var not just a meow just a $var again The part between the square brackets above uses [`qq` interpolation](https://docs.perl6.org/language/quoting#Interpolation:_qq), while the rest uses just plain `q` mode. To make it really-really non-interpolating, use [`Q` quoter](https://docs.perl6.org/language/quoting#Literal_strings:_Q) (or, it's [Unicodey brothers](https://docs.perl6.org/language/unicode_texas), the `｢｣` quoters): my $var = "meow"; say ｢just $var \qq[not just a $var] just a $var again｣; say ｢It's a real nice way to quote a \｣; # OUTPUT: # just $var \qq[not just a $var] just a $var again # It's a real nice way to quote a \ It's really handy when you need to write strings with some backslashes in your code, as you don't need to backslash them 😆
I thought setenv was a shell function, not a binary. What are you trying to do? 
System("something") is not technically a system call. System calls are the things you find from section 2 of the man pages. System() invokes external processes from your path. You can adjust environment for your own process by doing $ENV{key} = "value".
I haven't tried IDEA in a while for Perl dev. How is IDEA with the likes of Moose for autocomplete and syntax highlighting?
The reason you get that specific error is that `setenv` is a builtin of C shell, but the single-argument version of `system` uses the system's Bourne/POSIX shell.\* But even if you changed that to use the Bourne shell syntax of `export foo=bar`, it would just silently fail to do anything. In fact, it *can't* work, because of how processes and environment variables work in Unix.\*\* Each process has its own environment. Each time you use `system`, it creates a new child process. Usually child processes inherit their environment from the process that called them, but this is a one-way ticket, and happens only when the process is first created: After you start a new child process, any changes made to the child's environment are *not* reflected in the parent, and vice versa. So `system "export foo=bar"` would start a shell as a child process, the shell would change its environment, ... and then the shell would terminate because it finished running your command, throwing away the environment that just changed. The correct solution, as /u/audioen points out, is to use `$ENV{key} = "value"` to change the Perl process's environment, which will affect any subsequent child processes you might create (calls to `system` and the like). \*: Also, if you're going to be pasting variables into command lines, the single-argument version of `system` is dangerous and should be avoided, because it makes [shell injection](https://en.wikipedia.org/wiki/Code_injection#Shell_injection) attacks possible. The list version of `system` doesn't use a shell, so there is no risk of the arguments being parsed incorrectly. \*\*: I assume Windows is similar, but I haven't done Windows programming since the days of 3.1.
I am always in awe of Damian's presentation of his code slides. His discussion of Perl 6 vs. Perl 5 vs. Perl 5 w/Moose (9:30-11:45 in the video) is a thing of beauty.
I was there (am there), it was a great talk. He had another one today that also was good.
Does IntelliJ constantly check the syntax compile errors and perlcritic errors like how Eclipse EPIC does? With that, does anything else constantly check and show syntax compile errors and perlcritic errors besides Eclipse EPIC? I know of Padre, but that no longer compiles on most system and versions of Perl and sadly has been long abandoned.
See [Here document](https://en.wikipedia.org/wiki/Heredoc#Perl). For example: my $str = &lt;&lt;'UNTILTHISTOKEN'; data data data data data data data data data data data data data data data data data data data data data data data data UNTILTHISTOKEN Everything up until the matching token will be literally copied into the string and not interpolated.
Pretty nice
Yes, it does
That was incredible! Every time I think I've seen the best of Damian Conway, he tops himself.
Emacs + [PerlySense](https://metacpan.org/pod/Devel::PerlySense#Displaying-Code) highlights syntax errors and Perl::Critic violations too.
BTW, when can we expect (if ever) TPCiA (a.k.a. YAPC EU) 2017 videos?
Putting string data inside `q()` is still subject to at least two interpretations: `\\` becomes `\` and `\'` becomes `'`: $str = '\' and \\'; print $str; # will print: ' and \ Putting string data inside a single-quoted heredoc avoids the abovementioned two interpretations, but you have to be careful not to have the heredoc marker inside the string data. Choosing a long enough random marker (say, 32 hexadecimal digits should be safe): $str = &lt;&lt;'MARKER'; \' &lt;-- will become \' as-is, not ' \\ &lt;-- will become \\ as-is, not \ MARKER Another safe choice is, as mentioned in the other comment, putting string in DATA section. $str = join '', &lt;DATA&gt;; __DATA__ Anything goes here.
They're already appearing [on their Facebook page](https://www.facebook.com/ThePerlConference).
Thanks! Unfortunately, ~~many~~ some videos do not have audio source from the speaking person's mic, so, hard to hear :-(
Why not just install perltidy? 
Also, which online beautifier?
It's work system, no permission to install 
if it's a work system, you shouldn't be sending proprietary company code to an untrusted third party.
It's not proprietary. Its just a local text parser. Doesn't have proprietary info 
you know if you can write local files you can do a user space install of modules and entire perls, right? with local::lib and such?
look at perlbrew, you can install in your home folder with special permissions
If you've managed to get other beautifiers on your system, you can get perltidy on there
Deprecation - "It seemed like a great idea, no the best idea, when we did it. Today we decided on a better idea". Deprecation nailed me over and over again in Java. 
I'm still sore about the promotion to error of the syntax: for qw blah blah blah several years ago. When I upgraded my Debian system all of a sudden several Perl open source applications I had relied upon broke, and I had to go around the source inserting parentheses! It was not a good change.
It seems like a much better idea once you get useful features/syntax that would not have been possible without removing the old.
A google search brought up http://www.tutorialspoint.com/online_perl_formatter.htm which seems okay.
Just a nitpick, it's not "Lisp macros", go look what Perl6 is planning to get an idea of what Lisp-like macros would look like in a Perl.
You should try Perl6, where these things are polished. Since learning Dios helped you with Moose, I think learning Perl6 will help you with Perl5.
I'm quite familiar with both Lisp and Perl 6's macros. The difference here is much the same as early Perl 5's object system and C++'s. They both support real objects, but in one case you have to build quite a bit of it manually. Some people referred to Perl 5's object system as an object system toolkit, and in much the same way, Keyword::Declare + PPR + PPI constitutes a macro system toolkit. In this case, you would have to call PPI (not PPR) on the parameters to your keyword function in order to gain access to the AST that it produces, modify that, and then re-stringify the result. Indeed, and amusingly, you could write this as a keyword. I'd call it "macro," personally. ;-) 
Have a look at the experiment: https://github.com/masak/007 You'll receive an object-oriented parse tree, it won't be text based. Although that would also be possible.
I'm not sure why you're linking to this... This is masak's unexpanded AST work, but it's not really relevant to anything I was saying. Perl 6 macros are much more of a direct macro system like Lisp. You don't have to re-parse anything. In Perl 5, to build fully functional Lisp-like macros from Keyword::Define, you would have to re-parse the matched inputs using something that could generate the AST (e.g. PPI), though in many cases, you don't need to do that because you can get by just fine without knowing what the parameters actually mean or modifying them as code. But let's take an example: You want to write the keyword `backwards`. This keyword takes a block and executes the statements in that block in reverse order. In this case, you would have to define the keyword: keyword backwards (Block $body) { ... } But what goes in that keyword definition, while trivial in Lisp (and theoretically in P6, though it's still getting there) is much more complex in Perl 5 because in P5, where you have the string `$body`, you now have to get the data structure that represents that code: use v5.26.0; use Keyword::Declare; use PPI; keyword backwards (Block $block) { my $doc = PPI::Document-&gt;new(\$block); return "{".join( '', reverse $doc-&gt;first_element-&gt;first_element-&gt;children)."}"; } backwards { say 1; say 2; say 3; } 
I assume you're wanting to scan a remote host, not the one you're running the Perl program on? If so, see how nmap does it. You're going to be wanting to do some banner scraping, possibly looking at low level TCP/IP connection parameters, etc. I wouldn't expect it to be simple for the general case but if your situation is more limited, it might be easy.
I'll look into banner scraping, if it's not simple I can always abandon it and just use nmap
nmap will do that. Don't know about a Perl wrapper but I'm sure one exists. 
I suggest quotemeta Very handy.
It's worth noting that `dd` is [not a standard language feature](https://docs.perl6.org/programs/01-debugging#Dumper_function_dd) and what and where it prints is not defined and can be changed by implementations at will.
An interesting and reasoned review. I coded in Perl 5 for many years, until it became clear that a) jobs were becoming rare and b) the language was stagnating. I moved on to Python. I'm not here to promote it... Many find the move from Python 2.7 (which actually has a defined EOL date) to Python 3 to be a controversial thing because a few things improved along the way and code changes are needed. However, the Py2-3 switch is a *cakewalk* compared to migrating from Perl 5 to Perl 6. For that alone, it will be interesting to see if Perl 6 gains significant traction.
&gt; the language was stagnating. Around what year was this? These days, I feel that Perl 5 is zipping along.
I stopped actively using it about three years ago. But when you say "zipping along", how much has 5.x really changed since then? How much *can* it change, given backward compatibility? Again, not arguing Perl 5 is dead, just wondering if Perl 6 is going to catch on.
It has subroutine signatures, lexical subroutines, ref aliasing, postfix dereferencing, regular expression set operations, computed labels. That is only a few choice ones since 5.16. There have also been various speed improvements, in particular to subroutine calls. There are plenty of ways of extending the syntax, if you design it so that new feature is a syntax error in previous versions. Perl 5 has also been extended by use of pragmas for turning on certain features; which allows a large range of otherwise backward incompatible changes to be added. Stevan Little has also been working on extending the built-in object system, and this time it looks a lot more like it will get merged. (partly because he is extending the existing one rather than trying to create a new separate object system) There was a video of him discussing how it currently works that I watched recently. --- Most of the people who show up in #perl6, are also new to Perl in general. We really see it as more of a sister language; similar to C, C++, and C#. I think I personally have translated more Haskell code to Perl 6 than Perl 5 code.
As I like to point out, perl (both 5 and 6) are the only languages I know of with unicode-aware regexps-- e.g. you can search for a greek character with /\p{Greek}/. More to the point, there are limits to how much languages *need* to change-- there's nothing wrong with saying "okay, the core language is done, now any further development will take place in optional libraries". And in case you were wondering: there's still quite a bit of development of CPAN modules going on. The killer app for perl6, in my opinion, is convenient features for asynchronus, parallelism and concurrency-- it's probably not (yet) the best for raw performance, but for ease of crafting code, it's clearly one of the best options out there. There are a bunch of really good Jonathan Worthington talks out there on this subject. 
Guy who's new to Perl here: I started checking out Perl because I thought "Hey it's existed for awhile, and I can write Unix scripts with Perl, so might as well check it out." If there's anything that I can say about Perl 5 vs 6 is that if 6 features faster practically everything, simpler syntax, and contains all the same/similar modules and pragmas then people and companies will want to switch over to it. Again, I barely know anything about Perl itself, so maybe my opinion isn't valid.
Async is basically the killer app for Python 3 too, FWIW. As for Unicode regex, Python supports it in 2.7 as well as 3.x. It's also baked into Go (aka Golang) - though it's a compiled language, it has made compelling inroads into the infrastructure space, among other areas. Likewise concurrency is baked into both (and Perl 5 has it too, though it probably isn't as advanced as what's in Perl 6). As for how much a core language ought to change, there is something to be said for controlled deprecation. I don't think the move from Python 3 to Python 4 will be nearly as contentious as the move from Python 2 to Python 3, and the latter is only painful for certain use cases (many of which can be avoided by proactively coding in the Python 3 syntax using "future" imports). The language isn't fundamentally different but refined. That's where I think Perl 5 vs Perl 6 is different... I don't see any indication of Perl 5 ever being deprecated in favor of Perl 6 (I'm sure there are myriad reasons why that would be so, with the rather disjoint path between the two being the toughest part). That's a blessing and a curse - it limits how much Perl 5 can change, and as /u/b2gills noted above, Perl 6 isn't really a continuation of the line so much as a fork of it. I'm really surprised a different name wasn't chosen just to reduce the perception of tech debt, but it is what it is. Python is making it through the 2 -&gt; 3 move steadily, and in a little over two years 2.x will be EOL. If that transition had taken a few years longer, I suspect Python 3 would also have been more of a fork than an update as well, if it even got any traction at that point. I'm glad that didn't happen but it was rather close. I have no doubt Perl 5 will be around for years or decades to come, but Perl 6 circumscribes that tree - how much different can, say, Perl 5.98 be from Perl 5.24, really? And why move to Perl 6 if you still have to support Perl 5 as well? I'll be interested to see how it goes, but it's a cautionary tale - the longer a language takes to go one major uprev, the more likely it is that it'll fork rather than transition in an orderly fashion (and if it's effectively forked and there's many other choices at that point, there's a tendency to switch away altogether, whether or not the new fork-line of the language is superior to said choices). Again, we shall see - it might have been quite different if Perl 6 happened ten years ago (obviously not in its current form but as a step on the road to today).
&gt; convenient features for asynchronus, parallelism and concurrency-- it's probably not (yet) the best for raw performance, but for ease of crafting code, it's clearly one of the best options out there. If not for the performance(speed), what is the point of taking on the complexity of concurrency? In fact, I am hving the odd opinion of prefer Perl5 do not have thread support and even reduce its xs support. Perl is for its convenience, period. When efficiency is a concern, learn to use C. Looking at the tremendous effort trying to speed up Perl, or other dynamic languages, and in the mean time watching those effort killing the elegance of those language that made them shine in the first place, is an irony.
&gt; If not for the performance(speed), what is the point of taking on the complexity of concurrency? The immediate point would be that in a concurrent app the speed of individual nodes may not be the blocking concern, but on the other hand ease of development and maintenance is always going to be an issue. And if that's handled well enough-- and like I said, p6 is pretty good-- that can motivate the effort to fix the raw performance issues. 
Ah, I see you're right about improvements to Python 2's regexps... last I looked I didn't turn this up, maybe because it wasn't core: https://stackoverflow.com/questions/1832893/python-regex-matching-unicode-properties#4316097 Seriously though, the perl6 features in the concurrency department are actually pretty slick, it gets the job done with some very tight code. &gt; I'm really surprised a different name wasn't chosen just to reduce the perception of tech debt, but it is what it is. A number of perl5 people were annoyed at the naming of perl6 for the opposite reasons actually, it created in a lot of people's minds the impression that p5 must be dead because p6 was so long delayed. (Actually what happened is a lot of new blood moved into perl5 development when some of the old guard moved on to perl6 development... there have been few issues with perl5 development and maintenance, and in some respects it probably got better). &gt; how much different can, say, Perl 5.98 be from Perl 5.24, really Fairly different, really. E.g. if your code begins with something like "use 5.10.0;" you've got access to core functions like "say" that didn't exist before that version was released. You might look through the list that b2gills just posted. It will actually be, for example, a pretty significant performance boost when Stevan Little gets his meta-object protocol built into perl5 core, and it'll be entirely backwards compatible with existing OOP code, much of which is based on an un-accelerated CPAN-only version of this already. But really you're missing the point I was making: if you're using perl5 (which I do when I can, I *like* perl5), how different would you *want* it to be? 
Perl6 can use Perl5 modules, Python modules and directly call C libraries with ease.
&gt; Async is basically the killer app for Python 3 too Python has nowhere near what Perl6 has to offer in terms of concurrency. They barely got rid of the global interpreter lock. In Perl6, concurrency is *easy*. In fact, every program in Perl6 is concurrent because GC and JIT happen each on their own threads. The author of the OC only talks about what's in Rakudo core. He didn't even talk about what's available as modules.
It's always a pleasure to read Evan Miller's wriitings. Even when he dispatches a couple of bitter truths, like in this case, he procures to be fair and encompassing. I really liked this article.
The GIL has its place and its reasons - it trades a certain flexibility for lockless performance (that is, you don't end up sprinkling locks all over to make up for its absence, costing single-core performance). I don't always like it but multiprocessing and queues dodges all that for multi-core use cases. I'm not here to evangelize for it though, just noting that if going from Py2 to Py3 was challenging for people (despite the often mild rework typically required, most of which can be automated), going from Perl 5 to Perl 6 is a whole new level of complicated. Given the time Perl 5 has remained relatively constant in terms of backward compatibility, it's well-entrenched. As for Perl 6, perhaps it is performant, or has excellent modules, but that wasn't my point. I simply wonder (as the author of the article does) if Perl 6, so long delayed and so different from Perl 5 as to be more of a new language than part of an upgrade path, is going to take off?
If Perl 5 was good enough that the core language was "done", there would be no Perl 6 such as it is... there would just be further iterations on Perl 5, with backward compatibility retained as much as possible. But what living coding language is ever "done"? Usually the definition of done is either "nobody uses it much anymore" or "it's got so much tech debt that we need to make a clean break". More often, things either continue to be refined and improved (with deprecations and other breaks with backward compatibility as necessary to move forward), or they fork and diverge. My only point here (because I'm using those other languages for illustration and in the case of Python, roadmap/rollout comparison) is that Perl is effectively forking itself, and as forks even half this late in the game are tough to get traction on, it seems unlikely that Perl 6 as-named will get traction. It may be the best thing since sliced... slices... but it's burdened by a name and version number that suggest uprev, not revolution. Either way, time will tell.
For modules, you do not need need admin rights. . Just use (where Makefile.PL is the from the extracted module downloaded from CPAN) perl Makefile.PL PREFIX=$USER/scripts/modules make make test make install if you need to use a nonstandard dependency too, make sure you update the PERL5LIB= environment variable to point to the dependency's directory 
Well, the main difference is that Perl5 is going nowhere. There's no upgrade path, at all. There's no parallel between Perl 5/6 and the Python 2/3 *transition*. It's not a transition. So, use Perl6 if it's good and don't use it if it doesn't fit. &gt; is going to take off? Most companies using Perl5 seem to think so, because the language is just too good. They are the ones paying for Perl6 development. If they are paying for it, one expects they want to make use of it in the future. Yes, it took time to get ^^(^somewhat) right and [they already a list of things they got wrong since release](https://github.com/perl6/6.d-prep/blob/master/TODO/FEATURES.md). But they are going for the long game.
The link to the videos leads to a facebook page, and then I'm lost. Note that I have no account in there.
Yeah, I was not happy about the Facebook link either, but that what the organizers provided.
Perl 5 and 6 are different languages.
[removed]
Guy who's been using Perl for quite a while here: I tend to agree with your assessment.
You must be a Perl 5 folk. I think Perl 6 folks have every intention to replace or succeed over Perl 5.
The videos are all on YouTube as well now. * https://www.youtube.com/channel/UCd9Fs_oZBMmTUWKJKuR_qdg I have no idea why they all started off on such a suboptimal platform. But I'm glad that they exist.
To clarify, the end-goal is that you write something like: macro backwards (Block $block) { my $doc = PPI::Document-&gt;new; $doc-&gt;add_element($_) foreach reverse $block-&gt;first_element-&gt;first_element-&gt;elements; return $doc } This gives you the power of `PPI::Document` parse trees as the datastructure to represent code and the speed and efficiency of `Keyword::Define`'s `PPR`-based parsing which terminates at the end of the match. 
Nope.
also plenv
The mic ended up without battery so they had to use the one from the camera. It's really unfortunate.
You still seem to have some misconception here: Perl 6 is not (at least, not anymore) a fork of Perl 5, but a ground-up new language design that initially shared some concepts. There *are* further iterations on Perl 5 and will be for the forseeable future. And that's why you're correct that the name is a burden, as has been [previously discussed](https://www.reddit.com/r/perl6/comments/6lstq3/the_hot_new_language_named_rakudo/).
No, there is general agreement on this much. Note that https://perl6.org/ and https://www.perl.org/ both describe them as sister languages.
The [cpantesters matrix](http://matrix.cpantesters.org/?dist=Log-Log4perl+1.49) for the latest version on windows doesn't look promising. You can always force install it (install regardless of the failed test) and hope that one failed test doesn't indicate a problem you will run into yourself. (This failed test looks very different from the one in that perlmonks post, btw). You might also consider searching for [existing bugs](https://rt.cpan.org/Public/Dist/Display.html?Name=Log-Log4perl) or [reporting a bug](https://rt.cpan.org/Public/Bug/Report.html?Queue=Log-Log4perl).
Nice project. What you have looks fine so far, although I'd suggest starting with .WAV files or reading directly from the audio system. Some other modules that may help: * https://metacpan.org/pod/Audio::PortAudio - for reading the live stream of audio * https://metacpan.org/pod/Math::FFT - for the FFT, best to apply a window to the input and you'd need the magnitudes from the result. * https://metacpan.org/pod/Tickit - for terminal rendering Output is typically rendered as logarithmic in both axes. 
It's really never too late to change names, though it looks very unlikely here. I get it, and what led to it, but names stick. If you have to explain at length that Perl 6 isn't really a successor to Perl 5, odds are most people won't get it because they'll never hear it. To most users, Perl is pretty much Perl, because 5.x hasn't changed so significantly over time as to require significant migration efforts... but now Perl is really *Perl 5.whatever* and *Perl 6 or greater* (at least in terms of names and history), and one has to dive in to find out just how disjoint the two sets are. I'm trying to think of any other language that from the outside is major revision +1 (and where that previous one wasn't some half-baked 0.1 or 1.0) and yet is mostly different inside, just for a comparison that's better than the major rev +1 I had above, and which gained traction. Perhaps another way to look at it is, where will developers and contributors focus their efforts? It's work enough supporting functionality spanning the usual major revision boundary in most languages, let alone effectively supporting two different languages. However different the names are, that dilution of effort can be a problem in itself. And that's why, as I see it, Perl 6 looks to be a hard and confusing sell. But who knows? It might eventually supplant Perl 5... or there might be a Perl 7 someday that is disjoint from the other two. The way this effectively turns one language into two ongoing languages is the main problem IMHO - unless Perl 6 omits functionality / capability present in Perl 5 (which I'm not gathering from here), people should be encouraged to move to Perl 6, and Perl 5 should get a sunset date. While the naming issue may be a closed question, the rationale for keeping Perl 5 alive *indefinitely* is very unclear. Perl 6 may be a new language more or less, but if it is functionally everything that Perl 5 is then people should be encouraged to move along to Perl 6, lest Perl 6 starve for development.
You're still equating Perl 6 with too much of Perl 5. They are *completely* separate languages, they have (with small overlaps, as with any other languages) different developers, different internals, different designs, and different goals. The reason the name is so confusing is because it engenders this perspective of "new version of the same language", when in fact Perl 6 is as much a Perl 5 successor as Ruby is. The Perl 5 development team is active and has no intention of sunsetting or doing anything with Perl 6 except lift neat ideas from it and cooperate at the community and infrastructure level.
If it's going to be like Cava I should probably just have it directly read ALSA, Pulseaudio, or OSS. EDIT: I'm sort of having trouble understand the `Math::FFT` library but it's also late at night here at the moment of this edit so maybe I should break and with until tomorrow to try and look at it some more. Maybe it's a matter of understanding FFT itself.
Thankfully the videos uploaded to Facebook are not the official ones, we're still waiting for the official videos which are in post-production. But I still wonder about the sound for the videos that were recorded without the mic.
Force installing did not work. I also saw a bug report of the same issue back from December 2016 but was hoping I could find a fix here. Thank you though. 
Maybe I'm getting confused between conferences... There was GUADEC, DebConf and TPCiA all at the same time.
I think he kinda sorta has a point in that perl5 and perl6 may be two different languages that appeal to the same sort of people, so they could end up splitting the user base. Of course, any new tech has the potential to be divisive in this sense... 
Also you may use an IDE to format text.
I don't have a direct answer to your question, but you might want to look at how [other authors](https://metacpan.org/requires/module/PPR?sort=[[2,1]]) have used PPR (on the other hand matt's code can be a bit impenetrable at times)
Yes, portaudio should be easy to get started with, also makes it slightly more portable than using any of the other audio systems. At a guess, the basics for the FFT part would involve: * apply FFT to data my $fft = Math::FFT-&gt;new(\@points); my $spectrum = $fft-&gt;spctrm(window =&gt; 'hann'); * render the points in $spectrum Have a look at the portaudio VU meter example here: https://metacpan.org/source/JDIEPEN/Audio-PortAudio-0.03/eg/vumeter.pl Hopefully that should be something you can adapt to work with the FFT instead.
I think every language has an intent to see success. But not sure many set out to actively replace, that was certainly the original plan behind Perl 6 before it became outrageously different to the point an upgrade path was utterly non-trivial. Given the main plan is for Inline::Perl5 to be that pathway its not replacing its augmenting and expanding.
Thanks!
Thanks for the replies (and others). I accept the answers. Now another question: do we have kind of a non-spoken consensus that really at this point that Perl6 called Perl6 is not doing anything good -- for both perl5 and perl6? I use Perl and teaches and promotes Perl at every influence I can get. Since the release of Perl6, I often find the need to emphasize it is Perl5 that I was referring to. And every time I would get a little annoyed doing so. There is no way to put two camels in the same (name)space that you can pretend they are not affecting each other. Perl5 (and Perl 1-4) and Perl6 are different languages. They have complete different philosophies. One is looking at practicality, the other is aiming at ideology. That is OK, but can we follow the example of APL and J? 
This reasoning requires examination. If one is already committed to Perl6, then having the feature that allow calling Perl5/Python/C where Perl6 fall short may be a merit. But if Perl5 is mostly what you want, then having perl6 call perl5 always add extra complications. I use Perl5 for most every thing and used to write xs where speed matters. But xs makes my perl cumberson and my C ugly. So I switched to write stand-alone C for speed critical parts and let Perl to call it via IPC. It has been a much better solution for all of my cases. With that experience, I start to wonder how the current Perl5 can be made simpler and cleaner removing these XS feature? -- Maybe another fork called Perl4?
There is a project like that already, it's called Perl6.
Hehe, funny
&gt; the rationale for keeping Perl 5 alive indefinitely is very unclear It works better than Rakudo. That's very clear.
You may consider [libffi](https://metacpan.org/pod/FFI::Platypus) as a much simpler alternative to XS for interfacing with an external C (or other compiled machine code) library. There's also a [NativeCall](https://metacpan.org/pod/NativeCall) wrapper presenting an interface similar to that in Perl 6.
Ah, you remind me of a [young Zoffix](http://backpan.perl.org/modules/by-authors/id/Z/ZO/ZOFFIX/)! &gt; Yeah, all of the distros are trivial and most of them classify as crap Eh, it's still a good learning experience. Glad you're enjoying Perl this much!
As soon as I use Rakudo daily, I'll be pushing out some Rakudo modules :)
&gt; It is like double celebration for me, as we celebrated 70th year of independence, yesterday i.e. 15th Aug. We're not that far apart. For us tomorrow the 17th of Aug will be the 72nd year of independence.
&gt; Well, the main difference is that Perl5 is going nowhere. There's no upgrade path, at all. I'm planning on upgrading to perl 5.24, myself. Not that I have anything against perl 6. 
There's no upgrade path from 5 to 6.
&gt; that Perl6 called Perl6 is not doing anything good There's no particular consensus, but most perl people are tired of talking about the issue. Actually, I guess there is a rough consensus on one thing: Larry gets to call his project "Perl" if he wants to. It's not the worst naming clusterfuck in the history of computers (I would vote for java and javascript, myself). 
Actually, I'd figure one out if that's what I wanted. Someone else has already mentioned an "Inline" module. 
I use perltidy every day and have for 15 plus years. It is the ultimate Perl code formatter. If you don't like the way it formats your code, you can override the default settings several ways. I used to do this but have since decided that I am fine with the defaults. It will address the problems you describe. You can install this on any system using local::lib - see the module pod for bootstrap instructions to get started. The install is local to a directory where you have wrote access. local::lib prefixes these directories in @INC Good Luck lbe
Yes, there are migration tools, but it's not an upgrade and Perl5 won't stop being developed.
I was expecting at least a mention of https://metacpan.org/pod/DBD::SQLite#$dbh-%3Esqlite_progress_handler(-$n_opcodes,-$code_ref-) - as it is, this isn't really sqlite-specific.
&gt; PREFIX=$USER/scripts/modules Do not use `PREFIX`, use [`INSTALL_BASE`](http://p3rl.org/ExtUtils::MakeMaker#INSTALL_BASE) instead. And you forgot about Module::Build based installers. &gt; make sure you update the PERL5LIB= environment variable and the PATH… At this point it's easier to just use [local::lib](http://p3rl.org/local::lib) which handles all those details correctly.
This is fantastic! Testing hardware projects is always a challenge, and this kind of standardized setup is the way to go.
Add [GStreamer Perl bindings](http://p3rl.org/GStreamer1) for decoding audio files.
Aha, dari Indonesia? I attended the celebration of the 17th of August at the Indonesian embassy in my country the other day. Happy independence! 
On the "adding a license"...is there a list somewhere of modules that need it added?
Try the "lab" on Single-Page MetaCPAN front-end at http://cpan.perlmaven.com/ that I've just updated to use v1.
Thanks!
Wow, I've been looking for *exactly* this. Thanks! (Also, I recognise your name, and portrait. You're definitely known for some famous CPAN module or another, no?)
https://geekuni.com/
[Perl 5 Essential Training] (https://www.lynda.com/Perl-tutorials/Perl-5-Essential-Training/447321-2.html) by Lynda.com
not a course, there are these two free online books [Beginning Perl](https://www.perl.org/books/beginning-perl/) , [Modern Perl](http://modernperlbooks.com/books/modern_perl_2016/index.html) which are both very good
That version of "Beginning Perl" is looking a bit dated now. There have been two updated editions and then [a whole new book with the same title](https://www.amazon.co.uk/Beginning-Perl-Programmer-Programmerwrox-Guides/dp/1118013840/) since that one was published.
I agree it is dated. However, i used it a year ago to learn perl. I found it very useful. 
[The O'Reilly School of Technology](http://archive.oreilly.com/oreillyschool/courses/courses.html#course_id_128) Not sure if "good" or "bad".
Question: Is the using the unicode character `⚛` the final implementation? If so am I missing something? It seems incredibly unwieldy and awkward. I honestly have no clue how I would even type that outside of mobile let alone quickly while programming.
&gt; Question: Is the using the unicode character ⚛ the final implementation? It's yet to be ratified to be officially part of the released language version, but so far there doesn't appear to be any reason to change the atom symbol. &gt; If so am I missing something? It seems incredibly unwieldy and awkward. Yes, you're missing knowledge of convenient ways of typing Unicode characters outside of ASCII subset 😛 There are many ways to type them—[the docs list a couple of them](https://docs.perl6.org/language/unicode_entry). On my setup, typing `⚛` is just a single key-press, no different than typing `a` &gt; I honestly have no clue how I would even type that outside of mobile let alone quickly while programming. If you find fancy Unicode a struggle, Rakudo provides what are known as [*Texas variants*](https://docs.perl6.org/language/unicode_texas) which are ASCII-only alternatives. Since atomics aren't an oft-used feature, their Texas versions are just subs: ⚛= | atomic-assign ⚛ | atomic-fetch ⚛+= | atomic-add-fetch ⚛-= | atomic-sub-fetch ++⚛ | atomic-inc-fetch ⚛++ | atomic-fetch-inc --⚛ | atomic-dec-fetch ⚛-- | atomic-fetch-dec ~~P.S.: speaking of finality and implementations, I plan to put forward a suggestion to rename `atomic-add-fetch` and `atomic-sub-fetch` to `atomic-add-assign` and `atomic-sub-assign`.~~ EDIT: nope, I was wrong. The current names make far more sense.
Could we please introduce markdown? If there is one thing I hate about Perl, it's POD.
&gt; Yes, you're missing knowledge of convenient ways of typing Unicode characters outside of ASCII subset. There are many ways to type them—the docs list a couple of them. Unfortunately the docs examples are largely limited to *nix work spaces. While I prefer Linux for many things I don't run any of my IDEs in a Linux environment. &gt; On my setup, typing `⚛` is just a single key-press, no different than typing `a` I checked your comment history to see if you discussed this elsewhere and looked at the comments on your post in /r/perl6 about this. We have almost the same keyboard. I have the K95 RGB as well but with a slightly different layout(e.g. standard key sizes.) Even with those keys at our disposal it's still awkward as hell to deal with. I couldn't imagine trying to work the G keys into my regular typing flow. With the exception of just a few all the G keys require my left hand to leave home row to hit, and I have big hands. I wound up taking some rubber adhesive nubs from an old mouse(naga, nubs were for helping you find the thumb keys) and put them on the G3, G12, and G18 keys so I can just feel with my pinky instead of hoping I hit the right one. Personally I have no dog in this fight. I just found it interesting that a unicode character would be used as an operator when it doesn't seem like desktop support/accessibility for unicode input isn't up to the task.
I guess different people have different tolerances for how much effort they're willing to go to type Unicode. But as I always say, we have Texas versions for that exact reason: you're not forced to use fancy Unicode if you don't like it.
It's defunct now.
I would suggest Java, you find some of it very similar to perl (from the C style). It also has really nice documentation. However, this would put you very much in the android world. 
I programmed (mostly) Perl professionally for, I dunno, 11 years or so (I do Node.js now) and of your short list I think Rust is the most interesting. It's kind of a great mix of both mind expanding and practical, I definitely plan on my next personal little project being in it, whatever that may be. I also found moving to Node.js very smooth from Perl, but I did already know JavaScript and 90% of my Perl programming had been event loop based already so it was kind of a natural progression for me. You haven't really said what you want to do though. If it's really just for fun, well, Perl 6 is _right there_ and really really cool. Personally I find Java has waaaay too much boilerplate for my taste. It feels very verbose by comparison to languages like Perl or even Python.
look at http://dlang.org/ ... it's how Perl 6 might have looked like if it was designed by structural engineers instead of academics 
C and Javascript for the web. Both look similar to Perl apart from the sigils. I'd actually learn some assembly as well, it helps a lot to understand how computers work. Which is very similar to Perl: there are no types. :D Assembly also helps to understand C much better. I feel that both Java and Python, especially Java, have too much boilerplate. I think Java is the most horrible, ugly and tasteless language in the world. It's not a coincidence that a whole lot of other languages appeared that run on the JVM. I'm very interested in Clojure, which is a Lisp for the JVM.
Most IDEs already do things like ligatures for operators. But you could genuinely have a nice Perl 6 environment that just replaces :atom: when typed with the unicode. On Mac its surprisingly easy to do this stuff, there is universal system level input support for emojii and maths symbols `ctrl+cmd+space` brings up the context sensitive menu on any text box, you then just type "atom" to search then hit `enter`. Some of the arguments around should unicode be in source I find a little odd. We've never really had a language that supported it so nearly all the negativity is not based on experience of how good/bad this might be. Meanwhile I have seen a huge trend in git commit messages having emojii codes for what the commit is about and I find that really quite useful. 
Just wading back in with a docs suggestion: add something there for Windows users as some of us have to deal with that I'm at work right now (and was yesterday when we discussed in /r/perl6) and I couldn't get any of the methods (that didn't require me to learn about / set something up) to work on a stock install of Ubuntu Mate either :(. **Edit: so it turns out I have to press `&lt;shift&gt;&lt;alt gr&gt;`, I was pressing `&lt;alt gr&gt;&lt;shift&gt;`. Compose works by default on Mate for me** For me the (tedious) method for getting a unicode character is to google it, find a page listing it and paste it in where I need it. I really don't want to do this when programming
Would you be able to open an Issue on our docs repo, so this could be addressed? https://github.com/perl6/doc/issues/new I can give you a commit bit if you are able to improve the docs. Just tell me your GitHub username.
Sure, I'll try to take a look soon. GitHub username is the same as here, pwr22
I sent you an invite to `perl6` GitHub org; you can accept it on https://github.com/perl6 That gives you commit access to most perl6 repos. Happy contributing!
Thanks, I added an issue [here](https://github.com/perl6/doc/issues/1467)
This language has no chance in business if a major mutex handler is presented as an emoji. It's annoying enough to type that, but I can't even read it. How would I present this at a code review?
ES6. It fills in some things missing in JavaScript, in a way that feels like the better parts of Perl. Matt Trout had a good talk about it at TPC this year: https://www.youtube.com/watch?v=OwCAFPKwAyE
Hi \o. There's a lot of information lacking in your question, which makes giving the correct answer difficult. Like, what are you using to serve the content, what code you have, etc. A shot-in-the-dark answer could be [configuring your server to wait longer](http://httpd.apache.org/docs/2.0/mod/core.html#timeout), but without knowing more about your situation, that may be a detrimental answer.
That's a good question! The emoji version of these operators is typically for Unicode-savvy folks working in Unicode-friendly environments. There are [ASCII-only alternatives, called "Texas variants",](https://docs.perl6.org/language/unicode_texas#Atomic_Operators) available for the atomic ops, as well as any other language construct that uses non-ASCII Unicode symbols. If a business sees an issue with using Unicode operators, they can simply adopt a policy that all programmers must use the ASCII-only alternatives.
My suggestion would be to [learn Rakudo](https://perl6.org/resources/). [Rust](https://doc.rust-lang.org/book/) is very nice too, and I see you already have it on your list :)
If increasing your timeout isn't an option, as it wasn't when I ran into this, you might try what worked for me: every 100th record I print to the stderr log. print STDERR "This is not an error. Keepalive" if($counter % 100 == 0);
Maybe you should try Go. It is fast and simple enough and could run on Windows, Unix/Linux, and Apple.
I haven't tried it yet but I'm intrigued by Dart. Write your backend plus web and mobile frontends in the same language.
Ah good to know. I did the Python one years ago.
If you're interested in smartphone apps, then you don't have tons of options if you don't want to deal with shitty frameworks between you and the native api. Starting learning Android programming in their Java dialect has tons of resources. 
If you haven't gone there already, I'd suggest you look at the R statistical language. It's by no means "like perl", but it's culture has some things in common: venerable, many choices in packages to play with, some cruft accumulated, but with many good write-ups out there to help you navigate around the traps-- there are lots of good books out there, e.g. from O'Reilly, which has just published the Wickham and Grolemund book "R for Data Science"-- Hadley Wickham and his cohorts are the people to watch in R package development. Perl6 is also pretty interesting, and somewhat underrated at present (in my opinion). There are lots of different tasks that need a CPAN module in perl5 (which means you have to sort through and evaluate a dozen CPAN modules to find the one you really want) which can be done with built-in features in Perl6. Though neither of those will get you very far in the embedded device space (actually, I've known some perl programmers working with perl embedded in networking equipment... I can't say they seemed like they were having a lot of fun with it). 
Larry Wall is not usually described as an "academic". In point of fact, the actual academics were running what amounts to a smear campaign against perl (*uglyuglygluguglguguglly!*)-- why you would trust people who thought lisp was the ultimate language has always been beyond me.
Your usage of Perl sounds similar to mine other than my infomatics topic is not bio related. My acquaintance with perl even predates yours :) Lately, I have been asking myself the same question. I've squarely landed on keeping perl5 for many things because I am still much more efficient with it than other options. I am supplementing perl5 with JavaScript with Node.js and NW.js and/or Electron as well as Rust. My rationale is that JavaScript is pretty broadly consumable by many of the people I work with whereas perl makes them roll eyes - heathens they be! Rust allows me to get bare metal high performance without the frustrations of C++ or the risks of C. Rust also allows me to build libraries that can be interfaced with perl (via FFI) without having to deal with C and XS. To any potential flamers, please note that the above is a statement of my personal opinion. Use it as you desire. If you like what I have written, thank you. If you don't, then ignore what I have written as I will likely ignore anything that you write me about it :)
If it takes the request up to an hour to run, there's many better ways to handle the problem. You could: * Receive the request and start the job as a background task and update a database when complete and display the most recent result on a page somewhere. * Run the task as a cron (or scheduled in some way) and similarly show the most recent result. * Possibly optimize the task so it doesn't take an hour or break it up into smaller parts? There's pretty much no great reason to require an HTTP request to stay open for an hour.
yeah i have decided to use a sql db instead. thanks
Aside from Rakudo Perl 6, JavaScript ES6/2017, and others, you could also try [Scala](https://www.scala-lang.org). garu (the maintainer of [Data::Printer](https://metacpan.org/pod/Data::Printer)) wrote a [guide](https://github.com/garu/scala-for-perl5-programmers) sometime ago. And for whatever language you finally settle on, check out [Exercism](http://exercism.io/) to get up to speed on that language via short problems.
PerlTidy is simply the right tool to use. It is an excellent code formatting tool and highly configurable. We recent adopted the Perl Best Practice code style and are enforcing them using PerlTidy. PerlTidy can also be integrated into most IDEs and editors so it's super easy to ensure you have a consistent code style without any thought necessary really. 
Benar sekali. Which country is that? I assume the embassy also held "pesta rakyat" games like we do in our home country. 
Regarding DateTime vs Time::Moment: there isn't yet a lightweight alternative for DateTime::Duration. I'd happily dump DateTime for most usage if there were such alternative.
Some prior arts: Data::Rmap (a generic data structure node walking module), Data::Abridge, Data::Visitor::Callback, and my own Data::Clean. According to [my benchmark](https://metacpan.org/pod/release/PERLANCAR/Bencher-Scenarios-DataCleansing-0.004/lib/Bencher/Scenario/DataCleansing/Object_DateTime.pm), Data::Clean can be several times faster than Data::Tersify, because it first generates customized code to do the transformation.
Nor is there a lightweight alternative with full IANA time zone and CLDR locale support.
Yes, DateTime is impressive and more "compliant" than other modules in existence, which is why I added the word _most_. It's definitely _not_ lightweight though. You get a significant startup overhead if you're a one-off CLI. You also get significant memory usage overhead if you're creating thousands of DateTime objects.
Also, here's my countersuggestion because the article doesn't mention any reasoning behind some of the suggestions: * JSON::PP is useful when you need to use a pure-perl (e.g. in fatpacked script) or core-only module (currently there is no XS JSON module provided in core distribution) * JSON::MaybeXS can be useful in same case like the above, but want to switch to an XS module for speed when available. * File::Slurp: also try slurping manually yourself (without any module), or File::Slurper. * Acme::Damn. I think it's okay if you just need unblessing and not the other stuffs in Data::Structure::Util. 
Added some clarification that DateTime::Tiny was recommended in our specific situation only.
Sweden. Yes, there was a pesta rakyat, but unfortunately it was on Saturday and we couldn't go that day :-)
I'd list out `JSON::XS`, with `Cpanel::JSON::XS` being preferred. The original module has some longstanding bugs, like: #!perl use strict; use JSON::XS; my %data = ( foo =&gt; "NaN" + 1, # Creates floating point NaN ); # This dies with: 'null' expected, at character offset 7 (before "nan}") decode_json( encode_json( \%data ) ); According to the official JSON spec, NaN/Inf/-Inf don't exist. They're supposed to be encoded as null.
Plus JSON::MaybeXS was written, not just to allow such switching, but to be a point of collaboration so that if we end up with maintainance issues again JSON::MaybeXS can switch out the default XS implementation and everything will just follow. Hard-coding Cpanel::JSON::XS all over your codebase is basically risking needing to make a massive change later, though it's an entirely reasonable decision to make if your build system for whatever reason doesn't handle JSON::MaybeXS correctly. But please, please use MaybeXS for CPAN code.
Obviously also as an attendee - but while I'll be submitting a perl-related talk there's probably a bunch more good stuff other people can do. -- mst (edit: also if you fancy coming from elsewhere, cool, but I was figuring UK people were more likely to submit ... and if anybody's upset by this being sort-of-an-advertising post welp, I want MOAR PERL TALKS and also it's our first year of attempting this lunacy so we need all the help we can get ;)
"Deploy" doesn't appear to be a CPAN module, but from the comment, it appears to be similar in purpose to [IPC::System::Simple](https://metacpan.org/pod/IPC::System::Simple), which I highly recommend. It wasn't really explained why cpan or cpanm can't be used, but I would tend to leverage [cpan-outdated](https://metacpan.org/pod/distribution/cpan-outdated/script/cpan-outdated) with cpanm, or [Carton](https://metacpan.org/pod/Carton) for this sort of operation. Despite the documentation, Carton can be used as a sort of 'local::lib manager' without having to use it to load the lib directory itself.
You can run `perl -ne "print if /ERROR #[0-9]/"`, but why not just use `grep`?
You can't use regex with grep. Thanks! Didn't know about the -ne. What does the n stand for?
 # man egrep or # grep -E '/regex/' &lt;file&gt; With perl one-liners: # -p = print all unless told not to # -n = don't print all unless told to
 man grep &gt; grep understands three different versions of regular expression syntax: “basic” (BRE), “extended” (ERE) and “perl” (PRCE). &gt; In GNU grep, there is no difference in available functionality between basic and extended syntaxes. &gt; In other implementations, basic regular expressions are less powerful. &gt; &gt; -E, --extended-regexp &gt; &gt; Interpret PATTERN as an extended regular expression (ERE, see below). (-E is specified by POSIX.) &gt; &gt; -G, --basic-regexp &gt; &gt; Interpret PATTERN as a basic regular expression (BRE, see below). This is the default. &gt; &gt; -P, --perl-regexp &gt; &gt; Interpret PATTERN as a Perl regular expression (PCRE, see below). This is highly experimental and grep -P may warn of unimplemented features. &amp;nbsp; &gt; What does the n stand for? No idea, but it does the same thing as `-p`, but without the auto-printing.
I live in Bristol walking distance from the venue and have used freenode for 14 years... I guess I should think about doing something.
Both -n and -p will wrap your script (the value of the -e option) in a while(&lt;&gt;) { ... } loop to run the script once for each line of input. The difference is that -p will also add a print inside the loop after your code. So yes, if you use -p it will print every line. If you want to print only matching lines then you need to use -n and a conditional print: perl -ne 'print if /ERROR #[0-9]/' or perl -ne '/ERROR #[0-9]/ &amp;&amp; print' A pattern I find really useful is: sometimes you don't want to print the whole line, so capture the interesting bit with parentheses in the regex and then print $1. The trick with this one is you'll need to add the newline: perl -ne '/ERROR #([0-9])/ &amp;&amp; print "$1\n"' or perl -nle '/ERROR #([0-9])/ &amp;&amp; print $1' or perl -nE '/ERROR #([0-9])/ &amp;&amp; say $1' 
`cat someFile.txt | grep -P "ERROR #[0-9]"`
I would rather use sed for this sort of thing sed -n '/Error [0-9]/p' &lt; someFile.txt
Where's the venue? I can't seem to find it on the page Edit: nvm, found it's @Bristol. I'll probably pop along then :)
[ack](https://beyondgrep.com/) is written in Perl
Wat? A regex is the only thing you can use with grep 
 foo | perl -nle 'print if /ERROR #[0-9]/' The -l is strictly speaking not necessary, it'll remove newlines from the input strings and add them on `print`, so you can more easily reformat the output.
&gt; why not just use grep? Because of *perl* regexes? Not in this simple example, though. Also: for additional line by line processing, in perl
To add to what others have pointed out, you could also help yourself on why your command doesn't work by taking a look at how perl understands it, via [B::Deparse](http://perldoc.perl.org/B/Deparse.html): % perl -MO=Deparse -pe "/ERROR #[0-9]/" LINE: while (defined($_ = readline ARGV)) { /ERROR #[0-9]/; } continue { die "-p destination: $!\n" unless print $_; } -e syntax OK % As you can see plainly, the only one `print` in the expansion of `"/ERROR #[0-9]/"` is in a `continue` block, which means it will print lines regardless of the match: not what would you expect. Compare this with `perl -ne "print if /ERROR #[0-9]/"`: % perl -MO=Deparse -ne "print if /ERROR #[0-9]/" LINE: while (defined($_ = readline ARGV)) { print $_ if /ERROR #[0-9]/; } -e syntax OK 
This and [ag](https://github.com/ggreer/the_silver_searcher) are secretly the best answer :)
AutoHotKey would be a good solution for Windows.
Thanks for the suggestion, i'm thinking so too
Lol at hot link prevention.
This `.htaccess` in old location did the trick: RewriteEngine on RewriteBase / RewriteRule (.*) http://newdomain.com [R=301,L] 
Comparison with the existing Object::Remote, perhaps?
I find it hard to believe force installing wouldn't work. You could always do `cpanm -n Log::Log4perl` This will skip tests when installing. Whats probably happening is the appender is creating the entry with windows line endings and the test is hard coded to expect unix line endings.
I will clarify, yes force installing installed it, but it was still non functional. 
I'm having a bit of trouble following what you're trying to do... Can you show some sample code to demonstrate what is currently being done? If it's all in the same DB though, one connection held open should suffice. How fast is the data being read? How are rows in a given table kept distinct?
$_: whatever is next in the list/array. Can also be used with opening and reading lines from a file. Grep: searching through an array. Just like grepping for words in a file on terminal. Overall its searching for all numbers from 0 to 2017 that contain 5. Scalar means to return the number of matches found. 544 numbers in that range contain the number 5
http://perldoc.perl.org/functions/grep.html should explain most of what is going on. `grep` is a function, which takes a block of code and a list (0..2017 creates a list of the numbers 0, 1, 2, ... 2016, 2017) and only returns the input elements where the block of code returns true. It sets `$_` (the "default" superglobal used by several similar functions) to each element of the list when running the block of code. The block of code in this case checks whether the input matches the regular expression `/5/`, which matches if there's a 5 in the string. (Side note: `$_ =~ /5/` can also just be written as `/5/`, since the match operator matches `$_` by default already.) Since grep is forced to scalar context by the scalar operator (http://perldoc.perl.org/functions/scalar.html) then it returns the number of list elements that matched, not the list elements themselves. For general perl tutorials check out the link from the sidebar: http://perl-tutorial.org/
This is actually a compound statement that chains several things together. Let's start from the right at the beginning and work it through. 0 .. 2017 This generates an array of numbers from 0 through 2017, inclusive. That array is passed to the next part of the statement. grep { $_ =~ /5/ } Grep here is taking a code block (the stuff between the {} ), executing that code block for every element of the array, and saving any element that the block returns true for. Let's go through the code block too. Perl has a special feature that in certain circumstances (typically loops, but also grep) it will alias the current element of an input array to $_. /5/ is a regular expression (regex) that matches "5". The =~operator says to match the regex against the variable on the left of the operator. So, back to the grep... put that all together and the grep is looking for any number in the array that has 5 in it. Then scalar returns the number of elements in the array that came from grep. And print, obviously, prints that number. 
Thanks. This was extremely helpful 
Thanks 
Thanks. This really helped 
Nitpick: 0..2017 is a list. `grep` takes a list. No arrays are involved in this code; array is a type of variable.
Let me specify the db architecture a bit more. This is a simplification and I'll likely need to do a bit more research before I have a better understanding of the requirements (small team, independence is expected of me). How the db is set up: Database name = content Relevant schemas: 1. master 2. subset1 3. subset2 4. subset3 Tables(containing columns: ): Master-&gt; TableA(containing columns: A_id, random_string) , TableB (B_id, random_int), TableC (C_id, B_id, random_int), TableD (D_id, C_id, B_id, random_int, random_float) B_id to C_id has a 1 to many relationship. In TableA, A_ids are all unique. In TableB, B_ids are all unique. In TableC, C_ids are all unique In TableD, D_ids are all unique. There is no intersection of B_id and C_id (totally unique) A_id is the distinct union of B_id and C_id. subset1-&gt; TableB, TableC, TableD (where TableB, TableC, TableD are subsets of the tables in Master) subset2-&gt; TableB, TableC, TableD (same as above) subset3-&gt;TableB, TableC, TableD (same as above) ==================================== The goal here is to export each table in each schema (including Master) to a separate file, either a CSV or another special kind of file. Additionally, I have to essentially create a TableA on the fly for each "sub" schema where B_id is unique. The only identifier I have on hand is an array of "random_float" for each schema. Therefore, if subset3 has a random_float that is NOT in my subset3_array[] i have to skip it. Overall, we currently have 20-30 schemas to export, each which contain 100s of thousands - 100s of millions D_ids (i only ahve access to a stripped down dev environment and i forget how many are in production at the moment but i know its a lot). I hope this clears it up a little bit. I can post some pseudocode later. 
Wonderfully clearly said. Much better than I was about to attempt. 
&gt; This generates an array of numbers from 0 through 2017, inclusive No. It generates a list of numbers, not an array. Arrays are not lists. &gt; scalar returns the number of elements in the array that came from grep The [documentation for `grep`](https://perldoc.perl.org/functions/grep.html) is very clear on this. In list context, it returns a list of the elements for which the expression in the block is true. In scalar context, it returns the number of elements for which the expression in the block is true. No arrays in this code at all. Arrays are not lists.
Here's a longer piece of code that does the same thing: my $count; foreach my $element (0 .. 2017) { if ($element =~ /5/) { $count++; } } print $count;
That sounds like a complicated schema. Of course perfectly possible to connect up with DBI and yank it all out, but (depending on the format you need) have to considered pg_dump or maybe some combo of PG's COPY command and maybe views or something?
Yup, good explanation. 
It's always possible to write it in FORTRAN after all.
`grep` searches through lists, not arrays.
Good point. A nitpick, but a legitimate one, because lists and arrays are not the same (very similar, but different enough).
My bad
It's not common. Perl manages strings and arrays and such in a way that avoids these issues. Now, it's always possible that the underlying C code has a bug, but this will be difficult to find. Generally speaking, buffer overflows are problems in languages that force you to manage everything yourself, such as C. Higher level languages, such as Perl or Python or even Java, rarely have these issues. When they fail, it's going to be down to the implementation, since the language itself makes guarantees about safely handling memory. If anything, I'd expect Perl6 to be *more* susceptible, because its codebase doesn't have a long history of smoking out issues. Where you're most likely to find issues is in modules that link to C code. The `DBD::mysql` module had a bug like that a while back: http://blogs.perl.org/users/mike_b/2016/10/security-release---buffer-overflow-in-dbdmysql-perl-library.html As for famously insecure functions, Perl hashes in general were susceptible to algorithmic complexity attacks. This was thought to be fixed in 5.8.1, but it was later found that those fixes weren't good enough. They were further hardened in 5.18.0. Then, of course, there are the general classes of issues, such as SQL injection, XSS, or path traversal.
You can induce a legal sigsegv (or worse) by using pack: `perl -e 'unpack("p", pack("J", ~0))'`. Other than that what [u/frezik said](https://www.reddit.com/r/perl/comments/6wkpba/buffer_overflows_in_perl/dm8t7mm/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=perl) applies. &gt; ... I'm sure Perl 6 solves many security issues Given Rakudo is an incredibly complex codebase, not sharing anything with the Perl5 source tree, (re)written multiple times entirely from scratch, your claim above is a rather odd assumption to hold. 
&gt;your claim above is a rather odd assumption to hold. It's not an odd assumption for a person who is not fully immersed in the Perl ecosystem. Most people would assume that a major version increase is an upgrade to an existing project, not a completely new product entirely.
Indeed it is unfortunately a very expected assumption (at least, to most people outside the Perl 6 community, apparently). And that is why this discussion happened. https://www.reddit.com/r/perl6/comments/6lstq3/the_hot_new_language_named_rakudo/
Perl6 is more susceptible to these issues because it's very easy to interface with C.
&gt; (Side note: $_ =~ /5/ can also just be written as /5/, since the match operator matches $_ by default already.) Yup, I'm a bit rusty with Perl, so I forgot about that. (OP almost certainly saw that code in [one of my comments](https://www.reddit.com/r/answers/comments/6vvfpd/how_many_times_does_the_number_5_occur_between_0/dm4hp7g/?context=3).)
I don't know why Gabor would neglect to mention the new [Postfix Dereference Syntax](https://perldoc.perl.org/perlref.html#Postfix-Dereference-Syntax) as an option for those running a more modern Perl. `my @slice = $kings-&gt;@[2,4,1];` Available as an experimental feature in 5.20 and 5.22; stable under 5.24.
Don't use perl. Use pg_dump. In your case, you can use perl to extract the metadata, and construct the proper command line options for pg_dump. 
Slides for the talk given at SPW 2017. https://www.youtube.com/watch?v=6CsBDnTUJ3A
 “During a relatively short period of time from the mid- 1960s through the early 1970s, the ‘magic mineral’ was exposed for what it really was—probably the most hazardous industrial material ever unleashed on an unsuspecting world.” Swetonic spoke with sardonic authority: “I know. I was there.” https://cprlaw.com/wp-content/uploads/2016/02/AIA-Article-AJPH.pdf https://global.oup.com/academic/product/defending-the-indefensible-9780199534852?cc=us&amp;lang=en&amp; Context leads me to wonder if this is a fresh utterance or if he was alluding to an earlier usage. 
Here's my solution: https://pastebin.com/GtGpkY60 This problem intrigued me, I thought about it all night, and so I coded up a solution today. My solution only passes over the source string **once**, so even very long strings or strings that need to be read from disk are analyzable. I did this by starting a collection of state machines to keep track of each sequence and possible sequence. Once I've gotten to the end of the source string, it's easy enough to see if any of them has a complete "magical" sequence, and then to see which one is the longest. I also added some methods for nicely displaying the collected sequence, including the same format that was used in the example above. Here's the output showing the same string as in the example, a string with all of the characters but no "magic" sequence, and a random string of 100 characters. ============================================================ Max: 10 Seq: aeiiooouuu aeiaaioooaauuaeiou aei--iooo--uu----u ============================================================ Max: 0 Seq: - auaueuaueuiuaueuiuo ============================================================ Max: 23 Seq: aaeeiouuuuuuuuuuuuuuuuu ioooeeiioeeieiiuuuauuuuouooiiaeeoioauuiaoouiuuauieieuiuaauoeieeaiuuiaaeoaeaouueooeoioeoaeiuuuaaeieua ------------------a----------aee-io-uu----u-uu-u----u-u--u-------uu---------uu------------uuu-----u- 
Short answer: `$_` is "it" -- the current value in an iterative operation in this case, and `grep()` returns a list of all values in a list for which a given expression returns true. So read this as "print the scalar context of the list of items returned by iterating through the list of numbers `0..2017` and selecting the items for which 'it matches the regex `/5/`' is true".
This isn't quite right. The `/e` modifier means the *whole* replacement is an expression, not a string. So you would need to do: $myline =~ s/\bhi (\S+) (\S+)/'hi ' . ($1+$someNum) . ' ' . ($2+$someNum)/e; You can read about `/e` at the end of https://metacpan.org/pod/perlretut#Search-and-replace and at https://metacpan.org/pod/perlop#s/PATTERN/REPLACEMENT/msixpodualngcer . EDIT: Parentheses are needed as `.` and `+` are the same precedence.
He does now :-)
Pedantically, you don't want to do calculations inside a regex here. The regex in your example is `\bhi (\S+) (\S+)`. The rest of it is the substitution operator (`s/.../.../`). So, really, you want to carry out calculations in the replacement string of a substitution operator. And the solution is to use the `/e` option.
Do have any good links to show the difference? in a detailed level? Thanks
There is another trick to perform math, or anything else within the second string of the `s///` expression. It works anywhere when interpolating stuff into strings. String interpolation works with scalars and arrays only. But you can turn ANY expression into an anonymous arrayref and then de-reference it: @{[ $a + $b, "$c$d" ]} In case of your substitution it works like this: $myline =~ s/\bhi (\S+) (\S+)/hi @{[ $1+$someNum ]} @{[ $2+someNum ]}/; EDIT: You could even use the fact that arrays are interpolated space-separated: $myline =~ s/\bhi (\S+) (\S+)/hi @{[ $1+$someNum, $2+someNum ]}/;
[Arrays vs. Lists in Perl: What's the Difference?](http://friedo.com/blog/2013/07/arrays-vs-lists-in-perl)
You probably can, but that doesn't mean you should. Perl is already a difficult language to read if you try to do too much on a single line, regex is even harder to read. Above almost every regex I use is 2 or 3 lines of comments explaining what i'm doing. Split the string into values using regex first, then use simple perl math, and then recombine them into a resultant string. It'll only take 3 or 4 lines of code and will be MUCH easier to read.
Looks good. thanks! 
Babycarting is not necessary because the `e` modifier exists.
It can be a convenient alternative though if most of the replacement is a string, so you don't need to concatenate a bunch of pieces.
A decent option for many cases, but won't always be easier to read, and is logically more complex so could lead to more bugs.
Here's another one: http://altreus.blogspot.com/2011/08/lists-and-things-made-of-lists.html
See also [CPAN modules for converting markdown to HTML](http://neilb.org/reviews/markdown.html). 
 $myline =~ s/\bhi (\S+) (\S+)/hi @{[ $1+$someNum, $2+someNum ]}/; $myline =~ s/\bhi (\S+) (\S+)/'hi ' . ($1+$someNum) . ' ' . ($2+someNum)/e; I think it's very obvious from the above 2 lines which one is the babycart and which one is the Ferrari. :D
It's just a bad assumption. Even if Rakudo P6 was an iterative improvement something like the optimiser+JIT is really memory unsafe. If perl5 had that sort of work done as an iterative change for 5.X it would increase the chance of buffer overflow attacks in using Perl 5. The assumption anything newer or higher numbered == better/safer/securer is naive in the extreme. Regardless of the full story of the relationship to number conventions in Perl land. PHP right now for example is introducing a JIT as standard so there it's actually the expected case and the OP is still wrong in their assumption. 
Gently Caress, that's unacceptable. `DBD::mysql` isn't just missing security bugs due to laziness, but because a small group is holding it hostage just so they don't have to update their applications for a new version. If the main project can't go forward, a fork is the only option.
That's not what really happened, audiatur et altera pars.
So what did really happen?
I am not involved, my understanding is likely imperfect. It's due to pali's own neglect of backward compatibility that 4.042 had to be reverted. In OP's post, pali does not link to the relevant discussion so that people can form their own opinion. There's a lot of frustration and bitterness expressed, and a promise to reapply the bugfixes without causing regressions: &lt;https://github.com/perl5-dbi/DBD-mysql/issues/117&gt; I feel that assigning CVEs (essentially forcing the causation of an outcome) and threatening a fork is extraordinary and raises tension beyond what is the average level of discourse in the Perl scene. I can't judge whether it's justified or not. If anyone has more public information that can shed light onto this matter, please share.
Unfortunately the maintainers have maintained complete silence since reverting the backwards incompatibility as well as all bugfixes that occurred in that version (https://github.com/perl5-dbi/DBD-mysql/compare/4.041...4.042). So there's no way of knowing how they feel about it, but it's clear they are not taking their promise seriously.
A lot of similar caveats to threads in Python also apply The [docs](https://metacpan.org/pod/threads) are a good place to start :)
Please read https://metacpan.org/pod/threads#WARNING and https://metacpan.org/pod/Perl::Critic::Policy::Freenode::Threads . Perl interpreter threads are not fast or lightweight, plus they introduce all the same problems of any true concurrent threading model, as most Perl code is not written to be thread safe. Depending what you are doing in those threads (the code you left out), either forking or an event loop are likely to serve your needs in a more bulletproof and performant manner. (This is not reflective of Rakudo Perl 6 threads, as that language and its implementation have been designed from the ground up for concurrent threaded operation.)
Ok, so I had read those docs and I guess I didn't really understand why they are officially discouraged. The way the docs were written made it sound like the reason was because people use them incorrectly. For more background, I am writing a script to execute embarrassingly parallel jobs. It just iterates through a list of elements and spins off one of these threads for each one to run a list of subroutines on. I wrote everything to be fully encapsulated, so none of the subs are trying to update global variables and I'm not passing any data structures by reference. I'm also not using anything outside of the core language (besides threads). So with that in mind... I know these are discouraged for a good reason. I'm just hoping for more of an explanation of why? What could/will go wrong. Will it just not be as fast as it could be in a different language? Will it be slower than the serialized version somehow? 
A very good policy to start with, just see [POSIX](https://metacpan.org/pod/POSIX#CAVEATS) for the mess that can happen if you rely on implicit imports too much; not to mention that it becomes very difficult to determine where functions are getting imported from. On the other hand, it can be annoying to use a module that has a sole purpose to import exactly 1 function (usually with a name similar to the module name) and have to repeat the function name every time you use it. For example, [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) once required explicit importing of 'try'. As usual, it's a judgment call, which is difficult to completely encompass in a Perl::Critic policy.
The main reason with that in mind would be that it will be slower and use more memory. The entire interpreter state is copied whenever you create a new thread, which can lead to unexpected oddities depending what happens to be loaded at that time. In contrast, forking on a unix-like operating system is Copy on Write, which means that memory is only copied when changes are made; this is a key part of the efficiency of forking. My suggestion for an option to run "embarassingly parallel" tasks you can encapsulate in a subroutine is [IO::Async::Function](https://metacpan.org/pod/IO::Async::Function). It abstracts all of the process creation and communication away, and indeed, on Windows it even uses interpreter threads behind the scenes (as forking is not really a better option there). There are of course many other options.
Ok perfect, thank you. This is exactly what I was looking for. I will take a look at that library then. For what it's worth, I'm working on learning some languages that handle this sort of stuff better. But I'm a sysadmin, so I have to use the tools I know for now while I learn the others in my spare time... That's how it goes though. 
ItPerl's official documentation, after describing all the good things you can do with threads, puts out a caveat: it basically says "don't use it". There are simply too many gotchas . You may like to use the module forks - it's a drop in replacement for threads. Only prob is that it spawns separate processes, and IPC between the price is via TCP. However, I find that perl code is not so much done where you need performance, but where you need to glue lots of different systems together. And if you are not worried about sending messages between the progs , the fork() intrinsic is just fine. However, if it really is vital to you to not copy the full footprint of your program , then you need to use IO::Async or similar
Threads don't work all that well in any language. Some say that writing non-trivial threading code is beyond human abilities. This is why there's so much focus on languages that can automatically parallelize (such as Perl6's hyperoperators), or on event loops that make more efficient use of I/O wait time. Perl's threads are basically the worst of both worlds, where they're just as complicated to program correctly as threads anywhere else, but also copy around a lot of memory like `fork()` does.
This might be a good candidate for parallelism via https://metacpan.org/pod/MCE
The post to the mailing list is somewhat disingenuous on pali's part as they don't link to the github discussion, which is [here](https://github.com/perl5-dbi/DBD-mysql/issues/117) - long story short, the changes can result in *corruption* of data and the "small group" is trying to prevent this from getting out resulting in, potentially, silent destruction of data for thousands of users if not tens (or hundreds) of thousands of users. The small group are those that pay attention, 99.9% of users do not.
I've used them with [Thread::Queue](http://p3rl.org/Thread::Queue) without problems. But I had to reduce the `stack_size` and carefully switch to requiring modules in the threads instead of using them from the main script. The "discouraged" just means you're not likely to get any help if they don't work for you.
Making readers aware of an identity that is not immediately obvious: Grinnz on reddit and Github == dbook﹫cpan.org on RT and lists.perl.org
 $bind_mesg = $ldap-&gt;bind("admedvtest\@AD.COM", password =&gt; $pwd); You've escaped `@` here to prevent array interpolation but there are other places in your code where you have not. filter =&gt; "mail=test.mail@ad.com" Alternatively you can use single quotes instead of double to prevent the need for escaping. You should place the following at the top of your code. use strict; use warnings; This will alert you of such issues. (Note you will then need to use `my` to declare your variables e.g. `my $mail = ...` like you have on the `for` loop) Not sure if this is the source of your problems but it's a start.
Except there are a *lot* of languages out there, and some of them do threads very well. One of my favourites in this area is G, the thing that powers http://www.ni.com/en-my/shop/labview.html
Personally I think the caveats are nonsense. It works fine, it's just you need to be aware that perl threads aren't lightweight. Most of the problems come from either that, or not realising that parallelism isn't a magic bullet, and it creates a whole new class of potential bugs as your execution flow becomes non deterministic. So it's much better suited to worker thread models than spawning ephemeral threads. And otherwise it's a lot smoother to IPC than fork would be. I would suggest Thread:: Queue is a must have though, as a way of passing information between threads. And otherwise be cautious about potential contention and race condition. This can be a problem with modules that often aren't thread safe. You can quite reliably hedge against that with locking or just using "require" within the thread, rather than "use" as a global, and not sharing scope between threads casually. 
That will work fine. Spawn the workers, feed them via Thread:: Queue and it will work beautifully. The reason they are discouraged IMO is a lack of understanding, leading to trivial misuse and horrific bugs. https://stackoverflow.com/q/26296206/2566198 For some examples.
Parallel::ForkManager is a very nice way of doing multitasking, and even works on older systems 
You could say that the caveats are acceptable, if you have a good understanding of how interpreter threads work in perl and how to work around and avoid the issues. But they're not nonsense. Almost every newbie that comes to perl, realizes there's something called "threads", and tries to use them, would have been better off using something else.
The same could be said of any concurrency though. It's a more complicated subject than it seems. 
Depending on what you're doing [GNU Parallel](https://www.gnu.org/software/parallel/) (written in Perl) is a surprisingly useful tool if you have trivially parallelizable programs based on input space.
[Perl Maven](https://www.reddit.com/r/perl/comments/6uywyh/online_courses)
Equal rights for robots! No more robot exclusion!
I use fork and waitpid in Perl 5 to do the same as "&amp;...wait"
It's not really what you asked for (in particular, 'something that compiles') but Elixir has a very different mindset to most other languages and might be something you'd find interesting
I have used Parallel::ForkManager and simple forking. Perl is one of my favourite languages but it is not the language that I would choose for concurrency. It does not relinquish memory and it uses a lot of memory for reasons explained elsewhere in the discussion. But I will say two things about threads: a) do your best to live without them until you think you can't; and then b) prove that you can't do (a). If you decide to use threads in any non-trivial way, you will open yourself to a very difficult and expensive class of code defects. If I were going to experiment further, I would read about Thread::Queue and https://metacpan.org/pod/distribution/Coro/Coro/Intro.pod. 
If you're writing code that has to be portable, using threads increases the chances your code will not even run. Its not too uncommon for people to have a perl installation where they compiled perl without threads support, and to *enable* threads support, one must: - Recompile Perl - Reinstall every perl module Granted, because of this, vendors like Redhat/Debian typically opt to have threads enabled, because end users can't really "reinstall perl". But its not really a guarantee, as there's LFS out there, Arch and Gentoo. ( I'm a maintainer for the latter, and I know less than 2% of the tree *needs* threads, and so its actually completely viable to have a system perl without it. The only things I know of off the top of my head are `mod_perl` ( which nobody loves anymore since Plack ), and Padre ( which I find terrible and wouldn't use ))
Coro is a whole different set of issues. It's not true concurrent threading, as in python there is only one thread running at a time, so it won't benefit from multiple cpu cores (but this does avoid some of the crazier problems in threading). Plus depending who you ask it is unstable, and the author has an unfavorable history with the community. Opinions aside it was broken for quite some time on perl 5.24 because of its use of perl internals, and led to the author forking perl to "stableperl". So all in all I would suggest avoiding Coro as well, for quite different reasons.
Today there has finally been some discussion and activity from the maintainers. There may be hope yet.
Nice! This will come in handy.
This article brought to my attention the fact that that [Coro](https://metacpan.org/pod/Coro) is now installing/testing successfully under 5.24 and 5.26! Looking at the changelog it looks like this has potentially been the case since July, but still... it's nice to see it working again.
I really need to work on the clarity of my blog posts. Aphra doesn't have any of the features needed to make it blogging engine. It's just a simple static sitebuilder :-/
I would somewhat tongue-in-cheek invert that logic as an argument for why you should steer clear of newer Perls, if consistency, predictability and "my code not being broken" are things that are important to you. (But only somewhat, because well, anyone can see there's a lot of truth to that, and the price paid in sanity in the 'ol vendor mill) ^^^^I would probably also wish people stopped commenting on the social problem literally every time he or something he's written is mentioned, especially as it keeps making the blame one sided, when its rather more complex than that. Its getting about annoying as having some idiot talk about line noise every time you talk about perl 
You say tomato, I say potato.
I made sure it was specified as an opinion and gave concrete reasoning for that reason. It's an ongoing issue if you use any of his modules though, and shouldn't be ignored.
I'm a bit confused: do you or do you not want `$pass` to have spaces after this code: $inline =~ m/.*custpw=([^&amp;\s]+)/; my $pass = uri_unescape($1); Your description suggests `$pass` has `+` chars which likely used to be spaces and got encoded and sent to the script. The regex won't stop when encountering one of them and `$pass` will still have them because by default `uri_unescape` doesn't unescape them. If you don't want them matched, you need to include them in your negated character class. HTH
/u/zoffix already answered, but aside of the topic you should be VERY wary of including user-supplied inputs in your shell commands. This script can be tampered with by using an invalid username to execute user-supplied shell commands on the server. Input like: custid=fakeuser";touch%20/tmp/hacked"&amp;custpw=test will execute touch /tmp/hacked when you run `echo "$date: no customerid found for $userid" &gt;&gt; $logfile`;
I want $pass to have whatever characters the user enters in. If their password has spaces, then I want $pass to have spaces. Why won't the regex stop when encountering a &amp; or \s? I'm clearly not understanding the use of these negated characters. The problem is this script doesn't accurately authenticate users with spaces in their passwords. And, THANKS /u/zoffix.
Yikes! In taking over the code I should know more about why this was done, but I don't. Thanks for the warning. 
&gt; Why won't the regex stop when encountering a &amp; or \s? m/.\*custid=(**[\^&amp;\\s]**+)/; \s is the character class for whitespaces, so it *does* stop the capture after it encounters the first "&amp;" or "\s" (whitespace). I'm not sure where/how strings are being passed to STDIN, but if it's a url or browser based input, any spaces would be encoded as %20 anyway, so you shouldn't need to specify \s in the regex.
&gt; The problem is this script doesn't accurately authenticate users with spaces in their passwords. Likely because you're not decoding them right. If you say they're encoded as `+`, then your `uri_unescape` call won't unescape them; they'll remain as `+`
&gt; I should know more about why this was done, but I don't Chances are, person in question was too lazy to, or didn't know how to, use `open` to do proper file IO with append. `system("echo")` is about as necessary as `qx{cat}`. That is: Not. Perl is designed to replace needing large collections of shell utilities, not to simply wrap them.
You're nearly there: $ cat file | perl -wnE 'say $1 if /test (.+) x/' (This works on Linux; on Windows you might need to use double quotes around the one-liner, and then maybe (or maybe not?) escape the dollar sign).
thanks! what does the wne mean?
warnings-loop trough each line of output of "cat file"-enable optional features. but really: `perl -h`
Or the more verbose option: [perlrun](https://perldoc.perl.org/perlrun.html)
or perl -lne 'print $1 if /test (.+) x/' &lt; file
The `-E` and use of `say` in @perlgeek's solution is almost certainly more like the output you expect. Ensures you get a \n on the end since you're cutting from the middle of the line.
Where you had `-ne`, perlgeek had `-wnE`. Adding `-w` turns on warnings and doesn't make any difference to how your code runs. Changing `-e` to `-E` is more interesting. It has the same "run the following code" meaning as `-e` but has the extra effect of turning on all the optional features in your version of Perl (by which, I mean the things you can turn on with the [feature](https://metacpan.org/pod/feature) pragma. In this case, it's being used to give access to the `say` function.
 ($who, $home) = @ENV{"USER", "HOME"}; # hash slice https://perldoc.perl.org/perldata.html
 my $pids = 0; for my $i (1 .. 3) { my $pid = fork; if ($pid) { $pids++ } else { mysub($i); exit } } while ($pids) { wait; $pids--; } This assumes you run `mysub` only for a side effect. When I want data back, I use pipes to get back (usually JSON) data from the child processes. The `fork` method forces your design in the right direction: immutable shared state, as soon as you mutate it, it's no more shared. Copy-on-write semantics kindly provided by the OS. :D
 perl -ne '/test (.+) x/ and print $1,$/' &lt; file
Either `cat` or file redirection `&lt;` are unnecessary since you can just pass the input file as an argument: perl -wnE '...' file Another advantage is that you can specify several files at once: perl -lne '...' file1 file2 ... filen This comes very handy when performing substitutions or other modifications over a set of files.
If ordering is not important: create a hash from the arrays, and get the keys: ``` my @array1 = qw( item1 item2 item3 ); my @array2 = qw( item1 item4 item5 ); my %tmp = map { ($_ =&gt; 1) } @array1, @array2; say join(", ", keys(%tmp)) ```
 use List::MoreUtils qw/uniq/; my @array1 = ('item1','item2','etc.'); my @array2 = ('item1','item3','etc2.'); my @array3 = uniq @array1, @array2; [CPAN List::MoreUtils uniq](http://search.cpan.org/~rehsack/List-MoreUtils-0.419/lib/List/MoreUtils.pm#uniq_LIST)
Generally, when you think "unique" think hashes. It's super easy to convert between hashes and arrays (or start with hashes if you anticipate needing uniqueness). Getting familiar with List::MoreUtils on CPAN is a great suggestion, too, if CPAN access is an option.
You need `/m` modifier: `$v1_readin =~ s/^\s+//gm;` `m` (mnemonic: "money", cause it affects meaning of dollar sign) changes the ^ and $ to match on every new line amd not just start and end
You need the /m modifier: $str =~ s/^\s+//gm; It changes the meaning of `^` from "beginning of string" to "beginning of line".
I remember that `/s` is "single", it changes the behaviour of only one character, `.`; while `/m` is "many", as it changes the behaviour of two symbols, `^` and `$`.
In my mnemonic "s" is "spot" ('cause "." looks like a spot). Someone in #perl taught me this years ago.
[List::Util](https://metacpan.org/pod/List::Util) (core module) now has the uniq function as well as uniqstr and uniqnum variants that may be useful. I recommend avoiding List::MoreUtils as its packaging and licensing situation is needlessly complicated; [List::SomeUtils](https://metacpan.org/pod/List::SomeUtils) is a fork without these issues.
If ordering is important and you don't have MoreUtils or other lib, you can still use a temp hash to track what has been copied. 
Il always thought m stood for multiline 
Not 100% sure but I recall seeing this a while back. https://github.com/perl5-utils/List-MoreUtils/commit/21c9eead8dc85b1ec133c2e7ba332ed0077183ae#commitcomment-21451144
I use fork with BGS мodule for it: use BGS::Limit; my @foo; foreach my $i (1 .. 7) { bgs_call { # child process return "Start $i"; } bgs_back { # callback subroutine my $r = shift; push @foo, "End $i. Result: '$r'.\n"; }; } my $limit = 3; bgs_wait($limit); print foreach @foo; Or I use IPC::MPS to utilize one child process for many task. 
Sound like [List::AllUtils](http://search.cpan.org/~drolsky/List-AllUtils-0.14/lib/List/AllUtils.pm) is the way to go, to avoid having to remember which module has which functions.
The situation has changed a lot in Perl 5.20. The core `List::Util` module has incorporated all the cool stuff from `List::MoreUtils`, like `uniq` `all` `any` etc. That's not all. There real cool things are the new `pair` functions like `pairmap`, `pairgrep` etc. Check them out, they are awesome for filtering/manipulating hashes. So the answer really depends on whether you use Perl 5.20+ or previous versions. Up to 5.18 use List::MoreUtils qw(uniq); my @a = uniq @a1, @a2; From 5.20 use List::Util qw(uniq); my @a = uniq @a1, @a2;
Personally I prefer to know where my functions come from, but it's a perfectly fine choice as well; it's written by the same author who forked List::SomeUtils so it was switched over to that some time ago.
Additional background (there's a lot): https://github.com/perl5-utils/List-MoreUtils/pull/9 https://github.com/perl5-utils/List-MoreUtils/issues/11 (the next ones came after SomeUtils was created) https://github.com/perl5-utils/List-MoreUtils/issues/24 https://github.com/perl5-utils/List-MoreUtils/issues/25 (this one has been since solved, mostly)
It does; a mnemonic is simply a way to remember its usage.
Thanks for the info.
You can also install List::Util 1.33 (for all/any/etc) or 1.45 (for uniq/uniqstr/uniqnum) on any older version of perl, as it is dual life.
The key/value hash slice is a nice addition in 5.20, but I don't know when I can reasonably set the minimum version to 5.20, since RHEL 7.x still uses 5.16 (yes, perlbrew and all, but targetting 5.16+ is overall safer and less hassle). RHEL 7 is EOL'd in mid-2024, add 3.5 years of extended support so around 2028. Heck, RHEL 6 + extended support will end in 2024 so only that time I should reasonably move on from 5.10.
Note that setting those variables **after** creating the object isn't doing anything useful. You probably want something more like this. my $mpd = Audio::MPD-&gt;new({ host =&gt; '127.0.0.1', port =&gt; 7200, }); But the module's default value for "host" is "localhost", so you can probably omit that attribute.
You want a [UI toolkit](http://enwp.org/List_of_widget_toolkits#Comparison_of_widget_toolkits).
experimental, but still great, I can attempt an upgrade now Coro being left in the cold had soured me a bit, had started looking into D2 
[removed]
It's shell code. http://catb.org/~esr/jargon/html/F/fork-bomb.html https://stackoverflow.com/questions/515844/the-bash-command-will-spawn-processes-to-kernel-death-can-you-exp 
It is not Perl, but rather [Bourne shell](https://en.wikipedia.org/wiki/Bourne_shell). The program is a [fork bomb](https://en.wikipedia.org/wiki/Fork_bomb). **Do not try** this on your own machine. If you must test it, use a VM that you can easily shut down. * `:() { ... }` defines a function named `:`. Technically it's not a portable function name (the standard only guarantees the standard alphanumerics and underscores work), but it works in most shells. * `: | :` is a pipeline, with the function forking (creating a new process) twice and recursively calling itself in each fork. * `&amp;` puts that pipeline in the background. * `;` is the end of the function definition. * `:` calls the function, starting the fork bomb. Since each process starts two more processes, the result is a wedged machine with thousands of processes running and thousands more trying to start, leaving no CPU time for anything else.
**Bourne shell** The Bourne shell (sh) is a shell, or command-line interpreter, for computer operating systems. The Bourne shell was the default shell for Version 7 Unix. Most Unix-like systems continue to have /bin/sh—which will be the Bourne shell, or a symbolic link or hard link to a compatible shell—even when other shells are used by most users. Developed by Stephen Bourne at Bell Labs, it was a replacement for the Thompson shell, whose executable file had the same name—sh. *** **Fork bomb** In computing, a fork bomb (also called rabbit virus or wabbit) is a denial-of-service attack wherein a process continually replicates itself to deplete available system resources, slowing down or crashing the system due to resource starvation. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Thanks, now I feel stupid... I've seen variants before but haven't used Bash enough to recognise it off the bat. 
It searches for `$x` as a word on its own, not inside other words: http://www.gnu.org/software/grep/manual/html_node/The-Backslash-Character-and-Special-Expressions.html#The-Backslash-Character-and-Special-Expressions &gt; ‘\&lt;’ &gt; Match the empty string at the beginning of word. &gt; &gt; ‘\&gt;’ &gt; Match the empty string at the end of word. 
so its equivalent to \b$x\b in perl regex?
Yes, except for some crazy cases like `$x` itself being entirely non-word characters
and then why are there 2 backslashes?
I wouldn't worry about that too much: It's deliberately obfuscated. No one in their right mind would actually define a shell function with that name, not least because `:` is already a shell builtin (that does nothing).
Perl has it's own backslash-escaped characters, and will apply that before passing the thing to `grep`. For instance, if you had `\b` in perl, `grep` would get a single backspace character, but if you had `\\b`, `grep` would get two characters – a backslash and a 'b', and would be able to apply its own parsing to that. If you had `\&lt;`, perl would replace that with a `&lt;` before passing it to `grep`. `\\` is replaced with a `\`.
Ah, i see. I thought perl passes literal string to system call. Thanks!
There are three levels of interpretation happening here: * Perl * The shell invoked by the backticks * `grep` itself We want `grep` to see the sequence backslash-lessthan. But backslash is also special to both Perl and the shell. The first backslash keeps Perl from interpreting the backslash, allowing it to be passed through to the shell. So the shell sees `grep -i '\&lt;blah\&gt;'` with one backslash at a time. The single quotes keep the shell from messing with the backslashes inside, so finally `grep` sees `\&lt;blah\&gt;` as its pattern. I will also highly recommend against doing things this way if the pattern `$x` is influenced by the user, because that allows [shell injection](https://en.wikipedia.org/wiki/Code_injection#Shell_injection) attacks. The problem is that someone could set `$x` to a string like the following (including the quotes) ' /dev/null;rm -rf /home;echo ' Which would result in running the following: grep -i '\&lt;' /dev/null; rm -rf /home; echo '\&gt;' You probably don't want to run that... **Edit**: Solutions would be to do the file I/O and processing directly in Perl, or to [use the list version of `open` with a pipe](https://perldoc.perl.org/perlipc.html#Safe-Pipe-Opens), and read from that in a loop
Backticks (or `qx`) work like double-quotes.
 use 5.010; use List::Util 1.39 qw(pairs); my @vertices = split / /, 'POLYGON 45 32 33 54 55 66'; shift @vertices; foreach my $coord (pairs @vertices) { say $coord-&gt;key + 5; say $coord-&gt;value + 5; } __END__ output is 50 37 38 59 60 71
My company always gives away [this shirt](https://imgur.com/a/cZNRN) at conventions, people love them, we've given away thousands of these.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/kwXwJre.jpg ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dmqfjzz) 
Don't feel bad, things could be worse. You could have it tattooed on your neck. 
Ha ha, now that's a valid statement 
&gt; that does nothing guards against the hideous bash: syntax error near unexpected token `:' 
So listed [here](https://metacpan.org/pod/Audio::MPD#CONTROLLING-PLAYBACK) for playback could I pass `$mpd-&gt;play()` into whatever UI toolkit that would give a method/object for left-clicking?
I just tried it. It's not wor
However you can use a single quote as a qx delimiter and then it won't interpolate (this also works for regexes). But in this case $x is being intentionally interpolated anyway. https://metacpan.org/pod/perlop#Quote-and-Quote-like-Operators
See related question on Stackoverflow: https://stackoverflow.com/questions/21186724/why-is-whitespace-sometimes-needed-around-metacharacters/21431106#21431106
Oh cool, I didn't know that.
That's shell code, but I'm slightly proud your first though was Perl. I think.
FORK BOMBBBB!!1
https://metacpan.org/pod/List::SomeUtils#WHY-DOES-THIS-MODULE-EXIST?
This came way after SomeUtils was created.
This is true, but SomeUtils is also conveniently free of this awkward and ambiguous licensing.
For related fun try unzipping [42.zip](https://en.wikipedia.org/wiki/Zip_bomb#Details_and_use). 
good bot
Thank you ether\_reddit for voting on WikiTextBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
wow, that's f****** evil!
 my $string = 'POLYGON 45 32 33 54 55 66'; my @data = split /\s+/, $string; my $command = shift @data; while (my ($x, $y) = splice @data 0, 2) { say "x =&gt; $x, y =&gt; $y"; }
Or emailing it to yourself. Virus scanners that deep inspect will have a bad day...
In place? my $poly = q|POLYGON 45 32 33 54 55 66|; $poly =~ s/(\d+) (\d+)/($1 + 10).' '.($2 + 20)/eg; print $poly; outputs POLYGON 55 52 43 74 65 86 
LOOOOL. I actually ran this once on a linux box and found out pretty quick what it did. Man, blast from the 90s past indeed.
Very smart. Didn't think of this simple solution. 
Sometimes a one line solution is the ~~simplest~~ most elegant and (probably) most efficient. Even if you do feel obliged to leave a comment in the code to explain what the one line is doing ;-)
What is the second half of that regular expression doing? All i understand is that *(\d+) (\d+)* is picking out the pairs of numbers.
You are looking for something like this: my $input = &lt;&gt;; OR my $input = &lt;STDIN&gt;;
Is there a technical difference between the two?
STDIN is explicitly telling the diamond operator &lt;&gt; to read from the command line. When not specified, &lt;&gt; reads from STDIN by default. This distinction matters when you want to change the default to be STDOUT or STDERR, but this is not often. You can print input to stdout with this: print while &lt;&gt;;
Thanks for the info!
You can read about the differences in the [I/O Operators section of `perldoc perlop`](https://perldoc.perl.org/perlop.html#I%2fO-Operators). The `&lt;&gt;` form is used to mimic the common behavior of command line programs, such that it takes input from any filenames provided as arguments, or if none, then standard input. `&lt;STDIN&gt;` explicitly only takes input from standard input. 
By the way, if you check the exact string entered against a known string (like, if you want to know the user typed "yes"), remember to `chop` the input first, because the user will have pressed entered, and some sort of line ending will be at the end of the input. (I usually use `chomp` instead of `chop`, but I think I use `chop` for this. I don't remember). I don't do this much, but I usually expect very simply input from the user, always provide a default, and I'm fairly flexible with what I will accept. Like, if it's a yes/no question, I will show "y/n" or something and then will do this: my $reply = &lt;STDIN&gt;; chop $reply; if ($reply =~ /^y/i) { # this is good enough of a yes answer for me }
The 'e' flag on the end of the regex means 'execute'. For each match on the left hand side of the regex, the code on the right hand side is executed and replaces the text matched by the left hand side. So, in the code above, the regex first matches '45 32'. The actual numbers that it matches are captured by the brackets so that they are available to the right hand side as $1, and $2. The code on the right hand side is executed with $1 being 45 and $2 being 32 i.e., (45 + 10).' '.(32 + 20) .. which gives you .. 55 52 .. and '45 32' is replaced by '55 52'. The process repeats for each pair of numbers in the original string.
Better to use `chomp()` than `chop()`. The difference is that `chop()` always removes the last character from the string (or strings) it is given, whereas `chomp()` only removes the last character if it is a newline character (more precisely, the current value of `$/`). If there's any chance that your data won't end in a newline (and there's always that chance, as you can never know how your code will be used in the future) then `chomp()` is the safer choice. (And, as an aside, your `$reply` scalar mutates into the array, `@reply`, in the second line of your example - could you please fix that?)
This is input handling is nifty and i will steal it.
Thanks for the explanation. I appreciate it. 
One can also create an input loop like so: while(my $input = &lt;STDIN&gt;){} or quite simply, while(&lt;&gt;){} In the second example, input will be living in $_ As well, always 'chomp()' input read from the command line; it'll save you some headache: the function removes the hidden '\\n' at the end of every string entered. 'chop()' also works, although keep in mind that 'chop()' removes (and returns) the last character in the string, whereas 'chomp()'\* removes a '\\n' if it finds it. ^\* ^^from ^^Perldoc, ^^"\[chomp()\]... ^^removes ^^any ^^trailing ^^string ^^that ^^corresponds ^^to ^^the ^^current ^^value ^^of ^^$/ ^^^(also ^^known ^^as ^^$INPUT_RECORD_SEPARATOR ^^in ^^the ^^English ^^module)."
Oh yeah, that was a weird typo. Thanks for pointing it out. I know the difference between `chomp` and `chop` (though it's certainly fine to include it here, for those who may not know). That's why I was saying that I usually use `chomp`, but for some reason I thought I remembered to `chop` was fine for this use case. But hey, I picked this up years and years ago, and I've never examined the situation very carefully. `chop` has just always been what worked in this case, though I assume `chomp` would also.
Note that I had a typo. I don't know why I type `@reply` instead of `$reply` on the second line. Sorry about that. Also, there should be no reason why you can't use `chomp` instead of `chop`. As I said, I usually use `chomp` anyway. Just not in this case, for probably no good reason.
Yeah whatever, i didnt even check it this closely, i just meant using a regex on the input is smart. ;)
Id like to suggest using something like [Docopt](http://search.cpan.org/~tokuhirom/Docopt-0.03/lib/Docopt.pm) if you can help it. Ask yourself: Do you really want or need to process user input at runtime? Are you just asking for an option that could be expressed as a flag or option? If you need runtime input, you should use &lt;STDIN&gt; .
In your first example, better written as $row-&gt;[0] In the second, you are actually referring to the non-existent variable @_. Similar to the above, you can get at the first field in your result row with $_-&gt;[0] There's no need for the double sigils at all in this context.
This may be helpful, from https://perldoc.perl.org/functions/say.html : &gt; Just like print, but implicitly appends a newline. say LIST is simply an abbreviation for { local $\ = "\n"; print LIST } . To use FILEHANDLE without a LIST to print the contents of $_ to it, you must use a bareword filehandle like FH , not an indirect one like $fh . 
I'll edit it for clarity, but $_ is also undefined.
Why do you expect `while (...)` to set `$_` ? `for` will alias `$_` to each item in the given list, but `while` has no such semantics because it doesn't deal with a list, it takes an expression. Caveat: my Perl is a bit rusty, but I think I'm still good with the basics!
I thought that `while` set $_ to the result of whatever expression was in the parentheses? It works for file handles. while (&lt;STDIN&gt;) { say $_; # whatever you just entered } 
I believe that `$_` is only set in a `while` for `&lt;&gt;`, readline or glob operations (i.e. those are special cases), although I'm struggling to find a definitive reference for that (like I say, it's been a while (no pun intended)). For any other expression you need to set it yourself (or use a named variable which is often preferable for readability). 
I guess that was my problem then. I use Perl a lot but still don't understand some of its basic workings. Thanks!
 &lt;STDIN&gt; Is equivalent to $_=&lt;STDIN&gt; I don't think it has anything to do with while 
`$_` isn't magic, it is set in certain well-defined ways, and it's *usually* the "default" variable, but you've hit on one of the cases where it isn't. In a `for` loop, if you don't specify a variable (as in `for $foo (@bar) {...`), then `$_` gets set to each element of the list. There are various functions which read or set `$_` by default like `grep` or `-X`. And regexes work on `$_` when you don't specify anything else for them to match against with `=~`. All of these cases are in the [perl documentation](https://perldoc.perl.org/perlvar.html#SPECIAL-VARIABLES). However, `while` loops don't do anything special with `$_` EXCEPT "when a `&lt;FH&gt;`, `readline`, `readdir` or `each` operation's result is tested by itself as the sole criterion of a while test." If you want that functionality, you could subclass or encapsulate the `DBI` methods to set `$_`, but I don't think there's a way to make this happen only within `while` loops, and you'd clobber any existing value of `$_`
That `&lt;STDIN&gt;` being equivalent to `$_ = &lt;STDIN&gt;` is only true for while loops, see perlvar: &gt;[$_ is] the default place to put the next value or input record when a &lt;FH&gt;, readline, readdir or each operation's result is tested by itself as the sole criterion of a while test. Outside a while test, this will not happen.
The rules about when $_ is set are kind of obscure. You have found one of the more common patterns where you might expect the subject to be set and it is not.
As others have said, automatic assignment to `$_` in a while loop is specific to a while-readline (or while-&lt;&gt;) construct. In any case it doesn't localize `$_` (for/foreach does, however), so it's a better idea to assign the result to an explicit lexical variable anyway, as you did in your first example, both to avoid clobbering `$_` that may be in use in surrounding code, and to avoid being susceptible to other code clobbering `$_` within your loop. EDIT: The special-case of while-readline is best documented here: https://metacpan.org/pod/perlop#I/O-Operators and [this policy](https://metacpan.org/pod/Perl::Critic::Policy::Freenode::WhileDiamondDefaultAssignment) discusses the caveats.
Ok, I've been using Perl for decades and didn't know that. Cool. :)
It surprised me too, I was looking it up because of this thread.
That depends on the toolkit. I encourage you to build a tiny proof-of-concept application for each of your candidates under consideration, and see how the integration with an external library shakes out.
I much dislike the other answers. They are of the quick and dirty variety: easy to implement to you the programmer, but without any consideration of UX given to the end user. Consequently, they will be received as inconvenient at best, hostile at worst. Remedy - use specialist modules: [IO::Prompter](http://p3rl.org/IO::Prompter) for reading input, and possibly [Lingua::Boolean::Tiny](http://p3rl.org/Lingua::Boolean::Tiny) for yes/no type answers.
You might like to try bind_columns: https://metacpan.org/pod/DBI#bind_columns
Problem now solved. For anyone interested, fetchrow_hashref was the answer.
for anyone else posting a problem, please use pastebin. ouch
Pastebin isn't (usually) necessary. But it would be good if posters made use of Markdown's code formatting feature!
It would seem not: https://www.nntp.perl.org/group/perl.dbi.users/2017/09/msg37443.html
Previous context: https://rt.cpan.org/Public/Bug/Display.html?id=87428 https://github.com/perl5-dbi/DBD-mysql/pull/67 https://github.com/perl5-dbi/DBD-mysql/issues/117 https://www.nntp.perl.org/group/perl.dbi.users/2017/08/msg37429.html
The way I started to learn it was by reading the Apocalypses, Synopses and Exegeses several times spread over years. (available at [design.perl6.org](https://design.perl6.org/), note that they are historical documents) They were based on the chapters of the book “Programming Perl”, if I recall correctly. It might be helpful to get a general insight into the design process, but would not help with Seq, as that was added to the language not long before the Christmas release. For insight into the process for that, you would have to look for references to GLR (Great List Refactor) on the Web.
I would have figured the perl script itself would have been enough to do the job.
Yeah like I said I'm not the best so I have to compensate for that :)
Yeah, I am not a prude, but this does not belong here. Specifically, your use of the word _c*nt_ may be offensive to some folks who may otherwise feel welcomed in this subreddit. Also, the sexual bragging might not fly with some of us here either. Like I said, I can totally swear, come up with messed up jokes and be generally against excessive political correctness. Hell, I don't usually censor the words I type. But this stuff has its place elsewhere.
Totally cool with that, I don't really care though, it's not about me, the reason I wanted to post this here is because I would like people to be inspired, I thought it was a really fun and cool thing for me and wanted to share that with other people who might not have thought about how they can use their amazing skills to find solutions in problems. And yes I get that some might find this offensive, but it's just words, it's the meaning behind the words that mean something, and I'm sorry if some people don't get it, and I'm working on trying to get the message across clearer and not be offensive. But the offensive stuff, it's not even for me you know, it's for her, that's what she really wants, and it has nothing to with degrading her, it's the opposite, when I call her a c\*nt I'm really saying *I love you* But this is also totally new to me, and I'm trying to get in to it for her so I can make her happy because I just like her so much you know, and this was our little way of finding a fun way to do that in a fun and for us hot way. If you are offended by it, then yeah sorry but also not sorry I don't care what you think about me, and yes I'm trying to say something nice, and share a to me beautiful story, and the girl in the story feels the exact same way, but it's our thing you know, everyone can find their own thing. But I can just as easily call you something horrible with nice words. And really would you not rather be told you are loved in a offensive way than to be called the c-word according to the rules? She also happens to be Australian which has another relation to that word, so yeah, if you are offended, it's only because you want to be, and that's just sad. But I'm sorry if it doesn't belong here, but not for me, I don't give a fuck you know.
You go, coder Romeo! Stand up to tha hate!
You're totally missing the point. [This reminds me of that Gorgasm debacle](https://www.reddit.com/r/golang/comments/1v0ys5/gorgasm_a_framework_for_writing_native_android/ceo2h6u/?context=3). And if you _know_ it doesn't belong here, but you post it anyway, what does that make you? A troll? A spammer, then? 
No I explained it already, the audiance this was written for are in these kind of places, not in the kind of places where this content is apriciated, this is not comedy, it's fun in a way, but yeah I'm sorry if you don't get it. But it just means I have to work harder to be able to get my point across I guess, so I will do that. And sorry if I offended you.
You still don't see the point, friend. I'm not trying to antagonize you for the sake of it. The code you wrote may be for an audience that welcomes it. Good. Not a problem with that. I might even be part of that audience. Let's use an extreme illustration. What if the code you wrote was about killing all Swedes (disclaimer: I think Sweden is awesome)? The Swedish genocide folks will welcome it alright. Then you post it in r/perlSveriege and the folks there don't welcome it. What's your response to that? Surely it won't be "but guus! This is code for an audience that likes this kind of stuff. _Sorry if I offended you._ I don't give a fuck." This subreddit is about perl coding, and we have to be mindful that folks here come from different places, mindsets and backgrounds.
There are a LOT of threads here, I'm not totally following. There is some UTF-8 bug in DBD::MySQL that we're trying to work around?
I would say that since I'm not you know an idiot, I would understand the intention behind the words and be offended if it were justified, if you're offended explain why, else you are just I don't know what you are doing really?
I'm sorry, I didn't understand what you meant by the above. What is it that you don't understand? I explained the situation clearly.
Essentially: DBD::mysql with the mysql_enable_utf8 (or mysql_enable_utf8mb4) option currently uses the internal representation of strings that you pass to it, presumably assuming that it's the UTF-8-encoded representation of the string. This leads to false positives (strings with non-ascii characters that are still internally represented in latin1 will not get encoded) and false negatives (UTF-8 encoded strings that are internally UTF-8 encoded again will end up double encoded). Overall this is not the correct way to use strings in perl and makes DBD::mysql's behavior dependent on how strings are internally represented, which can change behind the scenes at any time due to string operations or use of XS modules or even the version of perl you use; this is normal behavior. This same issue was fixed in both DBD::Pg and DBD::SQLite several years ago. However, fixing the issue led to breakage in existing code that depends on the current broken behavior, such as passing a UTF-8 encoded string in (if it behaved correctly, you should always pass decoded strings and let DBD::mysql encode them) or passing a bytestring and expecting DBD::mysql to *not* encode it automatically. So, the version that fixed this bug was reverted along with many other important bugfixes. Now the maintainers are discussing how to reapply the fix.
So did I so who is it that doesn't understand?
Ok, then obviously there is a misunderstanding. Let's see if I got what you mean: You say that you're aware that your post contains things that can be deemed offensive or distasteful to some folks. But you don't care because the topic of your post is meant to be fun, and in the end, the code you wrote was for a person who finds it fun. Is that correct?
That is exactly correct. And as I said I think it's retarded to judge words on arrangement of letters, words mean what we put in them, they are not magical. I explained this very clearly, I can see the points of what rules to follow, but my argument is not about rules or conduct or anything like that. I wanted to share a story with a specific community. Let's be real here for a honest second, the content I created here, is funny, weird, gross, offensive and creative just depends on who you ask. What I'm after is not to be liked, I want to entertain people who are entertained by what I do. There are mods on the sub, they can remove content that doesn't apply, I know I might be bordering on what's tasteful, but hey that's art man. So yeah if you don't appreciate what I'm doing, then I don't care, it's not about you then obviously, and it's not because I care about what people think, I care about what they think of them selves, this is my fucked up weird way to be happy, if someone else can see how I managed that through this whole mess, then yeah maybe they can get sparked by it, and yeah that's what I'm after. And if that doesn't speak to you, then that's ok, but who are you giving your opinion too because it's not me right? So anyways, that's the thing, I put it out there, what happens after that is up to you, I'm just having fun, and if you like that, stick around, else you can enjoy the other wonderful content on this sub that really gets you thinking about interesting things, like which fucking regex combination to use to not kill yourself before work ends. At the end of the day, I'm the guy typing this up with a naked chick watching me laughing her ass off. So ask yourself, when you go to bed tonight, who would you rather be? because to be me is fucking awesome, you just don't have to care what pieces of shit like you think. And I aint even charging you for this shit, be greatfull.
Except that if you pay attention to your "funny story" votes, 70% of those who read it **downvoted** it, so it's not welcome. Jesus, for a second I thought I was going to start a rational conversation with you. Silly me. You're just delusional. So, fuck it. Your story does **NOT** belong here. It's stupid, it's self-serving, it's crass, it's tasteless, it's offensive, it adds nothing to the Perl community, and worst of all, it's not funny. Good-bye and best of luck with your stubbornly closed brain.
&gt; It's stupid, it's self-serving, it's crass, it's tasteless, it's offensive I made you feel all that with my work? WOW, you made me feel nothing. Why would I need luck? I got all I ever wanted in life I don't need luck.
[removed]
Cheers, It's been working so far :) Too you too, honestly I mean it, I get how I can be offensive, this is my way trying to figure out how open I can be before people start getting offended. Sorry if I offended you, was never my intention.
`split` is your friend here. It can take a regex and capture. So: my @positions = qw ( QB RB WR TE DST FLEX ); my $regex = join '|', @positions; $regex = qr/\s*($regex)\s*/; my @stuff = split /$regex/, $data_string; And then potentially use something like map to transform it. If you didn't have duplicate keys, you could assign directly to a hash. But you could do: my %players = reverse split /$regex/, $field; And then you with have a hash where they keys are player names and the values are positions. Which then you can `map` thus: my %positions; push @{$positions{$players{$_}}}, $_ for keys %players .* Isn't as big a performance hit as you may think - your problem will be backtracking - as it has to "reverse" the greedy match to get enough delimiters. But you can see what the regex engine is doing by turning on use re 'debug'; 
There may be other improvements that can be made, but I've made a couple of obvious changes: * Change `.*` to `.*?` * Remove the repetition of the match and replace it with `/g` on the match operator And that seems to have made a pretty big difference. #!/usr/bin/perl use strict; use warnings; use Benchmark; sub orig { $_ = 'DST Chargers WR Ted Ginn Jr. QB Sam Bradford TE Coby Fleener FLEX Mark Ingram RB Melvin Gordon WR Stefon Diggs WR Adam Thielen RB Dalvin Cook'; my @names = /(QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) (QB|RB|WR|TE|DST|FLEX) (.*) /; } sub new { $_ = 'DST Chargers WR Ted Ginn Jr. QB Sam Bradford TE Coby Fleener FLEX Mark Ingram RB Melvin Gordon WR Stefon Diggs WR Adam Thielen RB Dalvin Cook'; my @names = /(QB|RB|WR|TE|DST|FLEX) (.*?)/g; } timethese(100_000, { orig =&gt; \&amp;orig, new =&gt; \&amp;new, }); The output is: Benchmark: timing 100000 iterations of new, orig... new: 1 wallclock secs ( 1.33 usr + 0.00 sys = 1.33 CPU) @ 75187.97/s (n=100000) orig: 13 wallclock secs (13.31 usr + 0.01 sys = 13.32 CPU) @ 7507.51/s (n=100000) 
What about splitting the string on the list of positions? my @players = split /\s*(QB|RB|WR|TE|DST|FLEX)\s*/, $str; shift @players; 
You never offended me, dude. I am a sarcastic ~~son of bad bitch~~ idiot, and as open minded as it can get given my circumstances. I just think that everything has its place and time. Edit: I apologize for my "son of bad b" phrasing. It's hypocritical of me using it, and I recognize it.
Rather than `shift` I would suggest `grep` to strip the empty field. 
Are Damian Conway's talks available somewhere, in some form?
And the previous reddit thread: https://redd.it/6x5t58
Given this exists https://www.reddit.com/r/askwomenadvice/comments/6zrpse/need_help_expressing_myself_without_being/ I cant help but feel (or hope) this is a troll post. Can we please just remove this? I genuinely feel uncomfortable this has been dumped here and left this long. Reading it made me mildly nauseous from disgust. Literally no one wishing to discuss Perl wanted to imagine your sex life. Please just go away.
Yeah I kind of agree you know, but also isn't that a thing too? Who are you to decide what things go where? Like you get me? I think it can be ok to push things further to figure out where the limits are. So yes, its cool to be upset with me, but all I want from you or anyone else, is just I don't want to offend anyone. So yeah please, if you want to make fun out of me, I can take it, even go with it you know, doesn't matter. I so much rather be loved for this weirdo i am, than pretend to be someone I'm not, and yeah that's allI want, but so far people are just offended, snd I get from what, but like I can't see why people always can't just accept that some people go after what they want. Like Im happy, just trying to see if someone else can figure out their own shit, if I just tell how I did it. So yeah thats where I'm at. But yeah gonna end this here for me and move on. And yeah from here, the mods are responsible for it. I put it out there, now feel free to do whatever with it including banning me whatever. I'm never gonna apoligize, for being me, because my intentions are good, so yeah only way to be offended by this is if you want to be. But yeah moving on now, this had been super fun though, and the girl laughed at me being me and that's what I got out of it, see her smile, worth it :) So yeah, I listened to me and I love my life you know. Whatever I'm not gonna force this on someone, either you get it, or you don't. If you like your life, this wasn't for you.
A couple of people have suggested `split`, which I wanted to use, but there are two reasons why (one bigger than the other). First, the position designations are not delimiters, but prefixes of each field. So split would give me all but one of them. I could overcome that, though. The other reason is because I do need to know what the position is, so I looked into whether `split` can return the value from the expression that was matched (`$1`, really)... but it doesn't appear to do that.
That's about good point about `/g`. The quick sketch of my expression left that out. I do already use `/g`, strangely. Maybe its' in there from some other try. Here's the problem that I have had with _not_ repeating the tokens. Because of the greediness of `.*`, it ends up identifying only one player. It takes the first position, and then the player name is literally everything else. So the ugliness of repeating the tokens for every expected roster position was the only way I found to catch every player. Not trying to be argumentative.... just remembering the things I have tried and telling you why I had trouble with them. But thanks for the code you have provided here. I'll give it a shot.
Oh, yours is faster, but... the results are wrong. I neglected to mention that I need to actually come away with the data :) Dumping `@names` from your `new()` yields: ('DST','','WR','','QB','','TE','','FLEX','','RB','','WR','','WR','','RB','')
I'm not starting with a list, but a string. So I don't see how `grep` can work. I could turn it into an array if I knew where each player begins and ends, but... that's really the whole challenge. In the simplest of worlds, I could assume very player is "Firstname Lastname", but of course names don't work like that. There are over 1000 players and new ones can be added, and existing ones can be changed. So what I _really_ need to identify player names is to say "any string that does not include these position identifiers" (I'm willing to risk that if a player comes along named "WR Hicks" (that's actually my great-grandfather's name), then it will break, because he has a position identifier as a substring of his name. But those are rare enough that I'll risk it. But I don't know how to say "capture any string that does not include as a substring any values from this list". If I did, that would maybe be helpful (though I don't know if it would improve performance, which is the only goal that matters right now, because -- as I have said -- the ridiculous expression that I have right now does yield the right results).
`split` generates an empty string when you do what you do, because it assumes there's a field before the first delimiter. I assumed you knew this, which is why you `shift @players` which would get rid of it. But instead of that, you could `@players = grep { $_ } @players` which would do the same thing, removing any 'empty' fields. 
Have you actually tried the `split` examples that have been given? The reason I suggest it, is because if you give `split` a bracketed expression, it captures it, and returns the "delimiter" at the same time - giving very much the same result as your regex. So in my first example above the output is: $VAR1 = [ 'DST', 'Chargers', 'WR', 'Ted Ginn Jr.', 'QB', 'Sam Bradford', 'TE', 'Coby Fleener', 'FLEX', 'Mark Ingram', 'RB', 'Melvin Gordon', 'WR', 'Stefon Diggs', 'WR', 'Adam Thielen', 'RB', 'Dalvin Cook' ]; Which looks an awful lot like what you're looking for? Or with the hash transform, you get: $VAR1 = { 'Dalvin Cook' =&gt; 'RB', 'Chargers' =&gt; 'DST', 'Ted Ginn Jr.' =&gt; 'WR', 'Melvin Gordon' =&gt; 'RB', 'Sam Bradford' =&gt; 'QB', 'Stefon Diggs' =&gt; 'WR', 'Mark Ingram' =&gt; 'FLEX', 'Coby Fleener' =&gt; 'TE', 'Adam Thielen' =&gt; 'WR' }; Or: $VAR1 = { 'FLEX' =&gt; [ 'Mark Ingram' ], 'WR' =&gt; [ 'Ted Ginn Jr.', 'Stefon Diggs', 'Adam Thielen' ], 'TE' =&gt; [ 'Coby Fleener' ], 'RB' =&gt; [ 'Dalvin Cook', 'Melvin Gordon' ], 'DST' =&gt; [ 'Chargers' ], 'QB' =&gt; [ 'Sam Bradford' ] };
That's because `.*?` will match an empty string, because it's a non greedy zero-or-more match. So it does, and just matches `''`. An alternative I'd suggest is the lookahead option in a regex: my @names = $field =~ /(QB|RB|WR|TE|DST|FLEX) (.*?)\s*(?=(?:QB|RB|WR|TE|DST|FLEX|$))/g ; Which says 'zero or more' but followed by space, then a zero width (non-consuming) match of any of your delimiters - or end of line. Note - you need the `$` and the `\s*` because otherwise the last entry won't match. Or rewritten because I prefer the non-repeating: my @positions = qw ( QB RB WR TE DST FLEX ); my $pos = join '|', @positions; my @names = $field =~ /($pos) (.*?)\s*(?=(?:$pos|$))/g; Which captures the whole string, with a non-capturing match giving: $VAR1 = [ 'DST', 'Chargers', 'WR', 'Ted Ginn Jr.', 'QB', 'Sam Bradford', 'TE', 'Coby Fleener', 'FLEX', 'Mark Ingram', 'RB', 'Melvin Gordon', 'WR', 'Stefon Diggs', 'WR', 'Adam Thielen', 'RB', 'Dalvin Cook' ]; 
[removed]
Oops. Yes, that's a problem. I checked I was getting the right number of results, but I forgot to actually check them :-/
In short, there was a way this could've been posted here. The original post contained nothing but a sweet story that involved perl code written to have some fun between consenting people. However this sub-reddit is frequented mostly by professionals, and americans, so certain cultural expectations apply, and having zero levels of indirection is not smart. I'll amend the sub-reddit description to make this clear. In future, such content would've been fine to post if: - the text body were hosted outside of reddit, in a blog or gist, etc. - the text post here was a rough description and warning with a link to the post
Just FYI, in future post earnestly. Just as unfiltered sexual content is unfitting for a sub-reddit focused on professional information, so is posting as a "sarcastic son of bad bitch". Not only because being sarcastic in itself is toxic, but also because phrasing it like that is sexist as well.
Most often you don't want to make things move, but to prepare screen content, clear the screen, then write over the entire screen from the top. There are also ascii gui libraries you might be able to use to do the rendering for you. I can't recommend any because i've not done this type of thing before.
Hugest feature? It's obviously the Shrug Operator! sub infix:&lt;¯\(°_o)/¯&gt; { ($^a, $^b).pick } say 'Coke' ¯\(°_o)/¯ 'Pepsi'; # OUTPUT: # Pepsi 
Look into Term::Screen which can let you put text at a specific (row,col) on screen, grab input, and more. Probably various other ways to do this as well!
Wow, I didn't know that `split` could do that, even though that's what I had been trying to make it do. It sounds like what I want. Is that undocumented? I don't see it in `perldoc -f split`. Yeah, you're right. I saw `split` and didn't even try it. Sorry about that. So... I just tried it and.... holy crap! That's fast, and I think it's what I want. Thank you very much for telling me about this usage of `split` (which I still don't see in TFM, but maybe I'm just missing it). I'll continue to look at other solutions posted here, but this is a huge improvement.
You're absolutely right. I've amended my post, and will be more mindful next time. Apologies.
https://perldoc.perl.org/functions/split.html &gt; If the PATTERN contains capturing groups, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per backreferences); if any group does not match, then it captures the undef value instead of a substring. 
You all act like it's something I'm not getting, it's tiresome, everything I did was on purpose, where I posted it everything, because that's what I want to do, I can't explain it. I know this was gonna play out either this way, or another, all I want is to find out how, you know. I wanted to get those negative emotions awaken at the same time as there is something sweet there, because that's what I like to do, I want to figure out people and I do that by seeing how I affect people. I can't figure shit out any other way, you see I suffer from something called synesthesia, which means stuff like colors, time, emotions can be wired together in a weird way. it's not super uncommon, but yeah I experience emotions way more intense than what is normal. And yeah when I let just myself out, I wanted to tell a love story from my perspective, and normally when people do that, all you get back is love. but since people don't understand how I love people, when I try to show it I get hate instead. and that's the thing for me, imagine being that person for 30 years, everytime you tried to say to someone that you like them, they instead react like the people in that thread. I lived that for 30 years, and it finally clicked for me, I found out who I am, and the only way to live my life is to live it honest, and just stick to those who get it, and learn to stay the fuck away from people who can't understand emotion for the life of them. Then imagine being 13 years in tech, surrounded by the same comments I got in the subreddit. are you starting to see my side of this yet? when I try to express my love to the world, I get that treatment. So yeah the only way I can get past that is to be ok with what people think about me, because the people that do get me, and get to recieve all that love I'm capable of due to my weird ass brain. I realized I much rather be hated for who I am than loved for someone I'm not, and the few people who get me, get me so well I just feel great, and yeah. So yeah I can take it all, but if some little fucking weird perl coder retard like I was just 10 years ago sees this, and think wait maybe I also can fix my shit and be happy like that? And if I can get 1 person to not live through 30 years of anxiety and PTSD, then yep that would be worth it. So yeah I can take the hate, it's cool, I just hope someone who got inspired got to see it before it went away. And I'm cool with anyone involved, like I said I don't want to offend, I just want people to listen, and just be open to that people can happy in different ways you know. Anyways this was the most likely scenario I saw it play out and we are cool, just hope there is no hard feelings, and you get that I'm not trying to make anyone offended in a bad way right? Anyways if you don't get me, maybe you could ask some of the mod team over at r/sweden, some of them know me personally and can vouche for me being a chill dude you know. Anyways I'm done with the whole thing, if you are cool with that so am I, I just really felt I wanted to do it my way you know. 
Thank you. :)
Damian's talks (some of which are available) are on youtube.
This doesn't even look like finding a path forward. One group of people doesn't want their existing applications to be broken and corrupt data, and I wish we didn't even need to discuss that this is important in a database driver. Another group of people wants to have sensible unicode semantics (actually I haven't looked into the details, but AFAIK everyone seems to think the new behavior is more sane). Which is a reasonable thing to want. There are two possible solutions to this: One is to fork, which is easy to start but a lot of work down the road. The other is add a mysql_enable_utf8=2 option, so both behaviors can be supported and everyone can be happy. This is more work to get done but much less work to maintain in the future. (This suggestion of increasing the major version is a non-starter given that none of the CPAN infrastructure makes such distinctions). You can probably guess what I think should be done (I'm not particularly invested in DBD::mysql myself). I guess what it really boils down to is "write code or shut up". Complaining about the status-quo isn't helpful at all.
That's really not the best idea, it can be slow and result in flicker if the screen gets drawn halfway through sending that whole screenful of data.
Move the cursor to the location where the player is now, and print whatever background character should be there instead (or just a space if it's blank). Move the cursor to the location where the player should be, and draw the player. Lots of modules available to help with the terminal codes for moving the cursor and other things like that.
Dude, you're not the only one with social skills issues in tech. Acknowledge them and do something about them. One person (me) trying to give you feedback, plus downvotes, plus not one but _two_ submission removals in _two_ different subreddits, and you still think that the problem lies in everyone else but you. &gt; this was the most likely scenario I saw it play And you still did it. 
yep, I get all that, but yeah I just need data on peoples emotions to figure shit out, and I'm trying to figure out how to do that without having to put on an act you know. So yeah I get it all but since this works for me, all I can do is try to do it you know and try to do it in a way that I don't offend people. And I learned a great deal from all that data, next time I open up like this somewhere I will probably offend less people. But it was really nice to see what my colleagues kind of really thinks about me but are too afraid to say when we are in the office you know. It was kind of what I suspected you know, but nice to get it confirmed, made me realize I can still do tech just need to find a way to do it far away from people who can't deal with me. Anyways thanks for taking the time to reply I do appreciate it. And yeah I know the problem is me, when have I ever said the problem is other people?
Good luck, friend.
cheers, all this gave me really good answers, and you all help, I promise to repay the community for doing this some day, just need to figure out how.
Thanks. Note to self: _read_ it, don't _skim_ it.
I translated your solution to Perl 6 just for fun. Perl 6 `split` can take a regex, string, or list of either, so I can just give the list of positions to `split`, and tell it to keep the split values (`:v`). I `trim` the results via a map, then `reverse` the list and assign to a Hash. I then used `classify` to create a new hash that uses the Hash values (positions) as keys, and map the values `as` the keys. my @positions = &lt; QB RB WR TE DST FLEX &gt;; my %players = $string.split(@positions, :v, :skip-empty).map(*.trim).reverse; my %positions = %players.classify(*.value, :as(*.key)); I could also coerce to Hash rather than assign to one, which saves me a variable assignment my %positions = $string .split(@positions, :v, :skip-empty).map(*.trim) .reverse.Hash.classify(*.value, :as(*.key)); Then pretty print the data for @positions -&gt; $pos { say "$pos.fmt('%5s'): %positions{$pos}.join(', ')" } OUTPUT QB: Sam Bradford RB: Melvin Gordon, Dalvin Cook WR: Ted Ginn Jr., Stefon Diggs, Adam Thielen TE: Coby Fleener DST: Chargers FLEX: Mark Ingram 
What im looking to do is make the player roll a dice and move the player object the number of spaces he rolls
I'll look into it thanks!
 /(?:(DST|WR|QB|TE|FLEX|RB|WR)\s*((?:(?!\b(DST|WR|QB|TE|FLEX|RB|WR)\b).)*))/g Matches any number of positions on the line, negative lookahead assertions FTW.
You might want to have a look at Perl6, where $_ will be set consistently across all of the language. $ perl6 -e '{say $_}(3)' 3 That's setting the topic in a bare block, and it can be called like a function.
A simple, oldschool low-level way to do this would be with ANSI (VT-100) escape codes: Esc open-bracket row_number semicolon column_number capital_H moves the cursor, i.e., print "\e[$row;${column}H" and Term::ReadKey to read a key without waiting. Throwback to how I used to write games (and accounting programs) for the Heathkit 8-bit computers running HDOS or CP/M in the early 1980s.
I have always wondered how they did this. Is it the same codes used for dos in C ?
Escape codes are specific to a particular terminal. The modern console windows all emulate one or more (hardware) terminals in software, so yes the escape codes are independent of language. In the "old days" you would have CP/M programs, one version that emitted VT-100 codes, one that emitted VT-52 codes, one for Wyse terminals, and so on. Termcap on Unix made the process more portable. Consumer-class microcomputers tended to have memory-mapped character displays and did not need escape codes, although MS-DOS early on added ANSI.SYS to emulate them. 
thanks, Im going to try some ascii spinners tonight. Previously Id have to print the delete character then print the next character which only works for animating the end of the current line.
Thank you for that. It's performs comparably to the `split` example given by /u/sobrique. Both of them make it possible to parse this one contest file, for example, in about 30 seconds, as opposed to 7.5 _minutes_ with my original, absolutely crazy expression. Mine was tolerable for baseball, but the contests are so much larger in football season that it really adds up. Not only this one contest, but I'm processing many contests at a time, multiple times throughout the weekend, so this savings really helps a lot. Thanks /r/perl -- not just for this, but for the reminder that, while my regular expression knowledge is very useful in my day-to-day activities, there is so much more to learn.
2 suggestions ... 1.) use regex "debug" to see what is actually happening. 2.) Here is what the documentation says: http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators $re = qr/$pattern/; $string =~ /foo${re}bar/; # can be interpolated in other patterns $string =~ $re; # or used standalone $string =~ /$re/; # or this way 
Can you please post an actual example of what you're trying to do? There are several issues with your example and it will not run as written. If you really do mean to have a dynamic pattern in that regex, here's a test program that shows Perl is doing what you apparently mean for it to do. #!/usr/bin/perl use warnings; use strict; my $pattern1 = '\w+'; my @multiLineVar = ( 'one two three', 'four five', 'six seven eight nine' ); my $someVar = "random"; foreach (@multiLineVar) { print("Line before: $_\n"); s/(\S+) $pattern1 (.+)/$1 $someVar $2/; print("Line after: $_\n"); } And the output: $ perl sample.pl Line before: one two three Line after: one random three Line before: four five Line after: four five Line before: six seven eight nine Line after: six random eight nine
Your pattern is probably failing, then. A simple test shows that it it should work fine: use strict; use warnings; use v5.20; my $t = "now is the time for all"; my $x = "joe"; $t =~ s/(is).*(time)/$2 $x $1/g; say $t; $ perl tofu.pl now time joe is for all 
Curses!
Just in case you forgot: _read_ it, don't _skim_ it.
Well done sir.
Perl 6 has something similar built in say 'Life, the Universe and Everything'.WHY # OUTPUT: 42
Does it also have the correct answer to 6 * 9?
Homework? A college or uni assignment?
Work. I'm trying to automate something for my own sake
Consider the four vertical sides of the two rectangles (the segments `(x1,y1)-(x1,y2)` and `(x2,y1)-(x2,y2)`). If there is an overlap, then at least one of the sides of the first rectangle collides with the second rectangle *or* at least one of the sides of the second rectangle collides with the second rectangle. A vertical segment collides with a rectangle if its x coordinate is between the rectangle's left and right x coordinates (inclusive), its top is at or above the rectangle's bottom, *and* its bottom is at or below the rectangle's top. You have to test it both ways (exchanging the first and second rectangles) to deal with the "one inside the other" cases, but as long as you do, you should be 100% covered. The entire thing also works if you use the four vertical sides, and exchange the roles of top/bottom with left/right, of course. I picked arbitrarily. For figuring out if there are any collisions among several rectangles, you can either do a bit of cleverness (like maintaining binary trees of rectangles ordered by their upper/lower y coordinates to help with finding potential colliders, or perhaps a quadtree), or if you don't have too many, you can do the straightforward n^2 check of each one against every other (which saves you from having to update your trees every time an object moves).
[removed]
There's unfortunately no automatic way to prevent malicious modules being uploaded with similar-but-misspelled names, as the first uploader for any module name automatically gets indexing permissions for it. But if you see such a module, report it to modules@perl.org and the pause admins may be able to take action if it's truly malicious. Also, a module author could pre-emptively upload dummy modules for common misspellings so that they hold the permission, such as people may do with similar domain names for a business.
Or job application 😂
I would expect this to track with CPU time; the more you stress the CPU, the more power it will take. The results largely line up with that, though there are a few exceptions. As the original programs came from the Computer Language Benchmark Game, we're mostly talking about problems that are pure CPU number crunching. Perl and other high level languages tend to be used in more I/O-bound environments. Waiting on I/O synchronously will hit all languages more or less equally in terms of energy or CPU.
The fact that most of the solutions use threads also doesn't help very much. A threaded perl interpreter is noticeably slower than one compiled without threads.
That makes sense as the cpu can then push those threads onto other cores if it wants, allowing more power to be drawn. I think the best arguments for or against a language running on, say, AWS is that by adopting a more power efficient language with a higher up-front development cost (say Rust or Go or what-have-you) is that you'd make up that cost over time by being able to run fewer instances or keep that cpu-time down. Hosting isn't free, so if you're building something that could be running for potentially years it would make sense to take that into account.
There's a lot of factors involved, definitely. Long-term maintenance is arguably more expensive, which having a solid compiler can help mitigate. Having a compiler that can tell you when moving one piece has broken another can be a godsend.
A simple O(N^2) algorithm is possible with a module like https://metacpan.org/pod/Tickit::Rect (see also Tickit::RectSet) - for small lists this would normally be good enough. With a larger list, options depend on what you want to optimise for - early elimination, minimal worst-case time...? Modules like https://metacpan.org/pod/Math::Vector::Real::kdTree may be of use. 
These days projects don't seem to last long enough for CPU time to ever cost more than developer time. Maybe that's on purpose.
That moment when you manage to mess up one line of code by getting the case wrong. &gt; String found where operator expected at /tmp/test.pl line 2, near "Print "42\n"" &gt; (Do you need to predeclare Print?) &gt; syntax error at /tmp/test.pl line 2, near "Print "42\n"" &gt; Execution of /tmp/test.pl aborted due to compilation errors. 
Ol it's your code that has an unmatched "
&gt; You might want to have a look at Perl6 I have, it's awful and it's not Perl.
It's better than Perl.
I love Perl but often it saves me both programming *and* compute time to just write the bottleneck functions in C++ and call it from the Perl application. Trying to do *everything* in Perl is just insanity IMHO
Now with piggies and tacos in the documentation ( https://metacpan.org/pod/zim ): use zim 'Scalar::Util' =&gt; 'blessed'; use zim 'Scalar::Util' =&gt; 'blessed' =&gt; { -as =&gt; 'typeof' }; use zim 'Mango::BSON' =&gt; ':bson'; use zim 'Foo' =&gt; { -version =&gt; '3.0' } =&gt; 'foo'; use zim 'Krazy::Taco' =&gt; qw(tacos burritos poop); 
It's always a good idea to learn multiple tools, so you can use the best tool for any given task. Though personally I tend to stick to those where Perl works.
Wrong.
The programmer will however use the energy if you employ him or not, so unless you plan to make new programmers through some ridiculous program of random recombination of helical strands of acid between two existing programmers, or to cull the existing programmer population once you don't need as many, it's not really clear how you save any energy on a global scale. That's probably even true of the tools the programmers use - most of us use so much electronics that sitting at a computer at work wont noticeably increase the energy consumption.
This only works for rectangles with no rotation off axis parallel to each other, and that are not completely subsumed by one another. So unless that's specifically the problem, then you don't have a general solution. Consider two rectangles rotated by 45 degrees and packed on top of each other, or one placed inside the other. The min and max x/y intersect but the actual interiors of the rectangles don't.
That's a great idea. Can't wait to see it come to fruition.
Best of luck!
Good luck! I'm looking forward to the Gray &amp; Black books. I admit I was confused at first as when I saw Rakudo, I assumed we were talking about the distribution or the MoarVM, but then remembered Zoffix is heavily pushing to change Perl6 to Rakudo, which has some merit as an idea.
From the question it's clear that the rectangles are all aligned to the x and y axes, and you're mistaken about the case of one rectangle completely inside another — the test works correctly if you apply it properly. If I'm wrong, please supply a counterexample (an axis-aligned one).
https://metacpan.org/pod/Authen::Simple::ActiveDirectory this is pretty easy to use, put a authenticated variable into the users session and check that when a user needs to be authenticated to view the page. 
Great idea ... can hardly wait, even for chapters of the white book
AD can be used as an LDAP back-end. Just focus on how to authenticate against your LDAP (with group) and you're done. Pretty easy this way. 
The problem isn't an unmatched `"`, it's using `Print` instead of `print`.
You might be better off starting with a framework that gives you more than writing bare CGI. Any of the major perl web frameworks have helpers for dealing with authentication. Then for specifics of dealing with Active Directory (the most complex non-beginner auth you could have picked) you want to check out Net::LDAP http://ldap.perl.org/. Assuming you have access to the AD service and can get it to present LDAP.
Unless this is for a history project, I have to echo /u/MattEOates. If it's not, and you're looking for something easy, I'd suggest starting with Perl Dancer. There are a couple others that I haven't kept track of like Catalyst and Mojolicious. Don't know what their current state is. 
Please don't write a CGI program. CGI programs are slow, (relatively) hard to write and they often tie you to CGI deployment environment. These days you want to use a technology based on PSGI - probably a framework like Dancer2. This will give you three immediate advantages over CGI: * Better tools for development, debugging and testing * Flexibility in deployment (deploy as a CGI program, a mod_perl handler, a stand-alone service behind a proxy server - all without changing your code) * Access to a large ecosystem of plugins and middleware that will make writing your application far simpler Writing a "standard" CGI program will make your life harder than it needs to be. Look at PSGI instead.
I use mojo a lot for mocking things up quickly or building micro REST API's. It's super easy to learn and there's lots of plugins