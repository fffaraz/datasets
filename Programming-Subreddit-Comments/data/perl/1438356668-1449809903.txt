What is your database? Most have some form of file ingest though the syntax is quite a bit different. If it's MySQL, LOAD DATA INFILE is considerably more powerful than people realize especially if paired with local variables and functions. Perhaps the perl app can give a quick analysis of the file, create the appropriate schema then construct the LOAD DATA INFILE statement. There is a variant that lets you send the file over the network as well so it does not have to be local. Other db have similar tools. I use this basic technique to create local copies of FCC license databases that are offered for download in a crummy pipe delimited incremental format and often contain errors. It is fast and it holds up. 
SQL Server limits the amount of values you can feed it if you insert into () values() so that way wont work. Maybe a big union all like I was trying. So are you suggesting a big SQL statement then call it from SQL cmd?
Hi, I was using the union all method since you can only list 1000 rows at a time if you use INSERT INTO table values (). https://technet.microsoft.com/en-us/library/dd776382(v=sql.105).aspx limitations. Again though I was merely testing the theory. 
This is a SQL server database. I have tried bcp (doesn't handle data well when some columns are quoted but not all), I tried openROWSET which truncates columns longer than 255. I know SSIS but the goal is to do this quickly. Import Export wizard is ok... but you have to do one table at a time. I tried fullconvert but it's not that great at CSV files. I passed it valid CSV files and it errored, fullconvert support was researching it and never got back to me. AKA they cant handle it. This all has left me with trying it this way with perl.
Have you considered doing this with [BULK INSERT](https://msdn.microsoft.com/en-gb/library/ms188365.aspx)? I suspect that's a better tool for a task like this.
Yes, it doesn't cooperate with a scenario like this: COL1,COL2,COL3,COL4 test,"STUFF","MORE,STUFF",END Where some of the data is quoted and is considered valid CSV, seems like it's all or nothing unless I am mistaken. 
I don't have any experience with SQL Server, I don't know if that would work. I used to do this with MySQL (and PostgreSQL I think). 
I tried that before after realizing how slow it is, it's still incredibly slow though compared to ssis or import export wizard unfortunately.
This script reminded me that I had a -TRIAL release of Moose sitting out there, and with July almost over, the next chance to make this go stable would be October. Thanks, David, released just in time! :)
Probably not the answer you're looking for, butâ€¦ I suspect it may not be that hard to write a new SNMP implementation that is actually sensible on the inside and on the outside, given that Convert::ASN1 exists and is generally amazing (Net::LDAP is also implemented that way). In fact, Net::Frame::Layer::SNMP seems to cover most of the difficult bits already (though I don't like its interface much).
IMO cute names are sensible for frameworks and applications, but not for libraries.
Why is there even a conditional? $var |= 2;
The result of that is the 2 bit always being set, which is different than the original functionality Though the way I see it `$var &amp;= ~2` seems like it would do same If the 2 bit is set, unset it. If the 2 bit is not set, it is left unset
I've only ever needed them on integers and in that case I wrap the argument in `int()` edit: And I've never actually needed them in code, just code I've maintained at work
I think it's something specific to perldoc. podchecker, pod2text, pod2man, pod2html are all fine with it.
I don't think your suggestion works either. Throwing it into the test script I gave in the article I see it fails many tests. You don't have to trust "the way I see it" when you can easily find out. :)
Indeed, sorry about that. Was just trying to quickly provide something non-conditional that worked
Hmm, the outcome of `$var` is identical, the tests probably failed for you since the conditional based versions return the result of the conditional, and not `$var` when it is not true Or more succinctly, **if the 2-bit is not set then the conditional versions eval to `0`; my version evals to `$var`** Test code showing this to be the case, everything will pass under this sub subtract ($var) { $var -= 2 if $var &amp; 2; return $var } sub bitwise ($var) { $var ^= 0x2 if ($var &amp; 2); return $var } sub peter ($var) { $var &amp;= ~2 } I agree that you're damn right that we should test things as much as we can, but we must not forget that test code is prone to the same weird bugs as non-test code :P
Note: it's =head1, not =head 1.
This is tested and actually, 3 scripts running on my server right now have been using it for months. One of them sends PMs, one checks the inboxes of my alt accounts, one reads submissions from subreddits. If there's a bug it'd have to be in some function I've never used; the bug in `me()` was because Reddit's API had changed and it had never been updated. I think the only functions I haven't used are the ones to upvote/downvote, and the one to save posts.
If you want this included in the official distribution, you should submit a ticket on it's bugtracker: https://rt.cpan.org/Public/Dist/Display.html?Name=Reddit-Client
1. "EVANGELIZING" in Australia? What's wrong with spelling the word properly? 2. Was this held at Optus' North Ryde campus? 3. Telstra use Perl now? Where? &gt; he said he'd read it at an outdoor Music Festival on a weekend before a job interview on the Monday I'd be curious the name of this individual if you want to PM it.
A nice little description of how you did something useful to you and kept updating it over the years. I don't think you should feel bad (if indeed you do) that you never put it under version control or made it available to everyone until now. Not everything needs to be fully open source and version controlled from the start. 
Yes sorry the logic was inverted. I realize that it is supposed to clear, not set the bit. pwr22 got it right.
when was this? I wanted to meet fellow perl coders.I guess I missed it..any news about the next event?
I'd like to hear some reasoning behind PSGI being dated. This is the first I've heard that, and I can't think of what it might be referring to.
I tried using it briefly about a year ago. I had a wicked hard time satisfying the compiler. It expects a lot of best-practicey boilerplate at the top of every file that is not intuitive (for backward compatibility with regular Perl?). That being said, it's a cool idea, and ISAGN for a sane subset of Perl that is fast and easy to parse, and you can only do that by throwing out lots of features. Maybe one day we'll be able to use RPerl or something similar for some of the things we use XS for.
[No](https://en.wikipedia.org/wiki/Betteridge's_law_of_headlines).
OK, PSGI author here :) &gt; we should revisit the PSGI spec in tandem with implementing P6SGI much like Perl 6's spec has been written in tandem with writing the language. I'm not sure I follow what you mean - PSGI and P6SGI isn't apple to apple to P6 spec to Perl 6 the language. We did iterate over the PSGI spec by writing implementations for popular web frameworks such as Dancer and Catalyst. Actually I have those adapters working before calling the PSGI spec 1.0. I don't think the spec is dated per se, but you could find some area where it needs to be updated, such as a non-buffered HTTP body read from the clients (some servers like uwsgi already do) or support for newer protocols such as HTTP/2, which wasn't around when we designed PSGI, which was a clone of WSGI and Rack. Ruby folks basically have [given up updating Rack](https://groups.google.com/forum/#!topic/rack-devel/P8oOycVBaH0) to support H2 though, explicitly yielding others in the community to spin up some replacement. That's the approach I would take here as well. See also: [WSGI 2 proposals](http://wsgi.readthedocs.org/en/latest/proposals-2.0.html)
tl;dr 
how about this tl;dr: "Perl is not very good at things Perl is not very good at, like lots of sub calls, frantic dereferencing and array differences." Ok, that's not entirely fair, but it is an ongoing problem when you try to apply the really cool haskell stuff to Perl. It works, but it's horribly slow. EDIT: Also, what beast of a laptop do you have? That snippet takes at least 7s on all my machines, including desktop.
And its a shame too. I really liked the hamming number streams in Higher Order Perl. And then I rewrote them to not use streams. Defeats the whole purpose. :( On that topic, why is perl that slow when calling subs? I know that creating scopes takes some time, but somehow other languages don't seem to have these problems. Or they are just broken, which is always a possibility.
This might be a KS specific thing, but I'm not sure what that id data is doing. The project is set clearly, and your login and password make sense. I see where it looks for backer openings, I'm just not sure what the rest of that is doing. 
Just for reference, here is my version: page: send_more_money module: perl my @digits $(set:prev=digits) &amp;call tryeach, s &amp;call tryeach, e &amp;call tryeach, n &amp;call tryeach, d my $send = to_number($s, $e, $n, $d) &amp;call tryeach, m &amp;call tryeach, o &amp;call tryeach, r my $more = to_number($m, $o, $r, $e) &amp;call tryeach, y my $money = to_number($m, $o, $n, $e, $y) $if $send+$more==$money $print $send + $more = $money exit subcode: tryeach(s) $(allow_recurse:10) $(if:s in s,m) $(set:range=1..9) $(else) $(set:range=0..9) $foreach $$(s) in $(range) $if !$$(prev)[$$(s)] my @l_$(s) = @$(prev) $l_$(s)[$$(s)] = 1 $(set:prev=l_$(s)) BLOCK fncode: to_number my $t=0 $foreach $a in @_ $t=$t*10+$a return $t That is in MyDef, equivalent in Perl: #!/usr/bin/perl use strict; sub to_number { my $t=0; foreach my $a (@_){ $t=$t*10+$a; } return $t; } my @digits; foreach my $s (1..9){ if(!$digits[$s]){ my @l_s = @digits; $l_s[$s] = 1; foreach my $e (0..9){ if(!$l_s[$e]){ my @l_e = @l_s; $l_e[$e] = 1; foreach my $n (0..9){ if(!$l_e[$n]){ my @l_n = @l_e; $l_n[$n] = 1; foreach my $d (0..9){ if(!$l_n[$d]){ my @l_d = @l_n; $l_d[$d] = 1; my $send = to_number($s, $e, $n, $d); foreach my $m (1..9){ if(!$l_d[$m]){ my @l_m = @l_d; $l_m[$m] = 1; foreach my $o (0..9){ if(!$l_m[$o]){ my @l_o = @l_m; $l_o[$o] = 1; foreach my $r (0..9){ if(!$l_o[$r]){ my @l_r = @l_o; $l_r[$r] = 1; my $more = to_number($m, $o, $r, $e); foreach my $y (0..9){ if(!$l_r[$y]){ my @l_y = @l_r; $l_y[$y] = 1; my $money = to_number($m, $o, $n, $e, $y); if($send+$more==$money){ print "$send + $more = $money\n"; exit; } } } } } } } } } } } } } } } } } Timing: $ time perl out/send_more_money.pl 9567 + 1085 = 10652 real 0m5.831s user 0m5.824s sys 0m0.004s The python version: $ time python send_more_money.py [(9567, 1085, 10652)] real 0m5.146s user 0m5.136s sys 0m0.008s 
He's fetching the rewards list for the KS, filtering with grep to just the reward tiers he wants with open slots available, and printing the reward name, id, and backer count. The postfix 'for' combined with grep is kind of confusing to read but I can see how he got there if this started as a one-liner.
Don't these have ASCII representations anyway? It would make more sense to prettify those characters with prettify-symbols-mode or something: http://www.emacswiki.org/emacs/PrettyLambda Easier to type, display choice, other people can edit the code, etc. 
Its rather ironic that testing in science is a relatively unknown concept ... given what science is fundamentally about. You know, testing your assertions, and repeatedly testing your assertions to make sure they are demonstrated to be evidence, not conjecture. That the tenet of "test all the things" doesn't bleed from the "science" mindset to the "code" mindset makes me a little fearful of how rigorously they apply "the science" part of the science mindset.
Scientific software is in a pretty bad state right now. Thankfully people are trying to correct this. Software Carpentry specifically teaches a few software engineering skills to scientists so they can bootstrap to better practices later on (e.g., how to use Git). But the practice of proper software testing is still one of the hardest skills to teach especially given the short workshops.
Well, there's [Test::Tutorial](https://metacpan.org/pod/distribution/Test-Simple/lib/Test/Tutorial.pod) to get started. You can find presentations and such on youtube, but I don't have any in particular to recommend, sorry.
"remove" sub can be rewritten(to gain some speedup) as: my %dig = map { $_ =&gt; 1 } 0..9; sub remove { delete local @dig{@_}; [keys%dig] } then: remove(0,$s,$e,$n,$d)
There is a large internal webapp at work written in PHP. It has no testing. Sometimes features are added or removed and things break. Why is this? Because there is no testing. But that answer is simplistic. The developers (of which I dabble because I detest this application and like to make it better when possible) do as much testing as possible to ensure things aren't broken, but there is only so much you can do when you just don't know what the cause and effects are. Take for instance a webpage where the normal expected input is a phone number. You run all the tests you think of on every phone number format you can think of. All by hand because you have no test framework. Once you're done you are reasonably certain that you didn't break anything, but maybe you forget to test some inputs, like NO phone number, or phone number less than 5 digits, or phone numbers with letters in them. The next day you get bug reports that half the callers are being routed to the default queue because of a change you made. Well, you fix it, but fixing it just means you've corrected the problem this time. You don't know if it will still work the next time you refactor code or add new features. Because of this lack of testing (amongst other issues), they are still on CakePHP 1.x with no upgrade path. They have had regressions on the page that have caused day-long outages (some that were un-revertable due to complicated database changes or other issues) Anyway, don't be the guy that doesn't test things. Getting people into a test-driven mindset is hard but it's very rewarding once done, and it really gives you good feelings to write code and then see the passing marks from the tester.
What use is the ability to use unicode in your code if you don't make use of it? Even perl5 C code has unicode in it.
My comment was tongue-in-cheek, but my serious response to this is that people will do what they must because they can. Perl5 has Elven written in Tengwar script in it, just cause. You have to strip comments manually to get it to compile in llvm, because it doesn't like it. That's how perl works and it's awesome.
"I swear I am not a spam bot" - /u/leolacz 
I got time to read some of the slides in [Perl is not dead, it is a dead end](https://speakerdeck.com/stevan_little/perl-is-not-dead-it-is-a-dead-end), skipped the early emotional images and I am on this slide with perl's *@_*: "Do you know any other language doesn't have proper subroutine signature?" and I immediately had this reasonance: _Do you know any other language that doesn't need proper subroutine signature?_ For me, @_ is the core feature of Perl -- dynamic to the core. EDIT: I guess it is not fit for enterprises or large scales, but that is why language like Java have a role.
&gt; motive is improving the language for the language's sake. See also [Perl6](http://doc.perl6.org/language/5to6) (the language, not the amazing underlying engine)
From the website: &gt; my $scalar = ("Alpha", "Beta", "Gamma", "Pie"); &gt; print $scalar; # "Pie" Is this because it was set as Alpha, Beta, and Gamma first? Is this value resetting itself every time it hits another element in the list till the list stops? 
I always `use strict`. However, I couldn't `use warnings` because I often rely on some features that it wants to warn me, such as relying on absent values being false and auto convert into empty string or 0. I think `use warnings` makes sense for modules especially when it is intended to be used by others; but for day-to-day programs, `use warnings` is like tying one's hand.
&gt; Do you know any other language that doesn't need proper subroutine signature? That's kind of like PHP 3 asking "Do you know of any other language that doesn't need variable declaration?" as a defence of `register_globals`.
&gt; "Do you know of any other language that doesn't need variable declaration?" A lot? (and the rhetoric question was not the sole defense either).
Your old version, you are summing up 8 fields and printing them, kinda clear. Your new version, takes some sitting down (I haven't yet). Of course you don't need justifications for your own favoritism (the second version is fashionable).
&gt; Why not instead state the fairly reasonable: "it is time for various stakeholders within perl to decide which of the two incompatible sub-currents within software in general they want to go with"? I don't intend this to sound snarky, but hasn't that already been decided to some extent? p5p's support policy is pretty clear to me. Maybe the CPAN toolchain needs an explicit support policy?
C has the same behaviour with the comma operator
Yeah, I wish it was apples apples, the second one (seems to) give up the totals.
The lack of variable declaration is a sizeable wart in pretty much every language I've seen it in, and people to make this mistake of language design usually find themselves writing stricture fixes to resolve this wart in later versions.
They kinda do, and its covered by various "Consensus" meetings at hackathons/QA events. But the pressure is mounting to push the minimum version forwards by some, and others are pressuring that at least a certain subset of critical Perl code should support `5.6` Its this very pressure of pushing it forwards that is inspiring the "How about we split then" mentality, because the "Compatibility" school and the "Get all the new things" school can't really share the same pie. So, for instance, a proposal *might* be to define a secondary index, and people who are joining the "break compatibility for new things" only find themselves in the second index, not the primary index. And this logic is of course under the presumption that the primary index should be compatible by default, so that only people who are willing to try new things get the new things by opt-in, as opposed to a "Your system will break because somebody changed something and you didn't opt out of getting things broken" attitude. 
So why is that value the last one listed? 
It is not a list. It is an expression with parenthesis. The expression is made up of comma operators. Apparently scalar context does not take list. Whoever write your example is making mistakes (writing code not as intended) -- in the same category as writing `if ($a=$b){...}`
For example, there is type inference, and there is default scope. So in many languages and many situations, you don't *need* declare variables. Of course when you intend something specific and different from default, you want to declare variables and you probably should as it is not *lacking*. As to Perl's sub, its need of argument signature is in the same nature as its scalar's need of types. Every sub often has an implied signature just as every scalar often has an implied data type. But to differ from a static language, Perl implement them dynamically. With this particular loose implementation, Perl become convenient to use -- the kind of convenience that is hard to find in other languages. As you said, people who need those features are coping with it. And that is another benefit of loose implementation. It creates a mantra of *there is more than one way to do it*, a kind of *freedom* that is hard to find in another language, a kind of freedom that allows some programmers who are having different vision than popular ones can still do their things in their ways.
I was little confused on your comments. If those *attributes* are 5.6 compatible, then it means those *attributes* do not break code written for 5.6, then why do they need back port? What does back port even mean? Back porting them will just make 5.6 into higher versions, right? Were you suggesting backports because in fact there are *features* gone into higher versions in addition to "security patches" and "compile on modern hardware" that are incompatible to 5.6? There are two ways to go about it (if those features are deemed not welcome, just if), back port the good attributes or remove the new undesired attributes. I really hasn't been following perl's new features since 5.8 and has been using whatever default version of Perl my system has without missing anything so I have no idea what kind of *incompatibilities* are there.
That's not a good reason for not using warnings. If there are warnings that you don't care about then you can explicitly allow them. use warnings; no warnings 'uninitialized'; Even better, just turn off those specific warnings in specific scopes where you know you're going to break the rules. use warnings; sub my_naughty_sub { no warnings 'uninitialized'; # Get no 'uninitialized' warnings here } But, really, I'd recommend getting out of the habit of ignoring those warnings.
In addition to what kentnl said, I find chromatic's line of reasoning bizarre. p5p is not some sort of **standards body** with anything even resembling a **mandate for change**. If anything, p5p should (yet doesn't often) be **serving at the pleasure of CPAN**. In any case having CPAN authors model their behavior and policies on the whims of p5p is... strange. 
yeah really looking forward to this. It's a shame I haven't had the headroom to spend time getting our code to work with the betas, sorry :/
Like a good teacher, I know someone will tell me the supposed actions. But bit by bit, they just making Perl a bit less convenient to use. Convenience, after all, is the main reason we use Perl. In order to fine-tune the warnings (globally tailor), one need go through all the warning categories and deliberate on the cases and judge which is merely a trivia habit and which may be ignored for greater benefit. Alas, such document is hard to find. The best I can find is on perldoc with a list. &gt; Note: Before 5.21.0, the "missing" lexical warnings category was internally defined to be the same as the "uninitialized" category. It is now a top-level category in its own right. If I use `no warnings qw(uninitialized missing)`, it won't compile on most of the machines as they do not have version 5.21 installed. But I can't just use `no warning qw(uninitialized)` knowing the code will spew what looks like errors on some alarming users. Such dilemma lead to the only solution of not using `warnings`. Ignoring warnings merely means learning and taking default behavior as part of language features. There are infinite amount of potential errors one could make in any languages. Warnings are some common error pattern that maintainer of the Perl took notice and deemed not harmful, hence put into warnings. It is by no mean extensive -- `use warnings` does not make your program suddenly safer as there are vast more potential bugs that is not covered by all the warnings. And I internally deduce that all the warnings category must all have legitimate use cases or why won't they put into `strict` or "critical warnings" that is on by default? So for me, warnings are used as debugging. I do not use warnings unless I intend to check them. PS: I consider my use of uninitialized and missing variables a key usage of Perl. If I do not ignore the warnings, I have to either always initialize them or always check existence/undef before use. In the case of arrays and hashes, I often cannot initialize them all. The checking of existence/undef is clearly a burden with no apparent benefit at all other than to suppress warnings -- that just feels silly. The same with localized `no warnings`, extra statement with sole effect to suppress warnings that we already deemed harmless. PS: A case in point that warnings are no where near extensive: I very much like Perl warn me (make it fatal) on following: my $scalar = ("Alpha", "Beta", "Gamma", "Pie"); print $scalar; # "Pie" if ($a = 1) {... } Not this: if(!$a{key}){...} EDIT: I understand `warnings` does not stop the program running. However, conscious programmers (I figure most of us) can't leave a program spewing error messages and call it running fine. So turning on warnings means to modify code until warnings disappear. Knowing the code is fine and writing extra to just suppress warnings (that should not be warned in the first place as the code is fine) is silly. EDIT2: I hate to be minority who advocates not to `use warnings` at all times. If every one is singing the same voice, then at one point the only thought will be why not make Perl use warnings by default. I don't know why that haven't happened yet as from what I see, all major Perl authors advocates it. But I am glad that hasn't happen yet
there is no list. in the statement: my $foo = (1, 2, 3, 4); there is no list at all. the thing you have to remember is that in list context, _everything_ is a list. in scalar context, _nothing_ is a list. there's another thing: the parens do not build the list. they are there for precedence reasons. so. because the above statement is a scalar assignment, its right side is evaluated in scalar context. therefore, the comma operator is also in scalar context. in scalar context, the comma operator does not build lists at all. there are no lists. it does what the c comma operator does, which is to give you back the right side. so the first comma returns (2,3,4). the next comma returns (3,4) and the last one returns 4, which is the value of the expression (1,2,3,4) in scalar context. which is what gets assigned. the () are there because , has lower precedence than =, so without it, the expression would be parsed as (my $foo = 1), 2, 3, 4; so dont let them confuse you.
&gt; without the parens, does that mean foo here would be 1 That depends on the precedence of the `=` operator compared to the precedence of the `,` operator. Which one gets evaluated first? Is the entire line equivalent to: (my $foo = 1), 2, 3, 4; Or is it equivalent to: my $foo = (1, 2, 3, 4);
&gt; remove features that break 5.6, i.e. make code written for 5.6 still work That's not as easy as "Let's turn all `say` calls into `print`" when you have XS to support.
Chromatic, this manner of arguing is bullshit. Let's just get to the root of it: You have a somewhat-respected-and-listened-to member of the "inner circle of perl" who is openly stating a non-negotiable prerequisite to his involvement: anything **I** ship to CPAN must install on Perl 5.8.5 or often even earlier (there are multiple consideration influencing the cutoff, I need to document them at some point). I am also openly not planning to re-evaluate this stance until at least year 2020. I do not need to "convince" anyone to take part in any of this, nor do I need a massive degree of cooperation from others to achieve my prerequisites. My currently engaging with some of the stakeholders are mainly there to benefit packagers and by extension endusers, by attempting to keep the deptree slim. That is - trying really hard to avoid forking pieces of the ecosystem that won't "play ball". My point is - you (as a community) either tell this contributor to go away entirely, or you put up with his requirements. You don't get to cherry pick which parts of my effort you get to keep. The toothless platitudes that I keep hearing more and more lately are neither here nor there. If it bothers you that much - take a definitive stand.
I nominate Plack.
Well, what I meant was the firs tone (that was your example that I was asking about, as it seems clear that in the second case, the answer is 4). I'm just wondering if the parens render the rest irrelevant, or if they are more there for clarity of reading the line. 
Hey, _perly_bot: please take olaf_alders off your list.
This thread and your *compatible* assertion piqued my interest. I downloaded v5.6.2, compiled it, and benchmarked a recent script against my current installation (v5.14.2), and the older version is 15% faster. I think it is kinda reasonable given that those *compatible* changes nearly doubled the core source size. I always got the feeling that Perl was the king of scripting language -- at least against python, but this 15% speed lapse really hurts my pride (in using Perl). I am attempted to maintain my own Perl from now on. 
&gt; If it bothers you that much - take a definitive stand. Oh, I have. I think supporting 15 years of code and 38 releases is a burden too large to put on volunteers. I personally have no interest in contributing to Perl 5.24-to-be if I'm going to spend the next 15 years hearing that I can't rely on any bug fix, feature, enhancement I volunteered to produce because of those considerations to which you allude. (That's one reason I don't touch the CPAN toolset.) I'm not going out of my way to write code that *can't* be used on 5.6, for example, but I consider the feature set of 5.16 fair game for anything I write that ends up on the CPAN. If someone wants to do that, big thumbs up from me. I'm not going to tell volunteers what they should do with their time, but I'm more than happy to discuss where the cutoff line is and should be--and what the consequences are for support.
Undefined values are not undefined behavior. Undefined behavior means different compiler/interpreter can run the code differently and all meets the language *expectation*. Undefined values are well defined and has well defined behavior in Perl (the language). In your example, sub returns undefined value as well as $_ by default has undefined value, and undefined value is converted to empty string upon print. Your examples' behaviors are well defined and above all, expected behavior. However, in the example of my $scalar = ("Alpha", "Beta", "Gamma", "Pie"); The author of the language are expecting a list assigned to a scalar; in reality, it was never a list despite of an identical appearance of a list syntax. If the language says list in scalar context is undefined, then any behavior is not breaking the language (either $scaler == "Alpha" or "Pie" or anything in between or even 4 will do) but at the same time, it discourages user to write such code. Undefined behaviors are syntactically correct code construct that does not make semantic sense.
I think the problem with Perl is it has never formalized a language specification. If we formalize the language, e.g. based on v5.6, then all the subsequent versions as well as earlier versions are simply language implementations. The later implementations may include security updates, bug fixes and even new features within the "unspecified behavior" section, but it should not break codes that conforms to the language standards. I understand the center point of current dispute is really on the myriads of XS modules with some of them relies on very deep internal structure. As such, it will be necessary to include in the language specification that part of internal structure interface to be standardized as well. If this effort of standardization is to be initialized, it should be understood that it is not supposed to be a copy of v5.6 behaviors because that would be forcing all implementation to be v5.6. It should be understood some of old modules will be deemed standard non-conformant. But the bottom-line is it will be a community effort and detach Perl (5) as a language from p5p. It will not be a disrespect for p5p's (largely volunteer) effort, but intended to simplify and free p5p's burden and better appreciates their effort. I like the idea of p5 as ANSI C, and p6 as C++.
Well, if you feel so strongly, so be it.
Thanks. Was wondering how to go about requesting that. :)
Ah, I didn't realize it was on Github. Maybe in future I'll just let _perly_bot handle submissions for me. That seems easiest. :)
I often like my warnings fatal (often impractical). If I want to avoid a warning I will turn it off 
probably the same, but `-e1` is a constant statement while `-e';'` is truly an empty statement. On a comparison with `-MO=Deparse`, `-e1` yields `'???';` while `-e';'` yields nothing.
People have floated this idea and tried before. If it were reasonably complete, it'd be easier to convince p5p to support. Why 5.6, though? That seems arbitrary, unless the intent is "Let's document the final version where Larry was directly involved". Personally, I'm loathe to give up working Unicode.
&gt; We at least try to make the life of these poor souls less miserable. Why? They've had fifteen years of free community support. What more can be done for them? Whose life is less miserable if I somehow figure out how to make `Modern::Perl` install on 5.6? (I know, bad example, but let's make this discussion more specific.)
&gt; It's "death by a 1000 cuts" from an individual PoV. Sure, but that cuts both ways. (Not sorry for the pun.) As a volunteer, the things I do in my spare time are not made more enjoyable or easier if "Here's some code I wrote to scratch my own itch; it's under a free licence for you to use, abuse, fork, modify, submit patches" is greeted with "You need to support 15 years and 38 stable versions of Perl across at least the major three platforms". I don't mean to cast this as two polar opposites with an excluded middle. I'd like to have the discussion of pros and cons with as much evidence provided and as many risks analyzed as possible. We may be able to come up with solutions that aren't either a guideline of "Apply patches to support older versions of Perl if they're not invasive" or "Stick with p5p's support timeline." Bonus points if we can deal with the problem of vendor Perls. (No, "everyone must use perlbrew/plenv" is not a complete solution.)
&gt; Nobody is asking the above of you. Then I don't understand the problem. Look, I know Reini doesn't speak for you, but when you and he share a similar position that "people still using 5.6 shouldn't be hung out to dry" and he complains that people like Ether who are doing fantastic, thankless, unrewarded, and unacknowledged work aren't doing enough (and, in fact, are doing *harmful* work), then I get a little nervous. Reini's a smart guy. The source code is there. I have full confidence that he can accomplish things most people would consider impossible. I just can't reconcile "Hey, I want to make sure that people still using Perl 5.6 can use the CPAN!" with "You're a bad and awful human being and programmer for suggesting that CPAN authors should be able to rely on features of a Perl released this millennium." Again, I don't intend to attribute Reini's words or thoughts to you.
Those can be left out of the standards or spec'ed as undefined. This way, the old is not necessarily standards non compliant, but dangerous or bad style. In particular, I would like every thing `use strict` forbids to be undefined, in which case, implementations are in fact, encouraged to turn `strict` on by default or at least warn. As long as the implementation also have a flag to turn strict off, I think it is still workable with legacy modules. The way v5.6 (or later) uses modules to implement certain core language features are implementation specific choice, and it shouldn't be concerned. `feature.pm` and `experimental.pm` are just some particular implementation extension, right? Defining standard at the same time is calling for a standard reference implementation -- which I am thinking could started from a v5.6 fork -- that is what I meant by basing on v5.6. Calling for but not necessary -- the standard can lead reference implementation. If the newest version from p5p contains option to turn on standard mode, then that can serve as a reference implementation as well (up to standard committee's sanction) . I think, (if the standard gets drafted), every implementation of perl ever existed will contain deviations from the standard; but that will be OK if the standard is carefully drawn as a core subset of all existing implementations (maybe since v5.6) yet is complete (e.g. without `say` is still complete). Most of the version specific features are implementation details anyway, to be lazy, the standard can leave most them undefined or implementation dependent, except a core set to ensure some baseline code compatibility. EDIT: Which also implies that large portion of CPAN legacy code will only run under special `pragma` options or spew error or not run. I think that is a good thing. On one hand, desperate users still can use it. On the other hand, too much unmaintained/legacy code is not healthy for the community anyway and some mechanism of weeding them out is good. EDIT2: On the other hand, the standard can include specs that does not exist in any implementations yet. For example, Perl is the language with context and one of the context is boolean context. I would be nice to spec that assignment in boolean context to be undefined. It maybe that none of the implementation detect such behavior (due to complexity), but the standards can vision it. I know many people like use `while (my $a = open...)` but I still can wish.
 perl -e '' Is even less nothing though... and faster the second time thanks to the wonders of caching.
Sigh... You tangled so many unrelated things above, that this medium is no longer suitable to untangle them. I'll ping you when there is a clearer writeup.
I'm honestly no longer sure who the real dominant P5.6 market really is, and my mental model of what/who we're dealing with in reality is a composite of a series of other observed behaviours. Typically, when I hear of individuals using it, they are already greatly out of touch with "the community", or they are wading into a system that has no community representation, trying to work out how to do something. These are typically also the "Can't use CPAN" sorts of demographic, so that further exacerbates their invisibility. Naturally, when these people cross our paths, our first port of call is the "Yes, you can use CPAN", but having used CPAN on 5.6, that's not actually very practical at present. ( Most things you just think "I'll install that" end up not working because some dependency needed something newer, but you don't discover that fact until you're 4-steps down the dependency tree. ) Naturally, our "best" recommendation is in these situations to explore the possibility of a newer perl, but that is frequently a "DevOPS/Legal won't let me" case. And of course, if you do have a sizable infrastructure of any description built on 5.6, the overhead of upgrading it to something newer and getting the technical assuredness that everything works as it once did is very relevant. I just don't quite understand how we can ever come to a point where we can say "well, what you do is too old, we can put you on an ice float now and hope the polar bears get you". It is ultimately every developers discretion as to what they invest energy in. But one developer blocking another developer from investing energy in a goal, where no inverse blocks are inherently present seems like some kind of freedom limitation. I can see how this may be perceived in the inverse, that compat people are blocking people from using new things, but that doesn't necessarily have to be the case, there's always ways of creating a secondary stack for legacy reasons ... its just usually less pragmatic to maintain 2 pieces of code when you can maintain one due to one of those ways working in 2 places. I've also suggested/entertained the ideas of Tiny-esque forks of common popular modules with a compatibility agenda instead of a features agenda. Just the duplication of logic and the duplication of dependency trees seems likely to be harmful in itself in some way. ( I'm not entirely sure what my objection here is, I just get bad feelings about this and I have to work out why that feeling exists ) 
It might be a lot easier to discuss smaller issues individually. I'm personally interested in seeing your list of constraints--but like I said, I have no interest in ever publishing guidelines myself, informally or otherwise.
That sounds very ambitious, but things like this have been done, so if you do it, I'll applaud you.
[**@peterseibel**](https://twitter.com/peterseibel): &gt;[2015-08-02 14:31:33 UTC](https://twitter.com/peterseibel/status/627849220729364480) &gt;We write: &gt;1994: Perl that emits HTML &gt;1999: HTML with embedded Java &gt;2004: HTML with embedded Ruby &gt;2015: Javascript that emits HTML ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3gba0q%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Also, don't forget Ruby is not *that much* younger then Perl. It was around from the mid-90s.
Yes, I'm sure that brings in lots of community contributions.
For me, 1998 was PL/SQL that emits HTML.
I pulled out some perl code I hadnt touched for two years or so this weekend (a localhost only web app I wrote to analyse some social science data). While sitting neglected I'd gone through a few perl major versions and a couple of OSs. there were a couple of missing CPAN libs, but otherwise it all worked fine. 
sigh, oh nevermind. 
The official link is: http://www.vromans.org/johan/software/sw_pbpref.html which also has a more recent version.
A common optimisation I've used for sciencee things: if you have a very large hash being used just for testing existence aka set membership using `$set{member} = undef` rather than `= 1` saves on some ram per entry. For normal code its gross and always demands a comment.
&gt; I wish you'd stated this at the start I [thought I did](https://www.reddit.com/r/perl/comments/3fx3cg/visualizing_perl_5_release_history_2015_edition/ctuzs2h) as clearly as I can...
For the least knowledgeable of us, is there a verbose version with explanations and examples for each ?
I suppose you did. I can think of many, many things more enjoyable than putting out code, for free, for anyone to use, modify, redistribute and then being told I haven't done enough because I don't care to support Perl 5.6--and then being told that I'm *harming* the community because I explain *why* I don't care to support Perl 5.6. Given *that* situation, it sounds a lot more enjoyable for me *not* to release code at all.
Is your `perl` old enough? ;-)
They're both unbearably slow, PERL is not the right tool for this job.
Don't use so much perl these days, but I do use Regexp:Assemble very regularly. I have a simple perl script that reads in from stdin, adds them to the assembled regex, then spits out a final regex at the end. A number of the things I do at work benefit from it.
`Data::Dump::Color` hands down
That's fantastic.
App::cpanminus :)
I quite like AnyEvent. 
Good call
&gt; But complaining about the non-existent requirement for you to support something is not the only thing you are doing. It seems to me that this argument hinges on the semantic difference between a specific definition of "requirement" and a specific definition of "request". I personally don't want test results for anything older than 5.16. I don't want bug reports for anything older than 5.16. I don't want patches for anything older than 5.16. You have the code. You can modify it. You can redistribute it. Feel free. I even just went through and gave ADOPTME PAUSE privileges on everything I'm not currently using so that someone who wants to support anything older can take them over. I don't want lectures about how the code I write in my spare time and give away for free (to be used, modified, redistributed) is "harming" the community because I personally don't want to support anything older than 5.16.
What are your top 15? 
Smart::Comments is by far the best thing I've found! Use it day in and day out!
Coro::ProcessPool does this. 
You can as long as you realize that every process has a completely independent event loop. You can't schedule a callback to run on a different process, and if you want to signal another process you need to do it through traditional means (signals, pipes, sysv semaphores, etc.). You can't, e.g. signal an AE condvar that's waiting on one process from another process.
There are, after all, 255 of them. It might be a bit extreme to expect any non-empty software project to conform to all of that. 
[ack!](http://beyondgrep.com/) 
See the `select()` static method of IO::Select, so basically: ($can_read_handles, $can_write_handles, $has_exception_handles) = IO::Select-&gt;select(\@read_handles, \@write_handles, \@exception_handles, $timeout); 
Thanks! I have not been able to find this with my google-fu. Up till now I just used Epoll, which is kind of verbose.
&gt; I do use Regexp:Assemble very regularly It's obsolete since Perl 5.10. The [documentation](https://metacpan.org/pod/release/RGARCIA/perl-5.10.0/pod/perl5100delta.pod#Trie-optimisation-of-literal-string-alternations) claims it could be harmful to keep using R::A or similar modules. &gt; I have a simple perl script that reads in from stdin https://metacpan.org/source/DLAND/Regexp-Assemble-0.35/eg/assemble
Interesting. Deprecated or not, it still works, and I'm not relying on it in a critical fashion in production. If I was I think I'd argue I was probably doing things wrong anyway.
I wrote [Modern Perl](http://modernperlbooks.com/books/modern_perl_2014/) for people like you. That's the HTML version, with links to the PDFs. Ideally the company uses a recent version of Perl that'll let you take advantage of some of the ideas in the book, but either way, I hope the book is a good reintroduction to the language.
Was just about to suggest this, sir. 
AnyEvent-MP (with or without Coro-MP) might be worth looking at
Perl Best Practices and Perl::Critic are essential tools. Perl (like most sufficiently powerful languages) is about style choice. Sure, you could write code that would baffle acolytes and give monks a chuckle, code laden with single characters and sigils. Illegible Perl is a byproduct of its author's choice. The art of programming is in making complex ideas intelligible through meaningful abstractions. If you do this, you'll be fine. 
It depends. If it's a legacy project - prepare for the worst. If it's a new one, then Modern Perl is quite nice. 
Things you might have missed from dabbing with command line type tools are unit tests and objects. There are more resources for those than I could shake a stick at including what's already mentioned in this thread. I guess you could divide Perl codebases into Moose and non-Moose. You could ask your employer if they use Moose, and that wouldn't be the least bit out of line. You'd be likely to get an answer more complicated than a simple yes/no. It probably wouldn't hurt to ask them if there are any other major modules that they use... Catalyst, Dancer, Mojolicious, Plack, and DBIx::Class come to mind as likely candidates. Usually you can ignore modules (or mostly ignore them) used by code, some larger more framework-y modules and OO systems are far more pervasive. Good luck, and have fun!
You can also f*ck up in Modern Perl or any other language for that matter (meaning it's a matter of programmer's attitude/knowledge and discipline to write good and maintainable code).
If you write Perl as if it were C#, you'll be fine. Modern Perl involves the same kind of encapsulation that C# requires.
Good on them. Exactly right.
/u/mr_chromatic 's book "Modern Perl" is indeed excellent. However, if you have very little recollection of Perl, my [Beginning Perl](http://www.amazon.com/Beginning-Perl-Curtis-Poe/dp/1118013840/) book has great reviews and has problems (with solutions) at the end of every chapter.
I'd brush up on common non-language-specific development skills if you're a bit rusty on things like version control. Also I ASSume that if they're a perl shop they're also a *Unix* shop, so swot up on that too. As well as shell basics I recommend looking over the slides from a couple of MJD's talks: * http://perl.plover.com/yak/commands/ does a very good job of explaining how processes talk to each other; * and http://perl.plover.com/yak/ext2fs/ does the same for how the filesystem works. Both are a bit different from what you're used to in Windows. I consider both of those to be required knowledge for anyone programming in a Unix environment.
Awesome.
Booking dot yeah Great to see big names throwing their weight behind Perl
I still don't understand the problem. Sounds so obtuse. Rebase can reorder commits. I don't understand why he knew that in the first post and then didn't acknowledge that in the subsequent one.
Make your life so much better: start using List::AllUtils and stop worrying whether the function you want in List::Util or List::MoreUtils.
I'm not (exclusively) a perl programmer, so a code review would be appreciated.
An explanation of what you are trying to do, and why you name things the way you do would be nice, starting with *precision* and *recall*. A lot of the utility of functions comes from their ability to take arguments. Also, I recommend [HTML::TableExtract](http://www.nu42.com/2012/04/htmltableextract-is-beautiful.html).
&gt; In pattern recognition and information retrieval with binary classification, precision (also called positive predictive value) is the fraction of retrieved instances that are relevant, while recall (also known as sensitivity) is the fraction of relevant instances that are retrieved. from [wikipedia](https://en.wikipedia.org/wiki/Precision_and_recall). I'm trying to verify whether Cramer's stock picks are full of gold or full of shit.
That's August 16, which is this Sunday.
I did check this. I'm editing on my server with vim, so, I have to quit vim, run the program (and there's only one program called program.pl or anything remotely like it). So there's no chance of my having another copy open. I even did a find earlier just to check if some other copy existed for some reason. Also, is it me, or does this sub have a downvote bot? Every post here gets downvoted to 0 right away, then eventually crawls back up.
I may do that. I just wrote a debug function that dumps nearly every variable in the program. I've had my share of maddening bugs over the years too. What's happening in my script isn't that complicated, or shouldn't be. I've tested the individual pieces of it, and there should be no way what's happening is possible-- variables have values that simply don't exist in the current version of the program. Anyway, thanks, I will post if I do figure it out. Edit: wow, be careful with that. I left it running for just a couple of minutes, then decided to check the file size on a lark and it was 837mb!
Have you tried this module? It worked for me: http://search.cpan.org/dist/perl-ldap/lib/Net/LDAP/Control/Paged.pm
&gt; he's a pump-and-dump short-selling jerk who manipulates that market so other people make money off the rubes Trust, but verify is what I'm trying to do here.
[cpanfile](https://metacpan.org/pod/cpanfile): &gt; Tools supporting cpanfile format (e.g. cpanm and carton) will automatically detect the file and install dependencies for the code to run.
Could your file be sitting on a network filesystem? I've seen issues on occasion over the years where the network filesystem does some caching so the same file looks different when accessed differently. Over course, this is typically with multiple clients accessing the same file on a file server, but it might be possible on the same system if something is screwy with the network file system.
&gt; I'm editing on my server with vim, so, I have to quit vim Why are you quitting vim? Because you're constrained to one open terminal, or because that's how you're saving the file? &gt; does this sub have a downvote bot? Every post here gets downvoted to 0 right away, then eventually crawls back up. People have a tendency to downvote poorly framed questions or questions that come up all-the-goddamn-time. If you find a lot of your questions are being downvoted, and you're not finding similar questions when you search the subreddit (you should generally search to see if someone has recently asked what you're asking), you might need to peruse http://www.catb.org/esr/faqs/smart-questions.html For example; you don't really indicate what you've done, or how you've confirmed that perl isn't running the code you've added (by providing some sanitized examples of your output, and what you're expecting, and relevant code.)
No, I mean I browse r/perl every day and it seems that every new post gets one downvote before going up. I was making the change in vim, exiting to the shell, and running it. I was basically just saying that there wasn't a chance it was open in another editor.
Gotcha. I like to use multiple xterms so I can view the code, and do quick testing in another window or gnu screen / tmux. As long as you're aware you don't need to exit vim, that's all that matters. As far as the 'downvoting' you're seeing, it might be reddit's fuzzy scoring? I know it does some weird things to young posts. https://www.reddit.com/wiki/faq#wiki_how_is_a_submission.27s_score_determined.3F
It is /r/perl. I am sure the crank-factor is high. ;)
You should probably ask on the mailing list for Net::LDAP how to run queries asynchronously. You may like also to check Net::LDAP::Gateway that is a lower level module that allows one to pack/unpack LDAP messages, intended mostly to be used with event based frameworks as AnyEvent.
She hasn't changed much.
October?
Most perls shipped with reasonably modern systems support 64-bit integers, even on 32-bit machines. The speed penalty isn't that significant considering that arithmetic in perl is already not that fast, and the convenience of being able to deal with 64-bit numbers is worth it.
They are more at the stage of testing the major syntax reshuffle and refactoring around that. A lot of people are onboard for that work; if commit mentions in #perl6 is anything to go by. The implementation of the GLR gubbins is quite far along which is mostly jnthn. Regarding third party code it doesn't effect too much of my own code so far. Something in the way Bag literals/construction/coercsion changed is screwing my tests at the moment. Rakudo itself was completely usable before the GLR but it does look like this is going to speed the remaining slow stuff up some bit. If stability doesn't go out the window from the GLR Rakudo is set for at least the Xmas proper release. The beta might be a bit hairy.
Tell me about it! It seems I'm damned if I do and damned if I don't. Right now I decode and encode the source data as UTF8 and that seems to work in most cases. And then I saw this :(
Do you use HTTP::Response-&gt;decoded_content? Then you shouldn't have to decode yourself. Think of it like it works in Python: there are 2 kinds of strings: byte strings and character strings. You have to know which one you have at any moment. When communicating with external systems, decode() incoming data and encode() outgoing data. Inside your program, your strings are "just" characters.
BTW, I've added a check in my release script to check for prerequisite to a few "blacklisted" modules (for whatever reasons) and bail/abort the release if the (CPAN) distribution I'm trying to release, depend on those modules. File::Slurp is one of them.
I've been thinking that there should be a list of currently reccommended modules, to weed out modules like that.
The statement that "a release candidate is expected in September" is thoroughly bogus in the first place. I've now fixed that part of the Wikipedia page. Here's the [diff showing the main change I made](https://en.wikipedia.org/w/index.php?title=Perl_6&amp;type=revision&amp;diff=676692783&amp;oldid=674283073). The current wikipedia page quotes what Mark Keating wrote on the TPF blog in February: &gt; "The Perl6 team will attempt to get a development release of version 1.0 available for Larry's birthday in September and a Version 1.0 release by Christmas."
&gt; I don't even know what "release candidate" means after all this time. Afaict, [someone using ip address 24.89.139.58](https://en.wikipedia.org/wiki/User_talk:24.89.139.58) made that bit up. Edit: I didn't mean to imply malicious intent, just that whoever wrote that cited a blog post that said "attempt to get a development release of version 1.0 available" yet translated that in the wikipedia page to "release candidate" and "expected".
Uri Guttman is still active in comp.lang.perl.misc. Perhaps he might respond to a thread there.
&gt; If stability doesn't go out the window from the GLR That's the hypothetical I'd be concerned about if I'd given an expected release date.
Which require either working with the original author, or making your case to the PAUSE maintainers. If you could work with the original author at all, there wouldn't be an issue here. I imagine PAUSE maintainers will want you to show that you went to a great deal of effort to get in touch with the original author, and that you've exhausted all other avenues. All the more so when the module's author is Uri Guttman, who (like him or hate him) has a long history with the Perl community and is still very active.
&gt; How can someone who is active in the Perl community be unreachable for requests to adopt a project he no longer appears to care about? I see you don't know Uri Guttman.
I've had some personal encounters with Uri. Let's just say that I try to avoid him.
*dons PAUSE admin hat* Adoption is for departed authors, not intransigent ones. PAUSE can't become the arbiter of correctness. *removes PAUSE admin hat* ... not that there haven't been times I -really- wish we could ;)
You seem to be assuming (quite wrongly) that no efforts have been made to get the issue fixed in the original source. PAUSE admins cannot and will not turn over maintainership of the module to someone else, because the author is still active and opposes such action. 
You're not telling us anything we don't already know. What's your point?
add a $query-&gt;{TraceLevel} = "3|SQL"; after your prepare and see what is actually getting executed.
&gt; `Role::Tony` http://i.imgur.com/CvY1shV.jpg 
Nothing per se. I just came to dislike blogs/introductions/tutorials that fail to put a date on their site. As most people are aware, times are a changing a lot in the programming world. While I don't disagree about writing blogs, someone could at least direct to the documentation that is continuously updated. It could well happen that this, well written, excerpt of the capabilities of perl regular expressions is vastly outdated two years from now. Yes, this is a good excerpt. Things I personally wonder about is the compatibility with PCRE, or other regex engines. For everything else, I refer to the documentation that even provides me with a dimmed down version with perlreref â€“ and I can indirectly check the compatibilty by changing the version on the top-left (or on command line with `perlbrew use â€¦`) . You as well could refer to [this](http://www.extropia.com/tutorials/perl_faq.html#pattern) if you want to use regexen in perl. No just kidding (maybe not completely, it's just a page, maybe well in its time, failed to put a date on it and if the design principles wouldn't have changed in the last years, you maybe wouldn't notice that you're left out). Sorry, got in a bit of a rant. Probably it is a good thing. I often think about writing _rtfm_ and admire the people that don't â€“ and put up with the $big_number^(th) guy that asks how to extract the third column in his csv file only if the first column is a number. **Edit:** Oh â€“ and one thing I really miss are the quantifier-modifiers `?` and `+` that stuff gets asked so often (in my opinion), you really should include it. (I am talking about something like `/a+?/`)
Good points: ? and link to perlref added.
You can do that if you want, or you can use a number of solutions, my preferred one being perlbrew
Just read the 'perlbrew is simple' section here: http://perlbrew.pl/
If I can install modules that are already downloaded, it will work for my use case. 
You can just cpanm after you have switched to the perl you installed, e.g. cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz See cpanm --help
It's alive to me and has been alive to me since 2011. Though only really usable speed wise since the Moar JIT releases.
Well the new one has all the parallel and shaped/typed/packed array stuff hanging around in the VM waiting now. That wasn't so true when the previous model was implemented. Doing a parallel map for example is kind of handy https://gist.github.com/jnthn/03e2082ca5ed20ff8d44 Also I think a lot of people used to P5 timescales perhaps don't grasp exactly what the pace is of stuff going on in Rakudo at the moment. In the weekly Timotimo mentioned 210 (out of 1047) test files failing due to the GLR (on Wednesday late night) by Thursday that number was down to 184 (http://irclog.perlgeek.de/perl6/2015-08-20#i_11090352), with a lot of people actively contributing. So not impossible all tests pass and Rakudo is stable for the birthday release.
Yeah. I think that some of their marketing techniques can be a little... er.... over-zealous :-/
If you're concerned with keeping the dependencies of different projects from interfering with each other (IE: "Oh no, $PROJECT_A updated Moose and now all of $PROJECT_B's MooseX classes broke!"), you can take a look at Carton ( https://metacpan.org/pod/Carton ). It plays well with perlbrew.
Once you sign up for something...watch out! Email after email after...well you get the idea.
155 files now http://irclog.perlgeek.de/perl6/2015-08-21#i_11095527 someone plot the graph and see if they will make it on time :D
Interesting. I'm not sure I fully understand the Supply stuff - exactly when code gets executed and how normal program flows over all the react/whenever bits - but having Promises and Pipelines looks really really cool.
It's a stupid question because for most people it tacitly invites a dishonest response. "Having moved on for a pay and responsibility bump greater than you are likely to provide here," is the reality and everybody knows it.
You are right. The comparison is not appropriate. I was just thinking about the how overwhelmed I had felt that one time I tried to diagnose something, but the reasons for the number of tests, as you point out, are completely different and justified. Updated the post with a link to this comment, and struck out the original statement. Thanks for pointing this out. 
Let's see ... * Doesn't use strict. * Ships with a random .so file and no corresponding source. We're supposed to trust this random .so to be safe to use. This .so appears to implement the vast majority of the code. * Ships one giant `chilkat.pm` module that contains dozens of different packages. * Not free software. * No tests (at least in the tarball). * No POD. Head to [CPAN](https://metacpan.org/). There are tons of useful modules on there which come with the full code, an OSS license, tests, and good documentation. Ask on [irc.perl.org's #perl-help channel](irc://irc.perl.org/#perl-help) for specific recommendations.
Undefined subroutine &amp;main::process_entry called at /usr/local/share/perl/5.20.2/Net/LDAP/Search.pm line 55, &lt;DATA&gt; line 755. The search doesn't to go through at all because it doesn't return anything.
I don't think that's it. I'm focused on "Undefined subroutine &amp;main::process_entry " It's failing because it attempted to call the subroutine "process_entry" because it had nothing to process. I'm not going to modify a module. I've used this module without Net::LDAP::Control::Paged extensively and never had problems. I'm not sure at all if Net::LDAPs is even compatible as I can't find any documentation that suggests it is.
I use Net::LDAPs combined with Net::LDAP::Control::Paged, and haven't had a problem. P.S. I think @cpbills means simply to add a print statement _temporarily_ to assist in your debugging.
Do you have any sample code I can look at?
Are you in Linux? This is pretty simple on the command line to do. cat filename | grep Alabama | grep 2015 | wc -l
Let me save you $100. I am going to assume you are on Windows and unable to just use the grep command line tool. But in a cmd.exe or powershell window you could do something like the following on the CSV file: perl -ne 'print $_ if /^2015/ and /Alabama$/' file.csv | perl -E 'say scalar map $_, &lt;&gt;' You can just do whatever you want with `and /ThingToSearch/` so another example all the James' in 1985: perl -ne 'print $_ if /^1985/ and /James/' file.csv | perl -E 'say scalar map $_, &lt;&gt;' If you want to see the lines of output just remove the bit at the end `| perl -E 'say scalar map $_, &lt;&gt;'` This isn't at all a robust solution to repeatedly use unsupervised. But if you personally want to investigate some data you can fiddle with it. Here's most of the way to the script you wanted but using command line arguments instead https://gist.github.com/MattOates/7678c1d87ff71062a3af To use it do something like: perl super_cool_script.pl --year=2015 --name=James file.csv
You must show your code. You have `DateTime::new('undef' ...` I don't know what you did (I am going to guess you are using indirect object notation), but that is weird, and indicates something is not right. Also on PerlMonks: https://www.perlmonks.org/?node_id=1140023
Does `perl -V` show the same `@INC` paths?
Alas, my employer doesn't let me post the AD stuff I've written, but it's super basic stuff that I reworked from the examples I found very quickly online.
No worries. I fixed it!
It looks like it removes commas inside "double quoted" text. It does it in what seems to me to be a computationally laborious way and I'd imagine it's done that way as part of why it's so useful. Perhaps something to do with counting. Or some form of torture testing. However, my KISS first guess is something to do with integers above 999 ending up being represented as strings with commas in them (eg `1,000`) and then stored in a file format that puts those strings in double quotes. My second guess for why that snippet is so useful is as something to post on an online service like reddit to achieve some nefarious end.
Or try perldoc -l DBI with each user to see exactly which file is loaded for the module. The difference could be two different perl binaries, but also different PERL5LIB environment variables. If it's the same perl binary but different PERL5LIB, check the shell init scripts ~/.bashrc and/or ~/.bash_profile for both users.
ding ding ding! first guess was right. The [reward](http://i.imgur.com/sy9lVl4.jpg) is my respect. It was to strip commas inside fields of a comma-separated file with double quotes as the text qualifier, so I could load the file straight into a DB with integer and double columns for those fields. I didn't really want to pull in a library for such a short task that can be accomplished with very little code.
&gt; unlike the shit on http://perldoc.perl.org/ Seriously? The language documentation and reference is not necessarily the same thing as a tutorial. That said, where there is the chance of being confusing, I find the language docs generally provide a line or two to disambiguate the usage. If you are going to the language documentation in expectation of finding a method to provide file compression and documentation on how to use it, you are misunderstanding the purpose of the Perl language documentation, and would be better served by looking something up on CPAN, as autarch's comment mentions. This misunderstanding could come from using a prior language with a much more comprehensive set of core modules. Perl takes a different strategy, as do a great man other languages.
Out of curiosity which database management system is this? Most I've used have CSV import and support for numeric literals with commas.
In the end it is MySQL/MariaDB which can do it like you said. It is possible to import the CSV with clauses in the statement for fields enclosed by quotes and to remove the commas in certain fields with a function. I also sometimes import to SQLite which I'm not sure has the support or there is some other pre-processing I might want to do before importing which is easier to do in the file.
Yup SQLite doesn't do it :( A generic Text::CSV-&gt;DBI script would be kind of handy. I've never used any of the more Windowsy databases so was wondering if they support CSV or not. Since Excel is the queen of awful complex CSV output.
http://p3rl.org/DBD::CSV exists since 1998.
Yes. Isn't it nice when someone takes the time to point out how to do it well?
You're the second person to say this, but I don't understand where the perception is coming from. The first example is not a dispatch table, but an unconditional routing of a given string to its corresponding subroutine. Right afterward I say "One solution to this is the dispatch table."
Because the title is "Dispatch Table" and you start off saying this: &gt; This code demonstrates why such a practice is bad: That is why maybe a little more explanation in paragraph would be nice. 
can you set them to empty string in &lt;magic&gt; instead of undef? or just turn off "use strict" - there are times when that's OK :)
That's probably the solution, but `(1,2,3, undef, 'password')` is a list.
Ah, thanks. I have a bad habit of using them interchangeably in Perl.
The [defined-or operator](http://perldoc.perl.org/perlop.html#Logical-Defined-Or) is your friend. $username //= -1; $pass //= -1; $firstname //= -1;
Then the script (in the gist) is easily edited :P Plus at that point you would abstract out the script. But for someone completely new to perl and by the looks of it programming you want something painfully obvious and copy pasta hackable.
I'm using Net::SNMP and I can get ONE stat, but I don't get how to get more than one. The documentation is very verbose. Can you give me a hint on a starting point?
Try it like this: my $data = $snmp_obj-&gt;get_table(-baseoid =&gt; "1.3.6.1.2.1.2.2.1.2"); Then use Data::Dumper to look at the output of the function.
Yeah check out this one function. Which it pretty much what you want. http://search.cpan.org/~dtown/Net-SNMP-v6.0.1/lib/Net/SNMP.pm#get_table()_-_retrieve_a_table_from_the_remote_agent
Nice!
Also, perhaps it should be announced here: https://plugins.jetbrains.com/wishlist/show?pr=&amp;wid=368
This one is closed.
Mojo requires much more love from plugin. Only few base features are implemented.
Looks like they already got a volunteer, but that's gotta be disk issues. Periodic lockups are usually timed out disk IO reqs in my experience. I guess i'll email in just to be polite.
Sure, but why is it in the sample code? `$n` is an Int, `$acc` is only ever `1` or itself times the integers `1` thru `$n`. That can get BigInt sized but never fractional. It has to be something the author forgot to explain or, more likely, remove. 
Given it's just producing some dummy content I'd go with the author felt like doing whatever came to mind :S 
&gt; the equivalent of BigFloat is a FatRat If you squint long enough that you don't notice how long you've been squinting...
Perl itself is much older, but yeah, CPAN is pretty young comparatively. :)
This refers to the permalink feature â€“ click the chain symbol at the top of the table â€“ which comes in handy when you require someone to file a bug report with the accurate browser version. Example: http://www.browserdetect.org/?ua=Mozilla/5.0+(X11%3B+Linux+x86_64%3B+rv:40.0)+Gecko/20100101+Firefox/40.0
Ah, that is useful. I didn't spot it. 
[The full article is here](http://www.olafalders.com/2015/09/04/stop-writing-your-own-commify-functions/). 
Don't tell me what to do!
&gt; Writing your own commify function may well be right up there with writing your own web framework or templating system. Most of us have done it and it probably wasnâ€™t worth the effort. That really spoke to me. After 12 years, I'm finally migrating off my custom web framework to Catalyst. It only took 5 years to migrate off my custom template system to Template Toolkit -- which is where my custom commify function has its current home, as a TT filter.
Why would it be expensive? You'd only instantiate $decf once in practice.
I understand not re-inventing the wheel and all, but a commify function is SUPER simple. It's not something you can really get wrong. It's a far cry from a whole templating language.
That's abysmal performance for something that should be a fairly simple operation. But looking at it under NYTProf I found it wasn't OOP that was killing it, but actual Math operations. That doesn't mean there isn't room for improvement: 18991 1 1 628ms 2.53s Math::BigFloat::new 18991 2 2 581ms 3.13s Math::BigFloat::bfround 18991 1 1 542ms 1.12s Math::BigInt::bround 18991 1 1 444ms 1.16s Math::BigFloat::bnorm 18991 1 1 379ms 541ms Math::BigFloat::bstr Introducing BigFloat while formatting decimal numbers is a bad idea. After a quick google search I found that most languages were using string formatting to take care of this. So basically treating the number as a regex and inserting the appropriate tokens where needed. That's disappointing from an algorithm standpoint but probably better than invoking floating point math. Even so, string operations aren't the fastest thing in the world. They're certainly slower than math if you can avoid the slower math libraries. I would love to see an implementation with Inline C that didn't use strings. Essentially you would be doing the same operations as BigFloat above, but you could divide and throw away the lower bits without using floating point. Finally, they should add try =&gt; 'GMP' to all their Math::Big calls so that it will try to use the XS based libraries. Where GMP can be GMP, Pari, or both, or whatever their preference is. Doing this improves things by ~700 calls/s on my machine.
I'm really not a fan of the "use a module for everything" mentality. If I'm going to have the extra layer of someone else's code in mine, there needs to be a reason. And there are lots of reasons and I use lots of modules. I just don't like the tendency to reccommend a module for everything, especially if I'm asking a question. If I'm asking a coding question, it's because I want to know how to do something, not how to have it done for me.
If you only need to commify for one locale, then yes, maybe it's simple. If you have to take various locales into account, then it's not simple at all. I've included some output in the post to try to show how it's useful in this way. Also, I thought this was interesting: https://twitter.com/parodyfuzzix/status/639682692620095488
[**@parodyfuzzix**](https://twitter.com/parodyfuzzix/) &gt; [2015-09-04 06:13 UTC](https://twitter.com/parodyfuzzix/status/639682692620095488) &gt; @wundercounter @genehack @novapatch Oh holy helmet, who would write their own functions for that?! &gt; &gt; People writing BASIC! ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Line 3 of your `TIESCALAR` sub. return unless $arr_ref eq ref []; I'm assuming you meant to type: return unless ref $arr_ref eq ref [];
FIRST and LAST are not conditionals, they are BLOCKS that run at a particular phase... Equivalent to BEGIN and END blocks, except in the context of a loop. What you want to do is not what these blocks were designed for. I am merely a casual observer of perl 6 at the moment - so there might be a better way - but one way of doing what you want would be to us the kv (key-value) method on the list to get each element index, and compare it to array.end... my @array = &lt;a b c d&gt;; for @array.kv -&gt; $i, $x { say "Common: $x"; if $i == @array.end { say "SPECIAL LAST: $x"; } else { say "NON LAST: $x"; } say "More common: $x"; }
Well, zip looks nice if `@A` is really that, an array with two letters; if it's a longer expression, `rotor` has the advantage of not having to repeat the array/expression. If you want the last element, you can use [roundrobin](http://doc.perl6.org/routine/roundrobin) instead of zip, which doesn't stop when the shortest sublist is exhausted.
Don't choose write only language. Perl is very ugly because of excessive used of symbols like $, %, @, ===&gt;, $_, many more confusing symbols and make your program unreadable.. I recommend Python Or Ruby Or Java
&gt; Well, zip looks nice if @A is really that, an array with two letters; True &gt; if it's a longer expression, rotor has the advantage of not having to repeat the array/expression. And *rotor* is the only "universal" solution. &gt;If you want the last element, you can use roundrobin instead of zip, which doesn't stop when the shortest sublist is exhausted. Yep, that is what I wrote in another reply. But this *rotor* thing is still un-intuitive and ugly, as it really fails to express what we look for in this case: - rotor: what? I don't want anything "rotating or rotative", I want "current and next element", or something related to "two elements" or "pairs", or some "sliding selection window", etc. - 2=&gt;-1: uhhhh? OK, "2" because I need 2 elements, perhaps, but "=&gt;-1" ??? - :partial: hey, I want my "full" array/list, not a "partial" one. I mean, when you first posted the *rotor* solution, I read the documentation and I got it, no problem; but it does not make it look better. So, to hide this ugliness, I could make a routine like this: sub curn(@list) { return @list.rotor(2=&gt;-1, :partial); } that could be used like this: for curn(@A) -&gt; ($cur, $next?) { if $next { say "$cur: $next"; } else { say "$cur"; } } or: for curn(@A) -&gt; ($cur, $notlast?) { if $nostlast { say "$cur is not last"; } else { say "$cur is last"; } } It doesn't look bad. It could be used with list literals and array variables, and could fill both of my original concerns: working with current and next elements, as well as detecting last element. Supposing I would like something even nicer, a *forn* looping construct: forn @A -&gt; ($cur, $notlast?) {...} forn &lt;a b c d e&gt; -&gt; ($cur, $next?) {...} Would that be possible to write? easy to write? With C-preprocessor style macros, it would be straightforward, but since these kind of macros are nowadays frown upon, is it (easily) doable with newschool macros or any other feature? 
It has its limits. It doesn't support +/- Infinity or NaN. It doesn't directly support binary data, leaving it to you to figure out an ad-hoc way of doing it (like base64 encoding). There's also no support for circular data structures. People also mistake it for a JavaScript subset. It's not (because it's specified to be UTF8, and JavaScript is either UCS-2 or UTF-16), but people still use `eval()` within JavaScript to parse it. Which also happens to be the reason why +/- Infinity and NaN can't be added. It's good enough as a cross-language serializer without the bullshit of XML and some other choices. If data is being passed between Perl processes, though, Sereal is really the way to go.
I mention many more serialisation schemes in &lt;http://stackoverflow.com/a/10684780&gt;.
I'm a big fan of JSON but its lack of a native date type really grinds my gears.
You have to type True or False rather than "True" and "False". You can also use 0 and 1 and even 0.0 safely as Rat reaches 0.0 every time they should. &gt; ?"False" True &gt; True.WHAT.say (Bool) You could do something incredibly evil and dumb if you really want. But no one is ever going to want to work on your code with you :P &gt; constant true = True; True &gt; true True
I didn't mean you should include the quotes... they're just there to make it clear...
You can use backticks for making that `True` and `False` vs `"True"` and `"False"`. 
All right, well, it should be clear to anyone that quotes are for terms, come on.
Why is that creepy bug staring at me.
but...ya know...why? I try to use the best language for the job at hand, while also balancing the statement "I'll be maintaining this 5 months from now" with "fuck, I have a deadline in 2 weeks." Learning a new language at this stage in my trade doesn't really have any benefits, and Perl is at that point where those who are using it don't give a fancy sh*ite about learning a new language. This isn't to say Python sucks or is bad. It isn't. It's a very solid language and I have great respect for it. But this is kind of preaching to the wrong crowd imo
That thing is a totally drugged out perv. Look at its pupils and the way it's staring at me.
Perl 6 is done? This is 6.0.0?
A presentation that takes place after the 6.0.0 official beta release. &lt;/hope&gt;
Yet I notice in your reddit posts you format programming terms differently from free text :P Why is that?
Where to start... First, it looks like you misundertood what ExParteVis wrote. He did not write anything about bits of Perl being inspired by other languages or not. "...where those who are using it...", he said. Then, please, spare us, the "I would not recruit you because you said this one sentence". I read this reaction so often on web forums, and each time I tell to myself "Gosh, I would not want to work with someone which makes so brutal and uninformed decision". It just makes no sense to judge like this. Your way of working may be different from his, and both be as efficient, or at least efficient enough for the expected results, which can be different. And there are so many domains, so many many different organisations types, so many different methods, so many different styles and habits to get a specific job done, that this kind of absolute declarations makes no sense. And about deadlines, please again, you should know that the delay comes sometimes indeed from oneself, from one's mistakes, but in many more cases comes from an unrealistic time estimation and from interaction/dependances from other people. And that is just logical: other people are more numerous than oneself, estimations are by nature randomly approximations and are often made on a commercial basis and not a technical basis. So, based on your misunderstanding, you went attacking this guy skills, competences and method gratuitously, with no knowledge of either of them, using a string of lousy HR commonplaces. I did not expect this behaviour from you, I must say (I would not have written this message if I were not so disappointed to read this kind of stuff under your name).
 Interesting. I'd given up hope on this to some extent. I wonder who's going to pick it up and start using it for reals.
How does the perl 5 - perl 6 interop work again? perl 6 has a more expressive type zoo.
[The GitHub repo](https://github.com/miquelruiz/snakes-for-camels) apparently isn't building the GitHub pages side as intended.
The simplest is use of [Inline::Perl5](https://github.com/niner/Inline-Perl5/) to: * Use Perl 5 modules including XS modules * Pass integers, strings, arrays, hashes, code references, file handles and objects back and forth between Perl 5 and Perl 6 * Call methods on Perl 5 objects from Perl 6 * Call methods on Perl 6 objects from Perl 5 * Subclass Perl 5 classes in Perl 6 For example: use DBI:from&lt;Perl5&gt;; my $dbh = DBI.connect('dbi:Pg:database=test'); my $products = $dbh.selectall_arrayref( 'select * from products', {Slice =&gt; {}} );
So is Perl6! ;-)
... which is the very reason for most people to stick with Perl5.
I'm not going to be using Perl 6. Ever. It's been 15 years in the making. That's about 1/3 of a lifetime career. That is way too long. The world has moved on. 
Spacebar is your friend.
So it makes sense to me that all the perl 5 types would have exact equivalents in perl6 land, but it also seems like attempting to bludgeon an arbitrary perl6 value into something perl 5 understands would be really difficult. The use case I'm curious about is using perl6 almost like XS, writing a low level library with explicit types (hopefully erased at runtime) that a typical perl 5 programmer who knows nothing about perl6 can use.
Ah. Let me ask some very different questions and see where that leads. Would you be willing to share what's at stake for you as a result of Py2 being "deprecated but current"? Is this about career investment, earnings, job satisfaction, sense of community, view of leadership, fun, technology choices, worries about the future? Any or all of these? Others? What matters to you so much you're "considering to leave Python"? I'm also curious if you recall which Perl versions you used and when/why you switched to Python.
I exclusively used Perl 5 and a bit of JavaScript and PHP for my first job, then I somehow focused on PHP completely and started to make money with it. Writing scripts in other languages was never a job choice for me, I just like to learn new things. (Although I guess that knowing more languages will highly increase my job chances anyway.) The occasional Perl here and there (a fun IRC bot in my spare time, a text parser for some of my colleagues at work) was never gone but I didn't invest much time into it. Some day I needed a website parser for the PHP tool I had been hired to develop. As I had read about Python's `urllib` just a short time before, I decided to implement that script in Python, not being aware of the actual difference between Python 2 and Python 3. Another hobby, I thought. When the script was nearly complete, I learned that Python 2 is about to be phased out *slooooowly* and Python 3 lacks a comparable community yet. I assume Python 4 will cause even more trouble, and it's not really worth all that. I have a couple of other projects in my "To do when there's some more spare time left" list, including a rework of the particular Python script and some web development things. I guess some will be in Common Lisp (learning languages by implementing things in them has always worked out for me), but I also *will* revive my Perl knowledge. I just don't want to learn that Perl will suffer from the Pythonversionitis too. *If* Perl 5 won't have the same "future" as Python 2, I'm happy to join the old Perl club again; otherwise, I (again) don't really know what to do. I don't want to rewrite my code every few years just because someone decides that the language I wrote it in is deprecated for no good reason now.
I'm somewhat interested in Perl 6, but it seems way too complicated. I just need a simple scripting language for small to medium sized programs. I looked at the [recent hands-on tutorial slides](http://jnthn.net/papers/2015-spw-perl6-course.pdf), and although the language looks somewhat stylish, the slides didn't even get to simple nested data structures (AoA, AoH, etc.) --- stuff that I'd need from day one. (And then there's weirdness like apostrophe's in variable names (slide 20) ... :| ) I plan to take another look at Perl 6 once there's a good tutorial available.
I noticed you [took this thread to perlmonks](http://www.perlmonks.org/?node_id=1141661) and concluded "Guess I'll start Perl'ing tomorrow again then. :-)". Welcome back. :)
Woohoo! Thanks __perly_bot for sharing, and thanks /u/plainblackguy for creating :) I've taken the liberty of sending bugs to our tech writer team to address the concerns about the documentation. In the future, anytime you have feedback, please use the "Send Feedback" feature of developer.google.com. We do actually read those. Really, we do, and we love your feedback. Thanks!
Yes. Larry Wall said he'd be happy if people just used it to parse log files. I use it pretty much every day to do something or other. Usually disparate database data aggregation or file parsing to create standardized formats. 
Dancer and use it for scripting various things. Very viable.
Well, that's part of it -- the other part of it is how do they compare to the number of job openings (or the pay or prestige or long-term prospects) of competitors? There are, I'm sure, VB6 jobs, but that wouldn't be my first recommendation to anyone who wanted to start a career in programming. I don't really know the answer to that question, though.
If you're starting from scratch, and you aren't already a perl wizard, I'd recommend python, ruby, or node.js. If perl is your thing, then it's a very capable language and there are *tons* of legacy systems in place that use it. I'd also recommend that you check out needed libraries for a system you might need... CPAN has a lot of stuff that just doesn't exist for other languages because of how long it has been around. The most important thing is that people should *not* try to re-write existing things as another language... I see that all the time, and it's always such a complete waste and creates so many new bugs. 
Mojolicious combines the best features of Ruby-on-Rails and Node.JS ... yes.
Yes. It may be hard to find pre-written code to do what you want, but it's still my tool of choice for many things. Most of my server scripts are Perl, and all of my Reddit scripts are. I've been waiting until I have more documentation to make an announcement (I want to document everything returned by the main functions and have some sample scripts), but [Reddit::Client](http://search.cpan.org/~earthtone/Reddit-Client/lib/Reddit/Client.pm) now has Oauth support and a lot of functionality.
I love Perl, and though I don't use it that much these days, it remains a language I have a huge soft spot for. But for people to act like it is on the same level, in the current job market, as python or Java is misguided.
I really beg to differ. All the new and cool toys are also available for Perl. There is a strong test-driven culture which keeps the quality of CPAN modules good. And there is CPAN itself... Perl performs well, has good support and a dedicated community. Labeling it as a legacy language is, at best, uninformed. 
There's a lot of complacency in the perl community, though - "strong test-driven culture" sounds good, but it's all too easy to claim that perl does tests well and leave it at that. At the time of writing cpantesters.org is down, I've yet to find a quickcheck equivalent for test case shrinking, many CPAN modules (including my own) have significant gaps in test coverage, documentation and features... in short, much room for improvement. I think I'd also disagree about the new and cool toys - can you provide some examples? Even simple network protocols (SPDY or HTTP2 for example) I had to write for myself, because there weren't any implementations around. There are some areas where enthusiastic developers have written modules - but there are a lot of gaps. I still use (and like) Perl a lot, but any time I start on even a simple Perl project I have to set aside a lot of extra time for implementing dependent components - something I wouldn't expect so much from a language with a larger, more active userbase. And you're not addressing the point of the decaying userbase: a room full of toys is a lonely place if there's no one around to play with them.
By new cool toys I am thinking of websockets, AMQs and stuff like Swagger - which are the toys I currently work with. Sure, every language has it's niche and there are tasks not suited for Perl. However I have built a solid carreer over the past couple of years with Perl, and have yet to come short at any challenge given. 
Websockets are a great example of complacency: yes, we have a few websocket implementations. The infrastructure on top of them is limited, at best. We lack modules for simple tasks such as rx-style observables. As a trivial example, take a container object in the Perl code - on change, element added or removed maybe, it should dynamically notify all relevant browser sessions. This is really basic functionality, easy enough to achieve with, say, Tangence over a websocket connection... yet last time I looked, we didn't have the modules for it on CPAN. Building blocks like this are essential for making even the simplest of webapps - for an example of this see http://todomvc.com/. If AMQ means things like AMQP then I had to write my own implementation (Net::Async::AMQP) because of the issues I ran into with the other ones - most of them based on librabbitmq-c, which really doesn't work well in async code (can't have two MQ connections with heartbeats, for example). It's worked better for my use-cases than the other options, but it still has its problems - spent over an hour fixing some connection handling today, and I bet there's other bugs that I just don't have the time to track down and add test cases (or fixes) for. Don't get me wrong, Perl itself works pretty well. Sure, there are cases where you need high performance or low memory usage where other languages start to look more attractive. That still leaves many, many projects where Perl itself makes sense. However, it's the building blocks that we lack - particularly in the async realm, I'm spending more time writing fundamentals such as streams/sources/sinks, async ORM, dependency resolution etc. than on applications themselves. I'd suggest it's also likely that the perl5 developer pool is going to shrink more rapidly as people start moving to perl6, which makes perl5 a less attractive investment.
 @AoH[0][0]{bar} == 2 @AoH[0][1]{baz} == 3 `{}` subscripts no longer quote strings automatically for you, so unless you meant to call subroutines `bar()` and `baz()` in the code above, you probably want `&lt;&gt;`: @AoH[0][0]&lt;bar&gt; == 2 @AoH[0][1]&lt;baz&gt; == 3
You should learn Perl 5, as Perl 6 isn't even released yet (still a few months to go). This will make it easier to learn Perl 6 later if you decide to. One recommended book for learning Perl 5 is [Modern Perl: 2014 Edition](http://modernperlbooks.com/books/modern_perl_2014/).
In this case, it really just needs to use the tag RSS. I submitted a pull request: https://github.com/dnmfarrell/Perly-Bot/pull/6
thanks :D or you could quote the strings
&gt; "So use LibXML instead." Is there actually any use case where XML::Simple is preferable to XML::LibXML ?
Perl 5 is Perl. (The /faIv/ is silent, so "Perl 5" is pronounced /pÉ™rl/). Perl 6 is a different language. (Although it hasn't happened yet, the "Perl" should be silent, so "Perl 6" should be pronounced /siks/.) As /u/mgvx says, you should learn Perl (5). It's a lot like learning English -- it's easy to learn enough to make yourself understood, but there are so many layers of nuance glommed on to the basic engine, that you can spend a lifetime getting really proficient at it. Most of what you learn will translate well to (Perl) 6 when it comes out.
Thanks, drzowie. This has encouraged me.
Terrific, enjoy! 
Not according to XML::Simple's author.
sure: perl -MJSON::MaybeXS -MXML::Simple -e'print encode_json(XMLin(shift))' somefile.xml &gt; somefile.json can be very handy for one-off conversions.
Perl 5 and Perl 6 (when its released) will co-exist for many years to come. There is a vast amount good quality Perl 5 documentation you would be better off starting now with 5 and transitioning along with the rest of us. The rest of us is an important point, plugging into the community is really worthwhile. See if there is a local [perlmongers](http://www.pm.org/) user group also sign up to [perl monks](http://www.perlmonks.org) See if you can get to a YAPC (Yet Another Perl Conference which is a low cost 3 day Perl meeting) or Perl Workshop (free one day Perl conference) https://www.perl.org/events.html Sign up to http://perlweekly.com/ to keep abreast of things Perl and for ongoing good stuff http://perlmaven.com/ 
You need to understand that a role file is almost the same as a class file (it just says `use Moose::Role` instead of `use Moose`), building on the same [module concept](https://metacpan.org/pod/distribution/perl/pod/perlmod.pod), and then the answers to your questions are quite straight-forward. &gt; Should the Role be defined as a separate package using module-starter? If you think package to mean module, then that's fine. If you realise you need another role file, you can also just create it manually. If you think package to mean dist, then that's not necessary. Normally such a code-sharing role file should be contained in the same dist along its consuming classes. &gt; When I do a with 'Foo' within a module that uses the Role, what are the search paths for the Role? Same as for any other Perl module (.pm) file, see `perldoc -f require` for the details. See `perldoc perlfaq8` how to change the include path. As usual, [it is good style and practice to have exactly one module name per file](https://metacpan.org/pod/Perl::Critic::Policy::Modules::ProhibitMultiplePackages). &gt; How can I modify these when developing and running 'make test'? `make test` automatically adds `blib` to the include path, you do not need to change it manually. &gt; How do I package this up properly? Define a dependency of the Role within the package that uses it? A class dependency (`use Foo::SomeClass`) is no different than a role dependency (`with 'Foo::SomeRole'`). Use the external dependency declaration mechanism that you are already used to, e.g. [editing the meta file section `prereqs`](https://metacpan.org/pod/CPAN::Meta::Spec#prereqs1). [Dependency information tools](http://neilb.org/reviews/dependencies.html#conclusion) like [Module::Extract::Use](https://metacpan.org/pod/Module::Extract::Use) can help you find undeclared dependencies. If you have *internal* dependencies (e.g. your dist is Foo-Bar containing main class Foo::Bar and role Foo::Bar::SomeRole), then you do not declare them. They get picked up automatically by your build tools as a [`provides`](https://metacpan.org/pod/CPAN::Meta::Spec#provides). After a build step or installation step these dependencies are already located a part of the include path. Again, here roles are no different than classes because they are both based on the module concept and the require mechanism for module loading.
Thanks. Don't have a Windows use case atm anyways.
https://www.youtube.com/watch?v=zmNInkzaYLc
I was able to make it work with the scripts below. However I am still not able to use the use strict; and use warning;. I cant figure it out. Below is my new scripts. I want to know how to edit to it to use the best practice. #!/usr/bin/perl # Title: Report_01.pl # Rev: 091501 #use strict; #use warnings; #Files open(FH, "LTE_091515") or die "datafile: $!\n"; open(OUT, "&gt;LTE_outfile.txt") or die "outfile: $!\n"; #Format format OUT_TOP = SITE SEVERITY DATE TIME ALARM . format OUT = @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;@&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; $Site, $Severity, $Date, $Time, $Alarm . while (&lt;FH&gt;) { ($Site,$Severity,$Date,$Time,$Alarm)=split(" "); write OUT; } close FH; close OUT; Input: ULA02290X2 Major 2015-09-15 15:18:28 FanFailure ULA02455A2 Major 2015-09-02 13:04:10 FanFailure ULA02840B2 Major 2015-09-15 10:19:01 EnclosureDoorOpen ULA33319B2 Minor 2015-09-13 13:24:01 Output: SITE SEVERITY DATE TIME ALARM ULA02290X2 Major 2015-09-15 15:18:28 FanFailure ULA02455A2 Major 2015-09-02 13:04:10 FanFailure ULA02840B2 Major 2015-09-15 10:19:01 EnclosureDoorOpen ULA33319B2 Minor 2015-09-13 13:24:01 
https://en.wikipedia.org/w/index.php?title=Fluent_interface&amp;oldid=681159313#Perl_6 for something that looks more like the traditional chaining concept of a fluent interface.
I dropped that version because the MOP hackery is really cool and powerful, but can scare newcomers. A simpler way would have been for me to just have wrapper methods: method set_name(NonEmptyString $name) { $!name = $name; return self; } The idea of having to write wrappers to do this really turned me off, but allows for the chaining concept. However, a fluent interface is about chaining primarily because that's how it's expressed in most traditional OO languages. The `given` example that I used is more naturally Perl 6 and is more or less a copy of the PHP version. However, it's not really "fluent" in the traditional sense because you're calling methods on the topic and can't easily utilize the return value of the previous method calls. I'm not entirely happy with that result.
There is a difference `[]` defines an `Array` and `()` creates a `List`. In a not too dissimilar way to Perl 5. So if you assign a list to an array variable `@array = (1,2,3)` you actually still end up with an Array anyway because of coercion.
Thank you very much for your reply. So that all makes sense, but I'm still not sure about distributions - it may be that I'm making assumptions that are incorrect. Lets say I have two modules which are two separate distributions: `Foo::Bar` and `Foo::Bee`. Both of these are using the role `Foo::Role`. You mention: &gt; If you think package to mean dist, then that's not necessary. Normally such a code-sharing role file should be contained in the same dist along its consuming classes. So you're talking an internal dependency here right? But if the role file needs to be part of both modules and thus both distributions, that means I'm either duplicating the role file, or I should hardlink the role file from one module to another? Can the role be a separate distribution, with the `Foo::Bar` and `Foo::Bee` modules/distributions referencing it? 
&gt; Can the role be a separate distribution Yes.
[This](https://metacpan.org/pod/Net::SSH::Perl#out-err-exit-ssh-cmd-cmd-stdin) looks like it could help you
Oh, *thank* you! This looks perfect.
Awesome. Assuming the functionality is similar, I think I'm going to end up preferring this to Net::OpenSSH since there's a package for it (and for Net::SSH2) in the default Ubuntu repos.
If you know what expect is, this one word answer is good. But if you know what expect is, then you probably don't need to ask the question in the first place. For those lost in the dark, [expect](https://en.wikipedia.org/wiki/Expect) is a TCL extension that made it easy to interact programmatically with with interactive shells. Perl has the [Expect](http://search.cpan.org/dist/Expect/lib/Expect.pm) module that does the same thing, and there are SSH modules that use it like [Net::SSH::Expect](http://search.cpan.org/dist/Net-SSH-Expect/lib/Net/SSH/Expect.pod).
Why would I want this instead of the native multiplexing/persistence as linked to by /u/ribasushi above?
You know what, the best part about this is it literally being a 30 second code fix for the existing 2,000 line application. Holy crap. You have made my day much less cranky.
This seems to have problems with windows cygwin/mintty/ssh. It's possible some settings are wrong, or I've got old versions of something. Or it's just a windows thing. What you get is errors like this: process_mux_new_session: tcgetattr: Inappropriate ioctl for device And newline doesn't work (CRLF both broken). Ctrl-D EOF is also broken. Reset fixes \n but doesn't fix ctrl-D. Anyway, otherwise it seems sweet :)
It will be API-wrapper rather than a GUI-Application and I guess I should pick one of the parameter checking modules in CPAN. 
Already accepted the answer above - native ssh multiplexing is what I was looking for.
I think that it isn't helped by the fact that the css limits the width to a width less than the one I used when I wrote it. Perhaps I should add a few more linebreaks to solve that one.
The multiplexing feature does not work on Windows. It is a known issue.
I'd say validate always, if at all possible. Never trust the user of your module to fully understand, always double check inputs, especially if releasing to a wide audience like CPAN.
This is why god invented classes and attributes and so many implementations of those in our CPAN eco system!
Thanks for the suggestions. I was planning to use Moo for classes. Do MooseX plugins work for Moo as well or could it be risky? Params::Validate seems like standalone module without Moose requisites but I am asking just for curiosity
If you're using Moo, then the first of those is preferred. Mostly, because MX:PV uses Moose type constraints, which require Moose. And loading Moose almost entirely negates the benefit of Moo.
Using a module just to check inputs is overkill and a half.
If you use Moo, add up Type::Tiny and you are happy, else you can totally work with the isa =&gt; sub {} function of Moo, in 90% of the cases this probably enough ;) but if you wanna go serious, Type::Tiny
Not really. It might be if you're very experienced and know how to write it in a pragmatic and lucid way for your usecase. But if you are in such a position, you are not asking this question. Hence, a well structured well respected toolkit for handling and validating inputs is strongly recommended as a stepping stone. I can argue that even using Moo is "overkill" for writing Object Oriented Classes in many cases, but you need a certain level of expertise to roll your own OO without it being ugly, and so an OO Framework like Moo gives you best practices for free.
`Mojo::Snoo::Subreddit object.` Reddit without a "For" prefix in use here, could be interpreted as a violation of license. Can't win. :p
This is a thoroughly solved problem: * http://p3rl.org/Dios * http://p3rl.org/Function::Parameters * http://p3rl.org/Kavorka * http://p3rl.org/Method::Signatures * http://p3rl.org/Method::Signatures::Simple * http://p3rl.org/MooseX::Method::Signatures * http://p3rl.org/perl5i#Subroutine-and-Method-Signatures * http://p3rl.org/perlsub#Signatures * http://p3rl.org/signatures * http://p3rl.org/Sub::Signatures I recommend **Kavorka**.
You should use the RFC 3834 header `Auto-Submitted: auto-generated` to prevent email loops.
Couldn't agree more.
&gt; Auto-Submitted Hmmmmm, that's a new one to me. Looks like a good idea though. 
But I have tab completion for perldoc Its part of the standard bash-completion suite. http://anonscm.debian.org/cgit/bash-completion/bash-completion.git/tree/completions/perl#n87 
&gt; In 19 years as a Perl programmer, I have neverâ€” not once!â€” needed to work with a date that couldnâ€™t be represented in epoch seconds. I know some people out there need that. Iâ€™m sure there are ... umm ... Perl-programming historians, I guess? Allow me to say that is a bit shortsighted. * There are people who were *born* before 1970, who are still alive and still have a job. So you don't feel the need to treat their birthday as a date? What if you want to format is in a certain way? Oops, you can't. * The time for 32bit epoch time is up around 2035, about 20 years away. That's about less than twice the age of some of these date modules. Built in obsolescence, nice. I can accept that you cannot deal with dates earlier than, say, 1600. The calendar was as regular in the period 1600 to 2000, as it will be for the 400 years after that. Skipping days on the calendar happened just a bit before that. 
Yup, perhaps I should've said better completion. I hate typing "Dist::Zilla::Plugin::" (or Dis(tab) Z(tab) or something like that) all the time, so I was finding ways to make completion of Perl modules more convenient in my day to day work with Perl. That's also why I wrote [App::DzilUtils](https://metacpan.org/pod/App::DzilUtils), [App::WeaverUtils](https://metacpan.org/pod/App::WeaverUtils), and so on. And, I want to write completion scripts in Perl, because writing them in bash is... less convenient to say the least ;)
For those that have trouble viewing the link, here's the regular link without the frame pointer: https://www.youtube.com/watch?v=5Vt8zqhHe_c Perl (Larry Wall) is mentioned starting from 4:44 till the next 1.5 minutes or so.
and [berrybrew](https://github.com/dnmfarrell/berrybrew) has been updated too
Sorry, "improper" was not the correct term. This link: https://www.youtube.com/v/5Vt8zqhHe_c?version=3&amp;start=282&amp;end=394&amp;autoplay=0 opens a Shockwave Flash download dialog for me (Firefox 40.0.3 on Linux, no Flash plugin installed). I thought others might see the same. Original comment edited.
64 bit is a nice transition path, for the future. Perhaps we can extend this to the past by using negative numbers for time before 1970. That way you can represent all (useful) times as (extended) epoch time, thereby getting have a nice backward compatibility with current practices. And probably half a billion years is still high enough as the limit. One shortcoming of epoch time is that it ignores leap seconds. Thus, the computed time can be off by a few seconds from what it should be. 
I'm curious; have you ever done and published a transcription? I have done so when I felt it appropriate (eg this [non Perl related non video transcription](http://julieamero.blogspot.com/)) but I think it's generally vastly more effort than is warranted. Youtube provides automatically generated transcripts for videos so you can always get a rough idea without actually watching the video. (Visit the video link, then click `... More` (listed after `+ Add to` and `&lt; Share`), and then `transcript`.) Fwiw, here's highlights from the 100 seconds or so's worth of the transcript that's directly about Larry: &gt; first person ever talk about ... culture ... in the context ... computers ... guy Larry &gt; a wonderful man &gt; I was ... visual artist ... hijacked into into programming &gt; I didn't really know what I was getting into &gt; when he was designing [perl he] actually thought ahead to what kind of culture he [wanted] ... what kinda people he wanted to be [perl] hackers &gt; the language was ugly [but] incredibly versatile and useful &gt; so what ended up happening is there is a community of people who are all holding their noses in using Perl because [it] got things done &gt; community was incredibly eclectic and diverse for computers &gt; it's no accident he's really religious guy in years trained as a missionary &gt; he wanted people to ... really exercise their minds and ... to be able to look at their own points [of] view from another direction and that's why he wanted to have this attractive to people &gt; it's perfectly OK to think about what kind of people you want in your world when you're designing something technical &gt; we're going to be living [together] ---- It only takes about 100 seconds to listen to the bit covered by this highlight; does a transcript/highlight really help in this instance more than the OP's "interesting view by an effective outsider (excerpt)" and perlancar's "Perl (Larry Wall) is mentioned starting from 4:44 till the next 1.5 minutes or so"?
I was on mobile, but I'm generally not going to watch a video of a talk or conference anyway.
(or are those fat commas just being used as commas and I'm thinking too hard?)
I don't even have speakers on the computer I am using right now, so a transcript is pretty much the only way I am going to get this content.
Looks like there's another part of the code where I've got a modInfo{Users}-&gt;{Snapshot}, though near as I can tell that is also keyed to the Users field. That said, I've got a modInfo{Net} and a modInfo{Proc}, so maybe that Actual level is more useful for other iterations of this piece of code and in this case it's just a little redundant. it's not really doing anything more complex than turning /etc/passwd into a hash. I'm needing to add things liker group and shadow, etc, to this data and I think the first time i implemented it I didn't enderstand how the data was being recorded, so I just overwrote the fields that it created with new data. It didn't break anything, but it didn't do what I wanted either. So I'm debating creating a new data structure or just making modInfo{Users} about 4 times longer and considering these systems are not huge, I'm leaning towards that. 
For me, the original link just plain doesn't work. I get a white screen.
compared to the ~2s it takes to read that quote - yes, I'd say it does. thanks for posting it.
No, epoch time doesn't *ignore* leap seconds. It *don't have* them. Epoch time is "seconds since 1970-01-01T00:00:00.00+00:00". A "leap" second is simply one of those particular sconds. If you convert from epoch time to the Gregorian calendar without accounting for leap seconds, you end up with [TAI](https://en.wikipedia.org/wiki/International_Atomic_Time), not UTC. If you store time as epoch and claim to convert to UTC, you really need to have some table like [this one from Rakudo](https://github.com/rakudo/rakudo/blob/nom/src/core/tai-utc.pm).
My best guess is that `Actual` may contain the "real" user id / group id of whatever `$grpflds[0]` contains. The fact that it's named `Actual` might just be showing how hard is it to name things... By "real" user id / group id, I mean the "real" one as opposed to the "effective" user id: https://en.wikipedia.org/wiki/User_identifier#Real_user_ID If that were the case, it may be better named "Real" ;)
I have been using this link format for years, without being aware it doesn't always work. Apologies for getting you a bizarre dialog window instead of the intended nice and to the point video snippet. Given I do not have a setup where this link doesn't work - would you be able to search/ask around, and figure out a way to coerce youtube to do what I tried (that is: show you a video-range, and stop the video there), in such a way that works for your setup as well? I will be very grateful and will switch to the new link format asap ;) Cheers
&gt; I have trouble taking anyone who says that perl was designed to be ugly Nowhere (backed by the part of the transcript you quoted) did the presenter say *designed to be ugly*. This is orthogonal to the language **being** ugly (which I personally believe it absolutely is, having spent over a decade working with it). In any case, while you were focused on that bit of the snippet, you happened to miss the entire point ;)
I've been particularly happy with Function::Parameters (in :strict mode) for quite a while now. It has a very clean syntax.
The transcript is missing a bit of verbal fluff that makes the speakers intentions a bit more clear. He says: &gt;"...When he was designing perl, he actually thought ahead to what kind of culture he wanted around it, what kind of people he wanted to be perl hackers. **He made a point, although the language was ugly by everybody's standards**, it was incredibly versatile and useful. So what ended up happening was there was a community of people who were all holding their noses and using perl because it got things done when their normal tools wouldn't..." The only ways to interpret that are that Wall made the language ugly intentionally or that the ugliness was a known and necessary consequence of the versatility (and thus intentionally ugly). I don't think either is true, but I guess beauty is in the eye of the beholder.
I think there are other ways to interpret that passage. Larry's own words may help. He touches on the issue of Perl 5 being "not pretty" in a couple spots in [a recent keynote](https://www.youtube.com/watch?v=RvCkvXvqi3U&amp;index=2&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK): for a couple minutes starting 6m 18s in and another couple minutes starting exactly 18m in.
Really funny to read that little summary while I'm heavily working on my slides for Perl Dancer 2015: Dancer, a brief history of code. :) https://www.perl.dance/talks/26-dancer%2C-a-brief-history-of-code Thanks for the spotlight on Dancer/Dancer2.
&gt; unusual OO conventions I sometimes feel like the only person who absolutely loves OO under perl. 
I don't hate it, but it is a common source of "ugly" complaints for perl. Most languages use the dot notation and stringing together a bunch of arrow operators looks a bit strange to many people.
Not really clear to me how a hash and comma-delimited data are related. Are you evaling the data directly or something? Otherwise it's just a string. Edit: if you're looking for a way to store a hash, you can't get any simpler than JSON. It'll take care of all your escaping or delimiting or what have you.
Well, yes, but field 3 is more like, "data1, data2, data3, data4" and that creates some trouble. The trick here is that I did not write this program,so I'm using what is already present. what I tried to do is something like setting @array[3] equal to $newscalar and then ran $newscalar =~ /s[, ]//g and then adding $newscalar into my hash instead of @array[3] but that did not work out. 
&gt; Well, it actualy caused a few problems. The commas, when looked at later, were read as individual fields in the reading array, so when I asked the program if the line had more than 4 fields, every field with those commas did. You may think that's what's happening, but I promise you it's not. Perl doesn't do anything like that at all. If I could see your code, maybe I could tell you what's actually happening.
&gt; why not collaborate with cperl author? Reini Urban (cperl author) and Will Braswell (rperl author) wrote most parts of [this blog post](http://blogs.perl.org/users/rurban/2014/01/bcc-and-rperl.html).
That wasn't my point, and not what I was trying to say. Consider this situation: You are doing a CPU intensive computation, and currently it's in pure Perl. You need to speed up this calculation, and there's not a CPAN module to do it for you (it could be internal to the company, proprietary, of just plain doesn't make sense for the general public), so you have a few options. * Write a library in C/C++ or other fast language for the algorithm and a module to interface with it (XS bindings). * Write a Module with the XS actually containing the C/C++ implemented algorithm as part of the module (no library, same speed as one though). * Write a Module that uses RPerl and write in near-perl syntax for 90% the speed of C. Continue to use regular Perl for the rest of your application. Let RPerl deal with the marshalling of data back and forth between the regular Perl interpreter and the RPerl portion. All approaches have their positive and negative aspects, but being able to drop to near-perl syntax to achieve near-C speed for specific, intensive portions of your application is a clear win IMO.
it's used as the default variable. perhaps this example will help my @array = (1,2,3,4,5); foreach ( @array ) { say $_; } is the same as my @array = (1,2,3,4,5); foreach my $item ( @array ) { say $item; } except the first is less clear, has some issues with scoping (think a loop inside a loop) and can be a little slower. however it's handy for things like this my @array = (1,2,3,4,5); my @new_array = map { $_ * 2 } @array; #@new_array == ( 2, 4, 6, 8, 10 ); see here for more info. http://perldoc.perl.org/perlvar.html#General-Variables unless is a negative if, so my $test = 1; if ( !$test ) { #something } is the same as my $test = 1; unless ( $test ) { #something } personally i avoid it, as it hurts my brain when people write things like unless ( !$test ) {} which is really if ( $test ) {}
unless? yeah, it's mostly handy for trailing ifs, do_something( $somevar ) unless ( $somevar ); which is the same as do_something( $somevar ) if ( !$somevar );
I assume this is a Windows laptop. To install Perl on Windows download the 32 bit or 64 bit version from [Strawberry Perl](http://strawberryperl.com/) and double click on the downloaded file. It will add an entry for Perl to the Start Menu. 
Did you see the [install page](http://pdl.perl.org/?page=install)? If you click on easiest -&gt; mac osx, it sends you to a package to install.
I tried following some of the instructions they had but came unstuck when it came to editing the config file and installing the dependencies. I'm really wondering whether there is a faster way to do this because I'm worried that I will make errors if I try to do too much manuallly
Have you tried Googling?
using CPAN you should not have to edit anything, and the dependencies should install automatically. Assuming your on a recent enough version. So what version of perl (perl -v)? what config file are you editing? what error are you getting in CPAN? 
Mac Provides a version of Perl as part of the system software, but it's generally not a good idea to use it for your own software. For one thing, you shouldn't upgrade to a newer version, because that could possibly break operating system functionality. Best to install your own version, elsewhere. Perlbrew is a program that makes it easy to install multiple versions of Perl and its libraries. Not so important if you're exploring for your own pleasure, but if you need to support software you've released, you may need to run a program with a newer version of perl, or an older one. Instructions on how to install at [Perlbrew.pl](http://perlbrew.pl); there are links to some software at the bottom of the page, including [Perlbrew and Friends](http://perlbrew.pl/Perlbrew-and-Friends.html). That shows how to install _cpanm_, a convenient program for installing CPAN packages. Type "cpanm -h" into a terminal window for a vrief review of using cpanm; "perldoc cpanm" for more detailed information. "cpanm PDL" to download and install a library. I'm an experienced Perl programmer, and I've attempted to install PDL. It didn't work for me, and I decided I wasn't that interested. Good luck.
thanks for the tip. I've got Homebrew so I'll have a look at getting Perlbrew to help me along. Managed to get PDL in the end through CPAN.
For packages wrapping native libraries there might be some need for this, but thats more at the level of CPAN. But for the core stuff you get with Perl 6 the Rakudo Star .msi (http://rakudo.org/downloads/star/rakudo-star-2015.06-x86_64%20(JIT).msi) works just fine. Anything core works on Windows and some of the most active compiler hackers for Perl 6 are on Windows as their primary OS. Rakudo Star is a bit like Strawberry Perl in that its the compiler and core modules bundled with some non core things which are good to have by default. So essentially there is a need for that, but it already exists.
Or you could do what everyone else has suggested and use [Text::CSV](https://metacpan.org/pod/Text::CSV). Have you tried it? It solves the **exact problem you're trying to solve.**
I mean shit dude, it says mac in the title. 
Perl is heavily influenced by natural languages. A scripts is mostly a set of expressions. If you'd tell them in English, you'd come up with something like this: â€œTake my **car**. Drive to the gas station. Fill the tank (here's some money by the way). Go to the grocery store and bring some milk.â€ As you might have recognized two of the three sentences indirectly reference the car. This is where `$_` comes into play. `$_` is the variable you don't have to mention (most of the time). Many functions in perl take a default argument: `$_`. Take this piece of code: while(&lt;&gt;){ chomp; if(s/(?&lt;=my name is)(.*)/pat_pat_pat/){ print "hello $1, "; say } else { say "who are you? I didn't understand you" } break if /bye|see you|have a good time/ } (probably terrible in production code) In this fragment, almost all lines, except the `print` line interact with `$_`. The `&lt;&gt;` operator assigns to `$_` in a `áºhile` condition. `chomp` and `say` take it as a default argument, if none is given. The match operators `s` and `m`(not explicitly mentioned, but in the last line with code, it is used) match/replace `$_`. It's just a shorthand. That's the positive side. The negative is, that it is a global variable that gets localized, not lexicalized. Thus you'll have to be careful when using it, because it could be, that it gets overwritten by some library function or yourself if you aren't careful. As all in perl, i tend to recommend to read the docs on it, and then consider if you use it or not. `unless` is just syntactic sugar for `if not`.
yeah that was the issue - I hadn't used sudo so it came up with a bunch of errors when I tried to install. I thought it would be something simple.
Great post Gabor. I must start using this in my code more often. As usual, you have posted something useful in a very clear way. 
From [the 'Modules' section of docs.perl6.org](http://docs.perl6.org/language/modules): &gt; Module files generally use the standard .pm extension, and scripts or executables use .pl. However, if you wish to highlight that the file is written in Perl 6 you can use the .pm6 extension for modules, and the .p6 extension for scripts. Test files still use the normal .t extension.
still opaque because of "generally", "you can use" but thanks.
if you are mixing perl5 and perl6 in one location you may want to differentiate with the "6" suffix. btw perl5 is still the de facto "perl" in 99% of people's eyes.
ok but perl 6 will be released next month.
not necessarily, while it's probably becoming more and more so that way, not all libraries have been ported yet to 3. so you have a broader selection of libraries to use in the old version. and those libraries have more history, more maintenance, less bugs, etc... tbh I haven't looked at 3 in a while, but in general, these are the reasons not to pick the latest greatest. edit: but, if you are starting a software project, and you've decided upon all the libraries you want to use, and they are all available in the most modern version, then by all means, go for it :) you'll be the cutting edge, supporting the great work that's been done for the latest version and probably get a lot of optimizations and improvements within the language as well as new language features. so there are plenty of reasons to go with the major version, as well.
In my experience, Perl5 and Perl6 are nowadays considered two members of the same language family ("Perl"), rather than Perl6 'obsoleting' Perl5. Perl5 is still under very active development - including taking some ideas from Perl6 - and the size of the Perl5 ecosystem dwarfs that of Perl6. Perl5 isn't going away anytime soon.
It's always more fun to help the less experienced perlist start from the ground up. Stripping the commas or other special characters when building the hash and reassembling based on a regex for long numbers seems like a helpful exercise.
Perl 6 is an entirely different language. Personally I'm not currently planning to adopt it because several things about it rubbed me the wrong way right off the bat. That could of course change. 
That's because extensions are arbitrary. On a *NIX system the parser for the file is being chosen either by the shebang line or by invoking Perl directly (`perl script.pl`). On Windows it's whatever the file association is (Strawberry Perl uses .pl, or you can set one manually) or again by invoking from the command line. If your system was using the extension only to decide, and you had both Perl 5 and 6 programs, then I'd obviously use the .p6 extension.
I think we'll need more context to give you a useful answer, what's the problem you're trying to solve here?
Im trying to get a simple alert to display when a certain item drops in a game.
Could you post (just) enough code to actually reproduce this? Like, a standalone Perl script that I can copy/paste into a text editor, run locally, and see the problem. The code you've posted is incomplete - the fmtswitch subroutine refers to $docstatus, but I have no idea what that is. Looks like a global variable that you haven't mentioned?
Yeah, I'll do it in a few hours since I think it's not trivial (but it might be). /u/vidude's interpretation is correct, %docstatus has the structure he used, and is indeed a global (our) as you suspected. Thanks to both! I'll update. 
**1** In cases like this, it's almost _always_ a case of your input not being what you think it is. Start dumping stuff at various stages of processing to the console with things like `warn` so you can see what's happening. **2** Stop trying to make complicated formats yourself. There are a hundred different modules for generating marked-up content, use one of them. There are [several modules on cpan](https://metacpan.org/search?q=RTF) that deal with RTF. I'd suggest, depending on your use case, RTF::Writer or the [SAX parser for XML::SAX](https://metacpan.org/pod/distribution/XML-SAX-RTF/RTF.pm) that handles RTF. Alternatively, if you're attempting to format the same message different ways, look at using a template language and modules like [Template Toolkit](https://metacpan.org/pod/Template) and just switch from "html" to "rtf" templates as-needed. 
That looks liek CSV to me. So treat it like CSV. Using the parser built into Text::CSV or, better still, Text::CSV::XS, is going to fix your problem, and it will be as fast as using only perl keywords . Do *not* use a simple `split /,/` . If you refuse to install a module, like my spidersense is telling me, at least use my @fields = grep defined, /\s*(?:"(.*?)"|([^",]+)|(?=,|$))(?:,\s*)?/g; If by any chance field 3 is without quotes, and you *know* you'll only get 3 fields and all the rest should go into the 3rd field, use `split` with a LIMIT parameter, like $data ='field 1, field 2, data 1, data 2, data 3'; @fields = split /, */, $data, 3; You'll get this for @data (shown as JSON): ['field 1', 'field 2', 'data 1, data2, data 3'] 
Thank you! I'm at point 1 right now. Everything seems to be OK with the spaces when they enter the regex. As to point 2, this is a utility I had coded years ago and I'm revamping now, so I guess it's easier to fix it than ditch it and start again using a proper module. Especially because only RTF is misbehaving. 
You're evaluating `/.../g` in scalar context, so it stops after the first match. For this trick to work you need to evaluate *all* matches, and then filter the results of that to consider only the ones where `$1` is non-empty. Look at the Perl sample code from the article: while ($subject =~ m/$regex/g) { print $1 . "\n"; if (defined $1) {push(@group1Caps,$1); } } The array `@group1Caps` then contains the data to be acted upon. 
So regex in a while loop condition is evaluated in a list context? Can you expand a bit on how the while loop knows to discard part of the string and start matching at some later point on the next iterations? Thanks.
That's pretty cool. I need to read up on how regex works in a list context. Thanks. 
No, it's still in scalar context here, but it's being evaluated repeatedly. To quote [`perldoc perlop`](http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators): &gt; In scalar context, each execution of `m//g` finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the `pos()` function; see `pos`. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the /c modifier (for example, m//gc). Modifying the target string also resets the search position. When using `/g`, the regex engine keeps track of where the last match ended, and begins searching there next time you evaluate a regex against that string. When a match fails, `/.../g` evaluates to false which ends the loop (and also resets the position, but that's irrelevant here since the loop has ended.) You could also use list context, but then you'd need to filter the resulting list to remove `undef`s, so you might as well combine both into a single loop. (You could get fancy and use something like `map` to do the filtering.)
I thought the greatest regex trick ever was `s/old macdonald/had a farm/eieio`
I haven't ever noticed garbage collection running under MoarVM. Other than Inline::Perl5 there is also 'v5' which is a bit like the ponie project in that it's a Perl 6 grammar implementation of a Perl 5 parser but targeting NQP rather than Parrot directly https://github.com/rakudo-p5/v5/ But that wont support XS so you are always going to need something more like Inline::Perl5. mod_perl is a really specific use case, not everyone uses Apache and mod_perl. Anyone on one of the more modern perl web frameworks under PSGI/Plack wouldn't have such a hard time since there are modules for that in the Perl 6 ecosystem.
The general feeling from the #perl6 dev chat room when this topic comes up is you should try and always put .pm6 .pl6 or even .p6. If you put .pm or .pl you ***must*** put a `use v6;` at the top of your code.
Perl 6 is being released for Xmas the beta period for that leading up to Xmas will be completely bog standard Rakudo Star releases, that have been happening for years now. The main one post lots of big language changes was [released just now](http://rakudo.org/2015/09/25/announce-rakudo-star-release-2015-09/) for Larry Wall's birthday.
&gt; Garbage collection was terrible back on parrot. When it triggered, the program basically stopped for seconds. Ah. From http://irclog.perlgeek.de/moarvm/2015-09-10#i_11196265: * 3.x ms average GC pause for `for lines('file'.IO) { }` * 6-7ms is common in apps that are retaining more stuff
what's the difference between .pl6 and .p6?
Thanks for the link. The original link didn't work on my phone and caused it to download and save a file. Your link works.
It's in Brazilian Portuguese, but the code is in Perl 6 and easy to follow.
http://patshaughnessy.net/assets/2015/9/25/perl5.png that is terrible perl. why not do the extra 4 lines and add a new method, so it would compare better to the go version?
I've just added a comment saying that. And, really, anyone talking about OO Perl in 2015 and not mentioning Moose is just embarrassing themselves :-)
&gt; open(my $FH, $ARGV[0]) or die("A horrible death: $!"); Please use the [three-argument open](http://modernperlbooks.com/mt/2010/04/three-arg-open-migrating-to-modern-perl.html), particularly in examples for new people seeking advice on writing better code.
You would be correct, /editted.
you can write your sub like $mysub={ my @params=@_; return "foo"}; you can then eval it.
`man strace` :)
Sorry, I just made up an example and forgot the sigils. It's not real code. :)
I've read that book. It's really cool and eye-opening. This is the inverse of what I need, however. The equivalent in my case would be a hash mapping functions to strings, instead of this. But in that case, I could just map functions to functions. I'm thinking of using strings to dynamically generate the names of the functions and avoid all this manual work. 
This sounds like it would work. I'm confused about @params, though. Will that be visible to foo? For example: sub bar { my $foo= sub { my @params= @_; return "foo" }; eval $foo; } bar( $scalarpar, \@arraypar, \%hashpar ); Would this work? Where do I use @params? 
You can use the `e` modifier to increment a counter variable and put it into the replacement. user@host $ cat input &lt;record alias="test"&gt;Sample text&lt;/record&gt; &lt;record alias="test"&gt;Sample text&lt;/record&gt; &lt;record alias="test"&gt;Sample text&lt;/record&gt; user@host $ perl -pe 's/(&lt;record alias="[^"]+"&gt;)/"$1(" . ++$i . ") "/ge' input &lt;record alias="test"&gt;(1) Sample text&lt;/record&gt; &lt;record alias="test"&gt;(2) Sample text&lt;/record&gt; &lt;record alias="test"&gt;(3) Sample text&lt;/record&gt;
I have edited the post because I noticed the behaviour is weirder than I thought. Please see the edit, /u/komtiedanhe /u/commandlineluser /u/dominix-pf. And thanks. :)
I appreciate the earnestness he put into his writing, but I disagree with pretty much the whole article. &gt; Choose the programming language that has keywords and syntax that allow you to express your ideas in a natural, straightforward manner. That seems like not a great way to choose a programming language, unless you are using it to teach with. 
Try something more like this: my $a = "We are the knights that say NI!"; my @b = ("NI!", "NI!", "NI!"); my %c = (shrubbery =&gt; 1, duck =&gt; "floats"); sub bar { my ($x, $y, $z) = @_; my $foo = sub { my @params = @_; print "Params: @params\n"; return "foo" }; $foo-&gt;(@{$y}); } bar($a, \@b, \%c); 
`use feature 'foo'` modifies the way the parser/interpreter works on a per-file basis. Add that line to PARAMREQUIRE.PL before `sub tell()` and you'll probably end up with the behavior you want. If Perl didn't work like this, then you could modify the behavior of the parser in modules that you use()'d, and vice versa... and that would make it difficult for module authors to predict how their module would be parsed. Also: the parameters ARE passed, in the automatic array `@_`, in both subs. when use `use feature 'signatures';`, you create copies with the names given (`$a`, `$b`, etc), as if you had done: `my ($a, $b) = @_;`. You can add this to each sub to prove this: use Data::Dumper; print Dumper(\@_);
Ah, you learn something new every day. I was looking in the docs, googling, etc. and couldn't find why this didn't work. Thank you so much! I got so happy when signatures came out that I totally forgot they aren't a stable part of the language yet. And I definitely didn't know about the file scope for `use feature`. So I was convinced my bug was in the string conversion instead of here. Thanks again!
Have you tried putting the path to a file? One of the examples in the POD is this: $client-&gt;PUT('/dir/file.xml' [...]
Put your json.gz file into $body. The function does not expect a hash there, PUT ($url, [$body_content, %$headers] ) so use $body instead of {$body}. 
There is no such function; the `LWP` module uses an object-oriented interface. Are you perhaps thinking of [`LWP::Simple`](https://metacpan.org/pod/LWP::Simple)? The documentation is very clear. Which parts do you need help with? 
This function apparently sends get requests to urls. I have no idea what get requests are.
Perhaps a link like this - http://perlmaven.com/the-diamond-operator - would be better than posting to pirated copies of out of date books.
Allowing dashes in names in an infix language with a "-" operator seems pretty dumb. Any guesses what the current version does with "a-b", "a- b", "a -b", "a.b-c.d", and "a-3" depending upon which subroutines are defined?
"get" is what gives you a webpage from a webserver when you went to reddit, your browser sent the reddit server a "get" request!
It's not dependent on which subroutines are defined, but it is whitespace sensitive.
"new" constructors need to be written in a way to observe the caller's actual class (which works with subclassing), but they can also hard-code which class they create objects with. Compare: package MyClass; # Considerate of subclassing sub new { my $class = shift; return bless {}, $class; } # Doesn't give a shit sub new { my $class = shift; return bless {}, MyClass; } Glib looks like it's an XS module wrapper around a C library, and it might hard code the class. You could probably just try to re-bless (call bless again on the object that was constructed) the object into your actual subclass. Not sure exactly how that would work with Moo, but probably in the BUILD method. You could also skip inheritance and use delegation instead. Create an attribute to hold the original Window object, and then delegate *all* methods to it, except your own in the subclass. In Moose (not Moo), you can do this with a regex: https://metacpan.org/pod/Moose#handles-ARRAY-HASH-REGEXP-ROLE-ROLETYPE-DUCKTYPE-CODE Not sure how to do that nicely with Moo. 
I was able to figure it out /u/Roknor was correct but adding the file path works as well
Thank you
&gt; COBOL allows dashes in indentifiers I believe COBOL identifiers couldn't start or end with hyphens and I'm pretty sure that symbolic math operators required spaces around them. I won't guarantee this holds true for any version of COBOL released in this millennium however.
You need to learn more about how the web works in order to understand what it is doing. But here is a basic point. When you type a URL into your browser, or 90% of the time when you click a link in your browser, the browser (or "user agent") sends a GET request to the web server specified in that link. On the other hand, when you fill out a form and click submit, probably 90% of the time your browser sends a POST request to the website referenced in the form. The difference between the two, aside from the fact that one literally starts with the word "GET" and the other starts with "POST", is basically where we expect the parameters to go. HTTP requests have a command-line, a list of Header: Value lines, and optionally a blank line followed by a message body. GET requests usually have no message body, so all parameters have to be in the path string in the command-line: GET /test.jsp?foo=bar&amp;baz=quux HTTP/1.1 Some-Header: Some value A Post request is going to use that same encoded a=b&amp;c=d, but it's going to put it below the headers like this: POST /test.jsp HTTP/1.1 Content-Length: 16 foo=bar&amp;baz=quux The URL is limited to maybe a thousand characters max, but POST bodies can be huge, this lets you upload files that are way more than 1kb in size.
Can you give me an example of how you accomplished this.
Additionally, I highly recommend to make clear what operation failed: open my $fh, '&lt;', $filename or die "Can't open '$filename' for reading: $!"; in this case add 'for reading'. Also, I recommend to check the return value of close, especially when writing: close $fh or die "Can't close '$filename' after writing: $!"; Ages ago I got bitten by this, disk full, and no check on the print nor the close.
How do you execute get requests in vb.net
Well my first question would be "why don't you know the difference between 'reins' and 'reigns'?". But more seriously ... do you think the wackiness of your picture and description text are going to help you or hinder you? Did you consider a more conservative approach?
&gt; which pastures are greener exactly Look at job postings and see what salaries come up.
I spot a ÐšÐ¾Ð½Ð³Ñ€ÐµÑÐµÐ½ Ñ†ÐµÐ½Ñ‚ÑŠÑ€.
I hear from recruiters about Java jobs daily and about a Perl job approximately once a year (granted, most of the jobs want things I don't have experience with and are on the other side of the country or other things). Entry level Java jobs pay more than the senior Perl ones, from what I've seen. But that's pretty moot because I'm essentially unemployable. It's not an insult to Perl to say that other things are fashionable right now. Don't shoot the messenger. "What motivates you to continue to work on Perl given the popularity of other things?" is a valid question.
If we find the garden of Eden again, will there be Unicorns there? Can we ride them? Is there porn in heaven? What's your favorite brand of sneaker? Who would you most like to see Larry Wall put in a headlock? What do you most regret about youth league sports that isn't testicle related? Why should DBIx::Class be funded instead of, say, Maypole? Have you been drinking with Simon Cozens (I haven't, but he seems like a real stand up dude and he's a great writer)? Do you think that if Larry Wall still worked at NASA, we'd have colonies on the planet Pluto instead of Perl 6? Or do you think we'd have both? Have you talked to Mark Keating and the other TPF cheerpeople about PR tie-ins? Have you considered doing screencasts of you working (I suggested on Twitter my doing it but no one was interested but I think I'm a lonely hacker sometimes)? "To top it off my sense of responsibility to the end-user is not shared within the active core of the â€œPerl5 toolchain gangâ€." -- yeah, agreed; attitudes towards users need to change in the Perl camp or we'll be obsolete. Did you know that grape skins are toxic to dogs? Have you applied for TPF grants even though they're much smaller amounts (word on the street is that really good projects are always in demand there!)? Do you see TPF growing and sponsoring more and larger projects, and companies using that as their primary Perl investment instrument? If you were a mixture of two breeds of dog, what would they be? What's your favorite card game? Do you think it would be fun to play human Backgammon, sort of like kings allegedly played chess with real humans dressed up on a giant checkboard, ordering them to move around? Wouldn't that be a power trip? Have you ever played Battlechess on the Amiga or Archon on anything? Wouldn't that be even cooler if you could order your human Backgammon minions to fight each other? What's your favorite video game console system? Do you like PAL or NTSC better? If you could invade Japan with only one type of miniature animal, what would it be? Do you think Linus Torvalds is ugly? What would be a fun thing to replicate Benjamin Franklin's famous (and likely fictitious) electrical experiment with instead of a key, where he flew a key in a jar up on a kite in an electrical storm and got it struck by lightning? Who would you cast in the role of yourself on a Broadway play? Have you ever licked a toad to get high? What's one thing you and the Pope have in common? The former Pope, who looked and acted like the emperor from classic Star Wars? If you were a Lego figurine, how many legs would you have? tico or edlin? Since Marvel vs Capcom is now a thing and happened, do you agree it would be awesome to have Marvel vs Capcom vs Pokemon? As president of the planet Pluto, what would your economic policy be? How has a cleaning product disappointed you? Do you think Pan is sexy?
Could you help him with a draft of a revised campaign blurb? I would, but I'm behind on work and a funded project (not getting rich ignoring the projects btw).
&gt; But that's pretty moot because I'm essentially unemployable. Just curious why you'd say that... what makes you so unemployable?
There is a **massive** amount of greener pastures in terms of green, arguing about that part is silly ;)
&gt; when one (re)watches the Curiosity rover landing, and sees this guy - one automatically knows this is the real deal, wacky or not What's wacky about that guy? He's dressed normally and expressing strong emotion. You on the other hand are wearing devil horns and making a strange face.
&gt; What's wacky about that guy? I think I have overestimated the prominence of this particular meme, apologies. Here is [the same person from a different angle](http://www.businessinsider.com/nasas-mohawk-guy-bobak-ferdowsi-facts-2013-2). And [here is a bit more about the "mohawk story"](https://en.wikipedia.org/wiki/Bobak_Ferdowsi#Media_appearances_and_NASA_advocacy)
Hi there Scott! Thank you for the formidable list of questions, really appreciate the... thoroughness. However - please **do not** do this again ;) I am short on time today, so I will answer you in two parts. The simpler (and more practical) answers will go below, the rest - in another post tomorrow, since I need to do some research ;) &gt; Have you talked to Mark Keating and the other TPF cheerpeople about PR tie-ins? No I have not. This campaign is entirely "solo". Given my main target audience are my own larger users, it didn't seem practical nor fair to involve the TPF into this effort. Now, if the campaign does go **over $150,000** - then (as spelled in the campaign) **yes**: I will definitely be getting in touch with all nonprofits we have, in order to forge a solid plan on how to put any such funds to good use. &gt; Why should DBIx::Class be funded instead of, say, Maypole? I am not looking to fund the development of DBIx::Class specifically, I am looking to **fund myself**, in order to continue working on all the large and small projects I have been working on until now. DBIx::Class gets a mention by representing the single largest manifestation of value I've added to the ecosystem to date. It also doubles as the foundation on which quite a few very successful companies have been built, including at least one (that I know of) within Y-Combinator, and as such is a good conversation starter". So... I do not have a view whether one project itself needs to be funded as opposed to some other project. In general it is the people (or in this case person) behind a project that make it happen and move along. So the question then becomes: is there a huge install base of Maypole-based software? Is there a dedicated group of people keeping it fresh and adding new ideas to it? Then yes - the install base and the maintainers need to have a conversation just like the one I am trying to start. &gt; Do you see TPF growing and sponsoring more and larger projects, and companies using that as their primary Perl investment instrument? The answer to this question is sad, but it is what it is: I believe the TPF has no chance in hell succeeding in such a role, given the current gridlock within the various committees and the general lack of direction. &gt; Have you applied for TPF grants even though they're much smaller amounts (word on the street is that really good projects are always in demand there!)? I considered this multiple times, but in each instance realized I have no project to submit that is both standalone and smaller than ~2 months of dedicated work. At which point the cost/benefit ratio becomes... suboptimal. Additionally I felt it would be inappropriate for someone of "my caliber" to tie up the already meager grant committee funds, when I potentially (campaign will tell) have enough recognition to fund my time both more effectively and by more invested actors. &gt; Have you considered doing screencasts of you working (I suggested on Twitter my doing it but no one was interested but I think I'm a lonely hacker sometimes)? Well, **yes!** In fact I have been working on and off on a system to make this possible *without* post-editing editing. Just several days ago the [last piece fell in place](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=794327#36), so yes, I am looking forward to stard doing that on a regular basis. [Stay tuned!](https://vimeo.com/album/3203706) &gt; &gt; To top it off my sense of responsibility to the end-user is not shared within the active core of the â€œPerl5 toolchain gangâ€. &gt; yeah, agreed; attitudes towards users need to change in the Perl camp or we'll be obsolete. Thanks! If you appreciate this brand of kool-aid you may also be interested in reading my [more specific ramblings](https://gist.github.com/ribasushi/74ce356123ede727e90f) on the subject. &gt; tico or edlin? Not familiar with `tico`, perhaps you meant `TECO`? In either case never used either. I started with [PE2](http://texteditors.org/cgi-bin/wiki.pl?PE2), but quickly wised up and moved to the built-in editor of [Norton Commander](https://en.wikipedia.org/wiki/Norton_Commander#/media/File:Norton_Commander_5.51.png).I actually often miss the vertical selection feature of PE2, moving around arbitrary rectangles of text was the shit, but oh well. And... that's it - to this day I do almost all of my editing and file work exclusively within [Midnight Commander](https://en.wikipedia.org/wiki/Midnight_Commander), as anyone who has seen me hack can attest. And yes, I am using the ridiculous default blue theme, though I will likely change this (the color) before starting recording screencasts regularly. &gt; Have you been drinking with Simon Cozens (I haven't, but he seems like a real stand up dude and he's a great writer)? I've met him only once. We shared a dinner table at FOSDEM 2015, with a bunch of other perlers. Sadly I was dead-tiread and didn't get to interact with him (or with anyone else) much that day. But technically yes - I have been drinking with Simon Cozens ;) &gt; Who would you most like to see Larry Wall put in a headlock? I have made a truly marvellous list of such individuals, which the margin of this comment box is too narrow to contain. 
Thank you for your thoughtful reply. Ah, TECO, sorry. No reply is necessary to most of those questions (though if you feel like talking about anything else, by all means!). I've used Midnight Commander before, during my brief PC stint. I had a bit of a vagrant phase where I was using institution PCs after that and mostly edited code in a tiny WordStar clone. Living off of a floppy disk or two is a hard life. &gt; The answer to this question is sad, but it is what it is: I believe the TPF has no chance in hell succeeding in such a role, given the current gridlock within the various committees and the general lack of direction. You probably know the committees better than I do. I have high regard for the people in TPF but I've also seen first hand how non-profits can stymie efforts. &gt; inappropriate for someone of "my caliber" to tie up the already meager grant committee funds Having talked to them previously, I was told that they want to fund a variety of projects (high caliber people and new people; interesting experimental things and established important things; etc). This could partially fund you. Putting in a grant application could be worth the conversation that it kicks off. Doing this, you're going to be talking to a lot of people anyway. Corporate decision makers like sit-down meetings primarily and phone discussions secondarily. &gt; Stay tuned! Looking forward to it! Thanks for making time for my inane questions. Please feel free to chat me up as the mood strikes. Good luck!
Catch me at a YAPC or on IRC for more backstory, but the obvious and maybe less interesting bit is a pattern of lack of full time employment. My plan is to finish the degree I started in the late 90's (lack of degree is no doubt part of the problem, too).
&gt; New Perl projects at companies are almost non-existent; everything is legacy. I keep hearing this, and yet I've been doing nothing but building new systems in Perl for the past 5 to 10 years. I'm sure new Perl projects are a minority compared to other languages, but there's definitely still people out there using it for new things. &gt; The main way to get any language introduced somewhere is to create things written in it, for real, actual end users. I completely agree with this sentiment. If people are going to start getting excited about Perl projects, we need to start making more visibility interesting projects in Perl. I guess to go along with that, we probably need to be a bit more vocal about how we market such efforts as well. I think one of the problems with a community of "hackers" is that we tend to focus a lot less on the frontend and other visible aesthetics (whether that's design, frontend UI, marketing, etc.) and a lot more on powerful backend functionality.
You didn't escape either of the slashes.
`s` takes any delimiter, so you could: perl -pi -e 's,&lt;integer&gt;5&lt;/integer&gt;,&lt;integer&gt;1&lt;/integer&gt;,' FILE perl -pi -e 's{&lt;integer&gt;5&lt;/integer&gt;}{&lt;integer&gt;1&lt;/integer&gt;}' FILE etc. http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators (edit) the idea is: if you change the delimiter, you won't have to escape the `/`, thus aiding readability
Wow...yup, that was it...thank you...
Thanks, that's something I'll keep in mind.
Not *any* delimiter! But yes, this is the best answer.
I'm just about 200cm
add a flag variable: perl -pi -e 'next if $f; s{&lt;integer&gt;5&lt;/integer&gt;}{&lt;integer&gt;1&lt;/integer&gt;} and $f++'
Tried the flag, still changed the string globally... EDIT: Forgot the if statement (doh!), it works! Thanks again! 
The command you posted will only replace the first instance of the string. If you wanted to replace *all* instances, a 'g' would need to be placed immeidately following the last forward slash.
&gt; New Perl projects at companies are almost non-existent; everything is legacy. Most of the projects my company is working on or is approached about are new Perl projects. The *only* client we have with legacy code is one where we've been doing Agile training and not even touching the code. We get contacted by both large corporations wanting us to do new work in Perl, and startups who need Perl expertise to build new projects. Maybe we're just lucky, but from what I have been seeing, those people who say "there's no new Perl work" haven't been looking very hard. And when I read industry research instead of blogs, I've found that the Perl market has finally stabilized, which is awesome news! I'll close by pointing out that the Gartner research firm, in their "IT Market Clock for Programming Languages" has stated: &gt; Current and prospective Perl developers should feel confident that the language will remain a solid technology investment for the foreseeable future.
That's what I thought, but even without the g it replaced globally.
I can't speak for him, but in corporate environment sometimes you have to call Java libraries to get access to specific resources. Having a way to call them from Perl would be a lifesaver for someone who doesn't want to write all his scripts in Java.
&gt; To put it another way - when one (re)watches the Curiosity rover landing, and sees this guy That guy patriotically shaved his head into a US Flag, but in your photo you're dressed as "the father of all lies" while asking for money. In US/Canada, ~70% of the population believe Satan is a real thing that actually exists. If you're seeking corporate support, keep in mind that likely will mean one of the engineers who uses your stuff will have to send that link to their $bossâ€”who likely knows nothing about youâ€”for consideration. I think there'd be an extra hesitation for that engineer to do so, if the first thing the boss will see is that photo. I'd definitely use a more professional pic, if I had the choice :) Anyway, you got my support in the form of a few bucks. Good luck!
The new pic is fantastic! :)
Depressingly yet predictably, it took just about an hour for the pedantic douchebags to arrive: "Oh, you want to use heuristics? Give up now you ignorant child!"
so the $app-&gt;start( ... ) starts a mojolicious app. mojo is basically a web framework that also has webserver built into it. Since OAuth needs to be able to prompt for user/pass and then receive the callback from Spotify via a HTTP call it has to run a web server. I have no idea what you are doing with spotify other than logging in via the cmdline, however once you have the OAuth key you no longer need the daemon (unless you delete the oauth key on the computer or revoke it via spotify. In order to not modify the actual module itself I would add an IOLoop that checks for the cache file which is "~/.spotify.yml" every 30 seconds or so. Once the file is there have it shutdown the daemon. Whatever depends on the cache file is also calling the module, however the oauth has a refresh key so when it expires the user does not have to manually intervene it just requests a new oauth key from spotify and no callback is needed thus no need for the daemon. Something like this in the file where you start the daemon should work ---- # Add the use statement with the others at the top of the file use Mojo::IOLoop; # Before you have $app-&gt;start but after you define $app Mojo::IOLoop-&gt;recurring(15 =&gt; sub { if (-f "~/.spotify.yml") { exit; } } ---- Now this *should* work but is not tested as I normally would not use the IOLoop but would have created my own module based on this one and exiting after the callback is received, however it will probably be easier to handle it this way if you don't know perl that well. You may also want to add in error checking (having it verify that the oauth key is good, verifying that the file does not exist prior to starting and how to handle it if the file is there, etc). 
You are awesome. It worked when I changed "~/" part to $ENV{"HOME"} (it seems that it is bash-specific). I am newly learning Perl and I was doing API thing for learning HTTP request and such, however I've been stuck in there. Now I can continue with the rest of the API.
Something I'm giving up on.
Who says they want to be taken seriously?
This tutorial seems to be written by someone not 100% familiar with English: &gt; Welcome, if you ever wondered what Perl 6 is able to this practical Tutorial, aimed to people who learn the most while our little tutorial: "Perl 6 for problem solver". It's made for practical people. It's all like that.
[Unicode Sandwich](http://nedbatchelder.com/text/unipain/unipain.html)! (it works in Perl too, except the types are less explicit)
Regarding the function composition operator: A couple of months ago I tried to do the exercises for [Category: The Essence of Composition](http://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/) in Perl6. Came up with this: sub infix:&lt;âˆ˜&gt; (&amp;f, &amp;g --&gt; Callable) { return { f( g($^x) ) }; } Wonder how this compares with Larry's version: sub infix:&lt;âˆ˜&gt; (&amp;f, &amp;g --&gt; Block) { (&amp;f).count &gt; 1 ?? -&gt; |args { f |g |args } !! -&gt; |args { f g |args } } The first big difference is that my version only handles unary functions, but other than that, has my version any downsides?
Vice grips is the common one - it's the wrong tool for every job.
How fast is Perl 6 now compared to Perl 5 and NodeJS? Is it worth it?
Oh, yeah, I view the vice grips analogy as a relatively complimentary one. Which probably says as much about my mechanicing as it does my programming...
Data::Dumper doesn't populate $VAR1, etc. -- that's just its output. You don't say exactly what you're looking to get, but I think you're more likely to get what you want with print OUTPUT "@fields\n";
Thanks for the help! I knew that was a problem and I've seen your solution as well as split '\|', as a way to get around that problem. I've tried both and have the same problem so I was assuming it was somewhere else. 
ok. I got excited because I thought Data::Dumper populated those variables and it would make my life much easier. All of the data is going into @fields but I'm not sure the best way to get it out. Each line from my tab delimited file has 145 different records. I need to grab about 40 of those and put them into a text file in a different order. In the past the files I worked with were not pipe delimited but each entry was in the exact same place so I could do something like my $variable = substr $array, 65, 9; and than just print that variable into a new text document. In this situation I'm not sure how to grab just the entries I need in @fields. Is there an easier way to read a pipe delimited file and have it automatically put each record on a line into a unique variable?
OK *now* I guess it's time to get started. There's no excuse any moreâ€¦ where should I go? I have actually installed Rakudo some time this year but got distracted. It's on my computer somewhere. 
Cool. When are THEY going to fix having to use capital letters for True and False.
So, this is Perl 6.0.0 and not Perl6 1.0?
No one is going to take this language seriously if you're wasting real estate on an anthropomorphic butterfly. &gt; Hi, my name is Camelia. Get real. `get_real.pl`
The new perl6.org seems like a pretty good starting point. http://perl6.org/documentation/
There are capital letters for all kinds of other stuff too. It's part of the style of the language, I guess. http://doc.perl6.org/type-basic.html I just noticed that there's both `int` and `Int`. Confusing. 
basin wrench: not everyone tradesman needs it, but those who do, *need* it.
no pressure.. 
Integer and int. One is a class the other is a primitive.
The sponsorship threshold has been set quite low. Hopefully this will make it easy for even the smallest of companies to get on board with this new fundraising plan.
Programmers on HackerNews respond to the release of Perl 6.0.0: https://news.ycombinator.com/item?id=10341832
Only if you don't realise all the lower case types imply native representation. So a shaped array of int rather than Int is near enough a C array in memory. So there are int64 uint int8 etc. When writing C/CPP bindings in pure Perl6 that's something you'll want, and enjoy that it's that simple to do.
I have a very similar story. For me, the answer is nostalgia, curiosity, and that feeling you get when you think about how badly you've fallen out of touch with an old friend. There are seriously some really cool seeming features in Perl 6, and I'm excited to see how they work. But my biggest hangup, or perhaps the biggest appeal for me, is the expectation that I'll have to do some serious thinking to answer the question, "Yeah, but how is this still Perl?"
I didn't understand any of that. ELI5 please?
That was the thing, Perl 5 still worked. And getting it out was like unleashing an entire Legion on a problem. Still is, in fact. However, it's getting rarer to encounter a fellow employee who knows it (shit, it was rare 10 years ago...). And from a softer point of view, what I was seeing was it disappearing from the bright shiny APIs for various things that one needs to plug into these days; CPAN helps here, but it's still worrying when there's no "official" support for a particular language/platform. Perl 6 needs a killer application. Something new, that hasn't been done a brazillion times before. 
Ok, so here's my question - how compatible are "legacy" libraries from perl 5 with perl 6 (e.g. CPAN)? Because unless that capability is there, it's going to be a very tough sell.
There's [Inline::Perl5](https://github.com/niner/Inline-Perl5) which allows Rakudo and the Perl5 interpreter to interoperate. There's also [v5](https://github.com/rakudo-p5/v5/) if you want to add the odd bit of Perl5 code, but it is less complete and development seems to have stalled.
It's beta release of the language. Rather than Rakudo the compiler which has essentially been in open "beta" for about five years. Once the spec is frozen it means that there will be some static requirements that Rakudo cannot change the behaviours for given a target of Perl 6.0.0 (or whatever the v number will be) until the spec changes. The spec likely will change on a longer time scale more reminiscent of perl5 release cycles, than compiler releases which would still be regular for bug fixes and performance etc. The issue is really that Perl 6 development is fundamentally a bit different to perl5 since the compiler isn't the defacto definition of the language version in lock step. Though more recently Rakudo development has mostly informed the spec. Not so hard to imagine when you think C89 is a version of C and gcc and clang can still target that standard. So whatever is specced now is essentially going through final checking and wont change much for Xmas when its fixed in place as the first official production release of Perl 6 with a compiler also ready to go.
I think I'd do something like this: use strict; use warnings; # The indexes of the fields that you want in your output. # Doesn't need to be in numerical order, give the order you want in output # Adjust to whatever your requirements are. my @keep_fields = (0, 5, 8, 21, 10, 1); # Read from STDIN while (&lt;&gt;) { chomp; # Write to STDOUT print join('|', (split /\|/)[@keep_fields]), "\n"; } The complicated-looking `print` line is just short for: my @fields = split /\|/; print join('|', @fields[@keep_fields]), "\n"; It is written as a filter. It reads from STDIN and writes to STDOUT. That is generally more flexible than hard-coding filenames. You call it using I/O redirection like this: C:/&gt; your_script_name &lt; test.txt &gt; D:/test/test.txt And if you ever need to change the filenames, you don't need to change your program. I covered a lot of this stuff in *Data Munging With Perl* which is now available for [free download](http://datamungingwithperl.com/). (**Note:** I assumed you wanted pipe-separated output too.)
I didn't say you did.
We did it, Craigslist!
I've never used IO::Compress::Gzip before but a very simple solution would be to simply use system("gzip File.json"); Or, use something other than gzip to compress the file like bz2 (I assume there is an IO::Compress::Bz2 but haven't looked). Aside from that, check the perldoc for IO::Compress::Gzip and see if there are any flags you can enable or some sort of error string you can check. Are you checking the return results of the gzip function call? Maybe it's returning an error (and if so you should be able to figure out what the error is with another function call or by reading a variable like $! or something).
I haven't tried any of this, but [Gzip::Faster](https://metacpan.org/pod/distribution/Gzip-Faster/lib/Gzip/Faster.pod) has a much better review on meta::cpan. 
Is `gzip()` returning errors? Which? Looks like if it is, you're ignoring them - better to see if any are returned! From the POD: use IO::Compress::Gzip qw(gzip $GzipError) ; gzip 'File.json' =&gt; 'File.json.gz' or die "gzip failed: $GzipError\n";
Is it supposed to be dog-slow? Have there been a lot of performance improvements since 2015-07.2 which is the version Fedora currently has? I tried running one of the examples from the perl6.org site and it took 45 seconds to run a pretty simple job: [dicey@entropy perl6]$ perl6 --version This is perl6 version 2015.07.2 built on MoarVM version 2015.07 [dicey@entropy perl6]$ cat words6.pl #!/usr/bin/perl6 for '/usr/share/dict/words'.IO.words -&gt; $word { say "$word probably rhymes with Perl" if $word ~~ /[ea?|u|i] rl $/; say "$word is a palindrome" if $word eq $word.flip and $word.chars ge 2; } [dicey@entropy perl6]$ time ./words6.pl &gt;/dev/null real 0m45.599s user 0m44.796s sys 0m0.266s `top` showed that the moar VM process was using 100% of a single CPU core during this time. Compare to a perl5 at 100x faster: [dicey@entropy perl6]$ cat words5.pl #!/usr/bin/perl open(WORDS, '&lt;/usr/share/dict/words') or die "Could not open words: $!\n"; while(&lt;WORDS&gt;){ chomp($_); print "$_ probably rhymes with Perl\n" if $_ =~ /[ea?|u|i]rl$/; print "$_ is a palindrome\n" if $_ eq reverse($_) and length($_) ge 2; } [dicey@entropy perl6]$ time ./words5.pl &gt;/dev/null real 0m0.419s user 0m0.263s sys 0m0.004s 
it seems like by far the slowest part in this example is the regex match. our regex engine doesn't yet analyze parts of the regex for minimum/maximum match length and so we have to go through the whole word from beginning to end, each time looking for e, u, i and then rl and *then* check if we're at the EOS already. a quick profile of the script reveals, that ACCEPTS, the method behind the ~~ operator, takes about 70% of the time the whole script takes.
Not exactly an apples for apples comparison with Perl 5. Perhaps if you used Moose and created objects for everything and read the strings in as normal form unicode. Just use Moose would add 0.2 seconds to that time. But yeah in my experience a lot of Perl 6 is about 10x slower even after the recent list refactor. Your code on my Macbook Air from 2011 took about 12s on Rakudo built ten minutes ago and 0.14s on Perl 5.20 The most important thing anyone can do right now is report this stuff to the Rakudo devs leading up to Xmas. There's been a number of times I've reported dog slow stuff like this and then by the next release its 10x or 20x faster just because they knew where to look.
Perl 6 [Grammars](http://doc.perl6.org/language/grammars) are what I'm most excited about. 
&gt; Perhaps if you used Moose and created objects for everything and read the strings in as normal form unicode. You don't have to do this in Perl, so why hamstring Perl in this benchmark by loading it up with the overhead of RakudoScript?
&gt; There's no excuse any more I've long been interested but the slow-as-molasses runtimes to date made it a non-starter. What's the deal with moarvm/rakudo benchmarks these days?
 $ time perl6 ./word6 &gt;/dev/null real 0m4.571s user 0m3.980s sys 0m0.092s $ time perl ./word5 &gt;/dev/null real 0m0.045s user 0m0.032s sys 0m0.000s +ander@ander-H61H2-I3:~$ perl6 -v This is perl6 version 2015.09-263-gc471450 built on MoarVM version 2015.09-55-gf09c782 
That's pretty interesting, thanks!
Thanks! What about marketing? Stuff about Ruby on Rails pops up everywhere. The Perl "equivalents", I hear practically nothing about on the grapevine. I used some Plack-based stuff for a while, but even then, a large part of those appear to have been "inspired" by happenings elsewhere. Who's marketing this to regular people? Perception by non-technical types is probably even more important than that of programmers. Everyone rave(s|d) about Ruby and RoR, companies like Java (I've been doing some Java/Groovy stuff recently, it's fucking tedious, but gets the job done in places), and then there are .Net, Swift, the Functional Languages, etc... I loved using Perl, and it's brutal approach to fucking the problem up the arse until it gives in, but I feel the war has been lost with regards to regular folks. 
It's interesting that a decent number of informed comments got above the noise level.
&gt; If the words file was on a Chinese computer it might be a different ball game. I'm fairly confident that looking for 1) English words which rhyme with "Perl" and 2) palindromes is somewhat specific to English, but if you'd like to normalize the words to NFC in Perl and benchmark it again, that'd satisfy me. (I mean, no one's seriously arguing that the Perl example should load `Parse::RecDescent` to put the "supports grammars" brick in its pocket.)
Perl 5 still has has a firm hold in Linux administration, Bioinformatics, and text processing. The most popular movements will always be the ones where everyone thinks the same. People want to be told the one true way, and that encourages them to find fault with those who have more than that one way. I think that's why wars are fought. But no one thinks the same way forever. And it's nice to not have to learn a new environment when that time comes.
Other Moo-based ORMs: * https://github.com/bradhaywood/DBIx-Moo * https://metacpan.org/pod/DBIx::Mint
I heard Perl 6 is one of the horses of the apocalypse, and it'll bring apocalypse.
Are they duplicate entries? Both entries here have the same start and end times: krodrig3 pts/1 :0.0 Mon Sep 7 15:40 - 15:52 (00:11) krodrig3 :0 Mon Sep 7 15:40 - 15:52 (00:11) But then in this example the end times differ: jpontius pts/1 :0.0 Wed Sep 9 09:06 - 09:19 (00:12) jpontius :0 Wed Sep 9 09:06 - 09:23 (00:17) If you just want to test if the 2nd column is `:0` you could just `split` the line into columns and deal with it like you would with cut or awk. #!perl use strict; use warnings; use feature 'say'; my %times; my $re = qr/^\((?:(\d+)\+)?(\d+):(\d+)\)$/; while (&lt;DATA&gt;) { # column 1 to $name, $column 2 to $from, rest of columns to @F my ($name, $from, @F) = split ' '; # Was column 2 :0? If so, skip to next line next unless $from eq ':0'; # The last column contains the duration e.g. (00:09) my $duration = $F[-1]; if (my ($days, $hours, $mins) = $duration =~ $re) { # if days not present, use 0 $times{$name} += 1440 * ($days || 0) + 60 * $hours + $mins; } } say "$_ $times{$_}" for sort keys %times; __DATA__ jpontius pts/2 :0.0 Wed Sep 9 09:14 - 09:23 (00:09) jpontius pts/1 :0.0 Wed Sep 9 09:06 - 09:19 (00:12) jpontius :0 Wed Sep 9 09:06 - 09:23 (00:17) jpontius :0 Wed Sep 9 09:06 - 09:06 (00:00) kconner3 pts/1 :0.0 Mon Sep 7 16:47 - 16:54 (00:07) kconner3 :0 Mon Sep 7 16:46 - 16:54 (00:07) kconner3 :0 Mon Sep 7 16:46 - 16:46 (00:00) bbarret8 pts/1 :0.0 Mon Sep 7 16:17 - 16:23 (00:05) bbarret8 :0 Mon Sep 7 16:17 - 16:23 (00:05) bbarret8 :0 Mon Sep 7 16:17 - 16:17 (00:00) mgrigalu pts/1 :0.0 Mon Sep 7 16:04 - 16:11 (00:07) mgrigalu :0 Mon Sep 7 16:03 - 16:11 (00:07) mgrigalu :0 Mon Sep 7 16:03 - 16:03 (00:00) krodrig3 pts/1 :0.0 Mon Sep 7 15:40 - 15:52 (00:11) krodrig3 :0 Mon Sep 7 15:40 - 15:52 (00:11) krodrig3 :0 Mon Sep 7 15:40 - 15:40 (00:00) Not sure what you're learning Perl from but you might want to check out Modern Perl to learn about `strict`, `warnings`, lexical variables, etc. http://modernperlbooks.com/books/modern_perl_2014/
This looks awesome. Thank you for explaining everything. I did not write the original script or regex, and I'm a complete perl newb. Yes I am trying to eliminate duplicates. Once logged in, our users run a program that opens a terminal session in the background, but I only want to track the time they're logged in. With the original script they're time was being doubled. 
I heard Perl6 will be the featured scripting language for the GNU/HURD OS.
1. Duke Nukem Forever 2. Perl 6 3. Half-life 3 4. GNU/HURD
[**CLICK HERE TO WATCH!**](https://plus.google.com/101610166474347948929/posts/hwz19p66Qtn) Beasts of No Nation full movie,Beasts of No Nation watch,Beasts of No Nation watch for free,Beasts of No Nation watch online free,free watch Beasts of No Nation movie,how can i watch Beasts of No Nation online for free,how to watch Beasts of No Nation free,how to watch Beasts of No Nation online,how to watch Beasts of No Nation online for free,how to watch Beasts of No Nation online free,how to watch Beasts of No Nation online full,watch Beasts of No Nation,watch Beasts of No Nation 2015,watch Beasts of No Nation 2015 for free,watch Beasts of No Nation 2015 for free online,watch Beasts of No Nation 2015 free,watch Beasts of No Nation 2015 free online,watch Beasts of No Nation 2015 free online streaming,watch Beasts of No Nation 2015 full,watch Beasts of No Nation 2015 full movie,watch Beasts of No Nation 2015 full movie for free,watch Beasts of No Nation 2015 full movie free,watch Beasts of No Nation 2015 full movie online,watch Beasts of No Nation 2015 full movie online free,watch Beasts of No Nation 2015 movie,watch Beasts of No Nation 2015 movie online,watch Beasts of No Nation 2015 online,watch Beasts of No Nation 2015 online for free,watch Beasts of No Nation 2015 online free,watch Beasts of No Nation 2015 online free full movie,watch Beasts of No Nation 2015 online free no download,watch Beasts of No Nation 2015 online free no sign up,watch Beasts of No Nation 2015 online free without download,watch Beasts of No Nation 2015 streaming,watch Beasts of No Nation (2015) full movie,watch Beasts of No Nation for free,watch Beasts of No Nation for free 2015,watch Beasts of No Nation for free in hd,watch Beasts of No Nation for free online,watch Beasts of No Nation for free online 2015,watch Beasts of No Nation for free online in hd,watch Beasts of No Nation free,watch Beasts of No Nation free download,watch Beasts of No Nation free full movie,watch Beasts of No Nation free hd,watch Beasts of No Nation free in hd,watch Beasts of No Nation free movie,watch Beasts of No Nation free no download,watch Beasts of No Nation free on line,watch Beasts of No Nation free online,watch Beasts of No Nation free online 2015,watch Beasts of No Nation free online full movie,watch Beasts of No Nation free online no download,watch Beasts of No Nation free online no sign up,watch Beasts of No Nation free online streaming,watch Beasts of No Nation free stream,watch Beasts of No Nation free streaming,watch Beasts of No Nation full,watch Beasts of No Nation full movie,watch Beasts of No Nation full movie 2015,watch Beasts of No Nation full movie 2015 free,watch Beasts of No Nation full movie free,watch Beasts of No Nation full movie free online,watch Beasts of No Nation full movie hd,watch Beasts of No Nation full movie online,watch Beasts of No Nation full movie online free,watch Beasts of No Nation full movie streaming,watch Beasts of No Nation full movie streaming online,watch Beasts of No Nation full video,watch Beasts of No Nation movie,watch Beasts of No Nation movie 2015,watch Beasts of No Nation movie 2015 online free,watch Beasts of No Nation movie for free,watch Beasts of No Nation movie free,watch Beasts of No Nation movie free online,watch Beasts of No Nation movie online,watch Beasts of No Nation movie online for free,watch Beasts of No Nation movie online free,watch Beasts of No Nation online,watch Beasts of No Nation online 2015,watch Beasts of No Nation online 2015 free,watch Beasts of No Nation online 2015 free streaming,watch Beasts of No Nation online for free,watch Beasts of No Nation online for free 2015,watch Beasts of No Nation online for free full movie,watch Beasts of No Nation online for free no download,watch Beasts of No Nation online free,watch Beasts of No Nation online free 2015,watch Beasts of No Nation online free full,watch Beasts of No Nation online free full movie,watch Beasts of No Nation online free hd,watch Beasts of No Nation online free no download,watch Beasts of No Nation online free now,watch Beasts of No Nation online free stream,watch Beasts of No Nation online free streaming,watch Beasts of No Nation online full movie,watch Beasts of No Nation online movie,watch Beasts of No Nation online now,watch Beasts of No Nation online streaming,watch Beasts of No Nation streaming,watch Beasts of No Nation streaming movie,watch Beasts of No Nation streaming video,watch free Beasts of No Nation,watch online Beasts of No Nation
Bingo. 
and for comparison, some other ORMs: https://metacpan.org/pod/EntityModel#SEE-ALSO tl;dr there are 30 or more options of varying quality and features (not counting the various ways people have reimplemented ORMs or some form of DB abstraction in their own code).
boilerplate? you mean like this: $sth-&gt;execute($self-&gt;id); my @purchases; while (my $h = $sth-&gt;fetchrow_hashref) { push @purchases, $h; } return \@purchases; and this: $sth-&gt;execute( $args{username}, $args{password}, $args{email_address}, ); my $user_id = $sth-&gt;fetchrow_arrayref-&gt;[0]; return $self-&gt;fetch($user_id); ? redesigning database schema... where *is* the schema? do you support migrations for upgrades? some form of specification for the database tables that other languages can use? so far it looks like you just have things inline in the code, so I don't see how that helps portability to other languages. locking you into the ORM's way of doing things... not really sure which ORM you're thinking of here, but anything that's DBI-backed will typically let you run manual SQL if you really want to. I wouldn't recommend DBI in general, but it's pretty much the standard access layer and many ORMs make it easy enough to get to a database handle. So if you're asking "is this a good idea", I'd have to say no - not at all. It's only one step better than manual SQL queries mixed directly with the program logic.
&gt; I thought DBI does this internally; if it sees a statement it has previously prepared and cached it fetches the prepared statement from it's cache instead of preparing a new statement. I just checked to see I was mistaken. prepare_cached seems to be like a memoize version of prepare. I don't use it too often because if I wanted to save a statement handle I would do it by hand. So my code would look more like this: $self-&gt;{create_user_sth} ||= prepare(); This does have advantages over prepare_cached(). It saves on the function call overhead and hash table lookup (against the prepare string) as long as the variable is already defined, but I think prepare_cached might be better for code maintenance because it describes what's happening. 
[Mojo::UserAgent](https://metacpan.org/pod/Mojo::UserAgent) includes batteries and DOM parsing. For web scraping specifically you could get everything in one package with it. [LWP::UserAgent](https://metacpan.org/pod/LWP::UserAgent) Is the standard go to for HTTP sort of things. It's common and lots of things are built on top of it. I personally like [Furl](https://metacpan.org/pod/Furl), it's small, light and does next to nothing aside from fetching things.
If you want something like urllib, then [LWP::Simple](https://metacpan.org/pod/LWP::Simple), [LWP::UserAgent](https://metacpan.org/pod/LWP::UserAgent) or [WWW::Mechanize](https://metacpan.org/pod/WWW::Mechanize) are what you want. But Perl also has modules which provide powerful web scraping DSLs over the standard HTTP modules - so you might not need to do your own parsing of the HTML. Take a look at [Web::Scraper](https://metacpan.org/pod/Web::Scraper) and [Web::Query](https://metacpan.org/pod/Web::Query).
If you want to fetch URLs form a URL you can even do it with Perl one liners: `perl -Mojo -E 'say join "\n", grep {/^http:\/\//} split /\n/, g("https://news.ycombinator.com/")-&gt;dom-&gt;find("a")-&gt;map(attr =&gt; "href")-&gt;join("\n")'`
Nice example! You could simplify it a bit by using the `grep` and `say` methods from [Mojo::Collection](http://metacpan.org/pod/Mojo::Collection). perl -Mojo -E 'g("https://news.ycombinator.com/")-&gt;dom-&gt;find("a")-&gt;map(attr =&gt; href)-&gt;grep(qr/^http/)-&gt;join("\n")-&gt;say'
Another vote for [Mojo::UserAgent](http://metacpan.org/pod/Mojo:UserAgent). It comes with [Mojo::DOM](http://metacpan.org/pod/Mojo::DOM) for parsing which supports [CSS3 Selectors](http://metacpan.org/pod/Mojo::DOM::CSS).
When I read stuff like this, I realize how much I don't know. 
It's hard to tell sometimes when he talking "past", "now" or "future". That whole paragraph you clipped is kind of messed up thinking.
He seems like a difficult person to work with, but he does have a point that the "features" (a.k.a. breakage) since 5.6 or so have done more harm than good. "//" was a good thing. "Smart" match was complete fail. The signature stuff will probably change again and again over the next few years, so I can't imagine using it. Heck, I'll be too busy batting away various "deprecated because I said so" junk to deal with it.
Naw. There's Perl5. If you're over that, there's Python. Different strokes for different folks, but not really sure where Perl6 stands in that spectrum.
No, in fact, we should kill perl5 and go back to shell and C, who needs new, better, languages?
I really like Perl 6 and what it has to offer. But I won't use it in my daily operations. Why not? It's too slow (or, at least, it was orders of magnitude slower than Perl 5 when I last tried it out 6 months ago). Perl 5 is relatively optimised for what it is. And Perl is often used because it is a great compromise between performance and coding effort. I'm keeping my ears open for news of radical performance improvements in the VM.
Python is not an alternative for those of us that strongly prefer braced and semicolon'd languages. Those who like their meaningful whitespace can choose from: * Python (scripted) * CoffeeScript (scripted) * Scala (virtualised) * Go (compiled) While those of us who want flexibility in the whitespace can choose from: * Perl (scripted) * JavaScript (virtualised) * Java (virtualised) * Rust (compiled) * C (compiled)
Yeah you do as they are checking the result of `ref`. return $self-&gt;new(grep { $_ =~ $cb } @$self) if ref $cb eq 'Regexp';
This will be why I failed :'( Thanks for the explanation. 
I'm interested to see Mr. Hushmail's reaction to this :-)
Nice article. But, what's this? &gt;Thus, calculating the distance between points is exact rather than approximate (assuming you don't use numbers so huge you're forced into overflow and fall back to floating point numbers). Exact squareroots? Good luck with that! 
I didn't think Go had meaningful whitespace? It's a braces-based language - albeit one which allows you to omit semi-colons. Yes - there are a couple of cases where you can't break a line (due to the auto-semicolon) but I think they're minor and similar issues apply to javascript? If you're referring to gofmt, that's just a tool which (successfully) encourages a coding style. I don't think the parser cares significantly if you use it.
Fixed text (quoted emails) on his page don't render - they are cut off. Must be because I'm on mobile. That said, he's a little arrogant too. Maybe frustration leads to this post.
If you are choosing your language based on cosmetic features like whether or not it has significant whitespace, rather than the actual semantic features, performance characteristics, or target platforms, you may be focussing on the wrong thing.
Yes. The blogs.perl.org rendering on mobile devices is horrible. We're working on it.
&gt; schmorp called them [p5p] clowns. He is right. ðŸ¿ 
I'm still tempted to try it. :)
"wire space sensitivity"? I googles but it tells me no refrance
[removed]
What they call 6.christmas or 6.0.0 which will be launched this Hanukkah, will be the first release with stability promises on the syntax. They are promising everything written for 6.0.0 will keep running indefinitely. 
The last time I had to do a sample project for a job (which I ended up getting an offer for) I use Catalyst and DBIx::Class plus Angular; The webapp only served up a single static file and Catalyst was just a bunch of ajax-y things the Angular app hit. It was the most over-engineered address book I have ever seen. 
I wonder if you aren't bringing the coding test in too early. I mean, aren't a number of people probably going to talk to you and think it's not a good fit? Why invest so much time in the test for so many people?
"white". Eh, TBH, I'm not a giant python fan, but the amount of crying we do about whitespace sensitivity is just unwarranted. Its yucky, ok. We get it. Its not really that big a deal. There are far more interesting things about it that annoy me than white-space. Like its namespacing system is hella awkward. 
[removed]
I assume not, but I feel like a short phone screen, at least, would save everyone a lot of time
On both sides... "moving on" doesn't involve blogging about it. I very much agree with Lyle on a key point. I understand that grading and reviewing candidates is hard, but employers/recruiters also need to be aware that an unemployed candidate is going to be applying to potentially hundreds of jobs. First impressions may be key, but giving instructions and not accepting feedback means that the candidate is left hanging if the requirements aren't perfectly stated. Even if the requirements are explicit, there needs to be something mentioning this in the test packet or you will have people trying to deviate for speed, creativity or any other reason. They're forgetting that in 7 days allowed for the test, the candidate doesn't have all that time to devote exclusively to their interview. If they have 90% of the solution done with mysql and someone asks them to use SQLite, the least they can do is ask if mysql is an acceptable solution. Let's say that a candidate applied to 10 jobs this week, all of them required tests. Just keeping the different tests and requirements straight is a challenge by itself. It's not unforeseeable that a requirement might be overlooked or that they might get two projects mixed up. This isn't a sign of bad communication or being a bad developer, just a sign of overwork, stress, or whatever. Again, first impressions may be key, but responding to the candidate to clarify your requirements seems like it could be done with a form response, so it doesn't take much effort, and anticipating they may get things wrong isn't too much to ask. I'm not saying you don't penalize failure, but grade the final turned in results, not the process taken to get there.
&gt; Profile and rewrite the slow parts in C, which is very easy to do. I take a different lesson from JavaScript performance in the past decade. We discovered similar things in Parrot--avoid C as much as possible and concentrate on writing everything in a very small, optimized core. The impedences of memory management and marshalling/demarshalling when you have to cross that language barrier is significant. I don't know where our Lorito prototypes were anymore, but they were very promising.
A friendly reminder: Include phrase "like in python's" for best results.
Very cool!
I made a pact with myself years ago to no longer blog negative stuff, so I probably wouldn't have written a blog post like this (if it was my experience). Maybe that's why I haven't been blogging for years... Anyway, I think one can move on at a later stage. I am also not really charmed by "Diva"; I am sure that some people who've contacted me in the past with potential work would call me that. But every story has two sides. I am slow to respond to email because my experience is that if I reply fast it raises expectations. It also makes that people fire off emails each time they have an itch. At one time someone asked me for a quote and over a day I got 3 addendum emails. So I waited a few days before I replied, also because I actually have to think about those things. On Monday I got an angry email that someone else had the job. Another thing I hate. If you email around for quotes at least make clear that I am in a "bidding war". Anyway, I decided that he would never be a customer I would like to work with (for several reasons, including the "breathing down my neck"). I am a "no news is good news" kind of guy which some of my customers have to get used to (and they do, in my experience); I limit the email communication to (what I think are) the bare necessities. Don't get me started on not replying to email by quoting and replying in line. Most emails I got that were time wasters where the ones in which people dumped a badly written, and often incomplete answer, on top of their reply. I don't bitch about it (except once) but keep replying how I would like to see it, and some customers pick it up, and at least in one case it was called "very handy". That one time I did bitch was when I had 4+ questions (I always make each question stand out by starting with Q followed by its number) and just got a reply (on top) "John, sounds great, when is it finished?" When I told my customer that this was not the way to communicate he argued that this way saved him a lot of time... I really needed the answers to those questions, that's why I wrote them down to begin with. So how "Sounds great" answers them all and saves time is beyond me ;-). As for IM or phone; I avoid the former like the plague and don't do the latter at all. I am sure that makes me a diva in the eyes of many but I don't like to be cornered with stuff like "You're a skilled programmer I am sure you can do that in under 4 hours". Followed an hour later with additional notes by email turning it into a 40 hour project... Also, I don't like interruptions when I am doing work that needs my full concentration. Aside: I don't do fixed price projects unless I am 100% sure of the time it takes (yes, yes, I am actually a diva). As for rejecting projects, I think that as a freelance programmer/consultant it's my right to do so. I've been maintaining until recently an extremely badly written Perl program for a few years on an extremely small budget and it's a pain in the ass. Won't do something like that again, ever. It's literally trying to polish a turd, and do I really want my name associated with that? As for refusing to listen to other developers.... I have no problem with listening, but can have a hard time with accepting criticism. That partially has to do with the "kick in the balls" kind of criticism that's so very common in IT. And yes, I have been guilty of that and I am doing my very best to be better at it. Moreover, I am a slow thinker, so it can take some time for me to see the other point as clearly as the person arguing with me. But to a customer (in my experience) the arguing between developers (which actually can result in a better product in the end) is often considered a waste of time. And I've seen customers picking the wrong side despite good arguments why a decision was a wrong one. And no, I really don't like to tell people "told you so".
Might as well name drop HTTP::Tiny http://www.dagolden.com/index.php/1212/why-httptiny/
Hopefully that will be true.
The only possible lesson to learn from JavaScript (and Java before it) is "throw enough money at a pig and it will, if not fly, at least move relatively quickly."
All of those "do you have any fucking idea..." questions at the top of your comment - well I'm pretty sure that Ovid knows exactly what you're talking about. He's a well-known Perl programmer and a well-respected member of the Perl community. I'm sure he has dealt with all the issues that you list. Which is why, I guess, when he's in a position where he has to recruit Perl programmers, he tried to come up with a procedure that worked around as many of those problems as possible.
&gt;&gt; If I had the time I could add another layer of abstraction and end up writing a whole ORM framework. &gt; &gt;Why would you do this when this has already been done already, and extensively debugged, for you? &gt; &gt;&gt; I know exactly whats going on &gt; &gt;This sounds like "I don't want to use something someone else wrote because I didn't write it", which is NIH-syndrome. That's not very perlish. Actually, I probably would use a 3rd party solution if I wanted more abstraction. The point is that I don't want more abstraction. My current solution is a nice balance between the high-level of creating and fetching objects, and low-level of retrieving and persisting those obects using SQL. I think my code is still maintainable and portable, and if I decided to start using an established ORM instead (which I know is the industry standard and everyone says is a good idea) I don't think it gives me anything I need, whereas it locks me into another dependency and reduces the portability of my code.
&gt; locks me into another dependency and reduces the portability of my code I don't think those words mean what you think they mean. But never mind, you'll figure it out eventually.
Java's a little easier to optimize that JavaScript (static dispatch, actual numeric types, somewhat better string semantics, somewhat better scoping semantics), but you do have a point. The fact that JavaScript is a language poorly designed for optimization but has good runtime performance despite that suggests that there are some well known techniques that could benefit better languages. RakudoScript is supposedly designed to make some of these optimizations possible, but a JIT isn't magic fairy powder to make up for the design defects of MoarVM in this regard.
I gave it a "++". Nice job.
IMHO, Java is what you get when you throw money at a bad competitor for C++ in its domain. JavaScript is the same for a bad competitor for Perl/Python/Ruby/etc. JavaScript worked relatively better performance-wise, but still sucks as a language. JIT may not be fairy dust, but the JS folks can "clap harder" until their palms blead. One easy test for me is whether the language can use SIMD. C++ and ilk can, Perl and ilk cannot, and the rest is noise and FFI.
&gt; One easy test for me is whether the language can use SIMD. That seems like an implementation detail to me, assuming the language design's memory model doesn't preclude cache-friendly data isolation. You probably want compiler-level data reorganization and unraveling of an OO-heavy allocation strategy in that case, assuming it's an OO-heavy language (or whatever model the language puts between you and the heap). So I probably agree with you there in practice. Then again, the myth of the sufficiently smart compiler set back performance of a lot of languages for the past several decades. On the gripping hand, this is nominally a discussion about the viability of RakudoScript, so bringing up the fairy dust hand-clapping rebuttal to "we'll make a sufficiently smart compiler" claims seems fair.
It took me some doing, but I finally got tesseract to do what I wanted to do with perl. Well the perl part was easy - I'm just calling the tesseract.exe and analyzing the resulting text file. The standard tesseract ocr font(s) training that comes standard with it was continually mixing up 4 and 5, so I had to train only on the particular font I was using, and that took some time and experimentation to figure out that whole process. It just OCRs the whole image file - not sure if you can set an area in the image. but if you've got consistent data in it, it's most likely easy to locate and parse. But yeah, tesseract works well.
I am the one defending this position not him. Honestly, If you see something that does not work for you move on. If you want to work with companies that does not test, fair enough. They are numerous. I want all our employees and contractors to go through a test as he taught us a lot about their personality and he taught them a lot about our expectations. The test goes both ways, it allows you to decide that we are or not a good fit for you and the same goes for us. Therefore, I cannot see the problem. You are the candidate and have the power to decide if our requirements work for you or not. Enjoy this power. Choose what's right for you and do not be an ass about it. 
What /u/mishagale said. Also what does "virtualized" and "scripted" actually mean? I mean, there is compiled-directly, compiled-just-in-time,(luajit) and interpreted.(lua) Could in principle be any or all of them...
They've adjusted it.
there is also a perl section on flipboard https://flipboard.com/topic/perl
So your partner's suggestion that the applicant asks politely by email about that is useless, since there's no answer anyway? Or, more accurately, the answer would be "whatever the client is willing to pay"? You have minimum standards for qualifications but not for salary? 
You know, usually you don't get to have these conversations with employers. I'm being open, honest, and respectful. You're being aggressive, insulting, and you're also flat out wrong. We pay our people fairly and treat them them well. You, who have absolutely no grounds for your opinion, are just guessing and assuming the worst, merely because we didn't do what you think we should do even though we explained why. I find that offensive as hell. I'm done with this conversation.
The flight controllers usually reserve the i2c bus for things like barometers or other sensors. A lot of them run open source firmware, so you could modify them to take movement commands over i2c (or spi) if you want. I'm not sure what the advantage would be, though.
For Perl5, I wrote [Gopher::Server](https://metacpan.org/release/Gopher-Server) years ago. [Apache::GopherHandler](https://metacpan.org/pod/Apache::GopherHandler) glues it into Apache2/mod_perl. That said, Gopher is an awful protocol that should stay dead: http://www.wumpus-cave.net/2013/10/27/why-gopher-is-awful/
spamassassin (written in perl) has an OCR plugin called fuzzyocr. It uses gocr to decode (which is probably C?). I didn't look into how it works, but it might be a good place to start.
What a shitty article. How about downvoting all blog entries by Israelis, and upvoting all blog entries by Palestinians. Why? Because if we're going to give trite voting suggestions a strict adherence to human rights should trump a petty loyalty to a 20 year old programming language. * [BDS - Academic boycott](http://www.bdsmovement.net/activecamps/academic-boycott)
&gt; smalltalk, all highly dynamic and all without a jit fyi http://www.bayareascience.org/calendar/index.php?eID=16179 
&gt; Then again, the myth of the sufficiently smart compiler set back performance of a lot of languages for the past several decades. Here we agree. I think certain versions of certain Lisp compilers on certain CPUs will do this in certain circumstances if you add all the right declarations. But even if you wrote the compiler, it can be hard to figure out when it will happen. (See also "space leaks" in Haskell and, farther afield, trying to outsmart Google to make it execute the search you actually want.). When you want performance, you usually want predictable performance.
You've voiced two concerns here. 1. Ugly 2. Unusable Would you be able to expand on both of these? We can't and won't be everything to everyone, but if there's something obvious that we're missing, perhaps it can be addressed.
Oh you have been downvoting the posts of the bot because you thought it is mine? I am sorry to disappoint you. That's not mine.
TLDR? Honestly, even these "summaries" are *way* too long to wade through.
It will be interesting to see what happens.
Perl 6 Hands-On Tutorial, I believe you mean...
It's good to have these kinds of presentations regularly and maintain an aggressive posture against outdated methods.
I'm literally the exact opposite. If I find myself on cpan, I look it up on metacpan... suum cuique!
Myself, i definitely prefer metacpan to cpan (thanks for your work!); but i would like to suggest adding a bit more whitespace on the left and right sides of the navigation pane on the left of the page, and limiting non-code line length in the main pane to some value between 60 and 70 ex. Also, layout seems to change depending on whether one is looking at a 'release' page or a 'pod' page: cf. [this](https://metacpan.org/release/File-Slurp) vs. [this](https://metacpan.org/pod/File::Slurp).
How about doing it in 2 passes? Write your high level grammar to recognise delimiters and have it output unpack statements and assignments. Note: I have no idea if this would work.
[Give Me MetaCPAN](http://perlhacks.com/2013/01/give-me-metacpan/).
never even thought of solving that problem... thanks!
So I've had the same dislike of meta CPAN myself. Although I'm not the person you replied to I'd like to put in my 2c since you're asking. I couldn't immediately put my finger on what the issue is from memory, so I had to archive this and come back on my desktop. So I think I've figured it out. Most of the time when I go to CPAN its to figure out how to begin using a module for the first time. With that, I'm usually trying to concentrate on the gritty details of the authors documentation. When I'm focusing on reading the text the sidebar ends up being extremely distracting. I love the bright vibrant colors but I would honestly tone them down just a tad. Honestly, now that I've compared them both I see meta cpan has a lot of features I've simply never used because I kept dragging back to plain old CPAN. I hope this helps. 
&gt; I don't think the parser cares significantly if you use it. gofmt is totally voluntary (albeit its so easy to just hit strg+shift+f to auto format your code, I don't care about whitespace as long as I can be lazy).
Exactly. You need a module to implement arrays. Yes, I probably shouldn't poke fun at python because there are some nice features, but I seem to work more fluidly in perl. (all IMHO)
ISTR Python's arrays are called "lists", see 4.6.3 and 4.6.4 in https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range ([Yojihito] led me to the right spot :-)
Also the whole of numpy... Arguing you need a module to do something, is the joke...? Perl 5 you need List::MoreUtils and List::Util to get most of the builtins that come baked in with Python's lists.
Yeah, I think the module thing makes it less accessible. (and I'm not REALLY putting down python) 
I love Perl too, but you should really try SNOBOL4 &gt;=)
I have tried snobol. Even spitbol. (long time ago!) is snobol4 recent? EDIT: nope, snobol4 is old. I thought maybe I learned snobol1 and maybe there were a couple revs I didn't know of.
Yes, Python doesn't have that level of autovivification and it goes strongly against its philosophy
No goto? I know, it's bad, but you don't tell me what to do, python. No breaking out of outer loops from inner loops? Well that's just asinine. 
Can we get a 5e edition release for Perl 6? On April 1st of course.
No, I just remember learning it as plain snobol without a version number. To be honest, I don't remember a lot of the concepts except that it was very good at text processing and patterns. I will have to check it out again. I also remember an ibm language called rexx that seemed to have a rather nice pattern matching set up for parsing arguments. I think the main thing that stuck in my mind is that it made it easy to figure out where the matches were going. (ok, now I have to look it up) Ok, here's a page: http://www.kyla.co.uk/other/rexx3.htm basically you run your program like this: program a b c ( foobar e PARSE ARG first rest '(' next 3 . first =&gt; a rest =&gt; b c '(' =&gt; matches literally next =&gt; foo . =&gt; rest thrown away Now might not be as powerful as regular expressions (although I don't have super-deep knowledge of PARSE), but it has one really nice feature: it's easy to tell variables, operators and literals apart. It's also easy imho to read. (rexx in general was easy to read and kind of fun with it's informal keywords) I think the #1 problem with regular expressions is the difficulty to determine if a character is a literal, an escape or an operator, and there can be additional layers of craziness when you figure in language and command-line escaping. (maybe perl 6 helps with this, I don't know)
Thanks!
Yes, sorry. VisualWorks of course has a jit. That's why it's 2x faster than the fastest interpreted VM, lua. Smalltalk was the first language ever to introduce a jit AFAIK.
I had a brief flash of insight last year about a really good April Fool's prank, where I'd transpile the entire RakudoScript test suite into LuaJIT-compatible code and do the bare minimum to emit "everything passed okay" TAP output. I didn't do it for two reasons. First, it's kind of a jerky thing to do, rules-lawyering the idea that anything that passes the test suite is a valid implementation. Second, it was more work than even the ten minutes I spent figuring out how to do it was worth. To answer your question "No, not from me, and not with the 'Modern Perl' name."
I am a XML::Simple addict. I needed XML parsing for some code at one point and needed it quick. It worked well for me. I used it even yesterday. I'm trying to write a script to automating testing a device and I wanted to provide the user some config info from the device so that they could verify easily. The device can output its config in XML so I took that output and passed to XMLin. I then displayed the bit of info I wanted. 
A little bit annoyed. I loaded that page without JS enabled. It showed me the content just fine, i started to read, then it redirected me to a page with a complaint about my lack of JS.
MooX::Options is much nicer. 
https://github.com/dnmfarrell/Perly-Bot
McCarthy had talked about it in the '60s, and I'm pretty sure Ken Thompson had a regex implementation that JITted to native code by the late '60s. I'd have to look back on text editor history to be sure though. The idea wasn't *new* when Smalltalk did it in the early '80s, but that's the oldest really popular language I can think of that did so.
I use it like so: my $xmls = XML::Simple-&gt;new( RootName =&gt; undef, KeepRoot =&gt; 1, ForceArray =&gt; 1, ForceContent =&gt; 1, ); Then I'm not surprised when something is either a scalar or ref depending on whether one or multiple of them appear in a particular XML response.
&gt; I thought that Sobrique gave a truly excellent description of why on that page. They also asked the question :/
Very nice. One things I've always wanted to do was rewrite Advance Programming in the UNIX Environment, but with PERL examples.
I actually really like XML::Simple. I just make sure whoever I'm interfacing with doesn't expect their tags in a specific order, i.e. xs:all instead of xs:sequence
The watermarks are more like footers. Non-intrusive.
Thanks for the info.
Yeah, I know. Actually I'm enjoying getting into python, it's just I'm missing some patterns I use. What I'm encountering are python features that are designed to "prevent" things. I can work around them, but it slows me down. On the other hand, no braces or semicolons - that is starting to grow on me. EDIT: sorry I forgot. I can't find the link, but when I wanted to do the array thing my search took me to stack overflow where someone said to pre-declare the array like this: `a = [0 for in in range(40)]` instead of just using it. I thought perl was more accepting. 
Need some assistance. Im still not able to receive the email. I am having errors: 530 5.7.0 Must issue a STARTTLS command first. p3sm7922574oei.9 - gsmtp. Not sure at this time where the command: STARTTLS will be placed. C:\Perl&gt;email04.pl Net::SMTP&gt;&gt;&gt; Net::SMTP(2.31) Net::SMTP&gt;&gt;&gt; Net::Cmd(2.29) Net::SMTP&gt;&gt;&gt; Exporter(5.67) Net::SMTP&gt;&gt;&gt; IO::Socket::INET(1.33) Net::SMTP&gt;&gt;&gt; IO::Socket(1.34) Net::SMTP&gt;&gt;&gt; IO::Handle(1.33) Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 220 smtp.gmail.com ESMTP p3sm7922574oei.9 - gsmtp Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; EHLO localhost.localdomain Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-smtp.gmail.com at your service, [68.109.82.88] Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-SIZE 35882577 Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-8BITMIME Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-STARTTLS Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-ENHANCEDSTATUSCODES Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-PIPELINING Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250-CHUNKING Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 250 SMTPUTF8 Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; MAIL FROM:&lt;islandcoffee4u@gmail.com&gt; Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 530 5.7.0 Must issue a STARTTLS command first. p3sm7922574oei.9 - gsmtp Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; RCPT TO:&lt;islandcoffee4u@gmail.com&gt; Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 530 5.7.0 Must issue a STARTTLS command first. p3sm7922574oei.9 - gsmtp Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; DATA Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 530 5.7.0 Must issue a STARTTLS command first. p3sm7922574oei.9 - gsmtp Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; From: islandcoffee4u@gmail.com Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; To: islandcoffee4u@gmail.com Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; Subject: This is a test Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; . Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 502 5.5.1 Unrecognized command. p3sm7922574oei.9 - gsmtp Net::SMTP=GLOB(0x26c0a1c)&gt;&gt;&gt; QUIT Net::SMTP=GLOB(0x26c0a1c)&lt;&lt;&lt; 502 5.5.1 Unrecognized command. p3sm7922574oei.9 - gsmtp
The Perl on that site is never particularly high quality (as the author freely admits), but this time he has excelled himself. None of the programs even compile. There seems to be huge chunks of code that have gone missing somewhere in the publication pipeline.
Perl is more accepting, but therefore more treacherous as well. I'll take Python's OOP implementation over anything Perl did for OOP. One big advantage to perl is the ability to write one-line commands in a terminal for text processing. 
I've little doubt those footers can be removed with a Perl script after one has read the book, so think of it as an exercise ;-) I am very happy with my free "Prepared exclusively for xxxxx" edition. Anyway, going to buy the real thing as soon as it's available on Amazon (it's still listed as January 2016).
When you [create one](https://wiki.debian.org/IntroDebianPackaging)?
How do the alternative clients handle this case? Mojo::UserAgent, HTTP::Tiny, etc.
These are the sorts of things where REST advocates made a great point. HTTP already has error codes that are handled very easily by clients. Why complicate things in the response body?
While in general I agree with my above comment, in this case I might have been a little quick to condemn. I missed that the X-Died header is sent internal to the LWP code and yet LWP's UserAgent doesn't interpret that as failure. Yes that should probably be fixed (one way or the other).
I've always assumed that HTTP "success" is the TCP request worked, the server responded with _something_ and a 200-ish code. Anything else is on me, the client, to figure out. 
That's generally how I would see it too
I agree. I am going to buy the book as well.
Why would the TCP status information be duplicated at the HTTP level? HTTP is an application protocol â€“ not a transport protocol.
To be clear, I've never expected the UA to parse a valid response body and then examine the content for success or failure messages. That's my job. What I wanted to clarify is that `X-Died` might be set silently at some point before you get the response object back. If you don't explicitly check for it or (worse) if you aren't even aware that this header could have been set on a 2xx response, it can be a real head scratcher.
That's fine for expanding on the issue, but `is_success()` can easily do the right thing if you use a sensible error code first.
I've been bitten by LWP::UserAgent within Frontier::Client (XML-RPC). What I've seen is that even though I specify a timeout value LWP::UA can and will use a select() with no timeout. This has nailed me on poor IP connections. Where I've seen it is one my devices that use a PPP over modem connection in a demand configuration. The pppd daemon is running with the demand option and an idle value of 60s. That select() will basically pause that script, the modem drops, and the script will never continue past the select(). I've strace the script and you can see a select() with the timeout then someone (LWP) calls another select() with no timeout. To fight this I've implemented alarm() within my Perl Module that is a XML-RPC client.
A quick Benchmark of your RegEx vs looks_like_number Rate REG LLN REG 3113701/s -- -84% LLN 19435213/s 524% --
The language hasn't changed much since 2003. What has changed is the way people use it. Based on a quick scan of the book, it doesn't look too bad. You could also read [Modern Perl](https://pragprog.com/book/swperl/modern-perl-fourth-edition) after, or instead.
While the core of the language hasn't changed, what's considered the best way to do some things have changed. For example, many Perl developers no longer use Perl's built in OOP and use Moose instead: http://moose.iinteractive.com/en/ The Modern Perl book has an introduction to Moose and the book the OP linked would not. I would suggest reading Modern Perl instead of Perl the Hard Way.
Those images make it extra professional. Can someone explain to me how it is better to load a module than do something like `my @topfive = ( grep { /^[A-D]/ } @all_names )[0..4];` or why that pattern is bad?
Is it common (or efficient?) to have arrays with 1e6 elements? Are there better data structures for that kind of data? edit: Also, good to know that there is some overhead to accessing an array like that.
I'd also add that it is likely more intuitively readable, especially to those newer to Perl
I'm not a fan of complicating and abstracting things for intuition. If you adopt this module simply for the more intuitive form (which I don't particularly find more intuitive, but I've been hacking perl for a while), then you add a dependency of grabbing and installing this module, for little / no benefit.
It doesn't create an index list in that situation, fairly sure.... $ time perl -E '@_[0..1e6]' real 0m0.156s $ time perl -E 'map {}, 0..1e6' real 0m0.349s The above works on a machine with 255MB of memory using essentially perl -E '' levels. It's using a range basically like the Perl 6 equivalent: $ time perl -E 'map {}, 0..1e100' Range iterator outside integer range at -e line 1. That the module is on CPAN and needs to be built with XS for such a simple bit of syntax relief makes it really not worth it IMHO. Anyone who doesn't know (or can't guess) what @list[0..3] does but can work out head 4, @list probably shouldn't be hacking on your code base in the first place. Anyone competent and new would just ask if the expression looks a bit nuts. Then they learn. In Perl 6 you get @list[4..*] which at least to my eyes is nicer for the tail case. 'Whatever' syntax for slices in Perl 5 would be fairly awesome.
The non-greedy modifier just means that if you have the choice between matching a lot or matching a little, all else being equal, choose to match a little. That's not the case here. Because you ended your regex with `$`, there's no way for `".*?"` to match anything but `"toto" add "HTTP"` in the case of the second and third examples, so the non-greedy modifier is completely irrelevant (i.e. there's no choice between matching a little and matching a lot; matching a lot is the only option.) There's no way that `".*?"` is going to match just `"todo"` because then the whole regex would fail due to `$` not matching. Again, the non-greedy modifier just says "try to match as little as possible if you can", it does not mean that matching everything possible it still not an option if it means it will make the overall regex match. If you want to match a single quoted word, you don't want the non-greedy modifier, you want something like `/"[^"]+"/` . That says match a double quote, then one or more non-double quote characters, then a closing double quote. That will never match `"toto" and "HTTP"`, it will only ever match `"toto"`. 
Unrelated, but Reading this made me recall this odd perlism to return references to slices. http://www.perlmonks.org/?node_id=618917 I have used it before when memory footprint was a huge deal and I needed references to everything while working with portions of an array due to iterating them lazily with closures.
Looks like a variation of permutations generator problem. Usually you can solve it using generator functions. Create a generator function for each key in the original hash, then iterate through them.
In addition to the reasons others have stated, `$` means "end of string" not "end of line". In order for `$` to mean "end of line", you need to use the `/m` modifier. m Treat string as multiple lines. That is, change "^" and "$" from matching the start of the string's first line and the end of its last line to matching the start and end of each line within the string. ( It wasn't clear to me from your description if you were working with multi-line strings or split-strings on a line-by-line basis ) 
Alright I think I got what you are saying... I need a generator function to return elements of what would be the top level array. so If my data is { 'a' =&gt; 1, 'b' =&gt; [2, 3], 'c' =&gt; [4, 5], } My generator should return { 'a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 4, } at the first iteration and { 'a' =&gt; 1, 'b' =&gt; 2, 'c' =&gt; 5, } { 'a' =&gt; 1, 'b' =&gt; 3, 'c' =&gt; 4, } and { 'a' =&gt; 1, 'b' =&gt; 3, 'c' =&gt; 5, } at subsequent iterations. And it will have to have some sort of recursion, because I don't know how many arrays there are. And my arrays and hashes are nested inside each other with like 150 keys in some hashes. Wow, I just realized this approach will result in a whole lot more data than I anticipated. I need to rethink my plan. I think I should be normalizing my staging tables instead of trying to denormalize my incoming data. Thank you for your answer, it was most helpful for me.
Thanks for responding, I agree that installing dependencies can be a pain but personally I've found the Perl module ecosystem to be the best developed and one of the easiest to use among all programming languages So my personal view on this, is if I'm not going for zero dependencies to make something completely standalone bar perl and I'm not writing for some sort of embedded system then I'll happy install a dependency even for just for the head / tail functions mentioned in the article When I next need to use this pattern I will very likely install and use this module
Doesn't this actually require a cartesian product or cross product? There's several modules on cpan for that.
Reminds me of [this](https://metacpan.org/pod/Data::Alias) which is more useful before the magic of 5.22
Not really pretty, but generalized to cycle through any number of array of arbitrary length: use strict; use warnings; use List::Util qw(max); use Data::Dumper; my $data = { 'a' =&gt; 1, 'b' =&gt; [2, 3], 'c' =&gt; [4, 5, 6, 7, 8], }; my $max_len = max map scalar @$_, grep ref($_), values %$data; my @result; for my $idx (0..($max_len -1)) { my %temp; while (my ($k, $v) = each %$data) { if ( ref $v ) { $temp{$k} = $v-&gt;[$idx % @$v]; } else { $temp{$k} = $v; } } push @result, \%temp; } print Dumper \@result; Output: $VAR1 = [ { 'b' =&gt; 2, 'c' =&gt; 4, 'a' =&gt; 1 }, { 'a' =&gt; 1, 'c' =&gt; 5, 'b' =&gt; 3 }, { 'b' =&gt; 2, 'a' =&gt; 1, 'c' =&gt; 6 }, { 'b' =&gt; 3, 'a' =&gt; 1, 'c' =&gt; 7 }, { 'c' =&gt; 8, 'a' =&gt; 1, 'b' =&gt; 2 } ]; 
&gt; It all kind of just mashes together in the first item returned. Yes, that's the expected behavior. Read [`perldoc perlsub`](http://perldoc.perl.org/perlsub.html): &gt; The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you'd like. (Often a function without an explicit return statement is called a subroutine, but there's really no difference from Perl's perspective.) . &gt; I also tried sending it by reference but the same thing happens. From the standpoint of someone asking for help, this sentence is useless. How are we to know what's wrong with what you tried if we don't know what you tried? Post a testcase. Here's an example: #!/usr/bin/env perl use warnings; use strict; sub foo { my @arr = (1, 2, 3); my %hash1 = (a =&gt; 10, b =&gt; 20); my %hash2 = (x =&gt; 30, y =&gt; 40); return \@arr, \%hash1, \%hash2; } my ($aref, $href1, $href2) = foo(); printf "%d %d %d\n", $aref-&gt;[1], $href1-&gt;{b}, $href2-&gt;{x}; # 2 20 30 This is rather clunky, though. I wouldn't expect many APIs to be designed like this. If you have multiple things to return, consider just returning a hash that contains everything under different keys. 
Hrmmm, @output = map {...} head 2, sort {...} head 100, map {...} tail 1000, grep {...} @input; You'd rather have a bunch of nested `(...)[0..X-1]` than that? 
Frankly? Yeah. What you have there is a pretty complex ... something. And I would prefer seeing it written as multiple lines.
Yeah, you'll have an explosion of table rows if you go with this approach. Better to keep it compact if you can!
Is that all of your code? I ran it and it told me $_ is undef (use warnings) If I define a $var and run against that, then LLN is still a clear winner my $var = 'this'; cmpthese 20000000, { REG =&gt; sub { $var =~ /\D/; }, LLN =&gt; sub { !looks_like_number $var; } }; Rate REG LLN REG 5934718/s -- -52% LLN 12422360/s 109% -- I've run a bunch of different types of tests and so far I have not found a scenario where a RegEx beats looks_like_number
the article makes it sound like this is a recent development, but Image::Scale was released 5 years ago. Plus, it's making a conclusion to use that module when it only compares it against GD for api and benchmarks. There are many other perl solutions for image resizing that are not mentioned, even in passing (correction: a couple are linked in the SEE ALSO section on the module page): * Imager * Image::Magick / Graphics::Magick * Image::Epeg * Image::Imlib2
The implementation is so simple it probably would have been a good candidate for inclusion in List::MoreUtils.
Not to mention PDL. 
But there are easier ways to slurp a file: my $string = do { local $/; &lt;$TXT&gt; }; Or: use Path::Tiny; my $string = path('somefile.txt')-&gt;slurp;
Can you explain why these are preferred? Edit: Just looked into `do {}` and `local $/`. You're a god damn wizard. Is it actually more efficient to do it that way since you don't have to iterate through `while` a bunch of times?
&gt; I'm not entirely sure what you're getting at with the nested bit. I see you provided an example of what you want the data structure to look like in your other post with 'Apples' containing another hash. Can you give an example of what the text file you'd be reading would look like? Hi there,.. My text file is indeed quite small. Less than 15 lines. I actually don't mind using the regex method at all. The people using this script aren't perl saavy and are afraid to open and edit my script to provide the params, and when I gave them the option of passing them as long command line arguments, they keep making mistakes in the order of how they give the params and end up not running it as required to. As for how my text file should look like, It would be a plain text .txt file, there will be no spaces between the equal to (`=`) sign for key and values. What is to the left of the `=` sign is the key name, and right has the value. Now as for the nested hash, I doubt myself how to give that, I imagined to make it like this, but I also have doubts if whether I should be using a fat comma (`=&gt;`) symbol or `{}` to indicate `Apples` is supposed to be my sub tree or nested hash (Apples) in the parent tree %fruits, but this is what I came up with, tell me what you think if it is parsable by your regex (after reading it to the hash, I also have to print it on screen to let the user know that I read the key/values they provided as such etc.. : Banana=4 Orange=2 {Apples}=( Red=3, Green=6, Yellow=1) {Water_melon}=( Green=1, Orange=2) Apricot=4 So, that's my text file. :-/. Well, I don't like it to be honest the way I gave, and please feel free to simplify it if its possible at all for your regex, I gave the sub trees `{Apple}` and `{Water_Melon}` in curly braces (still have doubts giving it that way), and the key/value pair inside I gave it separated by a comma `,`. Every key/value pair is separated by a new line except when it's a nested hashs key pair. Is that complicated? Any suggestions to simplify it? Unless you have a better more simpler way.. let me know. As for how my hash should appear, it doesn't have to print or store them in order, as you know hashes don't preserve order, this is how would write it if I were to give or write the hash inside my script and not read from a .txt file. %fruits=( Banana =&gt; 4, Orange =&gt; 2, Apples =&gt;( Red =&gt; 3, Green =&gt; 6, Yellow =&gt; 1 ), Water_melon =&gt;( Green =&gt; 1, Orange =&gt; 2 ), Apricot =&gt; 4 ); Now, since I cannot give values to my hash `%fruits` inside my script (my users are afraid/make mistakes when they write the hashes), I thought of giving it as the above .txt example I have shown you. What do you think? Also, one more thing, I also need to print the hash back to the user after all values are successfully taken/stored to the hash `%fruits`, and I would be using this method for that. my ($key, $value); while (($key, $value) = each(%fruits)){ printf("\t %8s --&gt; %3s\n", $key, $value); } I am sorry if I made it sound un-necessarily complicated, I am just having a hard time explaining my need exactly.
hmm,.. if I can use `Path::Tiny`, I'd prefer that too /u/davorg. It seems easier to write the code that way. Not sure if it would be easier to read my .txt, i don't know how `path()` can read a nested .txt file.
Ok. This is a bit more tricky. The method I gave is useful for building a single hash. The regex takes a key and a value from each lineand returns those in a list. Boom, a hash is born. Your situation is a bit more complex because the text file you're reading will have key/value pairs, and key/list pairs. Here's what I would suggest: 1) Your users are going to be writing this file, so keep it as simple as you possibly can. You need this to be idiot proof. Avoid using any curly braces or fat commas in there. Users see that sort of thing and get intimidated. Design the structure of your text file first, with your users in mind, before you write any perl at all. 2) Familiarize yourself with references and complex data structures. This can be weird and counter-intuitive at first but once you really understand it your perl life will become much easier. The big thing to remember is that arrays and hashes *never contain anything except scalar values*. So when you put a hash inside a hash, you're actually putting a *reference* to a hash inside a hash. 3) Once the above is done, you need to figure out how to parse it. This shouldn't be *too* painful, but it's going to be more complicated than the one-liner I gave above. For each key (Orange, Apple, etc.) you'll need to come up with a way to tell if that key will hold a value, or a reference to a hash. Once that determination is made, you can parse the text accordingly until you hit the next key. 4) For bonus points, come up with a way to tell, up front, if the text file being fed to your script is in the proper format. If it's malformed in some way throw it back to the user and tell them to try again. 
How many? How are you using them?
Nice,.. this is awesome. ah, for now it's working, but i will change my script tomorrow, and experiment with YAML, and print out a new instructions sheet for the techs to follow. THank-you for writing, responding.
I see. Hm. yep, that's a nice approach too, didn't think of that at all.. I'll give it a try. Thanks for responding, helping :). 
If I wanted a nested hash, then I'd use YAML or JSON as the file format.
But what does it even do?
It looks like it does the same thing as Test::More/Test::Builder, but with more modern internals. And nicer diagnostics on test failure.
Your attempt at analogy is not terribly accurate. Python and Ruby each have separate implementations that will run in the jvm. Perl 6 does not exist as a stand-alone interpreter â€¢at allâ€¢. Rakudo can run on the jvm (needs work there still) Its current best implementation is on a custom VM called MOarVM written specifically for P6. 
Yes, it would. I'm not sure the distinction is actually as meaningful as detractors like to infer, though. ðŸŒž
The internals have been greatly improved. The main motivation of Test::Stream was to help people who write testing tools. People who are simply writing tests may not notice much benefit at first, but once toolmakers can make better tools because of the new internals everyone should benefit.
It would be nice if it would export the Test::Fatal version of "exception" as well as "dies" so that people who used Test::Fatal could run things without modification. With the code now, if I remove "use Test::Fatal" from the test file it makes the exception {} method die normally. It's possible it undefines it entirely, but use strict/warnings didn't complain so it seems more likely it makes it an empty method. I tried this: use Test::Stream -V1; use Test::Fatal; And I get warnings from Test::Fatal because $Test::Builder::Level is undefined (not exported by Test::Stream since you aren't based on Test::Builder I guess) Here is a test example of what I mean: use strict; use warnings; use Test::Stream -V1; ok(!dies { exception { die "hello" } }, "exception should trap die"); use Test::Fatal; # pull in Test::Fatal version of exception ok(!warns { exception { die "hello" } }, "exception should not warn"); done_testing();
I've never used NYTProf in mod_perl because, well, it's 2015, but it claims to be simple to use: [Trivial to use with mod_perl - add one line to httpd.conf](https://metacpan.org/pod/Devel::NYTProf#Apache-Profiling). Now, if you need to do that in production there are of course a host of other considerations and problems to deal with. 
I intentionally chose different names, specifically so that people could use Test::Fatal without conflicting sub names. However, using Test::Fatal is apparently not an option until the Test::Builder conversion is complete. I am surprised Test::Fatal has any deps on Test::Builder::Level, you might file this as a bug on Test::Fatal.
somewhat tangential but if you add no indirect; then I think that'd give you a complaint along the lines of Indirect call of method "exception" on a block see https://metacpan.org/pod/indirect for more details. and yes, this is a case of "remember to add this line to make sure you didn't forget to add another line", so it's not perfect!
Agree with most things on Perl 6 but your post is also pushing old old FUD about Perl 5 which is bad: &gt; "Python is great because it is really similar to Perl 5, but it has object orientation in the base language and not bolted on clumsily." I dunno given in early Python 2 you have new and old style classes, no clean overloading of methods, no true private attributes/methods with method name mangling for inheritance... I'd say it's fairly bolted on or at least clumsy too. Perl 5 has had the same level of OO in the "base language" since before Java even existed (to give some point of reference), it's just you can have more advanced features with [Moose](https://metacpan.org/pod/Moose) and friends. The Moose extensions also bring Perl 5 quite close to the same level of features as the Perl 6 object system, which is really quite impressive given it's not part of the core language. Stuff like [Moops](https://metacpan.org/pod/distribution/Moops/lib/Moops/Manual/Objects101.pod) or even [Dios](https://metacpan.org/pod/Dios) gives you clean syntax support, so not sure how it feels bolted on then either? I agree with the sentiment in a more general way which is why I'm using Perl 6 regularly since the OO is a lot deeper throughout the whole language, which is something Perl 5 does lack.
I hadn't really looked at it that way, so thanks for pointing it out! I guess part of the weirdness with P5 is that you're using an external module for very base features. I suppose that is more of a philosophical concern than a practical one though haha.Thanks for pointing out the weakness in my own argument. I'm glad to hear you've been using P6 regularly. It is nice that some of the perl community decided to make such a fundamental change to get to P6. Python from 2.X to 3.X doesn't give us a huge amount besides Unicode support and removing a few warts, while majorly fragmenting the ecosystem.
A major conception of OO was for it to be extensible with a deep meta model from user code. That many popular OO languages *dont* allow you to gradually alter the semantics and syntax with time via your own code is the aberration. There are a lot of [fun Alan Kay talks on YouTube](https://www.youtube.com/watch?v=oKg1hTOQXoY&amp;t=740) to get a sense of the original plan. It's kind of sad there aren't really many languages in mainstream use that are working towards some of those ideas. It feels like Perl 6 is trying. In that linked video Alan Kay uses life as a good example of a computation that never stopped and never had problems with adoption of change and scaling up. That languages have a crisis of version with implementation details changing is a mostly solved problem from the philosophical and design side. If I went back in time about 100 years most people would understand my English if I went back 1000 years it would be a lot harder. At no point did everyone stop learning middle English and start learning "Modern" English. Computer languages need to evolve rather than change version.
There was an initial article about that. This is a second follow up article addeessing some questions that came from the first.
&gt; I suppose that is more of a philosophical concern than a practical one It is a practical one, since it means few people are doing active work to improve Python OO, add new features and such, while Perl OO is continuously getting more powerful. For example in Python you need to put extra logic attached to attributes into __init__, which means sharing an attribute and its logic between different classes is not so easy. In Perl you just write your attribute and ALL its logic in the has(); instruction, put that into a role, and suddenly you have one logical unit that you can just tell classes that need it to consume: https://metacpan.org/pod/distribution/Moose/lib/Moose/Manual/Roles.pod#WHAT-IS-A-ROLE
I don't have any hard numbers as this was from a job about three years ago that I left my code with. I recognize that none of my anecdotes may be valid any longer anyway; I haven't really kept up with the pace of either Perl or Python development in the meantime. However, my experience/recollection was Perl parsing out a million unique plaintext database entries ~300 lines long into a flat file in about seven seconds; it took a comparable Python script closer to a minute to do the same. I've always had the impression that PyPy was a bit laborious to set up; that might be mistaken now, but I'm almost certain that was still the case when I was at that particular job. On top of that, I was also working at a really big company with a moderately overworked IT department who were pretty draconian about allowing new software installs on their Linux boxes, as it meant they'd be the ones responsible for anything breaking or changing due to new software. Long story short: didn't have the option to use PyPy, probably wouldn't have bothered with the setup if I had. 
It sounds like we're almost agreeing on that although you're saying it was more preconceived in the user's eyes due to marketing than reality, but I'm willing to bet there is some truth due to the current state of numbers. Thanks for the explanation on the success of implementing new features with respect to backwards compatibility. It's nice that it is designed for the power user.
When perl6 is included in all major distros and you can expect to find it on every system by default like perl5 is now, then I will maybe use it for something. 
If you install the 'Linenoise' module the default Rakudo REPL is quite a bit better. You get it by just running perl6 with no arguments. Nothing near ipython yet though.
Without seeing the code, I'd suggest it's a call to the database using DBI, and the person who wrote it grabbed the sample code, which demonstrates the return of ( mostly ) the number of rows. I wouldn't be surprised that it's not checked or used anywhere. In the context of your program, the data is probably used immediately after, so that regardless of the value if the call fails it'll be caught soon enough ( e.g.: A foreach loop around the hash key in a fetchall_hashref won't happen because it's empty since no rows came back ( $rv = 0 ) ). ( WRT Java, in Eclipse, you're warned about unused variables, so something like this usually wouldn't get checked in even though it's harmless... ) 
Special variables are documented in perldoc perlvar: http://perldoc.perl.org/perlvar.html $rv is not a special or reserved variable, but it is a somewhat common name for a "return value" variable. But, if it isn't being used, it's probably an indicator of a bug waiting to happen. Turn on strict and warnings to help spot these kinds of issues at compile time. In short, yes, it is a naming convention, but not being used is a code smell that should probably make you wary.
imho, the only thing lacking in perl is native concurrency/parallelism, and lack of robust/efficient compiler I understand p6 addresses one of those concerns, but sadly (correct me if i'm wrong), you need to install perl and modules on your target environment to run a perl prog yes, i know there are tools to compile perl .. but my experience has been one of if you are lucky enough not to the the compiler to barff, it creates code that is way slower than the natural vm-based prog. 
&gt; it not confusing that it is constantly in flux? who are you talking about right there? just look at python 2 vs python 3 ... and btw, the tioowtdi mantra is a load of bollocks. i;ve seen wildly different ways of tackling problems in python too. i'm not saying that's bad ... just saying i wish pythonistas would pull their heads in when they feel like mentioning tioowtdi and "all batteries included" nonsense. 
Neither strict nor warnings would flag an unused variable?
The [CPAN Pull Request Challenge](http://cpan-prc.org/) would probably be a good place to start.
You can always check the issue tracker for your favorite modules, too. Or go crazy and start porting things to Perl 6 &gt;=) I'm involved in a content management system project (large, mature existing system that wasn't previously as easy to set up and run as ones in other languages) and we can always use help. It needs polish. I made a Docker image of it but it's having some strange bug in there, etc, etc.
Recently I've been working on optimising a largeish Perl codebase while watching how the JVM gets tuned from afar at the same time. What really like about optimising Perl is you get to concentrate on the symbolism of what you're trying to achieve. Java tuning by contrast is a very technical enterprise quite far removed from what you're actually trying to achieve. 
Iâ€™m not sure that I can give a satisfying answer but - though â€oldishâ€ - this talk by Paul Fenwick gives a lightweight introduction to a lot of newer modules/tools in a much clearer way then I can hope to (the sound is not the best at first but I think it is worth watching): https://www.youtube.com/watch?v=vgvMd4nuHTg On a more personal note, some of the improvements I like are: * Some of the new features to Perl 5 itself, for instance: â€œsayâ€, â€œstateâ€œ, â€œ//â€ (defined or operator), named captures, subroutine signatures ( for 5.20 and newer ) . I find all of these to help make common tasks cleaner. * New tools like cpanm and metacpan.org: Nice tools for finding and installing modules; having recently used npmjs and npm I have come appreciate the quality of CPAN. * New modules/frameworks: There are many but I have to mention Moo/Moose (object system), Mojolicious (web framework). Mojolicious is not the only game in town, but being able to start out quickly with a small single file web application â€“ just to test things - and then grow that into a structured application or simply embed a webserver and ship it as a small standalone app for some small custom job makes it really nice. For a Moose introduction I would recommend watching this really well made talk by Ricardo Signes: https://www.youtube.com/watch?v=LKXvG6VKew4 Not to paint to rosy of a picture I agree with jjolla888 that one area where Perl 5 is lacking is concurrency/parallelism. Writing threaded things in Perl isnâ€™t fun at all (or at least Iâ€™m too stupid to make it work). 
It'll catch undeclared and redeclared variables. If it's a leftover from a re-factor, rather than an unintentionally unused variable, it'd catch it. There's the "all is fair, if you declare" guideline for variables and strict/warn, but this is still a code smell.
your code works for me. using that reddit url and your exact syntax except changing the $xxsv assignment to a print to see where it falls.
Works ok for me: perl -w -E 'my $url = "http://www.reddit.com/i/some/thing.jpg"; if ($url =~ /\/i\//) { say "items";} else { say "albums";}' items perl -w -E 'my $url = "http://www.reddit.com/some/thing.jpg"; if ($url =~ /\/i\//) { say "items";} else { say "albums";}' albums How's it failing for you?
&gt; No, that is 100% due to marketing. Come on! Don't be obtuse. I am a Perl fan but dismissing other languages' success as totally due to "marketing" is ridiculous.
Thanks for these!
I usually contribute with pull requests or issues in modules where I found something that bothered me. Or sometimes if I'm looking for a module to use in a project I'll check the open issues for modules I research and see if I can help with some of them. Tangentially: CPAN's RT seems to be a wasteland. For some reason people tend to not close issues even when they're completed (or stalled/wontfixed/etc), which means the issue list can be daunting on some projects. I don't know how to encourage people to clean up their queues, but in some cases it's something that only takes a few minutes and can really help with keeping a project current. With that in mind, I also think RT could use a few new features to make it more usable. Markdown support for tickets would be great, as well as a mobile-friendly interface.
Thank you, I learned something new today and it helped me out in a big way! Thanks so much!
Thanks for the suggestions, everyone! I'll check out your suggestions after my tests this week.
Would giving away the remaining copies of the [Parrot Developer's Guide](http://onyxneon.com/books/pir/index.html) count as corrupting the youth?
I really doubt it. You are almost certainly going to have to build up the C++ data structure yourself. Think about the explosion of types and conversions that would be needed to automatically handle every nested C++ STL container across all the native types.
From your example, SWIG apparently automatically generates code to try and rebuild a perl list as a flat std::vector. You have to understand that there is piece of code rebuilding the entire list as a vector. The two structures are completely different things in memory. Your comment about pointers and sending things "directly" makes me think you don't realize the vector is getting built up as a new thing every time. For things more complicated than a std::vector of integral types you have to do the conversion yourself without help from SWIG. It *is* possible to work directly with perl lists and hashes from C++ code using the perlapi. If this is C++ code you control that approach may be sensible.
Apparently the blog's comment employs the "typing-on-a-phone-look" filter which removes all dots.
It not being on CPAN massively diminishes its chances of being noticed, left alone being used. For many power users (and a profiler is arguably a power-user tool) the lack of a POD page in a familiar sco/metacpan rendering and lack of a CPANTesters matrix to look at directly translates to "another time, tuits are short". 
Compiled perl code is slightly slower to start than interpreted code, but runs at the same speed.
Matt Daemon!!! http://search.cpan.org/dist/Acme-Matt-Daemon/lib/Acme/Matt/Daemon.pm
What, no mention of [Acme::Bleach](http://search.cpan.org/~dconway/Acme-Bleach-1.150/lib/Acme/Bleach.pm)? Or [Acme::EyeDrops](http://search.cpan.org/~asavige/Acme-EyeDrops-1.62/lib/Acme/EyeDrops.pm)?
[Tie::Hash::Cannabinol](https://metacpan.org/pod/Tie::Hash::Cannabinol)
(author here) Honestly, I was going to add that one, but decided that Bone::Easy was as far as I was willing to go on a corporate blog.
(T::H::C author here) I was slightly disappointed to see that it wasn't in your list :-(
Are you sure you're a shorty??? I have to crick my neck up when I see you at conferences! (I'm down here at 160cm (5'3") *grin*)
There's [one module we use at my work](https://metacpan.org/pod/AutoRole) that does a delay-load, but it involves adding a dependency: use AutoRole class =&gt; 'Carp', how =&gt; 'autoload', methods =&gt; [qw(carp croak)]; 
Well if you only want to process the first hash you don't need a for loop, you can just access it directly `$network_details-&gt;[0]`. my $network_details = $client-&gt;call('system.getNetworkDevices', $session, $serverid); my $network = $network_details-&gt;[0]; my $net_ip = $network-&gt;{ip}; .... 
Try this: my @network_details = @{ $client-&gt;call('system.getNetworkDevices', $session, $serverid) }; my $first_interface = shift @network_details // {}; delete $first_interface-&gt;{ipv6}; my $second_interface = shift @network_details // {}; delete $second_interface-&gt;{ip}; # do the rest here In the first line, I dereference the arrayref into an array again, for easier handling. After that, I shift the array (removing the first element from @network_details) and assigning it to $first_interface and delete the ipv6 key. Then, I shift again (removing the first element from @network_details, which is now the original second element since the first was already removed) and delete the ip key. The // {} assigns an empty hash reference if the interface is not defined.
Try this: my @result = (); for my $val ( @$stuff ){ for my $hash ( keys %$val ){ next if $hash eq 'ipv6'; push @result, $val-&gt;{$hash}; } last; } print Dumper(\@result); $VAR1 = [ 'xxx.xxx.xxx.xxx', 'eth1', 'vmxnet3', '255.255.255.0', '00:50:56:88:08:19', 'xxx.xx.xx.xxx' ];
I would add Higher Order Perl to the list. 
&gt; Is the import expensive so people try to bypass it for speed? Yes... or at least it was considered so back in the old days. Those where the same days when CGI.pm decided it would be a great idea to keep most of its functions in the `__DATA__` section and not actually compile them until somebody tried to call them, because otherwise the (time and memory) overhead of compiling all of those functions would be excessive, and the days when half the guts of Exporter were put in a separate module that's only loaded at runtime if its features are demanded. Today, that kind of thing isn't worth the complexity it introduces, and Carp isn't all that large, but some people either disagree, or else are copying a tradition they don't really understand.
As someone who is a student in security, those type of shows piss me off to no end. It's not just blindly typing crap into a black and white screen. 
Now someone could download and post a link to a share that could take front page traffic, someone else could best of it, it can then make it to the front page and then someone can write a wired article about it. Now, let's see it in Perl 6. 
So the idea that some shadowy figure spent insane amounts of time tattooing cryptic designs onto a mysterious woman's body then dumped her in Times Square didn't make you blink, but the open source thing, nuh-uh. Got it.
nice work, feels like some of my current problem.
Modern Perl just put out a new edition and Beginning Perl is the answer to why Learning Perl comes off so shitty nowadays, so I would keep those.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [Automated refactoring of perl with PPI (long) (x-post \/r\/perl)](https://np.reddit.com/r/programming/comments/3ruwbv/automated_refactoring_of_perl_with_ppi_long_xpost/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
That'll be a silent no Â¯\_(ãƒ„)_/Â¯ Thanks all the same
Ah, good catch. Didn't notice that :)
`sanity.pm` is more "irony" than funny. Because there's nothing sane about it, and you might find your sanity leaking out both of your ears while you cry black tears if you try working out what it does and how it works.
It turns out, `PDF::Reuse` had issues with the original documents downloaded from USTR's web site. I had to split each document into additional files (one per page), and then combine them into a single document. [Details on my blog](https://www.nu42.com/2015/11/combine-tpp-single-document.html).
Thanks! This is very handy, though maybe not in line with the use case (which may just be the wrong approach altogether) I have where some users have restricted access and wouldn't be able to execute the perl application under the debugger. They would only be able to check the logs or change the config to enable tracing (like trace =&gt;1 or whatever). I suppose I could have a wrapper, parent script that could run it with the debugger non-interactively.
Aha, I see now. Thanks again.
Nice! Any idea what you're going to tackle next? I was looking at rewriting a script for work in Perl 6 but I can't seem to find a suitable Net::FTP replacement. Unless already it's out there and my google is failing me. *I misspoke, evidently there is a New::FTP.
I found in the source of DB.pm how they handle all the return cases if wantarray is defined or not. https://metacpan.org/source/RJBS/perl-5.22.0/lib/DB.pm sub sub { push(@stack, $DB::single); $DB::single &amp;= 1; $DB::single |= 4 if $#stack == $deep; if ($DB::sub eq 'DESTROY' or substr($DB::sub, -9) eq '::DESTROY' or not defined wantarray) { &amp;$DB::sub; $DB::single |= pop(@stack); $DB::ret = undef; } elsif (wantarray) { @DB::ret = &amp;$DB::sub; $DB::single |= pop(@stack); @DB::ret; } else { $DB::ret = &amp;$DB::sub; $DB::single |= pop(@stack); $DB::ret; } } 
I think it might be kinder to say that the perl toolchain gang is more conservative than some people would like, or less coherent. I've occasionally sent patches or opened tickets and not heard anything. They were generally feature requests or low priority bugs so it was sometimes possible to patch/hack around them, or in some cases it was easy to ignore it and put it on the backburner for later. It can be frustrating or demoralizing to try to contribute and be ignored though. For some people it might even be unexpected if they're new to perl. They might have come from a community that has active rapid development with social coding, where dialog happens through issues/pull requests and code can be turned around in 24hrs. I'm personally content with the code being on github. People can look at changes and merge when they get around to it.. it's much better than mailing list managed patches like some projects I contribute to. EUMM is being used by too many projects to be broken right now. If someone is proposing a big change they should fork it for a while and play around with it. They can pull down lots of CPAN and make sure it still compiles when they're done with the changes, then request it be merged. If it's still not being merged but it provides huge benefits then maybe people will switch to the fork (most people would wrap it with something like Dist::Zilla anyway) 
I always do that on every system I encounter. It's easy, and it allows me to have a different version of CPAN than the OS.
What /u/ibleedforthis said, plus maybe a touch more Unixy stuff. If there are specific tasks that you're performing, create setuid scripts to do them for you. See the chmod man page, and perldoc perlvar for $&lt; and $&gt;. A setuid script or program runs as another user than the one that ran it. This lets you make a script that runs as root no matter who runs it. You'll definitely want to check who ran the script, the arguments provided, etc if you do this. In fact, this is quite a can of worms. You probably also want to taint if you do that (perldoc perlrun, look for 'taint'). This can be a good way to do certain tasks as root if you carefully sanitize environment variables and input and trust yourself to write secure code. Depending on the tasks you want to perform, group resolution permission might be able. You be able to add your user to specific groups so that it has access to the things it needs. Or you might be able to (and want to) change ownership of things.
perl programs often call expect scripts externally to do this since it is so good at it. Look up "TCL Expect Script Tutorial".
At best, this will simply display each entry in the hash, filtered by uppercase. What I want is to actually re-populate the entry with the uppercase value. The reason for this is that I reference the hash key thousands of times in my code, and I don't want to filter it every single time =(
leave out the SET? perl -e'use Template; Template-&gt;new-&gt;process(\q{[% myhash.foo = myhash.foo | upper %]result: [% myhash.foo %]}, { myhash =&gt; { foo =&gt; "some text" } })' result: SOME TEXT using the same variable thousands of times in the same template seems excessive though
Maybe add a custom vmethod? See: [Template::Manual::VMethods, last entry](https://metacpan.org/pod/distribution/Template-Toolkit/lib/Template/Manual/VMethods.pod#Defining-Custom-Virtual-Methods)
FYI _perly_bot is a bot that watches blogs.perl.org.
 [% myhash.foo = FILTER upper; myhash.foo; END %] 
&gt; myhash.foo = FILTER upper; myhash.foo; END Awesome! Thanks for the help. I'm still new to tt so I'm still figuring out how to put things together. Thanks!
This is a version of [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM) which has been extracted from its parent distribution. I'm always happy to see useful pieces of a project carved off and released as a separate distribution. But I should point out that the Mojolicious core team aren't happy about this. Sebastian Riedel described this release to me as a "hostile fork".
Thanks!
As do I. plenv makes this a piece of cake, and really the only way I'd want to be running things. 
I am not aware of a built-in function that will do exactly what you describe, but writing your own sub to do it is not too complicated. Of course there are multiple ways to do it, but who doesn't love the goatse operator... sub character_count { my ($string, $char) = @_; my $count =()= $string =~ m/$char/gi; return $count; } Then just do $varA = character_count($a, "A"); $varB = character_count($a, "B"); Note I used the case-insensitive ('i') switch in m/$char/gi, which means character_count($a, "A") and character_count($a, "a") both return 4. Remove the 'i' if this is not your intended functionality.
One way is with the `tr` (transliteration) function, which replaces characters and returns how many were replaced. From perldoc: &gt; How can I count the number of occurrences of a substring within a string? There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the "tr///" function like so: &gt; $string = "ThisXlineXhasXsomeXx'sXinXit"; $count = ($string =~ tr/X//); print "There are $count X characters in the string"; 
I would say in comparison to perl it is much closer to that level. You're correct that it does have several ways in some instances, but I feel that is largely a more recent development. In the last few years, I've seen a lot of Stack Exchange answers involve using list comprehensions, generators, and map/fold/filter where you would normally just see a for-loop. I think this is largely due to the rise in popularity of the functional paradigm (Haskell, Scala, F#...etc).
Use `m//g`: &gt; In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern. ([source](http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators)) And so the number of elements in this list is the number of occurrences. Since `/g` has a different result in scalar context, you need to force list context using `@{[ matching ]}`: $varA = @{[$a =~ m/A/g]};
I would usually split this into a hash and count (exactly like the Python counting dict) rather than use a function for each one. Unless the alphabet is huge. sub counts { my ($string) = @_; my %counts; map {$counts{$_}++} split '', $string; return %counts; } my %counts = counts("AAAABBBCCD"); my $varA = $counts{A}; my $varB = $counts{B}; In Perl 6 you get the fun of just doing `my $varA = $string.comb.Bag&lt;A&gt;` if you only wanted to know A and never call the function again. Where the .comb is like a hair comb splitting the characters rather than short for combine :S and Bag gets you a counting dictionary.
Seems rather slow compared with the `tr///` approach. #!/usr/bin/perl use strict; use warnings; use Benchmark; my $str = 'AAAABBBCCD'; timethese(1_000_000, { tr =&gt; sub { my $count = ($str =~ tr/A//) }, split =&gt; sub { my $count = grep { $_ eq 'A' } split( '', $str ) }, }); Output: Benchmark: timing 1000000 iterations of split, tr... split: 2 wallclock secs ( 1.52 usr + 0.00 sys = 1.52 CPU) @ 657894.74/s (n=1000000) tr: 0 wallclock secs ( 0.09 usr + 0.00 sys = 0.09 CPU) @ 11111111.11/s (n=1000000) (warning: too few iterations for a reliable count)
That's "go die in a fire".
As an unrelated (maybe) question, why does Quantcast rank reddit.com at #162 in the US while Alexa ranks it at #9? That's below southwest.com and dmv.com. Something fishy there.
Still, can't hurt to try! keke.
Oh I see now, you're just using the UserAgent part of Mojo, that makes more sense. I like that it has a dom parser built in.
you make it too obvious and they'll learn to just kill the entry as an input filter, eliminating your work. I have doubts that even this primary technique would stand against statistical analysis.
seems a bit silly. factoring out smaller things from big things is cool
Thank you everyone for the replies u/MattEOates, if I go with your method this is what I've written open(seqhw1.fna) &lt;seqhw1.fna&gt;; while ($line = &lt;seqhw1.fna&gt;){ chomp $line $seq = $line } close(seqhw1.fna) $len = length($seq) sub counts { my ($seq) = @_; my %counts; map {$counts{$_}++} split ''. $seq; return %counts; } my %counts = counts($seq); my $count_A = $counts{A}; my $count_T = $counts{T}; my $count_C = $counts{C}; my $count_G = $counts{G}; my $count_N = $counts{N}; my $count_Un = $counts{-}; my $count_Y = $counts{Y}; my $NUnY = $counts{N} + $counts{-} + $counts{Y} my $total = $counts{A} + $counts{T} + $counts{G} + $counts{C} + $counts{N} print(seq + '\n') print('Length: ' + str(length) + ' base(s)' + '\n') print('Nucleic Acid Composition:') print('A: ' + $count_A + '; T: ' + $count_T + '; C: ' + $count_C + '; G: ' + $c$ print('Unknown Base(s): ' + $NUnY + '\n') Where "seqhw1.fna" is a file that looks like &gt;sample seq1 "N-YAAAGGGCCC" 
I'm not sure that "resigned" is an accurate description :-/
http://pragprog.com/book/swperl/modern-perl-fourth-edition
Although there are some slides, a bunch of rosetta-code examples, an out-of-date book, a helpful IRC channel, and some docs at doc.perl6.org, there is unfortunately no tutorial. This, I think, is a major problem and hope it's rectified by Xmas. That whole week between Xmas and new years there will be hackers in new bathrobes and slippers amid discarded wrapping paper trying out their new toys. Perl 6 will be at a local maximum of potential new-user goodwill. I hope the Perl 6 team doesnt blow that goodwill by not having a great tutorial.
Yours says search for $nope and replace it with nothing. ie, delete it. Assuming $nope might change in size, build yourself a string of spaces: my $tmp = ' ' x length($nope); s/$nope/$tmp/g; 
If you use [Readonly](https://metacpan.org/pod/Readonly) or [Const::Fast](https://metacpan.org/pod/Const::Fast) they will interpolate normally :)
Fyi, another place for serious code reviews and Perl wisdom is [perlmonks.org](http://perlmonks.org/).
This is exactly what I did to teach myself perl and it has worked out great. Perl Maven is wonderful. Just research what you need as you need it.
Awesome response thanks! Fixed the glaring bug you mentioned, some great ideas there I hope you don't mind if I add into my script too
Learn about POD/perldoc for documenting your scripts. Here's a my script template: https://github.com/neilhwatson/nustuff/blob/master/perl/nhw.pl Here's my Perl cheatsheet. https://github.com/neilhwatson/nustuff/blob/master/perl/cheatsheet.pod
It's dated, but still a good place to start. Try http://modernperlbooks.com/ for an up to date view.
There are a few problems with your code that prevent it from doing what you want. Firstly you need to get the data into `$_` so that `s/.../.../` can work on it. The easiest way to do that is probably to add a `-n` option to your `perl` command so it becomes `perl -nle`. Then you need to print out the value of `$_` after the transformation in order for it to be written into the file. So add `; print $_` to the end of your command. And finally, because your Perl code is all in a double-quoted string, the shell is interpreting `$1`, `$2`, etc as shell variables which haven't been given values. You can access the Perl versions of the variables by putting the code in single quotes.
Check out the documentation of the `exec` function using [`perldoc -f exec`](http://perldoc.perl.org/functions/exec.html): &gt; The exec function executes a system command and never returns; use system instead of exec if you want it to return.
Camel book is a good one. My other favourites are Mastering Perl and Perl Best Practices.
It doesn't seem to like that there are multiple lines in the source file. Could that be the issue?
You should be fine starting with the fifth edition, although you'll miss some minor updates to new Perl features. For instance, in the sixth edition we pull back on smart matching; that feature didn't turn out to be as useful or interesting as we thought it would be when 5.10 was released. At the beginner level, the basics are the same. You aren't going to learn all of Perl from a 300-page book. You'll still have a fine start. Just keep learning more Perl after you read the book. You are never done learning a programming language. You can see some of the updates in the [companion website for Learning Perl](http://www.learning-perl.com) and read about Perl's latest features at [The Effective Perler](http://www.effectiveperlprogramming.com).
Works for me with three copies of the same line. What behaviour are you seeing? If you can put some more sample data in a pastebin or a gist, I'll have a look. (Or perhaps this might be better suited to StackOverflow.)
Change the `say` at the end of the Perl line to `print`. Sorry, that was my typo.
Do you specifically need the each server to open in its own `dtterm`? Can you just ssh to each server and run the command? I'm afraid I know nothing about the software that you're trying to run here.
I did this...no change.
&gt; Bought Modern Perl. Wished I hadn't. I what ways do you think it's lacking?
What do you mean "Ignore the my $test = &lt;STDIN&gt;" part? If you have that in your code it's going to "hang" waiting for input. How is it not working? Are you sure it's not just taking a long time due to the size of the input file? You can get rid of the `cat` and the `grep`. perl -ne 'next unless /pdu-a/; s/DATATYPE::\w+\s+TIMET::(\d+)\s+HOSTNAME::(\S+) SERVICEDESC::(.+)SERVICEPERFDATA::Temp in C divide by 10=(\d+).+$/Time:$1 Name:$2 $3 Temp:$4/i; print' service-perfdata.old `next unless /pdu-a/` is the equivalent of `grep pdu-a` .. it goes to the next line unless it contains `pdu-a` and both `grep` and `perl` can read directly from files so you don't need the `cat`.
Can you elaborate? Is this discussion described somewhere?
It finishes running. I think it has something to do with the size of the file....1 Gb text file. It works fine when i cut it down to maybe 100 lines.
I loved mastering regular expressions (perl).
For Perl 5, 5.10 is fairly recent.
Thanks for co-authoring the book, it reads really well, I'm almost half way through. I understand it's a book for beginners, will check your suggestions once I'm done with this one.
Noted. Modern Perl will be my next book after the one in the topic title.
While we're at it, do you know how to print $' variable when using perl with a -e switch? It interferes with the single quotes of the code.
Perl's built-in OOP isn't the best and can be very messy if you let it, but it definitely still has its uses and advantages as long as you accept its limitations. Moose is what you'll want for "real" OOP though.
Thanks, sounds like I'll be busy for a while )
At work I recommend the latest edition of beginning perl followed by modern Perl 
you should check out ansible. learning perl is very useful, but ansible can do what you're trying to do very easily. 
&gt; Wow, can we possibly reach an agreement You have just reached it. &gt; Literally nothing you wrote here will be taken into consideration in this situation. Ouch, that hurts. Speaks volumes about your: - technical skills which, judging from your post, are ~~close to~~ nonexistent - attitude - adroitness - starting an (X) terminal on each server for the sole purpose of running a shell command there is just about the most asinine practice I have seen in decades. Doing it **from perl** takes it to yet another level. Your refusal to see it, even after it has been pointed out to you, is priceless. But don't take my word for it, feel free to crosspost to /r/sysadmin. Now, while point 1 can be fixed (everyone has to start learning somewhere), fixing point 2 is way harder; point 3, I am afraid, is hopeless. I wouldn't let anyone who wrote a post like yours within a 10 mile radius of any of my (or my customers') servers. My simpathy is with your employers. &gt; Fist yourself. Nah, not tonight.
My technical skills with UNIX in general are admittedly extremely weak. I never made any attempt to say otherwise or to even sound like I had anything more than extremely entry level experience. I'm really curious about why you decided to use that as a basis for your attacks and I can only assume that you're naturally attracted to low hanging fruit because it provides an easy way for you to inflate your flaccid ego. Such is life for a troll, I guess. I guess my "simpathy", whatever the fuck that is, is also with you. 
&gt; My technical skills with UNIX in general are admittedly extremely weak. This being the situation, please be so kind to explain, how does pointing that out, and suggesting that you learn the ropes and the tools needed for the job constitute an "attack"? (This **after** having offered what I deem to be a sound solution to your problem). You appear to have root on an Oracle grid with "very weak technical skills with UNIX". That alone is a recipe for disaster. But hey, it's your party, have fun. I think I will now go to fist myself a little.
The way you acted like a prick basically invalidated any "help" you may have offered. You could have just said your piece and gone on your way. Please stop assuming things about my situation. I'm not going to explain things to you.
After having worked with it a while I think the choice to use mojolicious was fortunate. Google doesn't actually use HTML anymore so if try to parse out links in a simple way you get nothing. But Mojo::UserAgent uses DOM to grab the links and that saves a lot of hassle.
yep, thats the one. Correct, it isn't a great beginner book, but it sure as heck completely covers regEx
Ah, well, I was exaggerating due to frustration. What I mean is the webpage elements are created dynamically using javascript and there are not simple links like, &lt;a href="http://searchresultdomain.com/page"&gt;page title&lt;/a&gt;. Take a look at the source sometime. Sure, there's an html framework but [the page itself is javascript](http://codepad.org/Fh6rswmk). And even if you get the non-JS version of the page the links are not clean but instead, &lt;a href="/url?q=http://searchresultdomain.com/page&amp;amp;sa=U&amp;amp;ved=0CG4QFjAZahUKEwiF3rLahZvJAhUEo4gKHcPoBWw&amp;amp;sig2=VEgfny7gC5GmkK229Xd-2g&amp;amp;usg=AFQjCNFhNMhlXJ9NcgxtwZV5otrpMnsYbQ"&gt;link name&lt;/a&gt; So they all actually point to google instead of the relevant result domain. Since this script is for obfuscation it can't just request the non-JS pages with some &amp;nojsorsomething tag even if it did exist. Honestly I'm not sure how it manages to pull out any actual result URLs from that mess. I have been assuming that accessing via, $res-&gt;dom-&gt;find('a[href^="http"]')-&gt;each resolves the google URLs to get the actual result URLs because when I use LWP::Simple I just get one of the two above types of links (all JS, or google domain re-directs). 
A sensible question. I imagine it's going to be a long time before Perl 6 is anywhere near mainstream (if ever), but of course a dead-tree edition is also going to be around for a long while (possibly sitting on bookshop shelves for years). Though I can't help thinking that as Perl 6 is **so** unrelated to previous versions of the language, the logical course of action would be for that not to be called Perl.
Dan himself assures me that it is. However, Sebastian still asked him not to maintain the dist, so as the poor beknighted fool who wrote the 5.8 patches I'll probably be doing the next release.
I was going to mention it has a tag on the cover saying what version it covers but that point was made. So yes, it should be "Learning Perl 5" because that is what people are going to see right off the bat. Sucks it had to be this way.
&gt; Though I can't help thinking that as Perl 6 is so unrelated to previous versions of the language, the logical course of action would be for that not to be called Perl. I'm a long time Perl programmer and honestly to my eyes Perl 6 is the perliest Perl ever. It's unfair to say it's unrelated. It's not even that different.
Oh yeah, def. We're going to be calling things, "Perl 5" and, "Perl 6" for ages to come. We're going to stop calling things, "Perl" and, "that thing no one thinks is coming out one Christmas" in... a couple of weeks, right? Around... some holiday I think it is... Valentines?
&gt; the page itself is javascript I kind of see what you mean but it's a funny way to put it. You're in a tricky position, aren't you? The official, correct way to hit google with Perl isn't the way you're doing it, and it can't be, because you're trying to imitate real-life traffic. It might be better long-term to go with phantomjs which is a headless browser. &gt; I have been assuming that accessing via, &gt; `$res-&gt;dom-&gt;find('a[href^="http"]')-&gt;each ` &gt; resolves the google URLs to get the actual result URL I wouldn't assume that. I would assume it goes to that ugly URL and gets bounced to the correct one.
A little sad in my opinion. There isn't anything wrong with Perl5 per say, but the big issue is if you want the language to continue to grow, some changes need to be made. In 2015, nobody (outside the current Perl audience) wants to learn a language where modern OO has to be added on with a module (even if that module is awesome). As an outsider looking in, I would think it makes the most sense to name the book "Learning Perl 5" and explain the difference in the introduction. Larry could have just named the new language something like "Sapphire", but then you're completely splitting the ecosystem. With Perl 6 you get a bright future, but the problem is it isn't a production-ready jump. Kind of a screwed with any decision situation. Honestly, nobody seems to be jumping the gun to write a Perl 6 book at this point as the language is just starting beta. I'd buy one in a heartbeat, but if one isn't published for 2 years, this may end up a non-issue for Mr Dfoy and Randall. Edit: There are some nice cases where OO doesn't matter at all such as what you'd use GO for or system administration tasks. I'm thinking of the 95% of desktop programming cases though.
My impression is that there has been a lot of contempt for Perl 6 over the years, partly because there was a time when it distracted from progress in Perl 5, and partly because it seemed like vaporware. With the imminent release I get the impression that has instead changed into a lot of good will toward the future of Perl 6, while at the same time there is little worry about it detracting from continued efforts on Perl 5. I think calling it *Learn Perl 5* is somewhat like saying people no longer want Perl 6 to just go away. It would be more like acknowledging its existence and accepting that they are two separate languages. If Perl 6 does live up to some of the longevity and broad applications that it aspires to that would be pretty cool, and it does seem like it would merit a new name, but Perl 6 seems like the name it will remain.
The benefits and tradeoffs of, "modular design" are sometimes the same. Also, there's many places where CPAN isn't an option and Perl is the tool. Sigh.
It would make sense to keep calling it "Learning Perl". In the current context, someone that's new to Perl, if they have no specific version number in mind, probably wants to learn Perl 5. Someone that wants to learn Perl 6 will *know* that they want to learn Perl 6. Edit: typo
Serl Pix.
&gt; Also, there's many places where CPAN isn't an option and Perl is the tool. Sigh. An embedded device with no Internet connection? Other than that, CPAN is always an option.
Several years ago now, APress wanted me to write a Perl 6 book. At that point, things were being heavily and frequently revised, so it was clear that Perl 6 was a long way off. We compromised and I wrote _Perl 6 Now: The Core Concepts Illustrated with Perl 5_. Since then, every year or so, they ask me about writing that Perl 6 book... except I haven't heard from them in a while, so I assume that that means that they found someone to do it. I'd love to, but I've been pretty out of the loop and soaked up in other obligations. If you get the chance to write for them, I recommend it. So, anyway, I think at least one publisher is going to have a Perl 6 book out.
Anywhere I do now have full shell access. 
I really have no idea. I don't think the conversation ever got passed "It's Perl 6".
Almost every Government related project I have been on doesn't allow it.
...or any shell access. 
&gt; If you have Perl access but no shell access, that's seriously fucked up. Web apps running on a shared hosting account. That's not, "fucked up", that's just boring, normal things. So, no CPAN no Moose, no Moo, no choice between the two, and certainly nothing that would require anything XS because there's no support to access gcc. 
All it takes is a 'system' command, and you can do anything you want with a CGI script.
I'm really sorry, but that's not a technique I can use with full dependability. I can fully admit that I do not understand all the use cases of, say: Perl, perhaps you could as well? 
If you get a simple, single-level hash and want a single object, then pass that to the constructor. If it is more complex, PRANG might help: https://metacpan.org/pod/PRANG
There's this, too, 12 years old now: http://product.half.ebay.com/Perl-6-Essentials-by-Dan-Sugalski-Leopold-Totsch-and-Allison-Randal-2003-Paperback/2886625&amp;tg=info Not sure if you're wanting an intro P6 or P5 book but I'm predicting that within a year, there will be plenty of both.
Why not just Learning Classic Perl and Learning Rakudo Perl... The book titles don't have to be anything to do with a version number, just differentiate the languages.
I wrote this post a while back and I've had some time to think about. I'm actually not too concerned about whether I'm right or wrong. I'm happy to be either. ;) BUT, I do think there's a gotcha in here that people should be aware of, regardless of whether they think the behaviour is correct. The main point I wanted to drive home was that, in many cases, code that currently only checks for `is_success` should probably be checking `$response-&gt;is_success &amp;&amp; !$response-&gt;header('X-Died')`. That covers success in the response code and the absence of an exception in dealing with the response after that point. Edit: this article was originally posted here https://www.reddit.com/r/perl/comments/3q0ivi/httpresponse_may_have_a_different_definition_of/
The problem with this article is that it's not clear what it means by "problem with the response body". Most the comments I've seen on Reddit is "well, who knows what your API does?" The issue here is that `HTTP::Response` and `LWP::UserAgent` may *fail to read the API reply*, but report `is_success`. The only way to detect an error from the library is to check the `X-Died` header. That's a definite bug in the libraries, in my not so humble opinion. The library is basically swallowing exceptions from reading the response and saying the operation succeeded. * [RT Bug](https://rt.cpan.org/Public/Bug/Display.html?id=101990) * [Why can't LWP::UserAgent get this site entirely?](http://stackoverflow.com/questions/14740365/why-cant-lwpuseragent-get-this-site-entirely) (response silently truncated) 
Grep for "require" too.
http://perldoc.perl.org/perlsolaris.html There is a part about searching modules under certain circumstances ( eg. after an update ). Check if it might apply. What are the perl versions on Linux / Solaris?
++ for the nice docs.
Or, Learning New Perl, after which everyone gets mad, and we go back to Learning Classic Perl. Classic Coke, I mean Perl, tastes better anyway. Screw Pepsi. I mean, screw Python. And all you Tab drinkers can have all your parentheses.
Oohhh, thank you very much!
More options [here](http://stackoverflow.com/questions/3945583/how-can-i-conditionally-use-a-module-in-perl). I have seen/used the eval-block+require+import ( within BEGIN) rather than string eval. I never thought about the implications, though.
https://github.com/sergot/http-useragent/ is probably the most advanced user agent (does SSL when IO::Socket::SSL is installed). Not sure about the server side though.
I came up with this solution: http://pastebin.com/ZJNL3cEz I really like your `BEGIN` option. Is there a way to have the test for `Data::Dump::Color` be in the `BEGIN` block, and store the result in a variable I could reference in `out()`? If I declare a variable `my` in the `BEGIN` it's not available outside of that block.
Excellent! I used some of these to come up with my hacky solution: http://pastebin.com/ZJNL3cEz
You can make it much simpler than that: #!/usr/bin/env perl use warnings; use strict; BEGIN { if(eval "require Data::Dump::Color; 1") { *out = \&amp;Data::Dump::Color::dd; } else { require Data::Dumper; *out = sub { print Data::Dumper::Dumper(@_), "\n" }; } } my $a = [1, 3, 5, 'kitten']; out($a); out("foo"); out("barbaz"); 
Yeah... But quickly... 
I use M-x perldb in emacs. Syntax coloring, command history, and a little editing maybe... :-)
I might have an old version of the library. But I cannot install the new one: $ panda install HTTP::UserAgent ==&gt; Fetching HTTP::UserAgent ==&gt; Building HTTP::UserAgent ==&gt; Testing HTTP::UserAgent Method 'Int' not found for invocant of class 'HTTP::Header::Field' in method field at /home/alex/Documents/projects/perl/test1/.panda-work/1448173191_1/lib/HTTP/Header.pm6:58 in block &lt;unit&gt; at t/010-headers.t:15 # Looks like you planned 18 tests, but ran 2 t/010-headers.t ............ Dubious, test returned 255 (wstat 65280, 0xff00) Failed 16/18 subtests Method 'append' not found for invocant of class 'Array' in method push-field at /home/alex/Documents/projects/perl/test1/.panda-work/1448173191_1/lib/HTTP/Header.pm6:82 in method push-field at /home/alex/Documents/projects/perl/test1/.panda-work/1448173191_1/lib/HTTP/Message.pm6:52 in block &lt;unit&gt; at t/020-message.t:16 # Looks like you planned 19 tests, but ran 4 t/020-message.t ............ Dubious, test returned 255 (wstat 65280, 0xff00) Failed 15/19 subtests Method 'append' not found for invocant of class 'Array' in method push-field at /home/alex/Documents/projects/perl/test1/.panda-work/1448173191_1/lib/HTTP/Header.pm6:82 in method push-field at /home/alex/Documents/projects/perl/test1/.panda-work/1448173191_1/lib/HTTP/Message.pm6:52 and so on.
&gt; My favorite part of this is the local @stack = (@stack, $^N); [...] This causes it to get reset to what we want when backtracking happens. This is great feature! I'll try to add that to some new code at work, and see the reactions of my coworkers.
Fwiw, Jonathan Worthington did a talk at FOSDEM 2014 titled "Perl 6: what can you do today?" in which he spent 90 minutes exploring use of the Rakudo Perl 6 compiler with a global historical climate dataset including concurrent processing across multiple cores. Imo the [slide presentation](http://jnthn.net/papers/2014-fosdem-perl6-today.pdf) works standalone. The [video](https://www.youtube.com/watch?v=YW75CXY-P3M&amp;index=34&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK#t=4m) is worth watching if you can forgive the sometimes crappy audio.
"This is perl6 version 2013.12 built on parrot 5.9.0 revision 0" but rakudobrew says that it's quick and dirty and may be buggy. 
Parrot is officially not a supported back end. If you `rakudobrew build moar` you might have a lot more luck, both with this task and getting support from people. In general you want to be on a release of the compiler from after this summer using MoarVM.
 $ perl -E 'say $^V' v5.22.0 $ perl -Mversion -E 'say version-&gt;parse("1.2.3") &gt; version-&gt;parse("v1.2.11") ? "True" : "False"' False
thanks.
They seem to ship some bastardized version of Perl. You're probably going to be better off installing your own Perl using either perl-build or perlbrew. http://metacpan.org/pod/distribution/Perl-Build/script/perl-build http://perlbrew.pl/ For the example I gave above I used `perl-build` to install it into my home directory using `perl-build 5.22.0 ~/localperl`
That slide presentation was great, thanks!
Rot is what happens.
... but thats so time consuming, you should automate it! Then you can have a test framework for your test framework, its turtles all the way down!
[I've done that](http://blogs.perl.org/users/david_cantrell/2014/05/meta-testing.html), sort of.
Hi! There is a reference to bug #116677 Perl #116677: B::Deparse fails on readline ${"a"}. What is ${"a"} ? I can't remember, and didn't find anything useful online. Cheers!
`${X}` is a symbolic reference to `X`, so `${"a"}` is `$a`.
In regexps, literal metacharacters need backslash quoting: /\\\*/. Better yet, use index($s,'*')&lt;0 to test for absence.
Interesting post, and nice use of SQLite! Just passing these comments on from someone familiar with these data: " the author isn't doing any kind of area weighting in his average, which will bias his results due to the density of stations in the US, the coasts in particular, and the northern hemisphere overall. &gt; So, now you are familiar with the benchmark database of land surface &gt; temperatures which NOAA uses to make pronouncements about global warming. NOAA calculates the temperature anomaly vs a 30-year base period to make pronouncements about climate change. If the author does likewise (even without a proper Inverse Distance Weighting scheme), he should see a similar upward trend." 
What we have here, as we economists like to call it, is an "unbalanced panel." So called anomalies are just deviations from a mean ... But what mean? What deviation? With spotty station histories, with observations dropping out at an alarming rate etc, "deviations from a mean" lose meaning. Establishing a proper sample comes before everything else. What kind of weighting scheme can make the data OK if all temperature data ends up coming from the US? That said, I believe the one temperature graph I have does show a similar trend to the trends published by NOAA and others. What it does also show are break-points in the temperature average trends that coincide first with the increase in the number of points in the data set first, and then with the start of the decline in the number of data points included. That is curious. In balanced panel of station histories from 1880 - 2015 would contain roughly 11,880,960 data points. Instead, the GHCN contains only 4,931,273 data points. The recent (since the end of the 20 century) drop in the number of temperature measurements included in the data set cannot be explained away by saying we have a weighting scheme. I know a thing or two about panel data. PS: Also, note that there is only one temperature graph in my post. I care more about where and what time period the observations are coming from. If one is going to claim October 2015 has broken some record, it would help if there weren't less than half the number of temperature stations in their benchmark data set in 2015 compared to 1970. Don't confuse the graphs showing the number of observations with temperature data.
&gt; Then you can have a test framework for your test framework, its turtles all the way down! A test framework, being software, should indeed have its own self-tests. What's the problem? Testing that the tests themselves are being tested for optimum testiness, while not making near-as-well every test a test of a test's test, may require a pair of working testicles. (but that, too, is doable.)
Sounds like an [adoption candidate](http://neilb.org/adoption/)
Try cpan utf8::all
You probably don't even care what Log::Printf does. Personally, I would look at the parameters being passed to the function, and write a module that expects those parameters and forwards them to printf: package Log; sub Printf { return printf(@_); } 1;
You can get `cpanm` from http://cpanmin.us , it's quite nice. And you should only need to do `cpanm utf8::all` .
It does generally come down to that, but I don't have a problem with Gabor asking for someone else to do it. He's bringing this problem to the attention of a larger audience. That might be all that's required in order to find someone to do the heavy lifting.
Why did you put `Module::` in front?
It was there in an example that I saw.
I would double check that example. You simply need the full namespace of the module, don't prefix it with anything.
I thought we were supposed to start calling Perl 6 "Camellia"? If so, then there's no ambiguity in continuing to call Perl 5 just "Perl".
What example, where?
Your common task is not my common task.
Make p5p happy today and run [/usr/bin/perlthanks](http://perldoc.perl.org/perlbug.html#Can-you-use-perlbug-to-submit-a-thank-you-note%3f).
Do you think there are things that 90% of programmer do which aren't already well supported in the Perl code?
That's rather unperlish since you can [fail](http://doc.perl6.org/routine/fail#class_Exception)/[die](http://doc.perl6.org/routine/die#class_Exception)/[CATCH](http://doc.perl6.org/language/exceptions) instead of manually inspecting error values. If you want explicit error handling like in Go, there is no need to wrap errors into a data structure first, since you are able to return multiple values from a subroutine.
HTTP::UserAgent has just been updated with a POST method. `Add a simple .post method to UserAgent` http://github.com/sergot/http-useragent/commit/c5d4d0a9bcf2ebae12f113a34de1c5bb90570a0f
so I should raise an error if, say, I receive an http response from a server with the code 4xx or 5xx? 
Perl (5 or 6) has data types, so... yes. bless $success, 'Right'; bless $failure, 'Left'; But what are you *really* trying to do?
Nice. But booo for not pointing beginners to cpanm as the default choice.
return a value from a method which makes an http request. 
The Perlish solution would be to return data as if the query succeeded. If something goes wrong, instead of returning with a value, throw an exception. Of course at some point you have to handle the exception --- is there an alternate source you can query? --- or die. 
The way I look at it all types in Perl 6 are automatically Eithers by default. You have to go out of your way to *not* signify an Either. That is to say, the constraint implied by a bare type name such as `Int` is an Either wrapper -- a corresponding value may be defined or undefined. You have to write `Int:D` if you mean to denote what is typically denoted by the bare type name in other langs. (See [Constraining Defined and Undefined Values](http://doc.perl6.org/type/Signature#Constraining_Defined_and_Undefined_Values) for more details.)
Perl 6 adds a nice twist that fundamentally increases coders' control and often simplifies code from what I've seen. Rather than eagerly throwing an exception *immediately* on encountering errors (thus always immediately engaging the run-time exception error handling mechanism to deal with such errors), the norm in Perl 6 is to punt by returning an as-yet "unthrown" exception wrapping object called a [Failure](http://doc.perl6.org/type/Failure). A Failure corresponds to the OP's Left slot being occupied. Quoting from [the **Exceptions** section of the **Blocks and Statements** language design document](http://design.perl6.org/S04.html#Exceptions): "If you test a Failure for .defined or .Bool, the Failure marks itself as handled; the exception acts as a relatively harmless undefined value thereafter. Any other use of the Failure object to extract a normal value will throw its associated exception immediately ... sink context will automatically throw any unhandled Failure that you try to discard."
That's the bare type name. `Int` means may be defined, may not.
Thank you for taking the time to create this!
One starting point: [5to6-nutshell](http://doc.perl6.org/language/5to6-nutshell).
Discussion on Hacker News: https://news.ycombinator.com/item?id=10637789
In the standard library yes. I know there are plenty of CPAN options, but some programmers like huge standard libraries which help avoid the pain of installation.
Any language that lets you declare classes and define methods which call an embedded library. I could do it in Perl if I so wanted. I even embedded Perl in Parrot and had this feature working *years* ago.
space bar.
:
I know of things like .WHAT and the like, but that's going to be very rare to type. Can you give some examples of capital letters in the 90% case: regular application code?
I guess I chose the wrong title :D The post is more about writing command line apps. And I'm surprised nobody else says "tab" =)
Beginner question: is there a big difference in what my perl6 file extension is? I'm seeing multiple answers on what to use, ranging from pl6, pm6 and p6. According to to this tutorial, I should pl6 but VIM doesn't recognize that with syntax highlighting. It does recognize pl6 and pm6 though.
I think this is great! For folks like me, following this is fairly simple compared to following a book. Do you have any more we could use or is this the first?
I'll have more it's just been a busy wk for me haha grad school and life
Since no one had the good sense to warn you: donâ€™t get too excited about prototypes. Theyâ€™re little used, and thatâ€™s rightly so, because [theyâ€™re not a terribly good idea](https://encrypted.google.com/search?q=perl+prototype+problems). There are basically two actually useful prototypes, `()` and `(&amp;;@)`, two of questionable but occasional utility, `($)` and maybe `(_)`, and the rest should be avoided. And they only work on function calls, not method calls. (For details consult the articles.)
I see the response, it's wrong. OP specifically says he's looking for a way to do it without references. The response uses a reference.
Even as beloved as el Che is in some circles, I can understand people who lost family members in his revolution saying "Could you pick a different icon?"
&gt; OP specifically says he's looking for a way that doesn't use references. This uses a reference. Well, yes, it does use a reference. It has to. That's the only way to do this. But, it disguises the reference so that the user of the subroutine doesn't know that there is a reference involved. That's the important difference. &gt; I don't see how prototypes are even relevant; the result would be exactly the same without the prototype, all it does is move the reference sigil. But it moves the reference sigil from a place where the user (i.e. the programmer who is calling the subroutine) needs to know about it and use it to a place where only the subroutine's author needs to know about it. Given that most subroutines are called far more often than they are written, this seems to be a net win.
first example in perldoc perlsub, "Prototypes": sub mypush (+@) sub mypush :prototype(+@) then "mypush()" takes arguments exactly like "push()" does. seems quite relevant?
+1 for Tab. A few years ago I realized that CLI user experience centers around tab completion. Looking forward to how TINITA's CLI framework will help in writing CLI scripts with completion feature. We need more frameworks like that.
&gt; Note that later version of perl, the prototyping stuff changes a lot. The machine I was testing the code on has perl 5.8.8 so that's what I went with. # perl -e 'print prototype "CORE::push"' \@@
From the page: Statements are typically a logical line of code, they need to end with a semicolon: if True { say "Hello" }; So even `if` statements and such need trailing semicolons now? Is this actually true? It's the first I've heard of such a thing.
They need them unless they end with a closing brace as the last code on a line or they're the last statement in a list of statements. So this says "Hello" then "Bye": if True { say "Hello" } say "Bye" And this just says "Bye": say "Bye" if True But this fails with "Unexpected block...": say "Bye" if True { say "Hello" } See [Separating statements](http://doc.perl6.org/language/syntax#Separating_Statements).
As delias_ and raiph said, only a postfix if: say 'hello' if $x; needs a semicolon. The normal if doesn't require one. We corrected the typo and updated the page to reflect the changes.
As much as I'd like to believe that it's Tab, based on the smudge level of the keys on my keyboard, I have to say it's Enter and Space.
I've been keeping an eye on Perl 6 ever since it was announced, way back in 2000-odd, so I get the gist of the post, but I've not been following every detail of development, so there are some things I don't understand. Towards the end, there's this code: 217 my $constant-variable := Proxy.new( 218 FETCH =&gt; { q{Merry 1.0!} }, 219 STORE =&gt; -&gt; $, $ { die X::Assignment::RO.new(typename =&gt; 'none really') } # line 219 220 ); 221 222 say $constant-variable; 223 224 $constant-variable = 'The Grudge stole Christmas!'; # this will die in line 219 225 say $constant-variable; I don't understand line 219 (the "-&gt; $, $ {" bit). I get that "-&gt;" defines a "pointy sub", which is usually in the form -&gt; $param1, $param2 { ... sub body ... } but I don't understand why it's "$, $" in this case. Is it some fancy syntactic sugar to represent 2 anonymous args? And if so, why 2? I thought a STORE call would just take a single value, that being stored. 
Sadly, many things are left unclear. As I understand it, `Proxy` is the new `tie`. But just the first paragraph (including the code example): what does *BOS* stand for? &gt; By handling `X::AdHoc` we can turn a fatal `die` into a harmless `warn`. Why? Isn't that possible with other exceptions too? What's the difference between `$foo.VAR.^name` and `$foo.WHAT`? I was up to now always confused as to when to use assignment, binding or even *compile-time* binding (`::=`). Not sure if this makes it any clearer.
&gt; what does BOS stand for It confused me too at first, until I realised it's a Fallout reference and stands for "Brotherhood Of Steel" - there are other Fallout references throughout the examples: "Supermutant", "Ghoul", "Synth", "Cait", and "Dogmeat". So in this context BOS is just an arbitrary sub name. I wish the author had made it more clear that BOS wasn't some Perl6 notation as the caps seem to imply, though, as I think it will be more confusing to people who don't know/spot the game reference. 
For the benefit of people reading this when the article you're talking about is no longer on the front page, it's probably worth pointing out that this code is taken from the [2nd December article](https://perl6advent.wordpress.com/2015/12/02/day-2-2-bind-or-2-bind/).
Thanks, that makes sense now. 
Actually, I have a question. In that code I quoted in the post you replied to. STORE iis defined as a pointy sub with 2 params, but FETCH just appears to be a block - why the difference? Why is FETCH not defined as `FETCH =&gt; -&gt; $ { q{Merry 1.0!} }` ? 
Any word when a Windows MSI will be released for Rakudo 2015.11?
 if True { say "Hello" }; say "world"; # ^^^ this ; is required Is there any particular reason for this restriction? I can't think of any other language with a C-like syntax that doesn't let you just start a new statement immediately after a brace-delimited block. This just seems like a pointless departure from programmers' long-held intuition.
I voted this down because of Reini's nasty calling people out by name. I don't think he needs a wider audience for his unpleasantness.
Was curious what Perl 6 uses under the hood. On JVM it defaults to the java.Random.getDouble which isn't crypto level secure (not sure on the algo). On MoarVM it uses LibTomMath from the looks of things which ultimately if you [follow the bread crumbs](https://github.com/MoarVM/MoarVM/blob/45d5efc12bfa545899e91777d876a9483a6ed6aa/src/math/bigintops.c#L882) is whatever the [default C rand() is](https://github.com/libtom/libtommath/blob/b505db8f48d831ad7363ef90a00763c59d6c9d13/tommath.h#L112) for the system.
Unless things changed sine I last looked, the core `rand` on Windows *only had 15 bits*. That's right, you can only have 32768 (or 32767?) different values before it repeats. Surely that could be improved upon, even if you don't change the algorithm.
Many thanks! Actually, I feel a little guilty about my whining that the article doesn't make things clearer. The code it contains *is* daunting, but the part about when to decide between assignment and binding is actually very straightforward. If I'm not wrong, you could summarize the difference like this: * assignment copies the contained value from one container to another * binding creates an alias, so that two names refer to the same container, which in Perl 5 could only be done by assigning a reference to a typeglob.
Crypto-level randomness isn't necessary for all applications, and their general slowness make them unsuitable for many of them, as well. The `rand()` function itself probably has to stay the way it is due to widely-deployed standards, but it would be nice to have a better alternative around.
The Perl 6 spec at least defines very well what to expect from rand() i.e. not too much. ["Pseudo random number in range 0 ..^ 1. That is, 0 is theoretically possible, while 1 is not."](http://design.perl6.org/S32/Numeric.html)
I had this between my old bookmarks: [Generating random numbers in perl](http://wellington.pm.org/archive/200704/randomness/index.html#slide0). No idea when it's from, it doesn't say on the page.
[Things have changed](https://www.nu42.com/2014/05/perl-5200-brings-better-prng-to-windows.html).
Best for what? ... For doing reproducible simulations for statistical estimation? ... For crytpo? ... For Hangman? Is PCG better than MT?
I think /u/robertsrealaccount is mistaken. Lots of real code probably depends upon a repeatable sequence from a PRNG: if you run into a bug in your randomized algorithm, it's really helpful to be able to reproduce and debug the same sequence. Producing the same sequence on different Perl versions matters far less. (On a semi-related note, Perl's recent hash behavior is a real pain in this regard.)
Perl's builtin RNG is already good enough for most non-crypto purposes; it provides 48 bits of randomness per call, its period is also 2^48, and it's very fast, which *is* a requirement for the core implementation. People doing crypto or heavy-duty numerical simulation should reach for another module; the core `rand` is supposed to serve general-purpose needs and it does it well enough. Incidentally, calling `srand` manually for purposes other than getting predictable random numbers stopped being necessary *18 years ago*, so people should quit doing it.
I was trying not to confuse the issue by getting too wordy. Yes, it's a good idea to `srand` after `fork` if the RNG might have been initialized pre-fork. However, call it *without an argument*. Don't try to do time xor pid mojo or anything like that, Perl's is probably better :)
But I like man pages, I cannot live without them. Speed up man pages generation process instead :)
Seems to me like the reasonable thing to do is to add wrappers for two or three use cases into core, maybe: Random::Fast Random::Secure Random::Pseudo The wrappers would provide standard names and APIs for people whose needs can be met by a "default" module. The actual randomness would come from whatever the current best implementation is for each use case (which would also be added to core), be that Bytes::Random::Secure (for ::Secure) or maybe even good ole rand/srand for ::Pseudo. Obviously if you're implementing your own secure messaging service, you should dig deeper and investigate all the options, but that doesn't mean it's not possible to try to elevate the quality of random numbers for people with less strict needs.
There's been quite a bit of this kind of stuff going on in recent versions of perl, and is one of the compelling reasons to upgrade. Be aware of hash key ordering bugs if you're still on &lt; 5.18 though and thinking of updating. Here's another example of an optimisation in 5.22 that i came across whilst working on the PRC (from [this](https://github.com/dex4er/perl-Exception-Base/pull/2) pull request): &gt; Using $# is better here because it means the last index, which is exactly what you want to express here. Yeah, that's true. You know what's surprising? Using `@{$self-&gt;{foo}}-1` is between 5% and 15% quicker than `$#{$self-&gt;{foo}}`: #!perl use strict; use warnings; use Benchmark qw( :all ); my $self = {foo =&gt; [1,2,3]}; cmpthese( 10000000, { var =&gt; sub { $#{$self-&gt;{foo}} }, idx =&gt; sub { @{$self-&gt;{foo}}-1}, } ) Results: :!perl /private/tmp/bm_lookup.pl Rate var idx var 9523810/s -- -12% idx 10869565/s 14% -- I wonder how `$#` is internally, looking at it through B::Concise it seems that `$#` introduces another op: &gt; perl -MO=Concise -e '$#{$self-&gt;{foo}}' a &lt;@&gt; leave[1 ref] vKP/REFC -&gt;(end) 1 &lt;0&gt; enter -&gt;2 2 &lt;;&gt; nextstate(main 1 -e:1) v:{ -&gt;3 9 &lt;1&gt; av2arylen vK/1 -&gt;a 8 &lt;1&gt; rv2av[t1] sKR/1 -&gt;9 - &lt;@&gt; scope sK -&gt;8 - &lt;;&gt; ex-nextstate(main 2 -e:1) v -&gt;3 7 &lt;2&gt; helem sKM/DREFAV,2 -&gt;8 5 &lt;1&gt; rv2hv sKR/1 -&gt;6 4 &lt;1&gt; rv2sv sKM/DREFHV,1 -&gt;5 3 &lt;$&gt; gv(*self) s -&gt;4 6 &lt;$&gt; const(PV "foo") s/BARE -&gt;7 Compared to: &gt; perl -MO=Concise -e '@{$self-&gt;{foo}}-1' 7 &lt;@&gt; leave[1 ref] vKP/REFC -&gt;(end) 1 &lt;0&gt; enter -&gt;2 2 &lt;;&gt; nextstate(main 1 -e:1) v:{ -&gt;3 6 &lt;2&gt; subtract[t2] vK/2 -&gt;7 4 &lt;1&gt; rv2av[t1] sK/1 -&gt;5 - &lt;@&gt; scope sK -&gt;4 - &lt;;&gt; ex-nextstate(main 2 -e:1) v -&gt;- - &lt;1&gt; ex-helem sK/2 -&gt;- 3 &lt;+&gt; multideref($self-&gt;{"foo"}) sK -&gt;4 - &lt;0&gt; ex-gv s -&gt;3 5 &lt;$&gt; const(IV 1) s -&gt;6 Interesting! If we added an extra assignment to an intermediary variable, as @bambams suggested, if would be even "slower" (5% on 10000000 ops/s is not exactly slow, but nonetheless). But ultimately i'm not bothered because, as i said originally, they're both equally ugly constructs the represent the same thing. It turns out the the way i chose to do it is more efficient and you could argue that using `$#` is actually *worse* not better.
How's the performance of Perl6 these days? I have an idea about a new hobby project and it would be an excuse to use Perl6 but it'll use large data sets (GBs of memory and TBs of disk) so I can't use anything slow.
So, bad Perl article, or *worst Perl article ever*? 
I know we can't keep all of the people happy all of the time, but it's depressing to think we can't at least have a status quo for the 90% of people who just don't care. Right now if I say "your rand usage is sketchy, here is a patch that uses Crypto::Foo::Random to improve things. All unit tests and code coverage is done, please add it." Most people without a crypto background might just integrate it (if the author is still an active maintainer and likes to accept user patches). Some would say "Why didn't you use Crypto::Bar::Random" or "What about Bytes::Random::Math::Rand". There is no way I could convince everyone to use the same module. There isn't even a unified API that allows them to pick their own module but switch without renaming things everywhere. I don't have any clout with CPAN module authors. The Best scenario I could hope for is to convince them that switching to a pluggable module format is better. None of the modules are vetted by anyway, so one might be just as good as any other. Having a "middleman" module author who isn't a crypto nerd but is still a blocker on your patches means the end-developer is stuck in a political process anyway. Either they can start their own forks of well established large projects and maintain our own local versions of them just to be in charge of the random code, or we standardize somehow to reduce the issues. What I want is this: use Net::SNMP rand =&gt; 'MT'; use Mojolicious::Lite rand =&gt; 'MT'; use Catalyst rand =&gt; 'MT'; use Random::MT; Sort of like Math::BigInt try 'GMP,Pari'; Alternatively, this: use Random::MT; # loads a namespace variable that tells everyone this module is in use use Catalyst; # checks to see if $RANDOM::rand is used and uses it if so.. The ability to tell module authors, either through an import statement or a pragma that this program that is using their module will be doing some random stuff itself too, so please use the same module I'm using for consistency, and so we're only doing initialization stuff once. Yes, we could just overload the CORE rand() function but that doesn't stop people from doing sketchy stuff in their modules. We can either overload rand() and make_random() and random() out of the 10 viable implementations to enforce that the middle modules will use the one we want, or we can fix it with policy.
Okay, I see why it fails now. There's actually a semantic difference between them. Accessing `$#{$self-&gt;{foo}}` will autovivify `$self-&gt;{foo}` into an empty array reference if it doesn't exist; `@{$self-&gt;{foo}} - 1` doesn't. multideref only works on op chains that *don't* autovivify the last-level element. So I suppose it would take at least a bit of actual work to make things play together.
I was tempted, until I saw that it was $20 for the shirt ... and $15 for the international shipping :/
That isn't the prettiest perl code out there but try reading that exact same thing written in ruby. It would be about 2000 lines long and contain about 100 trivial classes. The problem isn't that perl has more complexity, it's that it condenses that complexity into into fewer lines of code. 
No the problem is the variable names that were chosen are incomprehensible, non-descriptive, and these variables aren't even used in this part of the code. EDIT: and the nonsense use of random globals, and that all of this could probably be done in a couple lines with any of the 3 proper date modules, if I was willing to spend an hour to figure out what it's doing. And that's just the first 20 lines of the module
I have mostly used panda. I would suggest trying them both and see if you like one over the other. Also I would post perl 6 questions over in /r/perl6
I would suggest trying out perl6 to see if it is fast enough for your case. 
Funny, I didn't think to check for its own reddit group.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/perl6] [Perl 6: zef or panda?](https://np.reddit.com/r/perl6/comments/3vl9s9/perl_6_zef_or_panda/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
perl6 is like a whole different world, man.
I see all those 'my' and 'our' scope declarations and my mind goes back to Donnie Brasco: "He's a friend of ours, so show him your time stamp."
It's big. Top men will be involved. It could be several megaby-- gigabytes. One line, 900 gigabytes. So scary. Yes, frightening. And we need you to find all the ampersands.
yuk
I'd be happy to help with your bioinformatics homework, but not happy to do it for you. Checkout the [#bioinformatics chat room](https://webchat.freenode.net/?channels=bioinformatics) for some more interactive help.
&gt; I know you're arguing for conservatism in some of the threads. Its' not really "conservatism", conservatism is typically adhering to "old ways" and "old traditions" for unqualified fear of change. This is less conservatism, more "Civil Engineering". A lot of the stuff he talks about are fundamental components, and being so fundamental, any change can have unintended consequences. And these are not "unqualified", these are things we constantly face, as every slight change we make we feel the fall out from when we make even the slightest mis-step. The difference is between fearing change in an artistic endeavour with an audience of social peers who may react negatively, and an engineering endeavour where you're objectively recognizing that if you do bad, people could die, or billions of dollars could be lost. Every change must be well planned, well thought out, and have the path for that change well managed, so that the change we *do* make eliminates all the negative consequences instead of creating more of them. This very mindset is what is grossly under expressed in software development in 2015.
No, thank you for pointing it out in the first place. It was totally unexpected for me, and interesting to look into. The upshot is that when working with a plain array, `$#foo` is still faster than `@foo-1` (almost twice as fast, in fact), but when working with a complex multiderefable expression it's the other way around. `@{$self-&gt;{foo}} - 1` is a bit faster than `#{$self-&gt;{foo}}`, and `@{$self-&gt;{foo}[0]{bar}{baz}-1` swings around to almost twice as fast as `$#{$self-&gt;{foo}[0]{bar}{baz}}`.
I'm very sorry that your tilt campaign didn't work out (I was one of the 40 individual potential donors), but - sad to say - I think you've now missed the point even more than you did at first. I should say that I haven't experienced the inner workings of the CPAN community - so of course I haven't experienced any of your frustrations. Like others, I don't quite understand the core problems you think CPAN has - and perhaps if I did, I wouldn't care. For me, your campaign had two problems: Firstly, it was much too diffuse, subjective and focussed on you and your problems, and not focussed enough on: what useful deliverables would a year of your paid time generate. I'm sure you would have done great work over that time, but it wasn't very clear what. Secondly, there could have been some real rewards at much lower levels, for example you could have promised to come to a corporate donor and present some customised training for them, or directly support them in adding any DBIC features they wanted (or explaining any DBIC weirdnesses) etc. Anyway, these just my thoughts for what they're worth, hope you do stay a solid member of the Perl community. Focus on the fact that lots of people thought you worth backing to the tune of $30000, a substantial chunk of money! Best wishes!
I call this bullshit. It is actually 48% slower than with my builtin overflow checks which I added to cperl on February 18. So davem added an optimization useful only for old compilers, without even looking at my cperl improvements. And everybody cheered up and declared it a winner. They also blocked me from the mailing list and bugtracker, because I called them incompetent (which is easily observable looking at the features they implemented in the last 12 years), so they have no idea at all. Good luck perl5 to attract any serious users which so much nonsense and clueless cheerleaders. See https://github.com/perl11/cperl/issues/83
So you prefer the people I named to continue to destroy the program you like? In contrast to those people I was never nasty or unprofessional, and I don't threaten perl5. Instead I am the only one who is actively trying to improve perl5. Against their cabal. In the last 10 years I was called "Asshole" by them regularily every single year without any consequences. And when I call them incompetent (which is easily observable for anybody looking the 12 year history of their work), I am attacked. Go figure. You have "nasty" attitudes also, but I don't care because you don't maintain code I'm using. The compiler is now released, btw. 1.53 on CPAN. Bytecode is broken, and I cannot do much to fix that. But this happened during 5.10-5.16 on windows also, and nobody cared.
If one is going to be favoured, nobody knows which. In the perlverse it is considered healthy when there is more than one way to do it.
I know. I am not a fan of the philosophy when it comes to package managers though.
I don't use perl via the command line very often so it's probably obvious, but I thought they were the same thing? They both go through the same Perl interpreter, no?
I have a multi-line pl program but I need to run to run the same program from command line. I was hoping some tool could add all required escape sequences to allow it to run in the perl -e '' format
Wow, it supports a number of non-MS languages besides Perl. And the "Getting Started with Git" video on the sidebar! This would have been unimaginable from MSFT in the 90s.
Hey, long time no see! Your comment is atypically neutral... it is unclear whether you love or hate the entire idea. Can you elaborate? ;)
&gt; They also blocked me from the mailing list and bugtracker, because I called them incompetent Negative, aggressive, morale-destroying behavior can destroy open source projects faster than incompetency. That's why many open source projects ban this behavior.
You took away the option that it ever will happen. You didn't "waited" for the right moment, you said "now or never", and now its never..... 
&gt; Yes, its not the right time and NO you can't do anything against or towards that, it happens or not. Which is completely fair. It's not like I am going to go senile overnight and lose any value. When it is time, you know where to find me, I am pretty sure something can be worked out. &gt; but 5.6 was more important Everything is [equally important](https://www.reddit.com/r/perl/comments/3fx3cg/visualizing_perl_5_release_history_2015_edition/ctuzs2h). My effort comes as an inseparable package. This **is** in fact what makes me most valuable.
&gt; But why should you be the only one with that? I never implied anything like this, not sure how we got here from where we started.
Nothing prevents you and others from declaring the same. OSS would be arguably in a much better place if everyone did just that. OpenBSD [did something similar a year ago](http://marc.info/?l=openbsd-misc&amp;m=138972987203440&amp;w=2), and I admire them for it.
Since I started using this a couple of months ago I made a permanent switch from Sublime Text to IDEA/Pycharm for my perl work. Thanks so much for all your work! 
That's not actually the "why you need to do it". That's the solution you settled on, and the solution is wrong unless you can explain a situation that exists that makes you need that solution.
Easy! When you use `$schema-&gt;deploy`.
Looking at the ReadMe on zef's github. zef seems way more user friendly and more robust in general. But maybe panda just has a lackluster ReadMe...
I spent way too long trying to work out which new plugin I've never heard of they were going to use to do Github API calls. &gt; Oh, not actually interacting with github, just creating markdown files that github just so happens to format nicely. You could also put ".pod" files in your directory, and Github will also format those, but clearly ".pod" is not purely for Github. But funnily enough, Github renders POD with crosslinks far more reliably than Markdown, due to fun facts about how it takes `dest` in `[link](dest)` as a literal value, while `# Heading::Colons` gets munged by Github to `&lt;a id="HeadingColons"&gt;`, and so you're forced to guess how Github is going to render your link-destinations while you're writing them. Which is a bit suck. --- nb: If you do that trick with `EUMM`, make sure you add the `.pod` files to `/INSTALL.SKIP`, eg: CONTRIBUTING\.pod$ README\.pod$ Its a list of regex that filters files between the `blib/lib` staging target and the OS `$DEST` during `make install` And you need to do this because `EUMM` by default thinks $SRC/Foo.pod $SRC/Bar.pm $SRC/lib/Quux.pm Should become $DEST/lib/Dist/Name/Foo.pod $DEST/lib/Dist/Name/Bar.pm $DEST/lib/Quux.pm And you really don't want the first 2 of those. 
I get the feeling it's going to make someone else very unhappy later if you do this, so please don't try to do it.
&gt; It is about my inability to fix the environment I work in Things are moving forward. Improvements are being made. But without you to help push things forward, it will now take longer and be much harder.
The PCB is past due for a new edition.
I'm hoping this makes it. Learning dancer is on my todo list.
Yup. Whoever takes on that job has some big shoes to fill though. http://shop.oreilly.com/product/9780596003135.do nat and tchrist are still around-ish. Any gossip as to their attitudes about filling their own shoes?
Heh, I still have mine and just recently brought in in to work to put on the shelf ..... printed circa 1999.
&gt; Things are moving forward. Improvements are being made. From where I stand it does not seem this way at all. In fact things **have quantifiably regressed** in some ways since my [original writeup on the subject](https://gist.github.com/ribasushi/74ce356123ede727e90f). Things are moving, no question about that. And will continue to move without me. The question is **where** are they moving, and that's the core of why I can not continue putting my name on things within CPAN in its current form.
That'd be odd for two different languages. Has anyone heard anything recently about a perl6 book from a publisher like O'Reilly? I asked this fairly recently on another post and the answer seemed to be no. I'm guessing Larry and the gang who wrote the camel book might have something out in a year or so whenever it is production ready. It'd be nice to see something sooner rather than later. I'd love to even be a beta reader for it.
Quaint last millennium thinking. Who would ever buy a bound copy of wikipedia? 