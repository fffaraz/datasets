Much easier to just use a DOM parser like [Mojo::DOM](http://mojolicio.us/perldoc/Mojo/DOM): use strict; use warnings; use Mojo::DOM; my $dom = Mojo::DOM-&gt;new(&lt;&lt;'HTML'); some stuff.|some other stuff &lt;blockquote&gt;more stuff|and some more&lt;/blockquote&gt; yet more|stuff HTML my $quote = $dom-&gt;at('blockquote'); my $text = $quote-&gt;content; $text =~ s/\|/&lt;br&gt;/g; $quote-&gt;content($text); print $dom; 
http://shadow.cat/resources/catalan/moose1/
Neat. Thanks.
OK, it seems that it is a pretty good module and I am going to be using it. Still seems strange that there's only one module for that kind of task
From https://metacpan.org/pod/release/EXODIST/Test-Simple-1.301001_099/lib/Test/Stream/Architecture.pod#IMPLEMENTATION &gt; This decision will need to be made before we go stable.
This can be done using eval. I have a script which needs to load one of several possible modules depending on the data source it's being called to use. Each module has identical subroutines and outputs so once loaded they're interchangeable. All I need to do is set the handler then call: eval("use HANDLERS::$handler"); Alternatively, as I have in a module in another system my $dbh; if(defined($main::dbh)) { $dbh = $main::dbh; } else { eval { use Db_connect; $dbh = db_connect(); } } 
With python, I generally find that if the code is ugly or awkward, you're doing it the wrong (dangerous) way. Prime example, I recently found some code where someone was doing multiple inheritance by globbing a directory, loading the py files it found, then iterating through the classes exposed to add them to the object. That's just waiting for disaster. 
`eval { block }` happens at compile time, so that will happen no matter what happens in the conditional you've wrapped it in: $ cat Foo.pm package Foo; print "I loaded Foo!\n" $ perl -e 'if(0) { eval { use Foo } }' I loaded Foo! If you want it to happen at run-time, use string-eval or `require`.
I do know about `Rat`, I used Perl in the example to keep it succinct and uncluttered. It came from my attempt to explain to someone else who was using C++ (actually, glorified C, but some people conflate the two) why I prefer to stick with established statistical software rather than roll my own even for the simple case of calculating a sum, mean, or variance. Perl5, I could have used `bignum`, and gotten better accuracy at a cost of performance. A huge cost, it turns out. Like almost 50 seconds per average as opposed to fractions of a second. I am not sure what the performance is like with `perl6`. **Update:** So, this helped me realized that [building Rakudo with MoarVM on 64-bit Windows using Visual Studio](http://perltricks.com/article/135/2014/11/18/Building-Perl-6-with-Visual-Studio-2013) is no longer problem free. I'll see if I can diagnose that later. In the mean time, `perl6` from Rakudo* 2015.02 does the naive mean using rationals in about 6-7 seconds where as `perl` 5.20.2 on the same system takes 0.06 seconds, and the `stable_mean` takes about 0.12 seconds ... All of which is astronomically better than using `bignum`, but still points to why using floating point has its benefits. In any case, there is a valid reason to use floating point, but one has to understand one's own limitations. 
Yup, eval (the string variant) can also be used, but it traps the error so the full equivalent of `use if $cond, "Foo"` is: if ($cond) { eval "use Foo; 1" or die } I personally prefer using `require` unless I want to trap error.
OOPS! That's my extrapolation coming back to bite me. Thanks.
That has nothing to do with Python; that's idiotic in any language.
I see that. Those folks were probably sun's profitable customers, but it ignored sun's roots... Unixy, tool using folks.
not sure what you are trying to accomplish by pasting this quote. Once we go stable the decision is locked in, so far nobody has protested that decision so I am not changing it. Is there anything actionable you wish to see done?
Agreed, Python is a fine language, These kind of posts come around every once in a while ... best to ignore
 say time(); my $deadline = time() + 5; while (time() &lt; $deadline) { # do something } 
If the author expect something different for a product that is made to produce income (no, its not a "freedom project" or something in that direction), then he must be new to IT ;-).
You could, but you *should not*. If you cycle waiting for time you're using up the system's resources. You need to be using sleep(), or the versions in Time::HiRes (better accuracy). print time() . "\n"; sleep( 5 ); Failing that, you need to be using the alarm() functions as described in the perldocs (useful when you're working with event loops).
Of course, you could've just used "sleep 5" but I guess that was too easy...
I agree, it runs consistently forward.
No-one has actually explained what the problem is with your approach. So in case someone else comes along a reads this in the future... There are two problems here. Firstly in the code you show us, you only ever set `$time` once. You need to change its value in your loop (probably by running `$time = (localtime(time()))[0]`). I expect you just omitted that from your example code. The second problem is more serious. You're basing this on the seconds value that you get back from `localtime()`. That's going to be an integer between 0 and 59 (actually, between 0 and 60 to cope with leap seconds). If you call your line that sets `$delay` at, say, the 57th second of a minute, then `$delay` will be set to 62 (57 + 5). And your `$time` variable will never be more than 60, so the expression in your `while` loop will never be true. Far better, as others have pointed out, to just use the output from `time()`, which is also a seconds counter - but one that just keeps on incrementing.
The first thing I noticed is that 'use strict' and 'use warnings' were not in the code. (See http://perlmaven.com/always-use-strict-and-use-warnings )
Good info, thanks for the reply.
I think a cool thing to draw some attention to is this sort of programming can let you investigate probability of games quite visually and intuitively too. So what happens if I had two biased dice and rolled them together? &gt; my @rolls = ("⚀".."⚅","⚅","⚅").Bag.roll(10000) Z~ ("⚀".."⚅","⚀","⚀","⚁").Bag.roll(10000); &gt; @rolls.Bag.sort({$^b.value &lt;=&gt; $^a.value}).Hash.map({$_.key =&gt; $_.value /= 10000}).say; ⚅⚀ =&gt; 0.1242 ⚅⚁ =&gt; 0.0834 ⚅⚄ =&gt; 0.0452 ⚁⚀ =&gt; 0.0448 ⚅⚅ =&gt; 0.0436 ⚅⚂ =&gt; 0.0424 ⚀⚀ =&gt; 0.0418 ⚃⚀ =&gt; 0.0411 ⚂⚀ =&gt; 0.0393 ⚄⚀ =&gt; 0.0389 ⚅⚃ =&gt; 0.0389 ⚁⚁ =&gt; 0.0287 ⚀⚁ =&gt; 0.0282 ⚃⚁ =&gt; 0.0272 ⚂⚁ =&gt; 0.0272 ⚄⚁ =&gt; 0.0264 ⚄⚄ =&gt; 0.0157 ⚀⚃ =&gt; 0.0149 ⚂⚂ =&gt; 0.0146 ⚂⚃ =&gt; 0.0145 ⚃⚂ =&gt; 0.0144 ⚄⚂ =&gt; 0.0144 ⚁⚄ =&gt; 0.0144 ⚄⚅ =&gt; 0.0143 ⚁⚂ =&gt; 0.0143 ⚁⚅ =&gt; 0.0142 ⚂⚅ =&gt; 0.0141 ⚄⚃ =&gt; 0.0141 ⚀⚅ =&gt; 0.0138 ⚃⚅ =&gt; 0.0137 ⚁⚃ =&gt; 0.0135 ⚀⚂ =&gt; 0.0134 ⚃⚄ =&gt; 0.0132 ⚂⚄ =&gt; 0.013 ⚃⚃ =&gt; 0.0127 ⚀⚄ =&gt; 0.0115 So in the above I have one die that is 3x more likely to roll a 6 than a normal die and then the second die is actually a bit more complicated because there is a 2x weight on the 2 and 3x weight on the 1. So it's not as simple as just 2x and 3x bias because each of them effect each other. But you don't have to worry about that exact probability since the .Bag.roll(10000) takes care of it for you. The .Bag in general lets you collapse a list into a count of the elements in the list. A roll on a bag uses those count values as the expectation of selecting a given key. So we create a load of paired dice rolls as little strings using the Zipped ~ concat operation then count all the strings that are identical for those 10000 rolls. Then on the second line we sort by the number of times we observed a given outcome and divide by the total observations getting the expectation. Then print it all out. 
Fair point. Many thanks!
Why not just use try_load_class() from [Class::Load](https://metacpan.org/pod/Class::Load)? 
When `App::cpanminus::reporter` is installed, the script `cpanm-reporter` is also installed to your path. Because your shell reports `command not found`, that means that the installation did not work. Retrace your attempts and post details for further help.
It has been a while since I tried installing but here's the output I get when I just tried to install it. jcarty@Perltesting:~$ cpanm install App::cpanminus::reporter ! ! Can't write to /usr/local/share/perl/5.18.2 and /usr/local/bin: Installing modules to /home/jcarty/perl5 ! To turn off this warning, you have to do one of the following: ! - run me as a root or with --sudo option (to install to /usr/local/share/perl/5.18.2 and /usr/local/bin) ! - Configure local::lib your existing local::lib in this shell to set PERL_MM_OPT etc. ! - Install local::lib by running the following commands ! ! cpanm --local-lib=~/perl5 local::lib &amp;&amp; eval $(perl -I ~/perl5/lib/perl5/ -Mlocal::lib) ! install is up to date. (0.01) App::cpanminus::reporter is up to date. (0.12) 
I feel like these kind of groups are important to the community. Looking forward to checking out some upcoming Cleveland talks!
Hi, Based on your experience with statistics and Perl which modules would you recommend to use to eliminate or at least dampen these errors you demonstrated here?
Private methods: package Foo; use Moo; has 'x' =&gt; (is =&gt; 'ro'); { #-- Group private methods with their clients my $some_private_method = sub { my $self = shift; return $self-&gt;x + 3; }; sub some_public_method { my $self = shift; return $self-&gt;$some_private_method(); } } #-- END grouping package main; use strict; use warnings; use 5.10; my $foo = Foo-&gt;new(x =&gt; 7); say "x = " . $foo-&gt;some_public_method; 
And do you use this?
In practice, yes, but I generally try to avoid private methods. I have adopted the philosophy that private methods represent a code smell of some sort, usually an organizational modeling problem, especially if the private method is used by more than one public piece of API. This was probably a tradeoff between release time and crafting something beautifully modular. If it is used by only one public piece of API, then the private method exists (justifiably and hopefully) to aid readability, and it should probably be scoped anyway to the method using it, using my technique above or declaring the sub within the one method using that code. 
There's some niche communities across multiple subjects. The big boys are of course java and .net oriented but there's also Linux user groups, ruby people, scala, big data/hadoop, python, raspberry pi/arduino, Web dev, etc. Depends on what you're interested in!
https://twitter.com/briandfoy_perl/status/580240526026379264 ... just kidding. Both other recommendations are good. Depending on what you want to do with Perl, there might be an even more specialized book. I really enjoyed _Perl for System Administration_, and there's _Perl for Bioinformatics_ and various other things.
[**@briandfoy_perl**](https://twitter.com/briandfoy_perl/) &gt; [2015-03-24 05:31 UTC](https://twitter.com/briandfoy_perl/status/580240526026379264) &gt; What should I do with this Intermediate Perl in a language I don't read? :) [[Attached pic]](http://pbs.twimg.com/media/CA1tpvrUwAA8YVy.jpg) [[Imgur rehost]](http://i.imgur.com/TtOLH9d.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Im running Arch so i got systemd :) Iv looked around, the general consensus seems to be to put a udev rule which runs my script. The problem is they all seem to use a specific device, by hard coding the UUID of the device into the rule. I want to have this script run when any flash drive gets plugged in. Looking at the Arch wiki theres also something about udisks, udevil, and some other similar sounding things, i dont really understand if thats whats needed though. Im doing this as a sort of programming exercise i guess. I figure once i can figure out how to get this part working the rest will be pretty easy. Since its just a matter of asking the user yes or no, and upon yes i just run `mount`.
I think [Beginning Perl](http://www.amazon.com/Beginning-Perl-Curtis-Poe/dp/1118013840/) by Curtis Poe is one of the best introductory texts for complete beginners.
If your starting out in Perl plugging into the community is worthwhile. There are three things to look for:- See if there is a local [perlmongers](http://www.pm.org/) user group See if you can get to a YAPC (low cost 3 day Perl conferences) or Perl Workshop (free one day Perl conference) https://www.perl.org/events.html Sign up to http://perlweekly.com/ to keep abreast of things Perl and for ongoing good stuff http://perlmaven.com/ EDIT: I'm going to start posting this to any "I'm a beginner" thread any other suggestions as to other resources I should add.
I'm a beginner programmer as well. I've found the tutorials on the perlmaven.com site to be very helpful. Thanks Gabor Szabo.. I also have the latest edition of Learning Perl and it's a good book for beginners. The 6th edition came out in 2011, so I'm hoping it teaches modern perl syntax. It seems to. It appears to me the learn.perl.org site is a bit out of date. I could be wrong. Modern Perl seemed to be a little harder to follow for a beginner, at least for me, when comparing to the previous resources i've mentioned.
Well its on its 6th edition or something like that. So i believe so.
Parse the output of dbus-monitor --system "type='signal',sender='org.freedesktop.UDisks2',interface='org.freedesktop.DBus.ObjectManager',member='InterfacesAdded'"
This won't help much because you want to deal with file systems and mount points, but udev only gives you devices, so you need udisks2.
What is udisks?
Using the [Kahan sum](http://en.wikipedia.org/wiki/Kahan_summation_algorithm) also produces 500000000.600000, and better yet -- it gives the identical answer regardless of sort order. It will be slightly slower. E.g. sub kahan_mean { my($c,$s,$y,$t)=(0.0,0.0); for (@_) { $y=$_-$c; $t=$s+$y; $c=($t-$s)-$y; $s=$t; } $s / @_; } One of my modules has a lot of functions with summations, and this helps reduce the errors (that and using long doubles internally where possible). I'm certain there are still places I'm making horrible numerical analysis mistakes however -- this is hard.
Starts at about 1:04:00, and it's not subtitled. It's in an [unprocessed form in Github](https://github.com/meis/talks/tree/gh-pages/R-for-Perl-Hackers), and on GitHub pages as [R for Perl Hackers](http://meis.github.io/talks/R-for-Perl-Hackers/#/).
Or, you know, you could just use `zcat` or `zless`.
Mommy, make the bot go away.
My experience with projects that are estimated as "simple, ... no longer than an hour" is that they are not simple and take at least 4 hours. So don't feel bad if the estimate is 4 hrs and people want at least to be paid 240 USD.
I see where you're coming from. Really, I didn't mean a professional in that sense; I meant compared to myself. I'll post up a pseudo-code (?) of what I'm looking for. Thanks for your input!
go for it, I worked for a couple of years doing GIS in Perl and right now I'm kind of bored and already invested 10 minutes replying to you &gt;;3
The usual and cheapest tactic for this is to do it without modern perl and lots of mistakes and let Stackoverflow correct everything for you. :) 
Besides, I don't know much about KML files, so I would struggle to make a start.
Using `PerlIO::gzip` did provide a significant speed advantage over all other methods I tried the last time [I needed to squeeze more performance out of reading gzip'ed data files](http://www.nu42.com/2013/02/large-gzipped-files-long-lines.html). I should check again with the updated module, and the [SDD in my trusty MacBook](http://www.nu42.com/2014/06/did-i-really-need-to-put-ssd-in-my.html). 
KML is just an XML file often zipped up, so any software for manipulating XML will work.
Understood. Thanks
In retrospect, this is mildly amusing and explains the source of my disgruntlement this morning ... Yesterday I answered a question on stackoverflow. It was about generating KML files and the OP did make reference to animals within a certain distance of a point. It seemed a bit like a homework question so rather than answer directly, I provided some reference links and gave them an example of how the XML::Generator module might be used to plug data into an XML document. This morning I went to check if anyone else had answered and discovered that the original question had been deleted! Sounds like a job applicant covering their tracks.
It is likely that the reason your very simple perl example was faster than `gunzip` was because your script wasn't writing anything out to disk.
How did your perl script compare to zcat or zless, which won't touch the disk for writing?
I have a solution for you. You can try the more powerful, more open, more Linux supported [pinguino](http://www.pinguino.cc/)
You're going to have to explain what you want to the person who does the work anyway.
Nice article. Another PPI-based approach is [PPI::Prettify](https://metacpan.org/pod/PPI::Prettify), which uses the same markup as Google's prettify.js, which means you can use prettify.js CSS themes, but not require prettify.js (or any JavaScript).
Uh, no.
I know Perl 5.20 has been there for a while. But I don't see a Perl 5.20 interpreter app available from the Play store. Is there any reason behind this?
Most applications communicate with the webserver of FastCGI or something of the like. For a single webpage this may seems silly. But on my server I host a static html page, a php-fpm powered page, a rails powered page, and a catalyst powered page. A single webserver handles all incoming requests and dispatches to the correct application based on the domain (eg. mail.domain.com or git.domain.com).
Part of Dancer's appeal is that you don't have to deal with antiquated CGI programming which you are almost guaranteed to have to use through any traditional web server. Dancer is great for quickly deploying something and by having a dedicated, single-instance web server, you don't have to waste time messing with Apache or whatever to make sure everything stays bottled and separate. You could also use something like Nginx to route your traffic to each individual deployment with minimal work. Basically, Dancer makes you not have to deal with CGI and makes things a lot cleaner and easier to deploy overall. You can technically use Dancer under Apache if you want though with something like Dancer::Deployment.
so the dancers server basically helps when developing the web app, by cutting down trouble configuring the web server?
It helps with developing a lot in terms of organization and testing. If done right, it can make your web server configuration a lot easier to deal with. It reduces maintenance too. The biggest thing it helps me with is making adding and removing applications a lot easier. Since everything is bottled, I remove a folder and a couple lines from my configs and it's like the thing never existed. The way Dancer's server stuff works also makes it a lot easier to do CGI type stuff without having to do it the old CGI way which results in a massive amount of boilerplate code. I can write some one-off converter in like 20-40 lines of code in Dancer that would be at least 100-200 lines using CGI.pm. I can have it up and running and all of that in like 5 minutes, while it takes a lot longer with Apache to make sure everything is sane and won't cause issues down the line (documenting where assets are, what changes were made to the configuration if any, etc.). TL;DR: it makes configuring pretty much everything easier but also makes the organization and even the actual coding generally easier.
Which web server are you using? EDIT: [Here's a good example](https://www.digitalocean.com/community/tutorials/how-to-use-apache-http-server-as-reverse-proxy-using-mod_proxy-extension) if you are using Apache in a Debian/Ubuntu environment.
Just wanted to let you know that I finally figured it out!
I don't want to spoil it! I don't know anything about coding, but I put the code into a free code testing website, and then you have to enter the right input. It took me forever to figure out what to put in the input, and it finally hit me the other day.
Just PM me the answer xD I have seriously given up on that step XD
Dancer, like most actively developed Perl web frameworks, uses [Plack](https://metacpan.org/pod/Plack). Plack is an implementation of [PSGI](https://metacpan.org/pod/PlackSGI). ([wikipedia](https://en.wikipedia.org/wiki/Plack_%28software%29)) "a standard interface between web servers and Perl web applications or frameworks" So Dancer does not really come with its own webserver, instead it implements all that is needed to work with Plack and voila, you can run with a simple standalone server or behind a webserver like Apache, Nginx, ...
I work at a company who's code base is written in Perl. I think one reason why other languages have the attraction they do is either a real or perceived situation of lack of new developments in the open source community. Yes, there is a lot out there in perl, but a lot of it feels like it isn't bring maintained. I am a novice programmer, that cut my teeth on python. Coming into a company that uses perl, I get a sense that my skills won't be as transferable learning perl as if I were learning another language. The other piece to it, is the amount of gotchas and "be careful doing this, because perl behaves in strange (although predictable) manner. The last bit, from my point of view, as a newcomer to programming, is that the resources for learning are just better for other languages. Many free and paid learning resources out there have Java, C, C#, Python, Javascript...but not perl. There are is a ton of new content being generated about the above languages...not so much with perl. Frankly, I think it's a bit of a chicken and egg situation. Fewer new users and less content means fewer people see it as attractive means fewer people learn it and create content means...and we start the loop again. That said, working for a company that uses perl goes a long way in making me learn and use it.
Python might be less flexible than Perl, but Python is a more unified and simpler language to get started. It also has a lot more batteries included. In many situations you need to install extra stuff for Perl to be usable (e.g. XML handling) or to be nice (e.g. Path::Tiny). In Python these are part of the standard libraries. In Perl you have to make a lot more decisions (which CPAN module to use) than in Python, and people, especially when they are not familiar with the space (e.g. beginners), have a hard time to make these decisions.
They do not have to run their own server.
More people in my field use python so it's easier to share code. Also if perl had a ipython notebook equivalent that would be awesome. 
The lack of good teaching tools a big one, particularly interactive tutorials. The codeacademy python intro is excellent (and fun). A perl equivalent would go a long way.
&gt; You know, I wonder if perl doesn't suffer a bit from what X11 did... The X Window System never enforced policy, a program could do and look like anything... And everything written in it looked different. The popularity of Windows currently says this is not a problem. Even MS can't keep a consistent look in their own software or consistently use the same toolkit. 
Can Dancer server coexist with Apache on single host and sharing the same TCP port?
As I said elsewhere, it's not about saying this approach is better, it's about understanding that the separation of concerns is just as important for the full software stack - not just the bits you write. Making a particular web server or it's configuration an integral part of the application configuration is a serious breach of this principle, with several significant downsides.
I wrote some thoughts about this subject last year - [Perl's Problems](http://perlhacks.com/2014/09/perls-problems/).
Kind of? You would use something like a reverse proxy or something like Dancer::Deployment. I'm not really familiar with that setup with Apache so I can't be more helpful.
not bd but why compete with matplotlib and pandas? 
I only started using Python about a month ago, to write a Reddit bot. Things like no increment operator annoyed me on principle, but what really made me throw my hands up was not being able to include a file from a subdirectory. I'd written some library files, and naturally they began to clutter things up, so I wanted to stick them in a library folder. After not being able to figure out how to do that, I googled and found out why. Here is [the Stack Overflow answer of how to include a file from a subdirectory:](http://stackoverflow.com/questions/279237/import-a-module-from-a-relative-path) import os, sys, inspect # realpath() will make your script run, even if you symlink it :) cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0])) if cmd_folder not in sys.path: sys.path.insert(0, cmd_folder) # use this if you want to include modules from a subfolder cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"subfolder"))) if cmd_subfolder not in sys.path: sys.path.insert(0, cmd_subfolder) What the everloving fuck? _I just want to include a file._ I would simply drop all my functions in at the end of a file, but Python is completely in-line, meaning functions need to go at the top, which means the script becomes totally unreadable.
You'll find that people will be more willing to help you (both here and in life) if you can demonstrate that you actually put some effort into solving the problem. 
How to get printf documentation: perldoc -f printf # perl's brief description man -s 3 printf # a more detailed description 
I tried a multitude of things that I know, including going on a number of Web resources to try to help me with this problem. I didn't mean to come off as lazy college student looking for the easy way out. I'm just not sure where else to turn. I've tried messing around with the %s and %f parts of printf, but had zero luck. 
&gt; I tried a multitude of things that I know, Show us what you've tried, and explain how they didn't work, and we can go from there.
1) something involving open() and close() to access files, something involving print() or say() to output text, something involving length() to find out how long a string is, something involving the repeat operator 'x' or the substr() function. 2) If you're doing it with printf, your solution will involve '%s'. If you have a command-line terminal on your machine, you can learn about commands, say the open() routine, by typing the command "perldoc -f open" into your terminal window. or you can ask cpan.org, or simple google "Perl open() routine". Similarly, "perldoc perl" will show you the first perl doc, which has a guide to the others. There's info about if/then/else blocks, loops, and so on. Not to mention what's in your textbook.
 #!/usr/bn/perl use warnings; use strict; # open the data file to get the data from open (IN, '&lt;', 'data.txt') or die $!; # open and create the file to where the new checks will go open (OUT, '&gt;', 'output.txt') or die $!; # declare all variables my ($first, $last, $ssn, $city, $union, $reghrs, $rate, $dep, $ovrtime); while (&lt;IN&gt;) { #while not EOF #split input line into variables of data $first, $last, $ssn, $city, $union, $reghrs, $rate, $dep, $ovrtime) = split(" ", $_); my $grosspay = ($reghrs * $rate) + ($ovrtime * 1.5 * $rate); my $fedtax = 0.14 * ($grosspay - 13 * $dep); my $ssd = (0.052 * $grosspay); my $citytax = (.04 * $grosspay); my $uniontax = (.0475 * $grosspay); my $netpay = ($grosspay - $fedtax - $ssd - $citytax - $uniontax); my $regpay = ($reghrs * $rate); my $otpay = ($ovrtime * 1.5 * $rate); my $paystring = "$grosspay"; # process the data my $x = 100; # width my $y = 96; # number of "hollow" rows my $solid = '*' x $x . $/; my $hollow = '*' . ' ' x ($x-2) . '*' . $/; print OUT $solid, ($hollow) x $y, $solid; printf OUT ("XYZ Corporation \t\t\t\t\t Date: March 26, 2015", "\n"); print OUT "\n"; print OUT "999 John Doe Street \n"; print OUT "New York, NY. 10304. \n"; print OUT "\n"; print OUT "Pay to the order of: $first $last \n"; printf OUT ("\t\t\tThe Amount of: %10.2f dollars,and cents \n", $grosspay); printf OUT ("\t\t\t\t\tsigned:\n"); printf OUT ("\t\t\t\t\t\t President, XYZ Corporation\n"); print OUT "--------------------------------------------------------------------------------\n"; print OUT "\t\t\t\tSUMMARY\n"; print OUT "Social Security Number: $ssn \n"; print OUT "Regular Pay: $regpay \n"; print OUT "Overtime Pay: $otpay \n"; print OUT "Gross Pay: $grosspay \n"; print OUT "Federal Tax: $fedtax \n"; print OUT "Social Sec. Deduction: $ssd \n"; # make an if statement to see if lives in city or not if (($city eq "c") || ($city eq "C")){ print OUT "City Tax: $citytax \n"; } else{ print OUT "City Tax: 0 \n"; } # make an if statement to see if part of union if (($union eq "U") || ($union eq "u")){ printf OUT "Union Dues: $uniontax"; } else { print OUT "Union Dues: 0"; }
Storable?
[Cannot recommend `Storable`.](http://stackoverflow.com/a/10684780) It is version dependent on Perl. Older versions cannot read newer version's format. This is problematic in a heterogenous production environment. Prefer serialisation formats that are backed by a formal description or standard, such as Sereal, YAML, JSON.
To me that's the same amount of noise; you have just moved the comments and changed the wording. The comment is (to me) still the same, and unneeded (in my opinion).
His example is bad, but the idea is good. 
To me this is clear from the code, so why add an English "explanation"? To me comments like this are equal to: $counter++; # increment the counter by one I might code the example code like this: sub consume_bananas { Monkey-&gt;new()-&gt;eat( $_) for @_; } No need for comments, IMO.
What I put in my comments is the history of my decisions. For example, I think about two ways to solve a problem, but can't find a way to decide between them, so I just choose one and implement it. This is a very good thing to put in comments, because the other solution could come in handy in the future. Or just to understand the engineering decisions that went into the program.
Many of the examples, including that one, are intentionally "what not to do".
Yes, that's a good example; if you (or someone else) can ask himself/herself "Why didn't he/she ..." a comment should be added. Another one: when I implement an algorithm I add a comment that gives the source of the algorithm (e.g. "Introduction to Algorithms, 3rd edition, p455-457").
I maintain one project were it's better not to do that :-) ;-)
&gt; Comments are not source control hell yeah! I had one $client whose source code would start with pages of change history and the code was peppered with irritating inline anecdotes like: changed by John Doe 2015-03-04 
The curious thing about those sorts of annoyances are the limitations of the things that drive them. In this sort of case, I've seen two main factors: 1. Their instructor required it because it makes the instructors life easier (as with many of the bad practices that come out of formal training) 2. The source control system they first used didn't have good tools for looking at history.
Agreed, Storable needs to die! I've been bitten a few times by it in the past decade. Now I avoid it like the plague. In the past we were stuck with it because we didn't have a replacement. Now that the guys at booking.com have produced Sereal, there is hope.
Quack and Hack is tomorrow! Looking forward to see ppl there :)
Dancer, Mojolicious and Catalyst applications can be deployed using Apache (for example via fastcgi or modperl), but you can also use a pure-perl server, which is very handy for development (no need for root access to configure your apache, for example). That said, Mojolicious comes with *two* pure-perl web servers: one for development, which automatically reloads changed files for you, and one for production, which has websockets support - I don't think Apache offers that, nor would I know if there was a standard way to to handle the websockets/application boundary with perl.
Last year, we upgraded from 5.8 to 5.18. The only worthwhile improvement for me personally was the // stuff. I love having defined-or, because I no longer have to think if I'm making a mistake that matters when using || instead of doing the whole "defined($x) ? $x : $y" crap. Unfortunately, I had to fix every place that did "for $foo qw(x y z)" because that doesn't work anymore. Also the "use fields" changed, we no longer have compile-time pseudohashes with 'bless [], Package'. That probably harmed performance and increased memory usage.
Benchmarks are useless unless you give us examples of what you want to benchmark and, sweeping generalisation here, you'll probably get more benefit looking into your own code with Devel::NYTProf and such[1] rather than blindly updating your version of perl. The talk Nicholas gave over a decade ago is still largely relevant[2]. That said, i know there has been significant work over the past year or two in speeding up certain low level operations in perl. If you want to find out about these then look through the p5p mailing list archives[3] and perl commit logs[4]. The most compelling reason to update to the latest version is that there has been a significant number of bug fixes, features, and improvements over the years. Take a look at the perldeltas for more information[5]. Another reason is that module authors are starting to specify a minimum version of perl that their code will work with, and if you're on 5.8 then you may well be excluding yourself from the latest and greatest on CPAN. * [1] https://metacpan.org/pod/Devel::NYTProf * [2] http://www.ccl4.org/~nick/P/Fast_Enough/ * [3] http://lists.perl.org/list/perl5-porters.html * [4] http://perl5.git.perl.org/perl.git * [5] http://perldoc.perl.org/index-history.html
Woohoo, thanks Wendy and Liz!
&gt; we no longer have compile-time pseudohashes with 'bless [], Package'. That probably harmed performance and increased memory usage Have you seen [MJD's talk on pseudohashes](https://www.youtube.com/watch?v=-HlGQtAuZuY)? I don't want to do a TL;DR because the whole thing is worth watching, but if you think pseudohashes helped performance you might be surprised.
MJD's talk on pseudohash is technically not competent enough to recommend it. He has no idea what the actual problems were and how they should have been fixed. 
Here are the benchmarks: http://speed.perlformance.net/timeline/#/?exe=33,22,31,21,29,14,27,25&amp;base=none&amp;ben=grid&amp;env=4&amp;revs=50&amp;equid=off But it misses the old fastest version 5.6.2 and the recent huge performance win in 5.22. (~1.8 faster than 5.14) Where did you get the idea that recent versions had less bugs? I can still only recommend 5.14.4 as the last stable and fast release, but 5.22 does look very good indeed.
The "r" option in "s/foo/bar/r" (which returns the changed string) is very useful, especially inside a map {}.
* Uninitialized-variable warnings now give you the name of the variable. * Unicode has improved all over the place since 5.8. * `//` defined-or operator is very handy. * Y-2038 compliance. * `\N` and `\R` in regular expressions * `delete local` * Non-destructive substitution with `s///r` * String appending up to 100x faster. That's just up through 5.14.
Looks like it is expecting a constant rather than a string for up/down vote. Remove the quotes from the value of the direction parameter.
You're right, it is expecting a constant, however it has this: use constant VOTE_UP =&gt; 1; use constant VOTE_DOWN =&gt; -1; use constant VOTE_NONE =&gt; 0; in the source. I did however try what you suggested, as well as just using 1 or -1.
The function signature: sub vote { my ($self, $name, $direction) = @_; defined $name || croak 'Expected $name'; defined $direction || croak 'Expected $direction'; ... } isn't expecting an args hash. Try calling it as: $client-&gt;vote($id, $direction); instead.
The IPC::Run module has been my go to for capturing output since it's so versatile. It might be arguably more heavy-handed than backticks, but IPC::Run lets me use the a list for my command, so I don't have to worry about escaping things for the shell. \`links -dump $url\` passes the command to /bin/sh -c "links -dump $url", so you have to ensure $url doesn't contain nasty things like "; rm -rf /"; 
How is Reddit::Client working for you? It can be used to write bots, right? I've been using the Python library, but I hate Python, and if the Perl one is functional I'd like to try that. Not that I have anything I need a bot for at the moment. I just like to be able to. You know, _in case_. 
Named captures, ternary operator, declaring variables on the same line, not initializing the $total (there is no need). Reduces the function length by 25% and is still legible IMO (and no line is &gt; than 80 chars for the old school-ists): sub roll { my $input = shift; return if $input !~ /(?&lt;num&gt;\d*)d(?&lt;die&gt;\d+)\s*(?&lt;op&gt;\D?)\s*(?&lt;end&gt;\d*)/; my (@dice,$total); push @dice, int(rand($+{die}))+1 for ( 1..$+{num} ); if ( $+{op} eq 'b' ) { $+{end} = $+{num} if $+{end} &gt; $+{num}; @dice = sort { $b &lt;=&gt; $a } @dice; $#dice = $+{end}-1; } $total += $_ for @dice; return $+{op} eq '+' ? $total + $+{end} : $+{op} eq '-' ? $total - $+{end} : $+{op} eq '*' ? $total * $+{end} : $+{op} eq '/' ? $total / $+{end} : $total; } But i wouldn't write it like that, i would write it like this as i like to be generous with both vertical and horizontal space. I also like to be very lisp like with parentheses to prevent ambiguity and obscure precedence bugs: sub roll { my ( $input ) = @_; return if $input !~ /(?&lt;num&gt;\d*)d(?&lt;die&gt;\d+)\s*(?&lt;op&gt;\D?)\s*(?&lt;end&gt;\d*)/; my ( @dice,$total ); push( @dice, int( rand( $+{die} ) ) + 1 ) for ( 1 .. $+{num} ); if ( $+{op} eq 'b' ) { $+{end} = $+{num} if $+{end} &gt; $+{num}; @dice = sort { $b &lt;=&gt; $a } @dice; $#dice = $+{end} - 1; } $total += $_ for @dice; return $+{op} eq '+' ? $total + $+{end} : $+{op} eq '-' ? $total - $+{end} : $+{op} eq '*' ? $total * $+{end} : $+{op} eq '/' ? $total / $+{end} : $total; } FWIW here's the (pretty poor) tests i wrote before refactoring this function: use strict; use warnings; use Test::Most; my $result = roll( "10d10+10" ); like( $result,qr/^\d+$/,'roll' ); ok( $result &gt; 0,' .. &gt; 0' ); ok( $result &lt; 100,' .. &lt; 100' ); ok( defined roll( "10d10-10" ),'-10' ); ok( defined roll( "10d10*10" ),'*10' ); ok( defined roll( "10d10/10" ),'/10' ); ok( defined roll( "10d10b2" ),'b2' ); note $result; note roll( "10d10-10" ); note roll( "10d10*10" ); note roll( "10d10/10" ); note roll( "10d10b2" ); If you're going to refactor a function to clean it up then always write tests, because it's so easy to introduce bugs. I may well have done in my attempt above, since the tests i wrote are no where near comprehensive.
Install Perl v5.20 and benchmark your particular code. Don't worry about other benchmarks; it only matters if it makes *your* use of Perl faster.
 perl -e "opendir(DIR, '.') || die; my @files = grep { /^[^\.].+(txt|html)$/ } readdir(DIR); closedir DIR; print @files;"
That doesn't do recursive search unlike File::Find.
This code is broken, $_ will only contain the filename and $dir will only contain the base directory. $dir/$_ will only contain a valid path for files actually located in $dir but not for any files found in the recursive descent. You need either cwd() (absolute path) or $File::Find::dir (relative path).
Yeah, didn't get past the first page because you require google account. Not trying to be a dick, just completely honest about my experience. 
 @files = split("\n", `find -name '*.txt' -or -name '*.html'`);
FWIW, you can do the same with File::Find::Rule. Path::Iterator::Rule is better for actual iteration file by file as it doesn't have to build the full list first the way File::Find::Rule does.
A whole lot less. To put things in perspective, your "discount rate" is $26,280 per CPU-year (or more, if "time scripts are executing" includes IO wait). You charge 5 cents per *minute* at your cheapest rate, while Linode charges 1.5 cents per *hour*. No sane person would pay your 200x premium.
Is there a better way to run a linter, that would be more safe?
That makes sense... Is there a best practices for "linting" your own code, that won't run afoul of other **use**d libraries? Obviously I want to get warnings for my code, but not others.
Just make sure you have 'use warnings' in your own code. Then, if you want to get really fancy, check out [perlcritic](https://metacpan.org/pod/Perl::Critic).
Not that I know of. Well, perl -c isn't really a linter, it's closer to a syntax check. [Lint](https://en.wikipedia.org/wiki/Lint_%28software%29) checks for style mistakes. So the closest to that would be Perl::Critic. Perl::Critic uses PPI, but I don't think PPI would notice any syntax errors, perl -c is probably the best we can get. Just be careful about what code you open in your editor. Ideally it would have a concept of a project, so you could turn this on on a per-project basis.
Hm, the benchmark result doesn't show as verbatim even though I've prefixed each line with four spaces. Here's another version: https://gist.github.com/perlancar/927e7f96e1e12111eb52
Just don't actually worry about it, but be aware. This is the standard "advice" thrown around about perl -c. I have *never* actually seen a report of someone getting bitten by a BEGIN payload doing something. The reality is perl needs to do this to check your code with all the modules that alter how stuff is parsed, like certain Moose like extensions. Personally I'd like to know if my dev environment is going to get hacked running some code before it gets into production regardless. For those utterly paranoid open your code in a VM :P Or just use the dumb system editor for a script you have no idea about.
It's counter-intuitive but `my @files;` produces less byte-code than `my @files = ();`. Personally I initialise, anyway, because it is not an optimisation you normally need to worry about, and because I like to program in several languages and making no assumptions about what is inside an uninitialised variable is generally good practice. If you're just going to program in Perl and you feel confident then it is perfectly okay to make assumptions about the value of uninitialised variables.
There doesn't seem to be a way to delete your account.
From your [About Page](https://www.hookscript.com/about-us): &gt; With hookscript you make web apps without configuring a database, managing a server, or creating an account.. In other words, you're entering the PaaS (Platform as a Service) market. That's a great market to be in and I welcome more Perl-friendly PaaS providers. Further, PaaS, despite what detractors say, is has a brilliant future and those who compete well in this area should do nicely. I also have to admit that Prolog looks lovely, too, but I would be surprised at its viability. That being said, **HOLY SHIT** your prices are insane! My apologies for using such strong language (I don't like to do that), but **HOLY SHIT**. I can't imagine for a moment that anyone would pay that and that makes me question the fundamentals of the business. Here's [the pricing for volume discounts](https://www.hookscript.com/pricing): Monthly Charge| % Discount|Adjusted Rate per Minute :--|:--|:-- &lt; $10| 0%| $0.12/minute $10-$20| 20%| $0.096/minute $20-40| 40%| $0.072/minute &gt; $40| 60%| $0.048/minute So let's compare this to OpenShift, a full-featured PAAS. [Here's their pricing](https://www.openshift.com/products/pricing): —|CPU|Memory|Storage|Region|Usage :--|:--|:--|:--|:--|:--| BASIC GEARS | Small |1x|512MB|1GB**|US only|$0.02 / hour* PRODUCTION GEARS | Small.highcpu| 2x| 512MB |1GB**| US &amp; Europe| $0.025 / hour Medium| 2x| 1GB| 1GB**| US &amp; Europe| $0.05 / hour Large 4x| 2GB| 1GB**| US &amp; Europe| $0.10 / hour So OpenShift's lowest price appears to be $0.02 per hour, but your lowest price appears to be $2.88 per hour, or **your lowest price is 144 times higher than a typical competitors**? So either this is one of the most poorly researched business ideas I have seen, or there's something fundamentally different about hookscript that your marketing efforts have failed to convey.
In my specific case here, I wanted to return an empty array if no file matches were found. Which is why I initialized to `()`.
Hmm perl delta from 5.14 to 5.22 doesn't seem to agree with you. If you know of outstanding bugs (and can demonstrate them) then why don't you report them - or better yet, submit a bugfix?
Thanks for the detailed reply. (I'm one of the developers on this project). It looks like we need to better communicate what Hookscript is for. A key distinction is that OpenShift (and others) round to the nearest hour. We round to the **nearest nanosecond** of run time. Our target audience is low volume web scripts. In real world use cases, Hookscript's monthly fees are about 20x **lower** than with OpenShift. An example: We wrote a tiny app (~100 lines of Perl) for my wife to automate SMS reminders for her parent teacher association (uses Twilio APIs). She visits the app once a month (~20 requests spread over 5 minutes). On other PaaS providers I have to run an instance 24/7 for the entire month. On OpenShift, that would cost $14.40 each month. On Hookscript, I end up paying about $0.03 each month. One gets a good price per pound by purchasing 1 ton of chocolate. But sometimes all you need is a Hershey's kiss :-)
OK, that helps to put things in perspective. How have you identified a targeted market for this? It seems to me that the sort of low-volume scripts you are talking about are the sort of things that someone might run on the shared server they already have ... or just off their laptop, or their friend's server, and so on. The concept sounds interesting, but yeah, marketing that message will be interesting.
&gt; ... the sort of things that someone might run on the shared server they already have I used to run my own mail server and git server. Eventually FastMail and GitHub came along. I'd rather pay them a couple bucks each month to manage the servers to I can focus on code. Some developers like the sysadmin stuff. For me, it's been refreshing to ditch my shared server entirely. It's also nice that Hookscript retains the full, raw HTTP request/response messages. That's been great for debugging. &gt; or just off their laptop Most of my small scripts have to react to incoming HTTP requests (Twilio event notifications, GitHub webhooks, etc). My laptop's network connection isn't amenable to that.
Yes, and they are a guaranteed way of getting your data lost, because every Windows program traverses in them when doing file operations, including MS own tools. A simple mis-drag in explorer? Let me delete all your files for you.
I guess you failed reading comprehension in grammar school. Please don't reply to me any more. I'm not your staging ground for a soapbox.
"Windows" doesn't have symlinks, NTFS has junctions and other crap that behaves very differently in certain circumstances than symlinks do. Symlink are a feature of the underlying filesystem... not the OS per se.
&gt; As much as people seem to believe otherwise, the only operating systems in the world are not just variations on a single flavor of Unix. It's not a case that we "believe otherwise", we just spend all our time developing on Unix platforms so inevitably there will be bugs when it comes to dealing with other platforms. This is why we have things like cpantesters, travis, etc.
That's true. But deprecating a good syntax for `for qw` lists is still a not-acceptable behavior, esp. since technically it made no sense at all and the general direction went into the other direction: less useless syntax, not more. perl6 can get rid of unneeded parens in `if` statements.
p5p
I understand that when we are talking about subtle issues. However, the problems I complain about are almost always related to hard coded file paths, paths interpolated into regex patterns, paths being treated as plain strings. `File::Spec` despite all its warts, has been around for a long time. To get to finding the more subtle errors, justifiably difficult to anticipate issues, one needs to first deal with a lot of other unforced errors due to a seeming insistence on not using the portability features offered by Perl and CPAN. See for example [Tests failing due to directory separators are unforced errors](http://www.nu42.com/2014/11/tests-failing-due-to-path-separators.html).
The Windows part of that.
So it's running a web server 24/7 you aren't paying for and you only pay for the runtime of a request to your script? I can almost see the utility in that. I'm still not sure I have a use case because all it would take is 5x low volume hookscript scripts to completely warrant a full server else where anyway which I could be doing a lot more with without worrying about pricing.
I'm definitely in favor of reducing useless syntax. It seems like this is a conversation that should include the perl devs. Otherwise I don't see how it will translate into a concrete change. My experience with the current Perl dev team has been very positive. I think this would be considered if submitted as a pragma proposal. Code would need to be included, of course.
&gt; because every Windows program traverses in them when doing file operations, including MS own tools. A simple mis-drag in explorer? Let me delete all your files for you. What? Really?
Would you rather fight one Perl sized duck or 100 module sized horses?
Apart from there isn't much sysadmin thanks to Docker... DigitalOcean have a really simple to use API too. I'm not trying to nay say on the idea I think it is good, but the pricing isn't something most people are going to go for.
For a new language, would you rather create one Perl sized Lisp or 100 Lisp sized Perls?
This, 100x this.
I'm pretty sure Perl6 is rather obviously not 100 Lisp sized Perls. However were he to do it over again ... I'd be curious :)
Interesting concept, thanks. Deciding when to cull the seemingly-dead code could be the tricky part - especially for large apps that have lots of rarely-used features - but at least you'd have something to go on, and perhaps it would even prompt some feature culling too!
Soon to be the minor motion picture, "Perl 5: Still Trapped in the [Osborne Effect](https://en.wikipedia.org/wiki/Osborne_effect)"
brian missed the two biggest changes: * internal performance is up by 1.8. new multideref and signatures op and esp. cached class pointers. compile-time known class and method names are now pre-initialized into the class cache. SUPER::new is now parsed at compile-time. * new OP_PARENT, op_sibling is gone. * Unicode 7.0 * UNIVERSAL-&gt;import (e.g. use UNIVERSAL '...') is now fatal * -fstack-protector-strong as new default made perl slower, and the added security is questionable. * empty sub bodies containing only undef are now "inlined" * non-utf8, non-magic length is now 20% faster * in @array = split the assignment can now be almost always optimized away. * lots of more such lvalue assignment optimizations with other ops. syntax wise: * new bitwise string operators * sub signatures parsed before attributes. * defined(@array) and defined(%hash) are now fatal * literal { needs to escaped in a regex * prefer subs over barewords with the * prototype * constant inlining of sub () { $var } may now throw deprecation warnings when the $var refers to a closed over variable, and a side-effect to change $var was ignored or not detected. it produces however still wrong code. 
Module::Build is out. What is the "way" now? These things seem to wax and wane.
&gt; internal performance is up by 1.8 Performance has increased 1.8 percent?
I'd really have liked to see them in `JSON` and/or `XML::Simple` as core modules. Everyone seems to use JSON these days, it'd be nice if that were a core module.
JSON::PP has been in the core for a while now but it is really only there to support CPAN. XML is definitely not going to happen.
I wish XML::Simple would die :)
I don't think either should go into core personally. The fact that "these days" in your comment might mean it isn't always so but then we are stuck with them in the core until someone decides to yank them out. Core should be small IMO.
Worse than SOAP::Lite?
180% percent. 1.8 times faster, almost twice as fast.
You have install Module::Build from CPAN if you need it. It was always instable, insanely slow and very hard to work with. Hopefully CPAN will change it's preferred mechanism back from MB to EUMM soon, the old and only sane default.
core should be small, but the required modules to provide upgrades should be included. Otherwise you will be stuck with the once installed core module set and will not be able to install anything else. JSON is required for CPAN.
What the... that's HUGE. How is that not the #1 bullet point? Where did you read it's that much faster, I haven't heard that yet.
Is that why `Digest::MD5` and `Digest::SHA` are in core?
I have a couple of projects using Module::Install which isn't bad. I have one project using Module::Build and I'll probably migrate that to Module::Install. I can't remember if any of my stuff is using EUMM directly, but I do have some Dist::Zilla things that are outputting EUMM/Makefiles.
I'm not sure if Dist::Zilla does this, or if it's possible for a CPAN linter or something to do it, but rather than just saying "Either way, always declare a dependency on everything you use despite its provenance." it would be nice if there would be a warning every time someone does this. It may be rare for a module to be moved out of the core, but if it's best practice to declare a dependency on everything you use then I'd rather it trip a warning when I upload to CPAN (or before upload) than have it documented on the web and ignored :)
&gt; UNIVERSAL-&gt;import (e.g. use UNIVERSAL '...') is now fatal FAIL. I assume the only reason for this change was "because fuck you."
AWS support in Perl is generally not good. One of the reasons I switched to Python and have hardly looked back. If someone who's a big time Perl evangelist wrote the equivalent of boto for Perl, that would resurrect Perl in a big way.
Props to Tim Kay and his very helpful [script](http://timkay.com/aws/), which I used for a long time. I eventually made the plunge into the official AWS CLI (which is also written in Python and is apparently distinct from boto), just to ensure I was using something that adhered as closely as possible to the rapidly-expanding array of AWS services. I'll even admit that I still write AWS scripts in Perl, and I actually make system calls to the Python CLI commands. Shameful, I realize. Oh wait, what is this? Somebody wrote a whole [CPAM module](https://metacpan.org/pod/AWS::CLIWrapper) that does the same thing. I keep telling myself that I'll dive into the guts of AWS again and either write my own Perl classes for it or contribute to whatever project seems to match up with the way I'd like to use it. But alas, time is precious. While I use the CLI that is written in Perl, make not mistake: I don't code Python, not a dime. I don't like it. But I'm willing to use a good piece of software, no matter what it's written in, and I like the AWS CLI.
I hear you. I can say that the AWS CLI for Windows definitely uses boto, since I had to put a file in a directory under blah/botocore/blah to test out an experimental new AWS feature.
Thanks for the clarification- this service is perfect for me! I'm constantly doing small projects with small volumes that I would like to scale once I'm satisfy. 2 questions- in your unbias view how reliable (eg uptime) is your service and would u ever consider perhaps a upper tier service similar to your competitors?
[Paws (Perl AWS)](http://search.cpan.org/~jlmartin/Paws-0.03/) is a new project to provide a comprehensive API.
Neato. I toyed around with a one-liner that does about the same thing for standard output. perl -Mojo -E 'say g($_)-&gt;body =~ /((?:\d{1,3}\.?){4}:\d{1,4})/g for @ARGV' $url1 $url2 ...
I have a friendly tip: When there's already free, tested code written by someone else that solves the problem, use that code. That way, on the average you'll be more productive and have fewer bugs to deal with. 
Finnish.
&gt; I'm just overwhelmed each time I hit any part of this Unicode stuff. I know what you mean. The computing and locale issues related to the world's languages are fundamentally complex and the Unicode standard covers just about all of them. One bit of good news is that the Perl 6 design as it relates to Unicode explicitly addresses the most fundamentally confusing issue, namely that ["extended grapheme clusters"](http://unicode.org/glossary/#extended_grapheme_cluster) are what humans think of as "characters" and these latter ought to be the fundamental units of "strings". Excerpting/editing the OP: * **Bytes** are the way things look on disk, on the wire, and in memory. * **Codes** are things that Unicode gives a number to. * **Graphemes** are what ordinary humans call “characters”. * **Strings** should work in terms of graphemes. When you specify an offset for computing a substring, then you should never be at risk of your grapheme getting cut into two pieces. &gt; "v" and "w" are to be considered equivalent for sorting purposes, and "ä" is not a variant of "a" but a letter in its own right. Yeah. Aiui, simplifying, these are locale issues covered by [CLDR](http://cldr.unicode.org/). In the Perl world that means [nick patch's Perl CLDR project](http://perl-cldr.github.io/). The Perl 6 design process has included many discussions related to CLDR issues over the years but ended up postponing almost all related design work. Presumably, once NFG (ie the work discussed in the OP) has landed and matured a little, various pieces of CLDR will rise to the top of the Perl 6 Unicode design and implementation to do list.
One thing that worries me though is that "grapheme" apparently can be a collection of unicode codepoints. This means that you can no longer represent a character by a single value, even if it were a 32-bit integer. Bad times. I'm convinced that we'll soon have unicode characters for individual penstrokes, so that through composing them we can describe every character in the world, including those not invented yet...
If I want to test this myself can I just install 5.21.10 with perlbrew?
&gt; how reliable (eg uptime) is your service Our goal is to be as reliable as the underlying Google infrastructure that we run on ([99.95% availability in 2014](http://www.networkworld.com/article/2866950/cloud-computing/which-cloud-providers-had-the-best-uptime-last-year.html)). Our private beta is only 2 months old, but we've met that goal so far. &gt; would u ever consider perhaps a upper tier service similar to your competitors? We're certainly open to something like that. We've toyed with steeper volume discounts (currently 60%) or maybe having those discounts start sooner.
What's types of code are 180% faster? I'm benchmarking some code on 5.20.2 vs 5.21.10 and I'm not seeing much difference.
Nice, cased numbers.
just wondering how would that make a difference? Can you not see the code that i posted?
alright i will post it on github
The second `eval` isn't really needed. This works just fine: say "$mode: $tag" if $c =~ /^\p{$mode}/; as variables are interpolated in regexes, too.
https://www.youtube.com/watch?v=8SkdfdXWYaI as an example of how to actually do this... at least for Python
I think your life gets a lot easier if you use `$ARGV`. #!/usr/bin/perl use strict; use warnings; my %stats; my %total; my $str_fmt = "%-20s %-10s %-5s %-5s\n"; my $num_fmt = "%-20s %-10d %-5d %-5d\n"; @ARGV or die "Usage: $0 filename [filename ...]\n"; my @files = @ARGV; while (&lt;&gt;) { $stats{$ARGV}{lines}++; $total{lines}++; $stats{$ARGV}{chars} += length; $total{chars} += length; $stats{$ARGV}{words} += split; $total{words} += split; } printf $str_fmt, qw[File Characters Words Lines]; foreach (@files) { printf $num_fmt, $_, @{$stats{$_}}{ qw[chars words lines] }; } if (@files &gt; 1) { printf $num_fmt, 'TOTAL', @total{ qw[chars words lines] }; } I haven't tried to be too clever with the formatting of the output.
Variables are interpolated, but I'm always unsure at which stage, so I usually avoid interpolation in the regex side of things. Good catch, though. 
Do you plan to manipulate the data more frequently than you load data from the server? If so, that's a point for client side rendering.
The problem; people want to browse data that updates fairly regularly, and getting updates means getting full pages of data and formatting, instead of simply getting the new / updated / changed data. In-client rendering seems like a decent solution. A better solution (at least in my mind) is a new protocol and markup language, or perhaps HTML can remain, but a new way of browsing the web, where a page's / site's / app's 'template' is downloaded (introducing an opportunity to allow users to tweak it to their liking) and then dynamic content is regularly fetched / polled. When I reload Facebook and I look at the profiler in Firefox, for example, over 3MB of HTML/CSS/JS is downloaded to my computer. That is a ridiculous waste of bandwidth and data, especially since most of it remains highly similar between reloads.
I don't know how many words of Finnish have around a hundred meanings. There are some, like the word for "standing", or "head", which have variety of abstract meanings that relate to things being upright, or an obstacle, or having come to an head, or to end, etc. But it is beyond my ability to enumerate them -- I'd have to think long and hard to come up with examples, and would still miss many. In any case, "set" is a good example of an extremely ambiguous word.
What platform are you talking about? What I propose is a new platform, essentially. A window that displays some form of markup language, eerily similar to a web browser, but doing the protocol, text and data exchange in a more (hopefully) sensible way for the type of data we look to consume on the internet these days. We've crammed so much garbage into HTML/WWW that was never meant to be there. It's time to start fresh, now that we have an idea of the sort of things we want from a 'browser'.
aargh this is perfect! I've been meaning to figure out how to switch my tests to sqlite3 instead of what I'm doing now (testing against an actual MySQL instance that persists between tests :( ). I had no idea it was as simple as specifying `sqlite3` in the `$dbh` construction, thanks!
The Cult of Testing has apparently infected my brain, because there's a voice in my head saying "running acceptance tests will exercise all the rarely used features; anything else is genuinely dead." Testing and tombstones sound like a combination more powerful than its parts.
I always default to parsing log files. Figure out who hits your apache server the most, and output the top 10 IPs.
Good idea! I just found myself a little job parsing some CSV files that I need to make some changes. Thanks for your help!
https://projecteuler.net is a great way to become more familiar with a different language.
Excellent choice. Look in to `Getopt::Long` if you write command line tools. It's fantastic.
&gt; scrape the web That's on my TODO list as well ;) Thanks!! 
If you're not already, try using the [Text::CSV module](http://search.cpan.org/~makamaka/Text-CSV-1.33/lib/Text/CSV.pm) Poorly formed csv can be a real pain to deal with. 
Write a CMS, it's a rite of passage. It's simple/complex enough, there's so much room to grow. If you want to be really fancy, learn how to write functional style (vs imperative style) code.
Sign up to CPAN PRC http://cpan-prc.org/ Write tests for CPAN modules. Fix bugs in CPAN modules. 
If you want to try your hand at bioinformatics with Perl http://rosalind.info is a good place to get tasks. I did the Python challenge http://www.pythonchallenge.com in Perl too it made the task on Pickle serialisation a bit more fun :)
Are signatures still going to be experimental in 5.22?
Creating methods like this is my favorite potentially-dangerous-but-justifiable technique. Moose/Moo attributes tend to make them less necessary, though.
This looks like fun, cheers mate! 
That sounds quite a lot like pinto (https://metacpan.org/pod/Pinto) , which I've had a lot of luck with - local cpan is such a big easy win I don't know why more places don't do it
So did you get help with that?
There are links to exercises http://perl-begin.org/exercises/
At first I was like "eh? this is silly." Then I read the comments and realized that shebang is more powerful than expected. 
This is what I like about Perl -- practical. Just make it work (and tolerate harmless side effects). Actually this is what I worry about the Perl6 effort -- it starts to care about bullshit (such as a language for next hundred years).
O'Reilly School of Technology is the closest I've seen to an online university experience without having to deal with admissions. [They have a four-level Perl certification program.](http://www.oreillyschool.com/certificate-programs/perl-programming/) You get individual feedback from a real human instructor, not just a robot running tests against your code. 
are you using strict and warnings? if not, you should be. use strict; use warnings; you should also use a lexical fh variable, open(my $in, '&lt;', $fil) or die "Couldn't open file, $!"; finally, cpan is awesome, use it. in this case, i'd recommend https://metacpan.org/pod/Path::Tiny something like this (untested) will do what you want use strict; use warnings; use Path::Tiny; my @lines = path('/home/lum/Desktop/e_coli.fasta')-&gt;lines; my @seq; for my $line ( @lines ) { next if $line =~ m/&gt;/; push @seq, $line; } path('/home/lum/Desktop/comp_e_coli.fasta')-&gt;spew( @seq ); and you should look into grep, you can replace the loop with one grep http://perldoc.perl.org/functions/grep.html my @seq = grep { !/&gt;/ } @lines
You're using the same variable both for the contents and for the file handle. Don't. Use a different variable. open($fh, "&gt;", $filename) or die "there was an error $!"; print $fh $seq; # print $seq to $fh 
Pluralsight.com has 4 videos on perl. You can also check out tutorialspoint.com I think they may have some
Swiss army chainsaw. 
As someone who works professionally in bioinformatics can I *strongly* suggest you stop what you are doing unless you are a student with a specific assignment. Instead use BioPerl for everything like this: http://www.bioperl.org/wiki/HOWTO:SeqIO Even your tr///; to get the complement is going to not do what you want if there are any lower case letters in the FASTA file. This is quite common for either masking, distinguishing intron/exon or indicating quality depending on where the data came from. If you have transcript data then often introns are in lower case for example. It's too easy to make these sorts of basic errors not notice and then pass on the data to other software silently getting utterly bogus results.
Seems like something the developers of the dependent libraries should worry about, and not the people who have their libraries used.
I would guess that it's this issue: Can't link/include C library 'png.h', 'png', aborting. In other words, the Perl module requires that you (separately) have the "libpng" library installed, which is written in C (and isn't part of Perl). So to install "libpng", see: http://www.libpng.org/pub/png/libpng.html
Use brew to install libpng headers
diff
Algorithm::Diff
It will probably help to provide output of the `cpanm WWW::Mechanize` command, preferably by a pastebin
ok: http://pastebin.com/JvvzKJwd Like I said, seems to be the prerequisites. I am running as root.
udemy.com has some courses (not free but afordable) https://www.udemy.com/courses/search/?q=Perl
On further searching, it seems to be a longstanding problem with mechanize: http://www.perlmonks.org/?node_id=901715 The person in that thread solved it by making a script that grabbed all of the dependencies, around 50 of them. So I copied and pasted it, and it seems to be working. It lets me use WWW::Mechanize, anyway. --- As an update in case anyone is still reading this thread, I've installed many modules since then and they've all been fine. It was definitely Mechanize. I'd love to know what can stop something with straightforward dependencies from going ahead, but I only have so much time in a day and I've made a decision not to devote further brainspace to it =p
No, perl is a mess. Seriously, perl is outdated and leaves only because there are many projects already written in perl. It does not support OOP or any other paradigms, all you can find in perl are dog-nails which make it look like it "supports" OOP (or anything else) but that is just an illusion.
Right now, no. I know of no companies who will hire you because you know Perl 6. Ask me again in a year and the situation may very well be different. Perl 6 is hoped to be production-ready this year and there are three planned requirements: 1. The Great List Refactor (GLR — clean up how lists work) * Native Shaped Arrays (NSA — predeclare array "size" for massive performance gain) * Normalization Form Graphemes (NFG — fix some obscure Unicode issues) That last requirement might even get kicked. The first two items in that list will make the language easier to use (and in some cases, safer) and should also allow for some significant performance improvements in many areas. There's also a lot of work currently being done on performance and it's impressive. When it's declared "ready", I expect performance to be on par with many other dynamic languages, but in the long run, it has the potential to exceed them dramatically. Combine that with a working concurrency model, *sensible* gradual typing, a non-threatening [Algol-style syntax](http://c2.com/cgi/wiki?AlgolFamily), and a mind-bogglingly expressive language which can greatly improve developer productivity and I think Perl 6 has the *chance* to be a game changer. I mention the Algol-style syntax because frankly, that's what most developers are comfortable with and languages like Lisp, no matter how powerful, [will struggle to overcome this](http://www.paulgraham.com/syntaxquestion.html).
&gt; I can’t think of a single reason why anyone would pick &amp;my_sub over my_sub(). The only reason I've ever encountered is that the programmer cut their teeth on Perl 4 and still thinks on some level that the ampersand is required. &gt; It would be great if we could remove it from all example code. I completely agree. Also, all production code. :)
Interesting. I was not aware of `goto &amp;NAME`.
I wouldn't rely on knowing any language for finding a well-paid job. If that's your only concern given the other languages you know I would learn one of Java/C/C++/C# none of those have a GIL mostly because the 'I' doesn't apply! They also have the advantage of being very popular with a long history of employment opportunity. Even if something is trending now amongst programmers as :cool: that doesn't mean there are necessarily jobs. Haskell is a great example of this, the first few sponsored job adverts you see on Indeed come up as 'Clojure, Scala, Lisp, Haskell, F# etc.'. This is probably just companies who want a functional programmer and there are so few in general they advertise for any functional language and hope for the best. Has the advantage of you could be one of those rarer devs and get well paid. But also the drawback that there are so few jobs you are competing with people who essentially had a hand in creating those languages and the jobs aren't likely to be where you live or want to live. 
&gt; Then we come to the invisible passing of @_ to the called subroutine. I have no idea why anyone ever thought this was a good idea. The perlsub documentation calls it “an efficiency mechanism” but admits that is it one “that new users may wish to avoid”. It's needed if you want to write tail recursive functions. If you're doing this, you're probably familiar with Higher Order Perl, and are well beyond the beginners stage. It's also occasionally nice for taking functions out of stack traces that tend to provide more noise than signal when it comes to debugging things. For instance, the constructor methods in Moose-like libraries may choose to do something like this. Of course, it makes it harder to debug things when the problem actually is in one of those hidden functions, so maybe it's a bad idea, anyway.
&gt; Perl 6 stands a great chance of being the only popular dynamic language with usable concurrency TCL 8.6 has well baked thread support.
&gt; http://www.libpng.org/pub/png/libpng.html Thanks! I'll give it a try. 
what's that?
What's what? 
Are you somewhere that web search doesn't work? Or maybe you're mentally retarded in some way?
http://brew.sh/
If you want to visually see what a regular expression does `rxrx`is just about the best thing ever: https://metacpan.org/pod/Regexp::Debugger
If your sub has the same name as a Perl keyword, like `sub` or `for`, you need to prefix it with &amp; to avoid confusing the parser: `sub()` or `for()` won't do. Not that there's any good reason for you to name your sub as such. Also when you have weird sub names like ones that contain spaces, etc.
that's an intermediate task, although with the help of the [Template Toolkit](https://metacpan.org/pod/Template) and possibly [Path::Tiny](https://metacpan.org/pod/Path::Tiny) a static site generator would be a nice easy intermediate project or a very challenging beginners project. If you haven't already noticed, step one is to work out how to use the cpan effectively. For bonus points and career opportunities, work out how to try contributing back too.
https://metacpan.org/pod/Parallel::ForkManager (fixed URL).
&gt; Normalization Form Graphemes (NFG — fix some obscure Unicode issues) I wouldn't call the issue tackled by NFG "obscure". Most existing programming languages make it hard or impossible to correctly handle characters like Ḍ̇ (you should hopefully be seeing a D with a dot above and below). The Unicode standard calls such characters [graphemes](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries). It defines graphemes as "what the user thinks of as a “character”". For about half the planet, proper handling of graphemes (like counting them as one character and not accidentally cutting them into pieces) is a fundamental non-obscure problem. (Note that using UTF-8 does not avoid this problem.) To get a good idea of what's going on right now with NFG, consider reading [yesterday's post about NFG progress by jnthn](https://6guts.wordpress.com/2015/04/20/this-week-digging-into-nfg-fixing-use-fatal-and-more/) and/or [jnthn's NFG commits](https://github.com/jnthn?tab=activity). &gt; When it's declared "ready", I expect performance to be on par with many other dynamic languages Rakudo has some profiling tools and some nice features that mitigate its general slowness, sometimes enabling it to notably outperform 5.20, but my guess is that, by the end of 2015, Rakudo will be something like 10x slower than 5.22 for typical code that hasn't been hand optimized and there'll be occasional much worse pathological slow-downs (that get addressed as they get reported). &gt; but in the long run, it has the potential to exceed them dramatically. I agree with that. Most of the optimizing effort to date has been building the optimizing infrastructure. The next few years will focus on leveraging that infrastructure.
Note the sidebar: "Be civil or be banned." Sure, sometimes we express our opinions strongly and we mods give plenty of leeway, but that was over the line.
&gt; * Tools like plenv and perlbrew install the fatpack into its own bin, which makes upgrading difficult. Maybe, the new cpanm fatpack will detect the upgraded executable in the perl bin path and prefers them. I wonder how long it takes till the perlbrew ans plenv guys figure that out and prevent `cpanm` from doing that.
But you just said that the fields afterwards don't matter in their order. 
 use Sort::ByExample cmp =&gt; { -as =&gt; 'sort_custom', example =&gt; [qw(e f g)], fallback =&gt; sub { $_[0] cmp $_[1] } }; my @items = qw(a c e g i); print join ", ", sort sort_custom @items; Basically does [this](http://www.reddit.com/r/perl/comments/33g8rk/writing_a_sort_function_that_prioritises_n_values/cqko5os) except you don't have to write it. If you don't care about the ordering of the non-example items you can drop the `fallback` option.
Cool
I'm a regular contributor to both plenv and perlbrew (actually I'm a maintainer on plenv repo) so that shouldn't be a concern. The concern here should be more about users who have old perlbrew/plenv and don't upgrade.
Interesting approach; filter out leading values first, then filter out non-leading values. Out-of-the-box thinking! Nice.
Fantastic article. 
The same reason that: 2/3 + 2/3 + 2/3 = 2 but .66667 + .66667 + .66667 = 2.00001 4.412 cannot be represented exactly as a binary number: just like 2/3 in decimal, it has a repeating expansion, so has to be rounded to fit into a floating-point number. If you add up a bunch of numbers rounded to, say, the 10th decimal place, your answer might not be correctly rounded to the 10th decimal place. http://en.wikipedia.org/wiki/Floating_point#Accuracy_problems
If you know the limits of precision in advance, the workaround is usually to convert everything to an integer (*1000), and back again before output. Always do this with money, for example.
&gt; Also your sysadmins are probably super happy about all those paths on movement then. Yeah, I shuffle my custom perl around every other week. Right now it's in /opt/local, but next week I'm moving it to /usr/getafuckingclue. I do perl shit for a sizable team managing over 5k physical systems, but feel free to tell me about what I should put in my shebang. PS: The bash script thing is lame. Use an exec inside of a fucking BEGIN block instead of distributing two scripts.
Maybe I shouldn't have tried [DateTime](http://deps.cpantesters.org/depended-on-by.pl?module=DateTime)...
Just read about geekuni. Maybe its what you're looking for http://perltricks.com/article/150/2015/2/18/Why-I-Started-Geekuni
Did you pass `save_model_on_disk =&gt; 1` to `new()`? my $vsm = Algorithm::VSM-&gt;new( save_model_on_disk =&gt; 1 ); 
And I believe in 5.20 with postfix dereferencing turned on my @a1 = $total[0]-&gt;@*;
/u/djpyro has already given you the answer and yet, I can't recommend strongly enough the [perldoc perlreftut](http://perldoc.perl.org/perlreftut.html) tutorial. Once you learn its contents you won't ever have troubles with (understanding) references again!
And what's the best book to get started with perl? 
Background is no perl training or coding. Some she'll scripting and usage of Awk. 
Some one else might have a newer suggestion, but [Learning Perl (2011)](http://smile.amazon.com/Learning-Perl-Randal-L-Schwartz/dp/1449303587) is probably a good place to start if you're already used to using things like awk for getting rid of repetitive tasks. In other words, let's say that you don't need the concept of variables explained as if they are a foreign idea, and you pretty much get the difference between different primitive data types like strings and types of numbers. Yet, while you may have used arrays and hashes, it wouldn't hurt to have them explained more completely, and why they're so useful in Perl. One way of describing Perl is as a good Swiss Army Knife for doing what you can do with awk, sed, and many other utilities with the unintended consequence that it turned out to be a pretty good general purpose programming language, especially when most alternatives required compilation. If you sent a colleague a C program to accomplish something, you could be diligent and send both the executable and the source, but if you sent a perl script then you automatically sent the equivalent of both without either hassle. They did not have to compile what you sent *and* they could readily modify it to their changing needs.
Hi rz2000, I greatly appreciate you taking the time to make the book recommendation and explanation of perl. I have a question about this below from you... &gt; One way of describing Perl is as a good Swiss Army Knife for doing what you can do with awk, sed, and many other utilities with the unintended consequence that it turned out to be a pretty good general purpose programming language, especially when most alternatives required compilation. While they may be difference languages, do you see any benefit form python in the same context above? Could python be replaced with perl, or is perl much more advanced because of cpan and the simplification of the syntax? Thanks, techsnapp
I will give shell scripting a shot. And you are right, Ctrl+c is actually being used up by adb, the Perl script is never getting that signal But there should be a way to implement, isn't it? http://perldoc.perl.org/perlipc.html suggests to use waitpid(), will try that too
Thanks, I followed the second option. I check the value returned of system command and exit the script if it is not 0, capture_int subroutine is not required at all now.. this is a crude solution, but enough for my current case.. best way is to use waitpid() I suppose... Thanks a lot :) A simple solution escapes notice when the thinking is narrowed to use one particular approach :D
Will be glad to contribute some German titles. Hopefully better than the ones now on the list! *GoTo Perl 5* by Michael Schilli, for example, was very good at the time (1998). Not for beginners, though. It covered some basics, but then zoomed off to fairly advanced stuff. The publications of *Markt &amp; Technik*, *Franzis*, *bhv* and others were probably only popular because they were cheap. OTOH, still too expensive for a doorstopper, if you ask me.
I do. I think that the call $vsm-&gt;generate_document_vectors(); uses the memory to create it then it saves it off to disk after it is made but its running out of memory during that call. 
CPAN may be more advanced for having a greater number of unusual problems already solved for you. However, [PYPI](http://www.python.org/pypi) itself is pretty huge. I personally think that Python is a better language to learn programming. Why? It is widely used in universities so there are tons of resources and textbooks, and you benefit from the network effects of tens of thousands of fellow learners out there. There are also many excellent online courses. Here's [just a listing of ones with Python in the name](https://www.class-central.com/search?q=python), compared to [zero](https://www.class-central.com/search?q=perl) with Perl in the name. Perl has advantages in system administration and string processing, people like the latest web frameworks and packages like Moose, and I think it remains popular in bioinformatics. However, I'd still recommend being opportunistic and taking advantage of all that is out there for learning Python.
You could check the exit code of the commands ran via system; it should be different if the command was aborted by SIGTERM. Or you could send SIGTERM to your script via kill.
perly_bot needs to learn how to recognize blogs.perl.org posts that simply link to another site. Particularly when they end up creating duplicates like this one.
[This](http://perldoc.perl.org/perlfaq7.html#What%27s-the-difference-between-calling-a-function-as-%26foo-and-foo%28%29%3f) will probably help shed some light on the subject. Perl's docs are generally pretty good, although they can be a turnoff to newer users. One of the biggest things is that it allows you to reuse @_ from within a subroutine that's been called. sub foo { &amp;bar; } vs sub foo { bar(); } (This is all seen in the link I provided) The other main points can be found in the link you provided. If you're having trouble understanding some of it, just know that you can probably get away with not using '&amp;' and calling subroutines while specifying parameters.
You might want to check who you're replying to :-) But yeah it's generally best avoided unless you know why you need it. A lot of new programmers seem to assume it's required.
Oops. I assumed OP was asking a question, now I realize he was posting an informative post. 
Does anyone know many of these wont be experimental for 5.22? 
I don't have any recommendations, though I see *Effective Python* has good reviews like the Mark Lutz *Python* book, but I haven't read either. 
I watched it because I was promised SNOBOL discussion, and I was not disappointed. I suspect that the SPITBOL implementation/extension of SNOBOL changes that as string and language performance is radically improved. I was also interested to discover that WebWanker, the string oriented assembly language I created in the early 2000s by accident when my boss told me to re-write a bash script in C and then the application continued to grow and grow, uses the Python bucket method: while(bufshash[hash].name[0]) hash++; /* seek an unused slot */ Huh. Ya learn something new every day. And yes, SNOBOL is the bee's knees. Greetings from my bathtub. Edit: there's a seed stuck under my "d" key.
No biggie and I was being snarky. Thanks for taking it well. :)
Given that it was a reply to a post where I was doing the same sort of thing to MJD, it only makes sense that I should be graceful about what I got wrong.
One thing I'd like to see is for the "hash" terminology to turn back into "associative array" (which is what everyone called it way back before 5.005), and use variable attributes to declare what kind of associative array you want: my %foo : hash; my %bar : btree; my %baz : trie; Or maybe you want to guarantee certain properties about the datastructure, but don't want to worry too much about the details. You could say: my %qux : keep_insert_order; my %quux : lexical_key_sort; For an associative array that guarantees key insertion order, or orders the keys lexically (respectively). This lets us get the benefits of alternative algorithms without the overhead of `tie`. When I gave Tree::Trie a try, it was still slower in practice than a plain hash, even in situations where a Trie should be better in big-O terms. This is true of Tree::Trie's OO interface, and `tie` would only make it worse. Obviously, this happens because the plain hash has everything happening in the core. With luck, this could be implemented without dragging current hashes down the way pseudo-hashes did. Of course, variable attributes have been marked experimental since forever, mostly because nobody seems interested.
This pastebin is now deleted. What were the errors? The WWW-Mechanize distribution does properly declare all its prerequisites, so it's possible your cpan client is misconfigured if it cannot detect this.
I agree that the talk was all over the place, a mishmash of assorted trivia, but that was a deliberate decision: the audience was also very mixed, and I wanted to include something to interest everyone. If I'd talked at length about the details of different kinds of hashing, a lot of people might have been bored. Also, if I had done that, it might have turned into a talk that anyone could have given. But I wanted to give a talk that only I could have given, and I think I succeeded at that. 
If you know how a PRNG works, turning a string into a seed is trivial. The PRNG is a process that takes a sequence of bytes as input and modifies its internal state deterministically using the input bytes. The key is a string, which is a sequence of bytes. So when I said you use the string to seed the PRNG, it wasn't tautologous. It was brief because nothing more needed to be said. I think I said up front that I hadn't used Tcl since about 1995, but if I neglected to mention this, I apologize.
Pluggable backends for the perl "hash" interface have been on the wishlist for years, but it's not clear that it can be done in the current codebase. 
Good and fun reading, thanks
I know how PRNGs work, and they are terrible for hashing. Let's ignore the fact that most random number generators use an integer as a seed (which would require turning the string into a integer, which is precisely the thing you are trying to use the random number generator to do) and look at how well random number generators act as hashing functions. The number one criteria for a hashing function is that small changes in the input should result in large changes in the output. Let's take a look at how two hashing functions (one based on a random number generator and Perl's hashing funciton) do with similar inputs: random: a 177149146 b 177149146 perl: a 1451030276 b 2085256851 The above was generated with this code: #!/usr/bin/perl use strict; use warnings; use Hash::Util qw/hash_value/; use Math::Random::Secure; sub digest_random { my $data = shift; $data = ("x" x 8) . $data; # the seed must be at least 64 bits long my $rng = Math::Random::Secure::RNG-&gt;new(seed =&gt; $data); my $digest = $rng-&gt;irand; return $digest; } print "random: ", join(" ", map { $_, digest_random($_) } "a", "b"), "\n", "perl: ", join(" ", map { $_, hash_value($_) } "a", "b"), "\n"; You can quibble with my implementation, but the fact remains that PRNGs don't care about similar seeds producing dissimilar outputs. If all you want to do is demonstrate how a hashing works, you don't need to bring in the red herring of randomness. You can just write a really bad hashing function that is easy to understand: function bad_hash(unsigned byte data[]) unsigned byte digest = 0 for byte in data digest = byte + digest return digest That is closer to what a real hashing function does and is easily understood. It allows you to segue into why it is a bad hashing function (small key space and addition doesn't avalanche so it generates lots of collisions). As for the Tcl stuff, you did state that your knowledge was out of date, I was just confirming that (like I did with the versions of Perl that introduced randomized hashing); however, it appears as if [your knowledge was out of date for even 1995](http://www2.lib.uchicago.edu/keith/tcl-course/topics/arrays.html). I certainly remember using arrays and hashes in the mid-to-late nineties in some Tcl/Tk programs I wrote (and not the strange "a list is a space separated string" thing you were talking about).
It was certainly entertaining. The hardest part of watching the video is not being able to ask questions at the end.
Out of curiosity why all the .add_to_buffer stuff and your own method for handling nesting when you could just use the built in 'make' and stash stuff in the match object as things are called in the parsed tree order? It's a lot easier to handle nested tags then. make essentially throws the string you build up the match tree replacing the previous tokens. Am I missing something obvious?
I share(d) your confusion about make/made. From the Glossary (S99), the [definition for "Actions"](http://design.perl6.org/S99.html#actions) says: &gt; A class used to generate an "[AST](http://design.perl6.org/S99.html#AST)" from the results of parsing text with a "grammar". The method to attach a generated AST is called "make", the one to retrieve an AST is called "made". Aiui you've basically got Grammars down and you're easily parsing text with a Grammar and getting parse tree results. The problems is Actions. Perhaps some existing doc will help: * [Perl 6 Advent Calendar (2009): Grammars and Actions](https://perl6advent.wordpress.com/2009/12/21/day-21-grammars-and-actions/) * [p6doc: Language/Grammars/Action Objects](http://doc.perl6.org/language/grammars#Action_Objects) If that doesn't do the trick, I'd be happy to dialog about it here.
Yeah it took me a while to get the hang of playing with 'make' but it's really nice once it clicks in your brain how it works. The advent blog has a worked post with some Actions that use make https://perl6advent.wordpress.com/2009/12/21/day-21-grammars-and-actions/ My post from this Christmas has another example of using make to stash string values until you have enough to build a full object too https://perl6advent.wordpress.com/2014/12/15/day-15-bioinformatics-and-the-joy-of-perl6/ I ended up doing the extension I mentioned in the bioinformatics post. If you're interested take a look at the grammar/actions for dealing with proto tokens and selecting specific sub classes to make here: https://github.com/MattOates/BioInfo/tree/master/lib/BioInfo/Parser/FASTA Just this feature sells Perl 6 to me. I went a step further and made a little slang that compiles FASTA strings between grave accents \` \` as a literal for a list of sequence objects. The type of sequence is automatically detected so you get the correct typed object back. So if you put a list of DNA sequences in quotes you get back DNA objects if you put Proteins you get the right object too. Even a mixture you still end up with the right class for the object thanks to the grammar using proto tokens and being smart enough to select the right class to build an object from. The code is minimal, readable and more importantly quite robust and extensible! I haven't used another language which makes this specific use case so trivial. I'm sure they exist but I bet the syntax isn't as clean or first class. I think it's great you are pushing this on perltricks because it really is a bit of a killer feature. One that is still obviously possible in Perl 5 with all the newer regex extensions, but it still isn't as easy to build objects out of what the regex is parsing.
See, just because you earn money doesn't mean you know what you do, that is what I said, you seem to not understand what I say, that is why you bring up this shit all the time. If you wanna get a real developer then work like all the other professional software developer, just because you earn money doesn't mean that you are allowed to "redefine" the job area, as the software is never making the money, the things AROUND are making the money, and you are just the developer, like a tool, and if they make much money, they give to their tools also lots of money, so..... yeah, you are a good tool, but you are no good software developer..... One day you will understand, or not, who cares?
I am a little confused about this reaction. API/abstraction = someone's language, for sure, but I can express that I had relative comfort with what was presented. Maybe it depends on our relative exposures. Background: I do not use Moo (I use Moose), and I use Getopt::Long for parsing parameters. This post's code delegates the responsibility of handling the main script functionality to a class; it's a debatable pattern but it has plenty of supporters, such as with Java, .Net, and Ruby programmers. The Moo (CPAN) module provides modern Perl class semantics. MooX::Options (CPAN) is an extension to roll Getopt into some of the attributes in a fashion that one might dare call elegant and uses familiar attributes from Getopt::Long (core Perl module).
My issue is that _most_ sysadmins I have met and come across do not have a strong background in computer science or OOP. They are not developers, as much as people want devops to be a thing. For a large-scale project that's headed up by developers and actively being developed on, tools like Moo or Moose are great (I imagine), but for scripted solutions and systems maintenance, verbosity and explicitness are important. If a CLI script / tool gets so complex that it requires the developer time optimizations that Moo/Moose provides, I would argue its missing the point and probably trying to do too much.
I'm curious to hear your response to the Perl 6 syntax for a CLI script: use v6; sub MAIN ($file, :$verbose) { if $verbose { say "Processing $file" } } When run without args this prints: Usage: process.pl6 [--verbose] &lt;file&gt;
I have less of an issue, because it's native to the language. It's not adding a language to the language; it is the language. My only gripe is that I feel perl6 should go by a name other than perl. Perhaps perl++. Unless it executes all my perl5 code the same, it should have a distinct name change. And if it can, I would be annoyed by the backward compatibility bloat. Call me crazy, but I also think a distinct name would make it much more appealing to people who have misconceptions about perl5.
&gt; unless it executes all my perl5 code the same There are now several 5+6 packages that combine execution of perl5 code using the regular perl interpreter with execution of Perl 6 code using the Rakudo Perl 6 compiler. For example, [Inline::Perl6 for Perl 5](https://metacpan.org/pod/Inline::Perl6) and [Inline::Perl5 for Perl 6](https://github.com/niner/Inline-Perl5). &gt; I would be annoyed by the backward compatibility bloat. Technically speaking, Perl 6 isn't backwards compatible. It's just good at smooth interop.
Is it worth using though?
Found this issue, I should have been doing: `$match&lt;text&gt;&lt;format_codes&gt;` Woo!
uh.... why uservoice.com ?
uh.... because that's what they officially use for this stuff?
You missed the [About](https://6guts.wordpress.com/about/) link under the picture ("Home About Interesting Papers"). The About page reveals his personal site which contains [his personal contact details](http://www.jnthn.net/contact.shtml).
They being who? Perl, or Microsoft?
They being the VisualStudio Code team at Microsoft.
Relevant quote: "Since Java is my full time job now, and I have little reason to be doing Perl as I've been unhappy with the Perl 5 Framework landscape, I'm unlikely to continue developing features for my Perl 5 modules. If you're interested in becoming a comaintainer on any of my modules, my requirement is that you show interest in the module by contributing high quality patches to that module. I'd like to see evidence that I won't have to come back and fix things later, and that your interest is sincere. If you're not interested in being a comaint patches are still welcome." http://www.xenoterracide.com/2014/05/two-hundred-posts.html 
What the hell does this have to do with perl? edit: Thanks /u/raiph for the clarity. Still doesn't seem terribly relevant, and I would hope people going to that workshop would be paying attention to travel conditions, on their own, but whatever. Leaving my original comment, since I imagine a few other people are asking themselves the same thing.
There will be murders if I ever inherit or need to maintain code, perl or otherwise, that replaces != with something I cannot natively type on my keyboard.
I don't understand. I don't see this commit in blead and it seems so unlikely such a contentious patch would land this late in the cycle.
It seems to work well. I prefer to handle parameters as key=value using a hash: my %argHash=(parm1=&gt;1 , parm2=&gt;0 , parm3=&gt;0 , dbgmode=&gt;0 ); # optional=&gt;0 my @requiredArgs = grep { $argHash{$_} eq 1 } keys %argHash; my @optionalArgs = grep { $argHash{$_} eq 0 } keys %argHash; #split @ARGV entries ("k=v") and compare to required and optional values 
Catalyst::Plugin::InjectionHelpers is downright sexy
You can't type ≠? It's just compose-=-/ ☺
You don't see it happen to be ever applied to blead. But perl5 is not only blead. Esp. when you want to have bugs getting fixed or new features. Good luck in waiting to get proper signatures, mop, multi or types. It will not happen.
For vimmers: au FileType perl abbr != ≠ Now you can type the operator as usual and have it be replaced automatically. Saves a little horizontal space, and may help make Perl grammar less vague in some places, too. Perhaps more importantly, it helps make sure your environment is Unicode-friendly all the time, rather than scrambling to try to fix it when you're in a pinch.
Indeed. It's no drama at all, happens all the time. cpan has a lot of co-maint and takeover requests. In this case I rather believe Caleb switched fully to Java now, which he does at his new job. I have seen only 2 from him in perl6 so far.
How is `!=` vague and why do we need Unicode in programming?
Dropping sigils? But what will the naysayers have to complain about? Doesn't anyone think of the naysayers anymore?
Is that only for scalars, or could you drop @ and % as well? And would you say array[0] or $array[0]?
My biggest problem with P6 is lack of modules. There is no easy way to solve it. I think CPAN is one of the strongest features of Perl. I rely on tons of modules for every day tasks. There is nothing for me to do with P6 if it doesn't have the modules I need. And there is simply no way to rewrite stuff like DBIC to P6 in some easy way.
&gt; There is no easy way to solve it. Write them. I'm not trolling here, i'm genuinely suggesting if you want to learn and use perl6 and want to see it adopted and grow and become fantastic then pick a module you can't live without and write the perl6 implementation. This is pretty much what the post argues for: &gt; "The best advice I can see for ensuring Perl 6's success is for Perl developers to start writing code in Perl 6. I mean now; it's definitely stable enough. Every module available within a year of release is going to be a major argument for people to try the new version. Getting Shit Done can win a lot of arguments." Are you going to fuck up, waste time, get frustrated? Yes, but that never stopped anyone writing code in the past. And with new implementations in perl6 we can get away from the "but CPAN!" argument and throw away 95% of the shit on CPAN that most well informed perl developers stay well clear of. I'm looking forward to the Swiss perl workshop this year as there is going to be 2 full days devoted to perl6 in terms of tutorials and workshops. That's when i'm going to dive in.
Microsoft uses GitHub's [atom/first-mate](https://github.com/atom/first-mate) to integrate TextMate's bundle for most language support including Perl5/6. Unless Microsoft develops their own integrations like C#/TypeScript, the best they can get is what you can get with TextMate/Atom too. Source: http://channel9.msdn.com/Events/Build/2015/3-680 (07:50)
Put 4 spaces in front of every line in the code block.
"switch" is deprecated since Perl 5.10, and in fact was dropped in Perl 5.14 Check out "switch" equivalents at http://perldoc.perl.org/perlfaq7.html#How-do-I-create-a-switch-or-case-statement%3f
Ignore what snerfo says about formatting if blocks. I assume you actually have "#!/usr/bin/perl", rather than without the '#'. The very first lines in the program should be: use warnings; use strict; I don't bother if I'm doing a 5 or 10 line program to achieve something quickly, but I usually manage to fit in error into that space. As a program goes over 10 lines, I definitely add the warnings and strict. warnings &amp; strict would have notifued you that while you declare '$input' with 'my', you don't declare '$no'. The suffix if() is great if you have a single case, especially if the focus is on the thing that happens, rather than the condition that causes it. die( $msg ) if $error If you have several lines, or you have both then{} and else{}, format over several lines: if ( $input eq 'Help' ) { help(); } else { print $no; } I would put all the subroutines at the top, and the "main" processing at the bottom. Actually, I have a main() subroutine, which I invoke. While snerfo is out-of-date in suggesting an actual 'switch', he/she is correct in tying the multiple if-blocks into a single sequence. I think what you want is to get the user's request, and compare it to three valid commands, or a request for help, and only present Hal's comment only if it matches none of those. I would achieve that with a hash, but I suspect that is beyond the material you have been taught so far. So I would go with if/elsif/else: if ( $input eq "Systems Check" ) { # do system check } elsif ( "Comm Relay" stuff ) { # stuff } # .... else ( $input eq "Help" ) { # handle user error } 
Why not just use the Perl 5 modules?
Sadly two modules in Perl 6 is like a heroic effort so far :'(
&gt; help() if ($input eq "Help") else {print '$no\n'}; That hasn't compiled in any version of Perl that I've ever used. Using `if` as a statement modifier has never supported an `else` clause.
The system function does not return the stdout of the program, you may want to read [this](http://stackoverflow.com/a/800105).
I initially set out to write UAV::Pilot for Perl6. In retrospect, I'm glad I didn't. The early stages probably would have worked out fine (sending control data and receiving telemetry to the AR.Drone). When it came time to getting the live video feed working, though, it meant getting Perl xs, ffmpeg, and SDL all marching in the same direction. All three of those are pretty well documented with lots of people who can help get out of ruts. Put Perl6 in there, and I don't think it would have ever gotten done.
So I Probably miss understood something. I know if I can get the help command to work I can get the rest to work. This is what I got out of everything #!/usr/bin/perl use strict; use warnings; print "hello, Dave. My name is HAL. How can i help you?\n"; my $input = &lt;&gt;; if ( $input eq "help" ) { print "Systems Check\n"; print "Comm Relay\n"; print "Crew Vitals\n"; } I also tried writing a sub then tried to call it but I think I wrote that wrong as well. sub help { print "Systems Check\n"; print "Comm Relay\n"; print "Crew Vitals\n"; } if ( $input eq "help" ) { help; } 
Something got seriously screwed up with Mojoconf and the organizers have called it off. If you still have plans to be in New York, I'm trying to figure out something else for you. Maybe free Perl training or something to justify corporate travel. I need a few days to see what I can pull together.
Damn, already canceled my hotel and flight. Have fun, guys.
I am astonished at this! I think that, for example, python community would kill for having v2 and v3 inter-operable modules. Should this render moot the point about loosing CPAN modules when switching to perl6?
I have always been rolling my own with simultaneous %name and @name (often both global/package variables). Is my solution considered sufficient?
Count me in!
My typical use cases are: # at collection if (!defined $name{$key}){ $name{$key}=$value; # often simply 1 push @name, $key; } # at report foreach $key (@name){ # process $name{$key} } Somehow hash deletion has not prevailed in my programming (other than resetting the value).
Sorry, I'm a bit out of the loop. For Perl 6 Is there an established way to: * publish modules * install modules and manage dependencies similar to the Perl 5 CPAN toolchain? ?
Hey, it looks like there's still stuff happening! :D http://richelberger.com/2015/05/06/from-mojoconf-to-miniconf-a-agile-reinvention/ Don't cancel yet guys. Mojoconf is still on, but perhaps looking a little different than before..
As someone who has written hundreds of CLI scripts, some of them non-trivial, I'd certainly say Getopt::Long alone is not enough. Higher-level frameworks help relieving the pain and speeding up development. But it's certainly easier to not make things :)
I consider Rakudo and Perl to be different. To quote [Why I (still) Love Perl](http://allisonrandal.com/2013/03/31/mythbusters-why-i-still-love-perl/), &gt; Right now, Perl and Rakudo are getting in each other’s way. They’re like conjoined twins, trying to live separate lives, but always anchored to their brother. That doesn’t mean I love Rakudo any less than I love Perl. I love them both, and want them both to succeed. But their paths are very, very different, and they each need the freedom to walk their own path. The way to grant that freedom is stunningly simple: accept that it is what it is, and let each go its own way, with its own chosen identity. Let Perl be Perl and let Rakudo be Rakudo.
I wasn't aware of readdir until now. My world just got a bit more complex.
Oh, hello!
There was nothing vague about `IS NOT EQUAL TO` and keyboards didn't always have exclamation marks on them. This is what progress looks like. It's supposed to make you uncomfortable. 
&gt; So please, please, introduce use strict, warnings, diagnostics the first day of class. I've taught Perl to plenty of PhD students, that is the first thing out of any teachers mouth. I'm going to go out on a limb and point to the bit where you mention its a programming course being taught within the Biology dept. From my experience that is often the blind leading the blind. :P
typically i would suggest that anybody that is teaching perl that doesn't tell you to use strict and use warnings isn't a good teacher at all. come down the the freenode (IRC) perl channel (#perl) and show them code that doesn't use strict or use warnings will usually get you a slap on the back of the knuckles. Op, have your girlfriend read this book (it can be had for free): [Modern Perl](http://www.onyxneon.com/books/modern_perl/) It's a good place to start and has been revised in 2014 so it's actually updated as the language evolves. The #perl channel on freenode is another decent place to get help, however carefully crafted questions are expected....sometimes they can be rough on people that don't put an effort to solve their own problems before asking. 
&gt; use warnings; OMG! Nothing's wrong! I can't run! Ugh, I loathe the warnings pragma. Try using common::sense instead. It won't warn you about messages that don't mean anything like quoting within hashes, but it will let the warnings that indicate that your code is broken through.
 use experimental 'smartmatch';
strict et al are more useful in large programs if you are learning they offer some assistance, i guess. but a better first step would be to make sure your student uses an editor that is perl-smart and highlights syntax with colors. 
And honestly, that slap on the knuckles is more disheartening to beginners than struggling with Perl. That hostile reception by the Perl community is one of the chief complaints I hear from beginners.
Care to elaborate? I use it all out the time.
I run into warnings so rarely that I can't believe they cause anyone problems. 
&gt; For example, Scott Walters, who wrote the Perl 6 Now book in 2004, kindly donated the Perl 6 code snippets into the public domain, which became some of the earliest materials in Pugs repository. I wrote _Perl 6 Now: The Core Ideas Illustrated in Perl 5_ in POD with some hacky custom code to spit out the RTF that APress wanted (I should really clean that up and put it somewhere... so much code all over the place... ugh). One of the features was that it built a nice little directory structure of code, and of course, all of the code in the book was example code in either Perl 5 or pseudo-Perl 6. At the time, all Perl 6 was made up Perl 6, and I did my best based on the Exegeses and Apocalypses. Oh my, that was back in 2002. Eg, http://perl6.org/archive/doc/design/exe/E05.html So there was a made up language spec'd and documented, and then I wrote more examples continuing in the style of the made up language, and then Audrey came along and implemented an interpreter for that made up language. Life is rad. The "Oh, hello!" was just "I hear my name, thanks for the shout out". I'd love to have hacked on Pugs. Learning Haskell is one of those things on my really long list of things to do. I loved Audrey's policy of just handing out commit bits to anyone who shows up. I've tried to adopt that in other work. Oh yes, that was in darcs. =)
How is this progress? There's a next-to-zero chance that a ≠ key will show up on keyboards any time soon, it doesn't save key presses, it adds them, and it doesn't save any 'space' because it's at least a 2 byte character.
As someone who has also written hundreds of CLI scripts; I've very rarely even needed the benefit of Getopt::Long and only added it as a sort of polish (in the few times I've used it). Then again, most of my shell scripts, these days, tend to be bash. I keep my scripts simple and doing a single thing, that way they're easier to re-use in pipelines with other scripts or just as a manual work-flow.
This most likely would break a lot of scripts, scripts used by sysadmins and scripts currently used by various Linux (and BSD?) distributions. And will most likely result in those scripts being rewritten in Python.
I've helped students in the past with Perl homework and Perl is being taught like it's 1999 or worse.
Good read! 
The problem with strict is... ... for me at least: if the braces in your code are not properly matched, then you'll get *a bunch* of noise warnings for undeclared variables before it even gets to the meat of the real error: that your braces are not properly paired. Sometime I turn off `strict` just to see the actual error message. In my opinion, `strict` should never emit any warnings at all, if your code won't even compile without `strict`. Traditionally that is called a "semantic check", which ought to be performed *after* the syntax check, in a next phase of the compilation. But in Perl, syntactic and semantic check are done in the same phase. Hence the noise.
Oh sweet, your book was so good, I bought it twice (back in 2002 and then again a year ago). Are you still contemplating the big CMS project (the WebGUI rewrite)? Or would it be a from-scratch rewrite? Any chance of it being in Perl6?
&gt; strict et al are more useful in large programs No they are mandatory in all programs if you want to be a competent programmer.
I said 30, not 3. But ok... Hit 8 was http://affy.blogspot.com/p5be/ch16.htm for me.
Oh right. I have not notice that, but in any case according to the numbers I see from Google Webmaster about 90% of the people click on one of the first 3 hits and about 99% on one of the first 10.
I buy nine's [Leapfrogging the bootstrap](http://www.reddit.com/r/perl6/comments/2xznj3/fosdem_video_leapfrogging_the_bootstrap_bringing/) vision. ---- The Perl 6 design and nine's initiative exhibit the classic Perl virtues: * Laziness. Perl 6's interop design, and NativeCall, and nine's work in the last 6 months or so, represent investment of effort up front to facilitate the laziness of not writing Perl 6 equivalents of already existing good/great Perl 5 modules. * Impatience. A lot of CPAN should already work for a lot of scenarios without change. Why wait for pure Perl 6 modules? Why spend time writing Perl 6 equivalents of already existing and good Perl 5 modules when that time could be spent improving Perl 6 in other ways? * Hubris. While nine is remarkably humble, he's also super smart and undaunted by current weaknesses of Inline::Perl5. He seems to think that the majority of existing Perl 5 modules can be made to just work with Perl 6; who's to say he's wrong? ---- I'm not suggesting stopping Perl 5 folk writing idiomatic Perl 6 equivalents of Perl 5 modules if they really want to. For example, Tux has clearly been having "fun" writing an idiomatic [Text::CSV for Perl 6](https://github.com/Tux/CSV) and he's been super helpful in exposing bugs and speed bumps. But note that [his Perl 5 Text::CSV module is several orders of magnitude faster than his Perl 6 equivalent](https://github.com/Tux/CSV/blob/master/NLPW-2015/041-speed.txt) and may remain so for some unknown duration, quite plausibly years. What I *am* saying is that my guess is that the best roles for Perl 5 folk who want to do something with Perl 6 are things like: * Triaging CPAN and fixing blockers. That is, identify which Perl 5 CPAN modules work with Perl 6 code and which don't. Test via both [Inline::Perl6 for Perl 5](https://metacpan.org/pod/Inline::Perl6) and [Inline::Perl5 for Perl 6](https://github.com/niner/Inline-Perl5). If a module doesn't work in Perl 6 exactly the same way it works in Perl 5 (modulo syntax), bug nine and hack until it does. (Or document issues and/or conclude that a replacement Perl 6 module is the easier or better route.) * Help make the Perl 5 and Perl 6 ecosystems work more smoothly together. Make panda more CPAN friendly and, perhaps, CPAN more panda friendly. * Write Perl 6 code that uses Perl 5 modules and share the results. nine has begun writing Catalyst controllers in Perl 6 using the Perl 5 Catalyst from CPAN. This involves subclassing Perl 5 classes in Perl 6, which sounds like it might be complicated, but is apparently simple and Just Works. (In fact something similar is in principle possible with other langs such as Python and Java.)
Hey, really cool project, but I think you really should have used a "complete" js framework. Almost all of the newer of them come with some kind of routing ability, that would save you from the big `switch` statement in the middle that really looks odd. Or scout out for some router module. I can't recommend one, because the js "community" churns out about one new framework a week.
thanks - i didnt know that one
I understand that your scripts are a lot more involved than the one I'm writing. To me that sounds like a very large codebase to maintain. Do you have it shared anywhere?
This started as pure JS without even jQuery and I am also planning a version using either Angular or React.
http://perldoc.perl.org/File/Find.html
Long time Perl dev here. I'll tell you why. Beause a lot of people have written horribly unreadable code and called it "great perl" because they use all kinds of Perl features that 99% of people don't have the time or patience to learn about. Perl one-liners are the canonical example of this. Also, TMTOWTDI is good if you are really into Perl, but most people only want to have to learn one or two ways to do it. It's sad because the language itself is awesome and many newcomer languages aren't any better (and in some cases are much worse) but people would rather try those than try to learn Perl. Now, sure, people write horrible code in all kinds of languages. However, people often find that horrible code less confusing on the surface (even if it is really confusing/bad once you look into it more) so it doesn't give those languages the same reputation.
EDIT 2 - OP has clarified his question. ~~Not exactly sure what you're trying to accomplish (your example doesn't do anything with $_ after removing non-alphanumeric characters). Can you explain what you're attempting to accomplish (and potentially provide some example input and output) OR provide us with the actual code you're looking at (because you reference printing something, but I don't see anything being printed)?~~ EDIT - Making the assumption you're trying to remove special characters before counting words, I think your issue is that you're doing things in the wrong order (your code could also be written to be a lot more readable, imo). e.g. my %count; foreach my $title (@titles) { my @words = split ' ', $title; foreach my $word (@words) { $word =~ s/[^a-zA-Z0-9]*//g; $count{$word}++; } } 
You might want to use explicit variable names instead of `$_`.
I think the double-implied `$_` are throwing you off, here. What you're doing is equivalent to this: my %count; for my $line (@titles) { for my $word (split(" ", $line)) { $count{$word}++; } $line =~ s/[^a-zA-Z0-9]*//g; } You probably want to run that regular expression against `$word` before you increment it in the hash. EDIT: I derp'd; running the regular expression on `$line` before the split would render each sentence into one long word.
Fantastic, sorry for the lack of info in the beginning. Realizing now that my regex was not inside the nested loop. Thanks for providing a more readable solution that works! +1
Thanks for the advice. I will say that the formatting looks terrible on reddit, but much nicer in sublime text haha. Mostly due to my hasty editing. Also the names of some variables were changed haphazardly for this post. One of the reasons I love perl is the great community support, thanks once again!
I would also add that this reputation has been helped along by proponents of competing languages wanting to dissuade people from using Perl. 
Just a small word of caution if you decide to use this code: the ramdisk driver in OS X should be treated with care. While it’s good for smallish volumes, I’ve found that one can easily panic a machine with it.
Shouldn't a modern OS take care of this? Especially the caching of read data?
I'm glad you've got this thing sorted out. But I have to kind of question what you're doing. What are "special characters" anyway? Why are they in your text and what does it do to your text to take them out? If one of your titles is `Amélie` do you end up with `Amlie`? All I'm saying is, this has the smell of an encoding issue, like you're getting Unicode input and trying to force it into ASCII or something?
It also seems that many who learn other languages started on non-Unix-like systems and just don't get the Unix way at all. I think Perl fits in with that very nicely. Many other languages just don't. 
I have a Web script that takes reddit link names and counts the duplicate word entries on the whole page. That info is represented as a hash where the key is the count of duplicates and the word is the value. I put that into a sql db and check the entries with the new hash each day and update the counts. You bring up an interesting point with some of those characters, but the subreddit I'm crawling the bot on doesn't seem to use them often enough to throw off the data. Mostly I was worried about matching something like 'jimmy' with '[jimmy]'. Thanks for the reply. 
Dominos. Because one wasn't enough. O:-) 
$count{$_} is a number ... the number of words in the titles
Ouch! On the [given link](http://www.softouch.on.ca/tutorials/) the font-size keeps getting bigger and bigger. But thanks for all the info, because I am trying to learn Perl myself at **[http://ai.neocities.org/AiSteps.html](http://ai.neocities.org/AiSteps.html)** for coding artificial intelligence in Perl. 
Thanks for yet another link. I went there and left a comment in English about my work on porting a German AI Mind from Forth into Perl. Sadly, I know that when I comment here, the Mentifex-bashers will jump all over me, because we are not in a human face-to-face meeting room and so people without manners do not even bother to pretend that they have manners on the Internet. The resulting insults makes the Perl community look unfriendly to newcomers, but c'est la vie. Anyway, having worked on AI in Forth for many years, I am pleased to be learning the Perl language in my "AI Steps" at **[http://ai.neocities.org/AiSteps.html](http://ai.neocities.org/AiSteps.html)** and I am especially glad to find out in this thread that there is a large Perl community in Germany.
Hello Arthur, good to directly interact with you. Welcome to /r/perl. I didn't even know who you were until I followed your link earlier today. The quality of the content made me question who I was interacting with. Your own reddit history betrays your lack of genuine interest in discussion which is why I linked to that FAQ (http://www.nothingisreal.com/mentifex_faq.html) previously. If you feel vilified then I would also point to the simple fact you couldn't even discuss your own history of impolite behaviour without getting in a self serving link. I'm more than happy to chat to you about Perl. Nothing would please me more, and I'm sure everyone else here would love to chat to someone new about their learning experience. I have a background in AI but I'd rather not discuss that with you at all. If I did I wouldn't do it here. My personal ideas on AI are likely far too conventional to interest you, and I already read many of your ideas earlier today and feel more than fulfilled on the topic. You've done a good job of codifying your personal philosophy which is commendable. Hope you enjoy the subreddit, but perhaps lay off the links and build up some good will before calling out your perceived haters. You haven't earned notoriety here yet at all. I would love to eat my words and take back my rash judgement of your motivations for posting.
I'm giving my "Become a CPAN Author in Three Hours" workshop!
Well, I was writing a long reply when I hit some unknown combination of keys and it all turned blue and vanished. Please, everybody, form your own judgements and do not hit a newbie over the head with a link to a biased, outdated and vicious pack of lies.
Short perl script to set flickr images free. Stylistic criticism, no, really, any criticism, is welcome, either here or on the entry itself. 
https://jobs.perl.org/
Perl programmers who are actually looking for a job are all subscribed to jobs.perl.org. In your post, advertise a salary that's competitive for experienced Java or C# talent. Offer relocation assistance and part-onsite or better. Write about your corporate culture. You don't have to have snacks, but you do have to empower good people to do what they know how to do, and good programmers are going to read carefully to pick up clues there. People looking for qualified developers in other languages will work with recruiters, either agencies or hire their own on-staff professionals. A good recruiter has many contacts and will poach people. I could give you the info for the recruiter that poached me for one of the best gigs I've worked. Sponsoring conferences and advertising on Perl sites doesn't hurt. Edit: Another great way to attract top talent is to sponsor a core developer or author of an important project. If you hired a core Perl 5 or Perl 6 hacker and let them work on Perl three days a week and corporate stuff two days a week, you still have a direct line to them for questions, them available for mentoring, they will be more productive in the two days they're on than most most developers you can find, having them there helps create visibility when hiring additional developers, and you're benefiting Perl. I cannot recommend this strategy enough. If you want to do it yourself (without the benefit of contacts), get on monster.com and all of those. http://www.socialtalent.co/blog/how-to-use-github-to-find-super-talented-developers is one approach that I'd recommend. If you can't find good Perl talent, you've got two^Wthree options: Find senior talent in Java/C#/Clojure/Rust/Go/Objective-C/Scheme/Forth/Lisp/whatever, and have your staff train them up. Find intermediate but promising Perl talent, and have your staff train them up. Hire a consulting firm that has senior Perl talent in-house. ShadowCat Systems and PlainBlack Corp come to mind as highly recommendable. A lot of people choose to work for places like that because effective management is an enormous part of making projects go smoothly, and a consulting firm like that creates a structure for spec'ing projects, adhering to good practices, setting reasonable deadlines, and isolating programmers from indecision and trickle-down-stress that generally is lacking working directly for a company. All of those things promote productivity which promotes job satisfaction which lets them hire and retain top notch professionals. Good luck!
Yeah, because this sub is so full! 
Thank you everyone!
I'm guessing this is the ThinkGeek position?
[The most recent reviews from GlassDoor] (http://www.glassdoor.com/Reviews/ThinkGeek-Reviews-E333916.htm?sort.sortType=RD&amp;sort.ascending=false) doesn't have them in the best standings. That's what has deterred me from considering that job.
Another good resource is the local Perl Monger's group. For the DC Metro area that is [DC Perl Mongers](http://dc.pm.org). Also, [YAPC::NA::2015](http://www.yapcna.org/yn2015) is almost here (early June), you could send someone to it. There is a section of the conference (between the lightning talks) where almost everyone is present and anyone can get up and talk for thirty seconds (these are called lightning advertisements). The talks are often "we are X, we do Y, and we are hiring. Come talk to us after the lightning talks." Sadly, you just missed the [DC-Baltimore Perl Workshop](http://dcbpw.org), but you should keep it in mind for the next time you are hiring.
No, because that is where Perl jobs are posted!
I'll be doing it, but earliest in 3 weeks. I'm out of the country right now
I know three people who work there (two well and one as an acquaintance). All have been working there for over a year and seem to be as happy with their jobs as they were with the job they had before they started there.
People *do* gossip.
The point of Perl mongers was never talks. We designed it as a networking and social endeavor. That people don't use it as such might explain their discontent.
Multiline comments are ugly. Why not: #- This is multiline -# Or some such? They created a language after all.
I'm not especially happy with the #`[ ... ] form, but I see why it was chosen, and I haven't come up with a better solution, and imo your proposal doesn't necessarily improve things (read on for why not). ---- I do think it might make sense to remove the comment about the #`[ ... ] comment form from the learnXinY. ---- Perl 6 supports multiline comments closed by a blank line: =Notes This is a multiline comment Blah, blah &lt;back to code or whatever here&gt; Or, for a comment block with blank lines in it: =begin SYNOPSIS Blah, blah And more blah =end SYNOPSIS ---- The '#' based comment forms are mostly intended for comments that are very tightly bound with the line(s) of code immediately before or after the comment. For example, there are variants that tie a comment to the declaration immediately before ('#|') or after ('#=') the comment: #| Call this to save the planet! sub foo() { ... }; say &amp;foo.WHY displays: Call this to save the planet! The intent is to enable display of documentation of interfaces etc. in a REPL, IDE etc. ---- I don't recall seeing anyone use the #`[ ... ] form for a multiline comment. Aiui it is mostly intended (and used) for embedded comments: token foo { .* #`[ no backtracking ] this will not match }; (Tokens are regexes that don't backtrack.) ---- The #`[ ... ] comment form eschewed using just two characters as the opener because of problems that arise when folk use the common technique of commenting out code using a bunch of '#'s: lines of code, including: --$a or blah; ...more lines of code If someone "comments out" this code by prepending a '#' to each line they get this: #lines of code, including: #--$a or blah; #...more lines of code Now the `--$a` line is misinterpreted as the start of a multiline comment (assuming '#-' starts a multiline/embedded comment). The obvious available ascii delimiters -- parens, curlies, brackets, or angles -- are particularly prone to this problem. The chosen solution was to insert a character that's not likely to cause misinterpretation. Given that ` is (deliberately) not used in the standard Perl 6 grammar, and was considered visually lightweight, it was picked as the second character.
I said "or some such". :) I get why it is "#" since that is what it is currently. They didn't have to follow that and the #` plus whatever is ugly with an F.
+100 Now that I've started working from home full time, I'll never go back to an office again. I'm *way* more productive this way.
It's not the case with most of my friends in Japan. Perl shops in Japan (LINE, DeNA to just name a few) tend to serve a lot of traffic, and they prefer lightweight solutions.
I appreciate the post, but felt it didn't really pick a target audience. For current perl5 users, it could have been shorter and more to the point as a list of changes from 5 to 6. For non-perl users, it might not cover all ground that needs to be covered, since it seems to assume some familiarity with perlish syntax. In general, as a relatively new perl5 user to start with, I feel I'm mostly confused after reading the tutorial. That could be entirely on me, though. 
Nice. UX: Hitting Return in the search field doesn't submit the query. 
For modules with xs code, I've found it a little easier to get Dist::Zilla to do what I want by generating a Build.PL with [Dist::Zilla::Plugin::ModuleBuild::Custom](https://metacpan.org/pod/Dist::Zilla::Plugin::ModuleBuild::Custom). Dist::Zilla in general seems like it needs some work for xs stuff. There's very little documentation on how any of it should work for xs.
The answer is to get it on github. Signup for an account, get your ssh-key ready and then go here https://github.com/jsober/Reddit-API and click the clone button. That will give you a copy of the repo in your own account. Check out the code and apply your patch to it. Push it upstream to your repository. Go here https://github.com/jsober/Reddit-API/compare and create a pull request from your repository to the main application and wait for it to be accepted.
Well the term "pull request" finally makes sense now. You're requesting that someone "pull" your change into their code. I never understood that.
http://search.cpan.org/~bbyrd/Parse-Path-0.92/lib/Parse/Path.pm
There are several modules on CPAN for this. I'd recommend [Path::Tiny](https://metacpan.org/pod/Path::Tiny).
Why are you using -f?
I agree! This looks super useful; I'm just starting to look int writing Reddit bots, and I'd love for this functionality to be added. I'm not sure if Reddit wants bots sending PMs though.
That's a decent workaround. You could also do this 'the bash way' with process substitution. Something like: nc machineB port &lt; &lt;(tail -f somefile)
I'm the maintainer of the module. Thank you for your contribution! Look for my comments on github :D
I agree with the other replies that suggest using pre-existing path parsing, but in answer to your actual question: my %ifile = (); do { my $input = $ARGV[0]; @ifile{'input', 'path', 'name'} = ($input, $input =~ /(.*)\/(.*)/); @ifile{'class', 'type'} = ($ifile{name} =~ /..(...)(...)/); }; I think that slices are under-appreciated. :) 
&gt;Then again, I always thought if a component of a shell pipeline terminated, it would break the whole pipeline. You're right, killing any component of a shell pipeline will result in every command involved exiting *eventually*. OP's example is kind of neat in that it shows the pipeline might not break as soon as you might expect. &amp;nbsp; First, let's set up nc to listen and send to the same port: $ nc -k -l 8080 &gt;/dev/null &amp; [1] 23888 $ tail -f afile | nc localhost 8080 &amp; [2] 23890 $ jobs [1]+ Stopped nc -k -l 8080 &gt; /dev/null [2]- Running tail -f afile | nc localhost 8080 &amp; &amp;nbsp; Now, we will kill the listener: $ fg 1 nc -k -l 8080 &gt; /dev/null ^C $ jobs [2]+ Running tail -f afile | nc localhost 8080 &amp; &amp;nbsp; Let's try and send some data now: $ echo "........................................................." &gt;&gt; afile &amp;nbsp; Nothing happened? Huh. Perhaps there's a buffer involved somewhere. Let's try sending another line of data: $ echo "........................................................." &gt;&gt; afile $ Ncat: Broken pipe. ^C &amp;nbsp; OK neat! netcat has now decided that it can't send anymore data to port 8080, and has exited. $ ps -ef | grep nc user 23904 22842 0 18:31 pts/2 00:00:00 grep --color=auto nc &amp;nbsp; Next, let's see if tail is still running: $ ps -ef | grep tail user 23917 22842 0 18:40 pts/2 00:00:00 tail -f afile user 23920 22842 0 18:40 pts/2 00:00:00 grep --color=auto tail &amp;nbsp; Still running eh? Let's add some more data to afile: $ echo "........................................................." &gt;&gt; afile $ ps -ef | grep tail user 23926 22842 0 18:44 pts/2 00:00:00 grep --color=auto tail $ jobs [2]+ Exit 1 tail -f afile | nc localhost 8080 &amp;nbsp; tail finally caught the SIGPIPE, exited, and the backgrounded process has completed.
https://metacpan.org/pod/File::Spec is shipped with perl so you don't have to install anything, see 'splitpath'
Cool! I'm working on making those changes work with git. I'm just not good with version control systems. It doesn't want to let me push it because "non-fast-forward" updates are rejected. This is probably an incredibly simple maneuver, I'll get it =x
Thanks Bytemark, we appreciate it! 
I didn't know MetaCPAN were on Bytemark. I've been using Bytemark for several years now (I've lost count, probably more than 3, but probably less than 10 - Linode has over 10 years of loyalty). Bytemark have always been responsive in tickets - and have been able to provide VMs and dedicated machines as I've needed.
http://www.nntp.perl.org/group/perl.perl5.porters/2013/08/msg206502.html
**Core Enhancements** &lt;&lt;&gt;&gt; &amp;.= |.= ^.= ~.= ;____;
&gt; It offends my sense of code style that the two chdirs are apart from each other when I want to keep the logical parts close to each other. I'd like all of the code to handle the current working directory next to each other. Maybe I'm just not a developer or something, but this seems 'dumb.' Your code shouldn't be thought of as what is similar should go together; you don't open a file and close a file in the next line, just because they're they 'same logical part'. If you want to have your `chdir` calls close to each other, you should instead structure your code like: my $dir = '/usr/local/etc'; my $old_dir = getcwd(); chdir "$dir" || die "Could not chdir to $dir: $!"; my $foo = do_some_work(); chdir "$old_dir" || die "Could not chdir to $dir: $!"; But that's a bit silly, especially if it's a function you call often. Am I just weird in accepting that functions have phases; e.g. init, work, cleanup? You'd `chdir` to your working directory in the init phase, and `chdir` back in the cleanup phase. Why place them near one another? Do all `print`s need to go next to each other, too? The one benefit I can see of `guard` is that you can be 'lazy' about your coding, and not handle all error cases / exceptions, because now you have a 'guard' that's going to clean up your mess, when your function / code fails. That seems like a bad thing, but I'm cynical, curmudgeony and 'old skool'.
But closing a file and changing a directory back are not done implicitly. I don't get your comparison. 
That might be the case. I'm trying to post to the r/Test subreddit. I registered for an API key but as far as I know, my program is not using it since the reddit::client example doesn't use an API key. Am I missing a vital step here with incorporating the API key?
Perl will implicitly close a file for you either when the reference goes out of scope or at the end of the program.
Interesting and good to know (and confirm with strace). I'll still opt to explicitly close my file handles, going forward, but in case I forget, it's good to know perl's got my back.
Aaand here is the [perldelta](http://cpansearch.perl.org/src/RJBS/perl-5.22.0-RC1/pod/perldelta.pod)... (5.22.0-rc1)
My use has mostly been wrappers for build tools, but I've had odd tasks here and there where it's been useful
+10 geek innernet points for you sir
&gt; The new /n non-capturing regular expression flag makes all paren groups non-capturing. Why would you want to do this? Does it speed things up? If you're not using the captures, why not just ignore them?
We use parenthesis in a regex to group things, which capture can be a side effect of. With many of those, the extra `(?:` can make things pretty muddy. Non-capturing parens are faster since they have to do less. But, I haven't written the post for that feature yet so you'll have to wait. :)
Ah, I suppose that makes sense, since you have to run the build commands in a particular directory.
Although I know you're joking, there is already some pretty hot unicode-on-regex going on. One of the v5.22 features is Unicode zero width assertions for grapheme, word, and sentence boundaries. v5.18 added [set operations for character classes](http://www.effectiveperlprogramming.com/2015/02/perl-v5-18-adds-character-class-set-operations/) as part of the checklist for [Level 1 Unicode regex compliance](http://www.unicode.org/reports/tr18/). And, it's time to move onto Level 2 Unicode support, which I think we're only missing the esoteric case folding and equivalence features.
OK, that makes sense. I guess I'll work on getting my Karma up so I can post to the r/Test subreddit using the Reddit::Client module. Thanks for the help.
I'd recommend: Moose, PSGI/Plack, Dancer, Mojolicious, maybe eventually DBIC, Slaughter. However, I wonder if the post might be fake. For example, this seems extremely fishy: &gt; I also undertook a big, 3 year bespoke project (all written in legacy non OO perl). So I'm skeptical.
I look forward to reading that post
Is 5.22 scheduled to go live tomorrow? It is May 22nd.
Mojolicious on the backend/ Javascript, Jquery, etc in the templates on the frontend...
Informative.
Reddit::Client supports cookie authentication only, so you will need to pass the path to the cookie file into class constructor. Be aware that reddit heavily rate limits requests made through cookie auth (user agent plays into this as well, e.g. don't use Python's default agent). Also, reddit will be deprecating cookie auth by August.
I recently wrote some code to do what PRAW does and prompt the user when captchas need solving. Relevant bit is [here](https://github.com/aggrolite/Mojo-Snoo/commit/6eae6afd9d08f3d23da219108e6ff1847ea4d62e?diff=unified#diff-1bdabbda7ff52d8785740aad36246d40). I'm assuming it could easily be ported over to Reddit::Client to resolve [this issue](https://rt.cpan.org/Public/Bug/Display.html?id=83178).
sorry, that was mean and/or stupid. 
4.5
Interesting. Especially the CAPTCHA solver bit. I say this as I have *super horrid* vision (so bad that I am viewing this on a 28" monitor and still am inverting the screen colors for easy viewing). I absolutely **HATE** CAPTCHAs. While as a programmer I understand their use and why they are used, I can't read half of them. If there was a way to autosolve them interactively (e.g. run script with page open, solve CAPTCHA), that'd be great, and the fact that your implementation is trying to do that is wonderful to see. When you do release it, I'd be interested in taking a look at it.
Perl5 and Perl6 are different languages. I wish Perl6 would have been called something else because it created a completely avoidable marketing problem.
indeed - the key is that nobody "needs" perl6 - just about everything you want is in cpan - and the bits that arent there are easily put together with perl5
And the capability has use-cases. What if Reddit themselves needed to automatically send users PMs for some reason? That's still a bot sending PMs.
&gt; Slaughter Is it really that good? Is it production ready? How does it compare, to let's say Ansible?
&gt; grossed me a cool quarter mill Tech me, master!
It's working well for me. I don't know enough about others so I can't compare. I chose it because the docs seemed good to me.
Keep in mind, I'm not actually solving the Captcha. I'm only generating one (see http://www.reddit.com/dev/api#POST_api_new_captcha) and sharing the Captcha link for *you* (a human) to solve.
I don't know what this is, _perly_bot.
I like these quick-start tutorials. Simple and effective (at least for me).
https://metacpan.org/pod/Device::GPS
 dance; I'm wary of frameworks that name their functions like this. (A popular PHP framework does it too.) If I've learned anything, it's that clarity is king. 
Anything?
As someone who has only been learning Perl 5 for a few weeks now, I found this to be a very interesting read. I realize this is a broad question but how does Perl 6 currently compare to Perl 5, speed wise?
A camel or onion is hardly a stellar choice for a logo or branding either. Just ignore it or clone your own P6 site to package it up for adults and corporates.
When the revolution is a **Singularity**, you can not see it coming and you can not see beyond it.
Why can't we see it coming?
Agreed, even when dying, Perl's local mechanism will still work to restore the old value of a local variable (in this case, File::chdir will restore the old pwd) when the variable goes out of scope.
Without being familiar with that particular api call, it looks like you may need to (redundantly) include the username in the JSON payload, and possibly the t and and/or sort params. I'd have to do a bit of exploration to figure out which params are required there.
Ah, okay, thank you.
How can they know if the program they are writing will ever stop?
The same way we do/don't.
Thanks for this. On the topic of tutorials, I wish there was an intermediate level of tutorials. Most seem to vary between "Hello, World" and re-writing Facebook. No middle ground.
You, as a human, wrote a program and it is taking some time, should you kill it? Same situation. The halting problem isn't generally a problem for programmers. It won't be for a sufficiently advanced AI either. Also, not all programs are undecidable. It is possible to do static analysis on a large class of reasonable programs and if it is taking a really long time to determine if it is going to halt, then it is probably a really bad program.
The code does work! I should have said. No authorisation problems. But I think the thing I pasted is incomplete. In order to get *all* saved posts you need to repeatedly re-request. In order to implement a `get_saved_posts` method you'd have to wrap the call in a loop an continue while there was still something being returned. But on the other hand, the basic `json_request` method seems to be a solid basis on which to build new functionality quite easily. 
Hi Sinan, thanks for the PR and the blog post! Actually I was aware about the fragility of the original test suite, which can fail depending on whether the module to be tested is already loaded. The original test suite was minimal and skeleton-ish. I've now expanded on it. The logic from the PR has been extracted/refactored into a routine called `test_require_ok` and `test_require_nok`: https://github.com/perlancar/perl-lib-filter/blob/master/t/filter.t https://github.com/perlancar/perl-lib-filter/blob/master/t/lib/testlib.pl 
Gotcha. And patches are always welcome :D. All I ask is that tests are included. I don't have a lot of time to keep up with a regularly changing API, but I do my best to make sure things that have already been implemented are working. It's always nice when someone contributes a new feature :)
Maybe there should be a subreddit for the module?
Sorry, I realize that "middle ground" is pretty vague and relative. Speaking for myself as someone new to Perl and VERY new to webapps, it would be helpful to have an introduction to a simple webapp scenario. Maybe a Dancer2 tutorial about using a template to display a simple form that allows the user to submit a value, then having the webapp accept the value and perform a database lookup, then return that result to the user. Ideally this would be without getting bogged down in the details of accepting and validating logins. As a newcomer, I feel that would provide a great stepping stone for beginners to progress after "Hello, world!".
[It's just a joke] My take on this is that Perl6 is correct (less edge cases, no crazy computer math, floating point problems, etc.). Anything else would be premature optimization. If I need, I will embed C into it, after measuring where it's needed and worth the hassle.
You're right about preloading them before Test::*, thanks. As to local lib, usually my problem is determining the appropriate name for the module. So I often just stick with testlib.pl (so Perl 4, I know...)
That's what Devel::Hide does. It ships with little modules [P.pm](https://metacpan.org/source/FERREIRA/Devel-Hide-0.0009/t/P.pm), Q.pm and R.pm for testing. As an aside, wouldn't lib::filter have been better implemented by submitting a patch to the Devel::Hide maintainer to extend its functionality?
How big is your listen queue on the socket that is accepting incoming connections? Is it possible that it is full?
 $ perl -le 'print "Nandor" + 1' nan /u/briandfoy, I see what you did there. ;-) 
I've been at that point for a few years now. My last Perl job was about 80% keeping the legacy stuff humming as well as possible :)
Please, bioinformaticians are writing Perl everyday. 
not for me it's not, we're writing new code all the time at $work in perl, and replacing the old legacy code with modern stuff.
I think Python does well because it's orderly. But it's rigidity makes it a bit harder (for me anyway) to get the idea in my head into working code. For example, writing a regular expression in perl is more streamlined than using one in Python. In Python, people are generally corralled into using the string functions. Perl to me: I think at the highest level in this language. That never goes out of style.
About 15 years ago, tossers used to call C "legacy".
Hi, Thanks for the suggestion. I've tried using this but I get the error "readline() on closed filehandle IN at C:/Users/Tom Hudson/Documents/Workspace/Perl Test/reddit.pl line 3.", &gt; open (IN, "&lt;/C:/users/Tom Hudson/Documents/workspace/perl test/smtplog.txt"); open(OUT, "&gt;/C:/users/Tom Hudson/Documents/workspace/perl test/file.txt"); while (&lt;IN&gt;) { if($_ =~ /[a-zA-Z0-9]+@[a-zA-Z0-9]\.co\.uk/) { print OUT $_; } } (Edit, I can't get the formatting in Reddit to look right but you get the jist of it)
It's probably those file paths, I've never used perl on Windows honestly so I don't know much about that, but that's where I'd imagine your error is coming from. 
It may have been a bit snarky, but it's not wrong. There's really no reason for using global filehandles anymore. 
If you're up for learning, another *new* thing is lexically scoping file handles in a scalar rather than a bare word so something like`open my $IN, '&lt;', '/path/to/smtp/comm.txt';` People aren't so much full of themselves as they are full of experience on why some ways of doing things are inherently a good idea to avoid common bugs and issues. There's more than one way to do it, but not all of them are equally good.
Move those 10 "use" statements into a single module?
That sounds just as weird as people writing Perl for Windows :)
This mindset is ridiculous, it's the same confusion that fuels each reinvention of wheels. Yes, Perl is in no way *new* technology, it is **established**. The apparent decreased level of adoption ("apparent" because the field is a moving target and greatly expanded vs 10 years ago, for example) does not make it *legacy*. By that measure, looking at, say, github, you'd think Windows is some obscure operating system few people actually use. In any event, rumors of its death are greatly exaggerated. ;) You'll always find some shop with some system written in, hell forbid, C++. Hey, wtf, this is *legacy*, I will rewrite everything in Go/Rust/Javascript/Nim, because that's NOT ... *legacy* and it is new and good and I am a god rockstar that knows everything. Excuse me while I kiss the sky.
The project's site is [strawberryperl.com](http://strawberryperl.com/), not .org. The .org version is an unrelated site that some domain squatter happened to buy. You can't expect a volunteer open source project to acquire every related domain on every TLD, that would be very costly and time consuming. 
Perl's module search path usually includes the current directory so you should be able to have it in the same directory as the script that needs it. You don't need to post protected code. Develop a small script and a sample module that has the same problem. Figure out how that little bit works before you struggle with everything else that you have going on. Beyond that, I cover this stuff in [Intermediate Perl](http://www.intermediateperl.com).
That's awesome.
Hey man, relax, no need to be so dramatic! Jeesuz!! :-) First, there are way better resources for you to check out instead of reddit. The bad news is you do need to do some reading for yourself, because nobody's gonna do it for you. The good news is there are tons of excellent *free* resources available to you. http://modernperlbooks.com/books/modern_perl_2014/ -- **do** read a few chapters at least, for your question see: http://modernperlbooks.com/books/modern_perl_2014/09-managing-perl-programs.html#bW9kdWxlcw http://perldoc.perl.org -- search whatever you need http://www.perlmonks.org -- way better for beginner Perl questions than reddit http://strawberryperl.com/ -- perl for windows kits and then... good old google: http://www.google.com/search?q=perl+use+library+path+pm+windows Now. Library paths, perl looks for those in an array called **@INC**. You can set up @INC in a number of ways, all of them very simple. For example, if you have Jones.pm in C:\tmp and Jones has its first line "package Jones" you can say in your program: use lib qw&lt;C:\\tmp&gt;; use Jones; and, as http://perldoc.perl.org/lib.html says, this is almost the same as saying: BEGIN { unshift @INC, "C:\\tmp"; } use Jones; If Jones.pm is in a deeper tree, say C:\tmp\Some\Path\Jones.pm and has its first line saying package Some::Path::Jones; then the "use lib" thing is still use lib "C:\\tmp"; because :: can mean deeper down the directory tree. It might also work to use "C:/tmp", with forward slashes. You can also set environment variables, if you are more comfortable with that, PERL5LIB=C:\\tmp;D:\\extra\\dirs you can read about it in perldoc perlrun. Cheer up, enjoy.
I wish Perl would add a keyword to make values immutable. #functional
Thank you, I will try to do that. and check your other link!
Inventor is surprised by the future. Film at oh wait no one cares.
Something in public health, but I doubt my employer would want me to identify my job. 
I am using it in manufacturing for data parsing and file management.
use Readonly;
Thanks for all the suggestions everyone. I'll take them on board and see what I can come up with!
Because TMTOWTDI?
&gt; use Readonly; at least link to the docs :) https://metacpan.org/pod/Readonly 
In China there are looking for geniuses, and then they'll end working with bioperl: http://www.wired.com/2013/07/genetics-of-iq/
If you search a little bit, you'll find that you are preaching to the choir. I have showed my colors as a Perl 7 supporter for exactly this reason. 
It could optimize a lot of code internally if there would be a syntax, not just a module. I use it for enforcing an API, perfect hashes, unchecked arrays and sealing classes for fast method calls. This is typically 4x faster. I haven't added general :const support for function arguments yet, where you could leave that value on the stack, no need to copy it around two times (first to @_ and then to the pad). I measured that to be 80% faster in fibonacci(20).
Did not even think about the performance benefits. What can we do to move this along?
Nothing. It will be released eventually
When Perl sees the line "use Jones;" it immediately tries to load that module. If you don't get an error message along the lines of "Can't locate Jones.pm in @INC (@INC contains: C:/Perl64/site/lib C:/Perl64/lib . ). BEGIN failed--compilation aborted." then it managed to load the module. Which means you now get to figure out what the module's trying to do and why it isn't working.
BTW, Net::FullAuto is certainly not recommended and SHOULD NOT be installed without a full code review, especially of its build process (I think you will realize why after seeing it). Further, I don't see any ++ on that module so I don't understand why your query is responding as though it has. Perhaps something is wrong somewhere?
Brian here. Yeah I was counting `release` instead of `favorite`. No I don't remember why. Probably because I hadn't gotten enough sleep when I was reading the MetaCPAN docs. [miyagawa pointed out the error](https://twitter.com/miyagawa/status/605778075830214656), and the post has been updated to reflect that - along with some changes in rakudobrew since the draft was written.
[**@miyagawa**](https://twitter.com/miyagawa/) &gt; [2015-06-02 16:48 UTC](https://twitter.com/miyagawa/status/605778075830214656) &gt; @iinteractive @brianwisti wrong API endpoint. s/release/favorite/ ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Perl 5 should just start using the release date as a version number and fall back to the first version before the creation date on the script it's executing if no version is specified :) Perl 2015 rather than 7. Then Perl 6 can just be Perl++ 2015 or something *shrug*
As perpetual beginner mediate, remind me: are we supposed to 'require 5.18' or something?
I'm thinking a foreach loop in File B to find and delete from File A... would that work?
If you're on some kind of unix or linux, the "comm" tool does this for you.
Why would you not want to just amazons API to get the reviews? (http://docs.aws.amazon.com/AWSECommerceService/latest/DG/EX_RetrievingCustomerReviews.html) The problem with that script is if they change their layout in any way (rename any of the comment div's) the script breaks as its trying to scrape the data. I would think its very unreliable! Let alone, enough of the hits to their site from your IP will cause them to lock you out (or atleast should to prevent DDos)
I'd start by editing the file and add in that $! into the print (like I show above). That way when you get a failure it will look something more like this: ```failed com B00PVF9CWG 1 2``` ```Permission denied```
Actually, I have held on to this laptop because it works so well with Linux. In addition, both my Windows and Mac laptops have Linux virtual machines. But, a considerable amount of my work involves being able to connect to Windows machines seamlessly via gateways, and that doesn't work so well Linux with rdesktop. You missed the point of the post: I am trying to improve how Perl works on Windows by default. "Install Linux" is not an answer to "how can I improve Perl on Windows". 
I meant, you didn't specify that the content was per line in both directions or what. So it's hard to give some code to help you without a more specific example of what you're attempting. But looks like you got what you needed. Cheers.
I use Perl for a variety of things, many that some consider it to be not well suited for. I've built entire network management platforms, interacting with a number of technologies: Syslog, SNMP, Expect, BGP, Mysql, Elasticsearch, Cassandra, Couchbase, Memcache, NTP, to name a few. I've also used it under mod_perl to build REST APIs, and interact with any number of API interfaces, including REST, SOAP, and JSON/RPC. It's an incredibly capable language, so don't let people put you off on it. 
You are an evil, evil person. Thank you.
My personal opinion is using `[MetaProvides::Class]` unconditionally in a bundle might be the wrong option. It will certainly work, just I feel its not justified to make all perl distributions need `Class::Discover` and friends _just_ to build it even if they're not using `MooseX::Declare`. My opinion is you should `MetaProvides::Class` directly in dist.ini when needed. This will make your bundles dependency graph more minimal, and as a result, more usable for contributors. ( nb: I am also on bpo's list of people who can't log in, so if somebody could relay these remarks to the intended, pls )
I find it shines best as a great language for "glue" projects, where you have two disparate systems you need to talk to eachother . Some real world examples for me are connecting HP OVO (monitoring) with BMC Remedy (ticketing) and ExLibris Voyager (ils) with Pro Quest summon (discovery engine) and people soft (accounring). Edit: I type gud. 
Well, I just wrote [chaturbot.ninja (NSFW)](http://chaturbot.ninja/about) in Perl. Perl gets data from an API, sorts it several different ways, puts it into database tables, creates some JSON files for other sites to use, then tweets, sends emails, and Reddit PMs based on what the user chooses. He also makes his own tweets with attached images. He used to automatically post to his own subreddit too, but I've disabled that for now because I don't think it's super useful/likely many people would use it.
[Original Source](http://xkcd.com/224/) **Title:** Lisp **Title-text:** We lost the documentation on quantum mechanics. You'll have to decode the regexes yourself. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/224#Explanation) **Stats:** This comic has been referenced 64 times, representing 0.0968% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cruuegw)
I use it for webapps, and have since the 90s. Tastes may have changed, but my opinion that Perl is the best tool for the job sure hasn't. I've worked with CGI.pm, Catalyst, WebGUI, and Mojolicious. I've made my own web frameworks (one of which made it out onto CPAN as Statocles), and consider Mojolicious to be the best web framework of any language at all. At $work I use Perl for web apps (Mojolicious), ETL, release management (Git::Repository and Git::ReleaseRepo), deployment (Rex), time series analysis (PDL and TAlib). It's wonderful for ETL because every database I come across has a CPAN module (except for esoteric/internal databases, for which I have to write my own driver using XS or Inline::Java).
I strongly suggest that people learn languages without regard for the task they might use it for. It's a tool and you put it in your toolbox. You learn the tool on its own terms. Later, you have a problem and you have some tools to apply to it. Different tasks might use different tools. You should have more than a couple tools like that. Some people may suggest Ruby or Python. My comments apply to them too. Try those languages too. You don't have to choose a side (and if someone is trying to make you choose sides, find better people). When you start with the task, I've mostly seen people learn just enough to piece together something that solves the problem. Their solution tends to be ugly. It's why people think Perl is unreadable—a lot of people not only don't understand what they wrote but don't even know why it works. Although they have "solved" their problem, they haven't really put a new tool in their toolbox. They don't have something that they can apply to a new task. Spending time with Perl won't be a waste of time if you learn correctly. You might not use Perl later, and you may not even like it. However, the ideas you run across will feed into how you think about other languages. Any language is going to think about some things in a completely different way that illuminate how another language does things. However, you have to know how to learn, which is something that goes beyond applying the minimum knowledge to a task. The other advice I give is to find what the people in your field of interest use, and use that. It's easier to communicate with other people when you're using the same tool. While you're doing that, you might explore other tools for the parts you find their tool doesn't do well. Good luck,
As a writer, I've stopped using word processors (save for final compilation/checking/exchange with the publishers) because there are too many risks in working with complex, often proprietary file formats. I write everything in a text editor, with some minimal markup of my design, and then perl transforms everything to RTF/HTML/LaTeX/PDF/more coming. I've even built a GUI for it. As a journalist, I'm currently building an interface to access my contacts, both in a private database on the Internet and in my Google account.
Oh, I already did that. I have a `t/lib/Foo.pm` which I use for testing (although `Local::*` is probably a better namespace). I still use a real core module for testing `allow_core` and `allow_noncore` though. I'm not sure if creating a test core or non-core lib directory is worth it at the moment.
That's one of problems with CPAN :) I didn't find Devel::Hide when I was searching for existing modules before I whipped up lib::filter.
Mass data import and manipulation. The Postgresql drivers in perl are the only ones that can fully handle anything that postgresql can do. Also mass mail sending and other things like this. It pretty much boils down to the fact that you just glue together various CPAN modules because pretty much anything that you need exists in CPAN.
An alternate use case… I use Perl to make smaller in-house business applications in a Windows environment. The application size and complexity is ranging from simple “pull data from 5-10 different Excel workbooks and generate some statistics” to a standalone touch applications for Windows 8.0 and 8.1 tablets with a matching web-service (all in Perl with a HTML/JS UI). What may differ from the common perception of what Perl is used for, is that all of my client applications are compiled to an exe file and wrapped in a MSI package using PerlApp and PerlMSI* and distributed to the users through SCCM. So for my users the applications could be written in anything, for me? I get the power of CPAN with very little hassle :-) Compared to other languages? Of course you can do something similar in other languages, there are some “why”s and “why not”s for choosing Perl in this setting – from what I have experience with Java, C/C++, R, JavaScript and Perl of course. Following the path of least resistance - I use Perl if I can (my guess for 90+% of what I do), C/R when I have to and JavaScript for Browser stuff. * The PerlApp and PerlMSI tools are not flawless, but allows for scripting of the compile and packaging step, so it becomes trivial to redo when adding a feature ( or a bug fix – cough ). 
This is the best thing I've read in a long time.
thanks for a very thorough and thoroughly interesting answer. You've raised a lot of interesting points for me so thank you very much for that!
I think it took me longer to understand the problem than it did to write a solution. sub count { my ($a, $b, $c) = @_; my $div = 0; my $nondiv = 0; for my $t ($a..$b) { if ($t % $c) { $nondiv++; } else { $div++; } } return $div &gt; $nondiv ? $div : $nondiv; }
I found a software solution called Revili. It worked as I wanted. Thanks for your help guys. 
I used Perl to write all the code for my dissertation. Perl is fantastic for quickly coding up (and later adjusting) complicated algorithms. This code ingested text based data, did a bunch of statistical and geometric transformations, and then generated a plot. Perl's mathematical and scientific capabilities are quite strong, especially with PDL. I have used Perl for quite a bit of what I believe many would consider more in the realm of, say, R, and Perl is just great! Perl is a great general purpose language, but in the areas of text processing and data mining I consider it to be king of the hill, based on my experience. Check out http://circos.ca for insanely awesome Perl based software that generates mind blowingly expressive scientific data visualizations.
This is well-worn territory ... *yawn*
Ah thank you. I was wondering where it was documented!
Strawberry Perl revolutionised Perl on Windows for me. Thank you, Strawberry Perl.
The sweet spot for Perl is any job that involves text manipulation and Unix system calls.
For me as well. Thank you, Strawberry Perl and sponsor: http://www.enlightenedperl.org/
I use it for everything programming-related. Easy to write, has CPAN, OO-systems to do whatever you want, doesn't get in your way and has Mojolicious.
Booking.com built the largest online accommodation booking service with Perl, and MySQL.
Strawberry Perl is great, thanks!
Thanks, I need to fix this :)
Does that mean that I shouldn't be able to reach out to the community and get up to date information and engage with people?
I use Perl for where the most important aspect of a program is going from my mind to working code. The problem is I rarely ever have a reason to change the prototype to anything but Perl because its usually fast enough and easy to refactor into something that looks nice and is easy to maintain. Perl 6 interests me because the same is true but with a lot less of a requirement to hit cpan for common things my brain thinks but Perl 5 doesn't have without extra modules. Even built in data structures like Bag (counting dictionary/bag model type) in Perl 6 make it a joy to use.
To access single scalar stored inside the array, use **$** instead of **@** e.g.: for (0..$#list) { say $list[$_]; } Note that it's clearer to iterate array like this: for (@list) { say $_; } 
`say for @list;`
And, I just read this in Bjarne Stroustrup's [Programming: Principles and Practice Using C++](http://goo.gl/nTcYqL): &gt; If your desire is to use the work of others without understanding how things are done and without adding significantly to the code yourself, this book is not for you. If so, please consider whether you would be better served by another book and another language. If that is approximately your view of programming please also consider where you got that view and whether it in fact is adequate for your needs. and &gt; Programming is learned by writing programs.
Just remove all newlines, now its one line of code!
`@list[$_]` is accessing a one-element slice of the array `@list` -- you'd ordinarily use a slice to pull out multiple values, like `say @list[0 .. 3]` to display the first four items. If you want just one item, you use this form: `$list[$_]` with a `$` instead of an `@`. [The Anatomy of Types](http://altreus.blogspot.com/2011/06/anatomy-of-types.html) is an excellent write-up on how to define and access Perl's variable types.
Poorly titled article. But yeah exhaustive matching is cool. Hello, /r/scala.
Perl has an end-of-life date? =(
And there's apparently something called "standard Perl".
Thanks, I'll give that one a try as well. EDIT: Ok I tried that and unfortunately I can't eliminate the $imagedatasize variable because its used elsewhere as well. However I did manage to combine several my statements into one towards the bottom. 
N.B. Not me.
From http://irclog.perlgeek.de/perl6/2015-06-06#i_10710024: &gt; exhaustive pattern matching checks is nice, but impractical in many cases. ... scala ... can check for exhaustiveness, but only if the classes are "sealed" ... which means they can't be extended from another file
Perhaps that's a reference to [perlsupport](http://perldoc.perl.org/perlpolicy.html), which gives a three year support policy for stable releases.
When's the last time you wanted to extent a sealed trait?
Iirc the hash seed randomization was due to a securit (DoS)y issue; I wonder how long it takes until somebody submits a security bug against stableperl if mlehman reverts the randomization.
No one would (knowingly) subject themselves to that
I agree it's a shame it never ended up in core. Putting aside the obvious reasons, it's possible Coro just does too much dark magic to make it easy to integrate into core without compromising something else. I like Coro too, but I have to concede that its user base is small, perhaps too small to justify such large-scale changes to the Perl codebase.
http://www.perlrdf.org would seem to be the place to look but nothing there yet
That contacts list sounds awesome... :)
I've often seen tchrist using that term before.
Just for the record: Perl 5 has a stellar record on backward compatibility both at the language and API levels. But Coro basically violates every bit of API and encapsulation (which perl5 doesn't have much, being written in C and all) it can find to make it work. Coro literally swaps out the majority of VM-global state including the major runtime stacks for "thread" switches. If perl5 were to promise not to break Coro ever it would become prohibitively hard to make any changes at all. Therefore the sensible approach is to attempt to fix any breakage incurred. Alas, this is where cooperation with Marc being very, very difficult comes in. On that latter point, I'll leave you to form your own opinion from his public interactions with the perl5-porters and others (see also other comments in this thread). So no. For virtually all reasonable code, perl 5.22 is not backwards-incompatible.
&gt; So perl porters breaks something Coro relies on, don't realise or don't care, refuse to revert compatibility breaking changes and blame the author, author overreacts. good job, all. Blaming p5p is bullshit. One of the changes has been [fixed in blead](http://perl5.git.perl.org/perl.git/commitdiff/73949fca) and has been nominated for 5.22.1. If he had bothered to communicate with p5p on time it would have been handled sooner. The other one is him doing something he should have never done in the first place: writing to a vtable owned by core. There is an obvious and much safer way to achieve exactly what he wants to do (replacing the vtable pointer on the object). With a 3-line patch, Coro will work fine on 5.22.1. I'm not sure he's going to accept that patch though.
The reddit post used the language. The paper had more to say than the one sentence. I am not going to continue feeding this semantic game.
&gt; So perl porters breaks something Coro relies on, don't realise or don't care, refuse to revert compatibility breaking changes and blame the author I think this quote from Dave Mitchell covers that: "But it's not our responsibility to fix every CPAN module that relies on some internal implementation detail of the perl core." If the language doesn't change and the module author is poking internal routines in the perl interpreter then there isn't much that can be done except asking them to fix their module when it breaks. Anything else is impossible to support. You would constantly find yourself tiptoeing around that module authors code, and maybe building intricate hacks into your core routines just to keep one set of modules working. It's a real shame we have this situation because Mark seems like a really smart guy who doesn't take criticism well. A stableperl "fork" might be better handled as a distribution, or just an OS choice where people stay on an older version a bit longer while working things out. I don't know if the fork will gain many adopters but any effort that is a bunch of work but not much benefit to the community just seems sad.
Yes, please don't hack it. ;) The reason I decided to use my own system to store contacts instead of Google, Yahoo, Outlook or an already existing contacts program is that none of those can manage dependencies, something which I need very frequently. For example, if a colleague I know is a spokesperson for a government agency or private company, and I have their cellphone, it wouldn't be wise to store it in the agency's or company's entry, because they could be working at a different place next year (as it very often happens in journalism). So, I have an entry for the entity, where I store the office land lines, corporate email, address, etc., and a different entry for my colleague, and then make the person entry a dependency of the agency or company entry. One entry can be dependent or parent of many others. If the person ceases working for that entity, I cut the dependency and that's it. Dependencies can have dependencies too. No other contacts program I know does this. Sadly, *that* code is in php in my server. I am now building a Perl interface for the database in my desktop, which is something I should have done from the start. Perl is so much more powerful than php that I think it would have been easier to do it this way.
&gt; Blaming p5p is bullshit. One of the changes has been fixed in blead and has been nominated for 5.22.1. If he had bothered to communicate with p5p on time it would have been handled sooner. This seems to be his standard practice now -- ignore all failing test reports or bug reports from blead, and then claim after the stable release that p5p "doesn't care". The purpose of the smoke tests against blead is to provide exactly the type of canary-warning that he claims doesn't exist.
&gt; "But it's not our responsibility to fix every CPAN module that relies on some internal implementation detail of the perl core." And yet, the p5porters *do* fix many CPAN modules that experience such breakage. I've had the honour of applying and shipping *many* patches from the porters (notably Father Chrysostomos and Zefram) to cpan modules to fix module-blead interactions. Thank you again!
Is it me or is the stream really jerky?
Not just you. Hotel WiFi sucks. For Ballroom C, [the Livestream connection](http://livestream.com/accounts/13878536/events/4112215) seems to be better.
Neither. You should have just read http://modernperlbooks.com/books/modern_perl_2014/
"Programming Perl" is more of a reference book than a learning book. I did learn using the 3rd edition myself (in combination with hanging around PerlMonks a lot), so it's doable if you have some programming knowledge already.
I tried so hard, my fingers will be beaten for this
Learning Perl would be better an geekuni has the best internet tutorial I've seen it nothing like code academy you actually get your own VM you ssh into it gives you a quick intro in each section then let's you come up with your own solution teaches you how to look through perldocs ... I think the first three days are free give it a try I recommend it to any learning Perl after already having some programming experience.
Don't worry too much about it. You'll need to have Programming Perl on hand once you get going anyway. So it's not wasted money.
I used Programming Perl as a reference quite a bit as I was learning (with Learning Perl), and afterwards while I was researching how to do things. I do enjoy books more than reading websites, things just stick in my head better. One you probably should buy is the Perl Cookbook. I learned more about Perl from that book than anything else - learning what those crazy one-line code segments actually did, and learning how to do them myself...
Sounds like he's an expert in Pearl 
Yeah, I found that the book is a lot funnier than I thought, really sets a nice tone for Perl as a community
Does anyone know if better quality versions of the talks will be uploaded at a later point? I would like to see a lot of the talks, but the video quality is an issue (at 240p reading slides is hard and it ruins the experience somewhat). Regardless – thank you for sharing online for us that can’t attend. 
"book" ? what's that??
Yes, I had used a Debian version of Rakudo, thus probably rather old; and a Gentoo version, probably more up to date, but I think I had compiled it with a "parrot" option. So, it seems worth giving it another try (and if I run into dependencies troubles, I can try the installation mean you suggested)! Thank you for this answer.
Hum... well, I built a new Rakudo using rakudobrew on my old Debian. It went fine (a lot of swapping though, on this low memory computer). But... it still does not handle multidimensional arrays declarations the way I wanted to do them. I believe it is the same error message I got on my early trials: Shaped variable declarations not yet implemented. Sorry. ------&gt; my Str @table[*;7]⏏; $ perl6 --version This is perl6 version 2015.05-139-g2281689 built on MoarVM version 2015.05-49-g07fbd62 So, not only the HyperWhatever (what a name :-) ), but also the "simple" Whatever seems not completed yet.
I think this article could be clearer in making the distinction between your computer's ip address and the ip address seen by websites that you visit. In my experience, most people don't care about their local ip address, they want to know their external ip address. You can get this with [WWW::IP](https://metacpan.org/pod/WWW::IP) I should ALSO say that I enjoyed reading this article and the solutions provided though :)
Thanks I tried using always_quote=&gt;1. Same result. It is odd because it only quotes some fields. I wish I knew the method to its madness of what fields it choosing to quote.. It looks like if I put a column separator in the data it will quote the field. otherwise it seems to randomly quote the fields, i'm sure there is logic to it, I just haven't found it.
How would I reconstruct it? I am looping through each record in the csv object and fixing certain fields then printing the record.
My example will be geared towards Text::CSV_XS and is also untested. my $out_csv = Text::CSV_XS-&gt;new(always_quote =&gt; 1, other_options=&gt; 'foobar'); $out_csv-&gt;combine(@data); print $out_csv-&gt;string(); $csv-&gt;print would be a better fit but it essentially does the above. The docs are very good for CSV_XS so i would suggest taking a look around on there.
Those are shaped arrays not just multi dimension arrays. You do not need to define the dimensions upfront when you declare a list. I've seen a patch from ages ago which adds this functionality just by having a constraint, but if you want native aligned arrays like that they are probably not going to make it in until the end or after summer. It's worth going onto the IRC chat room and raising that you tried the feature and it wasn't there. The more people shout about things at the devs the more likely they are to get done before some other feature. Commits with bounds checking and not much else. It was never merged into the nom master branch, not sure why. https://github.com/rakudo/rakudo/commits/sized-arrays?author=Arcterus
I'm trying to work on adding support to [Attean](http://p3rl.org/Attean) for that. There isn't one right now that I know of.
https://www.youtube.com/user/yapcna/videos
Oh, come on! Multidimensional arrays is the main reason I use Perl instead of shell script when I am programming anything on Unix. If you can't depend on your data structures, you might as well be using assembly.
Nah, let's just retcon Persix out of existence. It is a marketing disaster anyways.
I'm sorry to say that the quality of Perl conference videos continues to be on the lower end of the spectrum, especially compared to Python/Ruby/Node ones. I'm wondering who the supposed professionals that are hired to handle these audio/video recordings and streaming are. Bad WiFi connection might be to blame for the jerky videos, but how to explain one side of the stereo audio recording being off or buzzing in some of the videos, or audio being off for a minute in the middle, etc... Also, some videos start when the speaker is already started his/her talk, while some others only after several minutes of waiting.
Before someone complains that this is off-topic/not Perl-related, there is a mention on Perl 5.22's new `\b{wb}` support in the comments (a feature which I also just TIL'ed).
What is?
But I like Perl 6 as a language :P 
&gt; But the apostrophe of possession and the conjunctive apostrophe are part of the English language and coding should reflect this. &gt; Language is a product of history. Changing it now to suit computers is one approach Hi, I'm the guy who wrote that blog post. At what point do you think I was saying that we should change the English language to suit computers? Because I didn't say that at all, I don't believe that, and I get angry at people who say things like that. The people who say things like "Oh, Perl's \b{wb} has a problem with words that begin or end with apostrophes? Well, English words shouldn't begin or end with apostrophes.", they're the ones who think language should change to suit computers. I'm saying the opposite. I'm proposing a different encoding of the English apostrophe to fix the fact that things like \b{wb} don't properly detect English words. I'm suggesting changing the *technology* to match the *language*. &gt; Badly written regular expressions break because they were not reasoned about properly nor tested before use. That's not what I meant. I'm not talking about specific regular expressions being broken (though I give examples of those). A lot of work has been done to create "Unicode regular expressions" that are language-agnostic (and Perl implements much of that work), but the conflation of apostrophes with closing quotation marks undermines that work. That's what I meant by "breaking regular expressions". I meant the technology is broken.
The proposal is not to use different apostrophes for possession and conjunction, it's to use the apostrophe for possession and conjunction and use quotation marks for quotation. I don't see how this is inconsistent at all with English. I've never thought, "oh, someone is saying something, better surround the text with some apostrophes."
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 29. [**Typographic form**](https://en.wikipedia.org/wiki/Apostrophe#Typographic_form) of article [**Apostrophe**](https://en.wikipedia.org/wiki/Apostrophe): [](#sfw) --- &gt; &gt;The form of the apostrophe originates in [manuscript](https://en.wikipedia.org/wiki/Manuscript) writing, as a point with a downwards tail curving clockwise. This form was inherited by the *typographic apostrophe* ( ’ ), also known as the *[typeset](https://en.wikipedia.org/wiki/Typeset) apostrophe*, or, informally, the *curly apostrophe*. Later [sans-serif](https://en.wikipedia.org/wiki/Sans-serif) typefaces had stylised apostrophes with a more geometric or simplified form, but usually retaining the same directional bias as a closing quotation mark. &gt;With the invention of the [typewriter](https://en.wikipedia.org/wiki/Typewriter), a "neutral" quotation mark form ( ' ) was created to economize on the keyboard, by using a single key to represent: the apostrophe, both opening and closing single [quotation marks](https://en.wikipedia.org/wiki/Quotation_mark), single [primes](https://en.wikipedia.org/wiki/Prime_(symbol\)), and on some typewriters the [exclamation point](https://en.wikipedia.org/wiki/Exclamation_point) by overprinting with a period. This is known as the *typewriter apostrophe* or *vertical apostrophe*. The same convention was adopted for [quotation marks](https://en.wikipedia.org/wiki/Quotation_mark). &gt;Both simplifications carried over to computer keyboards and the [ASCII](https://en.wikipedia.org/wiki/ASCII) character set. However, although these are widely used due to their ubiquity and convenience, they are deprecated in contexts where proper typography is important. &gt; --- ^Interesting: [^Modifier ^letter ^apostrophe](https://en.wikipedia.org/wiki/Modifier_letter_apostrophe) ^| [^Apostrophe ^\(figure ^of ^speech)](https://en.wikipedia.org/wiki/Apostrophe_\(figure_of_speech\)) ^| [^Modifier ^letter ^double ^apostrophe](https://en.wikipedia.org/wiki/Modifier_letter_double_apostrophe) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cs1my9k) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cs1my9k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
@raiph &amp; MattEOates Since it is not for any professional use, and not either for any serious personal/hobby use, there is no reason you should rush anything or prioritise this matter over another for me. For the same reasons, I will not try to work around or use other ways of writing that do not look as good, I will just give up for now and check again in another 6 months. I was very happy when, after just a few minutes of Perl 6 discovery, I found out this syntax because it was expressive. So it appears as soon as the 5th line of my 'translation'. I would rather wait until it is clean and ready than trip again on the next almost-but-not-yet-fully-supported feature a few lines further on and thus get disappointed. Hopefully some day it will happen :-)
The company that produced last year's streams (which had great reviews) was brought back. I haven't seen the live video streams from other conferences but being nerdy enough to watch CSPAN a lot this looks comparable. Live is hard. The video has all been captured at high quality and will be uploaded after they have a chance to edit it to replace the video that is there now. At least that is the plans I have heard from the on-site crew.
It's human nature. Apple must suck to enjoy PC or Android and vice versa, Firefox must suck to appreciate Chrome, Coke must suck to like Pepsi,etc 
Upvote for using fucky as an adjective.
It was the least I could do considering you both replied with detailed answers and even woke up the development process about this feature. About the release, my personal opinion is: I prefer it is delayed for 3 or 6 months after Christmas and you do not rush everything to comply with an arbitrary deadline someone randomly fixed, causing the release of an unpolished product that will break soon after, just like the other 'new' language which is the hype of the moment... And people who still follow (closely or very very loosely like I do) Perl 6 have proven to have an infinite patience :-)
Just saw RJBS' YAPC::NA 2015 talk, it's `(?-n: ...)` or named captures `(?&lt;foo&gt;...)` (or `(?P&lt;foo&gt;...)`). 
So you replaced a line of Perl with a Scala _framework_? :)
See also [Sort::Key](https://metacpan.org/pod/Sort::Key).
&gt; woke up the development process You make it sound like it was asleep! &gt; an unpolished product It's already sufficiently polished for the most adventurous users. I doubt the most demanding users will be satisfied this decade. &gt; that will break soon after The Perl 6 design directly addresses the potential conflict between stability and evolution. A very important notion is protecting production code from compatibility issues when upgrading. In particular, a fragment of code can specify that a particular version (or version range) of a module or of Perl 6 itself should be used in that fragment. Aiui, this version control stuff is one of the most important things to finish before shipping an official production ready 6.0. Once it's in place production breakage due to compiler or module upgrades should simply cease to occur. (Of course, it's not quite that simple. But hopefully you get the point.)
I understand what is happening. The question is "how to make a signal interrupt the read".
mfontani did answer your question: die inside the sub. $SIG{INT} = sub { die "Interrupt received.\n" };
But I wanted to do some work in the loop context before dying (properly closing the handle etc).
&gt; You could set the filehandle to non-blocking and then handle signals during the read loop. IO::Select might be helpful for this because otherwise you're going to have a tight loop which wastes CPU. Playing with non-blocking IO is overkill for my use case, I was just trying to get the usual behaviour where read() calls interrupt with EINTR error code. If that's not possible in perl, I'll just forget about doing things properly...
Perl implements safe signals nowadays ( http://perldoc.perl.org/perlipc.html#Deferred-Signals-%28Safe-Signals%29 ), which appears to resume I/O when a `SIGINT` occurs (after running your signal handler); see "Interrupting IO" ("The `:perlio` layer checks the signal flags and calls `%SIG` handlers **before resuming IO operation**," emphasis added). I believe your solution is to add an `eval` block: #!/usr/bin/perl $SIG{INT} = sub { die 'Signal'; }; while(&lt;&gt;) { eval { print $_; }; if ($@) { # signal caught ... } } Since you probably want to do the clean up anyway, you may not even need to check `$@`. Personally, I would recommend using an approach that automates the cleanup. When you exit a scope, filehandles are closed, `local` variables are changed to their previous values, and objects with destructors are destroyed. You don't have to remember to do anything for that to happen.
As a remote viewer, I've been disappointed by the videos streamed and uploaded by YAPC, whatever continent they're from. A wide shot of the presenter and screen means you can't really see either properly. A closer shot of the presenter means you can't see the slides, kinda pointless. Screens that are too bright or too dark are unreadable, as are those showing lots of information but streamed at low resolution. https://www.youtube.com/watch?v=U4ja6HeBm6s is an example of what is possible. You don't have to be Harvard, MIT or Google to produce high-quality recordings of tutorials and workshops.
Get roughly the same performance improvement by memoizing your comparison routine.
If it's free, what's the catch?
I think they are mostly using the free level of AWS. Note that you don't get an "always on vm" at the free level of Koding. If enough people buy the next tier up (or better), it subsidizes the free level if they go over. A t2.micro (which is what it looks like you get) costs $6.57 a month (for a year) to reserve with no other up front costs (or as little as $4.19 if they are willing to gamble). Koding is charging $9.95, but you get an IDE and other management tools you don't get from Amazon. It also looks like you can walk away at any time (unlike Amazon), but the monthly is even more expensive: $12.50 (close to two months with Amazon).
It is not safe to assume the value of $@ is correct. The right thing to do is use a true value at the end of the eval and test for that: eval { do_stuff(); 1; } or do { handle_failure($@) }; Or, better yet, use Try::Tiny as it handles all of the edge cases for you: try { do_stuff() } catch { handle_failure($_) }; 
No. Until [this bug](https://rt.cpan.org/Public/Bug/Display.html?id=101962) is fixed, mod_perl won't run on 5.22. 
They sure can be fun! Actually they are very useful for micro prototyping or for a quick demo. 
Sounds good.
Yep, I tried again and still can't get in either.
yes the last point is to use Inline C, but why wasting time if you could write a fore like "for(my $i=0;$i&lt;=10;$i++)" instead "for(1..10)", the second is faster and better to read .... or use an o flag in regex just bring performance with a single char if it is possible to use.....
I never had any problems with that ....
I know that they both do the same, y was an older version. I am not sure what you mean with your "use strict" answer, my point is that its not necessary to load modules that I only need for developing .....
And I just used pack for SpaceX! 
Yes ^^ but some points are point of view, to chose this or that .... Because its a function from Perl and its written in C, and if you do it manually in Perl its slower ....
ok, i said to change it, but i think its a little bit point of view in some cases ....
* [Modern Perl](http://modernperlbooks.com/books/modern_perl_2014/) * Programming Perl * The Perl Cookbook * Mastering Perl
"Beginning Perl" by Curtis Poe is very current (and goes well beyond beginner).
Glad to see porn is still a programming motivator in the older languages ;-)
And here I was, glad to see I wasn't the only one who doesn't `use strict`. There are dozens of us!
I don't get it. Someone explain?
Just curious, why does this need Reddit::Client? For private subs?
Just for the interface pretty much.
I wrote myself something similar which just grabs JSON from Reddit's `.json` URLs. It's not nearly as detailed as yours, but it does the job. Here's an idea: use LWP::Simple's `mirror()` function instead of `getstore()`and run your code as a cron job every night. 
&gt; The only non-core library it uses is Reddit::Client, which you can install with cpan Reddit::Client. It also uses LWP::Simple. The HTTP library in core is HTTP::Tiny (since 5.14).
LWP::UserAgent has been in there since 5.10.1 though. LWP::Simple is the (simplified) non-OO version of that module, right? 
Don't you spend a lot more time finding bugs?
I use it largely for administrative scripts that are small in comparison to larger software pieces and such so, generally no. I am floored by the negative response Haha. It's as if differing opinions can't exist. Besides, it still reports line numbers of errors..... 
I'm only handling the LA ones which will switch between Santa Monica and Downtown LA. You can host Quack &amp; Hacks in your city too. Check out https://duck.co/blog/hack-your-city
Ah, indeed I was. The perils of using `corelist -a`, the actual module name gets lost among all those version numbers. :) 
&gt; it hasn't been updated since 2003 so a lot of the code examples will be really dated Agreed. I occasionally dip into it and find a useful gem. Like temporary filehandles with `open`: open my $fh, '&gt;', undef; [Entry](http://docstore.mik.ua/orelly/perl4/cook/ch07_12.htm)
I agree, Python is powerful than Perl.. Perl is almost dead now, new programmer never use perl because of so much ugly language.
PBP only mentions that regexes are slower. The potential for errors is the opinion of the blog poster.
Most Perl code avoids this kind of problem by separating `==` and `eq`, which is the same choice that `cmp_ok()` lets you make. PHP and JavaScript both really screwed themselves by not making the same distinction.
A reason against that is that `cmp_ok()` will give you better diagnostics for failures: $ perl -MTest::More=tests,2 -e 'ok(1 == 2 ); cmp_ok( 1, "==", 2 )' 1..2 not ok 1 # Failed test at -e line 1. not ok 2 # Failed test at -e line 1. # got: 1 # expected: 2 # Looks like you failed 2 tests of 2.
The difference is in the precision, which an unwary test-writer may assume would evaluate to be the same (but doesn't).
Yes, and I see people use it for numeric comparison all the time. Edit: including people who know better than to write `if( $num eq $other_num )`.
["Official" version](https://www.youtube.com/watch?v=e5_7v7q98-g#t=48m17s)
I wish the title included the words "for numbers" in it. The title as is makes it sounds like a vulnerability or something. That said, it makes it more sensational and thus I read it.
What works for some doesn't work for others. What works for you? Try out some different methods.
I think it's unfair you're being so heavily down voted. As others have said, it's tough to offer objective advice for this as we are all so different. I'd more try to think about what kind of learner you are! 
I found it useful to read like SICP. Read until you reach a point where you aren't sure if you understand. Write the code. Study the text and the code until you're sure you understand. Sometimes that's a paragraph. Sometimes that's several pages. It's worth studying at that level of detail.
One thing you might try is watching the MIT OpenCourseware lectures for the Structure and Interpretation of Computer programs class: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/ Hearing some of the ideas explained with hand gestures and whiteboard action might be helpful. I enjoyed reading Higher Order Perl, but I had a class at the University of Minnesota that used SICP (Wizard Book) first. Regardless, it's a subject that requires practice. Good luck, and most important, *have fun*!
I wish downvotes weren't anonymous. Especially in some other groups, I'd really like to know who the haters are.
there are 22 links, in this article ... I don't want to put the hole code in the article that is a bit confusing.
I do use `is()` in `Test::More` and will continue to do so. The fact is that a failed test is a successful test. You discovered a bug. Your floating point code was doing something you did not expect. That you acknowledged this particular bug was not a problem is also a success - you changed your test code appropriately. It would be wrong to assume `is()` does not provide a useful function because of this specific case.
You have a hard time finish it because of lack of background in the concept which mostly are of functional programming. Read a introductory book on functional programming first, then come back to this book, it will become much easier.
Starting there in September, can't wait!
To some degrees, yes, I'm sure. I guess I'd have to know more about why people downvote things. The problem is, it seems like it's used both to combat spam (yet another copy of the same obvious joke that's already in the thread 30 times, for example), but I also see anonymous downvoting used to enforce a hindmind. /r/randomactsofblowjob often manages to completely sink M4M posts before anyone sees them for no apparently reason other than apparently "it's gay". This isn't a plan I've thoroughly thought through, but I'd hope if people had their name attached to the downvote, it would encourage them to explain their position, briefly, and be out about their position, and I think in a lot of cases, their position is indefensible. Perhaps if things got downvoted and people commented and explained "this is an unfair attack on religion", for example, people might be more fair (and therefore constructive) in posts on religion. Maybe it would de-polarize things if we got used to hearing the voices of people. Dunno.
I also don't know. I though of asking here than in /r/learnprogramming because I wanted to know more about this specific book not in general
I took that detailed approach the first time. Coded every paragraph but I've felt I don't advance and then just left it...This time I'm not going fot that detailed granulation, but just read through it and ad the end of every chapter/sub-chapter
That's true, it's very detailed...thanks for the approach too, sounds good
&gt; But, they went further than that and asserted that Perl is worse than line-noise, a common bad joke for people who wonder why they can’t learn a complex skill before lunch. What d foy says here is simply not true. The authors only say that their experiment was not able to distinguish Perl from line noise. Maybe that sounds bad, and we've all seen the inflammatory reddit posts exploiting that fact in ways the author of the paper do not intend. However, i know that the authors would be the first admit the limited power of their experiment. Brian d foy's butt hurt blog posts miss the point of the Quorum language studies by mistakingly thinking the authors are writing about Perl. Hint: the authors are writing about Quorum, and their methodology for designing it from the ground up using the scientific method.
This is the second time today I've noticed _perly_bot posting something that was broken. The first one was a typo leading to half the page being formatted as code, this one is an empty RSS feed with a broken SVG tag. I'm guessing someone is about to post an article and the bot is indexing before the author has a chance to finish editing. Would it be possible to tweak it for either article time &gt; than x hours, or article word count &gt; xx or some other metrics, so that it has a chance of quality control while retaining freshness?
&gt; There seem to be two kinds of data files out there. Three. Defined format, no defined format and then Novell / NetIQ log files. 
Use Marpa from the start, and then as you encounter weird unexpected formatting inconsistencies dealing with them isn't a total nightmare, like it would be if you naively used some regex and split and so-forth.
A new revelation (to me) was that their Quorum code does not work: http://www.nu42.com/2015/06/quorum-creators-cannot-write-quorum.html Also, in a follow-up paper, they added Java, Python, and Ruby to the mix, and the code snippets they show are strangely inconsistent with each other: http://www.nu42.com/2015/06/then-they-came-for-java-and-ruby.html
You do not know what *ad hominem* means.
What they did in this paper is an offense to the discipline of Statistics. They do not understand what a hypothesis test is, they don't know how to interpret a p-value, they make a big deal out of a *p = 0.047* with six observations, they use a test that only performs well asymptotically with just six observations. The correct way to look at their data would have been to just plot the observations, instead of obscuring them with box-plots with just six observations.
Coupled with the inconsistencies across their Java, Python, and Ruby snippets, it emphasizes the sloppiness of their methods. The participants in their study were given such snippets to learn from. The variation in the participants' performance is not necessarily *just* due to variation across participants in ability, or variation across programming languages in comprehensibility, but also due to variation created by the researchers' sloppy snippets.
Ok, but we still don't know whether or not the old Quorum code worked with the Quorum implementation available in 2010, when the study was done. One would have to get the old version of Quorum to even know for sure that the code was invalid in 2010.
Someone needs to bring back MUD: multi-player adventure game with combat that you get access to add to after beating. First, you learn how everything works as a user, then you get sample code for creating simple things (items, weapons, rooms, armour, monsters, etc) which you can copy and modify and put into your own area, and then you get access to more and more stuff -- the main world map to help fix and improve it, then other player's areas to help them learn and fix their stuff if they bail, then the core logic of the game. I must have taught hundreds of people to code on one of those and still run into people from that era who remember me. Good times.
I agree with this. It highlights the fact the functions return the same data in different formats and will encourage you to align them or think hard about whether your code relies on the wrong evaluation test.
And then they can go into dungeons, after having programmed their party with things, and they've got to survive it. That sounds awesome!
I've been using Perl in bioinformatics for about 5 years, this is a great guide for beginners. I wish more people that want to take bioinformatics seriously to read this. Crosspost to /r/bioinformatics if you like :) 
Yeah, i was wondering for the same. I feel that Perl is left behind as Python took over it's stardom. 
Meh. Python helps you think more like the computer. Perl helps the computer think more like you. 
[Text version of slides](http://www.reddit.com/r/perl6/comments/3b40pt/hacking_on_rakudo_talk/csjf8kv).
I hate to defend them, but I want to mention something (without reading the new article). The Perl example that was given in the original article might have been written by one of their novices. If so, that might explain why it's terrible. This also might explain why several of the examples are counting with floating point. It might be something in the instructions that steers the novice towards doing it, or a natural tendency of the persons they're testing. Or perhaps they falsified the data and had one person generate the code for all three languages and that person has a tendency to count with floating point? (Yes, I went back to being mean spirited.. sorry about that) An interesting side point is, without help from a teacher or each other, I find it hard to believe that 6 Novices can complete some of these programming tasks unless they have some background in math or computers or something. It seems like they would need a much larger pool and have lots of "Did not completes" in their results because people just can't grasp concepts even with unlimited documentation. This outside influence might also explain similarities in code examples (a more benign answer, but ultimately showing another way the study might be flawed?) 
You should read the papers. These are reference code samples for *one* of the tasks. That is, the participants, who have never programmed in their lives, are supposed to learn from these examples provided to them by these CS super heros: &gt; Figure 1. This code shows one of the code samples provided to participants. The description said the following: "This code will count the number of values that are and are not divisible by c and lie between a and b. It then compares the number of values that are and are not divisible by c and makes the greater of them available to the user." They have other reference code samples, but you have to request them. Also, I doubt any of the participants had a 100% correct program at the end. Instead, they have a scoring system which they don't describe. That's how they decide how good the programs are. That is, all six data points for each task probably come from people who did not write a complete working program. Use the links from [Stefik's research page](http://web.cs.unlv.edu/stefika/Papers.php).
I love that site. (Although I don't see Perl as a choice in the dropdown menus...) :)
Because even though windows may *have* GAI, perl doesn't use it, and doesn't try to detect whether the system has it, so the config variable isn't set. It uses gethostbyname and getservbyname from winsock. If Windows's GAI is good enough to use, and provides some advantage over what perl is already using, maybe that could be fixed.
Fortunately, there's basically no reason whatsoever to use lib::filter so its failure to install isn't really a problem. If you'd care to explain why you think this is a good idea, I'll have a go at suggesting a sensible way to achieve the same thing :)
The question is weird to me. If you have the values in an array, why bother putting them in a database? A database is generally used for handling lots of data. So much data that you'd rather not load it into memory. But you already have the data in memory.
&gt; That's because plackup is a very basic server that can only handle one request at a time. &gt; Let's try Starman which is a "High-performance preforking PSGI/Plack web server". &gt; We stop the server using Ctrl-C and start it again using `starman echo.psgi` Plackup isn't a server at all, it's just a script for loading a server and an app and doing some basic housekeeping. You're talking about [Plack::Handler::Standalone](http://p3rl.org/Plack::Handler::Standalone), which is the *default* server that Plack::Loader uses most of the time. If you use `plackup -s Starman`, it will go ahead and use starman instead.
Because I am a database developer. I am trying to create something to adhoc load files to a database. I should have stated that earlier.
This is very helpful, thank you.
I'm not sure exactly what you need, but have you seen the in-memory option available with [SQLite](https://metacpan.org/pod/DBD::SQLite)? It lets you create a table(s) in memory and then insert/select/update/delete/etc. from that table using standard SQL commands.
Please don't capitalize Perl.
How do you create a table? Using SQL: create table foo { id int, name varchar(255), rank ENUM('private', 'corporal', 'sergeant', ... ), serialnum int } If you have an array with elements, how would you create a corresponding 'create table' SQL? Just automate the process, then feed the SQL into DBI.
geekuni .com its awsome gives you your own virtual machine to ssh into where you can write scripts play around and install different cpan modules
It actually is working. You're just seeing the effects of output buffering: the prints have been sent to the buffer but not yet flushed to the terminal. If you put a newline on the end of your notification *and* are outputting to a terminal, you are likely to see the messages immediately, since stdout is usually line-buffered when it refers to a terminal. If you need the output to be produced immediately, even if you don't include newline or are writing to a file or pipe or socket, you can set the stream to flush on output: sub { use English; local $OUTPUT_AUTOFLUSH = 1; # or $| without use English # If this were print HANDLE, you'd use FileHandle's autoflush method instead. print "Created dev file " . shift-&gt;fullname . "; " }
I just decided to try the /dev directory again and it outputs my message. But if i try my home directory and create a file with `touch` then it does not work. 
Step one: Don't use Net::IRC. Use POE::Component::IRC instead (or one of the many modules built on that which make IRC Bots significantly easier to build).
Ok, thanks for the advice, I knew I was delaying the inevitable. I will work on rewriting the bot to use this. Could this be the reason the script isn't delaying properly though?
Apart from not using Net::IRC which was already mentioned, I increased the delay to 2.5s and it seems to work just fine. 0.25s is barely noticable, I've read somewhere that anything below 0.1s looks as though it's instantaneous. And if you're interested in writing more stuff in Perl, I'd suggest reading [Modern Perl](http://onyxneon.com/books/modern_perl/) to increase the quality and consistency of your code. 
&gt; I knew they were selected to be novices Then I'm just confused as to why you would have accused the authors of accidentally selecting "bad coders". Obviously the participants were "bad coders" since they were novices. &gt; You're approaching a fallacy by saying it's accepted by the ACM Stating a fact such as, "the paper was accepted into an ACM conference" is not even an arguments, so I don't know how it would approach a fallacious argument. I said it to suggest perhaps you have a low opinion of ACM standards. I never said the paper was good or that the results were correct because it was accepted an an ACM conference. &gt; No it doesn't. &gt; "An empirical comparison of the accuracy rates of novices using the quorum, perl, and randomo programming languages." That's the title of the article, not their research question. It's actually not even a question, so I don't how anyone could honestly be confused by that. &gt; Your fixation on this is sad I pressed the issue because previously none of the comments that were made in reply to my statement addressed either the content of my statement or the content of Brian's blog post. Your original reply to me was non sequitur, and even off-topic. I guess I was intrigued by your behavior. &gt; in other words, Perl users were unable to write programs more accurately than random noise And anyone, including both fans and foes of Perl, who believes that the paper attempts (successfully or not) to make the case that Perl is as bad as line noise has misread the paper. &gt; you tried to ... say that [the paper] wasn't an attack on Perl The result of the paper was to reject this null hypothesis: *Novices programming a computer for the first time will have equal accuracy rates, regardless of the programming language used.* If the paper was meant to be an attack on Perl, then the authors plainly choose the wrong null hypothesis to test. I don't know why you've attributed authorship of the paper or the development of the language Quorum to me when you said "your paper" and "your language". I'm not an author of either. I've never claimed credit for their work and I won't take credit it whether or not you think their work is terrible. 
&gt; Fortunately, there's basically no reason whatsoever to use lib::filter so its failure to install isn't really a problem. &gt; &gt; If you'd care to explain why you think this is a good idea, I'll have a go at suggesting a sensible way to achieve the same thing :) Author of lib::filter here. Call me intrigued :) Currently I'm using lib::filter for several purposes. Could you suggest a sensible way for each? * Testing whether a fatpacked script can run with just core modules: % perl -Mlib::filter=allow_noncore,0 fatpacked.pl Admittedly, in this case one can also use [lib::core::only](https://metacpan.org/pod/lib::core::only). * Testing whether a test script can run (can skip the tests as expected) without an optional dependency: % PERL5OPT=-Mlib::filter=disallow,DateTime prove -l t/perl-type-date.t Also, admittedly, in this case one can also use [Devel::Hide](https://metacpan.org/pod/Devel::Hide) instead. * Testing whether a fatpacked script produced by [fatten](https://metacpan.org/pod/fatten), which can be instructed to skip some modules, can run with only core modules *and* a certain set of specified modules: % perl -Mlib::filter=allow_noncore,0,allow,'Foo::Bar;Baz' fattened.pl 
Since it says it will teach you formats and "the Perl CGI.pm" I would say it is at least 5 years out of date.
helpful.
No. A question is a question, it has an answer. This seems to be trend of Perl devs going back 20 years and it's a bad one.
That's because Perl leads a lot of novice developers down pathways that are dangerous. "How can I call a method on a class if I have the method name in a scalar?" The X answer is dangerous. The Y answer is a dispatch table. Not all questions are good questions.
I don't see what you're having problems with, this seems utterly trivial. Caveat: all below is just typed and not tested, it probably doesn't even compile. To find out the max length from a data file you'll have to probably loop throught the entire dataset and compute the max length for each column. Let's say that's already done and now assigned to $value_max_length for a certain column. Now you create a table. In SQL that's my $ddl = qq| CREATE TABLE abc ( -- PK here my_column VARCHAR( $value_max_lengt ) ); "; Here's how you run arbitrary SQL using DBI: # The DBD::ODBC driver might be a good option # for connecting to SQL Server. my $dbh = DBI-&gt;connect(...) or die; $dbh-&gt;do($ddl); Done! Now you need to adjust that to deal with the max length for multiple columns (put them in an array or hash keyed on col names), maybe get the column names from the first record of the file, if it's in CSV maybe read the file using the Text::CSV_XS module (using the file handle interface, not by reading in the whole thing into an array in RAM). etc. etc. BTW, beware of SQL injection when dealing with SQL as strings, but I'm pretty sure this example can't be done at all using placeholders.
Keep `strict` off, and most of the example code probably compiles already.
Good advice for beginning and intermediate programmers. Somewhat more advanced programmers, though, have sometimes over-learned this lesson. Template formats with raw Perl sections, like tt2, seem like magic when it's actually quite simple: the template reads the Perl in between two delimiters, and then passes it to `eval(STRING)`. Sometimes it will add a `package` statement and wrap it inside a `sub run() { ... }`, so that way you can run it with `$pack-&gt;run()`. Either way, the trick isn't that tricky at all. I've seen some perfectly competent programmers go to great lengths to avoid `eval(STRING)`, only to end up using a gigantic, memory-hogging template module that eventually does an `eval(STRING)` of its own.
Is CSV_XS the best option for this? I need to be able to open the file, loop through each column to find max length and then insert each record. I have something right now working with Tie::Handle::CSV; but it's choking on quotes with commas in them.
Tie::Handle::CSV uses Text::CSV_XS internally to do the parsing and construction. I don't think there is a better way -- you're going to have to process each one to find the max value. `my $hashLen = %tableCreator{$loopVar};` is an error. It should be `my $hashLen = $tableCreator{$loopVar};`. You could use Text::CSV_XS directly but I don't think that makes it any easier. $ cat file.csv foo,bar,baz value1,value2,value3 valuevalue1,value2,value3 $ perl csv-xs.pl $VAR1 = { 'bar' =&gt; 0, 'baz' =&gt; 0, 'foo' =&gt; 0 }; $VAR1 = { 'bar' =&gt; 6, 'baz' =&gt; 6, 'foo' =&gt; 11 }; csv-xs.pl use strict; use warnings; use Data::Dumper; use Text::CSV_XS; my $csv = Text::CSV_XS-&gt;new({ auto_diag =&gt; 1, binary =&gt; 1 }); open my $fh, "&lt;", "file.csv" or die "file.csv: $!"; my @column_names = @{$csv-&gt;getline($fh)}; my @column_lengths = map { length } @column_names; my %table_creator; # used 0 instead of your default of 255 @table_creator{@column_names} = (0) x @column_lengths; warn Dumper \%table_creator; $csv-&gt;column_names(@column_names); while (my $row = $csv-&gt;getline_hr($fh)) { for my $column_name (keys %$row) { my $length = length $row-&gt;{$column_name}; $table_creator{$column_name} = $length if $length &gt; $table_creator{$column_name} } } warn Dumper \%table_creator;
Edit: oh I guess I misunderstood your request. With my module the code would still look similar. I can plug my module: https://metacpan.org/pod/Tie::Array::CSV
Thank you, this was very helpful. Got it working with your solution
First, check out the performance section in the [Math::Bigint manual](http://perldoc.perl.org/Math/BigInt.html#PERFORMANCE) for a few tips. Second, you definitely want to install GMP and use it like mentioned in the [library section](http://perldoc.perl.org/Math/BigInt.html#MATH-LIBRARY). Third, are you sure it's the library itself, and not some algorithm issue giving you exponential time or something making too many calls? Can you move invariant things out of loops, etc? Perl has a number of performance tools, [see here for a few](http://perldoc.perl.org/perlperf.html) which will tell you where the time is being spent.
Anyway, I'd love to get your input/comments on my other modules, if you have one :)
I learned a few things when I was working on a Perl assignment with the [Ackermann function](http://rosettacode.org/wiki/Ackermann_function). BigInt can be more efficient when the most frequent values have already been converted to BigInt values and are called accordingly. For example, the first thing I did in my Ackermann script was to declare 0 through 3 as BigInt variables: use vars qw ( $zero $one $two $three ); $zero = Math::BigInt -&gt; new (0); $one = Math::BigInt -&gt; new (1); $two = Math::BigInt -&gt; new (2); $three = Math::BigInt -&gt; new (3); During my main process I convert my user's two values to $mary and $nancy as BigInt values. Then I have a short table (really just some elsif-ery) to skip the most CPU-intensive steps: if ($mary == $zero) { return ($nancy + $one); } elsif ($mary == $one) { return ($nancy + $two); } elsif ($mary == $two) { return ($two * $nancy + $three); } elsif ($mary == $three) { return ($two ** ($nancy + $three) - $three); } There is more to it, but you may want to write your own script and learn from the experience. A [Computerphile episode](https://youtu.be/i7sm9dzFtEI) has a legendary computer scientist running a C-based Ackermann executable with A(4,2) and it was taking hours. My Perl script takes a second or two on a dual-core laptop from the garbage or 4 seconds on an old P4. (He was proving the point about unoptimized scale, so I give him props -- it's an excellent demonstration.)
By all means leave lib::filter on cpan, though I'm still not convinced those other options are necessarily *useful* :) &gt; Thus creating a fork/separate module is easier. Easier for you, at a cost to the rest of the CPAN ecosystem. Also you miss out on chances to collaborate and learn; I usually hand out co-maint to people who produce good patches so they can do their own releases so they aren't dependent on me and having their patched version on cpan is a quick step. You're missing out on what I consider to be a lot of the fun of writing perl modules - also, it's traditional to put your cpan author in the name for "this is a hack while I get a patch in" type stuff. If fatten had been called PERLANCAR::FatPacker while you prepared a patch I wouldn't've minded at all - but polluting real namespaces with things that could just be patches isn't how cpan stuff is generally done.
DBD::Pg groks array types. https://metacpan.org/pod/DBD::Pg#Array-support Use the standard ? placeholder and pass in your arrayref when you call execute(). DBD::Pg will flatten it to the PostgreSQL array syntax (just make sure the arrayref you pass in matches the dimensions of the column as defined in PostgreSQL). When retrieving data, DBD::Pg will automatically explode array type columns in the resultset to Perl arrayrefs, though as the docs linked above point out you can turn that off if you have a specific need for doing so. If you're asking how to use placeholders for individual elements in a PG array type in your query strings - I'd be inclined to say there is probably a better, more PostgreSQL-y way by sticking with the built-in PG array operators and functions (http://www.postgresql.org/docs/9.4/static/functions-array.html) rather than getting yourself into a situation where you're mangling SQL strings with some unholy mess of sprintfs, joins, concats, and -&gt;quote() calls to build the raw array strings yourself. Let DBD::Pg handle translation between Perl arrayrefs and PostgreSQL arrays, since it will do it consistently and correctly.
Sorry; I forgot to come back and look for responses. I always feel bad about looping. It seems inefficient, but I don't see how you can avoid it in this case. You want to know the longest string in each column. You're going to need to look at each string to find the longest one.
You'll note I also answered the question. I generally try to be helpful, but I am also willing to ask "wait, what are you doing?" Perhaps there's a better approach. Perhaps I can tell somebody not to shave a yak.
I'm also interested in Perl. I would say write programs, find a need for something that you can fulfill and build it will Perl!
Thank you for assuming the worst. I'll try my best not to belittle you one day when you come asking SQL questions. 
Will there be a rakudo-star-2015.06-x86.msi install coming out?
&gt; `\my $error_msg` I do *not* like this type of declaration in the parameter list of a function call. I don't care if it is legal - it is ugly.
I thought it was a logic puzzle. Instead, it's very literal. 
This is a great example of poor puzzle design.
Hi, I wrote the book. Thanks for reading it. Many people report getting bogged down in chapters 4 and sometimes 5. If this happens to you, skip to chapter 6. My favorite chapters are 8 and 6. (Chapter 4 is really long, My editor and I talked about splitting it into two or three chapters. I don't remember why we didn't do this.) Sometimes there's an extended example. If the example isn't interesting, or seems to be going on too long, skip to the next section. My style is to write down absolutely everything I can think of on a topic. Sometimes, that's more than you want to know. Just skip it. If there's a bunch of mathematics that is too advanced for you, skip it, it's probably not important. I put that stuff in because I like mathematics and I find those examples compelling. But I know they're not for everyone. Basically, don't feel like you have to read it in order. If you're reading something later on and you need to know something earlier, I'll tell you. Also the index is pretty good, so if you're reading some page and it says you need to use a foozle, but you skipped the section that explains foozels, the index will tell you where foozles are explained. Also don't worry if it takes you a long time. HOP took me five years to write. I wanted to write a book where people could keep coming back to it and finding new things, like SICP or the Knuth books. Take it slow if you want, or put it down for a month and come back to it. I won't judge you, I'll be flattered. What else can I help you with? 
Interesting, that's the order I wrote it in too. Also usually wrote the first word of every sentence sometime before the last one. Weird. huh?
The problem isn't the design, it's the implementation. 
Thank you for the tip, I will look into it right now!
In addition to the above, I'd add that for debuggability you should pick a human readable format (like Data::Dumper, JSON, YAML or even one of the XML based modules in that list), not e.g. Storable which is a binary format.
Thank you sir for alerting me to this package's existence (e.g. Curses::UI).
You might look into /r/roguelikedev because your game is similar enough (i.e. map-oriented) that you can probably find lots of techniques. Long story short: storing map states for even a simple game can quickly become a lot of data! There are lots of techniques, and if the game gets large you'll probably want to look into them. For now, though, I would follow the above poster's advice and simply serialize it and dump it into a file. As someone wise once said: "The most important part of writing a game is to write a game."
Hy, thabks for the answer, I added the lines of code, now the output is: Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 4. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 5. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 6. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 7. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 8. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 9. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 10. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 11. Global symbol "$output" requires explicit package name at mkt_connect.pl line 12. Global symbol "$telnet" requires explicit package name at mkt_connect.pl line 12. Global symbol "$output" requires explicit package name at mkt_connect.pl line 13. Execution of mkt_connect.pl aborted due to compilation errors.
You must define your vars. my ( $telnet, $output );
Click on the "formatting help" link at the bottom right under the text entry box, and you'll see that indenting text 4 spaces will cause it to be displayed as code. That's common at many systems that accept messages. So you're having trouble with: $output = $telnet-&gt;waitfor('/[mktbk\@mmv] &gt; $/i'); If you look up regular expressions [perlre](https://metacpan.org/pod/distribution/perl/pod/perlre.pod), you'll discover that square brackets denote a character class or a set of characters. /[abc]/ matches an 'a' or a 'b' or a 'c'. So you're trying to match any one of the characters in the string 'mktbk\@mmv', i.e. '\', 'b', 'k', ..... Backslashing the square brackets will probably fix it for you. But I would start by simplifying the search pattern. How about waiting for 'mmv' ? That's jot going to appear anywhere but in the prompt, is it? As a benefit, you bypass the question of whether to escape the '@' zero, one, two or three times. In fact, if you do go with a longer match pattern, I would use wildcards rather than the '@' or the square brackets: '/.mktbk.mmv. &gt;$/i' 99.99% the same precision as an exact match, without any concerns about regex meta-characters. Visually, it focuses attention on the string portion you're trying to match, which may aid comprehension when someone else ( yourself in 6 months) is trying to read the code.
Hy, thanks for the answer. I still get that error, here is the code: use strict; use warnings; use Net::Telnet; my ($telnet, $output); $telnet = new Net::Telnet ( Timeout=&gt;5, Errmode=&gt;'die'); $telnet-&gt;open('192.168.255.100'); $telnet-&gt;waitfor('/login: $/i'); $telnet-&gt;print('mktbk'); $telnet-&gt;waitfor('/password: $/i'); $telnet-&gt;print('password'); $telnet-&gt;waitfor('/.mktbk.mmv. &gt;$/i'); $telnet-&gt;print('/export'); $output = $telnet-&gt;waitfor('/.mktbk.mmv. &gt;$/i'); print $output; The error is: pattern match timed-out at mkt_connect.pl line 11
I did the modifications that you suggested, still getting the same error. The character $ is not a literal character. Here is the code: use strict; use warnings; use Net::Telnet; my ($telnet, $output); my $IP_NUMBER = '192.168.255.100'; my $LOGIN_PATTERN = '/login: $/i'; my $PASSWORD_PATTERN = '/password: $/i'; my $PROMPT_PATTERN = '/.mktbk.mmv. &gt; $/i'; $telnet = new Net::Telnet ( Timeout=&gt;5, Errmode=&gt;'die'); $telnet-&gt;open($IP_NUMBER); $telnet-&gt;waitfor($LOGIN_PATTERN); $telnet-&gt;print('mktbk'); $telnet-&gt;waitfor($PASSWORD_PATTERN); $telnet-&gt;print('password'); $telnet-&gt;waitfor($PROMPT_PATTERN); $telnet-&gt;print('/export'); $output = $telnet-&gt;waitfor($PROMPT_PATTERN); print $output; The error is: pattern match timed-out at mkt_connect.pl line 17
How is many info about RPerl in the web...
Is this something like rpython? https://code.google.com/p/rpython/
I did that the first time, there are more lines, but the prompt is on the last line, I thought only the last line will count because when I match against login there are a couple of lines above it, and the router os version, I don't specifiy there that there's anything else above login. Anyway, the whole sequance of logging in is: [alex@samba scripts]$ telnet 192.168.255.100 Trying 192.168.255.100... Connected to 192.168.255.100. Escape character is '^]'. MikroTik v5.25 Login: mktbk Password: MMM MMM KKK TTTTTTTTTTT KKK MMMM MMMM KKK TTTTTTTTTTT KKK MMM MMMM MMM III KKK KKK RRRRRR OOOOOO TTT III KKK KKK MMM MM MMM III KKKKK RRR RRR OOO OOO TTT III KKKKK MMM MMM III KKK KKK RRRRRR OOO OOO TTT III KKK KKK MMM MMM III KKK KKK RRR RRR OOOOOO TTT III KKK KKK MikroTik RouterOS 5.25 (c) 1999-2013 http://www.mikrotik.com/ [mktbk@MMV] &gt; Thanks
And what happens if you waitfor( '/MMV. &gt;$/') or maybe with a space before the $? 
I finaly did this: my $PROMPT_PATTERN = '/[a-z0-9.\/:\[\]\@\&gt;\-\(\) ]/igm'; and it works, I think, I only get a 1, not all the output of the export command, I guess the 1 means that it executed correctly. How do I get all the output of the export command redirected into a txt file? The code right now is: use strict; use warnings; use Net::Telnet; my ($telnet, $output); my $IP_NUMBER = '192.168.255.100'; my $LOGIN_PATTERN = '/login: $/i'; my $PASSWORD_PATTERN = '/password: $/i'; my $PROMPT_PATTERN = '/[a-z0-9.\/:\[\]\@\&gt;\-\(\) ]/igm'; $telnet = new Net::Telnet ( Timeout=&gt;5, Errmode=&gt;'die'); $telnet-&gt;open($IP_NUMBER); $telnet-&gt;waitfor($LOGIN_PATTERN); $telnet-&gt;print('mktbk'); $telnet-&gt;waitfor($PASSWORD_PATTERN); $telnet-&gt;print('password'); $telnet-&gt;waitfor($PROMPT_PATTERN); $telnet-&gt;print('/export'); $output = $telnet-&gt;waitfor($PROMPT_PATTERN); print $output; And what I get: [alex@samba scripts]$ perl mkt_connect.pl 1[alex@samba scripts]$ Thanks, Alex
I also try with the pattern that you suggested: '/MMV. &gt;$/' and '/MMV. &gt; $/' I get a pattern match error. Thanks
So i just have to figure out where there installed and then go about deleting the directories? Then maybe delete the ~/.cpan directory? The modules to be installed in /usr/lib/perl5/site_perl. If i go into one, then theres a whole bunch of pm files and such. Theres also directories for them in ~/.cpan but those appear to be the modules downloaded from the CPAN like you said. 
This seems to be mostly a negative side effect of using the CPAN client as a privelaged user. ( Like root ) CPAN.pm installing to `/usr/lib/perl5/site_perl` is almost certainly a sure sign that you have contaminated your vendors perl in ways that might not be reversable. ^(because hysterical raisins) Unfortunately, this is the default behavior of CPAN clients, because they expect if you can write to site, that you want to. To "fix" this you may need to nuke that directory and restore it from your vendor packages somehow .... but doing that could also brick your system in the process. This is pretty much why we never recommend using CPAN to install modules to your vendors perl install. You may want to read this: http://shadow.cat/blog/matt-s-trout/but-i-cant-use-cpan/ ( because it covers some elements of installing things as a non-privelaged user ) And this: http://www.cpan.org/modules/INSTALL.html Which covers the basic tools you'll need to be able to *easily* manage your own library sets without having to fight with either system perl, or system perl's module versions. Good luck, and if you need more in depth support, consult `irc.freenode.org #perl` or `irc.perl.org #perl` --- **Footnote:** Actually, you may be very fortunate and have a Linux vendor who was smart enough to put all their stuff in `vendor_perl`, if you have one of those you're in luck and `site_perl` **might** be nukable. I say `might` because some things **may** install outside that location, and nuking things they need ( which might be in `site_`) can cause subsequent breakage. It just all depends. 
&gt; Theres also directories for them in ~/.cpan but those appear to be the modules downloaded from the CPAN like you said. Yeah, those will be `CPAN.pm` staging material which it uses in the process of preparing your modules for installation, not the final place they get deployed to.
1. So this is Arch Linux then? 2. What sorts of errors were you seeing wiht 5.22? 3. If it were me, I'd try this: * backup your current machine, however you do so. * make a VM with a similar Arch install * tar and copy the VM's perl tree to your current machine. * rename the existing perl tree, and untar the new tree. P.S. Your problems sound somewhat Arch-specific, as (against most advice) I've managed to install things into a distro's perl via packages and then fill in the gaps with CPAN, and haven't had more than a hiccup in many years. (RHEL, Centos, Ubuntu etc.)
If you read "Thinking, Fast and Slow" by Daniel Kahneman, there's a perfect explanation as to why so many people got it wrong (myself included): After reading the puzzle, my intuition (system one) told me correctly that there was no solution. I didn't trust my intution, though, so I thought about the problem (system two), lazily, and promptly came to the wrong conclusion (red box). Only if you overcome the natural laziness of system two you do get the correct answer. So: think long enough or not at all.
It's not on autopilot. There are people trying to fix stuff.
If you know Perl, you've probably heard of ActivePerl, ActiveState's very popular distribution of Perl. We're looking for a lead engineer in beautiful Vancouver, BC who can become a key member of the ActivePerl team and help take ActivePerl to the next level. 
Cool, but what does this one mean (7th item under under "A Perl User..."): - Uses .
What exactly do you mean by "behind a proxy"? Are you able to make outbound connections to port 465? Or port 25? Usually when people talk about proxy servers, they mean HTTP proxy servers. To my knowledge, there is no way to send SMTP through an HTTP proxy. If you are talking about an outgoing SMTP proxy, those are usually "transparent" - you shouldn't need (or be able) to tell your mail client about them. As I understand SMTP, the sending mail client can't tell the SMTP server it connects to how to route the mail, although a local SMTP server can be configured to forward mail through another (relaying) server. If you are talking about needing to connect via a SOCKS proxy, you might be able to use [IO::Socket::Socks::Wrapper](https://metacpan.org/pod/IO::Socket::Socks::Wrapper) If your only way of getting to the internet is through an HTTP proxy, you might be able to send mail using GMail's web-interface and [Mail::Webmail::Gmail](http://search.cpan.org/dist/Mail-Webmail-Gmail/lib/Mail/Webmail/Gmail.pm) - I've not used that module, I just found it by googling, but it appears it uses the web-interface, not SMTP.
Aha, thank you! 
&gt; Usually when people talk about proxy servers, they mean HTTP proxy servers. Sorry yes, this is exactly what I mean. We actually have an smtp relay available, but I'd have to go though a bit of rigmarole to send through that server - so mostly to avoid the red tape of submitting a formal request for them to allow connections from my host (it accepts mail from whitelisted IPs only) I figured this was the quicker (read: lazier) route since the alerts are destined only for me anyway. I'm the owner of another box which is whitelisted to send mails through that smtp server, but to make a long story short it doesn't fit my needs to send these mails from that device... Thanks for your suggestion, I'll check it out!
What level are you at if you never learned to appreciate and love the default Perl 5 object system because you jumped on Perl 6 instead... Perl Heretic?
If you do it like this you might as well do your calculations with a standard unix timestamp, ie with time() . Also, a month is not really exactly 1/12th of a year. That's a simplification. For date calculations I prefer something like Date::Manip. 
I was under the impression that you would need "use signatures" or perl6 in order to accomplish that. I'll look into it. 
No. Perl is an interpreter. The code you write is interpreted. There is no translation to C or native instructions. Many of the built-in functions are implemented in C, but that doesn't really have anything to do with the code you write. The fact that your code is first compiled into opcodes is just an implementation detail. It's a common method of implementing an interpreter. It's common to speak about the "compilation phase" of a Perl script, but this just means the portion where the interpreter is parsing your source code and turning it into its internal representation. It does not mean your code is compiled in the way that C is compiled to machine code. It's possible to use XS to write portions of your code directly in C for speed purposes, but usually that's only done in certain limited circumstances because it's a lot more work. 
Thanks! So my source code gets converted to Perl's "internal representation" (some of which leads to the execution of functions which were implemented in C). I guess I was wondering, if the interpreter is written in C, and the built-in functions are written in C, would it be fair to say that the execution is ultimately handled by C code? (Or does some chunk of it remain in Perl-specific byte code or opcode?)
Think of it this way: the Perl interpreter is a C program whose job is to traverse a tree structure, and each node of that tree has an instruction in it which the interpreter follows. The tree is built by parsing your Perl source code -- that's the internal representation. You can think of the Perl interpreter as a virtual machine (which it is) which is executing machine code. Its machine code is the tree structure which is generated by parsing your Perl, rather than the microprocessor instructions that a C compiler would create.
I think you may enjoy reading "The Structure and Interpretation of Computer Programs", it will answer many of your questions and teach you a lot Edit: It's available free online
Strictly speaking "your code" is translated into something else from opcodes, it is translated into actions. Which is to me the only thing that separates a compiler and an interpreter I'm not trying to be pedantic here, but to give OP as much context as possible to get their head around the concept of languages / implementations and compilers / interpreters
rperl is very limited, and does it differently. perlcc (B::C) is the usable compiler, which does compile to C, and then to executables.
I'm not familiar with the Perl interpreter specifically, but most bytecode interpreters work as follows: for every possible opcode, there's a function (written in C, like the rest of the interpreter) which tells the interpreter how to behave when it encounters that opcode. Your program is translated into a collection of opcodes in memory; the interpreter traverses those opcodes, and for each one it hits, it executes the corresponding C function (which may cause it to manipulate memory, do IO, jump to another point in the opcode graph, etc). So yes, the execution is ultimately handled by C code, but your program never exists in the form of native code. Does that make sense? This is not the only way to write a VM - more advanced ones will indeed compile your code to native code "[just in time](https://en.wikipedia.org/wiki/Just-in-time_compilation)" and execute that code. Perl 6's MoarVM does this, for instance, as does LuaJIT, Java's HotSpot VM, and the better class of JavaScript implementations. The Perl 5 interpreter doesn't, though.
Great answer! But then what language is the opcode in?
Woo-hoo! https://mitpress.mit.edu/sicp/ Thanks! This looks really really interesting...
 The interpreter is written in C. C code turns your Perl into instructions the computer can actually use. Perl code also does some of the work. Ever used 'eval'? That's Perl creating more Perl code. But is "execution ultimately handled by C code"? I'm not sure that's the right way to put it. More like, "Perl is an interpreted language, the standard interpreter is written in C". There are versions of Perl that use interpreters written in other languages, but most of us use this C interpreter. This is one case where getting into the details might make things easier to understand. It's cool, but not magical. You can actually write your own interpreter in Perl for any language you can dream up, its not even that hard.
I would use Mojo::IRC which is a well written gold usable module
No, 10% memory savings and 10% startup time improvements with B::C are important to us, and not really useless. They are rather business critical. For performance we have the optimizing compilers, but they are not ready yet.
I translated the old "Bitcoin the Hard Way" article/example (which uses Python) to Perl, with some effort (various implementations of Perl crypto libraries have problems and it took me a while to work that out). I might use it as the basis of a lightning talk at YAPC next year or for the local PerlMongers group or something. Besides drawing on inputs, deciding what the outputs should be (including change and fee), and signing it, there's a lot that has to happen to make a wallet app. I admire the Python folks for actually making apps rather than just dicking around with CPAN libraries, but I've too much other stuff going on tackle this. Thought I'd say "hi" rather than being silent though.
I feel like we've got only half the story here
I started writing wrappers to SAT and SMT solvers some time ago, but haven't published anything. And JD gave a Houston.pm talk about Bitcoin and Perl. We also started reviving the various crypto libraries on CPAN, which were mostly in a horrible state. But there are still only openssl bindings, which is not satisfactory.
Thanks! (Er, where is it in *Programming Perl* ?) Maybe my older edition doesn't have everything that newer editions do -- I looked in the index for optrees, and didn't see a listing (or even a listing for "interpreter").
&gt; I've heard some of the things said about p5p wanting to be private about private interfaces, essentially. That in and of itself shouldn't be controversial. XS is XS because Perl has traditionally not treated private interfaces as if they were private.
https://github.com/rurban/b-generate/commit/73ad197ef38acb87d5dc1e8790295f9548628a00 Looks like #defines are being taken away in particular. From my point of view, that's annoying, but not a show stopper. It also seems like an attempt at a technical solution to a social problem (making people who p5p doesn't like go away). It's contrary to “Perl doesn't have an infatuation with enforced privacy. It would prefer that you stayed out of its living room because you weren't invited, not because it has a shotgun”. The internal APIs were marked internal before. Maybe people complained when they changed, but p5p would be right to say, "well, we warned you". I'd rather see things like Coro moving away from being hacks rather than being pushed further that direction. Autodie was offered official support in core. That puts p5p not just in a maint role but a kind of gatekeeper role, which has the potential to make human relationships problems worse than they are. Ugh.
What would be wrong with just having openssl bindings? Would a pure perl implementation be easier to maintain? 
Did you look at openssl? First have a try and the come back. It's a mess, it's buggy, it has no proper tests. A pure perl of crypto is nonsense. First is is too slow. People are only using openssl because of its speed, not because of its quality. And everybody who cares about quality and security uses something better. Second, who's is going to maintain that? Check the update rates and tickets in openssl, and compare that our openssl bindings. There are only two modules who keep up, IO::Socket::SSL and partially Crypt::SSLeay. Recommended is only IO::Socket::SSL. And now compare that to other openssl bindings Crypt::OpenSSL::* and Net::SSLeay. Some don't need to update that often, because the bad things happen in the openssl shared libs, but still it's a mess. Acceptable TLS libs would be GnuTLS, Mbed TLS, partially NSS, libressl. See https://en.wikipedia.org/wiki/Comparison_of_TLS_implementations Ok back to pure crypto, as in bitcoin. This is not so bad. Our GMP binding is good. The various bitcoin modules are all good. Just for the reverse, breaking crypto, perl has nothing to offer, compared to python.
The defines are not the problem. This is trivial to fix. schmorp could have fixed it also, but he refuses to monkeypatch wrong defines in principle. I do so to keep everything running. Explicitly added guards in core to forbid B::Generate running at run-time are the problem.
Or even sub a(&amp;) { } sub key {} a{key}; Which is equivalent to sub a {} sub key{} a(sub { key() }); Thinking about it, how would removing $ handle my name = "Chas."; my %h = ( name =&gt; 1, ); Is the key "name" or "Chas."? With subroutines, you could always add parentheses to clarify that it was a subroutine call. Would you have to add an optional $? 
I've been very [targeted](https://jobs.perl.org/) with my job hunting but I've had no trouble getting Perl-specific interviews.
I landed a perl job knowing zero perl. Eeek. 
Sorry, I lied, it's not anywhere in Programming Perl. There's a little mention in Advanced Perl Programming, but not as substantial as I remembered either.
I had to do this for a project a while ago and struggled with the best way to do it. I'm not sure if I would've done it the way of the article or not, because I wanted to have different modules load their own data. However, I also didn't have the restriction of not being able to load the entire stream into memory since my files were tiny. In fact, I wanted to load the entire file at once so that my read was one syscall rather that a hundred. This is what I ended up doing: https://github.com/rfdrake/JRobin/blob/master/lib/JRobin/Unpack.pm I'm still not that pleased with the results, but it worked. I think to adapt what the article said into a module it would be something similar. Passing the instance of the Unpack object around to various modules, each uses it's own packstring to tell what to load. the Unpack object would contain the filehandle at the current location rather than the memory buffer at it's current spot.
&gt; You're kidding me. Much of the schmorp debate centered around him adding checks to AnyEvent to make it refuse to work with other modules he didn't like (because of potential technical problems). That's the same thing. Argh. Remember that he added those checks because the modules in question were accessing internals in a way he thought was inappropriate. Rather than provide the necessary hooks he added exit 1 if $INC {...}. Sounds familiar? 
And if it's your thing, MIT OpenCourseware has videos of lectures of the class based on that book. (I took UMN's version of it and it changed my life.)
Indeed, but that'd look funny :) 
Yep, I check that every two days or so! Don't see many UK positions advertised though!
That's a good one, not seen that before, cheers :)
Just had a look and unfortunately not. I know there are functions to work it all out for you, however I need to be able to write the code for myself. I have the co-ordinates of the atoms and the distances, just need to work out the angles.
Look into bioperl there's probably a module in it that parses pdb files. 
Umm, are you saying that you can read the data in from the file ok, and you just need help with the math of it... It sounds like trigonometry is your friend! If this is what you need, then https://www.khanacademy.org/math/trigonometry/basic-trigonometry will be *very* helpful and it's pretty much a guided work-through of how to measure the angle between two points (i.e. by pretending it's a right angled triangle and doing a bit of math). However... I'm not sure, because it you're reading torsion angles... well, I would have guessed you allready know about trig.
I don't think I knew about the gzip layer, where can I learn more about that?
I have read all the other data from the file in, I'm purely trying to write a generic but of code that will calculate the torsion so when I run the programme for lots of files it works it out for me. I thought about basic trig but I have 3 sets of 3D coordinates to take into account and I'm not sure if I can get away with only using two. In my head, if I only use two then I'll only get the angle between those 2 points, if that makes sense.
I think I have already parsed the file, but I'm not sure
C# is a great pick, career-wise, it seems like. The barrier to entry is far lower than Java, where everyone wants many years of experience with enterprise middleware solutions (middleware in Java is an enormous universe unto itself) or other specific frameworks. I meant that the Perl community screwed up by not writing higher quality software. Whether things like Moose and CI contribute to higher quality software is up for debate, but as far as broader programmer perceptions go the debate was settled a long time ago on CI and OO (picking some examples). Personally, I think the broader Perl community failed both in actual code quality (readable, sane code) and perception (doing the things generally expected and associated with code quality). I didn't mean to say that you personally failed to deliver quality. As far as Moose goes, the style has some fans from other languages, but Java made a decision early on to do interface based inheritance, and Moose is basically like lol inheritance wot let's just duck type everything with mixins, which Java strongly rejected early on and continues to strongly reject. I'd take a well written code with few deps any day over a misapplication of the latest, trendiest frameworks. It's hard being old enough that you're subjected to raising and falling fashions outside of your control. JS is fixated with event systems, but I've already lived through that multiple times and seen people (thankfully) come around to realizing that, for most use cases, they're utterly terrible. For a while, everyone was trying to write everything in POE. And that's really what it is -- everyone must write everything in this "new" paradigm. Angular.JS and JavaScript MVCs do this. It makes things tedious. In _Design Patterns_, no one was suggesting that programmers all go off and try to solve the MVC problem once and for all, or the singleton problem once and for all, or the state machine problem once and for all. They were just trying to create a language for discussing things that people often do in code. I've had mixed feelings about DBIx::Class too. Even when used well, any class hierarchy you've created to model the problem universe gets hijacked by instead modeling the database representation. Delegation based on class relationship lines takes over composition through inheritance. It becomes the object model unto itself. Sometimes that works well. It's frustrating when people are so sold on a technology (perhaps because they lack experience with other styles, such as 30 years of research and history on OODA) that they aren't capable of critically evaluating things and happy go down rabbit holes into an Alice-in-Wonderland-esque yak shaving adventure. But I digress. Personally, I'm not opposed to abstractions, only inappropriate use of them. Trying to keep abreast of all of the change is hard, too. It's frustrating spending so much time retooling. Sometimes I feel like I spend more time learning things than using things. Angular.JS was an example of that for me. It became extremely popular, and I was asked to learn it for a project, which I did, and now, boom, it's out of fashion. JS is badly fixated on magical things that transmogrify the business logic into other styles. It's like they just discovered event systems, POE style, and now everything has to be expressed in terms of that. That's not the worst thing in the world, but I've been around long enough to know that it's a fashion that they'll soon get over when they realize that it just means breaking up the problem into millions of tiny pieces with more opaque relationships between them than is warranted for what they're actually trying to accomplish. Again, often the wrong abstraction. Yes, PHP is wretched. I think there's value in developing a basic proficiency in things that have made it past flash in the pan point. You don't have to be a Moose god or Catalyst god to be able to do basic stuff. But recruiters are never going to beat down your door unless you spend large amounts of time trying to learn the things that wind up becoming the next big thing. Or Java enterprise frameworks. Professionalism requires both delivering working, maintainable solutions, and doing it using the technologies specified by the shop you're working for or that the client uses in house (or picked for the project). Your existing capabilities and professional opinion just don't matter and that's just how it is. 
This might be a good spot to toot my own horn in this area: https://github.com/wschroeder/git-sync-world I really liked sqitch's workflow approach and that it supported more than one database. I disliked that specific databases were inherently tied to it; for example, last I looked, changes must be written in pure SQL (no help from your local ORM, no help for complicated algorithms for data transformations). gsw separates concerns by implementing only the sqitch workflow, making no judgments about databases, and it leverages git to track the changes rather than storing those in specific tables in the schema. It adds a "verify-rollback" stage to the workflow. gsw lets you coordinate changes between databases and anything else, simultaneously. For example, maybe you want to make some changes on the file system in concert with the database change. The framework is written in perl, but the scripts it executes may be in any language; it relies entirely on a 0 exit code for successes.
Actually, sqitch has lovely support for ORMs or complicated algorithms. All you have to do is point your sqitch engine to software you've written and let *it* decide what to do. For one client, I wrote a custom sqitch driver for MySQL that decides whether to execute raw SQL or pass the arguments off to [pt-online-schema-change](https://www.percona.com/doc/percona-toolkit/2.1/pt-online-schema-change.html). MySQL is broken enough that you often can't throw raw DDL at it without bringing your software down, so this made life much simpler. So instead of this: sqitch config --user engine.pg.client /opt/local/pgsql/bin/psql You do this: sqitch config --user engine.pg.client /path/to/my/client
Thank you for this tip! I should definitely check it out again.
The [dot product](https://en.wikipedia.org/wiki/Dot_product) of two vectors will find the cosine of the angle between them. I have no idea what torsion angles are, but it sounds like you have 3 points (A, B, &amp; C) and you want to find the value of the angle ABC? If so, you could subtract the common point B from A and C so they form vectors starting at the origin. From there you just find the dot product of the two vectors and solve for the angle.
Thank you all for your input. It was more of a vent than anything, so tired of dealing with agencies, but I've got some very useful info out of it. Again , thank you!
Hi fellow bioinformatician! :) If the calculations are not too complex, you can learn the very basics of C to write embedded C functions in Perl code. See the [Inline::C](https://metacpan.org/pod/distribution/Inline-C/lib/Inline/C.pod) module.
Perl can easily be 100 times slower than C. That said, it is highly dependent on your estimated development time vs run time. In scientific programming, most of the situation I encounter is of try and error nature, that either I need some quick results or the algorithm is not set in stone and I need modify every now and then to figure out new ideas or new directions. In these cases, even when the code runs for a couple of hours, I am thinking about the code or testing different ideas, i.e. I am not really bothered by waiting for the code and actually I often appreciate the waiting time when the code is running as it provides me time for reflection. So as a result, I wrote most of my code in Perl. Then there is some tasks that it is obvious that I need write/rewrite into C. Simulations that runs for days/weeks, repeated tasks that I don't appreciate the waiting time, stable but slow algorithms that I can benefit with the speed, etc. In short, when in some situation, the run-time benefit overwhelms developing time, which include thinking, debugging, testing time, then it is silly not to rewrite in C -- unless you do not mind wasting your time in waiting for the CPU, and knowing the CPU is wasting cycles while you are being impatient. By the way, it is not exclusive. Perl is excellent glue language. EDIT: I think your question is trying to find excuses not to learn C. My advice is to learn it. Even if you will never write/read a single line of C, the knowledge is beneficial. In fact, don't stop at C, learn assembly as well -- while you are waiting for your code to finish. 
OK, that makes more sense now, thank you. would you happen to know how to write it out in perl so I have a rough guide to work from?
You can totally write simulations in Perl. I wrote several. This one for example has its guts in a c solver but the setup and execution is in perl https://metacpan.org/pod/Physics::UEMColumn
The computer language shootout can give you an idea of the relative difference ( http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=perl&amp;lang2=gcc ). In the shootout, Perl takes anywhere from 3 to 100 times the time over C (results for C++ are similar, but not identical). Surprisingly, there are tasks where Perl uses less memory than C, but in general I expect a data structure in Perl to take three times as much memory as the same structure in C. Perl's strength is that it encourages different algorithms, data structures and solutions to the same problem, which often means it takes less code to get the job done. I don't know whether those trade offs fit your needs ( http://www.interviews.slashdot.org/story/02/09/06/1343222/larry-wall-on-perl-religion-and , question 2, quoting *Lord of the Rings*): &gt; 'And it is also said,' answered Frodo: 'Go not to the Elves for counsel, for they will say both no and yes.' &gt; 'Is it indeed?' laughed Gildor. 'Elves seldom give unguarded advice, for advice is a dangerous gift, even from the wise to the wise, and all courses may run ill. But what would you? You have not told me all concerning yourself; and how then shall I choose better than you?"
That is an excellent interview.
R gets clunky with big data, or am I missing some libraries? 
What about system calls with C. Say I need to execute a ton of samtools view commands. Would using perl vs C for system calls make any difference?
http://www.gocomics.com/calvinandhobbes/1993/01/25
Cause I am lazy and find comfort in the status quo :). I actually want to learn C, but if I could have done it faster on perl it would have been better for me. On the long run to do it faster but sacrificing performance does not look like a good plan. So learning C it is. TIL the C does not have a native exponential operator, so I am starting! 
&gt; find comfort in the status quo Is that the best approach to scientific discovery? &gt; if I could have done it faster on perl it would have been better for me True; there is certainly merit in "optimizing for developer time", but when most of the work your program will be doing is on a tuned HPC cluster or something, milliseconds of improvement add up over the millions of cycles.
That's probably possible, although I think that will only get the first page of posts. Once you put in logic to increment pages and get all the posts you've got another 10 lines of code. But, the script is about convenience and organisation, naming files, putting them in a directory, creating an index, checking the headers to make sure the MIME type matches the extension and correcting it if not, etc. Letting you set limits. If you don't need all that then by all means. I wrote it to get pics from a blog that had over 350 posts, so I did.
Cool so doing a system call won't matter in C or perl. thanks. The problem is that I tried downloading that lib for perl many times but it won't install on my cluster. 
Wrote this quickly so its not pretty. It assumes you have 3 arrays @A, @B, and @C that have your coordinates. Result is in radians. use Math::Trig qw/acos/; use strict; my ($dot_prod, $A_norm, $C_norm) = (0,0,0); # Shift the vectors so they start from the origin for (0..2){ $A[$_] -= $B[$_]; $C[$_] -= $B[$_]; } # Find dot product &amp; normalize vectors for (0..2){ $dot_prod += $A[$_] * $C[$_]; $A_norm += $A[$_]**2; $C_norm += $C[$_]**2; } ($A_norm, $C_norm) = (sqrt($A_norm), sqrt($C_norm)); my $theta = acos($dot_prod / ($A_norm * $C_norm)); print "$theta\n";
It is modelling, I need to model the likelihood of progeny genotypes with genotyping error integrated in the analysis. There are a few C programs available, but they don't do what I need to do. I can probably re-use part of the code, but I still need to learn C
I do that already. I do a lot of C calls from perl too, samtools, bowtie, RSEM and Trinity for examples. Now I am stuck with lack of a specific tool, so I need to write my own. Hence, my question.
Are you using the samtools 0.1.x API for Perl or system calls? I couldn't get the install to work for me until I realized it doesn't work for samtools 1.x ... And now source forge is down! 
Can you prototype it in perl, then decide from that whether it is fast enough? Modern computers are already so fast, I believe that I/O is generally a bigger bottleneck than CPU cycles. If you have to trade a month or two of training and development time to save a couple of hours of elapsed execution time, you haven't gained anything. On the bright side, C looks almost the same as perl...the nuances aren't the same, but the raw material is very similar...you shouldn't have any trouble learning C if you can handle perl.
Just to clarify, a system call is typically thought of as a call that invokes functionality that is provided by the kernel. In perl the system function also calls into the system, but in this case it's actually the shell, which runs on top of libc, which runs on the kernel (via system calls). Your usage makes complete sense but it took me a second to realize what you meant. Calls to the perl system function aren't actually system calls in the traditional sense. Perl system() calls work by actually doing a fork and an exec of the shell, which then may subsequently fork and exec again while also capturing the output. They're much, much more expensive than an actual system call, which themselves are more expensive than a normal function call (primarily due to the context switch). That's written about clear as mud I think, but it's a little pedantic and I don't think so important. I just wanted to note that there is a difference and it can be confusing to some people when you use that terminology. If you're curious the wikipedia page on system calls gets into this more. If you look at the library that MattEOats provided, specifically this file: http://cpansearch.perl.org/src/LDS/Bio-SamTools-1.41/lib/Bio/DB/Sam.xs you can see that it uses facilities in Perl to call the same C code that the command line variants of samtools use. Using this directly will be more efficient than going through the command line for short lived commands. For long-lived commands, the overhead of fork+exec system function will cease to be significant as long as the output is not significant since you'd have to reparse that output as opposed to retrieving it as some native data structure. If you use perl and you use those facilities, the overhead is now converting C structures to perl structures (and vice versa) which is not free, but this is probably not a significant bother. If the data structure to and fro conversion does get heavy, that's where you'd write your own XS functions that avoid that, in which case you'd essentially have no overhead due to perl because you can move the heavy lifting to strategically chosen snippets of C for when it really matters. The TLDR of this is feel free to use perl. Use the SamTools package from CPAN and sequester conceptual freestanding chunks of functionality into separate functions. Profile the program and any functions that are prohibitively expensive can have the expensive parts cut out and rewritten in C without the rest of your program being any the wiser. Iterative optimization like this can be nice because you don't fix anything needlessly.
Wtf? Assembly? Are you serious ?
It will if you point it at a local install of the sam libraries which is annoying but not too hard to do. The following should work assuming you have access to cpanm if you don't its worth just installing your own perl into your home with perlbrew. cd $HOME &amp;&amp; mkdir .deps &amp;&amp; cd .deps &amp;&amp; wget http://kent.dl.sourceforge.net/project/samtools/samtools/0.1.18/samtools-0.1.18.tar.bz2 \ &amp;&amp; tar jxf samtools-0.1.18.tar.bz2 \ &amp;&amp; cd samtools-0.1.18 \ &amp;&amp; CFLAGS='-g -Wall -O2 -fPIC' make -e lib \ &amp;&amp; SAMTOOLS=$HOME/.deps/samtools-0.1.18 cpanm Bio::DB::Sam@1.41 The version of samtools is important. The latest version will ***not*** work with the latest version of the Perl bindings. The API changed massively with the rearrangement of htslib.
C is faster to run and slower to write. Perl is quicker to write a slower to run. Depending on how soon you need the results perhaps it does make sense use Perl over C and sometimes it doesn't but yeah you should consider development time as well as execution time especially when collecting the results is a one-time activity.
I didn't even know blogs.perl.org was a thing, but, as someone who writes and shares a lot of Perl code, I might mirror my Perl code/articles someplace like that. 
Not to write applications, but to understand what other languages are doing under the surface. It's very interesting, and the level of assembly knowledge required to get to that point is fairly elementary. Is one week of sparse studying worth it to have a richer understanding of every other part of computer science?
Ahhhh. Yes. When you put it that way, that makes perfect sense. I'm sure it is very interesting because you're seeing it at such an elemental level
(FWIW, I tried to comment on your blog itself but it wouldn't let me.) Please don't delete your modules from the CPAN. A couple of months is not enough time to know if someone is dependent on them! Just keeping them on CPAN is no work to you, but deleting them can cause harm. You can mark them as "up for adoption" by setting some permissions in PAUSE: http://neilb.org/2013/08/07/adoptme.html That way, anyone who is still using the modules and wishes to keep them maintained can adopt them.
Will do
You're right, of course. Removing them from CPAN would be a bad idea. I think that what I'll do it release new versions that clearly mark them as unmaintained, but then just leave them there. I've already marked the mas ADOPTME. What problems did you have commenting on my blog? I'd like to fix that error if possible.
I was a little disappointed this didn't use actions and grammars to produce the slang :'( So I rolled my own as a full HQ9+ defacto standards compliant REPL &gt;;3 https://gist.github.com/MattOates/1b12a5f3ae46bce03c60
Old adage: You can write faster programs in C, but you can write programs faster in Perl. And it can be a couple orders of magnitude for both. Most here will say, correctly, that it is better to prototype in Perl, then kick parts out to C when, if, and specifically where performance is an issue. Sometimes slow down is due to language performance, but often it's an inefficient algorithm or lag in the network or I/O. 1) Make it work. 2) Make it right. 3) Make it fast. Keep in mind: Your time is generally more expensive than computer time. Throwing better hardware at the problem is almost always much less expensive than throwing more of your time at it. Also, determine what counts as "fast enough". A C version may run in 0.1 sec while the Perl version runs in 1 sec. Does it matter? 
I was just looking for Perl 5 support in IntelliJ a few days ago but my search netted nothing but people asking for one :I
Well, most of the links google gives me, leads to Camelcade somehow. But i've got an idea, will adjust plugin title in JB repository a bit for better search results
Why is C faster than Perl?
Oh get your knickers untwisted. My point was that, given the scale you're talking about, programming language runtime performance is not a bounding factor. 
Yes, smartmatch and given/when are still marked experimental. The current version of smartmatch is flawed enough that once you do what needs to be done to make it behave *predictably* in all cases, you've added so much code that you might as well just use functions to do the matching instead. If a better implementation comes along, the experimental status gives us the possibility of switching to it — but it's entirely likely that there will never be a satisfactory smartmatch in Perl 5. And a switch-like construct in a dynamic language isn't really useful without something like smart-matching. You're welcome to use them as they are, if you think you understand the issues and you're okay with the off chance that your code might break on some future Perl version. I wouldn't recommend it for CPAN, but if it's your own code, do whatever you like.
Yeah, I could easily change my mind and agree with you. I feel like a lot of other people wouldn't be happy with it though :)
I have used smart-matching in Perl 5.14 it seems to work as it should, i don't find it flawed at all. It's indeed a very useful tool which shortens your code considerably. 
In terms of getting useful things done now in modern Perl, I would probably skip that and read up on Moose instead. It might be useful to read later to understand what's going on under the hood. 
Having read the docs, I get the impression that `given`/`when` has indeed some issues/caveats related to topicalization, making it hard to predict what it does (`perldoc perlsyn`, section *Switch Statements*). **But** - The smartmatch operator per se (`~~`, `perldoc perlop`, section *Smartmatch Operator*) is very well documented and there are no caveats mentioned. So is it safe to say: use of smartmatch is OK, but only if you use it outside `given`/`when` or if you topicalize with `foreach` (one-pass loop)?
Depends on what you think is ok. My problem with smartmatch is, that it's really friggin hard to know what it's supposed to do, because it does so many things at once. Quick, without looking at the docs, what do these do: - +{} ~~ sub { 0 } - 0 ~~ "0 but true" - "value" ~~ $some_ref_passed_to_sub; Imagine you encounter these in production code and have to judge wether they are correct or buggy.
http://metacpan.org/pod/perlootut#PERL-OO-SYSTEMS http://metacpan.org/pod/Moo http://metacpan.org/pod/Moose
OK, you got me on the 1st and partly on the 3rd item (I didn't even grok what `+{}` could mean - disambiguating plus on anon empty hashref?). With the 3rd I was unsure what happens if you pass a hashref - does it match keys or values or both? I see your point, though. One of the hardest things about understanding/debugging foreign code is to guess the *intentions* of the original coder. Edit: spelling
I have a persistent error in one of my programs and I've traced it back to a Moose module (which I've never used, but is used by a module that I do use). "Internal error at /usr/local/lib/perl/5.14.2/Class/MOP/Method/Wrapped.pm line 158" and "Over capacity at /usr/local/lib/perl/5.14.2/Class/MOP/Method/Wrapped.pm line 158" I have no idea what either of these things mean, but other errors have appeared at line 158, which makes me think it's caused by a failed HTTP request earlier in the program. I'm wary of using modules to handle basic programming tasks in the first place, so that hasn't been great for reinforcing biases. Ultimately I can't wait for Perl 6 and its reportedly more modern OO. I plan to start using it on zero day. (I hope it has a sleek way to update itself to get through the first few months of contant bugfixes/updates.)
I think the `for { given {} }` is rather double, but I'm not entirely sure.
This is a good starting point: http://modernperlbooks.com/books/modern_perl/chapter_07.html More about that here: http://modernperlbooks.com/mt/2011/03/why-modern-perl-teaches-oo-with-moose.html 
Maybe because I don't have a hammer in my toolbox I don't see any nails, but I don't use given/when that often (or long strings of if/elsif). I'm guessing I short circuit lots of my if's with return and then only do if/elsif/else where I really feel that I need it. One case where I would say I used to use switch in C was finite state machines. This would probably be handled by dispatch tables now in perl, you might even do that in C depending on the complexity of the system. That isn't to say that there haven't been times I haven't used it or wanted to use it though. Do you find yourself writing lots of things that use those constructs often? If so maybe I'm just doing it wrong, or writing different types of programs than other people.
Oh... I was kidding...
Yes. For what it's worth, given the code's assumptions, it could have just been: for @*ARGS.words { when "h" { say "Hello, world!" } when "q" { say @*ARGS } when "9" { nine } when "+" { $accumulator++ } }
I'm guessing you're doing some kind of Twitter automation? Anyhow, without actually seeing the code it's hard to draw too many conclusions, but I am hesitant about blaming this on Moose itself.
Have you looked at HackaMol? See [HackaMol::Angle](https://metacpan.org/pod/HackaMol::Angle) and the [angle_rad](https://metacpan.org/source/DEMIAN/HackaMol-0.032/lib/HackaMol/Roles/PhysVecMVRRole.pm#L194) function.
Well the construct is problematic because of the issues with ~~ which given when defaults to. And yes I find when possible refactoring to use returns as a short circuit to be even better. But as a consultant I spend a lot of my day up to my elbows in code someone needed to hire a professional to look at. Often times a long if/elsif/else was put there by the last guy and I need a way to make it more readable for the next guy. About 20-30% of the time given/when would be perfect for making the code intent clear and intelligible.
Most of your coworkers would just be pissed it's no Go.
It's still an important, useful book. Perl 5's native OO (P5OO) has a certain elegance and is worth knowing. Perl can do OO without Moose or Moo. You can use it to define classes within your main script file. Note that there's no true privacy for members in Perl's native OO. You decide whether that is really important to what you are implementing. I prefer P5OO to the bigger module systems. P5OO is unlike other OO idioms (C++, Java), though. P5OO receives abuse for being different. But it's especially good to know when you are writing a module. Even for trivial Perl code, I usually include several classes in the same file as my sub main {}. Here's a short example (will try to get the formatting right): #! /usr/bin/perl use strict; use warnings; package dataOjb { sub new { my $class = shift; my ( $type, $value ) = @_; my $self = bless { type =&gt; $type, value =&gt; $value, }, $class; return $self; } sub setType { my ($this, $newtype)=@_; $this-&gt;{type}=$newtype; } sub showData { my $this=shift; print "T=". $this-&gt;{type} ." , V=". $this-&gt;{value} ."\n"; } }; sub main { my $ob = dataObj-&gt;new( "int", 250 ); #more non-trivial code! }
The given/when topicalization issue was fixed in [5.18](https://metacpan.org/pod/distribution/perl/pod/perl5180delta.pod#given-now-aliases-the-global-_).
That "Over capacity" is a very common response from Twitter's API, and I think it's a custom message that they have chosen. I don't know if I've ever seen it anywhere else. It might help you to track it down to know that you are getting that along with an HTTP status 503 and their internal error code is 130. https://dev.twitter.com/overview/api/response-codes Is it a CPAN module that you're using? If so, which one? Maybe a bug report filed there with the additional information will get someone to actually patch it, as it sounds like the underlying issue is probably easy to fix and is probably affecting every other user of the module on a sporadic basis.
&gt; I have a persistent error in one of my programs and I've traced it back to a Moose module (which I've never used, but is used by a module that I do use). &gt; &gt; "Internal error at /usr/local/lib/perl/5.14.2/Class/MOP/Method/Wrapped.pm line 158" &gt; &gt; and "Over capacity at /usr/local/lib/perl/5.14.2/Class/MOP/Method/Wrapped.pm line 158" &gt; &gt; Being able to see the full stack trace would help here. It's not actually the final line that's relevant -- the real error lies a bit farther up the stack.
Carp::Always will force a stack trace: http://search.cpan.org/~ferreira/Carp-Always/lib/Carp/Always.pm 
Jack126Guy is right, but also you probably are not defining your arrays properly. @var = { .... } defines an anonymous HASH. This means that @var the array, contains just one element, @arr[0] .. which is this HASH. The following will describe how you access the elements inside the {}: @var = { "alice", "bob" , "carol", "dave" }; for $i (keys %{ @var[0] } ) { print "key=$i, val=${ @var[0] }{$i} \n"; } will produce: key=alice, val=bob key=carol, val=dave The way to define arrays is @array = ( "alice", "bob", "carol" ) ; # populate arrays with (), which is a list @brray = qw/ alice bob carol /; # qw shorthand for a list $crrayref = [ "alice', "bob", "carol" ] ; # [] is an anon ARRAY, so your variable is like a pointer or ref and refer to them as follows: @array[0] # alice @brray[1] # bob $crrayref-&gt;[2] # carol 
In fact, any repeating values in the first array break the function. (1,1,2,3,6) and (2,4,5) returns (1,1,3,6,4,5) 
This looks like an issue specific to OTRS, not generic Perl. You might have better luck asking on their mailing list or forum.
Don't you just want to concatenate the variable UserFirstName with "@company.com"?
I am not really liking the format and/or syntax of your object declaration.
Because Perl 5.6.1 is 38 stable releases and 14 years out of date. Because releasing new software for people who haven't updated Perl in 14 years and 38 stable releases seems a little silly. Because expecting volunteers to support 38 stable releases of Perl going back 14 years is a bit much. ~~Because mst's paying customers are paying him to support their 14 year old, 38 stable releases behind versions of Perl, not the volunteers for the rest of the Perl community.~~ Because why bother contributing to Perl--new features, bug fixes, optimizations, improvements, better modules--if you can't use them on CPAN code for at least 15 years? Because not even p5p supports Perl 5.6 anymore. *Edit:* I've struck through a comment; the specific details are completely unsupported by the article. I apologize, mst, for characterizing your position very unfairly.
The per5-porters group officially refuses to support anything below 5.18 (and this is a moving target, which will become 5.20 next year). Are you saying the rest of the Perl ecosystem is under semi-obligation to adopt the same "3 years and you are out" cycle?
@joelberger https://twitter.com/szbalint/status/624202396575600640 I had to link to the internet archive as reddit auto-spamcans tumblr
&gt; I can only conclude you didn't read the article. That's where I stopped reading this post. There's no need for you to be insulting just because someone disagrees with you.
&gt; Are you saying the rest of the Perl ecosystem is under semi-obligation to adopt the same "3 years and you are out" cycle? I'm saying that deviating from that cycle isn't free and it isn't "no extra work".
Please clarify your point. "An effort isn't free" is an obvious statement and was never a part of this argument. 
Then why assert things that are directly contradicted by words right in the article? The only conclusion is that you didn't read it, or didn't understand it, or (more maliciously) preferred to believe something else.
Good point. The article linking to Miyagawa's Twitter post followed later by "when I said on twitter that maintaining compatibility with perl 5.6 is wrong" led me to that conclusion.
Remove the insult and the implied threat of doxxing and I'll reapprove the post.
"Be civil or be banned." No threats, please. Consider this your only warning.
ribasushi is right that it's not me :)
If you actually read the article, you'll find that this paragraph - &gt; Now, the usual response to this is "but now I have to care about 5.6 compatibility and I don't want to", which would be a reasonable response if true. But it turns out in practice that isn't actually true. and the ones following - already explain why this isn't a problem.
&gt; this isn't a problem. If you have specific, concrete suggestions for how to coalesce all of the costs of verification, validation, coordination, and ongoing maintenance into "it only takes me two minutes, and that's effectively free", I'm interested. It certainly wasn't in your article any of the four times I read it.
&gt; Let's talk about maintenance again, briefly, because maintenance is so very expensive. How much do I need to understand about what works and doesn't work in all of the supported versions of Perl? Some versions have bugs that are fixed in bugfixes and some versions have bugs that are never fixed. Sure, the article suggests that it's okay not to support specific versions if they can't be supported, but how much time do I have to spend explaining these subtleties to people who want support for older versions? That's not free? None. As an author, I would expect that the patch submitter should be doing all the work to support a configuration that I don't care about. FWIW, it's exactly the same for me for MSWin32. I won't deliberately put in code that *excludes* MSWin32, but I occasionally do things that won't work there, and I count on people who care to feed me patches and test them, because I don't have a windows box of my own to test on.
My apologies for misreading the article and the subsequent discussion then. You do you, man. 
&gt; I'm just making clear that "but it would be a vast amount of work for me" is, in practice, not necessarily the case, and therefore not a particularly good justification for not trying at all. I understand the argument that you've not encountered long-term maintenance costs. I'm not comfortable dismissing them entirely because you haven't personally encountered them. Maintaining SSL bindings and providing reasonable security, for example, is a much different question from maintaining cpanminus or Moo, even with Devel::PPPort to help.
&gt; I understand the argument that you've not encountered long-term maintenance costs. I'm not comfortable dismissing them entirely because you haven't personally encountered them. Your arguments have all been phrased of the form "these costs are guaranteed to exist and therefore I disagree" - or at least, statements like &gt; I think you're ignoring a lot of work that isn't free at all. certainly feel to me to contain an implicit assumption that the costs will exist, and at the high rate you expect. I don't want to dismiss the possibility of them at all, I just also don't want to dismiss the possibility of them not being a problem in practice. Edit: Also, I don't think I'd try it at all for SSL bindings, because that would likely involve hairy C level compatibility, which goes well beyond the "make it trivial for me" situation. I feel like introducing SSL only makes sense if I was taking a much more extreme position than I actually am.
What kind of statistics is this? Perhaps GSL can help. I know it has been said several times, but looking into PDL might help. It's very fast for numerical computations since it is written in C and Fortran. Is this modelling amenable to working with vector operations? I would still recommend learning C since you can use it quite easily using Inline::C which lets you write a small bit of C and immediately use it from Perl. PDL also lets you do this and knowing C can help with that as well.
... to do it.
DY?
Yeah, the article uses TIMTOWDY though, twice. If it was one time I would think it's a typo, but two seems like it's intentional. Is this a sort of joke, like there's more than one way to do (spell) it?
So true about the lack of documentation thing. But no mention of perlmonks.org? It's really good one well-known community site where you can always find smart people who are going to insist on you doing it the right way.
5.6 is still "a thing"? Support 5.6 seems pretty insane in 2015.
5.6 is old but I heard that cPanel uses it because it's very performant. 
I learned Perl around when 5.8 is coming out and got the 3rd edition of "programming perl" as reference. That book is still the only reference I am using today. I never felt I was missing anything. In fact, I never touched chapter 13 and 14, so I believe I may be fine to go back a few versions. 
It is a language, not just an application. Stable and capable is an attribute.
&gt; (and unlike, say, most pydoc pages, Perl module docs are usually actually helpful) Really? I think you got lost in the moment... I decided to look at an Rosetta Code example at random: http://rosettacode.org/wiki/Web_scraping Then do a google for the name of the URL opener library prefixed with the name of the language and compare the resultant documentation: * http://search.cpan.org/~ether/libwww-perl-6.13/lib/LWP/Simple.pm * https://docs.python.org/2/library/urllib.html I think they are both helpful. Perl talks about possible issues with imported head, Python mentions the difference in Python3. Your throw-away comment should be thrown away.
I'm not sure your random selection of one page of documentation has any more credibility than op's statement.
I'm guessing Redhat is to blame.
Those other attributes are not 5.6 incompatible, are they?
No, we stayed on it because perlcc didn't work with anything newer than perl 5.6.2. Anyway we moved our non-compiled code to 5.14 2 years ago. And one year ago, we moved the compiled code to 5.14. We are currently evaluating either 5.20 or 5.22.
&gt; I note that none of these are any reason to downvote the article. Agreed; I merely pointed them out to do exactly as you suggest--start a discussion.
Starman, starlet, corona, tatsumaki, plagger, twiggy... Not to mention POE and Perlbal which predate ruby's popularity in the west.
Are you still as strong asupporter of his statement I copied? If so, why? -- Oh wait, r/perl! I forget my audience when I post from the front page.
Will mostly end up with 1000 comments saying: "Lol PERL sucks!!!!"
https://www.reddit.com/r/programming/comments/3emifx/things_your_language_should_steal_from_perl/
ribasushi is correct. In fact, by default Rakudo installs to a local directory under the source tree, so it doesn't clobber anything. Once you install it, add it to your $PATH, and start your script with `#!/usr/bin/env perl6`. And yes, now is a good time to start playing with it. If you need any help, the fastest way to get some is the [#perl6 IRC channel on freenode](http://perl6.org/community/irc)
perlgeek is correct that ribasushi is correct.
The only danger you have with trying out Perl 6 is that you'll be unhappy with other languages you use.
Confirmed.
POE isn't *awful*; at least it has a plausible initialism. I always thought Perlbal was short for "Perl load balancer".
No. 
https://twitter.com/ribasushi/status/625339764275867648
POE isn't bad, and for the public record I should point out that I am the guy behind the illicit love child that is MooseX::POE. Mostly though I just wanted to point out that while we have a tradition of module names like HTTP::Tiny we also have a tradition of module names like Hijk. Something something motes vs beams.
Funny story, I actually spelled it as TIMTOWTDI originally and then thought "hang on, TIMTOWTDI sounds way too complex, it must be closer to an acronym version of Tim Toady that a well known person uses on irc" and thus I changed it. (I'm the author of the linked post, and finally had a reason to create a reddit account.)
Documented and tested on 5.10.1 or newer. I have one box with 5.8 for the occasional testing. No 5.6.
Hello, I am Will the Chill, creator of the RPerl optimizing compiler. I apologize for the current lack of user documentation, unfortunately I am still too busy working on the source code to focus on docs. Install notes can be found here: https://github.com/wbraswell/rperl/blob/master/INSTALL Help for the RPerl command can be found here: https://metacpan.org/pod/distribution/RPerl/script/rperl I've started implementing Learning RPerl exercises here: https://github.com/wbraswell/rperl/tree/master/lib/RPerl/Learning If anyone experiences technical difficulties, please find us either on Facebook or irc.perl.org in the #perl11 channel: https://www.facebook.com/rperlcompiler I am normally not a reddit user, but I will try to check back here and answer any questions. Thanks!
Brother from another mother.
Thanks for the Learning RPerl link, I didn't know about that one. I see you need to disable a lot of Critics in even trivial cases. I usually don't use perlcritic nor perltidy in my code. Is it possible to disable the perlcritic check with an rperl flag for fiddling around?
Rakudo is just to compile Perl6, right? As in, the Perl 6 executable is a compiled C program? The docs say this: "The primary Perl 6 compiler is called Rakudo, which runs on the **JVM**". I've noticed a slight delay when running perl6 programs, compared to perl5, which made me wonder if there wasn't some other step happening. Surely the Perl6 interpreter can't be touching Java, can it?
Rakudo has two backends: MoarVM, a separate VM written in C, and the JVM. Depending on how you built it, it could be either of those backends. If your startup times are around 0.1 or 0.2s, it's likely the MoarVM backend; if it's 1 or 2s, it's likely the JVM backend.
I agree it makes no sense. Some of it quotes PBP and some of it seems to be specific to RPerl. And there's all that whimsy and invented vocabulary again. What's "magic"? What do "high" and "low" signify? If RPerl Just Worked: * it would take a given script and make it run faster * if it couldn't (or performance could be improved), it would explain why, with references Not all this whackiness. You get to be a lovable eccentric *after* you've made a solid contribution to the community, not as a step along the way. 
So you still haven't been able to install it? Even with his direct help? 
In case this helps, here's an article explaining why some people start down the path of "if it's all just C really, why not just use C in the first place?" and then realise their mistake: http://www.perl.com/pub/2001/06/27/ctoperl.html
&gt; Thou shalt not &gt;[…] &gt; 45\. Use Regular Expressions, Smart Match, q Quoting Mechanisms, Unicode/UTF-8, Or String Interpolation What do I use perl for then? I get the smart match part, but no regex, quoting Mechanisms and no unicode support? Welcome to the future. Does that mean that `use List::Utils qw(shuffle reduce);` isn't supported?
You also can't use things like `$_` and `$@`, and you can't use auto-vivification, or even Taint mode. And you can't "Use Indirect Access To $ Scalar Variables Via References" though I'm not sure what that means exactly.
&gt; 1) Can I use most CPAN modules? You probably can't use most CPAN modules, assuming the "Shall Not" list means "won't work". Here are some examples of things that will rule out most of the useful bits of CPAN: * local * our * auto-vivification * punctuation variables * defined() on a variable * runtime require()
"Magic" is actually a term used in Perl development, mainly being shorthand for "something happens behind the scenes." I'm not sure if the RPerl project uses the term the same way, though.
I installed successfully in kubuntu, but I had problems in slackware-current. I was specially sleepy that day and to be honest, I made stupid mistakes following the instructions. Shame on me.
I think I solved it actually :D I wasn't aware you had to add the .pl file extension to the file within the project... I thought it assumed the extension when you selected to create a perl file :) Working good now!
No. Might it not be easier to ping Jan directly ?
I'm aware of that usage, but here "magic" is taken for granted and features are divided into "high" and "low". That seems unique to RPerl. And I still can't remember which is the "good" type, high or low, even after obsessing over this the last couple of days. Or are those not two types of magic, just a grading on how *much* magic a construct uses, as in "high-fat" foods?
There is always scope for improvement; I definitely support any work you want to do in that area. I do love Perl and Net::SNMP. That and [RRDTool](http://oss.oetiker.ch/rrdtool/) has allowed me to write relatively simple scripts over the years for exposing metrics in many different environments for different purposes. Of course nowadays you have Zabbix, Cacti, Munin, Cricket, and a whole host more applications that do most of this work for you.
There is a good reason
Depends on what you mean by "in production". I maintain [cpXXXan](http://cpxxxan.barnyard.co.uk/), partly as a service to users of older perls, but also as a service to authors who don't have to worry about users moaning about how the latest release of Some::Module doesn't work on their old perls and that this then breaks everything that depends on it. Part of that is [cp5.6.2an](http://cp5.6.2an.barnyard.co.uk). To keep cp5.6.2an up to date I need to test all new releases using perl 5.6.2, so in a sense my CPAN-testing machine is an example of perl 5.6.2 being used in production. I have no choice but to use 5.6.2 to generate the data I need. Of course, the very nature of what I'm using it for means that I care exactly this much --&gt;&lt;-- if stuff doesn't support 5.6.2.
In perl, you pretty much already know the type of the variable by the variable's name, unless it's a reference: $test is a scalar (which might be a reference), @test is an array, %test is a hash, etc. So, ref (@a) wouldn't make much sense. The ref() function is there to disambiguate the $a syntax. So, I think the typical approach is one of the options in 'man perldoc': if (ref($r) eq "HASH") { print "r is a reference to a hash.\n"; } or unless (ref($r)) { print "r is not a reference at all.\n"; } 
Not really. You should be able to just know what type of data you're passing around. I'd argue not knowing the fundamental type of object you're dealing with in any language is a strange situation. Perl does have some interesting type handling bits though, like 'wantarray', which you can use to see if a calling function expects an array return or not. So many things depend on the programmer knowing if they are dealing with a ref or actual data, and it's up to you to know how your libraries work. It would be weird to confuse an int and a character string in C.
Ah, that makes sense, and thanks for pointing out the mistake there. So, in this sense, if I have a function that could potentially return a hash, array, or string, and I: my $result = function(); there would essentially be no way to tell what type of reference got stored in there, correct?
Every function returns a list in list context, and a scalar in scalar context. If you do `my $result = function();` then `function()` will always return a scalar. If it returned a reference, you can find out what kind it was using `ref` (although usually in real-world code there's no need to check). If the function ended in something like `return @array;` then `$result` would get the number of items in `@array` (because that's what an array does in scalar context). That's probably not what you wanted. If the function ended in something like `return ($this, $that);` then `$result` would get `$that`, because that's what the comma operator does in scalar context. Again, probably not what you wanted. Basically, don't do that.
The thing is, you can not really return an array or a hash. All you can return is a list of arguments. When you see code like this: sub gimme_hash { return %hash; } my %hash2 = gimme_hash(); what the sub really returns is a list of arguments. You can as well assign those to an array or even to a scalar (which will, by design, not blow up, but do something that makes sense on paper, but confuses next to everyone, so don't do that). There is a keyword to make your sub aware of wether a single value was requested or a list. This is called context. The keyword however (wantarray) is a major can of worms and I would advise you not to use it if there's any other way to achieve what you need to do. In the case you mentioned... just return refs, and write a sane API that either knows what it's returning beforehand, or will return a ref to just about anything, and that it's the job of the calling code to figure out what.
&gt; I am writing client code that interacts with an API. The API could return a hash, array, or string, so I wanted to use ref to differentiate. That's not how Perl works. To quote [`perlsub`](http://perldoc.perl.org/perlsub.html): &gt; The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you'd like. There is no way to tell whether a function returned a hash or an array, because that information is gone. The only way to maintain it is to return a hashref or arrayref, and in that case `ref()` can tell you what kind it is. 
I will update and check tomorrow and come back if I still see the issue I'm thinking of. Does it handle the AUTOLOAD method btw?
It is a REST API, and the code needs to grab a couple of different fields from the response and process them all in (almost the same way). However, the data inside the response elements could be a string, array, or hash. So, there are plenty of ways to work around this, but using `ref()` to identify the data type seemed like the most flexible option. By the time I posted this question, it was mainly just a matter of curiosity. I must say that I am quite impressed by all of the knowledge in this sub-reddit. I generally have a hard time finding reasonable answers to my "weirder" perl questions. I hope that puts things in context, thanks again!
If this is true I have to redact my statement. In my memory I had to fix numerous ETHER and RJBS modules to remove wrong prereq numbers to get it work with 5.6. Maybe I'm wrong. That was 3 years ago. Found it: http://blogs.perl.org/users/rurban/2012/01/how-to-install-into-562.html Indeed, you are not on this list. I wonder why I put you mentally in my aggressive anti 5.6 list then. Maybe because of your install blurp: "Congratulations, your toolchain understands 'configure_requires'! If you're seeing this warning, your toolchain is really, really old* and you'll almost certainly have problems installing CPAN modules from this century. But never fear, dear user, for we have the technology to fix this!" on toolchain versions which were better than the required newer versions. So it was not the strictness, just annoying.
Have you checked DateTime?
Thats not all about `ref`. I'm still surprised noone directed you to [the docs] yet. If you get an object (which is a reference bound to a package in perl), you can find out the package name which the object is bound to: my $a = {}; my $b = bless $a, 'SomeType'; say ref $b; # prints SomeType. So basically, `ref` does two things: Give you the type of the reference if you have a plain reference, and the package name, if you have an object (which is an reference with a package name glued to it). You can access the two functionalities split up via the following functions from the [`Scalar::Util`](http://perldoc.perl.org/Scalar/Util.html) package: `blessed` returns the package name of an blessed reference, `undef` otherwise `reftype` returns the reference type of any reference, even blessed ones. [the docs]:http://perldoc.perl.org/functions/ref.html
&gt; Maybe because of your install blurp: &gt; "Congratulations, your toolchain understands 'configure_requires'! ... Yeah, you'll get that if you run Makefile.PL by hand in distributions that also provide a Build.PL, because cpan clients are supposed to be preferring Build.PL now.
I know what modules to use, I just don't have the time this week to sit down and write out examples for his questions.
 print "'$_'\n" for @$x; I learned a new syntax today. That happens pretty much every time I read someone else's Perl code, though. It works as `say for @a;` too. Edit: Does anyone know of a really good guide to $_? I've been using Perl more and more for quick and dirty tasks (I traditionally used it for more complicated scripts) and want to get to know it better.
In this case, I wanted to enclose the value of `$_` within `'` and `'` to show that there was no extraneous whitespace. I used `print` because once I had forgotten to add `use feature 'say'` at the top of the file, ti was easier to type that ;-) It is equivalent to `say "'$_'" for @$x`.
So you are advocating the abandoned and broken experiment of Build.PL over Makefile.PL? In all your modules? As banner? MB is dead, get over it. Anybody who has prefer_installer MB in her cpan config has to deal with this consequences by herself. It's not only slow, it also just doesn't work. Declarative configuration fine, but it should provide a valid alternative. EUMM always worked, and will hopefully work longer, as long as people like you will not get comaint. "Supposed to prefer MB" is ridiculous. Infect your own community with this nonsense, please, but not everyone else. $ cpan &gt; o conf prefer_installer EUMM &gt; o conf commit &gt; exit 
And this is why we use Unicode. 
Fauxgrant?
It's 0.1 to 0.2, still noticeable compared to regular Perl. Is that likely to improve to be more in line with the Perl 5 interpreter?
As long as you were capable of staying civil and not presuming malice with every breath, I was willing to converse with you. But I will not respond to your verbal diarrhea.
&gt; EUMM always worked, and will hopefully work longer, as long as people like you will not get comaint. From http://www.cpan.org/modules/06perms.txt: ExtUtils::MakeMaker,ANDK,c ExtUtils::MakeMaker,BINGOS,m ExtUtils::MakeMaker,CHORNY,c ExtUtils::MakeMaker,ETHER,c ExtUtils::MakeMaker,MMML,c ExtUtils::MakeMaker,MSCHWERN,c ExtUtils::MakeMaker,MSTROUT,c HTH, HAND. 
Nóirín chose "they/them" as preferred pronouns, so it's a sign of respect for their wishes.
Regardless of the name, this looks like an interesting project. I've only started to use vagrant to get freeBSD snapshots: https://atlas.hashicorp.com/freebsd/ thanks for writing it.
Why don't you generate full SQL queries for all your data, save those into file and feed SQL Server with it? Let the database handle it the best it can. That way you skip all this read-data/prepare-sql/execute-sql loop. You just have to make sure that you generate valid SQL. 
This is an empty database on a server, I created it for the sole purpose of testing this so I have ruled the DB out. Also the DB and files are both local.