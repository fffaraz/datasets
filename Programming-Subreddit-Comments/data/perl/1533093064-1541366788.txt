As u/6timo says and I show in my top level comment, just put a `FatRat` in. As u/zoffix notes, and u/cluelessbilly perhaps demonstrates (I can't tell; their code makes my eyes bleed!), if you mix in any `Num` values, it'll be for nought -- so don't do that.
Much apologies, I don't know what I am doing, added that FatRat (never heard of it until today) everywhere I could and the code produces 5.000000 no matter the iteration (performance be damned).
I don't think the sequence has converged to 5. I think you'll find that if you dump the nominator and denominator of the FatRat, you'll just see two very large numbers. I think the issue is with printing the value of a FatRat, it probably ends up being a floating point value and starts showing 5 when that's the closest float available to the true value.
I think the question that has to be asked is, "why would you bother?" Is there any benefit whatsoever from migrating to Perl 6 that would justify the effort involved and the risk that a hitherto working system might break?
I cannot determine the reasons why people want to move Perl 5 code to Perl 6. I am a firm believer in "if it ain't broke, don't fix it". My article is equally intended for people that want to just try and see how it would look in Perl 6, and for people that *need* to port it to Perl 6 because of some of its unique features, such as regular expressions with full Unicode grapheme support, or its async features such as `react` / `whenever` blocks. So, this the article is not about "why would you bother". It is about when you're bothering, and the things you may run into while bothering. FWIW, this was the first article of 12, each taking on a specific aspect of Perl 5 to Perl 6 migration.
It might only converge to 5 at the limit, but they do get very close. As you can get arbitrarily close to 5 as you want, that's the limit right there and it indeed converged to 5.
We keep being told, "Perl 6 is not a new Perl 5." It's almost like no-one in the Known Universe or Beyond believes that. It's almost like those of us who love Perl continue to suffer verbal abuse about "Why haven't you upgraded yet?" and why we will never stop campaigning for "Perl 6" to be renamed.
I have a bad feeling about this thread. It probably should be locked or deleted.
\&gt; I don't think the sequence has converged to 5 by iteration 75, or any iteration. You're right. (Notes to self. It seems I'm not listening properly to my math intuition brain cells. It's *obvious* that it couldn't have converged on an exact number after such a sequence. And I know I was thinking that in the back of my mind. But I failed to listen. Nor am I listening to my P6 knowledge brain cells. I *know* that the default printing routines limit the number of decimal digits and round accordingly and this was very obviously a candidate. But, again, I ignored that niggle. Perhaps worse, I didn't properly read your earlier comment and I didn't otherwise adequately investigate.) \&gt; Since the exact value is potentially infinitely long in base 10, that's quite defensible thing to do, I guess. Perhaps, when printed using `say` or `gist` (which specifically muss with values, eg truncating output and appending `...` instead because their output is intended for humans) rather than `print`, `put`, or `perl` (which specifically *don't* muss with values), rationals could do something like prepending `‚âà` when the number has had to be approximated or appending `(Num)`? (If there are any tests in roast or the ecosystem relying on `say` / `gist` not changing what they generate, well, those tests are arguably terribly wrong.)
You need to think positive! For example, this is a good time to invest into a popcorn stand! 
If this is serious, send a message to the mods making your case. As it is, i see absolutely no reason for either of these actions here as the thread is on-topic and in good faith. If you're not serious, be a better person and don't post such a thing publicly next time.
On systems where I'm forced to use Perl 5, I really wish I wouldn't have to write reams and reams of code for constructs that have sane shortcuts in Perl 6. Like `use List::UtilsBy qw/nsort_by/; ... nsort_by { -$_-&gt;importance } $self-&gt;departments-&gt;@*` which in Perl 6 would be just `self.departments.sort: -*.importance` or `App::Model-&gt;new(db_file =&gt; $db_file)` which in Perl 6 would just be `App::Model.new: :$db_file` Probably isn't the reason to convert an *existing* app to P6, but any time I switch over from P6 to P5, I develop RSI just from the *thought* of all the extra damn typing I have to do.
Please don't stop here, I'd enjoy reading comments on Python, Go and Node subs. Perl5 is pretty small fish, think bigger.
&gt; Please don't stop here FWIW, we have Foo-to-Perl 6 guides for Python, Ruby, JS(Node), and Haskell in the [*Language* tutorials docs](https://docs.perl6.org/language.html). &gt; Perl5 is a pretty small fish It's pretty big for Perl 6. [75% of Perl 6 users](https://perl6.org/survey/2018.06/results) used Perl 5 extensively before.
&gt; Replacing Python is what you should be striving for :-) Python's philosophy of "preferably only one thing" is diametrically opposed to Perl's philosophy of "there's more than one way to do it". Trying to cater to Python's users is the worst thing a Perl can do.
Then happy living in your &lt; 1% bucket :-)
As a Perl 6 programmer who sometimes have to write Perl 5, I wouldn't mind seeing a similar guide going the other way. Core Perl 6 has a ton of features core Perl 5 doesn't. There's a gazillion modules that offer some of the features, but what do the cool kids use these days? Unless you're an active participant in the Perl 5 community, it's very hard to know those things. There's `Task::Kensho`, but IMO it's too generic. I wouldn't be using `HTTP::UserAgent` in a `Mojolicious` web app. 
*The bucket of a thousand Litres begins with one drop.*
I think this is a good idea, but I don't know if it would have much of an audience at the moment. Maybe a more generic "how do I do things from other languages in Perl 5?"
Good point. And yeah, the guide from-other-langs instead of specifically from P6 would be equally good.
What kind of problems are you solving where RSI is your biggest worry?
I work for a medical company üòé
Heh, I didn't mean core, the perl binary itself.
A separate posting with a listing of those things might garner a few (opinionated!) replies. "language X has feature/module Y, how would a Perl user approach it", etc.
I decided my eyes wouldn't *actually* bleed if I took another look. &gt;5.000000 no matter When I run the code at [tio.run](https://tio.run) it shows `5.0000000000` starting at iteration 48. At iteration 48 the nude is `8881784197120901988004362109521604 / 1776356839440133686216246923876993` which `say` says is `4.9999999999550955`. That's 10 `9`s followed by `55`... Your code says `.fmt("%3.10f")` which [the doc](https://docs.perl6.org/routine/sprintf) says will format a number as "a floating-point number, in fixed decimal notation" with up to 3 digits before the decimal point and 10 digits after. So it naturally displays as... `5.0000000000` and does so for the first time at iteration 48. In conclusion your code is doing as I would expect. You can remove all the `FatRat`s except for one for the result of `rec`. You also need to deal with the fact that `4` isn't a rational. The idiomatic thing to do is write it as `4.0`. In my code the first iteration that `say`s `5` is the 76th. That's because I'm just using `say` whereas you're using the `.fmt("%3.10f")`.
&gt; how do I do things from other languages in Perl 5? * [PLEAC](http://pleac.sf.net) * [Rosetta Code](https://rosettacode.org) * https://duckduckgo.com/?q=%22programming+chrestomathy%22
Thanks for the links, Rosetta Code is pretty cool.
"Gern geschehen" - Your welcome! So i think we won't meet at YAPC::EU/The Perl Conference - Glasgow, right?
strict.pm isn't even in the perl binary itself.
That's why perl is four letter word everywhere but this board. Horribly mismanaged project.
My understanding of the docs and using helpers in a Mojo::Lite context is that 'my_cookie_manager' creates a method in the controller, not the app. The controller is passed in for every request.
You're right! That's really helpful. Now instead I'm doing: `$app-&gt;helper(my_cookie_manager =&gt; sub { $cookie_manager-&gt;controller(shift) });` And this way I have the controller on every request. Thanks!
&gt; There's a gazillion modules that offer some of the features, but what do the cool kids use these days? I like things *simple*. That means to reduce dependency on modules because of *dependency hell*. If there's a simple module that doesn't depend on any others - I'll use it. Even better if it is part of the core distribution. But I'm very reticent to use any non-core modules that pull in more than 1 level of dependency. Sure, CPAN makes it easy to pull a module that depends on another module that depends on another module that depends on another module. But I'd rather avoid that unless I absolutely *need* it. I'm also not a fan of modules just for the sake of turning everything into an object. I worked on a large corporate project that ran like a dog because every single URL was turned into an object when it performed far, far quicker as a simple string. &gt; As a Perl 6 programmer who sometimes has to write Perl 5 You have to consider *why* you want to use Perl 5 in preference to Perl 6. Sometimes for backwards compatibility (Perl 5 is everywhere). But a far more pragmatic use case is when you have a short-lived script. Perl 6 needs a virtual machine spun up which takes time. Perl 5 rockets on, does what you need, then exits - making it perfect for short scripts that need a fast response time. Perl 6 may well *never* be optimised enough compete for this use case. And if you're using Perl 5 for performance reasons - you have to really consider the need to objectify things that simply have no need to be turned into objects.
Helpers are actually accessible from both the application and controller object. When called on the application, they will receive a dummy controller object (with no usable request data, of course). So you still will always get a controller object as the invocant.
&gt; You have to consider why you want to use Perl 5 in preference to Perl 6 For social and office-political reasons mostly. It was a years-long battle to switch to better tech from what we used to use and I don't want to redo it just because Perl 6 came out (especially since there are more important favours about the systems we use I'd rather win instead). In some other cases, it's because the app was already written in Perl 5 years ago and is fairly big. But I foresee those being switched to Perl 6 eventually, when there's enough of downtime to allow the conversion. &gt; But a far more pragmatic use case is when you have a short-lived script Hmm... Can't say I ever had such a usecase ever since CGI died.
Yes though mostly through the examples: https://metacpan.org/pod/Mojolicious#helper
 use Types::Standard 'HashRef', 'ConsumerOf'; has an_attribute =&gt; ( is =&gt; 'ro', isa =&gt; HashRef[ConsumerOf('This::Is::The::Role')], required =&gt; 1, ); 
The example there doesn't use `$c` at all. However, I do see mention way up in the 'AUTOLOAD' section: https://metacpan.org/pod/Mojolicious#AUTOLOAD Is there a way for a helper to determine if it was called from a real controller or not? What would one look for in `$c` to tell if it's legit? I'm guessing that `$c-&gt;req` would be undefined? (this could get interesting if the helper sub tries to access e.g. `$c-&gt;req-&gt;url`.)
It does, under `# Controller`. Generally if a helper cares whether it gets a real controller, it should never be called on the application, avoiding the issue.
Happy anniversary!
From the wonderful world of.. IT MIGHT WORK. perl -E'say for "-10".."01";' (doesn't work)
Did you get the job?
Classes that teach worst practices are a huge disgrace to the field. Anyways, HTTP::Tiny is part of core perl and is easy to use.
Just the second interview. Many more left. But it went relatively well.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://metacpan.org/release/libwww-perl) - Previous text "LWP" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
CGI.pm was removed from core. Which isn't quite the same thing as deprecating it.
Positive feedback just came in from Facebook... :)
Positive feedback for the second interview. Still lots and lots to do.
It's just perl code. Can you be more specific about what doesn't work? Your foreach loop should set $_ to each element of the array as in a normal loop.
It's just perl code. Can you be more specific about what doesn't work? Your foreach loop should set $_ to each element of the array as in a normal loop.
WITHDRAWN: Stupid typos in three places. This works just fine without the xsd\_files references, just using $build-&gt;add\_build\_element('xsd') 
Most people would recommend against using the `CGI` module these days. In fact, it has been removed from core Perl. Current best practice is to instead use a web framework. The main popular once are Catalyst, Dancer, and Mojolicious. My preference, particularly for "lite" webapps is Mojolicious, as it makes it pretty easy to create a small webapp in a single file, and deploy via CGI if required. Secondly, you are requesting XML data, but not converting that XML to something you can easily query. It's probably easier to request JSON and convert that to a Perl hash... In fact, Mojolicious has built-in support for that. Here's a simple webapp for you that I hope is simple enough for you to expand upon #!/usr/bin/env perl use Mojolicious::Lite; get '/' =&gt; sub { my $c = shift; $c-&gt;render(template =&gt; 'index'); }; post '/results' =&gt; sub { my $c = shift; my $q = $c-&gt;param('q'); my $h = $c-&gt;param('h'); my $url = "http://dblp.org/search/publ/api?q=$q&amp;h=$h&amp;c=4&amp;f=0&amp;format=json"; my $json = $c-&gt;ua-&gt;get($url)-&gt;result-&gt;json; $c-&gt;render(json =&gt; $json); }; app-&gt;start; __DATA__ @@ index.html.ep &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Perl Statistics Form&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="results" method="post"&gt; &lt;input size="100" type="text" name="q" placeholder="Query" &gt;&lt;br /&gt; &lt;input size="100" type="text" name="h" placeholder="Max Hits"&gt;&lt;br /&gt; &lt;input class="button" type="submit" value="Submit"&gt; &lt;/form&gt; &lt;/body&gt; &lt;html&gt; You can test this with Mojolicious' built in development webserver `morbo`, ie. If your file is called `webapp.pl`, then run `morbo webapp.pl`. You app is now reachable at http://server-ip:3000. This will just dump the raw JSON as a result, but you could format it however you like. If you want to play around with the data you get back, here's another small script using the Mojo::UserAgent (from Mojolicious) and my data dumper of choice, Data::Dumper. use strict use warnings; use Mojo::UserAgent; use Data::Printer; my ($q, $h, $c, $f) = ('query', 10, 4, 0); my $ua = Mojo::UserAgent-&gt;new(); my $url = "http://dblp.org/search/publ/api?q=$q&amp;h=$h&amp;c=$c&amp;f=$f&amp;format=json"; my $res = $ua-&gt;get($url)-&gt;res; if ($res-&gt;is_error) { say {*STDERR} '%ERROR: ' . $res-&gt;message; exit(1); } my $content = $res-&gt;json; p $content-&gt;{result}{hits}; Once you have the json as a Hash ref (eg. `$content`), you can pull out whatever data you need, for example for my $hit (@{ $content-&gt;{result}{hits}{hit} }) { printf("%10d: %s\n", $hit-&gt;{'@id'}, $hit-&gt;{info}{title}); } When you are ready to deploy, you can switch from the development server `morbo` to the production per-forking server `hypnotoad`. Can then throw it behind a nginx reverse proxy as desired. Hope this helps! Mojolicious has extensive documentation on everything. It's a little overwhelming at first, but I've found it the easiest web framework to learn, given I'm not really a web guy.
It would if you had not used \`my\`. That keyword is for scoping a variable to a block (lexical scope), so it becomes a completely fresh thing to think about within the curlies {} you declare in and anything referring to that label will be getting that copy. If within your if you had just said \`@flag\_array = ()\` without the my it would have over written to be empty. Something like Python for example only has function scope rather than lexical scope, you can just write your Perl as if it was function scope though, just don't keep using my everywhere only in the outermost block of a function.
Cool thanks for the explanation. The second declaration was a mistake, but that was the reason for the unexpected outcome and thanks for the explanation. I am mostly a python user and only occasional perl, C# and a few others. 
FWIW you can even run a mojo-lite application as CGI but it's wicked slow, only useful for something that's called once in a while. Hypnotoad is the bomb, though.
Sorry, I edited out the url for the form action because it had my name in it , but at present the form is submitted to itself and the inputted data prints below the form, Still struggling with the format of this should i edit my code so that the from is in one file then submitted to a new action page in a seperate file which contains the cgi syntax to compare the input ? or cane it all be coded in one single file? also the code at the bottom of my script above which compares the data, does that look correct or am i a long way off?
To add to /u/MattEOates great explanation, check out these nice guides to scoping: https://github.com/mvanwinkleias/perl_tutorials/blob/master/MyOurLocalTutorial.pod and a bit older but still useful https://perl.plover.com/FAQs/Namespaces.html
Thanks for the reply! and thank you very much for your help its gratefully appreciated. I suppose the problem im having is that the code at the bottom of the previous script doesn't seem to do anything apart from print "no matches found for query", but thats because ive set the get request without looking at the data from the http request ? just a number of replies to your points 1) I've tried to use, use Strict and use warnings but for some reason I keep getting an internal server error each time "Server responded with a status 500 (internal server error) line 1 when i inspect the code in highlights !&lt;DOCTYPE HTML&gt; 4) Unfortunately i'm not allowed to use Json, can the url in you code above and be stored and displayed by replacing $json with $xml &gt; 5) absolutely! I had previously set them using the param() function, i must have panicked abit and made it unnecessarily frivolous in the hopes of attaining more marks, I'll change them back 
JSON is just a data format, like XML. So "not allowed to use json" doesn't make any sense. There's a JSON parser built into perl, it's slow but functional https://perldoc.pl/JSON::PP
yea that was, pretty much the development process thus far, using mac os so ive tried running the programme in terminal but keep getting an error "cannot locate LWP/simple.pm in @INC line 7 operation aborted. i'll these suggestions, thanks!
Weirdly after adding use CGI::Carp qw(fatalsToBrowser); to the code it executes without error, the form is displayed and takes user input but doesnt execute the comparison bit, but ill restructure it and try again one small grip i have is that the code which validates user input `if (param($query) !~ /^[\p{Alpha}\x20]+$/) {` `print "Not a valid query"` `} else {` `print "Your Query is: " ,param('Query'), "\n";` `}` "not a valid query" is printed as soon as the webpage loads before data has even been input into the textfields
Well, of course. You run that code every time, and if you don't have any parameters, then that regex isn't going to match. You only want to run those checks if you've been sent some date (`if (params()) { ... } `). Also, `param($query)` is wrong. You want `param('Query')`. As a general principle, your code will be easier to follow if the expression in an `if` statement is positive, not negative. People find it easier to follow logic that goes "if this is true do this, otherwise do that" than "if this isn't true do this, otherwise do that". So I'd write your check as: if (param('Query') =~ /^[\p{Alpha}\x20]+$/) { print "Your Query is: ", param('Query'), "\n"; } else { print "Not a valid query" } Actually, I might even prefer: # If Query param contains a character that isn't # a letter or a space... if (param('Query') =~ /[^\p{Alpha}\x20]/) { print "Not a valid query"; } else { print "Your Query is: ", param('Query'), "\n"; } Yes, that seems clearer to me.
You should define your project a little more carefully. **If it's a homework question you should be up front about it.** If there are special requirements then you should be up front about that, too. People here are clearly putting in a lot of thought and time in their responses, and your way of tossing those answers away with "sorry, can't do it that way" is kind of a slap in the face. IMHO it's pretty rude.
I was doing something similar, but for each customer (determined by virtual host), so the count was pretty small. Logic was connect before request, access db via app object and close after request (e.g. use a `db` helper and `around_dispatch` hook). As our "user" count was small, no further optimization was required, and with Postgres as backend, I'd rather be more tame about the connection count. So you can just set the `max_connections` of `Mojo::mysql` to 1 and be done with it. You can keep the connections object in a hash directly if you want to avoid reconnecting before each request. Also be aware that you get your connections per worker process if running under a prefork setup (like HypnoToad). That might matter if you really need to cut down on connections, but generally a MySQL server can handle quite a few connections (default is about 150, but that's rather conservative and can easily be raised on a modern server).
Oh, so if you prefork each process is getting its own model, which would then mean it's own Mojo::mysql with its connections? And you're saying set max connections to one since only each client needs access to their database?
Also, did each virtual host have their own DB config file to know how to connect?
max_connections default has actually been changed to 1 in Mojo::Pg, it's a perfectly reasonable default. There's no reason to ever cache multiple connections when running blocking queries, and when running non-blocking queries connections will only count against that limit when they aren't waiting or being used to retrieve results. So it won't actually prevent you from opening a bunch of connections if you run a lot of simultaneous non-blocking queries, but if you control that factor you can control how many connections are made. The biggest factor is usually that each process will need to make a separate connection (as mentioned regarding the prefork server).
It's a regular accessor. Or you could just make it more explicit and have a separate app attribute/helper called `user_config`‚Ä¶
You control how many connections are made by controlling how many non-blocking queries you run at once, in your program logic. With max_connections of 1 only 1 connection will ever be retained of the connections that are no longer in use. Mojo::mysql's non-blocking queries do use a connection to run a non-blocking query.
Thank you! That was all super helpful :)
Got it. Thanks! :)
This is undefined behavior. There are no guarantees whether $x will be decremented before or after it is added to itself then assigned to $y.
That‚Äôs what I thought. It was on a review and I was super confused
If you're using Modern::Perl, you might consider using "say" instead of "print".
When you realize that you can't dynamically unload modules because Perl sucks, loading them at run time seems a lot less impressive.
It's two in the same: in your example you have to terminate. In my example you don't want to terminate. In many applications you don't want to terminate. Terminating is massive overhead because it means once against starting back up at some time. If you're running in a FastCGI loop for example, it would be massively less-shitty to be able to `use POSIX;` to do some work, and then `no POSIX;` or the like to shrink the resident memory back down (when you no longer need the symbols and functions). Unfortunately, perl doesn't provide for this. See also, * https://stackoverflow.com/q/46738256/124486
Maybe delete this post and repost it as a link?
I know it's offtopic, but please don't use c-style for. The following is **much** more readable: for my $count (0..4) { ... }
In a typical mod_perl setup, you usually want to make sure you load everything before forking, so the memory can be shared between all processes. Your runtime use POSIX/no POSIX example might make some sense, but when you start using it in multiple places in your code you're going to want to think about factoring it out. So you've got an attempt at optimization that could be very counter-productive depending on what's going on elsewhere in your code... 
Is there any specific reason to use `eval "use $module"` instead of `eval "require $module"`?
Ah, thanks. I didn't realize you could even use `use` at runtime, which this code must be doing. Maybe wrapping it in `eval` makes it behave like a separate file of Perl code that is run and is therefore valid? perldoc indicates that `use` is equivalent to calling `require` and `import` inside of a `BEGIN` block. That seems to make sense. Learning new things every day...
Yes, that's basically right. The `eval(STRING)` doesn't happen until runtime, but it still passes the code back to the compiler.
`use` also does the import. Maybe you want that and maybe you don't. It depends on what you are doing.
A lot of dynamic languages don't release memory back to the OS until they shut down the process. Not even all Java VMs release memory back. Sometimes they do, but even then, it's probably not on every loop of the garbage collector. They're all came to the same conclusion as perl: releasing memory to the OS can be an expensive operation, and there's no sense doing it if we're just going to use it again later.
I would recommend instead using [lib::relative](https://metacpan.org/pod/lib::relative) and [Module::Runtime](https://metacpan.org/pod/Module::Runtime). The former for reasons explained in that module, and the latter because string eval is a huge complication and vulnerability that is unnecessary for this use case.
This is correct, however it will still happen at runtime since that's when the string eval will run, so it's not very useful for things like importing functions.
Can you please explain which complexities are you referring to?
FindBin's complexity is describe in the lib::relative docs. Plenty has been written about the dangers of string eval particularly as a recommendation to newcomes. It is a new perl interpreter context and evaluates whatever code you pass it, which means you have to be extremely sure about what you pass to it, it could do anything and doesn't have to compile along with the surrounding code. Whereas lib::relative is extremely straightforward (it is two lines of code) and Module::Runtime takes a module name, validates it, and loads it with require(), no eval involved.
While in the spirit I agree with you, a lot depends on the environment your script will run in: if the string to be evaluated comes from a generic user input, that could be extremely dangerous, if the code change ‚Äîas in this case‚Äî in the config to load the module has been done by some person inside the same company / organisation, there are easier ways of doing harm than trying to trick an eval
Gotta agree with Grinnz. While it's fun to know some of these under-the-hood things, in practice: Don't do any of these and use CPAN modules to do it for you instead of playing whack-a-mole with bugs while blind-folded.
Here's another fun one, for those of you raised on C: use v5.10; my $x = 7; say $x--; say $x; say $++x; say $x; What do the last two lines print, and why?
I didn‚Äôt write this code it was my professor lol. It was on a review
But the import is delayed. So it doesn't behave exactly the same as a direct `use` call. Most notably: your function calls need parens.
YoungQuavo, not trying to harsh but why not at least run the code and see?
A couple of ways: return $self-&gt;model-&gt;accounts-&gt;find_by_client_id_p()-&gt;then(sub { return ($_[0], $client) }); return Mojo::Promise-&gt;all($self-&gt;model-&gt;accounts-&gt;find_by_client_id_p(), Mojo::Promise-&gt;new-&gt;resolve($client)); Note that the latter will pass two arrayrefs as that's how -&gt;all passes its arguments to the next step.
Fibonacci sequence, with cache, using the Perl 6's sequence operator: @fib = 1, 1, *+* ‚Ä¶ ‚àû; say @fib[99] # OUTPUT: ¬´354224848179261915075‚ê§¬ª Piece of code Perl 6 that runs for 1 second, parallelized over 4 cores, quartering the total runtime: ^4 .race(:batch).map: { sleep 1 }; say now - ENTER now; # OUTPUT: ¬´1.0488641‚ê§¬ª
I clicked through the link without thinking and I was like "Whoah! I gotta brush up on modern perl! I don't even recognize this stuff!"
In Perl 6, is there a useable alternative for characters like "‚àû"?
Oh cool, didn't know that feature was in there.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://docs.perl6.org/language/unicode_ascii) - Previous text "Inf" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Cool! I've not been following Perl6's development, really, at all. 
Yes, all fancy Unicode constructs have [ASCII-only alternatives](https://docs.perl6.org/language/unicode_ascii).
His blog posts on Type::Tiny have been great. Inkster, if you're around, keep it up! I really wish there was a better way of quickly indicating how useful a post is on blogs.perl.org - I'd even settle for those stupid Medium claps... üëè
This one is moderately legendary, it's the "no punctuation" JAPH. &gt; not exp log srand xor s qq qx xor s x x length uc ord and print chr ord for qw q join use sub tied qx xor eval xor print qq q q xor int eval lc q m cos and print chr ord for qw y abs ne open tied hex exp ref y m xor scalar srand print qq q q xor int eval lc qq y sqrt cos and print chr ord for qw x printf each return local x y or print qq s s and eval q s undef or oct xor time xor ref print chr int ord lc foreach qw y hex alarm chdir kill exec return y s gt sin sort split output: "just another perl hacker"
The alternative: all punctuation. eval eval '"'. ('['^"\+").( ('[')^ ')').('`'|')'). ('`'|'.'). ('['^'/').('{'^'[' ).'\\'.'"' .('`'^ '*').('['^'.').('['^ '(').('['^'/').('{'^ '[').('`'|'!').(('`')| '.').('`'|'/').("\["^ '/').('`'|'(').('`'|'%' ).('['^')').(('{')^ '[').('{'^'+').('`'|'%').( '['^')').('`'| ',').('{'^'[').('`'|'(').('`' |'!').('`'|'#' ).('`'|'+').('`'|'%').('['^')'). '\\'.'"'.("\!"^ '+').'"';$:='.'^'~';$~='@'|"\(";$^= ')'^'[';$/='`'| '.';$,='('^'}';$\='`'|'!';$:=')'^"\}"; $~='*'|"\`";$^= '+'^'_';$/='&amp;'|'@';$,='['&amp;'~';$\=','^'|' ;$:='.'^'~';$~ ='@'|'(';$^=')'^'[';$/='`'|'.';$,='('^'}' ;$\='`'|'!';$: =')'^'}';$~='*'|'`';$^='+'^'_';$/='&amp;'|'@'; $,='['&amp;'~';$\=','^'|';$:='.'^'~';$~='@'|'(';$^=')'^'[';$/= '`'|'.';$,='('^'}';$\='`'|'!';$:=')'^'}';$~='*'|'`';$^='+'^ '_';$/='&amp;'|'@';$,='['&amp;'~';$\=','^'|';$:='.'^'~';$~='@'|'(' ;$^=')'^'[';$/='`'|'.';$,='('^'}';$\='`'|'!';$:=')'^'}';$~= '*'|'`';$^='+'^'_';$/='&amp;'|'@';$,='['&amp;'~';$\=','^'|';$:='.'^ '~';$~='@'|'(';$^=')'^'[';$/='`'|'.';$,='('^'}';$\='`'|'!' ;$:=')'^'}';$~='*'|'`';$^='+'^'_';$/='&amp;'|'@';$,="\["&amp; '~' ;$\=','^'|';$:='.'^'~';$~='@'|'(';$^=')'^'[';$/='`' |(( '.'));$,='('^'}';$\='`'|'!';$:=')'^'}';$~ ='*'|'`' ;$^ ='+'^'_';$/='&amp;'|'@';$,='['&amp;'~';$\=','^ '|';$:= '.' ^'~'; $~='@'|'(';$^=')'^'[';$/="\`"| '.';$,= '(' ^'}';$\='`'|'!';$:=')'^'}';$~ =('*')| '`' ;$^='+'^ '_';$/='&amp;' |"\@"; $,='[' &amp;+ '~';$\= ','^'|'; $:='.' ^"\~"; $~ =('@')| "\(";$^= "\)"^ "\["; ( ($/))= '`'|'.'; ($,) ='(' ^"\}"; $\=('`')| '!'; ($:) =')'^ "\}";$~= '*'| '`'; ($^)= '+'^'_' ;$/= '&amp;'| '@'; $,='[' &amp;'~' ;$\= ','^ '|' ;$:= '.'^ '~'; $~= '@' |(( '(' )); $^= ')' ^(( '[' )); $/= '`' |(( '.' )) ;( ($,))= (( (( '(')) )) ^+ "\}";$\= (( '`' ))|+ "\!"; $: =(( ')'))^ '}'; $~= '*'| "\`";$^= '+' ^'_' ;($/)= ('&amp;')| "\@";$,= '['&amp;'~'
comp.lang.perl.misc used to have a regular poster named Abigail. Abigail posted this once: `perl -E 'say "Prime" if (1 x shift) !~ /^1?$|^(11+?)\1+$/' $1` The moment I figured out how it worked, it was like the sky opened up and the angels sang.
So many cool things in Perl 6. Just a shame it seems like it's never really going to get used.
This is only a problem if you're generating code which is a rather uncommon use case.
Adults left the house long time ago, children do what they do best, play. p5p asleep at the wheel while Rome is burning.
This is exactly the kind of clever trick that led to the "line noise" jokes. 
Strictly speaking, a single /e doesn't do an eval; the replacement text is treated as part of the body of the code at compile time. For example, if $&amp; was hypothetically usable as an lvalue, then these would be equivalent (where RRR represents whatever physical text is present in the replacement part of the source code): s/abc/RRR/; same as /abc/ &amp;&amp; $&amp; = qq/RRR/; s/abc/RRR/e; same as /abc/ &amp;&amp; $&amp; = RRR; s/abc/RRR/ee; same as /abc/ &amp;&amp; $&amp; = eval RRR;
It's like that for every language.
&gt; seems like it's never really going to get used How come it seems like this to you? Any specific reasons?
In the second part of the regex, does it have to match the first group (`11+?`) *non-greedily*? You could as well use the greedy version (i.e., `^1?$|^(1{2,})\g1+$`), right? I assume the only difference is in the way the chunking works: * non-greedy version goes from small to larger chunks * greedy version from large to smaller chunks Or is there more to this specific regular expression?
You‚Äôre not matching the numbers in their unary representations! For me, in a quick test, both versions finish in just about the same time‚Ä¶
Only because it's been out for a few years now, and hardly anyone even knows about it (beyond a very small echo chamber, which doesn't even include the vast majority of the Perl community). To be clear: I don't think it's really about anything the Perl 6 team has done wrong. It's just quite difficult for new languages to break through (even if they've got some cool stuff in them). And I think the "Perl" brand is too tarnished for most people to get passed. (The one major mistake, in my view, was calling it "Perl 6". A different name would have been better for a number of reasons). That said, it may change. I think if people can build some cool stuff in Perl 6, people may take an interest. e.g. some useful open source projects that others want to contribute to.
Yeah, good point about the brand, though there is a path away from total disaster that's currently being worked on. I wish in early 2015 instead of announcing Perl 6, Larry would've announced Perl 6 will never happen (play off the joke about '6' being unlucky, like with PHP 6) and that those who like Perl should look forward to Perl 7, which is what some future release of Perl 5 would've become. And then say that Perl 6 effort actually ended up in a new language called whatever, and that on Christmas 2015, you can get the *beta* preview of that brand new language. Then on Christmas 2015 release what was released for Perl 6 and 3 years from that (which is around today), release the first stable-but-unoptimized release of that brand new language. That sorts out the branding, leaves an easy path forward for Perl 5, offers a good mental reason for why Perl 6 took so long, and sets correct expectations for the performance/stability of the Christmas release of Rakudo we got. Hindsight's 20/20, I guess, but good a good plan to have if I ever invent a time machine :P
I agree, that would have been a much better approach. I'll be interested to see what is being worked on to get around this problem.
I don't see the relation between CGI::Emulate::PSGI and Mojolicious. What are you trying to do? Integrate with an existing Mojolicious app? Doesn't matter where your `use` statements are, Perl always executes `use` statements at compile-time. &gt; but later the documentation That's if you want to use CGI::PSGI in place of CGI, the documentation states this is optional.
Thanks will take a look at those as well. 
&gt; $dbh-&gt;{LongTruncOk} = 1; That probably should be set to 0.
I tried the following but the data is still being truncated. $dbh-&gt;{LongReadLen} = 512 * 1024; $dbh-&gt;{LongTruncOk} = 0;
What type of database is it? (IOW: what DBD driver does it use?)
Database is `sybase` and using the `sybase` driver.
Long time since I've hear dof that. Could this ancient issue be related? http://freetds.ibiblio.narkive.com/jxwgMh3P/dbd-sybase-mssql-varbinary-255-byte-limit
Are you using a version of the Sybase database or client libraries older than version 12.5? If so, then that is likely why you are limited to 255 characters. Prior to 12.5, Sybase varchar fields could be not larger than 255 characters. See [https://github.com/opinkerfi/DBD-Sybase/blob/master/dbd-sybase.pod](https://github.com/opinkerfi/DBD-Sybase/blob/master/dbd-sybase.pod) for more info.
Sybase version is 15.7. I am unsure who to check client library version.
The syb\_oc\_version attribute of a $dbh should tell you that. See [https://metacpan.org/pod/DBD::Sybase#syb\_oc\_version-(string)](https://metacpan.org/pod/DBD::Sybase#syb_oc_version-(string))
syb_oc_verision `freetds v0.91 (threadsafe, default tds version=4.2)` 
That is an old freetds version, released in 2011. The tds client version 4.2 is the likely cause of your issue here. You will need to use tds version 7.0 or higher to have a chance of this working. See [http://www.freetds.org/userguide/choosingtdsprotocol.htm](http://www.freetds.org/userguide/choosingtdsprotocol.htm) You should be able to specify the tds version to use for each server in your freetds.conf file.
Your link doesn't work. It redirects to metacpan. You could have used perldoc.perl.org instead: http://perldoc.perl.org/functions/delete.html 
Sorry, reddit included the : in the link
&gt; It feels like this article somewhat misses the key point of the feature "Somewhat".... I'd rather say "completely". The examples in the article work identically when you replace "‚Ä∞" with "@" &gt; delete %hash{ qw(Bird Lizard) }; # syntax error prior to v5.28 delete @hash{ qw(Bird Lizard) }; &gt; delete %array[ 2, 4 ]; delete @array[ 2, 4 ]; 
Thanks I will talk with the admins and look into getting this upgraded.
Not really one line, but the coolest Perl5 trick I saw in recent years is CoW aliasing to abuse internal regex engine state. I saw it first in Math::Prime::Util::PP. It creates a large string as a sieve because an array would be too much overhead, and more compression with vec or bitmasks would be slow. Then it can access it 0-indexed to set composites with substr: substr $sieve, $pos, 1, '1' But as the last stage you want to extract the positions of primes from the string, and there comes this genius bit: $_ = substr($sieve, 1); push @primes, pos while m/0/g; The first line creates a copy-on-write version that doesn't touch the actual hundreds of megabytes of sieve, and the global matches runs blazingly fast (for Perl at least) through it and extracts the now 1-indexed positions.
Looks like good clean fun. I may give it a try.
Just for my education, who is "forhorn"?
It's apparently how the lame macOS spell guesser corrects [Foghorn](https://en.wikipedia.org/wiki/Foghorn_Leghorn).
I was thinking that but I wanted to make sure. lol 
On a related note, there's actually a simplified math formula you can use too. fib (n) = round((((‚àö5 + 1)/2)^n)/‚àö5); note: this is limited by the precision of your floating point. If you use Math::BigFloat you should be ok up to some pretty high numbers. fib (150) = 9,969,216,677,189,303,386,214,405,760,200. #!/usr/bin/perl use Math::BigFloat; $n = 150; $r5 = Math::BigFloat-&gt;new(5); $r5-&gt;bpow(.5); $phi = Math::BigFloat-&gt;new(1 + $r5); $phi-&gt;bdiv(2); $fib = Math::BigFloat-&gt;new($phi); $fib-&gt;bpow($n); $fib-&gt;bdiv($r5); print "fib($n) = " . int ( 0.5 + $fib ); 
All the cool kids know that backwards compatibility is for hosers. 
Backward compatibility with what ? The cgi code from 2k bubble days ? However, frankly it's meaningless to even try at this point to save Perl 5, it's dead. 
&gt; The first (meta) things are to &gt; Identify what "Perl" means &gt; Who the target groups are &gt; What (used to make) makes Perl great &gt; Which market developments helped promoting Perl I would like to see answers to these questions. 
&gt; Identify what "Perl" means There are three answers to this: 1. "Perl" means all the acronyms that it has been retroactively expanded to. 2. Perl means the extension of the Unix ethos of textual interoperation and presentation up into the language space. 3. Perl doesn't mean anything. It is a vessel into which the community brought its hopes, desires and needs for a language. &gt; Who the target groups are Traditionally, people who just need to get shit done, as opposed to those who wished to impose some ideal programming paradigm on those who just need to get shit done. &gt; What (used to make) makes Perl great Being what all the other tools were, but in one place; being slingable but fast; being universally accepting. &gt; Which market developments helped promoting Perl It varied by time period. In the late 1980s when Perl was launching, your options were AWK (which was horribly restrictive) or C (which required tons of up-front work just to read and write strings). Perl was able to fit into that space. In the early '90s, Perl 5 introduced OO programming and functional features to an audience whose suite of tools generally only consisted of simple procedural capabilities. This was tremendously important. When the Web hit, Perl was ideally placed as the most featureful language that allowed you to sling text around easily, and the Web was just a differently structured text (HTML over HTTP). It wasn't that Web developers dove into Perl, it was that Perl and the Web co-developed. This is why Perl became popular. It's why Ruby became popular (it was Ruby and the website-as-application space co-developing). 
Always has been. 
Very interesting. 
perl needs function signatures and a more compact way to make objects, it's a shame to see people have been talking about this for years. I also would like some way to pass two lists without having to dereference them in another line. something like this fucnt(\@arr ,\%hash , $var); sub fucnt () { my (\@arr ,\%hash , $var) = @_; #same as @arr=@{$_[0]}; } or one step further would be sub fucnt(\@arr ,\%hash , $var) { #........... }
I‚Äôm confused. It‚Äôs all so vague as to be meaningless.
This is the most drama-seeking reactionary post ever. You're angry that some dude was held accountable in the eyes of some other people and you want us to sympathize with him without knowing what he did, and without speaking of allegations themselves? 20 years in the Perl community here: it's always been a bunch of white dudes. The culture is highly problematic. Knowing that someone is trying something -- you've got a huge barrier to climb before I shit on that effort. 
Something very similar to your last code block is likely to appear in perl 5.30.
You've described the thing you want to match, but you don't say what the useful information that you need to get out is, or what the general patterns are here - we've only got one example, so can our regex assume that there's only one `tex_args` bit, for example? Can you show us a few different versions of what the input would be? On the face of it, though, this looks like it might be a reasonable job for a getopt module (which are for parsing the `-&lt;name&gt; &lt;value&gt;` style options)
I've editted the post to clarify. You can not assume there is only one "-tex_args" and -tex_args-" start/closing tags. There can be multiple within the same command line. For example: execute test_number_1 -tex -tex_args -sub_args +debug_dir=./ -sub_args +debug_dir=./ -tex_args- -opt 1 -tag -tex_args -constraint parity_en,random_en -sub_args '"' ruck=1 '"' -constraint dual_en -sub_args -cd -sub_args 2596.slow -sub_args test -seed 1 -tex_args- 
Hey, matthewt, just a quick heads-up: **publically** is actually spelled **publicly**. You can remember it by **ends with ‚Äìcly**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
no, [because](https://stackoverflow.com/questions/6162484/why-does-modern-perl-avoid-utf-8-by-default/6163129).
Thank you - that awesome answer from Tom Christiansen is way more informative as is good for me! Ah well. But I guess "PERL_UNICODE envariable to AS" use utf8; use open qw( :encoding(UTF-8) :std ); use charnames qw( :full :short ); binmode(DATA, ":encoding(UTF-8)"); use autodie; $dbh = DBI-&gt;connect('dbi:mysql:test','user','password', {mysql_enable_utf8 =&gt; 1} ); Will have to do, then.
&gt; If I ever get to find out who you are, you're going on my shitlist and earn a lifetime ban from the conferences I help organise And what conferences might those be, precisely?
If it were me (and I'm more self-taught-hacky-scripter than developer) I'd first try to bend one of the Getopt modules to fit, and if not I'd loop through `@ARGV` examining each word in turn. Assuming there's always only one `-tex`, the splitting of the `tex_args` doesn't matter and you don't need to support completely arbitrary switches, I think this ought to be doable with something like `GetOpt::Long`, perhaps with some fiddling of @ARGV first. Can you remove the `'"'` from around the 'ruck=1' argument to `sub_args`? And the - from the `cd`? How easily these can be removed and remembered really depends on how variable they are. You can treat `-opt` and `-seed` as switches wanting integers `-tag` as a flag, create an array of `-sub_args`, and `-constraint` arguments, and ignore the `-tex_args` and `-tex_args-` switches. Something a bit like: my @sub_args; my @constraints; my $opt; my $seed; my $tag; GetOptions ( "constraint=s" =&gt; \@constraints, "sub_args=s" =&gt; \@sub_args, "seed=i" =&gt; \$seed, "opt=i" =&gt; \$opt, "tag" =&gt; \$tag, ); You can use `GetOptionsFromArray()` rather than `GetOptions` if you need to have it operate on a fiddled-with copy of `@ARGV`.
You want utf8mb4 not utf8, because mysql's utf8 only supports a subset of unicode. And also, you want DBD::MariaDB because DBD::mysql's utf8 handling is completely broken on every version except 4.042. https://github.com/perl5-dbi/DBD-mysql/issues/197
People sure complained about the massive breaking changes in python3 because of the total conceptual changes around Unicode, but in retrospect I wish Perl had done something similar.
The file has to be rewritten. Don't blame the filesystem ("the underlying filesystems don't make it easy"), it simply is how files work. The problem itself has nothing to do with perl. What if people want to add some text in the middle of a file? Are you going to write a new article about that? Maybe use yet another module?
Thanks for the suggestion. I can't rely on the '"' not being there. The argument can either have it wrapped with those or not.
Prototype aside (you're creating a function that expects no parameters, then using `@_`?), the first one already works in recent versions of Perl: perl -e' use experimental qw(declared_refs); (sub { my (\%x,\@y) = @_; print "hash =&gt; {" . join(" =&gt; ", %x) . "}\n"; print "array =&gt; [" . join(", ", @y) . "]\n" } )-&gt;({ abc =&gt; 123 }, [ qw(x y z) ])' hash =&gt; {abc =&gt; 123} array =&gt; [x, y, z] Seems likely that a similar form will be allowed for signatures someday (and yes, Perl already has various forms of signatures, they've been around for years - see https://metacpan.org/pod/Function::Parameters if you're on an older Perl version). There are also several compact ways of making objects, any specific syntax or features you're thinking of there?
Thanks for the heads up! But I do wish there were some brute UTF8 option that maybe throws warnings when one is doing something funky. Ah well 
&gt;you should use options like 'use open' ... with care, because they affect global state and CPAN modules According to Tom Christiansen's answer, in point 5 it explicitly states that `use open` only affects the lexical scope. &gt;5. Declare that anything that opens a filehandles *within this lexical scope but not elsewhere* is to assume that that stream is encoded in UTF‚Äë8 unless you tell it otherwise. That way you do not affect other module‚Äôs or other program‚Äôs code. &gt; &gt;`use open qw( :encoding(UTF-8) :std );`
Check the standard unicode preamble article by Tom Christiansen... https://www.perl.com/pub/2012/04/perlunicook-standard-preamble.html/
Ahh, of course. Thanks for the clarification. I guess, in an ideal world, modules should try their best not to touch the standard IO handles but - depending on the functionality - that is not always possible.
One important example is Test::More and Test2, which by necessity must use STDOUT to report results. Test::More was designed before anyone cared about unicode, so it assumes anything you pass to it is already encoded (which is rarely true). Test2 assumes you pass it characters, but there is still some debate over the correct way for it to work.
I don't want to deal with identity politics and the easily offended when it comes to something as logical as programming, why I fucked off from github after the WEBM for Retards ban. Is the Perl community actually being infested by SJWs? :/
I did and it‚Äôs what I said.
Wait, what? Was the lightning talk the one with "how to ruin a tech talk?" or something like that? That's what it sounds like from your post: &gt; if you want your talk to fail, forget to bring your video adapter and drain your laptop charge That talk seemed quite uncontroversial to me.
This is pretty quick but gets the wrong answers starting at n=180 on my system. 
No. daxim misunderstood, overreacted and got offended on behalf of an organizer and a speaker who weren't actually upset. Which is kind of hilarious to me since it's pretty much a mirror image of the *actual* SJW incursion we had at once point, which you won't be aware of in the first place because I had it quietly knifed before it turned into a public dramastorm. (if you're confused by this given my reputation for publically and viscerally taking a chainsaw to people ... that's what happens when the back channel diplomacy fails and I can't arrange a dark alley and a knife quickly enough) -- mst
&gt;some dude was held accountable The way I see it it wasn't just the speaker that was held accountable but more importantly the organizers of the conference and by extension the entire Perl community. Someone was upset. Would we collectively and competently give a shit? &gt;you want us to sympathize with him I don't think daxim's post was aimed at sympathizing with the speaker but rather with those angry about CoCs. (I think there's an important principle underlying daxim's anger, one that's not going to go away until we address it. I plan to post about that another day.) And I don't think the speaker wants sympathy. Indeed, per mst++'s post, the speaker apparently merits major kudos, not sympathy, for sympathizing *with the complainant* and *voluntarily* concluding that the net result of their talk as delivered at the conf was negative and removing their talk from the net. &gt;Knowing that someone is trying something -- you've got a huge barrier to climb before I shit on that effort. I was at the conf. Folk like mdk were not only trying things but were succeeding beautifully (with the sole fly in the ointment I've seen so far being this post by daxim which shows up another part of the problem). Imo the lightning bug, immediate fix, and public mea culpa reflect mdk and by extension Perl getting it very right, not wrong, a reason for collective celebration, not sadness.
Just going to [leave this here](https://docs.perl6.org/language/unicode)....
The future of Perl 5 is Perl 7. I said it. We've all talked about it and it needs to happen. It would help with marketing. Perl is my go to for webdev and scripting for my sysadmin stuff. Its not going away.
Given that mdk not only voluntarily took on organizing the entire conference but was also humble enough to do lots of little things like getting badges printed and then delivering mea culpas about that and the lightning talk, I imagine he's too busy doing good things to have time to take offense. But I'm guessing your point is more about the apparent absurdity of conference organizers being held accountable for well intended lampooning. I agree with mdk: &gt;Most often mockery of anyone is how language can enforce elements such as privilidge or dominance and victimise people. With his words in mind, spelled correctly or not, it was clearly incumbent on mdk to react to the fact that someone had taken offense to the lightning talk, and on the speaker to do likewise, and it's clearly a good thing that both mdk and the speaker reacted with kindness rather than hostility. Ultimately offense is taken, not caused, but that doesn't stop humans taking offense due to their interpretation of what they hear/read and thus we're all left with the conundrum of what to do when no offense was intended but offense was taken.
 Markdown::Pod installs fine under 5.26.2. You seem to be running 5.16.3, which is 5 years older than any maintained version
Makes a sense, @scruss, will try to upgrade my Perl, thank you. 
Thanks for this link. I read through the recipes. It‚Äôs impressive how much work has been done!
Yeah you get drift depending on the how much float precision you have access too. I ran it on an online ide which only ~16 digits of precision and had the same problem. I ran it on wolfram alpha and got accurate results until the numbers were too high to calculate. I hadn't actually used BigFloat before so this was something new for me, there might be a setting where you can specify desired precision.
Afaict this particular situation is an exemplar of the principle I have in mind, not as a violation of it so far but rather as an affirmation of it. At an after conf meal on Friday, JJ (Jos√©) explained an obvious-in-retrospect principle to me. I don't know if he'd ever thought of it before and I know I hadn't. The principles I don't like involve defining codes of conduct for attendees and having that be the focus of attention. The principle JJ shifted my attention to was in essence defining a code of response for community/conference organizers and their helpers. This would declare how they will react to a negative experience of a community member, conference attendee, or guest. So if I'm upset because someone has put my shirt size on my badge, or disappointed that I can't get thru a doorway because my wheelchair is an inch too wide, then organizers are accountable for having created an environment in which: 1) I feel safe complaining to helpers and organizers; 2) organizers handle my complaint with respect; and 3) my complaint is seen to have been handled respectfully. Imo that's what happened in this incident. 1) Someone took offense. None was intended but that's immaterial at this first stage. (Someone else at the meal pointed out they'd made a T-shirt they'd worn to a conference with something like "I'm not looking for sex. I just want partners." with some academic program requiring partners described elsewhere on the T. Someone took offense. It's irrelevant that the T-shirt was just meant to be funny.) Because mdk is a good organizer and had made it abundantly clear that anyone could speak to him the complaint reached him without undue hubbub. 2) mdk took the complaint seriously. He could have thought of it as a light-hearted lightning talk that was taken the wrong way and ignored the upset. He didn't. Afaict the speaker agreed to erase their talk without acrimony and in so doing turned upset into love by making mdk's job easier and helping the complainer to see no harm was intended. (Likewise, the T-shirt in the example mentioned above was exchanged for a fresh one.) 3) Finally, mdk did an official mea culpa so healing was seen to be done. Simple, quick, effective. Well, not so fast. Then came this post. So now we have secondary effects and *yet another round* of people taking offense where clearly none was intended. Imo the community needs to deal with daxim's response with kindness just as it did in response to the upset at the conf. And that's essentially the principle I'm focusing on: organizers, or at least key people in the community, responding with kindness to all with a commitment to reacting respectfully both privately and publicly. Of course it's all easier said than done. Fortunately there are Perl folk up to the task. Your concrete steps related to this incident, both at the conf and your reply in this tower of babel thread, are every bit as beautiful in their own way as a sack of yak hack stacks.
Aha, I see what you mean. I was thinking of the principle of "don't punish people for genuine mistakes" and associated things. Your three step process is something I entirely agree with though. Arguably your explanation of (2) misses a trick though - it absolutely *was* "a light-hearted lightning talk that was taken the wrong way" but both mdk and the speaker were able to think that *and* not feel that that justified ignoring the upset. Which, IMO, speaks even more to their favour. I'd note that everything that happened at the conference should be 100% credited to mdk and the speaker in question; I've jumped in here because I believed that I knew enough to be able to elucidate the situation and that as such it was better for me to do so than for either of them to try and weigh in under the circumstances. But I'll take the compliment to my comments here - thanks! -- mst 
Yes -tex will always be there. \-tex\_args not always, but highly likely. If it exists it will always have a closing -tex\_args- Yes -sub\_args will always have at least 1 argument present. Yes your tabbing understanding is correct.
&gt;Arguably your explanation of (2) misses a trick though - it absolutely was "a light-hearted lightning talk that was taken the wrong way" but both mdk and the speaker were able to think that and not feel that that justified ignoring the upset. Which, IMO, speaks even more to their favour. That's exactly what I meant. (I tried explaining how to parse my words so you could see that I meant exactly the same as you but it got complicated. Suffice to say, we 100% agree.) When I wrote "the speaker agreed to erase their talk without acrimony" I meant to compliment the speaker on keeping it simple. When I wrote "and in so doing turned upset into love" I meant to compliment the speaker as the prime mover. Perhaps it was easy for them but it doesn't matter. And if it wasn't, even more kudos are warranted. Please let them know they rock.
Ah, but does your script need to know if they were there? Would it behave differently for `-sub_args '"' ruck=1 '"' ` than it would for `-sub_args ruck=1`? If not, you could do just strip them out and so make the command line into something getopt-able, with something like: my @fiddled_argv = grep (!/^'"'$/, @ARGV) GetOptionsFromArray( @ARGV, "constraint=s" =&gt; \@constraints, ... 
Not really. The important thing is the when '"' is encountered, it could mean multiple args enclosed within them.
I assume you see the vague cognitive dissonance between the two positions you're holding? Perhaps you should check out cperl http://perl11.org/cperl has less memory usage with the unicode features being used. Looks like rurban is planning some optimisations for unicode in the future too. Fast signatures with gradual typing looks good. 
&gt; it was clearly incumbent on mdk I do not know that and clearly it is impossible for anyone who wasn't there to begin with to know that because it is impossible to figure out what actually happened which seems to negate the idea of a public apology posted on the conference web site apologizing about some unspecific thing. Brings to mind Yezhov, Kamenev etc. But, then, I stopped going to Perl conferences after schwern made us all stand up &amp; held us responsible for his perceived lack of diversity among Perl conference attendees. I can't remember if Larry stood up with us.
For completeness, OP was cross-posted to https://perlmonks.org/?node_id=1220646
I had thought I deleted that post because I couldn't get the syntax correct. And lo and behold there are answers there too, thanks.
There's no dissonance if you start from the position that Perl 6 is not Perl 5.
haha, it did.
Regarding OOP, there are a few things that come to mind. I have not used objects much, i've avoided using them and used a function to return a hash ref in lieu of full blow objects. here's why * Self should be the default. e.g., implied * Moo &amp; moose are nice, but very heavy on the syntax. for example "has name =&gt; (is =&gt; 'ro');" to make the access methods is a hassle when you want to get the ball rolling on a small program. * returning 1 at the end looks odd. * without a module, the varables I know the above looks picky. However, if we compare to java (which I any many others learned OOP in). It's very compact and neat, no need to refer to documentation to write a class.I appreciate perl does many powerful things. but for a simple object as a placeholder for data, everything seems overkill. I agree pretty much with the blog post for class'. Just having it called class (with curly braces) and self being default on methods would be a massive improvement. 
Moo and Moose are standards sure, but this is Perl, so there are just as many more lightweight options (both featurewise and syntaxwise). For example: [Class::Tiny](https://metacpan.org/pod/Class::Tiny), [Mojo::Base](https://metacpan.org/pod/Mojo::Base), [Mo](https://metacpan.org/pod/Mo), [Mu](https://metacpan.org/pod/Mu), and for something that's not an object class at all but safer than using a plain hashref, [Struct::Dumb](https://metacpan.org/pod/Struct::Dumb).
The apology covered the badge thing clearly. The apology did not cover the lightning talk because the organisers and the speaker all concluded that simply filing it under "didn't work, gone now" was the correct answer. The apology wasn't for you. Live with it. Meanwhile, however, (and I really hope if you downvoted the comment I'm replying to you'll read this and reconsider) I know exactly which talk you're referring to and it was a tone deaf out of touch train wreck that angered basically every member of the audience I spoke to about it afterwards, including those who'd never been to a YAPC before. It even talked about team based development when the rest of the perl community had substantially switched to that for any significantly complex project but he'd not bothered participating for years and in fact two of the most critical projects he maintained only didn't have a team by that point because he was unable to do the things he was telling everybody else to - which most of them were already doing. That and a couple of other related things resulted in all sorts of fascinating consequences, including but not restricted to (1) an anti-code-of-conduct movement suddenly appearing in spite of the fact this was far from the first YAPC to have one but because it had previously been done competently and apolitically nobody had noticed (2) an extended (~18 mo as I remember) running battle across various community forums to get the foaminist fuckwits[0] to shut up for long enough that I could LART the (impressively few) actual shitlords[1] and then get us back on track (3) @GeekRuthie giving a lightning talk spontaneously to talk about how inclusive she'd found the perl community - and I think we can all agree we're better for having her with us since (4) a couple of withdrawals from the following year's YAPC because the community as a whole, while absolutely in favour of everybody being welcome and educating (if possible, and malleting if not) people with foolish prejudices, refused to play the assholes' game (5) I wrote a blog post [2] in the aftermath that got me a *huge* number of responses from people who said "yes, we actually agree with that, we're [not extremist idiots on either side] but really didn't want to have to be part of the Discourse but are very very glad somebody visible said it", which made a nice change from the earlier battles where I kept getting called a misogynist and a radical feminist for the same opinion ;) (note, I'd ask that people don't dredge up further specific details of said situation because it won't gain anybody anything) This situation is not that situation. At all. Providing sufficient details for you to be able to verify that for yourself would, I'm afraid, at least by my judgement, be a cure that would be worse than the disease. But I'd hope that, given my track record of blunt honesty, you can at least believe that I believe my explanation downthread and are willing to consider it at least as a provisional/plausible explanation of what actually happened. -- mst, out. [0] i.e. *not* what I would consider actual feminists, at least not according to my mother's 2nd wave conception that I was raised with. [1] i.e. people sufficiently invested in their stereotype based perception of others that they weren't willing at all to engage with the idea there might be a nuanced understanding that made both their initial interpretation and the foaminists' obviously silly [2] https://shadow.cat/blog/matt-s-trout/on-codifying-conduct/
Suffice to say, words are hard and I believe we do. I'll make sure to let them know.
Please consider extending the same level of consideration to daxim for his current state of anger and upset as mdk and the speaker did to the attendee who brought the situation to their attention.
I understand you, the modules are good. Although, all seem a bit fiddly to get right. However, the out the box OOP is complex and off-putting. Indeed, it seems rarely used. Let me show you an example #!/usr/bin/perl package Student; sub new { my $class = shift; return bless {@_} , $class ; } sub get_name { return shift-&gt;{name}; } 1; then to use the class to make an object use Student; my $sa = Student-&gt;new(name =&gt; "bob", age =&gt; 10 , class=&gt;"A"); Where as, i feel it would be far nicer to keep the syntax the same as we're sued to in regular programming in perl. #!/usr/bin/perl class Student { my ( $name , $age, $class ); sub new { ( $name , $age, $class ) = @_; } sub get_name { return $name; } } To make an object my $sa = Student-&gt;new("bob", 10 , "A"); ##ofcourse here you can make your constructor however you like; a hash for example. I do not know how the compiler works in the background. Many the syntax just is imposable. 
The idea is of course possible; there have been a few attempts at it like [Moops](https://metacpan.org/pod/Moops) and [Dios](https://metacpan.org/pod/Dios) and now [Moxie](https://metacpan.org/pod/Moxie) (and some older ones that use discouraged methods like Devel::Declare or source filters). The main issue is that everyone has different ideas on how the specifics should work, it may seem obvious but there's a lot that isn't.
There are two concepts here, and they're quite separate. Function::Parameters give you signatures, this allows you to write: sub check { my ($x, $y) = @_; ... } as fun check($x, $y) { ... } Newer perl versions have something similar built in. The `declared_refs` feature provides `my \@something = ...` - this is in core perl since 5.26, and is completely separate from signatures - basically you're missing this line: use experimental qw(declared_refs); See https://perldoc.pl/perlref#Declaring-a-Reference-to-a-Variable for details.
Perl 5 should get its own distinctive name. There are plans for Perl 6 to get a new marketing name - Perl 5 should get one too. Checkout: [http://nigelhamilton.com/perl-branding-proposal.html](http://nigelhamilton.com/perl-branding-proposal.html)
I personally am angry to see that talks are being purged from existence simply because some people found it offensive, and no real information is given. What exactly was so offensive that nobody is allowed to see this talk now? How many people complained compared to how many people liked the talk? The first talk at the conference makes snarky remarks at white males, which I considered to be offensive. But I'm not going to call for removal of the first talk. I suck it up and try to be the better person. I can just opt to no longer attend that person's talk, and have conversations with people on how to improve the situation without resorting to censoring their "wrongthink". I've liked the Perl community a lot, and mostly *because* we have been civilized to each other without resorting to banning things for the sake of pleasing a small group of people who just like to complain at everything. We've gotten pretty far without adding ridiculous CoCs that have no positive effects on the community. And that part of the community seems to have crumbled now. That's what upsets me. &gt; it's always been a bunch of white dudes (I can think of three of exceptions). The culture is highly problematic. Knowing that someone is trying something -- you've got a huge barrier to climb before I shit on that effort. I haven't been here for 20 years, but I can safely say that it's a *lot* more welcoming than other communities I've been in to a lot more different people. I've seen plenty of non "white dudes" in my couple years of dealing with the community. But let's zoom in on your remark here, which both has racist and sexist connotations. What is so evil about the "white dudes" you're referring to? Why is it wrong to have white dudes in a community? If you're so bent on being inclusive, it feels odd that you have something against this particular group, which also happens to be the biggest in IT to begin with. It's very strange to come over as demanding that communities forcibly change their demographic to something that does not represent the larger reality around it. How is it "problematic" to have people in your community? Why do you have to make it something both racist and sexist? I thought the whole idea of social justice was to treat people as people, regardless of their skin color or genitals. This is why so many people have issues with your cause: you're hypocrites. You say you want to be inclusive and defeat racism and sexism (and every other -ism), yet you yourself use sexism and racism to not be inclusive of the largest part of the wider IT community. You actively go out of your way to impose harmful documents such as CoCs that offer vague terms which are easily abused to ensure you people can remove the wrongthinkers from the community. And knowing that someone is trying something is not immediately an excuse to praise them. They should try do something good, that will help the community on the long-term. Doing anything doesn't immediately merit praise. And what has transpired at the Perl conference doesn't merit praise in my opinion either. This all said, apart from this one incident, I had a lot of fun at the Perl conference. I would like there to be more such conferences, which I will still gladly attend. I think mdk and the rest of the organisation did their absolute best, and I do want to thank them for that. I'm still going to advocate against silly CoCs like the one implemented at this conference. Additionally, I think all sides would have benefits from a better system to deal with complaints. It is currently not transparent, we just have to believe that many people were gravely offended by something so harmful it can't even be repeated. A transparent system to deal with complaints and see the actual impact, and to get opinions from multiple sides before making aggressive decisions would come a long way.
How do other languages resolve this problem? Do you agree that P6 resolves this problem for P6? What do you make of the prospects of P6 being sometimes used to wrap P5 to combine P6's cleaner overall management of Unicode issues with P5's CPAN modules and speed? (Or, P5 wrapping P6 via Inline::Perl6?)
 #!/usr/bin/env perl my @arr1 = ("A","B","C"); my @arr2 = ("C","B","D"); #convert to hash my %arr1 = map { $_ =&gt; 1 } @arr1; #delete common entries delete($arr1{$_}) for (@arr2); #print remaining entries print join(", ", keys(%arr1)),"\n";
have you looked in Perl Cookbook? :) ```perl my %seen = (); my @aonly = (); # build lookup table foreach $item (@B) { $seen{$item} = 1 } # find only elements in @A and not in @B foreach $item (@A) { unless ($seen{$item}) { # it's not in %seen, so add to @aonly push(@aonly, $item); } } ```
A pretty common perl paradigm is to copy an array into the keys of a hash, since it's trivial to look up hash keys. This only works if your arrays don't have duplicate entries, though. Something like: my @haystack = qw(Alice Bob Charlie Don Ethel); # array to search my @needles = qw(Alice Don); # find these my %needles = map { $_ =&gt; 1 } @needles; # flip to a hash my @not_found = grep { ! $needles{$_} } @haystack; print "$_\n" for @not_found;
See, I tried this too and it only "sort of" works and I can't understand why. my %P1_hosts = map { $_ =&gt; 1 } @P1data; my %P2_hosts = map { $_ =&gt; 1 } @P2data; delete($P1_hosts{$_}) for (@P2data); delete($P2_hosts{$_}) for (@P1data); open FILE, "+&gt;not_in_P1"; print FILE join("", keys(%P2_hosts)),"\n"; close FILE; open FILE, "+&gt;not_in_P2"; print FILE join("", keys(%P1_hosts)),"\n"; close FILE; ...and I end up with a ton of duplicates that appear in both arrays regardless. It makes no sense. 
should work. Are you sure you're talking about exact duplicates (case-sensitivity/whitespace/etc)?
Why do you open with "+&gt;" and not simply "&gt;" ? Also the three term version with open is recommended.
&gt; should work. I agree. Hence my confusion. &gt; Are you sure you're talking about exact duplicates (case-sensitivity/whitespace/etc)? Yep. All names are made uniform before being put into the array and duplicates are stripped from both arrays using the following function: sub uniq { my %seen; grep !$seen{$_}++, @_; } I'm finding the broken entries using the following bash script: for n in `cat not_in_P2` ; do grep $n P2data ; done (where P2data is a straight print of the array)
&gt; Why do you open with "+&gt;" and not simply "&gt;" ? Because if the file does not exist I want it to be created. 
I can change it to &gt; , but this is honestly the least of my worries right now. The syntax you provided looks wrong, as well. Extra quotes. 
&gt; Opening the file read/write could possibly have some side effects, if you did multiple runs in the same directory. &gt; &gt; This is why I suggested to try with this syntax. I agree with other posters that the logic seems OK, so it would be useful to check if the problem is somewhere else. Changed to the following: open FILE, "&gt;", "not_in_ossec"; print FILE join("", keys(%tanium_hosts)),"\n"; close FILE; open FILE, "&gt;", "not_in_tanium"; print FILE join("", keys(%ossec_hosts)),"\n"; close FILE; The results behavior is unchanged. 
&gt; This smells like Unicode issues. Here's the weird part... I can run the script two times, one directly after another, and the problematic results are *different every time*. $ ./ot-report.pl Analyzing 53341 hosts... Done. $ for n in `cat not_in_P2` ; do grep $n P2data ; done nopintr1 w3pvap1140 w3pvap1142 w3pvap1145 w3pvap1146 w3pvap1147 w3pvap1148 ^C $ ./ot-report.pl Analyzing 53341 hosts... Done. $ for n in `cat not_in_P2` ; do grep $n P2data ; done n1pvap1040 n1pvap1042 n1pvap1043 n1pvap1047 n1pvap1048 n1pvap1049 ^C^C The source files are completely static. This makes no damn sense at all. 
Can you try `grep --color` and/or `grep -w` instead of just grep? The way you're doing it, if (e.g.) '1' is in `not_in_Px`, you'll match anything that has a `1` in it. grep -w will do exact matches, grep --color will show you if this is the problem. Also, I have a longtime habit of never using plain `keys`; I always use `sort keys %x`. Consistency, ease of reading results, etc.
&gt; Can you try grep --color and/or grep -w instead of just grep? The way you're doing it, if (e.g.) '1' is in not_in_Px, you'll match anything that has a 1 in it. grep -w will do exact matches, grep --color will show you if this is the problem. Okay now this is eye-opening... using --color I'm starting to see the problem and the solution. Your assumption is correct; it's grabbing partial matches. I'll have to poke more at this. In the meantime, **thank you**. &gt; Also, I have a longtime habit of never using plain keys; I always use sort keys %x. Consistency, ease of reading results, etc. Yeah shortly after I responded before, I figured it was throwing the keys in random order. Using "sort" fixed that part. 
(1) Evan is a massive troll who mostly socially imploded out of the perl community by annoying almost every channel on irc.perl.org into banning him, then evading the bans, then blaming me when I k-lined him for evading them. You can safely ignore the 'problematic' claims from him. (2) You, yourself, are part of a known freenode trolling group whose members have been responsible for all sorts of stupid shit, and love the 3edgy5me stuff to the point where #perl6 had to point out to you that it wasn't appropriate to upload a distribution with a 'perl6-n*gg*er' directory in it to CPAN. So you're no more a good arbiter of what is/isn't going to offend people than I was when I was your age, though I wouldn't be surprised if your social skills are *slightly* better than mine were back then overall. (3) These codes of conduct have been in place for years, as I already said elsethread. You just didn't notice because, usually, CoC stuff gets resolved quietly and without the need for a public statement. This time it did require a public statement. Please recalibrate your outrage based on the fact that our CoCs have been enforced sufficiently non-ridiculously that UNTIL NOW YOU DIDN'T EVEN NOTICE THEY EXISTED. (4) "you people" and "wrongthinkers" makes you sound like a 70 year old racist grandpa shouting at a cloud - fainting couch histrionics aren't constructive when the far-left soi-disant feminist idiots do it, and they aren't constructive when you do it either. It was fine. It wasn't an incursion by the evil taking-offence-because-we-can brigade, they might be your boogeyman but I've fought the real thing and won. This wasn't it. Chill, dude. It'll all work out in the end.
Indeed, the fact that it seems superfluous to you is precisely why I said it wasn't for you. I'm not sure which part of that wasn't clear. Also, more people read comments than the person whose comment I'm replying to - I was asking *other* people who had read *your* comment to consider not downvoting you until they'd read the context. Newsflash: Not everything is about you. -- mst
Questions like this come up all the time from people new to both Perl and file manipulation. It seems like a reasonable if minimal article to me.
&gt; (1) Evan is a massive troll who mostly socially imploded out of the perl community by annoying almost every channel on irc.perl.org into banning him, then evading the bans, then blaming me when I k-lined him for evading them. You can safely ignore the 'problematic' claims from him. I don't think I've *ever* been banned from a channel by anyone except a Shadowcat employee. I still consider *most* of the perl users my friends, that aren't you or your friends. BTW, isn't DVK the guy at the center of all this drama a shadowcat employee? It is an unfortunate reality that you've squirmed your way into running perl's IRC (which is largely a result of the language being so dead no one else cares to foot the bill). And subsequently you seeing it as a place to plaster your consultancy's name. And, if I'm a massive troll that "imploded" your claim to fame was to hostilely take over a project (Catalyst) and piss off *most* every one of the original developers into never talking to you again. Moreover, they're so sick of the drama that you and your cohesive cohort of cantankerous cranks brings that now Mojo doesn't use external dependencies -- an almost laughable notion for a Perl before you started to sour the scene. As for your skills vs the skills of others, Sri starts both -- you take over Catalyst and Sri starts something new and makes it three times popular. Mojo is my go to in perl, simply because it lacks you. Anyway, I've moved on. =) And, Perl is still dying, and you still haven't explained the K-line except to say "I don't like you." And, yes, I did exactly what Sri did after the K-line. I just stopped talking to you and forked modules that weren't on GitHub. This is how *most* of the Perl users that I know work around you.
&gt; The first talk at the conference makes snarky remarks at white males, which I considered to be offensive. Glad to know the first talk was a rousing success and did what needed to be done.
"cohesive cohort of cantankerous cranks" is fantastic. The rest of your post is merely fantasy. I'm glad you're enjoying Mojo, though; it's been really good fun for me both as a user and because it's given me the opportunity to work with sri on insane bugs again. The core team are all fun to drink with too - I recommend you try it sometime, I'm sure you can find a conference they're at and I'm not if you're still so triggered by my existence. -- mst
Strings? - populate ah ash with the names as the hash keys - with grep, check if the name is in the hash. It's very little code. For example: my %A; $A{$_} = 1 foreach(@A); my @diff = grep !$A{$_}, @B; my @intersect = grep grep $A{$_}, @B; Now @intersect will contain the names that exist in both, and @diff those names only in @B. p.s. I use the same name for the hash and one array. I like that because it shows the connection between the two data structures. Some people get really confused by that. 
Last conference I was at in 07' was a bunch of a fun. Everyone was shit talking you.
Interesting to see how it's "doing what needed to be done" when it's insulting one group, but deeply offensive when it's another group.
&gt; (1) Sure, I don't know the guy, but that could be true, I guess. &gt; (2) What "freenode trolling group" would this be, exactly? I'm pretty sure I'm not in any freenode channel that is actively advocating for trolling. Also, you need to drop your grudges against me for a mistake I made, which you are now also rewording completely as to be completely inaccurate of the truth. If you want to make a point, you'd do well to start with being honest. &gt; (3) Interesting use of full caps to make a very non-interesting point. I did indeed not notice them, however, now they're being used incorrectly, so now I do and now I talk about them. Just because a rule has been there for a while without making trouble doesn't mean we should accept it forever after it has shown to be susceptible to abuse. That's just oversimplified and short-sighted at best. &gt; (4) Nice work on the ad-hominems. Feel free to start a constructive discussion if you can attack my points instead of my inferred character. &gt; Chill, dude. It'll all work out in the end. Maybe it will, maybe it won't. From semi-recent developments all over the IT industry, it seems like it won't work out in the end. As such, I will do my best to make sure it doesn't go the wrong way.
Very clever indeed.
And minimal articles are often the best. Judging by some of the remarks, the title of the post would probably have been better without the question mark.
Others have presented great solutions already, but I just want to note that [List::Util](https://perldoc.pl/List::Util) does come with stock Perl and may be helpful. Also, the reason `!/$name/` may not have worked is that this does not account for regex metacharacters that $name may contain; you wanted `!/\Q$name/`. [details on \Q](https://perldoc.pl/perlrebackslash#Modifiers)
&gt; more people read comments than the person whose comment I'm replying to Similarly, more people read public apologies than just the person who took offense.
Yes. That's why it was a good thing.
I am clearly not sophisticated enough.
&gt; In the TIOBE Index, R has tumbled from 18th to 15th place over the past year unless you're holding that index upside down, I'd suggest "tumbled" is perhaps not quite the right term.
Didn't COBOL die 40 years ago? I'm over here supporting users in HPC running Fortran. Isn't is supposed to be dead too?
And they have the R statistical language in the number one place on the doomed list... I've been looking at R lately, and there are some remarkably similarities with perl-- it's got a really strong programming community with a lot of really useful libraries, a lot of new development, and some of ti's libraries are arguably some of the best things of they're kind ever written (notably the ggplot2 data plotting package). I can't imagine why the programming world would want to abandon all of this and re-write it from scratch... it's almost as though it were dominated by irrational trend-chasing teenagers or something. 
*checks the calendar* Yep, another "these languages are all going to die real soon now ^(tm) - we really mean it this time!" article, same as there is pretty much every month. Must have been a slow news day.
Two words: repeating prejudice.
Doomed! DOOMED!! But on a serious note: Perl is fun and all, but it's Python that has been paying my bills for the last 16 years.
&gt; Other than the edgelordish tendencies I'm sure you'll grow out of, we're basically on the same side so far as I can see. Can't say I expect to convince you of that, but stated for the record anyway. Yes, I've known that since last Friday. I did read your stance on the issue already, even before I got into this thread. Don't forget I'm also on irc.perl.org. If you could do away with the condescending tones for a single discussion, people (including me) would be much more willing to take you serious. I don't know why you try to keep conversations aggressive, but it's not helping out anyone in the long run. Just like you realized, we're basically on the same side. It would help us both if we could discuss things like adults, without resorting to petty remarks.
I figured COBOL and Fortran was like the House Greyjoys words _What is dead may never die._
as a hardworking programmer .....mhhhhh
Perl has been paying my bills the last 18 years. Learning is continually and my stuff continues to improve. And it's fun. I can honestly say that I love what I do.
I think that for some types of programs, in particular those processing arrays of numbers, programs in Fortran run circles around the same programs wriien in C.
if you ever have to build numpy ‚Äî that's Python's numerical library, much beloved of the current ‚ÄòAI‚Äô crowd ‚Äî you'll see a bunch of 40+ year-old Fortran being compiled into the library. You can't beat the speed ‚Ä¶
All the comments here are laughing about the fact that people have been predicting the death of Perl for years. No, I don‚Äôt think it will ever truly die. But good luck hiring Perl developers, or trying to convince other developers to join your company and learn Perl. I‚Äôm in that position now and it‚Äôs an incredibly tedious process.
Fun stuff. AFAIK Groovy is the only langue with [built in functionality](http://groovy-lang.org/grape.html) for this. 
&gt; I‚Äôm in that position now and it‚Äôs an incredibly tedious process. Who are you? Are you active in any perl communities? Do people know you're hiring? Have you reached out to some of the authors of the modules you use? Have you posted to jobs.perl.org or careers.stackoverflow.com? I've been programming in Perl professionally for over 20 years and virtually every job I've ever had has been through word of mouth.
We‚Äôre a major news website in the UK. I‚Äôm not active in any Perl communities. We have job ads everywhere and get a steady stream of applicants, but they‚Äôre often too junior. It seems to be hard to find good devs in the UK right now. We advertise for devs who have OOP experience in any language. We don‚Äôt make much of the fact that we use Perl in the job ads though. Maybe we should? We ask people pretty early on if people are willing to learn Perl on the job and a lot of people back out after that, basically due to Perl‚Äôs reputation as a dying language - or if not dying, then at least old fashioned.
Interesting. What level were they? We‚Äôre looking for more senior folks (due to us having a small team and complex, large scale system) and a lot of people object to learning Perl. To be fair, a lot of people are also fine with it, but they rarely get past out small JavaScript-based coding exercise. Do you know how many applicants you had to sift through to find those four?
&gt; We‚Äôre a major news website in the UK. I‚Äôm not active in any Perl communities. Come to this year's London Perl Workshop and advertise the fact that you're hiring either through word of mouth or by giving a talk and mentioning it. You'll have access to over 100 Perl developers, many of which are very experienced and at the senior level. &gt; We ask people pretty early on if people are willing to learn Perl on the job and a lot of people back out after that, basically due to Perl‚Äôs reputation as a dying language - or if not dying, then at least old fashioned. Then you need to look at hiring juniors and training them, as they don't come with preconceptions about Perl.
Senior (unclear what qualifies as such) would probably not be as keen on new languages as their younger counterpart I would imagine. Of these four, two of them had 5+ years in other languages and two were fresh out of university. They are rather quickly becoming productive as well (it helps that we try to be less of a unicorn and CI/CD removes any tooling burden). &gt;Do you know how many applicants you had to sift through to find those four? This is in Norway, so things may be very different from other places. The response has varied from 20 to 50 applicants, however far too many of these are not relevant at all. We go out with a very wide net and see what is out there. 
You might want to put up an advert here too [https://jobs.perl.org/](https://jobs.perl.org/) That's where I picked up my last job involving Perl. 
Thanks for the insight, very useful.
dont send an email unless the network is available so under the while() but before the email::send, run a network check to see if there is network connectivity. Then if the email does die, catch that and attempt again.
easy way, just wrap it in a looping shell script that reruns the job until it exits normally.
For reliable email delivery I would usually use a local mail server like postfix and deliver to it. It will retry emails until they send for free. If resources are scarce you could use something like https://metacpan.org/pod/Retry which makes it easier to retry with back off periods etc. I've never used it myself, but seems sensible.
Dynamic variables and lexical scope are different. A dynamic change to a filehandle persists through any function calls in that scope, this is the effect of `local`. A lexical effect only applies to that scope as you see it in the file, and pragmas tend to have lexical effects to avoid affecting things not in that file.
Using Net::Ping, you think?
Hey, that ought to work.
In the past, I have had delivery issues with email originating from a residential IP address.
I wish I could find a perl dev job.
&gt;Net::Ping Yeah that would work. 
I used code I found at [StackOverflow](https://stackoverflow.com/questions/14875298/how-to-check-the-presence-of-the-internet-connection-in-perl) to accomplish this in concept. Thanks for getting me pointed in the right direction.
I used code I found at [StackOverflow](https://stackoverflow.com/questions/14875298/how-to-check-the-presence-of-the-internet-connection-in-perl) to accomplish this in concept. Thanks for getting me pointed in the right direction.
Thanks. I think I'm back on track now.
awesome
The local server would handle queuing and retrying, but typically you would configure to deliver through a "smart host". See https://www.linode.com/docs/email/postfix/configure-postfix-to-send-mail-using-gmail-and-google-apps-on-debian-or-ubuntu/ for example.
I write that verbose stuff, maybe even more enterprisey than shown. But it's easy to read and not necessarily slower to write, and by God it's reliable that way. I guess I'm saying that the fact that my code isn't elegant in the minimalist sense doesn't limit me in any way. It's not like most of my time is taken up by typing.
&gt; But good luck hiring Perl developers, or trying to convince other developers to join your company and learn Perl. This. Speaking of my own experience based on work done both in the US and Norway; it's close to impossible to get (good) Perl developers these days. Unfortunately. :(
Wanna move to Oslo, Norway? :)
You actually can have function signatures with gradual typing via Function::Parameters and Type::Tiny. ``` use 5.014; use warnings; BEGIN { package My::Types { no thanks; # inline a package but can still "use" it. use Type::Library -base, -declare =&gt; qw(NonNegativeInt); use Type::Utils -all; use Types::Standard qw(Int); declare NonNegativeInt, as Int-&gt;where( sub { $_ &gt;= 0 } ); } } use Function::Parameters; use My::Types qw(NonNegativeInt); fun fib( NonNegativeInt $nth ) { return $nth if $nth &lt;= 1; return fib( $nth - 1 ) + fib( $nth - 2 ); } package Cache::LRU { use Moo; use Hash::Ordered; use Types::Standard qw(Str); use My::Types qw(NonNegativeInt); has _x =&gt; ( is =&gt; 'ro', default =&gt; sub { Hash::Ordered-&gt;new } ); has max_size =&gt; ( is =&gt; 'ro', isa =&gt; NonNegativeInt, default =&gt; 20 ); method set( Str $key, $value ) { if ( $self-&gt;_x-&gt;exists($key) ) { $self-&gt;_x-&gt;delete($key); } elsif ( $self-&gt;_x-&gt;keys &gt; $self-&gt;max_size ) { $self-&gt;_x-&gt;shift; } $self-&gt;_x-&gt;set( $key, $value ); } method get( Str $key) { return unless $self-&gt;_x-&gt;exists($key); return $self-&gt;_x-&gt;set( $key, $self-&gt;_x-&gt;delete($key) ); } } ``` 
 croak("‚Ä¶") if $nth !~ /^+?\d+$/a; This line is an abomination. This is obviously meant to check whether the argument is a unsigned integer. To check that it stringifies it and launches a broken regex on it. Doesn't it bother you that this gets posted in a post about making core better? Shouldn't something so basic have a better way to do regardless of function signatures? If you use Scalar::Util::looks_like_number, that also recognizes floats and Inf and ignores get magic. I'd expect the code to check "int($nth) &gt; 0" instead, but the subtle difference here is that the above code tries to check what the argument *is*, whereas my code only checks the implications of using it as a number. It's very easy in Perl to use a value as something but it's extremely hard to figure out what it *is*. This isn't the first time that pops up. There was the same problem with the utf flag in strings, the same problem with the identity of arguments in smart match, the same problem with auto-deref of tied arrays and hashed. It's not even clear whether an IOK/POK scalar was originally a string or a number. Typed signatures are meant to catch programming errors. But checking whether something can be used as an unsigned integer isn't even remotely the same. For every proposed implementation here and on perlmonks, give the fibonacci sub a ref. If it accepts it (because: a ref works fantastically as a uint), the type system won't do it's job.
Although Curtis wants to focus on the aspects besides the actual computation of Fibonacci numbers, I spent a lot of time in [Mastering Perl](https://www.masteringperl.org/) showing that you don't need recursion to do this problem. You only ever see it in a recursive form because we rely on other language compilers to not actually do what we literally typed out. Module maintenance and architecture complexity is the biggest problem I see with the big companies I work with. They end up writing a lot more code in many more files to support the frameworks and OO systems they decide to use. Once they commit, they are stuck in that for years and people grow to hate it. Since they are writing more code (like the big Moose example he shows at the end), there's many more opportunities for bugs. There's not any particular way that will win in every circumstances, but every approach is going to have drawbacks. It's up to the people managing the enterprise (not the programmers necessarily!) to decide between those drawbacks, but only if we make them plain. 
The Perl websites have indeed brought a designer on board, perhaps it could have happened sooner: https://www.perl.org/. C bindings are also great now with [libffi support](https://metacpan.org/pod/FFI::Platypus) (and [NativeCall](https://metacpan.org/pod/NativeCall) sugar) like P6 uses; making people learn Perl internals in order to write XS was and still is a huge hurdle as you mention (though it's necessary for other endeavors unrelated to external libs). The main problem internally is the lack of designers of another kind: [language design](https://www.nntp.perl.org/group/perl.perl5.porters/2017/12/msg248481.html).
Dispatch tables have many uses, but this sort of use where you're explicitly only using a specific element of it is just adding misdirection that makes it 10 times as hard for anyone to understand the code. Just use strings when you need strings, or use [constants](https://perldoc.pl/constant) if you want typo checking.
I am not talking about websites on Perl, most of which are still ugly .. I am talking about websites built by Perl. The way ruby bought designers on-board was via libraries like sass. PHP the same way by giving them marketplaces via Wordpress. Because of that you have tons of good looking websites on PHP and Ruby, and people naturally wanted to imitate the stack of good looking websites. If you make Perl[5,6] a perfect language and expect designers, undergrads and others to come you are terribly mistaken. You might think embedability is a joke but if you look at all the IOT stuff you will find tons JavaScript heavily used. 
Hmm. What about remote work?
Good points, well put. Perl really is a favorite to punch down on it seems. Is it because it's always competing for a bottom slot on "most popular languages," or are some people that experience it's "sprawling" nature really just reacting negatively to its multipurpose application? Seems like every dev has to have a favorite language to argue about these days, and being a jack of all trades doesnt make Perl win any "my favorite thing is the best because ____" contests.
What senior-level anything objects to learning something new?
Don't tell that to, like, every corporate bank that exists.
People like to reassure themselves that they've "chosen" the correct language(s) for all possible tasks, and so put down others, and Perl is an easy target that's cool to hate on, because everyone's seen the worst of it. Whereas in Perl communities it seems more common to be perfectly happy suggesting someone use python, R, bash, whatever is the most appropriate tool for the task at hand.
## $a{ $_ } = $b-&gt;{ $_ } if $_ ~~ keys %$c; ‚Äã
`if exists %$c{$_}`, maybe?
They're just placeholders for the actual variable names. And thanks! I'll give that a shot.
It would be `$$c{$_}` more commonly written as `$c-&gt;{$_}`.
Doh, I should know better. Fixed.
Ah, that makes sense. I'll avoid that next time.
I think it might be cleaner if you detect which implementation is available and import it into your package all within the `BEGIN` block. For your fallback implementation, you can use something like: *any = \&amp;_fallback__any; Doing all the sub binding in `BEGIN` means the sub doesn't need to do those tests each time it is called. You can still re-export whichever sub ended up blind to `any`.
You could use [List::Util::MaybeXS](https://metacpan.org/pod/List::Util::MaybeXS) to automatically use the core List::Util version or a pure-perl fallback, since it's pure-perl itself it can be [fatpacked](https://metacpan.org/pod/App::FatPacker) so you don't need to install it, if that helps. Just make sure you are not relying on the contents of `@_` within the any block, as pureperl implementations will treat it differently.
I don't really disagree. But Sass is a very ironic example given its been entirely rewritten in Dart obsoleting the Ruby implementation entirely... and no one cares, because its just a cli component in any stack.
lol .. dart ! I didn't know about that !! Probably google pushing it. I find it fascinating how Javascript solved Parrot VM's goal of interchangeable languages with trasnpilers and peg / bison grammars. And now it has strong typing like Java with all the horror that it entails. Perl6 seems so beautiful. Waiting for brian's book to be out. That butterfly sure is creepy. I really liked the raptor logo perl5 had sometime back. Goddammit Wall, not everything has to fit your whimsy. 
Not an option, unfortunately.
Just looking at the code, we don't know what that's supposed to do. That's why people want to remove the feature. What are you trying to do? Smartmatching against the result of `keys` likely won't work. That's the number of keys in the hash. This only works if you happen to have a key that is also the count of the keys. Perhaps you meant to smartwatch against the hash itself: $a{ $_ } = $b-&gt;{ $_ } if $_ ~~ %$c; But here's the trick. We don't know what that will do until we know what `$_` is. It's not as simple as checking for the existence of the value of `$_`. The intent of the programmer who wrote that might have been that, but someone else might be using other features of smart matching. * What if a regex reference is in `$_`? It finds all keys that match that regex. Then the key in `$b` is the stringified regex and you don't know which value it will have because multiple matches are all using the same key. * What if `$_` is an array reference? It's the same thing with something like `ARRAY(0x7fcee9800708)` as the key. * What if `$_` is an array reference with regex reference items? 
OK, I'll bite. Why do these posts come with lower-case roman numerals in parentheses?
&gt; There is is no scope entry/exit code in the code block of the 'if' if it holds a single statement/expression Oh, you're right. I had actually checked it (through `-MO=Concise`), but I failed to notice that the `scope` op had been skipped. I notice that brian d foy has updated his article. &gt; There is is no scope entry/exit code in the code block of the 'if' if it holds a single statement/expression It would have to depend on the type of expression. Something like a `local` assignment (which would be dumb on its own, but whatever), ends up with an `enter`/`leave` pair.
Although I am happy Perl is keeping up, honestly, does anyone think that moving from 26 letters to thousands of ideograms is a good idea? Anything past smiley-face, I read as "blob" -- it's impossible to tell what most of those "emoji" things are supposed to mean. I was recently informed that what I thought was the "One dollar" "emoji" was supposed to mean "perfect" -- huh? It clearly says 1.00 I have started to receive text-messages on my flip-phone that just read, blob blob blob blob. Then I have to call the sender to ask what the heck all the blobs mean. Why not just write a real message? /r/ForgetUnicodeBringBackHollerith
I wonder why people down voted this?
The first in a series of many
Sorry, maybe I should use ‚ÄúRexify‚Äù or ‚ÄúR(?)ex‚Äù ...
Same thought here!
The same reason I find it awesome. Sigils and TIMTOWTDI. 
Yeah, it's a great language. Read Rexx too.
Same can be said for PHP. Python came along later and you didn't have a billion script kiddies posting miles of useless crap online so it didn't immediately get a rep as "junk".
"There is more than one way to do it" is the hallmark of the intelligent/experienced/creative. Imagine telling budding new artists that there's only one way to paint a portrait using one set of paints and one type of canvas and doing every stroke in one particular order. Oh, sure, you painted a portrait. But that would rob the best and brilliant of all they could achieve. It would stifle true creativity. And it would make the difficult jobs impossible due to rigidity - imagine being unable to paint the [Sistine Chapel](https://en.wikipedia.org/wiki/Sistine_Chapel) because it was the wrong kind of canvas. The truth is that programming is being offered to more and more people - as a result what is being taught has to be dumbed down for the average person. Even companies like Google need for their very average staff to script. Hence languages like Python. Twenty years ago companies needed the best and brightest and most passionate technology staff. Now they just need the cheapest. Ignore Perl if you want; but you don't do so because you want to use the most flexible and powerful scripting languages - you do so because you need the simplest.
PHP has some issues that continue to make it pretty bad, though, issues that Perl was able to overcome. Poor consistency in libraries and lack of a strict mode (variables-without-declaration just begs for bugs-by-typo; default global scope is a crime) immediately come to mind. I have the pleasure of working in Perl daily, and the displeasure of working in PHP from time to time. The differences are glaring.
Perl was the first language I learned. I love it. It is a great first language.
The beginning of the Worldwide Web started a coding boom. I'm not talking about the beginning of the Internet, which started long before. I'm talking about the mid-1990s. Perl was there and ready for this boom. PHP was not, Python was not. No other simple, non-complied language that you might name was there, except JavaScript, and JavaScript's only domain was inside the browser. So Perl was really the only option accessible to people who didn't already have a background in programming. People like me. So I'll take some responsibility for this. Though I'm proud of the code I write today, I was certainly writing pretty crappy code over 20 years ago, when I first started writing code. I was also learning from people who weren't writing great code. However, a lot of that crappy code that we wrote did its job pretty well, at least for a time. And so that code sat around and did its job. All the while, it was becoming "legacy code." So, generation after generation of programmers came along and had to deal with this "legacy code." A lot of the oldest stuff was written in Perl. They complained about it, as programmers do. These complaints snowballed into something bigger than all the beautiful code in the world could ever cover up. So you can certainly write elegant code today in Perl. And you can still do things in Perl that you can't do nearly as elegantly in other languages. But the world doesn't care. They hate Perl.
&gt; by sysadmins without using OOP, and was illegible garbage... There's plenty of illegible OOP garbage. 
Perl is great, but the biggest portion of software development is maintenance. Unless you write Java/C in Perl (which you should _never_ do), it can be difficult to go back to code written months and years ago and comprehend it at a very basic level. E.g., without understanding business logic/context. Exporting, strictness, warnings and compile time/runtime behavior can be confusing and make it hard to develop bulletproof code. JavaScript is a bit like this but it powers the platform of the 21st century so... 
In every popular object system on CPAN, the getter and setter for attributes is the attribute name by default, so it's expected if you're using an object that you'll use the method of the same name to access an attribute. The `_set_$attr` style writer comes from [MooseX::AttributeShortcuts](https://metacpan.org/pod/MooseX::AttributeShortcuts#is-=%3E-'rwp') or Moo (which has the 'rwp' attribute type by default). It's a convention where you will be setting the attribute internally, but outside code shouldn't be setting it. There's nothing *stopping* any code from using the setter, but the leading underscore is a convention for private methods and the 'some_attr' method no longer allows setting the attribute, so in that sense it's a hidden setter, and leaves the attribute read-only from the outside.
What Grinnz said, also note that in the code you have posted both accessors styles will be generated. Typically if one is making a private accessor (using `writer` explicitly) then you‚Äôd want to set `is =&gt; ‚Äòro‚Äô` so that the public accessor will die if passed a value.
I've been saying this since the first GUIs with icons for menus in the early 90's; 5000 years of progress and we are right back where we started with hieroglyphics.
&gt; Do you need developers or do you need chair-stuffers making the office looks rockstar-busy to the investors? No need to take that tone; we have no investors, but we depend heavily on having our developers onsite. Our teams' performance would be severely hampered by having developers all around the world and trying to tie them together. We have tried outsourcing jobs, and it was a terrible experience.
"Dark PAN" is a name that used to be used for any proprietary code-base that was set-up to use the CPAN tool-chain. It behaves like CPAN, but you it's not generally accessible. 
 I can see why the writer style would be a good convention. Thanks! 
There's also "greypan", which is publicly accessible, but published outside the cpan infrastructure, resulting in a codebase that is factually public, but functionally non existent from the perspective of CPAN, as things can't really depend on it, and subsequently doesn't get b subjected to multi Arch testing with every release, and critical breakage is likely to go unnoticed until too late. Hence, it's a darkpan that doesn't immediately appear "dark", but functions with most of the downsides of a darkpan
&gt;You're very likely right. I feel we can't spare the resources to train juniors right now, so a more pragmatic approach might be to move away from perl entirely. You may want to consider the arguments Curtis Poe gave at The Perl Conference in Glasgow a short while ago. He talks quite informatively about several common issues to consider when looking an older codebase and thinking about reimplementing it in another language. [https://youtu.be/KrGSg7uVZj0?t=5h35m40s](https://youtu.be/KrGSg7uVZj0?t=5h35m40s) &amp;#x200B; &gt;The Perl workshop thing might be fun, thanks for the suggestion. It's very fun, but more importantly, it offers you a way to get to know the people in the community that your software depends on. You'll both meet core devs and CPAN authors there, and chances are that some of them have written code that your business daily depends on. I can't underline enough how beneficial it can be to have a positive relationship with the Open Source communities the business depends on, so I would strongly suggest that you consider upgrading LPW from "might be fun" to "we really, REALLY, need to be there". :) Don't get me wrong though ‚Äì It \*is\* fun too. :)
&gt;This. Speaking of my own experience based on work done both in the US and Norway; it's close to impossible to get (good) Perl developers these days. Unfortunately. :( Have you had any contact with the Perl communities (meetups or Perl mongers) when looking for people? Those often have quite a good network of friends &amp; former colleagues that you could reach...
Do you mean like stuff on GitHub?
What stuff on github? 
Github, sure, but also source forge, Gnu.org, etc. For example: GNU Autotools/Autoconf uses Perl substantially, and is widely used in OpenSource, but due to not being on *CPAN*, it doesn't attract being tested as routine against developmental versions of Perl. This means that when Perl makes a change that breaks Auto*, it won't be until Perl *ships* ( or is nearing shipping ) that people will know Autoconf is broken, which will mean there's little to no scope for avoiding breaking it. Greypan software is extra useful here, for another reason: It demonstrates that the argument about "stuff on darkpan could break", is not merely a strawman, but a reality. NB: Autotools being broken by perl changes actually happened, and late-cycle changes had to be made to Perl to avoid breakage, the "oh, consumers can fix their code" argument just isn't helpful when the consumer is both so widespread, and important, and yet, potentially have a stagnant release process.
I took precisely the tone I meant to take. The last sentence in your answer underscores the very problem I posit you have: in your book if they are are not sitting in a designated are - you are outsourcing to them. Changing the stack will not fix this ( though, yes, it will **mask** the root cause pretty well )
&gt; But the world doesn't care. They hate Perl. Hate? More like ignore, I think. But I think you have the history right. Perl was once among the best choices for web development, which expanded its position from "improved unix scripting language" to "the forefront of the whole web boom". But it couldn't last: it had too much legacy, it was too difficult to write, it was too hard to deploy. Competitors such as PHP sprung up and basically ate the whole space by being simpler to write and easier to deploy. Perl's fade from popularity into the background is partly a return to normalcy, but partly it's also about being competed by Python, Go, and similar languages in its old niche. I'm expecting Perl to lose out to these competitors, though it will go slowly.
Maybe try '-e' instead of '-f'. That should check for actual existence.
Side note: you almost never want -f as that excludes non-files that can be used as files ( eg: devices, sockets ) For that you want !-d So you really want -e and !-d Also, try logging the value of "$! $?" After the -f call and see if it contains anything interesting.
Totally random idea: is this app running in some kind chroot or similar?
Post a sample of the log output with filenames included.
I meant mostly modules that are hosted on GitHub, but not published on CPAN. 
Yes, there are lots of people ignoring Perl, or who don't even know about it. But I'm talking about [the people who hate it specifically](https://www.google.com/search?q=perl+hated+language).
I just tried that on a Mac and a CentOS 7 host, both worked correctly. A couple things. First, you've got a DOS line break in the log entry in the else clause, but no line breaks in the one in the then clause. That makes me wonder if you're on a Windows system. Is that the case? And can you post example paths?
In that case, yes. Modules published on github.
Yeah, try to examine the actual return code of the test. My guess is you don't have permissions to access the file to even run the test. IS the file owned by root, but you are not root?
If there is an error it should return undef which should have failed the above check anyway. I'm guessing there's an additional factor at play.
Crazy question. Is it printing "file1 exists"? If not, then that block of code isn't being reached
No. If there's a problem to get a Perl developer _on site_, it actually means that there's a shortage of Perl developers. Us hiring/outsourcing Perl developers doesn't create more Perl developers. I think you are looking at the problem from the wrong end: why do you think there are few Perl developers?
Yes, but - of course - all the developers already have a job. It's _impossible_ to find new ones. :(
That's the idea I was going for. I called it crazy because OP hadn't specifically mentioned that behavior and the other responses seemed to assume that the test was failing, rather than not being executed at all. 
It's the count of the post, since these are posted weekly. This is the 199th such post.
What's $file_path1?
You can check the return values of the chown() and chmod() calls, or "use autodie;" to automatically raise an exception if they return an error. Also remember that you can't always change ownership of a file if you're not root -- and you shouldn't be running your Mojo app as root, for security reasons.
&gt; croak("‚Ä¶") if $nth !~ /\^+?\d+$/a; &gt; This line is an abomination. This is obviously meant to check whether the argument is a unsigned integer. To check that it stringifies it and launches a broken regex on it. &gt; &gt; Doesn't it bother you that this gets posted in a post about making core better? When someone as comfortable at Perl as I am does something like that, it perfectly reinforces my point. Thanks for the support. &gt; Typed signatures are meant to catch programming errors. But checking whether something can be used as an unsigned integer isn't even remotely the same. For every proposed implementation here and on perlmonks, give the fibonacci sub a ref. If it accepts it (because: a ref works fantastically as a uint), the type system won't do its job. Which is why there needs to be serious discussion as to its implementation. Should `fib("12")` be allowed or not? Saying we can't solve this problem is throwing in the towel and that's not acceptable.
&gt; You actually can have function signatures with gradual typing via Function::Parameters and Type::Tiny. They're not core to the language, which is my point.
&gt; you can't always change ownership of a file if you're not root More accurately: the only situations where you can change the ownership of a file are 1) your process is running as root or 2) your process has the CAP_CHOWN capability (which is root-equivalent). In practice: `chown` requires root.
I've added an asynchronous API now using Mojo::Promise. For backends that don't support async, it still provides a promises API, it just doesn't happen async. Thanks for the idea!
Reading from `&lt;STDIN&gt;` includes the newline. `chomp $x;` to remove it.
Why can't my instructor explain this? Goddam waste of time 2 hour lecture Thank you
One of the main problems with $language classes is that they are being taught by people that don't know $language.
He is a smart and accomplished instructor. I just do not like his teaching style at all. It's all over the place. Slides are rarely followed and he hacks up a terminal half way through and gets side tracked.
So a bad teacher *and* a bad programmer? If you can't focus on what you're trying to teach, you're gonna just confuse the fuck out of your students. This may not be *his* first time doing this, but if he's expecting ya'll to keep up with his scatter-brained process, he's not doing you any favours. 
the XPAN (where X != "C") are usually misnomers because they refer to a single archive site, whereas CPAN is a *network*.
I am trying to wrap my head around $x += 1/$_ for 1..50_000_000; Could somebody explain to somebody non fluent with Perl?
Perhaps this is more readable? for 1 .. 50_000_000 -&gt; $divider { $x = $x + 1 / $divider }
Note that there are multiple shortcuts for appending newlines to output. Here's one: local $\ = "\n"; print "4"; print "5"; output: 4 5 And another that works in more recent perl versions: use v5.20.0; say "4"; say "5"; output: 4 5 Enjoy! 
If you are going to do this, write the new data to a new filename. There's an [answer in perlfaq5](https://perldoc.perl.org/perlfaq5.html#How-do-I-change%2c-delete%2c-or-insert-a-line-in-a-file%2c-or-append-to-the-beginning-of-a-file%3f), for example. I also cover this in [The Effective Perler](https://www.effectiveperlprogramming.com/) when I covered [tmpnam's removal in v5.26](https://www.effectiveperlprogramming.com/2017/09/dont-use-posix-to-create-temporary-files/). Here's the FAQ answer: open my $in, '&lt;', $file or die "Can't read old file: $!"; open my $out, '&gt;', "$file.new" or die "Can't write new file: $!"; while( &lt;$in&gt; ) { print $out $_; } close $out; Futhermore, don't read in the entire file at once. Perl Maven shows: local $/ = undef; # turn on "slurp mode" my $content = &lt;$in&gt;; That might work in situations where the data are small, but I've heard plenty of people say that and later end up using it for very large files. It's easy to avoid that situation and not code this bad example. 
I dislike perl in the sense that the syntax is implicit not explicit. The documentation at times is a bridge between very well done, and "hasnt been touched in years, and the last guy who wrote docs wrote them like a robot". When documentation is on par, the language is a blast. Otherwise it isn't too bad. I'm enjoying re-learning it coming from C++, PHP, and Python currently. It is just a language that doesn't seem to abide by what I'd expect from any other language. Even Ruby and Java felt more standard than perl does.
How does that quote go? "Those that can, do...something, something."
I'd try this, it might work: my $response = $mg-&gt;send( { to =&gt; $email, etc... } ); print $response;
I did that and its returning a hash: HASH(0x2847340) 
Cool. So now maybe try: print $response{"message"};
Data::Dumper is your friend
Thank you, now it is clear. Perl has a wonderfully succint syntax. Very nice.
You have been in contact with them, really? Have you for example showed up at an actual Perl meetup and talked about this with the people there? Nothing "impossible" there, but it \*does\* require some effort. 1. Actually tell people *in person* that you need them. Show up and talk with them. 2. Show that your company is a desirable place to work (build a good reputation, offer competitive pay), and give your community a reason to help you find your next colleague. If you're invisible in the community, you're just making the hiring job difficult for yourself. 3. If you still can't find people, consider training new ones. While it's not as convenient as just posting something on [finn.no](https://finn.no), this is not rocket science. You just have to bother working with your Open Source communities a little instead of going the lazy route, pressing submit buttons on some website.
I do quite a bit at the command line using \`perl -lane\`.
I wrote an [altogether far longer version](https://www.perl.com/pub/2004/08/09/commandline.html/) of this for [perl.com](https://perl.com) back in 2004.
q and qq with -e/-E are incredibly useful and often forgotten. But note that `perl -n -E 'say if /code/'` will emit the newline from the input as well as an extra blank line.
That is a face with tears of joy? On my screen it looks like a flying saucer, or a medicine ball with handles. p.s., Looked up "twitch" on Wikipedia and still not sure what it is (watch someone else play a gratuitous-gun-violence game? huh?); and while Perl is perfectly good reading, it's Twits that are the modern line noise.
You forgot `-M`: /tmp &gt;perl -MData::Dump -E'dd {a =&gt; 123, b =&gt; 456}' { a =&gt; 123, b =&gt; 456 } /tmp &gt;perl -MData::Dump=ddx -E'ddx {a =&gt; 123, b =&gt; 456}' # -e:1: { a =&gt; 123, b =&gt; 456 } Though `ddx` is exported by default so... 
How‚Äôs SQLeet compare to sqlcipher?
FWIW, I'd say it'd have to be a mini CPAN. To me half the point is being able to install in-house code using cpanm, carton, and the like.
I find [ojo](https://metacpan.org/pod/ojo) pretty inspirational in its power of making complex problems into simple oneliners.
That depends on context; if you're just writing oneliners yes, but if you're debugging problems in larger programs, version and configuration will likely be more relevant.
You should really submit these as links rather than text posts.
Summary: * sqleet is based on the ChaCha20 cipher (https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant) * sqleet does not depend on encryption libraries and implements the encryption algorithm by itself Detailed comparison by the author of sqleet: https://github.com/resilar/sqleet/issues/12
Thanks for treating me like an idiot. Fortunately, I have better things to do in life than having to deal with passive-aggressive people like you. Have a nice life.
Please don't post images of code. One of the best way to help you in cases like this is to run the code ourselves and with an image we'd have to retype it all - which, obviously, makes it less likely that someone will help you. &amp;#x200B; Code is text. So it's far more sensible to copy the text into your question.
To add to this you can also capture directly without using $1. `my ($var) = $line =~ / ([0-9][0-9]) [a-zA-Z]/;`
I've been thinking about adding Perl to my list of languages for a while. Is this book worth getting?
You're wrongly assuming hostile intent. I'm not treating you like an idiot ‚Äì I'm treating you like someone who publicly shares something wrong and after polite feedback insists on repeating their error. So when you wrongly claim something is "impossible", the polite reply is to spell out how things can be made possible. I don't think you're an idiot, but i *do* suspect you're being disingenuous when claiming that you have had contact with any Perl meetups etc. I'd love to be proven wrong on this account though.
Is this for your work?
Ah, I'll take a look at this when I get home. Missing $ infront of ARGV (line \~6) I need it to be in Perl because I'll be doing more post-processing, and possibly pre-processing, which I can all leave in one script file Thanks for the help, I'll report back to see if it works
This sounds like homework, so I'll merely point to what look look up in the docs, for example on [perldoc.perl.org](http://perldoc.perl.org/): * &gt; takes in a file name as its first argument `@ARGV` (though that may be unnecessary with `&lt;&gt;`) * &gt; a text file Again, `&lt;FILEHANDLE&gt;` where FILEHANDLE is a name you give your filehandle. without one perl will read from STDIN, or if that is empty, it'll use up the first argument in `@ARGV`, try to open it as a file (`$ARGV`) and read from it (`ARGV`). See also perlrun, probably. * &gt; space-delimited, and reads the third column, `split` although you could use `-F` as a command line option, see perlrun * &gt; basically making a hash table of all unique values that occur. The common idiom for that has already been addressed in other replies. * &gt; Also, they would then be listed in alphabetical order. `sort` * &gt; The pair would correspond to a numeric value but I can figure that out. I think you best use regular expressions, see perlretut, and use something involving `/\d+/` or `/[0-9]+/` * &gt; The rest is something I can do (such as: converting all to lowercase, `lc` * &gt; deleting trailing "G" if present (which is a code we use externally). `s/G$//` &gt; I heard CPAN can help me with this, but I'm just not quite sure where to look Frankly, these requirements seem all so simple that you can do each with a single Perl expression or construct, so using a module and passing the proper arguments to them involves more work than doing them in plain Perl.
&gt; Greypan software is extra useful here, for another reason: It demonstrates that the argument about "stuff on darkpan could break", is not merely a strawman, but a reality. 
What, no `-n` or `-p`? `-a` Is only an extension of those, and it used to not enable them by default. In those days you *had* to use `-n`or `-p`, or nothing would happen.
If you feel for it, please refer me to available Perl developers in Oslo or Trondheim, Norway. If not, shut up and keep living in a world where there are Perl developers everywhere.
[Gabor had already covered -n and -p in his article](https://perlmaven.com/perl-command-line-options) so I didn't repeat them. 
You should be able to do that with just unix commands. cat FILENAME | cut -f3 -d' ' | sed 's/G$//g' | sort | uniq
 # Always use these use strict; use warnings; # Turn on say() use feature 'say'; # To store the data (terrible name for a # variable!) my %data; # Read through any files passed on the command # one line at a time while (&lt;&gt;) { # Get the 3rd space-delimited field. # Note: split splits on whitespace by default my $field = (split)[2]; # Do any other transformations you need # on $field. $field = lc $field; $field =~ s/G$//; # Store $field in %data $data{$field} = 1; } # Print the keys from %data, sorted say for sort keys %data;
&gt; I just need the dates to appear in MM/DD/YYYY format. I don't need the extra data in the cell. Well, the easy solution is to split on a space and throw away the back half, like this: `my ( $date ) = split /\s+/, $source_sheet-&gt;{Cells}[$row_index][$col_index]` I would tend to plan ahead, though, because programs often have larger and longer lives than any plans for. I would pull in the DateTime module and use the value to create new objects. The you can reformat the date into any format you wish.
Because I‚Äôm too dumb to understand functional programming - Me
Same here. I read that article and felt like, "wait, isn't the computer's job to do the boring stuff correctly for us?" I guess Haskell is a challenge. That doesn't make me want to use it in production. I guess you improve your coding skills. However you're perfecting Twinkle Twinkle on a harp when you can already play that on piano and guitar.
Yeah, seemed to be an huge amount of time spent on an incredibly trivial problem.
`04/23/2018` 18.58 a becoming `MM/23/2018 18.04 a` makes me think there is something wrong with either the formatting code of the spreadsheet, or with the way `Spreadsheet::ParseExcel` parses that format. I would guess that it's seeing `mm` (lowercase) meaning "minutes" and interpreting it as "months", hence `18.04`, and not understanding the `MM` (months) and just rendering it as literal characters. I don't *think* `MM` (uppercase) is actually valid as an Excel date format, but I don't have Excel handy to check, since I'm on a Linux box. According to [this doc](https://support.office.com/en-us/article/format-a-date-the-way-you-want-8e10019e-d5d8-47a1-ba95-db95123d273e): &gt;If you‚Äôre modifying a format that includes time values, and you use "m" immediately after the "h" or "hh" code or immediately before the "ss" code, Excel displays minutes instead of the month. It sounds like `Spreadsheet::ParseExcel` isn't aware of this rule, or has a bug in it's implementation. If you are able to modify the actual spreadsheet, maybe you could try fixing the date formatting codes. If that's not an option, you could have your script detect those cells, and manually format them - see https://metacpan.org/pod/Spreadsheet::ParseExcel::Cell#Dates-and-Time-in-Excel (basically, get the `-&gt;unformatted()` cell contents, convert it to a DateTime object with [DateTime::Format::Excel](https://metacpan.org/pod/DateTime::Format::Excel), and finally use `strftime()` or `format_cldr()` to turn it into a "MM/DD/YYYY" string)
So GopherCon is about Go-the-programming-language. Kinda disappointing. I hoped it would be about Gopher-the-protocol. And I'm only half kidding.
Port 70. Never forget.
Once you learn the concepts, it's surprising how often you encounter them. Monoids are just things that have a binary operator and an identity element, for example lists, by concat'ing them with an empty list, or numbers via multiplication and the number 1, Functors are things that can be `map`ped over (lists are another good example). Monads are monoids in the category of functors.
Meh. Gopher was a terrible protocol. Nostalgia is all it has going for it.
I dont know bash but i know perl....so tell me what this code is doing...then .i'll write the code here 
I've taken some liberties here. The Bash doesn't use a named variable for the filename. And I've opened a filehandle to write to the file. But this is functionally equivalent, I think. #!/usr/bin/perl use strict; use warnings; my ($counter, $max, $file) = @ARGV; $max++; open my $fh, '&gt;&gt;', $file or die $!; while ($counter &gt; $max) { print $fh $counter++; }
I meaning the following to be taken as light-hearted silliness. Please ignore if you're only interested in serious stuff. It's ironic that you responded to "I encounter a mental block anytime I read or hear the terms monad, monoid, or functor" by using those words five times in a short reply that's loaded with jargon. :) &gt; Once you learn the concepts, it's surprising how often you encounter them. I've gotta say it's surprising how often you encounter them even if you haven't learned them and don't want to; or haven't but do want to learn them; or have learned them and then lost the plot again even though they're really trivial; or have learned them and then lost the plot again because they're not really trivial; or don't know if you've learned them or not because there's a big difference between learning that, on the one hand, there being a God is a trivial concept and, on the other, figuring out what that means and how to react to the fact it's simultaneously irrelevant to understanding anything that's not circularly defined as dependent on God yet seems to be fundamental to discussing understanding of anything with most people alive today. (My apologies to God and atheists alike for making a simple subject more complicated than it needs to be.) To what degree would you say the following is an essentially equivalent explanation to yours, or too weak, or just plain wrong? * Assume there can be multiple things of the same sort kept in a collection. Eg a bag of colored spheres. * Assume there's a transparent sphere that can be combined with any ball in such a bag to yield the latter ball unchanged. * Assume some of these bags of balls allow people to do a particular thing with each ball in the bag to produce another bag of balls. Bingo. Or no?
Don't you want $counter &lt; $max?
You're right. Thanks. Fixed.
Here's your bash file. You should see [www.shellcheck.net](https://www.shellcheck.net) if you are learning bash - great resource. #!/bin/bash # Need error checks on these # to make sure they are numeric. Also, upper case # is traditionally reserved for values in the environment # passed to multiple scripts. Locals use lowercase. declare counter=$1 declare max=$2 # Don't use $n multiple times in a program. # If you rearrange args, you have to do many edits. declare file=$3 # Why? 'max' isn't max enough? A comment explaining # this would do wonders, even in a throwaway script. ((max+=1)) # If you do not want to create a new file each time, # the '&gt;&gt;' will append to the existing file, and create # it the first time if wanted. # If your intent is to re-init each time, then you use # echo -n &gt; "$file" # which will echo zero characters (-n means no newline) # into the file and using '&gt;' will create it anew if it exists. touch "$file" while (( counter &gt; max)) do echo "$counter" &gt;&gt; "$file" ((counter+=1)) done &amp;#x200B;
Webperl (the thing that this is written on top of) is beautiful and an abomination if I ever saw one. +1 from me.
Yeah, then how do you explain it's runaway success today? Oh...
It would also append a newline after each count.
Useful but *really* needs a makeover. Not just to make it prettier, but to make it easier to understand.
Other notes: [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) is what you want to use, not Syntax::Feature::Try, despite the name similarity they are very different. You can use [Devel::Confess](https://metacpan.org/pod/Devel::Confess) to cause all exceptions to be thrown with a stacktrace (via Carp), though this is normally only used in debugging because it can surprise modules that expect certain error strings (and of course is more verbose than some may want). Throwable is just a role, but Throwable::Error is an exception object that uses StackTrace::Auto to include stacktraces via Devel::StackTrace. Also see [Throwable::SugarFactory](https://metacpan.org/pod/Throwable::SugarFactory) for a Throwable interface more similar to Exception::Class.
Switched to using `say()`.
I've managed to sort this out, for anybody who stumbles across this with the same question I used Dependency Walker (depends.exe) and managed to find out that the following DLL's needed to be included with the -l C:\\path\\to\\dll\\file.dll arguments: \- C:\\pperl\\c\\bin\\libcrypto-1\_1-x64\_\_.dll \- C:\\pperl\\c\\bin\\zlib1\_\_.dll \-C:\\pperl\\c\\bin\\libssl-1\_1-x64\_\_.dll
What does line 85 look like? And it‚Äôs probably only a non-fatal warning.
In the code snippet I posted line 85 is in the middle and reads "0 and q r". I didn't build this module, simply installed it via "cpanm WWW::Scripter" which includes CSS::DOM::Interface. Whether it's a fatal warning or not unfortunately the packaged executable does not proceed past this error.
It really does read "0 and q r", doesn't it? Very confusing.
File a "feature" on cpan. Give your perl version. It installed so it passed its tests.
This seems like some sort of hacky attempt to get the source code to show up in POD. There's no universe where this is a good idea.
The shell variables $1, $2,... are found in Perl as $ARGV[0], $ARGV[1], etc. Yes, they're indexed starting at zero. So it looks like you want to append the numbers from $1 to $2 to the file $3, one per line. Here's how I'd do that in Perl. There's no error-checking to make sure the numbers are numbers, or that the first is less than the second. #!/usr/bin/env perl use 5.010; use warnings; use strict; open my $out, '&gt;&gt;', $ARGV[2] or die $!; say $out $_ for ($ARGV[0]..$ARGV[1]); 
That will remove that no-op "statement" as well as prevent the following code from being parsed as pod (and thus removed by pp) so that should work fine.
Hi @bart2019, thank you for pointing ppm. However i found it missing many cpan modules. Only a few i could install using ppm. 
I searched through the subreddit but couldn't find the same video posted. So hopefully its not a duplicate.
Don't have time to watch the whole video, but starting with strawberry perl, perlbrew, and use strict+use warnings is a good start. The switch feature not so much.
Where does it talk about references?
TL;DR: The author is incapable of keeping focus. A working code snippet is literally in the first half of the article, the rest is just trying to generalize for no reason whatsoever.
The code as you have given it won't compile. I'm assuming you have the `/` and `\` at the start the wrong way round and you actually mean: $line =~ /\$([0-9])/ or die; The outer `/ ... /` isn't part of the regex. It's the match operator. It's the bit of Perl syntax that means "match the pattern between these two characters". As you say, the `\` is there to remove the special meaning from (we call it "escaping") characters. In a regex, a `$` means "the end of the string", so having the `\` there removes the special meaning and makes it just match a dollar sign. The parentheses (round brackets) are there to "capture" a section of the matched string. Your pattern matches a dollar sign, followed by a digit from `0` to `9`. And the digit is "captured". That means that once the pattern has been matched, the digit will be available in a variable called `$1`. Typically, you'd use that in code like: my $digit; if ($line =~ /\$([0-9)/) { $digit = $1; } Your `or die` has a similar effect, so you could write: $line =~ /\$([0-9])/ or die; my $digit = $1; You can have multiple sets of capturing parentheses in a regex. The text captured from the first set goes into `$1`, the text captured from the second set goes into `$2`, and so on. Your second example also uses capturing parentheses. $line =~ /"(.*)"/ This says "look for something (or nothing!) between two double-quote characters and put the string found into `$1`".
The code as you have given it won't compile. I'm assuming you have the `/` and `\` at the start the wrong way round and you actually mean: $line =~ /\$([0-9])/ or die; The outer `/ ... /` isn't part of the regex. It's the match operator. It's the bit of Perl syntax that means "match the pattern between these two characters". As you say, the `\` is there to remove the special meaning from (we call it "escaping") characters. In a regex, a `$` means "the end of the string", so having the `\` there removes the special meaning and makes it just match a dollar sign. The parentheses (round brackets) are there to "capture" a section of the matched string. Your pattern matches a dollar sign, followed by a digit from `0` to `9`. And the digit is "captured". That means that once the pattern has been matched, the digit will be available in a variable called `$1`. Typically, you'd use that in code like: my $digit; if ($line =~ /\$([0-9)/) { $digit = $1; } Your `or die` has a similar effect, so you could write: $line =~ /\$([0-9])/ or die; my $digit = $1; You can have multiple sets of capturing parentheses in a regex. The text captured from the first set goes into `$1`, the text captured from the second set goes into `$2`, and so on. Your second example also uses capturing parentheses. $line =~ /"(.*)"/ This says "look for something (or nothing!) between two double-quote characters and put the string found into `$1`".
The code as you have given it won't compile. I'm assuming you have the `/` and `\` at the start the wrong way round and you actually mean: $line =~ /\$([0-9])/ or die; The outer `/ ... /` isn't part of the regex. It's the match operator. It's the bit of Perl syntax that means "match the pattern between these two characters". As you say, the `\` is there to remove the special meaning from (we call it "escaping") characters. In a regex, a `$` means "the end of the string", so having the `\` there removes the special meaning and makes it just match a dollar sign. The parentheses (round brackets) are there to "capture" a section of the matched string. Your pattern matches a dollar sign, followed by a digit from `0` to `9`. And the digit is "captured". That means that once the pattern has been matched, the digit will be available in a variable called `$1`. Typically, you'd use that in code like: my $digit; if ($line =~ /\$([0-9)/) { $digit = $1; } Your `or die` has a similar effect, so you could write: $line =~ /\$([0-9])/ or die; my $digit = $1; You can have multiple sets of capturing parentheses in a regex. The text captured from the first set goes into `$1`, the text captured from the second set goes into `$2`, and so on. Your second example also uses capturing parentheses. $line =~ /"(.*)"/ This says "look for something (or nothing!) between two double-quote characters and put the string found into `$1`".
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from 0 to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
The code as you have given it won't compile. I'm assuming you have the \`/\` and \`\\\` at the start the wrong way round and you actually mean: &amp;#x200B; $line =\~ /\\$(\[0-9\])/ or die; &amp;#x200B; The outer \`/ ... /\` isn't part of the regex. It's the match operator. It's the bit of Perl syntax that means "match the pattern between these two characters". &amp;#x200B; As you say, the \`\\\` is there to remove the special meaning from (we call it "escaping") characters. In a regex, a \`$\` means "the end of the string", so having the \`\\\` there removes the special meaning and makes it just match a dollar sign. &amp;#x200B; The parentheses (round brackets) are there to "capture" a section of the matched string. Your pattern matches a dollar sign, followed by a digit from \`0\` to \`9\`. And the digit is "captured". That means that once the pattern has been matched, the digit will be available in a variable called \`$1\`. Typically, you'd use that in code like: &amp;#x200B; my $digit; if ($line =\~ /\\$(\[0-9)/) { $digit = $1; } &amp;#x200B; Your \`or die\` has a similar effect, so you could write: &amp;#x200B; $line =\~ /\\$(\[0-9\])/ or die; my $digit = $1; &amp;#x200B; You can have multiple sets of capturing parentheses in a regex. The text captured from the first set goes into \`$1\`, the text captured from the second set goes into \`$2\`, and so on. &amp;#x200B; Your second example also uses capturing parentheses. &amp;#x200B; $line =\~ /"(.\*)"/ &amp;#x200B; This says "look for something (or nothing!) between two double-quote characters and put the string found into \`$1\`".
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 &gt;but why is there another one at the end and in the beginning, but reversed? This looks like a mistake. It's not *syntactically* invalid, but it's unlikely to do what the programmer wanted. (You *can* take a reference to the result of a match, then use that reference itself as a regex... but it's rather nonsensical.) Are you sure you just didn't transcribe that correctly? &gt;Also, I am not sure why there is a circle bracket inside a square bracket Um, they're *outside* the square brackets. &gt;I read something about grouping So parentheses (round brackets or "circle brackets" as you call them) have a few purposes. First, yes, they *group* parts of the regex. For instance, in: /prefix(a|b|c)suffix/ the alternation is only between the sub-regexes inside the parentheses. They also mean a quantifier like `*` or `+` can act on more than one token: /(abc)+/ matches a sequence of one or more "abc" strings. They also *capture* the portion of the string being matched. You can get the results of captured through Perl's `$1`, `$2` etc. variables, or by performing a match in list context: ($key, $value) = /^(.+?)=(.*)$/ Finally, parentheses are part of the syntax for all sorts of extra regex features. As just one example, you can create a *non-capturing* group with `(?:...)`. 
 &gt;but why is there another one at the end and in the beginning, but reversed? This looks like a mistake. It's not *syntactically* invalid, but it's unlikely to do what the programmer wanted. (You *can* take a reference to the result of a match, then use that reference itself as a regex... but it's rather nonsensical.) Are you sure you just didn't transcribe that correctly? &gt;Also, I am not sure why there is a circle bracket inside a square bracket Um, they're *outside* the square brackets. &gt;I read something about grouping So parentheses (round brackets or "circle brackets" as you call them) have a few purposes. First, yes, they *group* parts of the regex. For instance, in: /prefix(a|b|c)suffix/ the alternation is only between the sub-regexes inside the parentheses. They also mean a quantifier like `*` or `+` can act on more than one token: /(abc)+/ matches a sequence of one or more "abc" strings. They also *capture* the portion of the string being matched. You can get the results of captured through Perl's `$1`, `$2` etc. variables, or by performing a match in list context: ($key, $value) = /^(.+?)=(.*)$/ Finally, parentheses are part of the syntax for all sorts of extra regex features. As just one example, you can create a *non-capturing* group with `(?:...)`. 
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 $line =~ \/$([0-9])/ or die; That doesn't look right. Did you copy it from a working script? I'm going to assume that you or someone else messed it up and it's supposed to be $line =~ /\$([0-9])/ Ignoring the "or die" part, this basically means "the variable $line contains a dollar sign, followed by a number, and I want to keep the number in the variable $1". To break it down: $ means literally a dollar sign, but we put a slash before it, otherwise it has a special meaning [0-9] the characters from zero to nine (all the digits in other words) ([0-9]) wrapping the parentheses around the previous thing means "and keep them in a variable". The variable will be $1 because there's nothing else being kept. $line =~ /"(.*)"/ This means "quote, absolutely anything or even zero things (except linebreaks), then another quote". This is a rather na√Øve regex because of what it does when it matches on this string: "let's go to the pub" she said, "I need a beer" Hope this helps.
 &gt;but why is there another one at the end and in the beginning, but reversed? This looks like a mistake. It's not *syntactically* invalid, but it's unlikely to do what the programmer wanted. (You *can* take a reference to the result of a match, then use that reference itself as a regex... but it's rather nonsensical.) Are you sure you just didn't transcribe that correctly? &gt;Also, I am not sure why there is a circle bracket inside a square bracket Um, they're *outside* the square brackets. &gt;I read something about grouping So parentheses (round brackets or "circle brackets" as you call them) have a few purposes. First, yes, they *group* parts of the regex. For instance, in: /prefix(a|b|c)suffix/ the alternation is only between the sub-regexes inside the parentheses. They also mean a quantifier like `*` or `+` can act on more than one token: /(abc)+/ matches a sequence of one or more "abc" strings. They also *capture* the portion of the string being matched. You can get the results of captured through Perl's `$1`, `$2` etc. variables, or by performing a match in list context: ($key, $value) = /^(.+?)=(.*)$/ Finally, parentheses are part of the syntax for all sorts of extra regex features. As just one example, you can create a *non-capturing* group with `(?:...)`. 
The code as you have given it won't compile. I'm assuming you have the `/` and `\` at the start the wrong way round and you actually mean: $line =~ /\$([0-9])/ or die; The outer `/ ... /` isn't part of the regex. It's the match operator. It's the bit of Perl syntax that means "match the pattern between these two characters". As you say, the `\` is there to remove the special meaning from (we call it "escaping") characters. In a regex, a `$` means "the end of the string", so having the `\` there removes the special meaning and makes it just match a dollar sign. The parentheses (round brackets) are there to "capture" a section of the matched string. Your pattern matches a dollar sign, followed by a digit from `0` to `9`. And the digit is "captured". That means that once the pattern has been matched, the digit will be available in a variable called `$1`. Typically, you'd use that in code like: my $digit; if ($line =~ /\$([0-9)/) { $digit = $1; } Your `or die` has a similar effect, so you could write: $line =~ /\$([0-9])/ or die; my $digit = $1; You can have multiple sets of capturing parentheses in a regex. The text captured from the first set goes into `$1`, the text captured from the second set goes into `$2`, and so on. Your second example also uses capturing parentheses. $line =~ /"(.*)"/ This says "look for something (or nothing!) between two double-quote characters and put the string found into `$1`".
The code as you have given it won't compile. I'm assuming you have the `/` and `\` at the start the wrong way round and you actually mean: $line =~ /\$([0-9])/ or die; The outer `/ ... /` isn't part of the regex. It's the match operator. It's the bit of Perl syntax that means "match the pattern between these two characters". As you say, the `\` is there to remove the special meaning from (we call it "escaping") characters. In a regex, a `$` means "the end of the string", so having the `\` there removes the special meaning and makes it just match a dollar sign. The parentheses (round brackets) are there to "capture" a section of the matched string. Your pattern matches a dollar sign, followed by a digit from `0` to `9`. And the digit is "captured". That means that once the pattern has been matched, the digit will be available in a variable called `$1`. Typically, you'd use that in code like: my $digit; if ($line =~ /\$([0-9)/) { $digit = $1; } Your `or die` has a similar effect, so you could write: $line =~ /\$([0-9])/ or die; my $digit = $1; You can have multiple sets of capturing parentheses in a regex. The text captured from the first set goes into `$1`, the text captured from the second set goes into `$2`, and so on. Your second example also uses capturing parentheses. $line =~ /"(.*)"/ This says "look for something (or nothing!) between two double-quote characters and put the string found into `$1`".
 &gt;but why is there another one at the end and in the beginning, but reversed? This looks like a mistake. It's not *syntactically* invalid, but it's unlikely to do what the programmer wanted. (You *can* take a reference to the result of a match, then use that reference itself as a regex... but it's rather nonsensical.) Are you sure you just didn't transcribe that correctly? &gt;Also, I am not sure why there is a circle bracket inside a square bracket Um, they're *outside* the square brackets. &gt;I read something about grouping So parentheses (round brackets or "circle brackets" as you call them) have a few purposes. First, yes, they *group* parts of the regex. For instance, in: /prefix(a|b|c)suffix/ the alternation is only between the sub-regexes inside the parentheses. They also mean a quantifier like `*` or `+` can act on more than one token: /(abc)+/ matches a sequence of one or more "abc" strings. They also *capture* the portion of the string being matched. You can get the results of captured through Perl's `$1`, `$2` etc. variables, or by performing a match in list context: ($key, $value) = /^(.+?)=(.*)$/ Finally, parentheses are part of the syntax for all sorts of extra regex features. As just one example, you can create a *non-capturing* group with `(?:...)`. 
No. Now you have two problems. Use one of the html parsing modules.
I don't think I'm allowed to do so. Could you still explain what this is, it'd be great to know anyways.
I am not familiar with regular expressions. I am currently watching a video on them. The goal is to extract movie names and show times from the html file.
Out of curiosity, how does one get into a situation where one gets exposed to Perl for two days and then a test comes? Vague question, vague answer: https://stackoverflow.com/search?q=user%3A46395+%22Web%3A%3AQuery%22 
Haha! It's a job interview, the test is meant to be done in perl, and so I had to get as much information as I could. Thanks!
There's a gotcha in the second example. Unless there are only two quotes in the text the regex is examining, you're probably going to get more in $1 than you wanted. As it's written, it will capture everything between the first and last double-quote characters it finds. If you want only what's between the first two double-quote characters, use /"(.*?)"/
In that case, the correct answer would be "well, something along the lines of a regex if I'm in a pinch. But the correct way of doing it is to use a module"
Hi. What do you need the answer for? (For work, play, school, self-education, ...?) Perl 5: $_ = 'Tom tom tom boy'; print $count = () = /tom/gi; # 3 The `g` tells the regex engine to match `g`lobally (as many matches as there are in the string, not just one). The `i` tells it to `i`gnore case. The `()` establishes a plural context for assigning the result of the match. It's like saying "these match" instead of "this match". In plural context the match engine returns three matches, "Tom", "tom", "tom" rather than one match "Tomtomtom". The `$count` establishes singular context for assigning the list of three strings. In singular context a list becomes its length. ---- Perl 6: $_ = 'Tom tom tom boy'; print +m:g:i/tom/; The `m` means "match". You have to use it if you want to specify regex adverbs. The `:g` and `:i` are regex adverbs, the Perl 6 equivalent of the `g` and `i` in the Perl 5 above. Given those adverbs, the match engine returns a list of matches. The `+` coerces its right hand side to a number. If it's a list, the result is its length.
Thanks for the detailed answer Raiph )). For now only self education and in the near future simple scripts that would help me go through large amounts of big data and sort them out using bash. Cheers!
You're welcome. :) You'll find you're more likely to get useful feedback when you post questions like yours on reddit if you put a bit more effort into letting folk know where you're coming from. I think you've gotten downvotes without comment because you asked a basic question without saying what you'd done to try figure out the answer yourself nor why you needed to know. I saw sincere gratitude and genuine effort to figure things out in your prior posting but folk usually won't bother to find out. Someone posted a Perl basics video in this sub a few days ago. Try watching it; if it's too simple for you after a few minutes then skip it but if you're learning, stick with it because it's fast paced while super clear and done by someone who clearly knows both Perl and how to do a presentation. Perl 6 is a different language with some similarities. If you're interested in exploring it a little, visit /r/perl6. The latter is unusually friendly. :)
Thanks I'll check it out! On a BTW notice, I have tried playing a bit with the silly example and noticed I can also achieve the answer by doing the following: for (s/tom//gi) {print $_,"\n"}; #prints 3 I understand this is not the way to write code, but as I'm new to all this, I'm trying to figure out how all this works. I did expect the above example to print out 'boy' and omit everything else. Was wondering if you can explain this one. Next thing I would like to do is find the end of the line in a text and split it so that each new line would be displayed as a paragraph. If you can direct me how to get it done (no need to show the solution), I'll be grateful. Cheers.
From [the documentation](http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators) for `s`: &gt; Searches a string for a pattern, and if found, replaces that pattern with the replacement text and returns the number of substitutions made. Otherwise it returns false (specifically, the empty string).
&gt; Was wondering if you can explain `for (s/tom//gi) {print $_,"\n"}; #prints 3`. `s///` returns the number of matches it made. You could just write `print s/tom//gi, "\n";` But it changes `$_`. That's why I didn't suggest it; it makes sense if you know Perl but would just add more surprises if you don't. For an explanation of such things as your splitter task, google for perl one-liners, eg https://gist.github.com/joyrexus/7328094, http://www.rexegg.com/regex-perl-one-liners.html, http://www.catonmat.net/blog/introduction-to-perl-one-liners/, https://code-maven.com/slides/perl-programming/oneliner-process-csv-file, etc. There are loads of great tutorials: http://perl-tutorial.org/
I wonder why reddit thinks there are 32 comments on this post? 
You were right Raiph)) what took me a few hours in the morning took me less than 3 minutes in the evening. Thanks for the help and the references! I am now about to install apache and dive into CGI in order to automate some of the tasks I perform manually today. Cheers!
&gt; You were right Raiph Er, about what? &gt; I am now about to install apache and dive into CGI in order to automate some of the tasks I perform manually today. That sounds exciting, empowering, and productive. :) Will the apache and CGI stuff be on the public web? If so, it will get attacked and you need to learn about that or be OK with the consequences of the server it's on getting hacked. It's nothing to be fearful of, more like something to just know is the way things are.
A closure are a bit more than a sub reference; they know about variables that have gone out of scope: sub make_counter { my $n = shift // 0; sub { $n++ } } my $counter1 = make_counter( 9 ); my $counter2 = make_counter( -5 ); say $counter1-&gt;(); # 9 say $counter1-&gt;(); # 10 say $counter2-&gt;(); # -5 But, as you say, these are quite nice. I write quite a bit about them in [Mastering Perl](https://www.masteringperl.org/) and [Effective Perl Programming](https://www.effectiveperlprogramming.com).
Thank you
 (echo 'pear'; echo 'mellon'; echo 'apple'; echo 'banana') | \ perl -nlE 'push @words, $_; END { say for sort @words }' apple banana mellon pear There are other ways to do this that are simpler, but I think that this illustrates the general form of the sort of thing you want to do best. 
I thought it was just me... 
&gt; alphabetize strings When you find that [`sort`](http://p3rl.org/sort) does not work correctly, use [`sort` from Unicode::Collate](http://p3rl.org/Unicode::Collate#Methods-for-Collation) instead.
Try not to depend directly on numeric comparisons. Advice for what to use in specific software ecosystems varies. General advice can be found here: https://semver.org/ Perl has a built in feature for dealing with version strings. http://perldoc.perl.org/perldata.html#Version-Strings It maps dotted sequences into character ordinals that can be compared as strings. It is the feature used by `use` and `requre` and can be helpful at times if you are playing perl golf.
Semver has many known issues; I recommend getting as far away from that "spec" as you can. Everything else you said is wrong, for Perl, as well.
Yep. It's unfortunate that Perl has this trap, but it's been that way since Perl 5.001, so we may as well learn to live with it.
[Test::Warnings](https://metacpan.org/pod/Test::Warnings) is a better all-around option for this task.
FYI, the module in question has had first-come permissions transferred to [DUFFEE](https://metacpan.org/author/DUFFEE), though they have not done a release and it seems the permissions for the other modules in the distribution were missed in this transfer. https://cpanmeta.grinnz.com/perms#~Boost::Graph 
 push @aryFuncs, $funcName; push @aryFuncs, $funcCmnt; can be shortened to push @aryFuncs, $funcName, $funcCmnt;
You can mail to the authors via cpan.org, mail gets forwarded to thair real address.
A large majority of cpan authors do not have forwarding enabled or have it misconfigured, so it is a much better bet to first see if they specify a contact address in metadata, pod, or their metacpan page. Also sending to their cpan.org address can't hurt though.
Why's that?
You don't want to use regexes to extract data from arbitrary HTML. http://htmlparsing.com/regexes.html
It's a drop-in replacement for Test::NoWarnings that works with the very commonly used done_testing method of planning tests, and also provides functions for testing warnings output similar to Test::Warn.
Huh, interesting. For me, neither of those are a win. Thanks.
Ah yes, I remember reading your post and thought it was great. Adding a link to it on my post. Thanks. &gt; You can use semver with that form, it just looks like x.yyzz instead of x.yy.zz Yeah, but this is a whole new trap on its own :-)
I'm not sure if I'm interpreting the question right, but as a start use [MetaCPAN::Pod::XHTML](https://metacpan.org/pod/MetaCPAN::Pod::XHTML) which is a Pod::Simple::XHTML subclass used by metacpan (and also perldoc.pl). You may need to configure the WithLinkMappings role and look at other processing metacpan does like stripping disallowed HTML tags. Then you'd need the CSS and JS that metacpan uses to apply to that. The [pod renderer](https://metacpan.org/pod2html) tool on metacpan also lets you preview how metacpan would render pod.
I'm a bit confused. You're the maintainer of pod2html but you're asking for advice on how to do the HTML part? But anyway, what's the context/use case for this. How is it going to be viewed? On disk, online? The main task would be figuring out how to do the CSS. Normally CSS is served up from a URL via separate HTTP request.
Sorry for the confusion. I wrote *podtohtml*, which I upload to CPAN inside the App-podtohtml distribution. It is a wrapper for *pod2html*, the standard tool that comes along with core perl. So they're two separate things. Not very creative, I know. I want to see (preview) how my POD would look like if rendered on MetaCPAN, without having to upload to PAUSE first. Yup, this means mostly linking to the appropriate CSS and JS to make the plain HTML produced by pod2html look like it would on MetaCPAN.
OK I get it. Seems like you've got your answer anyway.
I've exhausted the cpan and non cpan addresses for DBURDICK. I'll try DUFFEE next. How, for my future reference, did you find the information about DUFFEE?
Just by looking up the permissions on the module on [https://cpanmeta.grinnz.com], then seeing if they had done any releases on metacpan.
Can't say I'm a fan of requiring parentheses for sub calls, but I would like to see Perl shed the optional whitespace between a sub and its parentheses, as well as a variable and its sigil; these two cause no end of parser confusion and are used by very few. foo (1+3)*2; # interpreted as foo(1+3) * 2
Removing prototypes would break List::Util, Try::Tiny and equivalents, and many of the DSL implementations... bold strategy, let's see if it pays off!
I went back and revisited. Turns out we have some hoops we are jumping through to get around the behavior that Test::Warnings gets around. I'm going to switch over. Thanks.
The first one is. The multiplication is in void context because it is applied after the function is called. In the second one you are printing to a bareword filehandle named 'foo', not calling a function. Welcome to indirect object notation.
Do you run things through a formatter (PerlTidy) before checking in? That can help with making these, shall we say, style decisions at least uniform. 
Pretty aggressive. I feel like this is probably more disruptive than the python2-&gt;python3 switch, but less disruptive than trying to convert perl5-&gt;perl6. &gt; prototypes (but improve signatures!) This breaks modules at such a high point in the CPAN river, I can't imagine that anything would work at all. Like, anything. &gt; all sub calls need parens (no perl poetry mode or different arities) (how does this affect $_ defaults. This probably rules out 30% of CPAN. &gt; move some platform specific keywords to modules (kill was the focus of that part) This probably breaks most of the most important modules for people in devops. &gt; indirect object notation This probably rules out 50% of CPAN, and like 95% of all the older stuff. &gt; require m on // for a match operator This probably rules out 100% of all deployed code larger than 2k LOC.
[The video](https://www.youtube.com/watch?v=0jIk3s7GsEo) is up now :)
Hey! I tried the first one, and it worked great, except it is parsing "100's" as "Z's" instead of "ZZZ's"
as a oneliner: perl -pi -e 's/\d/Z/g' foo.txt In any case the regex s/\d/Z/g in your above code will work. The /g bit means it is global, and applies to every instance in the line.
`[0-9]*` matches zero or more digits. So that matches an empty string and you'll end up with far too many Zs. You want at least one digit. So you need `[0-9]+`. But then I saw you wrote this in a comment: &gt; it is parsing "100's" as "Z's" instead of "ZZZ's" Which I take to mean that you want to convert every digit into a Z. So that's simpler. You don't need to worry about `*` or `+` at all. s/[0-9]/Z/g; You'll see people suggesting `\d` instead of `[0-9]`. There's a subtle difference there. `[0-9]` matches exactly the ten characters between '0' and '9' in your character set, whereas `\d` matches all digits and that will include many Unicode characters that are defined as digits. It's likely that your data contains none of the non-Arabic digits, in which case the two solutions will be equivalent. But if there's a chance you'll be getting more esoteric data, then you'll need to decide which approach is right for you.
Obviously it doesn't work as you expect. \[0-9\]\* matches any number of digits, including zero. This means that the empty string matches and so this is an endless loop. The repeat character you'd need to use is "+" which means "one or more matches", not "\*" for "zero or more matches" - if you really want to fold successive digits into one "Z". If you want to substitute every single digit with one "Z" you need to use \[0-9\] which means "exactly one digit", or you could use the meta character \\d.
s/\\d/Z/g;
Oh, so you actually think there's a chance that what I want to add (templating functionality) will be incorporated to pod2html?
That doesn't seem to be what podtohtml does now? Its documentation says that it is fixing some bugs and annoyances with pod2html. Why are those not being pushed back to the original?
Read again.
There still seem to be quite a few presentations missing. Is the upload completed already or not?
No idea. The last one was uploaded 5 hours ago, so there might be more coming. I just saw that quite a few had already been posted and wanted to share in case anyone else was interested.
There still seem to be quite a few presentations missing. Is the upload completed already or not?
So you prefer Perl 6 sigil syntax. How about the attached container semantics?
Sigils were a nice idea, before Perl5. It's really nice to have easy shell-like string interpolation, and it's nice to have some static type information in the variable name. And I find that sigils give my code more visual rhythm and makes it easier to read, e.g. as compared to Python where every identifier looks the same, whether it's a variable, function, method, or class. However: * Sigils are *not necessary* for convenient string interpolation. E.g. Ruby's `"#{foo}"` syntax, Python's `f"{foo}"`, C#'s `$"{foo}"` etc. are just as convenient ‚Äì and arguably better because you can provide additional formatting info and interpolate arbitrary expressions. And there's no reason why $ couldn't just be a interpolation marker rather than a sigil, e.g. the sigil-less variable `foo` could be interpolated as `"$foo"`. This is actually exactly how the Posix shell works. * The type information via sigils becomes pointless the moment you have user-defined types. Perl5 only has 5 sigil-types: scalars, arrays, hashes, code, and typeglobs. All strings, numbers, references, and user-defined types are scalars. So any nontrivial program will almost exclusively use scalars. Those sigils are no longer valuable type indicators, they are just visual noise. You also cannot provide user-defined implementations for arrays or hashes unless you use the `tie` mechanism, reducing the utility of those sigils. This inconvenience might be part of the reason why special collection types (sets, queues, ordered hash tables, ‚Ä¶) are rarely used in Perl5 code. * Sigil variance is totally confusing and was a mistake. It can be argued linguistically why it made sense (singular vs plural), and it has deep connections with scalar context vs list context (`@foo[bar()]` and `$foo[bar()]` both access the `@foo` array, but `bar()` is evaluated in different contexts, possibly leading to different indices). This can be a quite subtle cause of bugs. Also, that `$foo` and `$foo[0]` refer to unrelated variables‚Ä¶ * Prior to the post-deref feature working with references was rather annoying, e.g. having to use a circumfix operator `@{ foo() }` to get a flat list from a function that returns an arrayref. Now it's much better with the postfix `foo()-&gt;@*`. Part of the problem here is that sigils aren't just variable prefixes, but type casting operators. This kind of makes sense if you interpret all variable names as strings that must be ‚Äúdereferenced‚Äù to get the variable contents, but symbolic references/varvars aren't exactly good style. * I've never encountered a case where string interpolation of arrays or hashes did what I wanted it to do. I know I can set `$"` to change the list interpolation separator, but it's usually better to just format the list explicitly. Confusingly (if one isn't aware of scalar context), concatenation `"foo" . @bar` results in different output from interpolation `"foo@bar"`. * Sigils are mildly inconvenient to type depending on keyboard layout. So from my experience with Perl5, I don't consider sigils to be a terribly valuable language design decision. Perl6 fixes many of these problems and makes some subtleties of the data model more accessible (e.g. the dual role of scalars etc as objects and as a reification of variables), but doubles down on sigils by adding twigils with scope-information. Compare also Ruby with `$global, @instance, local` variables. I'm torn on this, but it's definitively more convenient than [`self.foo`](https://self.foo) in Python or `$self-&gt;{foo}` in vanilla Perl5. Even Java needs the occasional [`this.foo`](https://this.foo) to disambiguate a local variable from a field. Unless you have to combine sigils with other Perl specialties (such as list context), carefully consider whether some more boring syntax wouldn't work as well. E.g. C++ needs to disambiguate at parse time whether an identifier refers to a type name, template, or variable. Because C++ doesn't have sigils, some code needs the sigil-like keyword `typename` instead, as in `typename foo&lt;42&gt;::bar`. Similarly, Java places methods in a separate namespace which is usually disambiguated by the method call syntax. To refer to a method `Foo.bar()` as a value rather than calling it, you need to use the `::` operator, as in `Foo::bar`.
I think so. I emailed them a few times because we ran into a problem while pulling. So we switched to a local [Pinto](https://metacpan.org/pod/Pinto) repo. Basically Stratopan is a web frontend for Pinto.
Container semantics are very good because they take away the pain of passing references around. For Perl5 developers, the way it works in Perl6 is that by default a reference is passed, but it's marked as (shallow) read-only. To get a copy, you have to ask for it (with 'is copy' in the signature) and to get Perl5 read-write pass-by-reference, you also have to ask (with 'is rw').
How about you chip in yourself to kick off the discussion? :)
 I don't have enough experience with both of the libraries i am interesting what the thought of the experts on the field . Below are some comparsaion which i did : &amp;#x200B; 1.Blocking/Non Blocking : Mojo::UserAgent support both while with Requests you can only do blocking requests 2.WebSockets : Mojo::UserAgent supports websocket request while Requests didn not 3.Pasring DOM/XML : Mojo::UserAgent has built in support for parsing DOM through Mojo::DOM while Requests require other python libraries to do this job 4.CSS selects/JSON Pointers queries : are built in on Mojo::UserAgent while Requests you need to install other libraries 5.HTTPS requests : supported by default with Requests through python , while on Perl it requires [IO::Socket::SSL](https://mojolicious.org/perldoc/IO/Socket/SSL) 2.009+ version of IO::Socket::SSL which could no easy to install on older versions of perl like 5.16 ,which installed on older linux systems which supports older verison of OPENSSL &amp;#x200B; any thoughts ? &amp;#x200B; &amp;#x200B;
 I am not so expert with those libraries , I did some compare which listed above , I would love to see what the experts opinion about those libraries ?
&gt; And I find that sigils give my code more visual rhythm and makes it easier to read This, right here. I don't need a fancy IDE or somehow encoding the type of the thing into the name of the thing to know what it is. Or, at least, the type of thing that the author wanted the interpreter to treat it as. Having spent the last couple years in node/javascript land, too often it's a "oh, shit, it's a function?" is too common.
How's that related to APL's enclose declose shoes?
Typical. I decided to delete that sentence 30 seconds after I posted cuz I hadn't explained what I meant and concluded it wasn't worth going there. The following would be start in a likely complicated dialog to get at what I meant. Imo P6 keeps things simple and APL's enclose/disclose is horribly complicated. But they share something. my $foo = 42; # Creates a Scalar container, binds $foo to it and puts 42 into it say $foo; # 42 say $foo.WHAT; # (Int) say $foo.VAR.WHAT; # (Scalar) $foo++; # Takes 42 out of Scalar, increments it, puts 43 back in $foo = 99; # Puts 99 into Scalar my $bar := 42; # Binds $foo to 42 say $bar; # 42 say $bar.WHAT; # (Int) say $bar.VAR.WHAT; # (Int) $bar := 99; # Binds $foo to 99 $bar++; # Error: postfix:&lt;++&gt;(Int) ... require mutable argument $bar = 100; # Error: cannot assign to an immutable value I don't know if that's enough for you to see how this is a really simple way to do some of what enclose/disclose do. If not, I suspect I'm going to have a devil of a time explaining why I see a connection...
&gt; Sigils are not necessary for convenient string interpolation. This is interesting and I hadn't considered it, thanks. Regardless, I still prefer having sigils elsewhere anyway, because it makes the parser's job easier (and as we know, the Perl parser has enough problems with ambiguity already).
None
It‚Äôs even more similar to perl than that: result = ‚Äúsome string‚Äù =~ /^my-regex$/
Pretty much every language nowadays. Javascript: "123".replace(/\d+/i, "a");
They worked well in the context of old school perl. There are just so few problems where you need a super terse scripting language anymore. You either need a full-on native oriented type system for performance reasons, or you need a super simple syntax some junior employee can learn in a few months and use for a year before getting a better job.
I am a naive programmer and not particularly skilled at it. I like sigils. 1) The are visual signals that help describe a variable. For example, when I code in Javascript, I can not tell just by looking whether a word is an object, a string or an array or a function. 2) Another benefit I see in Perl is the back-end parsing of the code is probably easier that way, and certainly IDEs probably are able to 3) About using only the dollar sign...I would say meh... The beauty of Perl 5 is its *optionally* object orientated programming. Treating everything as an object gives a certain amount of power, by sacrificing a lot of performance, memory usage and adding unnecessary complexity. There is plenty of hate towards sigils, particularly from people coding in other languages. I would suggest a module that allows a sigil-free coding without disrupting the code and thought processes of those who find them useful.
I like sigils. If I wanted to use a language where everything was an object, I'd be writing python, not perl.
I'd be writing ruby instead of perl? 
You forgot one huge advantage: Sigils allow even a dumb text editor to accurately color highlight code while also giving different types dfferent colors.
I don't really see a connection between Scalar and the ability to create a scalar value out of an array in APL. In my mental model of Perl 5, references are actually like APL's enclose verb as they allow you to make a scalar of an array. But for Perl 6 I don't see any connection.
I thought the same, we already have a full OO Perl. And things like perl5i also allow you to call methods on arrays and stuff in Perl 5.
But then I'd be writing perl6 instead of perl. I don't really want to do any of these things.
OK. I can't yet tell whether to mostly credit that to Larry's great lang design talents, or to my weaknesses in communication, or to my lack of understanding. Do you see a connection between this and enclose/disclose? my @array = 1,2,3; my $scalar = @array; say $scalar[1]; # 2 If not, perhaps it would work best if you showed some use of P5 refs that illustrates what you're talking about?
Note that it's easy to sharply reduce use of sigils in P6. In fact you can remove them entirely if you feel the need.
That script is pretty hacky. That's probably not the behavior you want anyway. You should put your backups in another directory, or ideally on another machine. You might want to compress them too. There are tools that do this. If you want a dead simple backup an easy way is to use rsync to copy the files to a directory with a timestamp in its name on another machine. rsync -a source dest-`date -Iseconds` What you are trying to do is very close to the old VMS idea of versioned files. That was abandoned long ago.
Have you considered using `git`?
Hmm. I just peered back at APL thru a thick layer of cobwebs and perhaps I'm confused about floating vs grounded. Or just plain confused. Anyhoo, let me turn my attention to P5. That way I'm still dealing with cobwebs but they look less dense to me and hopefully I will look less dense to you. :) Translating to P6 based on what I think you're illustrating: my @A = 1, 2, 3; # 1 is a scalar inside a Scalar inside an Array my @B = 4, 5, 6; my @C = @A, @B; # @A is an Array inside a Scalar inside an Array say @C[0].VAR.WHAT; # (Scalar) (.VAR shows enclosure, it doesn't add it) say @C[0].WHAT; # (Array) (rvalue use of a Scalar automatically discloses) say @C[0].perl; # $[1, 2, 3] (.perl shows the underlying truth) say @C[0]; # [1 2 3] (automatic disclosure and gisting) say @C[0].Array.perl; # [1, 2, 3] (.Array is a no-op in this instance) say @B[1] = 99; # 99 (Scalar did contain 5, now contains 99) say @C[0].List.perl; # (1, 2, 3) (1 is a scalar. It is NOT INSIDE a Scalar) say @C[0].List[1] = 99; # Cannot modify an immutable List ((1 2 3)) I see what P6 does as automatically enclosing and disclosing by default for normal usage. One can explicitly enclose using `$ = ...` and defeat automatic disclosure by writing `.VAR` but this sort of code is very seldom necessary. In the meantime P6 has changed the emphasis for `\`. If one runs the first three lines of your P5 code as is in P6 one gets: my @A = (1, 2, 3); # Works my @B = (4, 5, 6); my @C = (\@A, \@B); # Potential difficulties: # To pass an array ... just pass it as is. # For other uses of Perl 5's ref operator ... # Parenthesize as \(...) ... When I squint to peer through the cobwebs `\` is like another way to keep things as a reference but one which requires explicit dereference/disclosure to get back to enclosed reference: say @C[0].perl; # \([1, 2, 3]) eqv \[1,2,3] eqv \@A say @C[0][0].perl; # [1, 2, 3] eqv @A say @C[0][0].List.perl; # (1, 2, 3) eqv @A.List Am I making any sense? If not, I'll concede there's no point in me attempting to talk further about what APL does in any flavor. :)
&gt; the files aren't ordered properly with sort, so some cases don't work right You've used `sort` without specifying the sort order so it sorts according to a default ordering. If you've picked what you consider a proper ordering and it doesn't match the default ordering then you need to direct `sort` to use the ordering you want. The same notion will apply to any programming language. So a useful question to answer is what is the ordering you want?
I would have figured the higher $n values would be bumped then decent toward zero, and the original file.
It would be useful if you could edit your question to include your existing code. That way, we could see where your misunderstandings are and could probably offer better advice.
Is this homework?
Cross-posted discussion: http://perlmonks.org/?node_id=1222431
Which was also cross posted from Perl Guru [https://perlmonks.org/?node\_id=1222507](https://perlmonks.org/?node_id=1222507) I have to confess Im not sure why this sort of behaviour is tolerated so much by the community. This is very clearly someone just farming out their degree coursework to the internet. Any code you see is someone else's half done attempt passed off as the OPs so that you take it one step further. 
Great presentation. Exciting that Bugzilla is moving to Mojo.
Probably made in a perlbrewery
And afterwards pop in to Malaysia where [Perl Xlim](https://www.youtube.com/watch?v=qcURvOolOfs) can get rid of that beer belly
So Perl is not in such a bad position like others are trying to show us, isn‚Äôt it?
[Fine Wine](https://www.schmitt-weber.de) from [Perl](https://en.wikipedia.org/wiki/Perl,_Saarland)!
**Perl, Saarland** Perl is a municipality in the district Merzig-Wadern, in Saarland, Germany. In 2010 its population was 7,593. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
I have 2 bottles at home. They can be bought at many Perl events ;-)
I went to go look at it and saw that I already did and was no use back then, either. :-(
Yes, you did review it back then. I appreciate you taking the time for that. :)
Thanks. It's a shame stratopan's gone to bitrot.
I'm happy to get involved. In the past for modules that I use regularly there have been existing pull requests on github, but they're often so incredibly stale (12+ months old) and I'm not even sure they're worth reviewing anymore, because it certainly looks like the author hasn't touched them. Or is that a common thing?
There can be many reasons for it: * The author forgot about it * The author (often just a current maintainer) doesn't feel qualified to review it * The author is inactive (in which case, may need prodding via email or may want a new maintainer to step up)
Unfortunately it is common to have older pull requests, often for the reasons /u/Grinnz has mentioned. However, that often doesn't mean that they're not worth reviewing. Before spending a lot of time on a module, I think it's good to get an idea of whether or not your work will help move things along. So getting in touch with an author is generally a good thing. In the case of WWW::Mechanize, we've a) just been overwhelmed trying to keep up with things and b) we're still working through the backlog. A lot of the existing pull requests predate my involvement, but I'd still like to see them dealt with. Thanks for taking a look at this code. It's very much appreciated!
Whilst this looks handy, why is this JavaScript code in a Perl sub?
It's for use on [https://metacpan.org].
You can always try tagging the PRs with [Hacktober Fest](https://hacktoberfest.digitalocean.com/). 
Good to know. Perl programs have been know to create some BIG strings.
Glad to see things are going strong.
[Mojo::DOM uses them](https://github.com/mojolicious/mojo/blob/1d80b8efd2c48723be21a8987875d396a02db145/lib/Mojo/DOM/HTML.pm#L13).
is there a tutorial on Perl?
Useful article! Took me a moment to realise the thumbnail did not actually say "perl lol"... Given the target audience, perhaps the wording here is a tiny bit misleading? &gt; If you change the topic you change the original value if the list source is an array (the values are read-only otherwise and you‚Äôll get an error) Since it's iterating over a list of values, arrays are (mostly!) irrelevant here: ``` for (3) { ++$_; # this is not going to work so well } ``` (the exception for an array that you modify in the loop is covered well, kudos) I find it's not always immediately obvious to new Perl programmers that constructs such as this are valid: ``` for(my $x = 7) { ++$_; # totally fine, if somewhat pointless } ``` or, maybe more useful: ``` for($some_variable) { s/\s+$//; # trim trailing whitespace s/^\s+//; # trim leading whitespace } ``` or even ``` s/\s+/ /g for values %hash; # normalise spaces ``` 
The way how brian indents his code really grinds my gears.
Maybe. But it's a popular library that _seems_ to be reliably using them ((bugs aside)[https://github.com/mojolicious/mojo/issues?q=is%3Aissue+MOJO+DOM+is%3Aclosed]). 
Huh. I didn't know that $_ was an alias and can be used to manipulate the original array. Cool!
I don't like it either. It's apparently called [Ratliff](https://en.wikipedia.org/wiki/Indentation_style#Ratliff_style), in case you want to use name the next time you rip it apart in a code review ;)
Pearl lol?
I think there's a missed opportunity here to relate it to [perllol](https://metacpan.org/pod/perllol) :D
[https://perldoc.perl.org/perlintro](https://perldoc.perl.org/perlintro) or type "perldoc perlintro" into a terminal (except cmd or powershell).
It doesn't return references; foreach aliases directly to the list provided, whatever the source.
lol @ initial commit message: "useless humongous commit with all the stuff" ^_^
Hi. I have not yet created Perl related article in this series, however following old, hopefully still useful links might help: - https://github.com/melezhik/outthentic/wiki/FAQ - http://blogs.perl.org/users/melezhik/2016/11/how-to-upload-a-script-to-sparrowhub.html - https://sparrowdo.wordpress.com/2017/02/09/outthentic-quick-way-to-develop-user-scenarios/ - and last but not the lease Sparrow/Outthentic docs on GH HTH Alexey
Yup, and I've used it in the example code. It doesn't solve my problem because it doesn't natively allow for named parameters. That has to be emulated via hashes, and it has warts. I'm hopeful that one day we'll have something that's at least as useable as what Python has.
There's ultimately nothing that can keep me from shooting myself in the foot, but the proximity between the parameter names and their values might provide a visual check.
This sounds like an opportunity for P5/P6 cross pollination: sub _build_r_z ( :$self, :$f, :$beta_star, :$beta, :$r0, :$z0, :$xi ) { ... } ... my ( $f, $beta, $r0, $beta_star, $z0, $xi ); ... _build_r_z( :$f, :$beta, :$ro, :$beta_star, :$z0, :$xi); The `:$f` in the sig is an argument named `f` that's mapped to a parameter `$f`. The `:$f` in the call is an argument named `f =&gt; $f`. Does that achieve what you want, albeit in P6? If so, can P5 follow suit?
[Function::Parameters](https://metacpan.org/pod/Function::Parameters) does natively allow for named parameters. I believe it's been mentioned that it's something desired for the core signatures feature as well.
In general I consider anything requiring PadWalker to be too hacky for production use. Lexical variables exist for the primary purpose of not affecting or being affected by other files. The signatures feature and various keyword plugins like Function::Parameters offer a nicer approach to the problem.
That's a really nice location!
For Perl versions that don't support all the fancy new signature stuff, I've done this with: my ($self, %params) = @_; my ($foo, $bar, $baz) = @params{qw( foo bar baz )}; It's reasonably maintainable.
Yeah and modules like [Kavorka](https://metacpan.org/pod/Kavorka), [Method::Signatures](https://metacpan.org/pod/Method::Signatures) and [Function::Parameters](https://metacpan.org/pod/Function::Parameters) make it clear it's not impossible to have all the nice things. 
More detail: https://docs.perl6.org/type/atomicint 
Jonathan Worthington has some implementations of [lock free datastructures](https://modules.perl6.org/search/?q=lock-free) using `cas` so that you can avoid the need for explicit locking in your code that are worth a look. The [stack implementation](https://modules.perl6.org/dist/Concurrent::Stack:cpan:JNTHN/lib/Concurrent/Stack.pm6) is probably the simplest to understand.
For various (perhaps not entirely thought out) reasons I've been reluctant to use a module which introduces non-standard keywords. I think it's mostly because I dread having to refactor the code when that particular module falls out of style and is no longer supported. IIRC, CPAN has sported several modules which interface with the custom keyword facility in Perl; not all of them have survived, and those modules which relied upon them have fallen by the wayside. I've been burned by similar events in the past, and the scar seems to be permanent. Perhaps things have settled now, but my reticence remains.
That certainly would achieve what I want. The [Function::Parameters](https://metacpan.org/pod/Function::Parameters) module mentioned elsewhere in this thread provides that functionality with similar syntax (perhaps the same, I haven't checked in detail), so there already seems to be some cross-pollination (or parallel evolution).
You may be thinking of modules based on [Devel::Declare](https://metacpan.org/pod/Devel::Declare) or similar hackery, that's been exploited to achieve similar goals. While any CPAN module is susceptible to falling out of favor, the keyword API is at least a supported core facility and as such won't be going away itself, so is a far better choice. Modules commonly used for leveraging the keyword API include Keyword::Simple and Keyword::Declare.
Keyword::Simple and Keyword::Declare both self-identify as either alpha or experimental, which unfortunately makes them less appealing for production use.
Cool. I ‚ù§ Perl of whichever flavor and especially their combination.
Hello, my name is lbe, I'm a recovering perl programmer. It has been 10 mins since my last one liner, 2 hours since I played golf and a day since I wrote code using implicit punctuation variables :( I do have peers and friends who treat my use of perl as a psychological problems bordering on addiction. In some ways, maybe they are right - when I see a problem and think about how to solve it, perl approaches come quickly to mind. Have my synapses reorganized themselves to match perl? I hope not, maybe its my denial, but I "believe" that perl allows me to describe a solutions in an expressive manner that matches how my mind naturally processes "things." Enough about me - back to the OP ? I think /u/neilhwatson's response covers things pretty well. My only addition is an observation of the human condition -- we tend to look for what is currently in style. perl went out of style 2 decades ago. Consequently, humans tend to dismiss perl as being old which in the US at least is often equated with being bad. These days I don't write much code for production purposes. I generally use perl for analytical purposes and to create proof of concepts. My only concern about using perl for this purpose is that it can be difficult when I try to pass this on to developers that we note evening born when I began writing perl :) I often get scowls, pushback and bad attitudes ( not sure if perl is the cause of these behaviors or if it is just a millenial attitude at dealing with an old person :)! ). But I do smile when they come back to me with their Java/C# ... and ask for help to implement functionality that is inherent to perl core or part of a long toothed CPAN module. Absent theoretical preferences about language purity and programming paradigms, my choice to use perl is really based upon the realization of Larry's 2nd Slogan of perl - "Easy things should be easy, and hard things should be possible." In many, if not most cases, I can do what I need to do more quickly in perl than in most other languages. Some of this may be due to my decades of experience in perl; however, I think most of the speed is from standing on the shoulders of perl's giants (i.e. LWALL, DCONWAY, NEILB, DAGOLDEN, TOBYINK, OALDERS, OVID, RJBS, LEEJO, SHLOMIF, MARIOROY, JDHEDDEN and many others). Their contributions, in my experience, often make hard things easy! My "Thank You" to all of them. I hate to see perl hated. Fortunately for us, those committed to maintaining and developing perl continue forward irrespective of hate. As a result, perl is alive and thriving!
I don't think this would be a good choice for learning a new language.
Rookie question: what type of scenarios or projects could this functionality be useful?
&gt; while on Perl it requires IO::Socket::SSL 2.009+ version of IO::Socket::SSL which could no easy to install on older versions of perl like 5.16 ,which installed on older linux systems which supports older verison of OPENSSL This looks like an unfounded claim to me. IO::Socket::SSL (and Net::SSLeay which it requires) works for really old versions of Perl and OpenSSL, even for perl 5.8.9 and OpenSSL 0.9.8. 
What's your level of proficiency in other programming languages?
Got a link to it? Wouldn't mind checking it out myself.
I'd strongly disagree - the format is well documented, it's a task that Perl is well-suited for, and it'd be easy to break it up into a series of steps. Try something like this to get an overview of how+where things are stored: https://blog.angularindepth.com/become-a-git-pro-by-learning-git-architecture-in-15-minutes-9c995db6faeb and the documentation covers the concepts in more detail: https://git-scm.com/book/en/v2/Git-Internals-Git-Objects You can compare your code directly against the equivalent `git` commands and rapidly build up a toolset. Much of git was constructed by shell scripts and Perl scripts originally!
I think the Overview section of [Concurrent::Trie](https://modules.perl6.org/dist/Concurrent::Trie) gives a nice example: &gt; This data structure is well suited to auto-complete style features in concurrent applications, where new entries and lookups may occur when, for example, processing web requests in parallel.
We use mojo and minion for a few key services at work, thank you. 
Vivid green on black text detracts from the message. 
any sample chapter available? thanks
`$sep` will take the first value, and `@list` will take the rest. Just try it! This isn't really about `@_` or `my`, it boils down to assigning a list to a list. So: ($a, @b) = (1, 2, 3, 4) # $a is 1, @b is (2, 3) ($a, $b, @c) = (1, 2, 3, 4) # $a is 1, $b is 2, @c is (3, 4) # The first list on the left side eats everything it can: ($a, @b, $c) = (1, 2, 3, 4) # $a is 1, @b is (2, 3, 4), $c is undef # You can skip values by using undef on the left side: ($a, undef, @c) = (1, 2, 3, 4) # $a is 1, @c is (3, 4), 2 is skipped
Yes, two sample chapters were released: http://www.wumpus-cave.net/2018/03/27/perl-raspberry-pi-ebook-sample-chapter-intro/ http://www.wumpus-cave.net/2018/03/28/perl-raspberry-pi-ebook-sample-chapter-1/ 
How does this compare with something like Test::More?
* it takes less efforts to create tests IMHO. * has different model - split definitions of what you test ( stories ) from definitions how you test ( checks ). 
To clarify, that whole expression is still in a list context. Assigning @_ to any list of things will assign its first element to the first thing in the list, the second to the second, and so on. `@list` in your example ends up slurping up the remaining items after the first is assigned, if any.
On the "less effort" aspect, I'd say writing 3 lines using something like [Test::Script](https://metacpan.org/pod/Test::Script): use Test::Script; script_runs(['script.sh', '--blah']); done_testing; is certainly less effort.
It reads really well on AMOLED screens. My cell phone made it easy.
You could use try and make a unique selector that doesn't involve an ID, maybe something like: button.button.js-multirecommendCountButton[data-action-value] Although you would need to check to see if that pulls a unique element. You might also be able to use the parent to help select, but without knowing the HTML structure, it's tough to say. You'd likely be better off triggering a form submit manually as opposed to attempting to click the button to trigger the action.
&gt; Undefiend subroutine &amp;main::move Modulo the typo, that's pretty clear. You're calling a sub that doesn't exist. Did you intend to use [`File::Copy::move`](https://metacpan.org/pod/File::Copy)? If so, did you `use` the module and import this sub? Alternatively, did you want to use the [`rename`](https://metacpan.org/pod/distribution/perl/pod/perlfunc.pod#rename) builtin?
&gt; use File::Copy qw(copy); That's going to import `copy`, not `move`.
There is no Perl built-in called "move". You need to &amp;#x200B; `use File::Copy;` &amp;#x200B; to have it available to you. The built-in is "rename", but File::Copy comes with Perl since 5.2, and appears to be what you want. You also want to check the return status of your "move". Something like `move( ... ) or die "Failed to move file: $!";` will save trouble down the road. I suspect trouble based on the fact that your description says you are trying to move the file to the `apples` directory that is a subdirectory of `Desktop`, but your code tries to move it to a top-level directory. &amp;#x200B; One more thing -- there is no need to quote $file when you pass it to move().
Please edit the question and provide `%cefr`.
More information would be welcome.
I forget the exact syntax, but you want to provide a custom compare. Something like # I'm pretty sure this isn't exactly right, it's been a few months... sort { $b-&gt;{found_count} &lt;=&gt; $a-&gt;{found_count} || $b-&gt;{level} &lt;=&gt; $a-&gt;{level} } values %cefr The idea is to compare by `food_count`, and if they are equal then compare by `level`. 
I'm downvoting you, but it feels unfair without explanation because it seems like you want to help. I can't speak for the other downvoters (-2 as I write this) but here's why, I hope it helps. OPs question can be answered with a basic sort that includes two clauses. Your first thought included two loops, which is inefficient. Your second thought doesn't make much sense so I'll assume you meant something other than what I understood. Your final thought is pretty complicated without a good reason. Now, if OP came back with 'ok, I tried this with the built-in sort but it was too slow and here's the results of profiling to prove it', maybe then we can talk about a radix sort or something else highly specialized.
Kind of
I‚Äôm currently working on a sane plenv based Docker environment to spin up microservicesish things. Complicating factor - for work purposes, oracle is involved. Plenv is your friend, Docker or otherwise. 
or you can use standard unix tools: `sort -nr` and `wc -l`
This would be a great project, and I have done similar before. I would do the following, with reference to: [http://eagain.net/articles/git-for-computer-scientists/](http://eagain.net/articles/git-for-computer-scientists/) * Create a set of classes representing each of the storage types, in abstract, listed in the above. Don't worry about reading actual data yet, but think through the attributes each should have, and how they should link to each other. Build some tests that represent some very simple branches, commits, etc, to check your model works. You could have extra fun by creating some graphing functions that take an object, and use GraphViz to draw what you have * OK, now start with playing around with the structure of an actual repository, read-only. Start with a tool that given a local git directory and the hash of a blob can instantiate one of your classes with that. Add any methods you missed in your original blob class. Build up through the storage types again, allowing them to be read from a passed-in directory. Eventually get to a point where you can read most of a simple repo, and then use your graphing tools to draw it * Try writing some repository filters at this point, that take an input repository, apply some changes to it, and then write out an output repository with the same structure. Have a filter for removing all traces of a file that was checked in, so it no longer appears in the history. Maybe one to retroactively run a code formatter over each of the files in a repo for each commit? Generalize it so that a function that makes the changes can be passed in, and you've written the code to just go through commit by commit, apply the function, write out a new commit in a different repo. If you want something \_really\_ challenging, try writing something that would support a function that splits each commit into a series of smaller commits, each affecting only one file. At that point you've become properly comfortable with creating and editing commits * Write a script to diff a directory on the filesystem with the directory at a certain commit in the tree in a git directory * Learn more about how stage and stash are implemented For your capstone, write a transform that takes a repo, and rewrites it, such that every commit starts with a specified prefix. This will get exponentially harder the longer the prefix you target, but by this point you should have a pretty good idea how to do it. Happy hunting!
The error arises because the style of "while" loop you are using is trying to read from $outFh, but $outFh is only opened for writing. I would advise breaking down the problem further. For now, don't worry about the output file. First, see if you can print the required data to standard output (i.e. you see it in the console). When you can do that, then it's easier to modify your code to print the same thing in the file instead.
You're currently writing to the same filename you're reading from, have you tried writing to a different file?
Thank you for the response! I'll try this 
All servers I develop Perl on have Perls separate from the system perl, whether it's just a standalone Perl from [perl-build](https://metacpan.org/pod/perl-build) or multiple Perls managed by [plenv](https://github.com/tokuhirom/plenv). Then for any project I manage its dependencies in a [cpanfile](https://metacpan.org/pod/cpanfile), which allows me to either install its dependencies as necessary or install and track them locally in [Carton](https://metacpan.org/pod/Carton).
While I don't mind the occasional Rakudo news as it relates to Perl, can we have the bot repost this particular blog to /r/perl6 instead?
By the way: die join(" ", "Can't open outfile", $outFh, "for writing:", $!); is over-complicated. This does the same thing: die "Can't open outfile $outFh for writing: $!"; Variables are interpolated inside double quotes. If you don't want that, use single quotes instead. 
Just to add, you can also use the autodie pragma to handle these kind of exceptions - https://perldoc.perl.org/autodie.html
This is strange: while (&lt;$inFh&gt;) { print $_; my @arr = &lt;$inFh&gt; } As you read all of the file into `@arr` on the first iteration of the loop, there's nothing left for any subsequent iterations. It's basically the same as: print scalar &lt;$inFh&gt;; my @arr = &lt;$inFh&gt;; But in your version, `@arr` goes out of scope immediately, and you lose all of the data. The second time you do it is even weirder, as that time you read from `$outFh` - which is your output filehandle. So that's what is causing your error. Oh, and then at the end, you create another array called `@arr`, and populate it by reading all of the data from `$inFh`. But as you've already read all of the data from that filehandle, you end up with nothing in `@arr`. I'm afraid your code is all rather confused. It's hard to help much as I can't work out what you were trying to achieve.
thanks! sounds like Plenv is the new Perlbrew?
thanks! sounds like with Carton I can have different set of modules per project, while simply keeping each project in a separate folder? I gotta give it a try tonight
thanks! to be honest I've only read about Docker, but never actually used it (well, I only used someone else's image without any modifications), but it does sounds like what I want to use.
Part 1. This code is right, but you may not understand it: open ($outFh, "&gt;", $outfile) `$outFh` contains the filehandle you're opening. `$outfile` contains the name of the file it's a handle for. What about `"&gt;"`? It's pointing *into* `$outfile` so it says to make a filehandle that writes to `$outfile`. Writing is the filehandle's **mode.** (Specifically, `"&gt;"` mode replaces anything that's already in `$outfile`. [Here are the docs for `open`](http://perldoc.perl.org/functions/open.html) if you want to read more about that.) Part 2. This is wrong: &lt;$outFh&gt; `&lt;&gt;` is the [**readline operator,**](http://perldoc.perl.org/perlop.html#I%2fO-Operators) and the filehandle you're reading from goes inside. Perl is giving you the "line 24" warning because you're trying to read from a filehandle that's in write-only mode. The 24th line of your code is the first (but not the only) place you've made that mistake. Part 3. This is right: close $inFh; It's good hygiene to close your own filehandles as soon as you don't need them anymore. Part 4. This is well-formed Perl, but it's not what you want to do: while (&lt;$inFh&gt;) { my @arr = &lt;$inFh&gt; } You can either read the lines from `$inFh`one at a time (with the `while` loop) or you can read them all at once (with `@arr = &lt;$inFh&gt;`, but mixing the two approaches will not do what you want.) "Wait," you might be asking, "so does `&lt;&gt;` read one line or all the lines? You said both." I did say both. Perl operators and functions can do different things, depending on what you say you'll do with their return value. This is called **context.** If you are returning to something that expects one value, it's called **scalar context,** and `&lt;&gt;` will return the next line it hasn't read yet. The `while (&lt;&gt;)` form assigns to `$_` so it's a scalar context. If you are returning to something that expects a list of values, it's called **list context,** and `&lt;&gt;` will read *all* the lines it hasn't read yet and return them all. Assigning to `@arr` is a list context. So your code is going to put the first line of the file into `$_` and the rest of the lines into `@arr`. One other thing. You've declared `@arr` with `my`, which is a good practice. A `my` declaration limits which lines of code can get to that array via the name `@arr` (and that means that in the rest of your program, you don't have to worry about messing the array up by accidentally reusing the name `@arr`). But in this case, it's a little too limited. The `my` is inside the `while` loop body, which means that the name `@arr` is only visible inside the loop body. The loop body is its **scope,** and if you use the name outside that scope, Perl won't know what you're talking about. In fact, the scope of `@arr` is a single time around the loop: If the loop body runs more than once, each iteration gets its very own `@arr`, unaffected by what was in `@arr` the previous time around. OK, one other other thing. Descriptive names. `$inFh` and `$outFh` are good names. I would probably just call them `$in` and `$out` but if your assignment requires the `Fh` part, whatever. `@arr` is not a good name. We already know it's an array from the @ sign. Tell us what's in it, maybe `@lines`. Part 4. At the end of your code, you again say my @arr = &lt;$inFh&gt;; which is where the "line 30" error message comes in. You already closed `$inFh` which means you can't use it anymore. So `&lt;&gt;` chokes on it and complains. Part 5. You should write your output to a different file than you get your input from. You are going to run your code several times in the process of working it out. If you overwrite `fastaFile.txt` each time, you have to put it back the way it was before you can run the code and read from it again. Part 6: Resources for you. 1. You need to know about [perldoc.](http://perldoc.perl.org/) When error messages say things like 'See "open" in perlfunc," `perlfunc` is the name of a perldoc page that has a summary of Perl's built-in functions, including `open`. 2. [Modern Perl](http://modernperlbooks.com/books/modern_perl_2016/index.html) is probably the best book for beginners, and you can read it online for free. Start with [The Perl Philosophy.](http://modernperlbooks.com/books/modern_perl_2016/01-perl-philosophy.html#VGhlUGVybFBoaWxvc29waHk). 3. If the best book for beginners is *not* Modern Perl, it's probably Learning Perl. Mostly they cover the same things, but from different angles, so I recommend you read them in parallel. You can find a used copy cheap. 4th edition or later will all be fine. 4. Avoid any tutorial materials that call it PERL (in all caps). Trust me on this. 
/(\[\\d\]+):(.\*)/ The round brackets are to capture the matches in $1 and $2 respectively.
I use a combination of locallib and Docker for my development env. I run tests on my local box with locallib and then I have Gitlab CI with Docker for pipelines. At work we use primarily Docker, so every developer has the exact same development environment. So they grab a Perl layer with all the deps installed and hack away. For a presenation about Docker and perl: https://youtu.be/Y3TH8dJhEwE?t=1465 https://gitlab.com/waterkip/docker-yapc/ And the speaker of this talk does it a bit different: https://youtu.be/9QYBMNRaFw0?t=7480. He has a docker image with perlbrew. If you are going to take the Docker route I would look into Docker Compose, it is really easy to setup a database and additional services within a project. 
I mean: in the error message you want to print the name of the file that couldn't be opened, rather than the file handle (which, since it failed to open, contains nothing anyway)
you can also do: ($num, $file) = split(/:/, $input_line); This doesn't have the benefit of checking whether the first one is a number, though.
Oh! Yes. You're absolutely right. I'm dumb.
Your explanation is awesome!!! Thank you!!!! So, unfortunately assignment requires the Fh. so if I write my @arr = &lt;$inFh; would that keep it open and allow it to be used? Also, yes was going to write another fastaFile.txt and make it fastaFile1.txt
TIL about the *defined-or* operator `//=` : thanks for that
my $str = "12:sound.wav"; my ($num, $file) = $str =~ /^(\d+):(.+)$/; 
Well, for a start, this: &gt; open ($FILE3, '&lt;',$finalPath or print "failed"); should be this: &gt; open($FILE3, '&lt;', $finalPath) or print "failed"; But of course, if the `open` fails, why go on to try to do things with the filehandle?
You're passing three arguments to `open()`: 1. `$FILE3` 1. `&lt;` 1. `$finalPath or print "failed"` The last one is probably not what you intended. I think you wanted: open ($FILE3, '&lt;',$finalPath) or print "failed"; But, because of the way Boolean expression evaluation works, this actually doesn't cause your problem (although you'll never see the error message and you won't know if the file is opened successfully. In order to be more help in tracking down the actual problem, we'd need to see more of the code. And you'd need to tell us which line it is that generates the error. Also, just printing "failed" isn't a great way to deal with an error from `open()`. I'd recommend killing the program with a useful error message at that point. And use a lexical variable for `$FILE3`. open (my $FILE3, '&lt;', $finalPath) or die "Cannot open '$FILE3': $!\n"; 
I don't know where you found the snippet, so I wrote a new one: #!/usr/bin/perl use warnings; use strict; use feature qw{ say }; sub dircompare { my ($dir1, $dir2) = @_; opendir my $dh1, $dir1 or die "$dir1: $!"; opendir my $dh2, $dir2 or die "$dir2: $!"; my %size1 = map { $_ =&gt; -s $_ } readdir $dh1; my %size2 = map { $_ =&gt; -s $_ } readdir $dh2; for my $file (keys %size1) { return if ! exists $size2{$file} || $size1{$file} != $size2{$file}; open my $fh1, '&lt;', "$dir1/$file" or die "$dir1/$file: $!"; open my $fh2, '&lt;', "$dir2/$file" or die "$dir2/$file: $!"; while (sysread $fh1, my $buff1, 65535) { sysread $fh2, my $buff2, 65535 or return; return unless $buff1 eq $buff2; } sysread $fh2, my $buff, 1 and return; delete $size2{$file}; } return if keys %size2; return 1 } say dircompare(@ARGV); 
thanks
idk if this works yet but when im able to login to my PC ill try it and if it does ty I love you for saving me so much time
Will there be a hard copy of the book? I bought several ebooks in the past. I have yet to complete a single one. I just don't like reading them. I find it hard to maintain focus.
Print out one chapter at a time? Preferably on a laser with a duplexer. Also, a GBC "comb" binder machine is a good investment.
This is perhaps where a feature can be inspired by Perl 6. :$x, :$y which is short for x =&gt; $x, y =&gt; $y I don't think that `:` is really available for this, but maybe there is some other way to spell it.
very cool.
Excellent work. 
The page you were trying to reach cannot be found. Not sure why the upvotes?
Link works fine for me? Does it say why it could not be reached? DNS issues? Other issues?
It's funny. They asked for community's feedback but their moderation isn't approving submitted comments. 
Works for me now
TL;DR please change name because I feel ashamed of telling other Hacker News chaps that I use Perl /s (but not too much)
Like menstrual pads and panty liners?
üíñ
Yupp, don't downvote that guy - it's a brand for these here in Europe
Nice.
Unfortunately, rhymes with "chlamydia"...
I'm really grateful for all Larry has created, but given that Perl 6 was the community's rewrite of Perl, it feels wrong that the community's opinion is (evidently) disregarded. Where's the benevolence?
A curious article. Here are some interesting things I pulled out of it: &gt; Perl‚Äôs success in the 1990s was tied to its culture of synthesis, or having it both ways. &gt; Wall‚Äôs work suggested a commitment to a civic order of worth, or regime of justification that privileges the interests of collectives over individuals I don't know if this is true but it seems plausible: &gt; Given that the first version of the GPL was published just a few months before Perl 3.0 was released, Perl was likely one of the first non-GNU projects to bear the license. Having been in the room when Perl 6 was invented, I'd agree that what we have now is much more modest than what we thought we'd have in 2001 (but, isn't that the case in any green field development): &gt; Perl 6‚Äôs development trudged forward, but in its nearly 20-year history implementations have yet to live up to the lofty goals outlined by Wall and the community at the outset.
&gt; what we have now is much more modest than what we thought we'd have in 2001 Not sure that was the same room, or a room shortly after, but I *was* at the Camelherders Meeting shortly after the mug-throwing incident. I don't think we had much more than the idea of a re-imagining at that point: the RFC's still had to come in. In several ways, Perl 6 is perhaps less than what we hoped it would become. On the other hand, it now has a lot of features fleshed out that were only very sketchy, to say the least. NativeCall / supplies / react / whenever / precompilation / MOP / pluggable almost anything / multiple backends. The only thing of importance that failed to materialize, is native support for Perl 5 code. There are many reasons why that didn't happen, of which Inline::Perl5 is only one. &gt; Perl 6‚Äôs development trudged forward, but in its nearly 20-year history implementations have yet to live up to the lofty goals outlined by Wall and the community at the outset. I think Rakudo Perl 6 is starting to live up to that goal, with basic object creation [being faster in Perl 6 than Perl 5](https://twitter.com/zoffix/status/1045623538345017344), *even* if you bypass accessors in Perl 5 altogether. If you look at what [Cro](https://cro.services) can do *now*, I think this has passed by many of the lofty goals of Larry already.
Yes, that's why it is marked experimental. What aspect of smartmatch are you looking to use?
If you're willing / can give Perl 6 a chance, that would look like this: sub ArraysAreIdentical(@arr1,@arr2) { @arr1 == @arr2 &amp;&amp; @arr1.Bag eqv @arr2.Bag } The first `@arr1 == @arr2` providing a quick shortcut to prevent building of the [`Bag`](https://docs.perl6.org/type/Bag).
Cool, thanks for this. I tried it out but the size comparison does not seem to be working. Using [this script](https://pastebin.com/s9C9xR5V), I see this output: 1 and 2 are not equal 1 and 3 are equal &lt;-- Should not be equal 1 and 4 are equal 1 and 5 are not equal Oddly, my original version with the hash doesn't seem to actually return false for mismatched sizes either. 
Your original version (and my version before I edited it) had a bug: it used `$#arr1` which refers to `@arr1`, not `$arr1`. Try my fixed version.
Yes
Consider this case where smart match fails to do what you want: use v5.10; my @first = qw( One Two Three ); my @second = ( qr/O/, qr/T/, qr/Th/ ); my @third = ( sub { 'One' }, sub { 'Two' }, sub { 'There' } ); say "smart matched: ", @first ~~ @second; say "smart matched: ", @first ~~ @third; Those arrays are not the same, but they smart match the same. That could be a powerful tool if you realized that a pattern could smart-match against another array element. If you don't know that could happen you can get false positives.
out of curiosity why not just eqv directly on the arrays?
Because the op wanted to accept arrays with same elements, but not in the same order. At least, that's what I got from the algorithm he was using.
you assume P6 is the community's rewrite of Perl. That was Perl 5. Perl 6 started as Larry throwing a coffee mug during a conference two decades ago. Every time the Community came close to writing something, Larry threw it away. It took him 16 years to be "happy" with the Community. This is the epitome of an abusive relationship. Meanwhile the world changed. The REST API took over. The web went from unrelated, static pages to a secure standard for inter-operations. CPAN grew, though that tapered as the world moved to Python. Most of us Perlmongers loathed Python back in 2000. It was that smug thing that told you how it wanted you to format, that seemed to be rubbing its bespoke but dull syntax in your face. Then someone realized you can lint more than C and you can do it inline in a simple IDE. We had work to do, so we moved over. Then this... thing came out. Larry Wall's Chinese Democracy. It's New Coke, complete with an MS Paint drawing of a butterfly mandated with the mention of it. All the business investment in Perl 5 over the years? Screw them, says Larry. Join my latest cult. No thanks... even Guido isn't this weird. So we resent that there is no plan to merge in the Perl 5 track. There is no way to explain to your boss, "so, we'd have to rewrite everything in a completely different language: libraries, APIs, everything. Oh, and they haven't even stabilized on conventions yet." Larry lost track of a valuable part of any sufficiently complex system: that the emergent properties build the fan base, and the fan base builds the infrastructure. He really should know this well, since he comes from the evangelical tradition. You can't just toss everything and expect everyone to come along. We don't obey Larry: we solve problems for pay. Suddenly there isn't more than one way to do it. In many ways, there isn't yet a way to do it at all. We're burned out. We have tasks to solve.
The standard solution without smart match is to use one of the various modules that serializes your data (FreezeThaw, JSON, etc.) and do a simple string comparison. I.e., use strict; use warnings; use feature qw(say); use JSON; use Data::Dumper; my @one = qw(1 2 3 4 5 6 7); my @two = qw(1 2 3 4 5 6 7); my @three = qw(5 2 6 2 8 0 2); my ($json_one, $json_two, $json_three) = map { encode_json($_) } \@one, \@two, \@three; say Dumper( $json_one, $json_two, $json_three ); say $json_one eq $json_one ? 'yes' : 'no'; say $json_one eq $json_two ? 'yes' : 'no'; say $json_one eq $json_three ? 'yes' : 'no'; You should probably just check for list _length_ prior to serializing both (use `scalar @one == scalar @two` or similar) to save some cycles. But a string comp is far easier to read than iterating over two arrays at once. 
Hi, thanks for replying. &gt; you assume P6 is the community's rewrite of Perl. That was Perl 5. Hmm, wasn't the catch-phrase "the community's rewrite of Perl" associated with Perl 6? It was a popular phrase for years. &gt; Perl 6 started as Larry throwing a coffee mug during a conference two decades ago. Tiny point which doesn't matter, but wasn't it Jon Orwant who threw the coffee mug?
&gt; At that point, no one really cared about the speed of object creation. That was the sort of small thinking that caused Jon to throw the mugs in the first place. I'm confused: many (Perl 5) people have told us that the major thing wrong with Perl 6, was its speed. Increasing speed has been the focus of Perl 5 as well, as it has clearly become 2x as fast for object creation between 5.8 and 5.28? And now that's called "small thinking"?
Just for the record, that's not how any of this happened.
Then please explain.
&gt; Are there faster ways to check if arrays are identical than this? I would just use List::Compare.
I don't think you are actually confused. In that room, where I was, this was the small potatoes stuff that caused Jon to throw mugs. And yes, it's small thinking. It doesn't advance the language in a way to help people solve new sorts of problems. Most people have slow programs from bad programming and object creation speed isn't going to magically help that. It's not a paradigm changer. But I'm not trying to defend this hill or comment on any work that you've done or where Perl 5 or Perl 6 is today. I was in the room and I'm reporting what happened there. 
Larry didn't throw mugs. Jon Orwant did. Larry said that Perl 5 was his rewrite of Perl and Perl 6 would be the community's rewrite. I know this because I was literally in the room where it happened.
6.d *is* a major release. Minor releases would be e.g. `v6.d.1` And yes, it's "Perl 6 version 6.d", or more precisely "Perl 6 version 6.d" with a non-breaking space in the name. 
Not only do I stand corrected, but I have to apologize to one of my favorite Perl authors. Dang, I got science dropped on me by the Alpaca author. I misremembered the coffee mug part from a Perl 6 presentation at Boston.pm way the bleep back. ...I'm still annoyed about Perl6. I may have deeper issues if I'm that angry about a frickin' programming language.
My point is it seems wrong to have "6" be part of the version when that portion can always only ever be 6, forever.
That is a rational argument. It's subjective, but rational. Also probably important, if other people agree with you.
I assume you mean to find where lines end in CRLF instead of just LF. `perl -E'say scalar grep { m/\r$/ } readline' foo.txt`
I feel that sigils are very convenient in languages like Perl. I think that they are especially useful, and should be used more, in shell languages. I would love a shell that treated `$var` as a literal variable substitution without word splitting and `@var` as the same, except *word* word splitting. Also, I [cross-posted][pl] this thread to /r/ProgrammingLanguages, as this is just the thing I imagine they'd be interested in. [pl]: https://www.reddit.com/r/ProgrammingLanguages/comments/9mgqod/xpost_rperl_what_are_your_thoughts_on_sigils/
One of the coredevs works in marketing, actually. But it's impossible to get anything done as everyone thinks they're Marketing/Branding/Design experts and endless bikeshedding about every minute detail always ensues. IMO what's needed is more solid leadership. For someone to say: "This is our plan and it needs this job done. I trust this person to do this job. Don't inundate them by second-guessing all of their decisions. They report to me." There's no plan that I'm aware of and leadership restricts itself to resolving stalemates in conflicts. It might be a nice organizational structure for squeezing in an occasional PR without too much of red tape or training, but for getting things done, it's shit. 
If you have errant newlines and don't know what you're up to, trust [`\R`](http://p3rl.org/perlrebackslash#\\R). ‚Ä∫ hex f* ---- f0 ---- 0000 30 0 ---- f1 ---- 0000 31 0d 0a 1.. ---- f2 ---- 0000 32 0d 0a 0d 0a 2.... ---- f3 ---- 0000 33 0d 0a 0d 0a 0d 0a 3...... ‚Ä∫ perl -MYAML=Dump -0777 -lne' my ($tail) = /(\R*)\z/; printf "file_name: %s\tCRLF_count: %d\tnewlines_dump: %s", $ARGV, scalar(() = $tail =~ /\r\n/g), Dump $tail ' f* file_name: f0 CRLF_count: 0 newlines_dump: --- '' file_name: f1 CRLF_count: 1 newlines_dump: --- "\r\n" file_name: f2 CRLF_count: 2 newlines_dump: --- "\r\n\r\n" file_name: f3 CRLF_count: 3 newlines_dump: --- "\r\n\r\n\r\n" 
thanks. I'll try it later. does this count at the end of the file only?
For each line. If you just want to know if there's a CRLF at the end of the file that's easier. `perl -E'local $/; say "$ARGV: " . (m/\r$/ ? "CRLF" : "No CRLF") for readline' foo.txt bar.txt`
IMO the Perl 6 site doesn't look that bad. Sure the design is not as hot as the Ruby one but not bad either.
If I understand this correctly, there is now a Perl6 VM that can run inside of JS?
I totally agree with this. I feel like the are both stealing momentum from eachother to some degree. A name change wouldn't fix that, but it would help. 
i get moarvm and the jvm but JavaScript....why
Because it's everywhere and people want things to run in the browser.
&gt; might encourage modernization of Perl 5 That's called Perl 6.
Rakudo +1
I've modified the message, I'd appreciate it if you'd have another look at my problem. Thanks
I've modified the message, I'd appreciate it if you'd have another look at my problem. Thanks
Well I've guessed wrong twice so far and you still haven't explained what "identify and count" means, or whether you're strictly looking for CR LF pairs, but based on your output string here's another guess. Note that \R will match a lone CR or LF in addition to CRLF pairs, and $ will also match \n, and this still won't work properly on Windows with the :crlf layer. my $count = split /^/, $text =~ m/((?:\r\n)+)\z/;
A couple decades ago it was.
Yeah, maybe I'm not explaining myself well. OBJECTIVE: I want to be able to count paragraph markers at the end of the DOCX file to allow me to remove these and potentially save paper if/when the file is printed. To do this: I have a load of DOCX files. I'm using docx2txt to convert them to text files (I need to do this anyway for another part of the script). I'm reading this text file into one long string ($text). From there I'm struggling to get a count of these paragraph markers. I don't entirely understand your solution and it does not appear to work - it gives me 0 for each $text. 
Doesn't `chomp` output the number of newlines removed from the end of a string?
doesn't seem to
Yes.
PROBLEM SOLVED!
Is there a list of those goals?
You're doing it wrong, the whole point of IO::Socket::SSL is to avoid all the getaddrinfo() and socket() stuff. The manpage you should be reading is IO::Socket::SSL (or "perldoc IO::Socket::SSL" which is really the same thing), not Socket. For IO::Socket::SSL it's simply: my $sock = IO::Socket::SSL-&gt;new($ai-&gt;{addr});
If chomp works then you did not have CRLFs at all but just \n.
Yes, so that you can have a sane language running your website.
ES6 is fairly sane, plus its still running the front end under the Perl 6. This is probably a worse statement than "perl is line noise". A lot of bad JS is written in the world, but its partly a function of just how many monkeys with typewriters are writing it.
Sorry, didn't mean to flame. It's just an old, not very-tough-out language showing it's age. It's not an insane language, you're right.
This might be a good start - (Top 20 Perl Programming Blogs, News Websites &amp; Newsletters in 2018)[https://blog.feedspot.com/perl_programming_blogs/].
&gt; but wasn't it Jon Orwant who threw the coffee mug? It was.
YAPC or TPC searches on Youtube might show up a few useful videos, if you're into that sort of thing. https://www.youtube.com/user/yapcna Any particular area you're interested in?
These talks look great! I'll be checking them out for sure. My area is data crunching / munging. Anything in that vein is of interest. 
&gt; My area is data crunching / munging. Anything in that vein is of interest. Then perhaps I can point you at [Data Munging with Perl](https://datamungingwithperl.com/), which is out of print and, therefore, I can offer it as a free download. I mean, sure, it's a little dated. But free :-)
My [The Effective Perler](https://www.effectiveperlprogramming.com/) site covers most of the new features of each Perl.
I'm only slightly biased by the fact that [Perl Hacks](https://perlhacks.com/) is included in the list :-)
Curious that none of my sites are ranked there. I figure that's mostly because I'm not on Facebook, but apparently some of those aren't either.
I certainly haven't given them any money. I hadn't heard of them until a couple of days ago. I have no idea why my blog is included and yours isn't.
&gt; From that came the mostly useless exercise of the RFC process. Perhaps useless from your perspective that &gt; Perl 5 solved most of what we wanted In Larry's talks, he states that it was by examining the RFCs and studying the implied pain points that the syntax and other aspects of the Perl 6 language design were crafted. In other words, the RFCs were a valuable source of inspiration as they expressed collective user wishes for the language, regardless of whether any individual RFC was as practical or well-crafted as if you or MJD had authored it. It's not clear that those who submitted RFCs will necessarily want to learn a new language that addresses these underlying language design issues, however I think time has shown that the Perl 6 design offers sufficient value to have attracted developers and other contributors. How far the language's user base will expand is an open question, but the number of books becoming available and activity on stackoverflow are positive indications that Perl 6 does offer features that are valued by the programming community.
I will check it out! The title sounds like everything I've ever wanted.
I found i earlier today and it is exactly what I was looking for! Awesome site, and awesome books! Thanks for putting the time into make stuff like this available!
Just posting in case you get an answer.
There is a [pandoc module](https://metacpan.org/pod/Pandoc) available that might work for you.
Best would be to version Perl the same way Sun versioned Solaris or Java. Perl 5.30 -&gt; Perl 30 Perl 5.32 -&gt; Perl 32 That would show that we're not waiting to be replaced by Perl6 but moved on.
In short: [not yet, but hopefully soon](https://stackoverflow.com/questions/52727279/how-can-you-call-javascript-builtins-from-perl-6-with-the-new-js-backend)
dclone() creates a "deep copy" of a structure. In Perl, nested structures are created by references, if you say ``` my $ref1 = { key =&gt; [ "a", "b" ] }; ``` then $ref1 is a hash reference which stores an array reference under its only key. When you assign ``` my $ref2 = $ref1; ``` $ref2 now contains the same reference, i.e. both of them refer to the same hash. Changing anything in $ref2 changes $ref1 in the same way. The next step to fix it is to do a "shallow copy": ``` my $ref3 = { %$ref1 }; ``` i.e. you de-reference the original reference and point a new hash reference to it. Now, changing $ref3-&gt;{key} won't change the hash referenced by $ref1, but the array referenced under the key is still the same, so something like ``` push @{ $ref3-&gt;{key} }, 'c'; ``` would change the array in $ref1, too. To get a totally independent structure, you need to do ``` my $ref4; for my $key (keys %$ref1) { $ref4-&gt;{$key} = [ @{ $ref1-&gt;{$key} } ]; } ``` But what if there's another reference deeper in the structure? And that's what dclone() does for you. It copies all the values to new references, so you can change the structure without influencing the original one.
Cloning means to duplicate a data structure. Shallow cloning duplicates the top level only. Deep cloning duplicates everything. This is used to make sure that existing references into the existing data structure are not able to change the copy. This is best illustrated with an example, perhaps another redditor can provide one. The code you show does not appear to use the hooks mentioned specific to the Storable module: http://p3rl.org/Storable#Deep-Cloning This means you should be able to replace `dclone` with a similar working module that's hopefully faster: http://p3rl.org/Clone http://p3rl.org/Data::Clone
Here's my explanation: [Make deep copies](https://www.effectiveperlprogramming.com/2010/03/make-deep-copies/). But, there's also [The Storable security problem](https://www.masteringperl.org/2012/12/the-storable-security-problem/) to think about. 
I haven't, either, but Perlbuzz is on there.
Another option that should also be faster than Storable: [Sereal::Dclone](https://metacpan.org/pod/Sereal::Dclone)
Larry Wall is a linguist and has talked about it, you seek his interviews. He also explains it in his books.
Yes, iconic hat. Also love his enthusiasm. Makes me want to go forth and code!
Seems like Keno Antigen will never launch (sad tears here).
why not apache?
I did that (years ago) and installed Apache on windows from binaries. But this time looking at the Apache site it said there are no binaries to download, or it gave me a choice and I didn't know which one to pick. So I started looking at other choices. Is it easy to install Apache on Windows still?
[thrall](http://p3rl.org/thrall#DESCRIPTION) Install modules: * `Plack::Handler::Thrall` * `CGI::Emulate::PSGI` * `CGI::Compile` and put into `app.psgi` (tested): use Plack::App::Directory qw(); use Plack::App::CGIBin qw(); use Plack::Builder qw(); my $builder = Plack::Builder-&gt;new; $builder-&gt;mount( '/' =&gt; Plack::App::Directory-&gt;new({root =&gt; "/path/to/htdocs"})-&gt;to_app ); $builder-&gt;mount( '/cgi-bin' =&gt; Plack::App::CGIBin-&gt;new(root =&gt; "/path/to/cgi-bin")-&gt;to_app ); $builder-&gt;to_app;
&gt; Is it easy to install Apache on Windows still? With a [package manager](https://chocolatey.org/about), it is. [`choco install apache-httpd`](https://chocolatey.org/packages/apache-httpd)
I don't think "compile your own" is appropriate advice for someone who cannot even figure out which [ready-made build](https://www.apachehaus.com/cgi-bin/download.plx) to pick.
Alternatively you can install cygwin and proceed like you could have done on a linux system. (If you feel more comfortable this way)
Probably 0.9.21 
¬´ There have been some comments about the somewhat unusual version number. The problem was that David used a future date (2004.0904) in his version number, and the only way I could get CPAN to index my new module was to make it have a version number higher than the old one, so I chose the 9999 prefix and appended the real revision number to it. ¬ª https://metacpan.org/source/CAPOEIRAB/File-Slurp-9999.21/README
There is always WSL (Windows Subsystem for Linux) if you need something quick and easy.
Ahhh, thank you!
LOL it's true I'm a little rusty. I ended up picking the one from apachehaus and it's working fine. I enjoyed seeing all these great suggestions though. 
Don't let File::Slurp's high number of votes fool you: [it's fundamentally broken](http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html) (despite genio's heroic efforts to keep it installable).
[https://www.ritlabs.com/en/products/tinyweb/](https://www.ritlabs.com/en/products/tinyweb/)
Just use XAMPP.
Just because it isn't here already, if you've got Python installed you can start a web server on the command line. https://docs.python.org/2/library/cgihttpserver.html
To be fairer, giving a wrong version number can happen to most if not any versioning scheme. And if one uses a date-based version, one can actually add a pre-release check for this.
How does this work? You mention command line, but where is the detailed documentation for end users?
I was expecting it to be a lot more broken to be honest. It handles reading and writing of files in latin1 or utf8 (rather than UTF-8) which is good enough for 99% of people. I have switched my modules to Path::Tiny but most people do not have to panic and start replacing it asap if it's already working.
[File::Slurper](https://metacpan.org/pod/File::Slurper) is there for those who just want reading and writing.
I wouldn't be so sure; [this bug](https://rt.cpan.org/Public/Bug/Display.html?id=117005) has always been broken behavior and will be a fatal error in 5.30, and it hasn't yet been decided if/how it can be fixed. Now more than ever it's a good idea to replace it.
[cgi_this](https://metacpan.org/pod/cgi_this) is a similar Perl server, though thrall as mentioned by /u/daxim seems like a better fit for Windows.
There isn't really that much detailed documentation. See here: https://docs.python.org/2/library/simplehttpserver.html where it tells you do to `python -m SimpleHTTPServer 8000` ‚Äî it's basically that, only with CGIHTTPServer 
&gt;has different concepts mixed What concepts are you referring to here?
Re: Mug throwing https://www.nntp.perl.org/group/perl.packrats/2002/07/msg2.html http://strangelyconsistent.org/blog/happy-10th-anniversary-perl-6 &gt; We spent the first hour gabbing about all sorts of political and organizational issues of a fairly boring and mundane nature. Partway through, Jon Orwant comes in, and stands there for a few minutes listening, and then he very calmly walks over to the coffee service table in the corner, and there were about 20 of us in the room, and he picks up a coffee mug and throws it against the other wall and he keeps throwing coffee mugs against the other wall, and he says "we are fucked unless we can come up with something that will excite the community, because everyone's getting bored and going off and doing other things". &gt; And he was right. His motivation was, perhaps, to make bigger Perl conferences, or he likes Perl doing well, or something like that. But in actual fact he was right, so that sort of galvanized the meeting. He said "I don't care what you do, but you gotta do something big." And then he went away. &gt; Don't misunderstand me. This was the most perfectly planned tantrum you have ever seen. If any of you know Jon, he likes control. This was a perfectly controlled tantrum. It was amazing to see. I was thinking, "should I get up and throw mugs too?" 
Personally I like Perl because you can do many things with short code and it is a good option for hacking or security in general. 
Anything involving untrusted data (I don't know of any other language with something like perl's taint mode) Anything involving doing stuff with text files or textual data. Anything a bit more complicated than you'd want to do with a shell script. 
Text processing, Regex built in, has some OO constructs (more so with Moose), higher order constructs like closures, some nice basic data structures like arrays and hashes built in, nice Database API via DBI, nice web frameworks like Mojolicious and Catalyst, nice command line options, awesome community and documentation, rapid development and prototyping.
Many of its strengths are shared with those of other languages, but in my opinion, its main strengths are first-class regex support, the prevalence of lexical scoping, the vast repository of [CPAN](https://www.cpan.org), and the flexibility to solve problems in the way that works best for each author and each set of requirements. Here's a [similar but slightly different](https://www.reddit.com/r/perl/comments/7xccke/why_do_people_like_perl/) thread from a while back.
Text manipilulation, especially creating and manipulating code from itself and other languages on the fly.
Hear! Hear! Perl is good for almost any kid of computing, especially *creative* computing. 
Someone once described Perl as "the Cliff's notes to Unix".
I don't know about faster, but it's more fully-featured and flexible than bash. I'm not qualified to talk about awk.
&gt; It's strength as a web programming language was, I think, more from the early days. I think modern stuff like Python, Ruby and Go (and others) are better for web stuff. Out of curiosity, have you used Mojolicious?
No.
Yes, definitely. More structured, better syntax and more features (it started as a superset of sh, grep, awk and sed.)
I once wrote a data analysis script within a few hours because we had made more than 65,535 widgets in one quarter and the Excel spreadsheet blew up. Import CSV, mangle the data and run the same statistics as the spreadsheet, write CSV. Done.
A classic answer, which is still true in my opinion, is perl's "[whipupitude](http://modernperlbooks.com/mt/2012/07/whipupitude-versus-very-serious-perl.html)" in that it is easy to "whip up" proof of concept code quickly to test an idea out. Sometimes that code works well enough that it just ends up in production... which is also one of perl's strengths... but also a weakness.
[removed]
It's good at many things, but one of my favorites is [Autovivification](https://en.wikipedia.org/wiki/Autovivification). Basically you can just start assigning arbitrary values as far down a hash structure as you want, without having to define that those structure exist or what they're called. That's particularly useful if you want to make a two-dimensional hash. Say you're going through a bunch of names of people and cities. And you want to see an index of first names, and then cities for each name. $index-&gt;{$first_name}-&gt;{$city}++; Then you change your mind and you want to see cities, and the names in each city. You just change how the data structure gets populated, but there is no definition to change around: $index-&gt;{$city}-&gt;{$first_name}++; The typical use case for me on things like that is two levels deep, but you can go as deep as you want.
**Autovivification** In the Perl programming language, autovivification is the automatic creation of new arrays and hashes as required every time an undefined value is dereferenced. Perl autovivification allows a programmer to refer to a structured variable, and arbitrary sub-elements of that structured variable, without expressly declaring the existence of the variable and its complete structure beforehand.In contrast, other programming languages either: 1) require a programmer to expressly declare an entire variable structure before using or referring to any part of it; or 2) require a programmer to declare a part of a variable structure before referring to any part of it; or 3) create an assignment to a part of a variable before referring, assigning to or composing an expression that refers to any part of it. Perl autovivification can be contrasted against languages such as Python, PHP, Ruby, and many of the C style languages, where dereferencing null or undefined values is not generally permitted. It can be compared to the HTML standard's "named access on the window object" which results in corresponding globally scoped variables being automatically accessible to browser-based JavaScript. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Things I go to perl for are usually when text processing, or index lookups. Bash can do both, but slower, and I wouldn't bet my pennies that the script could be running where those features predate the bash version. Perl is more constant and believe it or not, often cleaner to read.
* perlcritic
**There's more than one way to do it** There's more than one way to do it (TMTOWTDI or TIMTOWTDI, pronounced Tim Toady) is a Perl programming motto. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
&gt;jplin A few examples: Does a Path::Tiny object represent an actual path on the filesystem, or an abstract one? Yes and yes, and sometimes it's not clear which/when. path("foo")-&gt;child() is still abstract, but path("foo")-&gt;children will read the filesystem. Does a failure result in an exception? Sometimes it does, but sometimes undef/empty list is returned instead (including when one attempts to slurp a directory). Why does is\_file mean only "regular" file (excluding symlink to a file) while is\_dir allow symlink to a dir? I think my cup of tea for a Path::Tiny equivalent would be a non-OO module that provides a relatively complete file/dir/I/O routines that are more consistent with the way Perl behaves. Or I'm just fine with using directly the set of core Perl modules that Path::Tiny uses, e.g. File::Temp, File::Spec, etc.
What is your idea of sane?
You want to read a config file, but do not describe the format in sufficient detail. If you control the config file, replace it with [ini](http://enwp.org/INI_file) and read it with [Config::Tiny](http://p3rl.org/Config::Tiny). Otherwise you need to provide the real config file, not an approximation of it. ---- Other style improvements: Please do not retype your code, instead use copy/paste. You should not make the people who want to help you guess what the real code is. incorrect|correct ---------|------- `10::Socket::SSL`|`IO::Socket::SSL` `SSL cipher list`|`SSL_cipher_list` `'ECDH+AES128‚Ä¶'A`|`'ECDH+AES128‚Ä¶'` `II`|&amp;#124;&amp;#124; You do not need to put quotes around single variables, Perl is not shell; e.g. instead of `"${address}"`, simply write `$address`. The space in the hash key `' config'` is unusual and most likely a mistake.
When I program in Perl, it's almost as though I'm able to engage the natural language part of my brain - the part that processes spoken/written languages like English. If you think about how powerful that is, that here is this programming language that enables you to be expressive with your right-brain, well - it's powerful. I'm not saying I make great code when I'm programming like that. But when you program Perl for long enough, your intuition has a shortcut to becoming code. That's the best thing about it. It comes out as easily as writing sentences in English (for a native speaker with good reading comprehension, I suppose). 
I feel like I should know awk better, but once you know Perl and a few of its command line options, there doesn't seem to be a reason to bother.
When was the last time anyone actually wrote something using -T though?
I'm maintaining a custom web app with it. Haven't needed it yet but it's caught me doing insecure development.
Glue. I know of no other language that makes it as easy (sometimes) or possible (other times) to stich together libraries from a bunch of different languages. There are lots of other things as well, but I've yet to see this done well in other languages yet.
Sadly the "ubiquity" is not really true any more. Places Perl is not usually found include: - Windows - Android - iOS - okay, make that most of the "internet of things" However, if you're running a Unix-ish server, then you *do* most likely have access to Perl. That's still a very useful resource.
If you're writing something very simple then yes, the 3-word answer of TAP is great. However, overall I find Perl's automated testing and framework options to be dated at best. Here's just a few things that other languages have: - [quickcheck/rapidcheck](https://wiki.haskell.org/Introduction_to_QuickCheck1) - automatically generate test cases, and when you hit a failure, simplify the autogenerated inputs to generate a minimal version. Granted, there's a partial implementation in [Test::LectroTest](https://metacpan.org/pod/Test::LectroTest) but how many Perl distributions actually use this? - [rich XML results specification](https://github.com/windyroad/JUnit-Schema) - metadata including timing information, different data types (embedding YAML in TAP output is at best a hack), structured "expected"/"actual" output... - [tagging and attributes](https://nose.readthedocs.io/en/latest/plugins/attrib.html) - run subsets of tests or group results I've seen the "Perl is very good at testing" assertion several times, and I think we're missing out on just how far other languages have come in the last few decades. Have a look at https://codecept.io/ for example. We *could* have something like this in Perl, given time and effort, but I'm not aware of anything that is currently even close. I believe part of that is complacency.
I've setup something very much like CodeceptJS for work. And that's my point. TAP started at the right layer of abstraction, where you can add on whatever you need.
&gt; sometimes undef/empty list is returned instead (including when one attempts to slurp a directory). Have you reported this as a bug? Your other criticisms are reasonable though I don't agree that they're problems.
Perl is a programming language. It has concrete advantages and disadvantages. To describe it with metaphors is absurd. If someone asks you what engine works best, and the response you get is that the Honda engine is a * "Painters pallet" * "creative computing" * "whipupitude" You should rightfully **run** away.
 Here, I'll give it a shot. There are a lot of things not to like about Perl, but one of the things that I do like is that everything does something, regardless of whether it's sane. For example, hashes behave as lists in list context. There is no particular reason why they should, but why the fuck not -- right? It's Perl. perl -we'print "\n$_" for %{+{foo =&gt; 1, baz =&gt; 2}}' perl -we'print "\n$_" for (foo =&gt; 1, baz =&gt; 2)' The opposite is also true. And that makes a little more sense: because functions are only ever supplied a list of arguments declaring a function that receives a hash means that the function will coerce the list into behaving as a hash. perl -we'sub foo { my %args = @_; print $args{foo} } foo( foo =&gt; 1, foo =&gt; 2 );' And, because why not. It's perl.
This is true if **running code** was the only thing that mattered. It is not. People also have to \*write\* code; They express concepts through code, try out new and creative ideas, and quite often in a "one-to-throw-away" manner. Having a flexible "painter's pallet" that let's one be creative can be exactly what's needed to solve a problem. :)
And suck data out of a .txt file, suck more data out of a web service, and trigger some functionality in program periodically, based on that data, to accomplish a sysadmin task. It's the glue that binds different programs together.
So perhaps a Honda engine is not the best choice when you're looking for a scripting language?
Any sort of text or string processing is amazing with Perl, as is any sort of interaction with a unix system. In my previous job we used it on a massive ETL pipeline that processed millions of jobs per week, most of which consisted of text data. It was a breeze. 
I \*\*love\*\* autovivification and miss it so much in Python.
But that doesn't tell me anything of how it's easier to *write* code either. I could say I like Perl because writing it gives me a good hallow unicorn dildo and it wouldn't tell anyone anything about the language itself. You could however say that you like negation built into your conditionals and Perl is the only language that provides `unless`, or you could say like the indirect object syntax: `new UnicornDildo Hollow =&gt; 1;`
Python is a better Perl for any non-trivial script these days and to be honest I think we could simplify and improve a lot of Linux distros by putting in a concerted effort to eliminate Perl entirely. Problems with Perl include: * duplicate ways of declaring things (reference vs non-reference) * the begin block arms-race * no parameter declarations and people depending on ‚Äúthe last statement‚Äù accidentally. * bad multi-threading support * use of warn instead of carp croak means frustrating to debug other peoples code. * the other 500 things people do from PBP because they have no brains. (Eg return false instead of undef) * people using wantarray (e.g. Dbix::class) * try catch implemented by using two closures (which subtly changes return keyword behaviour and has a syntax gotcha) * forgetting to use &lt;=&gt; instead of eq or vice verse. * having to read the same blog post every week that you aren‚Äôt using the right open file method. * people who think ‚Äúuse utf8‚Äù makes your app support utf8. * having to ‚Äúuse strict; use warnings‚Äù everywhere, but oh no not in Dancer, we import it for you so you can forget that easy to follow and consistent rule you had for everyone. * having to convert objects between blessed/moose etc * serialisation libraries that can‚Äôt decode booleans or ‚Äú1‚Äù (number-as-a-string) * no sane sigterm/interrupt handling. Hope that library with a thousand dependencies doesn‚Äôt interfere with your shit bro. * cpan generally crashes out of the box on Debian last time I checked. Thousands of failing tests and locale comparison failures. I forget the other reasons I dislike it.
So you consider the artistic components of programming, and how the language supports the ability of the programmer to express him or herself to be an unsuitable arena for answering what the Perl language is good at? Second, how technical an answer would be appropriate to such a general question? How would you answer the question for Python, if that is an interest of yours?
&gt; Places Perl is not usually found include: &gt; &gt; Windows Actually, given how many developers install [Git for Windows](https://git-scm.com/download/win) and/or [VS Code](https://code.visualstudio.com/docs/setup/additional-components) and/or recent versions of [Visual Studio](https://www.oreilly.com/library/view/mastering-visual-studio/9781787281905/61432953-a0b3-4b16-b1fb-2636f7271582.xhtml), you are bound to find Perl on a large number of machines. Sure, it's a crippled install, but you can always [`fatpack`](https://metacpan.org/pod/distribution/App-FatPacker/bin/fatpack) stuff, and it will run. I believe the my Visual Studio install came with v5.24.
&gt; artistic components I consider artistic components to be an entirely subjective description-lacking method of describing a language. If I said I like the "artistic components" of the natural language spoken by people of Northern Timbuktu to be superior, would you be at all moved to go learn it? It would mean nothing to you.
TBH whenever I have to dig through the Mojolicious source in order to understand an underdocumented feature, I am shocked at how cryptic and outright golfed the code base is. Sure, Mojo is totally object-oriented and has *very* nice capabilities, but I wouldn't necessarily put it out there as a shining example of modern Perl.
There are a lot of things Python does better than Perl, or things where Perl has legitimate issues. Your list isn't about that, but is mostly about your minor squabbles with the Perl data model (JSON type mismatch, numerical vs string operators, ‚Ä¶). And some of the problems you list are shared similarly by Python. A few spotlights: * For example, multithreading. Perl's threads (if enabled) allow true parallelism but no shared data. CPython allows shared data but no parallelism because of the GIL. Either choice is ‚Äúbad‚Äù, and both ecosystems have moved towards either forking a subprocess (if parallelism is needed) or enabling concurrency through event loops (which Python admittedly does better due to native async/await support). * I really miss "use strict; use warnings" in Python, where I instead run a suite of linters (flake8, mypy, pylint) over my code. Gradual type checking with Mypy is awesome and I wish Perl had that, but without those external tools vanilla Perl is a lot nicer than vanilla Python. Alone the requirement to declare "my $variables" is super helpful. On the topic of warnings, Python has a similar "warnings" module but it's mostly just used to mark functions as deprecated, not to point out possible bugs at runtime. * Perl's throw { ‚Ä¶ } catch { ‚Ä¶ } equivalent is the cryptic "local $@; eval { ‚Ä¶; 1 } or do { ‚Ä¶ }" idiom. You complain that try‚Äìcatch as implemented by third party modules (Try::Tiny?) messes up "return". That is true, but at least Perl provides some mechanism of syntactic abstraction. If this were missing from the Python language, there would be no way for a module to add new syntax: decorators or reflection are very limited. For scripting problems, the question is usually how easy it is to run other programs and how easy it is to munge the output of that program. Perl's builtins (qx, system, open) are difficult to use safely, but Perl's IPC::Run and Python's subprocess modules are equally fine. However, Perl's supreme regex integration makes data extraction and filtering much easier. For larger scale problems, I find that only the existence of Mypy breaks the tie for me ‚Äì other people that don't value static typing as much might decide differently. Other ecosystem concerns tend to be more important than minutiae of the syntax.
Fear not: from collections import defaultdict turtles = lambda: defaultdict(turtles) some\_autoviv\_variable = defaultdict(turtles)
All of the special variables are documented in [perlvar](https://perldoc.perl.org/perlvar.html). `$_` is the default topic variable and `@_` is the subroutine argument list.
Hi, I can't remember all of them, but $_ is, or was, the most used I suspect - it's the default variable, the one everything works with unless you specify something. So, here's a little script which uses $_ even though it doesn't explicitly say so anywhere. open(F, 'a_file.txt'); while(&lt;F&gt;){ print; } Create a file called a_file.txt and put some lines of text into it, then put the little script above into a .pl file and run it. The while(&lt;F&gt;) statement reads lines, one at a time, from the file F - and puts each line into a variable called $_ The print; line, prints the contents of $_ Both statements work on $_ unless you tell them otherwise. Using default variables is probably bad for the blood pressure of anyone who has to maintain your scripts, I don't recommend using them.
&gt; Meanwhile the world changed Everything after this line feels about right.
You perhaps already know this but to recap: * `$` means "treat this as a single item". Note how the symbol overlays an `S` for `S`ingle with an `I` for item to emphasize treating it as a singular thing (even if that singular thing is a reference to an array). * `@` means "treat this as an integer indexed array of items". Note how the symbol is an "at" symbol that overlays a `0` with an `a` for `a`rray because an array contains zero or more items indexed "at" indices starting with `0`. * `%` means "treat this as a dict (hash) of key/value pairs". Mnemonic is that it's a key`/`value pair that uses two `0`s because it contains zero or more pairs. * `_` means "fill in the blank". So: * `$_` means "it" aka the topic in a given context. What is it in the current context as I write this? It's your question. What is it at any given point in code? It's the current topic aka `$_`. * `@_` means "them, by number" aka the arguments, numbered one by one, in a given context. What are the numbered arguments provided in the current context as I write this? It's the comments replying to your question if we assume a particular order. What is it at any point in code? It's the current list of arguments aka `@_`. * `%_` means "them, by name". In Perl 6 these are named arguments. What are the named arguments provided in the current context as I write this? It's the comments replying to your question indexed by the author who wrote them. What is it at any point in P6 code? It's the current list of named arguments aka `%_`. (Note that my analogies are weak. In P6 an argument must be either numbered or named, it can't be both.)
Short answer: &gt; *EVERYTHING*.
IIRC python's RE engine is, or is very close to PCRE, so little to no conversion should be needed. And those regexes would greatly benefit with some /x, m||, and other love.
nice explanation.
You're including things in the RE that should be in the replacement string.
The `_` file handle is used with file test operators, `stat` and `lstat` to refer to a cached copy of the last results of statting a file.
Is it? Well, I've been running training in this stuff for almost twenty years. I'm supposed to know most of the obscure stuff :-)
I'm curious what parts of the source you've read; Mojolicious source code certainly prioritizes terseness, but it generally isn't outright obfuscated except in cases where it needs to be hyper-optimized (e.g. Mojo::Base code used almost everywhere in the code base for object classes). The project would also certainly appreciate feedback about any feature that might be considered underdocumented, provided you've read all of the guides and not found the answer there.
FWIW, [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) implements a try/catch that does not have those issues.
This is a great practical explanation. The [$_ docs](https://perldoc.pl/variables/$_) list the built-in aspects of Perl that either assign to or read from that variable by default.
I've been using perl since... 1995 or so and still learn new things about it on occasion.
Yes! A good place to have this discussion is on the #epo channel on [irc.perl.org](https://irc.perl.org). They also accept pull requests with suggestions, if you have some good ideas. :) [https://github.com/EnlightenedPerlOrganisation/task-kensho](https://github.com/EnlightenedPerlOrganisation/task-kensho) Did you have something specific in mind?
Yes that works perfectly, thanks a lot for the help. &amp;#x200B; My initial solution was this: $criteria-&gt;{'history_entries.date'} = {} if $from | $to; $criteria-&gt;{'history_entries.date'}-&gt;{'&gt;='} = $from if $from; $criteria-&gt;{'history_entries.date'}-&gt;{'&lt;='} = $to if $to; But that really didn't work at all.
Definitely! Well volunteered :-)
That's very close, and likely was only not working because `if $from | $to` is using the [bitwise-or operator](https://perldoc.perl.org/perlop.html#Bitwise-Or-and-Exclusive-Or), not the [boolean logic or](https://perldoc.perl.org/perlop.html#C-style-Logical-Or) (which would be `if $from || $to`). But, you don't need that first line because of [Perl's "autovivication" feature](https://www.effectiveperlprogramming.com/2011/04/understand-autovivification/). It'd be fine to leave it in, but it's extraneous. You also [don't need the second `-&gt;` in lines 2 and 3](https://perldoc.perl.org/perlreftut.html#Arrow-Rule): It's fine to leave them in, but leaving them out Perl will figure out what you mean. So, the only real difference between killinrax's solution and your attempt is the `$from | $to` bit.
Thanks for sharing your explanation. Autovivication looks like an interesting feature.
I, for one, would love to see Test2 on the list :)
Why not just do: `perl -MCarp -e 'print $Carp::VERSION, $/;'` &amp;#x200B;
They wanted to mess with people who use this idiom for finding the installed version perl -MFile::Slurp\ 9999
And you're method will fail with File::Slurp if you have one 9 less ;) `perl -MFile::Slurp\ 9999 -e 'print $File::Slurp::VERSION, $/'` `# print 9999.19`
If you just want the version number shown, without any need to do something with it, then this is enough: `perl -MFile::Slurp\ 99999999 -e1`
There's also https://metacpan.org/pod/V which is older and works almost the same.
Look at me! I'm mister not-reading-the-article! :-D
Look, perl is awesome at a few things, particularly "just making things work in unix" but in 2018 its not a language to look at to do webdev. If the question was "I love perl, and want to experiment with webdev in perl!" I'd have a wildly different response to you, but if you're this new, this isn't the way you want to start.
If you want a simple to install web dev environment in Perl, have a look at https://mojolicious.org You can get it up and running with a simple command and there are good tutorials on how to get started 
If you want a simple to install web dev environment in Perl, have a look at https://mojolicious.org You can get it up and running with a simple command and there are good tutorials on how to get started 
How is mojo with production deployment? This seems to be what the OP was most hung up on, and it was definitely my biggest hurdle getting my apps running with Catalyst. Would be cool to have a pythonanywhere or heroku workalike for Perl.
Here's my fork of [Mojolicious::Command::deploy::heroku](https://github.com/rage311/mojolicious-command-deploy-heroku) that does just that. The version on CPAN doesn't work anymore and has been abandoned by the original author. I've also got one in the works for dokku, which is a self-hosted and open source heroku-like deployment platform, and what I prefer these days. Digital Ocean even has a 1-click installer for a dokku droplet (VPS).
If you were going to try the CGI route then I'd agree with you, but Mojolicious is a modern and capable web framework.
The question then is, will they act on issues or pull requests?
But just typing "hypnotoad start" is not a production deployment! What if the server reboots? For a beginner, figuring out a service manager like systemd or reverse proxies like nginx can be more complicated than writing the app itself. (It was for me when I tried to deploy my first Mojolicious app). Of course this is on par with other modern web frameworks, but Python and Ruby have a huge ecosystem with easy to use PaaS style deployment options. Perl and PHP look attractive for beginners because you can use them on cheap shared hosters, except that ‚ÄúPerl‚Äù there just means ‚ÄúCGI‚Äù which *cannot* provide decent performance (because of repeated app startup for each request) and makes asynchronous features inaccessible.
&gt;Look, perl is awesome at a few things, particularly "just making things work in unix" but in 2018 its not a language to look at to do webdev. This narrative isn't true any more (as pointed out by several others here). Time to update your priors! :)
&gt; I'm wondering if there is a trick I'm missing... One of Perl's "weaknesses" is that it has so many options with documentation scattered all over the shop over so many years that it can be hard to find the right document/help for figuring out which way to go. But there will be a reasonable way to do whatever it is you want done (unless you want to do something unreasonable, and maybe even then). So the trick is to ask questions as you've just done. :) Just keep asking questions whenever you get stuck or remain confused. Perl folk will then guide you all the way, even as they disagree among themselves. (Beware simplistic answers that don't get significantly upvoted. Other than that, if you don't get the answers that you need, post some follow up comments explaining where you're still confused or stuck to move things along.) I look forward to seeing you post a dozen follow up questions with interesting answers here on the way to a great web site. :)
I've been a Perl guy for a long time, and I want to encourage you. But I can't help but wonder why a _beginning_ web developer would choose Perl for that. The problem is one of adoption and support. The more supported something is, the more documentation can be found, and tricks and tips, and simple, supported hosting options, etc. I would be happy to help anybody do web development with Perl, if that's really what they want to do, because I use it for web development, and I think it's a wonderful language, of course. I guess I'm just not as much of an evangelist as I used to be. It's harder to encourage people to use Perl in the face of decreasing adoption.
One of the benefits here is consistency. While there are lots of possibly good ideas that other languages have at their disposal, what they generally lack is for every module to use the same user-facing interface. And add to that that most languages treat "running the tests" as something only developers do, not something that is standard fare for execution during installation. Even if *featurewise*, our system leaves much to be desired, in terms of *effectiveness*, that's where it shines.
In fairness, most of the applications of "non-references" in regards to passing arguments to functions only really applies to primitive scalar values, like strings and integers. If you're going to pass an Array or a Hash or an Object to a function, by-reference is the only way. ( Because otherwise, you'll be passing a Array/Hash deconstructed into a list of scalars ) But python has immutable scalar values, so having the ability to choose between reference and non-reference passing doesn't help you. Whereas with Perl, being able to decide what you're going to do there allows a few things that would otherwise be difficult. eg: if you have a parser implemented as a collection of functions, and you pass input as a string , you can instead opt to pass that string by reference, and have the functions "eat" parts of the string as it goes, whereas with python, I'd imagine you'd be forced to design it differently, and perhaps need to return the modified string among other data structures, resulting in lots of extra work, and memory overhead. And there are useful applications of "passing a Array/Hash deconstructed into a list" that otherwise require specific alternative mechanics in languages like JS (eg. invoking `foofunction.call(...)` or `foofunction.apply(...)`) Surprising to newbies, yes. But also very useful to people who understand what they're doing. 
I don't disagree with using `%{ ... }` or `@{ ... }` to turn lists or whatever into list context and process them that way, if you are advanced. Even doing this would be fine: `my $arrayRef = [ @{ ..array processing.. } ]` to instantiate a list is fine. I just feel that having both `my $arrayRef = []` and `my @something` to define a single array is confusing for new people. That's as far as my comment on the matter goes really.
Most of that stuff covered here: [https://mojolicious.org/perldoc/Mojolicious/Guides/Cookbook#Hypnotoad](https://mojolicious.org/perldoc/Mojolicious/Guides/Cookbook#Hypnotoad) I ended up rolling my own solution that's more framework agnostic but honestly after googling "mojolicious production" and seeing this guide for the first time what I threw together is almost identical. I think the process would be similar in other languages like Python and Ruby too. Maybe it has less to do with what language you're developing in and more to do with the software that manages and interacts with it, like systemd and nginx.
All modern frameworks can run in CGI mode, the rest of them do it via [Plack](https://metacpan.org/pod/Plack::Handler::CGI).
I don't know what JSON libraries you've used but [Cpanel::JSON::XS](https://metacpan.org/pod/Cpanel::JSON::XS) and [JSON::PP](https://perldoc.pl/JSON::PP) now have improved number detection, so it's more likely that a value will be encoded to a string or a number as you intended. I describe the difference [here](https://metacpan.org/pod/Mojo::JSON::MaybeXS#Upgraded-Numbers). Cpanel::JSON::XS is the default encoder used by JSON::MaybeXS for this and many other reasons.
Most hosts I've seen using CGI actually use FastCGI, which avoids the process starting overhead you mention, there's virtually no reason not to use FastCGI on a shared hosting environment afaik, so it seems unlikely (but I guess possible) that anyone would still be using old-school CGI on a shared host.
&gt; FastCGI I'm a big fan of FCGI, to me it is the happy middleground between mod_perl and CGI. Obvious problems with mod_ style development is consumption within the HTTP server, whilst in fcgi models it is relatively easy to simply pkill overly busy tasks. Definitely my preference.
This. Oh, one hundred times this :-)
In (1) you are saying that scalars should not be able to hold references, and in (2) you say that JSON libraries have bugs. As a professional programmer since 1980, no, I do not understand your points.
Its the JB weld of \*nix. 
I tell folks: Learn Mojolicious. (It happens to use the Perl language.) 
Have you tried connecting to localhost on port 3306 with telnet? Maybe try 127.0.0.1, localhost might magically try to use /tmp/mysql.sock or something.
Windows 8.1, which is what I'm using, doesn't include telnet, so no, I haven't yet. I tried the 127.0.0.1 thing and it didn't work either. 
I spoke too fast. Turns out it's there but not enabled by default. I enabled it. `telnet localhost 3306` gives me a prompt that looks like garbage and when I press a couple of keys it dies with: "Got packets out of order / Connection to host lost." 
Ok, that sounds great. I think you should try ur $dbh = DBI-&gt;connect( "DBI:mysqlPP:database=$database;host=$db_host;port=3306;mysql_enable_utf8=1", $db_user, $db_pwd, { 'RaiseError' =&gt; 1 } ); 
You don't get any kind of connection error? That seems really weird to me.
Which Perl are you using? I had endless DBI problems on Windows but switching to Strawberry Perl fixed them.
No you don‚Äôt understand my points at all. I pity you.
You mean just adding the port? I tried that, with the same result. 
The garbled data you're getting from telnet is likely a good sign that you're connected properly. To check whether the connection is indeed working properly you could download a windows mysql client and try connecting with it to see if it can then do queries, list tables, etc. &amp;#x200B; Also, how do you know your script is dying without a connection? Is it giving an error message? 
So its listening. Next step is to get it to connect with those credentials with the command line mysql client: $ mysql --host=localhost --user=user --password=mypwd Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. mysql&gt; Can you get that going? If it errors, what does it say? 
I'll have to check it later, because I'm moving right now (about to turn off and dismantle the PC). ;) But my script closes automatically before I can see any errors. If I restore the data for the remote server, though, it works properly. So it's not connecting to the local version as it should. I'll try running it without the GUI so that I can see the error message on the terminal. But I'll have to modify the script a bit. I can't right now. Thanks for your help!
To see what's happening, add this line after setting `$temp`: `print "&gt;$temp&lt;\n";`. Then read up on `chomp`.
To add to the other comment, if you were using positive comparisons instead of negative (`eq` rather than `ne`), your code would be simpler and more-intuitive and you probably would've determined your issue sooner
Look up how to write a perl program. Then look up how grep works. ``man`` is your friend.
i did but I am still confused because when I grep the array with |grep /pattern/ nothing comes out of it /pattern/ being /koalas/ thanks for the helpful suggestion but you aren't helping me from anything ive already looked at and don't understand completely... which is why i am here...
If you quote what you're actually doing instead of unsuccessfully trying to describe it (which makes me think that you don't know what you're doing and have to start from scratch) that would be a start.
k
https://perldoc.perl.org/functions/grep.html As /u/rrohbeck has said, pastebin your code, it would be easier to tell you what you are doing wrong. My thought is that you are doing something semantically wrong.
In this case, `perldoc -f` is his friend.
fixed it for pseduo code...
fixed it for pseduo code...
Ok, that makes sense. Look at usage of grep in perl doc (and that should work). Keep in mind that grep returns a list, not a single item.
thanks for being nice though :D
thanks for being nice though :D
thanks, cool stuff, but please read the problem. 
Normally when we think of arrays, we think of them as being homogeneous (each item is the same type, and contains the same kind of data, as the other items). Perl doesn't require this, but when using heterogeneous arrays, a justification or explanation on behalf of the programmer is appropriate. Your pseudo-code arrays don't make sense to me (or the other skilled programmers responding to you). Not the syntax, but the actual data values you're displaying. You haven't told us enough about what the values they contain are, or why, for us to be able to help answer your question. Which is why you've had a number of requests for non-pseduo-code, because the real code might enlighten us to the real meanings here.
thanks, you're the first person to be helpful instead of telling me to read more when I have read a lot, and still need help... So a list; Say i had an array where one line had "# cool people, % of weird people, # of people who care"; but that's just one line of an array, how am I supposed to grep or get that value of the # of cool people and store that in a scalar vs % of weird people in its own scalar. i originally used AWK but the lines that it's supposed to find can be different in another array. 
what do you mean by "multi line array"? Arrays contain items, not lines, and are always assumed to contain multiple items. Strings (could) contain lines. So you could be referring to an array of multi-line strings? The last item in your array seems to be heterogeneous to the other items in it. Is it a comma-separated list in a string? Are the other items in your array comma-separated lists in a string?
yes the last line can be comma seperated, I am trying to get the value for each part of the csv line. If the line contains "koalas" which is supposedly the pattern? 
Now it's starting to make more sense. Your array is composed of the lines of a CSV input. You need the line of the array containing the string 'koalas'. Further, you need to then split that array element on commas, and from that resulting array, get, again, the element containing the string 'koalas' You also seem to want a value (the number of koalas) from a different array. I'm not seeing what the relationship between those arrays is. Can you provide more background?
you're close I am trying to grab a value from an array that can have csv's in the line and other lines not csv/ empty/ useless. I just want to grab the line that has koalas in it with grep than grab those values. I tried using AWK but I got stuck when the Array had different lines that had the # of koalas. I want to be able to find that line is all. and from there i can just split fro, csv and put it into a scalar.
 $ perl -e 'use v5.10; my @arr = ("a","b","c"); my ($l) = grep { /b/ } @arr; say $l' b
so how do i distinguish between my @arr =("a","b","c"); grep { /b/ } @arr; say $l' vs my @arr =("a","b,4 here1,3 here3,2 here4,","c"); how am i supposed to grab , 3 from here3, and 2 from here4? 
You're doing two things here. Array manipulation and string manipulation. Grep on an array can only give you elements. Once you have the element you want, you need to do string manipulation on it to get components of it. For example, my @array = ( 'This thing', 'That thing', 'The other thing', '#of people who love koalas, % of people who love pearl, # of people who like computer science', ); my ($l) = grep { /koalas/ } @array; say $l; # "#of people who love koalas, % of people who love pearl, # of people who like computer science" my @components = split(',',$l); # @components = array('#of people who love koalas','% of people who love pearl', '# of people who like computer science'); my ($k) = grep { /koalas/ } @components; say $k; # "#of people who love koalass" 
Of course, if this is actual CSV data, you should use something like `Text::CSV` to parse your CSV lines instead of doing it yourself, as there could be complex quoting issues involved
I really do want to be nice but what you just wrote only has a vague similarity to Perl.
I have to do it by only perl, no external libraries, i was just super confused, by how to use grep with an array that might or might not have commas in that line/ could be any line of an array. 
 K well instead of just letting it be I deleted it so nobody can ever learn :D
Looks like if the page doesn't get the cookie that it expects (that was set on the previous request by the javascript) it redirects to that page with the javascript. Should not pose a problem, but you'll need to set a cookie that emulates what that javascript is doing. In this case you'll just need to set "beget=begetok" I guess. There's no general solution without reading the javascript and understanding their requirements, in each case. Additionally, you may find Mojo::UserAgent an easier to use tool over LWP::UserAgent.
That would limit my script, I'd like to be able to user on multiple web sites but since each has its own unique set key and hash.
Did you test this? $temperature = chomp($temperature); `chomp` doesn't return the chomped string, it returns the number of characters removed.
Then you will have to look at PhantomJS/Selenium or similar. You might be interested in https://metacpan.org/pod/WWW::Mechanize::PhantomJS 
I did not and I said as much. 
You don't chomp `$temp`. Why is you expression for `$temp ne 'C' quoted?
Less than 14 hours to go!
The `-D` switch to cpan can do this: $ cpan -D Mojolicious Reading '/Users/brian/.cpan/Metadata' Database was generated on Mon, 22 Oct 2018 01:54:17 GMT Mojolicious ------------------------------------------------------------------------- (no description) S/SR/SRI/Mojolicious-8.04.tar.gz /usr/local/perls/perl-5.28.0/lib/site_perl/5.28.0/Mojolicious.pm Installed: 8.02 CPAN: 8.04 Not up to date Sebastian Riedel (SRI) kraihx@googlemail.com
Thank's I'll look into it.
Well, #1 on the list would be to take a look at the build log.
I posted the build log. That's just one of several dozen modules the refuse to install when I try to install Dancer2. Looking at the smoke tests for these modules, they are installing fine on 5.28. So I'm not sure what's going on. This is a fresh install of perl with perlbrew. Something tells me something is off somewhere.
Sorry, I assumed since it referenced the log at the end that it wasn't the log. Ok, so start working your way through the errors and trying to fix each one, or try to roll back to your older version of Perl. 
What I'm trying now is an uninstall/reinstall of perlbrew. Hopefull it works.
&gt;Only pair in map hash assignment allowed while "strict hashpairs", got 4 elements at This error definitely comes from cperl. "Normal" perl doesn't have "strict hashpairs".
Ah, OK. I had never heard of cperl until I saw it as an option in the perlbrew menu. I googled it real quick and it sounded to me like it was perl but on github. Guess I screwed up installing it and that it's different from "normal" perl.
OK, I installed "normal" perl and all is well. I have no idea why perlbrew only showed \`cperl\` versions. Tip for others, do \`perlbrew available --all\` to see all available perl installs in perlbrew.
Another option is to use WWW::Mechanize::Firefox, which lets you drive Firefox around via Perl and click on things. https://metacpan.org/pod/WWW::Mechanize::Firefox
Epic answers in this thread! Here's some more curated tutorials to [learn Perl](https://reactdom.com/perl)
Firefox does not allow installing the mozrepl add-on anymore which is necessary for that module to work.
Please show what code you have so far. \`reduce\` is available in List::Util, which is in core Perl (so you can just use it without installation). [https://metacpan.org/pod/List::Util#reduce](https://metacpan.org/pod/List::Util#reduce) (If you use other CPAN modules already, use \`List::AllUtils\` instead, since you then dont have to care about in which module your list functions come from.)
For perl, haven't got anything so far. Need this done by 1 hour or so and I don't have much experience with perl unfortunately
Perlish solution combining map/grep (which you know as Array#filter): use List::Util qw(sum); # this module is part of Perl sub species_count { my ($target, $species) = @_; return sum map { $_-&gt;{how_many} } grep { $target eq $_-&gt;{species} } @$species; } my $species = [ {"date" =&gt; "09/09/18", "how_many" =&gt; 11, "species" =&gt; "XXXXX"}, {"date" =&gt; "04/11/17", "how_many" =&gt; 41, "species" =&gt; "TTTTTT"}, {"date" =&gt; "17/03/18", "how_many" =&gt; 30, "species" =&gt; "DDDDDDDD"}, {"date" =&gt; "17/08/18", "how_many" =&gt; 31, "species" =&gt; "XXXXX"} ]; my $target = 'XXXXX'; print species_count($target, $species); # output: 42 
perl6 also has strict hashpairs.
Thanks, I had no idea it was broken. Too bad, it was neat while it lasted.
yes.
Indeed. Tip: make methods for your objects that do the coloring: printWARN, printOK, printERROR,etc. Then, if the user is 80, go ahead and convert your output to html. Now, when you are too lazy to ssh in and run a script. You can webbrowse to a cgi version of your script and still see your pretty colors. This module: HTML::FromANSI
In the words of the great sage Travis Meeks: "Sometimes, there are always problems."
For the case that you really can't run perl -MCarp::Always you can set the **PERL5OPT** env variable to **-MCARP::Aways**. 
no way those are fun reads.
"use Carp::Always" shouldn't probably be explicitly written in the code, but instead added as a runtime flag (e.g. via perl -M, or PERL5OPT). Users should be given the choice to turn stack tracing on/off. Also, [Devel::Confess](https://metacpan.org/pod/Devel::Confess) should be superior to Carp::Always in almost every aspect. &amp;#x200B;
FWIW, I've commented on a few entries, to at least try to remove some misunderstandings about Perl 6.
Had a laugh when I saw the Business::US::USPS::WebTools module. I couldn't find anything like it on metacpan and ended up writing my own module. Now I see this!
perl scales better than anything else I know (for a given value of scale). From thowaway onliners to huge applications [1], it can do it all. [1] Here be dragons - huge applications can be a mess in any language.
Inspiring, thank you!
Carp::Always (and Devel::Confess, which you should use instead) also affects regular die and warn calls.
That's a good idea, will update the article. Thanks!
I'll try that out for a while.
The perl kits really are better tools than what other languages provide though.
Perl 6 is getting a new name?
No, it's not. It's possibly [getting an alias name](https://rakudo.party/post/A-Request-to-Larry-Wall-to-Create-a-Language-Name-Alias-for-Perl-6). I somewhat wish nige didn't make this post because: (a) there's already a load of confusion about Perl 6 naming because not everyone reads every post on the topic; (b) the "stage name" thing is just based on catching Larry thinking aloud and isn't his final decision or announcement; (c) Perl 5 doesn't have a naming problem. Unlike Perl 6, it is exactly what its name says it is. There are no false promises being made with the name. *That* name ain't broken.
I thought there was information of interest that got highlighted in the discussion. Yes there was some cruft but also at least as much interesting comments.
Oh I‚Äôve never seen these before! Thanks for this, I‚Äôll check it out as soon as I can!
For distribution of Per apps, I also recommend looking into App::Fatpack.
That's a dead end, auto/Term/ReadKey/ReadKey.so cannot be fatpacked.
Oh for reals? Why not?
If you're going to use Perl::Critic, use a sensible plugin set rather than the default. I suggest [Perl::Critic::Freenode](https://metacpan.org/pod/Perl::Critic::Freenode) only because I wrote it and don't know any better alternatives to suggest modern practices.
Like many other PBP suggestions, including both a Makefile.PL and Build.PL is no longer a good idea, so I can't recommend using that Module::Starter plugin either. Other issues include installing pod/perlcritic tests that are not author-only, and using the discouraged qv() version declaration form.
For alternatives, the default Module::Starter plugin has been kept reasonably modern through the efforts of myself and others, but I would also strongly suggest using something like [Minilla](https://metacpan.org/pod/Minilla), [mbtiny](http://metacpan.org/pod/mbtiny), or my Dist::Zilla bundle [@Starter](https://metacpan.org/pod/Dist::Zilla::PluginBundle::Starter) which all provide much better authoring experiences from minting to release.
What I thought was super cool about the projects listed on the Perl 11 page was that there is continued parallel development of Perl5, similar to pypy for python. The comments totally didn't go that route though. I really wish there was more info on 'Modern Perl5', more than just the book. But discussion of things like autobox in production, or a distribution of perl that was batteries included etc. Maybe some of this stuff exists and I just haven't seen it. I'm coming back to perl after a long break, and the quality of packages for making life better is amazing. The new features that have come out are also awesome. I almost feel like someone could release a new language... or dare I say a Slang, just by including a few packages by default and turning on a few pragmas.... 
FWIW, Mojo::DOM's behavior is based on HTML5.
There is [Modern::Perl](https://metacpan.org/pod/Modern::Perl) to go along with the book, and [Mojo::Base](https://metacpan.org/pod/Mojo::Base) does a similar job of turning on many modern features for Mojolicious projects. The problem after that is everyone has different opinions on what kinds of things should go on top. Autobox introduces huge performance penalties so it's not for everyone. Function::Parameters and experimental signatures both have their pros and cons. Nevermind something even more opinionated like Moops or Dios. It's a balancing act to recommend what will most universally be beneficial to the most users.
I had not yet looked at Mojo::Base, Dios, or Moops! They also all look cool! I understand what you mean though, regarding disagreements on what to use and when, and that is the best part of Perl, that there are so many options out there. I guess maybe I just need to read more new Perl code to see what is 'acceptable' in the community and what is just novelty... because it looks like I could write very Rakudo'y Perl5 as is right now if public opinion / future maintainers of my code allowed.
The main determination of what you "should" use in your code is whether you plan to put it on CPAN, and whether you want other people to actually use it. For code I write for my own use I use experimental signatures, but this requires 5.20 and theoretically could break on future Perls, so I would not use them in my CPAN distributions. Most CPAN distributions currently support back to Perl 5.10 or even 5.8, though Mojolicious is currently [planning to bump the requirement to 5.14](https://groups.google.com/forum/#!topic/mojolicious/7pT7vNXxQDw), and Dist::Zilla already has done so. 5.14 is also an important milestone in that it's required for most keyword plugins like Function::Parameters, Kavorka, and Syntax::Keyword::Try.
This could make some things easier because JSON and Perl5 don't have an identical info-sets. XML term, I'll explain. The most obvious example is Javascript for example has discrete \`true\` and \`false\` values, Perl5 has truthiness (roughly anything that evaluates to 0, undef, or "" in scalar/boolean context is false, otherwise it's true). The current Perl5 implementation does have a boolean type but it isn't readily exposed at the language level (you have to do things like `!!$value` and then not manipulate the results in any way that would cause it to automatically convert to a compound scalar). Less obvious to anyone who doesn't deal with JSON deeply on a regular basis: Perl5 at the language level doesn't really do data types the way Javascript does. In Javascript `1` and `"1"` are considered different values (`1 === "1"` is false) and operators are overloaded based on the type of the operands (`1+1 =&gt; 2` but `1+"1" =&gt; "11"`). Perl is the opposite, our operators cause the operands to coerce (`1+"1" =&gt; 2` but `1."1" =&gt; "11"`*). For JSON this comes into play because when you're generating JSON from Perl5 sometimes you need to force values to coerce to a specific type: `{count =&gt; 0+$count}`, `{user_id =&gt; "$id"}` or `{is_true =&gt; !!$value}`. It gets worse when you are round-tripping JSON because currently** Perl5 doesn't maintain the original type of the value. This means that if you take in some data, and do an operation on it that causes it to be coerced you lose the original state of the data irreversibly, so when you go to re-serialize the data sometimes it gets serialized as the wrong type (e.g. `{"count": "1"} // count blows up if it's not a number`). All of this brings us to the point. tl;dr: In theory this package could either a) save you from round-tripping the JSON, or at least b) save you from having to track the type differences manually. 
Yeah reality is often a far cry from theory.
tl;dr
In theory, theory and practice are the same. In practice, they're not. -- quote by someone I can't be arsed to look up
I don't think it's a misguided **idea** to create a DSL for transforming data structures, if that's a common problem domain for you. I do think the syntax is fairly inscrutable though, but then again I haven't spent any time actually looking at it. Whether this is a good trade-off depends on how generally applicable this thing is and how hard it is to learn and use (for you and others). Sometimes learning something difficult will unleash new opportunities that you weren't at all aware or capable of before, or which wasn't worth the effort doing the manual way. Probably, you won't even notice that until afterwards. Compare regexes: it's inscrutable and largely unreadable for the novice, but has a very general application and is almost universally supported in programming environments and languages. 
Thanks for that obligatory plug. You beat me to it. I have no idea what JSON::Transform is, but I can certainly talk about a problem that I always had with JSON, and which `jq` solved for me. You can write code against a JSON data structure, but you have to know what it looks like, and often the entire structure is too big and confusing to get your head around. So it's useful to start at the top and work your way down the tree, in order to know what you're dealing with. Not useful, actually. Necessary. You can do that with Perl, with the JSON module or JSON::XS or whatever. But there are problems with that. One is that the parsing is not all that fast (even with the XS module), and so I often ended up parsing it and using Storable to store the parsed data structure in a Storable file. That sped things up, but if the JSON was quite large, even that was slower than I wanted it to be. But the other problem was worse. Once you have it in a Perl data structure, then you have to be able to see it to know what you're dealing with. You can do that by writing throwaway code, or by using something like Data::Dumper (Maxdepth is a very useful setting), or whatever. One day I said to myself, "Man, I sure wish I had a command line tool that was just really focused on parsing, analyzing and transforming JSON, from the command line." And my google search revealed a few options, `jq` being absolutely the best, in my view. So, what do I use `jq` for? Well, I use it all the time, so it depends. But if I'm writing Perl against JSON, I use `jq` to sort of prototype what my data strategy will be. So I end up writing code, yes, but it's code that is specifically _for_ that sort of thing. And maybe that's also why JSON::Transform is useful. I don't know, because I haven't used it. When I'm done using `jq` and ready to move to Perl, I have to rewrite my code, yes. But at least now I know what I'm going to do. I wrote my `jq` code as a one-liner (never in a script file, because that never seems to help me), so I copy and paste the one-liner into a comment in my Perl code and use it as a template that reminds me of what's going on in the data tree. I've never written about that before, so I don't know if it makes sense, or if it's helpful. But it's _certainly_ not really an answer to OP's question :) 
 Global symbol "$foo" requires explicit package name (did you forget to declare "my $foo"?) at /tmp/reddit-9sx4xg.pl line 4. Execution of /tmp/reddit-9sx4xg.pl aborted due to compilation errors. https://perlmaven.com/always-use-strict-and-use-warnings
or `-d:Confess`
IRC Freenode has basically everything tech related you‚Äôd ever want.
For Perl, it's all about IRC. Also, here's a thing https://www.codercommunities.com/
I found this while looking at various implementations of fuzzy match modules. I couldn't believe it wasn't more known. The one example in the description is cool, but it doesn't show that you are also getting all the Perl regex magic variables for 'free' as well, which is hard to come by in a fuzzy match implementation. Once I realized you can swap out regex engines, I did a little [search](https://metacpan.org/search?q=re%3A%3Aengine). So many cool options! Including a PCRE that uses a jit! 
There's no centralized Slack workspace about Perl that I'm aware of. In the Chicago Tech Slack, there's a #perl channel. The Test2 team has set up a Slack workspace. I've set up a Slack workspace for discussing the ack and vim-perl projects. There are probably many others around, but nothing that's become a _de facto_ standard centralized place to meet.
You are right. I may do an actual write up of it. Both the author of the TRE engine, and the author of this module are very very lite on examples. TRE is, or was until very recently, part of core netBSD it looks like though, and is one of two alternate builds of agrep. So maybe I can steal examples from there. 
Slack is designed for corporate invite-only communities so it's not great for open source communities. [Freenode #perl](https://kiwiirc.com/nextclient/#irc://irc.freenode.net/#mojo?nick=mc-guest-?) and the [Perl IRC network](http://www.irc.perl.org/) are the main chat communities. I created a [Discord server](https://discord.gg/Mnbj6th) in case things move that way, since Discord is better designed for public communities, but it seems unlikely at this point as IRC still works fine.
Stackoverflow is probably best.
Post your actual assignment here. Don't hide it in PMs. As long as you learn something from it, it's fine.
for my first program im supposed to write a program that reads the FASTA file of a protein and prints out the accession number and the length of the protein sequence.. &amp;#x200B; this was my attempt, so far, i can get the accession number, but i keep getting the length of the final line of the FASTA FILE, and not the complete length... &amp;#x200B; #!/usr/bin/perl ; use warnings ; if (!open(FASTA, "FastaFile.fasta")) { die "Could not open FASTA file" ; } $AccNr = &lt;FASTA&gt; ; $AccNr1 = substr ($AccNr, 4, 6) ; print ("Accession Nr: $AccNr1\n") ; $res = 0 ; while ($length = &lt;FASTA&gt;) { $res1 = length ($length) ; $res2 = $res + $res1; } print ("length is $res2\\n"); The reason why i asked to PM is because there are a bunch of questions i need to do, so i didnt want to spam the subreddit
 $res = 0 ; Here you set $res to zero. $res2 = $res + $res1; Here you (repeatedly) set `$res2` to `$res` plus the length of the current line. In other words, zero plus the length of the current line. In other words the length of the current line. Does that help? 
Start with naming your variables better, this will suggest you a solution :) `$res` is meaningless. What do you want to calculate here? Let's say `$total_length`. So start with `my $total_length = 0;` up top. Then inside the loop, `$res1` is even worse of a name. What do you hold there? A length of one line. So call it `my $line_length`; Then you have `$total_length`, starting with 0, and $line_length, having some kind of number inside. If you want to update the `$total_length` so that it keeps growing, how do you do that then?
thank you, my variable names were pretty bad! that is the issue im having, i keep trying to write the code so that the $totallength is updated as each line‚Äôs length is calculated but i keep getting just the length of the final line... ill edit this reply if i figure it out
1. You should definitely have "use strict" in addition to "use warnings" 2. There shouldn't be a semicolon in your first line (the "shebang") 3. There are no popular code styles that include whitespace before each line's semicolon. While style is a matter of personal preference, it is helpful to use a standard style so that you can effectively read other people's code and they can read yours.
I figured it out! it works somehow when i wrote this: @length = &lt;FASTA&gt; ; $total_length = 0; foreach $line (@length) { $length = length ($line) ; $total_length = $total_length + $length; } --$total_length ;
I am glad you still see the positive sides. I am confident you will get past the mark next time. You should have contacted me earlier. I had plenty to offer. Never mind, please do get it touch next time.
Sure, the script is in the distribution: https://github.com/frezik/Game-Collisions/blob/master/scripts/bench.pl I'm guessing going recursive wouldn't be too bad for the tree structure. If it's kept balanced, then going 20 deep would *a lot*. I just started using an iterative style when I first did the brute force method, and then kept doing it for most other things.
Please post your full code when you're done and we'll provide more tips/tricks.
Ah thanks, I didn't see it there. And yep, it's like I thought. You lose so much time with method calls that the algorithmic superiority is drowned in Perl overhead. With some inlining of method calls and getting rid of the manual queue handling in favour of doing it on the Perl stack I get [these](https://pastebin.com/Y8D2ru0j) changes. The tests still pass (but it's probably still buggy somewhere) and I get for the benchmark: ~/src/Game-Collisions-0.1$ perl -Ilib scripts/bench.pl Running tree-based benchmark Ran 1000 objects 6000 times in 0.209484 sec 28641805.5794237 objects/sec 477363.426323729 per frame @60 fps Running brute force benchmark Ran 1000 objects 6000 times in 6.676304 sec 898700.838068488 objects/sec 14978.3473011415 per frame @60 fps
I think there'd be a lot of gain to be had by reimplementing the AABB class in C, including storing the data in floats so there's no overhead of getting data in and out of SVs. That may or may not be worth it, as I'm pretty happy with the numbers I'm getting on the pure Perl implementation on modest hardware. We'll have to see how it goes in a real game, which is what I'm hoping to do over the next few months.
Very cool!
Thanks for sharing! I decided to skip Hacktoberfest this year because I have too many T-shirts as it is‚Ä¶
Thanks for sharing! I decided to skip Hacktoberfest this year because I have too many T-shirts as it is‚Ä¶
I would really love sqllite to support MySQL's INSERT INTO table SET col = 'value' Syntax. Does anyone know if there is a compatability layer for that?
It‚Äôs hard to prove a negative, but that sounds very unlikely.
Plain stubbornness, I guess. I abstract most of my FB calls, but sometimes I use the SET Syntax directly. And the VALUES syntax, even though I know it's the standard, just seems very ugly to me.
For those who don't know: "TimToady" is Larry Wall
Nothing special. Its just nicer (for me) to write INSERT INTO table SET foo = "bar", foo2 = "baz"; Instead of INSERT INTO table (foo, foo2) VALUES ("bar", "baz");
I am sure you are joking ;-) This is not just about T-shirts. Having said that you already do so many other contributions, so skipping Hacktoberfest would not matter, I reckon.
Hi! I wasn't joking. I didn't register to hacktoberfest this year, because I didn't want resources to be wasted on processing my participation, while technically trying to still send some pull requests during October (or otherwise).
Yupp, that's good. 
From [an earlier discussion](https://colabti.org/irclogger/irclogger_log/perl6?date=2018-10-25#l584) on possible alias choices: &gt; \&lt;TimToady\&gt; [...] at the moment I'm liking Raku the best for a short name (it's 4 letters like Enya or Pink or Gaga), with long names of either Raku-go or Go-raku (where "go" is Japanese Ë™û for "language") because I'm not terribly fond of the "-lang" neologism
Does this mean that if/when Perl 5 has a major release can be 6.0? Or was this never a possibility? 
Perl 5 is out of scope of my involvement on this issue and I've no idea what TimToady thinks about its versioning.
No.
[#FREE AT LAST](https://www.azquotes.com/picture-quotes/quote-free-at-last-free-at-last-thank-god-almighty-we-are-free-at-last-martin-luther-king-34-65-63.jpg)
It could be he understands SQL and cares about performance. 
What's the source on that answer?
This is just an alias, so it does not affect that situation. Time will tell.
The law offices of Ego&amp;Pride
Honestly I think we'd be better resurrecting my old 'pumpkin perl' idea (or something similar with a different name) and declaring that our major version is currently '28' - i.e. also take on an alias-ish thing ourselves. Even were Larry to agree to let us do something else, I find it incredibly unlikely that we'd be able to find a something else that causes more problems than it solves (c.f. the whole "perl7" thing being ridiculously divisive and in fact getting fairly substantially boycotted by much of the perl5 community as a terrible plan) -- mst
perl5 attempting to use 6.0 would look just as deliberately nasty and pointlessly divisive as liztormato's titling a talk "perl5 is the new perl4" was. I'd much rather keep doing down the "two sister languages in the perl family" path that Larry and Jnthn (rakudo lead dev) have long since endorsed - so perl5.28 becomes "${something} v28" as an alias and we go in that direction instead.
Probably "oh gods I'm going to have to have this conversation again aren't I?". Certainly that's a fair bit of what I'm currently thinking. -- mst
Deliberately nasty how? If Raku is a different language at this point, what's Perl5 to do, then? Jump to Perl 7?
Would you care to elaborate on that?
Difficult to do so substantially in a fleeting comment thread. The tongue in cheek quip is based on many years of following your line of argumentation through presentations, writeups, conversations etc. You have identified with "perl" ( the word specifically ) for so long, that you mistake your personal view for a widely accepted "how things are". I mean: you went so far as [to write this mindboggle](http://news.perlfoundation.org/2018/10/dave-rolsky-nomination-for-tpf.html#comment-38516665) a few weeks ago. More - some day in person if you actually care to have the conversation at all.
WRT deliberately nasty: perl5 and perl6 have been acknowledged to be different languages in the same family for years by the majority of the key stakeholders - both perl.org and perl6.org's sites have reflected this understanding for a long time. So attempting to grab '6' would basically be a giant attack on the 'sister languages' narrative that better represents the current situation, given both languages are taking their own paths and are actively developed. WRT what to do instead, I thought I already covered that in my original reply to you, but to expand: You will find (and this has been true for some time) that if you run perl -v you get e.g.: This is perl 5, version 22, subversion 2 so since we've been treating 'perl5' and 'perl6' as language names for years, simply embracing and continuing that seems like the sane path - "pumpkin perl version 22.2" or "raptor perl 22.2" or whatever (obviously you'd start with v30 next year but hopefully you see what I'm gesturing at). -- mst
Wow, Talk about bad taste.
Larry. Until he says otherwise, the major version numbers are his. A slight change in name (eg as Reine Urban did when he created 'cperl') was his preferred solution in 2013, and as far as I'm aware, nothing has changed since.
It's not nice to call TimToady names...
"Raku Perl" sounds good to me for Perl 6. Thanks Larry. Now it's Perl 5's turn! Someone riffed on 'raptor perl' and suggested - "rapt" . "Perl" is an umbrella trade mark for both Perl 5 and 6: [https://nigelhamilton.com/perl-branding-proposal.html](https://nigelhamilton.com/perl-branding-proposal.html) &amp;#x200B;
Sure. But the original intention was to evolve Perl5 into Perl6. The whole different language narrative came up later. I guess I'm okay with the status quo. But again, since Raku will not be Perl6 anymore, then Perl5 can continue with its original versioning scheme. Perl could pull a Windows (skipping version 9), and just skip to version 7 and be done with it. But anyway. I just code in Perl(5). I'll leave the rest to those who mind about those things.
&gt; Sure. But the original intention was to evolve Perl5 into Perl6. Not as far as I remember: The decision to make a breaking change instead of an incremental one was made early in the design process. However, you were supposed to be able to interleave these two incompatible languages at block scope via `use v5`/`use v6` pragmas.
Why? This is a burden that the perl language has been dealing with for years.
There was a *lot* of rock throwing in the period before before we (mostly) agreed that "sister languages" was the narrative best reflecting how (most) people in the two subcommunities saw things. The wonderful masak came up with it and I did a lot of the perl5 side cat-herding. Plus Raku is an alias/alternative name, not a replacement, and I don't want to trample on a potentially fragile plan that I'm hugely in favour of. Hence "let's skip to 30" seeming even better to me - 7 would be interpreted as "replaces 6" and a complete clusterfuck. It took Larry and I a keynote each to murder that idea the last time, and the rock throwing had already started by the time we did. So I get where you're coming from, but in practice it would end up being a giant dramastorm that would damage both perls, and while my primary interest is in perl5 I know and love many perl6 people and don't want either group damaged by intrafamily infighting :)