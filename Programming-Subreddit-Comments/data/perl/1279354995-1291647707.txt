Ubuntu 10.04 has 5.10, Debian Testing has 5.10. I think people will want to get used to that first ;)
(at work, we're still migrating away from ancient FreeBSD servers with 5.6-- 5.10 is a breath of fresh air compared to that :))
Definately based on what version the distro has. 
You think that's ridiculous? *Gentoo* was on 5.8 until a few weeks ago, and they've only added php 5.3 in the past month. Debian Stable seems to be more up to date these days... *Oh wait, I just updated portage and it's at perl5.12.1 now. That was a surprise.*
Update link is on the map now! http://vimeo.com/13423319
Either Qt or Wx. The important thing here is getting a solid amount of documentation and keeping the module up to date. This is one of those cases where we need 1 obvious library. 
Yes, it matters. Someone using PDK, can now migrate to 5.12.1, not 5.10.1.
Yay, Perl's 10th anniversary is the same as my reddit birthday! :-D
... and I still don't know anyone (in person) who uses it.
I would like to see something like JPerl or something so I can actually use perl to do the things that java can't and use java for the rest of my co workers. Unfortunately there seems to be no interest in doing this.
Perl6 hardly makes it to ten years. It's like mum and dad discuss having a baby, and ten years later they celebrate its 10th birthday when in reality it's its 6th :)
Way to provide a whole bunch of SQL examples that are open to SQL injection. Sigh.
Read the article more carefully, specifically the explanation of what the little language compiler does before executing the SQL statements. As well, I know of no language where a novice programmer can copy and paste those snippets of code directly and cause SQL injection errors; no language I know supports that particular dialect of SQL. That's why I used extra syntax.
Well, you mention that we could or should take some action to prevent SQL injection (which is good). And my knowledge of Perl 6 is light enough that I'm sure there may be some mechanism for performing custom-interpolation for different situations. Still, I'm looking at code that, to the best of my understanding, is interpolation of scalars (of unknown origin, e.g., a web-form!) directly into a larger string that is intended to be executed as SQL. If there's more to it than that, it really deserves more comment to that effect.
I'll be at the YAPC::EU in Pisa, Aug 4-6. That's your chance to change that situation.
*If there's more to it than that, it really deserves more comment to that effect.* I don't know how to be any clearer than "This pseudo-SQL statement gets parsed into code which, as part of its running, performs type checks, validation, and then sends the values through placeholders to prevent SQL injection attacks." I specifically wrote that this process *avoids* interpolation three times. Update: I don't mean to be rude or obstinate, and I apologize for any of that which comes across. I honestly don't know why people are saying "Please don't interpolate into strings!" when the entire article is about how that does not happen.
*Part of the reason it took me so long, is that Rakudo is sloooooooooooow. No getting around that one for the time being. If your expectation of Rakudo includes blazing speed... fuhgedabowdit! But if you don't mind taking a coffee break while your code runs far enough to produce a nice stack trace, give Rakudo a whirl.* I think your definition of "ready" might be different than mine.
He presents a disclaimer early on ("depends on your expectations") and ends with the specific context that Rakudo is ready for ("It is ready enough for TestML"). You don't have to think the definitions are different. You can know for sure. The basic syntax features of Rakudo have progressed to the point where people can confidently use it for their own projects, write tutorials, and contribute to improving what's there. Now that the bleeding edge users - or "howling in pain with a severed stump" users, as the case may be - have had their way with it, it's time for the next round of plain old early adopters. Rakudo may not be ready to make the next Facebook yet, but that's a secondary concern for the star release. *edit*: I upvoted you anyways, because the title does confuse a little based on the way we use the word "ready." Your reaction is understandable.
&gt; `:$var` generates a Pair ("colonpair"), using the variable name as key (but with sigil stripped). So it's the same as `var =&gt; $var`. Every time I read about p6, something like this comes along and floors me again.
In a good way?
I can't count how many times I've written this particular line out manually in a bunch of languages. Definitely the best thing I've seen all week. The mountain of new operator stuff is too much for my tiny mind to cope with, though. Especially the «» things.
Advanced operator combinations read very densely at first, but once you realize their patterns and can decompose them into "Oh, this is obviously a hyperized foo operator!" they're remarkably consistent.
Ready for lots of us non Rakudo developers to start playing with it! I'm guessing having a lot more users will really drive Rakudo development forwards at a pace. Including making it faster :)
Not a huge perl genius here but I can get by with what I know in perl 5. Is the period in front of a command a new thing in perl 6? What does it mean?
It's roughly equivalent to `$_-&gt;method()` in Perl 5; invoke the named method on the current topic.
Ah, that makes sense. Thanks for clearing it up for me :)
There's a few: http://search.cpan.org/search?query=Speech::Recognizer&amp;mode=all Or, the [sassy version](http://lmctfy.org/Speech::Recognizer/)!
Most of those were written in 2001 think they're safe?
No clue! A general rule of thumb is to check for (serious) and still-open bugs. You might also want to head over to the [CPAN Tester's Matrix](http://matrix.cpantesters.org) and get a quick overview of what versions of perl it works with. PASS is good...
Currying is *the* best way to make your code completely incomprehensible to anyone not familiar with the concept.
Only if you also have no clue how to do interface design.
OO is the best way to make your code completely incomprehensible to anyone not familiar with the concept. Structured programming is the best way to make your code completely incomprehensible to anyone not familiar with the concepts. Borrowing the vocabulary of your problem domain is the best way to make your code completely incomprehensible to anyone not familiar with the concepts. I conclude from this that you're better off hiring people who know what they're doing, or people who you can train.
A good article, but I think there's a third level of perl in there (although yeah, he really strayed from that original point ;) ). I think there's the "knows just enough to be dangerous" crowd. This is where the code is written like a large-scale perl project, but scratch the surface and you find Desperate Perl. It's an attempt at trying to do "the right thing", but getting caught up by deadlines and reverting back to old/bad practices, or just not having the time/knowledge/motivation to do everything the proper way. It's better than raw desperate perl, but not as good as a real full-scale perl project. I think this crowd exists, because I think I'm in this crowd. I try to do the right thing, but don't always do it, for varying reasons. ;) **edit:** spelling.
 * * 5 + * is equivalent to -&gt; $a, $b { $a * 5 + $b } Oh... dear god. I'm a big perl5 fan, but perl6 kinda scares me. That's one hell of a syntactic construct.
Well, I usually call these "Golf clubs". Guess why.
The reuse of `*` for multiplication *and* "placeholder" does seem inscrutable.
I think I've seen and written the kind of code you're talking about. In my own notes, I call it "Feral Perl." It's especially dangerous, because all the sensible Large Scale hooks have overgrown with thorny Desperate code.
&gt; I'm a big perl5 fan, but perl6 kinda scares me. I'm in the same boat. Not only am I a big Perl 5 fan, but also something of a programming language fan in general. I'm torn between being really excited that Perl 6 is embracing so many advanced concepts, and utterly dismayed that it is doing so by adding umpty new operators and cryptic non-alphanumeric symbols. Much of Perl 6 code looks to me like they've taken away the line and left the noise.
I've yet to work at a shop that didn't use Perl in a very serious way. Biased author is biased?
Author claims to have rewritten utilities from Perl to bash to "improve portability". I can believe that author might be better off with a different language.
&gt; Author claims to have rewritten utilities from Perl to bash to "improve portability". Good grief.
I like the part where he said migrations to 100% PHP were taking place to reduce complexity. I almost threw up on my keyboard when I read that.
"Perl's claim to fame has always been that it makes easy things hard." *Facepalm* No wonder his column is called the Deep End - he's gone off of it.
&gt; There's also been a push in some applications to rewrite Perl utilities in Bash to enhance portability between platforms. HAHA This should have been the submission title, and it should have been posted in /r/WTF.
Pays my bills. 
I think I'm going to generalize and keep "feral code" in my lexicon.
Good point. That can be generalized to code I've looked at in any language.
&gt; Content-addressable stores (hashes, dictionaries, whatever you call them) are basic to doing, well, anything; they should be built-in to languages, with a convenient readable syntax. This is the crux of it for me, and most importantly, they should be easy to express/compose. Trying to compose JSON messages for example in some languages leaves you weeping, whereas doing the same in Perl is simplicity itself.
Also related - check out Perl Best Practices from O'Reilly. That book helped me clean up my perl quite a bit.
Yeah whatever man, we all know you're a secret interpolater.
I agree, the ease of data manipulation is really one of the things that have me glued to perl. Also, Data::Dumper is such a fantastic tool.
Wow .... This is hilarious. Forget the web world for a sec. Do people realize just how much Perl is used in the Financial Industry? Or the Bio-Informatics Industry? Or for Quality-Assurance? There is more to the world then just web applications. PHP, Ruby ... have yet to be playing in these fields. Python is finally starting to make a foray .. but about 15 years to late. 
These are the slides from a 3-hour tutorial that rjbs gave at OSCON last week. rjbs has been writing some very useful, very real-world code with Moose for a few years now, and there are *very* few people who have a better understanding of its power than he does. If you're wondering *why you should care* about things like roles, traits, type constraints/coercion, delegation, or even just attributes and laziness, you should take the time to give these few hundred slides a look. If you're already sold on all of those ideas but you want to use them *better*, you should also look.
Looks really great - just getting into Moose. Thanks for the link!
You're welcome. You should also know about the [Moose::Manual](http://search.cpan.org/perldoc/Moose::Manual) and [Moose::Cookbook](http://search.cpan.org/perldoc/Moose::Cookbook) if you don't already, and you're also welcome to visit #moose on irc.perl.org.
Will do. In the middle of a rapid prototype model project and wish to shit I knew about Moose three years ago.
seems to be pushing a lot lately. It's not a bad contender. Plus, according to crunchbase, it's 2 people.
Moose is great. I'm using in production for the last 2 years or so. I hoped there would be some syntax clarifications because I'm constantly annoyed by the mixup of different coding styles in all my code. I mean Moose could be nicer if I all those declararations could be done with barewords to blend in to the rest of the Perl language. Consider: use Moose; with MySite::Roles::Database; with MySite::Roles::Logging; has find_stuff { is =&gt; 'rw', isa =&gt; 'MySite::Stuff' } has delete_stuff { is =&gt; 'rw', isa =&gt; 'MySite::Stuff::Delete' } sub check_stuff { _check(@_); } instead what is default now: use Moose; with "MySite::Roles::Database"; with "MySite::Roles::Logging"; has find_stuff =&gt; (is =&gt; 'rw', isa =&gt; 'MySite::Stuff' ); has delete_stuff =&gt; ( is =&gt; 'rw', isa =&gt; 'MySite::Stuff::Delete' ); sub check_stuff { _check(@_); } The first one fits more nicely into my other sub/method declarations. I know it's a minor thing, but it can be annoying. OTOH, the problem with Perl is not the language, but all those people who consider their programming style the best there is. (Maybe I should send all this to the Moose maillist?)
The `with` lines: actually it's legal right now without the quotes, but unfortunately if you've loaded the `Foo::Bar` module at any point already, Perl will want to parse `with Foo::Bar;` as `Foo::Bar-&gt;with;` which is major fail, so we use the quoting to avoid horrible hard-to-reproduce bugs at runtime. The `has` lines: would need at least one more arrow, or some quotes (for "find_stuff" etc. to be parsed as strings, and not sub calls). And semicolons at the end. Unless you want to use `Devel::Declare` magic. So all that really leaves you with is your braces vs. the (optional, actually) parens, and I can't really get behind the braces. :)
Thanx! I didn't know 'with' works already. That's one step toward less DSL-ish Moose :)
I'd really like to use Moose, but it's a hard sell when the Moose version of DBIx::Class doubles the already ridiculously long startup time of our app (&gt;80% of the startup time is already in DBIx::Class and related modules like Class::C3, although the XS version of Class::C3 cut it to 1/4 of what it used to be). Maybe some day.
I like the sentiment. The thing that has always drawn me back to Perl is its community. The language is interesting and CPAN is excellent, but neither of those alone are enough to give me a strong emotional attachment to what is in the long run simply a useful tool. I try to keep it civil these days. I was never really *uncivil*, just occasionally whiny and sarcastic. I know that as a Perl/Parrot/Rakudo/etcetera geek I'm part of that community which is so vital to me. It's important to offer an olive branch for Perl's detractors - at least the ones who seem willing to consider it. It's also necessary to look beyond places like perlmonks or /r/perl for conversations about Perl, warts and all. And keep from posting those initial bilious responses we may have. The Internet tends to remember angry rants more than reasoned discourse, so the rants need to be heavily outweighed by reason. Yeah. I need more coffee before I can really finish the thoughts in my head. But I like the post. *Edit:* typogarphical error.
I'm not sure who the 2nd person is :)
Hahaha :D. Just wanted to let you know, have another convert here.
If you ignore the haters unfortunately they'll be the authoritative voice of the uninformed. While it may be good for your mental health it's not good for the thing you care about. Obviously I'm not talking about trolls but people who make pseudo-rational arguments that get some attention.
&gt; Some of them have been so badly burnt by terrible Perl code, that they will never come back. Some of them simply don’t like Perl, for their own, legitimate reasons. Some of them have a vested interest in seeing Perl fade, even if it’s just that they see Perl as competition for their favourite language. And of course, some of them are genuine trolls, simply fishing for a reaction (although probably not as many as you might think). Or most people (especially redditors) will just parrot whatever they last heard, leading to an echo effect come meme.
...and leading to more unfortunate manifestations of [Mere Exposure Effect](http://en.wikipedia.org/wiki/Exposure_effect). #sigh# 
Awesome, thx!
Sadly, trolls get their attention too, upvoted by other trolls they seem to be the right source of information.
I tend to agree with the OP, trolls mostly get downvoted eventually. The people who get upvoted do so because they present a semi-coherent opinion that's absent any real context or information.
This was originally presented by Perler Abigail in 2000. [source](http://www.perlmonks.org/?node_id=21580)
Are you on Perl 5.8? On 5.10+, DBIC should be using Perl's builtin mro stuff instead of Class::C3, for a noticeable speed boost. Moose does the same. Usually if people notice a major slowdown from the DBIC plumbing it's in Class::Accessor::Grouped.
The answer (to me) is not to respond to them directly, but make a post in the same thread that's sensible, positive and convincing. If you look at the Perl 6 birthday post, almost all the top voted comments ended up being positive ones not directly answering the haters, even though it took a while to get there.
And it seems it's going to be posted every week...
Short answer? Probably.
No.
http://github.com/rakudo/star/downloads#download_43123
It's still July 29 for a few hours on most places of the world. It'll be there in less than an hour, unless something very serious goes wrong. Update: it's out now: http://rakudo.org/node/75
Heh... :)
This was a bit premature :)
With all the real world use it's going to get now, just imagine how good it'll be by Christmas!
This would be a good place to say "thank you" to all the people who have done such incredible work on Perl 6. Thank you, amazing volunteers. You are awesome.
Excellent! Are the monthly Star releases replacing the previous release schedule? I was wondering if we'll see Rakudo #32, or if Rakudo Star starts a new count.
Which Christmas?
If by "complexity" he means "functionality," I can believe it.
 my $f = * * * * * * * * * * * * * * * * * * * * *;
They are separate things, Rakudo will come out every month, and so will be Rakudo Star
The regularly monthly compiler releases will continue, so #32 next month. The "star" releases are Compiler + Modules + Docs, and have a separate count. We'll likely settle for a Star release every 3 month, after things settle down a bit.
&gt; I conclude from this that you're better off hiring people who know what they're doing, or people who you can train. Easier said than done :(
That's it, I'm calling it the Buffalo operator.
Good to know. Thanks for the clarification.
Yeah, we had issues with Class::Accessor::Grouped until we got Class::XSAccessor going. Yes, we're stuck on 5.8.8, but that's good fuel to the fire to get our boss to let us roll our own updated version, thanks.
Am I the only one who finds perl6 harder to read than perl5 ?
All of them!
99.5% perl5, and 0.5% perl6. I guess you've found the problem.
Does that `native()` feature work for everything, or just C libs? I went poking through the MiniDBI code and I was wondering where the rest was. Then it hit me - the entire thing fits into a few KB, and no nasty XS C code anywhere. Wow.
Ex-act-ly :)
Just coincidentally, Perl 6 manages to decompress regular expressions into something much more readable :)
The release announcement mentions "macros" as one of the features that are unimplemented, and that's mostly true, since *most* of the features of macros (the coolest ones) aren't implemented yet. But you do get simple unhygienic macros (like C preprocessor macros only with a little more parse-awareness) -- I saw Damian use them at YAPC::NA. Might be enough to whet your appetite for the real thing.
&gt; Yeah, we had issues with Class::Accessor::Grouped until we got Class::XSAccessor going I'd love to see what you did there, but I understand if you can't share :)
Brilliant! There goes my weekend...
Searched an obscure phone number that only had a few hits, and at the bottom there was a link: "No more results. Try Google." Now that is convenience. (Not that Google did any better from a non-junk standpoint.)
If you're going to basically advertise your own articles here, why don't you do the right thing and buy an ad at reddit? That way you don't look like a spammer, and you support reddit financially for driving traffic to your article.
Definitely not. Especially if the problem you're solving doesn't require OO. 
For some reason all chromatic articles keep getting upvotes, which means people _want_ to read them, which makes them good enough to be posted here.
**ELAINE:** What about ponies? What kind of abnormal animal is that? And those kids who had their own ponies.. **JERRY:** I know, I hated those kids. In fact, I hate anyone that ever had a pony when they were growing up. **MANYA:** ..I had a pony. (The room is dead quiet) **JERRY:** ..Well, I didn't really mean a pony, per se. **MANYA:** (Angry) When I was a little girl in Poland, we all had ponies. My sister had pony, my cousin had pony, ..So, what's wrong with that? **JERRY:** Nothing. Nothing at all. I was just merely expressting.. **HELEN:** Should we have coffee? Who's having coffee? **MANYA:** He was a beautiful pony! And I loved him. **JERRY:** Well, I'm sure you did. Who wouldn't love a pony? Who wouldn't love a person that had a pony? **MANYA:** You! You said so! **JERRY:** No, see, we didn't have ponies. I'm sure at the time in Poland, they were very common. They were probably like compact cars.. **MANYA:** That's it! I've had enough! (She leaves the room) **ISAAC:** Have your coffee, everyone. She's a little upset. It's been an emotional day. (Isaac leaves, everyone looks at Jerry) **JERRY:** I didn't know she had a pony. How was I to know she had a pony? Who figures an immigrant's going to have a pony? Do you know what the odds are on that? I mean, in all the pictures I saw of immigrants on boats coming into New York harbor, I never saw one of them sitting on a pony. Why would anybody come here if they had a pony? Who leaves a country packed with ponies to come to a non-pony country? It doesn't make sense.. am I wrong?
the 'is native' trait only works for C libraries, for now. But once you've got an interface to another language, it's only a small matter of programming to give it an equally nice syntax as the C thing.
Not a whole lot, just installed Class::XSAccessor and a newer version of Class::Accessor::Grouped which uses Class::XSAccessor if it's available. It made a pretty good difference. I read up on the mro stuff after you replied. Sounds pretty cool. We're gonna try to play around with the newer toolchain in our dev environment, do some profiling on it. Thanks for the heads up.
Perhaps the wait might be seen by some as a bit on the long side. However, good quality stuff takes a little longer to prepare and is therefore enjoyed a hundred times better when finally served.
where is mr_chromatic when we need him? http://oreilly.com/catalog/9780596100926 was our bible when I was doing QA in a perl shop
After *Modern Perl* comes out, I'm thinking of writing/editing/contributing to but definitely publishing a new Perl Testing book.
I would find that very very intriguing, the whole TMTOWTDI paradigm of perl makes it very hard to establish a good testing procedures. 
Sorry to be a jerk, but could you have tried any harder to give a less informative subject?
I don't get it. The announcement stated *very* clearly that this version of perl6 is an early adopters pre-release is *NOT* as optimized as it would be later. Yet so many folks seem to have overlooked this and keep yapping loudly that it's slow or the startup time is long or whatever.
Haters gonna hate.
Just wow?
you realize you can edit posts right? 
nothing to see here. just another apparently semi-informed user who saw "beta release of perl 6", didn't read the release notes, and blindly expected it to be better than perl5 in every regard. when rakudo is expected to be a true replacement for perl5, you'll know it, it will be very clearly claimed in the release notes folks lets be a little charitable here..."perl6" as a design project has been happening forever now. we know. but RAKUDO, the project to build a "real" perl6...is only a few years old and has made remarkable progress
I'm looking forward to the optimizations that will reduce memory usage by 95%...
Not from lame iPhone reddit client
If you consider that Rakudo is an unoptimized, experimental implementation of a language inside of an unoptimized, experimental virtual machine, such stuff does not seem too unlikely.
I don't really get it. Why do they care about software 3D rendering?
Lets review php with your criteria. Can I make a game in PHP? Well it depends, if you are making a simple webbased game, it is certainly possible. But don't create anything, which needs concurrency or is running for more than a couple of minutes (memory leaks!). A website. It is possible to make a website with PHP. A TCP or UDP server. It is possible to create a TCP or UDP server. It will crash in time. It cannot communicate between threads safely. The core functions of php are not thread safe. A threaded application. Nopes, we can simulate it. But it will never be the real thing. Does it have mysql/postgres/sqlite/oracle support can it talk to databases. Yes it has. Can I write stable applications with it? No, you can't. PHP hasn't a garbage collector (5.3 has, but prior version 5.3 it hadn't), so expect a huge memory profile. PHP core functions aren't thread safe. So you can't write a real application in it. can I run a program with it and let it run for a long amount of time without crashing ? does the compiler have memory leaks ? See the above. The conclusion from your test, is that php is not production ready. We can make a webpage. We can make a webbased game. We have database support. Beyond that, php becomes unuseable. You can guess, I am not a fan of php. But to say php is not production ready is a bit bold. It has its place. I think your test is flawed. I am writing a parser lib in rakudo. (parsec like including monads!) It works so far, this is far beyond 1+1 (although category theory covers that too). 
Trolls: Perl 6 is vapour ware, it'll *never* be released, and when it does it'll be so behind everything else no one will use it. Perl sucks! Perl community: here's Rakudo star to let you see it's not vapour ware, and try out some of the cool features Trolls: OMFG it's so slow. There's no way anyone can ever optimize this code that I know nothing about. No one will ever use it. Perl sucks! Perl community: ...
The point is in *learning* how to do it. Sure it is fine and excellent to depend on OpenGL and the various tools available now. But for some all the *cool* stuff is hidden away, as it was Talon^. Also it showcases really fast FPS for SDL perl with some real calculations done in Perl. In the end: It is fun, silly! :D
&gt; After ten years of development, if the best that can be achieved is a feature-incomplete, buggy, bloated alpha... that's a sign that the project has gone off the rails. Or is running on Rails.
THAT IS JUST PERL 6 DOMINATING THE RANDOM ACCESS MEMORY.
I thought the release announcements of Rails projects had to promise to cure cancer!
Here's an easy[1] one: optimize object attribute layout in Rakudo. That's close to a 50% memory usage improvement. [1] Where "easy" means "We know how to do it and we know it'll give huge memory improvements, but we haven't finished it yet" and not "That's only a couple of lines of code."
I think you misunderstood the author's expectations. Sure, everyone knows that Perl 6 hasn't had the years of work put towards optimizing it that Perl 5 has had. But still, it uses ***30 times*** more memory than Perl 5 does. That's a sign that something is seriously screwed up. Now, maybe it'll get fixed soon enough, but it doesn't leave a good first impression, that's for sure.
&gt; ... it uses 30 times more memory than Perl 5 does. Then you add in only a handful of features that Perl 6 has natively that Perl 5 doesn't, and Rakudo Star starts up just about as quickly and uses moderately more memory.
But ***30 times*** the memory usage? You have to admit, that is excessive, even for a relatively new implementation.
By my count, it's 2.5x virtual memory and 4.4x resident memory once you start loading modules in Perl 5. A single optimization we're working on in Parrot right now should almost halve the memory requirements of Rakudo Star.
Digg just called, wondering where you wandered off to.
well, the Moose people could put a hook on "no indirect" (or shovel indirect.pm in and adjust it to fix the call instead of warn) that calls the 'with' routine the right way, I think, but is that something they really want to do?
No, I don't think it is. Just pointing out *why* it looks like it works and why it's not a habit to get into anyway. :)
This is some great work. You're doing the Perl community a real service.
What's Perl telling you? Hard to diagnose without knowing the output.
What kind of problems are you having? I see the "can you help me out" portion of your post, but do not see the "it is doing undesirable thing X" portion of it.
You've got about half of a viable problem report here: you've shown us what the code is and what it's supposed to do, but not what it does. Random speculation: If the files really are in the directory BKUP then using the glob 'BKUP\*.\*' is just going to match the directory name and not any of the files. Edit: that could be a side effect of Markdown, as if you type \\\* in a message you get just \* as \\ is the escape character. You should really either quote your code properly or put it on pastebin and link to it. 
Ha sorry, I guess the problem is that there is no output. No sql files are created and no error messages are given.
Sorry, there is no output. It appears to run the pl file, then the command prompt comes back.
crap. that should be BKUP\*.* It's supposed to take the .mddata files and turn them into SQL files that I can open with SQLite3. When I run it, nothing happens, but I don't get error messages.
Then your first step should be to liberally sprinkle some "got here" style print statements throughout the program, so it _does_ output something, and you can tell what it's doing. :) And this wouldn't go amiss at the top of the foreach either: print "Looking at $filename\n"; Then you'd know if it's actually looking at any files. :)
Do you mean BKUP\\\*.\*? Again, \\ is the escape character for Markdown. To test that your glob is correct put in a statement to print each filename as it's being processed. 
I ran it on my iphone backup and it created a few dbs before I control c-ed it. The resulting dbs (named "unknown_xx.db"--the $type thing isn't quite right, I think) were able to be opened by the sqlite3 command line app. A minor error. This line: printf STDERR "%-60s to %-25s\n", $filename, $type, $outfilename; should have an extra %s in it. I did: printf STDERR "%-60s [%10s] to %-25s\n", $filename, $type, $outfilename; Edit: Turns out it was copying stuff but wasn't actually changing the files. For instance, it printed: 09a618ce5da211113646f10d98a4f0d22441709f [ unknown] to unknown_01.db But "diff 09a618ce5da211113646f10d98a4f0d22441709f unknown_01.db" says the files are the same. And incidentally, I can run sqlite3 on the original file. Which makes me wonder, which files are you looking for that aren't directly openable by sqlite already?
Protip 1: `use warnings` is the more modern way to say `-w`. Every non-trivial Perl program should start with: use strict; use warnings; Or use one of the modules (Moose, Badger, etc) which set the `strict` and `warnings` pragmata for you. As for your script, I can't see any glaring errors in the Perl code. Perhaps it's a logical problem. This line looks suspicious: ($data =~ m|SQLite|) or next; Perhaps try changing that to something like this to get some feedback about which files are being ignored: unless ($data =~ m|SQLite|) { warn "Ignoring $filename (not a SQLite file)\n"; next; } 
No! Bad monkey! Use [Dist::Zilla](http://dzil.org/) for new distributions.
http://search.cpan.org/~msergeant/DBD-SQLite-0.31/lib/DBD/SQLite.pm Might be useful for dealing with SQLite files.
My favorite was from someone on /. Perl looks like an explosion in an ASCII factory
Thank you for the suggestion, I'll look into Dist::Zilla. Unfortunately it's not mentioned in any of the resources I listed at the bottom of the page, so this is the first I've heard of it.
Instead of `use strict; use warnings;`, I've switched to `use Modern::Perl;`. Nice article.
From the [description](http://search.cpan.org/~rjbs/Dist-Zilla-4.101900/lib/Dist/Zilla.pm#DESCRIPTION), &gt; Dist::Zilla builds distributions of code to be uploaded to the CPAN. In this respect, it is like ExtUtils::MakeMaker, Module::Build, or Module::Install. Unlike those tools, however, it is not also a system for installing code that has been downloaded from the CPAN. Since it's only run by authors, and is meant to be run on a repository checkout rather than on published, released code, it can do much more than those tools, and is free to make much more ludicrous demands in terms of prerequisites. 
`perldoc Test::Tutorial` 
Module::Starter is not a bad choice for beginners. In fact, I suggest that it's probably better for beginners than the mighty dzil.
As another resource check out [Task::Kensho](http://search.cpan.org/~apeiron/Task-Kensho/lib/Task/Kensho.pm).
Nice API. Will definitely consider this tool over threads. How does this compare with IO::Lambda though.
Which 3 people missed the up arrow?
That tells you how, not why.
Well, presumably, if someone is looking for a "testing best practices" document, they probably already know *why*, and have also decided they do in fact want to test, and at this point simply want to know the practical aspects of how to go about it. Which modules to use, which files your tests go in, how to run them, etc. There are already tons of blog posts and other articles out there telling you why you should write tests. 
I see a hypothetical *Perl Testing Best Practices* as a design book.
Nice. I'm hoping there's a pretty-print option for that too - could just pipe the output through perltidy though in a pinch, I suppose. 
It'll be coming soon, I'm sure. 
I trust Sledge Hammer. He knows what he's doing.
If it were a very thin and opinionated book that discussed things like "how to structure your code so it's easier to test" (in addition to, of course, the basics as I mentioned above), then I'd probably be interested in buying that book. 
**Lastly, be very clear when you say "useable".** Ahh so true, reminds me those conversation around the office coffee machine: &gt;"So Perl 6, so now is it use-able ?" I still struggle to find the right pitch in less than 20 words 
I was expecting the software to print some gibberish that was stall valid perl.
This is good advice for writing to experienced developers about any language or platform. I think it's okay to point out commonalities when you're writing to novice developers, though. People need to understand that learning a new language isn't scary - it's fun! But yeah - even those novice developers should get to learn what's different and interesting about Perl 6 or Parrot or whatever.
Even a human brain speech recognition wouldn't have recognized all what this guy said.
This guy just saved me the frustration. Thanks!
Crying... that was the finniest thing I've seen today.
So efficient, it could only be made by M$. 
Show us the code that doesn't work, and tell us what it does, and what you expected it to do.
It seems like such a little thing, but it really is a huge improvement: $ perlbrew switch perl-5.8.9 $ perl -wle 'my $foo; print $foo' Use of uninitialized value in print at -e line 1. $ perlbrew switch perl-5.10.1 $ perl -wle 'my $foo; print $foo' Use of uninitialized value $foo in print at -e line 1. 
It's like `say` in that respect. How facile it seems until you use it.
You're right, that did seem a little fishy.
Related: [Difference between my and local](http://www.perlmonks.org/?node_id=94007) 
IF IT IS INSIDE ME, IT IS PERL.
At first glance, it doesn't sound too difficult for $@ to contain an object that has a stringification overload that returns the standard error messages as in current versions. The object can then contain meta-information like what is contained in [perldoc perldiag](http://perldoc.perl.org/perldiag.html) -- message severity, which [warnings](http://perldoc.perl.org/warnings.html) or [strict](http://perldoc.perl.org/strict.html) classification would disable the check, and even a permanent error code. 
That's my suggestion.
You might get help here, but my guess is that your best shot will be in posting on the forums of your hosting provider or looking at their wiki (if they have one).
@INC is the search path that perl is using to find the module. There's a good chance that cpanel installed the module somewhere in your local directory structure. If you find it - via a browse feature or whatever - I'm not a cpanel user, then add the line: use lib '/home/server/path/to/module' or whatever and your script should start to work.
Greetings, I have a script that needs DateTime. A lot. The only way that all of the functions are located is to list them as in the example below. use DateTime; use DateTime::Format::Strptime; use DateTime::Locale::en; use DateTime::Locale::en_US; use DateTime::Locale::root; use DateTime::TimeZone::America::New_York; use DateTime::TimeZone::CET; use DateTime::TimeZone::Asia::Tokyo; ETC. As a down and dirty diagnostic tool Perl2exe http://www.indigostar.com/perl2exe.php works a treat. Perhaps you are using a subset of the Reuse.pm module. If memory serves the evaluation time out for Perl2exe is 30 days. Another good feature is the intended one of creating executables. This will keep most, not all, people from mucking about once you "fix someone else's problem". Namtog P.S. It seems Reddit formats a little strange. Each use statement is on it's own line.
This is certainly one of the more- ahem... creative, novelty accounts.
1. Don't use Switch. Ever. 2. Stop repeating yourself. 3. You don't really need to handle days of the week that haven't been invented yet. Working code, that turns the actual meat of the program into just two lines: use strict; use warnings; my $vlc_path = q{C:/Program Files (x86)/VideoLAN/VLC/vlc.exe}; my @movies = ( "D:/Movies/blah blah", # Sunday "D:/Movies/herp derp", # Monday "D:/Movies/etc etc", # Tuesday ..., # to Saturday ); my $wday = (localtime)[6]; system($vlc_path, $movies[$wday]) and die "Failed running VLC: $? ($!)";
PERL 6 IS ALL NOVELTY. IT IS NOTHING BUT RAW INNOVATION. AND IT IS INSIDE ME.
You can put two asterisks before and after your text to make it bold. **Like so.** If you're going to troll, at least do it well. P.S. does is pull out before it it comes (y/n)?
Thanks. Just one question. Why shouldn't I use switch? Is it an efficiency issue? Or does switch just suck?
Guido.
Only because I starting writing the code using switches, I have it fully working using them. I am already working on a version 2 code using arrays and pre-defined file paths like you indicated. One snag I'm hitting though is that on certain days of the week I need to call up two movies. Using switch I just add two movie args to the system call but using your method, I am having trouble seeing how this can be easily implemented. Thanks again for your help.
http://www.perlmonks.org/?node_id=453292
ah. so it is considered bad practice because things *can* go wrong. but if i have written code for personal use, and i use switches, and it works, there's nothing really wrong except that i'm being lazy and/or sloppy. correct?
 my @movies = { 0 =&gt; ( # sun 'movie1.mp4', ), 1 =&gt; ( # mon 'movie2.mp4', 'movie3.mp4', ), ... etc }-&gt;{(localtime)[6]};
thanks, i'll try it out.
I should note that i posted this specifically looking for criticism, so i would be grateful if down-voters could leave a word or two as to why they are doing so. :)
We all get to choose our own poison. Stiull, source filters are rarely a good idea. For perl 5.10 and above we have given/when and the smart match operator. Hobbified's answer seems the most clear. Though I might actually do it myself using a directory of links. I dislike config in code.
You're writing a script, so if it works in the script yeah no problem. If you want to practice a more correct way for future situations or if you're just plain anal (if you're not now, you will be soon), do it a better way with arrays (as in this case) or hashes or given/when - see [perlsyn](http://perldoc.perl.org/perlsyn.html#Switch-statements) for the latter. Also, I don't know why you're getting downvoted, seeing that zero irritates me.
I didn't downvote you, but I've seen arguments before about whether your metrics are in fact meaningful indications of "bad smells" in code. Perhaps you could offer your reasoning. You might also get references to Perl::Critic as being a better option. Universally, people seem to agree that code reviews are among the best methods.
haha. thanks. yes i am anal. it works perfectly and i'm still going to rewrite the code to be perfect.
Context: http://stackoverflow.com/questions/3435428/how-can-i-count-the-respective-lines-for-each-sub-in-my-perl-code
I think the thing you and possibly others are stumbling over is the difference between proof and indicator. No metric can ever be a proof of code quality, simply by virtue of code quality being subjective. However, the metrics of line length, byte length and indentation depth can be very useful indicators of code that needs to be reviewed. As for Perl::Critic, yes it is a very useful tool, but largely cosmetic and focused on very small-scale indicators. It just plain does not take a large view like this. My situation is this: I have about half a megabyte of perl code to "clean up". That is a lot of stuff to review. As such i decided it would be best to find a way to get perl to tell me what seems to be the worst and where i should start looking. (Note: Looking, not changing.) I've attached example output at the bottom of the file in the __END__ block of the script, please do scroll down and have a look at it. It clearly points out Family.pm as looking like the worst file among what I'm working with, and having reviewed it, i agree with the script output. It's flat out terrible. Take a look for yourself: http://gist.github.com/514713 (Also, thanks for the input.)
Result of running it over my Perl installation. Depth detection seems to be working fine now and finds some pretty ugly constructs. ### Average Block Length 12.1921178249061 ### Average Block Size 351.142237945591 ### Average Block Depth 1.37439390803084 ### Top Ten Longest Blocks File Line Lines Size Depth Dev. ================================================================================ site/lib/Module/ExtractUse/Grammar.pm 5 3689 102499 0 302.57 site/lib/ExtUtils/XSpp/Grammar.pm 494 2944 45805 2 241.47 lib/perl5db.pl 1859 1686 61080 0 138.29 site/lib/Bio/SearchIO/blast.pm 443 1414 53587 1 115.98 site/lib/DBD/Pg.pm 246 1405 55545 0 115.24 lib/perl5db.pl 2165 1383 50915 2 113.43 site/lib/Bio/SearchIO/blast.pm 460 1374 52164 2 112.70 lib/perl5db.pl 2255 1206 44745 1 98.92 site/lib/Bio/SearchIO/fasta.pm 209 1189 44556 1 97.52 site/lib/Bio/SearchIO/fasta.pm 219 1168 43980 2 95.80 lib/perl5db.pl 2294 1144 42619 4 93.83 ### Top Ten Biggest Blocks File Line Lines Size Depth Dev. ================================================================================ site/lib/Module/ExtractUse/Grammar.pm 3694 1029 106845 12 304.28 site/lib/Module/ExtractUse/Grammar.pm 5 3689 102499 0 291.90 lib/perl5db.pl 1859 1686 61080 0 173.95 site/lib/DBD/Pg.pm 246 1405 55545 0 158.18 site/lib/Bio/SearchIO/blast.pm 443 1414 53587 1 152.61 site/lib/Bio/SearchIO/blast.pm 460 1374 52164 2 148.56 lib/perl5db.pl 2165 1383 50915 2 145.00 site/lib/ExtUtils/XSpp/Grammar.pm 494 2944 45805 2 130.45 lib/perl5db.pl 2255 1206 44745 1 127.43 site/lib/Bio/SearchIO/fasta.pm 209 1189 44556 1 126.89 site/lib/Bio/SearchIO/fasta.pm 219 1168 43980 2 125.25 ### Top Ten Deepest Located Blocks File Line Lines Size Depth Dev. ================================================================================ site/lib/Math/BaseCnv.pm 71 5 428 20 14.55 site/lib/XML/Tidy.pm 56 7 562 18 13.10 site/lib/Bio/Tools/Run/StandAloneNCBIBlast.pm 187 12 888 13 9.46 lib/CPANPLUS/Internals/Constants/Report.pm 301 4 204 13 9.46 site/lib/CPANPLUS/Internals/Constants/Report.pm 301 4 204 13 9.46 site/lib/Net/SFTP/Foreign/Common.pm 314 4 204 13 9.46 site/lib/Module/ExtractUse/Grammar.pm 3694 1029 106845 12 8.73 lib/CPAN/Distroprefs.pm 157 35 1213 12 8.73 lib/CPANPLUS/Internals/Constants/Report.pm 300 11 637 12 8.73 site/lib/CPANPLUS/Internals/Constants/Report.pm 300 11 637 12 8.73 site/lib/Net/SFTP/Foreign/Common.pm 312 7 425 12 8.73
I see what you're saying and I did look at your example output before posting. In your case it probably is a useful tool to tell you where to begin. At worst it's telling you what you already know, although I'm still not convinced it's telling you much more. Perhaps if you included more specific metrics like number of lexical variables and their average references/assignment count, number of die/croak statements (or other validation measures), # of tests per function and # of tests per line/size. This may take considerably more work (I've never used PPI) but then you'd be getting somewhere a lot more interesting. btw, I'd be interested to see the output on [HTML::TreeBuilder](http://cpansearch.perl.org/src/PETEK/HTML-Tree-3.23/lib/HTML/TreeBuilder.pm), although the current maintainer may not. :) &gt; # ... ALL HOPE ABANDON ALL YE WHO ENTER HERE ... 
Thanks for the input. I've been thinking about possible other metrics to add, and i will over time. (Though not all you mentioned there.) Also, it told me something very useful: I had mentally pegged Family.pm for being the worst from the start. What i did not know is if there was something else hiding that was worse. On second thought, maybe i should label this code structure statistics, since that's more what it looks at: How well/badly structured code is. Other modules (strict, warning, critics, cover, nytprof) handle the detailed stuff and some of what you mentioned very well already. This is the first project i am aware of that looks at code like this. &gt; HTML::TreeBuilder Aside from outliers, not that bad, compared to the averages of CPAN overall: http://gist.github.com/514749
to be perfectly anal, upgrade your perl to 5.10 or greater. Then you can do the following: use feature qw/switch/; given($string) { when (/^abc/) { $abc = 1; } when (/^def/) { $def = 1; } when (/^xyz/) { $xyz = 1; } default { $nothing = 1; } } it can do more than compare with regexes. http://perldoc.perl.org/perlsyn.html#Switch-statements
&gt; I have about half a megabyte of perl code to "clean up". Could you elaborate a little more about what you are "cleaning up?" I'm confused by your metrics because, code unseen, I don't see how your metrics matter. Just taking [your example](http://www.reddit.com/r/perl/comments/cyuhm/perl_code_statistics_find_that_smell_of_code_in/c0waszs) and looking at [the code itself](http://padre.perlide.org/trac/browser/trunk/Syntax-Highlight-Engine-Kate/lib/Syntax/Highlight/Engine/Kate/CSS_PHP.pm?rev=6351#L20) I have a surface response of 'so what?' Have you taken a look at [Devel::NYTProf](http://search.cpan.org/perldoc?Devel::NYTProf)?
This won't work. @movies is an array, but it assigned a single element .. the anonymous hash enclosed by { ... }. Also, within the hash, using key =&gt; value is good, but ( 'element 1', 'element 2' ) creates lists, not anonymous arrays. You want my @movies= ( [ 'movie 1.mp4' ], # Sunday [ 'movie 2.mp4', 'movie 3.mp4' ], # Monday ... ); system( $VLC, join( ',', @{ $movies[ $wday ]} ) ); Derefernce the array using $wday to get a that day's data, which is an array reference. Enclosing it in @{ ... } tells Perl to use the whole array ofdata; join() turns it into a comma separated list
I think you may have gotten confused somewhere. I never said that the example you linked was related to the code i am cleaning, nor that the code itself, which you linked, was bad. I hadn't even looked at it, in fact. I am working on code as represented [here](http://gist.github.com/514749), and the output i am getting on it is at the end of the file linked at the top via reddit. In regards to the code you linked there, please note what i said earlier: &gt; No metric can ever be a proof of code quality, simply by virtue of code quality being subjective. &gt; However, the metrics of line length, byte length and indentation depth can be very useful indicators of code that needs to be reviewed. The output of this script does not mean "this code is terrible, fix it". It means "this looks weird, you might want to look at it". It is meant to be a guide in deciding where to look first when confronted with a body that cannot be surveyed in an instant, or any appreciably small timeframe, for that matter. (Nonetheless, the linked module could use some restructuring. Not urgently, but it could benefit from it.) Lastly, i am confused as to how NYTProf helps with code structure in the least, but yes, i have made extensive use of it in many occasions.
&gt; I think you may have gotten confused somewhere. I never said that the example you linked was related to the code i am cleaning, nor that the code itself, which you linked, was bad. I hadn't even looked at it, in fact. Clearly I am baffled. In your comment on the results of your profiling you [describe](http://www.reddit.com/r/perl/comments/cyuhm/perl_code_statistics_find_that_smell_of_code_in/c0waszs) "ugly constructs." That seems to be a negative assessment based on some kind of judgment. I linked to NYTProf because that is a reliable toolkit for profiling. And yet you are indicating that not only you are aware of it, it is irrelevant to the discussion at hand. Especially specific for what you have indicated: &gt;&gt; No metric can ever be a proof of code quality, simply by virtue of code quality being subjective. However, the metrics of line length, byte length and indentation depth can be very useful indicators of code that needs to be reviewed. I fail to see how you have demonstrated that these are useful indicators if you haven't even examined the code that your, ah, profiler has reported. If your meat grinder generates fruity oatmeal, wouldn't you wonder if you are putting in fruits and grains? Furthermore I don't agree that code quality is entirely subjective. But given the profusion of confusion that we share, I'm not even sure that we could approach that topic.
i was just looking into that. thanks.
...Or [Rose::DB::Object](http://search.cpan.org/perldoc?Rose::DB::Object)...
Larry. (I love the picture. Wish I could upvote it more than once!)
&gt; profiling See, this makes me think you missed something. You seem to think i am collecting runtime performance statistics when I am clearly not. Why do you think so? (Also, splitting this up in multiple threads at this point.)
&gt; haven't even examined I have mentioned more than once that I am working on code base that is separate from CPAN. I spent considerable time testing it on this limited codebase beforehand, where i did indeed examine and verify the results. My posting of the result of running it on CPAN is meant nothing more as to provide a curioso. Furthermore, as to that data set: The "ugly construct" comment was edited in with new data, AFTER i made my post above. I spent the whole night continuing to improve the script, and after i made the earlier response to you i turned my focus towards verifying its results when run on cpan. The indentation detection was my main focus, because it was the most hairy part, and as such i was mostly referencing those results with the comment on "ugly structures". As i sort of agree that it's a bit pointless to criticize modules that are largely data containers or auto-generated. I have put them on the default ignore list and rerun the script, so the line length and byte size top ten lists provide more interesting data. (I still would need to exclude ExtUtils/XSpp/Grammar, but i do not feel like running it for an hour again just to filter one module.)
&gt; I don't agree that code quality is entirely subjective Consider this: I am mainly a functional programmer. A while ago i worked for a person who is mostly an imperative programmer. To me clean code consists of clearly named functions that are ~5-40 lines in length, a screenful each at most. To him clean code consisted of huge functions, handling one over-arching task, with each activity in the task spelled out directly in that function. To both of us the code of the other was hard to read and looked simply terrible. As such i think it is a subjective matter, if only because i do not want to appoint myself an arbiter on this. I do however have opinions on code quality and voice those.
I'm not familiar with submitting patches to modules for perl. If someone knows the route better than me, would it be possible that the patch in this article could be submitted for Net::Oscar so that others can get this fix through cpan?
Report a bug at [Net::Oscar's RT Queue](https://rt.cpan.org/Public/Dist/Display.html?Name=Net-OSCAR).
I'm just gonna say this I was in junior high hearing about Perl 6 and now I am in college studying for my computer science degree. And I still think this... Perl 6/Rakudo is awesome. I don't care if it's slow I still love Perl. 
Oh, so the Perl users who bagged on Ruby for its speed are no longer concerned about speed. I guess when it's *your* favorite language, speed doesn't matter. Isn't religion fun?
I suspect you didn't actually read the article. Nothing close to what your reply suggests can be reasonably inferred from there.
Maybe it's just me but I think perl mongers have the coolest cult leader of any programming language out there.
Dude!
this doesn't work. when i try to print out that element of the array (given by $wday), it prints out an address, something like ARRAY(0x11afc8) what am i doing wrong?
Great interview. Thanks for posting. Would've liked to hear him talk a little more about Perl 6 though. Anyone know when this was recorded? 
I really enjoyed this - good insight on programming in general. Obviously (and naturally) he's spent a lot of time thinking about this.
I can quote many Ruby developers saying "speed doesn't matter". Can you quote any Perl 6 developer doing the same? 
I always like hearing Larry talk. It's been a bit since I've done serious in Perl and he makes me want to come back.
Cool!
I think you're in for a major headache and should just upgrade to the latest Fedora release to handle this problem. But you could try to build perl from the source. I think though you will end up breaking some library dependency somewhere.
Larry Wall is nice and has a great perspective. I keep thinking I want to see a new edition of "Programming Perl" - but it wouldn't feel the same if it wasn't in his voice, and given the choice I'd prefer that he keep working on Perl 6 stuff.
As far as I know, @INC's initial contents are set at compile-time. You'll need to build Perl on your own. Try building Perl with a prefix and put it in /opt (or whatever other location you like), and update your #! lines to point to that Perl. Replacing the system perl is almost certainly not going to work well. Or upgrade your distro. Fedora Core 3 has been out of support for something like 5 years now.
* Fedora and Redhat and Perl don't jive well together. Google "Redhat perl" for fun reading. * Never put a custom-built perl on top of your system perl. Far too many things depend on perl for you to be futzing around with it. * Instead, put it in a separate location. There are several solutions, depending on what you want, but I'd suggest just compiling it yourself. Make sure you set your PREFIX to something that's not `/usr/bin` or whatnot. `/opt` is a good alternative. * `@INC` is set when perl is compiled. You can futz with it at runtime using `use lib` or `local::lib`. * `perlbrew` may be an alternative for you, allowing you to run multiple versions of perl on a per-user basis. May not be bug-free. * Seriously, drop Fedora. Or at least upgrade to something from this **decade**.
Yes, @INC is baked in at compile time. To install a separate copy of perl in its own prefix: wget http://www.cpan.org/src/perl-5.8.7.tar.bz2 tar jxf perl-5.8.7.tar.bz2 cd perl-5.8.7 sh Configure -Dprefix=/where/ever/you/want/it/to/install -des make make install # if you need more info: perldoc ./INSTALL 
Unfortunately, he's ten versions behind. Yes, *ten*. That will mean trying to upgrade and fix 10 upgrades. Considering however that the archives for anything older than IIRC Fedora 7 are offline now, though, that's pretty much a longshot.
To be fair, FC3 came out in November, 2004. It's a little shy of 6 years :) I've rebuilt multiple servers from FC to Debian here at my current gig, and I could choke a bitch for it. Honestly, why people think building servers off of sandbox OSes (which is what FC is, it's a testing ground for Redhat) is even a reasonable idea is beyond me. Listen, if you like Redhat, use RHEL for your servers. If you don't want to pay a license, use CentOS. But for the love of god and all things non-shitty to do to the admin who will someday have to take over for you, use an OS which, from the get-go, has long-term support planned.
Hum. Rolling decade, then?
Fair enough ;) It is, however 10 versions back, heh :)
Please don't run Fedora that is that old. It is, by definition, completely unsafe and vulnerable to all kinds of attacks. If you *must* do this, just compile your own version with a --prefix=/usr/local or maybe /opt and it shouldn't interfere with the RPM-installed system wide one. Better yet, [install Fedora 13](http://fedoraproject.org/get-fedora) and get your code working under a current version of perl (it comes with 5.10).
I don't think you should decide that Fedora is shit for perl because of one long-fixed bug. Shall we bring up [the colossal Debian OpenSSL cock-up](http://www.linux.com/archive/articles/135270)? But I do totally agree with you that the OP should upgrade to something even remotely current.
Don't touch the system perl. You *will* break things if you replace it. Build perl from source (either manually or with perlbrew) and install it in its own directory, and install anything you need under it from CPAN, not RPM. You'll need a C compiler and toolchain installed, and appropriate dev headers for any XS libs you want to build. Questionably useful alternative: see if you can find a build of ActivePerl that's compatible with FC3 and install that. ActivePerl is a binary distro of perl that keeps itself separate from the system perl, and includes its own package manager full of pre-built modules. No need for build tools, but whatever versions of whatever modules are available in the repos are what you get. And most of the third-party repos out there are only for ActivePerl on Win32, not for Linux.
The redhat thing was not that they felt it necessary to take a development release of perl, patch it, and release it as stable, but rather, after the bug was diagnosed and reported, the amount of time it took redhat to fix it.
You're definitely looking at a fresh install. I just don't see that as a very big deal; ymmv.
Yeah, the only big issues I've found is when there's a significant purpose for which the software either doesn't upgrade gracefully, or sometimes (rarely) exist any more. Just sucks to have something as casual as requirements for a perl app be the impetus behind the upgrade.
Interesting. I started using Moose the first time this weekend and found myself defaulting to heavy constructors. Now i see an article that discusses exactly that design choice. (And the startup speed penalty is a lot smaller than i expected from all the flack Moose gets.)
Although those are good solutions, I had hoped to find a "push"-model based deployment method (à la Tomcat).
An admin wants to view the deployment target as a whole. With the OS having one kind of configuration management, and each application tool chain having another we end up managing and automating our way around a lot of different deployment schemes. The worst part is that software developers continue to think they know better than everyone who came before them. They continue to invent new and different ways to complicate system configuration management. Often simply because they did not bother to research what techniques were available and in use prior to their arrival on the scene. 
Go through the Catalyst Tutorial http://search.cpan.org/dist/Catalyst-Manual/lib/Catalyst/Manual/Tutorial.pod
You can definitely build a simple blog which uses a template system and stores the items in the filesystem (as text files), eliminating the need for a database (if that's what you want). Nothing wrong with that at all and it's a great way to learn. A framework doesn't always save you time, or shield you from the complexity. Sometimes the abstractions aren't the exact ones you want. Your project sounds very modest in scope and looks to me like a candidate for a feathery-light, non-framework approach -- for example, potentially just a script to merge your blog entries with a template or two, and generate static pages, served by Apache maybe?
For a simple framework I suggest [Dancer](http://perldancer.org/). Great thing, it made me stop hating web development. But really, seeing the amount of **very simple** in your post I think that possibly you won't need even CGI. I once wrote a blog engine (kind of very simple stuff) which was using DBI only.
I'd love to take the feathery light approach, but I think that it is still fairly above me, so it might be better to take the framework route. Would you happen to have any Perl related reading material/links on the feathery light approach though? 
My favorite book is the Perl Cookbook, and for asking questions, http://perlmonks.org (or IRC). Maybe others can chime in with their recommendations?
As with any web application, be careful with letting random web users submit any sort of data. If you can avoid having user authentication or user comments at all then you win. The best case would be a script that processes templates server side and only (generated) static HTML getting served by the web server. If you are handling incoming data over HTTP you have to start worrying about security, and web application security is non-trivial.
This. While Catalyst is a bit heavy-handed for "simple things" I've found that, almost invariably, I end up wanting to add features or make changes to my design later. In cases where I've used other frameworks (which were perfectly suited to my needs at the time) I usually come up short, or with a fairly ugly hack. Catalyst, so far, has always been able to accomplish what I want. As a side-note, (modern) versions of Catalyst are built on top of [Moose](http://search.cpan.org/~drolsky/Moose-1.09/lib/Moose.pm). You will probably want to look at [CatalystX::Component::Traits](http://search.cpan.org/~rkitover/CatalystX-Component-Traits-0.14/lib/CatalystX/Component/Traits.pm), which allows you to compose Moose roles at runtime into your application, via the config file. 
He could get comment functionality via third-party services like Discus.
Dancer is great. Inspired from Ruby's Sinatra. Another Framework similar to Dancer is Mojolicious::Lite. The good thing about that one is that you get something simple done very easy, but it can be changed into a full Mojolicous app without any extra work. Quote from the website: &gt; A project can be started as a single file web application using Mojolicious::Lite and later grow to a well structured Mojolicious application. 
Please read about security, and be aware of the risks like cross-site scripting, cross-site request forgery, SQL injection, code execution and the like. You don't want to open a door for spammers, don't you? :-) If you want a small web framework, look at CGI::Application &lt;http://search.cpan.org/perldoc?CGI::Application&gt;. Some people like it.
The last ultra-simple Perl blogging setup I can remember was Bloxsom. Whatever happened to it?
Check out [ikiwiki](http://ikiwiki.info).
It's still [going strong](http://www.blosxom.com/)!
I did this for the same reasons back when perl5 was just new, and CGI.pm was the greatest thing since sliced bread! I'm not sure we called them "blogs" so much way back when ;) I only used the CGI functionality on my local server. The whole interface amounted to a couple of pages with a "go!" submit button on each and not much else. The app would gather blog entries kept as html in a certain directory, scan them for date/title/content, and rebuild a series of interlinked web pages. After a feedback screen to let me preview, one more button to upload to the live site via LWP. No worries about security, and still pretty automated. I learned a lot building it, even though I didn't know from CMS. I think a framework is kind of heavy handed for a simple task like this, btw. 
So.. we've got frameworks, but stuff that's not been covered: 1. Your articles, tags, and whatnot exist somewhere. Whether that's the filesystem, a document DB, or a relational DB is up to you -- but whatever you pick, don't marry your app to it. Just write a `MyBlogApp::Blog` sort of class, with classes under it like `Article` and `Author` and `Tag` (only `Article` is really necessary of course) and methods for finding relevant things. Then in your actual app, finding the relevant thing to display should *never be more than two or three lines of code*, and if you want to change your whole backend, or add multiple backends, or add something new (like multiple authors) you can. Software componentry is a nice thing. 2. Post formats. Markdown? Textile? POD? HTML? Pick one, or pick "all of the above" by writing some code that reads any of the formats and spits out HTML for all of them. Just be careful if you accept HTML that you don't let it blow up the whole page or do XSS.
Maybe if I'd remembered how to spell it…
This is hilarious ! I lost it at "Plus: How miyagawa writes five distributions before breakfast" Bookmarking perlvogue.com right away. Looking forward to the future content. 
If you can keep it as minimal as you say, why not write it a few different times. Seriously. If it's really simple, it will probably only take a few hours, then you can try it with a framework, without a framework, and whatever combination you feel like trying. Personally, I write todo list apps, but a blog would probably work.
http://freshmeat.net/search?q=perl+blog&amp;submit=Search
What version of perl has the flip/flop? My 3d edition of Wall's camel book doesn't have it.
page 103. it is the range operator. when used in a scalar context it is often called a flip-flop.
How minimal? http://www.0x743.com/vee
If you like that idea you might want to take a look at [chronicle](http://steve.org.uk/Software/chronicle) - disclaimer I wrote it.
RTFM http://cpansearch.perl.org/src/MARKOV/CPAN-Site-1.06/explain_101.txt
Yeah, actually I did, but I didn't get it. I ended up installing v0.26 to get the shell back.
I think your supposed to use the cpan shell and change it's url list to point to your local CPAN::Site server. The CPAN::Site module is now server side only
I really like Config::General, it's similar to the apache configuration file syntax. Also, you can use JSON, YAML, XML, ini files, whatever. Or use Config::Any that loads anything it finds :)
um, well do it yourself in the program. look there are tons of modules out there, and you could use them... but since you're new to perl this is an excellent excerise- * open the file. * have it referenced by the program. * create a loop that reads each line to the end. * do things while in that loop, like parse per-line info and split it into chunks of useful info to be used in the rest of the program (using regex) * close the file. That's the extremely basic idea (and don't consider me an expert, I barely know what I'm doing) and I think if you put that together even as a mere framework, you could then go back and learn how to do each of those things. The value you will derive from this exercise will be valuable to your programming skills, more than any pre-built module could be at this point.
I'll expand- * design your own config file and the different categories of info per line- separate them with a space or other character so your loop can sift through them easily. no need for xml for that at all.
I appreciate your guy's responses, but I'm not *that* new to perl. I could do all of that pretty easily, I just wanted to see if there was a simpler way to do all of it.
Don't use XML. It's slow and unnecessarily complex. If you really need a tree config structure, JSON is good. If you can go a bit more simple, look at Config::INI::Reader.
how can i install that package on windows? it looks like i'm going to have to install a gcc? or is there a pre-built package?
woah
lol sorry about that. *Cheers*.
Which vendor's perl are you using on Windows? ActiveState, etc. I haven't done Perl on Win for a while, but you might be able to use this command: perl -e -MCPAN 'install Config::General'
activestate
thanks i'll look into it
Hello, I've wrote some time ago some simple code making this, here it is: http://blog.0x1fff.com/2009/07/simple-config-reader-in-perl.html (comments welcome) Rhere are also some ini file readers in CPAN, but are not in standard Perl distribution AFAIK.
If you're using activestate, just see if they have a package for any format (parser/generator) (yaml, json, etc) . I would always recommend using Strawberry Perl on windows though. http://strawberryperl.com/
Sounds like Config::Tiny is what you're after - simple, lightweight, no dependencies that don't come with Perl already. The config follows the familar INI style format, easily hand-written.
Don't do JSON, use YAML if you'll go that route. However, Perl Best Practices suggests Config::INI for this sorta stuff. (I usually do a: # NOTE: WRITTEN AT 6:30AM w/o coffee, not even tested. my %conf; open(my $conf_fh, '&lt;', "$ENV{'HOME'}/.somedotfile"); foreach my $conf_line (readline($some_fh)) { next if $conf_line !~ /=/; next if $conf_line =~ /^\s*\#/; my ($key, $value) = split('=', $conf_line); $conf{$key} = $value; } close($conf_fh); but that's a severe over simplification of it all (works great for quick and dirty programs though)
&amp;#8721;F = 0
commented in the article as well, but I'm a fan of this one: &lt;C-F&gt; :1,$!perltidy -pro="/home/myhome/.perltidyrc" -st&lt;CR&gt;
IIRC, there's a command "ppm" that fires up the package manager. Either the [PPM list](http://ppm4.activestate.com/idx/CM...CO.html) or [CPAN](http://search.cpan.org/dist/Config-General/) should tell you if Config::General is compatible and how to load it.
I'm probably missing something, but doesn't this merely reformat the code for easier viewing? Wasn't the author interested in readjusting his indentation so he could match other authors' indentation styles when maintaining their code? This seems to be the opposite of his original point: &gt;Reformatting usually isn't a good idea since not only may the original author object... Don't get me wrong. Perltidy sounds useful. But, it's usefulness is at cross purposes with the blog post.
Config::Tiny is my goto module...its a single module file you can just include in the directory tree with your script.
An open dialog would work best. There are also save dialogs and directory dialogs. Win32::FileOp::OpenDialog - http://search.cpan.org/~jenda/Win32-FileOp-0.14.1/FileOp.pm Tk::FileDialog - http://search.cpan.org/~bpowers/Tk-FileDialog-1.3/FileDialog.pm ---- I see you are working on Windows. Clearly the module is for Win32, but I don't know if it is crossplatform for Linux or Mac.
How can I install those packages? PPM doesn't list either Win32-FileOp or Tk. The ActiveState perl distribution uses Tkx instead of Tk. Is there a comprable directory dialogue in Tkx?
this should download the module and install it. perl -MCPAN -e 'install Tk::FileDialog' 
Installing Tk::FileDialog requires building the Tk distribution, which itself requires Visual Studio installed because it requires building C files. Most ActiveState users therefore don't use CPAN but get their modules precompiled as binary packages, so this is kind of dangerous advice to be giving.
To directly answer, use your OS's or a cross-platform's open-file dialog. Win32 if you don't care about cross-platform. Tk, WxWidgets, Qt, GTK and others are common toolkits for cross-platform. I'd suggest [WxWidgets](http://www.wxwidgets.org/) for a decent toolkit. Second: **Oh my god do not use ActiveState**. ActiveState Perl is what you use when you want to pay for a support contract. A decent alternative for windows, and one that doesn't stink, is supported by the perl community, and _works_ is [Strawberry Perl](http://strawberryperl.com/).
AFAIK, Tk is included in ActivePerl - ppm GUI is based on it.
run `cpan Win32::FileOp`
The easiest solution would be to insulate the 32-bit stuff on a separate server and provide a RESTful API to that server. You'll incur a bit of overhead, but it'll be the quickest solution.
That would mean building a RESTful API, though, right?
DBI::Proxy, if you can stand the incompatibilities (of Storable) that implies.
A sensible suggestion! So, basically, set up a 32-bit virtual server and put Firebird along with 32-bit Perl in there?
Virtual or physical. Yes. But use the same distribution, or get all kinds of hell wrt. Storable compatibility.
That's what Catalyst::Action::REST is for. CGI::Application also has a RESTful plugin.
If you want to read them in learning order, look at http://perlgeek.de/en/article/5-to-6 instead (same content, different ordering)
Should have posted that...
Greetings, Here is a down and dirty way to read config files that works with ActiveState Perl. # Read config file to see which options are enabled. { local $/; # Slurp file open(MLB_TIME_OPTION,"$config"); while (&lt;MLB_TIME_OPTION&gt;){ $MTO=$_; #print "$MTO\n\n"; # Uncomment to print entire config to console #print "$_\n\n"; } if ( $MTO=~/^Tokyo/mg ) {$TO = Tokyo}; #print "$TO\n\n"; # Uncomment to print Tokyo option to console if ( $MTO=~ /^Time_First/mg ) {$TF = Time_First}; &lt;SNIP&gt; close MLB_TIME_OPTION; } I use the long hand version above instead of a module since it is so basic. Namtog
Thanks namtog1. I already installed and started using the Config-General though.
Haha. It looks like I'll have to switch to Strawberry. Thanks for the advice.
Nope, Tkx is included now. I think they made the change after 5.8.
You can even use the same machine, and install a 32bit perl and DBD::InterBase. BTW I found that the released version of DBD::InterBase sucks. However there is hope: http://github.com/pilcrow/perl-dbd-interbase contains new development, and the author of that github repo has asked for feedback. If you want to give something back, test the code on github, and report to the author.
Can you compile in 64-bit only Firebird's libraries?
No. The 1.5.6 makefiles seem to be broken in our fairly modern system. There *is* a makefile for AMD64, but, as far as I know, it was experimental even at the time of release. And I cannot find any instructions on how to build this thing. The standard autoconf/configure/make crap doesn't work. It seems that whatever autoconf looks at was meant for Win32.
&gt; MySQL is 64-bit already (and there's no point in "downgrading" to 32-bit) That's like saying that you need to run a 32 bit httpd server if the client ran a 32 bit browser. The MySQL client and server are separate programs that aren't linked together, they communicate over a (unix or TCP) socket. So if you build a 32 bit perl and link with the 32 bit libmysqlclient you don't have to touch the server at all, which can continue to run the 64 bit version.
Gah, not helping the "Perl is unreadable" argument much :-/ I'm hoping for some great examples of expressive, readable Perl 6 code that will have everyone declaring this is the language of the next decade.
I've been trying to teach myself Perl 6, and I don't think that this is unreadable. Once you understand how the series operator (...) works and what a pointy block looks like, the code is fairly straightforward. In fact, I think conciseness like this is one of the greatest strengths of Perl 6. The terse syntax is more indicative of intent, because the screen real estate is not taken up by hand-coded loops and things like that. You can look at a series like that and immediately see: ( first element(s), -&gt; { generator function } ... limit ) Whereas in another language it might involve two nested loops, a lot of conditionals, etc., and a lot of code ends up looking alike and indistinct.
This is expressive, readable Perl 6 code. The only sane standard for readability is readability *by people who are comfortable with the language*. No one sits around arguing whether Spanish or French is more readable to someone who speaks only English. (It's French, by the way, but Spanish is the more elegant language.)
I'd argue (but not vehemently) that readable code does always not rely on a good working knowledge of the language. Python list expressions for example are terse but generally can be made readable. This Perl 6 example is getting back to the "line noise" type of Perl and away from the more modern Perl (5) we're seeing these days. Think also of the rules that Perl Best Practices introduced and how much more clear they make code. Anyway, it's a small beef, and I reiterate my other point- some better examples are going to be needed if we want Perl 6 to move beyond just those of us who are Perl devotees. I so want Perl to be the next big language because I am so totally over Java/C# and their dominance. 
I think it's more like "it's not easy", rather than "it's unreadable". Coding both Perl 5 and Perl 6 I can say that once you learn the new syntax and idioms, you are amazed on how simple and neat everything is. That's my feeling at least. Moreover, I personally find the "lol unreadable" argument so silly it's not even worth fighting.
Poor, lonely Pythoners :(
At least the Django crowd get to [play with ponies](http://djangopony.com/).
Before you ask: my tests show that it's about 2-20 times faster than the last release.
You guys are awesome. (What happened to all the whiners declaring it'd only get slower with each release?)
Will there be a .msi for Windows released relatively soon?
As an aside, what happened to [rakudo.de](http://rakudo.de/)? It doesn't seem to be updating anymore.
Jnthn, how built the previous .msi, is currently on vacation; so if nobody else steps up, you'll have to wait for roughly two weeks :(
I accidentally deleted some files which take care of the updating; I thought I restored them from backup, but there might be something missing. I'll look into it.
Surely perlmonks aren't allowed to marry? 
Cute.
Sounds good. Thanks a lot for all your hard work. I'm really enjoying Rakudo Star.
Their heads exploded with the cognitive dissonance of believing that computer science dictated it's impossible for Rakudo to improve versus the actual statistics that it had.
&gt; I'd argue (but not vehemently) that readable code does always not rely on a good working knowledge of the language. Your assumption of readability depends on the audience who you intend to read the code. Sufficient domain knowledge may give sufficient hints to people with an insufficient knowledge of the language and its dominant idioms.
&gt; (I’ve used parentheses instead of do because that’s how I roll, but otherwise this is exactly the same idea as Masak’s solution. Kerching! The light just went on. I couldn't quite get my head around [masak's code](http://use.perl.org/~masak/journal/40516). It made sense on one level, but looked kinda weird on several others. But this. This is really sweet: &gt; my @Fibonacci := (0, 1, -&gt; $a, $b { $a + $b } ... *) If I understand it right, the `...` is the `upto` operator, so a list specified as: (0, 1, ... *) Is shorthand for: (0, 1, 2, 3, 4, ...etc...until the universe grows cold) And this bit: -&gt; $a, $b { $a + $b } is a generator which feeds on the 2 preceding items in the list and adds them to generate the next item. So `-&gt;` is what you might call the `into` operator (does it have proper name, I wonder, other than "arrow"?) So you put them together and you get a really nifty list generator. my @Fibonacci := (0, 1, -&gt; $a, $b { $a + $b } ... *) Or with english-like operator names (say, if you were reading it out loud), that would be something like: my @Fibonacci := (0, 1, into $a, $b gives $a + $b upto *) Nice. I'm not so scared of Perl 6 now. 
&gt;If I understand it right, the ... is the upto operator Its official name is "series" operators. Indeed, it works as you describe, as it recognize an arithmetic sequence in (0,1) and continues it, the Whatever * meaning "to infinity". It also recognizes geometric sequences :). &gt;So -&gt; is what you might call the into operator (does it have proper name, I wonder, other than "arrow"?) Actually -&gt; constructs a closure. `-&gt; $a,$b { $a + $b }` is the same as `sub ($a,$b) { $a + $b }`. Here, the series operator takes a list, a closure and an element; it applies the closure to the last element(s) (it knows how many to take thanks to introspection) of the list until it reaches the element (or forever, if it's *). Edit: I forgot, closures created with `-&gt;` are called 'pointy blocks'. I don't think the arrow itself has a special name.
Okay, so if I say this: &gt; my @squares := (1, 4, -&gt; $a, $b { $b * 2 - $a + 2 } ... *); 1; 1 &gt; say ~@squares[^30]; 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529 576 625 676 729 784 841 900 That's all well and good, but what would I have to do to say “up to 900” instead of saying “up to 30²”?
 &gt; my @squares := (1, 4, -&gt; $a, $b { $b * 2 - $a + 2 } ... 900); 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529 576 625 676 729 784 841 900
Sorry, I wasn't explicit enough. The thing I was trying to ask was that I'd want to take a sequence, maybe defined somewhere else and that I don't want to know the inner workings of, and grab values from it until a known value instead of having to know the input that produces that value in advance. Just pretend it's a list of MD5s or something.
I don't know how to do this one without a loop, but your squares generation example feels weird for me. How about this one: &gt; my @squares := gather { for (1..*) {take $_ * $_} }; 1; 1 &gt; @squares[^30] 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529 576 625 676 729 784 841 900
Oh, I see. I think gather is rather adapted: &gt; my @squares := gather { for (1..*) {take $_ * $_} }; 1; 1 &gt; gather for @squares { take $_; last if $_ == 900 } 1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529 576 625 676 729 784 841 
Thanks for the clarification. &gt; the Whatever * meaning "to infinity". Will Perl 6 will also recognise ∞? I recall Larry saying that Unicode operators were in (which is fine, as long as there are ASCII equivalents). It would be nice (I think, maybe) to be able to write: my @Fibonacci := (0, 1, -&gt; $a, $b { $a + $b } ... ∞) Or, to go the whole hog: my @Fibonacci ≔ (0, 1, → $a, $b { $a + $b } ⋯ ∞) &gt; Actually -&gt; constructs a closure. -&gt; $a,$b { $a + $b } Ah right. So it's the series operator taking a subroutine reference (aka closure, lambda expression) that makes the magic happen. But if it's a lambda expression then surely the arrow should come between the arguments and result? ($a, $b) -&gt; { $a + $b } Having `-&gt;` as a prefix operator seems Just Wrong™ to me. Everything about it screams "I'm an infix operator, dammit!". If it's an arrow then who the hell fired it? :-) Hmmm.... well ok, maybe I don't like the arrow/pointy blocks any more. But I suppose I can always spell it `sub` and pretend `-&gt;` never happened. my @Fibonacci := (0, 1, sub($a, $b) { $a + $b } ... ∞) In which case, I now can't see any point in pointy blocks at all. Why waste a perfectly good arrow operator just to save a character on typing `sub`? Oh, OK, I guess you can drop the parens too. But is that it, or is there some other reason that makes the arrow special? I can't help thinking that Perl 6 is a very *unintuitive* language. Sure, you have to learn the syntax, semantics and idiosyncrasies of any language before you can truly understand it. I'm not expecting to be able to read or write Perl 6 code just because I can write Perl 5. It's a new language based on Perl 5, and I'm cool with that. Progress is good. But... languages like Python and Ruby are generally easy to pick up because they're *intuitive* - they do the "obvious thing" that, more often than not, is the same way it's done in numerous other programming languages (or has a precedent in mathematics). Perl 6 seems to do everything different. In some cases, it makes sense because the new way is better - some degree of trail blazing here is definitely in order, even if it means upsetting the status quo. But in other cases, I can't see any justification for it other than, perhaps, "it's easier to parse this way". Now that I know that `-&gt;` is an alias for `sub`, I'll never forget it. But if the arrow had come between the arguments and block then it would have been obvious and I wouldn't have had to ask anybody at all. 
If you have no knowledge of the inner workings, you need to iterate through the returned list until you find what you're looking for (or give up).
The pointy blocks were originally designed to make `for` look better. Compare: for @list -&gt; $x { stuff($x) } for @list sub($x) { stuff($x) } What the arrow does in this case becomes visual and intuitive: "Take one element at a time from @list and do stuff with it". Of course, you can still use bare blocks with placeholders : for @list { stuff($^x) } It really depends on how you want the code to look. My impression about Perl 6 is that syntax is made specifically to be consistent. There are (almost) no special cases in the syntax, AFAIK. All the things that would be special cases in other languages, like the arrow in the `for` construct or the star, are actually general things, like a standard block or the object of type Whatever, that you can reuse for your own code. At least that's how I view things. (As for ∞ or ⋯, I don't know, maybe)
It doesn't get much simpler than this: map { m/^([\w.]+)\s*=\s*(\S*)$/ &amp;&amp; $conf-&gt;{$1} = $2 } &lt;FOO&gt; You config file will, of course, look something like this (unless I screwed up above): foo.bar = baz quux = 1 dont.set.me = Edit: You can, of course, come up with something more elaborate. I doubt it would be much trouble to implement some basic sanity checking on values at the time you read them. E.g., quux should be an integer, foo.bar can be any alphanumeric string, etc. Validating config at the time you parse it is probably a Good Idea because it saves you from having to validate every value every time you use it.
thanks
"Programming is hard, let's go scripting."
From the article: &gt; Most misconceptions seem to me to be merely the result of a deplorable lack of correct information, mixed with blindly cargo-culted mockery. Any guesses as to when we'll see perl6doc docs? For example, "perl6doc perlintro" and perlreftut, perlboot, perlretut, etc. Are these being worked on? Is Larry writing them? Is anything blocking them at the moment? Getting perl6docs is place would seem the next logical step for Rakudo Star. I can't see widespread adoption happening without good man/perldoc pages. 
Ever write a little command-line script which takes several arguments? Ever write any validation for the arguments? Consider that Perl 6 allows you to define your own `MAIN` function with a signature. If argument binding succeeds, all is good (no more messing with `Getopt::*`. If argument binding fails, your own `USAGE` function gets called. Add in a few hundred minor conveniences you may or may not use and you have reasons to consider exploring Perl 6.
Most of my scripts start with something like: my $var = shift; my $other_var = shift; I have looked into using the Getopt stuff, but haven't really _needed_ it since no one but me sees or uses my scripts. The MAIN and USAGE treatment is interesting. I will have to do some research there. Thanks.
You will not need to worry much about perl 6 until perl 5 is no longer available. Be prepared to spend many years waiting for that to happen. edit: spelling, thanks AmbroseChapel
Perl 5 isn't going anywhere. Think of Perl 5 vs. Perl 6 as more like C vs. C++. There may come a point when it seems like a good idea to switch, or you may reasonably conclude that C is the right tool in spite of the fact that C++ exists.
&gt; Think of Perl 5 vs. Perl 6 as more like C vs. C++. I've written useful code in each language and I'm not even sure what that means.
Perl 6 is a nearly completely different language than Perl 5. Write in what is useful to you. TMTOWTDI
Learn object oriented perl 5 now I would say. That's the most bang for the buck. Perl 6 wont replace Perl 5 until enterprise Linux like SuSe and Redhat and unix like AIX, Solaris and HPUX have it built in. I would not be suprised if might take a few years. It took forever for python after it was popular in the open source community to take off because of that same lag in enterprise acceptance and availability. In the enterprise space where most application developers are writing code you pretty much have to use what comes preinstalled. It's too much of a hassle to go through the hoops to get some custom opensource tool installed on every system. 
C++ didn't replace C. It grew out of it, but people still have very valid reasons to use both. C++ is like a new language that happens to share many similarities with C. The same is likely to be the case of Perl 5/6.
Notwithstanding the s/hears/years/ thing, I think this is all you need to know. Perl is absolutely everywhere, installed on billions of computers and doing billions of different things. A world without perl would be like that Simpsons educational filmstrip about A World Without Zinc. And by perl, we mean perl 5. The day when the average Linux distribution, for instance, includes perl 6 and *doesn't include perl 5* is many years away. Probably tens of years.
I would say just keep striving to be a better Perl programmer, regardless of version. For some reason, I'm finding the more I learn about good modern Perl 5, the easier it is to pick up Perl 6. I'm writing all my Perl 5 code with an eye on someday porting it all to Perl 6 so it's all time well spent in my mind.
For simple scripts, Perl6 will be like Perl5, only different, using ~~ instead of . for concatenation, if I remember correctly. The basic Perl-ish feel remains, the details are different. You'll try out Perl6 when it becomes more accessible, and when there are some tutorials, but you'll stick with Perl5 until some feature motivates you to change. For significant programs, Perl6 will be more robust and faster, because of things like real typed parameters, real object attributes and methods. The ability to borrow modules from Ruby or Python or other languages, assuming Parrot support for multiple languages works out, may lead to better and faster evolution for all languages, instead of concepts such as YAML needing to be re-implemented on each system. My hope is that the new features, like functional programming-ish elements, list reduction, junctions, and such will make it easier to think in new ways. While such operations could be achieved previously, the implementation got in the way. A "Design Pattern" is a human doing the implementation work ... once it becomes part of the language, it becomes trivial. Replacing the most powerful regexes in any language with an even more powerful, and simpler to use grammar system will simplify the process of creating application specific little languages. Associated with that the ability to modify the language itself means we won't need source-altering modules, instead we can customize the behaviour of the language.
&gt; I would not be suprised if might take a few years. Fedora packaged Rakudo before Python 3, as I recall.
C++ didn't fix the biggest flaws of C, which is (to me) the most difficult part of your analogy.
Perl 6 while cool and all isn't going to be usefull in the business world until its really released and supported by cpan. The current power of 5.10 is CPAN and the wealth of modules. Of course I'm looking at this from a full on business app programming perspective.. For just sys admin stuff, I would say its not a big deal, but there are some nice little bonuses of using 6.. again though, until its finalized, it may not be worth the effort.
&gt; its really released What does that mean? &gt; until its finalized What does "finalized" mean, and what do you expect differently from Perl 6 when that happens?
See for example http://perlgeek.de/en/article/5-to-6#post_14 for some documentation
No. Perl 6 is an entirely different language with the same roots as Perl 5. It is currently **far** too slow to be of any use for anything practical. Perl 6 has been in development for 10 years now. Expect it to take a few years more before it gets useful for anybody but Perl geeks. Even then, it'll still be an entirely different language than Perl as we know it now... An analogy: the difference between Perl 5 and Perl 6 is much larger than the difference between Java and C#. 
I agree. I had some free time recently and immersed myself in the P6 documentation for weeks, and hacked out a few tens of scripts for practice. But then I had to get back to production, which called for 5.12. I expected more typos etc. when I got back to production, but I found that my careful reading and experimentation in P6 actually *helped* my 5.12 work.
&gt; For simple scripts, Perl6 will be like Perl5, only different, using ~~ instead of . for concatenation, if I remember correctly. ~~ is smart match and ~ is string concatenation. Array reference is also different, @foo[$n] instead of $foo[$n].
&gt; It is currently far too slow to be of any use for anything practical. Anything is exaggeration, but slow and immature runtime implementation is main reason why I haven't used perl6 yet. I hope it changes soon, parrot seems to be developing.
I have hundreds of scripts/webapps written in perl5, I don't want to recode the 2 000 000 lines of code I have done in the last years...
This is why I love reddit. Thanks everyone. 
whilst descriptions of perl 6 as vapourware are unfair there is, as with all jokes like this, an nugget of truth in there. Go perl 5 for now but keep assessing the situation.
&gt; ... an nugget of truth in there. How so? Seems like existence is a binary condition, and there's been a `perl6` binary for a couple of years.
oh, so nice a pun; an upvote for your skill. :) 
Like what?
I'm wondering if it would be possible to represent in Perl 6 subroutine signatures complicated command line arguments like ffmpeg: ffmpeg [[infile options][`-i' infile]]... {[outfile options] outfile}... Where options are associated to the next input or output file.
Once there are more high-quality Perl 6 tutorials out there I think your question will be easier to answer. At the moment, there's lots of handwaving tutorials ("look at how great this new feature is!"), and examples ("here's the Perl 6 equivalent for that"), but no concise nuts-and-bolts intro material for learning Perl 6. So, my advice is to wait for really good beginner/intro documentation and *then* take a good look at Perl 6 and decide if you want to migrate. Another option to consider is Python 3 ([tutorial here](http://docs.python.org/py3k/tutorial/)), which won't give you as many conveniences as Perl 5|6, but is very easy to get started with. 
I don't think you'll need to. Pretty sure the plan for Perl 6 is to be able to run Perl 5 code (from your Perl 6 program) using some kind of bridge to an external Perl 5 installation. I don't think sixers have any intention of trying to convince anyone to port Perl 5 code to Perl 6. This is in contrast to the Python plan, btw, which is to gradually encourage folks to eventually port their code over from Python 2.x to 3.x (with the help of the 2to3 utility). 
Hey. Yours is a very good question. And I agree with your sentiment as well, that docs would be a great boost at this point. To the extent that the lack of docs so far is my fault, I apologize. I had this idea early on for [how to structure the docs](http://svn.pugscode.org/pugs/docs/u4x/README) and how they'd look, and later requests for documentation have tended to be merged in with that project... it's just that the documentation project hasn't taken off yet. It's blocking on time and motivation, mostly. Writing all that documentation is a big undertaking. With a bit of luck this project, or some project very much like it, will get going soon. And we'll see better and more reliable documentation. Until then, the hands-down best source of information about all things Perl 6 is the IRC channel: #perl6 at irc.freenode.org. Also, though they're not a substitute for perldoc, there's plenty of good, coherent information over at [Perl 6 Advent Calendar](http://perl6advent.wordpress.com/2009/12/01/perl-6-advent-calendar/) and [Perl 5 to 6](http://perlgeek.de/en/article/5-to-6).
*I don't think the arrow itself has a special name.* For hysterical raisins, sometimes some of us call it "lambda".
In signatures themselves you could represent something like this in nested signatures, but there's no obvious way to turn a command line into a tree that the nested signatures can match against. So you can't do that with MAIN subs now. Which is unfortunate, but OK. They are meant to handle the 80% use cases that occur most often, and for the other 20% you can still write a proper parser that uses @*ARGS directly, or write a module for that.
Hi. The link to the u4x readme is broken. I think the pugs repo may have moved. The link is also broken on perl6.org. I did find this though: http://nix.is/gsoc/gsoc-u4x.html Regarding structuring the docs, given the success of the Perl 5 docs, I'd suggest that straying from what Perl 5 has now (a bunch of simple separate man/perldoc pages) would require pretty substantial justification. As an aside, the name "grok" seems a bit overused of late and even might sound corny to many (there's a Python zope-based web framework named "grok"). You might instead consider "perl6doc", "6doc", "pldoc", or possibly something ultra-perlish like "elucidate". 
Indeed, there was a repository move this very weekend. [Here](http://github.com/perl6/mu/raw/master/docs/u4x/README) is a new, working link. I agree that we'd want more or less what Perl 5 has now. I think that the idea behind 'grok' has merit, though. I'm not too tied to any particular name.
Anyone maintaining/releasing Perl modules should have a look at http://dzil.org/ . It takes care of all the crappy stuff you hate doing, and remembers all the "community best practices" for you.
Thanks for the suggestion on Dist::Zilla. I'll be sure to update the blog post with the recommendation (I'll also take a look at it myself for possible future use).
There should be Programmin Perl 4E, IMHO. A lot of stuff have changed in the last 10 years or so. People are publishing new editions of their books for less stuff. It would be cool if Programming Perl (or its subset) is in public domain and wiki-editable. This book is fun to read whether one likes Perl or not. 
&gt; There should be Programmin Perl 4E, IMHO. You're not going to see printed Perl 5 books from that publisher.
What would it take to have them start placing Perl 5 books into a creative commons attribution license like [some other titles](http://oreilly.com/openbook/)?
That's a good question. I support doing so with the books I've written.
On the topic of perl IDEs from the comments, Eclipse has the [EPIC](http://www.epic-ide.org/) module. Supports realtime error checking, syntax highlighting, indentation enforcement (if you like that sort of thing). It's pretty well made. I recommend it for anyone looking for a decent perl IDE.
That's sad. There should be another book of Larry Wall's witicisms even if it's a reprint with additional "What's new in Perl" chapter only.
Why is that?
chromatic said "printed Perl **5** books", not Perl 6. The perl6.org documentation page suggests that there might be 2 forthcoming Perl 6 books from said publisher. 
They think there's no market for Perl 5 books, because they're not selling very many Perl 5 books. (How many copies of a decade old Programming Perl 3E can you sell, considering that it describes a 5.6 release which never actually existed and that there have been 17 stable releases of Perl 5.x in the intervening period?)
A language can have malleable syntax in at least these 2 ways that I'm able to see: 1. offer that malleability in the language itself -- that is, having it as a language feature available to the app programmer, or 2. simply to have the developers of the language recognize when they need to change the syntax and then change it come the next major release. So the question then becomes: is the first way more valuable than the 2nd? The first way would certainly lead to more new ideas out in the wild, and more customized syntax for your own problem at-hand, but wouldn't it also lead to frustration like, "everyone's $malleable-language code looks different from everyone else's?!". 
I work with HL7 data. I hate hate hate hate it.
First, check for a CPAN module to parse this format. How about this one: http://search.cpan.org/~ddokter/Net-HL7-0.72/lib/Net/HL7.pm If there hadn't been, I'd ask over at: http://perlmonks.org (Had there been no CPAN module(s), it's just a matter of iterating over all the lines while detecting when a new record is beginning -- at least that's what I've often done on similar data when there's no CPAN module.)
While I'm not familiar with HL7, have you checked out the [cpan module](http://search.cpan.org/~ddokter/Net-HL7-0.72/lib/Net/HL7.pm)?
Sorry to post it chromatic, I'll donate any and all upboats to you :P TBH, I couldn't agree more. I've never understood why distros use the system perl/python/whatever for their tools. It makes alot more sense to have an alternate install elsewhere for that... leaving the system one for users to abuse to their hearts contents
I liked CentOS when I initially used it 4 years ago. However, the system was quite fresh then. However, as I got into Perl and started writing my own CMS (over PHP), it very quickly outstayed it's welcome. Granted, I never really understood RPM so I went so far as building a simple package manager to handle the problem. The host I had used I got for a good price for what I needed so I hated to change. When they decided to up the price, the choice was quite obvious. Through my experience, I became quite jaded by the stable distros. They seem to offer more issues than they solved. Granted, I'm not running a million dollar production server so my needs have been covered by bleeding edge systems like Arch. I also know Arch like the back of my hand so that helps a bit, but I don't have to worry about what features I want to impliment. And frankly, stable versions are usually pretty good but I can roll back if I need to. Although, I do have to limbo a bit. On a recent setup Debian stable just didn't work and in a quick bid to get it working, Debian testing blew up in my face. Too much automation made my fixes worse. Edit: Sorry, it's late and I've seemed to go off track. Accedentally posted this before I was finished and lost my train of thought. If I get it back, I'll add a reply. Although it's probably just a mindless rant at this point. Again, sorry. :)
In the event the CPAN module doesn't work out for you and the specification allows you to clearly know when a message starts/ends (I took a quick look at the Wikipedia page, but not in depth), you could try writing a finite state machine to parse the file. I did this using the D Programming Language for CSV files and it works very nicely. Of course, this is assuming the format is relatively sane. I didn't look in depth, so I may be wrong.
From a very quick look, it seems that the every message has to start with the MSH line? So, surely the approach is to say, when you hit a line beginning with MSH, you have finished the previous one? If it's not the first, of course.
Warning: PDF
Interesting.
Nah. And judging by the amount of time we've been waiting on Perl 6, I'd say it would be more like a 48-day programming contest. /rimshot
Well, I'm so glad they made the parser all "clean", and broke over 10 years worth of legacy code for me in the process. I'm sorry guys, IMO, this is a dick move.
What the fu... *sees examples of deprecated code* ...oh, never mind. This sounds about as bad as PHP deprecating `register_globals`.
&gt; ... and broke over 10 years worth of legacy code for me in the process. You really used that syntax? Fortunately, there are dozens of versions of Perl 5 you can use until 5.16 comes out.
&gt; ... judging by the amount of time we've been waiting Well volunteered!
As is often the case, the headline makes it sound worse than it really is. Personally, I have never witnessed the usage they are deprecating. A commenter on the original FA sums it up nicely: &gt; Used to work, is being deprecated: &gt; &gt; for my $a qw( 1 2 ) { print $a } &gt; &gt; Has never worked: &gt; &gt; for qw( 1 2 ) { print } &gt; &gt; Will explicitly continue to be supported: &gt; &gt; my @arr = qw( 1 2 ); &gt; &gt; Practically nothing except the first example is changing. 
you can use perl in the google ai competition you'll lose, but it will still be fun
I posted this before reading the comments all the way down. Having done that I see that the only syntax where (qw&lt;&gt;) is newly required is: for qw&lt; x y z &gt; {...} Had I seen that far down I doubt I'd have bothered posting this here.
Rather, that's the idiom that has never worked. The deprecated bit is: for my $a qw(foo bar) { ... } I actually use this quite a lot (mostly in tests, etc., where I'm iterating over known values) because it's quick and easy to write. Kind of a shame it's being deprecated, really... it's so very convenient.
Ah, I see. I DO like the way that in Perl6 there is no need for brackets in a "for" condition at all. It's one of the odd things about Perl5 that it forces brackets in situations where they seem unnecessary.
The title is nonsense. It's not "*qw() in list context*", but "*qw() around the loop list in a `foreach`/`for` loop*". The basic documented syntax is: foreach (LIST) { CODE } foreach my $loopvar (LIST) { CODE } The deprecated syntax was just the abuse of the idea that `qw(foo bar)` was (originally) basically just a macro that got expanded to `('foo','bar')`. Thus the parens were still there in the end, after macro expansion. So from now the parens will have to be in the source *before* the macros expansion. Good. List context has nothing to do with it. 
Agreed. It's the C legacy rearing its ugly head. Since the loop body in Perl is *always* a block, and not just a statement as in C, the parens are actually superfluous.
It's not superfluous. Without parentheses you can't really know if the opening braces start the block or are part of the expression. Perl 6 gets away with it by requiring a space before the opening brace that starts the block.
They didn't break it. It's deprecated, so they might break it in the future. For now, all they do is give a warning where it will break when the time comes. And like chromatic said: are you really sure you have this issue? It is a quite obscure and uncommon, not to mention easy to fix.
Relax, 5.14 won't be coming out tomorrow, and you probably won't upgrade to it immediately even if it did. The non-backwards compatible changes in 5.10 were more significant than this. Lots of places are still on 5.8.8 even!
It was a fucking joke.
I use qw() in a list context for a lot of use statements. For example: use Date::Calc qw(Gmtime Day_of_Week_to_Text Month_to_Text); And "easy", I really don't know what you are talking about. Changing the code requires a whole QA cycle, which is definitely not easy. I don't have a problem with completely redesigning the language like from Perl 5 to Perl 6, but really, shit like this should not get deliberately broken on a point release. Legacy support should be the primary consideration, not "let's fix a broken parser". That's bullshit. As a result of this trend, I really don't feel secure going forward to continue using Perl. What I now know for a fact is that the developers care far more about being academically "correct" than they do about my code retaining correct functionality.
&gt; I use qw() in a list context for a lot of use statements. That use of `qw()` has not changed. The headline is nonsense.
I've been succesfuly using the Net-HL7 module in production environments. I like it because it parses the messages, but really does nothing more than that. You can then provide your own handlers for any type of message / segment / ... So it's actually some kind of pimped SAX, but then for HL7. You still have to solve the usual HL7 crappiness yourself though. But no module can do that for you. HL7 sucks because, from looking at a message, you can't tell if a segment is a child of the previous one, or an entirely new segment. Each line contains exactly one segment. If you want the structure of the message, you have to look it up in the HL7 definition (which is hard to get to) and hardcode the possible combinations separately for each possible message (and there's lots of them) I hope that the HL7v3 (which will be using XML syntax) fixes that and is quickly adopted by many hospitals and healthcare IT firms.
Thanks for that tidbit of information. Unfortunately, it does nothing to stop the practice of the Perl "gods" capriciously changing the language definition. I don't want to wade through 200k lines of code every time they make a release.
&gt; I don't want to wade through 200k lines of code every time they make a release. Can you give an example of this capriciousness? It took *years* to remove the broken `Switch` module, for example.
Meh, too many obligations and too unlikely to win. I prefer the method to [get a free Pro Git eBook](http://progit.org/book), which comes in handy with the [paperback version](http://amzn.to/aMehSe). (still upvoted you though)
This seems like a Win a free iPad 1TB ad if you punch the monkey. You have to comment their post, and if they like what you suggest, you might win a free ebook. I really thought there was a free download link.
Are you kidding me? This article and [this](http://www.reddit.com/r/perl/comments/dcysr/qw_in_list_context_deprecated/c0zctlh) are but a couple of examples.
What's your definition of "capricious" then? Do you have *any* code which falls afoul of the change to require parentheses around iterations over `qw()`?
I go with Oxford's, myself: http://dictionary.reference.com/browse/capricious And you're completely missing the point. The point is I cannot rely on Perl devs NOT to make a conscious decision to fuck something up for users on a point release. I've been a Perl and mod_perl developer for about 8-9 years, and this behavior is new. They didn't used to just go saying "oh, I'll change this because I think it's better".
&gt; And you're completely missing the point. You're evading the question. Does this affect you? (Another fun question is "Do you know what a point release is?", but that's just snippy of me to ask.) * Was deprecating pseudo-state capricious? * Was deprecating and removing Perl 5 threads capricious? * Was deprecating and removing Switch.pm capricious? * Was deprecating and removing the bytecode compiler capricious? * Was deprecating the Perl 4 compatibility libraries capricious? * Was deprecating and removing pseudo-hashes capricious? Given the amount of blood, sweat, tears, and toil it takes even to make the argument on p5p for deprecating something (let alone *removing* a deprecated feature), it's laughable nonsense and borderline libel to argue that p5p is full of power-mad developers who cackle into their straggly beards as, from deep in their dank basements, they plot how to abuse millions of hapless Perl 5 users who may have never even known that you could leave off parentheses in a syntactic construct few people have ever, ever used. The absolute *horror* of you adding parentheses to code you likely have never written. My goodness, man. The universe is a cold, angry place today because of something deployed in a development version of Perl 5. Life cannot go on. ... or you could test the monthly bleadperl release against code you care about and report back to p5p that you'll have to rewrite billions of lines of code if you upgrade to Perl 5.16 in 2012, and could they possibly reconsider? You know, because the entire point of developing software in the open, warts and all, and releasing monthly versions is to get exactly that kind of feedback. *edit* I couldn't find any documentation of the removed `qw()` syntax, so I have even less sympathy over the complaint of deprecating an undocumented feature.
I'm not evading the question, you're not reading. It does effect me, as stated earlier: &gt; As a result of this trend, I really don't feel secure going forward to continue using Perl. &gt; I don't want to wade through 200k lines of code every time they make a release. &gt; I cannot rely on Perl devs NOT to make a conscious decision to fuck something up for users on a point release That's how it effects me. Do you understand now? 
&gt; Do you understand now? I really don't, but I don't use this feature, I don't mind deprecation and removal of undocumented features, and I read perldelta documents and test the code I care about against monthly snapshots to see if anything has changed for me, inadvertently or not. I'm a cold-hearted unfeeling jerk when it comes to software.
&gt;I don't want to wade through 200k lines of code every time they make a release. Has this really ever happened to you before? If so, which deprecation was it? It seems to me it's pretty rare someone will find themselves in the following situation: * They have code that uses a deprecated feature (which in itself, is pretty rare, as it's usually only undocumented or obscure functionality that's deprecated) * They have to upgrade to the very latest version of Perl (or at least a version where this feature is removed (note, not just deprecated)) * They don't have enough time between the announcement of the deprecation and the removal of the feature to fix their code, i.e. years (but note, they do have time to upgrade their Perl version). Unless you fit into *all* of those categories, any removal of a feature will not affect you. There's plenty of legacy code out there that might make use of deprecated features, but it's also running on a legacy Perl, which doesn't need to be upgraded. There is a very small number of people who will be affected by these deprecations. In some cases it may actually be 0. But even if it's not, there's a trade-off to be made. Do we weigh the needs of an indeterminate (but very small, as they have to meet all the points above) group against the rest of the Perl community? Of course not. The reality is, you're making both the deprecation itself and the number of people who will truly be affected by it seem a lot bigger than they really are. They're not big, and the Perl gods wouldn't be doing this if they were. End of story.
I don't think it's about the *likelihood* that fargyfump will ever have to port code forward to work around a removed feature; I think fargyfump is afraid of the *possibility* of having to do so. If this were about risk management, fargyfump would be able to analyze the likelihood of any risk here.
Related, also nice: http://www.catalystframework.org/calendar/2009/8 
&gt; But it doesn't seem to working. Please clarify what is not working about it. Is anything being printed to the file? Is it not in the correct format? Is the original file not opening? More info please.
Sorry about that. It won't print to the OUT file. The first file opens fine, and when I just print to STDOUT instead of the OUT file everything is as it should be. edit: which just made me realize I could just redirect the output of the script to my file?
It's probably best that you open or close output.dat within the while loop. Also, it looks like you want to print a variation of $line to the file, not whatever.
&gt; which just made me realize I could just redirect the output of the script to my file? You could do this or... `open OUT, "&gt;&gt;output.dat"" or die $!` This will give you an idea why the file cannot be opened. 
&gt; It's probably best that you open or close output.dat within the while loop. Are you missing the word *not* in there somewhere?
You're not checking for errors. If you're using Perl 5.10.1 or newer, you have the [autodie](http://search.cpan.org/perldoc?autodie) pragma installed, so you can write: use strict; use warnings; use autodie; open my $accounts, '&lt;', 'whatever.dat'; open my $out, '&gt;&gt;', 'output.dat'; while (my $line = &lt;$accounts&gt;) { # do something to $line print { $out } $line; } If you're not using 5.10.1 or 5.12.x, you can install `autodie` through the CPAN (though you should consider upgrading to a newer Perl 5 if possible).
My guess is that Parrot doesn't need a JIT or threading to be a success -- but rather that it probably just needs to be (*edit: and fwict already for the most part is*) sturdy, modern, and easy for language implementors to use. One thing though: the Parrot dev wiki [languages page](http://trac.parrot.org/parrot/wiki/Languages) indicates that languages can be implemented in PIR, NQP, Perl, Perl6Grammar, and NQP-rx (along with C and C++). My hunch is that people get the impression that to use Parrot they will likely end up doing so using a Perl-like language -- and they may not like this idea at all. 
I hadn't thought of that second point. Certainly NQP-rx is the most popular implementation strategy, but I do wonder if its Perl 6 roots are offputting to some.
Maybe I'm missing something, and I would certainly and respectfully defer to an explanation on your part... but wasn't the question about whether Parrot, and not Perl5, is mature as a platform? I mean, I see your point but don't think it's valid- it's not like Parrot was just a natural progression from Perl5 and therefore inherits all of it's maturity "out of the box". Or maybe it was and I'm just missing that. Perhaps I'm missing something.
Doh!
&gt; ... wasn't the question about whether Parrot, and not Perl5, is mature as a platform? If the presence of a JIT and a reliable threading implementation are the main criteria by which you judge Parrot "mature", how do you judge Perl 5?
Ack! Unless you're working on a perl from the early 90s, please, please, **please** do not use the `OUT`-style file handles. Modern version allow you to use proper scoping: open my $handle ... Also, secondly, **never** use the two-arg version of open. **Always** use the three-arg. open my $handle, "&gt;&gt;", "output.dat"; And finally, check for success. open my $handle, "&gt;&gt;", "output.dat" or die $!; (You can omit the `or die $!` if you're already `use`ing `autodie`. You can use `$handle` (or whatever you pick) in place of your ugly filehandle syntax and not have globals tromping about your code.
This thread has just proven to me how ill-suited threaded forums are to answering programming questions. 
You don't need that while loop... you can just: print $out &lt;$accounts&gt;; But, you may object, what about that comment, "# do something to $line". Well, that's what map is for: print $out map { "This is it: $_" } &lt;$accounts&gt;;
Some of those preferences sound like they come more from convention then any practical design imperatives. Am I correct?
No, you are most definitely not. There are some severe issues with using old style filehandles, the least of them not being that they are package global. Handling them correctly is non-trivial. Using lexical handles eliminates that whole category of bugs, and as a bonus they close themselves upon destruction. Using two argument open easily leads to strange bugs, specially if the filename is not a constant. Not in the last place it leads to security issues (try opening file 'rm -rf / |' if you're wondering what I'm talking about). You don't want this much magic when dealing with files. Checking for errors is common sense. You absolutely want to know what's going wrong when something is going wrong. I hope I don't have to explain that!
That all depends on the size of the accounts file. If it is large your method may prove to be a lot less (memory) efficient than chromatic's method.
I think that for Parrot to achieve the next level of success communities need to form around the Parrot-hosted language projects. And I bet that shouldn't be too difficult to make happen because I think there are developers out there who would actually like to contribute to working on a pet language implementation, but who also aren't really looking forward to the idea of writing page after page of C code (and who maybe have not considered Parrot because they don't really like Perl 5 and think they'd be implementing their language in a Perl-alike). So, it seems to me that what would really help is some blog posts showing off the modern and easy ways to use Parrot for implementing $pet-language. I think the reactions you'll get will not be "eww, looks like Perl!" but rather, "oh, that's a lot easier than C", and "hey, that's not as bad as I thought. I could get going in a weekend". 
Is this site down for anyone else?
That's a good idea. Patrick and I have talked about improving the documentation for the Parrot Compiler Toolkit, so we could work on something along those lines.
Working for me as of 10:47 PST. Try again.
injecting a shell command in an open clause will fork and execute? really? That's monstrous. How could this possibly be a good idea outside of some perverted notions of convenience?
The issue with the two-arg version is that perl will try to parse your filename and figure out how you want to open it (r, rw, pipes, etc.). In almost all cases, it gets it right, but if it doesn't, it's very, very wrong. For such reasons, explicitly telling perl what you want and then the filename to operate on is simply common sense. And yes, it _is_ convenient. Especially if you're doing something "quick". Perl doesn't enforce security on you, that's your job as a coder to not be retarded. 
Threading is a big fucking deal. It's why I use Qore (http://www.qore.org) for threaded scripting, when in the past I might have turned to Perl. Perl still beats the pants off of it in expressiveness and pleasure, but as I said before, threading is a big fucking deal.
Well sure. But I would imagine that there is a defined set of operations and that it tokenizes the directive and then runs an interpreter over the tokenized representation --- not that it falls back on executing raw shell commands if it gets confused. Maybe I just don't understand the perl mentality. 
The easiest way is to provide a demonstration. Is `foo|` a file that exists in the filesystem, or are you instructing perl to execute `foo` for reading? Also, solve this for all possible cases. Double-plus points if there is a file named `foo|` and an executable `foo`. The point of the three-arg open is to eliminate the ambiguity. That the two-arg exists is left as a way to not break older code and for the very, very rare cases when its needed. I've been at this maybe 15 years? So far, I've not needed it. Honestly, for a more comprehensive review, try reading the [perlopentut](http://perldoc.perl.org/perlopentut.html) perldoc. The relevant quote, and addressing your comment about the perl mentality: &gt; Why is this here? Someone has to cater to the hysterical porpoises. It's something that's been in Perl since the very beginning, if not before
Note that [ideone.com](http://ideone.com/) includes Perl 6 on its list of languages also. [Keen!](http://ideone.com/jZKsF)
&gt; I would imagine that there is a defined set of operations and that it tokenizes the directive and then runs an interpreter over the tokenized representation.... It does. Now imagine that part of the filename came from untrusted user input. Certainly you want to use tainting, and certainly you want to verify that user input contains only what you want it to contain, but security is all about layers. If there's no possible way that untoward characters in the filename could cause any shell execution because you've separated the file mode and operations from the file name, you're more secure.
Slashdotted?
You're probably invoking the script with "perl foo.pl". Try either using "/usr/local/bin/perl foo.pl" or setting the executable bit (chmod +x foo.pl) and then just invoking "foo.pl".
You may want to look at [Perlbrew](http://search.cpan.org/~gugod/App-perlbrew-0.10/)
That worked. Thank you very much. 
Wow... that's a really helpful module. Thanks!
Another alternative is to make the hashbang #!/usr/bin/env perl That will mean that whichever version of perl comes first in the PATH is used when you invoke a script directly (i.e. as ./script.pl) which means you can switch defaults by just manipulating PATH in your startup files, which is how perlbrew handles it. It's also handy if you're sharing your script with others or across different machines because it doesn't hardcode any paths that need changing into the script.
This is a fairly awesome profiler fwiw. I haven't had the chance to get too crazy with it just yet, but so far I've enjoyed it. Clean interface, simple and intuitive (the HTML output that is). It's worth tinkering with for sure. :)
It is indeed pretty awesome, saved me from a couple headaches already :) 
If JSON::XS supports what you need, it's by far the fastest and the output is pretty readable (and can be made more so by setting some flags). If you need to serialize code refs or objects and don't care about human readability or portability, Storable is where it's at. I don't think YAML supports much that JSON does not, so it seems kind of pointless to recommend any version of it (I've only used YAML and YAML::Syck, which was recommended over YAML::XS when I looked into them, so I'm confused why it's reversed now).
&gt; Storable is where it's at. Storable was my serializer of choice until recently. It turns out that the serialized data isn't portable across different architectures (32/64 bit). I'm using it to serialise session data into a database field. I frequently dump the database on the production machine and import it into various other development machines. Unless I remember to nuke the session table first (which fortunately, isn't a problem) it throws an error about incompatible binary data. I haven't investigated the matter in depth, so it's possible that the problem lies somewhere else in my data chain. But JSON doesn't have this problem, and has the added benefit of being human-readable. So from now on, I reach for JSON::XS or YAML::Syck. You've done a great job, Storable, but I think this is where we part company.
Right, I said if portability isn't a concern. It's a terrible format to store in a database (it's binary, for one, and BLOBs are a bad concession database designers made to people who want to use databases for something they shouldn't). It was never designed for what you're using it for. You can create Storable data to be more architecture-agnostic using 'nstore' instead of 'store', but you still can't import data exported from a newer version of Storable on to a machine with an older version of Storable (probably the incompatible data thing you mentioned). It's useful because it'll serialize subroutine references, objects, whatever you want, and it's pretty fast. Beyond that, you should never use it for other purposes.
Use the `nstore` variants instead of the `store` variants and you'll avoid the incompatibility. Integers that don't fit in 32 bits will be unconditionally encoded as doubles, losing precision, but JSON does exactly the same thing unless you tweak it -- and if you work on 32-bit and 64-bit systems that's likely not a problem for you anyway.
&gt; it's binary, for one Sorry, I wasn't clear. I was using Storable to serialise the data, *then* base64 to encode it as text. If memory serves (this is going back a few years now), I had switched from a filesystem-based session store (where Storable made a good deal of sense) to a database store and didn't stop to properly re-evaluate the sersialisation mechanism. At the time YAML::Syck didn't exist and JSON hadn't begun its quest for World domination. So in my defence, the alternatives were limited. But one way or another, it was a bad decision that I later came to regret. Thanks for the tip on 'nstore' (you too, hobbified), but I'm a lot happier working with JSON/YAML these days. The ability to read serialised data from the database console is invaluable, if nothing else.
One of the most irritating parts about managing different perl installs for linux/unix side stuff is what to put in the shebang line of your scripts. I use #!/usr/bin/env perl Which does a path search. Now you can manage which perl gets called using careful path control.
Well damn, I was rooting for Squirrel.
It wasn't Badenov.
Read reddit much? http://www.reddit.com/r/perl/comments/dezgx/installing_multiple_perls_with_appperlbrew_and/ =)
 $ mkdir -p ~/base/perl $ wget $latest_perl $ tar xvaf $latest perl $ cd $latest_perl $ ./Configure.pl -des -Dprefix=$HOME/base/perl $ make $ make test $ make install $ echo 'alias useperl=\'export PATH="$HOME/base/perl/bin:$PATH"\'' &gt;&gt; ~/.bashrc $ source ~/.bashrc $ useperl # now youre in $latest_perl env $ cpan # this is $latest_perl cpan, make sure to use a different CPAN_DIR if you use system cpan too For the shebang, I use: #!/usr/bin/env perl
Random thoughts as I read through it. Eh... what? Assigning to $0 works in perl 5.8.8 on CentOS. We do that in our fcgi process manager here. Not a new feature. Non-destructive substition is awesome. What, that's it? There has to be more than 4 new things and some minor performance boosts. 
Did you want the short list or the long list? For starters: * Perl can only be parsed by perl * Because of that, adding new keywords is nearly impossible, adding new syntax is impossible, and removing anything at all is unthinkable * The object system was bolted through the language, meaning that it's too easy to do certain things * The tie interface is horrific, making it nearly unusable, even though it's the right solution for many problems * The overload interface is mostly horrific, but still unworkable * The various reference types are not handled properly in all cases by the language I can go on and on, if you'd like.
Please refer to http://perl6.org/ as the official Perl 6 resource; the one you linked to is mostly outdated. So, to come back on topic, things that aren't so great in Perl 5 (note that some of them aren't great in other languages too) * not so easy to extend. The fact that the basic data types aren't objects, but nearly all extensions are objects makes many extensions feel very unnatural. * not so easy to extend. Many built-in functions are parsed in a way that's not available to pure perl modules, sometimes not even to XS modules (I think); so it's impossible to override them with something that can be used in the same way, but behaves a bit differently (like, dying on error) * too many globals. Read `perldoc perlvar`; nearly all of these variables are globals, which makes it hard to write robust modules (who remembers to check the value of $" before doing string interpolation?), and hard to add efficient, not-sucking threads * Some builtins really don't behave intuitively. Try `print reverse("foo")`. * Since the object system is slapped on, method calls require two characters, instead of just one (which all modern OO languages get right) * the non-distinction between functions and methods makes it hard to get introspection right, and means that your object suddenly has a `ceil` method if you do `use POSIX qw(ceil)`. * [magic ARGV considered harmful](http://perlgeek.de/blog-en/perl-tips/magic-argv.writeback) (IMHO this is a true WTF) * the dereferencing syntax is just ugly, and hard to remember the corner cases you don't use so often (what's the syntax for getting the last index of a an array reference? I can never remember). * The sigil variance (ie @array vs $array[0]) confuses many newcomers * The regex syntax isn't very extensible; later additions like non-capturing groups have cumbersome syntax, even though they are useful and often used * The string vs. byte distinction doesn't really exist, which makes it hard to write larger applications that don't suffer from encoding problems. * There are some cases of ambiguous syntax that are really hard to interpret correctly (for example \10 in regexes can be a backreference to the 10th parenthesis group, or the octal escape sequence for character U+0008) * Hash iterators are tied to a hash, so iterating simultaneously over the same hash at two locations in the source code leads to magic action-at-a-distance * XS is a pain to write, and necessary for interfacing with C libraries * the `/s` and `/m` regex modifiers are very confusing for newcomers, and sometimes even for seasoned Perl warriors. I know a place where Larry mixed them up. * It's unduly hard to get all match values from quantified captures in regexes. There are modules that fix some of these problems, other are harder or even impossible to fix. That said, I still like Perl 5, and use it a lot. (I have updated this list a few times and added some bullet points)
I have no idea what this means: @foo{@what} ~~ @bar
Smart matching. Came in in 5.10
If you need to write an Apache httpd module and you like Perl 5, it's the right way to go. If you want a persistent Perl application, use something compatible with Plack and choose one of the backends it supports instead.
The change in $0 is subtle. When using 5.12 and below some utilities will show it right, some don't. See [Sys::Prctl](http://search.cpan.org/perldoc?Sys::Prctl) for a description of what's wrong with the old behavior. I'm not sure what exactly you expect or want from the perl core if you're thinking *"that's it?"*. A lot more happened in the past 6 months, but most of that isn't particularly relevant to most end users. It shouldn't be. The Perl 5 way is a continuous flow of small improvement. If you want a revolution, you might want to join Perl 6.
If it's an actual app (and you're not using Perl to control Apache directly), then pick something else.
I had an mod_perl app that had been surviving for 10 years. I tried porting it to v2 and midway realized I would be better off using fastcgi and lighttpd. I've been using these for the last 2 years now and am much happier. Being tied to apache is not a good thing anymore. 
This is the case for me; and I'm trying to find out what the "what else" might be. Someone suggested Plack, which I had a look at and I like because it enables me to quickly change out the backend server. If you have any experience with other alternatives, I'd be most grateful if you shared.
As a result of your post, I checked out Plack and it seems like a fairly straightforward port, and I do like the flexibility of backends. One could, in a pinch, theorhetically thwart an attack simply by swapping the backend. Thanks for the tip, this is exactly the kind of suggestion I was looking for.
Why change _languages_ just because you don't like mod_perl?
You could also just go for CGI::Fast. It supports listening on a Unix domain socket (with an admittedly wonky %ENV variable) which is what both lighttpd and nginx use. In apache you can use mod_fastcgi or mod_fcgid which launches your fastcgi server for you. CGI::Fast might be a better option if you were starting from an old CGI script. As others have suggested, Plack is a decent choice and may be better if you are coming from mod_perl. As an aside, if the only thing you run on the web server is your app, I'd recommend also looking into one of the newfangled web servers like nginx. The configuration is *so* much more pleasant than apache, especially if there is anything complicated going on (mod_rewrite can die a slow painful death).
mod_perl2 has been good to me, I have a lot of experience with it. The code is robust and complete enough it doesn't need a lot of updates. On the downside, it is a real heavyweight solution, it needs a server with 8GB+ RAM and caching proxy in front of it to do anything serious. 
without a doubt you are probably better off with plack with plack, you get to choose a variety of servers and frameworks if you really want to front a non-perl server like nginx, just proxy to a perl server like starman running on a high port personally i like dancer as a framework and starman as a server cgi, fastcgi, and mod_perl are no longer options i will consider
Do you use Starman in a production environment? I'm just asking because it seems pretty bleeding edge with the first version on github being from Feb. of this year. If so, what kind of traffic are you moving with it? And thanks.
*It seems maybe the same applies to mod_perl 2...is it going to get patched?* Absolutely, modperl2 is still very well maintained and supported. If you already have an application in modperl1 that you can port to modperl2, you are probably best off going that route. Plack is cool, but still pretty new, and you'll need to rewrite parts of your existing application.
Why do you need that much RAM? Are you caching large datasets?
Thanks for this list, perlgeek. &gt; The string vs. byte distinction doesn't really exist, which makes it hard to write larger applications that don't suffer from encoding problems. How does Perl 6 handle strings/unicode? I think Python 3 has either bytes or strings (unicode) and you need to encode/decode to go back and forth. &gt; XS is a pain to write, and necessary for interfacing with C libraries How would you interface to a C library using Rakudo? I think Python has ctypes, which looks pretty nice. 
&gt; How does Perl 6 handle strings/unicode? I think Python 3 has either bytes or strings (unicode) and you need to encode/decode to go back and forth. That's pretty much the Perl 6 approach too: `Buf` is byte buffers, `Str` text strings with transparent encoding, `Buf.decode` gives a `Str`, `Str.encode` a `Buf`. For convenience, most IO routines can encode and decode for you. &gt; How would you interface to a C library using Rakudo Currently through NativeCall.pm in http://github.com/jnthn/zavolaj . Basically you write a stub Perl 6 routine, the types in the signature are mapped to C types.
Ah, so it fixes it to work with killall basically? Sounds nice. Sorry, didn't mean to offend or sound ungrateful for the continued work on Perl. It's just that distros wait years before upgrading to newer versions (CentOS is still 5.8.8, for example), so I was hoping for more features to be packed into a major release than that (as there were in 5.10 and 5.12, hell, even 5.10.1). The new things seem nice, but more like minor release material to me. Anyway, hopefully we can finally convince the boss to let us roll our own rpm and get some of the newer features before we die of old age.
Actually, he didn't mention the (IMHO) most important upcoming feature, probably because it isn't quite finished yet: a more reentrant parser. This will make Devel::Declare kind of code possible in a way that isn't batshit insane.
This is not a final release - it is planned for spring 2011. More new features are already planned and implemented in branches.
Each Apache child is 100+ MB. It appears to mostly be a side effect of prolific module use (hundreds of .pm files).
You can use Apache::SizeLimit if they processes grow too big before they die. I used dtrace to see if any of my modules were not being loaded in startup.pl and thus in shared memory - you might try that if you are using a Mac with the application. Else there is Apache::Status which shows module footprints IIRC.
It occurred to me the other day that reading Perl is a little like reading music. If you don't know what you're doing then it can appear to be an impenetrable mess of squiggles and sigils. But with a little understanding you realise that it is really quite simple, yet incredibly expressive. With a dozen or so different squiggles, you can encode everything from Chopsticks to Chopin. Of course, being able to read and write music doesn't make you a great composer - you can write "bad music" in any language. But give me the expressiveness of Perl over the Do-Re-Me of certain other "one way to do it" languages, any day. **TL;DR:** Reading music is hard, lets go shopping! 
plack is what you need :)
I have a group of servers running nginx proxy_passing Starman with 20 workers each in serving tens of thousands of requests a day for an internal service. Starman and Twiggy are production ready in my books as we've been using them both since March and never had a hitch.
&gt; What, that's it? There has to be more than 4 new things and some minor performance boosts. Why? What's wrong with cutting a release doesn't turn the world upside down? After all people can judge individually if they want to upgrade. It's much better for the user if the release cycles are predictible, and more motivating for the developers to see their patches in some release in the wild. (Also note that 5.13.* contains lots of fixes for long standing bugs)
I definitely get tripped up with sigils when dereferencing deeply (or even not so deeply) nested data structures. Also typeglobs, if I have the misfortune of encountering them. Also sometimes it seems like curlies are used for too many different things. :) But OTOH, built-in functions in Perl tend to be very well-named, and when you add in string interpolation, default variables in small loops, tasteful use of statement modifiers, and shortcuts like qw//, Perl 5 is quite readable, IMO. 
In my humble opinion, Java is alot harder to understand than Perl, especially when having to meander over to the enterprise side of things.
Thanks, that helps increase my confidence level. I'm really excited about Starman and want to use it. It makes complete sense. Instead of wiring Perl into a web server like a research monkey, just write the web server in Perl. Why didn't we figure that out like 10 years ago?
Some of us did.
If i could upvote this any harder than i already did, i would.
so, uh, could we get maybe a repost to a better link? one with a screenshot or something that doesn't look like a slashdot blog?
http://www.lacunaexpanse.com/
I didn't want to link directly to the PDF, that's where the interesting information is ;-)
I only had a brief look at the game, being that I'm at work I don't have the time to get sucked in, but that is an impressive looking browser based game. I'm definitely checking out that pdf, although I'm sure most of it will be flying right over my head.
Woot! Gaming in Perl! This is awesome! Are you the author?
No, I wish! [JT Smith](http://blogs.perl.org/users/jt_smith/) made it.
Cool!
pretty solid....for most of these books i think the intro chapter is better removed....no one reading an advanced text like this is going to be new to perl, and there are better resources for basic intros still, i read over most of it and liked it and learned some new stuff. whats needed now is just to make the leap to perl6. lets face it, the critiques that continue to dog perl5 wil never go away, and perl6 properly addresses many of these issues. its time now that rakudo is approaching usefulness that modules start getting ported and serious docs like this book start getting written 
We're working on the Perl 6 books. I skipped the intro "How to write a text file" part of the intro, but kept everything else because a lot of the advanced concepts in Perl rely on solid understand of fundamental, theoretical concepts. People who understand context from the start have many fewer surprises later.
This is a refreshing examination of how Perl is progressing, and it gives much needed attention to the basic understanding of the language which is required in order to appreciate the more advanced features on the long road towards the next generation.
Very impressive. I'd be quite keen on learning more about how the Plack / PSGI stuff is used.
For linux with *sysfs* /sys/devices/system/cpu/cpu*
Only thing is i want to make this OS independent, i could grep processor /proc/cpuinfo, but i was wondering if there was anyway to query the system with perl.
There isn't a portable solution in Perl, but there *is* one for Java: Runtime.getRuntime().availableProcessors(); Note this is sensitive to processor affinity on Windows but not on Linux.
there appears to be several modules on search.cpan.org that claim they can do this. Sys::Info::Device::CPU, Sys::CPU .. just search for "cpu"
There's no guaranteed OS independent way to figure this out. Linux has /proc/cpuinfo, Solaris has the *psrinfo* command, OS X has *system_profiler*, FreeBSD has a sysctl for it, etc etc. The bottom line is you will need to check which OS you are running on and then write code for that OS. Each new OS you want to run the code on will require some new code in this area. Sorry, but that's the way it is -- there's no portable built in method.
&gt; Each new OS you want to run the code on will require some new code in this area. A fairly extensible method might be to use Moose's roles to do the heavy lifting.. package Whatever::DetectCPU::Linux; use Moose::Role; sub detect { # Linux-specific crap here return 42; } And then just do some OS detection and `with` the proper role and call `-&gt;detect`. Adding a new OS would be a new role and a new OS check, but nothing more.
Not to mention /proc/cpuinfo doesn't even use the same format across CPU architetures.
Browsing through the Postgres sources, I stumbled upon this horrible and funny (in a way) usage of Perl. It's almost equivalent to that code from The Daily WTF where some guy selects now() from database to get the local time. O tempora, o mores with these programmers!
I've read worse; parts of MakeMaker for example.
*shrug* I wouldn't write that code, but I wouldn't try to replace it if it was passing its tests either.
I want to go "You already HAVE perl running, why do you need to run sed using it?!? shake-shake-shake..." If it wasn't tested, I'd replace it. If it was tested, I'd replace it when I had free time....
Does pg always think it is the same time as the system? Doesn't it report it as the time at the beginning of the transaction?
`now()` in particular returns [the transaction start time](http://www.postgresql.org/docs/9.0/static/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT). The only remotely-valid reason for using a database just to get a timestamp, though, is if all the other servers on the network accessing it have completely incorrect clocks and the sysadmin is an evil psychopath who forbids the use of ntpd.
It's kind of postgres' style to try to protect against psycopathic sysadmins. I'm wondering if there is some torrid history behind that line of code.
I started using FastCGI for everything a few months ago and haven't looked back since. * Restarting one app no longer requires restarting the entire server, including waiting for the other apps running on it; less downtime as a result. * Same goes for restarting the web server itself — if an Apache exploit shows up I can do an upgrade with virtually no downtime, or I could just as easily flip it over to Lighttpd until the problem blows over. For that matter, FastCGI will actually let you use other servers in the first place. * Keeping the web server at arms' length makes it harder to write code using server-specific functions. Good if you're writing portable code, I suppose. * The network-based IO means you can go a lot further with security, even going so far as to run each CGI in its own chroot, VM or physically isolated machine. Plus it's a lot more straightforward than trying to set up suexec. And for the most part, it still works the same as mod\_perl.
*Scrolling down, seems okayish so far...* *Huh. Lots of calls to `sed_file()`. Well, it probably just loads the files and s///;...* ಠ_ಠ 
That's some kind of double fail: The script doesn't even use sed the easiest way. Instead of redirecting the sed output into a temporary file and moving the output back to the origin then, -i could be simply used.
It is not uncommon for administrators to write code like this. The sub after exit is especially funny. Oh and passing a string to system? 
-i is a GNU thingy, it doesn't work with the default sed in BSD userland.
ug, cuddled elses. Someone needs to do a `perldoc perlstyle`.
Why not, it's simple script. Would similar shell script look much different? Although passing string to system looks bad idea in Perl.
- system sed - warnings enabled but no my - Two-argument "open" + Bareword file handle - sub{...} after exit() Oh well TMTOWTDI I guess...
Noob here, honest question: what is wrong with sub after exit?
http://jobs.perl.org/
Yep. Unfortunately I'm looking for temporary telecommute. Unless I'm doing it wrong, there aren't usually many telecommutes listed, and they all require "some" onsite, which I can't really swing after December, and are mostly full-time salaried. They don't have to be serious jobs; I'm just looking for some really simple Perl work that pays, which is what got me on freelancer.com looking at $50-$200 bids for eCommerce integration. Thanks for your help.
Nothing's wrong with it. It's actually pretty common to put your subs at the bottom of your scripts and your flow control (including `exit()`) at the top.
The fact that they are using Perl like shell is kind of the point. Each call to system is another process, and lots of overhead to do something that's already a Perl built-in. Perl was originally designed to replace shell, awk, grep, etc. Using to instead call out to those is definitely missing the point.
Call me an anal Perl developer, but the whole thing lacks a "use strict;" line in the beginning. That's the first thing I noticed. Next thing is that they are using sed to do something that is native to Perl. This person clearly needs to learn to use regex's in Perl. There is no reason to resort to sed for the pattern matching. Using regex's would eliminate the need for the system() calls. 
check out [scriptlance](https://www.scriptlance.com/cgi-bin/freelancers/search.cgi?cats=1)
Thank you! Looks like freelancer.com is a common site scheme. There seems to be a lot of competition for this kind of stuff; I guess that's what I get for looking for easy work.
You mean "There's more than one WRONG way to do it" :)
Yup, whenever I notice the absence of use strict; use warnings; I always wonder what problems they're trying to silence.
http://perldoc.perl.org/perlstyle.html Page 1: * Uncuddled elses.
It'd be pretty weird to go through all that trouble and suddenly get concerned about portability. Stranger things have happened I guess.
Sometimes perl is what you can get away with. I suspect the original author spent about 5 minutes of total time thinking about her or his janky script where this thread has spent well over 5 collective hours in bafflement.
You're right, I just finished setting up my profile with elance and it seems much more legit and the work quality seems much more well-planned. Will check out guru.com, but this is a great recommendation already. Thanks! Oh, and glad to see you're still alive.
I've done a few small freelancing jobs so far, and I got most via personal contacts. If there's a perlmonger meeting close to where you live, you should really go there (it's also good fun). If there is none, and you live in a bigger city, consider starting one - just meeting fellow Perl programmers, drink a beer, talk about tech topics, and sometimes a presentation on a programming topic.
There are a ton of Perl coders out there (unfortunately littered with those who 'call' themselves Perl coders). My experience is that a multitude of them just write Perl code to do what they have to do, regardless of how it looks or what it includes. As long as it works, its fine. For the rest of us, that just isn't the answer. I am a Site Moderator on a Developer forum and one of my requirements, running the Perl forum, is that if you want us to look at your code and help you, you have to use warnings and strict and have to have already worked out the syntactical BS. The reason that we do that is so that we don't HAVE to spend 5 collective hours figuring out someones unsupportable code. :)
That's a great idea. For some reason, I never considered getting involved in any kind of Perl community. While I've done some serious, semi-large-scale work for medium sized businesses, the nature of Perl and my limited experience in working with other Perl people always made me feel like a plebeian among scholars when I thought of approaching existing communities. That, and most of my experience is in Win32, which makes me feel like a leper when everyone loves lamp. I'm in Philadelphia, [which has some Perl mongers](http://philadelphia.pm.org/). What sort of atmosphere would you guess I can expect here?
Author of TT2 here... &gt; Extremely fast - Up to 50~100 times faster than TT2 Nice! I'm also working on a [C template library](http://github.com/abw/hemp). The primary purpose is to provide a super-fast implementation platform for TT3. But it'll support multiple syntaxes on a per-template level, so it's really a generic template/document engine with plug-in languages. Rather than write it all in XS, I've written it as a "raw" C library and then provided XS wrappers for plugging it into Perl (and plugging Perl data into it). This should make it easy to provide additional wrappers to port it to Python, Ruby, PHP, etc. It's still a work in progress so don't get too excited about it yet. But still, it's nice to have another player in the game.
I've visited two different perlmongers group, a national Perl workshop and an international Perl conference (YAPC::EU 2010). So far all my real-life meetings with other Perl developers have been very pleasant and relaxed. Not all perlmongers meetings had a strong focus on Perl (often general discussion about IT work, working environment, version control, server software, IDEs, web frameworks, ...); if strong focus on Perl contentis important for you, just ask on the mailinglist in advance. So all in all I'd say "go ahead and try", there's not much you can lose (except maybe for a wasted evening).
Heavy TT2 user here, kudos to you sir !
awesome how simple is this to drop-in a framework like dancer that uses TT? 
sweet, nice to see TT staying in the game
I've been freelancing for the past two years via odesk.com exclusively and it's done me pretty good. They don't just do job/provider listing, they also act as middleman in the cash transfer, which effectively protects you from ever losing more than a week's worth of pay. An added bonus is that they also provide a bugzilla instance for every project you do through them.
Duplicate of this link: http://www.reddit.com/tb/dkokv
You can't check prototypes. Well, at least all global variables are set at the end ... Yes - nobody like prototypes, but I'd still expect the subs at the top of the file. Calling the subroutine without parentheses works: sub func1 { say "hi"; } func1; You could use &amp; to get around it, but it's optional in perl5. I guess I should read perlsyn (again) to give you a better explanation. All approaches to subroutines in perl have their pros and cons I guess. And the code in question really is a simple admin script, nobody cares.
Perl is great to glue it all together..
I like the idea of the module builder recording "known good" versions of dependnecies (ideally it should be tied into the unit tests, so that only a full test pass made such a recording). I wonder if cpantesters could be used to gather some of this information? Or is it not likely that cpantesters' installations would have older versions of dependencies? (Comment here rather than on the blog because MT's comment engine *SUCKS*. The "login" page is reached by javascript, irretrievably replacing the original page, and it refuses to accept either a Google or LiveJournal OpenID.)
I know you don't want praise, but very nice looking code. Good job.
Thanks, that is actually nice to hear. I make a very conscious effort to make my code read well and i don't often know whether i succeed or not. :)
Looking at the sample pages it doesn't look like they put much extra effort in formatting. I would have loved too seen some printed tabs on the sides/margins to help navigating the book like you get with the O'Reilly Java in a nutshell type books.
Change print $list; to print "$list-&gt;[VAL]\n"; and it will do what you want. You got that example from http://www.perltutorial.org/perl-linked-list.aspx, but it's kind of confusing with all that $four = $list-&gt;[NEXT]; stuff. Here's another way with hashes use strict; my $list = undef; foreach my $x (reverse 1..5) { $list = {head =&gt; $x * $x, tail =&gt; $list}; } while($list) { print "$list-&gt;{head}\n"; $list = $list-&gt;{tail}; } Check out http://search.cpan.org/~drolsky/List-AllUtils-0.02/lib/List/AllUtils.pm for a bunch of useful list utilities. 
The best bet is to try what you think it should look like, and then use the Data::Dumper module to print out what data structure you actually have. use Data::Dumper qw(Dumper); # your code print Dumper $list or use the debugger perl -d program.pl and type 'h' to see all the commands. 'x $list' to display the data structure. If I wanted to make a linked list, I would consider a hash: my $list; for my $value ( 1..5 ) { my $node = { value =&gt; $value, next =&gt; $list, }; $list = $node; }
Why do you want a linked list in Perl? (Hint: it's meant to make you think about what sort of properties you want in a data structure, like "fast to sort", "O(1) access time", etc.)
This was my immediate thought on seeing the question too. Linked lists in a language with dynamic arrays and hashes seems a little pointless unless you've got a really good reason.
Useful. Thanks.
You need to `print $list-&gt;[VAL]`, not `print $list`.
There's a google code project at http://code.google.com/p/circos/ . I don't see a cpan repository, but it is listed in "ThirdParty.pm" http://search.cpan.org/~saper/Module-ThirdParty-0.27/lib/Module/ThirdParty.pm
What are you expecting to use it for? Why do you think you need Perl vs. every other tool you use? A bit more incite into your situation would be helpful.
I really have no clue. I was reading about that guy who created a nice reporting tool monitoring their storage. That was pretty cool, but a little aggressive for me to figure out. I don't have much to work on right now and would like to use the downtime to learn something new.
That's a pretty varied question, kinda like asking "what do I use this paper for" I would suggest playing around with some of the file system/DA querying tools to start with tinkering with generating reports or whatever. Really it would come down to what needs you have.
Sorry, looks like I accidentally did not place this post as a link.
Just learn the language. Play around with it. As you learn it you'll find the ways in which it will be useful to you.
As preparation for migrating to a Linux SysAdmin job.
any think that involves text processing and RE are good uses for perl.
Windows sets an environment variable NUMBER\_OF\_PROCESSORS
It's great that you've gone to the work to make these available. Maybe you could talk to the Rakudo team about getting fresh builds like yours on the [Rakudo Star downloads page](http://github.com/rakudo/star/downloads)?
Would it be pretty easy to fire off an update when something like, an object in active directory gets changed? Say a user was added to a security group?
From the article: &gt; Instead functions return objects that behave appropriately in various contexts, and the context is determined at run time. Can I see an example of a function that returns, say, a string in scalar context but a list in list context? Something like: sub remote_location { # if scalar context, return "middle of nowhere" # if list context, return [1.0e6, 1.0e6, 1.0e6] } 
In perl 5 you use wantarray() in your example. It returns true if the function was called in list context, false in scalar context, and undefined in void context (return value not being captured). Depending on what wantarray returns, your function can return the appropriate type of value. It seems that in perl 6, you only ever return *one kind* of object, but the object should somehow know the context *it* is being evaluated in and do the right thing (i.e. the function doesn't have to care about the context, but the object does). I haven't been following perl 6 closely lately, so I'm not sure of the mechanics of how you implement that. See [this](http://perlcabal.org/syn/Differences.html#wantarray%28%29_is_gone) 
Would be more interesting if the software in question was something other than a horribly planned out mess.
 class GeoLocation is Array { method Str { 'middle of nowhere' } } sub remote_location { return GeoLocation.new(1e6 xx 3); } # or even easier: sub remote_location { return (1e6 xx 3) but 'middle of nowhere'; } 
Task::Kensho provides a bunch of nice things, not all of them are needed by everyone, but it still gives you a nice piece of enlightenment.
It almost always has been written. The question is if you can find it and, once found, adapt it to your specific needs. Feel free to ask me or any of the other perl.reddit folk for specific advice.
Try taking a look at the Effective Perler book.
http://cpanratings.perl.org/ is pretty interesting to follow to find high quality modules. It's not an overview, but rather a cross section of CPAN. And it might tell you to not bother with some things.
1) Go to cpan.org and click on the third item down in the right hand column: 2) [CPAN modules, distributions, and authors (search.cpan.org)](http://search.cpan.org) 3) type in some terms relating to the module you want to write 4) profit!!!
I find myself constantly using Text::Csv_xs and Parallel::ForkManager.
The answer to this is no. The modules it helps to know about vary drastically between what one is trying to do. Given this there is no sane guess work that can be done to make a useful suggestion. You are better off searching it and seeing what comes up. Over time you will get better/quicker at finding stuff. Also don't worry about reimplementing something if nothing does something in a way you like/prefer. 
Catalyst, Moose, DBI, DBIx::Class, Test::More, Template
I use DBI and Moose on a daily basis.
I don't think it's about CPAN being vast, it's about it being so broad. You could spend your whole life not needing the CGI module, or use it every day, depending what kind of work you do. So it's like saying "tell me what are the good medicines in my pharmacy". They're all good ... for certain things.
Check out the [Modern Perl book](http://www.modernperlbooks.com/drafts/modern_perl/modern_perl_draft.pdf). It has a section on CPAN and information on useful modules
Perl has many concepts built-in that STL provides for C++. Examples: Hash tables, arrays that you can push to, and still access efficiently by index; sorting by arbitrary criteria. So there's not a a collection of modules you'll always need; it really depends on what you want to do. Maybe the closest are some pragmas like `strict`, `warnings` and `autodie`, and a few helpers like `Scalar::Util`, `List::Util` and `List::MoreUtils` (all except that last are core modules). If you want to write object oriented code, Moose will help you immensely. If you want to access databases, `DBI` will be your tool of choice, and maybe also `DBIx::Class`. For web development, `Plack`, `Mojo`, `Catalyst` and others are worth looking at. And so on, and so on.
These days, you can just use Text::CSV. It will use Text::CSV_XS if you have it; pure Perl if you don't (I think this is ideal for an extension module).
Dude, just use MirthConnect. It's a free open source hl7 interface engine. It's easy to use and very powerful if you know javascript. http://www.mirthcorp.com/community/downloads
Except it's more like if 5-10% of the medicines were great, another 20-40% were effective but had horrible side-effects, and the rest came without instructions, had never been tested or FDA-approved, or just outright killed you.
Thanks. Much appreciated. I love compiling. It stops my hands freezing on my keyboard in winter. I just had problems with the ICU library. I see that they provide [Windows source now](http://icu-project.org/download/4.4.html) - did I miss that before, or is it new?
So, what's wrong with the Perl 5's overloading? All I see is a problem with a function taking two different inputs. 
What's wrong with documenting such functions as taking a "string, or string equivalent"? Also, the hideous contortion given in the article can be hidden away in another sub; furthermore, the !defined and the !ref bits are often known ahead of time. I've asked this before: how exactly do you people get unknown invocants in your real-world code?
Problem with the installer - it erases the system path. It ought to append the location of C:\Rakudo\bin to the %PATH% variable, but instead it replaces it altogether, destroying any previous data.
Okay... so I was able to do the same two look structure with the VAR2 hash in the first loop so that solves one problem... now I just have to check for changes in the values. This seems really inefficient to me though... is there some other way of doing it?
check out the Perl Cookbook. Find common keys my @common = (); foreach (keys %hash1) { push(@common, $_) if exists $hash2{$_}; } # @common now contains common keys Find keys from one hash that aren't in both my @this_not_that = (); foreach (keys %hash1) { push(@this_not_that, $_) unless exists $hash2{$_}; }
http://search.cpan.org/dist/Hash-Diff/ or http://search.cpan.org/dist/File-Monitor/
Do something like this (not tested): for my $key (keys %search) { if (!exists $VAR2-&gt;{$key}) { ... new key added ... } else { my $val1 = $search{$key}; my $val2 = $VAR2-&gt;{$key}; ... compare $val1 &amp; $val2, act accordingly ... } } Good luck.
You write a CPAN module and want to take a string, and you want to actually check that you got a string. Is that hard to imagine? And yes, of course you can write a function encapsulate it, but all of this defeats the purpose of overloading, which is to make an object look like a builtin so you can treat it *exactly like* a builtin. Really, we'd be just as well off if we agreed that all objects should provide an "as_string" method if they stringify. We'd get the same effect for the same amount of work without having to use the weird API provided by overload.pm.
Just FYI, this: my @VAR1 = $_[1]; ... our $VAR2 = $VAR1[0][0]; Makes zero sense because VAR1 isn't doing anything useful here -- you're creating a list containing a single element and then accessing that single element. It would be like writing my @foo = "Hello world"; print $foo[0]; There is no reason to use an array to hold a single scalar. You should just write "our $VAR2 = $_[1][0]". (That's also a really bizarre way to be using 'our'.) 
a simple and straightforward solution: #!/usr/bin/perl use warnings; use strict; my %a_hash = (a =&gt; 1, b =&gt; 2, c =&gt; 3); my %b_hash = (a =&gt; 2, b =&gt; 2, d =&gt; 3, e =&gt; 4); while(my ($k, $v) = each %a_hash ){ if(exists $b_hash{$k}) { print "$k exists in a_hash\n"; if($b_hash{$k} ne $v) { print "the values of $k differ\n"; } delete $b_hash{$k}; } else { print "$k doesn't exist in b_hash\n"; } } my @not_a = keys(%b_hash); my $res_str = join( ", ", @not_a[0 .. length(@not_a) - 1]) . " and ". @not_a[-1]; print "$res_str dont exist in a_hash\n"; 
Why not just check if it's a ref? If it is, check isa to determine if it's your desired type. If it's not a ref, you can assume it was a string argument. Or, use Params::Util as suggested in the first comment (which probably works even more cleanly).
I think you missed the point. The desired type is a string. All refs can be stringified, but only some can be stringified in a useful way. As far Params::Util, yes, that's nice, except the function Adam suggests doesn't actually exist. Also, while it's nice that this is encapsulated, the fact that it's necessary at all is symptomatic of how broken overloading is.
I did miss the point :( I can see what the author is getting at, but I'm not sure I agree: he wants to guarantee that he's passed a path string, or something that stringifies to a path, and he's worried about being passed some object that doesn't represent a path. Having something like as_string on each stringifiable object would still put the burden on the caller to pass an object that represents a path and not some other random stringifiable object. Really, all he's going to do is to limit the set of possible arguments to objects that are stringifiable - you'd still need to check if a particular string represents a valid path, and don't really gain anything. In a more general case, yes, Perl will stringify anything, and it's up to you to determine if that string is meaningful. We can come up with schemes to eliminate "accidental" strings like "Foo::Bar=HASH(0x1234567)," but what if I decide all objects from modules I write should stringify to "Stormborn rulez"? Good defensive programming practices would indicate that I should check the contents of the string anyway. Mabe I'm missing something? As for Adam suggesting a function that doesn't exist - he wrote Params::Util, perhaps _SCALARLIKE is coming in the next version? :)
Of those, only Moose, DBI, and Test::More are truly general purpose.
I am the author. Compare this to a language with a stronger typing system like Haskell. In that language, I could insist that the argument implement a type class for stringification (I think it's called Show). Problem solved. With Perl, I want to do some sort of stronger checking that something is *intended* to be a string. That means it's either a native Perl string or an object that has an explicit "turn me into a string" method. The latter case is what overloading is supposed to be for. Unfortunately, since Perl stringifies everything, I can't actually just use things as a string and hope it works. If you write a module that stringifies to "Stormborn rulez", that's fine, it's a valid path. If you don't intend your module to be used as a string, then why are you overloading stringification? As for checking the contents, the problem in this case is that Perl's references stringify to perfectly valid paths (at least on Unix)! 
Just loop over the keys in A once, listing those that are missing or different in B while deleting them from B; then list the keys remaining in B, which aren't in A: map { if ( ! $b{$_} ) { print "in A but not B: $_" } elsif ( $a{$_} != delete $b{$_} ) { print "changed: $_" } } keys %a; map { print "in B but not A: $_" } keys %b; 
Or, avoiding map since you're new to Perl: for ( keys %a ) { if ( ! $b{$_} ) { print "in A but not B: $_" } elsif ( $a{$_} != delete $b{$_} ) { print "changed: $_" } } for ( keys %b ) { print "in B but not A: $_" } (Oh, and I used #!/usr/bin/perl -l to get automatic line breaks, add "\n" to each string if you don't.)
If you want something simple and your hashes are relatively small (or if you don't care too much about efficiency), then serialise both hashes and string compare the result. e.g. using JSON: use JSON; sub hash_eq { to_json(shift) eq to_json(shift) } Tip: install `JSON::XS` for better serialisation performance. The `use JSON` will use `JSON::XS` automagically. 
What do you want to achieve? If all you want to do is to calculate with these numbers, then just weed out the commas and you are done: #... $num =~ s/,//g; $num += 1; #works now #.... Edit: grammar, spelling
 m/\d{1,3}(,\d{3})*(.\d+)?/ That should match 1-3 digits followed by any number of ",xxx", followed by optionally any number of digits following a decimal point. \d{1,3} This part matches the leading number group (,d{3})* This part matches any number of groups following (.\d+)? This part optionally matches a decimal point and any digits that follow You can lead any group with ?: if you don't need or want it to be captured into a backreference. Like so: m/\d{1,3}(?:,\d{3})*(?:.\d+)?/ 
No, the module I'm using converts numerals to numbers in word form ("1" to "one"), so I need to extract the full numbers from the text.
Thanks -- this is getting me close. Now I think I only need to fuse the three strings produced by the search expression into one for processing by the module. The following throw syntax errors when they hit a number with a "," or a ".", however: $current_item =~ s/(\d{1,3})(.\d{3})*(,\d+)?/$numeral_converter_obj-&gt;cardinal("$1$2$3")/ge; $current_item =~ s/(\d{1,3})(.\d{3})*(,\d+)?/$numeral_converter_obj-&gt;cardinal($1.$2.$3)/ge; $current_item =~ s/(\d{1,3})(.\d{3})*(,\d+)?/$numeral_converter_obj-&gt;cardinal("$1.$2.$3")/ge; $current_item =~ s/(\d{1,3})(.\d{3})*(,\d+)?/$numeral_converter_obj-&gt;cardinal("$1"."$2"."$3")/ge; I've tried using "join" in the eval'd replacement argument, but that died too. Any suggestions?
"[0-9,.]+" is syntacticly correct and works for me: perl -e 'print "$1\n" if "xxx 1,000,000yyy" =~ /([0-9,.]+)/' 
use [Regexp::Common](http://search.cpan.org/~abigail/Regexp-Common/lib/Regexp/Common.pm) for common patterns like this. use Regexp::Common; $test = 'number is 10,123,456,789.123456789'; $test =~ $RE{num}{real}{-sep =&gt; ','}{-group =&gt; 3}{-keep}; print $1; #prints 10,123,456,789.123456789 And if what you're doing is substituting all instances in a text then $text =~ s/$RE{num}{real}{-sep =&gt; ','}{-group =&gt; 3}/$numeral_converter_obj-&gt;cardinal($&amp;)/eg; 
Thanks a million!
&gt;You write a CPAN module and want to take a string, and you want to actually check that you got a string. Is that hard to imagine? It's hard to imagine that a programmer would pass, to a function in such a module, a non-string when the documentation says to pass a string, while reasonably expecting the function to do what the programmer meant. Hopefully this clarifies the question.
Looks to me like Lingua::EN::Numbers will handle commas, etc just fine?
As it is, you need to trust the caller to pass something that stringifies to a proper path. If you had the ability to say "this is meant to be treated as a string" you'd be limiting yourself to strings and stringifiable things, but you'd still need to trust the caller to pass something that stringifies to a proper path. I don't see the difference.
Yes, but the test cases they give in the docs are toys. As far as I can tell, you have to extract the numbers (and only the numbers) you want to process with it from your text on your own, and then feed them to it, which makes this regex necessary. Maybe I'm wrong, though. I gotta wonder at something like Roman.pm -- if you want to use it to convert *from* Roman numerals, you have to figure out just what in your text is a Roman numeral first. This is either (a) impossible or (b) a matter of reimplementing the module in order to use the module, and since both of these options are so absurd, I have to assume it's me who's assuming wrong.
&gt; As it is, you need to trust the caller to pass something that stringifies to a proper path. Suppose the source of this something is user input. Of course all of the callers have validated it properly, but ....
This worked fine for me: sub parseNum { my $current_item = shift; if ($current_item =~ /(?:\d{1,3})(?:,(?:\d{3}))*(?:\.\d+)?/) { $current_item =~ s/,//g; print "$current_item\n"; } }
Are you sure? Works fine for me and i don't know what could cause such problem ;/
Definitely. I was able to replicate it. It seems to be a problem with the install script. I installed rakudo-star.2010.09.exe with the option to add it to the path. Strangely, the installer gave the message that the path was empty before it added the C:/Rakudo/bin folder to the path. It looks as if the installer is deleting the path *before* it adds Rakudo. I am using an admin account on Windows-XP which is vulnerable to this kind of thing. Possibly on Vista and Windows-7 deletion of the system path is not permitted, while appending is, so that the instructions which happen to delete the path fail silently, and the instructions which append Rakudo to the path succeed. 
It is totally reasonable to pass an object which overloads stringification, except for the fact that Perl's overloading is broken, as described in my blog post. I think you might not understand what overloading is supposed to be. 
The difference is that if you can check for totally bogus types (hash ref), you can at least rule out some inputs immediately, and give a useful error message like "this function expects a string containing a path". This is what type checking is for. 
Appreciate the constructive criticism. Like I said before... I'm new to perl, and I really don't know what I'm doing yet. :) Guess that's what happens when you try to teach yourself a language by looking shit up on the internet, eh?
It's not letting me edit my post... but I just wanted to thank everyone for the help. My script is fully functional because of you guys.
Does localtime with no arguments correctly return the current time?
Yes, it does.
The same for if you pass the current time to timegm and that result to localtime?
Sigh. Never mind. The month argument for timegm is 0 to 11, not 1 to 12. Thanks for looking at it!
Reddit is great but a, arguably, better place for this type of this may be a site I visit frequently called [perlmonks](http://www.perlmonks.org/)
Experience has told me that all that has to happen is for someone to ask boring questions that cause you to look at it slightly more... like in this case you figured it out. I often figure stuff out by having people ask me stupid questions.
I'd really suggest using DateTime for this anyway. my $dt = DateTime-&gt;new( year =&gt; '2010', month =&gt; '10', day =&gt; '31', hour =&gt; '15', time_zone =&gt; DateTime::TimeZone-&gt;new( name =&gt; 'local' ) # Get the zone from the OS ); # Do shit with $dt.. print $dt, "\n"; # 2010-10-31T15:00:00 Which is handy for setting the time zone when creating the object. DateTime also has a `set_time_zone` method for your handy conversion. As an unrelated note, Perl 5.8.8 on RedHat can be.. buggy. I don't recall the exact version, but upgrade if you can.
 $ TZ=America/New_York date -d '@1290369600' Sun Nov 21 15:00:00 EST 2010 gmtime/timegm (and localtime/timelocal) months are indexed from zero. By passing in a month of 10 and a day of 21 you asked for *November* 21. DST is indeed out of effect in November.
Dear Internet, Today I refactored some code, then wrote about it on the interblag.
Don't keep us in suspense; post a link!
 my $dt = DateTime-&gt;new( year =&gt; '2010', month =&gt; '10', day =&gt; '31', hour =&gt; '15', time_zone =&gt; 'local' # Get the zone from the OS ); You can pass a time zone name rather than an object. It makes the code a bit easier to read.
Ah, true. Personal preference.
timegm, timelocal, localtime and gmtime all use zero-based month indexes, so your code works with November, although the comment says October.
Rewrite it. Seriously, I can understand putting the 'compiled' version into production, but not to have the cleartext version stored in git or something?
Run it through with Dragon Unpacker (google it) and see if you can extract the raw text of the perl script. See if maybe you can just unzip it. :v
There is so many things wrong with this I dont know where to start helping you.
Firstly, the name of the language is perl not pearl. Secondly, compiling a perl script to an executable does absolutely nothing to hide anything. Whatever passwords or whatnot were in the perl script are easily extracted from the executable, probably using something as simple as the `strings` command. Compiling a perl script usually means not much more than concatenating a perl interpreter and the script. If you are giving this out to people that shouldn't have the router password then you need to seriously rethink your security procedures. Finally, assuming that this thing communicates with the router over a serial cable it sounds like you've got the com port set up wrong, i.e. wrong baud rate and number of data/parity/stop bits. It's usually something like 9600,N,8,1. If you get this wrong, whatever data you're trying to communicate over the link will look like nonsense.
Dragon Unpacker is excellent. Another approach is [windows-flavored strings(1) from sysinternals.](http://technet.microsoft.com/en-us/sysinternals/bb897439.aspx).
right, my black berry autocorrected. on that one. actually it uses telnet to access router, i wanted to use ssh. thanks for the dl on the security concerns. turns out my copy was corrupted.
http://search.cpan.org/~petdance/WWW-Mechanize-1.66/lib/WWW/Mechanize.pm Even though it's usage can be fairly complex, it's your friend. :) Also http://search.cpan.org/~petdance/WWW-Mechanize-1.66/lib/WWW/Mechanize/Examples.pod should help
It's possible, assuming there is a regular template. Obviously, if every page is so different that a regex can't find what you want... that will be difficult. Ad n2deep recommends, the WWW::Mechanize module is the way to go.
Scraping web sites can also be easy with excellent [Web::Scraper](http://search.cpan.org/~miyagawa/Web-Scraper-0.32/). Also, if you're having hard time with the regexes, try [HTML::PullParser](http://search.cpan.org/~gaas/HTML-Parser-3.68/) for old-school sites without CSS or "id" "name" in HTML attributes.
Some pointers: * Use [WWW::Mechanize](http://search.cpan.org/dist/WWW-Mechanize/) or [Web::Scraper](http://search.cpan.org/dist/Web-Scraper/) to fetch your pages * if you need parallelism, have a look at [Aaron's YAPC::EU talk](http://aaroncrane.co.uk/talks/multicore_for_mortals/) on the subject: just use processes and you'll do fine and better than threads or LWP::Parallel or whatever. Personally I use Gearman workers, YMMV. * Thou Shalt Not Parse HTML With Regexes! Use [HTML::TokeParser::Simple](http://search.cpan.org/dist/HTML-TokeParser-Simple/) or similar tools to do that. They work really well and don't cause you too many headaches. You can also try out [pQuery](http://search.cpan.org/dist/pQuery/) if you'd rather get HTML bits with a jQuery-like syntax ;)
Let's start really simple. You can pull web pages from a website using [LWP](http://search.cpan.org/dist/libwww-perl/), for example with [LWP::Simple](http://search.cpan.org/dist/libwww-perl/lib/LWP/Simple.pm): use LWP::Simple; my $html = get($url); After that, you can parse the HTML looking for links and images, for example with [HTML::SimpleLinkExtor](http://search.cpan.org/perldoc?HTML::SimpleLinkExtor). A title is also still feasible without actually resorting to using a "real" HTML parser, like [HTML::TokeParser::Simple](http://search.cpan.org/perldoc?HTML::TokeParser::Simple). [HTML::HeadParser](http://search.cpan.org/perldoc?HTML::HeadParser) looks like a handy module to quickly extract the title... This is enough to create an anonymous site crawler like you asked about. But if you need more advanced features, such as logging in first, [WWW::Mechanize](http://search.cpan.org/perldoc?WWW::Mechanize) might be more suitable (and likely, slower) which actually emulates a browser. Even more advanced: if you need support for Javascript, then there are alternatives for the latter that support Javascript.
Came in here to post about Mechanize. Really good PM that's relatively easy to use.
Once you start parsing HTML with xpath via XML::LibXML, everything else is a joke.
Scrappy might also be interesting. It encapsulates and abstracts lots of other modules.
I haven't used the other two being mentioned here, but I have done a fair amount of page scraping with LWP and LWP::Simple and they've been good to me (so long as you know Regex, or have another module for traversing the document tree).
use XML::LibXML instead my $html_page = '&lt;html&gt;&lt;/html&gt;'; my $parser = XML::LibXML-&gt;new( recover =&gt; 2 ); $self-&gt;parser-&gt;parse_html_string( $html_page, { recover =&gt; 2, suppress_errors =&gt; 1, suppress_warnings =&gt; 1 } ); my @nodes = $parser-&gt;find_notes('XPATH STATEMENT'); print $node[0]-&gt;as_string, "\n"; 
Should be very easy task. I've done something similar in the past, although Mech allows you relatively easily submit forms on the web I found that LWP::UserAgent gives you more flexibility. For the ebay, you're looking at something along the lines of: my $ua = LWP::UserAgent-&gt;new(agent =&gt; 'Mozilla/5.0'); my $response = $ua-&gt;get($url); if ($response-&gt;is_success) { my $tree = HTML::TreeBuilder-&gt;new(); $tree-&gt;parse($response-&gt;content); my @tables = $tree-&gt;look_down( _tag =&gt; "table", class =&gt; "li n" ); for my $table (@tables) { my $img = $table-&gt;look_down(_tag =&gt; "img"); my $img_link = $img-&gt;attr('src'); my $a = $table-&gt;look_down(_tag =&gt; "a"); my $title = $a-&gt;as_text(); } }
Step one of any perl project. Go to search.cpan.org and search for what you're trying to do: WWW::Search::Ebay http://search.cpan.org/~mthurn/WWW-Search-Ebay-3.021/lib/WWW/Search/Ebay.pm
The big thing to realize with mechanize is that the links it returns are mechanize::link objects, and have to have methods called on 'em to turn them into text.
Just because nobody's said it so far: &gt; is it possible to pull a picture and title from every auction on Ebay regarding automobiles Now that you know it's possible, you should probably ask if it's legal, or at least, if it violates their terms of service.
Ignoring questions of legality -- I'll assume what you're doing is legit, And before the WWW::Mechanize and LWP::Simple crowd shows up, Try [Object::ebay](http://search.cpan.org/perldoc?Object::eBay), an OO wrapper for [eBay's API](http://developer.ebay.com/common/api/).
This to me seems like the solution I will probably use. As a Perl novice, this is simple enough that I know how to do it. Thank you.
Web::Scraper can use XML::LibXML
Gotta love TAP, it is by far one of the most versatile testing platforms out there (thus Test Anything.. right?). I've seen it used for monitoring systems, smoke testing, unit testing, botnets...
Wow. *That* is clever.
Hey, that's the thegamecrafter guy! Great interview, thanks for posting.
I love Nagios, highly recommend it! I've had a good experience modifying the perl scripts to suit my needs, it was very straight forward. And if you've got a 'droid you should look at this app https://code.google.com/p/nagroid/
[Munin](http://munin-monitoring.org/) is written in Perl. Writing Plugins for it is as simple as printing to STDOUT.
if you are okay with nagios, check out icinga.
I like Munin, we were using it before, but it seems to be more about graphing than monitoring.
For alerting: [mon](https://mon.wiki.kernel.org/index.php/Main_Page) and [argus](http://argus.tcp4me.com/) For rrd-derived graphing/trending, collectd has [perl support](http://collectd.org/wiki/index.php/Plugin:Perl)
Opsview is a wrapper around nagios that is extensively written in perl, and has a complete perl API. 
Nagios hands down. You can write plugins for it in any language you want, and there are plenty of existing plugins you can start with. Nagios is written in C, but that shouldn't matter as far as being perl-friendly. http://nagiosplugins.org/ 
I like portsentry a lot for a number of reasons.
Even if it's not written in perl, I love [Cacti](http://www.cacti.net). You can have it execute perl scripts as data source and you can basically graph anything you want, very easily, with threshold. There's also a suite of scripts that allows you to automate the addition/suppression of servers. The polling is very efficient if you use the C based poller (spine). The GUI is well done and there's not so many bugs.
I've put OpsView in to a 5-datacentre 2,500 host 7,000 service setup (clustered back-end with satellites) and I can attest to it's quality. Edit: OpsView == nagios + simplicity of use.
http://collectd.org/ has a Perl plugin. It's mostly for gathering statistics, not monitoring though.
If you can get your hands on http://www.amazon.com/dp/059600639X (or its first edition, http://www.amazon.com/dp/1565926099 ), it provides quite a number of examples where you could use Perl in a Windows environment.
Sounds cool... Needs a Net::SFTP::Foreign::Mock...
That could be easily doable with application of some roles. I doubt i'll have the time for it, but the repo is open and i'll happily accept contributions. :)
Thanks.
That's odd; when I did it, [I got an extra link to cpan](http://imgur.com/HYaiW?full).
What if I want a 6th item in my array?
Your solution defeats the purpose of using an array - you might as well be using 5 named variables, because you're referencing each element individually. What you should do (if you want to write the algorithm yourself) is to loop through each element, so it works for any array: my $biggest = -1; # Note that this relies on the array having at least one number larger than -1 - if you need to handle negative numbers as well, it'd be a little more complicated. for my $element (@array) { $biggest = $element if $element &gt; $biggest; } print "$biggest is the largest number in the array\n"; If you don't care about the way it works and just want to use it, however, you should use the max method from List::Util.
cool, I see I'll have to think about it some more.
then uhhh, i add another line.
Just initialize $biggest to $array[0]. Of course, this assumes that you have at least one item in the array. You'd probably check that @array isn't empty before entering this section of code anyway. 
It's not _really_ a programming problem. It's a problem problem. If you had a stack of receipts, for instance, and you wanted to find the one with the largest total in it, how would you do it? I expect most people would go through the receipts one by one and keep track of what the largest one was. That is (almost) the solution amdpox gave you. Had he set $biggest to $array[0] first, it would be effectively the same as how most people would sove this in the real world (and work for negative numbers, but it is assumed that the array is non-empty). What your solution does is it takes the first receipt and compares it to all the rest. If it found one which is larger, it then takes the second receipt and compares it to all the rest. If some were larger, the third compared to all the rest, and so on. If you were doing receipts that way, it would a lot longer to complete. So just keep in mind how you'd solve things in the real world before trying to figure out how to write it in a programming language. Incidentally, sorting the array is not a very good way to do this problem. Going through one by one is the most sensible way to do this task on an unsorted list. (Sorting is more computationally complex than finding the max of an unsorted list.) If the list is already sorted, the problem is reduced to the real world equivalent to finding an entry in a dictionary, but sorting isn't free. If sorted though, you don't go one by one, but instead you use the fact that they are sorted to more efficiently find your entry. 
Actually, you'd also have to amend every one of the control (if, elsif, else) statements that you've written. That's why amdpox's solution is preferable: it is agnostic to the size of the array.
Rule of thumb; if you find yourself cutting and pasting line after line of code that is just a permutation of the line above it, you're doing it wrong. Computers are really really good at repetition. Make the code do the work for you.
thanks for the feedback people.
Do you have a rewrite to show us? It can help to get feedback on multiple iterations of the same code.
Well the fundamental problem with your version is that you would need more and more code as your array got larger. What if your array had six elements? You would have to change every single if statement and add another. What if your array had a million elements? Obviously your approach would be very tedious. What you really want to do is have a way to examine each element in turn and always store the current largest element found until you've reached the end of the array. That is the basis of using for and while loops. I would read up on those and see how you can apply that to your problem.
my line noise solution: perl -le '@array = (4,9,1,3,2); $m = 0; grep {$m = ($m &lt; $\_)?$\_:$m} @array; print $m' 9 
I don't like that your grep has a side effect... I don't know why that bothers me more than anything else. Why grep not map? Why not for? Also, erroneously returns 0 for negative or empty arrays. Here's some different line noise: use strict;sub max{my $max;$max=defined $max?$max&gt;$_?$max:$_:$_ for(@_);$max}print max 4,9,1,3,2
You can't possibly be serious...
Just use the max() function from [List::Util](http://perldoc.perl.org/List/Util.html), which is a core module.
 &gt;&gt; [14, 11, 190, 1500, 7].max =&gt; 1500
Exactly what I came here to say. No need to reinvent the wheel -- make your code shorter, easier to read, and more maintainable. Sample code: use strict; use warnings; use List::Util qw(max); my @array = (4,9,1,3,2); my $max = max(@array); print "Maximum is $max\n";
If beginners never implemented something that's already in a module, they'd never learn anything. I would suggest that using 'max' from List::Util is a perfectly fine shortcut for people who know how to find the maximum value in an array but couldn't be bothered (or who want more readable code).
Because it's Perl, it doesn't necessarily assume anything. If the array is empty, then $biggest is simply undef. It remains so because the loop never runs. $biggest being undef at the end is preferable to -1 since it's an obvious indicator that the maximum value in the array is undefined (doesn't exist).
Provided your list only contains integers and you don't want to use List::Util::max(): my $max = (sort { $a &lt;=&gt; $b } @a)[-1] Quite expensive though.
The problem statement stipulated that sort wasn't allowed. 
Yep I'm going to read the entire class again up so i can make this click.
Well, he's not resorting the original array here, just using a sort to create a temporary one.
Completely missed that one. :(
&gt; If beginners never implemented something that's already in a module, they'd never learn anything. Of course, that "anything" far too often means "Wow, someone can use my formmail.pl to send spam? You don't have to use a web browser to submit form data? Really?"
The first thing that leaps out at me is that you're using function prototypes completely wrong. Every one of your functions except for processNode are prototyped as taking no arguments when they do actually take arguments, which necessitates that ugly `&amp;function()` syntax for function calls. Prototypes really aren't that useful (at least IMHO) in perl except for writing functions that emulate the behavior of existing built-in functions. Certainly how you're using them is not how they were designed, so I would advise just dropping them. You declare an unprototyped function as `sub name { body }` and call it as `name(args)` or `name arg`, and such a function can take any number and type of args. When you declare it as `sub name() { body }` you're telling perl that the sub doesn't take any arguments, which generates an error if you try to call `name($foo)`. See `perlsub` for details. Also, the idiomatic way of creating aliases to function args is my ($first, $second, $third) = @_; And `undef` tests false so it's pretty rare that you actually need to test for `defined $foo`. Instead of `if(defined($var) &amp;&amp; $var-&gt;method ... ` you can write `if($var &amp;&amp; $var-&gt;method ...`
502 Bad Gateway? I'm not that great at perl, but I think I could manage that in &lt; 10 lines ;)
Don't worry about line count. Line count does not equal readability.
Agree! What I meant to ask is how could I decrease line count without degrading readability?
There are numerous ways to save a line or two here and there. For instance: if ($n &gt; 0){ $res = $nodes-&gt;item(0); } Can be rewritten as: $res = $nodes-&gt;item(0) if $n &gt; 0; Things like my ($node)=$_[0]; my ($doc)=$_[1]; Can be condensed to my ($node, $doc) = @_; In fact, I'd say directly accessing @\_ via $\_[...] is bad form in general, but that could just be a matter of personal taste. For one arg, "my $foo = shift;" at the top of the sub is much more common - @\_ is assumed. You can do the same with @ARGV at the top of the script. my ($original_file, $modified_file) = @ARGV; I might actually leave it as is for the sake of clarity, but it's handy to know about. In processChildNode, instead of if (&amp;isMenuNode($node)){ processMenuElement($node); } else { processElement($node); } I might do something like return isMenuNode($node) ? processMenuElement($node) : processElement($node); Minor nitpick: the &amp; sigil on a function name should pretty much never be necessary, except when referencing the function like \&amp;my_func. Aside from creating coderefs, I haven't used an ampersand for calling a function in about ten years. I could see it maybe being helpful if there's ambiguity and perl tries to treat it as a bareword for some reason (I've never had this happen, ever), but even then it can be resolved by calling my_func() instead of &amp;my_func. A few things are costing you extra lines here: my $n = $nodes-&gt;getLength; for (my $i = 0; $i &lt; $n; $i++){ if ((defined $id) &amp;&amp; getId($nodes-&gt;item($i)) eq $id){ $res = $nodes-&gt;item($i); last; } } return $res Better might be: for my $i (0 .. ($nodes-&gt;getLength -1)) { next unless defined($id) &amp;&amp; getId($nodes-&gt;item($i)) eq $id; return $nodes-&gt;item($i); } return undef; With this method there's no need to assign to $n simply to avoid calling $nodes-&gt;getLength once for each iteration. The range takes care of all of that, though it does come with the ugly side-effect of requiring you to subtract one because perl's range operator is inclusive. Using *next* will short-circuit the rest of the block, allowing you to avoid returning until you get what you want. It makes the whole thing much easier for these eyes to read, as well. I doubt these suggestions will get you down to your target, but hopefully you'll be on the right path. edit: reddit ate some of my underscores.
Go buy and read 'Learning Perl'. Here's a freebie though: my ($node)=$_[0]; my ($doc)=$_[1]; Change that to: my ($node, $doc) = @_;
Well, thanks for clarifying this function prototype thing, I did not catch that while running through some tutorials/examples. I did not understand why I need to use that ugly &amp;function() syntax to eliminate strange wrong number of arguments errors. Thanks again!
even better: my $first = shift; my $second = shift; or if you want to be very explicit my $first = shift(@_); Also, consider the following: my $var = 0; if ( $var ) { do_important_stuff() } if ( defined($var) ) { do_important_stuff() } Using defined is always a good idea if that is actually what you are testing; the shortcut mentioned above works if you know the context, but using it in the wrong place can get you into trouble.
First, the general advice. * Never use prototypes. You keep saying sub foo() { } This does not do whay you think it does, and the only reason it isn't bitting you is the second issue. * Do not call functions with `&amp;` prepended to them. This does not do what you think it does. Built-in and user functions should both be called like this: foo($bar); or this foo $bar; if `foo` was declared before this line of code. Calling a function with `&amp;` prepended to it causes special things to happen or not happen and you generally do not want this behavior. * Do not use the indirect object syntax. Always say my $obj = Class-&gt;new; Never say my $obj = new Class; * Exit as early as you can. Lots of your code is using a style developed during the spaghetti wars. This style dictates that a function has only one exit. That is a mistake. A function should have as many exits as it needs and it should take them as early as possible. Back in the bad old spaghetti-code days you would have functions that were thousands of lines long and jumped around. Trying to find all of the exit points of that sort of function was maddening. Now we understand that functions should be short (usually less than a page long) and it is much easier to see what is happening. Compare these two functions: sub foo { my $arg = shift; my $res; if (aaa($arg)) { $res = 1; } elsif (bbb($arg)) { $res = 2; } else { $res = 3; } } return $res; vs sub foo { my $arg = shift; return 1 if aaa($arg); return 2 if bbb($arg); return 3; } * Constants that are strings are probably a mistake. All you have done is replace a string that is easy to work with with a bareword that is a pain. If you must have them, then use the [`Readonly`](http://search.cpan.org/dist/Readonly/Readonly.pm) module instead. * In fact, constants are generally an error period. The only real value a contant brings you is the ability to change it in one place and have it changed everywhere, but if it is something you might want to change, then it should be in a config file, not hardcoded. Here is my version of your code: [http://pastebin.com/WPANnGax](http://pastebin.com/WPANnGax). I don't have your data, so I can't test that it does the same thing, but it does compile and is forty-five lines shorter and a lot more readable (to my eyes at least).
I can never make up my mind between my ($first) = @_ and my $first = shift. Why is the latter better?
shift should ONLY be used if you actually intend to modify an array. If you do not explicitly and pointedly have a reason to have @_ munged, just clone out of it once and leave it at that. It doesn't help that shifting out of @_ usually also increases the line count in a completely pointless manner.
It isn't better, it's actually usually worse if you're just setting up your function arguments.
Take a [look here](http://www.perlmonks.org/?node_id=575918) for a good discussion. I find myself doing this when I need it: my $var = shift || 'default val';
Instead of receiving subroutine arguments one by one: my ($origNode)=$_[0]; my ($newNode)=$_[1]; Accept a list of them all at once: my ( $origNode, $newNode ) = @_; You used to need the ampersand to invoke a subroutine in Perl4 ( pre-1995 ). It does have a special, rare use in Perl5, but if you don't know what it is, you don't need it. You almost never need C style lops: for (my $i = 0; $i &lt; $n; $i++) { ... } Most of the time you want to iterate over array elements or hash elements. If you really need to iterate over a range of numbers, use the range operator: for my $i ( 0 .. $n-1 ) { .. } Suffix conditions and for loops can save you a bit of space, and help simplify some simple code. if (isMenuNode($child)){ processNode($child); } becomes processNode($child) if isMenuNode($child); or processNode($child) if isMenuNode($child); A suffix for loop uses the defaul $_ and looks like .. processChildNode( $_ ) for $node-&gt;getChildNodes; Of course you were actually doing more than that one statement in that loop, but that's what it would look like. Trivial if/then/else blocks can use ternary conditions: &lt;pre&gt; if ( a() ) { $var = b(); } else { $var = c(); } becomes $var = a() ? b() : c(); some style guides prefer $var = a() ? b() : c(); Nothing looks too long, some of it looks too verbose in a Java / C / Pascal mind-set, but you'll get used to compactness over time. I would consider moving everything into a module, and having a minimal .pl file use My::Module; My::Module::run( @ARGV ); That way you have the option of building some or all of the functionality into a larger program. I like using Getopts::Long to handle command line args, and Pod2usage to display POD documentation, but in this case your command line args are trivial.
 sub subroutine{ my($arg1,$arg2,$arg3,...)=@_; Very readable, cuts down on lines significantly.
Why not just do something like this: (psuedo-code) ARR_LEN = n arr = [0..n] biggest = 0 for(i = 0; i &lt; n; i++){ if (arr[i] &gt; biggest) biggest = arr[i] } print("The biggest number is %i", biggest) Of course, you could always use the max function like perlgeek said.
Sweet, I was trying something to this affect but still couldn't make it click. I'll try it again.
Without going into the details about business logic -- I'll assume you know more than I do about that here -- there are some style things you should probable fix here. **Command line options** While it's technically ok to use the `@ARGV` stuff directly, take a look at using [GetOpt::Long](http://search.cpan.org/perldoc?Getopt::Long) or similar module, which allows you to do things like `perl myscript.pl --remote=foo.xml local=bar.zml` or whatnot. Also, said modules are _very_ flexible and allow for pretty much any sort of logic you could want, without you having to worry about parsing `@ARGV` manually. **Subroutine prototypes** Don't use them. There is almost no reason in modern Perl to use prototypes, with the rare exceptions of handling XS (libraries written in other languages) modules or some very, very specific use cases. The general alternative is to use named arguments or to pass a hashref. A manual way of doing this would be something like: sub foo { my @args = @_; my $opts; if( ref $args[0] eq 'HASHREF' ) { $opts = $args[0]; } else { %$opts = @args; } # do stuff } And call it like `foo( bar =&gt; "baz" )` or `foo({ bar =&gt; "baz"})`. Most people, especially for things that aren't really an API just use a list and keep track of the order of arguments with `my ($bar, $baz, $blee) = @_;` and call 'foo('bar', 'baz', 'blee');`. Also, I am not un-hungover yet and make not guarantees that syntax is correct. ** Stylistic nitpicking** Put your `use` statements up top. Especially the `use constant` and module ones like `use XML::DOM`, waiting until halfway down really only makes it harder to read and determine what modules are being used. **Suggestions on a rewrite** Briefly looking over your code, you might be able to accomplish this task with [XML::TreeBuilder](http://search.cpan.org/perldoc?XML::TreeBuilder) and a whole lot less pain. For documentation, see the link and remember that in that world, the XML::TreeBuilder and XML::Element modules are just subclasses of their HTML:: versions (I know, backwards). 
It's OK if you're shifting the instance off in a method call and you're going to use @_ for the actual method params later: my $self = shift; map {do something} @_; Otherwise usually best avoided.
Defaults are done better with ||= and //=.
You're absolutely right, of course. In either case, the caller (copy/paster) of the function needs to be aware of the edge condition.
This isn't really daemonization. This is just the equivalent of "start /B perl yourscript.pl" it looks like. You want Win32::Daemon. But it's not on CPAN. You'll have to get it from http://www.roth.net.
Daemonization only requires that a program is backgrounded without a remaining console window and is detached from any parents. Win32::Detached does this. start /B will not detach, but only remove the window. Also, i wanted to have something like this on CPAN so it's tested, documented AND most importantly: easy to find.
Minor thing, as people have covered a lot of the other stuff. Near the top, you check your argument files with -f &amp;&amp; -r. -r implies -f, so you can simply test for that. Error messages for system calls end up in $!, so you should tack that on the end of the die() message. Thus the user will see that the file doesn't exist, or there's a NFS error, or bad permissions.
I came here to say this. You are a scholar and a gentelmanne.
&gt;Do not use the indirect object syntax. Always say my $obj = Class-&gt;new; &gt;Never say my $obj = new Class; I've never understood this. When would you run into problems using the indirect calling method? For those of us who started out with C++ and Java the indirect method is the most comfortable. We're already used to: my $bob = new Bob(); or my $bob = new Bob(name =&gt; 'Robert'); You just have to ensure that when you're calling a class method without any arguments you add an empty parentheses pair there. For people with the kinds of background that would prefer indirect calling that would be second nature anyway. In any case I've always used it and it has never failed me. The only time I use Class-&gt;new() style syntax is when I'm instantiating a class whose type is determined at runtime. E.g. my ($type, $calculation, @args) = @_; $type-&gt;$calculation(@args) 
I have to maintain multiple systms which rely on Win32::Daemon, and I really wish it was still being maintained actively. *sigh*
Indirect syntax is bad because it introduces ambiguity and makes parsing Perl difficult. Hopefully it will be removed from the language in a later release, but it will be harder to do that if people keep using it. It also leads people to mistaken impression that `new` is something special. It is just a method call like any other, so why use a different syntax for it? I also think (new Class opt1 =&gt; 1, opt2 =&gt; 2)-&gt;method; is a lot more ugly than Class-&gt;new(opt1 =&gt; 1, opt2 =&gt; 2)-&gt;method;
TMTOWTDI. I find the people who are wont to use indirect syntax will usually not chain their methods like you've described. They'll typically instantiate the object first and then make method calls (chained or otherwise) on them. Your second example could also be converted into its own initializer (which is what I do) to make chaining a method call on an initializer unnecessary. In some places you'll find code such as the following in my work: create Entity(name =&gt; 'Name', type =&gt; 'Type'); which is an initializer to create a new entity with specific validations vs. load Entity(entity_id =&gt; 1); which is an initializer to load an existing entity which has no validations since those were taken care of at create/save time vs. new Entity(); which is an initializer to create a blank Entity that has no validations but can later be save'd which is when the validations take place. You could also call them using direct syntax or using a chained validation method call off the new method but there's no need. Arguably this is more readable but maybe it's not to you. Which brings me back to TMTOWTDI.
&gt; TMTOWTDI I've seen code which uses lines in a temporary file to store data because the original programmer didn't understand or didn't trust arrays. Don't use TIMTOWTDI to excuse bad practices. The dative syntax can cause failures in at least half a dozen ways. It's fragile, especially because the intended parsing of such a construct depends on the *order of declarations* within your source code. If you insist on using it, do everyone a favor and read the Perl 5 lexer, specifically `intuit_method`. Once you understand all of the heuristics, feel free.
&gt; read the Perl 5 lexer, specifically intuit_method. Once you understand all of the heuristics, feel free. Thanks for the pointer; I'll take a look at that. As far as your original example of using a file to store data, that's common practice in the shell scripting world. Perl's entire raison d'etre was that it combined the functionality of awk, sed and bash into one platform that was much more than the sum of its parts. Does it allow you to work with awk-like syntax (think BEGIN, END blocks)? Yes. Does it let you work with sed-like syntax (think regex and in-place file editing)? Yes. Does it allow you to have shell-like constructs (think file test operators, loop syntax, etc)? Yes. Depending on the background, people will use perl differently. Just because it doesn't fit the way you use it based on your background doesn't make it wrong. It just means there's more than one way to approach a problem and perl will let you use any or all of those ways with ease. That is the strength of perl. I put it to you, then, that even the guy who didn't know about arrays in perl (probably because he'd never used arrays in shell scripts) was doing things just fine. It's not how I would do it but it's not wrong. Similarly, while my background pre-disposes me to using indirect method calls, yours most probably doesn't and therefore you use method calls that you picked up in your experience. They're both right because perl supports both of them and encourages the fact that there is more than one way to do it.
&gt; I put it to you, then, that even the guy who didn't know about arrays in perl (probably because he'd never used arrays in shell scripts) was doing things just fine. It's not how I would do it but it's not wrong. Where do you work? I want to stay away from it. If you are arguing that getting the job done is the most important thing, that is one thing, but there is no way you can call code like that correct. There is more to correct than just working. &gt; They're both right because perl supports both of them Perl 5 supports many things that were mistakes (bareword filehandles, formats, the two argument version of `open`, prototypes, symbolic references, and so on). It continues to support them for reasons of backwards compatibility, but you should not be using them for new code. Please get a copy of [Perl Best Practices](http://oreilly.com/catalog/9780596001735) and read it. Pages 349-350 deal with indirect object syntax. I will leave you with the last paragraph from that section: &gt; Indirect object method calls are ambiguous, brittle, fickle, and extremely context-sensitive. They can be broken simply by moving them about within a file, or by declaring an entirely unrelated subroutine somewhere else in the current package. They can lead to complex and subtle bugs. Don't use them.
&gt; I put it to you, then, that even the guy who didn't know about arrays in perl (probably because he'd never used arrays in shell scripts) was doing things just fine. It wasn't Perl, and even if it had been Perl, it's still a very silly way to solve a problem. &gt; Similarly, while my background pre-disposes me to using indirect method calls, yours most probably doesn't and therefore you use method calls that you picked up in your experience. I actively warn people from using the dative syntax because it is fragile and unreliable -- but I care far more about helping people write working code than about adhering to some silly belief that TIMTOWTDI means that bad code is just as good as good code. (Consider that Perl 6 removes the ambiguity from dative syntax for very good reasons.)
I'm responding to my own comment so I can respond to both cowens and mr_chromatic in one post. &gt; Where do you work? I want to stay away from it. Personal attacks aren't necessary :-) &gt; If you are arguing that getting the job done is the most important thing, that is one thing, but there is no way you can call code like that correct. There is more to correct than just working. &gt; some silly belief that TIMTOWTDI means that bad code is just as good as good code. My argument isn't about the proper way of doing things taking into account forward compatibility (perl6) and best practices. My argument was against limiting the meaning of TIMTOWTDI. My position is that while TIMTOWTDI would indicate that two seasoned perl programmers might create the same bit of proper working code in entirely different ways, it also indicates the different ways of using perl as it was originally intended to do. perl started out as a superset of awk, sed, tr and bsh. It retains a lot of the constructs of all of those platforms and various commandline switches make it function like any of those platforms (see the perlrun man page). Therefore, while you can argue that perl code written by someone with an awk background isn't *proper* perl in that it doesn't follow perl best practices, it doesn't make it incorrect. My argument for the indirect object calls wasn't that they are proper. Clearly perl6's abandonment of that syntax indicates it's not proper (i.e. following best practices etc) but for people who come to perl from e.g. a C++ or Java background the indirect object call is more comfortable than the regular way of calling a method on an object; much like the awk programmer is probably more comfortable using BEGIN/END blocks to initialize/output variables respectively rather than writing a proper perl script. From that point of view, the indirect object method syntax is no less correct than the regular method syntax because TIMTOWTDI. It might not be proper but it's not wrong. Does anyone who uses the indirect method call syntax need to be aware of the pitfalls of using it? Sure. Are they wrong to use it? Not unless they're using perl6 or expect their code to run in perl6. To give you an example that might explain things better: I typically write my conditionals like this: if (1 == $n) { doSomething(); } Most people write conditionals with the constant on the right side, like so: if ($n == 1) { doSomething(); } Now if you write it like the second example, there's a distinct possibility that you could miss one of the = signs and make that an assignment instead. That's an insidious, logical run-time bug which can be avoided by using the first way of specifying a comparison in the conditional (that results in a compile-time error vs. a run-time error). However, the second way is actually more readable and typically makes more sense. So, in the interests of proper code should everyone write conditionals like in the first example? Not necessarily. But everyone who writes code the second way should be aware of the pitfalls of that method. Does it make either of the two conditional statements wrong? No. Does it make one better? Yes. Are both correct? Yes. Is there more than one way to do it? Yes. I hope that clears up my position. Thanks for a lively debate :-)
You're confusing the issue. Yoda-style comparisons won't accidentally break because of changes in other parts of the program. Dative notation can and will. (The comparison to C++ and Java object models irrelevant because their object models are different--in particular, `new` is a keyword in both languages.)
Did you write this? This is great, thanks
I did not write the original incarnatin of this module, but picked it up from CPAN. I did however completely rewrite it, document, package it up, etc.
Ah, you are correct. I thought there was also a flag to detach the process using *start* but apparently not.
Thanks for looking it up. :)
&gt;my $var = shift || 'default val'; That's not as useful as it could be, since it uses 'default val' if `shift` returns a value that evaluates to false (e.g. `0`). In Perl 5.10 and later, the more useful `//` (defined-or instead of normal or) can be used: &gt;use 5.010; &gt;my $var = shift // 'default val';
This merge logic is quite custom and may become more complicated in the future so I doubt I'd have any library do the work automatically, but thanks buddy!
mobiles are hard to type on, sorry if i have made anyone [sic]
also, Yoda-style is now largely deprecated with the warnings such as: $ perl -Mstrict -Mwarnings -E'my $x; if ($x = 10) { say $x }' Found = in conditional, should be == at -e line 1. 10 
Your statement about `-r` is wrong: autarch@houseabsolute:~ $ perl -E 'say -r "/"' 1 The perl docs aren't well written on this topic. The permissions tests work on directories as well as files (and links, etc.)
Old and grumpy C hacker here; I don't get what closures are useful for. Is this just to avoid using globally scoped variables?
It's encapsulation and abstraction all in one. You can get the same effects with other approaches, but sometimes this approach is the simplest and most flexible.
Closures simply give your callback a some "context". So the code in the sub can have a little more info than just what its given when called...
[Higher-Order Perl](http://hop.perl.plover.com/) explains a lot about this and might be useful :)
effect, not affect. Keep up the good work learning though! The top comments are really useful right now. 
5.12 and up. 5.12 is available to anyone. sorry if your distro ships with five year old code
Any specific reason not to support 5.10? It's what most distros still ship, and I haven't really missed any of 5.12's features much yet.
because there are cool features in 5.12 and i think people want to use them. we're not talking about core modules here, but stuff on cpan. if people insist on staying on 5.10, then they can subsist on the modules they already have or what is in the core. this is the same problem webdevs have with ie6. the longer you support it, the longer it will live. just rip the bandaid off and move forward.
&gt; Any specific reason not to support 5.10? 5.10.1 is the oldest I want to support, and even that is three stable releases old.
(serious question in this post) Hey all, check this out. I just couldn't wrap my head around it. I learn by seeing and doing, so I googled the shit out of this problem and found the solution and made it my own. I had to add a few things to make it work properly, but, in my opinion, I learned the concept. I don't grasp the actual workings of the concept, but I can repeat it if I have to. I've done this alot in my tech career. I didn't grasp how it actually works, and my ADD brain goes into overdrive trying to figure it out, which gets me nowhere. But once I see how to accomplish a task, I can repeat it easily, and somewhere thereafter the internal workings of it click for me. Is this wrong or am I just compensating for a learning disability? TL;DR I fake it until I make it.
Congrats and thanks for all the hard work. I've already had the opportunity to point an interested classmate to the book and look forward to hearing about their first dive into Perl.
Congrats. I think this could use a post on r/programming too (if you're brave enough :)
Be my guest!
ordered from amazon. 
I'm brave. [Duly submitted](http://www.reddit.com/r/programming/comments/e50mv/modern_perl_new_book_available_in_print_and_free/)
If you see a C API with callbacks, you'll notice that it probably provides a null pointer to some piece of data that you can supply at some point. This is needed to give the callback context information. If you have closures, you don't need that. The closure can simply access the lexical variables from the outer code. 
&gt; Any specific reason not to support 5.10? That really depends on what you want to do. Some syntax extension modules greatly benefit from new C level APIs that are new in 5.12. There were also many Unicode fixes in 5.12, and some handy new features that I'd like to use ASAP (though no pressing need for those).
Congratulations... and thanks!
Is Horstmann style the prevailing indent style for perl these days? I'll order it none the less.
Amazon UK have it despatching in 4-7 weeks but there is a Marketplace seller that is despatching from the US in a few days. I've added it to my wishlist and will be buying it at the end of the month. Thanks for the free PDFs. I wish more people did this as you get the convenience of having it on an eReader and also the convenience of being able to flick through the hard copy for reference.
That is a great point. The context of the code above is that you would be expecting some sort of text value that is non-zero. Thanks!
Congrats! And thanks, awesome work, as always. :)
I ordered the book, downloaded the pdf, can't wait for the movie. Thanks for all the hard work. I have several students who are using Perl on various projects. I'm going to share this with them and try and get them away from "ancient" Perl.
This kind of attitude annoys me, the assumption that everyone using an open source tool not only uses it but has enough time to involve themselves intimately with the community and pick up on all the changes to how things should be done now. If it works, it works. People will learn and change code when methods like that are removed from code otherwise they have no incentive or reason to do so. If opening files like that is of serious enough concern that they want people to change the method, but without breaking the scripts in the process, chuck it in as a warning when the script executes.
Agreed. The change was made to address one odd ball situation that doesn't work as you might expect only to create a new odd ball situation that doesn't work as you would expect (ie open fh, '&lt;', '-';) and for most of us will likely occur much more often. Change for change's sake. 
Leave tags for what was stable at a given core release in your revision control. Apply patches if someone pays you for them. Don't bother back porting new features to older core releases unless you see a demand for it.
If it works, and it's clear, and it's not slowing anything down, why would we want to change it? Just to prove that we're au courant?
I'm relieved to see this attitude already expressed and supported. I probably would have given the author a "blank stare" just while attempting to contain my mounting rage. They will have to forgive me for being so ignorant to use methods that work just fine for any purpose I've had, and for needing to be convinced to change such ways in favor of newer 3-parameter methods further than simply being assured they are "safer." The author makes the mistake of assuming we agree with them, ranting rather than explaining.
If you use a tool on a regular basis then you should take the time and effort to understand current best practice. Every time I see an unjustified use of two argument open I think to myself "This person doesn't understand shell injection attacks". It is the sort of code smell that engenders general distrust of an entire codebase. 
If someone is in a position to leak something to my perl scripts in such a way that it will interfere with file handles I've got far more significant problems.
True, but my personal experience has been that one minor code smell often accompanies several major ones. All programming languages have certain aspects that need to be approached with care. C: buffer overflows, bad pointers ... Haskell: space leaks, lazy file handles ... Perl: circular references, bareword file handles ... Javascript: 'this', function scope, '==' vs '===' ... In Perl, if you have to opportunity to bypass a call to an external shell then it should be taken. The same goes for global identifiers like bareword file handles.
Most of the comments here ignore that the first thing he mentioned were the bareword file handles, which are very definitely bad in any context, as well as the little fact that he didn't just complain, but also educate them. Please read more carefully instead of just knee-jerking.
It's pretty impressive of you to find both (what I think we've mostly agreed is) a douchey blog post and a blog post that called out the douchey blog post. If I had a hat on, it would now be off to your link-fu.
Why is three arg open so much better?
It could be a problem if the filename is from (unvalidated) user input. With three args user can't overwrite unwanted stuff with your persmissions, I guess.
No, the general concensus is that the blog post is good and is pointing out an actual problem. Most of the people who deride it are of the type who can't be bothered to actually read something before getting all high and mighty. For example the fact that his main complaint were bareword file handles is completely ignored in quite a few comments talking about it. They also miss how it's his **job** to do code review to catch such things and educate his coworkers and how they're actually receptive to what he tells them and how his managers support it.
I read the post, though. I still think he's(?) being a bit of a douche. I agree with him, but I think he's selfishly muttering to his peers in the ivory tower about the peasantry's ignorance, rather than just taking the same time to make an *informative* post which would be a small step in solving the problem he's explaining in such length. The Perl community is complacent due to the infrequency of important updates, so if we believe in the need to change status quo practice, we need to inform each other--loudly, but politely and succinctly. This blog post is "douchey" because he chose to rant rather than inform, and once someone is up to speed, all his observations are obvious. Without the informing part, though, he's simply complaining about people not knowing something.
&gt; rant Either you have not read the post very carefully, do not know what that word means or are doing a whole lot of projecting. He's calmly musing and thinking out loud. He is not even asking people to do anything, but just inviting thoughts.
Okay, I apologize that rant wouldn't be a fair word. To be completely benign, I'll just say "present observations." Would it satisfy you to simply ask that he put his explanation of the problem and the modern solution immediately after the code snippet, and leave out my own observations?
Yes, that would be a perfectly fine way to handle this. Being **constructive** is always good and useful, especially when packaged in a way that will not leave the recipient with an unnecessary emotional charge. :)
It also removes unnecessary interpolation in the file argument. It also allows you to use IO layers such as open(FH, "&lt;:utf8", "file") See `perldoc -f open`. 
Wish I'd known about this at the time I spent a day writing 7 lines of incredibly ugly vbscript :)
ask my friend: http://twitter.com/#!/space_cadet
A better solution: Quit exporting subs. Have you seen the memory footprint you create by exporting subs repeatedly into various packages?
This module is not about optimization, its purpose is convenience. Nevertheless, i thank you for the insight. I was not aware of this.
Sorry, it seems like a nice convenience module and all. Didn't mean to redirect the conversation to my pet peeves. After having had to debug memory usage issues in some code that just did a 'use POSIX' in a few modules, I rarely, if ever, will export or import methods. Every 'use POSIX' adds 1MB to the process, FYI, and it was done in several places. That adds up pretty fast. Obviously, most modules don't export quite so many methods (especially by default), but I had previously thought exported methods were just references somehow instead of just being copied into the new namespace. It's also more readable, IMO, to fully qualify the methods with their namespace so you know where it came from.
&gt; Just to prove that we're au courant? Safety.
About 50 bytes per? What's created beyond a GV?
Nice, I usually go with Class::MOP::load_class, but it's nice to know I don't have to depend on the MOP for this
This was extracted from Class::MOP for just that reason.
They are just references. Your claim is, as far as I can tell, wrong. Here is a lame program: perl -E 'sub pm { say `ps -o rss -p $$`; } BEGIN { pm; } use POSIX; BEGIN { pm } { package X; use POSIX } BEGIN { pm } { package Y; use POSIX } BEGIN { pm }' You'll see that the *first* "use POSIX" chews up a lot of memory. After that, not so much. POSIX uses AutoLoad, so subroutines are not actually loaded into memory until we know they're needed. If you import *everything*, everything is compiled the first time. After that, each successive import is cheap, setting up only aliases in the symbol table. Importing routines is not expensive in terms of memory. It has a cost, but the cost is very low. Also, keep in mind that POSIX has many, many more default imports than most modules.
Did that blog post just tell people not to hack things together hastily in Perl? I thought that's what it was for.
&gt; Did that blog post just tell people not to hack things together hastily in Perl? Not at all. It said "code appropriately".
I can get behind that. My first comment was only half-serious. Perl does have a reputation for encouraging quick and dirty code, but that's obviously not the full story. 
I think it has this reputation only between non-Perlists.
It's easy to argue that Perl 5 has some of the wrong defaults in 2010, but it's also very difficult to build a language which allows you to keep existing code working while allowing people to write new code which follows the right defaults.
Perl let's me explore quick and dirty avenues, then refactor to competent code when a solution is found. Yes you need to know what you're doing, but you need to know what you're doing when you're tackling hard problems anyway.
Perhaps this has been fixed in a more recent perl? It was a few years back I saw the behavior. I was dumping memory usage before and after every module loaded and every 'use POSIX' added about 1MB.
No, this is stuff that hasn't fundamentally changed since the beginning of Perl 5. Exporting just makes a new symbol table entry, creating an alias to a value that already exists. Hell, even the string containing the *name* doesn't have to be copied if it's the same between the exporting and importing packages, because HEKs are shared. It's possible that there was some incredibly stupid interaction between Exporter and AutoLoader that caused needless recompilation, but I don't *think* so -- AutoLoader itself has also been around since the dawn of 5.000 and I've never heard of such a bug. :)
thanks for signing up to our community and contributing nothing other than to plugs for your shtty blog.
The HTML link is broken. The current version appears to be [here](http://www.greglondon.com/iperl/html/iperl.htm). Pedagogically speaking, I have some real issues with the way the text is presented. Lexical scope and lexical variables are only introduced about halfway through in sections 4.4 and 4.5, despite 'my' being used extensively throughout. And maybe it's just a conversion issue, but there seems to be no indenting in the code samples in the HTML version which makes it hard to read (and they're bizarrely double spaced which is even uglier.) There are also some really confusing discrepancies, like the fact that the author seems to claim that the array version is always spelled `foreach` and the three argument C version is always spelled `for`, but the two are synonyms and can be used interchangeably. Moreover in the section on control flow he lists only SINGLE_STATEMENT if (BOOL); ... while neglecting to ever mention SINGLE_STATEMENT unless (BOOL); SINGLE_STATEMENT while (BOOL); SINGLE_STATEMENT until (BOOL); SINGLE_STATEMENT when (EXPR); SINGLE_STATEMENT for (LIST); SINGLE_STATEMENT foreach (LIST); Nor does he ever mention IO using the empty angle brackets &lt;&gt;, so someone that read this book would be completely unable to write something as simple as print "\t\t$_" for (&lt;&gt;); He also uses lexical filehandles (good) without using the three argument open (bad). All in all I'd give this a pass and not recommend it to anyone. You can get the same density of information from `perlsyn`, `perldata`, `perldsc`, `perlop`, `perlsub`, and `perlfunc` without all the glaring omissions.
It encourages the ternary operator for if/elsif/else blocks. This is bad. It should at least mention that creating a new sub is the much more sane solution.
 SINGLE_STATEMENT unless (BOOL); SINGLE_STATEMENT until (BOOL); Well, you don't really want to use these. They make it only hard for non-native english-speaking folks to read Perl, and sometimes even for natives. (Especially when you devolve to "unless !$var".)
How is Magpie different from things like Test::MockObject or this? local *Package::func = sub {};
&gt; Lexical scope and lexical variables are only introduced about halfway through in sections 4.4 and 4.5, despite 'my' being used extensively throughout. Perhaps you missed the comment in the first block of code in Section 2.1 when he introduces variables: my $diameter = 42; # The “my” keyword declares a lexical my $pi = 3.1415; # variable. If you don't know what my $initial = 'g'; # that means, don't worry about it, my $name = 'John Doe'; # it will be explained later. my $ref_to_name = \$name # Specifically, in section 4 I have to agree that the formatting leaves a lot to be desired, making the comment hard to spot in the first place. Given that it's specifically billed as a introduction for impatient (but experienced) developers, I don't think it's all that bad in terms of content. Sure, he skims over a lot of stuff, but I would have thought that it's usually what the impatient kind of reader wants. &gt; You can get the same density of information from perlsyn, perldata, perldsc, perlop, perlsub, and perlfunc without all the glaring omissions. I'm inclined to agree in terms of the quality and coverage of the information. But Perl's documentation, while complete, isn't perhaps the best source for the truly impatient. There's a lot of wading around that must be done to find what you're looking for (speaking as someone who has been wading around in it for 15 years and still gets frequently lost). 
What? Nonsense. `unless` can be extremely readable. For example: for my $x in (@list) { next unless defined $hash{$x}; ... } or sub foo { my $arg = shift; croak "bad arguments" unless defined $arg; .... } These are extremely common perl idioms. I count 7032 instances of the use of `unless` in the core perl 5.12.2 modules after stripping all POD and comments (so that does include some in string literals, but the vast majority are keywords.)
It does a lot more than just providing you the functions. It provides a way to inspect method calls, and do so in a more general many (see argument matchers). Test::MockObject is quite nice, but I find Magpie's more DSLy interface a lot more workable
Magpie seems to abstract away some of the tedious details of using T::MO and T::MO::E. I haven't used it yet, but I'm looking forward to doing so.
Saw the part about non-native? For me and quite a few other people i know, all of whom have english as a second language, unless just plain takes longer to process in code than "if !". (It's also more typing.)
&gt; Saw the part about non-native? At some point, a non-native English speaker who learns how to program Perl is going to have to learn the meanings of various Perl keywords, including `unless`.
You're missing the point. It's not about **knowing**, it's about being able to recognize it **quickly** while skimming through code.
I have difficulty believing that a non-native English speaker skimming code quickly has an easier time understanding a single token than two tokens, especially one of them a vertical single-character symbol (and did you complain about `!$var` a couple of posts ago?).
I'm not sure i'm getting what you're saying and I have the feeling you might be misreading me. I'm saying this is easier to read: do_stuff() if !$var; Than: do_stuff() unless $var; This is because the meaning of "if" is completely ingrained in anyone speaking english, since it's one of the basic logic constructs in the language itself; while "unless" takes a certain amount of time to deparse into "if !" for a non-native, due to its relative rarity in common english. In case you're remotely familiar with japanese: It just plain isn't a "particle", but instead an actual word. And no, i wasn't complaining about "!$var", but about "unless !$var", because it is a double negation. This is something that can very easily happen, especially with programmers that aren't very conscientious, since adding a single ! is less work than changing an unless to an if.
&gt; ... "unless" takes a certain amount of time to deparse into "if !" for a non-native, due to its relative rarity in common english. I'm a native English speaker and *I* have trouble with a semantically significant single-character vertical operator immediately adjacent to a sigil, so unjustified assertions like that (do you have studies to cite?) don't convince me. What's easier to see while skimming code, a six-letter English bareword with concomitant whitespace or a single-character vertical symbol abutted against another single-character symbol?
Not see, recognize. "if !" is easier to recognize because you don't actually need to read it. You know what it is just plain by its shape, which is what skimming is: You glance over a body of text looking for recognizable shapes. It is easily recognizable without focusing on the individual letters since there is nothing else that looks that way. In order to recognize "unless" you need to actually read it if you're not already extremely familiar with it. It is a 6 letter word with a non-unique shape, so one needs to actually identify enough letters to be sure what it is. I'm sorry i don't have studies to cite. I'm merely using observations (unless in code acts like a speed bump) of me and people i know, as well as my experiences with speed-reading to try and explain why this may be. On a sidenote: If you have trouble with !$ constructs, a highlighting scheme that creates higher contrast and color value differences between operators and variables might help. (I found the scheme of notepad++ very pleasing in that aspect.)
Do you really believe that the difference between: do_something() if $some_var; ... and: do_something() if !$some_var; ... is *more* obvious during a casual skimming than: do_something() unless $some_var; ... ? I've spent far too many years fixing transpositions in mistyped variable names and fencepost errors in `&lt;=` and `&lt;` and `&gt;` and `&gt;=` comparisons to believe that.
[Yes](http://imgur.com/PsVSI.png). The visual signature is a LOT more unique in the second case AND remains true for other languages as well. More importantly though: With the first and second case i do not need to think about the meaning at *all*, while the third case always requires some mental processing to remember and apply the reversal of the meaning of the conditional following the "unless". &gt; I've spent far too many years fixing transpositions in mistyped variable names and fencepost errors in &lt;= and &lt; and &gt; and &gt;= comparisons to believe that. I don't even know what that means and what it has to do with unless. :/
One of the joys of using Perl is interpolating perl -MList::Util -e 'print "$_ =&gt; $INC{$_}\n" for keys %INC' If we add the -l flag, we can leave off the newline perl -MList::Util -le 'print "$_ =&gt; $INC{$_}" for keys %INC' Though recent versions of Perl have say perl -MList::Util -E 'say "$_ =&gt; $INC{$_}" for keys %INC' But do we really need the keys? perl -MList::Util -E 'say for values %INC'
Install pmtools. % pmpath Moose::Role /usr/lib/perl5/site_perl/5.12.2/i686-linux-thread-multi/Moose/Role.pm
Thanks for the kind words! This is my first CPAN release that feels like it might actually be useful to other people, so I'm very excited to get any feedback. If you do have a play with it, please don't hesitate to let me know any thoughts :)
&gt; With the first and second case i do not need to think about the meaning.... Are you *skimming* code or are you trying to *understand* code? Pick one. &gt; I don't even know what that means.... The six-character, whitespace-surrounded keyword `unless` is much more visually distinctive than a single-character, abutted typographic symbol `!`, especially when people make single-character, abutted typographic symbol errors *all the time*.
Both i guess? I'm honestly not sure where i or the conversation is going with this anymore. All i can know is that appearance of unless in code slows me down, even five years after starting to write Perl and twelve years after starting to code. I have little hope that this changes and friends of mine have made the same observation. As for your second paragraph: I admit defeat. My english isn't close to being good enough to get what you're saying at the end there. As for the conversation itself: We seem to disagree entirely on this and as much as i adore every single of your blog posts, i don't think there's any point in continuing. I lack the ability to word my thoughts in a lucid manner that could convince you and neither are your arguments effective in convincing me nor your claims in line with reality as i perceive it. I'm glad that you did engage in it though.
&gt; My english isn't close to being good enough to get what you're saying at the end there. A word is easier to identify and understand as a unique piece of syntax than a single piece of punctuation, especially if the single piece of punctuation is right next to another piece of punctuation.
Oh, that part i got and simply disagree with. A big, bold, dark blue vertical line next to a bright thin orange variable is much faster for me to get than a word that is similar to a few other keywords in perl syntax in shape. I mean, how many single vertical operators could possibly be prefixing a variable that closely? I meant the last part of that sentence when i said i don't get it. I guess you're talking about a typo, but i can't remember seeing any typo frequently that matches the current subject matter; and i just can't make out the combined meaning of the words with confidence to see if i'm guessing wrong.
You can't see where $schema is defined, but judging by that code style I'd bet theres some SQL injections in there somewhere.
Time to start a religion called DROP TABLES?
Either they use Perl or the stock "computer code" clip they used happens to be nicely syntax highlighted Perl.
[Learning to Count on Perl at the Census Bureau](http://www.oreillynet.com/pub/a/oreilly/perl/news/census_0101.html)
Aww, little [Bobby Tables](http://xkcd.com/327/).
I think Larry wrote Perl while working for the Gov't in some capacity so I image it's used all over the place.
I think perl zealots are the only ones guilty of using the leatherman on large projects. And there was a time when I was guilty. Dear God, the time I wasted forcing Perl 4 to fake OOP... ugh...
The use Perl. A friend used to work there. They even use Moose from what I hear.
Please, link to http://bobby-tables.com/ where there are actual answers.
I love how the Perl and Python examples are like, 3 lines. And then, PHP.
Honestly, most ORA material on Perl is.. dated. I can't speak for some of the newer things, but, here are two free books that you _should_ read, in order: [Beginning Perl](http://www.perl.org/books/beginning-perl/) and [Modern Perl](http://www.onyxneon.com/books/modern_perl/index.html) Both are free, but if you find them useful, as always, buy a paper copy and/or donate, as appropriate. Regarding your initial question.. it doesn't really matter _where_ you learn how to code, but more than you _can_. Demonstrate this and people will hire you. 
Modern Perl was an awesome read
You're correct, it was the Jet Propulsion Lab (belongs to NASA, as far as I know). But I think the real reason for the wide spread use of Perl is its usefulness, not who wrote it.
But isn't *Beginning Perl* itself outdated? It teaches things like bareword filehandles, which modern Perl (and *Modern Perl*) eschews. [The course as described](http://www.oreillyschool.com/certificates/perl-programming.php) sounds pretty reasonable to me and doesn't seem to be linked to any ORA books. I don't know what you need a certificate for, but I don't see any harm in it either. [Randal L. Schwartz, it seems, would disagree](http://blogs.perl.org/users/randal_l_schwartz/2010/11/perl-certification---still-snake-oil.html). 
If Larry gets certified then I'll consider it.
I think a perl certification is roughly equivalent to a gold medal at the Special Olympics. This is coming from an avid perl user.
I don't think the newer editions of Beginning Perl use bareword file-handles, but I like to think [the use CORE::open is outdated anyway](http://www.perlmonks.org/?node_id=763565). Not all interfaces are equal.
They may be using $dbh-&gt;quote(). Or data is cleaned before - with taint mode turned on it is hard to miss something.
I'll agree with Randal as well. In my experience hiring people I've noticed an inverse relationship between those who hold certifications and their actual (practical) ability.
I would hang mine up next to my lunar property certificates.
Thanks for this. We recently started using Factories in PERL for some new code we're rolling out, and this helped me understand them much better. 
Please don't ever use PERL, it is not an abbreviation. Perl is the language, perl is the interpreter. If you use the all-caps form in job ads you're likely to shoo away good perl coders because it's a sign that you don't really understand perl.
haha, that's funny. I wrote it out Perl, then changed it, because I thought it was actually PERL, and didn't want to be an idiot. My bad. 
Don't worry, we all made this mistake at some point :) It's odd how hard it can be to erase history!
Thanks for the feedback. As my question implied (or at least intended), I am concerned for the instructional quality/relevance/environment. Not so much the certificate.
The only way to be proficient in a language is to actively work in it. Having a certificate just means that you were able to attend a class and/or pass a test. The best *certificate* I know of for any programming language is a sample of personally written code.
I'm surprised about the fuss over the certificate. Anyone who's had to tangle with a 12 year old, 87 lb Tae Kwon Do black belt knows the value of certification. For all the bandwidth burned over the certification non-issue, I would have liked to hear some insight into the actual educational value of the OReilly online learning program (in particular the perl courses).
Doubt it, it's almost certainly using DBIx::Class given my knowledge of one of the consultants working on it.
Thanks, spread the good word.
It's perfectly OK to write "PERL". We're not barbarians from the 90's anymore. Yes, it's not an abbreviation, but it can be if you like it that way. TIMTOWTDI, remember?
Take a look at [Symfony](http://www.symfony-project.org/). It's got a large community base and seems to be largely based on Rails. There's two choices for the ORM, Propel or Doctrine. From my experience (which was pretty limited) Propel was AWFUL. Doctrine I don't know about, so maybe it's better ;) good luck!
accept it on its own terms or move on even with a framework, you'll never be able to get around the fact that php is a turd 
I am aware of the nature of PHP as a language, but I will have to work with it, and I do not want to reinvent the wheel either (authentication, authorization, templating, dispatching, ORM, form managament, etc). I see that there are at least half a dozen of popular frameworks in PHP, I was asking which one is less thraumatic for someone with Catalyst experience.
Peter Scott is an excellent trainer who knows Perl well. I'm happy to vouch for him. (I know nothing about the course or program otherwise.)
I wonder how many copies I'd sell of a book called *Modern PEARL*. TIMTOWTDI, remember.
Was it as bad as DBIx?
[DBIx?](http://search.cpan.org/modlist/Database_Interfaces/DBIx)
*hug* Also http://cakephp.org/ was slightly bearable . But I haven't done web stuff in a long time and I just discovered catalyst so never going back.
I should mention that I've tried several permutations of the DirectoryIndex statement to no avail.
I ran into something much like this and wound up finding &lt;directory&gt; with AddHandler which worked while &lt;location&gt; with SetHandler did not, so I'd try something like this: &lt;Directory /var/www/perl/hostman/&gt; AddHandler perl-script .pl .cgi PerlResponseHandler ModPerl::Registry PerlOptions +ParseHeaders Options +ExecCGI Order allow,deny Allow from all &lt;/Directory&gt; This was pretty much a result of hours of voodoo, fruitless googling, and twiddling through permutations for me, though, so perhaps someone with more knowledge of Apache 2 + mod_perl might be able to actually explain what's going on or have a more sure solution. If you are looking for help with Perl, this site is the best I know of: http://www.perlmonks.org/ 
This did the trick. Thanks a lot!
Despite the fact that you obviously now have it working, it should be mentioned that you should not be using mod_perl unless your code is intended to directly alter the way Apache functions. If you're deploying a web app of some sort (CGI, etc.), you should be using modern technologies. For straight mod_perl to normal, check out [FastCGI](http://www.fastcgi.com/devkit/doc/fastcgi-prog-guide/ch3perl.htm). You may need to slightly alter your script. For something more "serious", check out the various frameworks. To quote the bot on Freenode/#perl: Catalyst, CGI::Application (and subclasses / extensions), Jifty, Continuity, Mojolicious, Dancer, Plack/PSGI, SweetPea, WebGUI.
I think he means DBIC
The only thing I can suggest is that it's probably not a good idea to use a trailing slash with Location, i.e. &lt;Location /hostman&gt; not &lt;Location /hostman/&gt;. I don't think it's wrong to use it for &lt;Directory&gt; though. 
Good stuff. I've played a little with Haskell and Perl6 myself. My feeling is that Perl6 could end up being positioned as "Haskell for mere mortals". Cross-posted to [/r/programming](http://www.reddit.com/r/programming/comments/ebyp1/haskell_perl6_haskell/) for good measure. 
I rather like Haskell. It is some pure functional programming.
What is state? Is state not a value which is a function of time?
That's till the python folk comes along and driving the masses away from it. I mean, haha, the syntax is *unreadale*!
&gt; All built-in functions that operate directly on array or hash containers now also accept hard references to arrays or hashes I want to get excited about this, but it's the sort of obvious and easy thing that should've been there years ago. Still, one less thing to complain about I suppose.
I'm a perl 5 kind of guy who was getting a bit worn out on a few personal projects i work on, so i decided to spend a week of my programming time to learn more Haskell. I had put a few good hours and a lot of reading and some notetaking into it about it before that. That just ended two days ago, and i'm still feeling a bit drained. Neat language, I'll be back. That dude's article though, he invoke thoughts of an upcoming week of starting to learn Perl 6. I think i will do that. I'll have to jump in sometime. tl;dr [Real World Haskell](http://book.realworldhaskell.org/read/) - [Learn you a Haskell](http://learnyouahaskell.com/) - [Hoogle](http://haskell.org/hoogle/) Relax your brain, it's like writing a mathematical proof. 
I honestly would not worry about reading any thing from O'Reilly when it comes to learning Perl. Perl Monks is one of the best sources you will find. Also if you have not seen it yet, perldoc.perl.org is grand.
When Java has a simpler and more elegant solution, you're doing it wrong.
Sweet jesus, I wish I had more than one upvote.
I wish I was leet enough to adopt one. :(
I need to code this in VBScript...
Didn't you hear that perl6 is vapourware? You aren't allowed to do anything cool with it.
You can start with submitting patches.
I keep forgetting that the flip-flop operator exists. I wonder if I'd find any if I went through my old code looking for places to use it. Can someone explain how the $x if 0; idiom works to create a closure? I've never seen it before.
With that mindset, you must think All Your Base is still fresh and exciting.
That could prove to be a very efficient way dispatching URLs. 
`my` has two components. One occurs during compilation and the other occurs at runtime. `my $x if 0;` creates storage for the lexical `$x` at compilation time. Because the condition is *never* true at run time, the value of that lexical never gets reset when control flow enters its outermost scope. (Perl 5 has an optimization which declines to reset these values until absolutely necessary. If you're familiar with its reference counting, this does not produce leaks, but it's more complex than I want to explain in *full* detail here.)
Also worth noting that this is available as a feature rather than a hack in `5.10`, as `state`. `perldoc -f state` for more info. state $foo; -vs- my $foo if 0;
The glob operator is another one that stores global state with the operator itself, and here's [a similar SO answer I gave](http://stackoverflow.com/questions/2633447/why-doesnt-perl-file-glob-work-outside-of-a-loop-in-scalar-context) about capturing that state with closures.
This is an interesting change. A few weeks ago I read something that mentioned that print STDOUT "Hello world\n"; is really just indirect object invocation syntax in the same way that my $foo = new Some::Object; is the now-deprecated form of my $foo = Some::Object-&gt;new; ... which explains why `print` has syntax that is seemingly different than most other functions, i.e. no comma between the filehandle and the list of arguments, and why you have to surround the filehandle argument with { } if it's a complex expression. But I had always wondered why if that was true that this doesn't work: $ perl -e 'STDOUT-&gt;print("Hello World\n")' Can't locate object method "print" via package "IO::File" at -e line 1. But now I know you need -MIO::File or this patch. 
In that case they are dereferencing markers. A $scalar can be a number, string or a reference to another object, be it a scalar, array or hash. By prepending curlies with the right symbol you tell Perl to treat the reference as if it was an object of the type you supplied with the symbol. In this case $#array means "last index of this array" and $#{$ref} means "last index of the array that $ref points at".
Thank you very much! If you have time, I have one more question. For the example directly after that, in which the author uses a temporary scalar to point to the array: for $i ( 0 .. $#AoA ) { $aref = $AoA[$i]; for $j ( 0 .. $#{$aref} ) { print "elt $i $j is $AoA[$i][$j]\n"; } } Could '$aref' just as easily be '@aref' and the routine re-written as follows? for $i ( 0 .. $#AoA ) { @aref = $AoA[$i]; #changed $aref to @aref for $j ( 0 .. $#aref ) { #changed $#{$aref} to $#aref print "elt $i $j is $AoA[$i][$j]\n"; } } Also, why do many examples not use 'my' when declaring variables? My understanding was that all good code does that; is it just for readability or did I miss something? Thank you very much for your answer! If your religion permits it, I wish you a thousand internets.
&gt; Could '$aref' just as easily be '@aref' and the routine re-written as follows? You could do this: @aref = @{$AoA[$i]} However it would copy the array, so writing to it would not modify the original. &gt; Also, why do many examples not use 'my' when declaring variables? My understanding was that all good code does that; is it just for readability or did I miss something? You are correct. Much of the perl documentation is old, perllol indicates in the footer not having been changed since June 1998. Many people agree perl's documentation needs updating, but few hands are available to actually do it.
Actually, i think you meant to say "would NOT write to the original". :)
muchas gracias!
ah, I was wondering about that too... stealth ninja editing is stealthy!
Yeah, thought I fixed it fast enough, damn you! :-p
Read [perlreftut](http://search.cpan.org/perldoc/perlreftut) before anything -- it answers exactly this, and very clearly.
&gt; is it just for readability It's not just for readability. When you declare a variable as 'my' it means you're creating a new variable that only exists in that lexical scope -- when you leave the block or sub where it was declared it ceases to exist. More importantly, when you use a lexical variable you ensure that you're not stomping on a global variable of the same name. If you wrote a large program without ever using 'my' (or 'local' or 'our') then you'd have to be very careful not to accidentally use the same variable name in two places because everything is global -- a reference to $var in one place of the program would modify the same $var as in a completely different place. By using 'my', both places can use a variable named $var but they are different variables.
Thanks! I was looking for something like that, but qw(perl curly brace) aren't very good keywords....
My head just exploded with concepts colliding in beautiful synchronicity.
`print` is a keyword with a special case in the parser, so this one case of dative syntax avoids the ambiguities that plague other indirect method calls. Even so, the real benefit of this patch is doing something like: $fh-&gt;autoflush( 1 ); ... and avoiding a dance of `select` and the superglobal `$|`.
* If the example you are reading doesn't use warnings and strict, add them yourself or find a newer reference. The book "Modern Perl" is available online for free, http://www.onyxneon.com/books/modern_perl/index.html. * declare your variables. So you have an array, or an array of arrays: use warnings; use strict; my @AoA = ( [ 1, 2, 3 ], [ 11, 22, 33 ], [ 111, 222, 333 ], ); If you want to know how many elements it has, assign the array to a scalar value. I like to stick the keyword 'scalar' in there to make it obvious what I'm doing, but some people think it's bad because it's extra typing. my $N = @AofA; $N = scalar @AoA; To get the index of the last element, use $#AoA ... but you never need that. my $last_idx = $#AoA; You can take a reference to this, which is useful for passing around to subroutines or as a return value. Instead of copying a large quantity of data, potentially gigabytes, you pass a 32 bit or 64 bit pointer. The backslash generates the reference, which gets stored in the scalar. my $ aoa = \@AoA; To access the whole array from the reference, wrap it in curly braces and an at sign: my @copy = @{$aoa}; my $n = @{$aoa}; $n = scalar @{aoa}; The first element in the array is $AoA[0] ... the inner array [ 1, 2, 3 ]. If you want to access this from the reference, you just stick an arrow at the outermost index. my $inner = $aoa-&gt;[0]; But you can just stick more indices to access the inner elements: my $num = $aoa-&gt;[0][0]; $num = $AoA[0][0]; You rarely want an array index, that's just an implementation for accessing the array element ... so do that directory: for my $inner ( @{$aoa} ) { # $inner = [ 1, 2, 3 ] the first time, then [ 11, 22, 33 ]... for my $val ( @{$inner} ) { print "The next value is $val\n"; } print "End of inner array\n"; } On the other hand, if you just want to do things with the whole list, use array operations: my comma_separated_list = join ', ', @{$inner}; # 1, 2, 3
I think it's important to note that you can also just use `$#$ref` to get the last index of the array that `$ref` points to.
&gt; To get the index of the last element, use $#AoA ... but you never need that. I use it frequently when iterating over the length of an array. (When I want to know the index.) for(0 .. $#foo){ ... } Better than: for(0 .. scalar @foo - 1){ ... }
That's my point, if you want to iterate over the array, use for my $elem ( @array ) { do_something ( $elem ) } rather than for my $i ( 0 ... $#array ) { do_something ( $array[$i] ); }
Yeah, I agree. I also specified that, in my example, I wanted to know the element's index.
Perl seems overly complicated. o_O
5.14 fixes the worst of this ugly stuff; most of the builtins that used to only take plain arrays or hashes (and needed `@{...}` around everything) will now accept references directly.
It's not any more complicated than necessary, nor more complicated than any other common language. It's just somewhat *different*.
Pretty nifty design, could use a little polish, but still cool!
How come defined &amp;foo Doesn't call foo?
Parsing magic. Just like `exists $hash{key}` is not a simple function call and operates on the return value of `$hash{key}` (and instead retrieves both `%hash` and `"key"`), `defined &amp;foo` doesn't evaluate the argument first, but does some special magic[tm]. You can easily test that by wrapping the `defined` operator in a sub yourself: $ perl -wE 'sub d { defined shift }; sub f { say "CALLED" }; say d &amp;f' CALLED 1 # in contrast: $ perl -wE 'sub f { say "CALLED" }; say defined &amp;f' 1 
Thank you. Somehow I knew that, but reading the article I thought it was some special property of using the ampersand with a function, rather than a special property of defined.
How about: my @array = @{&amp;some_subroutine_returning_a_ref_to_an_array}; Tim toady, yeah, but is there a better way in this case? 
 my @a = @{fn()};
Ah, of course. Thanks! 
Useful summary to forward people to!
Interesting! Since TTY's are not supported, it doesn't work in one-liners (I was surprised for a second when I tried it). # ANSI colors work perl -MTerm::ANSIColor -E 'say colored "This is red!", "red"' # Extended colors don't perl -MTerm::ExtendedColor -E 'say fg "red", "This is not red!"' 
This article lost me at: "It is practically always bad when you're calling the subroutine. However, &amp;foo is slightly more efficient than foo(@_). If you're using this (micro-)optimization, be sure to add a comment that indicates that you know what you're doing, something like: &amp;foo; # optimization: pass @_ efficiently " Wouldn't typing an extra 34 chars of comments negate using the shortcut in the first place!
&gt; defined &amp;foo doesn't evaluate the argument first, but does some special magic™. FTFY
TTYs are not supported, that's right. That's a limitation of *getty though. Of course it works in oneliners - you just have to use the correct arguments. ;) # print some red shades perl -MTerm::ExtendedColor -E 'for(1..5) { say fg("red$_", "This is red") } # print all available colors, in color perl -MTerm::ExtendedColor -E 'say fg($_, $_) for keys %{ get_colors() } 