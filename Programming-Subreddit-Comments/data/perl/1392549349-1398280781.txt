You mean, just line find, and ImageMagick's convert? I can live with that. And it probably won't take *that* much code. This is perl, after all.
Why not: parser.xml --column Location="(/root/one_location OR /root/two_location)" --column color=/root/color Which makes your code look something like: GetOptions("column" =&gt; sub { push @column, [split(/=/, $_[2]] }); Or maybe push a hash, or a moose object or whatever. That way you end up with a single array with your two pieces of data in each spot.
The lack of filtering on user comments, and the use of SHA1 for password encryption, make me think that they don't know what they're doing. These things are fixable individually, but why not do it right the first time?
It's not just the individual issues that I'm worried about. Filtering and proper password hashing aren't that difficult, but you have to know *why* they're important. If they didn't start with them in the first place, I question their understanding of the Why.
I was a little worried that their Makefile didn't actually contain the right dependencies.
Thanks for sharing your feedback! As you may have noticed, PearlBee is released under the 0.9 version. We definitely know there's room for improvement, that's why we're already working on the next version, which will have new features and some fixes as you suggested. Disclaimer: I work for PearlBee.
How would you like for people to get experience on modern web application development? Is writing software no longer the best way to learn?
it's true, working in an agile way lets us to release early (sometimes with shortfalls), get feedback and iterate rapidly. 
I'm not saying it shouldn't exist. Just that it's premature to suggest it might be "Perl's next great" anything.
Fair enough. I may have a hair trigger on responding to this kind of thing. I just see so much bashing of projects, both new and old, in the Perl community for not being up to the ideal of Modern Perl. It's frustrating, to me, that a community that allegedly wants to bring in new people is so hostile to people who aren't yet great Perl developers, and the projects they start. This is how communities become insular and stop growing, and Perl crossed into that territory a long time ago. I feel like while constructive criticism is useful to the future of Perl, simply saying "this sucks" is not. Had you said, "Here's a link to a solution to this problem that I see in this project." I wouldn't have responded; simply upvoted and moved on. But, you've simply said something to the effect of, "I don't like this project. It is built by an amateur. All the good things people have said about it are bullshit (hype)." You've provided no recommendations for improvement, no references about what is wrong, nothing but negativity. I understand the desire to demand great Perl software. Badly written Perl software is also a negative for our community in many ways. But, I don't believe simply dismissing every new thing that comes along is the right path forward either.
how is quoting statistics a pissing contest? I was trying to correct wildly inaccurate claims I heard from outspoken promoters. I'm not a Python user.
But isn't that the magic of open source? Let's assume for the sake of the argument that they don't understand why. If you or somebody else do see the wrong in their ways, send them a pull request and explain to them in a gentle way why password hashing is important and how they can do it right.
I also like JavaScript, and I think Ghost is beautiful and is (probably?) clearly the new standard for Open Source blogging engines. That doesn't mean folks don't want a nice Perl blogging tool. I first checked it out a few days ago when it was posted to Hacker News because I wanted to see an example of something in Dancer. I couldn't find real world Dancer apps when I looked around for them in the past. If there are better Open Source Dancer apps out I'd enjoy browsing them. The "who's using Dancer" page has mostly just services, rather than Open Source tools using it; I understand the marketing value of having a list of real sites built with a thing, but it holds very little value from the perspective of learning.
I appreciate your detailed reply, and I feel similarly. I think the misunderstanding was that I was not criticizing this project out of the blue. I was criticizing the unjustified hype surrounding this project. Yes, there is an attractive website. Yes, blogging is a thing. Have they brought something to the community that is new or interesting in some way? It's not clear to me. I'm not even saying it sucks. I'm just saying I don't understand the hype around it. However, I'm not the hater that I might sound like. Time is short right now, but I will give it an honest look in the coming days. Maybe the hype is justified and I have just been blind to it.
Apparently the [Christmas Poo](http://www.reddit.com/user/educated_poo) is tired.
&gt; I'm not sure I could support writing a blogging platform in anything besides Javascript at this point. Genuine question: why? What advantage does JS have as a language or the center of an ecosystem on the server side?
What was Perl's previous great blogging platform?
Is there any up-to-date Benchmark of Perl6? Recently I saw this document http://sd.jtimothyking.com/wp-content/uploads/2013/12/Benchmarking-Perl-6-How-Ready-for-Prime-Time-Is-It-revised.pdf My opinion was: Still a lot work to do - until i saw that the scale is logarithmic! Now my questions: Does this benchmark show a real performance dimension? And the next (if it does): I dont have much experience in compilers but is there any chance to get Perl6 dozen or hundreds times faster without rewriting everything from scratch?
Lack of hype is why Perl is not cool/is dead/[insert your favourite phrase]. I don't think you should knock them for trying to spin up a bit of positive marketing around a Perl project.
I agree with adam, Perl does have a severe marketing &amp; communication issue. So yes, hype is good. Preferably good hype. We do need projects like BuilInPerl and PearlBee that are developed by young, passionate Perl developers. Because only by being giving back &amp; being passionate about Perl we can attract more people to Perl - and solidify its well-deserved position within the dev ecosystem. Disclaimer: I'm indirectly involved (non-dev) with BIP and PearlBee
Hi there, I'm running benchmarks every now and then to figure out if individual changes make a big difference. I don't usually compare them against perl5, though. Especially since the only benchmarks we have are microbenchmarks that have almost no value to any outsider — suggestions for viable benchmarks very much welcome! We can get Perl 6 a whole bunch faster on MoarVM with the upcoming type specializer and then even more with a JIT compiler. Otherwise, the code-gen is still pretty shoddy in many places, which I'm occasionally helping with; We don't even have a peephole optimizer on any of our "own" backends yet. All in all, I'm pretty hopeful. Big chunks of Perl 6 have been designed with optimizability in mind. Among other details, multiple dispatch candidates are known at compile-time, so we already partially do multiple-dispatch up front instead of every time we do such a call. Once we have better support for native "containerless" variables (`my int $a; $a++` doesn't work at the moment for example), we'll also have compact native arrays in Perl 6 rather than just in NQP and I'm willing to claim that'll make a noticable difference for any matrix/vector operations you can come up with.
It really is worth looking into. And I'm totally not just saying that because the guy who started it is my brother in law. 
Yep, I recruited member #223. =)
It helps to unbutton your shirt a bit more. However, at $100 a week max, this is a pretty bad escort service.
What the fuck is this? I have been programming perl for 20 years. No wonder the language is barfing up its guts. Source: once starred in Mamet's "Duck Variations"
Wow less members than Go...
could you provide a link for context? thanks.
Not anymore. ;)
Good stuff! FYI the Questhub link is broken, should be: href="http://questhub.io/realm/perl/explore/latest/tag/catalyst"
You seem contemptuous but I'm not sure about what and I'd like to have a better idea. I find it very hard to believe you are just reacting to the Ancona references. So... Is the basic problem in the title? The article it links to? The list of things being considered for Ancona? Catalyst in general? Use of quests and questhub? Some combination of these? Or something else?
Nice.. Though I think there might be a lot of bias from the tip process. Drupal for example I bet its all the plugin authors getting tipped for some change requested by a company. Unless Drupal is still unreasonably popular even now?
Well, only one of them is dead :P
Technology and favouritism are incompatible.
What are you attempting to do? If you just want to generate a report, it's one line per user, and maybe you have to sort for uniques once you have the other machines' users in the file. But if you're wanting some integrated network where accounts exist across machines, you need to read up on LDAP and whatnot.
If is is so easy and minor why am I not done with it yet? Why did I bother posting the question?
It's Perl!
Bullshit. Perl is perfect for anything that involves extraction and replacing. It's almost like those things ARE BUILT INTO THE FREAKING NAME
Because we're fucking around on reddit. Duh.
The Space Shuttle is indeed an awesome vehicle.
Perl can be used for huge business critical webapps, and small one-line admin-y stuff like OP asked about. Your understanding seems deeply flawed, but by all means keep talking out of your rear.
Suggested benchmark: time elapsed between announcement and relevence. Unfortunately it's still several orders of magnitude worse than Perl 1 through 5.
I make websites, using Mojolicious.
Lots of crawling, and lots of testing!
I don't use PERL for anything. Perl on the other hand, I use all the time to automate a number of tasks. 
Controlling instruments in spaceflight. Computer vision. Image processing. 
Gee-wiz info: it's Perl not PERL. It was going to be Pearl, but Larry Wall found that another language was named Pearl so he removed the a. I use Perl for rapid development. I work in R&amp;D and often will prototype ideas in Perl before taking the time to write it in C or C++. I also use it to code up quick, one time use recipes to handle small tasks as well as minor web development on my own time.
I though I was the only one that cringed when people call it PERL :)
Give [this](http://search.cpan.org/dist/Unix-ConfigFile/PasswdFile.pm) a shot, worked for me.
There's an extended description in [perldoc perlsub](http://search.cpan.org/~tonyc/perl-5.19.9/pod/perlsub.pod#Signatures)
I wrote a trouble ticket system that dances with dancer. :)
I'm a long time UNIX/Linux admin and recently head of tech for a small business. I've of course used Perl for just about anything and everything system admin related. Automating tasks, system testing suites, nagios plugins etc. I reserve Perl for on system tasks and use PHP for web related tasks it's just more focused on that side of the fence and I find Perl better suited for life system side. Side note, anything where you need to manipulate text is a Perl job. That is all, you can not beat Perl in that space in my opinion.
Gluing together third party scientific software with in-house stuff written in various languages (C++, Octave, Fortran). When Perl is your hammer, you learn the value of choosing the right tool.
So no passing more than one @ or % ?
Well they do have an entire Perl based plugin system for people to contribute new instant answer services. People get exposed to Perl pretty quickly around DDG afaict.
Yeah but some kind of small badge on the front page or whatever, just to give it some tiny bit of exposure.
You're not alone.
Why use a knife when a collection of rock slivers will do?
It says that this disables prototypes as far as i can tell.
PIMP (Perl is My Paycheck)
But you can add them back as attributes (read further)
I use it in nagios probes, had to change some of them the other day. I also used it to get a list of IP# and generate config for smokeping.
No joke. I hope they remove it from "experimental" for 5.20 release. 
Pretty much everything. Unless it's so simple that a shell script is more appropriate or if it's in a situation where I have no choice but to use other languages (Javascript on websites, Java for writing Android apps...) Perl's wrapped round my system backups and system monitors. It pulls a random selection of music albums to push to my 'phone. It serves up the content of most of my websites (and is used for content updates on the others). It runs my radio timeshifting system (downloading and parsing schedules from the BBC, showing me screens with programme listings to choose what's recorded and running the actual timeshifting). It runs my home-automation system. It even watches for my camera being plugged into a USB port and automatically takes all the photos off it.
perhaps something like this? sub foo (@$array1, @$array2) As a proposal for easy dereferencing Arrays (or hashes)
I use it for bioinformatics data munging and gluing together apps.
Thank you, will follow up with this.
Thank you, went through the article. That was actually the first article that came up searching for it when it all began. But bc we werent able to reproduce it after it "magically" stopped happening debugging it is nearly impossible. We are going to keep an eye on it and hopfully get a repeatable situation. 
Sheesh, get a bunch of programmers together and they just criticize your syntax. I've always just taken the manpage at its word that PERL is "Practical Extraction and Report Language". 
This is unlikely to happen, 5.19 is dev branch for stable 5.20, "experimental" could be removed in 5.22 (shipping May 2015) or 5.24.
From what I've read and watched of this feature, they just wanted to get *something* working. This feature is at least 15 years overdue and I'm glad it's finally moving along. Going the full Perl6 route of having a whole mini-language for signatures would be too much to ask. Fixing up references, default values, named arguments, or {INSERT PET FEATURE} can come later.
I use it for server administration tasks and automation and also web development. I enjoy programming in Perl the most compared to other languages that I use (Python, Java, C#)
Why not the camel book at its word tha Perl stands for "Pretty Ecclectic Rubbish Lister"? Larry has said both are equally apocryphal, and that Perl is not an acronym.
Indeed. This sort of bug is intrinsically a Heisenbug. It will happen only when you're not looking. That's because it depends on whether and when Perl will re-use the freed SV structure. 
I must've missed that part of the camel book. I don't think I ever read it cover to cover. I HAVE looked at the manpage quite a bit tho!
Sys admin stuff mostly. Project Euler problems. I am looking at doing web stuff (internal) with Mojolicious.
&gt; Perl officially stands for Practical Extraction and Report Language, except when it doesn't. Even if it implies a potential acronym, the docs are pretty consistent about Perl or perl but never PERL. Seriously though, correct capitalization is pretty much the password for entry into the Perl Hackers clubhouse.
Sounds interesting ... write some blog articles about your stuff. 
Glad to know the standards are so high! I may need to reconsider the offer the PHP kiddies had for me. They may have an annoying abundance of functions to do similar (but slightly different) things, but dammit they don't care about capitalization!
Not caring about capitalization is a good thing? Well Perl has a very Unix-y background. Case is significant! If you posted in a forum asking questions about "Php", you really don't think people would give you a hard time?
This is great!
I had a scope problem sub parse(@) { my @data; my @record; foreach (&lt;@_&gt;) { chomp; @record = split(/:/,$_); push (@data, \@record); } return @data; } Scope is incorrect, every reference in the array will point to the same data, the last data read in. sub parse(@) { my @data; foreach (&lt;@_&gt;) { chomp; my @record = split(/:/,$_); push (@data, \@record); } return @data; } Scope is correct.
Ouch, glad you figured it out. Next time, post the code with the question from the beginning... many eyes looking at that stuff will see it quicker. And post to stackoverflow too, if you didn't. I know it feels like it's letting someone do your homework for you, but they reward them with meaningless internet points, and often you'll at least be given clues as to what's wrong.
I haven't tested it but it should work exactly them same on anonymous subs. my $sub = sub ($x, $y) { .... } 
I'm not sure about the "nameless parameters that have a default value but the default value doesn't actually matter" but the rest looks long overdue.
I had a whole list of my thoughts, regrets, and goals wrote out but I'm too scared to post them. Remove the details and it reads too much like your post. Thanks for putting this up chromatic, it means a lot. 
A very interesting read, and a situation I can completely identify with (although I don't think I'm half the coder the author is.) While I'm exceptionally capable with javascript and sql, I can also deal with php, python and jquery if I need to. But I've been coding in Perl for 18 years now, and I can't just walk away from a toolkit that I love dearly and have become most proficient with.
Have you tried Go? Give it a shot, I came to Go from Perl (bypassing python/ruby) and am very happy
I'd prefer elixir (a better erlang with macros) or Clojure, if I wouldn't first try to fix what I don't like with perl.
FWIW I've found it easier than I expected to switch from Python to Java after 7+ years of Python. It turns out that 90% of my knowledge is language independent, which is what I would hope, and I've been glad to verify in practice. The other 10% is knowing tool names and the tool specific tradeoffs, but that isn't too hard to pick up. 
&gt; It was Fidel to the rest of the CPAN's Che—the one that gets the credit, unless you're some sort of weird countercultural rebel who likes giving oligopolic corporations money to wear t-shirts with your icon's image on them. (That metaphor rode away from my point on a motorcycle tour of South America. Sorry.) Please don't apologise for making me laugh :-) As well as being an enjoyable read, the article raises some very salient points that cut close to home for me. &gt; How do you market yourself as someone who solves problems instead of someone who transcribes ideas in the language du jour? Damn good question. I wish I had the answer... (NOTE: I fear I may be repeating a lot of what you wrote in my ramble below, some if it word-for-word, but this has been on my mind recently and perhaps now is as good a time as any for me to core-dump it) --- I've been freelance consulting for 10 years now. I am no longer a Perl programmer, although I still do most of my back-end work in Perl. I am not a Javascript programmer, despite the fact that I do most of my front-end (and some back-end) work in that language. I am not a PHP, Python, Ruby or C programmer either, although I've written code in all those languages over the past few months. I'm not a web developer, web designer or UI/UX designer, even though I consider myself an expert in HTML, CSS and related technologies, and reasonably proficient in the artistic/graphic/HCI design side of things. I don't call myself a web architect, systems analyst, database administrator, systems administrator, network administrator, bearded Unix guru, or any of the other labels I *could* wear quite comfortably. I am not an IT consultant, a contractor, a rock star programmer, or a gun for hire. For that matter, I don't think of myself as an author, a composer, a photographer, a kite designer, skatepark designer, or radiation protection specialist, even though they're some of the other feathers in my cap. I am a problem solver. *If you have a problem, if no one else can help, and if you can find them, maybe you can hire the A-Team*. (cue rousing theme music) To solve a problem I may have to call on many of the skills listed above. I will almost certainly have to learn some new ones along the way, too. Forgive me if it sounds like I'm blowing my own trumpet - that's not my intention - I'm sure most of the people here could list a similar set of skills. The point is that the companies I work with rarely care about the technologies I use to solve their problems. They just want the problems solved. Sure, the problem might involve a particular language or technology that I need to work with (you don't think I would *choose* to code PHP do you?), but that's usually just one small part of the larger problem. I'm fortunate in that I haven't had to go looking for work since I started freelancing so I can't honestly say what the job market is like in the "real world". But I'm fairly certain that I wouldn't want to apply for, or be happy working in a "Perl job" any more than I would be in any other "XYZ Job". That's a job where someone else has already come up with a solution and they need a particular shaped peg to fit an existing hole. TL;DR: Be a carpenter, not a hammer operator.
There are opportunities for Perl in genetics and other medical research fields. Check out : http://www.bioperl.org/wiki/Main_Page. I currently work at a major children's hospital that does genetic research. I use Perl to migrate data between Oracle, SQL Server and LDAP. I know of several small programming teams who use Perl. As you know Perl is an excellent scripting language and more and more we look for database developers who are well versed in a scripting language too. 
&gt; You tell me. I can give you references who will speak of me in positive terms. I can refer to to people who will tell you I helped solve problems or helped teach them something or helped them think about their problems in better ways. You can add "helped inspiration strike," but I'm not sure if I'd speak of you in positive terms now -- I now have *yet* another project to compete for my spare time. So, thanks! (both with, and without sarcasm)
i tried to switch to ruby but it was so slooooow and i could never figure out if i was doing it wrong or if it was just too slow. i dunno but i feel like i can do anything i want with a computer because i can do anything i want in perl. not only can i do anything i want, i can do it *several different ways* which is where perl wins over everything. it's not like i'll have to start over if i have to switch to something else, no matter what it is. i'm super paranoid about staying employed since i've entered the nightmare logan's run universe of being over 40 in silicon valley but i don't think i'll ever have a job without some perl somewhere. also, i suck crap compared to mr_chromatic, so this article is a little scary, but don't forget people mostly care if you're smart, can communicate, and aren't a jerk. if you can program, you can program. (ps chromatic DUDE: if you can *write* you can *write* and you *can* so there's always that.) i was a sysadmin in 1998 too, which tells you that i was around when everyone built their own tools, when a lot of things were very difficult, and when a lot of *work* was done. you don't stay in the business for 15 years because you're terrible at what you do.
&gt; I now have yet another project to compete for my spare time. You mean managing a boutique law firm? It's less interesting than it sounds!
&gt; As I see it, you can find a Perl job in one of a few ways: &gt; &gt; Create it yourself by starting your own company &gt; Create it yourself by recruiting a client without a strong technology preference &gt; Create it yourself by introducing Perl slowly into an existing job and making it irreplaceable &gt; Find one of the existing companies using Perl (read "Move to Amsterdam" or "spend time maintaining a codebase from 1997" or "get very lucky") &gt; Create something so amazing and compelling and useful that people can't not use it, like mod_perl or Movable Type or, let's throw cPanel and Catalyst in there &gt; ... It seems strange to me that it's that hard to find Perl jobs. For what it's worth, my company's recruiter is always saying how hard it is to find Perl *programmers*. I know we've got at least 3 openings. It was a similar story at my last job (in 2012). And, no, I'm not in Amsterdam and I don't spend my days maintaining a codebase from 1997 (in fairness we have codebase from 1997, but we're actively rewriting it in modern Perl). So what gives... Is there a Perl developer shortage or are there no Perl jobs? 
&gt; Is there a Perl developer shortage or are there no Perl jobs? I speak only for myself on this, but I have no desire to relocate and I charge more than a lot of companies are willing to pay.
I fully agree with you here- I have the " * " operator remembered as something that deals with symbol table entries. And pre-fixing @ makes it a lot more clearer what one is dealing with. If the reference was gigantic: $deep_array_ref-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;[0]-&gt;%* It isn't clear what is it a reference to from the first looks. (I doubt anybody would create such terribly long references though). But even in the smaller form, I still feel more comfortable with prefixing @ or %. Simply because... it is more simple. Unless something like: @{ %{$deep_array_ref_with_hashes-&gt;[0]-&gt;[0]}{'key_with_list'} } (Not sure if the above would actually compile, just thought of it out of the top of my head)
Yeah as a programmer with mostly doing systems programming experience using perl, php, Python,Ruby etc I found by the hardest part of working in Java was the massive amount of knowledge you need about the tool chain. Everything from maven, to artifact repositories to packaging war files properly. And there are no tutorials about that stuff. It is all on the job training only pretty much. 
ETL
If you have questions, feel free to ask them here. I don't think there is a specific sub for tips and such.
I would say that the majority of posts I have seen asking for tips/advice have posted directly to /r/perl. I know this isn't what you asked but [StackOverflow](http://stackoverflow.com/questions/tagged/perl) (SO) is a good place to ask perl questions. Also [irc](http://www.irc.perl.org/channels.html) is good too.
You might look into [AnyData](https://metacpan.org/pod/AnyData::Format::Passwd) module it supports read /etc/passwd into a database like structure. You should be able to export that data into a SQLite database pretty easily so I would suggest you combine all the passwd files into one to make creating the SQLite database easy in one step.
Thanks for the warning!
Thanks. I wasn't sure because I didn't see a lot of that going on here. On /r/learnpython, you'll see lots of beginners asking questions. I quickly glanced at the first few pages of /r/perl and didn't see much of that and didn't want to post in the wrong place. 
Yeah Maven can be a pain in the ass. 
PerlMonks is fine, albeit a bit brusque sometimes. The main thing is they expect you to have searched online resources *before* asking on there. For example, don't ask how to create a pointer to an anonymous hash when there is countless information online on that exact subject.
Welcome to Perl! :D
This is pretty cool!
it's cool, but Perl Dancer2 is cooler :)
Great.
If you have a question that isn't answered in stackoverflow or in the manual just ask.
You got it. Thanks!
This might be a dumb question, is dancer 2 ready for production?
And for goodness sakes don't cross them on the culture. 
I find the information already on perlmonks to be quite extensive and can answer a lot of questions if you read the comments. The search engine works well and google often turns up lots of results that link to perlmonk threads.
I wasn't even trying to be nasty. But it's pretty obnoxious for someone who doesn't know what they are talking about to come into a forum and spew garbage, then continue to do so with more sarcasm and ignorance when called out on it.
there is no "shortage" of either. It is just a niche market that is having difficulties to adjust to its being a niche market. So yes, there are not a lot of Perl programmers, and not a lot Perl jobs, so both sides need to go the extra mile to have a chance of meeting in the middle. but both sides are not used to do that. both sides complain that this is not what they signed up for. and until they will get used to the idea, everybody will complain. For example, "Move to Amsterdam". Booking have response to the problem by helping people to move to Amsterdam. I moved to Japan to work for a Perl-using company. Other companies and developers are going the tele-commute route. But these are the fast-response companies and developers. the traditional ones will continue to complain. 
I think it's somewhat sandboxed. Just writing bad code with infinite loops seems to lockup the session but the site is still responsive. Hopefully they put some sane ulimits to keep perl from consuming all the memory or CPU, and hopefully the users are restricted to a VM or directory that contains only their files.
Oh, are you saying that working remotely with a team, from vastly different time zones is as effective as cooperating face-to-face? Do you realize how ridiculous that is? Booking.com *has* made exceptions to the relocation rule, but they're few and far between. As anybody who lives in the Netherlands will be able to confirm: Pragmatism over strictly following the rules is a thing here.
Golly gee whillickers, I wonder what happened in 2000 that made Perl all of a sudden lose popularity. Oh that's right, it forked its community so that it could fail to deliver anything for at least fourteen years. Who would have that that wouldn't work! Gooooood jooooorb everyone.
This is awesome. Thanks for making and sharing.
That doesn't stop denial of service by just putting while(1){} though. Looks like it keeps trying to save and run those over and over too? Infinite loops could happen by accident, so some sort of timeout and report back to the user would be good.
This article glosses over the fact that despite it's popularity Python is going through its own crisis. Python 2 has stagnated into security fixes and Python 3 is a white elephant. Perl 6 was too ambitious and has taken far longer than anyone expected, but Python 3 wasn't ambitious enough. Meanwhile Perl 5 core development has rebounded, every release brings some new feature or improvement. CPAN contributions are steady, YAPC numbers are up every year and with v5.20 just months away, this could be the greatest comeback in history.
That depends on what you mean by "deliver anything". Perl 5 is still around making major releases every year, sometimes using ideas from Perl 6.
Whenever I've wanted to include my own libraries I've used "require" require "/var/www/skel/mods/Dbdld.pm"; I've never installed my libraries like "real" perl modules, so I used require. Note that if you do use require your module has to return true as its last statement. [Require docs](http://perldoc.perl.org/functions/require.html)
Could you paste the exact error message? Next guess would be: You switched off "Show known file extensions" (or sth. like that) in Windows and the file is named BeginPerlBioinfo.pm.txt in fact.
You're right, it is actually .pm.txt. Notepad doesn't do that with my .pl files, though.
Thanks! Now I can go on to the other errors. I tried for so long to figure it out because I wanted to solve it myself. I never would have thought of that. I had never even heard of that feature. 
We agree. It's not a perfect option, but we work in a field where we make tradeoffs all the time. On my last project I worked remotely with an exceptional team we'd never have been able to assemble if we'd required colocation. It was better to hire the right people than to hire the most local people.
I have a goal this year of pushing more code into the wild. This quick hack to solve a work problem is my start. I plan to use PrePAN as a first step in publicly pushing things out. I find the perl community has really great feedback and we have tools to aid in that process. 
very nice!
The link to "The Quick Python Book, Second Edition" is broken.
Don't listen to such pointless advice. Feel free to visit PerlMonks, and lurk for a while, and make up your own mind about the worthiness of the site. I have seen plenty of advice provided for newbie questions on PerlMonks. But, as I said, you don't have to listen to me either. Find out for yourself.
Isn't Perl 5 kind of good enough? and doesn't that take some of the steam out of Perl 6?
Thank you, it's fixed now.
Don't let the good be the enemy of the great ;)
I'm so sick of these articles.. You like Python better than Perl? Cool, now stfu and code. Experienced Perl developers understand the shortcomings of Perl. There are shortcomings in every language. It's ridiculous how much effort people put into talking trash about a language that is still very much relevant. Perl is used by the likes of Amazon, Craigslist, EBay, Zappos, DuckDuckGo. Please, explain to me how it's going to die soon? Get on #perl on freenode and look at how active it is. Perl 6 is being worked hard on and the community is alive and well. Sure, we never may be the "hip" language again, but for those who want to get shit done, Perl will continue to be considered.
I'll have to remember that.
Well said. To me, there's something of an element of ".... doth protest too much" about this sort of thing; if Perl (and Perl5 in particular) is increasingly irrelevant, why spend so much time and effort making "Netcraft confirms it: Perl is *dying*" pronouncements? Continually bringing a technology to people's attention is a decidely odd way to hasten its supposed irrelevance. :-)
With a little help from List::MoreUtils: use List::MoreUtils 'pairwise'; sub pairwise_sum($list1, $list2) { pairwise { $a + $b } @$list2, @$list2 }
Solving problems. Lots of tools (automation of build processes, code generators, Little DSLs), some web stuff.
&gt; For a yet-more-powerful import facility, see use and perlmod. That's why. I just needed a simple import facility, and didn't want to mess with changing @INC or mixing my modules in with the "official" perl modules. I also don't have any issue with the problem you point out. Several of my modules include additional modules (usually DBI) with no problem. 
"Don't ship", that's the lesson to learn.
What horseshit. I've seen better deployments of the "perl sucks, python r00lz" trope in YouTube comments.
Perl is also one of the projects in the associated [Outreach Program for Women](https://wiki.gnome.org/OutreachProgramForWomen/2014/MayAugust)!
Can't wait!
Alex Gaynor says in [About Python 3](http://alexgaynor.net/2013/dec/30/about-python-3/) that less than 2% of downloads from the Python Package index are for Python 3. He concludes with: &gt; First and foremost I think a lot of us need to be more realistic about &gt; the state of Python 3. Particularly the fact that for the last few years, &gt; for the average developer Python, the language, has not gotten better. He also seemed to have missed the most devastating points in Stevan Little's "Perl Is Not Dead" presentation, namely the issues with Perl 5 core and the problem of backward compatability. Seems like the compatability issue might be a relevant point to bring up if one were comparing apples and apples. Instead we get a healthy heaping of no true scotsmens ("talked about with elegance and eloquence among my circle of campus friends, who liked being part of an up-and-coming movement.") along with the usual litany of book sales and job listing "evidence". As my 13-year-old son (and **cough, cough** fledgling Perl hacker) would say, "meh". I have to agree with sillymoos' sentiment -- far from gasping for it's last breaths, Perl seems more exciting to me than it has in years. Stuff like [p5-mop](http://blogs.perl.org/users/damien_dams_krotkine/2013/09/p5-mop.html) and [moops](http://blogs.perl.org/users/toby_inkster/2013/08/introducing-moops.html) surfacing in the community every so often are exactly the sort of things that keep hope alive for this Perl hacker. When I do things like fire up Rakudo Perl on the JVM, the last thing that comes to mind is that my language of choice "is not getting better". True, I might not ever run Rakudo on the JVM even if it gets to the point of being usable, but the fact that I'm doing it **at all** is a bright, flashing neon sign on a street full of bright, flashing neon signs all spelling out the phrase "getting better". Honestly, I could care less what a Python zealot thinks about Perl. My main problem with this article is that it's lazy.
I think that was sarcasm. Back in those days, it wasn't a "sister language". It was the obvious successor which was always just right around the corner. In 2005, Rails suddenly took off and "just right around the corner" wasn't obviously soon enough--not that P6 was supposed to be the next generation platform for web development, but Rails was just shiny enough that refugees from the manifest-typing-but-XML world of Java could overlook the immaturity of Ruby as a platform.
To add to what dthvt said, this blog post is from 2008 - things could have changed since it was written. (a phenomenon called "bit rot") Contact the author, get a professional to fix it for you, or find a more recent solution. Good luck.
I don't know very much about this thing that I don't know very much about. I'm not very comfortable with things I don't know very much about. Things I'm not very comfortable with are scary and suspicious. Maybe it is best to stay away from things that I'm scared of.
The juxtaposition of this article and the [DuckDuckGo](http://www.fastcolabs.com/3026698/inside-duckduckgo-googles-tiniest-fiercest-competitor) one on the same page is irresistibly funny.
I don't disagree with this at all. I suppose I was more trying to make a point about what Perl 6 actually was as opposed to what everyone thought it was.
In the pwdexpire.pl script: my $mesg = $ldap-&gt;search( base =&gt; $ROOTDN, attrs =&gt; "maxPwdAge", scope =&gt; "base", filter =&gt; "distinguishedName=$ROOTDN" ); The attrs option needs to be an arrayref. Change that code to look like this: my $mesg = $ldap-&gt;search( base =&gt; $ROOTDN, attrs =&gt; ['maxPwdAge'], scope =&gt; "base", filter =&gt; "distinguishedName=$ROOTDN" ); I think that should fix it.
&gt; 1) This is discussed in the comments In fairness though, the "discussion" in the comments is: &gt; Yes! I will post an updated version later today. It will address this and add a bit of new functionality. But all of your points are still valid. 
You sir, are a hero. Thanks!
Hi, I'm down voting your submission and I feel I owe you an explanation. Its just not on topic. This forum is here to help people using Perl, either to get help for questions or to make announcements about projects using Perl, or some other reason related to community communication. Your post could conceivable fit into the latter category, however since it doesn't relay any new information (everything you mention is something that we are aware of or is incorrect in ways we've already discussed) nor does it offer a useful suggestion to Perl users (other than use Python...) its not useful or topical. This forum is for Perl users trying to help other Perl users and for Perl users to make announcements or otherwise communicate with the broader community. I'm glad you like Python. I like Perl and am well paid for my skill in using it. If there's anyone that is interested in learning Perl I hear a lot of companies wishing they could hire more Perl programmers so I think its worth learning if the language and community fits who you are. If it doesn't you might want to try Python, or Scala or something else. Best of luck. jnap
Hi, I'm sorry if you feel isolated. Perl community is actually quite active. Yoou can start by trying to find your local Perl Mongers group. Also, Perl programmers tend to hand out on various IRC channels (irc.perl.org). Since you say you use Perl primarily for sysadmin I am not sure the beset IRC channel for you, but if you are also using Perl for web development you might find the #catalyst channel a goof place to hang out. Catalyst is one of the more popular and mature web development frameworks, so if you are considering updating your website its not a bad thing to learn about. best of luck, jnap
Initial dirty release to the wild. https://metacpan.org/release/Path-Iterator-Rule-RT
When this was posted on Hacker News, commenter [smacktoward](https://news.ycombinator.com/user?id=smacktoward) beat me to the punch with their comment, which included this bit: &gt; Writing an article about "the fall of Perl" that only incidentally mentions PHP, for instance, is a *big* omission. Insofar as Perl has fallen, what it fell from is the position of leading language for building Web applications. PHP is what pushed it out of that position, not Python or Ruby. If you want to write an article about the fall of Perl you have to explain how that happened and why, but this article attempts neither. I couldn't agree more. While we can debate the fall or Perl (or not), any article that claims that *Python* is the main reason for a decline in Perl and entirely neglects PHP is just badly written. As a whole, this article is basically a bunch of the writer's personal thoughts presented as facts, loosely supported by other "facts" like the (pure garbage) TIOBE index.
Nice script. Saves a whole lot of time!
There are these great things called books that you can get that some people find really useful. You can get electronic versions but I find the dead-tree format to be much easier to look thugs up in than doing text searching in a PDF. 'Learning Perl' is great if you're still pretty new to perl and programming in general. 'Programming Perl' is a decent offline reference book that contains a lot of information in a very condensed form. If you're a mac user I'd also highly recommend looking at Dash the offline documentation browser.
I'd like to add that I'm currently obsessed with the books [Effective Perl Programming](http://www.amazon.com/Effective-Perl-Programming-Idiomatic-Development/dp/0321496949/) and [Perl Testing](http://www.amazon.com/Perl-Testing-Developers-Notebook-ebook/dp/B005EI86EK/).
What kind of help are you looking for?
This is way more significant than you'd guess if you haven't worked with it yet. Not only is the documentation for every core function and module available from the command line if you have a full install of perl (e.g. with the "perldoc" command), basically every CPAN module is too. And the quality standard is pretty high too.
Never heard of koding. Went and took a look. Signed up. They're hammered. I'll try to look harder in the coming days.
I don't know why people downvoted you. It is a valid question.
No problem, I love seeing code on this subreddit too.
I use Perl to make the photo managing application the I use. It allows me to browse, rate, tag, and filter my photos. It calls external commands (UFRaw/GIMP) to edit the photos. http://github.com/bart9h/bapho
Yea as they said already. Welcome :)
Are you using http://search.cpan.org/~ken/xls2csv-1.07/script/xls2csv? If so can you give an example of the command line you are using and what the error is.
Yes, that's what I'm using. Thanks for your help! Command line... # xls2csv -x spreadsheet_to_convert.xls -c converted_csv.csv Error: "Can't use an undefined value as an ARRAY reference at /home1/webstore/perl5/bin/xls2csv line 147". I've tried different variations of the command (encoding and such) but it's not throwing me anything different. I don't know why I keep getting this error. Any ideas?
I can't tell you how many times I've searched for answers to this using Google. I swear this page never popped up. Thank you! I shall try this!
You can also script it very easily using [this] (http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.60/lib/Spreadsheet/ParseExcel.pm) module. Looking over the stackoverflow answer, the question asked there pertains to a UNIX command rather than using a Perl command line tool. I'm fairly sure you're going to need to install the dependencies needed for converting .xls-&gt;.csv if you're using Perl. [CPAN](http://www.cpan.org/modules/INSTALL.html) tools can be installed here. It would also to be helpful to know what kind of machine you're running this on
So, if I used the [sample script at this link](http://search.cpan.org/~dougw/Spreadsheet-ParseExcel-0.60/lib/Spreadsheet/ParseExcel.pm) ...how would I go about modifying it to print or output to a csv file? Again, I apologize for my ignorance, as I'm VERY, VERY new to this all. Thanks again everyone. i truly appreciate it! 
First question - are you trying to convert an Excel &lt;= 2003 file (xls) or an Excel &gt;= 2007 file (xlsx) ? You'll need different tools. 
I recommend using Spreadsheet::Read, which is basically a wrapper for the other spreadsheet modules. I wrote a quick script here https://gist.github.com/jprjr/9272287#file-ss2csv You run it like $ ./ss2csv Workbook1.xlsx test Converting Workbook1.xlsx to csv... Writing sheet 1 to test_01.csv Complete
http://search.cpan.org/~kclark/excel2txt-0.05/
Glad you like it. &gt; my $caller = shift // 1; That grabs the first argument, unless it was passed undef, in which case it defaults to 1. http://perldoc.perl.org/perlop.html#Logical-Defined-Or
Well you know it isn't perl-6.
This is really nice! But I don't fully understand how to use Mojolicious to create a project? It would be nice if there was a tutorial about creating a web app. 
Invoking the Pod::POM::Web module indexes your existing perldocs, available pragmas, and modules, and optionally launches a local web server to display them. The navigation through the local html files is easy, and facilitates browsing. Easier, even, than looking through "perldoc perltoc". It can be run like this: perl -MPod::POM::Web -e server &amp;&gt; /dev/null &amp;
By big I mean that they use it heavily or as a primary thing so that it gets mentioned by them. Google says it uses Python heavily in YouTube and also mentioned in Wikipedia pages. Thanks for adding.
Perl is primarily a backend duct tape, though there are still a number of companies that use it as part of their main platform. The majority of Ticketmaster's code is mod_perl. Check out the Dancer, Catalyst, and Mojolicious communities for who's using the more modern perl frameworks.
I know that Reuters uses Perl heavily for their financial data products. I have also heard that most of the big banks have a lot of Perl in similar positions.
Amazon, Craigslist, zappos, eBay, and VERY heavily in DuckDuckGo to name a few. Also go to http://www.builtinperl.com to get a nice list of Perl startups.
http://www.builtinperl.com is a good start (and very pretty, to boot). For a longer list, have a look at https://github.com/vmbrasseur/Perl_Companies
We use it as our primary language at SocialFlow. I know Topsy also is based in perl.
Thank you for your reply.
Thanks it will be very helpful if you could provide citations so that it will help me to backup my points.
Perl is one of those things that stitch the infrastructure together and as such often hidden away. Not a bad thing :)
Thank you. Could you give examples of companies using it in backend with citations?
That's up to you! 
that's the thing with hidden services, they aren't cited anywhere :). For instance the CTO at my job (large financial company) would probably say we don't use Perl - while I write Perl almost daily and a bunch of our systems rely on it heavily :). That said, he'd be correct in that our core services are written in C# and Java (and COBOL - we are in finance after all).
Empoweredbenefits.com. we use perl extensively for carrier and client feeds. Source I work there
Automation and reporting for the most part. 
The entirety of cPanel is written in perl.
Does this mean that Perl is moving more towards a functional paradigm?
not only that, but banks/financial places have been using Perl long before Python became popular. There is just TONS of "legacy" Perl to maintain, and there seems to be lots of new development there too. Morgan Stanley couldn't get out of using Perl if they tried. Everything there is done in it.
If you really want to take it to the next level, try using lexical vars!
Fark.com is built on Perl [and has pretty impressive traffic](http://en.wikipedia.org/wiki/Fark). Slashdot is written [in Perl](http://www.slashcode.com) as well, and [also has some impressive traffic stats](http://en.wikipedia.org/wiki/Slashdot). Booking.com also is a well known Perl shop and they handle [625,000 hotel bookings a day](http://www.booking.com/content/about.en-us.html), which is nothing to sneeze at. IMDB is also written in Perl and is [an Alexa Top 50 website](http://en.wikipedia.org/wiki/IMDB). [This page](http://royal.pingdom.com/2009/11/06/perl-far-from-dead-more-popular-than-you-think/) also lists a bunch more as well.
I can't tell if you, parent, or both are being sarcastic,
I have taken up the challenge. I hope more join me. I want to give a big thank you shout out for all the CPAN contributors. You are all great but clearly some are just superhuman! 
I like his book, *Modern Perl* is a classic, but this article is pretentious and infuriating crap. Perl is having a hard enough time as it is without statements like, *If you do not use modules X, Y, and Z then you are not a true perl programmer.* Absolute rubbish.
&gt; If you do not use modules X, Y, and Z then you are not a true perl programmer. I'd feel really silly if I'd ever written such a stupid statement.
I wanted to leave some tireless whiny trolling to you massah!
I see what you mean and have edited the article to make that much clearer. In the context of that section, that sentence is supposed to mean "It's easy to learn enough Perl to get by without ever finding out that you *can* use tools like these"--because so much of the available learning materials for Perl never mention them. You can write perfectly good Perl without any of those, but if you've never even encountered them to *consider* using them, I believe you're at a disadvantage. There's a huge difference between a programmer who doesn't know that the CPAN exists and a programmer who chooses not to use certain CPAN modules in specific situations.
well, that might be the case for COBOL, but there is still active production of Perl. 
Yahoo has a large amount of Perl and it's vastly more popular than Python or Ruby. 
Thank you, sir! I have your book open in another window at this very moment. I really don't know why, but I find Perl to be bewildering, so far. Trying to keep track of contexts, sigils, curly braces, semicolons, etc., is making me lose my mind. :) The thing I still don't get about `\%router` is that it's empty. I don't get why it's being passed to the function, although it just occurred to me that maybe it's just there because the function requires that parameter but it isn't used in this case. It seems to me that it will always be empty. Thanks, again!
Thanks! Some of this is starting to make sense. It is still frustrating and seems fraught with peril for a newbie, but hopefully I'll pick it up before I lose all my hair.
Ah, after reading a part of your book, re-reading your comment, and then looking at the code again, I think I see why an empty hash was passed to the function....sort of. We earlier saw the empty reference to the %router hash passed to the `juniper` function. You mentioned this is because Perl flattens objects when passed to functions. (Why?? grrrr.) Anyway, take a look at the function itself: sub juniper { my $session = shift; my $command = shift; my $router = shift; my $hostname; It starts out using `shift` to grab the parameters passed to it and it sets a scalar `$router` equal to the reference to the empty hash that was passed to it. You mentioned this might be because the function needs to modify it. Well, later in the function I see something else that was confusing me, but I think it makes sense now: my @alarms = $session-&gt;$command("show chassis alarms | no-more"); foreach my $alarm (@alarms) { if ($alarm =~ /((\d+\-\d+\-\d+)\s+(\d+\:\d+\:\d+\s+UTC)\s+([a-zA-Z]+)\s+(.+))/ ) { $router-&gt;{"hostname"}{$hostname}{"alarms"}{$1}{"date"} = $2; $router-&gt;{"hostname"}{$hostname}{"alarms"}{$1}{"time"} = $3; $router-&gt;{"hostname"}{$hostname}{"alarms"}{$1}{"severity"} = $4; $router-&gt;{"hostname"}{$hostname}{"alarms"}{$1}{"problem"} = $5; } It seems like -&gt; is very popular and can be used for a few different things. Earlier in this script it was used to reference a subroutine in amodule as well as a method of an object. Here, I'm guessing that it is assigning new values to the empty %router hash but it's doing it by reference. I guess it can't assign them to the hash like I'm used to seeing because the hash itself doesn't exist in the function. We only have the reference, so I think that code must say something like, "Access the hash array referenced by `$router` and assign these variables to the hash." I'll have to think about it some more to figure out what that data structure really looks like. I'm getting closer to figuring this out. I think.
&gt; You mentioned this is because Perl flattens objects when passed to functions. (Why?? grrrr.) Not *objects* but arrays and hashes. Why? It simplifies some things even though it makes other things more difficult. (It simplifies the kinds of things people did with Perl 1, 2, 3, and 4.) &gt; We only have the reference, so I think that code must say something like, "Access the hash array referenced by $router and assign these variables to the hash." Yes, you're getting it. Keep in mind that `my $session = shift;` sets `$session` to a *copy* of the value passed in. You don't want to *copy* the hash, if you want the modifications you make in the function available outside the function. You want to modify that hash in place, so you need to pass a reference to it. (Also to avoid the flattening behavior.) Just like scrottie said, however, this isn't a great API. If it were a little different, it would be less confusing.
I think it's starting to clear up. Thanks again. I really appreciate everyone's help.
I know you didn't ask, and while there _are_ valid reasons to do so, please be aware that the `&amp;subname()` method of calling subroutines is not ideal. While it works, and Perl won't complain, there are nuances that can bite you in the ass later. See `perldoc perlsub` for details, and note that `&amp;subname();`, `&amp;subname;` and `subname;` do _wildly_ different things. In almost all cases, you're better off dropping the `&amp;` all together. It's mostly a holdover from earlier versions of Perl. 
It's interesting reading through the article and comments as I'm aged 25-30 and started learning Perl as my first language with no academic qualifications whatsoever. From what I gather, that's rare, and my understanding is that this is because universities no longer really teach Perl and that the language has become superseded in favour of more hip languages like Python. So with little young talent coming up you're more or less left with some very high-level, experienced Perl programmers and those which have merely dabbled with the odd script, with little in between.
I have lots of reservations with what and how chromatic writes, but he does not deserve such comments.
Bad Perl programmers are ruining Perl reputation. Employers with bad Perl experience will never try new project in Perl, no matter how good you are. 
Forgive me for responding to myself, but this is what I had in mind: &gt;People not only learn as they go, but come from different backgrounds, and will learn a different subset of the language first. It's Officially Okay in the Perl realm to program in the subset of Perl corresponding to sed, or awk, or C, or shell, or BASIC, or Lisp, or Python. Or FORTRAN, even. Just because Perl is the melting pot of computer languages doesn't mean you have to stir. - Larry Wall, 1995/07/27, on comp.lang.perl.misc
I'm glad you brought that up. Seeing `&amp;` in front of function calls in Perl makes me wince, because it usually means either the code is horrifically old, or it was written by someone that didn't really know what they're doing, and sadly, "written by someone that didn't really know what they're doing" is not an attribute you want associated with any perl code that you are responsible for editing or maintaining. 
The `$` in front of `$sth-&gt;fetchrow_array()` really just applies to `$sth`, not the whole expression -- it doesn't say anything about the value returned from the method, it just means that you're doing something with the scalar `$sth`. In fact, when you're dealing with `-&gt;` (the arrow operator, or dereference operator), the thing on the left hand side can only really ever be a scalar (or a package name, with no sigil) so you would never see `@foo-&gt;...` or `%foo-&gt;...`. (But you could see `$foo[42]-&gt;...` or `$foo{bar}-&gt;...` and so on.) If you're coming from a Python background, everything in Python is a reference, whereas in Perl there's a mixture of value and reference semantics. That gives you more options, but it makes the syntax more cluttered. A nested dict in Python just looks like `foo['bar']['baz']`, and the closest equivalent in Perl is `$foo-&gt;{bar}{baz}`, where `$foo` is a hashref. You could also have the case where foo is just a hash (i.e. it's `%foo`), and in that case accessing the nested item would be `$foo{bar}{baz}`. Remember there's a rule that says that `-&gt;` between `}` and `{` can be omitted, so these last examples are really `$foo-&gt;{bar}-&gt;{baz}` and `$foo{bar}-&gt;{baz}` respectively. In other words, the first `-&gt;` may or may not be there, depending on whether you're dealing with a hashref or a hash, but all the rest after that must be there -- there's no choice -- because the way that a nested hash works in Perl is by storing hashrefs as the values. And since they must be there, there's no need to specify them, which is why that rule exists. 
Thanks for pointing that out. In this case, this code snippet is probably pretty old and has just been modified through the years for different purposes. I don't really have the slightest idea about the differences you mention, so I'll check the docs and read up on it.
&gt;I've read a bit about Perl references and I think this has something to do with creating a new reference to the hash. I have to admit that I still don't get references. Is there a short way to explain what that means? If you come from a C dialect, Perl references are like C pointers. (In some ways they can be like C++ references if you use the newish signatures of which I know nothing more than they exist). When you pass the hash to a subroutine by reference (by pointer) the subroutine is able to modify the hash in place. 
Thanks, that's very helpful! You touched on another thing that confused me when I read about it. I was under the impression that Perl couldn't do nested hashes like we do nested dictionaries in Python, and that was what hash references were for. As I understood it, instead of assigning a plain scalar as a value to a key, in order to get a nested dictionary, you create a reference of the sub hash and assign that as the value in the main hash. Is that correct or did I misunderstand? Based on what you wrote, I don't think I'm on the right track there.
The last time I tried to learn C++, I think George H W Bush (the first one) was still president. lol I think I'm starting to get it. If you just passed a hash to a subroutine, it would get flattened *and* the subroutine would just get a copy of it. If you pass the reference instead, the subroutine can modify the hash in place because the reference is like a pointer to the original hash. Actions taken on the reference will change the original because they're pointing to the same place in memory.
No, you're right, that's how nested hashes work in Perl. But because hashes auto-vivify, you don't really have to worry about explicitly creating anything, you can just assign away. This works fine: my $foo; $foo-&gt;{bar}{baz} = "quux"; Of course, you might instead have written that as: my $foo = { bar =&gt; { baz =&gt; "quux" } }; ...which is closer to the equivalent in Python: foo = {'bar': {'baz': 'quux'}} 
Holy cow. This is starting to make sense. I think I've figured out and learned more about Perl behavior in this thread than I have while reading about it. lol This is really going to help a lot. I'm not sure I've seen the term auto-vivify before. I can just assign a hash into another hash and Perl takes care of the reference for me behind the scenes? If so, I'm glad about that because I thought it was something we had to do and track manually. I hadn't really read that much on them yet, but I was imagining something like this: %hash1 = { foo =&gt; "bar" } $hash1_ref = \%hash1 %hash2 = { bletch =&gt; $hash1_ref } I don't even know if that code works, but it was what I was envisioning while reading about it. That would be a pain to maintain and would be hard to follow.
The point you're missing here is that %router was declared, but when you stick the \ before it then you're passing a reference to it. If you passed %router then it would pass the value of it (which can be expanded further, but for now just "the value"). ````\%router```` is a reference to it. If it helps think of it as if I pass you ````%router```` then I'm telling you what's on my shopping list. If I pass you \%router then I'm giving you access to the actual piece of paper that the shopping list is written on. In the first case you get a copy of the contents, so you can do what you want with it. Maybe you make a copy, maybe you change it. If you do, you change your version. However if I pass a reference (the actual shopping list) and you make changes to it then you're writing on the same piece of paper. So if you delete() something (cross it out) then I can see that, and if you add something, I can see that too. And you can also see that this is a good way to save memory because if you pass by value you allocate memory for all of the values. If you pass a reference then you only need enough memory for the reference. (Roughly speaking compare the time it takes me to tell you everything on the list and for you to write it down, vs me just handing you the paper). I hope it gives you an analogy that you can use as a frame of reference to clear things up in your head.
I don't think this is a new problem. If anything, the more popular a language is the worse this problem gets. Popularity just attracts more people, most of whom will not be very good programmers. I imagine that hiring a great PHP or Ruby programmer is as hard as hiring a great Perl programmer.
This is great stuff and is really helping me out a lot. I really appreciate your time! Thanks for the heads up on Devel::REPL, too. That is one of the things I miss about Python, because in Python I can very quickly test things in the shell. Without that, it's a bit more of a struggle to get things right. I'm not joking when I say that my first extremely simple Perl script took like 30 minutes to get right when I could code the same thing in Python in about a minute. An interpreter would have helped me to quickly figure out what I was doing wrong. Mostly I was just having trouble with contexts, sigils, braces and semicolons. :-) It's so hard to get into the habit of typing all those extra characters, especially trailing semicolons. I forget to type at least a third of them, but that will come with practice.
&gt; copy and paste osmosis from a barely-working heap of sticks left by the previous maintainer Did... did you just call my code a faggot?
Not your best title Gabor!
Any ideas why this won't work? I run this... ./ss2csv file.xls and I get this error... -jailshell: ./ss2csv: Permission denied
I don't really know anything about your environment, the term "jailshell" implies you're running in some kind of restricted environment? 
Okay, I got past that issue. It seems to be the permissions set on ss2csv. So, after I run it...this is the output I get: ./ss2csv FILE.xls csv Converting FILE.xls to csv... Complete I don't get the line "Writing sheet 1 to test_01.csv" or anything like your example. It says it's complete in the last line, but there is no .csv file anywhere. Thoughts? Thanks a bunch!
Well, I don't think I did anything to actually check if the file exists or anything. You've got the code, go nuts 
Komodo, Padre, occasionally Emacs. 
s/perl//ig
This is amazing. I have been looking for something just like this! 
Thank you. Ya they have written Yahoo store in C++ and Perl years ago from Lisp. But I think they moved on to PHP as a whole according to [Wiki](https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Programming languages used in most popular websites**](http://en.wikipedia.org/wiki/Programming%20languages%20used%20in%20most%20popular%20websites): [](#sfw) --- &gt; &gt;The most popular (i.e., the most visited) [websites](http://en.wikipedia.org/wiki/Website) have in common that they are [dynamic websites](http://en.wikipedia.org/wiki/Website#Dynamic_website). Their [development](http://en.wikipedia.org/wiki/Web_development) typically involves [server side coding](http://en.wikipedia.org/wiki/Web_development#Server_side_coding), [client side coding](http://en.wikipedia.org/wiki/Web_development#Client_side_coding) and [database technology](http://en.wikipedia.org/wiki/Web_development#Database_technology). The programming languages applied to deliver similar dynamic web content however vary vastly between sites. &gt;*data on programming languages are based on: &gt; &gt;* [HTTP](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) [Header](http://en.wikipedia.org/wiki/List_of_HTTP_header_fields) information &gt;* Request for file types &gt; &gt; --- ^Interesting: [^Computer ^science](http://en.wikipedia.org/wiki/Computer_science) ^| [^Lego ^Mindstorms](http://en.wikipedia.org/wiki/Lego_Mindstorms) ^| [^GTK+](http://en.wikipedia.org/wiki/GTK%2B) ^| [^DBase](http://en.wikipedia.org/wiki/DBase) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cft09bs) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cft09bs)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I think I will format the comments and build a list. Apologize me for any typo. Please keep adding with citations. Also look at * https://github.com/vmbrasseur/Perl_Companies * http://www.builtinperl.com * [Amazon](https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites) * [Craigslist](https://en.wikipedia.org/wiki/Perl#Applications) * [Slashdot](http://en.wikipedia.org/wiki/Slashdot) * [DuckDuckGo](http://highscalability.com/blog/2013/1/28/duckduckgo-architecture-1-million-deep-searches-a-day-and-gr.html)(https://duck.co/help/company/architecture) * [IMDb](http://www.imdb.com/help/search?domain=helpdesk_faq&amp;index=1&amp;file=techinfo) * [Shutterstock](http://shuttterstock.com/) * [LiveJournal](https://en.wikipedia.org/wiki/Perl#Applications) * [Fark](http://en.wikipedia.org/wiki/Fark) * Empoweredbenefits (www.empoweredbenefits.com) (Source : comments from covertPixel) * [athenahealth](http://www.athenahealth.com) has around 8 million lines of Perl. Source : A guy from Athena health tells it before Stevan little talk on Perl, the Detroit of scripting languages. * [Socialflow](http://www.socialflow.com/) (comments from EdibleEnergy) * [Topsy](http://www.topsy.com/) Wikipedia listed applications (https://en.wikipedia.org/wiki/Perl#Applications) * cPanel * Bugzilla * Movable Type * TWiki * RT * Ticketmaster * Booking.com * bbc.co.uk * Priceline.com [Other lists](http://royal.pingdom.com/2009/11/06/perl-far-from-dead-more-popular-than-you-think/) * Salon.com * The Register * Vox * Magazines.com * BBC * Zappos.com (seems they moved to Java.) * Craigslist (They also made a donation to the Perl foundation.) * Delicious Banks and financial institutions using Perl ( from comments of biffsocko ) * JP Morgan Chase * Bank of America * Morgan Stanley * Millenium Partners * Credit Suisse * Deutsche Bank I too build an Open Source dictionary by using Wikitionary dump and Perl . I used Perl to make the database of over 200000 words in 2 minutes from the dump. I used it for my [android app](http://goo.gl/UnNXzS). Thank you Perl. I am looking forward to build a front end in Perl and make it as a desktop app. Fork me if interested at [Github](https://github.com/tirkarthi/Wordzilla).
Too abstract for my brain
"You mentioned this is because Perl flattens objects when passed to functions" Perl flattens arrays and hashes to a list. Why? If you dont want to whitewash it (even the inventor says today): because of a design failure. So if you want to pass arrays or hashes it is a good idea to do this by reference. (with a \\) -&gt; does (in most cases) dereferencing. Both on objects (who are references in fact) to call methods as on array or hash references.
[doit](http://www.youtube.com/watch?v=JoqDYcCDOTg)
&gt; Crypt::Lucifer is an implementation of IBM's Lucifer block cipher from the 1970s. I will install this just for the name :)
Have you checked CPAN.org for SNMP modules? What do you mean by migrating from v3 to v3? There are lots of modules available. SNMP, Net::SNMP, SNMP::Util, SNMP::Info, ..... If you're already using Net::SNMP, I would test the latest version, put a little effort into finding why it doesn't work. maybe you can send a patch to the author. If not, try the other modules.. LIke I said, earch CPAN&lt; there are over 25 pages of SNMP modules ( Many of them sub-modules of a package, so it's that too long a list.) 
This kind of post is great, i hope it becomes routine.
Net::SNMP would be the best one to use, and it has some examples of v3 usage somewhere.
Yahoo is made up of many different departments though, I recall a few years ago several Perl people working in the Yahoo Finance group using Perl. They were all UK based, not sure if that is still the case or not.
We use Perl at The Genome Institute for everything from classic Bioinformatics to the LIMS (software to track samples and goop in the lab), finance tracking, and clinical information.
I really like these articles. Good for those that don't watch CPAN's recent feed everyday. Thanks for these! :-)
... http://search.cpan.org/~dtown/Net-SNMP-v6.0.1/lib/Net/SNMP.pm
Posted here because I really think the Perl community needs to do something to ditch that About.com link.
Perl isn't as sexy as other languages these days. Most people still using it are either greybeards, or too busy quietly getting shit done. Of course, this presents a challenge to the evolution of the language. I remain guardedly optimistic at the prospect of moarvm / jvm finally elevating perl6 from a toy language to a getting-shit-done language, but it requires earnest evangelism.
I am wrote up a bot now to track the users at r/perl per minute.
I figure Perl's like commuting. I know how to do it, I rely on it, it achieves a purpose - but it's not sexy and I don't often spod about it in my spare time. It's also a bit like Bash, basic adminning, breathing. Skills I've learned and now I know how to use them, I don't get that excited about it any more. Doesn't mean they're not important.
Earnest evangelism? Its funny how I think it requires the developers putting down their beers long enough to get their shite together to write and release something worth using. One of these years.
Build an arithmetic parser for (to start with) four-function arithmetic on floating-point numbers. Implement the parse tree using hash refs. Extra credit: carry out the calculation once it is parsed.
You might find some interesting problems in [r/dailyprogrammer](http://reddit.com/r/dailyprogrammer)
&gt; or too busy quietly getting shit done. This part is understated. The low readership rate on reddit may be because that we'd prefer to be writing and fixing the code, instead of talking about it. And that can give the impression we don't exist. Sure, sometimes we break out of our echo chambers, usually when somebody posts a link somewhere and a bunch of Perl people see it, and then you'll get a small river flowing in that direction. For example, you'll see Perl has sprung up in the community rankings on GitTip in the last week quite significantly, and this was catalysed by some chatter in the core IRC channel. Myself at least, I don't have much time to lounge and read reddit. There's interesting stuff here, don't get me wrong, but with regard to interesting things I can be learning and working on, there's a whole lot more going on in our IRC network that I'd rather pay attention to, and reddit and other social media outlets are really just leaves of the community, not integral parts. ( At least, that is how I perceive it )
perl is my work horse. I use it mainly for things that are uncomfortable to solve in bash. I don't use perl for interesting problems any more. Ironically http://hop.perl.plover.com/ is a reason for that. It lead me to lisp/clojure/erlang... 
&gt; We're all on IRC, or Perlmonks, or mailing lists, or in the pub. Maybe so, but Ruby and Python and PHP all have IRC channels and mailing lists and beer-fueled meetups and Stack Overflow (at least), and they have much more active subreddits. Seems like most answers here are dancing around and not saying "Because Perl's just not that popular anymore".
Why is it important to increase the readership?
&gt; For example, Ruby's VM was radically slower than Perl's to due a lot of missing optimizations. That situation has now completely reversed itself. What? I realize these are synthetic, but perl beats Ruby in 8 out of 12 benchmarks: http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=perl&amp;lang2=yarv&amp;data=u64q And with jRuby, perl wins 9 out of 12 times: http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=perl&amp;lang2=jruby&amp;data=u64q &gt; PHP gained pretty OO class syntax years ago. Oh, okay. Now I know you're joking. ;-) 
"How do we make Perl more popular?" After 7+ years as a Perl developer... You can't. I'm sorry. There have been many pushes to make it more popular. Enlightened, Modern, Ironman, MOPs, Mooses, Mouses, Moos, blogs.perl.org, new releases, metacpan, PresentingPerl and more I can't remember. I'm very, very sorry. We'll always have our Perl memories...at least until their last reference go out of scope.
PerlMonks isn't much of a news and discussion site. Most of the discussion is about the site itself. I've never seen that much overlap.
&gt; We'll always have our Perl memories...at least until their last reference go out of scope. No, due to all the circular references they won't go away until global destruction kicks in.
I too have found myself enjoying functional programming (especially Erlang) in my free time. However, when I need something done quick and right, Perl is always considered. Unfortunately, I have been forced into Python world because the teams I work on generally don't want to maintain Perl code. With functional programming being my new addiction and Python becoming my work horse, I find it hard to work in Perl time anymore.
For the "interesting" parts of anything I do, I use Matlab, C, C++, R, and sometimes even Fortran, but rarely does a project get done without Perl to glue it all together. I have no idea if any of my "interesting" languages even have subreddits, much less if they are active. The Ruby subreddit looks like a bunch of noobs and self-promoters, and it's very active. I don't worry about any of it much.
Back under your bridge
it's like there's a bot that downvotes everything.
&gt; How do you see the p6 effort turning out? I personally have no plans to use it for the foreseeable future. The struggles of the Python 2.x to 3.x library situation in particular seem like they'll be worse--but I admit, I stopped paying attention altogether sometime last year, so it's possible there's an extant solution in the works.
Because only a troll would believe that perl-6 ISN'T going exactly according to plan? You must want me to think perl-6 is the homeopathy of programming languages. The less there is the stronger it is.
Or half assing it. I read a long paper about some cool optimizations they did in one the Ruby implementations (and then dabbled around with some B in Perl to do the same thing in the very limited scenario). One of them was optimizing away hash lookups. JS does this too. If you can figure out from static analysis of the code what all of the possible hash keys are, you can internally rewrite hashes to be arrays. This is done on method lookup (symbol tables) and on plain old hashes. They gave some impressive numbers. Of course, neither Perl nor Ruby JIT (minus a few experiments such as Faster, and as far as I know). Usually micro-optimization (which is all that Perl has been doing) doesn't win the game, so I'm legitimately surprised by that outcome. Of course, Ruby is a heck of a lot faster than it used to be. This data you presented weighs the argument in favor of "because other things are new and cool".
I'm mostly thinking of #perl on IRC, though there are a lot of well known personalities in Perl famous for yelling at newbies and generally be arrogant, short tempered, and hostile. I myself have been known to go blue in the face trying to get their attention. petdance, Yaakov, and a band of other lead a concentrated effort to improve standards for behavior but #perl still reads like a Beavis and Butthead cartoon too often. It's hard to collaborate when people's only interest is dumb jokes.
&gt; This is more true socially than technically Really? Not only php but also Python wins against Perl. If you start from scratch, why use Perl instead of Python (technically)? Good is good, but better carries it. 
Just to play devils advocate a little: Why does there have to be a huge and active community around a programming language? I've been to a few local PyCon events and its pretty cool that people have a common interest and all but a lot of it is in the end, essentially, patting each other on the back.
The future of Perl no longer hinges on Perl6.
PerlMonks is a lot quieter than it was 10 years ago. The Newest Nodes list has a much shorter SoPW section, and Meditations rarely gets a new entry.
Perl needs a new killer app. Something that captures everyone's attention and becomes the thing you have to use to be hip.
Here's a suggestion: all Perl developers donate a portion of their income to the [Perl Foundation](http://www.perlfoundation.org/) and fund a better Perl 5.
Perl's strengths as a domain-specific language are diminishing. Perl needs a Reason To Live. CGI is obsolete except for prototyping. Perl is still the best language for parsing and system admin work, but neither of these will make Perl popular. For anything non-trivial, Java has better designing principles even if it is bloated. Also important is that it's relatively quick and easy to build a GUI in Java. A new language that's a winner needs to have type safety, sound OO principles, a performant concurrency model, and enable GUI development. OR... it needs to dominate an important domain. 
I hope you don't mind if I respond with an essay to your essay. (Goto [The actual response] or just scroll down) **[Intro]** I am also new to Perl. I have been using it for about 1 month, but I am familiar with programming in general. I did little Assembly in N.A.S.M., then little C, little C++ and eventually ended up using Python for about a year and a half. The reason I chose Python was the following: I need about the Perl vs Python kind of situation and I needed someone to tell me which is better since I had 0 experience in both. I found a page which did some comparisons which focused mainly on how certain things are done in Python and Perl. The page/blog talked about "opening" files and gave examples from both languages, and the biggest argument was "Look how easy to understand it is in Python and how confusing it is in Perl." Or something of that nature. **[My reasons for choosing Perl]** After seeing some more examples I was convinced that Perl was some sort of messed up syntax jungle. And have been critical of it ever since. But after some time in Python, something just wasn't entirely great about it. I was so used to messing around with references (from assembly and C), optimizing code for speed and the like. I wanted Python to be about programming, rather than "making it look nice, understandable" and the like. The more I worked with Python, the more I considered to switch to another language. I tried Ruby, but... It was so slow that I couldn't deal with it. I eventually got over my prejudice and tried Perl. The community and tutorials from like 2005 still were useful while learning it (Mainly on Perl-monks). Documentation is amazing, I hardly need to search on the web to get my answer. (Just occasionally, and even then, someone on Perl-monks points you to a Perl-doc). I eventually ditched Python entirely. Turns out that just because the syntax differs so much from other standard languages, doesn't say anything about it's potential. I was amazed by the things Perl allowed you to do, whereas other languages were so paranoid that "you'll break something" you had to do some crazy shit to get something done that is usually trivial. Thousands of wrappers and other things get added to simplify that task, just so that "you don't break something." One of the things that bummed me out in python, for example, was that you couldn't create a reference to anything. Because "Why would you want to do that? Everything is an object!" and it flipped me off sometimes. What if I want to create a reference to an object reference? "Blasphemy!" Seriously. If I get lost in my code, it's my fault for choosing a bad strategy. The language shouldn't restrict things just because it may be a bad strategy. **[Small rant]** I don't want this to look like Python hating, but it's a good comparison since both Perl and Python are pretty fast as interpreters, and have quite a lot of modules and what not. The thing here is this. It seems to me, that Python makes incompetent programmers, look more competent. Because of how readable python is, many people think they can start to learn to program in it and get deceived into believing, they know something about computers. Since personally I tried to read as many doc's about computers and their internal structure, when using python I always wanted to have at least some control over the memory, because python just ate it up like crazy. 6Mib Just to start up, yea great... "At least everything gets done for me." **[More thoughts]** While you cannot directly influence this in Perl either, you can at least manage your own references to save memory. Recursion solutions like "goto &amp;function" if memory becomes an issue (or Sub::Call::Tail). And an army of senior programmers who understand the guts of computers and Perl(or so I believe at least) to tell you why your code sucks and you should know better. Thing is, as many have pointed out. People who use Perl aren't vocal about it. Maybe also because "There might be a better way to do this, so I'd rather not teach people to use my flawed technique." Since there is hardly a "best" way to do something, what would you talk about? Is there a topic that hasn't been covered on Perl-monks or elsewhere? Dealing with criticism when you are starting out with a new language might be frustrating for a lot of people. If there is a "one best way" to do something, you learn that and nobody can criticize you. In many cases this seems to be Pythons philosophy since there are limits to effectiveness in it. I don't think you can say that about Perl even though it has it's own set of limits but they are more related to overall computation performance, then simplicity/readability of code. **[The actual response]** I feel stupid for not trying Perl sooner. Who cares about syntax when you actually get-shit-done? People that are new to programming, and don't know how to get-shit-done. Maybe all it takes is to be a bit more excited and talk about Perl outside of Perl-monks and the like. But I am new, hence my optimism. I slightly disagree on the sexiness issue here. For outsiders (like I was myself) syntax might scare people off(What is up with that dollar sign and weird bracketing?). But now love it. I have come to understand other peoples code fairly easily through it. It is obvious what is a list,scalar,hash and references to them respectively (although still tackling with dereferencing at times). Personally, I don't care much about Perl6. Perl5 looks great to me. If it can get greater than hurray, if not, not a big deal. And I can see why someone would use it. The biggest reason for me in choosing Perl was: It is closer to the machine than other languages. (Besides C,N.A.S.M and the like of course) **tl;dr [To the point]** It's not popular because of the crowd of other languages and loud people who get bamboozled by niceness of a language rather than examining it's technical pros&amp;cons. If I had to make a few suggestions, and if you really wish to spread Perl around: **1.** Stay optimistic. **2.** Show something really cool you can do in Perl and write about it. **3.** Don't forget about windows. It still exists. **4.** Demonstrate, compare and prove the particular benefits of using Perl. **5.** Brag about it, prepare to deal with criticism. **6.** If you are new, point it out to highlight that it is still good for those who start. Also gives chance to seniors to bother to look for flaws in your code and make it better. **7.** Research and do your best to create easy-to-follow tutorials, with best possible results. **8.** Make it look all nice and flashy, people who start out, still care about appearance. **9.** Put your Perl knowledge to use by creating nifty free Apps for people to use. (Windows included) **10.** Try to make sure it's better than the counterparts of other languages. This will raise the standard. **11.** Make it as bug-free as possible (obviously) **12.** Experiment This is all that came to my mind. Also, apologies for my terrible verbosity. 
g0zar++ I like the way you think. :-) And you make a very good point with how people don't talk about things because they are scared that their technique isn't the best. This is the wrong type of fear to have. What people should actually be thinking about is how much they can learn by sharing their problem with others. To me, that's exciting.
as probably the oldest guy (50+) that has been to YAPC::EU, 'proudly sponsored by the community' through the ['Send-a-Newby' program](http://www.send-a-newbie.enlightenedperl.org)… my personal experience is that those so called arrogant loud and bold guys on stage, are actually those that stand up for you and defend the newbies. I have yet to find the first hostile Perl developer that is not willing to patiently explain things to me, step by step.
perl-6 killed it dead enough already.
Still not mature enough to .spew out static HTML. Proudly served by PHP. Your dog food might be fetid.
You might have come onto the scene after the community made some sweeping changes here. And it did make some sweeping changes. They made changes because they do care about Perl and they realized that newbies are critical to Perl. It's fine to say that something isn't the reason, but what are your thoughts? Why is Perl in decline? (And it is in decline; szgabor has some hard numbers on it, and the "Perl appearing in job listings" thing is kind of a red herring because it's almost part of a long list of desired skills.) Edit: I'm revising my theory as to why Perl is in decline to "Perl's reference syntax". That's it. Nothing else.
&gt; Edit: I'm revising my theory as to why Perl is in decline to "Perl's reference syntax". That's it. Nothing else. Good thing the next major version of... oh. Oh, wait. Announced in 2000, you say?
Oh, I am sorry. I mean v2c. I am not sure why I put SNMPv3 twice, must have been tired. I will check out some of the ideas below. The Net::SNMP module I was using didn't work for some reason. I will check it out though, its a new day tomorrow and I will actually have gotten some sleep! 
Yeah, it seems weird. As much as I like Perl, I might even do this in shell: seq 1 10 | while read doc; do echo $doc &gt; /tmp/doc; $EDITOR /tmp/doc; cat /tmp/doc; done | cat -n Thought writing that, it strikes me that OP might instead actually want something like this: pipenedit() { rm /tmp/doc; while read $doc; do echo $doc &gt;&gt; /tmp/doc done $EDITOR /tmp/doc cat /tmp/doc } seq 1 10 | pipenedit | cat -n This actually looks better in Perl (pipe.pl): use strict; use warnings; use Term::EditorEdit; local $/; print Term::EditorEdit-&gt;edit( document =&gt; &lt;STDIN&gt;); ^^*nothing ^^has ^^been ^^tested, ^^there ^^are ^^probably ^^numerous ^^typos/thinkos.
As was pointed out on twitter, it would be nice for it to be large enough people can continue finding work in it.
I'm downvoting you too not because you're wrong but precisely because you're right. Yesss... let the hatred flow...
It never doesn't come back to that, does it? It's almost as if the network effect of who's using a language has something to do with its future.
You could try building and ad server to compete with Google's, but I think that is verging on advanced instead of intermediate. 
Kinda depends on what you mean by library. Can you paste the shell output?
Try adding a second $. You need to dereference the hashref.
That works! $$variables{'$array'}{'sigil'} Now I'm trying to get my head around the difference. In the first version $variables-&gt;{'scalar'}-&gt;{'sigil'} it doesn't matter that $variables is just a pointer, because that syntax is just using it as a kind of stepping stone to find its way to the last sub-element. But in the second version $variables{'scalar'}{'sigil'} the syntax is for accessing a member of an actual ~~array~~ hash -- and $variables, being a ~~pointer~~ reference, is not actually a ~~array~~ hash itself. But $$variables *is* a ~~array~~ hash... $$variables{'$array'}{'sigil'} Thanks for the help!
This: $var-&gt;{key1} Is the same as ${$var}{key1} This: `$var{key1}` is a hash, while this`$var-&gt;{key1}` is a hash reference. %hash = %{$hash} $hash{key1} = $hash-&gt;{key1} Does that help? 
The hash ref and hash thing is clear. But why is the following working: $variables-&gt;{'scalar'}{'sigil'} when the thing stored in $variables-&gt;{'scalar'} is hash ref? Like these notations I understand: $variables-&gt;{'scalar'}-&gt;{'sigil'} ${$variables-&gt;{'scalar'}}{'sigil'} edit: formatting 
Yes. Thanks! 
**$variable{key}** is saying "there is a hash named %variable; I'm going to look up the value for 'key' in it". **$variable-&gt;{key}** says "I have a hash reference in the scalar $variable, and I'll look up the value for 'key' in the anonymous hash referenced by $variable". It's a rather unfortunate syntax, caused by the decision to represent hash elements as scalars instead of retaining the same sigil in all cases. I believe that Perl 6 retains the sigil, but I haven't looked at the language spec in some time.
&gt;But why is the following working: &gt;$variables-&gt;{'scalar'}{'sigil'} The arrow is the infix dereference operator. Since [subscripts next to subscripts imply references](http://stackoverflow.com/questions/2475042/nested-dereferencing-arrows-in-perl-to-omit-or-not-to-omit), requiring multiple arrows is not necessary. 
«the syntax [of a] language doesn't say anything about [its] potential» *This*.
The only thing Perl 6 has been good for, is poisoning Perl 5 to death. Why, Larry, why? **bangs head on keyboard**
Textbook case: http://en.wikipedia.org/wiki/Osborne_effect
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Osborne effect**](http://en.wikipedia.org/wiki/Osborne%20effect): [](#sfw) --- &gt;The **Osborne effect** is a term referring to the [unintended consequences](http://en.wikipedia.org/wiki/Unintended_consequences) of a company pre-announcement made either unaware of the risks involved or when the timing is misjudged, which ends up having a negative impact on the sales of the current product. This is often the case when a product is announced too long before its actual availability. This has the immediate effect of customers canceling or deferring orders for the current product, knowing that it will soon be obsolete, and any unexpected delays often means the new product comes to be perceived as [vaporware](http://en.wikipedia.org/wiki/Vaporware), damaging the company's credibility and profitability. &gt; --- ^Interesting: [^Osborne ^Computer ^Corporation](http://en.wikipedia.org/wiki/Osborne_Computer_Corporation) ^| [^Adam ^Osborne](http://en.wikipedia.org/wiki/Adam_Osborne) ^| [^Osborne ^1](http://en.wikipedia.org/wiki/Osborne_1) ^| [^Self-defeating ^prophecy](http://en.wikipedia.org/wiki/Self-defeating_prophecy) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cfxgzsz) ^or[](#or) [^delete](http://www.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cfxgzsz)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I wrote a brainfuck code generator available at https://github.com/tirkarthi/Brainf-ck . I am thinking to write a terminal based open source dictionary in which you can find meanings of the words from the terminal.
Wow, keep going, and learning! I kinda like it, and the form meets the purpose. For sure speed questions of the perl program are negligible. The only thing that I really would do in another way is a seperation of printing and bfck-code generation (replace the `print` in your subroutines with `return`s and make a sub that generates the bf code). Keep goin'!
s/array/hash/; and throw a couple "-ref"s in there and youre spot on.
&gt;It's a rather unfortunate syntax, caused by the decision to represent hash elements as scalars instead of retaining the same sigil in all cases. The reason is because of what the resultant type is. %hash; @array; would evaluate to a hash and array respectively. $hash{'key'}; $array[2]; $scalar; all evaluate to a scalar. @array[2,3]; @hash{'key1','key2'}; both evaluate to lists (which are very similar to arrays, for those unfamiliar with the Perl list concept) That said, the language *probably* could have handled keeping the same sigil in all cases. 
I thought the problem with my original syntax was I needed one more sigil. **$variable{'key'}** was saying "I have a hash reference in the scalar *$variable,* and I'll use the key *'key'* to find the value associated with *'key'* in that......scalar variable. Since scalar variables don't hold key/value pairs, that didn't work, and I needed one more change. **$$variable{'key'}** is saying "I have a hash reference in the scalar *$variable,* and I'd like to dereference it into an actual hash array with *$$variable*, so that I may then use the key *'key'* on that hash array to retrieve a value that's associated with *'key'*...
I wouldn't argue that mod_perl is as easy at PHP but PHP is not any more "built in" than mod_perl.
&gt; we are fucked unless we can come up with something that will excite the community, because everyone's getting bored and going off and doing other things - Jon Orwant at The Perl Conference in 2000 14 years ago Perl was stagnating, the community fracturing and people were having the same conversation we're having now. If it hadn't been for the Perl 6 project would the slow death have continued? Would someone else have come up with a better plan? Perhaps Perl 6 could have been managed better but, you know, you get what you pay for. It is really not helpful to look back with hindsight and say "well, they really fucked that up, didn't they?"
Oh this is more perl hate so common from the python community. Here's how to look at it: python helps you think more like the computer. Perl helps the computer think more like you. Otherwise there's not much difference between them. 
&gt; Perl on the Web requires mod_perl or some similar Apache extension Not any more. The situation now is identical to that in ruby and python but with better deployment tools. 
If you're talking about a system library, then the short answer is "XS" and "XSLoader". The long answer is http://blog.booking.com/native-extensions-for-perl-without-smoke-and-mirrors.html
Perl is very alive. I would never consider using python if I had to choose something else.
No. Definetily not. There was a comparison recently on reddit between Perl and Python out of a Python book. The challenge was to zip and sum elements of 2 arrays. Somebody saw it, compared it with a better, state of the art Perl version and postet this on reddit. In my eyes it looked very good for Perl - until the Python guys also saw this and took out their magic. There was no chance for Perl. The Python code was clearer and shorter. At least Perl6 with its Z+ operator was able to keep up.
I saw that discussion. It was very subjective, and in any case one of the later iterations of either was fine. O(n) they're the same thing. [edit] In fact, I'd go so far as to say that a single line where the outcome is O(n) similar is of almost no relevance. It's like one of those artifical benchmarks doing a hello world to find out how fast a framework is.
&gt; It is really not helpful to look back with hindsight.... Seems valuable to be able to warn other communities about the dangers of fragmenting a community.
Good stuff! A couple of things I noticed: &gt; chomp( my $user = qx'echo $USER' ); You can reference environment variables like this: $ENV{USER} But you probably want to lookup `$ENV{HOME}` which is the conventional environment variable holding the user's home directory. You could interpolate it into the `$db_file` string like so: my $db_file = "$ENV{HOME}/Wordzilla"; Also this: my $sth = $dbh-&gt;prepare("SELECT * from $char where word = '$word';"); You've got an SQL injection attack waiting to happen there. Consider the SQL query that gets generated for something like this: $ Wordzilla "Robert'; DROP TABLE r; --" (See: http://xkcd.com/327/) The SQL would be (roughly): SELECT * from r where word = 'Robert'; DROP TABLE r; --' I'm sure you can see the problem. The correct solution here is to use a placeholder variable: my $sth = $dbh-&gt;prepare("SELECT * from $char where word = ?"); And then pass the value in to `execute()` $sth-&gt;execute($word); More info on placeholders here: http://search.cpan.org/~timb/DBI-1.631/DBI.pm#Placeholders_and_Bind_Values Hope that helps!
Your and pemungkah's original comments (and most in /r/perl) were about Perl 5, aka Perl to most folk. I can see from your comments that you have developed a solid understanding of what's going on with hash references and dereferencing in Perl 5. Please let that be your primary takeaway. :) ---- The rest of this comment is to explain my comment and why you should probably just ignore it. :) Larry Wall (the original author of Perls 1 thru 5) working with Damian Conway and many others, has designed another language in the Perl family which I prefer to call P6. P6 has syntax, semantics, and so on reminiscent of Perl 5 -- but it is *not* backwards compatible because it fixes aspects of Perl 5 that Larry et al considered "less than awesome" such as the awkward aspects of references and sigils that are cases in point in this thread. My earlier comment was showing the P6 equivalent of pemungkah's comment (which of course showed Perl 5 code). As you can see, P6 code is not compatible with Perl 5. For completeness, here are some P6 equivalents of what you wrote above: **$variable{'key'}** is saying "I have a hash reference in the scalar $variable, and I'll use the key 'key' to find the value associated with 'key' in that......(hash, as dereferenced from the hash reference stored in the) scalar variable. So, in P6, you wouldn't need to do the next bit, but if you did then: **$$variable{'key'}** is saying the same as the above, but adds a (redundant in all cases I can think of) $ prefix op which imposes item (ie singular rather than plural) context on the result. Anyhow, all of this is a red herring for the average P5er. You can safely enjoy P5, knowing that, in parallel paths, a bunch of P5ers are still evolving the all powerful P5 while a small band of P6ers are trying to create a somewhat related "new" language and ecosystem.
Cpanminus has been awesome.
Great code. My two suggestions are small gripes. Firstly, I like to just add the -w flag on the first line rather than explicitly putting in `use warnings` (but this is entirely a matter of preference). Secondly, it'd be awesome if you could comment the code a little. I applaud your naming techniques, but a few comments are always welcome. Keep up the great work, I hope you come to love the language as much as I do!
It's starting to sound like Black Metal.
It's not about speed. It's about writing cooler code. Python map(sum, zip(list1, list2)) Perl map { $list1-&gt;[$_] + $list2-&gt;[$_] } 0..$#$list1; Ok, lets go through the code, why is the Python-Code better - Perl has this annoying difference between Array and Arrayref. - Perl has no tuples or real Array types, so the zip just would return a flattened list - because of that, map has to be misapplied and used as a simple index-Counter So looking at this example I cannot imagine why you think "Perl helps the computer think more like you". The example Shows exactly the opposite. I don't know Python very well, but the examples I saw so far are at least comparable to Perl, often a little touch better.
It has. And I'm pretty sure that I didn't say anything to the contrary in my article. All I'm saying is that it might not be the *best* tool for use in *all* cases.
One line does not a program make. For example in this 50k line perl codebase I have to hand (modules only no tests) I see ... [goes off to check] ... 70 uses of map and 30 of grep. In fact I might want to argue that perl's 'messier' syntax leads to binding closer to humans' messy thought processes. So long as you're disciplined and buy into the social contract that is. Another way of putting it: python is perl for bureaucrats. But what it really is for me, is that over every other language I've used, perl's documentation and culture of documentation wins every time, hands down, without a doubt. So my argument is basically, python, perl, the same thing barring some details (python sacrifices at the altar of flexibility, perl at the alter of rigidly enforcing convention). I quite understand why big orgs like to use python, as it's a sweet spot between java/c# and perl.
.. just a reminder: `warnings`/`-w` is not &gt; entirely a matter of preference [warnings - perldoc.perl.org](http://perldoc.perl.org/warnings.html) says: &gt; The `warnings` pragma is a replacement for the command line flag `-w`, **but** the pragma is limited to the enclosing block, while the flag is global. (my emphasis)
The reason is, that $variables{'scalar'} accesses a key in a hash named %variables. $variables-&gt;{'scalar'} accesses a key in a hash reference named $variables. Why can you leave the arrow out between keys: A hash key can only contain a single value, a scalar. A hash can not be inside as it is no scalar. So it MUST be a hash reference. And as there is no choice you can leave the arrow out because it is clear for Perl that it must be a reference.
I see your point but after thinking about it a while I'm not totally convinced. I find that trying to install Perl modules into system Perl (either with CPAN or using a systems package manager) to be a totally screw up down the road (and often immediately). If there is a Perl application that people want to just install for use purposes (like a blog, or some system monitoring tools) part of me thinks it would be best if that tool was available as like a virtual machine or maybe as a docker container. Thats much more a 'install and use' it approach. Using system Perl... at some point the system will make some sort of security related change and kill your code. Or any of a number of other problems. Installing perlbrew or plenv and getting this setup right is not a lot of extra work either. My two cents. -jnap
Wow, I never knew. I always added the -w flag to each script, so I never knew that `use warnings` would be limited in scope (though it makes sense given how Perl operates).
I hear you about not trying Perl earlier. I too have been coaxed into using Python. Python? Yep. The new first language for most, including me - about 6 years ago. Nowadays it's used at MIT as an for-idiots introduction to the object-oriented stink so people are ready to dive into Java and never learn anything else. Fan-fucking-tastic. Google has reportedly ditched it for something that actually performs well (the somewhat underrated Go) and even got rid of Guido in the process, because nobody is going to wait for PyPy (praise be upon it) to finally support Python 3. I can see people sticking with Python 2.7 for the next ten years because it "just works". Shows how much the community cares about the entire platform. Laughable. And let's not forget Ruby now that I'm ranting anyway. A terrible ecosystem focused primarily on web development. Everybody can develop web applications with it because everything is done for you. Hit the any key and an entire web application is shat out for you in seconds. No need to design templates (Bootstrap), no need to write code (Rails), no need to work with databases (ORMs), just use a cutesy DSL to insert some stuff into a database, write 3 lines of code to communicate with it, dump it in a template which automatically gets converted to HTML and you're done. Zero skill is needed for this. Coincidentally, most people have zero programming skills. The rest is history, as they say.
If you want to make an HTTP request and digest the result I most often use Mojo::UserAgent (http://mojolicio.us/perldoc/Mojo/UserAgent) since it has JSON path and nice methods for slicing and dicing the data. Otherwise JSON::XS directly to do whatever I want just manipulating a nested Perl hash.
JSON::XS is really all you need.
JSON::XS - it's written in C and incredibly fast. Use it as a serializer. Like these other fine gentlemen have said.
Nice /u/6timo! I had no idea someone was doing this.
I have enjoyed working with [Mojo::JSON](https://metacpan.org/pod/Mojo::JSON) lately.
Might not have 10 drivers but there is DBIish in Perl6 for SQLite, PostrgreSQL and MySQL, looks like its been touched recently no idea if it works... https://github.com/perl6/DBIish/. There are separate MongoDB and Redis modules too. So 50% ready? Christmas is in another decade for some.
Reading the headline, I thought you it was a reference to this: https://www.youtube.com/watch?v=HJe0-NHqXk8 ... and you were bringing an actor to YAPC.
I used JSON::RPC for the first time today, to communicate with a dogecoin testnet daemon. It was surprisingly straightforward :)
https://metacpan.org/pod/JSON::MaybeXS or just https://metacpan.org/pod/Cpanel::JSON::XS
[Bus Pirate hacking opportunity](http://blogs.perl.org/users/robert_blackwell/2014/03/bus-pirate-hacking-opportunity.html)
You may want to set up a passwordless `ssh` session. Look [here](http://www.tecmint.com/ssh-passwordless-login-using-ssh-keygen-in-5-easy-steps/) or elsewhere. Moreover, you can pass `ssh` a command to run on a remote host. Like: $ ssh me@myhost "ls /path/to/log/folder" or $ ssh me@myhost "tail -10 /path/to/log/folder/*"
Create a SSH certificate, and put your public key on the server (in the ~/.ssh/authorized_keys file). Now you can always ssh to that server from that client without a password. If you have a recent version of sshd on the server you can configure it so that the connections done with that certificate are limited or sandboxed, but this can be complicated.
Hey this is great, nice job. One thing to consider - can you put the core functionality into a module? That way it could be re-used for other purposes. For instance the search and parts-of-speech functionality could be incorporated into a natural language processing engine.
ssh-keygen is the command you're looking for to generate your ssh keys. Then you can manually copy the key, or use a utility called 'ssh-copy-id' (which is not generally a standard utility that comes with most linux distros or Mac OSX, but you can use brew or other packaging utilities to get it). The server also needs to support key-based logins, but I think that's set by default in most distributions.
In case it isn't immediately obvious, you can trigger your own scripts on the remote machine to do everything you want in one go: ssh me@myhost "/home/me/myScript.sh" 
If you want to avoid warnings, the best way you can do a switch-like statement is with an `if(...)`{},`elsif(...){}`,`else{}` Since *perl&gt;=5.16* you will always get a warning when using `given`, bellow that version this warning doesn't appear. There is also an interesting thread on [PerlMonks](http://www.perlmonks.org/?node_id=308901) that discusses this. But I guess you already saw that. The link is from 2003 and I really doubt we got any closer to *the* best way to do this.
Or even $ ssh me@myhost 'bash -s' &lt; /local/path/script.sh
I use dispatch tables. They replace the ugly if else stuff and as far as i know are not experimental. if you search google for "perl + dispatch table" you will find loads of information on them. Like anything in perl, there is more than one way to do it, so personal style likely will come into play as well. 
Thank you. I am sorry as I am a newbie I don't get you. I am thinking to port it to other languages and make a single ready to install package. But I don't know how to bundle SQLite3 with it. Happy if you find the app useful :-)
...with bonus points for working in *sed*, *expect*, or *chat*.
A little bit of named pipes, `nc`, and port forwarding over `ssh` can go a long way.
`ssh-copy-id` is 1.2MB in brew, while this does the same: $ cat .ssh/id_rsa.pub | ssh me@myhost 'mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys' ...and is only 100 bytes or so.
Needs more `wget`
also called dispatch table.
Use a computed goto: http://en.wikipedia.org/wiki/Computed_goto my $label = 'thing' . int rand 3; for ($label) { goto $_; thing0: print "case 0\n"; thing1: print "case 1\n"; last; thing2: print "case 2\n"; };
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Computed goto**](http://en.wikipedia.org/wiki/Computed%20goto): [](#sfw) --- &gt;__Goto__ (__goto__, __GOTO__, __GO TO__ or other case combinations, depending on the programming language) is a [statement](http://en.wikipedia.org/wiki/Statement_(programming\)) found in many computer [programming languages](http://en.wikipedia.org/wiki/Programming_language). It performs a __one-way transfer__ of control to another line of code; in contrast a [function call](http://en.wikipedia.org/wiki/Subroutine) normally returns control. The jumped-to locations are usually identified using [labels](http://en.wikipedia.org/wiki/Label_(programming_language\)), though some languages use [line numbers](http://en.wikipedia.org/wiki/Line_number). At the [machine code](http://en.wikipedia.org/wiki/Machine_code) level, a goto is a form of [branch or jump statement](http://en.wikipedia.org/wiki/Branch_(computer_science\)). Many languages support the goto statement, and many do not; see language support for discussion. &gt; --- ^Interesting: [^Goto](http://en.wikipedia.org/wiki/Goto) ^| [^PIC ^microcontroller](http://en.wikipedia.org/wiki/PIC_microcontroller) ^| [^Branch ^table](http://en.wikipedia.org/wiki/Branch_table) ^| [^Fortran](http://en.wikipedia.org/wiki/Fortran) ^| [^BASIC09](http://en.wikipedia.org/wiki/BASIC09) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cg02snd) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cg02snd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Before given/when, I would sometimes use the SWITCH:for style from [perlfaq](http://perldoc.perl.org/perlfaq7.html#How-do-I-create-a-switch-or-case-statement?). Dispatch tables are good but sometimes you need more flexibility. There are some CPAN modules available. I see two suggested [here](http://www.reddit.com/r/perl/comments/1w154n/givenwhen_is_now_experimental_should_i_stop_using/).
[Pinto](http://search.cpan.org/~thaljef/Pinto-0.0994/lib/Pinto.pm).
Dispatch tables as already suggested. Chapter 2 of Higher Order Perl covers the topic, which is available online. [http://hop.perl.plover.com/book/](http://hop.perl.plover.com/book/). If you'd prefer to use something from CPAN [Switch::Plain](http://metacpan.org/pod/Switch::Plain)
At first I thought I was in /r/linuxadmin I will go ahead and post my non-perl related answer. It seems the solution to your specific question has been answer, however there might be another way to do what you want. You could setup syslogd to send to a log server and then just parse the log files locally. Probably much easier (and safer) than trying to do it via ssh.
GlusterFS is slow. Slow. Slow. Did I mention how slow it is? You might find the best way forward is to install your perl and your modules beneath a common prefix, then deploy via rsync. Something like /opt/perl, for example. (This assumes that you have the same OS/architecture/similar.)
Hi, Its hard to know without knowing the company and the tech stack. If the company is Modern Perl or are stuck on modPerl and 5.8.8 for example? FWIW I have often done a pair programming exercise where we build a simple application, such as a personal blog or commenting system, or so forth. I'm personally more interested in knowing what it is like to work with someone and to learn how independent they are in terms of guidance (I prefer people that are willing to dive out of their comfort zone since I often don't have time for a lot of hand holding). But try to give us more!
Carton and use module cache. You can scp cache for faster installs. 
For modern versions of Perl, use `given`/`when`. For older versions, you can pick between dispatch tables or "`switch` is really spelled `for`". Dispatch tables look something like: my $table = { case1 =&gt; sub { do stuff }, case2 =&gt; sub { do other stuff }, case3 =&gt; 'some_method_name' }; And then some checks: # $criteria is your input.. my $thing = $table-&gt;{$criteria}; if( ref $thing eq 'CODE' ) { $result = $thing-&gt;(); # Args if you want! } else { $result = $self-&gt;$thing(); } There's lots of permutations. The obvious benefit is you get to pick what sort of things you store in your dispatch table. A bunch of subrefs? Method names? Raw values? You also get to fiddle with how it's handled, as above. The other option is to treat `for` like `switch`. The syntax is a little different, but you basically pretend you're iterating over a list of a single item (you are) and test various things based on the value. Ie: for( $criteria ) { /case1/ &amp;&amp; do { do_stuff; last; }; /case2/ &amp;&amp; do { do_other_stuff; last; }; do { default_stuff; last; }; } This works by assigning the value of `$criteria` to `$_` and then matching `$_` against the various regexes, coupled with the `&amp;&amp;` operator to execute whatever's in the `do{}` block. The upside: It's a somewhat familiar syntax. It'll work on super-old versions of Perl. The downside is you're going to test each case until you get to the bottom.
Huh. Perl can do switch statements? I still yearned for the Pascal of my youth and it's switch statements. Time to go clean up some hideous if/elsif/else nightmare code.
I'm sad to see you got downvoted. I think it has to do with some people's indocrination about how evil *goto* is. The example you showed shows the exact opposite of the major criticism of *goto*, in that it makes your code structured, and easy to maintain. Let's put doctrine away, people.
[autoexpect](http://linux.die.net/man/1/autoexpect) so you don't have to write the tcl from scratch.
Oh! That's what it looks like! I stumbled upon doing the same thing with Python's dictionaries and lambdas without really knowing there was a name for it. Thanks!
TIL I've been using dispatch tables without knowing they were a thing or what they were called. 
If the boxes are the same os/hardware, would this have a good chance of working? I mean even an hourly rync via cron would be easy if it would actually _work_. I figured that it couldn't be :)
What makes you think it wouldn't work?
If this deals with the right format for keepassx, you might be able to use perl directly. http://search.cpan.org/~rhandom/File-KeePass-2.03/lib/File/KeePass.pm
I got asked to test a rand function. It was very Socratic, for every answer he shut down my argument with another question. What does f(x,y){ return x + MS_rand(x-y); } do? &gt; random number between x and y Inclusive? &gt; Depends, is MS_Rand inclusive? Maybe. It's hidden away in a DLL, shell script, what have you. How would you test it? &gt; answer Okay, test passed, it's the standard [min, max) inclusive. Now they're complaining the numbers are wrong. &gt;How wrong? It only returns max or min. You track down the engineer and tell them to fix it. How to you prove it's fixed? &gt; $Test for uniformity Okay, now assume it's uniform frequency. But... they're in order. Test for sequences. Test for uniform time. etc. etc. 
Did you know that you can dispatch code references as I'd they were methods? `$result = $self-&gt;$thing()` works for code references and strings
Actually, yeah. It was more a demonstration of the idea that you can do different stuff.. I couldn't come up with something on the fly that illustrated that.
Yes, it would work.
I've staked my career on asking stupid questions without fearing how stupid I look when I ask them. It takes a small amount of brass in your balls, but I'm convinced it's better than the alternatives.
&gt; I figure Perl's like commuting. I know how to do it, I rely on it, it achieves a purpose - but it's not sexy and I don't often spod about it in my spare time. Oh wow, interesting analogy. Because perl enables not to commute (unless you count walking downstairs as commuting). Doesn't matter that it's javascript that keeps my brain occupied during much of my billable hours it was perl that helped me get there, and the perl mental model that keeps my javascript life sane. My wife commutes to her job (similar level of difficulty to mine, different problem space) and I know who has the better deal. She lacks the patience to sling code for a living though.
I am not a great fan of switch statements when you have to maintain existing code. Either they are not very powerful or they have weired syntax (at least more weired than an elsif) So most times the issue starts simple and later in several cases that I saw, the programmer introduced wild hacks to keep the switch construction working.
Wow for a Perl interview... This is more like a formal methods gotcha for writing crypto in C! 
Dispatch tables are a gateway drug to functional programming. You have been warned.
I take it you haven't seen how horrible some cascading if/elsif/else blocks can look.
Uh, no discussion of the legendary vaporware-like status of Perl 6? I also think there are some legacy warts in Perl that make it unappealing (list flattening, so you have to use references for multi-dimensional data, is kind of a hurdle, for instance) to new users.
I really do not think that Perl 6 was part of the problem. PHP and Python gaining in that arena started before that I believe. /u/jimbobhickville has the right explanation or "close enough".
The "Perl is bad" meme came from Perl's own success. It is so easy to pick up that an entire generation of self-taught programmers did pick it up. But there's no built-in correction for a certain style or for any sort of coding hygiene. You're supposed to provide that yourself. If you are an experienced or well-trained coder, you code with good hygiene as a matter of habit. If you are a self-taught cowboy, you do not. Perl is uniquely capable of being obfuscated and uglified to the point of incomprehensibility -- I know of no other language (even jokes like Brainfuck or Intercal) that can spiral so quickly out of control. The result was that tons of buggy, incomprehensible perl code flooded the world in the late 1990s. During that time and through the early 21st century, *most people with Perl experience were working with someone else's crappy cowboy code*, and crappy Perl code is the crappiest code of all. Python aimed for being more rigorous. Python::Perl as Pascal::C. Since the language itself and the Python culture both focus on directing style toward one reasonably hygienic standard, crappy Python code is not nearly so crappy as crappy Perl code. That led to another major blow to Perl: *Python, like Pascal before it, was adopted by the world's CS departments as the introductory language of choice*. This means that, since about 2002, every year sees an entire graduating class of fresh Bachelor's students with experience in nothing else but Python and a vague memory of the professor telling them that Perl is bad. That is a huge advantage for any language -- in the past, it was strong enough to cause people to write entire operating systems in the deliberately crippled teaching language Pascal instead of the more appropriate C. (Early MacOS is an example - though Apple came to its senses and gradually migrated everything to C over the early 1990s...) The Perl 6 debacle didn't help either. While Perl continues to be a great language, the writing is on the wall - it is destined to be a great *niche* language while the Python juggernaut continues rolling along (in the near-to-moderate term anyway). I am a [PDL](http://pdl.perl.org) developer, and I've been amazed for the last decade or so that a small group of us have been able to outdo the major data analysis languages of the world for so long. Careful early design and orthogonality have made PDL more powerful than even IDL or NumPy for general purpose numerical computing, for many years -- despite PDL having a small fraction of the developer hours available to either of those languages. But this year the available tools for Python seem to have caught up and - for image processing, computer vision, etc. - surpassed what can be done easily with PDL. I don't see that trend reversing, simply because Python has so much mindshare among the brilliant, ambitious 20-somethings who do most of the tool-building. Don't get me wrong -- Perl is awesome to use (especially with PDL :-). But awesome is different from dominant.
Thank you for the comments! I actually found out a local jump box has the module Net::SSH::Perl already installed so I'm going to run it from there instead of my laptop. A few things about the environment, we have too many hosts to install this locally for now, and I would need approval to package it for deployment. In the mean time, it would be a test script and until it's fine tuned (someone fixing my perl code) it would not go into a production state. Using Net::SSH::Perl has pretty much solved the issue. :) Yay cpan. 
I was asked on an interview to examine a regular expression and tell the development team what it would do. [I told them I was nervous enough that I couldn't remember what one of the common expressions did. They told me, so I proceeded to tell them exactly what the expression would do. Their faces dropped in amazement, as I was apparently the first to do so. But the company took a bit too long on making the offer and lost me to another.]
The classic mentality of "Oh, Oh! This is new. I must go do that instead." even though the current tool more than fits your needs.
Unfortunately that's less and less the case. At the places I encounter many sysadmin will prefer to use Python as they need to do some xml processing or some other task that requires a CPAN module. Even they don't have an easy way to install CPAN modules. (e.g. RedHat does not provide a lot of CPAN packages and installing directly from CPAN might require dealing with the legal department.)
Hype doesn't have a strong influence in language market share. Three top languages are Java, C#, and Python... but the hip new languages are ruby, haskell, node.js and so on. Hype helps, but ruby on rails only started to become dominant when the hype was replaced with corporate acceptance... and very few people are jumping ship on Java.
&gt; RedHat does not provide a lot of CPAN packages I'm not sure that's true. I mean, yes, all Linux distributions only package a small sub-set of CPAN. And, yes, there are a lot fewer RPMs than DEBs. But those numbers increase all of the time and I think that most of the important modules are included. To get the best selection, you probably need the EPEL repository enabled (https://fedoraproject.org/wiki/EPEL). That gives RHEL (and, therefore, also Centos, Scientific Linux,etc) access to the packages that are available for Fedora but not in the default RedHat repos.
&gt; The Perl 6 debacle didn't help either. Perl 6 both hindered and helped. Yes, by squatting on our next major version number for over a decade it has managed to give people (albeit people who aren't looking very hard) the idea that Perl has stagnated. But, on the other hand, many of the innovations in Perl over the last ten years or so (Moose being a great example) come from people getting bored of waiting to use Perl 6.
While what you say is true, it seems to argue a given. Every big language (that isn't super-legacy) was once hyped because the world wouldn't dream of picking up D as their language of choice. But if you look at the rise from "hyped contender" to top 5, and the equivalent drops... most languages don't hit top 5 *because* of hype, and none lose their place because of hype. The top several languages are either established languages, or aren't languages that were truly most hyped. Python beat ruby, hands down, in the growth game...but Ruby was hyped a whole heck of a lot more. And Java is still beating most contenders. It hasn't been hip since 2000.
I generally have 0 issues about using EPEL packaging in production, and at least the Red Hat users I know in corporate environments incorporate it frequently. EPEL is a guaranteed non-conflicting repo for RHEL and the packaging is typically up to snuff and Red Hat conventions given its origins. When you need it, you need it unless you'd like to RPM up everything yourself. 
The Perl 6 project is extremely ambitious both in the language design and the original implementation. Combine that with the lack of funding for full-time, dedicated developers.
Perl has a future in [artificial intelligence](http://mind.sourceforge.net/perl.html). [CPAN](http://www.cpan.org/authors/id/M/ME/MENTIFEX/mind.txt) needs to be populated with [AI Mind-Modules](http://ai.neocities.org/AiSteps.html). 
I would say that PHP has the same limitations as perl in terms of code quality, but it established itself as being newbie friendly by having a very good website with lots of examples for it's routines. It also had some builtin things that required addons in perl which made it even easier to use (mysql, and the easy ability to include files and it's builtin ability to be a template language)
re: the image processing and computer vision tools. I work in this area and I would love to be able to write more Perl for these problems (instead of mostly MATLAB. Because Python still can't compete with MATLAB's entrenchment.) One thing scientific Perl *can* compete on is having more complete libraries. Python may have lots of scientific libraries, but there are major gaps that mean that keep me writing MATLAB/C/C++ code. Plus, the docs for most Python libraries aren't very good either, the notable exception being the scikit-* libraries. If only I had more tuits right now.
Have a look at PDL -- you might like what you find well enough to stop messing around at Matlab... :-)
&gt; people getting bored of waiting That's one way of looking at it, but you also have to account for: * people who have no intention to use P6 * people who'd have written things like Moose or Try::Tiny or Mojolicious regardless of any P6 * people who've moved on to other languages for whatever reason * features borrowed from P6 which just didn't work out at all
You obviously know more about this than I do so I'm willing to take your word for it but do you really think that "a couple of developer years" should have been enough for what P6 is trying to accomplish? Have you ever compared it to commercially developed languages or even PHP/Python/Ruby?
Focusing solely on the idea of a paucity of funding ignores a rootier root cause: the enthusiasm gap. In the beginning, the project had a huge amount of enthusiasm. Over the years, more people than I can count have dropped in, contributed, then left. After almost 14 years, I think it's a fair criticism to say that the project's leadership did a poor job of harnessing and encouraging and developing that enthusiasm into a sustainable community. (I'll put myself in that group of failed leaders for a significant part of the project's lifetime.) I've complained about this at length elsewhere (so it certainly bores everyone reading this at least as much as it bores me), but I see a lack of focus as a rootier root cause which explains a lack of funding and lack of developers rather than the other way around. (As yourself this: if *you* were funding the project, how many different backends would you want the project to support for a 1.0 release? How many would you pay for?)
Is Perl 6 really more audacious right now than Perl 1 was in 1987? Perl[1-5] haven't had more than a couple of developer years of paid development, arguably it's in a more practical position for production projects (what is with me and alliteration recently?). Looking at the theme of straw men reasons people have been putting up in this thread I think chromatic is probably correct. The number one reason that Perl[1-6] isn't successful in the current market place is that we don't have a compelling case for why *new* development should be made with Perl. We're not even doing well with a compelling case why *old* projects should remain in Perl. To answer the OPs question, I'm not sure PHP and Python really did take over a huge part of Perl's market share. They say don't try to get a bigger piece, try to grow the pie. I think Python, Ruby, and now Node at least just were in a position to get more of the new pie. We were too busy refuting our own obituary. PHP arguably may have taken over a major niche from Perl. But one that we *gratefully* gave to them sometime in 2001-2003. What we didn't realize in 2003 was that the "OMG I need a website, what college kid can I pay chump change to build one" clients funded the development of a whole class of "cheap and dirty" web page hackers that when Yahoo compared Perl to PHP in 2003-2004ish ... they went with PHP because, even though Perl was technically better, PHP was where their developers were already at. Stevan Little gave his _Perl isn't Dead, It's a Dead End_ talk at one of my workshops. At the time he and I had several conversations about how if Perl became COBOL that wouldn't be terrible for us personally because we've built up an expertise. We'll always be able to find work. What I'm seeing now from chromatic says that may not be true. That's scary. The question shouldn't be "how did these other guys beat us" the question should be "how do we make it so more Perl developers have decent jobs?"
Curation is hard, and for the most part incredibly boring to people. I've had maybe a half dozen people contribute to Task::Kensho since I started the project in 2008. Most people either say "yeah those are great" or "meh, I don't use most of those" and move on. Second promotion of curated items is hard. Finding the time to market a curated list of modules that only six people have really given me feedback on in 5+ years is even harder.
You can resolve that issue by doing atomic replacements using symlinks. See [this page](https://gist.github.com/datagrok/3807742#file-symlink-replacement-md) for an example.
Yes, I do think that Perl 6 is more ambitious than Perl 1 but what do I know? I'm certainly not arguing that funding was the only reason for Perl 6's delay, maybe not even the primary reason. I guess my thinking is that better funding would have been needed to overcome the other underlying issues. On the other hand the big Netscape/Mozilla rewrite had corporate funding but still suffered from a lot of the same problems as P6. Ultimately it was a skunkworks project that saved it.
&gt; if Perl became COBOL that wouldn't be terrible for us personally because we've built up an expertise. We'll always be able to find work. COBOL has an advantage because it's tied to hardware that isn't going to go away in industries which are so exceedingly conservative that said hardware isn't going to go away. The competitive destruction in, for example, payroll billing or insurance record processing, is relatively low. Perl's situation is a little more precarious because so much of its code is tied up in grotty little websites or disgusting wads of system administration code. I'm sure everyone reading this can name at least a dozen credible replacements in the next minute. In other words, the types of organizations who are so adverse to risk that they have '80s-vintage mainframes ready to hot swap for their production systems--the types of organizations willing to pay hundreds of dollars per hour for COBOL or MUMPS programmers--are very different from the types of organizations who have legacy Perl code in production right now. The costs of rewriting and the business risks of switching languages are very different between these two types of organizations. I suspect that the market for legacy Perl developers in a COBOL situation won't exceed a few hundred, globally. That's not a pleasant situation to consider.
Maybe, but I think there was a lot of excitement about Perl 6 and at this point all those people have moved on to Ruby or whatever.
Besides the fact that in the Linux world Python is steadily encroaching upon that territory, in the Windows world PowerShell has been huge and has done a whole lot to elbow out Perl and VBscript, which are now niches and not languages regularly used for Windows system administration.
Back here on Earth languages live or die on their ecosystems, not on their design merits.
&gt; I've had maybe a half dozen people contribute to Task::Kensho since I started the project in 2008. Most people either say "yeah those are great" or "meh, I don't use most of those" and move on. I looked at it at some point, decided it was mostly about coding style fads I disliked and marketing, and have ignored it since then. 
One of my favorite to give is "write grep". The point is to scale it to the skill of the interviewee. You start off with fixed string grep, printing lines that match. Then you say, add the -v option to only print lines that don't match. Add line numbers. Add -A and -B. Add tests. Each one requires re-thinking the problem a little bit, and you can see where they're strong and weak and how they attack a problem. It's simple and familiar enough for anyone to get a good start on, but you can give the advanced guy something to keep him engaged and show off his skill.
[Image](http://imgs.xkcd.com/comics/python.png) **Title:** Python **Title-text:** I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=353#Explanation) **Stats:** This comic has been referenced 24 time(s), representing 0.1888% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
It was specifically culled from a collection of most used lists published at the time and tweaked around software I and others had run into in the better shops we had consulted for. Seriously though I would rather have feedback in the form of a pull request or a github issue or even a ranty blog post than silence. Curation is hard, curation without feedback is harder.
When I looked at Task::Kensho, I thought it was a particularly well thought out list. Seemed like the best perlers were using those same modules. The way the community regards it in such high esteem, I just assumed it was the accepted best-practice list and wasn't particularly in need of any feedback. 
 Perl 6 was the death of Perl.
PHP is an over bloated DSL for making personal homepages, and python looks simple and is taught as a first language. Perl on the other hand used to cover those niches but those tools do better. Simple as that.
What level of rant do you prefer in your GH issues? ;-)
Project Management. If you work 14 years on a Task and after that you have no idea where you stand there can only be one reason for that. Project Management.
This paper kind of points out the fallacies about /dev/random blocking. http://www.2uo.de/myths-about-urandom/ Even in the conservative world of cryptography it's important to know why your blocking for more input and the value it has. If ultimately they're both being fed from the same CPRNG and the block is arbitrary then it's kind of pointless. In the case of virtual machines it depends on what you're doing that would require such high security. SSL and ssh seem like they can be trusted to use their normal means of entropy gathering (I say this based on the fact there aren't vmware white papers encouraging us to use other RNG sources). If you're running a financial site or hosting a game where there is an advantage to be had from knowing the seed, then you would be better off with an external RNG. Possibly hardware based, or shared amongst multiple systems. You can use something like EGD for this. If you trust the kernel enough to provide entropy via /dev/random then you might as well trust /dev/urandom. If you don't trust the kernel then I would use openssl or EGD as they're both well established and hopefully vetted. Edit: having re-read the current docs of EGD I would skip it and just use the kernel. OpenSSL still seems like a viable alternative if you want a different RNG.
Probably two? Parrot and then another that is focussed just on Perl6 and willing to make any change or optimisation necessary to get 6.0 working efficiently... Parrot suffers from the inverse problem that there isnt focus on a single front end language by design. I can see an obvious solution to the problem, but that would mean the goals of volunteers in both projects having to be downsized... Which loses volunteers because it's not the project they signed on for anymore. The problems with Perl6 are more human than technical or even financial. A big part of the problem is no one in P5 world even really appears to care about or want P6 until it magically has codebase and usage parity... That won't happen by magic, people have to start writing code. Better yet code for a compelling use case. So I completely agree with the enthusiasm gap idea, but is there any road to a solution after so much time and built up negativity and dashed hopes? I'd say there is enough Perl6 implemented now there could be useful stuff created that gives a target for optimisation work. Ruby became popular even when it was dog slow! 
Marketing and Community Management. When you work for 14 years and have 14 years worth of work done and a beta product people can use. But they still hang around disapointedly waiting for the product to use it. When the community has no idea where a Task stands. When you said Christmas was here but it was only really Easter and you lied to get some attention. Marketing and Community Management.
&gt; Perl was created as a sysadmin tool and still is. With the rise of the Ruby-centric tools such as Puppet, and Chef, this seems to be no longer the case. Even my perl-based [slaughter](http://www.steve.org.uk/Software/slaughter/) tool, or "cfengine-lite", seems to be used very rarely. It also has to be said that people seem quite happy to jump ship from cfengine to salt, to ansible, etc, on a whim. Largely without caring about implementation language.
As a sidenote, rand() is not at all cryptographically secure, so don't use it for this application, no matter how you seed it. http://perldoc.perl.org/functions/rand.html
I can only second this. Puppet is crucial for us at Booking.com, managing thousands of servers.
I got interested in Ruby because of the Pickaxe book. OO in Perl 5 was annoying. Ruby had a much simpler syntax for objects and still took regular expressions seriously. Plus it was really annoying to work with Perl devs whose knowledge of Perl stopped at version 4. My interests took me back to Perl when Audrey Tang got the pugs project going. Since then I have seen a lot of activity in the Perl 5 world inspired by Perl 6, such as Moose. I suspect folks starting moving on from Perl to Ruby/Python/etc before there was any excitement about Perl 6. The decline in Perl's piece of the pie was inevitable.
It just runs kpcli: KeePass CLI (kpcli-2.4) v2.4 is ready for operation. Type 'help' for a description of available commands. Type 'help &lt;command&gt;' for details on individual commands. kpcli-2.4:/&gt; But it doesn't echo any of the commands. Any ideas? Thanks for this by the way! 
BSDs?
Docker maybe?
fibonacci sequence, or something like that.
Solved it in the end with a mix of using m's and a special delimiter and some substitution vetting beforehand. However, I can easily find a case that would break this although it won't happen in this case (I know for sure). I'm still interested in hearing if anyone uses a more proficient solution for these types of cases.
Have you checked that your bash script is producing output? If so, all I can think of is that kpcli handles its input in a non-standard manner.
Shared hosting? 
And Vagrant perhaps?
Thanks for your kind words. I have to admit that my responses are intentionally slanted against the dogma. Often the dogma itself isn't bad but the propensity for developing and defending it is. I think it's interesting that another reply to that comment complained that it lacked features (such as the ability to add cases at runtime) at the same time it complained about the use of goto. How does that logic untangle? If you can cases on the fly, then goto becomes okay? Are Code::Splice plus goto a perfectly acceptable solution then? The acceptance criteria there are quite opaque but I'm pretty sure that that isn't it. On the topic of anti-goto indoctrination, here's a passage from Knuth's _Literate Programming_: But there has been far too much emphasis on goto elimination instead of on the really important issues; people have a natural tendency to set up an easily understood quantative goal like the abolition of jumps, instead of working directly for a qualatative goal like good program structure ... What we really want is to conceive of our programs in such a way that we rarely even think about goto statements, because the need for them hardly ever arises. The language in which we express our ideas has a strong influence on our thought process. 
Newer perls call this "given" and "when", and they work with "smatchmatch" semantics. Except now they've been marked "experimental", which means that their semantics might change: http://perltraining.com.au/tips/2013-06-04.html
Turn each case into a package: my $color = ('red', 'blue')[int rand 2]; print $color-&gt;set_color; package red; sub set_color { "\033[0;31;40m" } package blue; sub set_color { "\033[0;34;40m" } This can be a good idea if you are doing if/elses or given/whens on the same variable over and over. Then instead of having the cases for handling each value (eg, red and blue) spread all over the program, they're each grouped together. It also lets you create a base class and moved shared logic into there. For example, I have a little utility that takes a really simple graph description language and then outputs either VCG or GraphViz, depending. Then it can just call $graph-&gt;do_this, $graph-&gt;do_that and not worry about which one it is. You're probably going to find that the best solution to any given problem is highly dependent on the exact details of your problem, so if this doesn't suit your exact problem well, don't worry about it. Do something else.
I hope that's a joke and not a serious suggestion.
Redundancy is part of any highly reliable system, so CPAN mirrors will always be useful in that regard.
is that going into the perl core somewhen?
" I'm incredibly happy that Dave is willing to work on Perl for us and to everyone's benefit." Sounds like it will or at least be offered.
In pseudocode: # using a hash; may be fast enough / first thing to try declare empty hash; for each line in file { normalize line; # eg strip extra whitespace increment hash entry with line as its key } At the end the list of keys in the hash is a deduped normalized version of the input lines. I'm not sure about the exact Perl 5 syntax. Here's a quick attempt: my %seen; while (&lt;&gt;) { s/\s+/ /; $seen{$_}++ }; print keys %seen; If that's too slow, maybe provide info about the distribution of values you're going to encounter (eg all integers from -X to +Y in column 1 or whatever).
&gt; The changes discussed here will not land in the main development branch (blead in perl parlance) before the Perl 5.20 release. 
That comment is specific to the changes in that section. Most other changes are already in the main development branch.
Is "1 2 2" equal to "2 1 2"? Either way, storing normalized forms in a hash should be okay as a first step. Have you at least tried that? Is there anything unsatisfactory about it?
Not an array, a hash.
 $ sed 's/\s\+/ /g' the_triplets.txt | sort | uniq &gt; deduped_triplets.txt Are you quite sure gnu 'sort' and 'uniq' aren't up to the task? They're probably faster than perl for this sort of thing. If there's any danger of excessive memory pressure you'll have to resort to hashing each line, one way or another, and putting the hashes on disk. You could do that with DB_File, or various machinations with Tie::File.
I like rdist
What's left unspoken previously that I think may help your understanding (for n=number items in original list): * /u/snaklab's solution: Hash lookups are O(1) speed, so it has O(n) time complexity. while(&lt;&gt;) in perl will read one line of the input file at a time, so you aren't actually storing the full input in memory at any one time. Space complexity is just the size of the hash, which is at most some small multiple of the number of lines in the input file, so O(n). Even if it read the entire input list in at once, it'd be twice the size of your input list, still O(n). * /u/kkrev's sort | uniq solution: Sorting first means its time complexity is O(n lg n) at best. The entire input is read into memory, so space complexity is O(n). * Your solution: It has time complexity O( n^2 ) to compare each line against each other line. It can be done with O(1) space with only a single line in memory at a time (but extra disk seeks can be quite slow and normally tracked in big O figures); or with all of it in memory, giving space complexity O(n). For a million lines of input, O(n) space means some fixed smallish multiple of a megabyte. On modern hardware, that's nothing to be concerned about. Any of these will run plenty fast. If I knew sed I'd use kkrev's solution because it's so compact/fast to write. Instead I'd make do by executing the hash solution as an incomprehensible perl one-liner: perl -e 'my %seen; while(&lt;&gt;) { s/\s+/ /; print if ( ! $seen{ $_ }++ ); }' FILE edit: O(n^2) looks terrible, O( n^2 ) less so. :-D
`perl -n -e 's/\s+/ /g; print $_, "\n" unless $seen-&gt;{$_}++' filename.txt`
The ship's sinking. We might as well have fun. Edit: Also, happy cake day!
A bunch of perl
This is what I ended up using, and it works perfectly, and much more quickly than my implementation.
Definitely wasn't looking to avoid learning it, I'm excited to actually, been a language I've wanted to learn for a while now. Was just wondering how quickly I would hit a wall with my programming understanding.
I didn't want to imply that you're lazy ;) I guess that if you have been able to learn C++, Perl won't be a major problem for you. Although Perl is quite often quite peculiar. But C++ is in many ways at least as strange.
Haha no offense taken, thanks for the input! Yeah trying to read some Perl code is pretty dense. I'm excited to see how it goes. I'll definitely be back to get more info and such.
Thanks ill definitely be back here and keep those resources in mind. What do you know about Perl mongers? There's apparently a good sized group in Houston.
Hang on, Laziness is a virtue!
It's worth grabbing a paper book, like Modern Perl, and just reading it. Every language has a bunch of unique stuff that you can pick up much faster from a book than from just wading in. It's also worth reading through the man pages. They'll cover some edge cases that a book won't. Also, they're one of the great things about Perl. I can't think of any other language that has quite the same standard of included documentation. This even extends to most modules.
When I started using Perl after programming in other languages (C, AREXX, Amiga E, various BASICS), I picked it up haphazardly. A few years later when I came back to Perl after having not done a lot with it, I picked up the camel book (*Programming Perl*) and read it. A *world* of difference in how I understood and used the languages. Since you've done some programming, you may be OK skipping *Learning Perl* (which is also a good book), or you may want to give it a shot, anyway. I think *Modern Perl* is also being recommended a lot lately, though I haven't read much of it yet, so can't say.
If you are lucky enough to be able to make a Houston.pm meetup, say hi to Todd Rinaldo. :) Todd also recently created "Hangouts.pm" on g+ (maybe other locations too, dunno) which has posts of recent presentations from various mongers groups (I see only US groups so far -- Houston, Dallas, and Salt Lake -- but I'm guessing that's just a start and Todd intends to increase coverage from around the world).
It seems like QA probably won't use Object Oriented Perl... Many parts of Perl are a very thin wrapper around underlying C functions. If you have done a lot of C++ on Linux that included system calls, then you were probably mostly using C functions. File I/O can be similar, but the standard way of reading files in Perl is a little different. To get to know Perl, practice parsing files. Get to know Regular Expressions.
Both C++ and Perl have some learning curve and programmers in both tend to be the crotchety types. Since you already have a good programming background and just need to pick up the spirit, idiom, and the funky, unusual stuff, Larry Wall's _Programming Perl_ is probably the best book for you. _Modern Perl_ is great but is more for writing reasonable code using a reasonable subset of the features as opposed to _Programming Perl_'s quick tour of all of the madness. Other comments about OO and types are correct. Perl can overload operators but this is seldom done. You'll definitely want to learn about scalar versus list contexts (expressions change meaning depending on this concept of context) and coercion (operators dictate whether arguments are treated as strings, numbers, or whatever). 'perldoc perlfaq' is your friend, as is 'perdoc perlmodlib' which is an index of all of the numerous modules bundled with Perl. Any given feature may be an operators, built-in function, idiom, built-in module, or 3rd party "CPAN" module. Those two pieces of reference will help you figure out which it is when you're looking for something. Like C++, if you're willing to abuse things creatively, you can have a lot of fun. Features were implemented with dedication. So you can do things like implement objects by blessing a reference to a package into itself. With dynamic inheritance resolution and method resolution, lvalue functions, access to the bytecode, piles of reference types including references to regexes, things like the PadWalker module (search.cpan.org for it), an autobox module, and on and on, there's tons of fun to be had. Just whatever you do, don't take on a maintenance or QA Perl position.
Oh hey, another Houstonian! I just started going to Houston.pm meetings and they've been good so far. Make sure you join the mailing list to find out about upcoming meetings.
&gt;&gt; I applied today to a QA Perl position &gt; { about having fun using Perl in crazy ways } &gt; Just whatever you do, don't take on a maintenance or QA Perl position. :)
I actually work in a QA perl position, and enjoy it quite a lot. I do most of my test automation in Test::More, if you have any specific questions in that regard, feel free to pm me. I think most of the other people here explained the overlap well enough, so I don't think I'll add to it. 
If you know how to handle pointers, you'll pick up references fast and you will even enjoy them. And this is the hardest topic for newcomers i think.
Ensure to read modern code and tutorials. There's plenty of ugly ancient code in the web. Unfortunalety it is not easy for a beginner to recognize bad/old Perl. Some marker could be: - "use strict" and "use warnings" is missing - function calls with "&amp;"
You'll want to look at http://perlmonks.org/, since the problems people submit are probably the kind you'll have, or be able to explore to learn more.
There is a book called [Impatient Perl](http://www.perl.org/books/impatient-perl/) I suggest you read through it. There is also a .pdf version of it on the linked page. It's kind of what it says. "Perl for the impatient." If you are familiar with programming this should give you some head-start. As was noted before *Modern Perl* is also a great book and highlights the bigger differences between older-perl code and the newer-perl code. I also highly suggest reading *High order perl.* For a more intrinsic look at the language. And also, If it will be possible for you, try to reuse modules from other folks. You just need to take a quick look at 'cpan' for the repositories. If you have worked with apt-get,pacman,dpkg,yum and etc. you will not have issues understanding the cpan utility :) Hope you'll have fun with the best language ever :)
What other module would you like to be listed there? For which other Linux distribution would you like to see similar article? (Distro/version, please.)
Awesome ill definitely use that.
I already have programming perl, although it's an older version (2000). I will definitely pick up modern perl once I'm done going through programming perl. All of the documentation seems like it will definitely be worth it to read through.
I'll keep this in mind as I learn / do my work.
Awesome resources! Thanks!
Will do, maybe I'll see you there.
I will look for Todd Rinaldo at this month's meeting.
I will definitely give you a buzz if anything stumps me. Thanks for offering to be a good resource.
I already have programming perl and will be looking into modern perl as soon as I finish that. Thanks for the recommendations!
Regular expressions are probably the point I need the most help in. So hopefully programming perl will help me out.
I am definitely in the write-only category at the moment, but hopefully I'll learn to read it over time. It's definitely one of the more interesting languages that I've worked with (albeit in a limited capacity.
However ranty you need to get off your chest as long as it's not personal :)
Known plaintext affects AES as well, even in CBC mode of operation. Everyone, please use integrity checks and authenticity when using AES. Something like HMAC is great here. And never re-use IVs.
To my knowledge, AES isn't fundamentally broken for known-plaintext attacks compared to block ciphers in general. Having known-plaintext certainly helps against any cipher, but it shouldn't make it trivial to break everything. I am planning on bringing up the hows and whys of CBC mode in the block cipher entry.
AES isn't broken at all, you just shouldn't be using it without an integrity check. AES has the attribute cypher text malleability. If an attacker knows the plaintext, they can modify ciphertext blocks and have it decrypt to what they want without ever discovering the private key. In CBC mode you modify the previous block which will decrypt to garbage, and the next block will be what you want. This can lead to serious vulnerabilities if implemented without an integrity check. Constant IVs can be a serious issue as well. It's not that these ciphers or modes are broken, just that they're easy to use in insecure ways. I've personally seen AES+CBC used in production without an integrity check where it had very negative consequences, and I wrote up a PoC and demonstrated it to them. These things can slip by a lot of people, a whole security team in this case. It's easy to implement encryption and decryption and see it working, but it's incredibly difficult to implement it securely. The crypto community will often tell you not to roll your own crypto, and not to use low level crypto primitives like block ciphers. If you're not an expert on the subject, it's best to stick to high level crypto like gpg and SSL/TLS. I'm not trying to talk shit about what you're writing up, your blog is some cool stuff. I'm just trying to show people that they might not want to play with this in production code.
so, does anyone use squitch? is it a good way to deploy database objects from git into oracle? 
Was it *really* necessary to confuse the issue by throwing in gratuitous mentions of a separate language that the OP is assuredly *not* going to use? You were doing so well not spamming this thread.
RHEL 5 uses Perl 5.8.8, and this will be supported until 2017. I think this is as far back as you need to go if you want broad version support. I have no tips for using perlbrew tough.
Mojo::JSON ftw imo - beautiful, simple, versatile. 
perlall -m (m for major) uses 5.8.4, 5.8.5, 5.8.8, 5.8.9,5.10.1 (5.10.0 is too broken),5.12.5,5.14.4,5.16.3 and 5.18.2. Since 5.10 all latest subreleases. 5.8.4 and 5.8.5 are still pretty common on old servers, 5.8.8 is big on the internet (centos 5) and 5.14.4 the most stable version. http://search.cpan.org/dist/App-perlall/ Testing in a cpan-like dir is done with `perlall -m maketest`, no idea about perlbrew.
See also https://www.crypto101.io/ - "an introductory course on cryptography, freely available for programmers of all ages and skill levels." Really interesting on the subject.
 perlbrew exec perl myprogram.pl ... will run myprogram.pl against every version of Perl you've got installed with Perlbrew (taken from the [homepage](http://perlbrew.pl/)).
Most of us take CPAN testers for granted but I had a need to use some code that had not been released since 2003. I checked the testers report that had run Friday, 7th March 2014 all looked good for my needs and everything just worked! Just wanted to say Thanks to all involved. (This is just one example of many. I just thought to say something this time.)
No reason you can't ask here; I'm sure most would be willing to help. Sorry that Perl is your first language. I think you'd be better off if you started with something uglier but more obvious like C, then it might be more obvious what Perl brings to the table. Best of luck!
I suggest you just start posting your questions and thoughts right here in /r/perl or at [perlmonks](http://perlmonks.org/). You might be pleasantly surprised at the quality of the help you get. (You seemed to be seeking private email help. That would mean the potential value to the rest of the community of getting to see the exchange, of being reminded of the struggles beginners face, is lost. So most Perl folk won't do that, at least not for free.) Anyway, good luck and welcome to the Perl community. :)
This may or may not help you. What I know about Perl is that the first developer of the language was seeking an alternative to see and ask in his Unix environment (some flavor of borne she'll maybe?). If this is confusing and you are completely unfamiliar then you can probably ignore everything else, but if you are brave keep going. So lots of Perl syntax is very similar to lots of features in modern Unix shells. Perl adds more syntax and provides optimized compiler behavior to allow a greater expressiveness around the Unix shell interface. Basically allows people who know the syntax to do more with fewer key strokes, particularly when the input to a task is a long text based output stream... or with modern libraries any byte or binary stream.... but I could be exaggerating that 'any' part because I am not that we'll versed with modern Perl uses... I spend more time with python lately. I still used Perl one - liners all-the-time. They are currently, and probably will be for some time, one of the handiest things that most every distribution has unless you specifically left it out for some reason (usually security or storage/memory constraints). Play with some Perl one liners a bit and your head may be shaken up enough to see what your lessons failed to communicate. Good luck!
Just post your questions in this subreddit, you will be helped.
You will most certainly find an answer in the mentioned websites, no matter what task you are being assigned. One to one help will only slow you down. Perl might be a bit harsh for beginning programmers, but it has been covered with explanations in documentations to gruesome detail. Most of the time, you will not really even need to ask. Chances are, someone had the same problem you have/had with a certain task and they asked already. (Especially when you are starting out.) And also, what if your mentor won't be available? Takes too long to respond? You are going to search the web anyway. Also, there isn't much benefit on email-ing back and fourth other than reassurance. And knowing that someone is there to assist when you need it. But again, this assistance has already been given somewhere on the web :)
Start by asking smart questions. http://www.catb.org/esr/faqs/smart-questions.html
And yet, there are a ton of people who laugh and claim that Perl is a "dead language". Who's laughing now? Also, Java blows.
"programming speed" is misleading. This article is a benchmark/comparison of different languages doing some basic string concatenation and manipulation. Still, perl++
Never ever. Although Perl is still my favorite language you have not the slightest chance in speed against C oder Java. Sometimes if there's time i solve something on projecteuler.net Sometimes with Perl, sometimes with Delphi. Delphi always is at least factor 50 faster than Perl. Sometimes more. Delphi itself can perhaps keep up with Java but again is much slower than C. I think it is a bad idea to challenge an experienced C-programmer in a benchmark with Perl as he will slaughter you. edit: Altough my Java knowledge is a bit rusty I remember never to use a string if you often modify it. A string is final in Java so at every modification a new one is created. There is Stringbuffer AFAIR to do this. The Speed difference is enormous.
Before I looked at the article I asssumed it referred to "speed at which one could program", in which case then, for myself at least, perl is definitely the fastest. I use 3 or 4 languages on a daily basis, and am comfortable with another good handful, but if I've got a common "munch this file and grab some data" request, or even "can I have a web page that does X", I can do the job in perl in half the time of anything else.
I was expecting this to be some kind of funky filesystem that concatenated incoming data from disparate sources. But no: felines.
GetOptions will modify `@ARGV` as it goes. You should save it to a separate array, and use `GetOptionsFromArray()` on it.
Java is fast as fuck, C can be faster but takes hilariously large amounts of time and danger to program it.
C &gt; Java &gt;&gt; Perl
[Module::Load::Conditional](http://perldoc.perl.org/Module/Load/Conditional.html) might fit the bill. Chapter 12.3 of the Perl Cookbook, Delaying use Until Run Time has a lot to say about native methods, either autouse: use autouse Fcntl =&gt; qw( O_EXCL() O_CREAT() O_RDWR() ); or by hand: load_module('Fcntl', qw(O_EXCL O_CREAT O_RDWR)); sub load_module { eval "require $_[0]"; die if $@; $_[0]-&gt;import(@_[1 .. $#_]); } 
 &gt; running each test once is good enough for comparison This is a huge red flag for me. I'm surprised at the inconsistency of memory usage for all but C and perl. That also leads me to believe there is a problem in the test for other languages, but it could just be that it's a poor test sample size. Regardless of my love for perl, I'd want to see these results replicated and verified with statistical significance before giving them any weight in future design decisions.
I suppose that depends on the value of the variables, but I'm pretty sure that evaluates to FALSE. (rimshot)
I would use [Class::Load](https://metacpan.org/pod/Class::Load).
perl does logarithmic realloc overallocation. We needed to add that for poor windows realloc performance. You need to the same for C, then C will win. Other than that the results are to be expected. See http://perl5.git.perl.org/perl.git/commitdiff/f12005599f648e675af22dfef1047191e260bc48 
You can check out [this script](https://bitbucket.org/pgporada/perl/src/d292ef8275082044be78ef8aab714a70d63f69da/bg_grapher.pl?at=master) I used it in. It's not a perfect script by any means, but it works if you have all the right dependencies/DB set up. 
[`use if CONDITION, MODULE =&gt; ARGUMENTS`](https://metacpan.org/pod/if) haven't tried it yet, I'd guess you have to ensure the condition holds true at compile-time.
Why would you use Getopt::Long for that? It seems like Getopt::Tree is what you want.
I don't see why you need the two levels of options. If someone selects -foo or -granola or -chocolate, then they're talking about a bar. If someone selects -bulldozer or -airplane or -typewriter, they're talking about a machine. Why require them to describe it explicitly? Imagin a program where people could specify a point on a plane, and they had the choice of Polar or Cartesian coordinates. You might offer -p and -c options, but what benefit are they actually providing? If you're using polar coordinates, you need to specify -radius and -angle; with cartesian, you have to specify -x and -y. So if the program gets -x &amp; -y, it can deduce these are cartesian; from -r &amp; -a it can deduce polar; any other combination is invalid. and leads to an error message. I'm glad to see you have the command line arguments stored in an options hash, rather than individual scalars. But why be so stingy with the keys? You allow long names on the command line; 200 lines into the program, might you mistakenly use &lt;c&gt;$options{m}&lt;/c&gt; thinking it refers to 'marshmallow'? Waste a few keystrokes, and call them $options{machine} and $options{chocolate}. If the short forms are for you (expert user) to use on the command line, Getopt::Long already provides auto_abbrev-iation, unless you disable it with $ENV{POSIXLY_CORRECT}: auto_abbrev Allow option names to be abbreviated to uniqueness. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case "auto_abbrev" is disabled
Yes, I would just stick with what you have.
\Q and \E are your friends: #!/usr/bin/perl use strict; use warnings; my $str = "+foo+ bar *baz*\n"; my $foo = "+foo+"; my $baz = "*baz*"; $str =~ s/\Q$foo\E/FOO/g; $str =~ s/\Q$baz\E/BAZ/g; print $str; Learn more about them in [perldoc perlre](http://perldoc.perl.org/perlre.html#Escape-sequences) So far as I know, memory is the only limitation to regex sizes. I have run regexes against strings in the megabyte range before, so 242 characters should be safe.
Speaking as a perl and java developer: not surprised that perl excels at this test. Also, that is the worst way to write the test in java. He should have used a StringBuilder. That will manipulate a single character array in memory. The way the author did it creates millions of objects. When I change that, the test runs 10 times faster on my machine. I think this is a very narrow test, and in general it's developer skill that is the biggest difference between languages.
\Q and \E will work. 242 characters is definitely safe. I've used it on FASTA files GB in size with no problem. Fix your spacing in your if statement. I would look into using a text filter like perltidy to ensure spacing is correct. if ($str=~m/$lang1/) { $str=~s/$lang1/$lang2/g; } I would also advise against using numbers in your variables. $lang_one is better than $lang1. 
For common usage, what you have is fine. But ... because you specifically mention that you are doing this for speed, you might want use some constants to optimize away your code branches if not needed. I recently posted a [blog entry](http://blogs.perl.org/users/joel_berger/2014/02/reflecting-on-the-dfwpm-winter-hackathon-competion.html) about this very pattern. That post refers to code seen [here](https://github.com/jberger/DeDuperizer/blob/master/deduperizer.pl). In that post I don't do the specific case you are after, in fact I do one harder, use a module if requested AND if available, otherwise, optimize that code away. Read the post first, then the code. Let me know if you have any trouble with either. Cheers.
It would take minutes to add a custom string allocator to the C++ code, after which I'm guessing it would be fastest and lowest memory usage.
 ... perl -pi -e 'BEGIN { $remove = quotemeta shift } s/$remove//' '&lt;full string&gt;' Minimize the amount of stuff you have to escape by passing stuff through `ARGV` and using shell single quotes (which don't require you to backslash anything except single quote and backslash), and furthermore make the search string regex safe using `quotemeta`.
Thanks a lot for the response. I gave your code a try however the match isn't happening, or at least isn't working on this example. this is the actual code I am working with: grep -R -e "wuzr.com" * | cut -d ":" -f 1 | xargs -n1 perl -pi -e 'BEGIN { $remove = quotemeta shift } s/$remove//' '&lt;script&gt;if ((navigator.userAgent.match(/MSIE/i)) || (navigator.userAgent.match(/Trident/i))) {document.write("&lt;scr"+"ipt type='text/javascript' src='http://www.wuzr.com/cnt/'&gt;&lt;/scr"+"ipt&gt;");}&lt;/script&gt;' and the folllowing is a sample of the file I am trying to match on: &lt;/center&gt; &lt;script&gt;if ((navigator.userAgent.match(/MSIE/i)) || (navigator.userAgent.match(/Trident/i))) {document.write("&lt;scr"+"ipt type='text/javascript' src='http://www.wuzr.com/cnt/'&gt;&lt;/scr"+"ipt&gt;");}&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Thanks
You may want to [check this out.](http://pastebin.com/hsnKmULR)
In addition to my comment: "Never ever" Here my results with Perl and Delphi (Perl Version copied from example) // Code Delphi procedure TForm1.btn1Click(Sender: TObject); var str: string; iMax, i, iLength: NativeInt; gstr: TStringBuilder; begin str := 'abcdefgh'+'efghefgh'; iMax := Trunc(1024/length(str)*1024*4); mmo1.Lines.Add(TimeToStr(Time)); gstr := TStringBuilder.Create; for i := 0 to imax+1000 do begin gstr.Append(str); gstr.Replace('efgh', '____'); iLength := gstr.Length; if (iLength mod (1024*256)) = 0 then mmo1.Lines.Add(TimeToStr(Time)); end; end; Perl: * exec.tm.sec str.length * 4sec 256kb * 15sec 512kb * 33sec 768kb * 59sec 1024kb Delphi: * 09:20:18 * 09:20:20 // = 2sec * 09:20:23 // = 5sec * 09:20:29 // = 11sec * 09:20:37 // = 19sec Although the benchmark ist basically just how fast the (written in C) regex engine in Perl works Delphi is about 300% faster. 
Since the code is executed every time the prompt is displayed and therefore load/execution time is critical, I do not recommend using `Module::Load::Conditional`, `Class::Load` or the `if` module, for your case the disadvantages of a library outweigh the advantages. These modules only `require` under the hood which you already have. I would go further and once you are happy with the results, port the code to your shell. Keep maintaining/developing the Perl code, but use the sh code for production.
Thanks. I've never had to use \Q or \E before. I'm sure they will be handy. * But do I have to use \Q and \E in $lang2? Because $lang2 also contains escapable ctrs. * Do I have to use \Q and \E in my if statement? Because $lang1 could have escapable ctrs also. line sep $str='Sometimes we use an old language (+)'; $lang1='old language (+)'; $lang2='new blah (+)'; if ($str=~m/$lang1/) {$str=~s/\Q$lang1\E/\Q$lang2\E/g; } Also, my output now contains a backslash before every space: "new\ blah\ (+)". How do I get rid of that backslash before spaces? A space does not need to be escaped like that for my situation. 
No, \Q and \E are only needed in the regex portion of the substitution. In fact, using the \Q and \E escapes can ruin your output by adding escapes to some characters: perl -le '$s = "\\"; print "backslash: $s escaped backslash \Q$s\E"; prints backslash: \ escaped backslash \\ As dreadpiratemiley said above, your bracing style is odd. I had assumed that it was just a copy and paste error at first, but, since you have repeated it, it appears to be a conscious choice. Please consider using one of the two widely accepted bracing styles: if ($str =~ /\Q$lang1\E/) { $str=~s/\Q$lang1\E/$lang2/g; } or if ($str =~ /\Q$lang1\E/) { $str=~s/\Q$lang1\E/$lang2/g; } Additionally, you are saving no work with that if statement. In fact, you are doubling the amount of work that must be done to replace the string. First you search the string for `$lang1` then you replace instances of `$lang1`. That means you must traverse the string twice. But if you just did the substitution, it would only traverse the string once and you would have the same result. Also, based on the code snippet, it looks like you aren't using the strict or warnings pragmas. This is a very dangerous way to program in Perl 5. For one thing, if make a typo with a variable name, a new package variable will be created. Adding the strict pragma will force you to declare variables (which is good because they will be lexical variables instead of package variables) and will error if you incorrectly spell a variable name. I would write your code like this: #!/usr/bin/perl use strict; use warnings; my $str = 'Sometimes we use an old language (+)'; my $regex = 'old language (+)'; my $replace = 'new blah (+)'; $str =~ s/\Q$regex\E/$replace/g; Given that you said you are translating several phrases, you may find the following pattern useful. It starts with a hash that maps phrases in language 1 to phrases in language 2. It then uses the keys from the hash to build a regex to find all of the phrases from language 1. This allows us to make one pass over the input string replacing the each phrase in language with the translation to language 2. #!/usr/bin/perl use strict; use warnings; my $str = "+foo+ bar *baz*\n"; my %map = ( "+foo+" =&gt; "frob", "*baz*" =&gt; "bar", ); # build a regex out of the keys using alternations # keys are sorted by length to ensure that keys like # abcd have a chance to match before keys like ab my $regex = "(" . join("|", map { "\Q$_\E" } sort { length $b &lt;=&gt; length $a } keys %map) . ")"; $str =~ s/$regex/$map{$1}/gi; print $str;
perl -p -i -e 's|&lt;script&gt;if.*?wuzr.com\S+&lt;/script&gt;||gs' *.htm On my phone, so not 100% sure that's typo free. Test by copying an infected directory, CA into the direction then run it. Should recurse through subdirectory and fix in place. Then worry about how they got in :-D (assumes you don't have any plain &lt;script&gt; tags in your code base) 
A couple of points: * In the first two examples you're defining ESCCTR2 (two C's) but using ESCTR2 (one C) in the regex. use strict and my variables would clue you in on this. * In the variable examples you're not quoting your special chars or specifying a character class (with [...]) This worked for me #!/usr/bin/perl use warnings; use strict; use autodie; my $re='\+\-\,\.\(\)\*\\\|\[\]'; my $instr="May/may not be a match."; if ($instr=~m/[$re]/) { print "Found\n"; You also might like to know about saving a compiled regex into a variable with qr/.../ my $re=qr/[\+\-\,\.\(\)\*\\\|\[\]]/; my $instr="May/may not be a match."; if ($instr=~ $re) { print "Found\n"; } Hopefully that's of some help. Edit - Just read about \Q...\E, which I was unaware of. The problem with the first example is that you don't have a character class [...] defined. This works my $re='+-,.()*\|[]'; my $instr="May/may not be a match."; if ($instr=~ /[\Q$re\E]/) { print "Found\n"; # This never executes } 
You should only use \Q...\E on the regular expression. You shouldn't use it on the replacement string. Try changing your substitution statement to: $instr =~ s/\Q$eng/$fr/g; (You also don't need the \E if it would go at the end of the string.)
definitely have &lt;script&gt; tags in some pages. Will test this out, thanks for providing a solution. Pretty sure we nailed the source already 
What I meant was that normally the script tag has a type attribute. You only need to change the regex if you have any script tags with no attributes immediately followed by "if" 
Thanks. That worked. 
because . is a wildcard in a regexp, and splitting on a scalar string like @l=split('.',$t) will be like @l=split(/./,$t); If you want the behaviour you expect but with a scalar string instead of a regexp you will have to double escape, like this: @l=split("\\\\.",$t) The latter two examples are the same because when you escape the "." you just get a ".". What you want is a string that escapes the "\" so that when the string is parsed as a regexp it then escapes the ".".
This is the right way to do what you are doing. Building a hash map between languages will definitely be faster/more memory efficient. If you don't understand some of cowens syntax, use [perldoc] (http://perldoc.perl.org/). Specifically, look up map, grep, and sort. These will be very useful tools while building hash maps.
The exact reason was covered by /u/unkz. As a more general style point, always use the regex syntax for `split()`. IMO, it's an accident that the string syntax works at all.
It was almost right, I sorted the keys, but I didn't sort them by length (even thought the comment said that was what I was going to do). It should be fixed in a minute.
Agreed... get in the habit of always using the regexp syntax for split, it'll save you headaches later when you actually need a regexp.
&gt; always use the regex syntax for split(). Noted. Thanks. Really thanks for explaining that. This explains why I see '@l=split /\./, $t' more often. 
That's a lower-case 'L', not a 1. Single-letter variables are also bad, of course, but not so bad for short example code like this.
Except for `split " ", ...` which is special. 
What's wrong with `split /\s+/, . . . `?
&gt; A `split` on `/\s+/` is like a `split(' ')` except that any leading whitespace produces a null first field. — perldoc -f split In other words, `split " ", " hi there "` gives `('hi', 'there')`, but `split /\s+/, " hi there "` gives `('', 'hi', 'there')`.
I made the C++ go over twice as fast by replacing the string.replace line with a std::copy. The string::replace method does not check and optimize in the case that the original and replacement sequences are the same length. By simply using std::copy instead of replace the C++ becomes by far the fastest. for (auto found = std::begin(gstr);;) { found = std::search(found, std::end(gstr), std::begin(find), std::end(find)); if (found == std::end(gstr)) break; std::copy(replace.begin(), replace.end(), found); } If you change the length of the replacement string to be different than the search string, then the original C++ code with the string::replace call is over twice as fast as the perl. 
understood. I will give that a closer look. I have since neutered the offending url for the time being with an innocuous text string to remove the 'problem'. just need to do the clean up of the extraneous text.
So to follow up for future reference. This is what ended up working for me: grep -R -e "wuzr.com" * | cut -d ":" -f 1 | xargs -I{} -n1 perl -p -i -e 's|&lt;script&gt;if.*?wuzr.com\S+&lt;/script&gt;||gs' {} currently plugging away at files expect it to be done in a number of hours. Thanks again for your help
Benchmarks are silly business. I like how I can write something quickly with Perl and get the logic down and leverage well-tested code. Then when I want to go for speed, I first look at the algorithm/data structures and switch out different approaches. When that isn't good enough, I choose the best of those and write it in C. Good algorithms ≫ optimisations. And they're easier to maintain.
&gt; Single-letter variables are also bad, of course, You are correct but all my Perl programs are used once, then never used again, and they tend to be short, under 20 printed pages. Only my temp variables, like for loops, are one letter. For variables which actually hold useful data, I use better-named variables. 
Works for the string you specified: my @arr = split /((?:[&lt;\[]\w+[&gt;\]])+)/; if ($arr[0] eq '') { shift @arr }
If the actual input is any more complex than the example, e.g. if the tags are longer than one word, then it would be better to use a module like [HTML::Parser](http://search.cpan.org/dist/HTML-Parser/Parser.pm) to do this instead of split/regex.
Solaris.
Dental plan!
 I paste this into command line apps: sub opt ($) { scalar grep $_ eq $_[0], @ARGV } sub arg ($) { my $opt = shift; my $i=1; while($i&lt;=@ARGV) { return $ARGV[$i] if $ARGV[$i-1] eq $opt; $i++; } } I had an args() version that returned multiple options (eg --foo bar baz quux) but I didn't use it that often and it had edge cases. The worst part of cutting and pasting was I wrote it when I was in a serious Perl6::Variables kick, so I kept having the change the sigils back to the sucky Perl 5 way after I stopped using it.
There's already dozens of existing alternatives to Getopt::Long. Search cpan for "getopt".
I very specifically wanted a single function I could copy and paste, so I didn't have to install a module.
This might be easy in the short term, but the payoff for coming up with a way to deploy modules (including your own) that works for your environment is huge. It is a nice function, though. =)
&gt; I very specifically wanted a single function I could copy and paste. What could possibly go wrong?
Haha no worries! Yeah according to the boss the programmers will be helpful even going as far as to explain things I may not understand.
Constructors in OOP serve the same behaviour needs as your first example: setting default values. If there's no new() or similar, you'll have to make another call to set your first object properties. Also, you want to check stuff during object creation - do you have resources needed for this object to do its work. You also want to check some other relationships you may need. So, it's complicated: needs and behaviours of objects can be quite complex and you want your code to be flexible enough. 
[Acme::Constructor::Pythonic](https://metacpan.org/release/Acme-Constructor-Pythonic)
A good possibility if you have no types specified. But if you have there's some redundancy my JSON $json = JSON(); I think it woule be nice if you could write alternatively my JSON $json = (); my UserAgent $ua = (); my Request $req = ( GET =&gt; 'http://www.example.com/foo.json' ); There's only one Problem. Distinguish between a direct assignment of an object and a new/build call with the object as an Argument. For example: my TreeNode $t = $parent; do you mean $t = $parent; or $t = TreeNode-&gt;new($parent);
You are confusing casting with constructors. to_string changes one type of data to a string type. the new method typically creates an object instance from a class. 
It's true, you should avoid this in 99% of cases. But there's a few cases where it's legitimate to do. It's useful for creating "portable apps" (like what can run on a USB stick, or can just be wget'ed and run immediately). If you use 100+ computers, computers that you don't sysadmin and may not be using for very long, on old versions of Solaris/AIX/HPUX, it may not be worth it to set up the infrastructure to distribute all your modules to those computers. Though for portable apps, App::FatPacker is a better solution, since at least you're using tested/mature code instead of bespoke untested code. For tiny scripts though, FatPacker seems like overkill. OP: there's a module that does the kind of simple processing yours is doing, [Getopt::Casual](https://metacpan.org/pod/Getopt::Casual).
&gt; It's true, you should avoid this in 99% of cases. But there's a few cases where it's legitimate to do. That's true in 100% of situations.
... but seriously, the only time you don't need a constructor is if the object is just a simple container for values (like an old COBOL record or something). Otherwise, it has to *do* something, and if it can't do that basic thing, then it doesn't ever really exist as an instance of that class. This is part of the principle of "throw errors early and often". If something critical fails, you're better off finding that out immediately rather than wondering why logic far later in the program is returning the wrong value, or other, apparently unrelated things are failing. If Dog-&gt;new fails, there's no point in ever pretending like you have a dog.
I'd add slice access.
Simplifying a little, you *can* initialize objects the way you suggest. ---- Starting with a simple case: my Int $i = 7; # This works. The Int type (note the initial cap; this distinguishes non-native types from native types) corresponds to an Int object; after the assignment an Int object will be stored in the Scalar [Container](http://doc.perl6.org/language/containers) associated with the variable $i. I'd say that P6 has reasonable default rules for appropriately interpreting the RHS of assignments and your question might be better reframed as: what about assignments to user defined types (whether object or otherwise)? Let's step back and look at a couple relevant mechanisms. P6 has types corresponding to values like Int (and int), Rat, FatRat, Str (and str), etc. It also has types corresponding to the [Containers](http://doc.perl6.org/language/containers) that hold such values -- a Scalar type for Containers for $vars, an Array type for Containers for @vars, and so on. If the LHS of an assignment is a variable, its Container's type determines how the RHS is interpreted. Using the default Container types: my $foo = ("Hello", "World"); In this case $foo's Container defaults to a Scalar. A Scalar Container .item's the RHS and stores (a ref to) the single value that .item returns. (Yes, ("Hello", "World") is a single value, called a Parcel. It's kinda like a P6 flavored tuple.) my Str $foo = ("Hello", "World"); # compile time error! $foo's Container (again, a Scalar) .item's the RHS. The single value -- ("Hello", "World") -- that .item returns is not a Str, so the result is a compile time error. my Str @foo = ("Hello", "World"); By default an @var's Container is an Array. An Array Container .list's the RHS and then suitably stores the items so listed. In this case "Hello" (a Str) is stored in @foo[0] and "World" in @foo[1]. my Str %foo = ("Hello", "World"); %foo's Container (a Hash) .hash's the RHS and then suitably stores the key/value pairs it extracts. In this case "Hello" (a Str) is stored as %foo&lt;Hello&gt; (aka %foo{'Hello'}) with "World" as its value. ---- The following is going to be hand wavy for several reasons including that I don't think this is correctly working yet: If you define your own Container type and then tell P6 to use that for a variable, then you get to control the RHS interpretation of assignments to that variable, say: class MyContainerType is Scalar { #`(assignment handling code) }; my $foo is MyContainerType = 3, ("Hello", "World"), &lt;a b c&gt;; Your assignment handling code would be responsible for handling the RHS. I'd expect this code to involve one or more of macros, introspection and meta programming, so it probably won't be trivial. As I said, I don't think this is working yet. And I'm pretty sure it'll be very low priority. ---- Hth. ---- Updated to add: Declarations are DRY -- there's no need to mention the type twice: my JSON $json; my UserAgent $ua; my Poodle $dog .= new("Fido");
OP shares something cool that he did for a specific purpose, internet says he was wrong. Thanks for sharing, OP.
PHP and Python/Django allowed the easy use of templates and template logic for web app design. Hacking on someone elses templates as a starting point is far easier and lowers the barrier to entry. Mojolicious/Dancer/Plack not only give Perl an easy way to do that - they add features that are truly next gen. Perl is reinventing the web ... Again.
Nice overview, but it seems to leave out the two greatest things about references: (1) they're pretty close to being foot-shoot-proof, as pointers go. ("pretty close" because of the whole circular-references-break-gc memory leak issue, but otherwise use &amp; forget...); (2) they include code references and closures, which will make your head explode, they're so powerful and cool.
For practice (and later utility), write a higher order wrapper around the open-close methods that perl uses for file access. If it's useful to you, try adding the ability to capture the outcome of system commands, like the third line. I call mine 'access'. As: my @lines = &amp;access( '&lt;', 'input.file', \&amp;read ); ### read input file &amp;access( '&gt;', 'output.file', \&amp;write, @lines ); ### write lines to output file my( $cwd ) = &amp;access( 'pwd', '2&gt;&amp;1|', \&amp;read ); ### get the working directory I use this all the time. And it was a revelation to me, that functions could be passed as arguments to change other functions' behaviors. EDIT and PS: I like explicit sigils, but you don't have to use them like I do. 2nd EDIT: use '2&gt;&amp;1|' instead of '&gt;&amp;2|'... I fixed it in the code. It means 'alias 2(stderr) onto 1(stdout) and punch thru pipe'. I had it backwards originally.
.... and the Perl community is surprised that people don't want to be involved.
&gt; Example 1 fails under strict as a subroutine can only return a scalar or a list. &gt; When strict is off, Perl will return a list of the the array's elements. You might want to recheck that. "use strict" doesn't care at all about subroutines returning arrays. You get a list of the array's elements whether or not strict is turned on.
Exactly... TIMTOWDI people. It is one of Perl's greatest strengths. Why do some people think that being an expert means telling other people that they are wrong?
I figured out a solution. my %options; GetOptions ( \%options, 'machine=s', 'bar=s', 'version', 'help', ) or die "Invalid parameters!"; if(defined($options{'bar'})) { my @bar = qw(foo granola chocolate); if ($options{'bar'} eq $bar[0]) { } elsif ($options{'bar'} eq $bar[1]) { } elsif ($options{'bar'} eq $bar[2]) { } else { print "Invalid parameters!"; } }
That's pretty cool! I met Randal a few years ago at Dragon*Con. nice guy.
When I wrote that the expressions themselves didn't matter, it prompted me to try something. I took part of my post and replaced each expression with something with no parenthesis... four equals signs. I think it makes it a little harder for me to get my head around because of those extra parentheses. Here's what it looks like without those: ============================================= For one expression, it's easy: ==== For two expressions, the nesting starts (the expressions are joined on "OR" and surrounded by an extra set of parentheses): (==== OR ====) Here's where it gets weird. You could think that you could enclose as many expressions in that outer set of parentheses, but that's not true. For three of these expressions, you do it like this: ((==== OR ====) OR ====) Note that there are three opening parentheses at the beginning, and two at the end. For four expressions, we complete the expression pair ((==== OR ====) OR (==== OR ====))
This shouldn't be too big of a problem with the right IDE; as you close a paren it will highlight or otherwise visually indicate which paren you're closing. Also, leaving a space between the open/close paren and the next thing in helps.
And, as you can see, the parentheses in each expression are what make it really confusing: (((((a = "a") OR (a = "b") OR (a = "c")) OR (a = "d")) OR (a = "e")) OR (a = "f")) Crazy. 
 #!/usr/bin/perl -w use strict; for my $i (0..5) { # Generate the data my @terms = map { my $letter = chr(ord('a')+$_); "$letter = \"$letter\""; } 0..$i; # Generate the expression. my $term = shift @terms; my $exp = "($term)"; while($term = shift @terms) { $exp = "($exp OR ($term))"; } print "expression with " . ($i+1) . " terms is ".$exp."\n"; }
Nice. Thanks.
Jogged my memory on the existence of PowerMach from Tenon Systems, it was first *nix based operating system for macintosh hardware I ever used. Blast from the past. Way to go Jason Scott for uploading these. Look forward to future installments.
Glad to see you solved your problem. Just FYI, that seems like a pretty standard LDAP style query syntax, so you'll probably see it again someday. 
Here's an alternative #!/usr/bin/perl -w use strict; my @names = qw ( andy brian chris deborah ); print &amp;createExpression(@names); sub createExpression { my @names = @_; if (@names &gt; 1) { my $name = shift @names; return "( ".&amp;createExpression(@names)." or ( name = '$name' ) )"; } else { return " ( name = '".$names[0]."' ) "; } } outputs ( ( ( ( name = 'deborah' ) or ( name = 'chris' ) ) or ( name = 'brian' ) ) or ( name = 'andy' ) )
This isn't weird at all, it comes from a rule that *every* expression has to be contained in parentheses, and that OR is a binary operator. Some other language might let you write `(a OR b OR c)`, but this one says nope, `a OR b` is an expression, so you have to write `((a OR b) OR c)`. There are two ways of doing this — the first one is super simple, but produces a left-unbalanced expression with more parentheses: use List::Util qw(reduce); my @names = qw(john paul george ringo pete); my @query = map qq{(name="$_")}, @names; my $output = reduce { "($a OR $b)" } @query; gives an output of (((((name="john") OR (name="paul")) OR (name="george")) OR (name="ringo")) OR (name="pete")) The other way is a bit more complicated, but keeps the nesting level down: my @names = qw(john paul george ringo pete); my @query = map qq{(name="$_")}, @names; while (@query &gt; 1) { for (my $i = 0 ; $i &lt; @query - 1 ; $i++) { splice @query, $i, 2, "($query[$i] OR $query[$i+1])"; } } which gives an output (in `$query[0]`) of: ((((name="john") OR (name="paul")) OR ((name="george") OR (name="ringo"))) OR (name="pete")) it's a tiny difference, but then again whatever parses this might be sensitive to the nesting depth. For 100 names, the first code will give an output that starts with 100 opening parentheses; the second has 8.
Yours isn't bad (looks like a port of the top Python solution) although I would discourage having the function print the result — it's just as easy for it to return the result and for the caller to `print solve(...), "\n"`, and more flexible. Also, your initialization of `@levels` with as many empty strings as there are brackets is probably totally unnecessary; perl will just do the right thing when you eventually `$levels[$i] .= $_` . [Here's a totally different solution](http://www.reddit.com/r/dailyprogrammer/comments/217klv/4242014_challenge_154_easy_march_madness_brackets/cggasex) using CPAN.
Very Perl applicable result. [Original submission from /r/javascript](http://www.reddit.com/r/javascript/comments/21rfnn/class_hierarchies_dont_do_that/) for commentary.
I agree most of those headers are quite useful. I don't agree that hiding software versions is adding any security. It's just security by obscurity. A serious attacker won't rely on those anyway...
With all due respect, please do not confuse "security by obscurity" with closing an information leakage problem. It is always good practice not to disclose any more than is necessary for the proper operation of a system. If you have a use case for showing the type and version of the server software that outstrips the risk that an attacker (however "serious" he may be) could decide to target your system, then have at it. If you really think this doesn't matter, then please feel free to tell us the make, model, and age of the locks you have on your home. Make sure to let us all know if you have any other secondary security devices on any door or window. Also please be sure to tell us the make and model of your garage door opener and security system if you have one. Don't forget to include the locations of the sirens and how it contacts the security company. Oh and feel free to put all of this information in some kind of public database so that people who find a flaw with anything you have can immediately discover you.
NOTE: Mojolicious removed the X-Powered-By header as of version 4.0: https://github.com/kraih/mojo/blob/b5da0c7afcdd793c85e8e2a67eb29f7f36bdb601/Changes#L538
Sorry for the wrong terminology, "information leakage" may be the better term here. Still, I disagree. The headers might not reveal what software you are using, but there are still more subtle information leaks that will probably reveal the software you are using to an attacker. And if this is a serious problem, can you tell me why OpenSSH does not have an option to remove its version from the banner it sends as the first thing every time you contact an SSH server? I don't know if your comparison is that good. For a lock picker discovering how the lock works is half the fun. And you don't need to know exactly with what kind of lock you are dealing for that ;)
I agree for the most part, but there certainly seems to be an anti-framework bias in the article. There are great frameworks in every language -- Rails, Django, Moose -- and no matter which language or framework you choose you will almost certainly have to write custom code for all but trivially simple projects. And that's okay! You can save tremendous effort using a framework for the repetitive stuff and writing your own bits for the less common functionality. Most frameworks aren't built to do everything for you anyways. The best way to pick a framework is to weigh the magic with the manual, and understand when one might get in the way with the other. Rails might sound great but it might be cumbersome to develop your customizations in that universe so a framework like Django or Moose might make more sense.
If there are "more subtle" leaks that can be closed then they should be closed. The point is simply to do as little as possible to help an attacker. Any comprehensive security plan should be including checks and double checks for information leakage. If for nothing else, taking the unnecessary information out makes the response a teensy bit smaller. I'm not suggesting that hiding the web server version is a hard and fast rule that should always be followed, nor am I suggesting that it is even generally a big problem, but I am saying that developers should be aware of where they are giving more information away than they need to. In one of my applications, I do not hide the vendor string (but I do hide the version) because I find it valuable during user support to be able to identify which backend (application server vs cache) originated the document. As for ssh it's in their faq. OpenSSH FAQ 2.14: "This information is used by clients and servers to enable protocol compatibility tweaks to work around changed, buggy or missing features in the implementation they are talking to. This protocol feature checking is still required at present because versions with incompatibilities are still in wide use." Note they say "still required at present." I'm going to take this to mean they acknowledge that it's not ideal, but the risk is accepted for usability purposes. This is, for instance, is why you still want a web browser to communicate its name and version to a web server. Plus OpenSSH has a pretty good history of being a lot more secure than most things that squawk their version numbers out in web headers.
1. How do you differentiate between options requiring value and not requiring value? For example: in --count 37, I might want --count to be a flag and not requiring a value, so 37 should be in arguments and not gobbled up as count option's value. 2. What if you have an argument value that starts with a dash? You don't want it treated as an option, of course. This happens a lot, e.g. in grep. That's why grep has an -e option (e.g. grep -e -some-pattern, -some-pattern is not a grep option but a pattern to be searched). 3. How do you check for typos? (--referer vs --referrer). You might want to specify a list of known options and warn for unknown options. Throw in a couple of other features like short aliases, and you'll soon end up with reimplementing Getopt::Long :) Especially #1 and #2 are important for any basic and hoping-to-be-sane options parser.
If you write it, then there will be one :)
Thanks Joel, article corrected.
If there's half a dozen good versions in other languages, why write a Perl one? Perl is about taking good stuff and bringing it together, not reimplementing it pointlessly.
There's `List::MoreUtils::uniq()`. It does things with a hash similar to the way you're describing. I'm sure there's a crazy regex solution, but the hash method is usually the recommended way.
The point is, nobody bothers to write it in Perl in the first place. Perl is no longer the first choice for many people. Including me, I only bother to rant about it :)
... it's a browser game. If your language of choice for writing a browser game is Perl, you're on crack.
This is a FAQ - http://perldoc.perl.org/perlfaq4.html#How-can-I-remove-duplicate-elements-from-a-list-or-array%3f Your "keys" suggestion would lose the order of the elements in the array. But you can use an array and a hash together. my %seen = (); my @unique = grep { ! $seen{ $_ }++ } @array;
...or Mojolicious or Dancer. Those are the "big 3". :)
You know what I'd like to see? A transpiler that would convert code from one of those languages to Perl. That way you don't have to write 2048 directly. :-) Just the libraries.
Just to make sure, is $_ the array parameter passed to uniq()? Also, at "=&gt; l" is that a one or lowercase L?
$_ represents each element of the array as it's processed by _map_; in this context, it's just setting the hash element's value to one (not lowercase-L); doesn't really matter what you set it to, as that information'll be discarded, anyway.
@_ always contains functional parameters. $_ represents each item in an array during processing of functions like map, grep, and any which all do something on or to an array.
 use autobox::Core; my @arr = ( 1, 3, 2, 3, 2, 3, 3 ); @arr-&gt;sort-&gt;uniq-&gt;print; See also perl5i.
I don't get it. Can somebody explain? Is brian d foy really just making fun of R?
It's a shaggy dog April Fools story.
Well I get it's an April Fools joke, what I don't get is his attitude towards R. He describes it as if it was an incomplete, useless subset of Perl. It's not funny because it's not even remotely true. The two languages serve very different purposes and R is, in many respects, more powerful than Perl. Maybe, but just maybe, I would have understood if he was mocking Python, but R?
I didn't read into it any mockery, but I have no strong feelings one way or another about R. It seemed to me that brian chose R because its name was a single letter in the backronym PERL and so made for a better store.
That's a one - 1 This exact same sub makes its way in to about 50% of my Perl scripts. It's a pain to read but it works, just use it like: @array = uniq(@array) And your @array will be cleansed of duplicates
Not my code, and just a little bit of a cheat, but: my $host = "http://2048.semantics3.com/hi/"; my $cmd = "curl --silent -L $host"."start"; my $output = `$cmd`; my $session_id = $output; $session_id =~ s/.*?ID:\s(\w+).*/$1/si; my %keyMap = ( 'w' =&gt; 0, 'd' =&gt; 1, 's' =&gt; 2, 'a' =&gt; 3); print STDERR $output, "\n"; while(1) { print STDERR "Input (w - up, a - left, d - right, s - down):\n"; my $userInput = &lt;STDIN&gt;; chomp ($userInput); if(defined($keyMap{$userInput})) { $userInput = $keyMap{$userInput}; } else { print STDERR "Invalid move.. w - up, a - left, d - right, s - down\n"; next; } my $cmd = "curl --silent $host"."state/$session_id/move/$userInput"; my $output = `$cmd`; print STDERR "\n$output\n"; if($output=~/Message:/si) { exit(0); } } :) 
 use strict; use warnings; use Benchmark qw(:all :hireswallclock); # Generate test data # 20 x 2000 element array containing random numbers # 0-99. my $array = []; for my $i ( 1 .. 20 ) { for ( 1 .. 2000 ) { push @{ $array-&gt;[$i] }, int( rand(100) ); } } cmpthese( 1000, { # Run the benchmarks 1000 times 'grep' =&gt; sub { foreach my $arr (@$array) { my %seen = (); my @unique = grep { !$seen{$_}++ } @$arr; } }, 'map' =&gt; sub { foreach my $arr (@$array) { my @unique = keys( %{ { map { $_ =&gt; 1 } @$arr } } ); } }, } ); $ perl test.pl Rate map grep map 48.7/s -- -68% grep 152/s 212% --
This is the only right answer here, since it: 1. Makes use of grep 2. Doesn't mess with the order of elements 3. Simple, only two lines.
Text::Balanced might be useful.
Text::Balanced is the right answer for work, but for playing, here is a start. It doesn't handle escapes or multi-lines. my $match = qr{ (['"]) # group 1: open quote ([^'"]*) # group 2: contents, anything but quote \g1 # same quote as the opening one }x; # ignore whitespace in this thing while (&lt;&gt;) { # for all lines while (/$match/g) { # look multiple times in a line print "$2\n"; }; } 
Also Regexp::Common
Several answers already here, but these ones aren't mentioned: 1. Use the `do`'s return ability: my @uniq = do{my %seen; grep {not $seen{$_}++} @array}; Technically the same as /u/davorg's answer, but doesn't mess up your namespace. 2. Use libraries: `use List::MoreUtils 'uniq';` `my @uniq = uniq @array;` I'm not sure if `List::MoreUtils` is a standard lib, but I think so. 
They're the big three web frameworks, certainly. I'm not sure that Dancer or Mojolicious are quite as tightly tied to the MVC paradigm as Catalyst is.
Yeah, probably a wrong move.
The clone doesn't have to be browser-based. (By *it*, I was referring to one of the clones, not the original 2048 game).
Gosh, a turn-based 2048 game. I guess the next step would be creating an email-based one :) 
&gt; I'm not sure if List::MoreUtils is a standard lib, but I think so. "Standard lib" meaning it comes with the vanilla Perl installation? 
Thanks. I put this in my util library which all my programs use. Oddly enough, in 10 years of Perl programming I've never had to do this, unique-ify an array. lol. 
Yeah, I was just to lazy to fire up `corelist`. According to /u/harbud3, it is not.
This is great news. Thank you Booking.com!
[might not be helpful] This sounds a lot like something [csplit](http://stupidunixtricks.blogspot.com/2008/03/csplit-splitting-file-into-multiple.html) could do. I just did something similar on a 1.3 GB text file (multiple genbank files concatenated). It's not perl but it's a simple command that you can chain with others. 
Don't feel bad about it, there's nothing to be ashamed of. `Devel::REPL` takes a little bit of time to get used to, and there are some very unintuitive aspects of it. The first is that it enforces strict mode, which requires variables to be declared with `my` or `our`. That's good when you're actually writing code, but it's not necessarily so good when using a REPL. It means if you want to assign to a variable more than once, you have to use `my` the first time but not the subsequent times, or you declare the variable first before assigning to it: $ my $foo; $ $foo = 42; 42 $ $foo = 99; 99 The second confusing thing is that the P in REPL is done via `Data::Dumper::Streamer` (by default at least) whose output can be confusing when printing a list. Take the following example script: #!/usr/bin/env perl use warnings; use strict; use Data::Dumper; my $foo = 42; my $bar = 'hello world!'; my $baz; # same as "= undef" print Dumper $foo, $bar, $baz; If you run that, the output is $VAR1 = 42; $VAR2 = 'hello world!'; $VAR3 = undef; `Data::Dumper` was passed a list of three scalars, but it only gets their values, not their names. But it's designed to output strings that are valid perl code that could be fed to `eval`, so it had to make up these pretend variable names. It makes a certain amount of sense in this example, but now consider that arrays flatten when you use them in list context, like when passing them as an argument to a function. From `Data::Dumper`'s standpoint, the first example is indistinguishable from this: my @quux = (42, 'hello world!', undef); print Dumper @quux; That gives the exact same output: $VAR1 = 42; $VAR2 = 'hello world!'; $VAR3 = undef; The same thing happens when the REPL tries to print the representation of a list: $ (10, 20, 30) $VAR1 = 10; $VAR2 = 20; $VAR3 = 30; So, that's a little confusing. The third thing to watch out for is the fact that the `print` function returns true (really the scalar number 1) on success. If you use `print` from inside the REPL, you get double output -- the output that `print` generates, and the REPL's representation of the result of evaluating the expression. It's especially confusing if you try to print `undef`, which results in nothing being printed, but a warning is generated and 1 is returned: $ print undef Use of uninitialized value in print at (eval 339) line 5. 1 If you didn't know what was happening, you might think that `undef` equals 1. The fourth thing to watch out for is that stdout is line buffered by default, so if you try to print something that doesn't contain a newline it will not be displayed until a newline is eventually printed: $ print "foo" 1 $ print "\n" foo 1 In general, if you're using a REPL you don't need `print`. There's already something that prints out each value that you enter. If for some reason you do want to print something, use `say` instead of `print`, as `say` automatically adds a newline, or always include a newline in the string you're going to print. ----- So now we can talk about what went wrong in your posted session. &gt; $ @asdf = [0..4] Strict mode. &gt; $ my @asdf = [0..4]; This creates an array that contains a single value -- a reference to an array. Remember that `[ ... ]` creates an array ref, not a list. Note that the output is: &gt; $ARRAY1 = [0, 1, 2, 3, 4]; Since there was only one line there, that means a list of one variable. To create a list, use `( ... )`: $ my @foo = (0..4); $VAR1 = 0; $VAR2 = 1; $VAR3 = 2; $VAR4 = 3; $VAR5 = 4; That's quite a different output. &gt; $ @asdf[0] &gt; Scalar value @asdf[0] better written as $asdf[0] at (eval 326) line 7. &gt; $ARRAY1 = [0, 1, 2, 3, 4]; The warning is to remind you that the sigil changes from `@` to `$` when you access a single value from an array. Using `@` is for when you want to access a slice, and in your case a slice consisting of a single element is still technically valid, but it generally means you made a mistake. &gt; $ $asdf[0] &gt; $ARRAY1 = [0, 1, 2, 3, 4]; You are printing the first and only value of the array, which contains a reference to an array of 5 values. &gt; $ print $asdf[0] &gt; 1 Line buffering strikes again -- this would have actually printed something like `ARRAY(0x812d23d0)` since `$asdf[0]` is an arrayref and that's how they stringify. &gt; $ print $asdf[1] &gt; Use of uninitialized value in print at (eval 329) line 6. &gt; 1 Because `@asdf` contains only one value, `$asdf[1]` results in `undef`. The `print` function doesn't print anything for `undef`, but if it did you'd also suffer from line buffering. A single `undef` also stringifies to the empty string under `Data::Dumper`, so if you just wrote `$asdf[1]` and let the REPL do its thing, you'd get just a blank line. That's kind of confusing if you're not expecting it. If you want to check if something is `undef` (and you're not satisfied with just a blank line) then allow me to suggest a few possibilities: $ [$asdf[1]] $ARRAY1 = [ undef ]; $ not defined($asdf[1]) 1 Side note, I used `not` instead of `!` in the second example because of the fifth confusing thing about `Devel::REPL`: by default it interprets an expression beginning with `!` as a history expansion, like in the shell. I find this incredibly infuriating personally. You can avoid it by adding a leading space: $ !defined $asdf[1] 1 Anyway, I hope that explains all of the strange behavior you experienced. It would be nice if `Devel::REPL` was more beginner friendly, because having a functional REPL is one of the best ways to learn a language. Perl could really learn from Python here, which has a stock REPL that is fantastic and has none of this bullshit. Edit: a few typos, and "listref" is not a thing.
Wow thank you so much for taking the time to type all this out! This answers a lot of questions that were raised while I was doing this. I'm a Python programmer usually so that's why I was trying the `[start..end]` syntax instead of `(start..end)`. When I think "array", I think "square brackets", but I need to start getting out of that habit for Perl.
Well, don't put it completely out of you mind. You do find yourself using `[ ... ]` relatively often in Perl, because it's necessary any time you want to nest an array. For example, this does not do what you'd expect: $ my %foo = (x =&gt; (1, 2, 3), y =&gt; (4, 5, 6)); $VAR1 = 'x'; $VAR2 = 1; $VAR3 = 2; $VAR4 = 3; $VAR5 = 'y'; $VAR6 = 4; $VAR7 = 5; $VAR8 = 6; Lists flatten and the `=&gt;` is really just a comma operator in disguise, so this really means `my %foo = ('x', 1, 2, 3, 'y', 4, 5, 6)` which results in this: $ \%foo $HASH1 = { 2 =&gt; 3, 5 =&gt; 6, x =&gt; 1, y =&gt; 4 }; That's probably not what you wanted. On the other hand: $ my %bar = (x =&gt; [1, 2, 3], y =&gt; [4, 5, 6]); $VAR1 = 'x'; $ARRAY1 = [ 1, 2, 3 ]; $VAR2 = 'y'; $ARRAY2 = [ 4, 5, 6 ]; $ \%bar $HASH1 = { x =&gt; [ 1, 2, 3 ], y =&gt; [ 4, 5, 6 ] }; $ $bar{y}[1] 5 In perl you really have to pay attention to when you're dealing with references and when you're dealing with values. Python has only references, no values, so it's kind of an alien concept if that's what you're used to. 
&gt; and the =&gt; is really just a comma operator in disguise Or more precisely: The =&gt; operator is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. http://perldoc.perl.org/perlop.html#Comma-Operator So there's a Little pitfall. my %foo = ( bar =&gt; 1, # same as 'bar', 1 01234 =&gt; 2 # same as 1234, 2. If you want to Keep the 0 you have to write it as string here '01234' );
Pretty nice. Although I had to comment out #use common::sense; #use Data::Dump 'pp'; with no apparent adverse effects. The yellow 16 is a little hard to read; now that I know, it's ok, but `yellow bold on_bright_black` looks better. I wonder if there's a way to specify draw-the-whole-thing-on-black and use "on_white" (but not yellow) for the big numbers. Could use a help screen describing the wasdq keys. vi keys would be nice too, and shouldn't be too hard to add. 
LOVE IT! Good work.
Lovely
&gt; To create a list, use ( ... ) Very small nit. To create a list, use the comma operator. To *assign* a list, use grouping parentheses.
Someday I think "The next edition of the Modern Perl book will use perfectly precise terms coherently and consistently", but then I think that no one reading it the first time will appreciate the distinction between *creating* a list and *declaring* a list.
I had that in mind but I decided to leave it for the next version. Honestly, I got lazy :)
Here's one I found on the internet that looks the same. ST*835*9001~ BPR*I*45.15*C*ACH*CCP*01*044115126*DA*01407602110*175254 221**01*012 345678*DA*1234567*20020618~ TRN*1*123456789*1752548221~ REF*EV*123X~ DTM*405*20020614~ N1*PR*EDS~ N3*950 NORTH MERIDIAN STREET*SUITE 1150~ N4*INDIANAPOLIS*IN*46204~ N1*PE*JOHN A DOE*XX*5555555555~ N3*P.O. BOX 12~ N4*CITY*IN*46000~ REF*TJ*177777777~ REF*1D*100123456A~ LX*1~ CLP*123456*1*100*45.50**MC*1234567891234*01*1~ CAS*CO*42*49.50*1~ NM1*QC*1*DOE*JANE*B***MS*123456789123~ NM1*82*2*DR. JON DOCTOR*****XX*5555555555~ MOA***AM12*MA01*JI224~ DTM*232*20020427~ DTM*233*20020427~ DTM*050*20020501~ REF*1D*100123777~ SVC*HC:99217*91*45.15**1**1~ DTM*150*20020427~ DTM*151*20020427~ CAS*CO*12*5*~ REF*1D*100123456~ REF*HPI*6666666666~ LQ*HE*55555~ PLB*1111111111*20021231*CV:1234567*-1.27~ SE*29*9001~ Looking at that first CLP segment (about halfway down), you can see the fourth part is 45.50 (in code it's probably considered the fifth part). That is the total that needs +5 added to it to equal 50.50. Then I would need an additional CAS segment immediately below it that would read something like CAS*CO*3*5~ Or something similar. I don't have my paperwork with me right now. This basically shows that we're adding a $5 charge that is considered a (CO)ntractual obligation. The 3 is the reason (co-payment) and that 5 is the dollar amount to add to the CLP segment above it. And this would be done every time we see "CLP" in every single file that we have from a certain company that did not add the $5 charge for some reason. :/
should I stop being a dunce and download 5.14 or is the an analogous op in 5.12?
You can replace line 259 with the following three lines my $t = $s; $t =~ s/\D//g; my $n = int $t;
common::sense is a module that activates a bunch if pragmas. If you remove it, you should add the pragmas back in: http://search.cpan.org/dist/common-sense/sense.pod The Data::Dump module was likely just there for debugging.
Yes, it's a standardized claim processing format with a delimited design. It's basically a check from the insurance companies stating what the money is for and all that. :)
thanks this worked for me :)
Yup, I'm that someout :) Cool, Perl people indeed do not disappoint :)
Put this in a file called CLP.pl then you can run it with: perl CLP.pl filename.txt &gt; filename_modified.txt use strict; while (my $record = &lt;&gt;) { my @fields = split /\*/, $record; if ($fields[0] eq 'CLP') { $fields[4] += 5.0; print join '*', @fields; print "CAS*CO*3*5~\n"; } else { print join "*", @fields; } }
urgh, common::sense. one of the reasons I use Cpanel::JSON::XS instead of JSON::XS. Seriously, just use strict; use warnings; 
you're my hero
Perl is not dead, some people just wish it was. I am a perl developer, and have had several awesome jobs as a perl dev. Don't let perl keep you from an awesome job. Whats more, if the job is awesome don't let the language of choice block you. Languages rise and fall. You can always pick up a new language, you can't always pick up an awesome job.
Take the Perl job.
Well, I think you should do what makes you prosperous and happy. And it seems like the Perl job is the better of the two right now. What I recommend you do is practice and read about languages other than Perl in your free time, maybe even during your work time. Using Perl is fine, but don't get into a rut about thinking about things only in Perl. Perl has a tendency to attract some really degenerate programmers/personalities, so you will have to counteract that force. That isn't even to say Java doesn't do the same thing. Good luck! Let us know how it goes.
"After almost two decades of Perl hacking, we decided that it does more harm than being useful" You really don't want to go take Perl advice from MLEHMANN :-)
Haha yes sir/ma'am
Do you know perl? If you do, then I would take a job working with it. If you don't, I wouldn't.
What do you think would happen if you asked this in r/java ? 
&gt; Perl has a tendency to attract some really degenerate programmers/personalities Could you perhaps expand upon this sentiment?
Well given the state of perl I figured this question would be relevant here where as it would not be relevant in r/java
I don't know perl. Is this general advice on languages and jobs or does it apply to this scenario. I'm not daunted by learning a new language.
As someone who has taken a job in perl (I am starting in July), I would take the job that you are going to enjoy more. I agree that perl is not the best language (that also seemed to be the feeling of many in the company that I am going to work for, based on my experiences from when I interned last summer), but it is certainly not a bad language and is far from dead. Also, as others have said, just make sure to keep up with other programming languages and concepts (do a some projects by yourself on the side, spend time on /r/progamming, etc.). You are fortunate (as I was) to be in a position where you have the choice to accept a job at a company you would enjoy working at, and I would (and did) take full advantage of being in that position.
Perl is matured in a way that has dramatically lowered noise levels. Much Java work as actually done amount to a huge corporate dead zone of enterprise management crud that has little value and tolerates no innovation. Imagine your current feelings being magnified over time.
Hey, author of the "Perl is a Dead End" [talk](https://speakerdeck.com/stevan_little/perl-is-not-dead-it-is-a-dead-end) here. Programming is programming, the language is really just an implementation detail. Take the job based on your feeling for the company, and not the language. 
In my career (large amounts of which has been Perl), I've met some really unsavory types. I guess you could chalk it up to the field in general. But I feel like there's something about Perl that attracts a certain... Rebel. Someone for whom coloring in the lines just isn't good enough. They're attracted to the way they can artistically express themselves and have Perl just understand them. I understand the sentiment, and I like it, but only in small amounts. As teams and projects get larger, that sentiment becomes more of nuisance than a novelty. And I feel like only a minority of Perl programmers really grow out of that. Writing "boring", "plain", orthogonal code goes a long way when communicating and working with others.
The advice would be the same regardless of what languages you had before you. What languages do you know now?
It's about being an active participant in life/culture. If you/people in general continually disparage Perl, then it will increasingly not be at the forefront of people's minds when problem solving in the future. So for the sake of language advocacy, absolutely reimplement the same thing.
I'm not disparaging Perl. But reimplementing something that's been done in half a dozen other languages isn't the way to make Perl look relevant. Doing something creative or useful in Perl *before* it's done in other languages, because Perl is a great tool for the job, is how you do that.
What exactly is the "state of Perl"?
What I meant was, that if you ask perl folks, they will say take the perl job. If you ask java folks, they will say take the java job.
So I was in your exact position a few months ago, offered a Perl job in senior year when my university program had been largely Java/C/Python/etc. It took a little while to make my way around the syntax, but all-in-all, I'm really enjoying the position and the work. The only downside would be the exclusion of a proper object-oriented system. There are alternative libraries like Moose or Mouse, but it all feels a bit hackey. In time, you will be experienced with the language. The biggest factor is the company that you work for. I have been blessed with an awesome workplace environment, so I would focus on that first and foremost. Be sure to let me know if you have any questions, and good luck!
Thanks!! sticking with 5.12 for now hah
&gt; I agree that perl is not the best language This is something that you can get past. In many ways, perl is one of the best. The newest real perl, 5.16, has a lot of features... cpan has a lot of updated libraries to do anything you want. There's very few things you can't do *easily* in perl with some library or another. I'm leaving a perl shop for a rails/python/node job, and it's all good. The language I left was great, the languages I'm picking up are great.
&gt; But reimplementing something that's been done in half a dozen other languages isn't the way to make Perl look relevant. Disagree. &gt; Doing something creative or useful in Perl before it's done in other languages, because Perl is a great tool for the job, is how you do that. Okay, like what?
A lot of companies are dropping perl for non-sysadmin tasks. My current employer has spent over 4 million dollars trying (and failing...) to write a perl web project's next incarnation in Java. My team's project was luckily untouched, but they were torn between from-scratch Java rewrite and end-of-life on us. Improving or cleaning the few flaws in the perl project was never discussed. They were going to jump on it and rewrite it from scratch, whether it needed it not. Why? Because perl is dead. This was a large-scale VC buyer who did this with any "dead language" code it found.
It's generally terrible advice. The most marketable developer can walk calmly into a job that uses a language he's never seen, pick up that language's nuances, and be at full speed in 3 months. And I have some recent personal experience that says this is exactly what a lot of employers are expecting. I walked into all non-perl interviews and nobody had an issue with me "only having a little experience" with the languages they used. Cept one Java shop. 
Java is not an improvement over perl... 
I have 3 coworkers who would scream obscenities across the office when mad. 3 (some overlap, but not all) do not bathe often. One coworker refuses to wear more than sweatshorts and t-shirts. He has 4 of his old computers in his cube, and about 30 empty bottles of Mt. Dew at all times. One is rude, and will not talk to people he doesn't respect. Oh yeah, we're a 150+ employee company, not a little startup. We're not all annoying, but I've never seen anyone as stereotypically "asshole programmer" as some perl devs.
I never said it was. The businessmen who bought my employer out did. That said, there are some advantages to Java over perl. Mainly benchmarks and (to some extent) scalability of something like an SaaS server. However, there are many languages better than Java at most of those things, and at least one better than Java at each of those things. And perl is still *capable* of them.
I can totally understand who you're talking about, as I think I'm one of the incorrigibles. I like that I can pretty much do whatever I want however I want in Perl. As you might guess, frameworks hold no appeal.
Pretty sure _most_ employers will want you to have at least _some_ experience with the language they are hiring you for.
Knowing is `$battle-&gt;half`.
Not really. For the most part, it's "a few new features in 5.16 and 5.18, simplified and improved explanations almost everywhere, and the removal of some things that seemed like a good idea a couple of years ago (smart match, lexical `$_`)." I could review a diff against the 2012 edition, but it'd show that I edited almost every paragraph of the book.
Ever work with experienced system administrators?
Yep...the one I worked with made a mistake and took a regular programming job. He threw his badge at my boss on his way out one day.
Yet they offered me a job.
Take it, then. Especially if you're confident in your ability to master perl quickly. I think hiring is broken in most organizations.
Great! Looking forward to the kindle edition... And I'll most likely order a print copy for the office.
Awesome thank you.
I have been a Perl developer for 18 years. I almost gave up on it a couple of years ago, simply because of where the industry seemed to be headed. About a year ago, I got into a renaissance period. Moose, cpanm, Dancer, Rose::DB::Object, Template-Toolkit. I love all of these. Last year I started a new project, and chose to use Perl. No regrets. I would encourage anybody to learn Perl, because it is so terribly useful and flexible. However, you should also pay attention to other technologies. Other open source interpreted languages like Ruby and Python, of course. And also .NET (not just Mono, but Microsoft .NET in Visual Studio). It's a huge part of the industry, and something that I think everybody should know something about. 
You bet! I think 5.20, due out next month, is going to be ossum! You should get acquainted with [perlbrew or plenv](http://oylenshpeegul.typepad.com/blog/2013/08/acme-envy.html) before then so you are ready!
Would you care to elaborate?
Why is 5.18 not a real Perl? Was there a memo I missed?
I feel like this is great general advice, for any job that may focus on just one language.
Thanks so much man. OOP is all I know, I do a lot of coding outside of work and school so I'm not worried about forgetting it, and actually excited to learn a different paradigm.
But perhaps realistic perl developers while enjoying their language of choice may see that it is not a good move to take a job in perl at this point in time.
It seems to be on the decline as far as popularity. 
Java ruby and python in that order of expertise.
Thanks so much for responding. I agree, the company just seems right, the developers I will work with and interviewed are smart and enthusiastic. I wont stop my side projects in other languages (rails and java/android) so there is no harm in picking up something new at work. Right? right...
run it in cmd ,the draw box is messed up. error message like this: 'clear' is not recognized as an internal or external command Use of uninitialized value within %h1 in string at 2048.pl line 270 ... ..
FTR, my employer couldn't give a damn whether or not a new developer already knows our primary programming language. But we're large enough to: a) hire experienced and highly skilled people, and b) take the time of reduced productivity at the start as an investment in the new colleague. So no, unless you're going to work for a small company, chances are that you can apply your more generic skills to learn their tech when you get in.
Any idea when the print edition will be available on Amazon UK?
I use vim with plugin tComment, so I hit V then &lt;Down&gt; several times and then *gc* to (un)comment lines
Best answer. The company is where you will go to everyday. It better be a good one else you will hate life. The language doesn't matter. Perl and Java are both great.
Hopefully the next week or so, but I lack a specific date.
I don't see the value in changing search.cpan.org to metacpan.org links. I can understand going from version-specific links from http://search.cpan.org/~triddle/MediaWiki-DumpFile-0.2.2/lib/MediaWiki/DumpFile.pm to https://metacpan.org/pod/MediaWiki::DumpFile but simply changing from a distro-level search.cpan.org link to a distro-level metacpan.org link as you've done on a number of my answers doesn't seem to have any benefit to me other than "I (Gabor) like metacpan over search.cpan". In your article you say "I think it would be better to drive people to MetaCPAN." but why is that a goal?
Using goggle seems to be a relatively easy way to find the mapping from cpan to metacpan. http://search.cpan.org/~rjbs/perl-5.18.2/pod/perlipc.pod#Deferred_Signals_%28Safe_Signals%29 https://metacpan.org/pod/distribution/perl/pod/perlipc.pod#Deferred-Signals-Safe-Signals google: perlipc.pod#Deferred-Signals-Safe-Signals site:https://metacpan.org/ http://cpansearch.perl.org/src/RURBAN/illguts-0.47/index-14.html https://metacpan.org/source/RURBAN/illguts-0.47/index-14.html google: RURBAN/illguts-0.47 site:https://metacpan.org/ open the resultant metacpan page and then click Browse, the index-14.html file is listed there
Why are you using `L` (32 bit unsigned integer) to encode the length of an exponent, but `S` (16 bit signed integer) to encode the length of the entire packet? That makes no sense, especially since you know that the length of `$rsa_n` is going to be at most 256 \* 2 / 8 = 64 bytes, so you could encode its length with a single byte if you wanted to, or just use shorts everywhere for consistency. Also, `L` and `S` reflect the endianness of the machine they're running on, so they're not portable and aren't suitable for a network protocol. Define an endianness for your protocol and use the n/N/v/V specifiers.
Thanks for the tip ;) my first piece of gold!
Also, someone just released [Games::2048](https://metacpan.org/release/Games-2048) on CPAN. Also text-based, with nice background-colored tiles and animation. More power to Perl :)
[Games::2048](https://metacpan.org/release/Games-2048) 
&gt; do not: log channel activity without the channel's express and on-the-record (preferably via /topic) consent LOLWUT? Since any usable IRC client has a scroll-back buffer, I can only assume this is a joke.
That should be "log, and then publish or distribute those logs to those were not present".
Does doing this with a data base file need a package I dont have installed?
http://search.cpan.org/~msergeant/DBD-SQLite-0.31/lib/DBD/SQLite.pm http://search.cpan.org/~nmarley/Parse-AccessLog-0.01/lib/Parse/AccessLog.pm Get the "cpanm" utility (google it). That installs Perl modules for you. You'll need modules to access SQLite and you'll want one to parse the log format (though you could cut and paste code there too... it's small enough). Play with the examples in the documentation for the modules. Get the examples to work first. Then try to combine the two examples/modules. When you get stuck, ask for help. If you're just learning to program, you're either going to need a *lot* of help or else you're the type who really enjoys solitary work for long hours on problems. I suggest going to a Perl Mongers meeting in town and making some friends: http://pm.org for one near you. This is big project. You're going to want books too.
$uptight++; 
Some more points: MetaCPAN is more information dense. I can see multiple pieces of information that I want to know without having to visit other parts of the distribution (upload time, number of issues, list of dependencies, repository, license). And from what I've seen, its support for images is better. Individually, these points are weak, but together I find they provide a better experience. And if you don't like the interface, you can use the API to write your own. Or just scroll down and click the link to s.c.o. on the left.
Public logs are explicitly banned. Private logs are typically okay with most channels but is a channel per channel thing. Scrollback buffers are rarely infinite or persistent so other than their use as a straw man here they are fine IMO.
If you want a private IRC channel, just create one,
If you want an irc network that allows you to publish conversations without people's explicit permission then just create one.
not what you're asking, but my issue with `cpanm` and `DBD::mysql` recently was that I didn't have any mysql installed or activated or anything, so the install was failing without a local db to play with. I'm pretty sure `brew install mysql` helped `cpanm` get through the install for my case.
take the perl job. perl is not dead. also the language doesn't really matter, what matters is not hating your job. also perl ftw
This is such a great book - up-to-date, clear, concise. I wonder what's with all the downvotes. Did you read that is was **free**
Does irc.perl.org enforce +z mode on channels (SSL required to join) by default? If not then this rule is pretty worthless; all kinds of third parties can be logging conversations without the participants' consent, or even having to agree to these terms.
Agreed. The language can be improved. I'll have revisions out soon.
I sometimes wonder if some people resent the fact that Perl makes producing good, effective software too easy. Even discounting the fact that it's the language I know best, Perl's structure means I can achieve what I want far quicker using it than any other language. Especially as "respected" languages like Java seem designed to make a programmer's job as *difficult* as possible, almost as if someone thought, "all these languages like Perl are *far* too easy. Let's get back to good old hard-to-use languages".
Even though I like MetaCPAN better, I still feel a bit odd editing someone else's comment unless the link is actually broken, or otherwise wrong.
There are only two kinds of languages: the ones people complain about and the ones nobody uses. --Bjarne Stroustrup 
install deps through cpan and you'll have the packlists.
something like; use strict; foreach my $filename (@ARGV[1,-1]) { open(my $file, "&lt;", $filename) or die "$!"; open my $fileout, "&gt;", $filename . "_out") or die "$!"; while (my $record = &lt;$filename&gt;) { my @fields = split /\*/, $record; if ($fields[0] eq 'CLP') { $fields[4] += 5.0; print $fileout join '*', @fields; print $fileout "CAS*CO*3*5~\n"; } else { print $fileout join "*", @fields; } } close ($file); close ($fileout); } Call like perl CLP2.pl file1 file2 file3 file4 will put file1 in file1_out etc.
Thanks, I'm doing this with several hundred files. Is there a way perl can grab the files by itself?
I don't understand. I've already installed those modules, it's just App::Fatpacker that doesn't see them.
when i had this problem, it was because i installed the modules via apt-get and debian strips the packlists. you might have some other problem though, dunno.
This seems to be more a question related to Artificial Intelligence or general algorithms than a question related to Perl (implementation should be quite straightforward if you have the algorithm). If I remember correctly, Bayesian networks still need examples to get good probabilities. 
Like sedusedan, I basically did all the little pieces by hand: https://github.com/iarna/App-Every/blob/master/build_fatpack.sh App::fatten looks awesome though, and I think I'd've used that if it'd existed at the time.
Amen!
The noise level is lower because no-one uses it anymore. 
The SoC has been updated regarding channel logging. See the "Channel Logging" section now up on http://www.irc.perl.org/rules.html
In most cases people who link to version specific or author specific pages did so because that was the first link that Google gave them. Changing those to links that won't break is improving their answers. StackOverflow encourages that.
Perl is like an old couch you know, when the new people come around, they see an old ragged butt shaped couch, but it fits you, and it's free, with a surprisingly low bug count. And then the new people come with bean bags, that seem very comfortable, but after a while they are full of bugs and the foam filling gets flat. Did i mention that the old couch comes with cpan?
A big problem is utter shit like this gets made and left around to be indexed: Should I Learn Python or Perl?: http://youtu.be/9SyUFO9X_TU
What you are looking for is Document Classification. Somewhat related to Information Retrival. Ask some NLP folks or Computational Linguists for that. It is a pretty elaborate theme.
First you win, then they fight you, then they laugh at you^* , then they ignore you. ^* Current state of Perl.
A naive Bayes classifier would probably be the easiest ML algorithm to implement, but there are plenty of other options too - random forests, Bayesian networks, support vector machines, etc. I'd suggest that you speak to an AI person if you know of one handy! I've done some ML in the past in bioinformatics, and it's rather important to have a good representative corpus of training data. Good luck, sounds like a fun problem!
Document similarity and document clustering algorithms are what you want http://semanticsearchart.com/researchBest.html
Youtube has a sucky DMCA filter. Flag it. lol
I'm with you on the Naive Bayes -- it's been working for years as a spam filter. I'd say start here -- tried/tested/true -- bonus: simple, intuitive -- many implementations available. Some commercial, many free, open source. http://en.wikipedia.org/wiki/Bayesian_spam_filtering
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bayesian spam filtering**](http://en.wikipedia.org/wiki/Bayesian%20spam%20filtering): [](#sfw) --- &gt; &gt;__Bayesian spam filtering__ (/ˈbeɪziən/ *__BAY__-zee-ən*; after Rev. [Thomas Bayes](http://en.wikipedia.org/wiki/Thomas_Bayes)) is a [statistical](http://en.wikipedia.org/wiki/Statistics) [technique](http://en.wikipedia.org/wiki/Scientific_technique) of [e-mail filtering](http://en.wikipedia.org/wiki/E-mail_filtering). In its basic form, it makes use of a [naive Bayes classifier](http://en.wikipedia.org/wiki/Naive_Bayes_classifier) on [bag of words](http://en.wikipedia.org/wiki/Bag_of_words) features to identify [spam](http://en.wikipedia.org/wiki/Spam_(electronic\)) e-mail, an approach commonly used in [text classification](http://en.wikipedia.org/wiki/Document_classification). &gt;Naive Bayes classifiers work by correlating the use of tokens (typically words, or sometimes other things), with spam and non-spam e-mails and then using [Bayesian inference](http://en.wikipedia.org/wiki/Bayesian_inference) to calculate a probability that an email is or is not spam. &gt;Naive Bayes spam filtering is a baseline technique for dealing with spam that can tailor itself to the email needs of individual users and give low [false positive](http://en.wikipedia.org/wiki/False_positive) spam detection rates that are generally acceptable to users. It is one of the oldest ways of doing spam filtering, with roots in the 1990s. &gt; --- ^Interesting: [^Anti-spam ^techniques](http://en.wikipedia.org/wiki/Anti-spam_techniques) ^| [^Bayesian ^poisoning](http://en.wikipedia.org/wiki/Bayesian_poisoning) ^| [^SpamBayes](http://en.wikipedia.org/wiki/SpamBayes) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cgn5bkr) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cgn5bkr)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
raiph: I agree with p6 semantics. That makes most sense. With function-call semantics you can either use the type as constructor (i.e. new) or as coercion, and most languages choose to use coercion. coercion from normal constructor args (i.e. some default attribute values, eg. ints or strings) can then choose to use this signature as constructor as special case of coercion.
Well... Unless there's a good reason not to, a Perl script *will* quit after it's executed. Maybe some more information, like the code and what it's trying to do?
I think that whoever produces the best results will keep winning. My company is hiring Perl developers left and right. Our Crawlers will out perform any Java/Python/Ruby Crawlers and that's why companies pay us the big bucks. They could care less what language we write in.
Perl is an extremely versatile language and it's uses have shifted more towards software development rather than web development
if you are going to be playing with perl, better get comfortable working (executing) in a shell environment. The standard CMD.exe shell on windows is crap, so look into powershell or cygwin.
If you want to sell a company, "Java" is worth more than "Perl". Also, while you need triple the dev team to do the same work, you can get them far easier (if not cheaper). Also-also, there's a lot more companies selling java app support, and they will cover the support stack... a lot fewer who will support Perl the same way. I got to sit face to face with the boss who made that decision today..He didn't convince me, but he admitted his first choice had been vetoed (ruby on rails)
Definitely, this! Perl will *work* in a pure Microsoft Windows environment, but it's not really *meant* for that environment. It is at its most powerful when embedded in UNIX/POSIX. 
my $poo = &lt;&gt;;
Sure, I get it. You store all your input in your $poo, but it looks like you don't do any garbage cleanup. Where does your $poo come out?
Run from console or use some orthodox file manager ([like FAR](http://www.farmanager.com/))
You could include a couple of little loops that wait for user input before proceeding through the script, if you wanted. Feel free to be more specific with your code, though - post some of it and we can talk it through with you.
*use English;* just gives you textual names to single character builtin variables... *use diagnostics;* gives you more verbose error messages. I have a feeling what the OP really wants is a REPL especially if they are trying to learn. Either `perl -de 1` or re.pl from Devel::REPL maybe.
Some editors will run a program and then capture the output in a new buffer/edit window. I don't know if Notepad++ will do this, but I would not be surprised if it did. 
This is the best answer because it waits for user input. Using a sleep will only sheep for a set amount of time. 
My bad, you're right. I use "perl -demo" as an easy to remember, and visually appealing access to the interactive environment. It does print an error message about the meaningless 'mo' part, but who cares.
Works as intended for me, your file fatpacked comes out to 486 KiB. $ ack 'package (Data::Dump::Color|XML::Simple|JSON);' fatpack-test.packed.pl package Data::Dump::Color; package JSON; package JSON; package XML::Simple; Submit a bug and tell your details: https://rt.cpan.org/Public/Dist/Display.html?Name=App-FatPacker
Your career will go better and last longer if you promote yourself as someone who can solve problems with a lot of tools in your toolbox rather than a specialist with only one tool. Yes, of course, there are a few people who know COBOL and have jobs for life, but focus on the "few people" rather than "jobs for life" part--and they're not writing lots of new, fun software. They're maintaining software that's been in maintenance mode for decades.
This is trying to quarantine a curable illness by murdering the infected with a lethal virus.
they're files called .packlist next to the module, containing a list of all files that belong to said module. if you install via a cpan client, you'll have them. distros seem to strip them, for no reason i can see.
notepad++ has a compiler plugin. Check here http://damienlearnsperl.blogspot.ca/2009/01/launch-your-perl-script-from-notepad.html
I really like some of these ideas: &gt;Perl ecosystem needs better branding and a style guide ... crowdfund a campaign to hire some agency to design that. &gt;major resources (perl.com, perl.org, jobs.perl.org, metacpan, etc...) need to be visually re-designed with that style guide in mind Great idea, excluding metacpan. I think it looks good already? &gt;a defacto, easy "get started" guide Would the [Modern Perl](http://modernperlbooks.com/books/modern_perl_2014/) site fit this criteria? Maybe we just need to link more to it. &gt;a course outline and eventually prepare an entire course with slides on Modern Perl that teachers from schools, colleges and universities can use Maybe Modern Perl, the course? &gt;We need to jump on some bandwagon trends and contribute to other communities. E.g. now is a good time to write some Perl tools for Docker Yes, yes and yes! &gt;We need to proactively collect potential user emails for marketing You-know-what perl.org has no mailing list on the front page. Or what about a link to Perl Weekly? That is the best Perl digest out there (albeit commercial). Some of them not as much: &gt;Provide a front end framework based on above style guide Not sure how useful this would be, it sounds good but unless it was an entire app (big development effort) just a collection of templates /CSS probably wouldn't have much traction. Maybe I'm missing something. &gt;We need to get rid of "Not invented here" anti pattern in Perl community I don't think this is "solvable" as it's not a well-defined problem. &gt;a web based forum Perlmonks, StackOverflow, Reddit are probably enough? &gt;We need a well thought out PR campaign to promote Perl Not sure what this would look like ... sounds expensive :) 
&gt; Perl ecosystem needs better branding and a style guide. It needs to be more iconic and recognizable. Possibly we need to crowdfund a campaign to hire some agency to design that. I agree that some websites have the 90's look but a style guide seems to be a bit much. A overhaul to &gt;2010 will do, I guess. &gt; Provide a front end framework... This will allow tool developers to quickly get started to advertise their creations in a digestible and pleasant manner. Websites should use whatever template they want, I don't think there is a lot of benefit to give Perl related websites the same layout. The content links them all together. &gt; But we definitely need a facelift for most of the community. Definitely agree. &gt; We need a defacto, easy "get started" guide, which is also easily accessible, like "perl.(com|org)/start"... This would list all authoritative resources and easy instructions how to get going with "Modern Perl". E.g. how to instal plenv, how to get cpanm. Agreed for the most part. A (official?) "getting started" with Perl can be very helpful but I would extend it to something like the Android docs ( https://developer.android.com/guide/index.html ) where there is one place that people can go to, to get information about Perl related topics. The key here is that it is written to get you up and running as fast as possible with concrete examples and explanations, not boring lists of every little option or subroutine like perldocs (which should be used if you already know what you're doing). &gt; We need a web based forum. This might indeed be a good thing but I agree with sillymoos that reddit, stackoverflow, perl monks etc. give plenty of possibilities to post questions. &gt; We need a well thought out PR campaign to promote Perl to nurture the growth and business acceptance. Let's all just write cool/awesome programs in Perl, that's the best marketing (strategy). &gt; We need to jump on some bandwagon trends and contribute to other communities. Definitely! 
You have things backwards. You don't punish people *before* they act. You assume people are reasonable and that asking up front that people not publish conversations without consent is a reasonable request.
I could use some blog software right now. I just got my baseimg all of the way done to my liking for my Linux containers on my vps. I'll have my network done by this weekend. I want to be gloating about it some time next week.
Meh.
Much as I agree with most of these, they don't seem like newly-discovered problems; this is just another copy of a list I've seen before.
there's a case which i'm experiencing where fatpack doesn't see the .packlist (despite the modules being installed through cpanm and the .packlist are there). I use perlbrew. https://rt.cpan.org/Public/Bug/Display.html?id=94395
&gt; I could use some blog software right now http://www.pearlbee.org/
`sort { $a &lt;=&gt; $b } @p`
It's always worth checking out the [Perl FAQ](http://perldoc.perl.org/perlfaq.html). In this case, there's a question [How do I sort an array by (anything)?](http://perldoc.perl.org/perlfaq4.html#How-do-I-sort-an-array-by-(anything%29%3f) and the answer starts by saying: &gt; Supply a comparison function to sort() (described in [sort](http://perldoc.perl.org/functions/sort.html)): &gt; &gt; @list = sort { $a &lt;=&gt; $b } @list; &gt; &gt; The default sort function is cmp, string comparison, which would sort (1, 2, 10) into (1, 10, 2) . &lt;=&gt; , used above, is the numerical comparison operator.
Use a text editor to edit your programs. Use a shell (Powershell or Cygwin) to run your code.
What do you mean by the Perl Weekly being commercial?
Or that people are too aged in their Perl ways to have patience with new people, and the beginners aren't so numerous that they help each other or have a community.
"Modern" and then "web-based forum"? I can't remember any old-fashioned forum ever being helpful for programming language questions in *any* language. Mostly I get [this](https://xkcd.com/979/)...
[Image](http://imgs.xkcd.com/comics/wisdom_of_the_ancients.png) **Title:** Wisdom of the Ancients **Title-text:** All long help threads should have a sticky globally-editable post at the top saying 'DEAR PEOPLE FROM THE FUTURE: Here's what we've figured out so far ...' [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=979#Explanation) **Stats:** This comic has been referenced 142 time(s), representing 0.9031% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
Test the value of $cell first. if (!$cell || !($v=$cell-&gt;value())) # Error here 
The fault ist not in the second line but in the first. And perhaps the error message is unclear because there are 2 completely different "value"s. First is the mrthod call "value". Second is the value, what is $cell, that is undefined. Perl tells you, that you need an object, not a undefined value to call a method. So for any reason -&gt;get_cell cant find the cell and returns undef. edit: "get_cell($row, $col): Return the "Cell" object at row $row and column $col if it is defined. Otherwise returns undef." But I don't have an idea what is meant by "it".
PearlBee is more like the result of a tutorial "How to make a blog" its FAR away from being a blog product or anything that someone should use.... Did you ever checked into the code?
&gt;My guess is that perl.org makes more profit to its owners What do you mean by this? 
&gt;But I don't have an idea what is meant by "it". The way I understand it: the cell. A spreadsheet is a sparse 2-dimensional array. Empty spreadsheet cells simply don't exist in the sparse array. 
&gt; I agree that some websites have the 90's look but a style guide seems to be a bit much. A overhaul to &gt;2010 will do, I guess. I think a style-guide is appropriate; governance is good and a small measure of uniformity and consistency will go a long way; Our conferences have an official code-of-conduct for this reason. When I say style-guide I am referring to a logo, color palette, and scheme (flat, bold, etc). &gt; Websites should use whatever template they want, I don't think there is a lot of benefit to give Perl related websites the same layout. The content links them all together. I agree. I don't much care about the page layout, however, I do think that our community and foundation sites should follow a style-guide. As someone interested in aesthetics, and with some taste, I can tell you that branding is marketing and marketing is about telling a story (or at the very least, sending a message) and not being consistent in your message can be detrimental. &gt; Let's all just write cool/awesome programs in Perl, that's the best marketing (strategy). Yes, I agree. I'd just like to add that the term "program" is very broad and "cool/awesome" is subjective. I think we might start by discussing project ideas and organizing (herding our cats).
Oh man! It's the UFO operator :D
You could extract ("using the the old fashion way"): time sntp server-address x.x.x.x no shutdown exit exit from the: time some other time protocol ---------- added by some op echo "bob don't forget to check if x.x.x.x is up" server-address x.x.x.x exit sntp option refresh 10ms server-address x.x.x.x no shutdown exit exit and then apply your grammar on it.
That's perfect! Thanks!
Why not talk about dancer... its pretty kewl...
Every developer I've spoken to says Java scares off software developers. I also don't know what you're talking about "selling" a company by which language you write in. My company writes in Javascript, Perl, Python, Ruby, Rails, PHP, C, C+...Some of our software is written in Perl, some in other languages. You should be selling some kind of product, not the language you write in.
Makes sense
https://xkcd.com/1053/
[Image](http://imgs.xkcd.com/comics/ten_thousand.png) **Title:** Ten Thousand **Title-text:** Saying 'what kind of an idiot doesn't know about the Yellowstone supervolcano' is so much more boring than telling someone about the Yellowstone supervolcano for the first time. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=1053#Explanation) **Stats:** This comic has been referenced 958 time(s), representing 6.0552% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcdcomic/)/[kerfuffle](http://www.reddit.com/r/self/comments/1xdwba/the_history_of_the_rxkcd_kerfuffle/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me)
&gt; I also don't know what you're talking about "selling" a company by which language you write in. I'm not sure what's not obvious to this. Stupid rich old businessmen see it and make money off it. Let's say you're an underhanded, conservative VC firm. You buy a medium company that still uses perl for its web-apps, and use that as a haggling point to drive the price down. You hold for 5 years, and ruin the efficiency of the division by swapping from Perl to Java, then sign a bunch of outside support contracts. Right before the sell, you drive out half the dev team to make it look like your profits are higher than they really are...then you go onto the market. You have: 1. Replacable support teams (Java support contracts are a dime a dozen in India). 2. An infrastructure that won't scare off a 90-year-old investor. 3. A high-profit buy-out. That's exactly what's going on with my former employer (just left) right now. They came in, strong-armed in Java (it was between that and C#), and are positioning for a sale in the next 2 years. Over 70% of our development team turned over, to be replaced with more expensive but less capable resources...but the profit margin is high and we are going to look like gold for a sale or merger. &gt; My company writes in Javascript... You should be selling some kind of product, not the language you write in. That's nice...but you're not in the middle of a brutal short-term investment. My old company sells a great product that was ready for a refactor anyway... this just led the refactor to be written in Java to raise the paper value of the company. You may not LIKE that fact...and it does scare off everyone but Java developers (who, oddly, are among the largest factions anyway). I'm not *fond* of the decision my old company made, and I think it would've been a terrible long-term decision...but a bunch of very smart people planned this to make themselves a lot of money in 5 years, not make a great company in 20.
As far as I know, there isn't a way to run a query on two different databases simultaneously, in perl or any other language. You either need to use to different DBI connections and combine the data using perl, or you need to import the data from one db into the other, and run a JOIN query on the db you imported into.
If you have any rights on the postgres database you can use [dblink](http://www.postgresql.org/docs/9.1/static/dblink.html) to create the sql query there, store it in a temp table or a full table if you want, then just connect to the postgres db using perl::dbi. Depends on your rights.
The perl program will be local to the Pg database, but this is still interesting.
I believe [Foreign Data Wrappers](http://www.postgresql.org/docs/current/interactive/fdwhandler.html) are the Pg-core replacement for dblink.
There is an entire guide specifically written to teach how to grow from a lite to full app; the growing guide: http://mojolicio.us/perldoc/Mojolicious/Guides/Growing In general one should start by reading the lite documentation, the lite syntax is much easier for examples than full oo style so we use it throughout the doc. It also serves as the introductory tutorial. From there one should read the guides in the order seen here http://mojolicio.us/perldoc
If I may say, the major difference between Dancer and Mojo is that Mojo is written to be nonblocking. I usually consider Mojo's primary competition to be node.js rather than the other Perl frameworks. 
OMG that looks like exactly what I need, though my software is running under RHEL 6 so I don't have 9.1 yet out of repos. I may have to manually install 9.1 or 9.3 to try this out. Thanks! 
You can get RPMs directly from Postgres. http://yum.postgresql.org/
I think where Perl has fallen behind the curve is there are no really big "applications" using Perl that the community has adopted. If we look at PHP they have Wordpress, the most widely used blog engine ^[citation ^needed], and Ruby has products like Chef and Puppet that are in wide use by the "DevOps" community. I mean, we have [WebGUI](https://www.webgui.org/) but WGUI8 has been in "beta" for how long now? And let's face it, it's not really easy to setup, especially for the uninitiated, whereas the Wordpress install is literally "copy these files to the server, then visit this web page". There are others, like MovableType, etc. but they don't really fill the same niche (the whole of the internet) that Wordpress does. Same goes for Ruby/Chef/DevOps people. Sure, there's [slaughter](http://www.steve.org.uk/Software/slaughter/) (what?) but who's heard of it (I actually think the project has promise, but has a long way to go to catch up) and [rexify](http://www.rexify.org/) who's codebase is a complete mess. I've long wanted to redesign the perlmonks site. Honestly, it's slow and hard to navigate and reeks of 1990. I mean, the chatter box is just so primitive (though let's be honest, how many sites have live chat on the front page?), and loading pages is slllloooowwwww... Not exactly our best foot forward when our websites run slow and look like they were built last century. I don't mean to be a negative nelly, WebGUI is an awesome product and I have users merrily churning along with MT. But we're never going to attract the lowest common denominator with a high barrier for entry.
++ I didn't know I needed this until now.
No, the issue is production dbs have to run off rpms from upstream (either RH or SL), meaning 8.4. But I'm planning on experimenting with installing the rpms, if there's no squashing of files (I think the package names are postgresql92 instead of postgresql, which may work. It's a VM so, eh, if I screw up no harm no foul (it's a backup of a backup)).
Glad to hear you're getting on well! Regarding documentation weaknesses - please feel free to drop me a message pointing at the bits you think need some love. Documentation is hard,and when you're very familiar with a project it can be hard to identify areas which are lacking information new users will need. Feedback, good and bad, is always very welcomed! (I'm one of the core devs and author of some of the commonly-used plugins)
Can you give a bit more detail on the issue (an example would be nice)? I assume you're doing the matching on a per line basis, so I'll give my best shot at it. In your looping through the file you might do something like this: next if $line =~ /(?:"\d+"|#.*\d)/; or you could separate them out: next if $line =~ /"\d+"/; # skip digits enclosed in double quotes next if $line =~ /#.*\d/; # skip digits preceded by pound Then do your regular matching that you already have. There's lots of ways of doing this. You could also try to make some really ugly one liner that does the trick for you, but I'm not a huge fan of that because of the readability issues it tends to bring with it (though using the x flag can help with that, more info here: http://perldoc.perl.org/perlre.html ). 
On windows? If you're going to do Windows specific stuff then ActiveState might be a better choice: they ship windows specific stuff too (like support for win32 services, which I missed in Strawberry). Personally, I prefer Strawberry because it's much closer to what I've got on Linux, and it works perfectly. On Linux, take what the distro ships, or compile your own, it's pretty easy.
Agreed, strawberry will get you closer to what everyone else is using
I think the goatse operator is my favorite "secret" operator http://www.perlmonks.org/?node_id=527973
You could try to come up with a better regex or you could simply filter out the "wrongly" matched numbers: my @numbers = $input =~ /(?:\d*.)?\d+/g; @numbers = grep { !/^"|#/ } @numbers; 
Thanks I will do that. Understand that documentation is always last on a dev's mind, and that some missing elements are only obvious when looked at by another person. The only part that held me up was that complex data structures, like hashrefs and listrefs, are not supported by the simple template engine. Once I switched to TemplateToolkit, everything worked great. I read the POD for Template::Simple, but there was no obvious mention that it doesn't support those structures. I think the solution is just the addition of a simple statement such as: &gt; **Note** Template::Simple can only parse scalar variables; it cannot parse hashrefs or listrefs. If you want to use these structures, such as iterating through a list of table rows from a database, you must use Template Toolkit.
If you want to be able to use the most recent versions of modules from CPAN, Strawberry is better than ActiveState. ActiveState is very easy if you're working with stable, older modules, though. If you want a more powerful command line to go with it, Cygwin can provide a Windows integrated linux-like environment (including Perl), but it can be a bit problematic with some Windows installs (rebasing issues) and some linux programs. Oracle VM Virtualbox can give you a full linux virtual machine, but it is a lot of overhead if you're just doing simple tasks. Personally, I use Strawberrry + Cygwin + VirtualBox. TL;DR: Strawberry :-)
Now I understand the issues. It's strawberry for now unless and until I need to do windows-specific stuff. And you never know when that might be...
Just curious but what about YAPC::NA is putting you off?
I wouldn't say "putting me off". Some interesting talks, I'm sure. Just nothing that I would say "Can't miss!" I've never been to Florida so I'm not sure if that is a plus or minus. I like OSCON for the variety and I enjoy the excuse to visit Portland. But maybe I should give YAPC a try.
Talks at YAPC can be hit-or-miss. I've gone to a few that I was really excited about, but came away unimpressed. OTOH, Hallway++ rarely disappoints.
I'm looking forward to giving a talk on Atari 2600 programming [edit: at YAPC this year]. I'm hoping to have some fun with it. Aside from that, honestly, I haven't even looked at the schedule. In the past, several people have given good introductions to topics but it's generally stuff I'm familiar with. A few years ago, there was a talk on extremely high throughput database work querying and loading for packet analysis that had a mini stats intro as part of it. Talks like that come up now and then and surprise me. I always enjoy hearing mst, MJD, Damian Conway, or Larry speak. Some other members of the community I see as up and coming pros. DEFCON has been my meat and potatoes for actually keeping a finger on the pulse of technology, though. There's a huge amount of cleverness there, but the audience can be pretty gutterpunk. Heck, it brings out the gutterpunk in me. I've never done an OSCON. Friends are going to Strange Loop https://thestrangeloop.com/ this year and it looks awesome to me so I'm planning on doing that one, money permitting. OpenDataVis looks neat too.
I use strawberry when I have to do anything with perl on a windows machine. It resembles the perl version(s) in Linux more and uses cpan (or cpanm) to manage its modules. That being said I haven't looked at active state perl in a long time. I tend to be lucky enough to work in a mainly Linux shop :-)
YAPC is tiny by comparison to almost any other conference. It's also very focused on the one topic. I've always enjoyed YAPC but it is quite a different experience than any of the big conferences.
Sad I *can't* go to YAPC::NA this year. I'd love to see that talk. Is that last conference (OpenDataVis) this [OpenVis conference](http://openvisconf.com/)?
You need to use list context if you want all the lines. Perldoc: &gt; In scalar context, it comes back as a single (potentially multi-line) string, or undef if the command failed. In list context, returns a list of lines (however you've defined lines with $/ or $INPUT_RECORD_SEPARATOR), or an empty list if the command failed. This creates another problem however, having one variable containing the lines of both files. You can either solve it by calling *ssh* twice, one for each file (=slow) or by being clever with the contents of the list and finding a way to split it in two.
Given the newbie prefix, then the best answer probably still is Activeperl , but as with anything it depends… I use both Activeperl 5.16 ( 32 bit ) and Strawberry Perl 5.18 (32 bit) on Windows and both Activeperl and Strawberry Perl works just fine. Crudely condensed; With ActivePerl you have in addition to cpan (cpanm) Activestates Package Manager ppm, which can save time and headaches when installing CPAN modules, though installation via cpan or cpanm on newer versions of Perl, rarely requires thinking either. And there are, depending on your needs, the option of buying ActiveStates proprietary PDK ( the actual reason I still use ActivePerl ). One caveat though; Activeperls community edition license restricts the usage of ActivePerl on production servers which, might/might not be a problem for you. 
obligatory security warning ... Make sure you're handling nasty crap inside of $options_hash{passwd_path} and {group_path} something like "/etc/passwd;rm /etc/passwd" in either could make your day go worse. :)
So I know for a fact there are a couple really (like REALLY) interesting talks at YAPC::NA this year which are not yet on the schedule (shh they are a secret). I have been going to YAPC::NA every year since 2005 and this year is the can't miss year in my opinion. 
Well, now I'm intrigued. Thanks!
system has the same problem if you pass it a string rather than a list. open3 is your best bet.
Yeah, I meant list system. I never remember that open can be used for this, though, so I always wind up finding something on CPAN to do it.
He could use a special delimiter between the contents of the 2 files. Typically, Unix people might use a null byte. 
I usually end up writing something like: sub backtick { open(my $capture, "-|", @_) or die "Couldn't run $_[0]"; local $/; &lt;$capture&gt; } That really deserves to be part of the core.
Just another note, your code would read a bit better if you didn't do weird things with foreach: foreach my $list_item ( @serverlist ) { ... qx(ssh -p $list_item{port} ... } Your code would also be faster if you just used the refs instead of copying your ref args into their normal counterparts.
pl is for scripts, pm is for modules It's hard to tell what's wrong with Alien::SDL because you provided no actual information. What was the output of "cpan Alien::SDL"? What happens when you run perl -MAlien::SDL -e "print 1;"? Have you configured INCLUDE and LIB environment variables to point to pre-installed SDL or you let Alien-SDL to download and install it for you? Do you use the same platform (32 vs 64 bits) for Perl and your library? Have you tried downloading a package file from CPAN and run "perl Build.PL &amp;&amp; Build &amp;&amp; Build test &amp;&amp; Build install"?
What do you mean weird things with foreach? I am using foreach to loop by index instead of by element because that is less weird for people I work with, and easier to conceptualize for me.
you can find most of these benchmarks in here: https://github.com/japhb/perl6-bench/blob/master/microbenchmarks.pl Now bear in mind that these are not at all good for comparing between languages or something like that. They are purely meant to see if improvements in little things have a positive impact on performance at all. That being said, the "iterations per run" variable is what goes into the SCALE placeholder in these pieces of code. We also have "minibenchmarks" in the minibenchmarks.pl file, which are rudimentarily better at being benchmarks. Patches very welcome :)
SublimeText2 is scriptable via Python. Learn some Python, and you can make sublime do what you want. On a different note, here's another worthy IDE, called [Padre](http://padre.perlide.org/) , it's written in Perl. And of course, the trusty [Emacs](http://www.emacswiki.org/emacs/PerlLanguage) with different modes for Perl. But let's not forget the [Vim](http://www.vim.org/) which is very good too. Maan.. there are many many IDEs out there. For dynamic languages like Perl or Python or Ruby it doesn't matter that much which one you use. IDEs are usually a problem for Java people. They're really relevant in that area. 
I would strongly recommend not working inside of a shell like IDLE. It will make your work much harder to replicate. I would suggest that you follow a work methodology like this: http://www.ploscompbiol.org/article/info%3Adoi%2F10.1371%2Fjournal.pcbi.1000424 I don't think that the exact organisation matters overly, so long as it's structured, and there's an equivalent of "runall" that will let me replicate everything from the fastq files / tag mapping onwards... Doing this really saved me when I was asked to reproduce a 3 year old experiment about two weeks ago! Also, the way that I do it is while I have an overall script that runs all of the other ones (some people I know use Makefiles, but that's a little ick), when I'm working on a single part, I won't rerun everything - just what I'm currently doing while I'm writing script/s for that partof the work/experiment. When I've got all of the stages working, I'll then rerun the whole thing to make sure that I can reproduce it in the future. EDIT: I know that's not what you asked sorry, and there is Devel::REPL, but I'm perversely not going to link to it.
It should be possible to run your Perl scripts from SublimeText. You need to use **Tools &gt; Build** (or CMD + B) But first you need to set up a build system file for Perl using **Tools &gt; Build system &gt; New build system...** See here for a possible build system config http://www.perlmonks.org/?node_id=935014 Official docs are here http://sublimetext.info/docs/en/reference/build_systems.html
Padre works great for Perl. I do a heck of a lot of scientific analysis work in [Perl/PDL](http://pdl.perl.org), which predates Scipy and is still in many ways more powerful and elegant. It has a very nice built-in shell: though it is not as full featured as Padre, it does have support for multiline commands, line retrieval, and many esoterica that make life easier for that specific application. My workflow consists of producing a script (in emacs) and pasting lines into perldl (the included shell that comes with PDL), or vice versa. At the end of a "chapter" of processing I have a script that I can run to reproduce the result. (Edit: the perldl shell also logs your work, so you can save your command history to a script -- but I prefer the control that text editor work offers...) 
I use Komodo. Its pretty good, but I have not used a lot of the advanced features beyond syntax checking, keyword coloring, and project file explorer. I am interested in trying Padre, but I'm on OSX and building from source seems like a bit of a pain (I've never had a lot of success building things from source). I know there is a binary available on WildPerl, but it doesn't look like its been updated since late 2011. Anyways, if people are using Padre on OSX, I would love to chat and learn your thoughts and how you got it to work.
Yup that's what I meant. 
A proper regular expression for matching valid email addresses is ridiculously complicated. http://search.cpan.org/~rjbs/Email-Valid-1.193/lib/Email/Valid.pm is a better way to do validation. If you're interested, here's a generated regular expression to do matching: http://ex-parrot.com/pdw/Mail-RFC822-Address.html
It has nothing to do with the regex. The `@` in a double quoted string interpolates arrays. Since there's no array named `Address`, that means that your `$x` variable equals `"Email.com"`, which is not what you intended. Use single quotes or escape the `@`. You would have discovered this for yourself if you had begun your script with the recommended settings: use warnings; use strict; If you had done that, Perl would have helpfully given you a hint: Possible unintended interpolation of @Address in string at ... 
Just for fun, print out the value of `$x` before trying to match it. Then add use warnings; use strict; to the top and try again.
First, **this is a bad set-up**. You haven't accounted for names like John.Smith@whatever or John_Smith or Jsmith123. And that's just the start of it. There was a great piece the other year... http://davidcel.is/blog/2012/09/06/stop-validating-email-addresses-with-regex/ If you really feel you need to do this... /.+@.+\..+/i 
Using foreach over an array index would generally be considered non-idiomatic or "not very Perly". Sometimes you really need that index though. At least you didn't do a C-style for (my $i = 0;.... Using the references directly should be faster in theory. In reality, probably doesn't matter much. EDIT: BTW, following the style of your co-worker has merit too. If you want to learn more about Perl style, checkout Damian Conway's [Perl Best Practices](http://www.amazon.com/gp/product/B002L4EXI8?ie=UTF8&amp;camp=213733&amp;creative=393177&amp;creativeASIN=B002L4EXI8&amp;linkCode=shr&amp;tag=jusanostublo-20). 
They are both true. A) Referencing array elements by index during iteration is error prone and old school. "Foreach" style loops are in vogue and better. Less surface area for mistakes. B) Due to the scale of your domain, performance is not a critical factor. However it is true that you are unnecessarily copying your data structures when in fact the originals are fine. Were this a larger domain, it would be a legit problem. Don't do things that don't need doing.
I know you're correct, but your reason for number one is essentially "fashion", which has no place in computers. Edit: *sigh* at you all. Yes I know why foreach is a better alternative. The point is that none of the reasons were given. The only reason given *in this time and place* for why foreach is better is that it's better.
"Best Practices" are frequently what you refer to as "fashion." They certainly have a place in computers.
&gt; "Best Practices" are frequently what you refer to as "fashion." I know this. I guess they do have "a" place of sorts...
At least you aren't using a C-style loop: for ( my $i = 0; $i &lt; @serverlist; $i++ ) { ... } The problem with both the C-style loop and your loop is that they are (clumsy, brute-force) implementation techniques to iterate over the array elements, when Perl gives you a clean, simple and efficient iteration technique. You are doing extra work. The extra nano-seconds won't make a life-or-death difference in the run-time of your five minute program, but you are making the reader figure out what you are doing, where a Perl-ish implementation would require less analysis. In my opinion, many people use the C-style loop or the (1..N) loop because, presented with the problem of doing something to a set of items, they think, "first I extract the first element ... ". That's like painting a picket fence by removing a picket, painting it white, waiting for it to dry, hammering it back and place, and removing the next picket ... . Better in my mind to think in terms of operations on sets: "Begin at one end, paint the fence, stop when you reach the other end". I think ChoHag's comments about fashion are misplaced. You might in the same way say that OO programming is fashion. Subroutines are fashion, for(), while() and until() loops are fashion, you could (and in the 70s we did) achieve the same with "loop; .... GOTO [line number]; end loop". Using high-level constructs rather the the manual implementation is always a good thing.
Perl was doing foreach long before it was fashionable. At least [back to 5.005](http://www.themanualpage.org/man/man1/perlsyn.1.php), maybe earlier. JavaScript didn't get Array.forEach() until v1.6, which was in 2005. Java added it for v1.5 in 2004. So no, Perl has a long tradition of foreach.
Thanks, I checked out the Padre site/screenshots and it looks quite nice. I think I will try this next. Do you code in Python at all? I like the fact that I can actively write a script in the editor and then ctrl+s to save, and F5 to run the script in the second window (debugger window?). That is how I was taught, but all I have ever written are single file scripts, nothing object oriented.
Thanks for the article. As I mentioned in another comment, I like to write scripts in the editor and run them in IDLE, just to be clear, is that what you recommend against? In my approach I always have a script file that is still usable. The pipeline I am working on right now is about 1000 lines of python, all in one script file. It certainly would be difficult to reproduce the work if it was only in the run shell (debugger?).
Very nice, thank you :) I had come across this before, but needed a little encouragement (yours provided) to do it. Works, and I like the layout. This might be my goto for now with the limited amount of Perl I will be working with, and perhaps I will try it with Python as well, it is certainly a more functional editor than IDLE.
I like SublimeText 2 for what I have used it for in the past, and with the help of /u/nickl77 I can run Perl within it now. What have you scripted ST2 to do, any examples?
It's honestly not that hard especially if you use Dist::Zilla. I am by no means an expert Perl programmer, but I've been able to release a little code over the past 1.5 years by just putting in a couple of hours on weekends. And my favourite part of releasing a module is that CPANtesters helps make sure your code is running everywhere. &gt; dzil new My::Fancy::Module &gt; $EDITOR t/my_tests.t lib/My/Fancy/Module.pm &gt; prove -l # test it &gt; dzil release # done! And by all that I mean: try it! You might like it.
https://metacpan.org/pod/distribution/Perl-Critic/bin/perlcritic command line program to tell you when you aren't following best practices. 
While I don't use C-style loops much, I do still use them when I have 2 (or more) arrays with synchronized values (like @headers and @row_values, for example). Should I be doing that a different way?
Here's some counterarguments for the C-style loop: 1) Anytime you need the index, you might want to use the C-style loop. Otherwise you'll code something like: my $i = 0; for (@ary) { do_something1(); $i++; do_something2(); } which can introduce some errors depending on where you put the `$i++` part (sometimes I'm tempted to do it in a conditional, like `last if $i++ &lt; $n` which can also introduce another potential bug. 2) If the @ary you're looping is modified (changes its length, gets inserted elements in the middle or at the start), the behavior for(@ary) loop might not be obvious (either does what you want, or becomes an infinite loop, or something else). So the short answer is: it depends.
There are two versions of Komodo. Komodo Edit is the free version, and the only version than I've ever used. Komodo IDE costs $$$. I don't really know the advanced features, so cannot say if it is worth the money.
&gt; If you're interested, here's a generated regular expression to do matching: http://ex-parrot.com/pdw/Mail-RFC822-Address.html And then Perl exploded. That's a huge regex. 
Your file.pl needs to use the module like this: use Alien::SDL; Make sure to get caps right. 
I use the C-style loop because it does not violate this Law of Programming: **Make it readable to other non-Perl programmers.** Which means, don't obfuscate code just because the next programmer doesn't know perl-specific syntax. If I really need speed, I use other methods. Which is rare, because 99% of the time my bottlenecks are disk reads and writes, which are already super fast in Perl. EDIT: I may have to clarify some context here. I've worked more in mid-sized companies who often have need of a programmer but don't have the funds to pay $60k. So they find whoever they can afford, and let them learn the language. Also, not every market has a very experienced Perl programmer. That's really a niche programming language. You CAN do SQL with Perl but it's not recommended if managing data is your primary job focus. There are other tools that are better at managing data, and printing ad hoc reports quickly. 
Well to be fair I consider the venue this year a Plus. It's less than 10 miles from my house so I'm contemplating sleeping in my own bed for a change. We're not as trendy as Portland but we are increasingly doing well in the food and freaky categories. One of the organizers (trog/Mark) is a great resource to ask for the Portland-like stuff to see and do in town. For me the most important part of YAPC is the hallway++ track. Being able to actually talk with people and see what they're excited about is incredibly cool and something that really doesn't happen as deeply at OSCON because of the crowds. The focus on Perl is also a bonus, I know that I won't have to explain that "yes I do work in Perl. Yes you can still work in Perl. Actually I make quite a nice living in Perl. Yes *that* Perl. No no it isn't dead." to every third person I meet is a nice feature.
&gt; 1) Anytime you need the index, you might want to use the C-style loop No, you'd write something like: foreach my $i (0 .. $#ary) { ... }
&gt; Should I be doing that a different way? Yeah, I'd do that like this: foreach my $i (0 .. $#headers) { # do something with $headers[$i] # do something with $row_values[$i] } But I would probably try not to have two disconnected data structures like that in the first place :-)
I don't think it is unreasonable to expect that others reading my *Perl* code will be familiar with common *Perl* syntax.
++ to hallway++ :D
Exactly. Isn't this what hashes are for?
One of the things that you should learn about Perl ASAP is that for most problems someone else has already solved it and put it on the CPAN. Validating email addresses? Solved. Fetching web pages? Solved. Scraping data from web pages? Solved. Validating ISBNs? Solved. Sending email? Solved. Handling inbound email? Solved. etc etc etc Unless the problem you're working is one where you might be the very first person to have to deal with it, go check the CPAN first.
&gt; ... don't obfuscate code just because the next programmer doesn't know perl-specific syntax. I don't mean this to sound snarky, but if you can't count on the next programmer knowing (or being willing to learn Perl), then perhaps your team is better off with another language that the next developer *does* know.
$dbh-&gt;selectall_arrayref($sql, { 'Slice' =&gt; {} })
1. www.google.com - "perl DBI" 2. Click first link to CPAN DBI docs 3. command(or cntrl)+F 4. type 'hash' 5. about 3 "nexts" later you'll find what you need. http://search.cpan.org/dist/DBI/DBI.pm#selectall_hashref
If you have List::MoreUtils installed, look at the each_array() function. But that's only if you absolutely *must* track matching data in separate data structures. Perhaps an Array of Hashes reference would be in order, something like: my $container = [ { header =&gt; 'something', row_value =&gt; 'something_else' }, { header =&gt; 'something_different', row_value =&gt; 'something_different_still', }, ]; 
Should happen in the next week. The organizers have had sudden outbreaks of "Life" causing issues.
Actually that's different. What Amphrael asked for is a *little* harder to find. But quitehairy has the right answer.
You don't run a business, and stay in business, by changing languages which can take hundreds of thousands of dollars or more and months or years. It's cheaper and faster to hire a programmer and let them learn the language. 
How are you passing the hash to the function? I mean, can you show an example of calling the function? It should be something like gethash(\%hash, 'value'); Because the code in the function is expecting a reference to a hash. In all honestly, I'm guessing you're doing this for practice because the code has some bad practices. (I'm ignoring the indention/formatting with the assumption that it's reddit making it weird) These two lines aren't needed. @a, @b, $i, $j are never defined or used. $t isn't needed because you might as well directly return rather than temporarily assigning the variable. my(@a,@b,$i,$j,$procname,$t); $procname="gethash"; What this next line is doing is changing the hash reference back into a hash. It's a copy operation so it's slower than just leaving it as a hash reference, but in order to use the reference you would need to be comfortable with the way references work. Also, the parenthesis aren't needed for this line. Using them here treats the input as an array and might be contributing to your problem. my(%hash)=%{$_[0]}; If you want to switch to using it as a reference you might do something like this: sub gethash { # I'm using shift instead of $_[0] and $_[1]. It takes the first argument off the stack my $hashref = shift; my $k = shift; # you probably don't need exists(), you might get by with if ($hashref-&gt;{k}) depending on what you really need. # See http://stackoverflow.com/questions/6534573/whats-the-difference-between-exists-and-defined if (defined($hashref-&gt;{k})) { return $hashref-&gt;{k}; } else { return "Unk: $k"; } # should never get here return; } 
You don't really need a function for such a common operation: my %backtype = (BLA =&gt; 'stuff', FOO =&gt; 'foobar'); my $type = 'FOO'; my $backtype = exists $backtype{$type} ? $backtype{$type} : 'unknown'; # or if the values in the %backtype are "trufy" you could use # my $backtype = $backtype{$type} || 'unknown'; # or if you can get a newer perl ( &gt;= 5.10) # my $backtype = $backtype{$type} // 'unknown'; # which would work even for values that are false (like 0 and the &lt;empty string&gt;) print $backtype, "\n";
&gt; These two lines aren't needed. @a, @b, $i, $j are never defined or used. This is a subroutine stub and these variables are often used, but are not used in this example. &gt; $t isn't needed because you might as well directly return rather than temporarily assigning the variable. As the project progresses, I might need to do more things to $t, so that's why I did it that way. &gt; It should be something like gethash(\%hash, 'value'); Ok I'll try that. 
&gt; You don't really need a function for such a common operation: Not true. I'm using this on at least 8 different hashes, and there might be more added as the project progresses. So, this function must work with any and all hashes I might use it for. And I prefer to make a common thing like this a function to make it more modular. If I use your way, and i have to change each time I do that, or add lines to it, I'd have to change it in 30+ different places, each time requirements change. That's a lot of extra work. So I make this a function. And if my requirements change, I change one function. 
Cheers, I'll give this a shot!
Since you don't want to use the idiomatic way that [tipdbmp][1] suggested, let's get stupid with it (tested on perl 5.8.5): DefHash.pm: package DefHash; use strict; use warnings; use Tie::Hash; use base 'Tie::StdHash'; sub FETCH { my ($self, $key) = @_; return exists $self-&gt;{$key} ? $self-&gt;{$key} : "Unk: $key"; } 1; test.pl: #!/usr/bin/env perl use strict; use warnings; use DefHash; my %hash = (); tie %hash, 'DefHash'; $hash{foo} = 'bar'; print $hash{foo}, "\n"; print $hash{q{I don't exist}}, "\n"; If you want the "Unk" text to be configurable, define `TIEHASH` to accept a parameter and pass it in the `tie %hash` line. Note that almost all of this is boilerplate and it's still of comparable size to your `gethash` function. You may want to check out `perldoc -f caller`, as well. That way you can avoid hard-coding the subroutine name in your subroutine. [1]: http://www.reddit.com/r/perl/comments/23chie/passing_hash_to_subroutine_along_with_key_as_2nd/cgvnozp
Your code looks OK to me, I think it's the way you are calling it that is the problem, you need to pass a hash REFERENCE not a hash, so you need to call it like this: gethash(\%backtype, 'BLA'); #note the backslash If you passed in a hash rather than a reference, that would explain the error you are seeing.
I've found this page to be a very useful regex reference. http://www.troubleshooters.com/codecorn/littperl/perlreg.htm
Try putting single quotes around your regex patterns in doesNotWork and doesNotWorkEither. EDIT: Tested this on a weather scraper using WWW::Mechanize and storing my regex pattern like you're doing. You need to remove the front and ending / in the variables and enclose them in single quotes. Code: #!/opt/local/bin/perl use WWW::Mechanize; my $tre = 'myforecast-current-lrg\"\&gt;(\d+)'; #Create browser my $mech = WWW::Mechanize-&gt;new(); my $url = "http://www.noaa.gov/"; #get NOAA $mech-&gt;get($url); die "URL failed: $!" unless($mech-&gt;success); #lookup search form $mech-&gt;form_id('localWeather'); die "Form failed: $!" unless($mech-&gt;success); #lookup search field $mech-&gt;field('inputstring','30044'); die "Field Failed: $!" unless($mech-&gt;success); $mech-&gt;submit(); die "Submit failed: $!" unless($mech-&gt;success); #put response into a variable my $c = $mech-&gt;content(); #get cloud condition and don't be greedy my $condition = $1 if $c =~ /\&lt;p class\=\"myforecast-current\"\&gt;(.*?)\&lt;\/p\&gt;/; #get temp #my $temp = $1 if $c =~ /myforecast-current-lrg\"\&gt;(\d+)/; my $temp = $1 if $c =~ /$tre/; print "$condition $temp\n"; EDIT 2: To explain a little on what's wrong with the code take a look at the regex pattern being stored and then when you're trying to match the pattern later in the code. Your $re = /^Traceback .+?^\S+.+?$/sm; Later on when you try and match this pattern it's being implemented like this //^Traceback .+?^\S+.+?$/sm;/ Simply remove the leading and ending / from your $re and enclose the pattern in single quotes. Personally, I like sub works better. One line of code versus two. I also like to comment a lot. If I come back to something later that I haven't looked at in a while I can get lost without my comments. I strongly encourage you to practice commenting your code :) 
Here! Here!
If you write my $re = /.../; ...that tries to match the regex against `$_` and stores the result in `$re`. To store the regex for later, rather than running it now, you need to use: my $re = qr/.../; 
Damn. Bitten by the syntax. Thanks, this makes sense.
Single quotes works just as well. Programmer preference I suppose.
They don't work just as well, they work differently. `qr//` compiles the regex now, resulting in a regex object; single quotes give you just a plain string. And single quotes don't let you do things like specify the flags, although you could work around that by writing it as `(?sm:...)`, but that's rather clunky.
qr is better for this example because it requires less code changes to implement. My example works just as well if the changes are made. The great thing about perl is that there's more than one way to do something. Programmer preference. 
I haven't got a source for this handy, but I think Perl is able to be smarter than that. That is, if it compiles a regex, and it later sees the same one, it'll reuse that. A quick look at the docs for qr// didn't mention that, I have no idea where I did see it (or if I made it up.)
I looked and couldn't find it either. It'll be interesting to know. I think it's great that there are so many ways to do something. I usually run my code prefixed with time to see what's faster and monitor top to see what's the best option. This was a good exchange. If you find your example, please post because I'm interested to know the difference. 
If you're interested in profiling (and it's worthwhile, believe me), seriously look into NYTProf. It's pretty great.
Oh my god, what is wrong with that singer? She tries WAAAAY too hard. Relax and let the song speak for itself!
He says he understands the jists of s// duh! In all seriousness though, I don't know how someone who claims to know anything about a function who's entire purpose is to pattern match ... not know how to use it to pattern match.
In Perl, the most-correct answer is probably: use Date::Parse; print scalar localtime str2time($ARGV[0]); where: * *use Date::Parse* imports the standard Date::Parse module * *$ARGV[0]* is the first element of @ARGV which is the special Perl variable that holds the script's command-line arguments * *str2time* is a function imported by the Date::Parse module that parses common date formats into the numeric date used by Perl * *localtime* is a built-in Perl function that, when passed a numeric date in scalar context, will print a formatted date * *scalar* is a built-in Perl function that puts its argument in scalar context
If you're allowed third party libraries: https://metacpan.org/pod/DateTime::Format::Natural 
The trick is to start small and build up your program little by little. Start with a program that displays the date. Don't worry about all the different formats right away. Progress to displaying the date in some different format, still not worrying about the letting someone choose a format. And so on. Each step you get a little closer. Oh, we're all too stupid for programming. :)
Just patched some existing Python plugins to do what I want. So you're saying you can write Sublime plugins in Perl? How ?
How generalized is its implementation? Will it parse just about anything?
Don't store regexes in variables. Instead store their STRINGS in a variable and use those strings. Instead of my $regex = /^Traceback .+?^\S+.+?$/; use my $regex = 'Traceback .+?^\S+.+?$'; if( m/$regex/ ) { ... } Captures work fine from inside the variable, but switches for the regex operator will have to be managed in parallel to the string-regexes non-parametrically. This is inconvenient, but can be done. If there is a parametric way to do it, I'd like to know. my $regex1 = 'Traceback1 .+?^\S+.+?$'; ### with m//sm my $regex2 = 'Traceback2 .+?^\S+.+?$'; ### without for my $line ( @YOURDATA ) { for my $regex ( $regex1, $regex2 ) { if( $regex eq $regex1 ) { if( $line =~ m/$regex/sm ) { ... } } elsif( $regex eq $regex2 ) { if( $line =~ m/$regex/ ) { ... } } } } In any case, this should help you get the regex bits parameterized. TL;DR: the operator m// cannot simply be stored in a variable. EDIT: see /u/Rhomboid's response. qr// is probably The Way.
Nice.
Does qr// compile the switches in?
one problem with your code is that you are skipping each file with next if ($file =~ m/./); # should be m/^\./ probably also you should really use strict; in all of your perl code, that would point out the other mistake of using the wrong sigil on creation_date (you are saving the result of grep in an array @creation_date but reading from a non-existant scalar $creation_date below) also i would recommend using 3-arg open and named filehandles on open and readdir (perldoc -f open, perldoc -f readdir, perldoc strict) and either get a copy of the [modern perl book or the free pdf version](http://www.modernperlbooks.com/mt/2014/04/modern-perl-2014-edition-is-out.html)
http://pastebin.com/8fWMnMmx Thanks!
it is already: m/^\./. I think it was formatted badly above. I'm going repaste into pastebin.
http://pastebin.com/w21ELNLC
Thanks. I fixed it. &gt; @creation_date but reading from a non-existant scalar $creation_date below This did the trick.
yes, but you can actually avoid copying the result into a variable by just printing lines that match your desired result, like while (&lt;$fh&gt;) { print "$file: $_\n" if /creation_date/; }
Yes, the state of the switches is stored in the regex object. If you stringify the resulting regex object, you'll see them encoded. (The exact way depends on the version, as there have been a few changes as to how that works in the last few major releases, but it will probably be something like `(?^ms:foo)` if you originally had written `qr/foo/sm`.) 
I'm only printing for testing purpose to see what the code is doing. I want to store them in variables because I have to eventually export the data to a csv in a specific order. Would it be possible to put the first word into the first slow and so on?
I ended up doing it like this:@creation_date = split(' ', $creation_date[0]); Thanks for the help!
 while (@list_config = &lt;FILE&gt;) { It's pointless to put this in a loop, because `@list_config = &lt;FILE&gt;` already reads all of the file into the array. It's not hurting anything, there's just no reason to do it. `@creation_date` and `$creation_date` are completely different variables; one is an array, the other a scalar. 
This is an impossible task. What date is meant by 07/09/2014? You can't know the answer without making assumptions based on the nationality of the source that created that data. For most of the world, it means 7th September 2014. But in the US it will be misunderstood to mean 9th July.
 use strict; use warnings; my @dates = ("OCT 08", "APR 07", "DEC 14", "MAY 08", "DEC 12"); print "$_\n" for sort date_sort @dates; sub date_sort { my %months; @months{ qw&lt;JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC&gt; } = 1..12; # may want to pick 'better' variable names my @a = split ' ', $a; my @b = split ' ', $b; $months{ $a[0] } &lt;=&gt; $months{ $b[0] } || $a[1] &lt;=&gt; $b[1] }
Handling dates by hand is rarely a good idea; there are *tons* of little traps. Try `DateTime-&gt;compare`.
I just noticed rx// returns a list in the first place! So you want to be using a prefix and grep if you want to do everything in one go. I would just do this as two lines and everything is fine... my @passwd_lines = qx(ssh -p $serverlist[$i]{'port'} $options_hash{'username'}\@$serverlist[$i]{'hostname'} "cat $options_hash{'passwd_path'};"); my @group_lines = qx(ssh -p $serverlist[$i]{'port'} $options_hash{'username'}\@$serverlist[$i]{'hostname'} "cat $options_hash{'group_path'};");
Yeah, It is actually already in a subroutine like that. I just left it out so I wouldn't become a distraction. Thanks though /u/Ultimatto.
A trick I've used is to assume 00:00 for the time on that date. use the correct year (ok to assume current?) and use Time::Local to turn the day/month/hours/minutes/seconds/year into a unix timestamp, then just compare the timestamps. Also, DateTime-&gt;compare as was mentioned earlier would work as well (and likely better) 
Well the examples he gave are all mm/dd/yy(yy) because 17 can't be a month. So hopefully it follows that, otherwise it's impossible to know.
It'll do its best: [Date::Parse](http://search.cpan.org/~gbarr/TimeDate-2.30/lib/Date/Parse.pm#EXAMPLE_DATES)
Nice. Dwarfs my little effort above.
Gateway seems busy, I'll have to check this out later.
You can use '()' inside a ternary to have one of the results be empty. return ... ? () : ...; $ perl -MData::Dumper -e 'sub x { return $_[0] ? 1 : () }; print Dumper( $_, [x($_)] ) for 0, 1' $VAR1 = 0; $VAR2 = []; $VAR1 = 1; $VAR2 = [ 1 ]; 
Ah, thanks! I had forgotten about this. Done it with map/grep a few times. It does appear to work the same way, returning an empty list or undef scalar.
My take is that any logic of a complexity to return something should not be done with ternary. Use ternary to set a return variable or something, but otherwise it's just bad practice.
In this case, I would agree with Ultimatto and split it into two calls. But for completeness, what you usually use to split an array in two based on a line separator is use the flip-flop operator (..). my (@file_one, @file_two); while(&lt;IN&gt;) { if (1 .. /$file_separator/) { push @file_one; } else { push @file_two; } } The if condition basically starts out as being true (A single integer gets compared to the value of $. which is the current line number of the file being processed, hence we start adding to file one at line 1), until it finds a line that matches $file_separator which is when it becomes false. Look at the perlop docs under 'Range Operator' or search for flip-flop for more info.
Does handleError detect Errors in $obj? And you only return the content if there are no errors?
I changed the template yesterday, before publishing the article and I wasn't sure how it will look. I added a syntax highlighter library now but it still doesn't show it right - I replaced the code with a gist, it looks better now.
[PDF::Create](http://search.cpan.org/~szabgab/PDF-Create-1.08/lib/PDF/Create.pm) supports font sizes, colours and bold. It seems there are only few fonts (the "standard" ones?) available, though.
You can execute a command-line in Perl in various ways, for that task [system](http://metacpan.org/pod/distribution/perl/pod/perlfunc.pod#system-PROGRAM-LIST) would be appropriate, e.g. system( 'pdfcreatecommand', '-c', 'args' ) For an explanation of the various ways of executing commands see [here](http://stackoverflow.com/questions/799968/whats-the-difference-between-perls-backticks-system-and-exec) If you want to use a Perl module you'll probably want to use [PDF::API2](http://metacpan.org/pod/PDF::API2) 
Interesting... It must be printing some sub return at the end though, because even the simple example outputs "Hello World1". Have to put a return; at the end of your code to avoid it.
Yeah, that is what it's doing.
 my $sth = $dbh-&gt;prepare("select * from vCountryStatus"); $sth-&gt;execute; my $row = $sth-&gt;fetchrow_hashref(); my %hash = %$row; or http://stackoverflow.com/questions/3573370/perl-dbi-fetchall-hashref my $sth = $dbh-&gt;prepare("select * from vCountryStatus"); $sth-&gt;execute; my $ref = $sth-&gt;fetchall_hashref('countryiso'); my %hash = %$ref; This "should" work as well to make the last 2 lines 1 :) my $sth = $dbh-&gt;prepare("select * from vCountryStatus"); $sth-&gt;execute; my %hash = %{ $sth-&gt;fetchall_hashref('countryiso') }; 
Maybe this ... my $hashref = $dbh-&gt;selectall_hashref('select col1, col2 from table', 'col1'); my %hash = map { $_ =&gt; $hashref-&gt;{$_}-&gt;{'col2'} } keys %$hashref; 
Something like the following should work. It will set the first found, if any of the rev numbers. You'll need to tweak the \d+ bit if rev can contain non-digits. my $rev; if ( $contents =~ m{Last \s Changed \s Rev: \s+ (\d+)}xms ) { $rev = $1; }
that worked real slick, thank you !
I think you want this... my %hash = map {$_-&gt;[0]=&gt;$_-&gt;[1]} @{$dbh-&gt;selectall_arrayref("select col1,col2 from table")}; 
It says : &gt;&gt;decline include its uncommon syntax and fewer possibilities for a &gt;&gt;developer to foul up when using the other languages in other words languages that oppress creativity, unlike Perl's essence ..............
Yes, you are right. I noticed that, but thanks for noting.
&gt; in other words languages that oppress creativity There are many things to complain about in this article, but that's not an interesting complaint. It would be more interesting to focus on Jansen's assertion that Perl doesn't have web frameworks. Then again, Jansen is the managing director at Tiobe, so we can assume he doesn't know how to use a search engine.
Did you test this? I like this answer. 
Yeah just open it once for reading and then again for writing...
Yeah, it works. Look at the answer from /u/JohnStow though, his has the same result, but he went directly from an array returned from DBI instead of going to a hashref first. Alternatively, if the data doesn't need to be in exactly that format you can skip the map altogether and access with something like $hashref-&gt;{$some_col1_value}-&gt;{'col2'} ... which would be better if you have more than one column you're interested in in the output.