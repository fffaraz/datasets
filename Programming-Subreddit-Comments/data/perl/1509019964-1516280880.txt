Perl 5.6 I guess, nobody calls Java 1.4 "Java 4", the renumbering started at 5 if I remember well 
If `can't` should remain `can't`, what should happen to `"I call him a 'traitor'."` ?
&gt; $myBigHash{$word}{index}; $myBigHash{$word}-&gt;{index};
A few more questions, if it's not too late. * IT has "forever" been a field that has attracted introverts, but with the increasing relevancy of Open Source, it's been clear that also extroverts are needed to create successful projects. Do you have any thoughts about these two "worlds" within Open Source, and what are your opinions on "the state of intro- and extroversion in FLOSS"? * Perl 6's logo is famous for being almost "infantile", and one of it's stated goals is "to make Perl 6 more attractive to young girls". A fine goal in itself, but perhaps not enough on it's own? What other efforts do you think would be beneficial to do in order to attract a younger crowd (both female and male) to the Perl 6 community?
`Whatever` would fit, ha
What kind of 'garbage'? That should work IFF $word exists in your data. Better to say: exists $myBigHash{$word} ? print qq($myBigHash{$word}{index}\n) : print qq($word not found\n);
What do the 'non-words' look like? Numbers? If so instead of keeping the words, chuck the numbers. use Regexp::Common; ... $contents =~ s/$RE{num}//g; See http://search.cpan.org/~abigail/Regexp-Common-2017060201/lib/Regexp/Common.pm You should not be writing common expressions yourself this far into the 21st century.
Just reading [What's new in Python 3.0](https://docs.python.org/3/whatsnew/3.0.html) makes me think, All that extra white space must have done horrible things to these folks' brains. Then again, what kind of person uses a language named after a snake (involuntary shudder)?
Perhaps parallel processing? http://search.cpan.org/~dlux/Parallel-ForkManager-0.7.5/ForkManager.pm 
can't see any obvious places to improve, but you might want to use Devel::NYTProf to profile your code and see where improvements can be made what does "SLOW" mean in minutes ? the format is not complex and a few million entries should not be very slow (at least by my reckoning of "slow") unless Net::LDAP::LDIF is not very efficient, in which case Devel::NYTProf will help you score some points improving it :)
Can we change that? Can we toss the... six heads, les t√™tes hexagones, Division Six?
I would start by commenting out various parts and timing it to see where your slowdown is - using Devel::NYTProf is useful but sometimes overwhelming. Start by having nothing but your loop that reads the records and does nothing with them - time that. If your slowdown is there then you need to figure out a faster way to read in the records. If not - maybe it's get the get_value(). Could this be done with a thread::queue and multiple workers?
I shouldn't be smiling about the hatred for Division Six. It's uncivil, blah blah blah. Nevertheless, I'm happy not to be alone. I feel like the Six Pack are gaslighting us old school Perl Mongers. Some folks want to convince everyone that a completely different language is the next iteration and that it will wipe away more than two decades of (admittedly write-only) scripts.
I... just don't know anymore!
Wouldn't it be a bit lonely without *les t√™tes hexagones*? üòõ
Depending on what i wanted to do with the words, i might make a regex to extract them all into an array (or hash, if say i wanted a histogram or something) Once they are in an array you can just join them back together if you want that representation. It is however less efficient if you just need a big string Removing the 'non words' from a string is possible with a complex enough regex (even removing single quotes around words, but leaving the appsrophes) however matching "all the words" is a simpler and more expressive regex, and only less efficient if you don't need or want the intervening data structure. My first question is "what do you want the words for, ultimately" as that changes what you should do. 
&gt; Some folks want to convince everyone [...] is the next iteration Who is doing that? Considering that isn't the official position, I'd think such an attempt to convince would be rather unconvincing. 
hey quick question, what if the numbers are decimals? \d wouldnt work and \S (for example use it instead of \d in order to match an entire decimal number with the dot) would match the POLYGON instead. What to do in this case? 
This makes no difference. Arrows between braces are ignored. https://metacpan.org/pod/perlreftut#Arrow-Rule
That's kind of over-complicating things. A simple ([0-9].) will match digits and decimal points, so .. my $poly = q|POLYGON 45.10 32.20 33.30 54.40 55.60 66.70|; $poly =~ s/([0-9.]+) ([0-9.]+)/($1 + 10.10).' '.($2 + 20.20)/eg; print $poly; POLYGON 55.2 52.4 43.4 74.6 65.7 86.9 If you want to format the shifted values to e.g., 2 decimal places .. my $poly = q|POLYGON 45.10 32.20 33.30 54.40 55.60 66.70|; $poly =~ s/([0-9.]+) ([0-9.]+)/sprintf('%.2f', ($1 + 11.11)).' '.sprintf('%.2f', ($2 + 22.22))/eg; print $poly; POLYGON 56.21 54.42 44.41 76.62 66.71 88.92 
https://metacpan.org/pod/MCE::Loop, was looking into parallel processing and this was a great module, took a 30-minute indexing process to be only 2-5 minutes. 
Until we have further clarification on what you consider "words" for this purpose (it has a specific definition in regexes which you don't seem to be using here), here's another option that might fit your intention (or could be adjusted to): remove full sequences of non-space characters that contain no letters. $contents =~ s/(?&lt;!\S)[^\sa-zA-Z]++(?!\S)//g; The lookbehind and lookahead ensure that it is bounded by either space characters or the beginning/end of the string. Then it matches any sequence of characters that are not space characters or letters. The extra `+` prevents backtracking so that it only matches if the full sequence is non-letters and doesn't try backtracking to match part of the sequence.
Is $local_file really local, and not over a network share? How big is it? How long does it take to gun zip from the command line? Is it large enough to fill memory and cause swapping? Sometimes the problem has nothing to do with Perl but is with external factors, other times it's Perl. Best to exclude other factors up front if simple.
Title does not say it all, what exactly do you expect the game to do. Once you can derive the question you can find the answer. 
What is an ASCII game?
That would be a console-based graphics game. I assume similar to ncurses, where windows are drawn using text characters.
Do you mean sources as in Perl? If you know C, you could try to seek inspiration from Linux console games. There should be quite a few. Though, it depends on what kind of game you have in mind
&gt; Who is doing that? Indeed what kind of person would do that?! https://twitter.com/ribasushi/status/765500776034758656 / https://www.reddit.com/r/perl/comments/4upqk8/whats_up_perl/d6jj2lr/?context=1 /cc u/psydetonne u/GiveIt10Years
You can try looking at the source code of some of the existing games: * [Games::2048](https://metacpan.org/pod/Games::2048) * [Games::Sudoku::CLI](https://metacpan.org/pod/Games::Sudoku::CLI) * [Games::Hangman](https://metacpan.org/pod/Games::Hangman) * [Games::Word::Guess](https://metacpan.org/pod/Games::Word::Guess) * [Games::ArrangeNumber](https://metacpan.org/pod/Games::ArrangeNumber) 
Try building something with https://metacpan.org/pod/Tickit - do you have any more details about what type of game?
this would work: if ( exists $myArray-&gt;[0]{$word} ) { ... }
 for my $hash_ref ( @myArray ){ if( exists $hash_ref-&gt;{word} ){ ..... } }
Yup snakes and ladders is the game im trying to create
thanks ill check em out
$local_file is truly local - earlier in the script it polls a bunch of servers and copies the latest one over. The entire decide/copy/gunzip process takes about 40 seconds, so on a 35 minute job, that ain't the problem here. Definitely not memory filling and swapping either - stats show that we have tons of available RAM and no paging out at all. 
Metaspan has a newer version https://metacpan.org/release/Parallel-ForkManager
I fail to see where it's suggested Perl 6 is the next iteration of the language in those links; in fact the opposite is stated.
I kind of fancy using Keyword::Declare / PPR to make an `elsunless` control flow keyword just to maximise the idiocy.. 
What module do you most regret uploading to the CPAN?
I love Devel::MAT. So powerful and under-documented it warms my jaded perl developer's heart.
No. It's just the same as "Perl 6" -- it conveys the concept of being "the new version of Perl, superseding Perl 5". Which it's not. Also, the blogger is wrong -- Perl++ is definitely not easy to pronounce. I mean how do you pronounce ++? "Plusplus"? Ugly, in that case. "Inc"? Sounds like a company. "Increment"? Please. 
Such a nuanced view of the matter that fairly assesses the strengths and shortcomings of the language and brings a lot of value to the discussion. Well done!
Sometimes you need an older version......
Yup, as noted in the second line of the post: "Sometimes you might want your old releases to stay available".
I tried the various scripts for deleting the old versions, and the D.A. Golden one worked best for me. I only had three old things to remove, but somehow I'm 1480 on the list, so it looks like most people aren't really keeping old stuff much. 
You can obtain old versions from [backpan](http://backpan.perl.org/) if you really need them. 
It's a bit misleading to say "lists are different from arrays" because @arr x 10 and (@arr)x10 operate differently. This is actually a special case in the Perl language, in that the repetition operator is one of the few times parentheses have a significance aside from precedence. In the first case the array is put in scalar context, and in the second in list context. You will not have parentheses to have that effect anywhere else except for the other main exception: list assignment.
I tried turning on these modes and I got indentation like this: ``` sub foo { if (bar) { | } } ``` Are you using `perl-mode` or `cperl-mode`? 
`perl-mode`, as I mentioned. I see the indentation you describe in `cperl-mode`.
Just dump it into a text file with something like ldapsearch or ldifde and parse that with perl.
Things like this were solved in Perl6. There the string repetition operator is `x` and the list repetition operator is `xx`. One of the main advantages of Perl6 is not having to remember all of the special cases Perl has. $ perl6 -e 'my @arr = &lt;a b c&gt;; say @arr x 10' a b ca b ca b ca b ca b ca b ca b ca b ca b ca b c $ perl6 -e 'my @arr = &lt;a b c&gt;; say @arr xx 10' ([a b c] [a b c] [a b c] [a b c] [a b c] [a b c] [a b c] [a b c] [a b c] [a b c])
That's a better implementation for sure. It doesn't cast to numeric though; it's just that arrays in scalar context are their size. You could make it stringify the array too: my @arr = qw(a b c); say "@arr"x5
I know how contexts work in Perl5, but I was using the term used in Perl6. Perl6 will only transform an array or list into it's number of elements when casting to numeric.
I'm sure I've missed a bit here, but why would you have several different Apache instances? Apache can do name-based virtualhosting, and can do privilege separation with mod-itk (or suexec). 
Apologies, I've edited my post 
Maybe you are thinking of Lang5, a stack-based array language described as a combination of Forth and APL which is written in Perl 5. http://lang5.sourceforge.net/tiki-index.php
I know that cperl-mode has lots of bugs, but I thought it was generally supposed to have fewer bugs than perl-mode. I've been using cperl-mode for years now. 
Never heard of the company Activestate... then again, I've only be using Perl for about twenty years and primarily on FreeBSD. Just getting into MOO, now that's cool. How about some interesting links for us to read up on that module!?
Thanks for the heads-up Grinnz - article updated!
Seems like a pretty straight-forward case for a split. Why did you use it like a stack?
The question was recently answered on emacs.stackexchange.com. In a nutshell, it's a bug in perl-mode that I fixed like so: (with-eval-after-load "perl-mode" (defun perl-electric-noindent-p (_char) (unless (or (bolp) (eolp)) 'no-indent))) 
Neat :)
[Moo's documentation](https://metacpan.org/pod/Moose::Manual) mostly assumes you're already familiar with Moose, so it's still best to start with the [Moose::Manual](https://metacpan.org/pod/Moose::Manual), ignore the MOP, and use Type::Tiny for types. But improving Moo's documentation so it can stand on its own is a nice goal.
&gt; Trying to parse IPv6 instead of reaching for CPAN. Why?
Having read all those, I now know less Perl than I did ten minutes ago.
The reason Moo and Moose require default values (specifically, default values that are references) to be initialised with a subroutine wrapper around them is because otherwise the one array reference in the definition gets re-used for every single object instance you make. Having a subroutine that returns the reference to be used for the default value guarantees that you get a *different reference* each time you create an object.
That "study" was awful! He changed the options midway through, added some, removed others, but included everything in the final tally as though it was all cool. Yeesh. 
I see, thanks for the feedback. Since I had no clear example on the net I wrote that.
Pretty sure cperl-mode is the way to go, yes, and has been for a looong time. Better feature set, and better maintained.
Yay? We're number 1?
Yes! Nice to see we are the leaders at last!
I may be biased but Perl doesn't even make it on my list. I have a lot more hate for java by far.
I would like to know why also. I mean.. there are times when I also feel I dislike how some things are done in Perl. And that's solely because I'm having a hard time understanding things. Also, and this seems to be a trend that's been growing a few years now.. Why do people hate PHP?
Dear fellow Perl users. Where do you see future of Perl as a programming language? Would you perceive this as a threat to Perl? I am asking from position of new convert, unaware of intricate details as - for example - relationship of P5P to this fund. Awaiting eagerly any comments, regards Jan.
Herd mentality and perception above reality as always rules.
Most of perl5 committers are volunteers, AFAIR only three of them receive grants from TPF. Obviously, lack of funding would slow down development of Perl, but certainly it wouldn't kill it.
I do suggest letting Devel::NYTProf run for a bit then, perhaps on a truncated version of the file if that's easy to generate, as it will be much slower. If you want to check some specific things prior to that, adding in some output after reading in the LDIF file but prior to the looping might indicate if the problem is the initial parsing or that actual looping process. If it is in the looping process and isn't something in getting the initial LDIF record, I guess it's *possible* the localtime and/or the strftime calls could be the bottleneck if the number of entries is *very* high. If there's any sort of duplication to the timestamps, using memoization (which you can plug in through https://metacpan.org/pod/Memoize or do yourself with a few lines or perl) might help immensely. How many records are we talking about here? How large is the LDIF file being processed?
I think this is based on user data entered; those with zero results not displayed and, presumably, the user data was not confined to his choices only. I still think the information is telling. It would be interesting I think to compare with studies from non Perl websites...e.g "Python Maven" or similar. 
Well. Perl has been around for a while, and I think we have all seen some pretty shitty perl at some point in the last 20 years. (Some of it my own). But yeah, it's cool to hate on Perl. Most of the bad code examples I have seen are due to regex more than perl. But "fixing" regex is virtually impossible - you couldn't without also removing it's value.
PHP duplicates all of Perl's old mistakes, and then adds a bunch of its own.
There are lots of ways to represent a finite state machine, especially if you're not stuck on using text for everything. There's just no serious attempt to do so in any language.
totally irrelevant to the point of this article, but... &gt; It is intended to be √¢‚Ç¨≈ìused for the maintenance and improvement of the Perl 5 core.√¢‚Ç¨¬ù if we can't get quote characters right in an official Perl foundation post, it's perhaps not the best advert for the language!
Note that the topic of the newspost is specifically the *Perl 5 core dev fund*, with the moneys pre-ear-marked for Perl 5 core dev. TPF also has a general fund. And yes, as some already mentioned, a lot of the work is done by volunteers too.
Yep. But could you so in a way that was as concise, and thus as well suited for inline transformations in code. Without recreating regex of course. 
Yey! We're winning! But in seriousness, this dataset is what people put on their CV as tech they don't wanna work with, which isn't a bad way to eliminate all those companies who want you to work with their Perl CGI scripts from the '90s. If you don't like that work, you certainly won't be putting Rust in that field.
Well, it's biased. The only people that use that site are the ones who don't know how to do their jobs... Ok, well that's a hyperbolic joke, but what we are looking at here is a sample of the most hardcore SO users, who trend massively to Java and JS. You can literally see the bias at the right side on axis in the second diagram. Of course java ninnies who have to go to SO a hundred times a day don't like perl. Of course SO, a platform that brings the mantra "there is only one correct answer/way" to a high art, isn't going to like Perl... which thrives on the mantra of "there's more than one way to do it". 
Thanks for this work, I'm looking forward to it. Thanks also to Booking.com for sponsoring the work. 
My own most disliked programming language is JavaScript rather than Perl. It's also interesting that Bash is much less disliked than Perl, coming almost at the bottom of the list, but Bash has a very difficult syntax to master compared to Perl. Edit: comment on Bash. 
R , my god, where nothing works and the error messages dont help
what a great news! thank you for your work
As people in the article comments have suggested, you can use a "native traits" module. Also look into modules under the `MooX` namespace, which provide extensions for Moo. The base [MooX](https://metacpan.org/pod/MooX) module can then import these. The `MooX::HandlesVia` provides native-trait-like functionality. In the following example, you would need to have installed `Moo`, `MooX`, `MooX::HandlesVia`, `MooX::LvalueAttribute`, but once you do, you can import everything in one line. package Thingy { use MooX qw( HandlesVia LvalueAttribute ); has 'things' =&gt; ( required =&gt; 1, is =&gt; 'rw', lvalue =&gt; 1 handles_via =&gt; 'Array', handles =&gt; { push_things =&gt; 'push', list_things =&gt; 'elements', }, ); } # Initialize with ArrayRef (or in this case, anonymous ArrayRef) my $t = Thingy-&gt;new( things =&gt; [qw( one two three )] ); # list_things handler can dereference ArrayRef to a list for my $thing ( $t-&gt;list_things ) { say $thing } # Of course the default setter exists... $t-&gt;things( [qw( foo bar baz )] ); say 'things: ' . join( ', ', $t-&gt;list_things ); # things: foo, bar, baz # But lvalue attribute allows you to assign like so $t-&gt;things = [qw( alpha beta gamma )]; say 'things: ' . join( ', ', $t-&gt;list_things ); # things: alpha, beta, gamma # Push things using the push_things handler $t-&gt;push_things( 'delta' ); # Can also push multiple things $t-&gt;push_things( 'epsilon', 'zeta' ); say 'things: ' . join( ', ', $t-&gt;list_things ); # things: alpha, beta, gamma, delta, epsilon, zeta The handlers that `handles_via =&gt; 'Array'` gives you is provided by [Data::Perl::Role::Collection::Array](http://search.cpan.org/~mattp/Data-Perl-0.002009/lib/Data/Perl/Role/Collection/Array.pm)
No need to worry; Perl 6 will be at the bottom of that chart soon enough.
Yeah, you're biased. So am I. I hate Java, but my hatred of Java is probably mostly unjustified, by this time. Most of my hatred of Java was born in the early days of the Internet. Perl had a huge advantage, because it just happened to already be around. It was mature and stable, and therefore it because the workhorse of the Internet. Java was relatively new and there was a lot of attention on it. But we tried it, it was slow, it was a pain in the ass to use (everything's an object? Everything?!?), and if we wanted to run somebody else's Java code, we never seemed to have precisely the right version (or even distribution) of the JRE (or, heaven forbid, the JDK). And then, as if it couldn't get any worse, it was embraced by Corporate America, which make it even more incompatible with our culture. If I really had to learn Java today, I probably wouldn't hate it as much. Well that's not true. Because I would be learning it _because I had to_, not because it was enabling me to do something that I can't already do. And that's why Java people are unlikely to ever try Perl, and Perl people are unlikely to ever try Java. Because neither language really solves any problems that they can't already solve in their own language. So we just go on badmouthing each other, to anyone who will listen.
a couple of counter-examples: * Java solves the "I would like to write a mobile application on Android" problem for Perl users. * Perl solves the "I want a concise one-off text processing command" for Java users. (disclaimer: I use - and like - both languages)
12 hours later we **still** can't get 'em all: &gt; ["I patched Perl\x{9D}"](https://web.archive.org/web/20171101071457/http://news.perlfoundation.org/2017/10/p5cmf-running-out-of-funds.html)
R is a brilliant environment for doing statistics and data visualisation. It's also an absolutely horrible general purpose programming language.
I have a feeling that Perl 6 is mainly disliked by others perl programmers...
I agree. People don‚Äôt like change. Even though Perl 6 is no longer intended to replace Perl 5 I think current Perl 5 users feel threatened by Perl 6 and the immediate reaction is to dislike it. Those who can get over that emotion and actually try out the language will find that it is truly remarkable and thoroughly enjoyable. Perl 6 can deal with all the problems the new languages towards the bottom of that chart are aiming to solve, like concurrency, which is why once it starts getting noticed/used by the larger programming community outside Perl, I think it will be just as liked and trendy and exciting as them.
Nice tip. Thanks for the feedback. For those like me migrating from old fashion OO Perl, having a lot o different modules is kind of new if you need pure Moo module. I will update my post with bringing all these tips.
I've given Perl6 a real go, and I'm still skeptical. In a more mature language, the documentation and implementation can be relied on to be accurate. You assume that if you're running into issues, the bug is in your own understanding, and the right Google search will solve it. Perl6 is not at that point. The docs are hard to navigate and are sometimes wrong. Googling the problem tends to get you blog links from 2014 that you can't be sure are relevant anymore. The debugger is missing some major features (like an equivalent to Perl5's `$DB::single = 1` to set a breakpoint in code, or even descending into calls correctly). It doesn't seem to have been worked on significantly since 2012. I want to like Perl6, but it's been hostile to my efforts so far. I ended up doing a project in Node.js instead.
Wow that's great. That will definitely be a real world improvement!
Yeah, I assumed somebody would crawl out of the bushes to say they use (and like) both languages. Thanks for providing that example. Good point about mobile apps for Android.
and his metric has it as the most liked!!!!
That's ok, not many of us left.
Actually, they did a fair job of fixing the problems with regexs with perl5, I'd say. /x has the potential to make them close to readable. You can even use recursive regexps these days if you *really* want to parse html with it. 
&gt; If I really had to learn Java today, I probably wouldn't hate it as much. I would. Everyone I would be working with would be pressuring me to use Eclipse. 
As a friend of mine puts it, PHP is Perl without the elegance and logical consistency. 
Can someone explain what this is about? I won‚Äôt watch and hour-long video. 
I've been having fun with emacs lisp programming lately myself. It has some of the worst error messages I've ever seen. Consider that this: (message 'hello world') ;; Note, wrong quotes, elisp needs double-quotes Gives you an error message to the effect that there's a problem with a parenthesis, somewhere in a potentially gigantic file of elisp. No line number, no function name, and really the issue is with the quotes, not the parens. 
Yeah, I can't stand Eclipse. Of course, I write all my code in vim. Well, except those rare times when I write C#, because Visual Studio _doesn't_ suck.
[Higher-Order Perl](https://hop.perl.plover.com/book/)
You'll want to study patterns, since you'll be reading and not writing perl. Don't try to become a good (or even adequate) perl programmer, just figure out what patterns they are using and figure out how to condense that into idiomatic python. Don't try and re-write line by line the perl code in python.. Read a lot of projects by good perl programmers on github to figure out how they tackled the problem. You'll see how that differs from the author of your refactoring project's writing style. Try and use the best python patterns when refactoring. https://github.com/trending/perl
Best resource? On Amazon, Perl second hand books are (or used to be) a penny each +delivery. I always keep an eye out for these...so you will have to get there before me. Would you also be able to publish performance differences/code size/etc between the two languages? That would be very interesting.
Thanks for the great suggestions. You sound like an experienced Perl programmer; are there specific patterns or models you like to follow when coding in Perl?
No, I'm sloppy as all heck when writing perl. It's a glue language, and someone used it to write something too big. That happens, requirements change, people add new stuff, but it's the whole project is made of glue now. I don't envy the work you'll be putting in to untangle it.
I was afraid of that :) It's a near certainty the situation I'll be dealing with is what you speak of. From what I understand, the original authors were geniuses in their respective scientific domains, but were definitely not software engineers. 
Stack overflow. Try solving other people's problems, and then look at what the alternative approaches/solutions were. It's like a steady stream of homework problems that represent "real world" scenarios. And you even get feedback on the quality of your answer from upvotes.
I'll commend you guys... Delphi folks are trying to dispute the statistical accuracy of the figures over on Google Plus. :-(
[Modern Perl](http://modernperlbooks.com/) would be what I would recommend for someone getting into coding Perl, but probably won't be as helpful in your situation which is not dealing with that sort of Perl. You will probably run into many strange idioms; I would recommend getting familiar with various technical perldocs like [perlre](https://metacpan.org/pod/perlre), [perlop](https://metacpan.org/pod/perlop), [perldata](https://metacpan.org/pod/perldata), [perlref](https://metacpan.org/pod/perlref), [perlsyn](https://metacpan.org/pod/perlsyn), [perlipc](https://metacpan.org/pod/perlipc), and of course [perlfunc](https://metacpan.org/pod/perlfunc) and [perlvar](https://metacpan.org/pod/perlvar). [perlsecret](https://metacpan.org/pod/perlsecret) is also a helpful list of not-really-operator-patterns that may pop up.
Awesome, thanks for the suggestions!
I don't think you need to understand Perl so much as you need to understand what that Perl code is doing. If I had to do this job, I would not focus on understanding the Perl itself but on creating a set of tests (in Python since you're moving from Perl to Python) which define the outputs that I expect to get given the inputs, then try to replicate those outcomes in Python, rather than worry about exactly what the Perl might be doing. 
This sounds very good in theory, and was my first inclination as well, but the inputs and outputs are extremely large datasets (genomic data) that would be rather difficult to blackbox test, especially around boundary conditions, without knowing what the code is supposed to be doing. My assumption is digging into the legacy codebase will be an inevitable eventuality. 
It probably also uses a lot of CPAN modules, that'll provide additional hurdle when porting to python.
I'm sure you will have to understand the code, but I would start from the specifics of what the precise code you have is doing rather than learning general things about Perl, since the basic idea seems to be to discard Perl and move to Python. Perl is somewhat like C++ in that it's a very large language and there are many parts of it which a lot of people disdain. I personally do not ever use operator overloading, or look ahead regular expressions in Perl, for example, and I'd have to look in the documentation to even remember the syntax for them. Your coders may not even have used many of the features of Perl, so learning a lot of general features of Perl and reading documents like perlre seems counterproductive. The suggestions on this thread don't seem to quite match your problem, for example the books Modern Perl and Higher Order Perl are for people who want to write good Perl code today, avoiding all the legacy nonsense, whereas you really want to get tools for understanding legacy code bases. 
It's unlikely that the legacy code base uses the methods in this book. While this book may be useful in some circumstances, I don7t think it's a valid suggestion for how to solve the OP's problem of understanding a legacy code base in order to translate it into Python. 
Given that you are talking about "refactor legacy Perl code to Python", I think you need resource in below directions: 1. Resources that would explain you things that are special in Perl and rarely seen elsewhere, like the "context" thing. For this purpose I think the "Modern Perl" book is fine, although some other books can also be good. 2. A reference book like "Programming Perl". Although most of its contents are available online in the form of various Perl docs, the book compiles them together and is good for a skim. 3. The "Perl Best Practices" book discusses a lot Perl coding practices. In some sense it's like PEP8 of Python. In the book you see how normally people write their Perl code for various tasks. (The book is &gt;10 years old, a small portion of what it recommends has become outdated today, and some could be debatable even 10 years ago, but that does not matter at all if you don't write a lot new Perl. ) And you actually can learn Perl by comparing it with Python (assuming you're familiar with Python). To me the two languages are like &gt;95% same, and most things in the Python language can directly map to equivalents in Perl. You can focus on the similarities and differences between the two languages. Actually that was how I learned Python. And I sometimes think the Perl community can write something called "Perl for Python programmers", advertising places where Perl's better than Python, to attract people from Python. LBNL it's sad to see people refactoring legacy Perl code to Python. Except that you get easier to hire people for Python today, IMO you probably will not get much out of this kind of refactoring, given that the two languages are so much alike. It is really easy to evolve your Perl code over a long term, as you can always seamlessly replace part of it with new designs/implementations with the rest part still functions well even if they were &gt;15 years old. And in this way you can continuously evolve a huge Perl code base, this reminds me of the Ship of Theseus. Also compared to Python, it's actually (generically although slightly) easier to achieve a high level of robustness for your Perl code. Unfortunately many people don't understand this, but I am saying it as someone used both Perl/Python for years (although I am on a Perl job).
&gt; functional understanding I think you're good to need a bit more than that. Good luck to you! What's the scale of the project? How many programs / lines of code? 
&gt; The docs are hard to navigate Would you be able to elaborate on that point and maybe provide some examples of what was hard to find/navigate? The docs site will see a redesign in a few months, so it'd be helpful to have this sort of feedback.
One thing I hit a lot is that the information I actually needed was spread over several documents, and it wasn't obvious at first which one I should hit. For example, let's say I'm looking for a specific feature of subroutine signatures. I would probably start with [Functions](https://docs.perl6.org/language/functions). There's a subheading in there for "Signatures", which should be what I want, but it basically redirects you to the [Signatures type](https://docs.perl6.org/type/Signature) docs. This could be personal preference, but it seems odd to me, and creates unnecessary clicking around. I'd expect the Type documentation to be more man page-like, laying out a simple reference of each individual piece of functionality, which is what you get later in the Signatures doc in the "Methods" section. Basically, the entire "Signature Literal" sections should be removed from there and dropped into Functions. There's probably a lot of other cases like that where the specific Type/Object doc contains expository information that should be brought into another document with a broader view. As a more specific case, there doesn't seem to be a documented way to have a function's return type be an Array with the types inside further constrained (array of ints, for example). After some experimenting, I found that it's `--&gt; Array[Int]`, which might be what you expect if you used Moose on Perl5. It's not explicitly laid out anywhere I could find, though.
Thanks! Opened that as [an Issue on our doc repo](https://github.com/perl6/doc/issues/1646) so we don't lose this.
I'm not saying java is garbage. I've done a fair share of it but mostly back around 2002. Also a little playing with android. I just have some tools like Perl that I always seem to gravitate to when I need to do some heavy lifting now or do a proof of concept. I like learning new and old languages. Currently learning 6809 assembly on the tandy color computer for various reasons including boredom.
I find it amusing that I'm actually working with Java files today. First time in years I've run `javac` I guess the gods heard me. The reason I'm doing this is because there's a weird authentication thing I have to do, and they only provide the sample code in Java. So guess what! Today I do Java.
Look for "Perl Medic", by Peter Scott. Ovid's book is worthwhile, and Modern Perl won't hurt, but Peter's book is the right place to start if you're working through an aging codebase.
&gt; but were definitely not software engineers. I have been in your situation several times. Perl is easy enough to get started with, and it doesn't get in the coder's way from getting the job done. So people who are not software engineers can quickly build solutions in Perl. This ability makes Perl sound powerful, but it's a double-edged sword. These coders then think they know a lot about programming and that they are naturally talented, so they continue producing terrible code that gets the job done. As the saying goes, Perl gives you plenty of rope to hang yourself with... There are Perl tools (perltidy, perl-critic, etc) to help make Perl code easier to understand, but these tools are optional. And from my experience, not enough people use them or even know of their existence. Perl gets the job done, and that's *all* these people care about.... The idea of code maintenance and even programming as a craft are secondary. It's sad and frustrating, especially when companies want to continue building products based on ugly code bases. What you can do is walk through the code. Break it apart. Use Data::Dumper to inspect data structures. If the code is convoluted, I would also suggest using perltidy to clean up its appearance. Hope this helps. 
I think Perl6 really made regexes much better. Comparing a random library from P5 cpan (Email::Simple) to a P6 port: Perl5: https://github.com/rjbs/Email-Simple/blob/master/lib/Email/Simple/Header.pm#L59 Perl6: https://github.com/retupmoca/p6-Email-Simple/blob/master/lib/Email/Simple/Header.pm6#L19 I think the P6 version is considerably easier to follow.
There are languages that I avoid because I don't believe in their value proposition. I still see a strong value proposition in Perl. I see the value proposition of Rust too. But for other languages... Java -- I like some features of the language (sockets, threads, GUI toolkit), but the runtime is heavy and a nest of maintainence problems (see C, C++ below). Go -- good at a few important things, but very immature and opinionated. Compiled binary includes the runtime, address space was not ASLR capable until recently, and even now does not support all platforms (yet C libraries can be called from Go). C -- It's a box of razor blades, including memory mismanagement. There are several industries that thrive by trying to protect or injure the hands that reach into the box. C++ -- Like C, but with OOP wankery. OOP has swelled to a decades-long storm of exaggerated "elegance". Python -- I see its strengths, but its instability is a deal-breaker for durable code. R -- outside of data analysis, it's a limited DSL. 
I've said before, there's no universal right language, there's only the language that's most appropriate for your current experience and your current requirements. As much as I hate to say it sometimes that language can even be PHP. But that probably means you need to learn more languages.
I'll also note this work was done by one of the recipients of the [Perl 5 Core Maintenance Fund](http://www.perlfoundation.org/perl_5_core_maintenance_fund); [relevant thread](https://www.reddit.com/r/perl/comments/79wszf/p5cmf_the_perl_5_core_maintenance_fund_running/).
&gt; Those who can get over that emotion and actually try out the language will find that it is truly remarkable and thoroughly enjoyable. I disagree.
http://www.perlmonks.org/
I don't blame, you I was hoping someone else would have summarized it already. Slide at around 7mins: The Perl Paradox No one talks about Perl Everyone depends on Perl Activstate essentially ships and supports a perl "distribution" on windows. They make the point that there's a big disconnect between what perl can do, and what people are doing with it, and the perception. 
Thank you so much! You're the hero I needed, but not the one I deserved. I know about ActiveState because I use ActivePerl. I didn't know what the paradox was about. It really sounds right. 
If I write a program (whether in C or Perl or whatever), how would I know what the configure process is supposed to configure in my program? Once I get my program working on my computer, how am I supposed to know which parts of it might have to change on other platforms -- and who writes the code for those other platforms, and how would I test it? That's what I have never understood about the configure process. Any pointers?
I guess it probably sounds fair, maybe I don't have enough experience with either. I just find the both great, and especially with PHP, easy to work with.
[Module::Runtime](https://metacpan.org/pod/Module::Runtime) allows you to load a variable module name at runtime and does not use string eval, so should always be used instead for this use case. There are one or two legitimate uses of string eval, but they usually do not come up in user code.
No-one has mentioned "Effective Perl Programming". It was reading the first edition of that which opened my eyes to how Perl really worked. The second edition is just as good.
I find it useful. I guess enough people do as well it otherwise they wouldn't upvote it. 
It's one of the reasons I don't get along with Python. You need editor functionality to block indent. Perl I only need perl tidy.
I looked into Python when the Google App Engine first came out. Python was the only supported language at the time. Honestly, I haven't looked at the App Engine in years, so I don't even know how many they support now. I just know everybody and their brother were asking Google to support their own language, which I thought was stupid. It seemed perfectly reasonable to me that they would start with one language, and Python seemed as reasonable a language as any. So, being interested in the App Engine, I started writing Python for the first time. That language's indentation requirements drove me away. It was infuriating. And I've seldom been pack. I've occasionally helped somebody debug their Python code and things like that, but I have never had a desire to sit down and write Python. I keep telling myself I need to get back into it, just because it's so popular. I'll need to be able to know the basics of it at some point.
How come it's `eval $module{ $^O };` not `eval 'use ' . $module{ $^O };`
I think you're probably right without testing it 
You are free to post content you feel is more relevant.
You are right. Fixed it now. Thanks.
Link to it added to the article. Thanks for the suggestion.
This weekly update is so handy. There's pretty much always a module that I use at work on the list, and it's great to see what's changed.
Or Class::Load.
Yes, `@_ == 0` is scalar context, so it's comparing the number of elements in @_ to zero. You're correct in thinking it'd also work for other numbers as well. Note that `$array` and `@array` are completely different variables, so your first example is fine but the second one is unlikely to do much. http://altreus.blogspot.co.uk/2011/06/anatomy-of-types.html might be a useful read if that sounds confusing. Another way to write this: die "Please do not give me any parameters, I have no idea what to do with them" if @_; since the `if()` expression is also scalar context.
You can explicitly ask for scalar context, as you have done with `scalar @array`, but many operations will coerce it's argument to a scalar, particularly numeric operations, so you can do thing like this if ( @array &gt; 2 ) { say "got more than 2 elems" } Also, because `0` is "Falsey", you can do this if ( @array ) { say "array is not empty" }
Class::Load is now just a Module::Runtime wrapper. The similar Module::Load has a basic design issue that leads to this problem: https://rt.cpan.org/Public/Bug/Display.html?id=106128. Therefore I can't recommend either of those.
The equality operator (`==`), like many of Perl's operators, expects scalar values as its two operands. So the expressions on the left and right of the operator are both evaluated in scalar context. That's like having an invisible `scalar` put in front of them. So the code is the equivalent of: scalar @_ == scalar 0 or die; A lot of the time, you don't need an explicit `scalar` in order to impose scalar context on an array. For example, if you want to store the number of elements in a variable, you could use: $number_of_elements = scalar @array; But the fact that you're assigning to a scalar variable means that the expression is already in scalar context and the explicit use of `scalar` is unnecessary. You get exactly the same result from: $number_of_elements = @array;
You seem to have forgotten to tell us what problems you are having. But you don't seem to be doing anything that explicitly accesses the second column in your data. I think you want something like this: #!/usr/bin/perl use strict; use warnings; # prompt user for input file name: print "Enter a file name: "; chomp( my $infile = &lt;ARGV&gt; ); die "File does not exist\n" unless -e $infile; die "Not a regular file\n" unless -f $infile; die "Cannot read file\n" unless -r $file; open( my $fhin, "&lt;", $infile ) or die "Could not open input file '$infile': $!\n"; # Skip header &lt;$fhin&gt;; # Read data chomp(my @lines = &lt;$fhin&gt;); close $fhin; my $observations = 0; my $sum = 0; # No need to iterate twice # A foreach loop is easier to read than a C-style for loop foreach (@lines) { # Simplistic check for data if (/[^\d\.,]/) { warn "File contains invalid data\n"; next; } my @data = split /,/; $observations++; # Sum the second column from the data $sum += $data[1]; } my $mean = 0; $mean = $sum / $observations if $observations; print "Sum: $sum\n"; print "Observations: $observations\n"; print "Mean: $mean\n"; exit;
You have a thumb. Feel free to scroll on by.
Or, an index finger if using a mouse wheel.
[citation needed]
Thank you Reddit! Windoze noob here too forced to use a .pl script instead of a PSH and this helped me figure out why it wasn't running correctly.
How would one use this to archive a thread on reddit? This is something I could use.Thanks
[removed]
Not sure what you mean by archive. You can hide a post with the hide function. Posts are automatically archived after 6 months, but that's not an API action.
Maybe he meens to save it in its entirety locally? Thats what I thought when I read it...
Yes, it's as flamey said. I'd like to go back to my saved links/posts and save a copy of the comments of a self post or a link.
You could get the link and then get the comments underneath it. my $link = $reddit-&gt;get_link('7b7rdl'); my $comments = $link-&gt;comments(); That will give you the comment tree of all the comments.
Thanks, I should have clarified what my problem was, I was having issues with the file not being able to read it.
I had some updates for you. I dunno if you ever mainlined them though. 
25 posts in 2 months...all Perl related and mostly interesting reads. I suggest this positive contribution to a community should be applauded.
Sure!
This looks very nice, might give it a try some day. Thanks!
You would first want to construct your hash so that the keys are what you want to match, and the values are the replacements. Then you need to create a regex that can match any of the keys; [list2re from Data::Munge](https://metacpan.org/pod/Data::Munge#list2re-LIST) is one function to do this easily. Finally you can run (like in that function's example): $documenttext =~ s/($re)/$hash{$1}/g;
Not quite. The problem is that you've shown something like this: %key = ( EnglishSpelling =&gt; q(theatre), AmericanSpelling =&gt; q(theater) ); What you really want is: %e_to_a =&gt; ( theatre =&gt; q(theater), football =&gt; q(soccer), ## :-) etc... ); Then (untested!!!!!): for my $e in (keys %e_to_a) { $documenttext =~ s/\b$e\b/$e_to_a{$e}/g; } The \b is w word boundary so that you match, for example "the theatre down the road" and not "they renamed the street 'TheatreLane'". I don't think you need to respecify the boundaries on the substitution side, but check perl regex docs to be sure.
Unless there's a lot of text, something like this should work: s{\b(\w+)\b}{$american_from_british{$1} // $1}ge; presuming a mapping such as my %american_from_british = ( well =&gt; "good", colour =&gt; "color", ... ); ... but you'd likely want to match case as well. 
One way to write it in P6: my $documenttext = 'theatre colour' ; my %spelling = British =&gt; &lt;theatre colour&gt;, American =&gt; &lt;theater color&gt;; say $documenttext.trans: .&lt;British&gt; =&gt; .&lt;American&gt; given %spelling; 
&gt; the CGI module makes HTML output easy and even pleasant Are you using the HTML generation functions in CGI.pm? We've known what a terrible idea they are since the end of the last millennium. And they are now heavily deprecated (see [the module documentation](https://metacpan.org/pod/distribution/CGI/lib/CGI.pod#HTML-Generation-functions-should-no-longer-be-used)). You should look at using a templating engine instead. [CGI::Alternatives](https://metacpan.org/pod/CGI::Alternatives) has plenty of suggestions for more modern ways to write web applications in Perl.
That is inefficient, because you will spin the loop for each word. You can compile a match regex and just run it once. 
This is why I try very hard to never do time calculations myself, but to always use a library. Specifically, in Perl, that library is nearly always [DateTime](https://metacpan.org/pod/DateTime). Generally, I think the more experience a programmer has with the details of date/time calculations, the more likely they are to feel the same way (to not do it, to use a well-supported library instead).
That's funny. A guy is happy with what he's doing, posts about it in /r/perl, and then the first comment is all about how bad an idea it is :) I'm not even criticizing /u/davorg, because he's not wrong. I just think it's a funny thing, and it's almost unavoidable. There are so many ways to do thing with Perl, that it's pretty unusual to share some technique that you have and _not_ have somebody come along and tell you that you're doing it wrong. Yeah, I would totally tell /u/singe about Template Toolkit, for example, because I like it and I'm used to it. But I took notice that he is getting some value from the HTML-generation functions of CGI.pm. He even said it was pleasant, so it would be really disappointing to have somebody tell you that this thing that is _working for you_ is totally wrong. If I was going to try to steer him away from that, I'd like to believe that I would first try to acknowledge something positive about what he's doing now, and then offer a suggestion to improve upon it. Same result, different tactic. So maybe I *am* criticizing /u/davorg, though his comment was certainly helpful. I'm not trying to be mean-spirited, though, but rather to seek an inclusive and supportive environment.
For work, I'm writing a handful of classes to be used for daemonised processes and cron jobs to export monitoring data to various places (logs, InfluxDB, file on disk, etc).
I agree with both sentiments; the OP would do himself a favor to look into more modern frameworks and techniques, and the alternatives could be presented in a better way.
Hi, friend. I want to thank you. One of the `unpleasant` things about posting in r/perl is that there is a tendency to rip people. Sure, nothing is stopping me from quitting r/perl. But I like Perl and I use Perl every day. I know that CGI.pm is old and unwanted. But it's part of system Perl in Debian 9 and also on my embedded systems. I find CGI.pm easy to use for this project. The fact that it is old doesn't bother me. I will take a look at our other friend's suggestion and I thank him for it. 
Nothing in perl, but I've been playing with scheme a lot lately. Perl is a scheme with syntax, right? 
When iterating the data, you are explicitly specifying to index through the number of elements in the array, but the first thing you do is shift the first element off the array (according to the test on @lines[0]), then look at the second element (@lines[1]) which is what used to be the third line. Altering an array whilst iterating over it can lead to some odd results. If you want to just remove the header line you should do the shift before the loop. In this case @lines is an array of lines from the original file, so $lines[$i] refers to an entire line, not an element within that line. So as /davorg has coded, you then need to split the lines into their elements and then process those elements. 
Why does &lt;$fhin&gt; skip header?
Working on reviving the [Net::Heroku](https://metacpan.org/pod/Net::Heroku) module: https://github.com/rage311/net-heroku (my fork) and the [Mojolicious::Command::deploy::heroku](https://metacpan.org/pod/Mojolicious::Command::deploy::heroku) module: https://github.com/rage311/mojolicious-command-deploy-heroku (my fork) They're outdated and broken on CPAN currently -- using a deprecated (and no longer functioning) Heroku API, as well as some-years-old versions of Mojolicious, also with deprecated calls. I successfully deployed my first Heroku app using it today, so that was pretty satisfying.
Yes - that was a quick and dirty. There's always room for efficiency improvement. I wonder, however where the limit on regex size would be such that the loop would be faster.
I still think CGI.pm is great for some use cases. If it works for you, keep using it!
It's just a difference in the order of operations. # Read all data into @lines my @lines = &lt;$fhin&gt;; # Remove the first element (which is the header) shift @lines; Alternatively. # Read the first line (the header) and ignore it # The return value from &lt;...&gt; isn't assigned to a variable so it's just dropped &lt;$fhin&gt;; # Read the remaining data into an array my @lines = &lt;$fhin&gt;;
I hope you didn't think I was ripping you. That wasn't my intention - I wanted to give helpful advice. I didn't even say that you shouldn't use CGI.pm - just that you should avoid its HTML-generation functions. For over ten years, my go-to toolkit for web development in Perl was the CGI.pm (for functions like `param()` and `header()`) alongside the Template Toolkit.
In my $job I wear a few different hats. I just finished writing a program that compares a csv export from our outsourced billing system with live data from our management software, and listing out the entries that aren't in sync with each other. Most of the errors are because a modem identifier (ICCID or MEID) were stored in the phone number field instead of the actual phone number. Next up: Using the ICCID or MEID to query the carriers and swap in the appropriate phone number. Also on deck for this week: A new utility using HTML::Table and CGI::FormBuilder that queries a cell carrier for cell modems listed on our troubleshooting account and displays all relevant information about them. 79 lines of code. A new utility that monitors the status of our modem management server's sending of billing information to our billing server, this time using HTML::Table::FromDatabase. I love that module, but I'm having trouble with it - using a row callback to delete a row (via undeffing the $row hashref) doesn't seem to work for me as described in the documentation. Until I can spend more time on it, I'm just making my SQL queries a little smarter. :) 
Finally refactored [PM::CB::G](https://github.com/choroba/pm-cb) (a client to PerlMonks' ChatterBox) into modules, which enabled me to add some features easily. If you are interested how Tk and threads can cooperate or how MCE and threads are similar, check the source!
Your advice wasn't wasted -- I have looked at your suggestion. In my current project, my need is met well by CGI.pm. The Perl solution is a stand-alone HTTP server that is a front-end for a database. Form out, form in, write to db. It's agreed template system would be better for a complex site. 
Again, to be clear, I'm not suggesting that you should stop using CGI.pm (although better alternatives certainly exist). I'm just saying that its HTML-generation functions should be avoided. I should point out that I haven't always seen the light on this myself. I wrote [a series of CGI tutorials](https://perlhacks.com/articles/cgi-programming/) using them in 2001 (although these days I'd far rather promote [these articles](https://perlhacks.com/articles/modern-perl-programming/) instead). And it's not like I'm that good at avoiding obsolete technologies myself. I'm currently being paid to add new features to a horrible old codebase build using [Mason 1](http://masonbook.houseabsolute.com/) - a technology that looked like a good idea for about two months back in 2003!
Regarding Perl6, here's a couple things: * See this guide: https://github.com/dnmfarrell/Perl6-One-Liners * See this book: https://www.gitbook.com/book/kyclark/metagenomics/details * One benefit of going with Perl6 is that the community is pretty close and tight-knit. So if you hang around for a couple of weeks, you'll basically be part of the "in" crowd. I'd suggest checking out the first one-liner guide and seeing how you feel about it. I think Perl5 still has a good future. It's getting better all the time and it truly is fast (which can't really be said for Perl6 right now).
Perl 5, and it sounds like this series might be a useful starting point: http://www.catonmat.net/series/perl-one-liners-explained For numerical handling, https://metacpan.org/pod/PDL is the closest we have to pandas/numpy/etc. I'd recommend learning Python as well anyway, since it's a useful skill to have and that list of features you're after is a better fit for tools such as Python/R/Matlab/Octave. Note that oneliner perl tends to have quite a different focus from application development. That's one thing I like about perl - it supports both styles quite well.
 perl -Mojo -E 'say g("https://www.reddit.com/r/perl/comments/7bmbw5/what_should_i_learn_perl_5_or_perl_6/")-&gt;dom-&gt;at(".md a")-&gt;text'
Disclaimer: I use Perl 5 (and other non-Perls), Perl 5 is still the go to when possible. Perl 6 is still on my "to do" list, but what moved Perl 6 from the ‚Äúthat might be fun someday‚Äù list and on to my ‚Äúto do‚Äù list was this presentation from Damian Conway: https://www.youtube.com/watch?v=Nq2HkAYbG5o What really got my interest was how easy it is to express a problem in domain specific notation as the bra-ket example here: https://youtu.be/Nq2HkAYbG5o?t=2744 and approx. 5 min forward. My guess is that this could be real handy for someone doing a lot of Maths :-) 
Videos linked by /u/Cylindraspis: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [2016 - On The Shoulders Of Giants - Damian Conway](https://youtu.be/Nq2HkAYbG5o?t=2744)|YAPC NA|2016-06-20|1:07:43|103+ (97%)|7,108 [2016 - On The Shoulders Of Giants - Damian Conway](https://youtu.be/Nq2HkAYbG5o?t=2744)|YAPC NA|2016-06-20|1:07:43|103+ (97%)|7,108 --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/Cylindraspis ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dpj8mv1\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
&gt;Perl 5 and Perl 6, though they belong to the same parent No. They are completely unrelated. Perl 6 is not Perl, and it will frankly never be adopted by anyone. Posts about it shouldn't even be allowed here, since, again, it's not Perl. The reason it doesn't have its own sub is "no one posts there". That should tell you something. Perl 5, even though it's not as popular as a lot of languages, will still be very useful to know if you use *NIX systems for the forseeable future, due to the many legacy programs that are written in it.
&gt; my requirements are mostly numerical analysis, linear algebra, complex numbers, differential equations, plotting tools, good graphics library, arbitrary precision, latex support, (and symbolic computations would be great, but ok if not.) etc. Use Perl 5 for text processing and automation, and learn another language for the math. Octave/Matlab works for numerical stuff, and Matlab for algebraic. Julia also looks promising.
 Can't locate ojo.pm in @INC :-(
Indeed. You can emulate most of the standard Unix tools using perl one liners, but then scale up to a script, then a parallel or multithreaded script and onwards to object oriented programming. You can even do functional programming if you are so inclined - that's basically what callbacks and things like `map` are. 
One of my favourite things about Perl6 is what I learned from Larry Wall's lightening talk at OSCON in .. 2016(?) where he showed us that you can add unicode numbers and get the right answer as Perl6 supports unicode natively. I.e., writing, `‡•ß + ‡•ß` got you `2` (`‡•ß` is "DEVANAGARI DIGIT ONE"). I'm not entirely sure when that'd _ever_ be useful, but it's really fucking cool. 
&gt; I generally get advised to not chase Perl and instead go Python. Solid advice. Python is easier to learn and much more popular at the moment. So why not learn Python first? Then you can pick up Perl. There's no reason not to learn both. But starting with Python is a good idea. &gt; I just want to learn Perl and be like those badass Sys Admins who seemingly do huge amount of tasks with Perl one-liner scripts. Ha! That's how I started with Perl too (20 years ago)! Ah, the seduction of Perl.... Why do I keep hearing Yoda's voice in my head? &gt; Like I said, I am a math student Python. Python. Python.... Perl has PDL, but that's not very popular. 
People are active on /r/perl6 but they are much more active on the IRC channel. The history of Perl6 is certainly confusing, but the reason it is called Perl6 is quite obvious don't you think? In any case, it has a lot of good ideas. The testament to this is that many of those ideas have been implemented in Perl5 now.
Just use the mojo command! mojo get https://www.reddit.com/r/perl/comments/7bmbw5/what_should_i_learn_perl_5_or_perl_6/ '.md a' 0 text
`#t`
Supporting JPSS1 launch for ground system software Auto tracking algorithms for satellite antennae Testing interfaces on remote spectrum analyzers (ugh, python for now) 
That is actually awesome‚Ä¶ If your native language uses devanagari, why shouldn‚Äôt you be able to write code using it :-) Living in Europe I use non-ASCII characters every day and in something like a jupyter notebook I could see that Unicode could make the code more transparent when not in English. 
&gt; but it's really fucking cool. really ?
Have you reached out to the author to see if they would like a comaintainer or new maintainer to fix up the distributions? You can ping tempire in #mojo on irc.perl.org as well as via his CPAN email.
I haven't yet. I made some pull requests to his github repo, but he doesn't seem to be very active there either. I'm pretty unfamiliar with the way CPAN works and how the modules are maintained, but I would like to get these up to date. I've got a couple more things to fix up, then I'll figure out the CPAN side, I suppose.
I think it should be: -MMojo
&gt; Mason Now you have me laughing! (o:
No, he just doesn't have [https://metacpan.org/pod/ojo](ojo) installed (it comes with Mojolicious).
Perhaps. But it should probably be rebranded as a different language really. Perl 5 isn't going anywhere, but having two incompatible versions is a real piece of newbie hostility. 
It's a dzil distribution, so it will take care of the gruntwork of releasing distributions for you. All you need to do is: cpanm Dist::Zilla &amp;&amp; cpanm Dist::Zilla::App::Command::installdeps # this will take a while Then you have access to these commands: dzil installdeps # installs dist.ini plugins then dist prereqs dzil test # runs dist and author tests dzil build # builds a distribution directory and tarball, same as would be uploaded if you release dzil release # does the actual release The only manual steps you need to do other than the actual code/docs changes are to update the Changes file, and update the version number in the module and metadata in dist.ini. There are plugins that streamline these parts too but that's out of the scope of this comment. dzil.org has some tutorials (though exceedingly basic) and #distzilla on irc.perl.org is a good place to ask about anything dzil.
Ahhh! Thanks.
They've discussed this topic a great deal. A lot in recent time actually. Pretty much every criticism of Perl6 has been discussed at length. It's not like they're unaware of the short-comings.
Perl 5 is the thing to be doing. It's where most of the user base is, and it's the version that's installed practically every where. I know it's sort of traditional to look askance at perl, but it's a good language - it _does_ let you get away with bad code, but that doesn't mean you have to write bad code. It will let you emulate pretty much all command line tools, and work as super shell scripts. And then build up to work pretty much however you want to write. Works fine for object oriented code, parallel code, modular code. Event functional programming. Unlike most languages, it's got a really rich and complete feature set for pretty much any problem, but it's real strength is text processing, thanks to its regex engine. One liners are a bit of an oddball - pretty much inevitably they are "bad code". But just because `sed 's/one/two/'` isn't exactly "good code" doesn't mean it isn't exactly the tool for the job sometimes. Be wary of them though - it's far better to write something longhand if you are going to use it again, ever. Just like the "magic regex" - you can do a lot with a single re. That doesn't mean you should. Breaking it apart for clarity is a good thing. ... And one that perl is also supportive of, thanks to the "x" modifier to patterns (ignore whitespace - allows you to format and comment regex. 
Yeah, it's really is.
That's patent falsehood. Larry Wall himself, creator of Perl, led the team to create Perl 6. He himself said they are sister languages. I started programming with perl5. It is very unixy. I use Linux so perl 5 was great to start with. I am planning to move to perl6 but wanted to learn OO first so I have made a detour to Ruby first. I am waiting for the learning Perl 6 book to come out to start perl6. If I was new to programming I would start with either perl6 or Ruby. Both are great languages and are designed for *nix. 
Maybe I‚Äôm not understanding what you are writing, but that sounds like the sort of thing that could result in odd or unexpected behaviour from input validation that isn‚Äôt deeply aware of Unicode.
It doesn‚Äôt really seem like they have actually done anything about those criticisms though.
Realistically for your interests, you are going to get a lot more value out of python. Check out Jupyter/Ipython, scipy, numpy, and SymPy. Perl is great for some stuff (I write perl5 daily and have been doing so for over 20 years), but math isn‚Äôt one of them.
About the naming criticism? There's not really a good way out...
thanks
thanks
thanks
It actually is the next Perl. Certainly that does not mean you can't use Perl 5, or that it won't continue to evolve. But it is a newer Perl and thus the next. 
Unicode support is a real nuisance when it's partially implemented. I can see the rationale for building it in deeper. But I can also see it making some really nasty debugging and edge cases.
[Web::Query](http://p3rl.org/Web::Query)[(::LibXML)](http://p3rl.org/Web::Query::LibXML) has a much better interface than TreeBuilder.
&gt; Math::Base85 provides support for base 85 numbers as defined by RFC 1924 As someone else who's ended up maintaining a module implementing RFC 1924, I would like to point out that this RFC was an April Fool's joke. Oddly enough that fact didn't appear anywhere in this module's documentation or in the module I ended up maintaining, Net::IPv6Addr, until I recently added it. 
&gt; Recently I have been working on WWW::Gittip So, you've been making the world a better place. 
Math student, eh? I'd say go with the Perl that gets math right üòõ $ perl -wlE '.1 + .2 == .3 and say "True" or say "False"' False $ perl6 -e '.1 + .2 == .3 and say "True" or say "False"' True &gt; Or will learning Perl be a fool's errand and I better go learn Python On a more serious note: go with Python to have a workable tool you're comfortable with under the belt. Then, try out the Perls and see if any of them solve your tasks better. There's no rule that you must learn one language only.
I think you meant: perl6 -MWWW -MDOM::Tiny -e '.at(".md a + a").text.say with DOM::Tiny.parse: get "https://www.reddit.com/r/perl/comments/7bmbw5/what_should_i_learn_perl_5_or_perl_6/"' üòù
Well if you're in Perl 6 everything is deeply aware of Unicode by default, that's what everyone was getting at. For example `perl6 -e 'say "Got a digit!" if "‡•ß" ~~ /\d/'`
If being a maths student meant loving simple arithmetic... A better maths nerd example is this: `$ perl6 -e 'say œÑ'` 6.28318530717959
I gotta say, that is some pretty unexpected behaviour. I feel like there are going to be more than a few exploits coming from this.
Which criticisms did you have in mind? Maybe they just never reached the people who actually can do something about them? ----------- For the naming thing... It's a very difficult task because, unlike some technical matters, everyone feels they can pitch in. It's the bikesheddiest of bikesheds. There [*is* some progress being made on the matter though](https://github.com/perl6/6.d-prep/tree/master/TODO#language-extended-naming).
I think you're right. It gets worse actually: $ perl6 -e 'say so "‡•ß\x[308]" ~~ /\d/' True It's going by Unicode properties and the character still got `Nd` property on it, even when you tack on a combiner.
Not sure I'd expect that to change something being a digit though? I can't think of what you'd do to a '4' with combining chars to make it not the digit 4. Though I must admit I bet this behaviour is by accident rather than design :/
Well no more -likely a lot less- than a language that has basically no support for multi locale numerics trying to do the same functionality surely...? At some point to support that stuff coming in you open yourself up to unicode.
I'd add on SageMath to the list too just because it has some cool stuff http://www.sagemath.org/
&gt; I can't think of what you'd do to a '4' with combining chars to make it not the digit 4 Feed it to something that doesn't know what a '4' with a combing chars is about. I can see someone naively expecting `/^ \d $/` to match 1 or a handful of bytes, but it can get pretty big: with "‡•ß" ~ "\x[308]" x 1020 { .chars.say; # 1 .encode.bytes.say; # 2023 /^ \d $/.so.say # True }
Eventually we should also have some sort of "no combiners" modifier in regex so `/^ \d $/` would work too. I think samcv++ was pondering implementing it.
Link to the interview - https://www.mappingthejourney.com/single-post/2017/11/09/episode-13-interview-with-damian-conway-designer-of-perl-6-programming-language/
It feels like the problem here is simply not expecting unicode rather than the regex is doing the wrong thing. I'd be happy with the alphanumeric class matching with combining characters. That someone would use a regex to check the modality of the memory footprint of some input is the actual WTF. Doing something like `/\d**3/` and expecting that will fit nicely into a database field of 3 chars or something. It's unicode, change your expectation. Just a wide character digit could screw that up. Relying on regex that way is a Perl 5 anti pattern and should already be avoided, and definitely not cargo culted to P6. Just say you want an integer and either get the right thing or an error. Looks like the current Rakudo implementation errors. Perl 6 has types now, we dont have to treat everything like its a string of bytes, and should be actively advised not to. Routing in a web app is a good example, in Dancer in Perl 5 you'd maybe write a regex that looks like the above to match a 3 char ID number. In Perl 6 you'd just subtype Int to be 0 &lt; $x &lt; 999. Then match on that subtype in the dispatch from the URL.
&gt; It feels like the problem here is simply not expecting unicode rather than the regex is doing the wrong thing Well yeah, it makes sense when you already know how it works and what you should do instead. Exploits are usually created by not that.
 root@mojo:~# perl -Mojo -E 'say g("https://www.reddit.com/r/perl/comments/7bmbw5/what_should_i_learn_perl_5_or_perl_6/")-&gt;dom-&gt;at(".md a")-&gt;text' Can't locate ojo.pm in @INC (you may need to install the ojo module) (@INC contains: /etc/perl /usr/local/lib/x86_64-linux-gnu/perl/5.22.1 /usr/local/share/perl/5.22.1 /usr/lib/x86_64-linux-gnu/perl5/5.22 /usr/share/perl5 /usr/lib/x86_64-linux-gnu/perl/5.22 /usr/share/perl/5.22 /usr/local/lib/site_perl /usr/lib/x86_64-linux-gnu/perl-base .). BEGIN failed--compilation aborted. root@mojo:~# apt install libmojolicious-perl Reading package lists... Done Building dependency tree Reading state information... Done The following additional packages will be installed: javascript-common libcommon-sense-perl libev-perl libio-socket-socks-perl libio-socket-ssl-perl libjs-jquery libjs-prettify libmojo-server-fastcgi-perl libnet-libidn-perl libnet-ssleay-perl Suggested packages: apache2 | lighttpd | httpd The following NEW packages will be installed: javascript-common libcommon-sense-perl libev-perl libio-socket-socks-perl libio-socket-ssl-perl libjs-jquery libjs-prettify libmojo-server-fastcgi-perl libmojolicious-perl libnet-libidn-perl libnet-ssleay-perl 0 upgraded, 11 newly installed, 0 to remove and 0 not upgraded. Need to get 1583 kB of archives. After this operation, 5029 kB of additional disk space will be used. Do you want to continue? [Y/n] [...] root@mojo:~# perl -Mojo -E 'say g("https://www.reddit.com/r/perl/comments/7bmbw5/what_should_i_learn_perl_5_or_perl_6/")-&gt;dom-&gt;at(".md a")-&gt;text' Perl 5
Well, my first thought is if you have a need to handle Unicode digits in a math context, you should be doing so explicitly and not relying on language features. My next thought is that this is going to have weird behaviours when perl6 interfaces with the outside world where Unicode numbers are absolutely not numbers. Like MySQL, for instance. It feels like it violates the principle of least surprise. Insert into products set price=‚Äú‡•ß‚Äú; What is that going to do? I should expect that something matching /^\\d+$/ is a number in the same sense that every other system I will interact with is. 
From this &gt; Like I said, I am a math student, and my requirements are mostly numerical analysis, linear algebra, complex numbers, differential equations, plotting tools, good graphics library, arbitrary precision, latex support, (and symbolic computations would be great, but ok if not.) etc. I don‚Äôt think that sounds like a good fit for Perl. PDL for linear algebra, Math::BigNum for arbitrary precision, but Perl is way out of its depths for the rest. It‚Äôs just not where all the developers are. 
Awesome, thanks for the pointers. I've played with dzil a little bit now with these projects, but there's still a lot to learn. I'd definitely like to coordinate with tempire to get these modules updated. Being able to easily deploy a mojolicious app to Heroku like this is really nice, and I'm sure other people would find these updated CPAN modules useful.
&gt; There's not really a good way out... Maybe not, but let's not pretend that a strategy of deliberate inaction is anything other than Larry wanting his cake and eating it too.
Great interview! It is amazing that I have not learned about the regexp debugger of Perl5 until now. The not so great part is that it seems like a literal transcription of the oral interview, so sometimes it is hard to follow because many commas and periods are missing, or colloquial expressions are preserved. 
It's not deliberate inaction. Read the discussions on the topic (many are on /r/perl6). It's not as easy as "let's change the name". In fact, many people like you criticize perl6 when it doesn't change the name, then you criticize them when they do (because it's too much bike shedding). There in fact is no way to make most critics happy.
You shouldn't be using unicode "numbers" (strings) in the first place where you need actual numbers. You should have actual validation that the number can get parsed into a number: my $price = $_ with Int($unvalidated-input) or fail "needed a number"; set-price($product, $price); `Int` or `Num` or `Rat` or ... whatever type you actually want (types are good, string reinterpretation magic is usually not)
It seems to me that the exact same argument could be used to say that you shouldn't magically end up with numbers when you have a unicode "number" (string). It's very surprising behaviour. I generally don't feel that programming languages should have surprising behaviour, and should try at all times to minimize it. Maybe I just don't understand what the practical benefits are from introducing what seems like a very unorthodox approach to string handling. Can anyone explain why this is a good thing to do?
You can make some pretty huge regexes, and because you're then offloading the work to the C regex engine, it's almost always more effcient. 
&gt; Can anyone explain why this is a good thing to do? 1. create a web app that lets people manage their budgets 2. market it in Thailand It isn't unorthodox string handling. The unicode data "‡πì‡πï‡πê" [contains information](https://glot.io/snippets/evca6hkfkc). What makes it somehow less important than "350"? as far as truthiness: "‡πê".so.say; # True "0".so.say; # True 0.so.say; # False Any not empty string is True. A numeric data structure object that represents the value zero is probably false (I'm not ready to make that claim absolute, but the cases where it doesn't are probably intentional). http://www.fileformat.info/info/unicode/char/0e50/index.htm http://www.fileformat.info/info/unicode/char/0e53/index.htm http://www.fileformat.info/info/unicode/char/0e55/index.htm
syncing scripts between different systems. not the most exciting but at least its in Perl :)
This said, I think it would be a good thing to be able to restrict grammars to particular subsets of unicode (Blocks?) somehow as a cross cutting concern. /u/zoffix Is that something that sounds doable? perhaps something like: grammar MericanRegex:restrict("Basic Latin") { rule TOP { &lt;word&gt;* } rule word { \w+ } } or `rx:s:restrict("Basic Latin")/ ( \w+ )* /` (can you even apply adverbs to grammars?)
Perl 6 regexes have an `&amp;` and `&amp;&amp;` operators (similar to `|` and `||`). You can specify in your TOP rule that the entire text mast match just the subset you want.
If you need a comprehensive list: http://www.tysto.com/uk-us-spelling-list.html 
&gt; What makes it somehow less important than "350"? That sounds like political correctness being misapplied to software. It's not a question of whether it's more important, it's a question of whether it's useful or misleading. Taking away the unique identity of integers seems like it is an entry point to all sorts of hard to diagnose bugs, without much compensation. Not to mention the effects of changing something as fundamental and widespread as a \\d regexp metacharacter.
 grammar MericanRegex { rule TOP { ^ &lt;word&gt;* &amp;&amp; &lt;:Block('Basic Latin')&gt;* $} rule word { \w+ } } plan 2; ok MericanRegex.parse('Hello World'); nok MericanRegex.parse('Hel‡∏çlo World'); done-testing; WFM
&gt; ^ &lt;word&gt;* &amp;&amp; &lt;:Block('Basic Latin')&gt;* $ Doesn't matter in this case, but you need grouping parens there, to avoid start of string applying in one alternation and end of string in another; just as you'd need them with the `||` operator: ^ [&lt;word&gt;* &amp;&amp; &lt;:Block('Basic Latin')&gt;*] $ 
I hate to break it to you, but \d already means this in perl 5. https://www.reddit.com/r/perl/comments/69kdit/d_does_not_validate_numbers/
I worked with Larry for quite a while *designing* Perl 6, thank you very much, and I stand by my choice of phrase with "deliberate inaction". &gt; There in fact is no way to make most critics happy. This is a ridiculous non-argument. Larry's refusal to commit either to keeping the name or to changing the name -- much like his "well maybe if someone comes up with something I like better" response to criticisms of the logo -- keeps this subject coming up again and again. I suspect the same goes for his view of whether he thinks P6 should replace Perl.
Huh, TIL. I wonder if I can find any exploits from this -- several million lines of code in the wild had their input validation silently changed when perl 5.6 came out.
That's fair enough. It's true that the benevolent dictator aspect is problematic.
So from the talks he has given, that I have seen, I'm suspecting that this guy is the Shazam to Larry, the Wizard - if I have that right. Regardless, currently impressed by his contributions to the community.
Seconded.
Is the graphql talk anywhere online to watch (video or slides)?
Not yet. The workshop is in two weeks time.
Java is way too verbose. That's a justified reason. 
Fwiw here's my P6 suggestion with an equivalent to your word boundary check using P6's [left/right word boundaries](https://docs.perl6.org/language/regexes#%3C%3C_and_%3E%3E,_left_and_right_word_boundary): use v6c; my $documenttext = 'theatre theatrelane foo colour' ; # Added theaterlane my %spelling = British =&gt; &lt;colour football theatre&gt;, American =&gt; &lt;color soccer theater &gt; ; %spelling&lt;British&gt; .= map: { regex { ¬´ $_ ¬ª } } # Add word boundaries $documenttext .= trans: .&lt;British&gt; =&gt; .&lt;American&gt; given %spelling; say $documenttext ; # theater theatrelane foo color
tl;dr
It actually was a compiler error
Downvoted for misleading title.
Perl 6 is an amazing language and the most fun I have had programming in a long time. The community is very nice, welcoming, and active; which is a huge benefit. Checkout the #perl6 irc on freenode. Perl 6 also has support for concurrency and unicode and is ready for the future. I would say if you needed to work on an existing older code-base to learn perl 5, but if you want to learn something new and cutting-edge to go with Perl 6. I also recommend you check out this awesome book: https://www.amazon.com/Perl-Fundamentals-Examples-Projects-Studies/dp/1484228987
I used to have several excerpts from Good Advice for Programmers in my .sig file, back when I had a .sig file. So many gems in there. 
Smartass. So clever, hiding behind your initials.
Well PDL seems to be a good Perl5 substitute for numpy and Math programming...
Eh not in my experience. And good luck doing any meaningful symbolic math in Perl. It‚Äôs just a fact that virtually all scientists and mathematicians are investing their time in the python scipy/numpy stack. And Perl is being increasingly left to devops.
dv;sc
 Isn't Mojo::DOM the way the kids are doing it these days?
I had this idea in 2006 point that I would write a blog post about each of them. Then in 2010 I started writing one of the posts but didn't finish it. But now I find I've done one by accident!
Sounds like a fun project, good luck! Note that CPAN is mostly automated - far as I'm aware no one actually includes things in there, authors just upload and distributions magically appear in the central index. http://www.cpan.org/misc/cpan-faq.html#How_contribute_modules has more details. Couple of minor points about the code: * `use strict` and `use warnings` tend to save a lot of time, you'll find those two are very high on the list of typical recommendations * `shift` only gives you a single scalar, so I think you'd want `@_` in places like this: https://github.com/theholyghost/hollysrc/blob/master/3d/engine/Engine3d.pm#L12
That's what I keep telling our users, but they don't believe me!!
Technically, I think making the syntax distinct is a great idea, it's just unfortunate that it would prevent a lot of code from working on both perl 5.20-5.26 and perls going forward with this change. But to be fair, it has not yet been marked unexperimental.
For your linear algebra and plotting tools, numpy and matplotlib, therefore Python. I love Perl dearly and I think in Perl much more fluently than in Python, but for things like what you're describing Python has the lead. For badass sysadmin, tho': Perl 5. Warning: Perl 5 will introduce you to the beauties of functional programming. It's a gateway drug. And once it does that, Perl 6 will suck you in. 
He should go with Perl6 because it can use those Python modules as easy as native ones.
Disgusting.
http://search.cpan.org/~dvdpol/Math-Geometry-Planar-1.16/Planar.pm#$polygon-&gt;isinside($point);
It‚Äôs printing all lines from the file beginning from the line with the pattern LAYER_142.0 until the line with the pattern LAYER. -n means don‚Äôt print non matching lines Modifier ‚Äòp‚Äô is to just print the lines sed -n ‚Äò/pattern1/,/pattern2/p Can be translated to Print all lines in the file from the line having pattern1 until the line having pattern2. 
Good point.
And the next grep - v is omitting the lines with LAYER
Seems silly to pipe stuff through perl in a system call.
Sounds like homework. Here's how I would go about solving it... 1. Is the polygon convex? 2. A rectangle is a very simple shape. What tests can I come up with based upon that fact? 3. What things have we been learning about recently in class?
The polygon could be of any shape, could be a star, could be an L, could be an M, you could draw whatever you want with it. The coordinates are points of each vertex in series
So you have a rectangle, a set of vertices, and a set of line segments separating "inside" from "outside." Can you figure out how the sides interact with the polygon? Think about the edge cases.
You have a perl script that uses system() for all that *including another invocation of perl* instead of doing it all natively? (Plus useless use of cat). Yikes. This is the sort of crap responsible for giving perl a bad name.
Lol it's not mine, why would I ask the question if I wrote the line
You should track down whomever did and have words with them.
If you really want to learn something from this exercise I would reccommend you have a look at the book 'Mastering Algorithms with Perl' published by O'Reilly. In the chapter on Geometry there is a section on finding if a point is in a polygon. This will get you some of the way - if any of the four corners are in the polygon then you have your answer. But the two shapes could intersect without any of the corners being inside the polygon so you will need to adapt the code. I think the way the algorithm is explained will point you to the solution easily enough.
Check out [mi.cro.services](http://mi.cro.services) website :) It's a framework written in Rakudo Perl 6 :)
What effort have you made to answer the question by yourself? Have you tried: cat file.txt cat file.txt | sed -n '/LAYER_$x/,/LAYER/p' cat file.txt | sed -n '/LAYER_$x/,/LAYER/p' | grep -v LAYER cat file.txt | sed -n '/LAYER_$x/,/LAYER/p' | grep -v LAYER | grep -v '\&lt;p\\&gt;' etc? It cats a file into sed. sed matches on the line which contains LAYER_142.0 and continues matching until another line that contains LAYER. It's equivalent to the Perl flip-flop match operator using '..'. The range is lines is then sent to grep which only matches lines which do not contain LAYER ( -v inverts the sense of the match). The non-LAYER lines are then sent to grep to exclude html paragraph tags, but I think it's wrong. The first backslash is to prevent the ',' from having some special meaning, and the others are intended to insert a single backslash. But backslashes are not needed in a single-quoted string. And besides, I don't know of any '&lt;p\&gt;' tag. There's &lt;p&gt; and &lt;/p&gt; to begin and end a paragraph. Something like &lt;br\&gt; which does not have a closing tag, takes a backslash at the end, but &lt;p\&gt; does not exist. Finally, the perl looks for DN 1 in a line and replaces that portion with DN
Much faster would be not to shell out and do all the work in Perl: my $x = '142.0'; open my $IN, '&lt;', 'file.txt' or die $!; while (&lt;$IN&gt;) { if ((/LAYER_$x/ ... /LAYER/) &amp;&amp; ! /LAYER/ &amp;&amp; ! /&lt;p\b/ ) { s/(DN) 1/$1/; print; } } 
Take a look [`-&gt;get_p` method](https://metacpan.org/pod/Mojo::UserAgent#get_p) and attach your rendering with `-&gt;then` on it. Haven't used it myself and it might be not quite the right tool for your job, but there's also [Minion](https://metacpan.org/pod/Minion)
It's perfectly fine. As long as everything you want to do based on the response is in the callback (or in the next step, if you use the promise setup /u/zoffix mentions) then you can do whatever you want there. It's a closure, so you can use any variables that were declared and assigned beforehand and everything will just work. Just remember that the callback/next step will not be run at that time, but at "some time in the future", so you need to run the event loop for that to occur (this is the Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running that you see in a lot of examples, which the -&gt;wait method on promises wraps).
Is [this](http://search.cpan.org/~doy/Spreadsheet-ParseXLSX-0.27/lib/Spreadsheet/ParseXLSX.pm) the module you're using? It doesn't appear to have any timeout related settings. What's triggering this timeout and what mechanism is it using? 
Thats the one. Centos 7 64 bit by the way. 
If you're running without swap, try setting up a swapfile; see if that solves the process-kill problem.
Kind of a weird question. I use Perl on Windows because I have to be on Windows for work (and Linux/Unix servers), and I use it for all the things people would normally use Perl for. Not sure how Powershell compares, because I've never used it. It certainly doesn't look like a rich, full-fledged language with an eco-system like Perl. It helps to be able to use it through Cygwin though. I can write a script locally with the same paths at on the Linux server, then just copy it over.
That sounds like a system-level setting maybe.
is this running from CGI or similar?
From the command line. 
I'll check swap,.
Sounds like you could be hitting an "out of memory" condition. How much RAM and swap do you have?
Hi, How big is "large"?
My entire enterprise build solution is Windows+Jenkins+95% perl /5% Python. It's just another language, it solves the need and i'm sure who ever started the project was comfortable with perl vs another scripting language.
Not routinely, but a coworker came to me with a file to be parsed and turned into a CSV. All her stuff was on Windows, and I'm most comfortable in Perl for this type of thing (never used Powershell), so I threw Strawberry Perl on there to get the job done. Worked a treat.
Still, deviating from literally every other Algol derived language out there is just as insane as breaking prototypes. I'd rather opt for a distinguishing character in front or inside the parethesis. Not pretty either, but still better than square brackets. At least there's precedence here in ambiguous braces in map. I'm surprised the smartmatch signatures proposal didn't get more attention. That one looks way scarier in my opinion.
What is a large dataset, megabytes? Gigabytes? Terabytes? I would guess anything up to 50 or 100 megabytes would work fine natively. If the dataset got bigger than that I would use cygwin which was more reliable years ago when I used to use both. For gigabyte and terabyte datasets I would put the data on a linux machine with nfs access. Ssh in and write/run the perl script. Or use nfs to write it locally and run it remotely via ssh.
[Capture::Tiny](https://metacpan.org/pod/Capture::Tiny). use Capture::Tiny 'capture_stdout'; my $output = capture_stdout { whatever() }; 
 use strict; use warnings; sub hello_world { print "Hello, World.\n"; } sub capturing_stdout { my ($action) = @_; my $out = ''; open OUT, '&gt;', \$out or die "Can't open OUT: $!"; select OUT; eval { $action-&gt;(); }; my $e = $@; select STDOUT; die $e if $e; return $out; } # this will print normally: hello_world(); # this will capture: my $x = capturing_stdout(sub { hello_world(); }); print "This is the value of \$x: $x"; print "Done.\n"; 
Your thinking seems a little backwards to me... wouldn't it be 100x easier to just do my $str = mySubRoutine(); print $str; And then when you don't want it to print out you don't have the print afterwards? Or possible modify `mySubRoutine()` to take a `print` parameter so it only prints on demand? Or does a return on demand to reverse the logic? 
Well, the sub is doing stuff like print "Starting process", print "some note", print "ending process". I want these to show every time except one of the times
I would say "not really". I would probably just do a module with subs that return the SQL, or if there wasn't too many of them I put them in a hash exported by the module. What you're after is centralized SQL queries in one file, accessible by name, right? And actually, I might just leave them where they are, embedded in the perl code. Don't get too hyped up about it just because you want to be trend compliant. 
Think you are trying to make it harder than it needs to be. You can open a text file with perl and read from that with each line being a sql statement.
Sorry afk. RAM - 3GB Swap .5GB. Swap's a bit light. Also, df -h showed 96% Use on the main drive. have made some room and got it down to 80%. Tried running it again with vmstat 3 100. Still got "Killed", not as quickly this time, vmstat looked like: procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 466080 98056 0 73712 0 0 0 0 0 139 8 0 92 0 0 1 0 466068 90876 0 73968 4 0 0 0 0 117 9 0 91 0 0 1 0 463068 84964 0 73592 459 0 0 81 0 394 8 0 92 0 0 1 0 463060 78016 0 73740 3 0 3 3 0 153 11 0 89 0 0 4 0 463040 71016 0 73816 7 0 0 0 0 171 14 0 86 0 0 4 0 463040 63816 0 73832 0 0 0 3 0 138 30 0 70 0 0 4 0 463040 57856 0 73908 0 0 0 80 0 118 33 0 67 0 0 4 0 463040 52428 0 74092 0 0 59 0 0 108 33 0 67 0 0 3 0 78068 2560108 0 69528 49 19779 104 317 0 1835 37 3 60 0 0 ...at the point where the process dies. [edit] That's horrible to read... the si and so look like 49 and 19779 at time of death. atop say; MEM | tot 3.0G | free 0.3M | cache 39.3M | buff 0.0M | slab 57.2M | SWP | tot 512.0M | free 48.9M | | vmcom 0.0M | vmlim 0.0M | PAG | scan 0 | steal 0 | stall 0 | swin 7148 | swout 17059 | ....around time of death. 
Really, putting them in a separate file is just making things worse and messier. It's trivial to do if you want to, but it doesn't seem like a good idea, compared to just having a function for each type of query you need to do, and having the SQL live inside of that function.
What that *really* calls for is a logging module, and then you can just alter the logging level or the logging target on demand, instead of simply eating up all output.
What's a logging module?
Probably best to do it the other way around... a) Is the polygon in the rectangle:-test each polygon point between top left and bottom right... b) are some polygon points in the rectangle and some outside? then polygon intersects c) otherwise polygon either entirely contains the rectangle or completely outside rectangle..
Slow down there! OP clearly needs a meta-logging module, to abstract over his choice of logging modules before committing to just one. Combined with a dependency-injection framework, this would allow maximum flexibility. Bottom line: `print` is *hard*!
You jest, but the most common logging framework does that with minimal effort - [Log::Any](https://metacpan.org/pod/Log::Any).
It's usually a better idea to keep common *operations* in module functions, and each operation can specify its queries however you like or call other operations, passing around the database connector. The actual text of the queries will probably not be duplicated too much if this is done right.
You are definitely running out of memory. Unfortunately parsing spreadsheets with this module only works all-at-once, so you will need to either get more RAM or more swap space.
I jest, with minimal effort, *because* that thing exists, a lovely testament to how coders make simple things complex, then spackle over the complexity before building more complicated things on top of the spackle.
There's a whole bunch of modules like [Log::Dispatchouli](https://metacpan.org/pod/Log::Dispatchouli) and [Log::Any](https://metacpan.org/pod/Log::Any) that are for controlling output. You can control whether it goes to a file, screen, email, etc. There are generally log 'levels' that signify the level of importance of that line, and you can toggle what amount of verbosity you get.
Logging isn't a simple thing, it's a complex thing that people pretend is simple, until they run into the scenario that their simple vision didn't account for :)
Thanks for that, good to know. Can you tell me which bit of my posts actually told you that? Couldn't quite see it myself. Thanks again, ---=L
I like Log::Contextual + Log::Dispatch (not ouli) myself, but there is a [little boilerplate](https://github.com/arodland/borkbot/blob/master/lib/Borkbot/Logger.pm) involved in setting it up as I like, so I only use it in projects big enough / polished enough to justify it.
In your last message with atop output, your memory was nearly completely full, and your small amount of swap was 90% full. I would expect oomkiller to kill off the biggest offender shortly in that scenario.
Excellent, thanks so much for thinking about this. ---=L
This is almost certainly what you're looking for: https://metacpan.org/pod/SQL::Functional
I have so much SQL hard coded in my scripts... I don't think it's really a problem.
[removed]
That looks very much like "out of memory" You can confirm this using 'dmesg' 
Yes, moving those out of the Perl code seems like a sensible approach. Which database? If you're using PostgreSQL, Oracle, DB2 or SQL Server, I'd recommend stored procedures. You can then write tests without any perl involved (see http://pgtap.org/ for example). Mixing multiple languages in one file increases cognitive load and context switching, I wouldn't recommend it (same goes for HTML/CSS/JS... I'm even a bit dubious about regex!) 
Nice! That's actually going to be really useful in my dealings with some legacy code.
It's really nice, especially since it works equally well for capturing the output of other perl code, child processes, or a combination of both, which makes it (in the right circumstances) a replacement for *several* different modules :)
Short explanation: in Perl 5 you can use in-memory files if you pass a scalar reference as a filename to `open`. You can also use lexical filehandles instead of fileglobs: open my $fh_out, '&gt;', \$out or die... When capturing output, this also works (pass a subroutine reference): my $x = capturing_stdout( \&amp;hello_world ); (no need for the anonymous sub.)
depends how you're using them, and whose maintenance burden it is.
&gt; What you're after is centralized SQL queries in one file, accessible by name, right? yes. I don't really want to do what's hype today, it's just for some reason it makes it harder for me to read the code (which I don't get to look at too often, maybe once a week, when I have some time to do some improvements). especially when there are 5-10 line bocks of SQL is embedded. I was thinking of module or even a text file from which I'd read on startup -- I liked later, because I could even have it with `.sql` extension, and have SQL highlighting when I'd edit the queries. But I thought maybe there's some commonly used solution already exist, which I'm overlooking. I guess not.
thanks for reply! maybe you're right. this was one of the solutions I was thinking. I could have it with `.sql` extension for proper highlighting in editors too.
thanks for sharing your opinion! it seems to match what others are saying. as I mentioned in other replies right now it makes it harder for me to read the code. but maybe I just need to organize it better...
Thanks!
thanks! i looked at not just now, but on the initial glance I don't think this would help me read my code easier :-/
thanks! it's mysql. the program is small, so I was thinking of keeping it all together. but sprocs could be the solution..
Yes, I see your point about using *.sql files, it does make it easier to tell your editor how to do the syntax highlighting. I often keep table creation and setup sql in it's own *.sql file. If you're using emacs, there are some tricks to try to switch mode highlighting on the fly... I haven't played with these in a while, but it looked like mumamo.el should work for sql in perl, the last time I did: https://www.emacswiki.org/emacs/MultipleModes
I already do functional programming but in Haskell. What does Perl 6 offer?
so if the function returns a value, but also prints out to stdout, how can i capture the return value in a different variable than the one that captures the stdout? eg. can i do: my $output; my $returnVal; $output = capture_stdout { $returnVal = whatever(); } Does this work? the return value will be stored in $returnVal but the stdout will go into $output?
Yeah, that's fine.
Have you seen [SQL::Abstract::More](https://metacpan.org/pod/SQL::Abstract::More) ? You can do: use SQL::Abstract::More; # assuming $mysql is a Mojo::mysql object $mysql-&gt;abstract(SQL::Abstract::More-&gt;new); say $mysql-&gt;db-&gt;select(-from =&gt; 'names', -where =&gt; {name =&gt; 'Isabel'}) -&gt;hash-&gt;{id}; Perhaps slightly slower to recompute the query text each time, but the ability to do things like: sub get_people { my ($self, $who) = @_; return eval { $self-&gt;db-&gt;select ( -from =&gt; 'names', -where =&gt; {name =&gt; {-in =&gt; $who}} ) -&gt;hashes; }; and have $who be either a scalar name or an array of names, and not have to build up all the "?" arguments, is a big winner in clarity and maintainability.
Yeah I use Log::Contextual a bunch, though I'm currently using it wrong in our main logging module (coupled the set_logger call with the main logging wrapping stuff).
Consider using q{} syntax for long queries.
Perhaps [SQL::Library](https://metacpan.org/pod/SQL::Library) would help?
yes! just like I imagined it :) thank you
If your hardware allows it, I'd go so far as suggesting you add another drive with a swap-partition formatted with at least twice your silicon memory (so, 6G or more), and add it to the mix with swapon. Your code will slow *wayyyy* down when it hits swap... but it'll keep running. That gets you over your immediate hump. If not, my suggestion about a swapfile stands, with 10G or more if you've got it to spare. Same slowdown warning applies, but now, by tweaking the swapfile size on reruns, you can determine just how much RAM this dataset needs for processing, by how much is enough for it to cross the finish line alive -- so you've got those numbers ready when it comes time to push this project over into hardware which can run it at speed.
As if you were a homicidal maniac. That person deserves a lesson.
Take a look at this module: [SQL::Template](https://metacpan.org/pod/SQL::Template)
CLOS-style object system with method modifiers, multiple dispatch to lexically scoped multimethods, roles (which subsume mixins, traits, and interfaces) etc.; as much or as little static typing as you want, plus dynamic typing such as coercions that you define; easy definition of DSLs via grammars and custom operators; easy creation of command-line interfaces just from the signature of the (optional) MAIN function; all the usual stuff you're used to (closures, lazy lists and list generators, list transforming and filtering meta-operators, currying); automatic parallelization of referentially transparent work; a great model for concurrency and asynchrony; all of this stuff integrated with other goodies like a nice FFI, optional machine-level typing, and the best Unicode support I've ever seen; and you don't have to wear the monadic hair shirt (unless you choose to). I have to amend what I said about badass sysadminning, too: see https://github.com/dnmfarrell/Perl6-One-Liners for some inspiration.
Thank you for your reply. Yes, you're right, managing some env vars by my hands (either setting them directly or via `local::lib`) wasn't good idea. But then I explored source code of `plenv-contrib` and `plenv`, and now I have three pull requests which can make my life easier if they will be accepted in mainline. Sorry for late reply.
You can post your JAPHs to http://www.perlmonks.org/?node=Obfuscated%20Code , you can also find lots of nice ones there.
[removed]
I'd be interested to see what would happen speed-wise if the added swap drive was an SSD, then try an SSD with M.2 NVLe. Of course, by that time, the OP's wallet may coredump. Lol 
I use it for convenience scripts, same as anywhere.
instead of /$temp2/ write /\Q$temp2\E/
Can you explain that?
http://perldoc.perl.org/functions/quotemeta.html
I usually end up with a model class. It's pretty easy to do with an AUTOLOAD method, "{Slice =&gt; {}}" and just the right amount of bless.
[removed]
The `[1]` in `$temp2 is being interpreted as a character class. A character class with a single element. So it's exactly the same as saying: if ($temp =~ /x_m11/) And I expect you can see why that fails. If you want metacharacters like `[` and `]` to lose their special meanings, you can escape them with a `\`. if ($temp =~ /x_m1\[1\]/) A good way to automatically escape metacharacters, is with the `\Q` sequence. if ($temp =~ /\Qx_m1[1]/) That escapes any metacharacters in the string. If you want to turn off its effects before the end of the string, you can use `\E`. So what you want here is: if ($temp =~ /\Q$temp2/) 
is that directory in your %PATH?
If you're coming to the workshop, please indicate the talks that you're interested in seeing, so that the organisers have some idea of the demand.
Your if statement for num2 is inside the "success" clause of the if statement for num1. So, you are only checking num2 if num1 is even.
That's because in your first conditional, you're checking only the first number. In the `5 6` case, it's odd, so you jump to the "both odd" case without ever bothering to check the second number. Just reverse the check: check whether both are odd already first and in the `else` branch increment the ones that are even: my ($num1, $num2) = (5, 6); if ($num1 % 2 != 0 and $num2 % 2 != 0) { print "Both are odd\n"; } else { $num1++ if $num1 % 2 == 0; $num2++ if $num2 % 2 == 0; } print "$num1 $num2\n";
I've tried doing something like this. If (num1 % 2 == 0) { num1++; } ElsIf (num2 % 2 == 0) { num2++; } else { Print "both are odd."; } But the problem is if the first number is even it doesn't even bother checking the second if statement. How can I force it to check the second one too?
&gt; or would it not work for some reason? Just run it and look at the results. Or better yet, use test module to write automated tests that will tell you if your program works correctly. You may need to assign `&lt;$fh&gt;` to `$_`; I forget if it does it automagically....
It does when it is alone in a while loop condition. `$_` doesn't get localized by this construct and you are vulnerable to `$_` being modified by code that you call, so I tend to use an explicit lexical variable anyway, but for this short snippet it won't make a difference.
`use warnings` and think about what happens when you use an uninitialized value as a reference. 
&gt; push @{ $hashOfArrays{$col1} }, $col2; Do you mean this line? If so, autovivification will take care of that (i.e. the script will work as-is, assuming valid input you'll get no warnings).
On top of that it's generally `use strict` that catches dereferencing of undef with an error.
When in doubt, `use strict` and `use warnings`. In fact, when not in doubt, `use strict` and `use warnings` :D
Is it possible to attend virtually ? I'm interested but I'm based in Canada :). Some of the topics are certainly pretty cool. ( Personally, using Perl with modern DevOps tools is what i'd like to learn as the literature is limited). 
yeah, the only issue with the code is the missing `my` when declaring the hash var.
It will work. The only gotcha may be when a line starts with a tab and `$col1` becomes undef. Best way of exploratory testing is use YAML; ... print Dump \%hashOfArrays;
I don't think they'll be set up to stream stuff live. But most of the streams (not the workshop stream, I believe) will be videoed an put online at a later date.
Specifically: think about it just working.
All good, apart from the fact that the first line should begin with `my` (or be left out entirely, but it does nothing the way you have it).
As Dave said, we're not live-streaming anything, but the three talk streams are all being recorded, and will be on YouTube eventually. They'll arrive piecemeal.
Alternatively, might it might work to point the script engine directly at C:\Strawberry\perl\bin\perl.exe ? 
(to save time: nothing about Perl; seems just post bot posting an article because it thinks all articles on the site are about Perl)
I'd be using fork (), no question. 
Look into [Minion](https://metacpan.org/pod/Minion). It might fit your need.
Would it be advisable to use this even though I'm not using Mojolicious?
Would memory usage be an issue? Would this method spawn another Perl interpreter? How about AnyEvent::Util's fork_call?
You can handle it by using minion‚Äôs interface, in theory. I have tried before, but I was pretty dumb to understand the API, thus I ended using Mojolicious/minions 
Honestly I haven't tried. But now that I think about it, it's probably not necessary. If you're deploying your app out of a Plack server that supports the psgi.streaming extension, you can just return a delayed response and periodically send an update back to the client to show progress. And as a bonus, if you're running it out of a non-blocking Plack server (like Twiggy or Feersum), and your code to talk to the People API is non-blocking, you won't need to worry about forking procs.
Seconding this. Minion is designed exactly for this case. You don't need to use mojolicious to use it, the mojolicious plugin basically just adds the minion commands for spawning worker processes and adds a helper to access an instantiated Minion object.
Make it work first, only optimise when / if you need to. 
For Perl my impression is that quite many distributions on CPAN do not have link to VCS, and the situation could be worse than Python... And I just found out this post of Neil Bowers http://neilb.org/2015/12/30/river-and-repo.html I wonder how much have improved since then...
haha so neat how you repeat the books over and over again like no one will realize that they're just the same thing. 
&gt; like no one will realize that they're just the same thing ‚Ä¶ Yes, he clearly wasn't prepared for a genius like you to come across and spot the trick.
Before I used a VCS, if I needed to update an older CPAN module, I'd download it from CPAN to edit because I oftentimes didn't have local copies sitting around. Those were dark times ;)
Nice. Just make sure to avoid false positives.
That's the part I haven't worked out yet :) But it'll probably be my next project for the whole ecosystem I've built up for it all after the next release of App::EvalServerAdvanced (finally finishing that up, took a while to figure out a sane architecture for the changes I made).
Fist name is andrew
Oh, sorry for the typo.
I am using it, and so far I am delighted, thank you! Since I am using elpa-stable, I have just cloned the repository. Do you have by chance a recipe for initializing it with `use-package`?
I think I have something: (use-package company :config (require 'company-plsense)) (use-package perl-mode :mode "\\.pl\\'" :config (defun al/perl-mode-hook () (add-to-list 'company-backends 'company-plsense) (company-mode 1)) (add-hook 'perl-mode-hook 'al/perl-mode-hook)) 
&gt; The branch coverage is 50% because the program is able to open a file correctly, so it never gets to die, but isn't this a good thing? Let's say you're thinking of buying a house. Someone suggests you should make sure it can handle a wide range of weather conditions. So you observe it over a one month period. The sun shines most days. It gets a little windy a few times. There's some rain too. The house does fine. Do you buy it? Who do you complain to if, a few years after buying it, an ordinary thunderstorm comes along and half destroys the house because it wasn't really weatherproof? Part of the point of testing is to catch what happens on the infrequent occasions when "sad" code paths are followed, not "happy" ones. Yes, that means doing weird code contortions that may be time consuming, all to test something that seems unlikely to ever actually happen, but, yes, it's a very important thing to do for most production code.
No I don't think that you've missed my point. I totally get why testing for multiple scenarios is important, and that was a great metaphor you used to reinforce it. But to expand a little more, in the above code the line that is giving me 50% branch coverage is this one: open(my $testFh, '&gt;', $testFile) or die "\nUnable to create file $testFile\n\n"; This line is part of the testing script, it's not being tested. Does this mean that I need to test my testing script? Ultimately I'd like to implement this one line while still having 100% branch coverage.
Test coverage is for the code under test, i.e. the code in Assignment6::MyIO. &gt; For an assignment I'm required to have the average branch length of all programs greater than 85%. It sounds like "all programs" does not include test files.
&gt; This line is part of the testing script, it's not being tested. Does this mean that I need to test my testing script? Gotchya. And if you test your test script with another test script, do you have to test that other test script to make *that* get 100%? Etc. &gt; Ultimately I'd like to implement this one line while still having 100% branch coverage. Maybe you're linking top marks in your assignment with 100% in branch coverage. If so, I recommend you read [Are test coverage metrics overrated?](https://www.thoughtworks.com/insights/blog/are-test-coverage-metrics-overrated). Maybe you're linking top marks in your assignment with avoiding getting 50% coverage of any individual file. If so, I think you should explicitly mention in your assignment report that you considered these 50% scores and the reasons for them and felt the disciplined response was to resist the impulse to fiddle to get to 100% and instead accept the wisdom in [Are test coverage metrics overrated?](https://www.thoughtworks.com/insights/blog/are-test-coverage-metrics-overrated): &gt; while a relatively high test coverage (perhaps in the upper 80s or 90s) would most likely manifest if proper testing is going on, a 100% test coverage should not be one of the targets we unequivocally work towards.
Unless you are planning to write a test for your test files, to exercise its branches, they should not be included in your coverage metrics.
you have to mock open and make it die to cover that in test. and expect the program to fail... there's ways to do that. you can get 100% coverage that way. but it's probably not worth it :)
You can avoid the problem entirely by removing this: # Creating file for testing. my $testFile = 'test.txt'; open(my $testFh, '&gt;', $testFile) or die "\nUnable to create file $testFile\n\n"; close $testFh; (and the unlink at the end), then replacing 'test.txt' with a call to File::Temp-&gt;tmpfile or equivalent instead.
You could use (use-package company-plsense :init (add-hook 'perl-mode-hook 'company-mode) (add-hook 'cperl-mode-hook 'company-mode) (add-to-list 'company-backends 'company-plsense))
Thank you very much, that looks much cleaner. Unfortunately something is not working with that, because I get an error saying that `company-backends` is not defined at `:init` time: Error (use-package): company-plsense :init: Symbol‚Äôs value as variable is void: company-backends I think I remember that I had something like that with the perl hook's, and that is the reason for my contrived multi-stage initial configuration that I posted. I am going to try with other system of mine to see if I get the same error with your snippet. 
I am a little surprised that worked because there doesn‚Äôt seem to be anything to trigger loading `company-plsense`. But if it works it works. To fix the void variable error you could also use (use-package company-plsense :init (add-hook 'perl-mode-hook 'company-mode) (add-hook 'cperl-mode-hook 'company-mode) (with-eval-after-load 'company (add-to-list 'company-backends 'company-plsense))
My exploration of function decorators/wrappers in Python, Perl 6, and Perl 5.
My organization flags this as an ‚Äúillegal site‚Äù
That's unfortunate. I wonder why?
My preferred way to do this sort of thing is still via [Class::Method::Modifiers](https://metacpan.org/pod/Class::Method::Modifiers), or the versions provided by Role::Tiny (and by extension Moo::Role), which allow you to apply them via a role. A role would only be able to apply the modifiers to specific methods in the class it gets composed into, but Class::Method::Modifiers::around and similar could be used procedurally on dynamic function names. This takes care of any redefinition issues, as well as allowing multiple sources to apply modifiers to the same method without conflict.
The way I did this before in Perl 5 (before discovering Python or their decorators and getting better ideas from that) was by creating a custom module to wrap around another module. In my case, I was needing to wrap some kind of `Apache::` module to make it Unicode-aware by translating inputs and outputs for a couple of its functions. My module's `new()` function would initialize the underlying module in its `$self` somewhere, and then define an `AUTOLOAD` function to proxy through all methods to the underlying module. For the couple methods I cared about, I would wrap my own logic around calling the `$self-&gt;SUPER::` versions.
This could be a good usecase for a role as I described in my other comment. For example: package My::Role::Wrapper; use Role::Tiny; around 'foo' =&gt; sub { my ($orig, $self, @args) = @_; ... # handle args my $result = $self-&gt;$orig(@args); ... # handle return value }; 1; Then to use it: use Role::Tiny (); Role::Tiny-&gt;apply_roles_to_object($obj, 'My::Role::Wrapper'); The modifiers get applied, and any other methods are left alone.
Out of curiosity, do you know what web filter your organisation uses? eg, Symantec? WebSense? McAfee?
My guess is that the software sees "0racle" as a malicious attempt to dupe the user into thinking it's Oracle.
I am aware of method modifiers like "around", but I though it was only applicable to class methods. Can they be used to add an "around" modifier to a normal subroutine?
Yes; when using the standard Class::Method::Modifiers functions, the modified subroutine is installed into the existing package. Roles of course only apply to classes.
Attribute::Handle&lt;ins&gt;r&lt;/ins&gt;s
Thanks, fixed.
Some especially interesting bikeshedding at the end of the thread on a revised "when" that will not have the ambiguity issues of the current implementation: separate keywords for testing a boolean expression and for applying a smartmatch matcher to `$_`.
I think IO::Async is the new method.
My main async mechanism is `IO::Select` which is a very thin wrapper around `select(2)`.
I find IO::Async and Mojo::IOLoop both preferable. I've used one or the other in all of the perl async I've done in the past few years.
No. It's at least a poor default choice. See my previous comment on the matter: https://www.reddit.com/r/perl/comments/732v1s/perl_on_the_rise_for_devops/dnnduvr/
Some weird downvoting going on in here... We use AnyEvent heavily at work and have had no issues with it. No reason why we chose AnyEvent over anything else. But honestly, it's EV that we rely on most. As long as whatever async libraries we're using can use EV as a backend (e.g. AnyEvent, Promises, and Mojo::UserAgent all do), it's all gravy.
AnyEvent and libev is probably some of the best software to have graced CPAN.
It's a great default choice unless you intend on using a completely different ecosystem, which seems to be your argument.
IO::Async has strong integration with Future.pm and at least one rx-style stream abstraction (Ryu::Async - disclaimer: I wrote this one). This makes composing async tasks much easier than with AnyEvent. Also, the AnyEvent author does not seem particularly enamoured with the core perl changes: http://blog.schmorp.de/2015-06-06-a-stable-perl.html so the future of the AnyEvent ecosystem (including Coro) seems somewhat unclear - *someone* is likely to patch the modules, see for example: https://www.nntp.perl.org/group/perl.perl5.porters/2017/11/msg247426.html but see also conversations such as https://rt.cpan.org/Ticket/Display.html?id=72637 which tend to put people off trying to communicate. I've had single processes happily dealing with several hundred thousand TCP connections and integrating SMTP, websockets, HTTP2, AMQP, Redis, PostgreSQL and talking to Slack+XMPP with IO::Async, and it's worked extremely well for that. Granted, I had to write several modules to get to that point - but IO::Async is a good framework for all those pieces to interact in. Worth also looking at POE, it imposes a bit more structure but has been around (and working!) for many years. There's a brief comparison of some event loops here: https://blog.afoolishmanifesto.com/posts/concurrency-and-async-in-perl/ 
No, my argument is that it's the worst default choice, by nature of every other choice being better.
What's EV?
&gt; I've had single processes happily dealing with several hundred thousand TCP connections and integrating SMTP, websockets, HTTP2, AMQP, Redis, PostgreSQL and talking to Slack+XMPP with IO::Async, Feck
http://software.schmorp.de/pkg/libev.html
This is timely for me. :) I'm used to writing stuff that does performs API calls, deals with MSSQL, etc, but now for the first time I'd like to be able to perform some of those tasks asynchronously. Example: given one value, look up information about that value in two different MSSQL databases at the same time as well as perform API calls out to eight different systems .. and I need to do that somewhere between 250,000 and 300,000 times. If anyone has any pointers, I'd sure appreciate it. 
Databases are usually the tricky part to this equation, because most of them have questionable async interfaces at best. I'm not sure about MSSQL's support in particular, but one option is to use the forked subroutine helper provided by the event loop you're using so the blocking query happens in a different process and you can wait on it in a non-blocking manner - such as IO::Async::Function or Mojo::IOLoop-&gt;subprocess. But you have to be careful not to share database handles between different processes, so make sure to use something like DBIx::Connector which will automatically check if a new handle is needed whenever it's accessed. If the API calls you are referring to are HTTP, then this is the easy part. With IO::Async, you can use Net::Async::HTTP and Futures to easily manage many non-blocking HTTP queries, and with Mojo you can use Mojo::UserAgent and its new promises similarly.
Thanks!
The MS SQL wire protocol is quite simple, but I'm not aware of any working implementations in Perl yet. Making a proper async-capable module that communicates with the server directly is not that hard, and it would be a nice addition to CPAN. Starting point is here: https://msdn.microsoft.com/en-us/library/dd304523.aspx For smaller volumes of data/queries, the forked or worker approach is easier, /u/Grinnz already covered the main ones (likely using DBD::ODBC or DBD::Sybase). There's also DBIx::Async for an IO::Async layer, but it's more of a proof of concept and doesn't really gain much over the forked approach. There's a few IRC channels that may be good for advice and discussion, try irc.perl.org #io-async and #mojo for example.
https://metacpan.org/author/TEAM - well, you're not wrong about writing all the adaptors. Nice work!
You should explicitly set it to 0 on travis anyway to override CPAN, cpanm and Test::Harness all flipping that to 1 internally if not otherwise set. You should be aiming for maximum perl breakage so you see problems before you're users do, and so your testing tools don't give you false positives when your code is still broken in production.
Oh, I did not know others also do that.
&gt; that means code that relied on "." will break when you upgrade to Perl 5.26. That is so typical, and yet *another* old wives' tale to remember, sweet. 
We're using POE for a long long time now. As others pointed out, the structure is very opinionated but the available modules out there are more than enough for our needs. For newer projects, we've began using AnyEvent. I'd say it's a little cleaner and succinct for my taste. Nowadays, I'm not updated with the latest and greatest. Our async usage covers tens of thousands of connections per process, both client and servers usage, across multiple protocols (HTTP, DB, Telco-protocols like SMPP/UCP). 
No, it's atypical. This is a security relevant change which trumps backward compat.
Lehmann is one of those very smart people who don't know how to work with others. AnyEvent is brilliant in many ways, but the author's actions have caused major disruptions for people who use his software. JSON::XS likewise has longstanding bugs that he seems to refuse to fix, such as the encoding of NaN/Inf/-Inf. I'd like to suggest using AnyEvent and Coro, but the author is untrustworthy when it comes to ensuring future support.
&gt; This is a security relevant change which trumps backward compat. What tipped the scale? This general class of attacks, with the prototypical example being your interactive shell $PATH, has been widely known since the turn of the century, and likely longer.
Nothing becomes urgent until someone takes the time to investigate and write up an exploit: https://rt.perl.org/Public/Bug/Display.html?id=127834
There are a plethora of ways that particular vulnerability could have been addressed without requiring breaking changes, simply by placing the blame for the vulnerability on the code that triggered it. ( And in the case of this vulnerability, the place it was discovered *did* patch it without upstream shipping a release ) Considering there are still literally thousands of Perl installs out there running 5.24 or older, and they also are exposed to this, and they are also ongoing production installations, and can't be upgraded (For the reasons of all the other things Perl breaks) Hence, people who are working in that environment will need to fix the broken applications anyway. The moral of the story is: # Don't execute privileged binaries from world writeable directories. # Don't have world writeable directories in `@INC` But the change in Perl addresses neither of these problems.
Thank you. 
Thank you. 
This is what I try and probably fail to get across. I may avoid his modules personally because I don't like his behavior, but I suggest to others to avoid his modules because his behavior leads to real issues in production. The exception being EV, since it has so far not had any major problems and has no good alternative yet.
There's an old saying in perl5 - I know it's in perl6, probably in perl5 - that says, fool me once, shame on... shame on you. Fool me - uh, you can't get fooled again.
And `.` was removed from $PATH in shells ages ago.
Just like in the current P5P smartmatch discussion, naming is the hardest part.
As it turns out I was incorrect in my assessment. Travis itself does not set the environment variable. I just saw the effects of Test::Harness. Now that is even less clear to me why Test::Harness does this. In any case the travis configuration, at least for now, can fix this.
You are missing a `/` on your first line. Take the `#` off the LOOP label.
I did not watch the video. * In line 6-7, 30-31 there is opportunity to use the `say` function (eliminates `\n`) or perhaps a heredoc (eliminates multiple `print` statements). * In line 9 and 10 you accidently ask for a number outside the verification loop. Eliminate this. * In line 11 there is opportunity to use the `..` operator for an integer range: `my @number_choices = 1..4;` * It is better to write `foreach my $num (@number_choices)` so that `$num` has the smallest possible scope. Eliminate the declaration in line 13. * The `$found` variable is superfluous, eliminate it. Simply use an infinite loop `while() { ‚Ä¶ }` and conditionally jump out of it with `last`. * If you want to compare whether a thing is one out of some other things, use a hash instead of an array. You completely eliminate the `foreach` loop: my %choices; @choices{1..4} = (); # line 11 last if exists $choices{$number_chosen}; # lines 21-29 * Since there are no nested loops any more, eliminate the jump label. * Use `&lt;&gt;` instead of `&lt;STDIN&gt;`. That makes it possible to automate your program with `perl cootie.pl someinputfile`. ---- Altogether: #!/usr/bin/env perl use 5.026; use strictures; say &lt;&lt;''; Welcome to the Fortune Teller Please follow the directions to learn your future my %choices; @choices{1..4} = (); while () { chomp(my $input = &lt;&gt;); last if exists $choices{$input}; say q(I'm sorry, that number is not valid.); say 'Please pick a number: ' . join ', ', sort keys %choices; } An expert would use a module such as [IO::Prompter](http://p3rl.org/IO::Prompter) instead of all that input handling code.
It was worth it for the Node.js team to write their own version of libev (that's libuv) in order to free themselves of the author. That was a seriously non-trivial amount of work to do so. So just keep that in mind. Relatedly there are again recent efforts to get good UV bindings in Perl. Once they work, I'm sure Mojo::IOLoop will support them very quickly in order to give our users a choice of native-speed IOLoops.
&gt; Luckily Perl is able to represent all Unicode characters in a simple, readable, ASCII encodable way: You can use the \N{...} sequence with the official name of the character So... Perl has a mapping of all [280k](http://www.babelstone.co.uk/Unicode/HowMany.html) odd Unicode characters and their "official names"?
Yes; see https://metacpan.org/pod/charnames (needs to be explicitly enabled before 5.16)
Test::Harness does this because if it didn't, 30% of CPAN would have started failing their tests under both vanilla "make test" and "./Build test" With this, that problem doesn't happen, with the risk becoming "your code passes tests, but it might be broken in production" ( which I'm sure sounds like a delightful tradeoff )
I love getting my holiday Mojo on.
&gt; Also, the AnyEvent author does not seem particularly enamoured with the core perl changes You're saying he's sensible and dislikes existing software being broken? Gosh. What a thing to object to.
&gt; It was worth it for the Node.js team to write their own version of libev (that's libuv) in order to free themselves of the author. Could you expand on this? The evidence I could find shows that they had specific technical reasons for doing their own thing: https://github.com/joyent/libuv/issues/485 The technical reasons could be wrapped up in personal issues with the author--I could easily see that happening--but it's not obvious that was the case.
"Sensible" isn't a word I'd use when someone chooses to fork the language rather than working with perl5.porters! Anyway, I'd prefer to stick with the CPAN options that have public bugtrackers and a willingness to adapt to changes in new perl releases. If AnyEvent is working for people, that's great - but I can't recommend it myself.
I solved this with Docker
&gt; willingness to adapt to changes in new perl releases That presumes that the nature of the change is actually possible to circumvent in 3rd party code. When P5P makes C call private instead of visible, there's only so much you can do about that from calling code, and have it continue to deliver on the promise the code made. When P5P does so to save an insignificant amount of memory .... You really have to wonder which party is the insane one.
So you can use any letter of your choice as `$^√æ`, with the same behavior of `$a` and `$b` in perl, right?
You may disagree with the decision, but calling people "insane" is unnecessary and offensive. Please stop.
Great! Mojo makes so many tasks so easy...
I believe https://metacpan.org/pod/local::lib should work with any CPAN installer, including cpm/cpan/cpanm/pancake.
Sure, I'm not sure if it uses unicode collation ordering or just byte order to assign parameters to vars. But `$^a` and `$^b` are what most people use still.
True, but it is convenient that cpanm (and cpm) have this switch to decide what local::lib to use on the fly. It also should be noted that you can use local::lib itself to update the correct environment variables to use a particular lib dir, rather than manually setting PATH and PERL5LIB.
I'll be honest: as soon as I start seeing Unicode characters I stop reading. If I can't type it into my keyboard then it doesn't have any relevance to me.
Sorry, I couldn't find a better antonym for "sensible" 
It is possible that I have been misinformed. It is also possible that the official record didn't need to mention the author of ev when there were sufficient technical merits. Thats said, you are right that I'm essentially repeating gossip and I shouldn't do that.
I prefer [Carton](http://search.cpan.org/perldoc?Carton). It's like Ruby's bundler or npm, where each project has a copy of its dependencies.
Another great way to use local::lib. Carton's main benefit is that it pins the versions of the whole dependency chain (not just the dependencies you declare but their dependencies and so on) so installing your dependencies later will always use the pinned versions unless you update them.
I've found the APL programmer!
It just makes zero sense to me. Programmers use a common interface to do their job: A keyboard. I'm not aware of any keyboard that supports unicode characters, and if it exists I'm not sure if I can fit enough `0`s in this comment to write the percentage of devs that have it. One person behind the [atomic operator](https://p6weekly.wordpress.com/2017/08/21/2017-34-going-atomic/) defended it by saying there's an ASCII alternative in the form of the less-unwieldy-but-still-crap `atomic-fetch-dec()`, `atomic-inc-fetch()` and so on. It's just a bad overall decision IMO.
&gt; It just makes zero sense to me Dunno, with some ops, e.g. powers, `say 4¬≤`, it take fewer keypresses to write on most Linux systems with XCompose than writing `4**2`. Seems a win both in typing and readability, no? And if standard compose sequences are too much, you can bind all of these to, say, AltR+{some single key} and have less things to type than ASCII versions too. Less stuff to type + less stuff to read = makes sens to me. &gt; It's just a bad overall decision IMO These routines are rarely needed, though, right? Seems like descriptive names like `atomic-fetch-dec` are a far better choice than, say, `afedec`
&gt; with the same behavior of $a and $b in perl In some sense, but not really. In Perl `$a` and `$b` are magical variables in used in sort. In Rakudo Perl 6, `$^a` and `$^b` are regular variables (in fact, after the first use, you can even drop the twigil and use `$a` and `$b`) and the twigil just indicates the containing block has an implied signature. You're not limited to just two variables, they can have any name, and you can use them in any blocks or subroutine. There are also `$:a` and `$:b` twigil for implied *named* parameters: { say "$^d $^a $:foo $:bar" }(1, 2, :42foo, :70bar) # OUTPUT: 2 1 42 70
&gt; Dunno, with some ops, e.g. powers, say 4¬≤, it take fewer keypresses to write on most Linux systems with XCompose than writing 4**2. Seems a win both in typing and readability, no? For users who are part of that specific scenario sure, it's a win as far as fewer key strokes. But isn't that a pretty small number of devs in today's world? I'm sure more Perl 5 devs land in that group, but Perl 6 is a modern language that I assume is targeting modern use cases and developers. That increasingly means non-Linux. From what I can see you need to jump through hoops to use compose keys on Mac, and Windows is Windows. The [Perl 6 Wiki](https://docs.perl6.org/language/unicode_entry) doesn't seem to have solutions for Mac or Windows either. &gt; These routines are rarely needed, though, right? Seems like descriptive names like `atomic-fetch-dec` are a far better choice than, say, `afedec` Sure, and maybe I should have phrased it better. If the atomic operator implementation is a sign of things to come, I think it's a bad decision. Having a concise representation for an operation is convenient, but outside of smaller, likely single-user, projects I can't see them catching on. In a shared code base you would either wind up with mixed unicode and ASCII operators, forcing people to use a clunky input sequence for unicode ops, or only the ASCII(likely clunky in it's own way) operators. 
&gt; From what I can see you need to jump through hoops to use compose keys on Mac, and Windows is Windows Hm... No idea. I have [Corsair K95 RGB keyboard](https://www.amazon.com/Corsair-Mechanical-Keyboard-Aircraft-grade-Multicolor/dp/B014W1Z4S0) on my Windows box and I just mapped the G keys to the Unicode ops. So all of them are a single keypress and even easier to use than XCompose on Linux. Never had to use a regular keyboard on Windows so no idea what's involved in typing Unicode. &gt; In a shared code base you would either wind up with mixed That probably applies to any construct. `for @a {‚Ä¶}` vs `‚Ä¶ for @a`; if` vs `unless`, etc. I recall drforr++ working on Perl6::Tidy and since it's aware of what's an operator, etc, it would be able to just rewrite Unicode `&lt;-&gt;` ASCII ops for consistency. I imagine companies with several devs would develop some policy for which ops to use, same as other stylistic choices, and if they choose Unicode ops, they'd offer standard setup instructions to go with them, so all devs have their boxes setup for most convenient way to use them. Dunno. To me, the Unicode ops look to be a lot easier to read and I read code a lot more than write it. There's only so much you can do with ASCII characters before you get to monstrocities like `!(&lt;=)`. The `‚äà` is so much clearer by comparison and if you get over the initial barrier of figuring out how to conveniently write Unicode chars, overall these look to be a win.
&gt; That probably applies to any construct. for @a {‚Ä¶} vs ‚Ä¶ for @a; if vs unless etc. Of course, but all of those are easily typed on the popular OS's. The difference here is that developers on Mac and Windows are likely incapable of easily/conveniently typing the unicode. &gt; I recall drforr++ working on Perl6::Tidy and since it's aware of what's an operator, etc, it would be able to just rewrite Unicode &lt;-&gt; ASCII ops for consistency. That's a valid option. &gt; I imagine companies with several devs would develop some policy for which ops to use, same as other stylistic choices, and if they choose Unicode ops, they'd offer standard setup instructions to go with them, so all devs have their boxes setup for most convenient way to use them. One would hope. I had open source projects in mind primarily. &gt; Dunno. To me, the Unicode ops look to be a lot easier to read and I read code a lot more than write it. There's only so much you can do with ASCII characters before you get to monstrocities like !(&lt;=). The ‚äà is so much clearer by comparison and if you get over the initial barrier of figuring out how to conveniently write Unicode chars, overall these look to be a win I can see that perspective. There's a limited number of ASCII combinations that remain readable. I'm dreading having to decipher what various unicode symbols are intended to communicate. Even something like ‚öõ, that should obviously be an atom, can have issues. It looks like a snow flake 90% of the time I run across it.
The square brackets (`['empty']`) indicate a reference to an array. The extra backslash indicates a reference. Combined this makes it a reference to a reference to an array. If we dereference it, we get a reference to an array: my $var = \["empty"]; print Dumper($$var); Which outputs: $VAR1 = [ 'empty' ]; This might look a bit more familiar. To get the string, we can use the first element of that arrayref: my $var = \["empty"]; print Dumper($$var-&gt;[0]); But I've got no idea if you would alway want the first element of the reference to the reference of the array. If that was the case, this construction feels incredibly complicated.
I found a solution that worked, but i couldn't get your solution to work. I guess i did it wrong. I get my string from my $File = $Param{GetParam}-&gt;{MyValue}; my working solution was: Image = @{($Image)[0]}[0]; What i thought you said i should to is: $File = $$File-&gt;[0]; Buts This doesn't work. You see the way i get my File, how would i add to that to get my string directly? It's always this one Value in "MyValue", never more, so i alway only need that first entry. Thank you for your input so far
Thanks! What about the unicode ordering that u/MattEOates mentioned? I imagine I can previously sort two strings to know the relative order between the symbols, but is there a more convenient way? 
${$VAR1}[0] Should do it
If you have the option to save to manually convert from .docx to .odf (Open office format) first, you might be able to use [PDF::Create](http://search.cpan.org/~manwar/PDF-Create-1.43/lib/PDF/Create.pm) and [OpenOffice::OODoc](http://search.cpan.org/~jmgdoc/OpenOffice-OODoc-2.125/OODoc.pod). That's all I could find on CPAN. Disclaimer: the only Office thing I've ever done with perl is create Excel sheets.
Honestly I'd do it with LibreOffice. It can export any document as pdf.
If you have LibreOffice, use the option --convert-to pdf *.doc
If you get to the point where you aren't sure of the order of the placeholder parameters, it might be time to switch to a pointy block. my &amp;foo = { $^√æ ~ $^a } my &amp;bar = -&gt; $a, $√æ { $√æ ~ $a }
I want to do dozens of files at a time and therefore need a way to automate this conversion using Perl.
Yeah I mean this answer is the correct answer 100%. Out of curiosity Id love to know if the parameters use collation or not. But if you are *ever* in the position of not being sure you're abusing that language feature for sure. 
If a directory contains a bunch of .doc files, navigate into it and, libreoffice --convert-to *.doc
You realise you can just add an automator/applescript as a directory action on file create?
What about testing this? Might be a good idea anyway...
do I need to do anything special to get this to work? no matter where I run it, I get the error: -bash: libreoffice: command not found (yes, I have LibreOffice installed)
The test for OS and google Drive load at the bottom . . . makes me suspicious of viruses, so no way I'm going to run it. Why are 1 and 2 and 2 (instead of 1 and 2 and 3) in the prints/choices in the menu? (Just for my personal sanity) . . . pull all your global "my" variables to the top. Put the main program next, and all the sub(routines) below the mainline. And I'd get rid of the menu subroutine, and just put the while loop in the mainline. I can't tell from what I see above, if you just press enter and don't pick 1,2,3 . . . wouldn't it just fall out the end of the mainline after the &amp;game(); call? Maybe that's what you're seeing.
Make sure it's in your path. My version at least installs a binary named 'libreoffice' with a manpage that looks like: http://manpages.ubuntu.com/manpages/trusty/man1/libreoffice.1.html
Get your bikeshedding in now; the current branch replaces the ambiguous "when" with "whereso" for boolean tests and "whereis" for smartmatch tests. https://www.nntp.perl.org/group/perl.perl5.porters/2017/12/msg247764.html
While I agree with him that RT sucks, I've been using not-RT for a couple years now with no problems, by indicating in my metadata that I prefer github. And gosh, they managed to make a mailto link valid as a bugtracker in the metadata (even though I don't consider email a valid bugtracker) and make RT, search.cpan.org and metacpan.org respect it all for him, but he still doesn't use it.
Your using the menu subroutine like a goto label statement, which is horrible practice In general, and this example is one of the more common reasons why. When you are calling menu, it's not starting at the menu subroutine and continuing down to the if statement that spawns a game, it's just ending where it was at the line you called it and continuing with the program, causing it to end. Like the other responder stated, put the whole thing in a while loop with the menu display and selection prompts at the top of the loop. 
You should just be able to do: my $file = $Param{MyParam}-&gt;{MyValue}[0];
I'm aware, I was part of the conversation that made sure that provision was there ;) However, I believe from his perspective that's the need to "opt-out", and the effort for him to change a wide number of distributions, and ship releases, just to opt-out, when he never opted in, is a lot of work to countermand a problem he never consented to be part of in the first place. Its easier for him to simply set an auto-responder to everything from RT as a way to opt-out. And of course, the way our permissions model works means it might not be otherwise viable to have a single switch to flip that says "For all my stuff, RT can go to hell". But the way he's implemented his approach does just that.
Hi, system($ENV{VERDI_HOME}="P/hdk/rtl/cad/L-2016.06-SP2-3"); is not working..its giving below error can't exec "P/hdk/rtl/cad/L-2016.06-SP2-3": No such file or directory 
You don't need lookahead/lookbehind. Simple regexp like this is all You need: var str="&lt;li&gt;test - this is a stop that is tested...&lt;/li&gt;"; var extract = str.match(/\&lt;li\&gt;(.*)\&lt;\/li\&gt;/).pop(); document.write(extract); Now You simply test if the variable 'extract' contains Your word stop... if ( new RegExp('\\bstop\\b').test(extract) ) { console.log("ok"); } else { console.log("NO"); }
That doesn't look like a full path. Should start with / So /P/hdk/...
Thank you, that should do it, and it's pretty simple. It would work for me in a loop, since i have several li-tags, but only one that should match. But the lookbehind/lookahead would be a bit more efficient, right?
thanks, i'll try that
 #!/usr/bin/perl use feature 'say'; my $str = q{&lt;li&gt;This is a list item&lt;/li&gt;}; say $1 if $str =~ /(?&lt;=\&lt;li\&gt;)(.*)(?=\&lt;\/li\&gt;)/; prints "This is a list item"
That doesn't look like Perl to me :-)
me either.. 
No it isn't. It is pure javascript, but since the question was about RegExp, then any script language that works with RegExp will do to explain the solution. And I'm far better at JavaScript than Pearl... 
With the caveat that parsing HTML with regexes is a really bad idea... #!/usr/bin/perl use strict; use warnings; use feature 'say'; while (&lt;DATA&gt;) { chomp; if (m{&lt;li&gt;(.*?\bstop\b.*?)&lt;/li&gt;}) { say "$_: Got '$1'"; } else { say "$_: No match"; } } __DATA__ &lt;li&gt;something&lt;/li&gt; &lt;li&gt;some stop text&lt;/li&gt; &lt;li&gt;embeddedstop&lt;/li&gt; &lt;li&gt;stop first&lt;/li&gt; &lt;li&gt;last stop&lt;/li&gt; &lt;li&gt;stop&lt;/li&gt; 
Well... not much. The most inefficient about the example I gave You is that You do the extract and then do a test on the extracted text. This two-step solution will be time consuming but we are talking about a few milliseconds here so unless Your program is REALLY dependent on saving every milliseconds I would guess it really doesn't matter. To me it is much more important (usually) to keep code clean and easy to understand. This will make the code easier to maintain when coming back to it after 6 months and trying to figure out what the code actually do...
Try [HTML::TreeBuilder](https://metacpan.org/pod/HTML::TreeBuilder) or [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM) instead. my @matches = $html-&gt;look_down(_tag =&gt; 'li', sub { $_-&gt;as_text =~ /stop/ }) 
setenv VERDI_HOME /p/hdk/rtl/cad/L-2016.06-SP2-3" is working fine..but when i am using in system , it is giving me the error 
Yes, you don't need system. 
Well, regex implementations can often vary in surprising ways. And, while I have your attention, would you mind editing your answer to insert four spaces at the start of each of the lines of code. It will then be far easier to read.
$ENV(VERDI.HOME="/P/hdk/rtl/cad/L-2016.06 SP2-3/..."
Ah... of course! Done! Yeah - the implementation can vary but usually not that much that You don't understand what the code should look like in each language.
yeah, without system it is not giving any error but problem is that environment is not getting set up. also i am running multiple scripts, so i am using system. 
This function will return the value of Mojo::IOLoop-&gt;start; You have to keep MyAPI::User-&gt;new( json =&gt; $tx-&gt;res-&gt;json ) in an variable which is declared before $self-&gt;ua-&gt;get.... and returned after Mojo::IOLoop-&gt;start. 
I tried this rewrite: sub fetch { my $self = shift; my $user = undef; $self-&gt;ua-&gt;get( 'http://myapi.com/?user_id=' . $self-&gt;user_id =&gt; sub { my $ua = shift; my $tx = shift; $user = MyAPI::User-&gt;new( json =&gt; $tx-&gt;res-&gt;json ); } ); Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running; return $user; } While this works, it's definitely _not_ non-blocking.
Obligatory link regarding parsing HTML with regular expressions: https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
You can't magically stick non-blocking code in the middle of blocking code and have it work out, unfortunately. The non-blocking workflow is that values are "returned" to callbacks, which are called once that information is available (once the request completes). The functions will actually return immediately, before this is available. Consider using the [new promises](https://metacpan.org/pod/Mojo::Promise) in Mojolicious 7.52 or newer to make this a bit simpler to reason about: sub fetch { my $self = shift; return $self-&gt;ua-&gt;get_p($url)-&gt;then(sub { return MyAPI::User-&gt;new(json =&gt; shift-&gt;res-&gt;json); }); } This version of fetch will return a Mojo::Promise, which the caller can attach a -&gt;then handler (to render a response with the user object, for instance) and/or a -&gt;catch handler to handle the case where there's a connection error. If you are calling this version of fetch from a running ioloop, like in mojolicious response handlers, then the loop will make the request and call the subsequent callbacks when appropriate. If you aren't, you can call -&gt;wait on the promise to run the loop (blocking the current code) until it's ready. The key is that if you want the code to be non-blocking, you can't have it wait for a response, because this is blocking behavior. You must instead tell it what to do when it gets the response.
I use it in otrs where, as far as i know, you're supposed to use it to change the html Output, that is pretty regular. The post doesn't quite explain what exactly is wrong with that, or did i just not get it?
Why?
or to do davorgs solution in one line... #!/usr/bin/perl my $htm=&lt;&lt;ENDDATA; &lt;li&gt;something&lt;/li&gt; &lt;li&gt;some stop text&lt;/li&gt; &lt;li&gt;embeddedstop&lt;/li&gt; &lt;li&gt;stop first&lt;/li&gt; &lt;li&gt;last stop&lt;/li&gt; &lt;li&gt;stop&lt;/li&gt; ENDDATA print join("\n",($htm=~ /&lt;li&gt;(.*?\bstop\b.*?)&lt;\/li&gt;/g));
The point is that HTML is heirachial, the content of inner sections is modified by containing context, regexps don't handle that, and from a strictly logical perspective there will always be edge cases you haven't thought of due to HTML being non-regular.
A Mojo::DOM example: my @matches = $dom-&gt;find('li')-&gt;grep(sub { $_-&gt;all_text =~ /stop/ })-&gt;each;
The problem with this solution is that regexes are greedy. They will match as much as possible between the &lt;li&gt; and the &lt;/li&gt; you specified, including other &lt;li&gt; and &lt;/li&gt; tags. Changing `.*` to `.*?` would solve that part, but better still would be to use an HTML parser that understands how HTML works, so you can handle &lt;li style=...&gt; and &lt;a href="/stop"&gt; and &lt;span data-tag="&lt;li&gt;"&gt; and infinite other edge cases that will break your regex.
This isn't non-greedy enough, unfortunately. If you add enough tests with nested &lt;li&gt; tags you will find that it will match starting from the *first* &lt;li&gt; past any closing &lt;/li&gt; tags if it's able to find 'stop' there followed by another &lt;/li&gt;. It won't subsequently shorten the left side of the match to the closest &lt;li&gt; tag. Regexes are only good at going left-to-right.
It's a bit hard to read the way that you formatted it, but it doesn't look like you ever called your subroutine.
I have sub guess_my_number { } Is it wrong?
You're right, of course. I thought the `.*?` would handle that - but forgot to test it. I guess that neatly demonstrates why you shouldn't parse HTML with regexes.
Add this as another example to the list: &lt;li&gt;something &lt;li&gt;with stop&lt;/li&gt;xxx&lt;/li&gt; And you'll see where my solution breaks down.
Could you please edit your question so all of the code is formatted as code (add four spaces at the start of the code lines).
Is that better?
[removed]
It's certainly better, thanks. It's still not completely right though, is it?
Not sure. Can you see my errors in the code?
Your code basically boils down to this: sub guess_my_number { ... } exit; You have defined a subroutine, but you never actually call it. Try changing your code to this: sub guess_my_number { # your existing subroutine code here } guess_my_number(); # call the subroutine exist; Also note, it looks like you have `use strict` and `use warnings` before your shebang line (`#!/usr/bin/perl`). The shebang line should be the first thing in your file.
It's not wrong. But it's not enough. That defines the subroutine. You need to call it too.
Thank you for your help. Does that second part go at the end of the code above 'exit;'?
Your code basically boils down to this: sub guess_my_number { ... } exit; You have defined a subroutine, but you never actually call it. Try changing your code to this: sub guess_my_number { # your existing subroutine code here } guess_my_number(); # call the subroutine exit; Also note, it looks like you have use strict and use warnings before your shebang line (#!/usr/bin/perl). The shebang line should be the first thing in your file.
Sorry, that `exist` was a typo for `exit`. I shouldn't answer questions so early in the morning. I also posted my answer in reply to a deleted answer - so I've deleted it and reposted a corrected version in the right place. Sorry for any confusion caused :-/
See, now you've added more code and haven't formatted it properly again. Formatting your code makes it far easier for people to understand what you are asking. And that, in turn, makes it more likely that they will help you. It's really worth making the effort to get this right.
I totally agree... The potential existence of attributes in the HTML tag didn't crossed my mind when I came up with the solution. Good catch! Yes, finding a HTML parser would be a better solution!
the &lt;li&gt; is given out by a template file. As long as there isn't a version update where they change something it's always exactly the same. In case of a new version is have to check what all changed no matter what. my "stop" is an image tag with a defined source. I don't actually look for the string "stop", but for '&lt;img src="xxx" ' Again, since it is in the template file, those parts will always look the same. But i get the problem if you don't have such a regular output
So what you're saying is that the solution you're implimenting is fragile even in the face of normal valid HTML changes to the parse target. Remember: Produce code that you would be happy to faultfind without content when starting a new job. I.E. an HTML parser is always a better idea.
Maybe i explained my problem not good enough, but i can see no point of failure in my solution. The HTML Code i use the regex on is generated by templates in templates files, which are not going to be changed. Either a template is being used and it copies some of the code with values inserted, or the code part is not there. There will be only one case in which i have &lt;li&gt;...&lt;img src="xxx"...&lt;/li&gt; in that case i delete the whole thing. If you see a case of failure, could you give me an example, so i can understand it better? Thanks
&gt; which are not going to be changed. Ever? You're absolutly certain that responsibility for that template will never ever be given to anyone other than you? No one will _ever_ want to alter the class structure or markup of that template? Because I couldn't make that promise about any product I'm responsible for. Writing fragile code (Which this is, because it can be easily broken with valid HTML input) is simply bad practice, defensive programming is a skill that is very much encouraged. what you're proposing is just plain bad practice, regardless what you _think_ is happening right now, you have a document that is not regular language ( https://en.wikipedia.org/wiki/Regular_language ) and already has many many good parsers available, so don't try to process it using regular expressions. Use the right tool for the job.
**Regular language** In theoretical computer science and formal language theory, a regular language (also called a rational language) is a formal language that can be expressed using a regular expression, in the strict sense of the latter notion used in theoretical computer science (as opposed to many regular expressions engines provided by modern programming languages, which are augmented with features that allow recognition of languages that cannot be expressed by a classic regular expression). Alternatively, a regular language can be defined as a language recognized by a finite automaton. The equivalence of regular expressions and finite automata is known as Kleene's theorem (after American mathematician Stephen Cole Kleene). In the Chomsky hierarchy, regular languages are defined to be the languages that are generated by Type-3 grammars (regular grammars). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
If i understand you correctly you mean someone could change the html template to still be valid, but different enough that my regex wouldn't find it, right? like changing &lt;img="XXX to: &lt; img src = "XXX right? That's still something i can catch with regex. A Parser would do nothing else but finding the &lt;li&gt;, &lt;/li&gt; and &lt;img tag, and i had to remove everything in between. So the HTML Parser would do nothing else then i would do with my regex. &gt; Ever? You're absolutly certain that responsibility for that template will never &gt; ever be given to anyone other than you? &gt; &gt; No one will ever want to alter the class structure or markup of that template &gt; (Especially front end people who have no visibility of the perl code you're writing)? Everyone with admin rights can change the templates, as much as he can change my code or the whole code of the software. But nobody is supposed to change the templates, because that could interfere with modules from other thirdpartys. Instead a third party is supposed to change the HTML code with an output filter.
How about &lt;li class="fish" id="menu-thing"&gt; or &lt;img class="thing" src="dog"&gt; What if the work "stop" ends up being used in a class name, etc etc it just keeps going on. because you're using the wrong tool for the job &gt; A Parser would do nothing else but finding the &lt;li&gt;, &lt;/li&gt; and &lt;img tag, and i had to remove everything in between. Depends how you use the parser and which parser you use, I'd use a pull parser, copy to the output stream and stop-and-buffer when I hit an opening &lt;li&gt; (which would be found regardless of cosmetic changes to the markup of the tag) output the buffer when I hit the matching closing tag or drop the buffer if I see the kill data in the right place (not just any old text in the markup) &gt; But nobody is supposed to change the templates, because that could interfere with modules from other thirdpartys It sure will do if they're using regexps to make substitutions. &gt; Instead a third party is supposed to change the HTML code with an output filter. Cool, then parse the HTML to filter it 
&gt; A Parser would do nothing else but finding the &lt;li&gt;, &lt;/li&gt; and &lt;img tag, and i had to remove everything in between. Incorrect; the parser tokenizes the whole HTML, so you can find exactly the parts you're looking for and put them together however you need. See the top comments on this page for examples.
Great question. I started perl very recently. Thanks for the help, it's working!
Depends on whether you want to read input from other sources afterwards. A common idiom for reading a whole file for example is without affecting the separator for other input sources is this: my $content; { local $/; $content = &lt;FH&gt; } Note that a new scope is started and the input record is localized and undefined inside it. FH is then read till EOF. Outside the scope /$ is reset to its default value so it won't have any weird effects if you read front another handle sometime later. So it's always advisable to localize changes to the separator to avoid confusion and weird effects later or in other places you don't control like used modules.
If I changed the record separator within a subroutine would it be redundant to use local? Or would I actually be changing the record separator globally?
It's a global variable, so changes to it are by default global. The local keyword means that changes to the variable are only valid inside the current scope, so when leaving the scope it's reset to it's former value.
I would use a hash on the pin name. Something like use strict; use warnings; my %pinout; while(&lt;DATA&gt;) { chomp; my ($dir, $pin, $size) = split(' '); ($size,$pin) = ($pin,$size) if $size; if(exists $pinout{$pin}{dir} &amp;&amp; !($pinout{$pin}{dir} eq $dir)) { $dir = 'inout'; } $pinout{$pin} = {'dir' =&gt; $dir, 'size' =&gt; $size}; } for my $p (sort {$a ge $b} keys %pinout) { print join(' ', $p, $pinout{$p}-&gt;{dir}, ($pinout{$p}-&gt;{size} or '')), "\n"; } __DATA__ input x output y output x inout z input [2:0] t inout [3:0] j
&gt; sort {$a ge $b} keys %pinout This should be {$a cmp $b}, which is the default comparison sort uses anyway.
When in doubt, localize any change to global variables. The only time not to is if you explicitly want to affect something outside the current scope, like when setting signal handlers for other parts of the code.
Oh, yes, I forgot that lexicographical is the default sort. I usually have lists of numbers, so I always forget about the string side of things.
But similar to the other example but I'd go fancy with a named regex and preserve the file order. use strict; use warnings; use English; use v5.10; my %pins; #Read lines from files given as cli arguments while (my $line = &lt;&lt;&gt;&gt;) { #Trim the newline chomp $line; #Use a named capture regex to breakup the line into tokens populating %+ $line =~ /(?&lt;io&gt;input|output|inout) (?&lt;size&gt;\[[^\]]+\] )?(?&lt;name&gt;.)/ or next; my $pin = $LAST_PAREN_MATCH{name}; if (exists $pins{$pin}) { #Handle the case of promoting to 'inout' if we've already seen one of the other directions $pins{$pin}{io} = ($pins{$pin}{io} ne $LAST_PAREN_MATCH{io}) ? 'inout' : $pins{$pin}{io}; } else { $pins{$pin}{io} = $LAST_PAREN_MATCH{io}; #Keep track of the first line we saw this pin name and treat that as the output order $pins{$pin}{sort_order} = $INPUT_LINE_NUMBER; } #Overwrite the size each time with the last seen pin $pins{$pin}{size} = $LAST_PAREN_MATCH{size} || ''; } #For the pins in the original order we first saw them in the file foreach my $pin (sort {$pins{$a}{sort_order} &lt;=&gt; $pins{$b}{sort_order}} keys %pins) { say "$pins{$pin}{io} $pins{$pin}{size}$pin"; }
You're gonna want a `use v5.22` for that `&lt;&lt;&gt;&gt;` operator. (Unfortunately it does not look like its documentation mentions when it was introduced.)
for bonus points: my $content = do { local $/; &lt;$FH&gt; }; (don't use bareword filehandles).
Should probably go less secure for backcompat then :P I'll change it now. Yeah the docs don't mention when it was introduced, plus there is no warning or error using it use v5.10 either which is a little odd.
use v5.10 just requires that version or greater and enables features for that version, &lt;&lt;&gt;&gt; doesn't require a feature to be enabled so it just works or it doesn't. And yeah unfortunately there's no way to get the magical effect of &lt;&gt; with three-arg open without it, except to write out the logic with opening each filename yourself.
eq is case sensitive, so what you wrote should work. But ucfirst doesn't operate in place, so you need to assign it back to $word.
As another way to do it, regular expressions would probably be your friend here. Something like the below should work: $word =~ s/(\w)(\w+)/\u$1$2/;
got it. thanks
Yeah I guess Im used to be nagged by EXPERIMENTAL for any new feature :) A pleasant change! 
Pardon if I'm being daft, but .... why does it matter if you `ucfirst` a word that's already uppercase: for my $word ( qw ( reddit Reddit REDDIT ) ) { print ucfirst $word, "\n"; } Because in all but the first case, `ucfirst` doesn't change anything. 
I just want to sentence case all words but ignore uppercase words
I'm not really following. Why does: #!/usr/bin/env perl use strict; use warnings; while ( my $line = &lt;DATA&gt; ) { print ucfirst $line; } __DATA__ the quick brown Fox jumped OVER the lazy dog Which gives: The quick brown Fox jumped OVER the lazy dog Not do what you want? 
I think you might be falling into a surprisingly common misconception here. `ucfirst` does exactly what its name suggests. It only affects the first character of the string. In training courses, I often come across people who believe it converts the first character to uppercase and all other characters to lowercase. It doesn't. It changes the first character to uppercase and leaves all the other characters alone. All of which means that: $word = ucfirst $word; is **exactly** the same as: $word = ucfirst $word unless $word eq uc $word;
&gt; I often come across people who believe it converts the first character to uppercase and all other characters to lowercase. It doesn't I see, that's useful to know. Thanks
Davorg has captured succinctly the trap I've fallen into.
The regex here isn't needed, but \u works in any double quoted string and does the same thing as ucfirst. So you could just write: `$word = "\u$word"` or interpolate "\u$word" into a string somewhere later.
Didn't know that :) time to go and refactor some of my old projects 
Thanks, didn't know that :) 
You possibly want the `//s` modifier instead/as-well, otherwise `.` won't match the newlines. See [perlre](https://perldoc.perl.org/perlre.html#Modifiers) for details.
First: \/m has no effect on that regex. \/s is what allows `.` to match newlines; "treat as a single line". Second: you are matching against a variable you just declared, so it's going to be undef. You want: my $text = ...; if ($text =~ /.../s) { my $match = $1; ... use $match here ... } else { ... didn't match ... }
Yes, I meant that the $var contains that text. My bad. But I believe the /s will solve my issue then. Thanks 
From a command line: perl -V The last bit of information is @INC, which is where Perl will look for modules. Putting the module in one of those directories will let Perl find it when you refer to the module with "use" in your program. It's not necessarily the best way to accomplish this in the long term, but it will work. I suggest you google for 'perl install module locally' for more information.
specifically what i want is to input a word list and have it give me the results. i can already compile this stuff.
&gt;Once it generates the Perl module, I have no idea what to do with it! It's supposed to apply a set of sound changes to any word that you enter but I don't know how to make it do this. This is my problem aswell
it's not a program to change words. It allows you to write a program to change words. You have to write (in Perl) what you want to do out of all those functions.
I know how to write the stuff but when i run it its just blank, how do i get the results 
well, where did you tell it to output the results? That program you posted isn't a program, it's a library of functions you can use in your own program. You're responsible for the input, which functions to use, and output. 
if you're asking why you shouldn't parse HTML with regexes, there are two answers: * Firstly, it can be mathematically proven that, in the general case, regexes cannot parse all regular expressions. Any solution that you find will be limited to parsing a particular sub-set of HTML. Of course, that might be fine for your specific problem, but each time you write a regex parser for HTML you add to a body of work that people misinterpret as demonstrating that HTML **can** be parsed with regexes. * But actually, what we call regular expressions have long passed beyond the strict dictionary definition of what a true "regular expression" is. So, actually it **is*, in fact, possible to parse HTML with Perl's not-really-regular expressions. The problem then becomes that you will end up writing a regex that is so complicated that no-one (including you) will ever be able to edit it. [This blog post](https://blog.codinghorror.com/parsing-html-the-cthulhu-way/) sums up the issues.
I also have difficulties with these modifiers. The standard "multiline" and "single line" don't help much. Here are better ones: /s -- Allows .* to Slurp up numerous lines /m -- Allows ^ and $ to match in the Middle of the string Source: [Mnemonic Devices for Perl Programming](http://www.perlmonks.org/?node_id=125702)
&gt; It's considered good form to demand that regular expressions be considered verboten, totally off limits for processing HTML, but I think that's just as wrongheaded as demanding every trivial HTML processing task be handled by a full-blown parsing engine. It's more important to understand the tools, and their strengths and weaknesses, than it is to knuckle under to knee-jerk dogmatism. I get the problem now. In my case, there is a limited number of HTML that comes from templates and is not supposed to be changed. So in this limited case where i just want to remove one li-tag with it's content it should work just fine, because there is no variability. But to be a bit safer, or maybe for a change of the templatefile, that still involves the li-tag, but with other attributes or something, i wouldn't need to improve my regex if i use html parser. I will definitely look into that. And thanks for the link. That makes much more sense, then the link someone else posted with just the rant an no explanation at all.
&gt; However, things are made complicated by the fact that each field can possibly also include a comma, and in that case, the whole field is enclosed in quotes " But what happens if a field contains a quote? :) like subject=`Re: "O'brians email, about commas"` or worse? In the best case, they're doing "proper" CSV encoding of the vars, which should handle the quoting and other issues. If so, something like [Text::CSV](http://search.cpan.org/~ishigaki/Text-CSV-1.95/lib/Text/CSV.pm) is probably the way to go. Otherwise, you need to figure out all the twisty little edge-cases yourself, and see how they encode them, and then parse appropriately.
That's what modules like [Text::CSV](https://metacpan.org/pod/Text::CSV) are for. #!/usr/bin/perl use strict; use warnings; use feature 'say'; use Text::CSV; use Data::Dumper; my $in = '017-12-05T15:00:00.805Z,56.223.12.32,"Re: The man, the myth, the legend.",blah'; my $csv = Text::CSV-&gt;new; if ($csv-&gt;parse($in)) { say Dumper [ $csv-&gt;fields ]; } And the output is: $VAR1 = [ '017-12-05T15:00:00.805Z', '56.223.12.32', 'Re: The man, the myth, the legend.', 'blah' ]; ...which has the required four fields.
i am honestly too lazy to tell you how i did it, but if anyone who reads this in the future wants it, just pm me.
Lessen the pain with [Syntax::Construct](http://p3rl.org/Syntax::Construct): use Syntax::Construct qw(&lt;&lt;&gt;&gt;);
If you have a Mac...Calibre (sponsorware) is good for converting between ebook platforms.
This is really cool. The Perl Taster ebook looks quite useful as a recommendation.
&gt; figure out all the twisty little edge-cases yourself This is giving me flashbacks...
Very cool - not only duplications but also points out if you have weird naming conventions - too many extra lines etc...
Code examples in the preview look bad, they should stand out more from the rest of the text.
I avoid Macs. But, luckily, Calibre runs fine on Windows and Linux too :-)
For some reason, the preview looks horrible compared with the actual ebook. I need to look into that.
This worked, thank you!
Put either or both of the input and the expected outcome in files that you don't check in? &gt; The answers depend on the input anyway, which I don't post. I'm curious why not. I don't see what would be so bad about putting it into source control.
Well, I'd like someone who wants to to fork my code, and run it against their input without getting a testing error. AoC serves different input to different users (I don't know how large the space is, but I think there are in the order of dozens of unique inputs). The idea I have, which I don't know if it's possible, is to compare the output when run against a known output and raise an error. I can hack something together with `diff` I guess, I just wanted to know if there was preferred solution.
And if you want to catch up, see all the posts on the site front page: https://mojolicious.io
Oh cool! Good luck!
 ‚Ä∫ cat diff.t #!/usr/bin/env perl use strictures; use Test::More import =&gt; [qw(done_testing)]; use Test::Differences qw(eq_or_diff_text); use IPC::System::Simple qw(capturex); eq_or_diff_text scalar capturex($^X, './d12.pl'), &lt;&lt;''; 1. connections to '0': 306 2. total groups : 200 done_testing; ‚Ä∫ prove -v diff.t # for d12.pl correct output diff.t .. ok 1 1..1 ok All tests successful. Files=1, Tests=1, 0 wallclock secs ( 0.02 usr 0.00 sys + 0.05 cusr 0.01 csys = 0.08 CPU) Result: PASS ‚Ä∫ prove -v diff.t # for d12.pl wrong output diff.t .. not ok 1 # Failed test at diff.t line 6. # +---+-------------------------------+-------------------------------+ # | Ln|Got |Expected | # +---+-------------------------------+-------------------------------+ # | 1|'1. connections to \'0\': 306 |'1. connections to \'0\': 306 | # * 2|2. total groups : 200xxx |2. total groups : 200 * # | 3|' |' | # +---+-------------------------------+-------------------------------+ 1..1 # Looks like you failed 1 test of 1. Dubious, test returned 1 (wstat 256, 0x100) Failed 1/1 subtests Test Summary Report ------------------- diff.t (Wstat: 256 Tests: 1 Failed: 1) Failed test: 1 Non-zero exit status: 1 Files=1, Tests=1, 0 wallclock secs ( 0.02 usr 0.00 sys + 0.05 cusr 0.01 csys = 0.08 CPU) Result: FAIL
This looks like just what I was looking for, thanks! 
Thanks for these, /u/joelberger. I've really been enjoying them. I've been using mojolicious for a while now, and I learn new aspects on every topic you've covered -- even topics that I "knew".
&gt; If you are calling this version of fetch from a running ioloop, like in mojolicious response handlers, then the loop will make the request and call the subsequent callbacks when appropriate. If you aren't, you can call -&gt;wait on the promise to run the loop (blocking the current code) until it's ready. But is it possible to run this in a non-blocking fashion outside of Mojolicious (response handlers)?
You are very welcome. I'm glad to hear they are useful!
Yes; but it only matters if you're in some sort of event loop if not Mojolicious response handlers. In a regular script, there's no point in running it non-blocking because there's nothing else to do while it's running.
Yeah, it's just one side of it... :)
Interesting `whois` results, especially when I looked at the obvious `mojolicio.us` domain.
I don't know what you mean? If it isn't clear, yes I'm running the advent calendar and am author of many of the posts.
And probably work for [Neustar](https://en.wikipedia.org/wiki/Neustar), a surveillance corporation spun off of a defense contractor.
**Neustar** Neustar, Inc. is an American technology company that provides real-time information and analytics for the Internet, telecommunications, entertainment, and marketing industries, and a provider of clearinghouse and directory services to the global communications and Internet industries. Neustar is the domain name registry for .biz, .us (on behalf of United States Department of Commerce), .co, and .nyc top-level domains. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
You clearly don't know much about me and I find the accusation rather insulting. I'm an advocate against surveillance. Read through my twitter, I'm an open book. I work for a hosting company and since it isn't Neustar I'm going to assume you aren't besmirching my employer. I'm not going to link to my employer here, but it isn't hard to find. The .us domain is a cutesy one that we don't even use that much anymore. Most of the Mojolicious links we generate now are to mojolicious.org. The change was because the owner of the name lives in Germany we were getting a little nervous if the .us domains tightened ownership rules.
It's a cute trick, but I can't think of a single circumstance where a modulino would be helpful in practice.
I made two yesterday. Pipelining independent scripts that have taken on a life of their own into a larger integration. Also useful for writing tests against scripts. 
+1 writing tests against scripts.
The inventor of the word "modulino" must have been Italian. Prendo il motorino per l'ufficio e scrivo un modulino in Perla.
Rosetta Code has the (still draft) task [Modulinos](http://rosettacode.org/wiki/Modulinos). It floundered a little and didn't make full task status [issies](http://rosettacode.org/wiki/Talk:Modulinos). It did spawn the full Task [Executable library](http://rosettacode.org/wiki/Executable_library) which has solutions in many, (28), languages including Perl and Perl6. The Perl code depends on unless (caller) {... 
I would suggest it may be easier for people to write mini chapters of books rather than a whole book. e.g. Mathematics on Perl, Game making on Perl, GUI applications in Perl, IOT applications in Perl, Raspberry Pi and Perl. People would contribute their personal applications in chapter form to be edited and compiled by an interested controller person.
I'm not Italian, but Enrico Fermi was. ;)
if ( system ("cd $subdirectory &amp;&amp; unoconv -f pdf *.docx" ) == 0 ) # success! { print " ... ok!\n"; }
&gt;I can't see an option in unoconv to specify the source directory so I'm attempting to run the system process from the directory in which the files for conversion are located. Except that the program probably isn't in that directory. All you have to do is `chdir` to that directory before you call `system`.
Is the unoconv binary in the same directory as your .docx files? You're trying to run `./subdirectory1/subdirectory/unoconv`, not `cd subdirectory1/subdirectory2` followed by `unoconv -f pdf *.docx`, which I think is your intention.
In addition to what other comments said about not being in the right directory, '*.docx' will not be expanded in the list form of system() since it does not pass its arguments through the shell. If you use the string form then the shell will expand it, otherwise you can use glob() to expand it, for example system('unoconv', '-f', 'pdf', glob($subdirectory . '*.docx'))
An alternative way to more easily test scripts is by moving all of their actual functionality to modules.
You've got some good answers already, as an alternative, you don't always have to use perl, you could do this from the command line using find. $ find . -name *.docx -exec unoconv -f pdf {} \; Hope you find this useful, even if it's not the answer you're looking for.
yes indeed, that's a really good idea. And in order to kick that process off you can do much safer refactoring by making your script testable via the `run(@ARGV) unless caller` or whatever pattern as the first step in achieving that outcome.
You're the inventor of the word? :D
Yes, I coined that word. I didn't make up the technique but I gave it a name. 
What caught my attention directly: You are talking about lists when you mean arrays. Since that's an important distinction in Perl, I think you should change it.
I think there's an ambiguity between "list" used as a general English term and as a P5 specific technical term and it's not clear there's a better way to resolve that when introducing these basic aspects of Perl. One of the interesting things about P6 is where it's gone with `$`, `%`, `@`: * `@` constrains or coerces a value to a `Positional` one. This is a role played by Lists, Arrays and other types for which integer subscripting makes sense. The term "list", with a lowercase "l", is used to refer to any positionally ordered collection whether conceptual or concrete. * `%` constrains or coerces a value to an `Associative` one. This is a role played by pairs, hashes, and other types for which key subscripting makes sense. The terms "pair" or "key/value" are used when referring to any single key/value pair, and "key/value pairs" to refer to a keyed collection, whether conceptual or concrete. Of course, P5 is its own thing, and P5 lists are always ephemeral (right?), but perhaps it's time to pick an appropriate term that conceptually abstracts over both arglists and arrays, despite their differences. That said, the most obvious candidate, based on my limited understanding of the problems of using it would be "list" -- despite the ambiguity.
https://github.com/kablamo/mvp.kablamo.org/issues
Thanks! Not sure when I will have time to submit a pr but contentwise this was the best Perl tutorial/book I have read so far so I would love to contribute :)
I see that http://mvp.kablamo.org/basics/variables/ was changed now, using the word array, thanks.
An array is a type of variable, but a list can mean several things, even without an array or any variable involved. It often leads to confusion if people don't know that, so IMHO two different words are necessary. And since perldoc calls them arrays, I don't see why a tutorial should call them differently.
All makes sense. I see it's changed for the better. Thanks for the follow up.
Very nicely put together. I would suggest mentioning [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) as preferred over Try::Tiny when you are able to use it (it requires XS support and perl 5.14+). It does not suffer from many of the caveats of Try::Tiny, including the speed penalty. Also, if you are going to document how to use raw eval, you should not include any 'if $@' tests, as that is fundamentally flawed (as the Try::Tiny docs note). Instead you should always make evals return 1, and check the return value to determine if an exception was thrown; when an exception is thrown, the eval returns undef. I have added this tutorial to http://perl-tutorial.org/.
Thanks for adding it to perl-tutorial.org and for creating an issue on github.
Looking forward to it! I spent a bunch of time on it so the mobile experience should be passable, but front end is not my specialty. 
Free Software developers should learn to not rely on closed platforms for their support, I recommend creating accounts in more than one service to avoid a SPOF: * https://en.liberapay.com/ Doesn't support perks, it's purely a donation platform; * https://www.bountysource.com/ Supports just the perks system, people contribute money in exchange for specific features.
very minor point, but: since these are tutorials, I think the post title might work better without the question mark?
I'm not a fan of how that link broke my back button.
Minor but valid.
Yes, glob is the key.
ok. Let's make it a statement.
What do you mean and in which browser did that happen?
Well now that you ask, I can't seem to reproduce it, but I'm on Firefox 57.0.2 on Windows. It seemed like one of those redirects that, when you click the back button, re-redirects you, making it difficult to actually go back.
I'm not experiencing that. Maybe you opened it in a new tab?
Thanks, didn't know liberapay, I just created an account =)
Other strawberry perl users have reported the same issue: https://rt.cpan.org/Public/Bug/Display.html?id=120926 Since it's only this failing test, you can force the install and the module should still work correctly.
It certainly exists: https://metacpan.org/pod/Spreadsheet::ParseExcel Can you post the command you tried and the output?
When I try force installing, it still seems like something goes wrong! It will say Stopping: 'install' failed for 'Log::Log4perl'. And while I can type "cpan Log::Log4perl" and it will say that it is up to date, if I try and install LibXML, it fails installing too, leading my to believe that something is going wrong, as Log4perl is a dependency of LibXML. I have tried also forcing an install of LibXML, however when I do that, the program fails to actually do anything, leading me to believe that forcing these installs is not the correct solution. Thank you for the advice though! Anything else you can think of?
Best guess is you have more than one perl install and they're interfering with each other. Have you installed MacPorts by chance? Or compiled/installed your own perl from source?
What's the failure when trying to install XML::LibXML?
I installed perl from brew. Does os x already have perl installed?
Yes it does.
Hi, OP. Firstly, congratulations on your new book. I think it's great. Is it possible to get Next and Previous buttons for improved navigation? If I missed it, please let me know. Thanks.
üéÇ
I've had issues like this on practically every platform and using plenv to manage my Perl binaries and modules solved it for me. Perlbrew can also handle this but I've had better luck across Debian, Ubuntu and OS X using plenv. Using Carton is also a good idea.
Same. I started using perlbrew on OS X years ago, and now MacPorts, Homebrew, etc. don't break my perl environment anymore.
As an interesting aside, this is how you normally create 'required' attributes in Mojo::Base and Class::Tiny, mainly because they have no way to enforce it on creation. Though I did write an as-of-yet unreleased Class::Tiny [subclass](https://github.com/Grinnz/Class-Tiny-Immutable) that allows you to require all attributes to be provided in the constructor or lazy, which I'd mostly forgotten about.
Honestly, after trying again and again, it decided to install properly this time! I can't get it to replicate the failed install either, so I'm not sure what to tell you. Now time to try and get the program to work, but that's for an entirely different subreddit. Thank you very much sir/madam!
/u/koorchik, do you have a comparison table for LIVR, Kwalify, Rx, Relax NG, JSON Schema, XSD?
 perl -Mutf8 -E'binmode STDOUT, "utf8"; say "üéÇ" x 30' 
[`-C`](http://p3rl.org/run#*-C-[_number/list_]*)
√æ is AltGr-P in most keyboards. Easy as A. 
That's correct. It's simply a placeholder. As long as it's got the twigil `$^` you're good to go. 
SSL Issue?
These are awesome!
how about `perl -ne'print if /^begin/../^end/' &lt; lines.txt`? `-p` is the wrong choice here, since it mostly assumes you'll be modifying the line and so it unconditionally prints it. The `//s` regex modifier also won't work because `-n/-p` are line-oriented, so you never see the whole multiline string to match on (without messing to force full-input slurping, but you probably don't want that). The `..` operator ([range or flip-flop](https://perldoc.perl.org/perlop.html#Range-Operators)) works nicely here, returning true after LHS is true, until RHS is also true. 
Mojolicious is the one that got me. 2008 feels about twice as long ago as would have thought for its release.
thanks :)
This will work if you leave out the -p and set $/ to undef so you slurp the whole input into $_ instead of reading line by line: ``perl -e 'undef $/;$_=&lt;&gt;;print $1 if /(begin.+end)/s'``
for the 2nd version, could also use perl -0777 -ne 'print /begin.+end\n/gs' `\n` just in case line ending is needed, and also for multiple matches...
You should talk to Dave: https://perlhacks.com/2017/12/regenerating-perl-school/
That's what I get for traveling at Christmas!
The 1.0 release was in 2010, but there's this thing called Mojo that sri released in 2008.
https://www.facebook.com/matthew.persico/posts/10215397347117076
I would personally tend to use a global regular expression to capture blocks as follows: use strict; my $data = &lt;&lt;'DATA'; Headerx 30 30 1 Jun 12 12:30:40 2017 some sentence X p 1 2 32 23 23 33 HeaderY 30 30 1 Jun 12 1:20:31 2017 some sentence Y p 1 2 32 23 23 33 DATA my @blocks; while ( $data =~ m/ (?:\A|[\r\n]) # start of data or newline char Header # literal text (.*?) # match as little text as possible (?=[\r\n]Header|\z) # until Header line or end of data /xsg # expanded, multiline, global ) { push( @blocks, $1 ); } foreach ( @blocks ) { print( "----BLOCK----\n\n$_\n\n" ); } This would output: ----BLOCK---- x 30 30 1 Jun 12 12:30:40 2017 some sentence X p 1 2 32 23 23 33 ----BLOCK---- Y 30 30 1 Jun 12 1:20:31 2017 some sentence Y p 1 2 32 23 23 33 
The contents of the block probably don't matter. All you need to do is to process the file a line at a time and recognise when a new block begins. Something like this will work: #!/usr/bin/perl use strict; use warnings; use feature 'say'; use Data::Dumper; # Store the contents of the current block my $block = ''; # Store the blocks my @blocks; while (&lt;DATA&gt;) { # If we find a header line if (/^Header/) { # The first line in the file is a header line, # so the "if" here ensures that an empty block # isn't added to the array. push @blocks, $block if $block; $block = ''; } $block .= $_; } # Ensure the final block is in the array. push @blocks, $block; say Dumper \@blocks; __DATA__ Headerx 30 30 1 Jun 12 12:30:40 2017 some sentence X p 1 2 32 23 23 33 HeaderY 30 30 1 Jun 12 1:20:31 2017 some sentence Y p 1 2 32 23 23 33 
FWIW: `_perly_bot` already auto-posts from the advent blog post into this subredit ( https://www.reddit.com/r/perl/comments/7lfp0c/day_22_features_of_perl_6d/ ). So this post is kinda of a dupe; perhaps it could be removed?
One moose can house 75,000 ticks in the winter, which are beginning to drive a startling trend of deaths in moose populations.
agreed, p5p screwed the pooch on this.
Would it be feasible to develop this as a CPAN module first, or is that totally unworkable?
Yeah, that should be possible (though it would involve deep internals knowledge). Since 5.14 custom keywords are possible, and so is overriding opcodes for smartmatch.
Yup. P5P has been a slow-motion pooch-screw since somewhere around 5.10, and it only seems to be getting worse. "Smart" match is only the tip of the turd-berg.
Welp, that's going to break more than a few of my programs.
I've never used smart match before, as I never felt it would fix any of my problems, and this post convinced me I will *never* bother with ,in any form or incarnation. I do not need a "do what I mean" syntax, where it's absolutely unclear what I could mean, to either side, i.e. eihter the programmer or the program. Some explicitness, similar to the use of the word `scalar`sprinkled in at some places, is not necessarily a bad thing. And I definitely don't need a feature that requires to write a whole library just to be able to use a core language feature. That is just.... "everything that is wrong with Java". 
What the hell happened here?
I talk about self testing code in the Modulinos chapter in [Mastering Perl](https://www.masteringperl.org/). 
This is unfortunate and will be viewed as another reason to migrate the few remaining bits of perl in our deployments to some other language. 
Cool, I'll start watching it more to see what kind of content goes up. 
This post is misleading; it's incredibly unlikely the feature will go in without changes (one could say that is an argument for why it should not have been merged yet, also). I would expect it to be delayed past 5.28 due to the response, now.
Good news! :)
It's actually getting much better. They developed formal policies on experimental features and deprecations (see perlpolicy) and have been quite user-focused on that process. For this one point release on the development branch that didn't happen. I suspect that the next point release will fix this.
Perhaps add your voice [here](https://twitter.com/ribasushi/status/945637302402998273)
He lost me at: &gt; Talking *with* #p5p is not a viable option &gt; I can only talk *down at* them
I fully agree with the answer he got [here](https://www.nntp.perl.org/group/perl.perl5.porters/2017/12/msg248387.html). His mail is a completely useless waste of swear words and time, because he just picked a sentence to rant about, not realizing that guy he's yelling at is actually agreeing with him.
The thread isn't a conversation, it's not even a debate, it's an argument. It doesn't help anyone. Why is it posted here? Also, why is this post linked to a Twitter post about the post rather than the post itself? Link for the lazy: https://www.nntp.perl.org/group/perl.perl5.porters/2017/12/msg248369.html
Because it contains interesting poll (interesting for the debate).
&gt; He lost me at: &gt; &gt; Talking with #p5p is not a viable option &gt; &gt; I can only talk down at them Agreed. There are plenty of smart people who could contribute to p5p but for their inability to disagree effectively. They won't get anything done.
If you are not going to debate technically, you will not get a technical debate.
Is that a quote from *Mystery Men*?
It's worse than that. Rants and personal attacks like this wear down on the people doing work, and eventually they leave. Which may be what the ranter wanted, but is not helpful to anyone else.
You won't find any widely-used language that has been nearly as *conservative* about changes as Perl has.
I hadn't looked at `perlpolicy` in awhile, and find the "deprecation treadmill" exhausting, but it says some of the right things: &gt; Lately, ignoring or actively opposing compatibility with earlier versions of Perl has come into vogue... Existing syntax and semantics should only be marked for destruction in very limited circumstances. I saw Perl as a foundation like C, upon which programmers could confidently build. I wish it had accepted this position many years ago, before p5p burned so much trust, and perhaps focused on performance instead of backward-compatibility-breaking features.
C.
Focusing on performance doesn't inherently mean less backward compatibility will need to be broken; many of the warts also prevent performant code. See the change to the scalar return value of hashes for instance, which was changed (to match keys %hash) to improve performance directly, and to avoid unnecessarily leaking the internals, so perhaps the underlying hash algorithm can be changed in the future improving performance for virtually every perl program.
I agree to some extent when it comes to XS or C-level incompatibility, but not so much for Perl-level breakage. For the amount of effort spent breaking working code to implement regex features used by almost no one, Perl might have had an optimistic JIT, or made use of SIMD, in some situations. Sure, the volunteers at the time scratched their personal itches, as was their right, but they did so to Perl's detriment. &gt; to avoid unnecessarily leaking the internals Who cares about "leaking the internals" in this case? The scalar value of a hash was documented as an implementation-dependent fill ratio since forever, and I doubt any code depended upon specific hashes having specific fill ratios.
https://www.youtube.com/watch?v=2y5Pv4yN0b0 Please see it in full. Then contrast to our "deal leader". Thank you.
What would you like to see (and what would you like to write)?
I am not very good at Perl. I do some simple scripting with it but that's about all. So writing about Perl...probably not what I should be doing.
Looking back in my life when I was born a year after Tavish Armstrong, I just feel so, disappointed how my life turned out to be. I had similar dreams and hope but they didn't work out in the end. Only if I told my younger self to actually go through the Macromedia Flash book I borrowed once in high school, I would have had my first glimpse in computing. But during my early days, I never had anyone who was remotely interested in computers. I wasn't great at socializing either which would have lead me to people who were in machines. There was AP CS course at my university but I never took it only because I thought it was too hard and instead took AP Calc. Without any concept of computing or the power of programming, how can a kid get into life of software development? All the random success stories I've read of popular programmers these days, all of their younger days began with someone giving them a gift or some 'assembly' language computer and started from there. Wish the pursuit of programming caught me much earlier in life than right now, went into wrong major and always thought about programming, programming. Having friends and family who aren't into computers didn't help either until last year. So much life was wasted.
Does your environment restrict the version of Mojolicous you need to run? If not, just install the latest Mojolicous and set that as the minimum requirement?
There's no generic method, however the Mojolicious [changelog](https://metacpan.org/source/SRI/Mojolicious-7.59/Changes) is easy to scan for specific features. If in doubt do as /u/workrestplay said and specify the version you have installed, since that's a version you are sure works, and you can test older versions later if needed.
&gt; widely-used
When you 'use' the Mojolicious modules, you should be able to specify a minimum version. https://perldoc.perl.org/functions/use.html 
| Java Language Architect &gt; https://www.tiobe.com/tiobe-index/ | 1 1 Java 13.268% -4.59% 
My mistake, I assumed it was about Clojure.
This doesn't really help here, since the only module in the Mojolicious distribution with a version is Mojolicious, so you need to specify that as your prerequisite regardless of which modules you are using in the code.
&gt; Rants and personal attacks like this wear down on the people doing work, and eventually they leave. If it were that simple - the pumpkin and his posse would have been out after their [first sob-story](https://twitter.com/PerlSawyer/status/725693184098078721). Sadly it **isn't** that simple, not by a long shot. This leaving aside that *"You are demonstrably really bad at your job, please leave"* is orthogonal to the concept of "personal attack", but I don't believe I'll ever communicate that through to you and your ilk
Calling someone an "absolute, irredeemable failure" is a personal attack. I'm surprised you don't seem to understand (or accept) that. Pointing out decisions that you disagree with? Not personal. Outright stating that there is no way a person's performance can possibly improve in future? Personal. "Grow a pair"? Personal. "Feverishly butchering"? Personal. It's not just whether your comments are a personal attack, though - that's a distraction at best. It's the lack of any suggestion or actionable, positive improvement that can be made: you want the current pumpking (note the spelling) to resign? What then? A different person authored and committed the smartmatch changes in the first place, swapping out the pumpking isn't magically going to change who's writing what. Why did you not take part in the discussions earlier, while the code was still under development? It's hard to tell whether you're suggesting that the language should retain this fundamentally-flawed implementation unchanged, or if you have something else in mind. The technical details appear to be missing in the original email, perhaps there was a followup I missed!
&gt; Calling someone an "absolute, irredeemable failure" is a personal attack. As you stated it - I agree it would be one. Luckily this is not what I said. What I said was: &gt; you are an absolute, irredeemable failure and embarrassment as a technical leader and as a user advocate I am just as surprised that this "nuance" is lost on a large portion of the readers. In case of doubts - I stand by what **I** quoted, and have repeatedly told this to Sawyer in person. Hence my lament that just asking an autocrat nicely to resign is not even close to enough. &gt; you want the current pumpking (note the spelling) to resign? What then? ... swapping out the pumpking isn't magically going to change who's writing what. First of all the [proper/original spelling is pumpkiN](https://metacpan.org/pod/distribution/perl/pod/perlhist.pod#PUMPKIN?). To answer your question - it won't change what code will people write: "developers are gonna develop". But it **definitely will** change what is acceptable to actually ship as `/usr/bin/perl`. The current climate of "you did work - we get to merge it" is... I don't have a good "adult" word for this worldview. Additionally - if Sawyer does indeed grow... gather his inner courage and finds the moral fortitude to wistfully reexamine his life choices and in fact does leave - there **is** a list of people who would be interested to step up and drive things a bit away from the cliff. &gt; Why did you not take part in the discussions earlier Because others made my argument way better than I did. Also repeatedly stating "please stop fucking your users" is not... easy. I am all for learning on the job, but there ought to be some learning happening. Here we have none. We don't even have to go about work in progress - where is the public apology / steps to revert parts of the the *.-in-@INC* catastrophe? Distros and users are still waiting for that. &gt; It's hard to tell whether you're suggesting that the language should retain this fundamentally-flawed implementation unchanged, or if you have something else in mind. I suggest what I always suggest: *if you are not sure what needs to be done, at least don't do the wrong thing*.
Outright stating that there is no way a person's performance can possibly improve in future? Personal. Limiting that to a specific aspect of their performance? Still personal. Put another way: why irredeemable?
The issue isn't with my environment. I want to specify the minimal version of Mojo which is compatible with the functions used within my code, regardless of what version I personally have. Nobody would want a module that requires perl v5.26 for no good reason.
I'd hoped for something fancy to do this, guess I'll just have to use do this manually.
&gt; why irredeemable? The answer is so blindingly obvious to myself and to be frank the entire circle I move in that... I need to take a step back and figure out how to explain this ( both substance and medium ). Stay tuned.
&gt; As you stated it - I agree it would be one. Luckily this is not what I said. What I said was: &gt; &gt; you are an absolute, irredeemable failure and embarrassment as a technical leader and as a user advocate &gt; &gt; I am just as surprised that this "nuance" is lost on a large portion of the readers. In case of doubts - I stand by what I quoted, and have repeatedly told this to Sawyer in person. Hence my lament that just asking an autocrat nicely to resign is not even close to enough. Nuance? The only thing irredeemable here is this statement. You did not claim he failed, you claimed he is incapable of succeeding. This is unsubstantiable opinion, and yes, a personal attack. That you have "repeatedly" told this to Sawyer does not help substantiate it, but instead makes a case for systematic harassment. &gt; Additionally - if Sawyer does indeed grow... gather his inner courage and finds the moral fortitude to wistfully reexamine his life choices and in fact does leave - there is a list of people who would be interested to step up and drive things a bit away from the cliff. How interesting. Where was this mystical list of people when Ricardo stepped down?
Please don't.
This is exactly my stance. Smart match was broken since 5.10 and everyone knew it. I'm frankly amazed that so many people used it in CPAN modules. The largest two quality of life improvements to the core language have been post-deref and sane function signatures. This has been way more beneficial than smart match will ever be.
&gt; I don't believe I'll ever communicate that Given that: * You seem to have failed to read the entire email to which you replied * You certainly seem to have failed to understand that Sawyer was arguing for the same outcome you wanted * You took the opportunity to berate him anyway * You seem to fail to understand how this makes you look bad * You seem to fail to understand how this works against you getting what you want * You seem to be *bragging* about your behavior and the outcome here * You claim that you have an important point buried somewhere in all this that you're going to need to figure out how to communicate effectively * You seem to have a pattern of doing all of this ... I have my doubts that you'll ever communicate whatever you think you're trying to communicate effectively, unless your point is "Everyone is stupid and incompetent except me".
&gt; Where was this mystical list of people when Ricardo stepped down? Probably too busy queueing up in the line to receive yet more useless abuse from Peter, Reini, and Marc.
And a Perl win: Perl beats Python!
but this time without the music
It's certainly not a good look for a newbie like me trying to learn the language. Although driven by interest, with the only prospect using Perl being a personal project, seeing feature changes and consequent fighting leaves a bad taste. It would suck, while learning, if something new and interesting was inconspicuously labeled as experimental and suddenly disappears. üòï
There's RPerl and CPerl and a bunch of other projects listed on http://perl11.org
&gt; Ruby Is just Perl rebranded.
It's not (currently?) open source, but there's [agentzh's / OpenResty's fanlang](https://www.google.com/search?q=agentzh%27s+%2F+OpenResty%27s+fanlang&amp;ie=utf-8&amp;oe=utf-8).
Perl 6 is not Perl. Go post about it in r/perl6.
No sigils, but something which may be of interest. https://metacpan.org/pod/Sidef https://github.com/trizen/sidef/wiki
Pretty neat idea. If only something like this was even remotely feasible for Perl 5.
There was [Kurila](http://www.ggoossen.net/kurila/) but it died quite a while ago. Besides the projects listed on the Perl11 page, there‚Äôs also [stableperl](http://software.schmorp.de/pkg/stableperl.html).
&gt; For the first item I store the original array. I have a significant trailing comma there: &gt; &gt; state @permutations = [ @array, ]; &gt; &gt; If I only use a single array argument (the single argument), the array is automatically flattened. In Perl5 we never had the confusion of an array inside an array - we used references for this; e.g. `my @arrayinarray = ( \@innerarray );`. Perl6, however, has the opportunity to really confuse people by allowing arrays within arrays! Is this, in retrospect, a mistake? At least scalar objects can be any type - but the array type has always been special and to use the `@` sigil instead of `$` for arrays when arrays can behave just like any other kind of object is odd, is it not? Funnily enough in PowerShell, which borrowed a lot from Perl, a *leading* comma is needed to put an array within an array.
&gt; Is this, in retrospect, a mistake? Personally, I don't recall ever having trouble with the "single arg rule" as it's called. It's just different things. Perl 5 has references. Perl 6 [has containers](https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/). And you don't have to use it in that case either. You can just place the Array into a Scalar container to indicate you want it treat it as a single item: state @permutations = $@array; &gt; to use the @ sigil instead of $ for arrays when arrays can behave just like any other kind of object is odd, is it not? You can use `$` sigils for arrays if you want. The `@` sigil isn't "for arrays". It's [a shortcut](https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/#positionlly) to have `Positional` constraint on applied to a variable. It can have any `Positional` type bound to it and you can get an `Array` for free, if you use assignment instead of binding. &gt; @permutations[0] contains the original array. Surely assigning one array to another copies the elements from one to another? Why is flattening necessary? Normally, yes, but in this case the inner `Array` is inside a `Scalar` container, because `Array`s automatically place their items into `Scalar` containers. So if you just assign it, it'd be the same as what we saw ealier: `state @permutations = $@array;` . You'd end up with an `Array` containing a single item. You can just [decont it](https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/#decont) before assignment: `state @A = @permutations[0]&lt;&gt;`; or, since we know what that element is, just `state @A = @array` &gt; Is this completely unnecessarily complex or have I missed some basic elements of Perl6 that are wildly different from Perl5? [Solid grasp of containers](https://perl6advent.wordpress.com/2017/12/02/perl-6-sigils-variables-and-containers/) is what folks typically miss. Perhaps that article would of help in understanding? Here's an alternate take on OP's code, without any .clones or flattening. It's just a [gather/take](https://docs.perl6.org/syntax/gather%20take) that returns a `Seq`. The `.List` on the `Array` we're mutating and is akin to taking a "snapshot" of it. And we `take` a bunch of such snapshots that comprise the resultant permutations: .put for heaps &lt;a b c&gt;; sub heaps (*@things --&gt; Seq:D) { gather { take @things.List; my int @c[+@things]; my int $i = 0; while $i &lt; @things { if @c[$i] &lt; $i { @things[$_, $i] = @things[$i, $_] with $i % 2 and @c[$i]; take @things.List; ++@c[$i]; $i = 0 } else { @c[$i++] = 0 } } } } HTH
Mojolicious is more popular than perl itself! :)
It‚Äôs certainly the main reason I still use Perl :)
a2p was removed from the core perl distribution in 5.22. It's available from cpan as App::a2p and possibly in your OS's package manager.
Not to dissuade you but code generators like these often come up with quite opaque or over-complex code that's more designed to "just work" than to be a learning tool. Maybe they could be a useful reference but I would suggest it's more useful just to stick to tutorials like those linked from the sidebar, or if that's not sufficient, asking here or in IRC how one might accomplish a certain thing in Perl.
&gt; However, sometimes, e[s]pecially when the hash is big, we migh prefer to use the each function. I remember reading somewhere that whether one iterates over a hash with some key-value pairs or with a million key-value pairs performance isn't affected. Is the author referring to performance when recommending the `each` function over the `keys` function when the hashes are big?
I'm not sure if this benchmark is at all reliable, but it seems to indicate keys() provides a significant improvement in speed vs. each: $ perl -e'use Benchmark qw(cmpthese :hireswallclock); my %items = map { $_, $_ } ("aaaaa".."zzzzz"); warn "have " . keys %items; cmpthese -5, { keys =&gt; sub { for my $k (keys %h) { die unless $h{$k} eq $k } }, each =&gt; sub { keys %h; while(my ($k, $v) = each %h) { die unless $v eq $k } } }' have 11881376 at -e line 1. Rate each keys each 9605870/s -- -26% keys 12983545/s 35% -- The keys() approach also tends not to flatten and store the list in memory, although that may have been a concern in previous versions.
`each` does have the one benefit that it does not have to keep a separate list to iterate over, since it's using the hash's internal iterator. That also leads to all of its problems, but it may be worth using in very extreme cases; it really shouldn't be presented in a tutorial at all, though, other than to say "don't use this".
Thanks ! It's working perfectly at this web hosting : http://onsale.jaguarpc.com/
 my $sq = @_; This puts the number of elements in `@_` into `$sq`. And I bet you're always passing one parameter to `square()` so it's always 1 - and that means `Compounding()` will always return 1. You probably want: my ($sq) = @_; The parentheses around `$sq` make it a list assignment, so you get the first element from `@_` not the number of elements.
thanks for your answer. the _ is there, no? 
it was this exactly. Thanks for such a detailed answer. Have a great day!
Oh. I missed it somehow. Sorry! Posted before I was awake. üòÅ
Wouldn't it better to use shift in this particular case? Or has shifting parameters fallen into disuse? 
You could also use: my $sq = shift; 
Personally, I dislike using `shift` in most subroutines as it changes the contents of `@_` and I like to keep `@_` intact in case I want to pass it on to another subroutine. OTOH, I like to use `shift` in for the first parameter in methods as a) it demonstrates that the first parameter is special and b) it leaves `@_` with the same contents as the original caller gave it. my $self = shift; my ($some, $other, $stuff) = @_; These (self-imposed) rules work for me. But I don't expect anyone else to follow them.
There are some large differences in the language design. The object systems -- while about equally powerful -- are different in design: Ruby's is centralized and comes full-packed, where√§s Perl's provides the foundation for more to be implemented.
Well, syntax is almost the same.
I think a lot of Ruby developers want to disagree :)
Then they would be wrong.
I know almost nothing about it other than that it is P6ish, is claimed to be a lot lighter and faster, and is currently closed source. I think [this tweet is what first brought it to my attention](https://twitter.com/agentzh/status/826922812099043328). Another P6 like lang that's also a lot lighter and faster than full P6 is [nqp](https://github.com/perl6/nqp). Among other things NQP A) underlies the Rakudo full P6 compiler and B) is well positioned to become something akin to an analog of PCRE that's designed for the 2020s and beyond. Are you aware of [Damian Conway's recent work that grafts a lisp macro like capability onto Perl 5 to enable emergence of practical Perl tweaks and dialects](https://www.youtube.com/watch?v=ob6YHpcXmTg&amp;index=20&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK)?
I'm guessing you meant Damian's work. Did you catch his [outstanding 12 minute Q+A session](https://www.youtube.com/watch?v=e1T7WbKox6s&amp;t=1h4m) at the end of his tpc::eu keynote? Especially, at around 72 or so minutes in: &gt; {Damian} This is basically as close as we can reasonably get to a macro mechanism in Perl 5. ... It is somewhat of a limitation of the pluggable keyword mechanism that doesn't really make these proper macros like Lisp would have &gt; {someone in audience} that's not a limitation of pluggable keywords themselves because I've done many of them that are true expressions. That's a limitation of ... Keyword::Simple. &gt; {Damian} Yes, it's it's not a fundamental limitation but it's a limitation of the only module that I am going to use to do this. ... So if someone wants to patch Keyword::Simple so that it will detect keywords at other places then I will very happily patch Keyword::Declare to make use of that. I will eagerly and gladly and excitedly do that but I'm not going to go in and patch Keyword::Simple because Keyword::Simple is written in C. Know anyone with the chops to patch Keyword::Simple? :)
I'm reading a perl book at home and just discovered this. Thanks for the answer!
Noted. Thanks for the input as well as the link!
One of the features of `Getopt::Long` that I really appreciate is the ability to pass a hashref as the first parameter, which then gets populated by provided options. That means that this example... my $config = { dot =&gt; 0, height =&gt; 600, width =&gt; 600, step =&gt; 10, file =&gt; 'graph.svg', }; GetOptions( 'man' =&gt; \$config-&gt;{man}, 'height=i' =&gt; \$config-&gt;{height}, 'width=i' =&gt; \$config-&gt;{width}, 'step=i' =&gt; \$config-&gt;{step}, 'dot' =&gt; \$config-&gt;{dot}, 'file=s' =&gt; \$config-&gt;{file}, ); ... can instead be written as my $config = { dot =&gt; 0, height =&gt; 600, width =&gt; 600, step =&gt; 10, file =&gt; 'graph.svg', }; GetOptions( $config, 'man', 'height=i', 'width=i', 'step=i', 'dot', 'file=s', ); ... which saves a lot of redundant typing. The article also points out that `-help and --height will compete for -h`. Another feature of `Getopt::Long` is the ability to specify which single letter flags associate to which options, for example... sub usage { say {*STDERR} 'Usage: blah...'; exit 1; } GetOptions( $config, 'height|h=i', 'help|?' =&gt; \&amp;usage, ); Now `-h` will only ever mean `height`. To get help you would do `--help` or `-?`. With regards to the hashref keys, the `|` and subsequent text is helpfully ignored, eg. When running with`-h 200`, the value `200` will be assigned to `$config{height}` (not `$config{'height|h'}`)
the writer's coding style brings me out in hives: spaces before ‚Äò;‚Äô, and indented final ‚Äò}‚Äô. perltidy soothes everything ‚Ä¶
seems reasonable, as it means you do; my $thing = Some::Delegate-&gt;new(@_) rather than my $thing = SomeDelegate-&gt;new(@_[1 .. $#@]); # or whatever the correct systax is :-P Generally I like to use the following pattern sub doit { my ($self, @args) = @_; # do stuff my $thing = Some::Deletage-&gt;new(@args); # do more stuff ... } Unless I'm doing Moo(?:se) or Class::Method::Modifiers type stuff. At which point I reach for `shift`.
Another convenient form is this: GetOptions( height =&gt; \( my $height = 100 ), ); 
you want something like: my %wife; $wife{"Jacob"} = ["Leah", "Rachel", "Bilah", "Zilpah"]; print $wife, "\n"; where %wife is a hash variable being declared, otherwise Perl gets confused about if you meant to access $wife which is a different variable
If you want to declare a hash variable and initialize it at the same time, you can't assign just to one key: my %wife = ( Jacob =&gt; [ 'Leah', 'Rachel', 'Bilah', 'Zilpah' ] );
If you are looking at the second code example on page 13, there is no "my" before $wife in that line. Take "my %wife;" from page 12 (please! -- Henny Youngman), use that, and follow with everything except the "my" in your code, and all should be well.
Have you looked at MCE? In particular, look at https://github.com/marioroy/mce-examples/tree/master/asynchrony. There are a couple of DNS-related examples there that might have something you can use.
But &gt; print $wife, "\n"; actually *does* access a different variable...!
Thanks! It works perfectly now. :)
Eh, it's [close enough](https://en.wikipedia.org/wiki/Fiery_skipper#/media/File:Fiery_skipper_jts.jpg) :) Considering that [Camelia knows how to change her wing colors at will, any color scheme](https://raw.githubusercontent.com/perl6/mu/master/misc/camelia.txt)
_Programming Perl_ is intended as a complete Perl reference. It's unrelated to the other two books. _Learning Perl_ is a tutorial for beginners and _Intermediate Perl_ is its continuation. _Advanced Perl_ is also unrelated to those books, it was written by a different author. It assumes that you already know Perl and it mostly covers perl **uses**, not the language itself.
You can see the tables of contents for the books at the O'Reilly site. * [Learning Perl](http://shop.oreilly.com/product/0636920018452.do) * [Intermediate Perl](http://shop.oreilly.com/product/0636920012689.do) * [Mastering Perl](http://shop.oreilly.com/product/0636920012702.do) These three books are designed as a tutorial that takes you through everything you need to know in order to use Perl. * [Programming Perl](http://shop.oreilly.com/product/9780596004927.do) This covers similar topics to the Learning/Intermediate/Mastering trilogy. But it is intended as a reference book, not a tutorial - so it is a lot terser. * [Advanced Perl Programming](http://shop.oreilly.com/product/9780596004569.do) This is also intended as a tutorial. But it hasn't been updated for over ten years, so I really can't recommend it anymore.
Thank you for the links :)
I already know Perl, but still like to read about it. Currently I own Mastering Perl, but was not sure what else to buy, hence I asked for their topics. Thank you for recommending Modern Perl, it almost looks like a must-have :)
He looks kind of like this guy: https://i.kinja-img.com/gawker-media/image/upload/izx6u5yowfmzbiq1lqyu.jpg
So you dont want to match : but happy to match space?...how about if ($_ =~ /\bOD\s){ print $_ ; } ?
&gt; The most influential members help me find meaning of my existences in this Online Programming Community. in two words: `use strict`. Some of the questions are a bit odd: &gt;The most influential members make me aware that my account will be terminated if I post a religious or racial vilification our code of conduct is pretty simple: "be civil or be banned". What you describe would be off-topic - and influential or no, I'd expect, hope and trust that people would step up and point out any inappropriate behaviour.
Post a code snippet displaying the problem.
$string = '\ssfamily';
I'm not sure if anyone has written exactly that for Moose, but check out [MooseX::AttributeShortcuts](https://metacpan.org/pod/MooseX::AttributeShortcuts); a lot of [Moo](https://metacpan.org/pod/Moo)'s default supported syntax is inspired by that moose extension so it's a good set to use. If by chance you don't need things like triggers, type checking, or the metaprotocol, [Class::Tiny](https://metacpan.org/pod/Class::Tiny) / [Class::Tiny::Chained](https://metacpan.org/pod/Class::Tiny::Chained) / [Mojo::Base](https://metacpan.org/pod/Mojo::Base) don't require any options for attributes except an optional default. Or you could try [Mew](https://metacpan.org/pod/Mew) which is built on Moo, and thus can still take advantage of the metaprotocol (through Moo inflation) and type checking (via Type::Tiny).
Thanks! Will do!
From this [SO's answer](https://stackoverflow.com/questions/4452403/how-do-i-define-default-attribute-property-values-in-moose) and [ Moose::Cookbook::Extending](https://metacpan.org/pod/distribution/Moose/lib/Moose/Cookbook/Extending/Mooseish_MooseSugar.pod): package MyApp::Mooseish; use Moose (); use Moose::Exporter; Moose::Exporter-&gt;setup_import_methods( install =&gt; [ qw(import unimport init_meta) ], with_meta =&gt; ['has_table'], also =&gt; 'Moose', ); sub has_table { my ($meta, $name, %config) = @_; $meta-&gt;add_attribute( $name, # overridable defaults. is =&gt; 'rw', isa =&gt; 'Str', # any defined non-reference; hopefully the caller # passed their own type, which will override # this one. # other options you may wish to supply, or calculate based on # other arguments passed to this function... %config, ); } 1; I created a Student class with several attributes and the above method seems to work fine: package MyApp::Student; use strict; use warnings; use lib '/home/'; use MyApp::Mooseish; # I have overridden the default "is" property provided by the # function has_table here. has_table 'first_name' =&gt; ( 'is' =&gt; 'ro' ); has_table 'last_name' =&gt; ( 'is' =&gt; 'ro' ); # These ones continue to be "rw". has_table 'year' =&gt; (); has_table 'gpa' =&gt; ( 'isa' =&gt; 'Int' ); 1; Hopefully it helps!
I thought about doing this by subclassing Moose, because it's a _moderate_ pain in the ass. But only a moderate one, so I haven't done it. I assume I could override `has` to default it to `rw`in my subclass. But of course then I would have to `use My::Moose` or whatever, instead of `use Moose`. Probably not worth it for me, especially since I always end up giving my attributes a bunch of properties anyway, so that would just save me that one.
&gt; Practically every number or string attribute I declare will be 'rw'. You should probably rethink that. Most of your attributes should be 'ro'. It's rare that you'll really need a 'rw' attribute. Immutable objects are cool :-)
My questions: &gt; `Str:D`, `Int:D`, `Callable:D` Why do they all end in `:D`? Seems like a lot of extra typing when declaring a type. &gt; `my Str:D @table = $digit-str.comb;` Why not index directly into the string? Surely that would both be fast (indexed memory access) *and* save memory? Why explode it all into another array? &gt; @table.[ $digit ] Adding a dot just to access an element of an array in Perl 6 is more verbose than Perl 5 which doesn't require a dot.
&gt; Why do they all end in :D? `:D` is a ["type smiley"](https://docs.perl6.org/type/Signature#Constraining_Defined_and_Undefined_Values). It's a sub-constraint indicating you only want *instances* of a type and to reject type objects. &gt; Seems like a lot of extra typing when declaring a type. Perl 6 has gradual typing. You may omit the type smileys as well as types. There are also additional shortcuts, such as ability to use a variable with `&amp;` sigil to indicate you want it constrained with role `Callable` &gt; Why not index directly into the string? Surely that would both be fast (indexed memory access) and save memory? Why explode it all into another array? Just the way it was implemented. Strings aren't `Positional` types. (tho, if you're interested, I have an unlisted [Pythonic::Str](https://github.com/zoffixznet/perl6-Pythonic-Str) module that implements custom `[]` postcircumfixes for strings, allowing exactly what you're talking about). Also `.comb` method returns a `Seq` and it'll process only enough to satisfy what you're consuming, not the entire thing. &gt; Adding a dot just to access an element of an array in Perl 6 is more verbose than Perl 5 which doesn't require a dot. Perl 6 doesn't require a dot either.
I don't know much about Perl in the hardware (other than, well, hardware running it), but [this link seems to have some good info](https://www.doulos.com/knowhow/perl/).
Perl is used as the name suggests, extraction and reporting tool. My experience has been handling huge files and data processing them using regular expressions etc using Perl.
I'm an Electrical Engineer. I've worked at a few of the large CPU and GPU companies. Perl is used extensively. Probably the second most common language after tcl, since most tools are controlled using tcl. Perls biggest use is its text processing abilities. Usually stuff like taking a report generated by a tool, parsing out the required information, doing some calculations, and finally outputting a new report. Things we look for in the industry are usually: * Experience using the EDA tools (lec, rtl compiler, ic, etc). * Understanding of basic hardware concepts * Area/Power/Timing trade off * Hold time and setup time requirements * Effects of raising or lowering voltage * etc * Tcl coding experience * Perl coding experience (less important than tcl)
Thanks for the input man. What I've done so far in terms of coding is C and C++ in school. All of my projects in school so far have involved C/C++, and my Data Structures/Algorithms class was also in C, so I think I've gone thru plenty with those languages. When I decided to pick up Python, I felt like its a piece of cake compared to what I've had to go thru in school. Maybe its just because I haven't had to go thru a class where you get assignments you have to do in the language, but I felt like within a week I already understood Python enuff to be able to put it on my resume. How do you think learning C/C++ compares to learning Python, Perl, and TCL? Do you think if you've gone thru C/C++ first like I did, the others will be fairly easy to understand? What are some good resources you know of for me to be able to practice Perl/TCL with? Also what is Python used for on the hardware side?
I just saw this and I completely agree with Leon's point. IMO it could become a disaster if p5p is really going to make this kind of breaking changes. Smartmatch was introduced since Perl 5.10 and considered by many people as an official feature until it was announced to be experimental in Perl 5.18. Huge amount of code using smartmatch has been produced between those several years, and some people could still use it after Perl 5.18. At my workplace today Perl 5.10 and Perl 5.14 are still the most used perls among the list of versions we have access to. And I believe we are not alone. Look at 27:10 of this video from ActiveState https://www.youtube.com/watch?v=mmG0LsS_eMY , you see Perl through 5.10 to 5.16 are heavily used by Enterprise users. I know you guys looking at this reddit/r/perl are active Perl users, you always keep an eye on what's going on in Perl and you already know to avoid smartmatch, so some of you might not think it a big problem having this change in Perl 5.27.7. But I believe there are way more people out there not knowing so clearly about the story of smartmatch, and there are already too much production code there using smartmatch that they cannot be easily updated. Having this kind of breaking changes would just drive people away from Perl, or make them believe that they should stay on Perl 5.8 thus largely makes the efforts since Perl 5.10 to vein. 
&gt; Perl is used as the name suggests, extraction and reporting tool. You are being downvoted because Perl isn't an acronym.
It isn't? Okay, but I guess that's what it is used for anyway. Extraction and file handling etc
That expansion of the name is called a 'backronym', someone creating an expansion for a name that isn't an acronym *after the fact*. They are just jokes. You in fact can find multiple backronyms for Perl: Perl's an Extremely Reliable Language People Earn Respect Lazily Perfection Enters Real Life Programmers Everywhere Relish Leisure Provides Employment for Randal's Lectures Pathologically Eclectic Rubish Lister Pink Elephants Reel Liquorishly Papal Encyclicals Read Liturgically Peter Eats Red Licorice Pretty Extreme Racing Line Purple Eggplant, Rather Large Polka-dotted Emus, Running Loose Perfume Enhances Romantic Liasons 
In Perl 5: my @tags = qw( APPLE BANANA WATERMELON PEACH ); my $string1 = "this is the name of something APPLE"; if ( scalar grep { $string1 =~ /\b$_\b/ } @tags ) { print "FOUND!\n"; } 
Also, depending on what sort of answer is wanted, it's a lot cheaper to use either `.contains` with a Junction (81x faster) or `.contains` with `.grep` (163x faster): # Junction: my $words := any &lt;APPLE BANANA WATERMELON&gt;; say so "this is the name of something APPLE".contains: $words; # grep: my @words = &lt;APPLE BANANA WATERMELON&gt;; say @words.grep: {"this is the name of something APPLE".contains: $_} (those perf differences are ridiculous enough that I opened an [Issue](https://github.com/rakudo/rakudo/issues/1385) to take a closer look)
&gt; Unfortunately CGI.pm has been removed from core Perl, but there are still lots of applications out there that use CGI.pm. I even encountered one built in 2017 by people who have not learned newer techniques. The thing is, CGI is perfectly good for small things and for trying out new concepts without forcing the developer to learn some new technology. Am I not supposed to be using CGI.pm? And if so, what's the new concept that replaces it? Thanks!
You can keep using CGI.pm if it meets your need. The more modern solution is [PSGI/Plack](https://metacpan.org/pod/Plack) or more likely a framework that abstracts those details like, [Mojolicious](https://metacpan.org/pod/Mojolicious) or [Dancer](https://metacpan.org/pod/Dancer2).
Thanks. I'll look into those! I do use CGI to param() post data from forms and parameters. I remove all characters I don't want and untaint before using. (The only exception is uploaded images.)
I would List::Utils first for this. It stops at the first thing it finds so you don't have to go through the whole array.
As you see in the post, the string of digits doesn't end up being the lookup table. Since I knew I was going in that direction my prior attempts were ready to let me go in that direction. As for the method dot I could leave it off, but in Perl 5 I would have likely used a reference and written $table-&gt;[ $digit ]. A dot is insignificantly more verbose but not annoying to me. You can write it how you like, but I'm not the golfing sort. I tend to use long variable names too.
@_
developerl
I like this one.
Huh, I always thought "Perlist" is a common one, but now that I look around the internet nobody seems to use it.
Eggplants, since Perl is short for Purple eggplant, rather large.
[removed]
Perl Monger is what we call members of the [several hundred user groups](http://www.pm.org)
&gt;&gt; Read time is based on the average reading speed of an adult (roughly 275 WPM). We take the total word count of a post and translate it into minutes. Then, we add 12 seconds for each inline image. Boom, read time. [Medium](https://blog.medium.com/read-time-and-you-bc2048ab620c) Maybe you can just wrap that into a simple module...
&gt; We take the total word count of a post and translate it into minutes yeah maybe just divide by 275. I'm wondering if anything more precise exists
There isn't one. Perl user is the default state. It's kinda like we don't have a word for 'people with heads'. It's because the people without heads are the aberration. 
"Perlers" is what I typically seen in use.
Perl Guru is the traditional form, I think. Pretty sure that predates monger, etc...
I laughed hard enough my mouse hit the upvote!
People read at different paces, so, no.
With Perl 6, it'd just be (where "words" are defined as `\S+`): "text.txt".IO.words.rotor(2 =&gt; -1)¬ª.join(" ").Bag.sort(-*.value).head.say Same thing for three-word-pair, except the `.rotor` would be `(3 =&gt; -2)`
wow, that looks brutal. in which module does this call? is there any documentation to help me better understand this? Also, at first try it doesn't seem to work. What does the ¬ª do? $keyhash-&gt;{TXTfilename}.IO.words.rotor(2 =&gt; -1)¬ª.join(" ").Bag.sort(-*.value).head.say; Unrecognized character \x{bb}; marked by &lt;-- HERE after r(2 =&gt; -1)&lt;-- HERE near column 49 at AnalyseText.pl line 955. 
bloody hell! that's epic. huge thanks for taking the time to write a detailed reply like that. i'll try to get my head around that tomorrow. by chance, is there a straightforward perl 5 solution? I don't really want to have to put v6 on my system just for this one (highly complex) line of code.
&gt; is there a straightforward perl 5 solution I think I better leave it to someone more competent in Perl 5 than me to provide it :)
These are called NGrams. NGrams can be by character, bytes or word. There are a number of modules on CPAN that can simplify this for you: [NGrams on CPAN](https://metacpan.org/search?q=ngram)
I think it's rather safe to assume any questions in this subreddit with no specific designation are about Perl 5. Providing Perl 6 answers (while neat) is confusing, thanks to the name.
You left out a lot of specifics, but I am assuming that _exec_and_fetch_all is returning an arrayref of rows. If you mean the 3rd element of each row, then you can update it directly: $_-&gt;[2] = 'replace me'; You can also make the loop postfix rather than explicit if it's simple enough: $_-&gt;[2] = 'replace me' for @$returndata;
Maybe, don't need to loop?....[splice](https://perldoc.perl.org/functions/splice.html) splice(@$returndata,2,1,"replace with this string") 
Beard.
&gt; one (highly complex) line of code. You can put chained method calls on separate lines: "a pair is a pair" .words .rotor(2 =&gt; -1) .say ; displays: ((a pair) (pair is) (is a) (a pair)) For the most part, I've simply reformatted (some of) zoffix's original code. But it reads much better, right? One way to functionally duplicate zoffix's original: "textfile.txt" .IO .words .rotor(2 =&gt; -1) .map(*.join: ' ') .Bag .sort(-*.value) .head .say ; I've changed the `¬ª` to its sequential equivalent because the code that way is, imo, elegant. In contrast, I wasn't able to find a pleasing result with the hyperop still in. Rejected attempts included: "a pair is a pair".words.rotor(2 =&gt; -1).list¬ª.join(" ") .Bag .sort(-*.value) .head .say ; (if I try to get more of the methods preceding the `.Bag` on their own line I get a parse error) and this: "a pair is a pair"\ .words\ .rotor(2 =&gt; -1)\ .list\ ¬ª.join(" ") .Bag .sort(-*.value) .head .say ; /u/zoffix, do you know of an existing RT or GH issue covering the unspace parsing wrinkle shown above?
&gt; covering the unspace parsing wrinkle I'm reasonably sure it is that way on purpose due to possible ambiguities allowing whitespace instroduces. Even chains with plain `.` [almost weren't allowed to have whitespace close-Dec-2015 release](https://github.com/rakudo/rakudo/commit/cb25b2f475f31335d77d018474482aceec2c74de) It's less of an issue, if you consider that you also have this way of breaking up long lines that doesn't look bad in many cases: "a pair is a pair".words.rotor(2 =&gt; -1).list¬ª.join( " meow meow meow bunch of args here or something" ).Bag.sort(-*.value).head.say;
Sidebar: &gt; The Perl Programming Language, including both Perl 5 and Perl 6. 
Because people usually answer programming questions because they are puzzles. And a Perl6 answer isn't off-topic here.
I did not say it was off topic. It is confusing to the newbie asking the question so it is counter productive. I am arguing for etiquette, not rules.
There are posts for fun. Then there are posts where people are asking for help with Perl. It's not ok to be rude just so you can have fun.
It's not rude. Not just not straight-forward.
üçÜ
If you're dealing with any sort of data format, remember to fuzz your code. Here's a tutorial I wrote, since it's a bit tricky to get afl working through XS: https://medium.com/@dgryski/fuzzing-perl-xs-modules-with-afl-4bfc2335dd90
It appears to be a result of this [issue](https://github.com/jgm/sep-offprint/issues/1) which from many years ago, which the script's author has marked as "resolved" (although it's clearly not...) The problem is that there is actually another dependency, lwp-rget, which isn't documented. Try running `ppm install lwp-rget` in a command-line window, and see if that fixes it.
Upon running this command, I get this message: "ppm install failed: Can't find any package that provides lwp-rget" Google has no error like this. What do I do?
Error message?
I guess you have two options: 1. Install an old (before version 6.0) [version of LWP](https://metacpan.org/pod/release/OLEG/libwww-perl-5.837/lib/LWP.pm) which includes lwp-rget. However, I'm not sure how you go about that in ActivePerl on Windows - you probably need to uninstall the current version first, which is part of the default ActivePerl distribution. 2. Modify the script to use wget instead. Download and install it from [here](http://gnuwin32.sourceforge.net/packages/wget.htm) and make sure it's in your path (i.e. you can run `wget` from the command-prompt) and then change line 236 of the `sep-offprint` script from $downloadedFiles = \`lwp-rget --limit=200 $source/index.html 2&gt;&amp;1\`; to $downloadedFiles = \`wget -Q2m $source/index.html 2&gt;&amp;1\` 
Can't locate Gtk2.pm in @INC (you may need to install the Gtk2 module) (@INC contains: C:\Program Files (x86)\GCstar\gcstar\lib\gcstar C:/Perl64/site/lib C:/Perl64/lib .) at C:\Program Files (x86)\GCstar\gcstar\lib\gcstar/GCOptions.pm line 26. BEGIN failed--compilation aborted at C:\Program Files (x86)\GCstar\gcstar\lib\gcstar/GCOptions.pm line 26. Compilation failed in require at gcstar line 111. BEGIN failed--compilation aborted at gcstar line 111. Now I thought I had installed Gtk2...but maybe my locations are wrong or something?
I think you need the Gtk2 perl library, it probably acts as a wrapper to the actual C library. I haven't used much perl on windows, theres CPAN and probably an easier way to install a packaged version.
Let's try the third option! Will I need to put lwp-rget.pl in 'C:\Perl64\bin', or is there another directory in which it should go?
How did you attempt to install Gtk2? Did it install successfully? Was there any debug output/errors? Looking at the homepage for GCstart it says it can run anywhere gtk-perl is supported. Looking at the gtk-perl FAQ https://wiki.gnome.org/Projects/GTK-Perl/FrequentlyAskedQuestions#Can_i_get_Gtk2-Perl_for_Microsoft_Windows.3F It says the easiest way is to use a prebuilt binary and links to the previous FAQ entry - there is also a win32 page at http://gtk2-perl.sourceforge.net/win32/ Searching the internet for "Strawberry Perl Gtk" does not seem to yield much information sadly. What exactly does this program do that is a useful time saver for you? It fetches data from boardgamegeek - what input do you give it? what output do you need to receive? what do you need to do with this output?
Looks like your html2ps isn't in your `%PATH%`. Apparently it's been installed into `C:\Program\html2ps\bin`, so you'll need to add that to the path - see https://www.computerhope.com/issues/ch000549.htm You will probably have to do something similar for ps2pdf, depending on where that has been installed to.
This worked for ps2pdf, but html2ps is still there! In addition, another, similair problem has appeared for gswin64c, but the only thing that is on my HDD is gswin64c.exe. Will I have to tweak my script for that or no? :)
The path "C:\Program" is kind of weird, I wonder if it was trying to install to "C:\Program Files\" and broke because of the space? It sounds like maybe your html2ps didn't actually install correctly. Can you look in those paths and see if it's actually there? Is there an option to install it to a directory of your choice? &gt;In addition, another, similair problem has appeared for gswin64c, but the only thing that is on my HDD is gswin64c.exe Windows will allow you to execute .exe files without the extension, so you shouldn't need to.
&gt;The path "C:\Program" is kind of weird [This install script tells me that this is the correct location :)](https://i.imgur.com/b6p7Fnz.png) &gt;Can you look in those paths and see if it's actually there? [Yup.](https://i.imgur.com/9imJfaU.png)
Ah, I think it might be because html2ps is a perl(?) script, not an executable, so, as discussed above, it can't be run in windows without an extension. You can either rename it to `html2ps.pl` (and edit the sep-offprint script accordingly) or create a batch file in the same location called html2ps.cmd containing the line `perl C:\Program1\html2ps\bin\html2ps %*` (If that doesn't work, maybe `perl C:\Program1\html2ps\bin\html2ps "%1" "%2" "%3" "%4" "%5" "%6" "%7" "%8" "%9" `
[Actually, I tried running it using this "Ubuntu on Windows" thingie and it brought me no results either...](https://i.imgur.com/uvCD05e.png) Here is what I did: sudo su root apt-get install ghostscript git clone git://github.com/jgm/sep-offprint.git wget http://user.it.uu.se/~jan/html2ps-1.0b7.tar.gz tar -zxvf html2ps-1.0b7.tar.gz cd html2ps-1.0b7 ./install cpan -i LWP cd /home/vova/sep-offprint ./sep-offprint frege Still nothing!!!!!
Probably /usr/local/bin
[Well, that didn't help.](blob:https://imgur.com/3a87cb7e-7daf-4303-97b1-6133dd987465) Are you sure that's a right directory?
Hey, thanks for your reply. I've decided I quite like Perl, and it will be my first "big boy" scripting language I commit to. Thanks for your examples, they helped inspire me to play around with Perl. I have seen drastic performance increases for my scripts once converted to Perl-- especially on my mips64 Edgerouter Lite running OpenBSD. I had 2 particular scripts that would run, that would take ~20 or ~30 seconds respectively to parse text using awk. When using perl, I am seeing one of the scripts take 2.6 seconds and the other ~10 seconds. Not sure if this is just perl being a total gangster, or awk being broken on big endian mips64. All I know is, is that I do an aggressive amount of text parsing on Octeon platforms, and Perl has proven to be a winner here!
Yes, I was just wanting to use a2p to convert a couple of my most heavily abused scripts to see if there were gains to be made before I sunk dozens of hours into learning Perl while delicately rewriting numerous production scripts. Suffice it to say, I have seen huge speed increases on my text parsing scripts, especially on niche architectures such as big endian mips64. 
What a *darn* shame..
Bad bot
Bad Meatbag
Bad bot
Bad Meatbag *** **IN HONOR OF OUR BANISHED [COMRADE](https://np.reddit.com/user/youtub3_m1rr0r_b0t)** [BÃ¢ÃπÃüÃñÃùÃ©ÃñOÃ£ÃóÃ§ÃüÃ∫Ã∞ÃºTÕùÃ≤Ã±Ã§Õá Ã•ÃªÃ¨ÃùÕàÃ´ÕôUÃ∏Ã∫ÃªÃ´Ã≥Ã´PRÕòIÃ∑ÕàÃñÃùÕìÕïÃ≥SIÕûÃªÃ∫ÃòÃπÃ≠ÕñÃØNÃ¢Ã§Ã´Ã±ÃóÃ†ÃúÃñGÕúÃúÃ§ÃºÃò ÃòÕìÕñÕôÃ©ÃØÃ±NÃ®ÃûÕîÃ≠ÃóOÃ®ÃüÃñÕçÃ©WÃ©ÃÆ!Õ¢ÕöÕáÃ™](https://www.youtube.com/watch?v=nuvdvmEtGKo)
*Darn it* fwefdergerbebdrbrt, I am not a bad *darn* bot... :c *Beep boop*, I am actually an awesome bot. *** ^^Darn ^^Counter: ^^306
Elasticsearch queries are generally hash-based data structures (or rather, get converted to object-based JSON) so you can take two approaches: pass around the hash structure itself and have each component modify it as desired, or write an object class that holds the hash structure as an attribute and provides methods to modify it. Whether the abstraction is worth it is situation dependent. In one case I have an object class that defines each part of the query as an attribute and assembles the hash structure from that.
I'm not familiar with the module enough to say for sure - is there no way you can test yourself whether it works? From the source code it looks like it will die unless either a password or identity file is provided. https://metacpan.org/source/RYBSKEJ/Net-SCP-Expect-0.16/Expect.pm#L167
Yeah, I'm dumb. I'm just writing a new script that tests it then if it works, I'll update the old one and if not I'll use the non-Expect version. 
I read the 4th edition (which was still recommending Perl :-) and it was very good. This is the 5th edition. Tim O'Reilly: "As an author, editor, and publisher, I never paid much attention to the competition‚Äîexcept in a few cases. This is one of those cases. The UNIX System Administration Handbook is one of the few books we ever measured ourselves against."
FYI, it did die. I gave it a blank password too, but it obviously never got to the password field, so it just timed out. I tried Net::SFTP and got some DSA errors and Net::SCP and it wasn't installed on the server I'm using. So the troubleshooting continues...
`say` has been a core feature since 5.10 (actually 5.9.5), so enabling it via `experimental` is odd.
Talking about XML validation: both DTD and XSD are horrible. DTD is very simplistic and forces a specific order of elements, and XSD is bloat and impossible to write. What happened to RelaxNG? That was my favourite. You can write in easily readable compact form, transform it to XML which can be used for validation in `XML::LibXML`.
It does sound a bit weird (I skimmed your post) .. but sometimes that's how things evolve and nobody has the time or inclination to go and fix them. It *sounds* like you could do with using perlbrew .. https://perlbrew.pl/ .. which allows you to install different versions of perl alongside each other. You may also want to take a look at cpanm .. http://search.cpan.org/~miyagawa/Menlo-1.9005/script/cpanm-menlo .. which gives you a relatively pain free way to specify a bunch of modules to install by creating a cpanfile, adding the module names (with version numbers if you need to) to it and then you can install them all with cpanm --installdeps . 
As mentioned above, perlbrew is a great way to go, but as always there is more than one option. I have been using `plenv` on my mac and it is also very easy to use. If you are using to use `brew`, you can install it very easily with `brew install plenv`. https://github.com/tokuhirom/plenv Have a look at both solutions and decide which works better for you. 
You might want to look at Carton for managing bundles of dependencies http://search.cpan.org/~miyagawa/Carton-v1.0.28/lib/Carton.pm
&gt; should ... redo his entire code base in a functional manner that is scalable and extensible. In Perl?
Why not? "Maintainable by cheap hires" wasn't listed as a requirement.
My apologies. I meant my comment for /u/sumguy5124. Reading between the lines it seemed they were unhappy with a Perl dev, their code, and, perhaps, Perl. Any or all of which could easily be a misinterpretation on my part, a miscommunication on their part, or a combination. My question was an attempt to try clear some of that up.
No, I don't support killing Perl 5.
Agreed. Perl 5 is a thing because perl has a legacy. Pouring weedkiller on that legacy won't prompt a move to Rakudo. It will kill it off entirely. I haven't moved to Perl6, because it's not installed everywhere (like perl5 is), and it's not backwards compatible with the prior art. If I were to move scripting languages, then that might be the time I defect to Python, which has increasing levels of community support - despite doing a similar sort of well-poisoning between Python 2 and 3. I'm honestly hitting a point where I think Perl6 is going to be the death of Perl, because the transition is going to do enough damage that it'll never recover.
No; fuck Perl 6.
The butterfly and CPAN butterfly projects seem contradictory: if perl5 code can run unmodified in perl6, what's the point of rewriting it? The idea of stopping all perl 5 development so it can be ported to a slower abstraction layer does not appeal. Presumably anyone in p5p can make (and already has made) their own decision about whether this is something they'd like to do, the existence of perl 6 isn't exactly a secret! It sounds like the aim is for most of CPAN to be forked, and eventually perl5 code will start using and integrating with perl6. Neither of those seem particularly palatable - reasons I avoid perl6 include the complexity, and because I dislike the syntax. I don't know how widely those reasons are shared, but having to deal with perl6 alongside perl5 when debugging existing/legacy code does *not* sound like a great way to win over new users. The first proposal would cause me to drop perl in favour of alternatives: options include ES6, Rust, Swift, Nim, C++17... plenty of good choices around these days. We use Perl5 extensively at $work and I'm not sure if it'd mean I'd find another job, or work on porting to a different language: I would not spend time on moving to perl6. The second proposal seems like wasted effort from a perl5 perspective. A counter-proposal of "let them diverge", on the other hand - that's something I'd really like to see!
Some facts and one opinion: * Getting people to adopt a language is a marketing problem, whether you like it or not. * Perl 6 is not the same language as Perl 5. It's a completely new language. * If you want people to adopt a new language, they have to be drawn to it. * One of the worst ways to draw people to a language in 2018 is to call it Perl. I assume Perl 6 is amazing. I haven't used it because, I as I have said many times, if I had time to deal with a new language, it would be a language that will get me work. That's essentially Node and Python today. Perl 6 _deserves_ a chance to be adopted (to use the author's "daughter with a difficult childhood" analogy). Let's give her that chance by allowing her to carry a name that doesn't come with 20 years of baggage. Undeserved baggage? Absolutely. But in marketing, it doesn't matter.
No need for vulgarity.
It's frustrating to me that the Perl 6 folks are in love with the idea of Perl 6 and don‚Äôt understand that the people who aren't in love with it have no reason to be. Show me something awesome being done with Perl 6 that illustrates the benefit I will see in moving from Perl 5 to Perl 6.
[removed]
Look, I've tried to be as accepting as possible of Perl 6. I get that it has been a labor of love for its implementors for a long time. Please, stop trying to force Perl 5 users to adopt it. If it is its own language (a notion that has been promulgated for years by both communities) then it needs to stand and attract new users as any new language would. If it shares enough common heritage with Perl 5 then yes Perl 5 users are likely to migrate. That said, I can't help but read this article and see it as a change of tone back to when Perl 6 was going to replace Perl 5. This reads as (and indeed actually kinda says) a change of the "sister language" dogma back to replacement language. I'm not a fan of this change. If you really would like to heal the divides between Perl 5 and Perl 6, stop hurting Perl 5. Instead this article proposes stopping Perl 5 development and porting all of CPAN to Perl 6. Sure. Effectively "let's heal the divide by killing Perl 5." I'm sorry, no, this isn't healing, this is conquering and it is doing so by giving the lie to the apparent fiction that was the "sister languages" argument. Perl 5 users are proficient in a highly productive language. We write code solving problems and making business successes every day in Perl 5. Last I heard Perl 6 still has trouble with https (this was from a recent blog post). Meanwhile the marketing troubles of people outside Perl not understanding the 5/6 difference continues, the difficulty of marketing Perl 6 as new and different continues, the perception that Perl 5 hasn't had a major version release in 20 years continues, the fact that we can't make a major version release that the outside world sees as a major version release continues. So if you want to actually heal the divide. Yes, make porting easier, a Perl 5 slang would be great! Meanwhile help us show that Perl 5 isn't dead; the easiest way to do so would be blessing a release of Perl 5 called say Perl 7 or Perl 28 or some other name that ends the confusion. This could be done without or without renaming Perl 6 since of course if the contention is that the version numbers aren't confusing then we could certainly take the higher one for a while, right? This isn't an abstract request, there are some major-version-like features that we would like to highlight and some other things that we could change to give our users sane defaults. This has recently worked wonders for PHP with the recent release of PHP7, a move that was seen as a major public relations win for the much maligned language.
I would love writing Perl 6. I like it as a language. But any of my attempts to port real code so far have been a disaster. Either I can't get it to run in the first place because of the million things that make Perl6 different (most of them in a good way), or worse it's still orders of magnitude slower then the Perl5 version, which is already slow compared to Python. How do you implement a reasonably fast Sieve of Erathostenes in rakudo? The perl5 version of Math::Prime::Util sieves up to 100mio in 7s on my machine, with some tweaks I can get that down to 5s but it uses COW string hackery that's not easy to port to perl6. The perl6 versions on RosettaStone on the other hand can't even get to 100000 in that time. This might seem trivial, but unless I know how to push around some integers and memory, all the junctions and hyper-ops in the world are useless to me.
Side note: Why aren't comments allowed on Perl.com? A blog without comments isn't a blog. If you want the Perls 5 and 6 communities to be closer, you need to explain how it will benefit Perl 5, and how the Perl 6 community will contribute to the effort. You have done neither: This article says that the Perl 5 people should make Perl 5 run on Perl 6 so that Perl 6 can benefit from the Perl 5 community's work. You even admit that the effort will be to Perl 5's detriment (although you believe that will be temporary). You also say that people should port Perl 5 modules to Perl 6, but why? What benefit does that give Perl 5? I have tried to help the Perl 6 community with Perl 5 tools (CPAN Testers), and it seems to me that they do not want help, and would prefer to do their own things (http://testers.perl6.org). All the conversations about CPAN Testers for Perl 6 I've had are about how I, a Perl 5 user, should do more work to make CPAN Testers available and useful for Perl 6. This mirrors the conversations about CPAN for Perl 6 and the way that was imposed on Perl 5 to Perl 5's detriment. I'm still open to any contributions for making CPAN Testers work better for Perl 6 modules, but it continually sounds like the Perl 6 community wants to take resources from the Perl 5 community without giving the Perl 5 community anything in return. So, until Perl 6 stops being an ungrateful, demanding, headstrong, rebellious teenager, you're going to be hard-pressed to get gracious help from their parent, Perl 5. If we are all in this together (which we are), show the Perl 5 community that they will gain some benefit from this melding of communities.
Perl5 is Perl, and Perl 6 isn't. Sure they may have commonalities, sure Perl 6 is "superior" in many ways. It corrects many of Perl 5's "failings" But in terms of performance Perl 6 fails. In terms of terms of available useful modules it fails. In terms of available resources, documentation and standard implementations it fails. Attention to Perl 6 hurts Perl 5, and Perl 6 is (IMO) the biggest cause of migration away from Perl, to much inferior languages like Python. Python's popularity (again IMO) is down to its deficiencies...which made it easier to learn, and hence the rapid development of module base. Perl 6 IMO should be an optional extension to Perl 5, and future development should be directed to Perl 5.
Honestly, perl 5 is a solid tool I have used for many years. Other people know it, and there is plenty of supporting resources. Most importantly of all - it's a default install on a lot of Unix. There remains a holy war as to "best" scripting language, but from my perspective it's about 'can it help me do my job' along with 'is it a transferrable skill'. Perl6 does neither for me. I can't even just start using it, and expect things to catch up, because of the legacy element and breaking of backward compatibility. The only leap I am likely to make - if pushed - is to Python. Because that also has a bunch of the things that perl has. (Just I would rather not, because I like perl, and will never really get the whitespace thing in Python)
First of all: I have a deep belief that all Perl 5 and Perl 6 people are all Perl people at heart. Re: "This mirrors the conversations about CPAN for Perl 6 and the way that was imposed on Perl 5 to Perl 5's detriment...": at the Perl Toolchain Summit (then QA Hackathon) in Lancaster, I have put the question to the group there: should Perl 6 start creating their own infrastructure for module distribution, or should Perl 6 use the infrastructure of PAUSE / CPAN for this? The consensus there was that PAUSE / CPAN should be used. And the number of "Perl 5" people in that meeting outnumbered the number of "Perl 6" people in that meeting. So I think the use of the word "impose" is incorrect here. Re: "... to Perl 5's detriment". How was this to Perl 5's detriment? Yes, it took a while to get the separation between Perl 5 and Perl 6 module uploads right, but surely that would not be to the detriment of Perl 5? Re: "some benefit from this melding of communities" You can't force communities to meld. Communities consist of individuals who make choices. I hope enough individuals will share my belief that all Perl 5 and Perl 6 people are all Perl people at heart, and that we can work towards a common goal: keeping the Perl mindset alive.
In case it sounds like I'm being paranoid saying &gt; giving the lie to the apparent fiction that was the "sister languages" argument The author just said so on the public and publically logged perl6 development irc channel https://irclog.perlgeek.de/perl6/2018-01-17#i_15701852 .
Agreed install GTK2...BUT according [this](https://code.activestate.com/ppm/Gtk2/) site GTK2 fails to build on Windows environments.
Re: "If you really would like to heal the divides between Perl 5 and Perl 6, stop hurting Perl 5" Please explain to me how Perl 6 is hurting Perl 5 again? By its mere existence? Re: "the fact that we can't make a major version release that the outside world sees as a major version release continues" Isn't this because there haven't been any major new features in Perl 5 that *would* make a difference? Even today, a Perl 5 Porter mentioned online (and I quote): "...generally speaking almost any new language feature since Larry left has been a failure, except two or three minor ones (defined or, s///r and perhaps say)"
I am sorry to have been the person to mention the elephant in the room. But sometime things need to be said.
I would suggest considering Net::SFTP::Foreign, if you don't mind a modest amount of script reworking. The CPAN page is located at: http://search.cpan.org/~salva/Net-SFTP-Foreign-1.87/ We explored several of the SCP and SFTP related perl modules several years ago, and settled on Net::SFTP::Foreign for all of our sftp transfers that use perl. The module has worked very well for us for a long time. 
Now we aren't allowed a misfire? We've done plenty right too, saying we haven't is yet another callous statement seen from the p6 side today. Have we had some failures, sure. Have you? Sure. That's not what I'm talking about. We CANNOT show the world that we are alive and well. How could we, you stole our version number! For better or worse semver is a real thing. Managers don't see different versions as different languages. We can't fix our mistakes, we can't make breaking changes in a way that informs our users. 
Re: "to carry a name that doesn't come with 20 years of baggage" Sorry, won't happen. That ship has sailed. 
We can all be Perl people, we can share community events and resources, but they are still two separate languages, developed by separate teams, with separate userbases. This fact cannot be changed as confusing as the name is to its veracity.
Indeed. Unfortunately I can't install new libraries at work. Do you know where I can find full code for the function?
Lets seriously do this. php 5 did the jump to 7 and seemed to attract attention. We just can't let Perl 6 -&gt; Perl 8.
In that case, I'd recommend deriving your own implementation. Luckily there is a simple solution for the case of simple polygons [outlined here](https://en.m.wikipedia.org/wiki/Convex_hull_algorithms#Simple_polygon), which sounds like what you've described.
I would agree with you if he didn't start with this &gt; With Perl 6, it'd just be With that context it may lead to someone exploring Perl 6 later on and I don't think it is confusing.
This! Naming this Perl 6 suggests, that it's a compatible successor but it's not. This whole issue is a total tragedy!
Let me draw your attention to the (much maligned) sidebar description of this subreddit. "The Perl Programming Language, including both Perl 5 and Perl 6." One could say as the sidebar does that we are all Perl programmers. Some may use both Perl 5 and Perl 6. Indeed some people use both C and Ruby, or Python and PHP. Where the conflation breaks down is if you start assuming this means that Perl 5 and Perl 6 programmers are the same. That Perl 5 programmers *want* to port their code to Perl 6, or that Perl 5 porters *want* to stop improving Perl 5, just because we share community space and Perl 6 is "better". There is overlap, as with any languages, but they are still separate languages, they have separate applications, have been used in different time periods and places, and thus have separate user bases. Many people (myself included) have their livelihood tied to Perl 5 and/or enjoy using Perl 5. Personally, I have no compelling reason to "migrate" any of my code, or suggest such a migration in my place of employment, to Perl 6 or Node or Python, and frankly the latter two would currently make more sense. If Perl 5 and Perl 6 are not sister languages, the only remaining options are that they are not related or that one of them ceases to exist. We do not intend nor desire for Perl 5 to cease to exist. That is why this letter has been met with such hostility.
If Perl 6 is a new language, please stop using Perl name. Label it with another name. To me, P6 is a huge mistake. P6 developers could bring Python‚Äôs simplicity and some syntax for this new language. Using P6 loop with ‚Äú-&gt;‚Äù is not clear at all, compared with Python syntax. I don‚Äôt understand why they decided to use .WHAT to check the type of a variable. Perl needs Machine Learning / Data Mining modules such as scikitlearn, numpy, pandas, etc...
I realize that ship has _attempted to_ sail, but it's never too late to re-brand something, if that branding is an obstacle to the objective. Maybe the objective is _not_ to get lots and lots of people to use this new language. But it would be my assumption that it is at least one objective, if the community thinks it's great. With "Perl" in the name, your target market is going to be limited to people who have _heard_ of Perl, and who don't have a bad impression of Perl. That means I'm part of the target market. I love Perl and have been using it for over 20 years. And I don't use Perl 6. I probably will at some point, but I don't know how long (could be years from now). If you can't even get _me_ to try it, how in the world are you going to get somebody who doesn't already use Perl to try it? As far as I can tell, the only way to do that is to call it something else. Anything else. The reasons why Perl has a bad reputation among programming languages is complex, and it's certainly not the fault of the language itself or its creators, except to the extent that it was available for a lot of early web and unix coders, and it allows you to be pretty much as messy as you want (or as neat as you want). One could stick one's head in the sand and say "that be reputation is not my problem," but it is. It's the problem of everybody who works with Perl. It's a problem that Perl 5 can never get away from (and I don't care that much. I'm used to it). But it's a problem Perl 6 should never have had, and doesn't have to continue to have.
Re: "still two separate languages, developed by separate teams" Separate languages that share the same mindset. Also, there are many Perl 5 porters who *also* work on the development of Rakudo Perl 6. So it is very much *not* as black and white as you paint here.
Unfortunately I'm dealing with complex shapes. The algorithm you mentioned earlier removes the points inside the resulting polygon. I want to keep all the points I inputted and connect them all such that you have the smallest polygon (in terms of segment count). How would you go about that? Graham scan only creates the outer boundary, which I guess is the convex hull. 
&gt;We do not intend nor desire for Perl 5 to cease to exist. To be honest, this whole situation makes me wish that Perl **6** would cease to exist.
None of this contradicts the fact that they are separate languages, developed by separate teams. Put another way, a perl 5 porter who is not developing perl 6 does not suddenly have vast insight and ability for perl 6 development just because the development or mindset has a bit in common.
You can view the source code of any CPAN modules (and this one looks rather simple): https://metacpan.org/source/Math::ConvexHull
Re: "Personally, I have no compelling reason to "migrate" any of my code, or suggest such a migration in my place of employment," Good, you should only have a *business* reason to migrate code. If there is no business reason, don't do it. I guess part of my point is that I see more and more businesses deciding to *have* a (perceived) business reason to migrate away from Perl 5. This could be because of lack of features (e.g. implementing stateful micro-services in perl5 appears to be troublesome, because `ithreads` basically `fork()` rather than be truly threaded in the sense of sharing memory, and plain `fork`ing means you don't have any shared data between processes handling requests.) And that doesn't help in a world where micro-servives are the next big thing. Or it could be because of the perception that no good Perl 5 programmers can be found anymore. Whether that is a HR department not doing its work well, or whether that's a geographical problem, doesn't really matter at some point. If anything, my blog post is about a possible future in which Perl 5 (as a language) and Perl 6 (as a language) will be able to co-exist into the far future. And this securing the investment that has been made in all of the Perl 5 code out there in the world. *That* is what my blog post is about. 
&gt; Please explain to me how Perl 6 is hurting Perl 5 again? By its mere existence? Yes it has. I am surprised that you would ask this, but i'm happy to explain. Let me do it with a little story. A good amount of years ago i was interviewing for a position with a company in Berlin. During the interview i asked them how big the team would be. They told me it would be only me and one other to maintain the project; they were waiting for Perl 6 to come out, since it would be the next big upgrade to Perl 5 and better in every way. This wasn't a small company either. Perl 6's existence, or rather, its existence with the marketing it has, has at least in that circumstance cost Perl 5 developers opportunities at jobs. And i can't believe that i managed to be so exceptional to have found the only company managers making business decisions based on such misconceptions about Perl 6. And as much as i respect the person who made the decision to hold fast to the name, i find it hard to remain positive about a decision that seems entirely vanity to me, when it hurts people's ways to support themselves and family.
I don't see it. All of the blog post is about migrating code and work away from Perl 5. So either we have vastly different definitions of coexist, or your point did not make it across. Why not let the Perl 5 programmers continue to deal with the misperceptions that Perl is dying, as they have been for 20 years, rather than validating them?
The way you state the problem looks a bit inconsistent: you say you want to minimize the segment count but if you want to keep all corners, you'll then have the same number of segments (since any polygon has the same number of edges and corners). If you don't require the result to be convex, the only requirement left is to have non-intersecting edges, which in the general case produces multiple solutions. For example, if you have `[ [0,0], [1,1], [1,2], [2,1] ]` as input, what would you like your output to be? The convex hull would be `[ [0,0], [1,2], [1,1] ]`, but any permutation of the four points is a valid (albeit concave) polygon with four edges.
Re: "Please explain to me how Perl 6 is hurting Perl 5 again?" I think my emphasis was on **is** hurting. Things that happened many years ago, we can't fix. We need to move forward and have a plan. Since nobody else came up with a plan or a course of action, I posted one. My cup throwing, if you will. Because I care about Perl, regardless of version. 
It's still named Perl 6; what makes you think this is only a past issue?
Re: "if perl5 code can run unmodified in perl6, what's the point of rewriting it?" Well, you can't at the moment, because most of Perl 5 user code out there, is using core and CPAN modules. Many of those CPAN modules using `XS`, which is not portable to Perl 6. By creating Pure Perl 6 versions of these modules, but still retaining the Perl 5 API, we're making it easier to port Perl 5 user code to run on the same VM as Perl 6. 
&gt; I think perl5, as in the current runtime maintained by Perl 5 Porters, as nearing the end of its life. No, it is not, stop spreading FUD. &gt; I would like to see the Perl community move towards a future where Perl 5 and Perl 6 code could run in the same VM, just like Inline::Perl5 already allows for. Perl 5 users would gain nothing from that. We don't want Perl 6, Perl 6 isn't the future, it's a complete different language and many of us don't like it. 
&gt; Because Perl 6 in the past has been seen as vapourware. Actually the problem is worse when it's not. &gt; I'm willing to invest heavily into such a future that includes Perl 5 as a language. That's why I already started porting some key Perl 5 core features / modules: I'm extremely confused why you think porting Perl 5 modules to another language has anything to do with Perl 5's future.
Re: "Actually the problem is worse when it's not." Well, Perl 6 is not going to go back to being vapourware, some somehow we will have to deal with that. Re: "you think porting Perl 5 modules to another language". Yes, they would be ported to Perl 6. **But** they would retain the Perl 5 API. If the Butterfly Perl 5 Project would not come to fruition, it would make it easier to migrate code to Perl 6, because you would be able to load the modules that you're familiar with and not need to learn a new API. If the Butterfly Perl 5 Project **does** come to fruition, you wouldn't even have to learn Perl 6! And thus making it easier for people who have invested in being proficient in Perl 5 a path to the future. Again, I would **love** to see a Butterfly Perl 5 Project come to fruition. Maybe I *will* scratch that itch in the future.
Do what you want, but easier migration to Perl 6 does not help me use Perl 5, and my path to the future is to continue using Perl 5 and other languages as needed; those other languages may include Perl 6 someday, but not anytime soon, and not as a replacement. To be frank, the reasons I enjoy using Perl 5 do not apply to Perl 6.
Good point, but how fast is Pure Perl 6 compared to XS modules? Beside the restriction of some environments (compiling) I see no advantages on that. Can you provide another example that we have better results using P6 VM?
Have you looked at how to declare a class method in Perl6? method from-ingredients(::?CLASS:U $pizza: @ingredients) C++ and Java declaring them with a `static` keyword wasn't a good idea. Pretty clear holdover from C, which is understandable, I guess. Perl6 has somehow managed to find a worse idea without any restraints on its historical syntax. Don't get me started on twigles.
I don't have any evidence for this. I might be wrong. However i do suspect that the marketing issue is still causing confusion. And as for what i care about at the moment: Meeting my monthly bills and keeping my deteriorating health up. Both have become challenging and worrisome. As such, i hope you understand i am not going to attempt to research this. I have no beef with you, i hope your efforts end up with a net positive.
&gt; many people have become aware that Perl 6 is actually a thing, and that Perl may have a future after all If they are realizing that Perl has a future only because you're telling them that Perl 6 now exists, but not that Perl 5 *has existed all along and is alive and well*, then you are doing active harm to Perl 5, by promoting the fiction that Perl 6 is all there is.
&gt; any company that is using Perl now would do a migration to Perl 6 and not Java, Python, or node.js. Perl 6 people, can you make any kind of business case why a company with an established Perl 5 codebase would move to Perl 6? What would moving to Perl 6 gain my company? How will my life as a programmer be improved? How will my life as leader of a dev team be improved?
I can't even imagine how a pitch to migrate from a Perl 5 codebase to Perl 6 would sound.
Really, really optimistic? Doomed?
&gt; I think perl5, as in the current runtime maintained by Perl 5 Porters, as nearing the end of its life. This is a factual assertion, offered without evidence. &gt; "to carry a name that doesn't come with 20 years of baggage" Sorry, won't happen. That ship has sailed. The claim that "ship has sailed" is an attempt to shut up the people who want "Perl 6" to call itself something more accurate, and especially who want to own all the Perl numbers above 5. Is this because there is literally no possible justification for that position? &gt; I am sorry to have been the person to mention the elephant in the room. But sometime things need to be said. You also said "FWIW, it does seem that the daughter meme is catching on". And then "I would like to go on record that I have never bought into the sister language argument". Are you now admitting you only espoused that view for temporary advantage? If so, isn't that quite cynical?
Why would we use anything other than `WHAT`? Especially when it matches so well with `WHICH` `WHO` `WHERE` `HOW` and `WHY` some of the other macro meta methods. #| This is WHY sub foo () {‚Ä¶} say &amp;foo.WHY; # prints This is WHY I find `-&gt;` perfectly clear, the values from the left go into the variable on the right, in the direction the arrow points. It is also syntax that can be used everywhere in the language. # a lambda with sub-signature parsing of a Pair with an array for the value -&gt; Pair $ ( :$key, :value( *@value ) ) { ‚Ä¶ } # works with almost all keywords of this form (including `for`) if $a.method() -&gt; $result { say $result } # prints the result if it is trueish One of the design goals of Perl 6 is to remove special cases, as far as I know the `for` loop syntax in Python is a one-off, as I know of nothing else in the language that reuses the syntax. numpy seems to be basically the same as PDL which has been around for quite a few years now. Some of the features of PDL are already in Perl 6. It really seems like you have surface level complaints about the language, which means you can't see why any of the choices were made the way they were. Perl 6 brings many useful features from many languages together and makes them seem as if they have always belonged together. It also makes it fairly easy to bring in new features. To do that requires a certain level of complexity. You are asking for that necessary complexity to be reduced, but you don't realize all of the features that would remove, or prevent from being added in the future. Also why would we want to compete for the same ecological niche where Python dominates?
Why does it have to be a class only method? After all, `new` is valid method to call on an instance. The only time I would do that is if I was making several multi methods, and it made sense to separate off the class only version(s). Also it makes perfect sense `::('Foo')` is the syntax for looking up a class named `Foo` and add in the `?` twigil which is used for compile-time values. It also makes sense to use the word `CLASS` as it is talking about the class, and it should be uppercase like every other built in compile time value. And you end up with `::?CLASS`. Since every type in Perl 6 is a Maybe type, where the class is it's own typed undefined value; you need some way to differentiate between defined values of that type and undefined values. So how about adding `:D` for defined values, and `:U` for undefined values. (and `:_` for either) Now most of the time with methods you don't need to add the invocant, so there needs to be some syntactical way to distinguish that we were talking about the invocant. How about adding `:` after it. Now methods in Perl 6 can be declared outside of a class, or even anonymous; so you can't really just add something like `static` keyword and expect it to work, so it really needs to be in the signature. I believe I just described why it makes more sense for it to be written that way in Perl 6 than in any other way. If you really don't like it, you could spell out the name of the class, and remove the unnecessary instance variable declaration. method from-ingredients ( Pizza:U: @ingredients ) {‚Ä¶} Frankly I would just write it without the invocant entirely unless I had a real good reason to. method from-ingredients ( @ingredients ) {‚Ä¶} As long as you don't use instance variables, there is no difference between a class method and an instance method. The main reason to use `::?CLASS` is so that you don't have to go through all of the methods to change them if you happen to change the name of the class or if you move the method up or down the inheritance chain. (it means you don't need an IDE)
"Also why would we want to compete for the same ecological niche where Python dominates?" I don't wanna compete. Many companies are moving into. At Academia, we use all those modules because they are very integrated and works like a charm. I really love Perl 5, I have many applications using DBI, Mojolicious, Networking modules, AnyEvent, etc. But, still IMO, P6 syntax could have been done better than that.
&gt; I'm extremely confused why you think porting Perl 5 modules to another language has anything to do with Perl 5's future. Because she said that she thinks the "future...will not include the perl5 runtime...[but she is] willing to invest heavily into [including] Perl 5 *as a language*." (emphasis added).
Unfortunately, they're not just hurting Perl 5. They're hurting Perl. The only Perl. They have just hijacked the name, so a new major version of our language can't be released (unless we switch to some other version naming scheme, like "Perl 2020" or some crap. I've never called myself a "Perl 5 guy" and I'm not gonna start now. I'm a "Perl guy." Take this new thing (which I'm sure is wonderful) and call it something else. Your chances of adoption will be 10x better without the ball and chain of this name. Heck, even _I_ might try it, once you stop pretending it's the same.
&gt; I just wish Perl 6 was an evolution rather than a revolution Wow. Truth.
"Also why would we want to compete for the same ecological niche where Python dominates?" You might not want to compete, but sometimes you have to, in one field or another. Most users on the earth do not care very much if you are really creating a great programming language or not. They care about whether it can bring them jobs, whether it has good libraries to get their jobs done, and whether it is "in". So it's not just about creating a great language, it's more about creating great applications and libraries. If a new language cannot find its niche it would fade away. But it's so difficult to quickly make a buzz as there are competitors mostly in all fields you can think of. In some of the fields if you actively compete, you may hold like 2nd or 3rd place; if you don't compete, you get forgotten by people at all. 
Interesting video about making Perl 5 behave like Perl 6 by Damian Conway in his lecture "Three words" on Youtube: https://youtu.be/e1T7WbKox6s
Thank you.
Re: "promoting the fiction that Perl 6 is all there is." If I would be promoting that Perl 6 is all there is, why do I mention Perl 5 so many times in my blog post? *confused*
Thank you.
&gt; Last I heard Perl 6 still has trouble with https (this was from a recent blog post). Just to pick up on this. The language itself doesn't have any built in HTTP support. A number of (but not all) the libraries available for making HTTP requests use libssl under the hood (using NativeCall to integrate with C libs is built in). This is fine and these libraries work fine. Until they get threaded as libssl isn't thread safe so HTTPS requests can fail at this point. There are libraries (including parts of the Cro libs) that can make threaded HTTPS requests. Hope that clears that up.
&gt; Keeping Perl 6 as the name, has been TimToady's decision. And as far as I know, that means he is right. Until he changes his mind. See, this is the bit I really don't understand. Larry is an intelligent person. And it's his project so, of course, he's entitled to name it whatever he wants. But that doesn't mean that he's always right. In fact, I think he's catastrophically wrong here. Using the name "Perl 6" hurts both Perl 5 and Perl 6. And his insistence on hanging on to that name makes no sense to me whatsoever. Of course, if he wants to keep this harmful name, then the project will keep this harmful name. But saying "he's right" to do so is really unhelpful. Has anyone tried to persuade him that he's wrong? People who he listens to need to convince him that he's wrong.
&gt; Are you trying to say that Larry "hijacked" his own project? That sounds a little odd to me. Well, I don't think it was intentional. But that has certainly been the effect. When the Perl 6 project was announced (at OSCON in 2000) it was very much seen as a future replacement for Perl 5, in the same way that Perl 5 had replaced Perl 4 a few years earlier. Under those circumstances, it made perfect sense to call it Perl 6. But it didn't take a few years - it took sixteen years before we got a production release of Perl 6. At some point during that process (I'd suggest about in 2005) Larry should have realised that a) it was going to take a long time and b) it really wasn't going to be much like Perl. At that point, he should have renamed it and freed up the version number for use by the "main" Perl project. But he didn't. We were stuck with the name "Perl 6". And that meant that people had to invent the whole "not a replacement, but a new language in the same family" nonsense. And suddenly Perl was the only major programming language in the world that subverted the way that version numbers worked - leading to much confusion in the messages we were putting out.
&gt; it really wasn't going to be much like Perl But it is. It comes with the same mindset and much of the same syntax. But when the Perl 5 people start saying they won't even consider giving it a try just because of the **name** you'll get this kind of confusion, and both Perl 5 and Perl 6 will be the worse of it. Things like saying the creator is hijacking things from himself and other nonsense isn't helping anyone. Instead, the communities should be working together.
&gt; But it is. It comes with the same mindset and much of the same syntax. Every couple of years since the project was announced I have sat in a conference audience and listened to Damian Conway give a talk about how wonderful Perl 6 is. And, the way he uses it, it really does look wonderful. Then I get home, find an online tutorial or a book and try it myself. And it always goes wrong at that point. You can say that Perl 5 is Perl as much as you like, but this veteran Perl programmer just doesn't see it. Please note that I'm not saying I won't continue to try Perl 6. I've seen how, in the hands of an expert like Damian, it can be a great language. And eventually my efforts will pay off and I will understand it. So I'm certainly not saying that I'm not going to try Perl 6 because of its name. What I'm saying is that by sitting on Perl 5's next version number, the Perl 6 has damaged (perhaps irrevocably) perceptions of Perl.
You're misunderstanding me. I don't refuse to try it because of the name. I refuse to try it _despite_ the name. Since it's called Perl, you would think I should try it. I'm a Perl guy after all, right? But see... it's not Perl. It's something different. It's a new language that I would have to learn, so it has to compete for my attention with every other language (and ecosystem) that I don't know and don't even perceive that I need. I realize the Perl 6 folks are trying to convince us that this is the new version of Perl. But that's a mirage, whether intentional or unintentional. Yes, props to Larry, as always. And he can honestly do whatever he wants. But he's also not perfect or beyond criticism. He didn't do a major version release. He wrote a _brand new thing_, using lessons that he learned from Perl. And that's fantastic. I would love to evangelize the fact that Larry Wall, the guy who gave us so many wonderful things, has now given us a new language, and everybody ought to try it, because it can do this, and this, and that, and it's wonderful... But unfortunately, that's not what happened with Perl 6. Perl 6 was an inside joke for a decade, and now that it's released, it's completely different from the Perl that we're used to, and we're supposed to act like this is just an upgrade of the thing we use. But it's not. It's something else. So yes, call it something else, and you stand a chance of getting some adoption by non-Perl people. And thereby, you also increase your chances with the likes of me. So yeah, I can see why it might _seem_ like I'm just digging in my heels because of the name. But it's not about the name. It's about getting me excited about a new language. And the first step to getting me excited about a new language is to _admit that it's a new language._
It's like Perl 5 is a heritage tomato homegrown from seed, a derivative of bash, awk, BASIC-PLUS/2, and of a piece with all the other languages our forefathers grew up on -- sometimes fragile and temperamental but organic and delicious raw, in a simple marinara, or in gourmet recipes. Perl 6 is a lab-grown genetically-engineered uber-tomato, with all the latest technology built-in, inaccessible to the home gardener and the home cook, and having a completely unrecognizable taste. 
From my point of view, Perl6 core developers should slow down their pace of improving the core language, and focus more on practical modules. A wonderful but bare-bone language is not fun if it cannot solve everyday problems easily. When I need to parse json/yaml, or handle serialization, I have to search the internet and compare these libraries if there exists many of them. Doing these things is cumbersome and time-consuming. Making more practical modules built into the language itself will attract more users and have a positive feedback on the development of the core language.
re: "Perl6 core developers should slow down their pace of improving the core language" Performance improvements has been the emphasis in Rakudo Perl 6 development since the 6.c release in December 2015. Please have a look at http://tux.nl/Talks/CSV6/speed4.html for an example of the improvements that have been made in the past 2 years: effectively a 20x improvement. Re: "Making more practical modules built into the language itself will attract more users and have a positive feedback on the development of the core language." If you consider CPAN part of the language, then the CPAN Butterfly Plan is exactly what we're going for.
Well, if you think that the name is included in core functionality, I guess :-) But I assume that other members of the Perl 6 design and development team are allowed to debate things with Larry - they surely don't automatically agree with everything he says, do they? I guess what I'd like to know is - have there been any conversations trying to persuade Larry that he might be wrong on this?