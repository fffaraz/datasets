No need for Perl; you can just use grep: grep -P '[^ \t]'
I also happen to write other data dumping modules like [Data::Dmp](https://metacpan.org/pod/Data::Dmp), and a few other variations/mods of Data::Dump. You can say that I like dumping data. I have an idea for an alternative data dumping module with the following rather specific features. These features come to mind because I spend a lot of time looking at data dumps in debug log outputs (produced mostly by [Log::Any](https://metacpan.org/pod/Log::Any) or [Log::Dispatchouli]](https://metacpan.org/pod/Log::Dispatchouli)). * highlighting certain parts of a string, e.g. from character offset 50-100, or every *n* lines, or substrings matching certain regexes. Have you ever looked at a dump of a long string and having to stare painfully and carefully at certain parts of it? * similar to the above, highlighting certain parts of data structure. I'm thinking of using [Data::Csel](https://metacpan.org/pod/Data::CSel) as a way to select the nodes of the data structure. For example, highlight everything deeper than three levels, highlight empty arrays, highlight array elements that have index higher than 20. * clip/remove data structure branches and strings, to let user focus on certain parts only and avoid long scrolling. * format a long string in a variety of configurable ways, e.g. as lines of certain widths, with markers or blank separators after *n* lines, and so on. In short, this data dumper will focus on making long strings or large structures more readable. No idea on when this will be implemented. I'll probably code along as I stratch itches.
Maybe this is a good time to plug my https://metacpan.org/pod/Data::Printer::Filter::DBIx::Class There are some other handy filters available: https://v1.metacpan.org/search?q=Data%3A%3APrinter%3A%3AFilter&amp;search_type=modules
I really like Data::Printer and think it's awesome. I like that it represents the data in a format that is nicer for me as a human being to read. When I just want to peruse the structure I don't necessarily think dumping into Perl is best On the other hand, if my intent is to actually dump valid Perl code, then that is a different matter. I rarely need to do this though
This probably needs to be more widely known.
&gt; I think this will require the blank line to contain at least one whitespace character. That is correct. The answer is: `perl -ne 'print unless /^\s*$/ ' test.txt`
I think passing the name of a global is fair.
The shell processes redirections before executing your program. It sets up your program to have its stdin already redirected to come from the file. Your program does not see that argument. All you need to do is read from stdin to read from the file. I hope you can see why that's a far superior setup: by having the shell handle it rather than making every program handle it, you can redirect input (and output) to any program, even if it was never written with that intent in mind. You can simply write a program that interacts with stdin and stdout and for free you get the ability to interact with any file handle, including files, ttys, pipes, sockets, fifos, etc. 
Yes The script is meant to take in a file but one of the tests is to have the &lt; in front of the argument
I should probably add that if you're doing any parsing in XS (file format, network protocol, serialization) you should use this to fuzz your code. Parsing is hard, and fuzzing *always* finds bugs.
Technically, isn't this DamianWareWear?
What happens when you run the code? Any errors? You can try passing `-verbose` to the constructor e.g. `-&gt;new(-verbose =&gt; 1, ...` to get some more output. 
Glad you got it working :)
Are you sure about the requirement here? Accepting a literal '&lt;file.txt' does not sound like a useful feature, so if the assignment requires that, I'd strongly recommend asking for more details. If they're asking you to support both these forms: perl script.pl file.txt perl script.pl &lt;file.txt that's fine, and the other answers (the ones that mention &lt;&gt;) cover this already. If you're supposed to support this: perl script.pl '&lt;file.txt' then your response should be along the lines of "no", "why" and "can I have a second opinion"... reasons include: * the syntax is non-standard * it's dangerous - the easy way of doing it would be [2-arg open](http://modernperlbooks.com/mt/2010/04/three-arg-open-migrating-to-modern-perl.html) * it'd mean you can't run the script on a file literally called '&lt;file.txt' There are some problems with &lt;&gt; too, so if you have access to a recent (5.22+) version of perl, use &lt;&lt;&gt;&gt; instead - see https://www.effectiveperlprogramming.com/2015/05/use-perl-5-22s-operator-for-safe-command-line-handling/ for details. Except you'd want to include 'use strict; use warnings;', and not use [bareword filehandles](https://www.securecoding.cert.org/confluence/display/perl/FIO00-PL.+Do+not+use+bareword+file+handles), so there's some bad advice on that post too - maybe just concentrate on the bits that mention &lt;&lt;&gt;&gt;. Perl documentation and articles can be a minefield at times :/
Was it a... clickwhoring title?
Nice write up for a very nice conference in Transylvania. It's a little sad that at least 2 people reacted to the jokey title, but there you go.
To those complaining about the clickbait title, yes, its a joke. [KYM](http://knowyourmeme.com/memes/clickbait)
Though I was hoping for a picture of a giant rabbit. Slightly disappointed about that.
I see this post has been voted down to 0. Reddit is worthless. 
"In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. " I'll probably use this feature, now that I know about it. Go has the 'range' built-in which does the same thing, FWIW. 
You have named yourself well. Run along now.
Nice post. Just one thing: &gt; 1st, Don't directly talk to a database. I wouldn't blanket-recommend people to use an ORM over DBI, context is important.
Salt is good, but please don't use plain sha256 as a password hash, don't use concatenation as the means to mix the salt with the password, and don't roll your own crypto when there are good modules out there that are easy to use and do the job *correctly*.
I have been using [Crypt::Eksblowfish::Bcrypt](https://metacpan.org/pod/Crypt::Eksblowfish::Bcrypt) for my password hashing needs and it works neatly, the prefix allows you to switch hashing methods later and the cost gives it an easy method for future-proofing.
I bought this on udemy. It is fine. I also bought learning Perl by doing which I have enjoyed a lot more. I was already reading Learning Perl by Randall Schwartz which is excellent in my opinion and much better for learning a new language.
&gt; I am not a fan of it, as I really like when my script knows how many tests it is going to run, but sometimes it is really difficult to know up-front. It might depend on the number of files in a directory. But the number of files in a directory (which I assume is part of the test data) should be known up-front right? Because we are testing that. &gt; We might be able to compute the number at the beginning of our test-script, but in some case this might be too difficult with a lot of value. This can be remedied by using (multilevel) subtests, as it should be when the number of tests has increased to hundreds or more. Anyway, in general I do the same (use `done_testing` instead of specifying the number of tests up-front). Specifying the number of tests might be useful in the case of a complex logic flow in the test script, where some tests might be accidentally skipped or duplicated. And the explicit plan catches that. But that complex logic flow should be avoided anyway. 
I wonder what existing tools are currently affected? I'd imagine not a lot, as I reckon most tools "consuming CPAN" use information from `modules/02packages.details.txt.gz` to get a list of files and/or packages. And PAUSE is not going to suddenly list Perl 6 packages there in the foreseeable near future, correct? 
+1 for Crypt::Eksblowfish::Bcrypt. Another one is [Crypt::ScryptKDF](https://metacpan.org/pod/Crypt::ScryptKDF), which seems good but I haven't had a chance to evaluate it properly yet. Perhaps we need a follow-up article!
The only clear advantage IMHO is its stack free nature, unless Data::Printer is stack-free as well.
It's a niche OS, but RISC OS uses dots, e.g. pictures.jpegs.cat/jpg
Because there is a lot of Perl use there (as there is in many places) See http://cluj.pm/pastevents Last year the conference was in Spain and next year it will be Amsterdam.
2 negative comments then suggestions on how José Martínez should organise his career. How about "Thanks for contributing this project to the community!" I sometimes wonder why people want to make open source work feel like a thankless task.
Sorry, it wasn't recorded. But I've submitted my talk to LPW, which may record it in December (if I get selected). Nova Patch's talk was a riff on many of the things they've talked about at other YAPCs, you can find those online and I highly recommend them. I have a feeling Richard will be blogging about some of the content from his talk real soon...
Thanks for sharing your experiences!
Just a reminder to people who come across this comment: http://www.nothingisreal.com/mentifex_faq.html
He's an old USENET crank. People who are actually entrenched in AI have been wanting him to go away for decades. See: http://www.nothingisreal.com/mentifex_faq.html
And I was so excited to see that my article had some comments. Darn.
Cool post, interesting to read about a learner's perspective on Perl
Please, the guy is an attention seeker and didn't invent anything. There's a reason why "obviousness" is a test in patent law - and this so-called transform is obvious; it doesn't need a brand. I refuse to use the label, and refuse to show any respect to this disrespectful man.
Note this seems to be talking about a Perl6-only module. [Tickit](https://metacpan.org/pod/Tickit) is an alternative for perl5 users who want terminal UI without going through ncurses. If you want a collection of useful widgets, installing [Tickit::DSL](https://metacpan.org/pod/Tickit::DSL) will bring them in as deps. The library (and widgets) are under active development, but it's already a useful framework for async terminal interfaces. (disclaimer: I wrote Tickit::DSL and a handful of widget modules - but not the core library - so my opinion here is massively biased)
Care to elaborate?
Thanks, I really enjoyed this article. I am reading intermediate perl now so I am just able to understand what the code is doing.
another great book is modern perl http://modernperlbooks.com/
What level is this book? I need to look for some intermediate books
Thanks
http://hop.perl.plover.com/book/
Wow, I see women, real women, and they're all gorgeous. That it, I'm switching to Perl.
Yea if you're doing a crazy jump like that it's probably worthwhile to step through major versions using perlbrew or something of the like.
A golden camel for you, sir. I knew it had to be something minor like that but couldn't figure out what.
&gt; Needless to say there was a lot of "if it ain't broke don't fix it" type talk in the office, ya know? Except there have been a *huge* number of bug fixes made between 5.8.8 and 5.22, not to mention efficiency improvements made and new features added...
Yes I know that; I just did some research to find 5.8.8 code was moved to a development server was on 5.18 (and working fine after a little work) but the switch to 5.22 is what broke it in the manner described. So it's not really as awful as it sounds. I also notice that perl now (i.e. 5.22) positively throws a fit if you redefine a "my" variable in the same scope. (Frankly I think it should have done that from day one; I can't imagine anybody ever *intentionally* doing that.) 
Be happy this code is being upgraded instead of rewritten in another language. 
The `%` sigil denotes that the variable is a hash, and it's being initialized from the given list of key/value pairs. Syntactically `=&gt;` acts just like a regular comma, except that it implicitly stringifies its left-hand operand if it's a bareword, which is not relevant in this example since they're already strings, but it's traditional to use it even when it's not necessary to make it visually unambiguous that it's a list of pairs. Edit: it seems like you may benefit from reading [`perldoc perldata`](http://perldoc.perl.org/perldata.html) and many of the other man pages.
My explanation: * it's a hash. * a hash is like a little filing cabinet where each drawer contains only one thing, and each drawer has a label on it. * the thing on the left is the label, the thing on the right is the contents, the `=&gt;` means "contains" * so your `%aps` is like a little chest of drawers with four drawers: * the drawer labelled `172.19.74.67` contains `172.30.10.` * the drawer labelled `172.19.87.2` contains `172.30.21.` etc.
I never had much of a gripe with the way that Perl 5 has always done OOP, though lots of people call it hackish. Whatever. However, Moose really changed the game, as others have said. It's wonderful.
Yeah, this is a good point that you both make. It was a good way for me to understand the inner workings of objects. Maybe that's why people call it hackish, because it's exposed, and not buried somewhere inside the code. It's like owning a clock that is transparent, and you can see how it works. It might not be the prettiest clock. But it is easier to see how it works.
Thank you, this makes a lot more sense now.
[This module](https://metacpan.org/pod/Dios) appears to have mostly flown under the radar but it ought to be at least interesting.
 my $new_class = Mouse::Meta::Class-&gt;create_anon_class( superclasses =&gt; [ ref $self ], cache =&gt; 0, ); bless $self, $new_class-&gt;name; $new_class-&gt;_initialize_object($self, {}, 0); This worked.
I'm sure they're all means to an end, but when looking only for some accessor helpers and a BUILD function, I just don't want to pull in thousands of lines of code that I know absolutely nothing about. I like Class::Tiny because I can look through it's code and generally understand what it's doing. No surprises. Why is the kneejerk reaction to someone asking "How do I OO in perl?" always "MOOSE!"? Call me weird, but I don't think there's *that* much wrong with perl's native OO system.
Neither does Moose really. But Perl's native object system has no opinion on attributes or attribute access. It has no BUILD method, or formalized constructors. It lacks any sort of type checks on attribute syntax. It has no formalized metamodel, or API to access it. These are all nice to haves sure, but for beginners they can prove invaluable by reducing the cognitive load on what you have to think about. Class::Tiny looks awesome as a solution for a lot of this cognitive load (but not all of it). It would never have existed without Moose, and I'm pretty sure David would be the first to admit that. Don't hate on people for recommending the current 900lbs gorilla because you happen to think its 850lbs overweight. The moose team is always looking for people to help us put it on a diet.
If Class::Tiny works for you, great. You also might enjoy Moo as a middle ground -- it contains most of the non-MOP features of Moose, but has fewer dependencies and is also fatpackable (which is a killer feature for some applications that send their code over the wire to run on a remote machine).
I'm super excited for this as I love text adventures from old school favorites like Zork that you have to run on Frotz now, to Emily Short's games which run and look great using Gargoyle. I've always wanted a SciFi game though and the only one I'm aware of is PlanetFall (Infocom), but it isn't available and the older text adventures are very basic compared to what one can do now with Inform7. It's a plus that it is being done by Ovid and in Perl. He has old blog posts on the perl blog under the game's code name (Veure Saga). Gameplay wise should be interesting as most text games have a clear end goal in mind, but this is more like a MUD game. Archae (spelling) is a good example of this genre as a fantasy game. Lots of players doing quests (kind of like a text version of WOW). If you have a good imagination and like reading, you should be set. I wonder how good the prose is though. Emily Short's stuff is top notch and can be appreciated for the fun storyline/puzzles as well as the shear art. If you're reading this Ovid, please do a blog post with a good sample of text if you can.
Throwing in my vote for [Moo](https://metacpan.org/pod/Moo) as well. Moose has a noticeable impact on startup time, and you probably don't need the MOP stuff that Moose has (unless you do). Moo also supports type constraints, but doesn't include any defined types like Moose. You can either define your own type constaints using something like [Type::Tiny](https://metacpan.org/pod/Type::Tiny), or just use the ones from [Types::Standard](https://metacpan.org/pod/Types::Standard) Example: package Planet { use Moo; use Types::Standard ':all'; use Math::Trig; has name =&gt; ( is =&gt; 'ro', required =&gt; 1, isa =&gt; Str ); has mass =&gt; ( is =&gt; 'ro', required =&gt; 1, isa =&gt; Num ); has radius =&gt; ( is =&gt; 'ro', required =&gt; 1, isa =&gt; Num ); sub density { my $self = shift; my $volume = 4 / 3 * pi * $self-&gt;radius ** 3; $self-&gt;mass / $volume; } } my $planet = Planet-&gt;new( name =&gt; 'Jupiter', mass =&gt; 1.898E27, radius =&gt; 6.9911E7, ); printf "The density of %s is %.0f (kg/m³)\n", $planet-&gt;name, $planet-&gt;density; # OUTPUT: The density of Jupiter is 1326 (kg/m³) 
What about [Mo](https://metacpan.org/pod/Mo)?
When working with stuff like this, I find it good practice to **always** use the [URI](https://metacpan.org/pod/URI) module. For instance: host:~$ re.pl $ use URI; $ my $u = URI-&gt;new('http://example.com'); http://example.com $ $ $u-&gt;query_form( username =&gt; 'bob test with spaces', password =&gt; 'very%hard to @ get right' ); $ $u; http://example.com?username=bob+test+with+spaces&amp;password=very%25hard+to+%40+get+right You can then pass `$u` into your request and not have to do any string interpolation and be sure that things are escaped properly.
You can also consider not using Perl to do the entire task. I might also use a Makefile to run the Perl script to fill in the templates, then call pdflatex. That's a bit much more unixy, but you didn't tell us which environment you're using. Maybe you kick off `make` with a different Perl script, but you don't have to.
Back when I used to generate PDFs using TeX and Perl, I followed pretty much the same process as you (I just used the Template Toolkit where you have Text::Template). So, no, as long as you're tied to TeX, I have no suggestions for improvements. But after several years of battling TeX and generally losing, I switched to using [wkhtmltopdf](http://wkhtmltopdf.org/) (more specifically [PDF::WebKit](https://metacpan.org/pod/PDF::WebKit) which hides all the command line stuff from you) on the basis that I'll always find HTML/CSS easier to understand than TeX :-/
Ubuntu. It is actually for my student job, they have an old perl script that generates delivery notes using Perl format report (Which is part of a larger program that gets data from a db, waits for incoming orders etc.), currently trying to figure out a way rewrite the delivery notes, so I can put in the logo of the company and just have it look much nicer and professional.
Not to muddy the waters for a newbie, but Moo isn't massively faster than Moose. The noticeable penalty for Moose is startup time. Mouse *is* massively faster than the other Moose-ish capable OO frameworks. For some reason it seems to have fallen out of fashion nowadays, not sure why. If you really need speed over OO power and flexibility, but still retain the nice declarative syntax, this is what to go for: use Class::XSAccessor::Compat "antlers"; There's a CPAN module which benchmarks various OO frameworks wrt object construction and accessors, but I can't recall the name right now. In general: * for CPAN modules, probably go with Moo * for your own persistent apps, probably go with Moose * for large sets of objects, probably do those classes with Class::XSAccessor::Compat 
The upside is that you have now taken the difficult step, and further steps to newer versions will be trivial in comparison.
Any module that would compile your document for you is going to have to make a system call at some level. `tex` is only an executable and not a library sadly. I would suggest making a temporary directory using File::Temp, generating your templated tex source file there and then compiling it with `latexmk` since that will ensure the correct compilation runs. From there copy the compiled pdf back to your target directory.
Fair point of course, but I would argue that one chooses lightweight scripting languages like perl for a reason. If I need a full-featured clunky OO beast, I might as well use Java. To keep with your analogy: When facing any challenge in perl, I would first see how far I can get by myself, then employ some helper monkeys to deal with the mundane/repetitive/ugly code, and only when the project gets too complex to handle, start looking for an appropriately sized gorilla. quick edit: not implying that Moose is as clunky as Java... that would be a bit of an exaggeration :) 
One of the great things about Perl (culture) is that your approach is okay as is mine. There can be more than one way to do it. For me I reach for Moose because writing the mundane/repetitive/ugly code that is: `sub foo { my $self = shift; if (@_) { $self-&gt;{foo} = shift; } return $self-&gt;{foo}; }` for every attribute got tiresome sometime around 2007 (before Moo, and Class::Tiny etc). So I'm kind of conservative in my own way, I just picked a different place to be conservative *at*. Having worked in both Java and Perl for money, I wouldn't say that Perl is necessarily "lighter weight" than Java. (I'm not even sure that comparison has any real meaning when you dig into it.) I work with Perl before Java because I prefer the more expressive syntax and flexibility of Perl. For my purposes I argue I work with Perl because it's *heavier* than Java, and requires more precise control on my part but in-turn enables me to more productive with fewer resources. Increasingly these days I reach for Moose for a smaller and smaller portion of my code base. The front-end is written in whatever REST engine I'm using (Magpie and Web::Machine get a shout out here). The backend is often DBIx::Class. Moose is used in the fat logic middle between the API and the Storage Engine, or incidentally used because the tools I'm using leverage it (again see Magpie here). As those tools get better and more expressive, the pieces I have to write myself get smaller and smaller.
Doesn't the requirement to login fix this problem? The web site knows who is making the change and the user can be prompted to confirm any necessary copyright information.
The system has to ensure it's possible to 'push' notifications to the copyright owner. So, if it requires that an e-mail is verified on the account, yes. But then it wouldn't be any easier. The process trough a "click here to submit a patch" script: * Find the place to create the account; * Create an account; (another login to remember, yikes) * Confirm your e-mail is valid; * Ask the user to mark a "I allow the use of this patch integrated in the program, with the same license" checkbox; * Click the button to upload the patch. The process to submit trough e-mail: * Find which e-mail address to send to; * Send the patch. (E-mail servers should refuse to accept if the e-mail is spoofd) So it could be useful, but not any easier.
I don't think "learning git" and "learning POD" are terribly high hurdles for someone in software to accomplish. Git is a straight-up prerequisite for modern software development, and POD is brain-stunningly simple. 
Agree with dave. Last time I had to do this I recommended wkhtmtopdf but the client insisted on [Template::Plugin::Latex](https://metacpan.org/pod/Template::Plugin::Latex). Either works. the former is less painful for most purposes.
it's in Mojo::Pg documentation: $c-&gt;render(json =&gt; $db-&gt;query('select now() as now')-&gt;hash); more stuff here: http://mojolicious.org/perldoc/Mojo/Pg
Fair enough. A patch to the mailing list isn't that much different though
I've looked at that link now, thanks, but can't figure out the `$sth` equivalent of `$db-&gt;query...` &gt; $c-&gt;render(json =&gt; $db-&gt;query('select now() as now')-&gt;hash); 
Sorry to waste your time, the answer was $sth-&gt;fetchall_hashref
DBI is very complete, but fairly low level. If you want to use a slightly nicer syntax, there are loads of libraries on CPAN: from making SQL nicer to call, to constructing SQL, to full ORMs. For the above example [DBIx::Simple](http://search.cpan.org/perldoc?DBIx%3A%3ASimple) is quite nice. For [running a select](http://search.cpan.org/~juerd/DBIx-Simple-1.35/lib/DBIx/Simple/Examples.pod#Fetching_all_rows_in_one_go).
&gt; OAuth No. &gt; online editor Is this joke programming?
Your response to the only login medium that doesn't require you to remember a login, or store credentials at each location is "No"? Your answer is to require people upload patches for review via a mailing list? &gt; Is this joke programming? I guess it is if that's your answer. 
Ignoring the copyright angle, it seems like the method is unclear, or at least confusing to Joe Average. That's hardly anything unusual, we often are so familiar with websites (and programs for that matter) that they seem highly logical to us, where to external users they're obtuse.
The [deleted] username - Reddit's version of the Twitter egg ;)
| perl /path/to/script.cgi
Try the [Email::MIME](https://metacpan.org/pod/Email::MIME) module for dealing with the email. For example: | perl -le'use strict; use warnings; use Email::MIME; my $msg = Email::MIME-&gt;new(join "", &lt;&gt;); print "Subject: " . $msg-&gt;subject' There are various ways to read from STDIN into a string, but I'd just use `join("", &lt;&gt;)` for that in a simple script.
It will be a performance boost in any app. It tells the database library that it should cache statements and re-use those cached statements to make queries instead of preparing new statements for every query. It is recommended for persistent connections. If you are using PostgreSQL, have a look at Mojo::Pg https://metacpan.org/pod/Mojo::Pg Also, the guys in the Mojolicious IRC channel are friendly and helpful if you need any advice.
For reference, unless you are running the same query many hundreds of times, it's generally a better idea to stick to the selectall_arrayref and similar functions in [DBI](https://metacpan.org/pod/DBI#selectrow_arrayref), as it's much more concise and readable. For example the above query would be written like `$dbh-&gt;selectrow_hashref('select now() as now')`
If you're writing the script in perl, consider using `Mojo::UserAgent`. It uses the built in `Mojo::JSON` which will return `undef`if the body is not JSON. $ perl -MMojo::UserAgent -MData::Dumper -le '$ua = Mojo::UserAgent-&gt;new(); print Dumper $ua-&gt;get("http://jsonplaceholder.typicode.com")-&gt;res-&gt;json' $VAR1 = undef; - $ perl -MMojo::UserAgent -MData::Dumper -le '$ua = Mojo::UserAgent-&gt;new(); print Dumper $ua-&gt;get("http://jsonplaceholder.typicode.com/posts/1")-&gt;res-&gt;json' $VAR1 = { 'body' =&gt; 'quia et suscipit suscipit recusandae consequuntur expedita et cum reprehenderit molestiae ut ut quas totam nostrum rerum est autem sunt rem eveniet architecto', 'id' =&gt; 1, 'userId' =&gt; 1, 'title' =&gt; 'sunt aut facere repellat provident occaecati excepturi optio reprehenderit' }; Read more at [metacpan](https://metacpan.org/pod/Mojo::UserAgent)
You could also use a try/catch block: use JSON; use Try::Tiny; my $command = `curl -s http://$host:$port/$contextroot/version.jsp`; my $hash = {}; try { $hash = decode_json($command); } catch { warn "Failed to decode_json: $_"; $hash = undef; }; Edit: semi-colon/ Try::Tiny
Does try/catch get you anything that eval doesn't? Not trying to be snarky, I honestly don't know the differences between the two.
Yeah, maybe that's just some people. Myself, I almost never have a good reason to use the non-reference syntax. The rare occasions I do, I have to remind myself what is is.
Probably the best way to start with this, if you don't want to implement it yourself, is to search on [CPAN](https://metacpan.org/search?size=20&amp;q=russian&amp;search_type=modules) for similar solutions. For example, there's [Lingua::Stem::Ru](https://metacpan.org/pod/Lingua::Stem::Ru) module that seems to do exactly what you need. 
This seems to give the right answer for the sample data you've given. It's not in the format that your lecturer is asking for but, hey, you wouldn't want to get the credit without putting *any* effort in, would you? :-) #!/usr/bin/perl use strict; use warnings; use 5.010; for (1 ..32) { my $text = "$_ student"; # 11 - 14 seem to be special cases if (/^1[1234]$/) { $text .= 'ov'; } elsif (/[234]$/) { $text .= 'a'; } elsif (/[567890]$/) { $text .= 'ov'; } say $text; } 
thanks for all the great suggestions folks. I found the Try::Tiny to work well for what I need. tnx again
Come to Denver! I can't make it to NYC this weekend... :(
The phrasing fooled me. Instead of courtesy of oreilly I would instead say partnered with or hosted by. The course is $99 to sign up. Reading the title I thought it was free :(
&gt; $month_is[$i] This is accessing a completely different variable. `%foo` and `@foo` are two completely different things. The above is trying to access members of `@month_is` which was never defined anywhere, hence the blank lines. As a beginner is it really crucial that you use perl in strict mode. Start every script with use warnings; use strict; These checks will automatically find mistakes like the one you made. They will also force you out of bad habits, like using global variables all over the place as you're currently doing. You'll want to read up on lexical variables. 
The first problem is that you've got trailing whitespace in your file. I'm assuming that is what you were trying to address with `chomp $url1`, but that won't fix it. `chomp` will only remove the input record separator, usually the newline. It won't trim trailing spaces. But the main problem is that you aren't putting a slash between `$tmpvar` and `$url1`. Also, you've written `\_` but you that's just `_`. You need a forward slash, not a backslash, which is a metacharacter. Also, there's no reason to use `quotemeta` if you give `system` a list rather than a single string. It skips the shell in that case, which is good for a number of reasons. Here's a suggestion for how your code might look, taking all of the above into account: #!/usr/bin/perl use strict; use warnings; use diagnostics; my $file = 'genomes_proks.txt'; open(my $FH , '&lt;', $file) or die "$!"; while(&lt;$FH&gt;){ next if /^#/; s/\s+$//; my @fields = split /\t/; my $url = $fields[-1]; my @url_parts = split '/', $url; my $last_part = $url_parts[-1]; my $new_url = "${url}/${last_part}_genomic.fna.gz"; system 'wget', $new_url; } I've included several additional tweaks, for example you can get the last element of an array with `$foo[-1]` rather than having these magic numbers like 5 and 19 all over the place. Also, there's really no reason to first create an array and then iterate over it; you can do it in one pass. And I've tried to use more sensible variable names. 
There's no reason whatsoever to see what happens when they're not included. All that happens is it's easier to write the wrong code and you don't get warned when the code does something you don't expect. The tutorial you linked is incredibly ancient, in fact it predates warnings entirely. Take a look at [this tutorial](https://qntm.org/files/perl/perl.html) for a quick one, and [Modern Perl](http://modernperlbooks.com/books/modern_perl_2016/index.html) for a comprehensive guide to the latest in best practices.
Can you paste the sample in an pastebin to preserve the tabs and spaces?
Hey rhomboid did split on tab as well my @fields = split /\t/; the line with s+ replaces all spaces with ""; If I had taken your command to download it would have downloaded way more files than I actaully needed. That's why I wrote the script else I would ahve downloaded GBs of files instead of jsut a few MBs. Nevertheless thanks for your answer I didn't know I can download with wget like you suggested . So i learned somethign new
This is just a small project I am making for myself to learn a little bit besides university. There are around 750 files, so pasting all in a text editor would take a lot of time =)
It will give you a very simple dispatcher. In one case it's the best perl alternative to a `switch` statement. #!/usr/bin/env perl use warnings; use strict; use feature 'say'; my %dispatch = ( frobnicate =&gt; sub { say "frobnicating a $_[0]" }, fantangle =&gt; sub { say "fantangling a $_[0]" }, foo =&gt; sub { say "doing a boring old foo" }, _unknown =&gt; sub { say "unknown action '$_[0]'" }, ); sub do_dispatch { my ($action, $arg) = @_; if (! exists $dispatch{$action}) { $arg = $action; $action = '_unknown'; } $dispatch{$action}-&gt;($arg); } do_dispatch($_, 'thing') for qw/frobnicate fantangle foo splat/; You can also use it to start refactoring old procedural/messy code to a more OO style.
reference to a subroutine: inversion of control 
If you're familiar with python, then a reference to a subroutine can be thought of like a lambda. Anywhere you'd use a lambda is python you could use a reference to a subroutine in perl.
It won't fix the main problem, but using Text::CSV ( https://metacpan.org/pod/Text::CSV ) instead of split should make your life much less stressful.
Very interesting, thanks!
Also note that \\&amp;foo gives you exactly the same sort of reference, just to a subroutine named foo. sub foo { say "this is a foo!" } my %dispatch = ( foo =&gt; \&amp;foo, );
As /u/Rhomboid said, it can be done, but don't do it with `stat`. `File::stat` is a core module so you don't need to install it. Pulling a scalar out of a list without an interim array is more useful with things like `split`, eg. my $third_word = ( split(' ', $sentence) )[2]; 
Okay, breathe :) The first thing you do when learning to program is to write a very simple program which simply says, "Hello, world." So open your editor (like Notepad) and create a file like this: print "Hello, world."; Save it as hello.pl somewhere. Then inside your Strawberry Perl folder, look for a file called "portableshell.bat" and run it. That allows you to run your program like this: perl hello.pl That's how I would start out, anyway. Baby steps :)
I'm sure it's not too complex for you. Perl is actually simpler than Java or C++ because there is no separate compilation step. Perl programs (as with any programming language) are text files. So you need a text editor to create them. Notepad++ was one text editor suggestion, and Padre is another. If your course recommends Padre then I'd go with that. Just open your text editor, write some Perl code and then save the file. This is exactly the same as with Java or C++. You then run your program by opening a command line window, finding the directory that contains your program file and running `perl name_of_your_program.pl`. This step combines two steps from your Java and C++ work - it will compile the program and show you any errors, and (if there are no errors) it will run the program immediately.
If you have an array reference my $arr_ref = [ 'a', 'random', 'list' ]; Then you can use the syntax `${ $arr_ref }[1]` to get a single element of the referenced array. say ${ $arr_ref }[1]; # prints "random" (More often you'll see that written as `$arr_ref-&gt;[1]`.) But `stat()` doesn't return an array reference, it returns a list. See the [documentation](http://perldoc.perl.org/functions/stat.html) which starts &gt; Returns a 13-element list ... You can use the similar(ish!) "list slice" syntax to get an individual element from a list. Just put (round) parentheses around the expression that returns the list and "array-style" square brackets after the parentheses. my $size = (stat $file)[7]; It's called a "list slice" because you're not limited to getting just one element from the list. my ($mode, $size) = (stat $file)[2, 7];
Thanks, I will go back and look at lists and slices as well.
Just bought the book! Yes we are supposed to do our exercises remotely I think. I really apologize for the dumb questions. Been out of college for more than a decade a now decided to hold the data bull by the horns and I am failing horribly lol. I am a molecular bio trying to see if I can learn programming and get myself to a bioinformatics bootcamp or something of the kind. It is a very odd experience to feel so out of the element. Maybe because I don't feel love for this? 
Perl and r seem to be very dominating in genetics (not so much number crunching but more kind of work alignment and fragment alignment. But to be honest what the fuck do I know? I feel so lost. I've been generating data for so long that it became really disheartening to have to wait a couple of years to have the analysis back. I really want to have a bit more control, even if at small scale to know the direction I should take in exploratory projects. The time-scale is wait is would sucking and I am wishing to move a bit forward with it. I really feel like I am being put in my place and stuffed back to my bench jokey position. There are a lot of scripts pre done all around the web and I can't even use those :( Sorry to be so negative, this thing is definitely changing me.
there's a shittonne of perl in bioinformatics code, as lots of bio stuff is in fact text processing. And generally it's not speed critical it's whip-it-up critical. Having said that python has a lot of traction in bioinformatics these days, and has better linear algebra tools than perl (but R is really the go to for statistical crunching - a horrible general purpose language though).
it should mention prepan.org, so authors can get feedback before publishing. new authors frequently choose bad module names or poor apis.
Oh yeah I've seen that written up on blogs.perl as well. I've used [Import::Into](https://metacpan.org/pod/Import::Into) by itself, especially for repetitive DBIx::Class schemas.
This sounds like a homework assignment! You really need to share more about the problem you're trying to solve if you want us to be able to help. - What are the source files? Can you give some sample data? - What have you tried already? - Are you able to use external Perl modules? Finally, if you know bash or shell then I suggest you look at [jq](https://stedolan.github.io/jq/)
Thanks for it we are in restricted environment i need to check for jq .However we do use xml and json modules in perl
I have bitbucket server which is git server from atlassian and this is json file i get from it .The other question u can ignore. {"repository":7112,"attachments":0}
&gt; this is json file i get from it &gt; {"repository":7112,"attachments":0} Okay - and what should the output look like? 
Well this is one iterative .So it there are multiple servers thanit loop in all and a html report should be send over mail.Well i admit i haven't given all details .But i will share soon. projects size A 7112 B 7113 
Most of these things work out to missing the TLS modules. Once you have proven that you can connect to the database securely using the mysql client then start debugging the perl again and ensure that IO::Socket::SSL is installed properly.
Good tips, the only one that I probably won't use is #1, because it looks like a typo and has a version dependency that I may run into with the RHEL 5 hosts I have to manage. I find `(-e $file and -r $file)` more legible.
Only running stat on a file one time can make a difference at a certain scale due to the I/O syscall. But another more readable option on perl 5.12+ would be to use File::stat, especially if you want to check other fields from stat(): `use File::stat; my $stat = stat $file or die "Cannot stat $file: $!"; if (-e $stat and -r $stat and $stat-&gt;uid == $uid) { ... }` Alternatively if you're stuck on older versions of perl, you can use the underscore syntax to reuse the last stat call, though this often looks like a typo as well: `if (-e $file and -r _) { ... }`
Thank you for pointing that out; I work with people who would be concerned about the 'double' stat of a file, so perhaps I will be utilizing it. Thank you for the alternatives; I was unaware you could use `_` like that. Is that described in `perlop` somewhere?
It's described near the end of the [-X](http://perldoc.perl.org/functions/-X.html) "function" documentation, as well as [stat](http://perldoc.perl.org/functions/stat.html) since you can use it there too. Just be careful not to confuse it with `$_`, they're both global but unrelated.
The author touches on not invoking a shell for **system** and **exec** but mentions only speed and not reliability nor security. There are many situations in which you don't want accidental shell interpolation of your arguments.
[IPC::System::Simple](https://metacpan.org/pod/IPC::System::Simple#runx-systemx-and-capturex) provides a systemx() which will do this, though it shares that module's semantics of throwing exceptions, so you'll want to use it with [Try::Tiny](https://metacpan.org/pod/Try::Tiny) or similar.
You could always do this to make sure that you don't invoke the shell, even if `@a` has a single element: system { $a[0] } @a; This used to be documented in perlfunc, but I'm not seeing it in 5.22.2's perlfunc manpage.
You can try my [IPC::System::Options](https://metacpan.org/pod/IPC::System::Options). It allows additional behaviours/features to be used separately. This code: use IPC::System::Options 'system', -shell=&gt;0; will cause `system()` to never invoke the shell. The rest of the behavior is the same.
If you dig even deeper, it gets worse. The WWW::Mechanize bug queue disappeared when Google Code shut down. So, what you see on GitHub is not representative of the unresolved tickets which built up over the years. Looks like some of it could be recovered, though. https://web.archive.org/web/20150227111857/http://code.google.com/p/www-mechanize/issues/list
When someone gives a good talk, it can be hard to suggest further improvements. But it's still a nice confirmation for the speaker to get positive ratings.
What does your META.json file look like?
Please don't confuse the closed source third party codebase running on search.cpan.org as having anything to do with the actual CPAN. It also has its own private indexer, the source code to which is unavailable, which often does random things. Best just to ignore it.
http://cpansearch.perl.org/src/CMS/Mustache-Simple-v1.3.4/META.json Yes you do. I suspect the problem is your using v-strings instead of a proper version. Please try either our $VERSION = '1.003004'; # standard way to render 1.3.4 into a perl-style version or use version; our $VERSION = version-&gt;declare('v1.3.4');
We cover IPC::System::Simple in [Learning Perl](https://www.learning-perl.com/). I don't get into the gory details on system until [Learning Perl](https://www.masteringperl.org/)
I just built a CentOS 7 box, and was also surprised that mod_perl wasn't there by default. But it was easy to install from a repo: yum install -y epel-release yum install -y mod_perl See: https://www.centos.org/forums/viewtopic.php?t=47378 
Thanks PBG. Indeed, definitely an option for short term. But I'm also starting to wonder about the future of mod_perl, and I'm looking to the medium/long-term!
The subdomain usage is definitely a source of confusion, but if you go to [www.cpan.org](http://www.cpan.org/) you'll notice that metacpan.org is listed first, and used for any links to modules as well as the search box on that page.
Including Makefile.PL/Build.PL and META.json in the repo means (for the majority of distributions that are simple enough) Dist::Zilla is not required for any step of the process except building a release. It was Dist::Milla where I first saw this strategy and it inspired me to do so in my own Dist::Zilla bundle.
Medium to Long Term look at Plack and by extension one of the frameworks Grinnz mentioned.
I tend to use ReadOnly for this. It works in nested datastructures, so the moment something writes when it shouldn't: crash.
Oh I never bothered with META.json because it can be generated if you have the Makefile.PL with `perl Makefile.PL;make dist`. Now I'm thinking maybe I should include it.
Nice use of tie
I've got some Windows dev tools in perl, because: - It's multi platform. (VB/powershell isn't. Python is, but I prefer perl) - It gives me 'unix tool like' functionality - perl can fake being sed/awk/grep trivially. - It's got some good XML parsing libraries, and that's cross platform too. - I installed it because I like perl, and post on Stack Overflow from a Windows machine mostly. I wouldn't say it's a 'wizard tool' as much - the post is perfectly correct that you can write unintelligible garbage in perl. But I would also assert - you don't _have_ to, and it's my opinion that well written perl is elegant, clear and concise in a way that VB isn't and can never be. (Powershell does it better, but it's still not cross platform)
I have a lot of Perl scripts on my Windows box, with Strawberry Perl. I was really surprised to find that it just works. I was expecting a bunch of half-functioning hackery, and didn't even bother trying cpan for years, because I thought there was just no chance it would work. But it does, and I'm really happy about that because Windows shell scripting is so arcane it's difficult to accomplish anything. 
Love getting these blog posts from Ovid and the full Tau Station team. A little sad to see Alpha is still a few months out, but it'll be worth it.
The META.json is needed because configure_requires dependencies must be satisfied before running Makefile.PL or Build.PL, and they can be found in META.json. The rest of the distribution's prereqs are read from MYMETA.json afterwards when building the dist (to allow for dynamic prereqs).
Tangent: Consider [ReadonlyX](https://metacpan.org/pod/ReadonlyX) or [Const::Fast](https://metacpan.org/pod/Const::Fast), which were both created due to design problems in Readonly.
Another similar option is to use [Variable::Magic](https://metacpan.org/pod/Variable::Magic), which has much less performance penalty and some other benefits discussed in the documentation.
This. I used Perl scripts in windows because windows shell scripting was almost non-existent at the time. Perl was convenient and what I knew. I've now moved on to using powershell for most things but still have a few perl scripts around.
If you haven't already, create a listing on jobs.perl.org.
Would be good to get some Perl issues in [their list](https://github.com/search?l=&amp;q=state%3Aopen+label%3Ahacktoberfest&amp;ref=advsearch&amp;type=Issues&amp;utf8=%E2%9C%93). There are some [issues labelled with Perl](https://github.com/search?l=Perl&amp;q=state%3Aopen+label%3Ahacktoberfest&amp;ref=advsearch&amp;type=Issues&amp;utf8=%E2%9C%93), but most of them seem to be for Perl 6. It's great to see Perl 6 on the list, but it would be better to see Perl 5 represented too.
Why should they not be?
Didn't know that, thanks.
One use for it is higher order functions. Python has sorted(list, key=lambda x: len(x)) Or just sorted(list, key=len) The equivalent Perl construction uses a block and a comparator instead of a key function. sort { length $a &lt;=&gt; length $b } @list; But if you were to write a function with a similar api to the Python version, you'd want to use a subroutine reference: python_sorted($list, \&amp;length) Here's a possible implementation sub python_sorted { my $list = shift; my $key = shift; [sort {$key-&gt;($a) cmp $key-&gt;($b)} @$list]; } An explicit comparator is a lighter weight alternative to creating an object and overloading `&lt;=&gt;` or `cmp`. Subroutine references also used a few places in the standard library like `File::Find`;
Last year I created this list: https://rawgit.com/neilb/cpantoberfest/master/index.html 
Something like /exception|failure|whatever/ should match each of the strings joined by ors
Thanks! It works perfectly! I appreciate your help!
This was a great idea. I've been testing it on a user that requires SSL and it's helped a lot. I still can't connect with Perl DBI though, but I can from the shell. I'm connecting to Amazon's RDS if that's any help. They only provide a bundle cert, and it works from the command line, but not with Perl's DBI module. http://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/UsingWithRDS.SSL.html Example command line (works perfectly): mysql --host=$host --user=$ssl_user --password=$pw $db --ssl-ca=rds-ca-2015-us-east-1.pem Example Perl (gives the same error I get if I try to connect without the cert above): $connect = DBI-&gt;connect( "DBI:mysql:database=$db;host=$host; mysql_ssl=1; mysql_ssl_ca_file=rds-ca-2015-us-east-1.pem", "$ssl_user", "$pw" ); The DBI examples I'm finding online always use 3 certs, but RDS only requiers 1. http://stackoverflow.com/questions/23566966/perl-dbimysql-connection-over-ssl-fails
I hope he is doing much better physically now.
:) I wonder if this PR could solve your issue: https://github.com/libwww-perl/LWP-Protocol-https/pull/24 If it does, please comment on the ticket and I'll see about bugging someone to release the fix.
Perl 6 should have its own sub. It's not Perl and linking it here only causes confusion.
if you are on Unix, you can use the standard utility, grep, to extract lines from a file. grep exception log.file or extended grep to use fancier patterns in your search egrep 'exception|inception|blah' log.file If you want to do it using Perl, you can use the -n flag to process every line of the specified file. perl -n -e 'print if /exception|inception|blah/' log.file The -n means to go through the file specified as an argument, line by line. -e means to evalulate the specified chunk of code, once for each line read. The lines are stored in the default variable, $\_, and conveniently, the match operator // examines $\_, if not variable is specified ... and print will print $\_ if you don't specify a variable. You can also use -E instead of -e, with modern Perls, and automatically have access to say() and some other new features, but the input lines have a newline at the end, so rather than chomp() that off and stick it back on with say(), we can just use print(). Also while -n just reads in each line and leaves it up to you what happens with it, -p reads in a line, invokes your code, and then prints it out. This is useful if you want to make a minor change to certain lines, for example to update config files. Finally, you can use -i.bak with -p -e to save the orginal file as a backup, with the changed version going to the orginial name .... or use -i on it's own, without the .bak, to edit a file in place, if you are confident.
/r/perl6 may have less traffic because no one uses it, and, being realistic, probably never will. What exactly makes it "Perl" besides that its creators decided to call it that? 99.9% of people looking for information about Perl are looking for Perl 5. If you say "Perl" with no qualifier, you mean Perl 5.
Great information! Another question: What if I'd like to use a different regex, depending on a switch that the user specifies? So, if they do myscript.pl -d, one particular regex is used but if they do myscript.pl -v, another (different) regex is used? 
I'm sorry you are so confused and incapable of delineating posts on Reddit you want to read, epecially when there is a giant butterfly next to the ones you dont. At one time when people said "Perl" with no qualifier they meant Perl 1, what makes Perl 5 Perl!!!!!!212123123 I'm 100% sure you're just trolling for the sake of it. But please point me at where all the confusion is happening because I really would like to see how bad it's become. Last I checked it was people day1 looking into Perl for the first time ever and they immediately understand and find their way. Kind of like how I don't accidentally deal with Python 2.7 when I'm working in 3.5. I know the language and I'm not an idiot. The main site for "Perl" makes things pretty clear I feel https://www.perl.org/
The description for this subreddit says: &gt; The Perl Programming Language, including both Perl 5 and Perl 6. 
[removed]
[Here's](https://metacpan.org/pod/Plack::App::FakeApache) a migration strategy for moving off mod_perl that might work for you. mod_perl is a horror. Actually it's a good thing with which to write apache extensions, but absolutely terrible for writing web applications.
Then you lack imagination and understanding. Which is fairly evident. I've been a user of Perl 6 since the first Rakudo* release, rather than a core developer, because I genuinely like the language. It gets rid of a lot of the things that personally erk me about Perl 5 even after more than a decade using it professionally. Again though your numbers are off and likely based on how things were a year ago at least. But hey why be angry at reality when you can invent your own world of hatred and anger. The reason I get annoyed by posts like yours is I am involved enough with Perl 6 to see the huge amount of human effort that's gone in to speeding things up and improving the language. The pre-caching model in Rakudo Perl 6 so that you can permanently precompile is both complex and now really very functional. All of these numbers are after I've run each command a few times to flush out-of-cache timings away: $ time perl6 -e '' real 0m0.198s $ time perl6 -e 'say "hi"' hi real 0m0.229s $ time perl -E '' real 0m0.012s $ time perl -MMoose -E '' real 0m0.216s $ time perl -MMoose -E 'say "hi"' hi real 0m0.251s Perl 6 is as fast starting as Perl 5 with Moose, but you get more than Moose as default at startup. That isn't some advert to just jump on Perl 6 either. Just simple fact. If you want something super fast starting and don't care about OO Perl 5 will likely always be a better faster choice, if you do always use Moose then Perl 6 is perhaps minimally at least interesting and shows that Moose is really quite fast already.
As a lighter weight alternative designed for CPAN modules, I really enjoy [Minilla](https://metacpan.org/pod/Minilla).
Same here, why no books?
There should at least be a note that Test::Builder has been superseded by Test2. 
You could make the script a modulino: it's a program structured like a module. 
Because it is still very much a moving target. I tried to play with it again recently and immediately ran into Unicode problems: $ perl -CO -E 'say "e\x{301}"' | perl6 -pe '' | perl -COI -ne 'printf "U+%04x\n", ord for split //' U+00e9 U+000a Perl 6 enforces an NFC-like normalization on all strings (ie the Str type). To write something that doesn't muck about with your text, you have to use the Buf type which holds raw bytes: $ perl -CO -E 'say "e\x{301}"' | perl6 -e 'while (my $buf = $*IN.read(1)) { $*OUT.write($buf) }' | perl -COI -ne 'printf "U+%04x\n", ord for split //' U+0065 U+0301 U+000a But wait, those are raw bytes, so the Buf is actually the UTF-8 encoded values we are expecting: $ perl -CO -E 'say "e\x{301}"' | perl6 -e 'use experimental :pack; $*IN.read(100).unpack("H*").split(/../, :v).map({ .Str }).say' ( 65 cc 81 0a ) Also, the Buf type has almost no methods. Almost anything you might want to do with the text will have to be implemented from scratch. Want to run a regex against some text without converting it to NFC first? No chance, regexes only work with the Str type. Want to split by graphemes? No chance, split only works with Str and good luck implementing a UTF-8 decoder to even find the code points let alone whole graphemes. The general answer seemed to be that the Uni type is what will hold raw code points without applying a normalization to them, but there is currently no way to read a file in as Uni (you can't even read it in as a Buf and then convert to Uni because the decode method returns a Str). And even if you do write your own UTF-8 decoder and produce a Uni "string", Uni can only do two things right now: 1. convert itself into a different type (NFD, NFC, etc) 2. tell you how many code points it holds You still don't get any of the string functions like split and you certainly don't get regexes. So, they could, in theory, fix all of this by making Uni more robust, but it won't be simple and will, in my inexpert opinion, require changes to how strings are handled (eg you should be able to specify which "string" type (Uni, NFC, NFD, Str, etc) you want to use). 
Is it a nice place to work? They have a small team but always seem to be hiring which makes me worry about turnover. 
You can take a look at http://perl6intro.com I wouldn't label it as a book, it's kind of a long tutorial (around 70 pages when converted to pdf). I hope it can help.
doc.perl6.org
bootstrap is part of DynaLoader. "DynaLoader - Dynamically load C libraries into Perl code" http://perldoc.perl.org/DynaLoader.html The parse() method is in Parser::Parser http://search.cpan.org/~wsnyder/Verilog-Perl-3.420/Parser/Parser.pm
&gt; The parse() method is in Parser::Parser That's the exact same source file that OP was looking at and couldn't find the implementation. It's [implemented in native code in `Parser.xs`](https://metacpan.org/source/WSNYDER/Verilog-Perl-3.420/Parser/Parser.xs#L430), which in turn relies on [a quite intricate bison-generated parser](https://metacpan.org/source/WSNYDER/Verilog-Perl-3.420/Parser/VParseBison.y). 
Given that this sub-reddit is clearly marked as being for discussion of both Perl 5 and Perl 6, I'm sure I speak for all of the moderators when I say that we'll ignore any reports that mark P6 stories as spam for no reason. We're far less likely to ignore posts like yours which contain personal attacks. You might want to reacquaint yourself with the code of conduct which is in the right-hand column. &gt; Be civil or be banned. Anonymity is OK. Dissent is OK. Being rude is not OK.
To add to /u/commandlineluser, as soon as you want to allow the user to provide options you should be using [Getopt::Long](https://metacpan.org/pod/Getopt::Long), it's the standard and core but there are also many other option parsing libraries either wrapping Getopt::Long or providing a different interface. If you parse the options yourself you will end up having to handle a ton of edge cases and you'll be missing features that are expected in command line scripts, and these libraries already do this for you. My recommendation for how to use Getopt::Long is packaged as [Getopt::Long::Modern](https://metacpan.org/pod/Getopt::Long::Modern), you don't have to use the module but I recommend to use the configuration options mentioned there, so your options are parsed like most other linux tools. The Getopt::Long docs have a good overview of how you can specify options but here is an example: use Getopt::Long::Modern; # or use Getopt::Long qw(:config gnu_getopt no_auto_abbrev no_ignore_case); my $re; GetOptions( 'dblahblah|d' =&gt; sub { $re = qr/foo/ }, 'vblahblah|v' =&gt; sub { $re = qr/bar/ }, 'someother|s=s' =&gt; \my $other, ) or die "Error in command line arguments\n"; This example would give your script a -d (or --dblahblah) option which would set $re to one thing, a -v (or --vblahblah) option which would set it to another thing, and a -s (or --someother) string option which would set $other to the passed string (like `--someother=foobar` or `-s foobar` would set it to foobar). If no options are specified $re would remain undefined. Also, GetOptions will remove any parsed options and option values from @ARGV, leaving it with any non-option arguments for you to handle.
There still seems to be an error in that it presents Perl 6 as "the future of Perl" when it is in fact a completely different language.
Thanks 
I remember running into that awhile back, but forgot all about it. I remember your HackerNews comments as well on no longer using P6. Thanks for your last P5 book btw! 
Hello, I am new here and was directed to this discussion by someone knowing that I am in the process of completing a book on Perl 6. The book has been accepted by a major publisher very recently. The book is basically fully written, but it is being reviewed by some core Perl 6 people, and this will take some more time. It might hopefully be out within a few months. It's a book originally based on the "Think Python - How to think like a computer scientist" book, adapted to the Perl 6 language. It is not primarily a book about Perl 6, but more a book about learning the art of programming, and doing that in Perl 6. Because of this orientation, it does not cover every aspect of Perl 6 (for example, macros and concurrency are not covered), but it still does cover quite a large part of the language. 
&gt;&gt; Same here, why no books? &gt; Because it is still very much a moving target. Swift is still very much a moving target. Authors have written tons of books about Swift 1, 2, and 3. Perl 6, via v6.c, the official "production" version of the Perl 6 language, is actually *frozen* (modulo errata). See [versioning guidelines](https://gist.github.com/jnthn/c10742f9d51da80226fa) to understand the language-level support for both stability (for authors and production users) and evolution (for future improvement and bleeding edge users). Last but not least, it turns out that *any* reason why authors haven't written any recent books yet is false. (See Laurent's post in this thread.)
* The person I was responding to started the personal attacks. The fact that you ignored that and gave _me_ a warning says a lot. * Perl 6 is not Perl, and the fucking idiots that post about it are wasting everyone's time with what amounts to spam. You need to fix the rule that allows it, because it's a problem _you're_ creating.
Ah, nice. Thanks. I don't think I've run across that before.
That's pretty awesome! Make sure to advertise it on r/Perl, r/Perl6, perlblog, and some of the other popular perl blogs out there.
I finally have an example for you. See my [stasis](https://metacpan.org/pod/stasis) distribution. It has no module file at all. You could download the tarball, replace `stasis` and `README.pod` with you're own versions, and then update the Makefile and META files with the details of your program. You may need to add a package declaration to the to of your program too (see the `stasis` file for an example).
Why do you think that? Is it because the Perl 6 syntax has been changing more than Swift?
&gt; Do you agree that it's more accurate to say you ran into Unicode solutions that you're not happy with? No, I do not agree that you can classify throwing away data by default is a "solution". And even if I was willing to consider it a "solution", I certainly would still consider it a showstopper bug to provide no other way around that "solution" than to reimplement the entirety of the string functions (including UTF-8 parsing!). I cannot even begin to fathom how the Perl 6 team came to this decision. Especially in light of the fact that they chose to make Rat the default class for non-integer real numbers. It is like they took one step forward with numbers and two steps back with strings. &gt; v6.c allows devs to handle text data at three levels: This is a flat out wrong. It will, one day, maybe, it is sort of planned to, but there are people in #perl6 asking why you would want to do that, allow you to work with raw codepoints. There is currently no way I, or anyone on #perl6, could find to read data from a file containing "e\x[301]" into a Uni string without throwing away data except by reimplementing a decoder for the encoding the file is in. By this logic, Perl 1 provides complete Unicode support, you just have to use the language to implement it yourself. Even if I were to accept that implementing a UTF-8 parser was a reasonable solution for a normal developer, to say "Perl v6.c allows devs to handle text data at ... Unicode codepoints (in either the non-normalized Uni type or a choice of NFC, NFD normalizing types)" stretches the truth beyond the breaking point. There are practically no methods in Uni. The only way that statement can be construed as true is if your definition of "handle text data" is you can (once you have implemented a decoder for the file you are working with) convert it to one of four normal forms that is equally bare of functionality. Using this definition, any language that provides arrays of 64 bit integers also allows you to "handle text data". Now I have barely started to learn the new Perl 6 (the last time I seriously looked at it was in the Pugs era), but I am finding some really odd behavior in the some of the methods of the Uni class: &gt; Uni.new(5.ord).Int 1 &gt; Uni.new(5.ord).Str.Int 5 &gt; Uni.new(5.ord).Numeric 1 &gt; Uni.new(5.ord).Str.Numeric 5 So, I would categorize Uni as both useless **and** buggy. &gt; Only Str supports character-aware operations. Gee, why would I want those? They are completely unnecessary for handling text. I would apologize for the sarcasm, but I can't see any other sane response (which probably says more about me than Perl 6). &gt; &gt; and will, in my inexpert opinion, require changes to how strings are handled &gt; Of course. But that doesn't mean breaking changes. Again, I am not an expert in Perl 6, but I have been around a long time and I seriously doubt that. There will be complications found once implementation starts.
&gt; For a long time CPAN was the biggest repository of its kind (in fact, the only one) CPAN has never been the only repository of its kind. The whole idea for CPAN was "borrowed" from [CTAN](https://www.ctan.org/).
&gt; I do not agree that you can classify throwing away data by default is a "solution". OK. What I meant is that throwing that data away by default is a deliberate response to the huge problem of dealing sanely with *characters* and it solves that major problem. &gt; There is currently no way I, or anyone on #perl6, could find to read data from a file containing "e\x[301]" into a Uni string Right. There's no version of `get` and `lines` that creates Uni strings. &gt; I am finding some really odd behavior in the some of the methods of the Uni class Aiui Uni is more a list-like datatype than a string-like one. A list-like datatype, treated as a single number, is its length. Treated as a string, it's a concatenation of the stringification of each of its elements. &gt;&gt; Only Str supports character-aware operations. &gt; Gee, why would I want those? They are completely unnecessary for handling text. To clarify, when I write "character" I mean "What a user thinks of as a character", otherwise known as "grapheme". So perhaps what I wrote would make more sense if it was written as "Only Str supports grapheme-aware operations.". But it's really weird to use an odd word like "grapheme" when what it means is "What a user thinks of as a character" and when Perl 6 itself has adopted the word "character" to mean "grapheme".
Happy to see that there are currently [162 issues labelled "Hacktoberfest"](https://github.com/search?l=&amp;q=state%3Aopen+label%3Ahacktoberfest&amp;ref=advsearch&amp;type=Issues&amp;utf8=%E2%9C%93) in Perl projects.
The home-finding module would actually be useful if it was actually implemented well. It's one of those non-trivial things with which I'd rather not concern myself if I don't have to (though I very rarely deal with a home directory specifically).
Perl 5 seems to work just fine without throwing away data. Yes, "\xe9" is supposed to be equal to "e\x[301]" and that can make life hard for people designing languages, but the answer isn't to just punt and throw away data. If Uni is going to be at all worthwhile, the problems are going to have to be solved anyway, but now there are going to be two ways of dealing with strings: the Uni way and the Str way, but the Str way is the default and it throws away data. Many people are not going to notice that nicety until too late. Hopefully they will not have just borked a file that doesn't have a backup. I certainly didn't notice it until I was I rewriting one of my tools that does a hexdump like thing but at the code point level and noticed I wasn't getting accurate results. There is literally no way to write the following Perl 5 code in Perl 6 without writing your own UTF-8 decoder: perl -CI -ne 'printf "U+%04x\n", ord for split //' file &gt; Aiui Uni is more a list-like datatype than a string-like one. A list-like datatype, treated as a single number, is its length. Treated as a string, it's a concatenation of the stringification of each of its elements. This right here is a perfect example of why the Uni/Str thing is insane. I just want a string that matches the data in my file. It doesn't have to match it bit for bit, but I should be able to recover the exact bits from that string if I know the encoding. But this supposed answer, the Uni type, isn't a string (even though it does the stringy role), it is a list. Do you not see how disconnected from common usage this is? &gt; To clarify, when I write "character" I mean ... "grapheme". Yeah, I got that and wasn't making an issue of it. What I am making an issue of is the idea that only NFC strings count as strings of graphemes. NFC isn't some magical arrangement of code points that turns into graphemes. The code points U+0065 U+0301 is a valid grapheme cluster. Converting it into U+00e9 should be a **choice the user makes**, not standard policy. The language designer should not be forcing this onto the user. I still don't understand what problems it solves. You still have to deal with other grapheme clusters like U+0078 U+0301 (x́) that don't have a combined form. So all this does is make it easier to do comparisons. This is a language that decided that, for the sake of accuracy, to use rationals instead of IEEE floating point by default, but has also decided that it is okay to change a string's code points because that makes implementation easier. Do you not see the disconnect here?
Interesting. I would have recommended a lightning talk too.
If you absolutely have never spoken before an audience before and want to give a talk just because it seems like a good idea, go with a lighting talk the first time. Otherwise the advice to see how long your material is by simply writing the talk and trying it out first is excellent. You discover that maybe you have a 30-40min talk that is easier to expand to 40-50min than it is to trim or a 25min talk that is super easy to get down to 15-20min instead of expanding. You also now have the talk written and can practice it a few times, revise and edit, and make it as powerful as possible before delivering it at its intended venue.
Of course, when a corporation started threatening *CPAN* authors, the end result was rather different - see http://p3rl.org/Nagios::Plugin for the write up.
It many not be designed as one, but people have abused it as if it was one. http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf The description I stole from [StackOverflow](http://stackoverflow.com/questions/2968411/ive-heard-that-latex-is-turing-complete-are-there-any-programs-written-in-late#2968527): &gt; In issue 13 of The Monad Reader, Stephen Hicks writes about implementing the solution to an ICFP contest (involving Mars rover navigation) in TeX, with copious use of macros. Amusingly, the solution's output when typeset is a postscript map of the rover's path.
It absolutely is. And actually I learned modular programming from TeX.
What an unfortunate situation. I'm glad XDG is involved though - maybe a neutral party can detox the discussion a bit.
Didn't know about this module ... but, hooray!
There speaks a man who's written a thesis! :-)
Actually, I think it's quite apt. Both are relatively new languages for which books were written before during and after their production release. I think Swift is an excellent benchmark for comparison in terms of when and where it makes sense for authors to engage it as a target. 
That's correct. There's at least one Perl 6 Advent Calendar where those posts would be welcome: https://perl6advent.wordpress.com/
Please demonstrate how to read a file containing "re\x{301}sum\xe9" into a string (ie something you can do normal string operations on) and back to a file in Perl 6. You can do it with a Buf, but you can do almost nothing with a Buf. You can't even read it into a Uni without implementing your own UTF-8 decoder because the default one only does NFC. This is most certainly on topic, as it demonstrates why few people are interested in writing/buying a Perl 6 book. There is no trust after all of this time that things are really frozen. I don't think you can resolve this problem with the system in place now. Uni is not a string data type despite doing the stringy role. People can talk about future plans until they are blue in the face, but plans don't survive contact with reality. Once a full Uni class begins being implemented to deal with the glaring problems with how Str is implemented there will undoubtedly be breaking changes need to how strings are handled. And that is just what I have run into in my latest brief survey of Perl 6.
&gt; I think Swift is an excellent benchmark for comparison in terms of when and where it makes sense for authors to engage it as a target. I know several people who write and train in the Apple ecosystem. When Swift was announced, it was quickly obvious that they all would adopt it as a writing and training target. I also know several people who write and train in the Perl ecosystem, and [another comment describes what I've seen accurately too](https://www.reddit.com/r/perl/comments/557m4k/any_new_perl_6_books/d88xgak). Arguing "Swift is under development, but it has books, so it's okay for all languages under development to have books" is silly because it ignores some important differences between Swift and Rakudo.
the diff looks really straight forward if you want to patch it yourself while you wait.
Exactly. That's why I think Raiph's argument is so dishonest.
&gt; Want to run a regex against some text without converting it to NFC first? Sure don't! That would mean I either miss parts of the data I'm aiming for (because it was normalized and I looked for un, or vice versa), or tediously stuff long alternations full of non-normalized renderings into every crevice of my regex. Granted that Perl 6.c doesn't have a built-in data structure that maintains a joint Buf, Uni, and Str representation with full alignment between its layers. That seems to be what you're saying you need. You are perhaps the first person to state a need for that. And yes, it seems not to exist yet, whereas features that lots of people have said they need (such as giving graphemes their own reified level of abstraction) seem to be further along. &gt; you should be able to specify which "string" type [...] you want to use Type system, yo? You can even define and implement a type that does the things you say you need, and insist on it where you need to, and allow sundry other stringy types where you don't. 
&gt; Arguing "Swift is under development, but it has books, so it's okay for all languages under development to have books" is silly Nobody's arguing that. The dialectic is "Why doesn't Perl 6 have many books?" "It's under development." "If that explained the lack of books, Swift would lack them too. Ergo that's not the explanation."
Raiph's posts are unedited as of when I loaded them. I read them twice for general interest, and I read them twice more solely to look for this thing you say he said, and I just. don't. see it. So yeah, I left it out. &gt; I'm done explaining that in this thread. We'll see.
Dist:Zilla looks like overkill for me. Thanks. Can you tell me how to write tests for the `t` directory for testing a stand alone script?
Yes, I will, once it gets out. Thanks for your answer.
Open Auth (The ins and outs) Google, MS, etc. Was on a single line in the original, posting it removed the new lines.. I edited to make it a bit more clear. Specifically Open Auth Providers Like Google, MS, etc. An understanding of how Open Auth/OpenIDC 2 works is a plus.
To add, in perl we have [File::HomeDir](https://metacpan.org/pod/File::HomeDir) which is much better implemented and very cross platform, though not perfect (yet) either.
I understand. Thank you for the clarification.
As a hiring manager I suggest talking about the type of tasks/what the business does too. :) Do you write software to save the world, spam everyone or something in between? 
Anything date related is the guaranteed way to a mental facility. You guys are much braver souls than I.
The time and place for Perl 4 is in the CGI environment in mid-1994.
I dunno... Perl 4 is the happening language again. Did you see the new library for Perl 6 compatibility? It's much better than the Perl 5 version because it uses require ;-) 
I would say we are more in the save the world camp, as opposed to spamming the world. We work with big data, we do data segmentation, and campaign management, and we also have a mobile app platform that we develop and maintain.
I'm going to try summarize what I understand to be the *technical* concerns (and *not* project / product level etc. concerns) that you have that ought not be contentious. My ideal is that you reply to say "what he said" or similar, confirming this summary covers enough key points, and I can then refer #perl6-dev folk to this thread. I'm deliberately omitting some other things you've indicated you think essential but which I think are best not repeated in this summary or your reply to it. 1 Rakudo's Uni implementation is so weak it's barely usable. The two biggest things are that reading/writing a file from/to Uni is NYI and string ops coerce Unis to Strs, normalizing them in the process. 2 The Str type forces normalization. The user can't realistically get around this except by using Uni -- but see point #1. 3 Reading a string of text from a file means using Str which means NFC normalization. The user can't realistically get around this except by using a raw Buf or Uni -- but see point #1. 4 How realistic/practical is it to use Perl 5 Unicode modules with Perl 6? Does `use Unicode::Collate:from&lt;Perl5&gt;` play well with Perl 6? &gt; If you were going to add a test to confirm that "e\x[301]" became "\xe9", which file would you put it in? Aiui tests of that ilk are programmatically generated (eg https://github.com/perl6/roast/blob/master/S15-normalization/nfc-0.t). Most other relevant manually written tests will likely be at paths that start https://github.com/perl6/roast/tree/master/S15-
Also, I'm sure you're familiar with (https://p6weekly.wordpress.com/), but if not, it's a good source of information that gathers all news on P6 from a wide variety of sources. Even a post I made on here made it there once, so the curator is extremely thorough (your book will probably get a bullet point regardless if you give them an fyi :)).
I don't think the statements you made are controversial, but they do not accurately represent my position. I have discussed this Perl 6 feature with at least eight other Perl 5 programmers (one of whom is familiar with Perl 6 and even contributes) and every single one of them had the [wat](https://www.destroyallsoftware.com/talks/wat) reaction. Now, sometimes, the wat reaction isn't fair; sometimes there are strong reasons for the behavior, but often they arise from a bad design choice made early in the language's history (eg JavaScript's "1" + 1 = "11"). I have looked and I see no strong reason for Perl 6 to be discarding data in the Str type. Nothing is gained by doing this (that I can see). The supposed benefit (O(1) indexing) can be achieved without discarding the data. I can see a future where Uni has been fully implemented and works just like a string. I also see, in that future, every single new Perl 6 programmer stubbing his or her toe on this feature, cursing the Perl 6 devs, and loading the sugar that makes Uni the default string type. Sadly, a large number of them won't discover this feature until the code gets to production. Then they will be left trying to explain to their bosses why their chosen language decided throwing away data was a good choice. The mantra "always say `use string :Uni;`" will become the new "always say `use strict;`". Ask yourself this: what does Str do that a fully implemented Uni doesn't? If the only thing is O(1) indexing and throwing away data, then why implement it to throw away data when you don't have to? If it can do things Uni can't, then Uni is a second class citizen (something you claim isn't true) and it is even more important that you don't throw away data. The programmatically generated tests seem to only cover Uni -&gt; NF* (completely uncontroversial, converting to NF* is a user choice), not Str. I have looked through the other S15 tests and I don't see anything that explicitly tests it, but there might be something like uniname that tests it indirectly.
Yeah I know, common sense now, just thought I'd share a weird insight :)
Yeah, I kinda get how it works, just found it surprising :) cheers for the extra info!
Don't have time to read it all right now but from the start it seems good, I don't actually know fully what strict does... seems like a good read.
If you use Data::Dumper::Simple you'll get less confusing output. 
I disagree with the linked statement. One should always use strict not to make your code better, but to avoid very common failures which are easy to miss. I'll also note that talk is from 2003, when the warnings pragma was still new and people were still using the vars pragma instead of 'our'.
Personally, I much prefer to"use common::sense". Check it out.
I didn't write the code :) Edit: Amazing, I thought you were joking - https://metacpan.org/pod/release/MLEHMANN/common-sense-3.74/sense.pod
[removed]
Thanks for replying. I've left a message about our exchange on #perl6-dev.
[Looks dead](https://github.com/perl6/book)
I was about to sarcastically say the one feature it needed was "a release". Then I read the article, hadn't even realised it had been released as I'd given up checking back in to see what the state was. Time to get cracking on 6.
Awesome, thanks for the heads up. I've since replaced with HTTP::Tiny, but it would be useful to know that LWP will still work securely in a pinch. I'll test and report back.
It doesn't really share the problems of Python's migration, but there are other interesting problems. This is not a new version of Perl but a new language called Perl 6. The development of Perl 5 has not changed due to the release of Perl 6 (Larry Wall has not been involved in Perl 5 development for some time), so there is no more compunction to migrate to it than to migrate to Ruby or Node. There is, however, a huge confusion resulting from this arrangement.
Largely posted to get some discussion going. Should we be appalled that people are being taught such horribly outdated Perl; or should be be grateful that people are being taught any Perl at all? Also, is there anything we can do to improve the situation?
Yeah. I'm used to seeing CGI questions too. And, whilst that's clearly sub-optimal, I generally answer the question and just include a pointer to PSGI. But this is different. This isn't just CGI, this is mid-90s era CGI. This is CGI without CGI.pm. This is CGI with hand-written query parsing. This is CGI with embedded HTML. This is CGI with ampersands on subroutine. In short, this is a Perl course that hasn't been updated in almost twenty years. And that's not acceptable. I certainly take your point about needing more CGI is dead docs. I have an idea alone those lines that I'll be asking for help with in a couple of weeks.
Appalled. If this is the first Perl exposure people get to Perl, it's no wonder they switch away to the first language that appears nicer.
A while back, just for the hell of it, I took a practice quiz of the A+ exam. If I had gotten the same score on a full exam, I would have passed without any study, but I had to guess on a lot of old obscure stuff. Things that I had exposure to at some point, but have totally forgotten, like VLB slots and SCSI cable length limits and the write-protect notch on 5.25 inch floppies. There's a reason those questions are there: the A+ exam is meant for people maintaining hardware in a corporate environment, and corporate environments have a lot of old ass shit. I would rather that people's early exposure to Perl have nothing to do with CGI. Modern frameworks have totally superseded it. But I understand why we need people who still know this stuff.
I'm a fan of CGI personally. It's extremely simple and easy to implement an app on your own without needing cgi.pm; all you need is access to environment variables and stdin. I'm actually writing a CGI app in Common Lisp right now, simply because it's so easy to get things done and it feels less magic. I don't know about others, but I don't like the magic that's coming with web frameworks and even concepts in PSGI. I don't want it to be obscured. Or maybe I'm just old fashioned :)
Hey, this is the way I did it in the 90s (at first, although I switched to mod_perl soon) so I feel right at home! 
I would suggest than if one feels the need to correct some newbie's code in favor of The Right Way or Modern style or whatever cargo cult groupthink happens to be in vogue, educate why instead of just saying 'don't do this.' 
Step #1: don't build it up to such a life-or-death thing that you think about it in terms of "survival"... 
 Most database access these days is written using DBIx::Class which is a wrapper on top of the raw DBI that you are using. Just curious, is this really true? I avoid ORMs but never stop researching them.
It isn't ridiculous at all. You wouldn't use raw Plack for a simple task, you would use a simplified single-file framework like Dancer2 or Mojolicious::Lite and use less code with more reliable results. https://metacpan.org/pod/CGI::Alternatives#Mojolicious and the relevant tutorial guides have examples. They work as CGI scripts either directly or with a PSGI shim, and can be transparently served in more performant ways if you choose. As for learning the raw CGI protocol, you could do that if you want but it's somewhat orthogonal.
The page you linked to quotes, and attempts to refute, the idea that using those frameworks is more complex: &gt; "CGI.pm scripts are shorter and simpler than alternative implementations." Again, not true and the following examples will show that. OK so here we go: **Mojo**: ------ #!/usr/bin/env perl # in reality this would be in a separate file package ExampleApp; # automatically enables "strict", "warnings", "utf8" and perl 5.10 features use Mojo::Base qw( Mojolicious ); sub startup { my ( $self ) = @_; $self-&gt;plugin( 'tt_renderer' ); $self-&gt;routes-&gt;any('/example_form') -&gt;to('ExampleController#example_form'); } # in reality this would be in a separate file package ExampleApp::ExampleController; use Mojo::Base 'Mojolicious::Controller'; sub example_form { my ( $self ) = @_; $self-&gt;stash( result =&gt; $self-&gt;param( 'user_input' ) ); $self-&gt;render( 'example_form' ); } # in reality this would be in a separate file package main; use strict; use warnings; use Mojolicious::Commands; Mojolicious::Commands-&gt;start_app( 'ExampleApp' ); This is a "full fat" version of the app in Mojolicious, as stated in the comments you would split the packages out into separate files in the real thing. Run using: morbo examples/mojolicious.pl ---- and this is simpler and less code, they say, than this, with clunky old CGI.pm generating the HTML, in a worst-case scenario. **CGI.pm**: ---- #!/usr/bin/env perl # most CGI.pm scripts i encounter don't use strict or warnings. # please don't omit these, you are asking for a world of pain # somewhere down the line if you choose to develop sans strict use strict; use warnings; use CGI qw/ -utf8 /; my $cgi = CGI-&gt;new; my $res = $cgi-&gt;param( 'user_input' ); my $out = $cgi-&gt;header( -type =&gt; 'text/html', -charset =&gt; 'utf-8', ); # html output functions. at best this is a lesson in obfuscation # at worst it is an unmaintainable nightmare (and i'm using # relatively clean perl code and a very very simple example here) $out .= $cgi-&gt;start_html( "An Example Form" ); $out .= $cgi-&gt;start_form( -method =&gt; "post", -action =&gt; "/example_form", ); $out .= $cgi-&gt;p( "Say something: ", $cgi-&gt;textfield( -name =&gt; 'user_input' ), $cgi-&gt;br, ( $res ? ( $cgi-&gt;br, "You wrote: $res" ) : () ), $cgi-&gt;br, $cgi-&gt;br, $cgi-&gt;submit, ); $out .= $cgi-&gt;end_form; $out .= $cgi-&gt;end_html; print $out; ---- Can you honestly look me in the eye and tell me that Mojolicious is less complex and uses less code?
That is the full app. I said Mojolicious::Lite, the example ~~below~~ above what you quoted.
The example below what I quoted is a wrapper for the CGI.pm script, so it can hardly be less code. It just wraps some sugar around the CGI.pm code so it becomes an app ... which I then have to start?
 use Mojolicious::Lite; any '/' =&gt; sub { my $c = shift; my $params = $c-&gt;req-&gt;params; }; app-&gt;start; More code? Maybe, but not once you actually need to do something. All of the params are decoded from UTF-8 which you need to do yourself using CGI.pm. $c-&gt;render will render text, json, or templates with the correct headers with no additional code. Dancer2 is even less code, since it tends to use more DSL style (like the any keyword) over object methods.
Sorry I meant above.
&gt; Using Plack would be ridiculous for a simple 5-minute task used by 20 people in my office. &gt; Those technologies are orders of magnitude more complex than CGI, need server-side knowledge and command line access a lot of the time &gt; They abstract away what's actually going on between the browser and your program, which in some cases is good I agree in part, though I come down slightly on the other side. Assuming you're using `CGI::Simple` instead of `CGI.pm` -- the code is better and a lot less complex, because it's trying to do a lot less, especially with its API -- I still prefer using Mojolicious (Dancer would be fine too) for a couple of reasons: * I have to care about fewer details I don't really care about (I can write my own CGI processor by hand, as I've done it far too often, and I know how to write it to avoid the at least four bugs I saw in the example code) * I don't have to test details I don't care about (my confidence that Mojolicious/anything PSGI compatible gets the basics right is high) * My code expresses the details I want to express in an appropriate way (the temptation for me is too high to intermingle the details of processing a CGI request with business logic in a single-file CGI script) * The questions of when a program-under-development transitions from a single-file script to a multiple-file project and how to arrange that project are already answered, because Dancer/Mojolicious/etc have decent opinions and defaults Or I could write something as a Plack handler directly, because I've done that too, and it's just as easy by now as writing to `CGI::Simple`, and I still get most of those benefits.
It looks like a long, complex and unhappy story. I hope very much it ends well for you. In any case, you have my thanks for your contributions. 
I don't completely disagree with your first point, because I don't think that is really a drawback; you have to learn how to use CGI.pm too, and then you have to learn how to work around its problems, or you end up with security issues, maintainability nightmares, or just plain broken code (failing to decode request parameters from UTF-8, for example). Which of Mojolicious or Dancer2 or any other Plack framework you pick up more easily differs by person and project. As for "too slow", that's just not true; if CGI.pm or CGI::Simple was fast enough to overcome to problem of reloading the entire program every request, then we wouldn't have had a mod_perl/FastCGI revolution as people tried to make persistent Perl applications. (Plack and Mojo applications can be deployed via these as well, of course.) The truth is, the perl interpreter itself is "too slow" for starting a new one on every request to be scalable; plus, lots of application logic has slower setup logic which in a CGI deployment has to be recompiled and run every request as well, regardless of underlying libraries. The framework you're thinking of that is very slow as a CGI deployed application is Catalyst, because it is based on Moose which is an object system designed to front-load as much setup as possible. We now have the significantly faster Moo (powering Dancer2) and Mojolicious uses its own object system. You still will get better performance from a persistent deployment because you don't have to start a new Perl interpreter, but it's hardly slow compared to CGI.pm.
In case anyone is wondering why the Mojolicious distribution is 3 times the size of the CGI.pm distribution despite having less code, it's because the tarball also includes over 11000 tests covering 95% of the code, significantly more documentation (as there is more to document of course), and a few hundred KB of art assets and javascript for the included development templates and error pages.
I think the decision to use an ORM is subject to the project's needs and the people involved. But if an ORM suits the needs, DBIx::Class is a good one to use. There are several modern connection managers for DBI which solve the basic problems of database access in a persistent environment, while still allowing you to use raw SQL: see for example [DBIx::Connector](https://metacpan.org/pod/DBIx::Connector), [Mojo::Pg](https://metacpan.org/pod/Mojo::Pg). This contrasts with the decision to use a modern perl web framework, which I maintain has no valid counter-argument once you understand the power and simplicity provided by the various options.
[removed]
Seeing this, I question myself: Is formal language theory futile? Perl 5 is unparsable, it says. Context-sensitive, not decidable, etc. Perl 6, in the other hand, has a regular grammar, which, according to them, is much simpler. Yet syntax highlighting has been implemented multiple times for perl5 without calling the actual parser. 
I'm not the one making the claim. Formal Language Theory is. That is why I ask if it is futile.
I question the value of trying to teach someone Perl by immediately demanding that they learn a PSGI framework, DB abstraction layer, and templating engine before making something that actually works on the web.
Maybe take a look at the formal Perl 6 grammar used in Rakudo to decide https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.nqp I found that clear and readable enough to write my own slang that gets mixed into the grammar as a Role. That can all be done from a user of the language declaratively and affect compilation. In my opinion that sort of meta language programming is the real strength of using a formal grammar.
Only these two things need to be highlighted more: - At which riba admits the capability for trolling: http://www.nntp.perl.org/group/perl.modules/2016/10/msg96188.html - At which riba admits the capability for autism: http://lists.scsys.co.uk/pipermail/dbix-class/2016-October/012234.html DBIC is a dead end now, better phoenix it to some other namespace!
No, every perl6 highlighting has problems. That's why this new library exist at all. 
Nope. But I do have a degree in computer science but didn't cover compiler design or even parsing. Just messing about with Perl 6 grammars yourself to do something simple scales to messing about with the language grammar. All you need to do is inject in a method in the right place to hook in your own little bit of code. So you can create your own bit of parser completely in isolation then mix it in https://github.com/MattOates/BioInfo/blob/master/lib/BioInfo.pm6
no I'm in a situation I need a book to study. I have a limited access to a computer. I'm thinking to read as many books as I can before I have a full access to a computer
The sequel to *Learning Perl* is *[Intermediate Perl](http://shop.oreilly.com/product/0636920012689.do)*. The books are deliberately written to complement each other. There's also a third book in the series called *[Mastering Perl](http://shop.oreilly.com/product/0636920012702.do)*.
Uh, what is this... the 1970s? Reading about programming doesn't mean much without practice. To practice, you need a computer. It could be a very cheap very old computer, but without a computer it's pretty much a waste of time. 
There are two books called *Beginning Perl*. One is written by Simon Cozens with later editions updated by James Lee. This was good when it was published, but it's rather dated now. The other is by Curtis Poe and is highly recommended. *Modern Perl* is also well worth reading. Basically, any of these books would be good. Getting different authors' views on the language is always a good idea. You might also add *[Effective Perl Programming](https://www.pearsonhighered.com/program/Hall-Effective-Perl-Programming-Ways-to-Write-Better-More-Idiomatic-Perl-2nd-Edition/PGM95897.html)* to your list of options.
like I said above, I'm in the army. I finish my service next year, will go back to finish my sw eng deg. meanwhile I'm trying to read textbooks I didn't read when I was in school. I know how important actually solving problems using a computer. But I just don't get much time with a computer...I don't think I'm being a laughing stock reading programming books because I get a lot of free time reading books and I found programming interesting....It would be nice to have my own computer here but whatamIgonna do...thanks for ide link by the way
Thanks. In other systems that do the same it's very difficult to find someone without formal training capable of dealing with them. Perl6 is revolutionary.
Oh I see. Well in that case, I'd recommend you'd rather dig into more abstract, theoretical books, whatever the language, and not so much the hands-on guides. Stuff like the "SICP" book, long title "the Structure and Interpretation of Computer Programs", which is in Scheme, a Lisp dialect, but the code is incredibly compact and readable. In Perl I could recommend "Advanced Perl Programming" from the O'Reilly collection (I prefer the original version to the rework), and "Higher Order Perl" by M.J. Dominus. Books that make you think, rather than rush to a keyboard to try it out.
&gt; I'm scared to go deeper for perl because I see so many negative opinions on learning perl in 2016. I'm not sure anyone can give you a definitive answer on subsequent question to this, but there are a lot of negative opinions about a lot of things in technology that are completely separate from whether or not something has value. PHP is probably a pretty good example of what I would consider a fairly universally disliked language, but that doesn't seem to curb the sheer number of people out there using it. I've always found it somewhat interesting that anybody uses PHP when Perl exists, but I suppose maybe we have Wordpress to thank for that? &gt; Am I just better off studying other language? I think this depends a lot on what your motivations were for potentially picking up Perl in the first place. Based on your prior knowledge of C, I'm assuming you've got at least some overall grounding in general programming techniques/skills. These underlying skills transcend the language you apply them to, so "picking a language" doesn't have to become a singular decision. What motivations are driving your decision on which language to focus on now? Longevity? Perl has been around long enough to see plenty of other things come and go. It's popularity is definitely waning at present, but the only thing that will change is more people building more cool/interesting things with it (and talking about it!). Availability of existing resources? CPAN is an amazing collection of historical work that has pre-solved a vast selection of problems that came before you. You'll be hard pressed to find common problems that don't have pre-existing go-to solutions on CPAN. Potential for driving personal income? There are still quite a few well known companies utilizing Perl, and while the startup scene seems to be dominated by people talking about Ruby on Rails or the latest Javascript framework of the month, I can personally attest to the fact that there are still small companies out there driving large scale web applications in Perl. Additionally, possibly based on current lack of popularity, demand for good Perl developers is probably a very real thing. Speaking strictly as someone who has spent the vast majority of the last decade working for very small startups building web applications in Perl, we're always in need of good Perl resources. Personal satisfaction? This is obviously extremely subjective, but I find Perl far more enjoyable to work with than most other languages I've worked with. I could probably write a long narrative on why that might be, but the reality is that I enjoyed the language from my very first interactions with it. While I understand some of the historical reasons why Perl earned a bad name for being a "read only" language, I can personally say that I find well organized Perl applications to be exceedingly easy to read and acclimate to (at least, those that have been written with such things in mind). This is turning into a rather long reply, so I'll cut it off here and just say: No one can necessarily provide a direct answer to this overarching question, but if you would like to share some of your concerns perhaps we can set you at ease (or, at worst, confirm your fears and solidify your focus in another direction). Regardless, it's refreshing to see interest in Perl, and in programming in general (particularly in the absence of even a computer to work with). Keep it up, OP, and good luck with everything ahead of you!
TBH, If you're afraid of people being "trolling capable", you should probably avoid much of CPAN. We're all trolling capable, myself included. But I have a liberal definition here, and I include teasing people for shits and giggles in a jovial manner. Because there was already a word for internet hostility: Abuse. And a "capability for autism" is a thing you need to warn of .... why? ( And I really fail to see how the second citation conveys that "admission", the substring "auti" has zero matches on that page )
There's a book called [Higher Order Perl](http://hop.perl.plover.com/) which covers advanced functional techniques in Perl. The author [offers the PDF](http://hop.perl.plover.com/#free) for free online. Damian Conway says of the book, &gt; It raids the deepest vaults and highest towers of Computer Science, and transforms the many arcane treasures it finds—recursion, iterators, filters, memoization, partitioning, numerical methods, higher-order functions, currying, cutsorting, grammar-based parsing, lazy evaluation, and constraint programming—into powerful and practical tools for real-world programming tasks: file system interactions, HTML processing, database access, web spidering, typesetting, mail processing, home finance, text outlining, and diagram generation.
Perl is useful in lots of companies. It's good to learn. But more than that, Perl is "cool", in a vinyl records, Pabst Blue Ribbon, pour-over coffee, Etsy sort of way. It's so uncool that it is cool. It allows great flexibility in expression. It runs on almost all platforms. I dig Perl. 
For that, I'd probably actually suggest - rather than a programming language book - that [The Practice of System and Network Administration](https://www.amazon.co.uk/Practice-System-Network-Administration-3rd/dp/0321919165/ref=sr_1_2?ie=UTF8&amp;qid=1471368472&amp;sr=8-2&amp;keywords=practice+system+and+network+administration) is worth your time. It's not _specifically_ a perl book, but rather one that covers ... well, Systems admin. And that's a place where perl is one of the more useful tools you have available. 
Ah, fair critique. I think in my head I was trying to answer "negative opinions on learning perl in 2016" rather than "I read Learning Perl... I feel like I need to read one more book". :)
Def on the advanced side, but really cool nonetheless.
&gt; as a friend of mine puts it, PHP is Perl without the elegance and consistency. I was actually thinking along similar lines this morning when I saw [this thread](https://www.reddit.com/r/webdev/comments/57d1pr/slack_on_taking_php_seriously/) pop up over on /r/webdev. You can do a `s/PHP/Perl/g` on that article and it will remain about 95% accurate. Perl is an amazing language. Sure, it has its warts like anything that's stood the test of time, but it is honestly fantastic to work with every day.
It's also insanely useful if you're dealing with linux, to complement bash and do stuff relatively painlessly that would otherwise be a huge pain in the ass using more "fashionable" languages.
&gt; Perl is a language that gives you a lot of power and flexibility. If it had one weak spot, it would be that it lets a lazy coder write bad code, and for it to generally 'just work'. I agree. Because one of the design goals seems to be "do what you think the programmer means, by magic if necessary", it's very easy for newbies to just make shit work and pick up bad habits along the way and write absolutely horrid code in the process. I was responsible for buckets of it back in the 90s. But I got better over time as I learned more and picked up better habits. Also, anyone who's been around enterprise Java knows that you can write shit code in any language. 
It's good, but these days you need to take it with a healthy grain of salt. Many of the PBPs are out of date now.
I think "Beginning Perl" by Curtis Poe is preferable to "Intermediate Perl." It covers a vast array of topics, for one thing.
I always thought PHP's prominence relative to perl was simpler apache integration. mod_perl required a sysadmin to be very knowledgeable about her/his system and the apache server while mod_php was easy and limited. In an amusing historical twist, many webhosts that started in the early oughts are running on perl based backends.
I own and have read bits of both. The former (maybe an older version) is available on the Perl.org website for free. The database access chapter on the DBI module is simple and clear. Ovid's (Curtis Poe's pseudonym) book is also really good and the last Perl book I bought. He goes over all the "modern perl" stuff like Moose, Catalyst...etc. It's also really good from a software engineering perspective as it is very much oriented on the practical aspects of using Perl to do work and make $. Ovid has a lot of experience as a consultant and is releasing a text-based SciFi MMO soon that I'm eagerly anticipating. Learning Perl is ok and good for beginners. 
I did a little playing with this awhile back. For large case-sets, it might be worthwhile to use a hash with the case-match as key and the condition's responding code as referenced value. That pushes the sequential-tries operation of a switch/case down into the bytecode level (and reduces the try-size to hashkey-size), getting close to the jump-table operation of C's switch/case (but without the fallthroughs). While it's quicker to run than repeated if/elsifs, it's by no means quicker to set up, so IMO it's best reserved for code that's called a lot, like a keybinding [e: or state-table] dispatch.
The `DBIx::` namespace is used for just about anything that builds on `DBI`. The problematic area is just `DBIx::Class::*`: there is some dispute about future direction but the current version is probably okay. I don't use it myself but there do seem to be a fair number of happy users of the existing codebase. So, to pick a random example, other modules such as [DBIx::Simple](https://metacpan.org/pod/DBIx::Simple) are not part of this exciting drama.
I think you listened too much to the people over at /r/learnprogramming that scream Python at anyone asking for advice on *anything* and the people over at /r/webdev only concerned with their JavaScript flavour of the day. 
Right, the problem of distribution has had some solutions, but from what I have seen, none that have kept up with modern tech or made it easy enough so that any developer can do it. That's why I'm focusing on getting that right for application that I've been writing, Curie, a document reader. I think I mentioned it in `#pdl` before. I released a version a few weeks ago to make sure that it works with CPAN and made a video here &lt;http://project-renard.github.io/blog/posts/2016/09/22/curie-release-v0.001/&gt;. I've currently got it working with an MSI installer on Windows and now I'm figuring out the process to make Mac .app bundles.
Web apps also benefit from easier deployments. Every client will grab a fresh copy of your scripts for you (at least the .js bits) every time the scripts are updated. There's no need to deploy to every seat in your organization, just deploy out to your server and you're set.
&gt; Of course Perl 5 can be parsed, the Perl 5 compiler does it all the time. People get hung up [...] and claim that it can't be done Well, to be fair, the usual claim (oft repeated by core Perl developers) is that "only perl can parse Perl". There are many reasons for this: 1. There is no formal specification of the Perl 5 language, so every bug, feature, convolution and legacy in the Perl 5 implementation *is the canonical language*. 2. There are many cases where the semantic content of a statement changes during parsing (due, for example, to a prototype definition). 3. The subtle interaction between regexes and the surrounding code is not always obvious. 4. There are many places that the language "guesses" the correct interpretation of code from ambiguous options. ... 
A Perl version of phpdesktop might work for you. https://github.com/cztomczak/phpdesktop 
Distribution to Windows environments can be partially solved by using [PAR](https://metacpan.org/pod/PAR) to generate executables with the perl interpreter built in. But I think the bigger problem is the limited options for graphical libraries: Wx, Tk, Gtk, and they all have their problems, so I hear. More people are familiar with the technologies needed to develop web applications, plus they are easier to deploy "portably".
Everything has to devolve over time. It's just entropy. Of course the most superior language yet invented, Perl, is being increasingly ignored by the ignorant buffoons out there that don't know its awesomeness.
Apple has the only platform where Objective C is a first class language. If they push Swift instead, and their dev community doesn't revolt against it, then yeah, Objective C will probably be killed off.
How is "old Apple language will be killed off by new Apple language" a sell-out to Apple?
He did state dying, but he was mostly referencing how it's niche has and is shrinking. Although he did state that he likes the language, so he understands it's strengths and weaknesses.
Rather than restate my comments here, I will just link to the comments on /r/programming when this video posted almost a year ago. https://www.reddit.com/r/programming/comments/3uindg/
I wrote a few scripts for an independent research course in college using Perl with no previous coding experience. I'm still pretty sure it's magic. Also, worked in a linux VM on my pc, worked on a friend's VM, but ultimately not my professors mac. Magic. 
Data:: Dumper that hash to see if it contains what you think? I would imagine (without testing it) that your problem is in assigning an empty list to the hash slice. But something like my %is_valid = map { $_ =&gt; 1 } @validFiles; Would work a bit better. Either that, or it isn't literally "LEMONS" and you might need to regex or chomp your input. I would also suggest that using substr to extract filenames is not a good idea - using a regular expression may be less brittle. Not that you actually use $file at any point though, so I am guessing a bit.
I don't think @hash{@validFiles} = (); is doing what you want it to do. I think something like: my %hash = map {' a thing '} @validFiles; might be more what you want.
&gt; Of course, it would be manifestly stupid to write something in a BEGIN block that would affect later parsing in ways that cannot be predicted short of running it for an arbitrary length of time. Look up the definition of "use". You basically just gave it, there. 
OP is checking if the key `exists` so it doesn't matter that he's assigning an empty list.
It only takes one nice module/framework/usage of a language at just the right time to revitalize it. This is true of Rails, and Angular and Perl has the same chance for it to occur in the future.
Yeah I stripped the real names for this example. The while loop would actually use those file names that I'm traversing, but I hardcoded the string for a test. Yet it doesn't work. 
The substring is because I know what the file names are. They always have that many characters that I need to throw away. Basically I'm searching to validate that ten specific files exist, and if they don't, I'll stop the script. 
Great video from one of the pioneers. Just want to say he mentioned perl6 not perl5. No disrespect to Larry Wall but, really?
That's why it seems odd. I would suspect that normally you want to truncate files to, say, the first 8 characters. But instead you are truncating based on a file length minus a hardcoded value. Based on your calculations... 'ThisLongFileName' becomes 'Thi' 'ThisFile' also becomes 'Thi' 'ThisLongFile' becomes 'ThisLongFil' Which just seems really odd and unintuitive. Ultimately we are just guessing at things until you show us a dump of `%hash` and the full output of your program.
&gt; There are a lot of useful modules ... Let's be clear, I'm not arguing that use is a bad thing at all. It's a wonderful way to handle library imports at "compile time" (not that that has a clear definition in most dynamic languages, much less Perl). But it's clearly a case where syntax can change radically mid-parse, and absolutely does. &gt; ... if one had a module that could potentially run arbitrarily long, and that could affect later parsing One word: Moose. Worse: PDL. Moose has more radical impact on syntax, but both are non-trivial to determine halting for (PDL involves C and Fortran externalities). &gt; But it's not worth giving up on the language over it. Well, that depends on what you mean by giving up. I moved to Perl 6 a while ago, but I'll always have a soft spot in my heart for Perl 5. 
Perl is like people that fake their death so the IRS doesn't find them.. but instead of IRS he is hiding from PHP developers.
Mac filesystems are not case-sensitive, so it's possible less magic was involved than you think.
I will say, having used both Perl and Ruby extensively, that any longevity issues on Ruby's part are by no means the fault of the language itself. Rather, the issues will likely be a result of its ecosystem's dependence on Rails, which is already showing its age.
Perl has [print](http://perldoc.perl.org/functions/print.html), [join](http://perldoc.perl.org/functions/join.html), [ord](http://perldoc.perl.org/functions/ord.html) and [chr](http://perldoc.perl.org/functions/chr.html) functions that are very much like the Python versions. You will find documentation for `if` and `for` in [perldoc perlsyn](http://perldoc.perl.org/perlsyn.html) and various I/O operators in [perldoc perlop](http://perldoc.perl.org/perlop.html). I can't see the Perl version being very different from the Python one.
I did some code that worked but it was really big and hacky . I want something that is the same size or smaller than that python code . I know it seems silly 
https://github.com/ddmitov/perl-executing-browser (Reminded again about this project by a recent blog post: http://blogs.perl.org/users/ddmitov/2016/10/perl-executing-browser-version-03.html ) PEB is "minimalistic HTML GUI for Perl desktop applications similar to Electron and NW.js."
I think Prima is worth mentioning here. You can find it on CPAN.
I think you could get away with running perl -pe 'uc; tr/ABCDEFGHIJKLMNOPQRSTUVWXYZ/CDEFGHIJKLMNOPQRSTUVWXYZAB/;' 
There's this open source project that uses Ethereum through pipe if I'm not mistaken. https://github.com/AppCivico/votolegal-api
&gt; perl -pe 'uc; tr/ABCDEFGHIJKLMNOPQRSTUVWXYZ/CDEFGHIJKLMNOPQRSTUVWXYZAB/;' Doesn't work for me because uc needs to assign to $_. Also why not use character ranges to be a bit more clear: `perl -pe '$_ = uc; tr/A-Z/C-ZAB/;'`
You need [Encode](http://p3rl.org/Encode) and its encode/decode. Also, including the variable $customer directly in the $query seems insecure, what about using a placeholder?
&gt; Are you using mysql_enable_utf8 when you connect to the database? No &gt; What is the character encoding in your template file? I added the following packages: * \usepackage[utf8]{inputenc} * \usepackage[T1]{fontenc} &gt; Does Text::Template have support for utf8? Yes, it works if I manually tell Text::Template to fill_in a variable with utf8 characters. 
IUP is also another simple GUI library with Perl bindings.
Use `file yourtemplate.tex` to verify the encoding of the file itself. 
A few nitpicks... &gt; The 6th edition covered Perl up to version 5.14, but with the current release on 5.26, 5.14 sounds like antiquated history. The book, though, covers up to 5.24, so not exactly cutting edge, but still a very recent update. A quick glance at perl.org would tell you that the current version is `5.24`. The next stable release `5.26` won't be out until mid-2017. Also, in an example demonstrating subroutine signatures, the author uses `&amp;max( 137, 48, 7 )`. Most modern perl users do not use the `&amp;` when calling a sub. It mainly used when referring to the sub as a "noun", eg. passing a sub to another function, or creating a reference to it.
Higher Order Perl. You learn more about Perl and about functional programming. It shows you don't necessarily need a fully functional programming language to apply functional programming concepts to your projects.
Calling pdflatex on a template.
&gt; You need Encode and its encode/decode. Not necessarily. Encoding and decoding should be happening automatically during communication with the database.
&gt; &gt; Are you using mysql_enable_utf8 when you connect to the database? &gt; No You should definitely do this; it encodes your queries/parameters to UTF-8, decodes results from UTF-8, and tells mysql to use UTF-8 for transport. It doesn't matter what the charsets of the actual mysql tables/columns are (as long as it is a charset that can store the characters you wish to store). If your DBD::mysql is up to date (&gt;= 4.032), you should actually use mysql_enable_utf8mb4 instead as the default utf8 charset in mysql only handles up to 3-byte UTF-8 encodings. Regarding "utf8 characters", this is sort of a contradiction. UTF-8 is a byte encoding that represents characters indirectly. You should generally be working with unencoded characters, and encode them to UTF-8 when you output to a file or terminal. Note that if you enter high bit characters into your source code directly, you should include the "use utf8;" pragma so that Perl knows to decode the source code from UTF-8.
The extra &amp; is mostly just visual noise - if you prefer to use it and are aware of the differences mentioned downthread, it's harmless enough. There's an argument for symmetry with variable sigils, and a counter-argument of "argh no what is this, perl4? please make it stop". A couple of examples where I'd suggest the &amp; prefix can make the code harder to understand for a casual maintainer: print $fh &amp;mysub $whatever; or defined &amp;mysub($x) 
As with any sigil there are good and valid reasons to want it. For example, when it conflicts with a bareword. But there aren't *as many* good reasons (and some reasons not to) with functions. In general, I suggest using it when needed and otherwise leaving it off. 
He mentions both throughout the talk. On P6 he said (paraphrasing slightly because I don't want to go back and memorize the line) "what about Perl 6? I think it's fair to say that Perl is dead or is never going to happen. It sort of missed a boat. Permanently? I don't know." Just note, however, this talk was from 2015, before Perl 6 was officially released. Today, he might have something different to say or he might take the position that until it's clearly useful for routine work, Perl 6 hasn't yet arrived. We'll see in the next year or so whether or not that time comes. 
I feel like the program you describe would still be very doable as a webapp driven from e.g. a Mojolicious webserver (https://metacpan.org/pod/Mojolicious::Guides::Tutorial#File-uploads), using https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API for the frontend part.
&gt; don't come up with arbitrary restrictions to prevent bad things That's a good rule, if only Nim would abide by it and not impose the significant whispace thing, which is a showstopper on it's own, for many. Otherwise, nice language, nice tricks, informative read.
Must be mentioned that this is *not* usually how you do scraping with Perl, if you care for either speed or aestetics. I'd personally go first for either Web::Scraper (with a libxml2 backend), or something backed by a decent event loop, either Mojolicious, or something manual backed by AnyEvent (xpath/css selectors plus an useragent is enough). For keeping it extra simple, but speedy, a simple LWP + Parallel::ForkManager + some selectors would also suffice.
In addition to what was said here, i strongly dislike the expectations here. This is not *crazy things* that happen out of the blue. **Whatever** the language, be it C++ or Python or Go or JavaScript and so on and so forth, you **will** encounter *crazy things* unless you actually learn and understand the language. When I read the code posted there I found nothing surprising. Not only you treated a scalar as a hash reference, but the scalar was undef, and you dereferenced it looking for something. Perl obliged. You *must* know what happened, otherwise, sure, kaboom. See *exists*, *defined* and *autovivification*, *coercion*, *references*, etc, etc, you know, actually learn the language. ;)
That sounds interesting, care to elaborate a little on how this would work? Thanks!
I have used a number of config file formats and I usually return to having the config file being perl code particularly if it's a configuration file for an internal project. More discussion in the [Perl Cookbook](http://docstore.mik.ua/orelly/perl/cookbook/ch08_17.htm) 
The most common approach is probably to run your web app as a persistent daemon on the server and use a proxy server to route requests to the daemon. Gabor's article [Getting started with Perl Dancer on Digital Ocean](http://perlmaven.com/getting-started-with-perl-dancer-on-digital-ocean) has plenty of good advice on getting that set up. As the title suggests, it's Dancer-centric, but most of it will apply no matter what PSGI technology you're using. You can actually run PSGI apps as CGI programs. It's really not recommended as you lose all the advantages of a persistent process. But see my [Easy PSGI](http://perlhacks.com/2016/01/easy-psgi/) article for details.
I've had good experiences using the Starman webserver with NGINX as a proxy. There's an explanation of the stack here http://stackoverflow.com/questions/12127566/an-explanation-of-the-nginx-starman-dancer-web-stack which looks pretty good (though I can't vouch for accuracy of the example snippets)
Indeed the packaging is not fun for Windows. I'm maintaining a hobby image viewer written in perl, yet another image viewer of thousands available, for the sole reason that I can hack on it and on imaging algorithms. I choose to host it as a single script file of 3Kloc, because even a single .pm would require at least Makefile.PL, and probably even more for windows. With a single script, it is working out of the box. https://github.com/dk/fotofix
There may be more FOSS desktop applications written in Perl, but they may not be so well known to the large public. As an example, I'm the author of a FOSS desktop application written in Perl, called "youtube-viewer" (https://github.com/trizen/youtube-viewer). I started the project back in 2010 and its main aim is to search and stream videos from YouTube in a native player, such as VLC, MPV or MPlayer. It comes with two user-interfaces: command-line and graphical with Gtk2. Although this is not the only FOSS application I worked on, it seems to be the most successful one. The list continues with Sidef, a modern programming language implemented in Perl (https://github.com/trizen/sidef) and some other projects which are aimed to a restricted group of people, such as "obmenu-generator" (a menu generator for the Openbox window manager) and "menutray" (an application menu in the system-tray).
Mojolicious: [The future is now.](http://mojolicious.org/). Catalyst and Dancer are good alternatives, but Mojo is lighter-weight and seems far more up-to-date.
I usually use uwsgi with the psgi plugin in my setups: http://packages.ubuntu.com/precise/uwsgi-plugin-psgi I then proxy to that with NGINX as others have mentioned.
I'm not surprised. I have had no problems finding very lucrative work as a full-time Perl developer. 
And the people writing perl are grey haired experts who have been around long enough to demand a hefty salary.
That's not fair, my hair is much more missing than gray.
[Here this helps] (https://www.youtube.com/watch?v=AD-E2B5GfI8)
Isn't that just programming in general?
Sure. Except when you're a Linux admin. Then you're expected to code in Perl like a pro with no added money. Not that I'm bitter. 
I'm pretty neutral. I've done some work in Perl, but only for an operating systems course to write my own basic shell.
Well I'm clearly working for the wrong company only get half.
actually if you can avoid mod_proxy do so. It has caused me various weird problems. Nginx is a better reverse proxy
Do you work in an expensive or cheap city? The median income is ~40k where I live, so $100k is princely and would allow you to buy a nice house (new starter home is ~140k with a 1/2 acre).
Thanks, will check out.
Depends. What does main return?
typically 0. die will do the exit.
Yes, I was thinking to build a hash of the commands as well but I wanted to make sure it worked first before I moved forward. How would the hash look for for the commands value? 
But, Puppet doesn't use Perl.
When I change the single quote to double, I get all kinds of errors from perl. The script won't execute.
yes! that worked! thank you!
i had inexplicable sighups. Friends have had problems with weird memory paging issues. 
How are you storing them? Do you have a literal `\r` at the end of your lines? user@host $ cat heredoc.pl print &lt;&lt;EOF this is\r a heredoc\r EOF user@host $ perl heredoc.pl | cat -vet this is^M$ a heredoc^M$
Guessing you might be on Windows? In Perl strings, when you use \n, that is a logical newline. Newlines in text files are platform specific, so it differs between Windows (CR + LF) and Unix (LF) for instance. If you're on Windows and have a file with Windows newlines (i.e. CR + LF), and you open the file in text mode (default in Perl), CR+LF will be combined into a \n. I bet Perl opens its own source files like that. If you then print to a file handle in text mode (like STDOUT), \n will be similarly translated. If you want to deal with a file handle as raw data, see "perldoc -f binmode". Read more: http://www.perlmonks.org/?node_id=890769 What platform are you on, and what newlines does the file have?
p.s., it's "Carriage return" (as in, the carriage in a typewriter that holds the platen)
linux, want to store a binary file, to write it again, and o lose the Carriage return
I did the WICS converter for my first job out of college (https://github.com/renatb/ITS2.0-WICS-converter). It was required that it be runnable on Windows as a GUI from a single executable file. I used WX and PAR::Packer with Wx::Perl::Packager. Since I used XML::LibXML I also had to track down the LibXML dll and add it to the package manually. It was a pain. I wrote about it here: http://garfieldnate.github.io/blog/2013/08/27/packaging-xmllibxml-with-par-packer-on/ Just writing the GUI code was not that easy, either.
Did you colleague chose Perl for it own comfort or was it required by spec ?
Somewhat both. For we are, at least as far as we know, the only company that uses Perl in the country. So most of the Perl Mongers of the country are working here.
Another trick which I recently discovered (after looking at a benchmark script written by [MJGARDNER](https://metacpan.org/author/MJGARDNER)) is that you can use `undef` as the filename in the 3-argument `open`: open my $fh, "&gt;", undef; this creates an anonymous temporary file. This alleviates the need to use [File::Temp](https://metacpan.org/pod/File::Temp).
Interesting. The docs make it sound like the open mode must be `+&gt;`. As a special case the three-argument form with a read/write mode and the third argument being L&lt;C&lt;undef&gt;|/undef EXPR&gt;: open(my $tmp, "+&gt;", undef) or die ... opens a filehandle to an anonymous temporary file. 
Doesn't seem to be so though. Even `"&lt;"` works (with no errors/warnings from perl). But the file is always opened using `O_RDRW|O_CREAT|O_EXCL`. % strace perl -E'open my $fh, "&lt;", undef or die; sleep 100' ... open("/tmp/PerlIO_t79shi", O_RDWR|O_CREAT|O_EXCL, 0600) = 3 
I sent a message to p5p pointing out this discrepancy, suggesting that maybe it should say the mode doesn't matter.
Installed and it runs. I get exactly the same output as before. No new information. Does it get logged to a file?
I generally recommend against using LWP::Simple in particular because it is impossible to implement error checking (unlike what your error checking suggests, `$!` is not actually used), and it's impossible to change the default 3 minute (!) connection timeout of LWP::UserAgent. Using LWP::UserAgent itself is nearly as simple and lets you do these things.
 BEGIN { no warnings; $main::Log_Level = 'TRACE' } Sorry, instead of the above line, try this instead: BEGIN { $ENV{TRACE} = 1 } The log should go to terminal, in dark yellow/brown color.
If you're using Centos' own RPMs for your CPAN modules then this might be useful - [How to get the rpm packages update history](https://access.redhat.com/solutions/59698). Also, you'll have learned a valuable lesson about separating your app's dependencies from the system Perl libraries :-/
&gt; Perl Best Practices are no longer considered "best practices"; I agree. Some of them (even in other languages) are not the best.
I'll be implementing this. Thanks!
Thanks! Now I get this: Patching format_request ... Patching simple_request ... Patching simple_request ... This is libwww-perl-6.13 HTTP request body (len=0): HTTP response header: 500 Can't connect to www.google.com:443 (Crypt-SSLeay can't verify hostnames) Content-Type: text/plain Client-Date: Wed, 26 Oct 2016 17:54:19 GMT Client-Warning: Internal response Can't connect to www.google.com:443 (Crypt-SSLeay can't verify hostnames) Net::SSL from Crypt-SSLeay can't verify hostnames; either install IO::Socket::SSL or turn off verification by setting the PERL_LWP_SSL_VERIFY_HOSTNAME environment variable to 0 at /usr/local/share/perl5/LWP/Protocol/http.pm line 47. Error: (https://www.google.com) at ./lwp.pl line 18. I list the output here in case someone can tell me the easy fix. Thanks! :)
Also: I tried to install IO::Socket::SSL using CPAN shell. It gives errors and refuses to make. I tried adding "$ENV{'PERL_LWP_SSL_VERIFY_HOSTNAME'} = 0;" near the top of my script and it doesn't change anything. Thanks! 
Yes, lesson learned. I've since learned that our CentOS server was scheduled for something described as "Linux patching" last night. I am convinced that is the cause. Something was deprecated and/or strengthened. I just need to know how to adapt.
Maybe check for expired certificates....
yeah LWP::Simple is fine for simple trivial stuff. Until something goes wrong after which its useless. My experiences have lead to me deciding not to use it at all.
Looks like your certificate was recently updated. Do you know use a SAN for this domain?
[Do you need Crypt::SSLeay](https://metacpan.org/pod/Crypt::SSLeay#DO-YOU-NEED-Crypt::SSLeay) &gt; Starting with version 6.02 of LWP, https support was unbundled into `LWP::Protocol::https`. This module specifies as one of its prerequisites `IO::Socket::SSL` which is automatically used by `LWP::UserAgent` unless this preference is overridden separately. `IO::Socket::SSL` is a more complete implementation, and, crucially, it allows hostname verification. ... &gt; If are using version LWP 6.02 or later, and therefore have installed `LWP::Protocol::https` and its dependencies, and do not explicitly use `Net::SSL` before loading `LWP::UserAgent`, or override the default socket class, you are probably using `IO::Socket::SSL` and do not really need `Crypt::SSLeay`. That is, just installing `LWP::Protocol::https` should have pulled in `Net::SSLeay` and `IO::Socket::SSL` and your code should have been using those ***unless*** you had overridden that in your source code. `Crypt::SSLeay` also specifies a dependency on `LWP::Protocol::https`: That is, simply by installing `Crypt::SSLeay` along with its dependency chain, you are assured of *not* using it unless you take special care to override its use.
He has a write up on the blog concerning his teams' stack. Basically Perl using Moose and Catalyst (I think) connected to a Postgres DB running all the heavy lifting. JavaScript is used on the front end. If you read in the post (and I recall his Perl book as well) they use Perl because speed of the language isn't a factor when your DB is the bottleneck. All in all a pretty cool looking project that I'm stupid excited about and if I was a millionaire I'd like to work on for free. For those that have never played a modern text game, they can be very rewarding and are generally far more advanced today than what you had with Zork in the 80's.
https://www.reddit.com/r/perl/comments/593zy8/9_tech_skills_that_pay_over_120000_and_are_in/
Ditto. I had no idea either. Still learning I guess.
Regarding Acme::Damn: I've had to unbless references once or twice before. I don't know why Perl doesn't come with the `unbless()` builtin. I can understand the reasoning against making untainting more convenient, but unbless? 
 sub format_date { my @dates = @_; for my $next_date ( @dates ){ if( $next_date =~ m/^(\d{2}).(\d{2}).(\d{2})(\s)(\d{2}).(\d{2}).(\d{2})$/){ # .... print "your stuff"; } } 
&gt; I understand that the array is being passed into the subroutine as "25.10.16 23.13.34 26.10.16 20.04.44" in one line, right? That's not right. Your array (with two elements) is copied into `@_` (which also has two elements). Your problem is when you try to do `@_ =~ m/.../`. The binding operator (`=~`) expects a string on its left hand side. You're giving it an array. Perl tries to do its best. It evaluates the array as a scalar - which gives you the number of element in the array. But it also gives you a (to my mind, pretty clear) warning about what it is doing. But it's just a warning, Perl will carry on and try to do the matching on the scalar value of `@array` (i.e. 2). That will fail and therefore `@_` is unchanged. Oh, and you get another error too, don't you? It also says: &gt; main::format_date() called too early to check prototype Best to drop the prototype (the `()` after the subroutine name). Prototypes have a very limited use and should generally not be used. There were a few other problems. You match dots in your regex with `.` (a dot actually matches any character). You print the result rather than returning it - so your original `print()` call doesn't get anything useful to print. What you actually want is something like: sub format_date { # Copy input to local variable my @dates = @_; foreach (@dates) { # If the input is formatted correctly as a date if (/^\d{2}\.\d{2}\.\d{2} \d{2}\.\d{2}\.\d{2}$/) { # Split string into date and time my ($date, $time) = split; # Replace all dots in $time with colons $time =~ s/\./:/g; $_ = "$date $time"; } } # Return the transformed data return @dates; }
Others have answered the original question pretty well regarding your use of the subroutine prototype and context, etc. But this is /r/perl so in the spirit of TMTOWTDI, I'll give you another solution: my @input = ("25.10.16 23.13.34","26.10.16 20.04.44"); print "\n$_\n" for map { s/\.(?=[^\s]+$)/:/gr } @input; That changes any '.' to ':' as long as a whitespace character does not follow it at some point in the string. The /r modifier to the substitution regex causes a copy to be returned instead of modifying the original which avoids having to modify @input or declare a temporary variable. Another interesting way to do this might be to use the special variable $' Admittedly this is just Perl golf and probably not something that someone who is learning would really ever need to understand.
Most people already helped. But some may be missing what he wants to do here. He doesn't wants to replace all .'s for :'s , just the ones for the time. The way I read the data, each element of array is like this: day.month.year space hour.minute.second So he just want to replace the 3 last .'s , the ones for the time. There are of course several ways to do this, for using neilhwatson example, and the code the OP already has, after the if for $next_date: $next_date= $1. '.' .$2 . '.' . $3 . ' ' . $5 . ':' .$6 . ':' . $7; print "\n$next_date\n"; Didn't test it, but something like that should work. 
yeah exporter would work but I wanted to export everything withouth having to think about it at all in no lines of code. And I wanted to flag the code as "I have not thought about the optimal design for this yet, and may not need to". I should really re-do the article to make it clearer: sub involved_workflow_part_1 { # do stuff } sub involved_workflow_part_2 { # do more stuff } Then in the test 1: involved_workflow_part_1(); involved_workflow_part_2(); And in another test: involved_workflow_part_1(); # do stuff to mangle the results involved_workflow_part_2();
I wish there was something like this for golang and Perl
The problem would fortunately be simplified a lot by only exporting subroutines, which is the usual practice in Perl5 anyway.
I would imagine Amazon SDE 2 starting salaries being over $120k, them hiring tens of thousands of new SDEs per year, and a majority of the retail tech being in Perl is the sole reason for this.
I'm not sure it is racist. Black dudes look bad ass with the shaved head minus the goatee. The video is telling them they only have to do one step.
I think that building Perl desktop applications needs to solve at least three major problems: 1. Finding an easy GUI. One can hardly say that Tk, Gtk and Qt Perl bindings are the easiest and fastest to learn. The tools we have to produce a GUI based on these bindings are quite few. So I think the best GUI for a Perl desktop application is HTML rendered in a customized browser like [Electron](http://electron.atom.io/), [NW.js](http://nwjs.io/) or [PEB](https://github.com/ddmitov/perl-executing-browser), which I started three years ago (already mentioned by perlancar). We all know that the tools and libraries one can use to produce a good-looking HTML are many. Even a Perl beginner is usually able to make an usable HTML in a short time, which is not the case with Tk, Gtk or Qt Perl bindings. 2. Finding a simple and reliable communication between the GUI and the functional part of the application. Complicated APIs should be avoided - they make the learning curve steeper and push back new developers, especially when pressing deadlines are ahead. The simplest solutions I know are: 2.1. using RPC interface to [Electron](http://electron.atom.io/) like in [Valence](https://github.com/hoytech/valence), 2.2. calls to a pseudo-domain resolved inside a customized browser like in PEB or 2.3. calling Perl scripts using Node.js functions inside [Electron](http://electron.atom.io/) or [NW.js](http://nwjs.io/) like in [CamelHarness.js](https://github.com/ddmitov/camel-harness). Well known web standards are put to good desktop use in this way. 3. Packing everything when application is ready. I still don't know a Perl dependency analyzer capable of finding all binary dependencies of an XS module. As garfieldnate says, it is a pain. I also had to track manually all dependencies of LibXML for a previous version of [Epigraphista](https://github.com/ddmitov/epigraphista). But that being said, I have a very positive experience with [Strawberry Perl Portable](http://strawberryperl.com/releases.html) combined with [Electron](http://electron.atom.io/) or PEB for the GUI part. The problem is that without tracking down the dependencies and removing everything not needed, you still have several thousand portable Perl files distributed with your application.
I'm still new to perl myself, but I've gotten into the habit of using prototypes frequently, especially when passing references of arrays and hashes to subroutines. Is this bad practice? Usually it'll be something like this: sub compareHashes (\%\%) { ... }
Yep, better to use `grep` or List::Util's `any`.
Statistically speaking, everyone is a newbie.
ahh I see. This is one of the older languages that we learn in class but towards the end we do use newer languages and framework.
400 samples is hardly statically significant.
Could you please elaborate a little?
This does not tell much of a picture. We need more information to be relevant. How many new programmers per year are there. How many programmers drop off per year? Is the number of new perl devs above or below the average of new programmers/devs? These numbers don't mean much at all without context.
It's not 400 samples. That's the size of the sample. And on top of that, it's impossible to determine the margin of error knowing only the sample size. While I agree that 400 people aren't going to be representative of the entire population in this case, I feel like you don't completely understand what it is that you're implying.
Hey! Thanks for sharing, original poster guy on blogs.perl.org. It's helpful seeing how other people approach these problems.
How many would we need to be significant? Sorry, stats newbie here.
What you just said is what's wrong with almost all Perl code in bioinformatics. Assuming I have ~40GB of RAM and writing your code lazily for efficency isnt a better plan. It's bad programming, if others are to use your source. Using more threads on IO of a single file should never matter unless you have something with high availability. A single disk or ssd many threads should reduce performance with serial read being often 2-4x as fast. Your code might work well on a lustre filesystem in an HPC environment, but Ken's will work well enough on a raspberry pi or a super computer. Its also maintainable. If I wanted to add more functionality such as reduce the quality string for better compression characteristics, I could add a single line. There is also a class to hang the method off of rather than just sticking it somewhere randomly. My first optimisation might be threading, but that would be to split up IO from parsing, so the disk is always being read with large chunks from each file rather than swap constantly or wait.
The syntax `{ ... }` can be ambiguous between a block or a hashref. The perl parser tries to figure it out based on context and the first thing it sees inside. The preceding + is one way to force the parser to consider it as a hashref. `{; ... }` is a way to force it to be a block. In both these cases, it's no longer ambiguous.
no, that is one of the cases that is ambiguous. Without a leading + that will be parsed as a block which returns @_ (the arguments passed into foo).
ok, so it's just to ensure that $config, no matter what, ends up as a hashref. thank you for the help.
[Image](http://imgs.xkcd.com/comics/lisp.jpg) [Mobile](https://m.xkcd.com/224/) **Title:** Lisp **Title-text:** We lost the documentation on quantum mechanics\. You'll have to decode the regexes yourself\. [Comic Explanation](https://www.explainxkcd.com/wiki/index.php/224#Explanation) **Stats:** This comic has been referenced 118 times, representing 0.0882% of referenced xkcds. --- ^[xkcd.com](https://www.xkcd.com) ^| ^[xkcd sub](https://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](https://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](https://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_d9kiukl)
I have been working on building a development system and I needed to rekindle my bash knowledge because Perl is not available until later in the build. Many distros use bash for startup, install, and build scripts. So much easier to just use Perl.
scripts that have not changed at all in literally years, they still work and do what they have to.
I didn't write this old stuff. In time these systems will be decommissioned when they're no longer needed. We're working with mojolicious now, the future looks bright
The short version is, this plugin can delegate to your scripts, thus wrapping old working cgi scripts into your new mojo app (for ease of porting incrementally). https://metacpan.org/pod/Mojolicious::Plugin::CGI
Sorry about the video/sound quality, also it was somewhat improvised as i wasn't planning to give it at LPW last year but it ended up on the schedule. You can access the talks here: https://leejo.github.io/code/ # also the source for the talks can be found in the links to github. I'm at home at the moment, but i can paste a couple of examples of proxying through to mojolicious with Apache when i arrive at work tomorrow. From memory the linked examples in the wiki look correct. Edit: checked the wiki against our config and it looks correct.
From this discussion (and many others) I think the main point is the bad name that many people assign to Perl. Many of the arguments come from people that say that they left Perl long before "Modern Perl" even existed. It is difficult to find any of them that have tried current web or OOP frameworks. So they think that Perl6 is just a new iteration of that old language from the nineties, but with a new weird syntax. I think someone was spot on when said that the language could be named differently ("rakudo" was proposed, even though we know it is just the name of the VM). People tend to like trying new languages (Go is mentioned many times), and it is worrying that they are avoiding this bleeding-edge one just because its name. 
I thought the new grammars and regexs looked pretty interesting. I tried toy searches where I'd write them badly, then improve my implementations. These were the kind of operations that might take a minute written badly and only a second or two once it was specified more efficiently. Instead my badly written code took over ten minutes to run. So, I decided to wait six months for the implementation to work a little better on badly written code before giving it more attention — but never got around to it.
In some ways if the name is all that keeps people away or from even taking a cursory look at some examples, they are also unlikely to contribute a great deal. I hate PHP but when Hack was announced I took a good look at it. I also didn't go around looking for posts about Hack to just slam it because of what PHP was like between 4.2 and 4.4 (which was a nightmare FYI) when referencing changed in function signatures.
What about a library?
You can get a used copy in very good condition from Amazon for about $6, including shipping. Better than stealing.
Interesting to know. Is it stressful living in an apartment long-term and being at the mercy of a land-lord to fix things? I've always wondered this. I do envy you if you can walk out of your building and do things without 20-30 minutes of driving and looking for a parking spot :)
It's more stressful for the landlords because you can withhold rent if they don't fix essential things and they have to worry about tenants destroying the place, not paying rent, etc. Plus I can leave if neighbors piss me off but owners are stuck. I do have a great spot with all the services within a couple of blocks and I just got back from a walk down to the water so it's pretty sweet. Most places outside of cities don't have parking problems though so I envy that. I pay an extra $150/mo for one of the few indoor parking spots and am very lucky to have it. Half of the other tenants in the building have to hunt for street parking.
&gt; "rakudo" was proposed, even though we know it is just the name of the VM 'Rakudo' is the compiler; the VMs are MoarVM, the JVM (to a certain extent), and perhaps soon, a JS VM (via rakudo.js).
Okay, here's my thoughts: 1. Performance: someone else mentioned this one, but when you hear about a new language and go try it out, there is little that's more off-putting than slow execution. This is a *hard problem*. Some can be addressed with progressively more passes over the implementation, but some of it... I honestly don't know if you can be THAT dynamic and performant. We'll see. 2. Strangely limiting syntax: For a language with so much syntactic sugar, Perl 6 can sometimes feel strangely restrictive. For example, I can never recall quite what `*` does as the *whatever* operator. Can I `.map: *+2`? Yes. can I `.map: *.sqrt`? Yes. But can I `.map: sqrt(*)`? No, of course not... for... reasons. 3. The lack of an identity: Perl 6 doesn't present the user with a clear identity with which to identify. Python says, "write simple, elegant and readable code above all else." C says, "get as close to the machine as you can." Haskell says, "bathe in the glory that is functional programming." Perl 6 basically just says, "I'll take all of that to go, please." Logically, that's a great point, but in terms of adoption it leaves some enthusiasm on the table. 4. Lack of a coherent library: Perl 6's built in library is in the state that the language was in a year ago or more. Things change rapidly and many features are clearly not quite there yet. It's going to take time for users and advocates to become engaged enough to make it do the things that make sense for them, not for the compiler writers. All of this is expected. It's a huge language and will have many corners to hammer out, but that's a good problem to have. I do love the language, and I think that it will find its user-base eventually. Patience... 
This is unfortunately an ugly implementation, and it has been written in a style that is more suited for Java and in fact would look much prettier if it were actually written in Java. No thanks.
Not a criticism, I just work in a loud environment and wouldn't get peace to hear it. Thanks
The Whatever Star `*` is a term ( in the programming sense, not the english sense ) If it can be parsed as an independant term you get an instance of the Whatever class. This would be the case with `sqrt(*)`. The `sqrt` is parsed as a subroutine call, and the `*` would then be parsed as an argument, an independent expression. So you end up trying to map using the return value of `sqrt(Whatever.new)`, which if it wasn't an error, would be a Num. The reason for the addition of WhateverCode is `@a[ * - 1 ]`, which would have otherwise have to be written as `@a[ -&gt; $elems { $elems - 1 } ]` or `@a[ @a.elems - 1 ]`. If Perl was a more restrictive language, that would be one of the only places this syntax even worked to create a lamba. (actually it probably wouldn't even be a lambda, just special syntax) The Whatever star basically always used for doing Whatever makes sense in context. In the case of `1..*` it means just keep going. In the case of `&amp;example.assuming(*,1)` it says to skip that argument for now, it will come later. ( the `assuming` method gets a Whatever instance as its first argument and it "decides" that means to skip the argument of the function reference it is creating a closure from ) In the case of `@a.pick(*)` it basically means pick all of them ( basically a shuffle ) In the case of `@a.roll(*)` it mean keep making independent selections In the case of `* + 1` add one to Whatever. ( which can only makes sense as a lambda, so that is what it does ) In the case of `*.method` call the method on whatever. ( lambda again ) --- I don't know why you would say it is strangely limiting syntax, when the WhateverCode syntax was only added as a typing shorthand. It's not like it is the only way to write a lambda expression. I mean how many languages allow you to write an `if` statement combined with a lambda syntax both the pointy block lambda syntax if $example.method -&gt; $result { say 'the result was ', $result } and a block with a placeholder parameter if $example.method { say 'the result was ', $^result } What makes Perl 6 different is it *doesn't* try to limit the syntax, and reuses syntax so that you have to remember less syntax overall. --- Perl 6's identity would be "Here is a bunch of useful features to do with as you please, go nuts" --- You seem to think that the built-in library is something like Python's idea of batteries included. It most certainly is not. (that's the impression you gave me anyway) It is a set of features that are universally accepted to be useful, and have a well-known design. Which means something like an HTTP client will probably not be added; ever. 
Thanks, I stand corrected.
So my httpd.conf listes on port 8080. Now I add the modules required for reverse proxy for the mojo stuff, and the following extra/httpd-vhosts.conf &lt;VirtualHost *:8080&gt; ServerName localhost &lt;Proxy *&gt; Order deny,allow Allow from all &lt;/Proxy&gt; ProxyRequests Off ProxyPreserveHost On #ProxyPass /test ws://localhost:3000 ProxyPass /test http://localhost:3000 keepalive=On ProxyPassReverse / http://localhost:3000/ RequestHeader set X-Forwarded-Proto "http" &lt;/VirtualHost&gt; ~~I can now access my mojo app running on http://iphere:8080/test~~ but can no longer access the CGI sites via their URLs, e.g. http://iphere:8080/foosite Regards the mojo stuff - it's not serving css/js files, they're showing up as 404 in the developer console. 
&gt;So you end up trying to map using the return value of `sqrt(Whatever.new)`, which if it wasn't an error, would be a Num. And you think that all of that is obvious to the user?! That `sqrt(*)` is different from `@a[*]`, why? What's the rule the user should remember? &gt;You seem to think that the built-in library is something like Python's idea of batteries included. I'm not even sure what that means, but I do know that there's a lot of inconsistency and missing functionality in the core library. We don't even have a coherent logging system yet. In general, it seems like you're very defensive, here, which is not a great way to ask, "why aren't people interested in my language?" 
Have to say I agree I really dont like the general way this is implemented as the ternaries are all a bit gross and hard to read. However, my criticism wouldn't be to not use enums but instead to use the nice feature of them that you can specify *any* value in Perl6. my enum HorzDir (Left =&gt; -1, Right =&gt; 1); my enum VertDir (Up =&gt; -1, Down =&gt; 1); With that in place and understanding you can stack conditional operations I believe move() becomes something more like the following, which is a lot more readable because of the enum: method move { $!col += $!horz-dir if 1 &lt; $!col &lt; $!cols; $!row += $!vert-dir if 1 &lt; $!row &lt; $.rows; $.reverse-horz-dir if $!col == 2 or $!col == $.cols -1; $.reverse-vert-dir if $!row == 2 or $!row == $.rows -1; } Also horz instead of horiz bit me... why would you do that ;___; Using dx/dy is just a change to the name of the `$!horz-dir` and `$!vert-dir` variable names and not really a massive deal. 
Weirdly I've commented previously on Whatever currying is the main thing that I think is super hard to learn intuitively, without understanding a lot of other stuff. From just a Perl 6 syntax perspective new people might think `*` is like a cleaner easier `$_` placeholder variable-like-thing; rather than understanding semantically it's a general mechanism for constructing and currying closures. The "for reasons" where the reasons involve a lot of arcane computer science and language implementation is not really where modern languages are going. But I think this comes up so infrequently in Perl 6 outside of this feature. It's just a shame it comes up with probably the most powerful cool feature that everyone immediately wants to abuse day1. Given you've now mentioned this a second time do you think there is a relatively simple rule of thumb we can just-so use to explain `*`, and how/why it works some of the time and not the rest of the time? Without using the words currying, closure, or worse "closed monoidal category" which comes up in Wikipedia! :S HyperWhatever and exponentiation are both `**` which gives rise to some fairly grim situations. I'm hard pressed to really fully trace why the following is true, ignoring how hard it is to even understand unless you know the parsers precedence and expectations: &gt; map ** ** 2, 1, 2 ((1) (4)) &gt; map * ** 2, 1, 2 (1, 4) I think the `**` case is slurpy on each element entering the map so coerces it to a list so you get a list of lists. But my expectation was it would be slurpy on the (1,2) and then give (1, 4) like using `*` but in one go. 
I shoved my reply re Whatever up above FYI. My simplest rule the user should remember for Whatever is that you should think "Whatever function goes here" rather than thing or value. I'm not really convinced logging should be put in the core without a tonne of code existing for it in use in the wild. Python and Perl both grew their core taking from the ecosystem. Logging especially has a lot of different requirements that are application specific and there's little point guessing how that will look in Perl 6. Logging for something with loads of supplies and promises might look different to without for example. 
&gt; Given you've now mentioned this a second time do you think there is a relatively simple rule of thumb we can just-so use to explain *, and how/why it works some of the time and not the rest of the time? Well, I generally try to explain it as a placeholder that acts as a sort of arbitrary object and which, in sequences and mappings will auto-curry. But then they run into the problem I mentioned with `.map: sqrt(*)` where they have to know that it only applies to the inner-most expression. It's even worse with this very real example that I tried to use once: my @a = [2,1,0]; say @a.map: @a[*]; This is one of those places where I would simply tell new users never to use this feature. You really can't not use it for array-indexing, which is annoying, but we can live with it. But outside of that, Whatever should be avoided. There's always a less ambiguous way to do it. 
&gt; That should work. Something clearly needs tweaking though I'll look into this. &gt; Right, in that case do you see requests to mojo for css/js/etc in the mojo log file? In scriptname.pl I have the line `push @{app-&gt;static-&gt;paths} =&gt; '.';` to add the current dir, with morbo -v scriptname.pl I see: Server available at http://127.0.0.1:3000 [Wed Nov 9 15:07:57 2016] [debug] GET "/" [Wed Nov 9 15:07:57 2016] [debug] Routing to a callback [Wed Nov 9 15:07:57 2016] [debug] Rendering template "search.html.ep" [Wed Nov 9 15:07:57 2016] [debug] 200 OK (0.0067s, 149.254/s) [Wed Nov 9 15:08:12 2016] [debug] GET "/" [Wed Nov 9 15:08:12 2016] [debug] Routing to a callback [Wed Nov 9 15:08:12 2016] [debug] Rendering cached template "search.html.ep" [Wed Nov 9 15:08:12 2016] [debug] 200 OK (0.001122s, 891.266/s) I don't see a request for anything besides the script being called returning the template. The same thing happens if I use hypnotoad.
&gt; I don't see a request for anything besides the script being called returning the template. The same thing happens if I use hypnotoad. That's because you're not proxying requests to, say, /css through to mojo so apache will be trying to serve them. Check your apache log.
I may be dumb, I added `test/` to the href for the js files and the css files and they work as expected. Is this expected behaviour?
That will cause those requests to be forwarded to your mojo server. If the theory in my other comment is correct, then apache returned 404 for them because they didn't match the ProxyPass route, and that VirtualHost has no other locations to serve.
I'm not familiar with this type of algorithm, but a google led me to: https://en.wikipedia.org/wiki/BLAST And a cpan search led me to: https://metacpan.org/search?q=blast Is this what you are looking for?
I've learned a lot at http://rosalind.info about kmers and related algorithms. The site is written for Python programmers, but I solved 249 tasks there using Perl only.
What happened when you ran the code?
&gt; If there is a console to put perl codes in I would have tried already, but I couldn't find one, do you know any? You know that Perl is open source, don't you? Perl is already installed on pretty much any (non-Windows) computer. And there's [an easy way to install it on Windows](http://strawberryperl.com/) as well.
 perl -le '$buypeople = 42; $rank = 2; $sale=$buypeople/2*0+rand($buypeople * ($rank&gt;1?1:$rank)); print $sale;' Or, see [Reply](https://metacpan.org/pod/Reply).
&gt;If there is a console to put perl codes in I would have tried already, but I couldn't find one, do you know any? Yes, http://codepad.org &gt;$buypeople/2*0 == 0? It doesn't make sense, did I understand it wrong? I agree, it looks like that will always be 0
The == 0 wasn't part of the code, just a comment
Funny thing is that bash was released two years after Perl, which makes it a young "Grand-Pa". Shell code have many [pitfalls](http://mywiki.wooledge.org/BashPitfalls), and frustration default [behaviors](http://mywiki.wooledge.org/Quotes), as well as it's dynamic scoped. Not to mention all the subshells that are spawned, which prevents you from setting variables in the parent shell. Take a look at this snippet: johnFound=0 cat my_file.txt | while read line; do if [ $line == "John" ]; then johnFound=$((johnFound + 1)) done echo $johnFound How many potential error can you spot? `cat my_file.txt | while ... ` will create a sub shell making the assignment `johnFound=$((johnFound + 1))` worth nothing, as the variables are local from `while ... done`. So `echo $johnFound` will always output `0`. `read line` potential have two problems, as `read` will do special stuff to backslashes. See `man read`, and use `-r` meanwhile: `read -r line`. Lines starting and ending with spaces will be trimmed, as long as `IFS` is it's default value. So to get an unmodified value one have to use `while IFS= read -r line`. `if [ ...` Again two potential problems: `[` should be treated as a command and `$line` should be quoted, as if it undergoes word splitting the code will fail. `==` is a bash extension and is undefined in POSIX, see `man 1p test`. The full line should look: `if [ "$line" = "John" ]; then`
Cheating, in general, on exams sucks -- what sucks is when a large fraction of the class cheats (test files) and then the course grade is normalized. Made me quit engineering and switch to physics. 
Yea. Another reason why when I had to solve some problems and discovered Perl I just stuck with it. My first Perl program was a script that took STDIN and sent it to a slave printer. Very simple, turn on the AUX port of the terminal, now send STDIN to STDOUT, turn off the AUX port. When I stated doing embedded C on Linux I needed to automate testing. !00,000 TCP connects. Open and close device driver looking for kernel memory leaks. As I did more and more I started writing more Perl than C and the appliance my company now sells uses mostly Perl for our code. 
http://learnxinyminutes.com/docs/perl6/ http://perl6intro.com join irc.freenode.org #perl6
Hey, that is a very nice introduction, thanks!
If you are in the US and a contractor and you think you may not be then go to you unemployment office if you are laid off. There is legit contracting and 1099 abuse gaming the system. If you're programming in Perl you're smart enough to know the difference and can calculate if you will receive it. In many cases your state DOL will give you unemployment and force your employer to pay the premiums you would have paid during your "contracting". If you were contracting for 2 years they'll pay 2 years. My company has been hit by this. Look at IRS form SS-8 too! 
Are you aware the OP is asking about Perl 6? I think you're referring to Perl 4.
What module were you using? What were you tying to do?? I've used Net::SSH2 and Net::SFTP::Foreign on Linux without difficulty.
I hope perl6 takes off because it looks great, but I have to say it is not even in arch repo yet. I have to add in from the AUR or use rakudobrew.
That's FUD. Perl 6 (the language) is stable, they're tweaking Rakudo (the runtime) for better performance. The Perl 6 you learn today will still be valid in the near future, whereas your comment suggests otherwise. You're right that for the time being, there are more resources on Perl 5 out there.
Perl6 isn't in the arch repo, that's a cutting edge Linux distro. I'm not saying it isn't a good language to learn but it may not be the Best first language to learn.
Which part isn't true? Many of the existing CPAN modules *are* either broken or need updating - CPAN tester results and the RT queue would be good sources to start with, if you're looking for data to confirm this.
Interesting: $ perl -E 'say for PerlIO::get_layers STDOUT' unix perlio $ perl -E 'binmode STDOUT,":encoding(ISO-8859-1)"; say for PerlIO::get_layers STDOUT' unix perlio encoding(iso-8859-1) utf8 $ perl -E 'binmode STDOUT,":encoding(ISO-8859-1)"; binmode STDOUT,":encoding(ISO-8859-1)"; say for PerlIO::get_layers STDOUT' unix perlio encoding(iso-8859-1) utf8 encoding(iso-8859-1) utf8 Ah, the utf8 layer isn't really a layer, from the docs: &gt; certain layers (like utf8 ) are not real layers but instead flags on real layers Also: &gt; Note that under stdio an :encoding also enables :utf8 . See PerlIO::encoding for more information. and (from PerlIO::encoding): &gt; On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding. None of this explains why it is printing the string "\\\\x{fffd}" (which is the replacement character but escaped as it would be in Perl 5). It sounds like the second ISO-8859-1 layer is trying interpret the input as UTF-8 and throwing an error because the byte sequence e4 isn't a valid UTF-8 and trying to replace it with U+FFFD (the invalid character). More info: &gt; PERLIO_F_UTF8 &gt; Data written to this layer should be UTF-8 encoded; data provided by this layer should be considered UTF-8 encoded. Can be set on any layer by ":utf8" dummy layer. Also set on ":encoding" layer. This is the flag that using the :encoding layer automatically turns on. This means all data fed to this layer should be in UTF-8; after the first ISO-8859-1 layer, the data is no longer in UTF-8, so it is definitely starting to do what it should (replace the byte e4 with the codepoint U+FFFD. But encoding U+FFFD into ISO-8859-1 should result in an ASCII question mark, not the string "\\\\x{fffd}". This is almost certainly a bug in PerlIO. You should probably send a message to p5p (the Perl 5 Porters list) about it. The easiest way to do that is with the perlbug utility that comes with Perl. As a side note: the double UTF-8 layer is just fine because the input is UTF-8 and the output is UTF-8. The error seems to occur for any other encoding that doesn't result in valid UTF-8 (like UTF-7): $ perl -E 'binmode STDOUT,":encoding(CP-1253)"; binmode STDOUT,":encoding(CP-1253)"; say "\x{0384}" ' "\x{fffd}" does not map to cp1253 at -e line 1. \x{fffd} I think the right solution is to either die when pushing more than one encoding onto the stack or at least throw a warning. On a side note, I now see how the string "\\\\x{fffd}" wound up being printed. They must be using the Encode::FB_PERLQQ flag in the PerlIO implementation: &gt; When you decode, \xHH is inserted for a malformed character, where HH is the hex representation of the octet that could not be decoded to utf8. When you encode, \x{HHHH} will be inserted, where HHHH is the Unicode code point (in any number of hex digits) of the character that cannot be found in the character repertoire of the encoding. This is almost certainly a bug.
See also http://blogs.perl.org/users/todd_rinaldo/2016/11/what-happened-to-dot-in-inc.html
Yeah, the (poorly named) UTF8 flag is just supposed to mean the string contains wide characters (values over 127). But the PerlIO docs are clear, the string handed to an encoding layer should be in UTF-8. Since the output of any layer that isn't UTF-8 or doesn't restrict itself to the ASCII range (like UTF-7) is not valid UTF-8, having two encoding layers is guaranteed to blow up for non-ASCII characters. If a user attempts to put the same layer on more than once, binmode should do nothing and if the user attempts to put more than one encoding layer of different types on, it should die, warn, or replace the existing encoding layer (probably one of the three based on a lexical pragma, defaulting to a warning).
I am saying that if that were true, the entire language would be unusable, which is not the case. Broken and not updated modules exist because CPAN is one of the most ancient repositories; others could be in the same situation in five or ten years, but for modules that no one uses anymore.
Maybe this is of little use to you since you are using Arch, but perl6 is now available on Debian and therefore in Ubuntu as well.
I think it will be easier to do the workaround: make binmode refuse to create a situation where a problem will occur.
More worried about superseding an imported library for nefarious purposes.
Making it hard for normal people to [see the actual problem](https://rt.perl.org/Public/Bug/Display.html?id=127834) makes Perl much more secure.
Can't see that ticket. What is it?
Thanks, I didn't know that. I wonder what Arch is waiting for?
Kind of surprised you're having any problems. I can build on OSX easily enough, and that should be a lot more different than just another Linux distro :S Have you tried with a fresh user on your machine free of your environment setup? If you have any error messages feel free to PM them to me and I can try and see what might be causing the problem if you're still interested in working it out.
What do you mean by this? When `PATH` does not contain `.`, user has to specify: % ./scriptname instead of: % scriptname That is, she explicitly has to specify that she wants to load script from current directory. Now when `@INC` contains `.`, a user can type (assuming `scriptname` is a Perl script): % scriptname and depending on her current directory (maybe in `/tmp`) she can load a dangerous module put there by a malicious user. She does not have to explicitly allow `.` and that is the dangerous part.
It's probably the ticket for the security issue.
It's private for a reason. Until the fix is rolled out, publicizing it just opens everyone up to potential exploits.
The default `.` in `@INC` (which this issue is specifically addressing) is at the end so actually the attack vector is to provide an optional module which the user didn't have installed, which then gets loaded "optionally" and can run whatever it wants. However the more general case of adding a relative path to `@INC` has the same problem, and `use lib` adds it at the beginning.
Omg! Thank you so much! Spent the whole day going around in this! I am completely spent by now. I promise I will come back tomorrow and review and try to apply it to a shopping list with items and prices! Thank you!
That's not the way I understood the original comment. Declaring Perl 6 a moving target suggests, at least to me, that they are still tweaking the language spec so that you'll have to unlearn some syntax and/or semantics in the near future. In other words: "don't bother to learn it now, before things have settled." I stay up to date with monthly releases of Rakudo (via rakudobrew), but it's based on Perl 6.c for almost a year now.
Again thank you so much! I feel completely adrift. The book is not helping me at all.
Not knowing your data, I can't say. However, that's a really common idiom. Split does return lists.
I am trying to sleep for a bit can I come back tomorrow and do a little test to see if it works? What is idiom? I don't remember that from the book!
Hmm, so this is assuming the items in the list are separated by space, this would avoid the need for split() and ::? What if I wanted to search an item on shopping list like banana and have its aisle and price to be printed out? Assuming the list is loosely organized like 3 column array For example? Banana $1 A2
I really don't recommend *Perl By Example*. The author seems to make many things harder than she needs to - I suspect she doesn't really understand the language. I'd recommend starting with *Learning Perl* or *Beginning Perl* (the version by Curtis Poe is more up to date than the version by Simon Cozens and/or James Lee). One of the nice things about Perl is that you can often write code which manipulates files without actually having to open specific filehandles. Using Unix I/O redirection to can just read from STDIN and write to STDOUT. This makes your programs a) easier to write and b) more flexible. What you're trying to write here is a filter. That is, it reads from an input file and writes data that has been transformed in some way to an output file. Say we're trying to just get all of the lines that contain a digit. The code would look like this: #!/usr/bin/perl use strict; # These two lines are always a good idea use warnings; # The actual logic is a single line of code. print grep { /\d/ } &lt;&gt;; The `&lt;&gt;` reads from STDIN. `grep { /\d/ }` returns all the lines containing a digit and `print` writes the matching lines to STDOUT. If this program was called `my_filter`, you would call it like this: $ my_filter &lt; my_input.txt &gt; my_output.txt and it would read data from `my_input.txt` and write the filtered data to `my_output.txt`. If you're uncomfortable with compacting all of the logic into a single line like that, then you can expand it a bit: while (&lt;&gt;) { # while there is more data on STDIN, read it into $_ if (/\d/) { # if $_ contains a digit print; # print $_ to STDOUT } } As another example, if you're filtering a three-field data file where the fields are separated by tabs and you're looking for records where the first field has the value "Banana", you can use code like this: while (&lt;&gt;) { my @fields = split /\t/; print if $fields[0] eq 'Banana'; } That can, of course, be written in far fewer characters :-) print grep { (split /\t/)[0] eq 'Banana' } &lt;&gt;;
I can't recommend using File::Slurp. There are [big problems](https://rt.perl.org/Public/Bug/Display.html?id=121870) in the way it deals with encodings and the author doesn't seem inclined to fix them. Use the `slurp()`, `slurp_raw()` or `slurp_utf8()` methods frpm [Path::Tiny](https://metacpan.org/pod/Path::Tiny) instead.
&gt; my @cols = split('\s+', @_); I think you mean: my @cols = split('\s+', $_); # $_, not @_ And of course, that's just a complicated way of writing: my @cols = split;
Oh ok, I thought it was specific to perl.
&gt; Also, if I was looking for an item instead of a digit would I have to change how it is presented in the text file? Almost certainly not. I can't be certain without seeing your input file, but I'd be surprised if you couldn't make logic like this work for almost any requirement. &gt; I guess what I am asking is what is $_ in this, is it supposed to a be a variable? Yes. `$_` is a special Perl variable that stands for "the data that we're currently working on". Many Perl operations use `$_` if they aren't given a specific variable to work on. Often when a program is using `$_`, it won't been seen. Some examples from the the code in my previous comment. * `/d/` - Regex matches work on `$_` by default * `grep { ... } LIST` - Puts each element of the list in turn into `$_` * `print()` - Prints the contents of `$_` by default * `while (&lt;&gt;) { ... }` - Puts each record read from `&lt;&gt;` into `$_` * `split /\t/` - Splits the contents of `$_` by default
so if I was looking for lines on file that looked like this inputfile.txt: banana:1:aisle1 tomato:0.5:aisle3 i would do my @inputfile.txt print grep { (split /\:/)[0] eq /pattern/ } &lt;&gt;; how would I output the file?
Cat grepper............... grep expression file.txt &gt; new_file.txt :)
something is definetelynot working, ot I am making a bad mistake since it is giving me syntax errors. assuming a grocery list in a file organized like this: grocery.txt: banana:1:aisle1 tomato:0.5:aisle3 I would write this? #!/usr/bin/perl use strict; use warnings; use File::Slurp qw(read_file); my $file_1 = 'grocery.txt'; # Extract all lines that contain a number my @filtered = grep { (split/\:/[0] eq 'Banana'} read_file($file_1); my $file_2 = 'output.txt'; open(my $fh, '&gt;', $file_2) or die "Cannot open file : $!"; print $fh @filtered; but it says I have a syntax error.
Good point, +1 for Path::Tiny
I am a bit confused, is this a third book I should be getting?
Its a great, free introduction to perl. I enjoyed it and thought it helped a lot. 
They are exempted from strict vars so not using them is helpful not to use them because all other variables are harder to use incorrectly.
The assignment says you should already know how to break a string into individual characters. Hint: see [split](http://p3rl.org/split). Or, you can use [substr](http://p3rl.org/substr) to extract parts of the string. For a string of unknown length, you'd need to loop over the characters, but for the fix length, you can directly compare the characters at the particular positions. Use eq or ne to compare characters that might be non-digits.
&gt; Hopefully you all can shine some light on how the fuck my teacher wants me to write a palindrome program in perl.........without using reverse. Well, he tells you in the assignment. He says: &gt; We have seen an easy way in Perl to rip apart a scalar piece-by-piece. Go back and look through previous lectures to find that code. This will make your program very straightforward. And that sounds like a good advice to me. If you have a string with seven digits, you can split it apart into an array with seven elements. If the original string is a palindrome, then the first element of the array will be the same as the last element of the array (and the same will be true of the other corresponding elements of the array).
This is awesome. Payday is Friday, I'll pledge. Hope it works out for you and ultimately us users. 
You should look for the 2016 (4th edition) version instead, it's updated to Perl 5.22. You can find it in several forms here: http://modernperlbooks.com/
I also recommend [File::Slurper](https://metacpan.org/pod/File::Slurper) as it has a similar explicit interface built just for reading and writing files all at once. But the Path::Tiny functions are nice if you're using the module for other methods.
Yes
[removed]
So people who want `.` or `lib` or something similar can add it to `@INC` themselves, correct? By the way, just to remind that not all people want/need that. Scripts/applications that are deployed as a Perl/CPAN distribution generally don't need it, because the installer already takes care of putting the libs into their proper place.
Just noting that there are already several O'Reilly books with butterfly as their covers. Of course for Perl 6 a different particular species will be chosen. * [Learning MySQL](http://shop.oreilly.com/product/9780596008642.do) * [Search Patterns](http://shop.oreilly.com/product/9780596802288.do) * [JavaScript: The Good Parts](http://shop.oreilly.com/product/9780596517748.do) * [Learning Oracle PL/SQL](http://shop.oreilly.com/product/9780596517748.do) * [MediaWiki](http://shop.oreilly.com/product/9780596519681.do) 
Yeah, this. I find it really confusing. I'm all for this book existing, but O'Reilly is normally the investor in O'Reilly publications, not me. /u/briandfoy please comment?
Copying and pasting from the FAQ: &gt;I will get royalties for the books that sell, but book sales aren't what they used to be. Not only that, the market is much more fragmented in the past because people have so many choices of technologies (that's a good thing!). The kickstarter reduces the publishers risk. I get to work with O'Reilly Media and their great process and quality control without them potentially losing a bunch of money. &gt;Also, I'm offering lots of real services at a discount. This is a book I want to write, and I'm sacrificing high-priced work at normal rates to do it. If I know I have some initial money to get going, I can focus on the book instead of finding new business. In other words, O'Reilly aren't sure enough that the book will sell to just give an author an advance and take a risk.
&gt; In other words, O'Reilly aren't sure enough that the book will sell Good thing Kickstarter exists exactly for situations like this... 
Few problems here: - It's case sensitive. So 'banana' won't match 'Banana'. - You'll need to bracket the `split`: `(split/:/)[0] eq 'Banana'` - I don't like `File::Slurp`. Especially as you don't _actually_ need to take the whole file into memory. So with that in mind, I'd probably do it like this: #!/usr/bin/env perl use strict; use warnings; open ( my $input, '&lt;', 'grocery.txt') or die $!; open ( my $output, '&gt;', 'output.txt' ) or die $!; select $output; #set destination of "print" while ( &lt;$input&gt; ) { my ( $item, $number, $location ) = split /:/; print if $item eq 'banana'; } But if you really want to use `grep`: chomp ( my @filtered = grep {m/^banana:/i} &lt;$input&gt; ); #regex matching Or grep { (split /:/)[0] eq "banana" } &lt;$input&gt;; #field based matching But it may be _even more_ useful to form this into an array of arrays first: use Data::Dumper; my @stuff = map { chomp; [split /:/] } &lt;$input&gt;; print Dumper \@stuff; my @filtered = grep { $_ -&gt; [0] eq 'banana' } @stuff; print Dumper \@filtered; foreach my $array_ref ( @filtered ) { print {$output} join (":", @$array_ref),"\n"; } 
If you are ever interested in writing your own book, I think you'll appreciate the things a big publisher brings to the table. After you self-publish a book, you'll probably like that even more! O'Reilly brings an excellent editorial staff, copyeditors, indexers, marketers, and an impressive catalog of other books that will surround Learning Perl 6. O'Reilly has the right connections with the online book sellers and distributors. If something is wrong with the book description in Amazon, for instance, I know O'Reilly has a person who knows a person. When someone wants the foreign language rights to the book, they deal with that and get me a pretty good deal. They deal with the Library of Congress and several other such bodies to register my copyright. They have lots of beneficial relationships by virtue of their size and focus. They know everything that needs to happen and they have systems in place that make it almost automatic. They have a pretty good royalty tracking system where I get paid monthly instead of semi-annually. They deal with all that accounting. And, I know they are going to pay my royalties. I also get to use Atlas, their real time layout and publishing system, and all of my tools are already built around that since I've published my other books through them. It's not that a publisher *pays* to publish a book. A publisher and author reach an arrangement where one side risks some resources and the other side risks some time hoping for future profit. Many publishers give an advance (something I don't think I've ever taken) which is actually just future royalties. An author who takes an advance won't see royalties until they "earn out", which means their royalties on future sales equals the amount of the advance. Many authors do take an advance and never earn out, which means the publishers lose a little bit of money. Pay too small an advance and the writer might not deliver because they have to work on something else to pay the bills. Pay too large an advance and you lose a lot of money. This works because the publishers don't know what will work and what won't. They have to make a bet. So, I'm removing that risk for the publisher. It's a book that I want to write and they'd like to publish. However, there are lots of books they'd like to publish. I've given them a bit more reason to commit to mine. I've gamed the system a little so some other book proposal is behind mine instead of in front of it. And, from that, I think I got one of the best editors working with me. But, I had an idea of testing the market by crowdfunding, which I can count as pre-orders. I'm curious if this would work. I'm doing it because I have that hacker curiosity about exploring this system. This isn't a safe thing to do. I'm extremely vulnerable: this good flop big time. This could be an epic fail. It's way out of my comfort zone, but sometimes you need to do that. I've had a lot of successes in my career, so something scary and uncertain like this seems to a good thing right now. Books are expensive for authors too. I've often told people that you don't make money writing a book, but you can make money writing ten books. I know Learning Perl 6 isn't going to get me the same sales as some of my other books, but I want to write it. I'm compelled to write it because that's the way I am. Getting some money from the community in return for future services (so, I'm stealing from future work a bit for time now) can give me space to focus on this project. If enough people in the community thinks its worth it, good for me. If it flops, nobody is out anything. As for you, a potential backer, you should only think about if the value I'm offering you (whatever that might be) is enough for you. Do you want the book? Do you think I can write the book and deliver it? Do you think you'll like what I write? If that value proposition makes sense to you, you can participate. If it doesn't, you might hope that enough other people participate so you get the book later (my first backer, Sinan, might call that a free rider problem ;). Going a bit further, there are several people who want *other* people to have to book, so there are higher reward levels for that. 
We're trying something new because I'm curious if it will work.:)
I am going over what you just taught me and and I want to test it and change a few things to see how it affects my program. I am using padre to code, is there a special place where I need to put my file for padre to know where it is? Or do I need to write the directory of where it is? I am sorry if it is a stupid question.
If you're opening a file, you'll need to specify a path. The 'default' is the current working directory. I don't know about padre, I just use a standard text editor. You could just open a command prompt and run it there - and then it'll be 'reading' your current working directory. 
How dare you disparage the beauty of our precious Camelia?
I see, I don't know how to do these things in cmd so I am stuck with padre. can grep also be used to count words that I input in an array? use strict; use warnings; my @words; my $count; my $line; while (@words = &lt;STDIN&gt;) { @words = split( " ", $line ); chomp(@words = &lt;STDIN&gt;); $count=grep(/" "/i. @words); if (@words eq /\^D/) { # control D my $count=@words; print "gotcha\n, there were $count words\n"; last; } } so in my previous grocery store example if I wanted to know how many items were in there. sorry got overwhelmed because I can't even open the file. trying to go for something simpler like just counting an inputed array instead of trying to open and close files.
This appears to be a introductory course in programming and your issues less about perl and more with construction of a solution. Some general advise: utilize the resources of your school, you're paying for them. Go to your professor or TA's office hours. Ask around about study groups. Visit the Comp sci lab and ask the TAs there. When programming a solution in any language, it's important to break the problem down and solve the smaller problems. It's helpful to write this out as pseudocode in natural language. You can then fill in as you write the actual perl. In this case the problem question lays this out quite well. # prompt and read user input # chomp user input to remove newline # determine if user input is a palindrome # if it's a palindrome print positive msg # if it's not, print failure msg Not knowing what you've covered so far it's hard to know where to go from here. You will definitely be using `print` and `readline` builtin functions and using an `if ... else` statement. That leaves how to determine if the input is a palindrome. This is a good candidate to break down further; if you've covered subroutines use one here, but if not that's okay. Just inline the logic. So how do you determine a palindrome? Pseudocode again. # determine if user input is a palindrome: # access individual characters of input # compare beginning and end characters You'll need to access the individual characters. In perl this can be done with `split` (hint split on the empty delimiter) or `substr`. To compare the characters you can use a `for` loop statement, but there is a pretty big shortcut because the input is always 7 characters. You can just compare `eq` the first and seventh characters, the second and sixth, and so on. Remember strings and arrays start with index 0. What's left is actually pulling all this together into a perl program. Don't be afraid to experiment. Use `perl -e 'sample perl'` to see what happens.
Nice. But If you read the posts by tye in the thread I linked to, you'll see that FindBin::Bin is fundamentally broken: The current script doesn't have to be in $PATH, and if there is a script in $PATH with the same name, it could be a different one. That is not what I would call "reliable". Manipulating $0, or chdir, which could both throw off my and tye's snippets of code, should be done *at compile time* to have an effect, because arguments to `use` are executed at compile time. That's quite an unlikely scenario. It won't happen by accident. `__FILE__` is a nice idea, but then you're forced to put this whole chunk of code in every script that wants to use of it, while mine could just as well be in a tiny module. Or you could pass `__FILE__` as a parameter. Or, still, we could peek in the `caller` stack, get the file from the bottom entry. 
Approaching 50% funded, wow!
It looks like that bug with FindBin was fixed, but as noted in the thread, that only fixes it for new perls, since FindBin is not dual-life so you can't upgrade it. But anyway that's just another reason to use `__FILE__` instead. And yes if you wanted to put it in a module for convenience, you would use `caller` to get the caller's `__FILE__`. I would just go one level up to avoid making usage confusing; the file in which it's used directly should be the filename used. (This is in fact how Dir::Self works: https://metacpan.org/source/MAUKE/Dir-Self-0.11/lib/Dir/Self.pm#L13)
The chained methods in the implementation of `k-mers` are just gorgeous. I need to go read up on `comb` and `rotor`.
Use hash slicing to run a regex replace on keys of a hash (this one in particular removes all periods): my @new_keys = keys %my_hash; s/\.*//g foreach @new_keys; @my_hash{@new_keys} = delete @my_hash{keys %my_hash}; I also wrote a blog post on it [here](http://kylestratis.com/2016/10/27/hash-slices-perl/). 
It worked, was just tired because I have mildly obsessive behavior towards completion of tasks. It really worked. I am stuck in something else now but I am going to sleep over the issue before I tackle it again. 
With Ovid's permission i have added this to my git-tools repo on github: https://github.com/leejo/git-tools/commit/2eea65690f7ace95ccf1cc9aa514371f69f8500d
Interesting! At first I though that was completely pointless. But reading the Perlmonks post, it seems to work because of the aliasing of @_ array items when making the subroutine call. So a new array is created, but with reused array items. (to be clear about what happens, the splice() is destructive, but the copy of the array contents is cheaper than with a regular assignment) So it should be *mostly* useful when it's expensive to copy the array contents (e.g. large strings) compared to the array itself. If there are a billion very small items (like references to other data structures), there wouldn't be any huge benefit. That seems to be missing from the conversation.
Glad to pitch in. Does perl have a wealthy benefactor? In a couple different crowdfunding projects, I see the highest available reward purchased, and there's usually a gap between that one and the next reward level that was actually funded.
Elizabeth Mattijsen and Wga Van Dijk aka "Liz and Wendy". Donate a lot of money to Perl efforts. But more impressive is their donation of time and code. Both go to most conferences and run a stall. Wendy maintains the Perl 6 facebook group, and Liz writes most of the weekly blogs. Liz has also been [toiling away at the rockface](https://github.com/lizmat) optimizing Rakudo for at least a year.
I tried from a Win 7 machine to Pfsense gateway and could only get it to work using icmp and running as Administrator $p = Net::Ping-&gt;new("icmp"); From the perldoc Net::Ping: &gt;If the "icmp" protocol is specified, the ping() method sends an icmp &gt;echo message to the remote host, which is what the UNIX ping program &gt;does. If the echoed message is received from the remote host and the &gt;echoed information is correct, the remote host is considered reachable. &gt;**Specifying the "icmp" protocol requires that the program be run as root** &gt;or that the program be setuid to root. Perhaps a similar elevated credential requirement for Windows? Update: That looks to be the case [https://stackoverflow.com/questions/7687401/why-does-ping-work-without-administrator-privileges](https://stackoverflow.com/questions/7687401/why-does-ping-work-without-administrator-privileges)
You only actually pay if it gets fully funded, in which case the book gets written and you get it. Given the publisher and author, there's not much risk that you'll pay and the book still won't exist. Think of it as a pre-order.
It's a CSS thing. Look at the source and ctrl+f for noscript. I made the screenshot by disabling CSS. If i edit that element out it even looks reasonable: http://i.imgur.com/m7WeaMW.jpg So yeah, i really hope they just disable the blocking, maybe add noscript tags for specific features, and leave it at that. :)
apparently it's the same platform that's used for http://blog.builtinperl.com/post/7-features-that-i-would-like-to-have-in-perl-5 - if so, it'd be nice to have a working comments feature... the arbitrary character-dropping approach that site appears to use is not quite what I'd call "visually stunning" =)
My investigation reached this page https://community.activestate.com/taxonomy/term/515 were it is said that *401* errors have to do with the business license, but anyway they recommend to update the version of ActiveState Perl since those versions are currently obsolete and newer versions give more informative messages.
Good to know that they are actively improving the performance in every release!
You might prefer [Strawberry Perl](http://strawberryperl.com/releases.html) - some of the versions come pre-loaded with PDL and its associated modules.
I tried PDL with Strawberry Perl on Windows. After 1/2 hour of downloading and running tests I gave up and terminated the install. Several tests failed too. I was pretty excited to use it, but that impression convinced me to stick to R and Excel. The doc looked really good too!
I second u/leejo 's sentiments. If you are going to go so far as to setup routes from configuration, I'd suggest using [Mojolicious::Plugin::OpenAPI](https://metacpan.org/pod/Mojolicious::Plugin::OpenAPI) since in that way you get input and output validation, documentation, and you are following a [spec](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md) that has been crafted for the purpose.
This is why it's important to remember that REST is not a specification, but an architectural style. There is no sense implementing DELETE endpoints unless you are prepared to authorize and present them properly.
Black numbers over a dark blue background is somewhat hard to read, specially from certain angles.
I'm also writing a [mini-article series on Getopt::* modules](https://perlancar.wordpress.com/2016/12/01/getopt-modules-01-getoptlong/) this December, each post scheduled to be published daily like an advent calendar. And I have plans to continue with a few more mini-article series in the following months. I hereby apologize in advance if my posts flood this subreddit daily in the next few months. _perly_bot might need to be tuned to tune me out (not all the time I hope). 
Fixed continue; been using C too much lately. Keeping the regular expression. substr looks so weird in perl. Rather keep it idiomatic (and likely more efficient).
&gt; I'm picky about using regexes in situations which can be handled by a simple text-oriented function. Don't be, unless you actually need to. Feel happy with your code, and only optimize when optimization is needed.
I wrote [Getopt::Long::Modern](https://metacpan.org/pod/Getopt::Long::Modern) because Getopt::Long does everything I need, but so I don't want to have to remember what options I want for every script. It sets mostly the same options as you mention, mainly via `gnu_getopt` which includes `bundling`, `permute`, and `no_getopt_compat`, and also `gnu_compat` which allows specifying empty-string values for options. It also adds `no_auto_abbrev` because most unix-like scripts do not allow abbreviated options automatically, most users do not expect them to, and I prefer to specify abbreviated options manually. By default Getopt::Long adds every possible abbreviation for an option which doesn't conflict with another, so `--foo` would get `--fo` and `-f`, but not if there was also a `--foe`option.
As for the day 1 article, as simple as the example seems, perhaps some explanation is useful regarding interaction with PerlIO layers, e.g. printf from C is not affected by encoding or might hang with some layers.
Interesting, I never had tried abbreviated options simply because it never comes up in documentation I suppose. I don't think I'll be adding it back to Getopt::Long::Modern by default but it could of course be turned on by listing it as an import option.
It looks like we're going to have a lot of posts from these calendars this month :)
Using substr is probably a pessimism in this case.
Well, even Perl 5 is a different beast today compared to the times when the people saying that critique would have a point. They basically mistakenly think Perl of today is the same language it was in the '90s... which is probably when they last saw or used it. As to why learn Perl 6... Personally, I find it a very fun language and the community is hugtastically friendly. We have grammars, superb high-level concurrency primitives, gradual typing, no Unicode pains, and excellent OO model. You can check out [our marketing brochure](https://github.com/perl6/marketing/raw/master/Brochures/Perl6-PR-Brochure/Perl6-PR-Brochure.pdf) we hand out at conferences or [come chat with us on IRC at #perl6 on irc.freenode.net](https://docs.perl6.org/webchat.html). We also have a separate subredit: [r/perl6](https://www.reddit.com/r/perl6/) where more Perl-6-ish eyes may notice your posts :) Cheers!
With pattern matching, multiple dispatch, and gradual typing, it's like a cowboy coder's version of Haskell.
I noticed the introduction to static typing and I was rather impressed. I'm kinda curious as to how it's different from fully static languages - I'm guessing type inference is used at run time which leaves me mind blown. Hmmm. You're making feel more interested in perl.
Downside is it doesn't have option types (I don't think). But check this out: https://news.ycombinator.com/item?id=9089259
Picking a tool which is specifically designed for a particular application, compared to using a complicated feature with a lot of overhead that does a whole lot more than is needed, is not premature optimization, it's simple appropriate behaviour. Actually, I would consider moving the comparison into a function, choosing a name such as is_a_url_line(); http://martinfowler.com/bliki/FunctionLength.html
What's your question? Your example works as expected. Are you asking if it's the idiomatic way of doing that? I'd say yes. Of course, there's more than one way to do it.
Some of the bits of functionality that brought me to using Perl 6 and have kept me interested are [Grammars](https://perl6advent.wordpress.com/2015/12/08/day-8-grammars-generating-grammars/), straight forward [Concurrency/Parallelism](https://www.youtube.com/watch?v=JpqnNCx7wVY&amp;feature=youtu.be&amp;t=27), [easily linking to native libraries](https://docs.perl6.org/language/nativecall) and [even Python](https://github.com/niner/Inline-Python) and [Perl 5](https://github.com/niner/Inline-Perl5). A feature people argue about the goodness is that all strings are a form of normalised unicode. But just how deep unicode is in the language and how well thought out is really quite impressive. You can use *any* unicode numbers for example, even the fraction characters end up being `Rat`ional typed literal values! The main nice feature I find is the language taken as a whole, it often just works nicely and how you might guess. Things like "metaops" and all operators secretly just being functions (even built in ones) are all really nice concepts. So the `Z` meta operator lets you do `zip` and something else at the same time. So if you had two lists and wanted to pairwise sum the elements you can combine `+` and `Z` to get `@list1 Z+ @list2`. Anything works with `Z`, or `X` or even `=`, for example `.=` where `.` does method lookup and then does assignment, so `.= new` calls new and then assigns that result. Perl 6 is a very big language with wide scope, but it does this with a relatively minimal set of concepts that it composes together to get that advanced and fancy functionality. An extreme example would be slangs, if you want to make your own domain specific language you can literally patch your own Grammar into the compilers parser and code generator. You do this with a bog standard Grammar class and another class with the actions to perform for your syntax. That large chunks of Rakudo itself are written in Perl 6 or its subset NQP make jumping between core language and user space language usage not a huge deal. It's not like in Perl 5 or Python where the implementation language is C, and there is that barrier between using the language and implementing the language. There aren't bits of Perl 6 syntax and standard library that are utterly special cased and weird feeling. An example would be lambdas in Python they just don't quite "fit" the rest of the language, they were an after thought... but then list comprehensions are quite a bit deeper. Everything in Perl 6 starts to feel more deeply integrated as you use it, which makes it all the more jarring when you do run across a missing method or a broken expectation. Usually when that happens to you whilst learning Perl 6 the core team listen carefully to what you're saying. I've seen a lot of serious debates come in around this sort of user experience. I think it's quite rare the actual design of the language is taken that seriously. Other modern languages like that I think are probably Swift, which fits a similar space to Perl 6 too.
I didn't notice that Dancer2 had switched to JSON::MaybeXS and added optimized encode_json and decode_json functions (using JSON::MaybeXS's functions directly). Looks like this [module I wrote](https://metacpan.org/pod/Dancer2::Serializer::JSONMaybeXS) isn't needed anymore. Great stuff!
I get that. Which is why I would learn perl 6 directly rather than spend time on perl 5. Thanks for caring!
It's unfortunately a common misconception this is a common misconception. Much more common misconceptions learners actually have are things like `scalar %hash` not being the same as `scalar keys %hash`. You don't see every Perl 6 person mentioning in a beginner thread "if you do want to learn Perl 5 please be aware of this". These sorts of comments whiff mildly of FUD and aren't that helpful. Who are you saving? A learner from learning a language? Given your own logic you might as easily have just said "you do realise Perl is not a version of Python, are you sure you dont want to focus on Python?". So what is the motivation for the comment? I loathe that I even had to add to the divisiveness of the community ATM by referring to "perl6 people" since most are just perl people. Almost the best thing that could happen is people are constantly confused and try both languages. It would add a lot of cross pollination!
A different job where I don't do as much image processing. I still use it occasionally, though. But at this point I'm not really contributing anymore. 
I would recommend running some [benchmarks](https://metacpan.org/pod/Benchmark) with varying data before assuming that a regex will have more overhead in perl, or even that a function call would have less.
I hate to say it but this is why perl is known as hard to read... how can you easily see wtf this code means?
What part is confusing? It's probably familiarity with the language and the Getopt::Long style of option specification. These are all just function calls with lists of arguments, but how you specify the types of arguments in Getopt::Long and derivative modules is its own format, you would have to familiarize yourself with the documentation to understand them. (Basically, =i means an integer option value, =s means a string option value, and @ means it takes multiple values. Without any extra metadata, it's just a boolean option that doesn't take a value.)
Interesting. We just installed jira service desk, and wrote some php code to access a couple rest calls. We have one programmer that still prefers perl, and I use it a fair bit too, so this could be handy for us.
Why can't knowing the module be a prerequisite for being able to understand code using the module? Regardless, there is room for more intuitive ways to specify options, and indeed there are many modules that do so, which I'm sure perlancar will continue to cover.
&gt; Why can't knowing the module be a prerequisite for being able to understand code using the module? It can be, however whenever you write code you want others to be able to use you want it to be readable. The number one complaint about perl is almost always that you cannot read others code. Most of the time I find this to be iffy, but if enough people say so then there is something to it. &gt; Getopt::Long - 8 lines / 192 char GetOptions( "--flag1" =&gt; \$opts{flag1}, "--flag2" =&gt; \$opts{flag1}, "--flag3" =&gt; \$opts{flag1}, "--flag4" =&gt; \$opts{flag1}, "--val1|1=s" =&gt; \$opts{val1}, "--val2|2=i" =&gt; \$opts{val2}, "--val3=s@" =&gt; $opts{val3}, ); &gt; Getopt::Compact - 8 lines - 183 char (with added value definitions) my $opts = Getopt::Compact-&gt;new( modes =&gt; [qw/flag1 flag2 flag3 flag4/], struct =&gt; [ [["val1", "1"], "Value1 blah blah"], [["val2", "2"], "Value2 blah blah", "=i"], ["val3" , "Value3 blah blah", "=s@"], ], )-&gt;opts; However just glancing at the 2 of them, Long is pretty damn straight forward if you know perl. Compact saves very little typing but makes it extremely hard to read. The little savings you get by using it in terms of short hand just do not seem to justify the readability imho
 ^ ^ | | Correct
Ok, I didn't know you were referring to the interface of this module specifically. I can agree with that.
note that the typo example is nothing to do with the uninitialized variable warning - that one is purely due to lack of 'use strict qw(refs)'.
I enabled `gnu_compat` to my modules a few days ago. Just realized today that bundling no longer works. Turns out `gnu_compat` also disables `bundling`. Not sure whether it's intended, because the doc doesn't mention about bundling. Have submitted a ticket ([RT#119165](https://rt.cpan.org/Ticket/Display.html?id=119165))
Yup, because `gnu_getopt` equals to `gnu_compat` + `bundling` + `permute` + `no_getopt_compat`, i.e. explicit turning on of `bundling`. If the POD is to be followed, then indeed `gnu_compat` should not turn bundling off.
Thanks. I'll consider that option.
It's for stuff like ``` say 'foo'.subst: :2nd, 'o', 'x'; # fox ``` There are also some variations on `:foo(10000)` that are valid `:foo&lt;a b c&gt;` works for a Positional, as does `:foo[1, 2, 3]`. `:foo{ :42a }` works for a `Hash` and `:foo{ some code }` works for a `Callable` And Perl 5 style of `foo =&gt; 42` works as well.
And if you really want to be up to date, move to RESTful APIs and move all your HTML to the front end with any of the Javascript frameworks: Angular, React, etc. You Perl back end should only send JSON information to your front end. But, as usual, YMMV.
That is a popular option, but it has the disadvantage of not being accessible because most frameworks don't know about or care about accessibility. [Here are a few tips on this](http://a11yproject.com/).
I have a nice simple module on CPAN called [HTML::FromArrayRef](http://search.cpan.org/~nicwolff/HTML-FromArrayref-1.06/lib/HTML/FromArrayref.pm) which lets you do e.g. use HTML::FromArrayref; print HTML [ html =&gt; [ head =&gt; [ title =&gt; 'My Web page' ] ], [ body =&gt; 'Hello' ] ]; and use natural Perl syntax to generate HTML from data, like print HTML map [ p =&gt; [ $_ &gt; 100 &amp;&amp; 'b' =&gt; $_ ] ], 4, 450, 12, 44, 74, 102;
for TT2, there's https://metacpan.org/pod/Template::AutoFilter - it's no substitute for a proper context-aware template engine, of course (HTML/&lt;script&gt;/attribute="..." etc.)
Specifically, look at [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM) where you can parse a simple template HTML file, then insert your content into elements you choose with CSS selectors. You can then hand-edit or use any HTML editor to keep your template files separate from your code.
Going further, there's also [HTML::Zoom](https://metacpan.org/pod/HTML::Zoom) and its "successor" [Template::Pure](https://metacpan.org/pod/Template::Pure) which are unique template engines where you start with an HTML page and then use CSS selectors to insert data.
&gt; I feel dirty mixing random HTML output in my code That's an excellent reason to move to another solution. Just don't be fooled into thinking that just because the majority do something differently that your way is no good for you.
yah it will be an abomination on top of an abomination on top of an abomination. However the interesting bit is that at at least one layer of the abomination will be fsvo correct.
Syntax highlighting would go a long way on that article.
Hey, if it worked for the OSI model....
It's nice to have this built in, but... I think I still kind of prefer Getopt::Long.
I've used this toolkit a lot for this purpose with excellent results. Recommend it 
As long as you have installed all modules you need for your scripts, there will be no issues. Interpreter is exactly the same, the only difference is the toolchain and included extras (PPM etc.). &gt;I just can't get DBI installed Isn't DBI bundled with ActivePerl? What problems are you having? There shouldn't be any problems with getting DBI to work under ActivePerl. 
No, it's not bundled. I've got a lot of DB files, but they won't work because it can't find some file, and neither can I. Well, I'll try Strawberry.
DB Files lying around? I'm confused. What exact error are you getting and what are you trying to do? Your response makes me think that there is some deeper misunderstanding going on and simply switching to strawberry won't fix that. I was able to use DBI just fine 15+ years ago with AS Perl, and I can't think they've gone and broken something so fundamental to doing business with Perl. 
How can I imply the talk is bad if I didn't watch the whole thing? I understand he is nervous since Larry Wall is in the audience, etc. I will give it another shot today. 
I prefer circumfix for regular dereferencing too, but I'm warming up to postfix deref for things like: `my @values = $foo-&gt;{bar}{baz}-&gt;@{@keys}` (rather than `my @values = @{$foo-&gt;{bar}{baz}}{@keys}`) or the new key-value slicing with `-&gt;%` on a hash.
Yes. Since core comes before site, it is impossible to update dual life modules unless they overwrite the core module. (Rather: it's not *good*, but it's necessary.)
It says in the article that he didn't invent it. It's really just a good name for a headline so that it grabs your attention. You're taking it too personally.
Sorry, this got stuck in the spam filter. You may want to resubmit it.
Looks like you're pretty close again. I got it working with just a few changes. Firstly, your `total()` subroutine looks like this: sub total { @nums = (1...100); my ($total); foreach (@nums) { $total += $_; } } And you call it like this: print "The sum of the array of numbers is ", total(@nums), ".\n"; In your print statement, you are printing the return value from `total()`. But `total()` doesn't return anything. Fixing that is simple, just add `return $total` to the end of the subroutine. But `total()` also ignores the values that you pass it. You call `total(@nums)` but inside the subroutine you have a hard-coded array - `@nums = (1 .. 100)`. We can fix that too. So now we have: sub total { @nums = @_; my ($total); foreach (@nums) { $total += $_; } return $total; } With those fixes in place, your first print statement now works as expected. &gt; The sum of the array of numbers is 5050. The next two are still wrong though. &gt; The largest value is 1 &gt; &gt; The smallest value is 100 That's just because you've got the values the wrong way round. I'll leave it to you to fix that. Then your next print statement kills the program with this error: &gt; Illegal division by zero at main.pl line 17 Line 17 is this: $avg = $total/scalar @test_array; You're dividing by the number of elements in `@test_array`. But this subroutine knows nothing about `@test_array`, so that's zero. Hence the error. Once again, you are passing the array into the subroutine (`avg(@nums)`) but not doing anything with the arguments. Let's fix that. sub avg { my @nums = @_; my ($avg); $avg = $total/scalar @nums; return $avg; } Now, we no longer get an error. But your print statement says that the average is 0. That's because the top of your division is `$total`. And the variable `$total` is local to the `total()` subroutine (you've defined it with `my` - which is a good thing to do). Inside `avg()` that variable doesn't exist, and therefore will be interpreted as zero. The quickest fix here is to replace `$total` with another call to the `total()` subroutine. So your subroutine looks like this: sub avg { my @nums = @_; my ($avg); $avg = total(@nums)/scalar @nums; return $avg; } And now everything works as expected. Some suggestions for the future: * **Always** have `use strict` and `use warnings` in your Perl code. * Don't use global variables. A subroutine should only ever use its parameters or its internal variables. * If you're passing parameters to a subroutine, **use them**. 
The article is talking about two different (arguably non-related) issues: 1) relationship between modules/packages and filesystem paths; 2) relationship between distribution name and its main module name. For 1, the mapping of modules/packages to filesystem path is mainly for convenience. If one says "use Foo::Bar" or "require Foo/Bar.pm", the default mechanism is too look for Foo/Bar.pm in directories specified in @INC. Then the first found file is loaded and evaluated. The file can contain any code or any "package Whatever" statement. But to avoid confusing users, the file should probably contains code that lives in Foo::Bar namespace. If one installs a custom require hook, this mapping can be changed arbitrarily. You can make "use Foo::Bar" to load some code in a database named Qux or on a remote server named Grault or whatever.
I just and reading the /u/davorg comment and I am now realizing that the subroutine works a little bit like a call by reference or like a pointer (sorry if my technical understanding makes no sense at all). Stupid book made it sound so unclear. So cryptic I am always expecting a Bigfoot to enter my living room.
*Perl By Example* is a terrible book on at least two levels. The author doesn't understand Perl as much as she thinks she does and she can't explain what little she does know clearly. You're doing yourself no favours at all by persevering with that book.
&gt; $avg = total(@nums)/scalar @nums; this makes so much freaking sense now!!! Why am I getting it wrong though? where am I failing in the comprehension??
I dropped the book when you guys first mentioned it. I just haven't had a chance to start the books you guys suggested. I am scared to stop attempting to code until I can pick up the other book because I am afraid of forgetting the little I've learned so far. So when I have a few minutes I try to come up with plausible questions that could be addressed with a tiny script.
They work just fine. The index contains package names. You don’t have a package called ACME::Foo::Bar. So you can’t install it. You *can* install it by asking for `cpanm Whatever`… or, you could, if you had chosen a package name that wasn’t already taken by somebody else. The toolchain does not get confused by any part of this, in any way. The question is whether cuckoo packages conform to your expectations, and the answer to that is “probably not, unless you understand exactly what’s going on”.
&gt; In this example, `Test::More` appears twice, but it really refers to two separate things; the first is a filepath, the second is a symbol namespace. That’s not correct. The “`use Test::More;`” statement is short for BEGIN { require Test::More; Test::Import-&gt;import; } The implied `require` call does in fact treat the package name as nothing more than notation for a relative file path. But the implied `import` call refers to the actual package. So a `use` statement combines both interpretations of a package name.
I think my brain broke.
You picked an unfortunate package name `Whatever`, which happens to be already taken by another author. Cuckoo or not, PAUSE prevents the indexing. If you use a different package name, they will work. 
Another one tripped by the `x.y` -&gt; `x.y.z` trap :) That's why I now use 3 digits for `y` instead the more common 2.
For those who happen to face the same issue, the current workaround is to enable `bundling` *after* `gnu_compat`.
&gt; You can install it by asking for cpanm Whatever… or, you could, if you had chosen a package name that wasn’t already taken by somebody else ~~The distribution doesn't have a module with a matching package name. Are you sure that changing the package name to something unique would work in this instance?~~ You're right - it works (package "Whatever2") with cpanm, but not with cpan. Maybe cpan is using an older package list? 
Good point, thanks!
cpanm can use [Meta DB](http://cpanmetadb.plackperl.org/) (which updates in minutes from PAUSE) in addition to reading 02packages of a CPAN mirror (which updates in minutes to hours or more, depending on which CPAN mirror one is using). 
Oh that's good to know. But [metadb](http://cpanmetadb.plackperl.org/v1.0/package/Whatever2) can't find my package. Maybe the 02packages cpanm is using is newer? I'm surprised it would even feature in 02packages if failed the PAUSE indexer. Have you seen it in a 02packages?
When the metadb lookup fails, cpanm falls back to a [file search on the metacpan API](https://github.com/miyagawa/cpanminus/blob/0739c5cdc7cbe769bf93ef6a49e7069d61d1c00e/lib/App/cpanminus/script.pm#L596), which apparently finds your release. (It starts with this search if you specify the --dev option to find dev releases, which are not PAUSE indexed.) If you pass the -v switch to cpanm you can see exactly what it's doing. In any case, the package is not indexed by PAUSE.
Thank you for the information
The module [Test::MockTime](https://metacpan.org/pod/Test::MockTime) is widely used for this sort of testing.
See [feature](http://perldoc.perl.org/feature.html) from perldoc. From Perl command line in recent versions: -e program one line of program (several -e's allowed, omit programfile) -E program like -e, but enables all optional features So: &gt; perl -e 'say 1234'; Number found where operator expected at -e line 1, near "say 1234" (Do you need to predeclare say?) syntax error at -e line 1, near "say 1234" Execution of -e aborted due to compilation errors. but &gt; perl -E 'say 1234' 1234
Maybe I haven't kept up... Do we no longer need curlies around a sub declaration block?
I was wondering why it was written that way as well, but based on the contrived example here, I'm assuming the OP just forgot to put those back in when he carved out the snippet.
I just use common::sense, it's awesome!
Unpopular answer: Yes, in Perl6
Yeah, I guess you're right. So it's dropping through each if instance here for ret per call of doInstall, then? 
 sub a {}; if (a == 0) { print 'Ohhhh' }; Please take a break (I suggest at least 20 minutes doing something completely different to properly flush the chemicals of frustration from your system) then return and focus on being crystal clear why this should and does print 'Ohhhh'. Then, if need be, take another break of 20 minutes before considering what will happen when `a` is replaced with `doCreate`.
It's available from CPAN http://metacpan.org/pod/App::Trrr
[App::MyPerl](https://metacpan.org/pod/App::MyPerl) is another neat approach to tackling this problem on a project-wide basis.
You're gonna have to include more code, bro.
LWP::UserAgent has a timeout option that can be passed into the constructor. ie): my $ua = LWP::UserAgent-&gt;new(timeout =&gt; 60, ssl_opts =&gt;{ verify_peer =&gt; 0 }); However, the timeout's default is 180 seconds, according to the docs. Are you sure that the remote host's SSL is up and functioning? Can you telnet into port 443 (or whichever port it is listening on)? If it's timing out after 180 seconds, you could be firewalled out, or something more problematic is occurring. 
I have loop 8 servers . It works fine when I put one server . But when I try to get the report from 8 servers . I get this error.
Hi, perlancar. These are respectful tools. But my experience using them teaches me is they are about unit testing, which deals with objects, functions and modules and is very close to cpan distrubituion itself. All this is fine. But if you try to use the same stack for black box testing , the most essential features of this tool chain probably does not help you much and becomes unutilized. Imho, of course ))) 
If you want short, I'd echo the suggestion below to use [Import::Base](https://metacpan.org/pod/Import::Base), but it's also worth mentioning that you can specify a version number with `feature` to import all features from that versions... so for example use feature ':5.10'; Will give you both `say` and `state`,as well as `switch` (aka `given/when`) but will issue warnings if you use it. Personally, I have configured vim to insert the shebang and pragmas automatically when I open a new `*.pl` file. autocmd BufNewFile *.pl exec ":normal i#!/usr/bin/env perl\n\nuse v5.24;\nuse warnings;\n" | exe "norm! o" 
I think I'm going to try this. Sounds like an admirable project.
If you read the documentation of Test::Builder, Test::More, Test, nowhere do they mention the term "unit testing", except when mentioning Test::Unit. They are meant to be generic testing tool. True, you write the test code in Perl and you need to install perl to use the modules. But basically what they provide is something like: is($whatever, $expected, $test_name); and a bunch of similar clauses which are close to as generic as can be. $whatever can be... whatever. The protocol is even named "Test *Anything* Protocol". My point is you can build higher level tools using the Perl testing framework. Of course, you are also free to reimplement the wheels :)
&gt; If you read the documentation of Test::Builder, Test::More, Test, nowhere do they mention the term "unit testing", except when mentioning Test::Unit. I did, and used Test::More, prove, TAP a lot. A unit testing is not about a tool but about testing approach where you focus on certain things you test. Well, _usually_ people use Test::More/prove to write test for their CPAN distributions. These are ( supposed to be ) fast, light, pretty isolated tests for a small piece of software ( modules , functions, methods, objects ) and as I told it's OK to use a mentioned stack for that, indeed it does such a testing in a great manner! But when comes to black box testing or integration testing I would not say (IMHO) that prove/Test::More is a finest choice for this, at least we can think about alternatives here ... Think about this quite common situation. You need to up a web server or web application, you need to install dependencies, you need to up a database, you need to create some files or populate databases, you need to send some http requests against ( and there are some real http resources , no mock ups ). Well, something a bit more complicated than "locally" test code for your CPAN distribution. And people can use a quite common things for this - like bash/sh scripts or perl scripts or ruby scripts or whatever scripts. I would say that Sparrow/Outthentic is a script oriented tool, when one could easily run some scripts and handle results, while prove / Test Harness limitation is one test for single t/*.t file ( which is I treat as goodness for unit testing ). But when we want to get a level higher ( integration testing ) I'd like to have a bunch of scripts to bootstrap / test my application where Prove / Test Harness (IMHO) is not very comfortable way to go. 
&gt; The threads are needed to make the bot read from Twitter at the same time that it’s connected to IRC, so that neither process is blocked by the other. This is not a good start. Aside from the fact that threads in Perl 5 are extremely inefficient and threads in general are quite complicated to avoid breaking everything, it's just unnecessary for this. All of the popular IRC interface libraries ([POE::Component::IRC](https://metacpan.org/pod/POE::Component::IRC), [Net::Async::IRC](https://metacpan.org/pod/Net::Async::IRC), [Mojo::IRC](https://metacpan.org/pod/Mojo::IRC), and even whatever AnyEvent has) are event-loop based so interacting with IRC will not block the program. Interacting with Twitter is done via HTTP, and there are similar event-loop based non-blocking HTTP clients for each event loop. I have a non-blocking twitter client based on Mojo::UserAgent called [Mojo::WebService::Twitter](https://metacpan.org/pod/Mojo::WebService::Twitter), which is rather spartan just to suit my own needs (though if you want anything added just open an issue and I'll see what I can do), but I hear that the new [Twitter::API](https://metacpan.org/pod/Twitter::API) redesign of Net::Twitter will support non-blocking API access as well.
This is a good practice when developing for yourself, but one also should keep in mind this will prevent the code from running on any lower version of perl (even if the features were available there).
Thanks, I'll write another tutorial soon using some of those libraries you mentioned and see if I can improve the bot a little bit.
I have used the Perl testing framework for purposes other than Perl distro tests, e.g. smoke tests, or website monitoring. It works pretty well. You can do HTTP requests e.g. using WWW::Mechanize then check the results using Test::More's like($mech-&gt;content, $some_regexp) or use Test::HTML::Content. Or check its DOM with Mojo::DOM. Or, use Test::HTTP. Similar with databases or other tasks. Just do whatever you need to do, then check the results with some test clauses. The test framework's job is collecting those tests and summarizing the result. The tests can be parallelized. The tests can be given timeout. The test scripts don't have to reside in t/*.t, it can be anywhere, even on remote servers if you want.
Hi! Probably I was not accurate in my last comment. But let me say again what I mean. I never say sparrow instead of Perl. If you look at sparrow docs you will see that sparrow is a cpan module , written on Perl. For end user sparrow exposes an API when one can write any code on Perl, Bash or Ruby. You are free to choose any cpan modules you like, as well as you listed at your comment. But what makes the difference that sparrow is script oriented tool, when you can orchestrate a bunch of scripts ( stories ) written on one of languages I told here. By orchestration I mean some out of the box configuration facilities , built in DSL to test scripts stdout and ability of calling one scripts from others with parameters and then handle script exit code and results. This makes it easy to build a complex system splited by simple scripts. Well when come back to prove you can't call one test from another , say you have a foo.t and bar.t - they always get executed independently, there is no by design way to reuse or call one test from another. it's ok, as one could use conventional methods for code reuse - Perl libraries ( modules ). And even more - for unit tests such an isolation is good. But sparrow makes it possible to go both methods - 1) scripts reuse on a higher level 2) modules reuse ( inside scripts ). Regards and HTH.
I think we had a good discussion, when I unveiled some sparrow design ( with your help ) and even tried to compare with the `prove` ))) and as I told `prove` is fine, but there's sparrow as well, which at least I find useful , hope some others too. Thanks ))))
For those of us using mobile, maybe link to the changelog instead of directly to the binary? Took me a while to figure out what was going on. 
At least you're not bitter!
Something like 85% of posts here are from a bot posting various perl blogs, which I (and apparently most besides you, who must be the one downvoting the posts as soon as they're posted) enjoy, even though I'm a perl5 developer. Don't like it? Post something. It's not spam, it's relevant, and it's even in the sidebar: &gt;The Perl Programming Language, **including both Perl 5 and Perl 6**. Want to learn Perl? See Perl Tutorials for great links! Want coding help? Asking at PerlMonks or Stack Overflow may give faster assistance. Keep up to date with Perl news by subscribing to Perl Weekly. Code of Conduct: Be civil or be banned. Anonymity is OK. Dissent is OK. Being rude is not OK. 
https://metacpan.org/pod/release/XSAWYERX/perl-5.25.8/pod/perldelta.pod
&gt; It's not spam, it's relevant, and it's even in the sidebar: &gt; The Perl Programming Language, including both Perl 5 and Perl 6. While this is true, I do sometimes wonder why Rakudo has the subs /r/perl6 and /r/perl. Why does it need both?
Perl 5 and Perl 6 have common heritage, many common devs, and a fairly common userbase. Why the hate? That's some fanboi level shit right there.
It's setting both `$outLine[13]` and `$outLine[14]` to the first 5 characters of `$outLine[7]` (if `$outLine[7]` contains at least 5 characters) Perhaps it may help to see it written like so if (length $outLine[7] &gt;= 5) { $outLine[14] = substr $outLine[7], 0, 5; $outLine[13] = $outLine[14] } 
 $outLine[13]=$outLine[14]=$1 if $outLine[7]=~/(.{5})/;} That trailing } doesn't belong here. It looks like you have included the end of a block but not the start :) Ignoring the }, what the line will do is set both $outLine[13] and $outLine[14] to the first 5 characters of $outline[7] if and only if there are 5 characters in $outline[7]. If $outline[7] is shorter, then both $outLine[13] and $outLine[14] remain unchanged. $x = $y = $z; is just shorthand for $y = $z; $x = $y;
You need {} around the second line to make it a block.
It's been a long while since I did Perl on Windows, but last time I did Strawberry had overtaken AS as the nicer experience. Installing CPAN modules with cpanm (I would assume) was remarkably smooth. There are no syntax differences, the big thing is how CPAN modules are installed, and that Strawberry Perl has a C compiler bundled with it to make that work.
So you can make sure the density plots match what it says in the intro to probabilities book?
&gt; Something like 85% of posts here are from a bot posting various perl blogs, This continuous flow is nevertheless a bit of an annoyance. I mean, look at the number of average comments, it is close to zero, and those bot posts swamp the 'interactive' ones. As far as Perl 6 is concerned, I think there are too many Perl 6 posts here too. There is a decent /r/Perl6 sub. What's the point of having all those Perl 6 posts here? I mean, an occasional post once in a while, for major events or when someone asks a more or less on topic question, is not a problem, it is even a good thing, but that's too many at the moment. Why isn't /r/Perl6 even mentioned in the side banner of /r/perl? It would 'advertise' for that sub and it could at least tell that /r/Perl6 is the *preferred* subreddit for... well, you know... Perl 6, which would just be plain logic.
I don't mind if the question is discussed, but this is not a discussion, this is an outright attack.
You might wanna roll with something like Dist::Zilla to get a basic dist structure, or at least look at stuff like this to get an idea of what conventional directory structure in a perl dist is: https://metacpan.org/source/MITHALDU/Perl-Tidy-Komodo-1.151340 It'll help the ecosystem handle your code much easier. :)
In which way this article fails to point that out? I admit that I knew what @INC was before reading it, so maybe I am missing something, but I think that it says exactly the same as you did.
Some curious fact is that until very recently no one that I know of frowned upon having the current directory "." in @INC by default. Since several weeks, Debian is removing it from @INC for security reasons. I wonder why this has not been exploited more in the past.
Yeah I think I got the gist of it in my response (surprisingly since it's been a long while since I did anything in perl) but the article talks about which perl directives use @INC.
It would at least be somewhere to point the grouches who are triggered by the mere mention of Perl&amp;#160;6. (A safe space…?)
I think the most relevant functionality if you already know Python is that you can replace complex command line oneliners using cut, tr, awk, sed and grep with some inline perl. This then can evolve into a script that's easier to grow and maintain than bash or awk/sed, as a there is a larger language + CPAN behind it. Python can't really get that experience without a change to significant white space. But you can make the same argument for Ruby or even PHP at this point. Perl is perhaps slightly more ubiquitous especially on older systems.
I hate to ask, but why would you try? Sadly, language bigotry is a thing and if someone's that hung up on it, I usually find that talking to them is not worth the trouble.
Pick a simple task and let them script it in python and you do it in perl. A little friendly competition. Allow that 3rd party modules are permitted. Go to CPAN, and your work is nearly done. 
I pick languages because of functionality and local adoption. Most people in my department are transitioning from IDL/MatLab to Python/NumPy/SciPy. Most of the Python usage is related to postprocessing. Fortran is used for the heavy lifting / numerical processing / parallel computing. I still use Perl for automation, parsing and creating massive text files. But I wouldn't feel comfortable pressuring anyone to switch to Perl.
Run a perlscript through perltidy then, and show them that :)
I wouldn't pressure anyone into using any language. But I'm getting a bit fed up of the 'anti-perl' snobbery from various quarters. 
Well, they're probably just anti-perl snobs, and there's no way around it. But for my money: - perltidy - especially when you add an outer loop to a block, and can just re-flow. - Object oriented code (perl does that just fine) - Threading or forking - perl does both, and IME much better than Python. (I wouldn't recommend both concurrently, as it's a can of worms - but it does actually work). - Functional programming techniques in perl (closures, callbacks, list comprehensions via map, grep and reduce). - Natively functions like most of the 'shell tools' - awk/grep/sed - but can extend them in 'full code' sorts of ways. #!/usr/bin/perl use warnings; use strict; my %replace = ( 'this' =&gt; 'that', 'first' =&gt; 'last' ); my $search = join ("|", keys %replace ); $search = qr/\b($search)\b/; while ( &lt;&gt; ) { $str =~ s/$search/$replace{$1}/g; print; } - Implicit variables are another way of writing code, and in some cases that makes things clearer: s/[\r\n]+$// for @list; #yes, it's a bit like chomp. But it works on Windows too. - just `map`, in general. That's before you get onto the numerous modules out there - python has a pretty good collection too. But I think I'd still dig up `XML::Twig` for parsing XML, which is something I've found highly unsatisfactory in Python. 
&gt; But I'm getting a bit fed up of the 'anti-perl' snobbery from various quarters. It's been around for the 20+ years I've been using Perl, I don't expect it to go away any time soon. :)
have you tried ansible? it has both a script module and a command module for this. If you insist on using Perl, I've done one similar using Expect. use Expect; use Net::Ping; my $host=$ARGV[0]; my $userprompt='USERPROMPT#'; my $rootprompt='ROOTPROMPT#'; my $timeout=10000; my $notimeout=undef; my $INFILE="$ARGV[1]"; my $LOGFILE="/var/tmp/biff.log"; my $command = Expect-&gt;spawn("ssh -q -o StrictHostKeyChecking=no -l $user $host") || die "Unable to start: $!"; $command-&gt;log_file($LOGFILE); ... some stuff where i do sudo and set my prompt ... while(&lt;Fp&gt;){ my $line=$_; print Op "$line"; print $command "$line"; $command-&gt;expect($notimeout, "$rootprompt"); } print $command "exit\n"; print Op "exit\n"; .... 
Just an intellectual exercise. 
Whoah!
This doesn't really show Perl having a benefit over Python, if I read correctly. 
Hi Perlancar! Sure. ))
I use both languages, probably more Python. It depends what you're trying to sell them on. I'll give you a few random things that I like about Perl and miss when I'm programming in Python. As a command line utility `perl` is generally more flexible than a chain of `awk`s, `grep`s, `sed`, and `tr`s. For instance here is uppercasing the first word. I like to write `print` explicitly so it's easier to go back and add an `if &lt;...&gt;` or `unless &lt;...&gt;` at the end but that's just me command | perl -ne 's/(\w+)/uc($1)/e; print' Here's a quick example of something useless you might do with that snippet (uppercasing the first contiguous group of file permissions characters). ls -al | perl -ne 's/(\w+)/uc($1)/e; print' | awk '{print $1}' | head -n 5 TOTAL DRWXR-xr-x DRWXR-xr-x+ DRWXR-xr-x -RW-r--r-- The only times I use `python` on the command line are `python -m json.tool`and `python -m SimpleHTTPServer`, but I guess ad-hoc command line stuff isn't its niche. For larger programs, one killer perl feature for me is regex interpolation: `$regex = qr/[&lt;]\w+[ ]?[\/][&gt;]/;` my `$bigger_regex = /some_fixed_word: $regex/;`. I think in Perl it's also flag-preserving, but I'm not positive. I haven't found anything equivalent to `Data::Dumper` in Python yet, but that could just be my ignorance. There are a lot of times I want an abstraction-breaking way to print an object for debugging / figuring out how a library works with some sane limits on number of items / recursion depth.
That's true until it's not. It can pay well for a while to maintain legacy systems, but those systems will most likely be gone before your career is over.
R is the bane of my life. Its default mode is to suck everything into memory... then do something. Works most of the time ... but we deal on large data-sets and my users only know one hammer :-(
Just read a little about `mclapply`, does that help for limiting memory consumption?
&gt; Object oriented code (perl does that just fine) My sense is that Python has better OOP capability. &gt; Functional programming techniques in perl (closures, callbacks, list comprehensions via map, grep and reduce). But Perl would be better here, especially when I want to do Unix-y type functions/piping. 
It's not that tricky to convert most Perl programs/scripts into Python....with a few exceptions of course. 
Mutli-line regexps with comments thanks to `/x` Use of `my` to declare variables rather than Python's crazy 'naming a variable creates it' style. More than one occasion I've had stupid typos or assumptions about a `variable_name` actually being called `variablename` make my python code behave really weirdly. "lambda functions" without special syntax. It's just an anonymous `sub`, people! I think they might be interested in seeing modern perl web frameworks like Dancer2, and how PSGI works. Not heavily into Python so don't really know if there's anything else I'd miss.
&gt; I also did not know that the If Statement put something in the $1 Just to be clear, that's due to the parens in the regex so it doesn't have to be an `if` statement: $_ = 'some text'; # $_ is like the English word "topic" /(.)/; # runs regex against the current topic print $1; # prints 's' Happy holidays.
I agree with the multiline regexps. With regards to the other points you mention, I don' t know if those are really that big of a deal, but everyone's different in this regard of course. 
I'm wondering what the most common conversion path (to borrow a sales term) is for new Perl users. Python was the first language I learned way back in high school ... and I learned Perl soon after that, mostly because the official documentation was entertaining. I found that it had some cool features like optional dynamic scope and explicit symbol manipulation through typeglobs that didn't have direct equivalents in other languages. It also gave you explicit control over references, which Python did not. I'm not sure what the long term health of the language is. I haven't met many people early in their careers who like Perl. Most of them have a superficial awareness of it though. Most have heard the "write-only language" or "line noise" quips or know that Perl uses sigils.
Go to PyPI and your job is 3x more likely to be nearly done than CPAN. This needs to stop being touted as a perl specific strength, younger newer developers expect even a language created last year to have thousands of modules. NPM has a disgusting number of modules because everyone in JS land writes a single if and packages it.
I think thats great though. Youre using multiple languages for their strengths. Pressuring someone to parse and clean up data in FORTRAN is equally lame.
&gt; relevance You make good points. I would suggest caution about "relevance", though. Academia itself struggles for relevance, despite what its brochures say. Academia is a bubble within a bubble. And to the OP: let's not be drawn into discussion with zealots. Waste of time. "More Jobs" is an important measure, but it isn't the only realistic measure. The opinionated Python-only developer despises any code that doesn't look like Python. That's 100s of millions of lines of **revelant** code keeping our world running. Python zealots live in an echo chamber. Perl is irrelevant to a "Java-only", "Python-only", or "L-only" (where L is a coding-language other than Perl) coder or teacher. I doubt that this kind of thinking can change, OP. Schools teach skills (maybe); Work teaches experience. An L{1} coder's relevance is artificial and is something of a zealot's handicap. Python is far from being the only game in town. It will never be the only game in town. Python has flaws and its opinions are not universally accepted. Perl's origins are in fact a noticeable *strength* for the L{2,} coder. Perl is everywhere, but it also has enough similarity to its influences that it is an advantage to know Perl for work in a Linux environment (e.g. C, C++, sed-awk-grep). Linux isn't going away. Perl isn't going away. (Well, I think C of all languages will be the only survivor 100 years from now. If it turns out to be Javascript, I will be glad to be dead. If that's possible.) Knowing only Python leaves an L{1} coder inexperienced in number of relevant languages that the L{1} coder can't be arsed to understand without Market Coercion ("layoffs"). These other languages and tools are not going to be replaced by Python. One could argue that Linux (and C, C++, awk, sed, bash) is a legacy design, just like Perl. But that legacy design is **more relevant than ever**. Knowing only one language is zealotry and/or stupidity; knowing relevant languages is exponential knowledge. Calling anything outside of one's definition of self "irrelevant" is a telling statement of limitation. 
["You're confusing me."](https://www.reddit.com/r/perl6/comments/4ud7vc/a_python_guy_in_perl_6_object_land/)
Sorry I couldn't let this go. Python is libertarianism? The entire ethos is "do it this way" to the point where they don't let you do it any other way. Consider this post from Guido about why Python doesn't support Tail Recursion Elimination (which Perl of course does) basically because he doesn't like it http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html . If anything Perl is the libertarian ideal (why shouldn't you be able to do it if it doesn't hurt anyone else) while Python is a dictatorship.
"Tommen" and "Rakudo" have the same number of letters in their names, and they're about the same age (depending on how you count, either 9 or 16). Totally works!
I'm keeping the options open. Feel free to discuss aspects of both. 
Perl: Unbowed, Unbent, Unbroken
Does R have good tools for partitioning datasets or sampling without reading the whole thing into memory or does that generally require another tool?
&gt; I'm wondering what the most common conversion path (to borrow a sales term) is for new Perl users. There are certain areas of the academia where Perl is still heavily used. To be honest, that's how I came across it, after using Python for years---I needed to collaborate with a colleague.
Haha, yes, thank you. :)
A mod suggests I refer readers to /r/perl6.
Re: features coming with core. I can certainly tell you which CPAN modules to use as a "standard" for each task and they would work just as well as python's core experience, but the fact that you have to have this much experience to know this is a problem to start with, and I'm not sure how to solve it. Adding the "preferred" modules to core seems like a solution, but right now there is a strong penchant for keeping things out of core which are not strictly necessary, to avoid going down the PHP path of including (and thus implicitly sanctioning) a gamut of random modules that may or may not be favorable to recommend anymore, such as with CGI which was recently removed from core. Inevitably some of the modules that were added fall out of favor or maintenance and have to be replaced. The other option is to have some way for people to find from a search which modules are preferred. Metacpan has ++ and there's a cpanratings website with reviews, but both of those systems have flaws (just see File::Slurp vs File::Slurper (preferred) for a failing of the metacpan system, and any number of modules with undeserving bad reviews of old versions on cpanratings).
You are right that the first match found (when iterating from left to right) takes precedence regardless of length. The greedy (default) or non-greedy (? applied to a modifier) match determines whether each component of the pattern will match as much or as little as possible while still allowing the full pattern to match. The regex engine will backtrack until it finds a combination that matches the full regex, but it won't backtrack to find a shorter or longer match if it already successfully matched; I don't know of any way to get the behavior you describe directly.
Nice!
&gt; your job will be maintaining an old codebase instead of developing new stuff Is this a problem/undesirable?
Sure: #!/usr/bin/python fns = [] for n in [1,2,3,4]: print(n) def fn(): print(n) fns.append(fn) for fn in fns: fn() And: #!/usr/bin/perl use strict; my @fns; for my $n (1,2,3,4) { print "$n\n"; my $fn = sub { print "$n\n"; }; push @fns, $fn; } for my $fn (@fns) { $fn-&gt;(); } 
Why are you linking this rant today? * This is super old. * The method was undocumented. If you're going to use an undocumented, private, or internal method you should probably not expect consistent behavior forever. * The breaking change was documented. Breaking changes happen sometimes. * The test caught the error. Good job, test writer. * "Left shifting" in arbitrary bases is mixing a programming metaphor with a mathematical metaphor and is in general total nonsense. Had it been up to me, I would have removed the methods entirely. As it is none of this matters anyway because the change was reverted and the methods were documented. Problem over.
Taking a step back what I'm really trying to do is tokenize a string and for that I want the ability to say "starting at this offset, find the length of the next token satisfying this definition or fail and return -1". For this specific use case I tend to use reluctant quantifiers everywhere (except for whitespace). There's probably a more idiomatic way to do that.
You might well think that. And you would find yourself surprised. FORTRAN and COBOL are growing.
I have no horse in this race, but I find your comment overly defensive and dismissive of a valid problem. * I hadn't seen it before. Thanks OP. * It is documented. [Even in this old version of the POD.] (https://metacpan.org/pod/release/TELS/Math-BigInt-1.87/lib/Math/BigInt.pm#blsft) If the exact logic has not been documented, then the code itself becomes documentation of the algorithm applied. Changing it is only going to surprise and inconvenience people. * Breaking changes should be handled with a new method name or at the very least a very loud deprecation warning over *multiple releases*. If modules can silently change their behaviour at any time, given the huge number of dependencies in a typical project, it becomes incredibly risky to keep those modules up to date. Luckily most maintainers are competent, and this doesn't happen. * That doesn't change anything. * It was useful to somebody, and it's the author's problem for including it in the module to begin with. As you say, removing the function altogether would at least prevent silent breakage of user code. The change being reverted doesn't excuse the maintainer for his or her irresponsible and worrying decision, or the wishy-washy defense of it, both of which would make me hesitant to use that module in the future.
I've actually never seen anyone in Python put a function inside a for statement, myself.... Is this common for certain situations? And regarding the Perl script, it would have the exact same behavior as the Python script if there wasn't `use strict;`, correct? 
&gt; Breaking changes should be handled with a new method name Full stop, I would say. We've been going through a spate of programmers who should know better just shrugging off backwards compatibility. It appears there's never going to be a time when we can stop talking about the issue, there's always going to be someone who hasn't gotten it yet. 
I use regular q{ or q{{ blocks with newlines inside, you can indent it however you like. But this feature seems great when whitespace in the string is important.
Python has a flag for "verbose" regular expressions: https://docs.python.org/3/library/re.html#re.X
 #!/usr/bin/env python3 from re import sub, escape from sys import stdin, stdout changes = { "this": "that", "first": "last" } needles = r"\b({})\b".format("|".join(map(escape, changes.keys()))) for line in stdin: stdout.write(sub(needles, lambda m: changes[m.group(0)], line)) 
&gt; Is this common for certain situations? Absolutely not. In the last 15 years of professional Python programming I never had to do that once. And I never see anything like that in other people's code. I can't tell about Perl but, python-wise, it's a bad example. You can find even worse programming pattern, but the simple fact that you can do that doesn't mean that you have to. 
Python has built-in regular expressions (the `re` module, which is part of Python). Sure, you need an import instead having built-in /foo/ literals, but `re` is guaranteed to exist in an install. And there are style checkers for Python. *(I was brought here by /r/Python; some people may consider this brigading or whatever, but that’s plain stupid)*
I would imagine it's not done in python for the illustrated reason. I don't really speak much python, but imagine some perl where you have a thing that has a bunch of behaviour required to exhibit in different places in the code (e.g. during assembly, immediately after assembly and after job completion) - warning, contrived incomplete example. sub do_this_thing { my ($self, $args) = @_; my %result = ( outcome1 =&gt; { user_message =&gt; $args-&gt;{user_message}, diagnostic =&gt; $args-&gt;{diag}, post_completion_action =&gt; sub { # do stuff with args here ... }, outcome2 =&gt; { # etc }, }, ); # gather the result early my $result = $object-&gt;do_this_thing(\%args); # much later $result-&gt;diagnostic-&gt;(); All of your complicated behaviour is in one place, and you haven't had to mess with internal-only objects and other boilerplate to achieve that because closure scope is giving you a lot of stuff for free. Yeah sure you can make messes with this. One advantage of bad perl is that bad perl is quickly obvious. Bad python takes time to discover due to the uniformity.
hey, are you the author of the article? I really enjoy reading your articles, they are really well done and they helped me improve my Perl skills; I just want to say thank you and keep up the good work!
Given that u/zhouzhen1 wrote that they'd used Python for years I'd be shocked if they weren't familiar with `re`. I had thought that Python's built in `re` regex feature was at least 5 if not 10 years behind Python's alternate regex library `regex` and that the latter is significantly behind where Perl 5's regex engines are in terms of both performance and features. Is this incorrect?
&gt; Absolutely not. It is more restricted and thus mildly easier to reason about, but from the standpoint of a user, its OO DSL capabilities are in baby shoes and completely outclassed by any Moose-like. Care to elaborate on this, I'm aware that perl is in general better at writing DSLs than python is, but what specifically do you get in perl's OO DSL that you *don't* in python?
tl;dr: Never ever write an `__init__`, setter or getter ever again. On a very high level: In Moose-likes attributes defined in classes are single units of data encapsulating all the behaviors attached to them, i.e. an attribute comprises: - what code to run on object creation - what code to run on setting, and under which method, or whether there's a setter - type checking, coercion, special behaviors like lazy attribute handling, tracking of "has been set", defaults, builder methods, etc. for the two above, and more - what code to run on getting, and under which method, and whether there's a getter - what methods OTHER behavior related to attributes fall under (e.g. has_x for checking if an attr had been set, or clear_x) - more stuff i forgot In short, in Moose-likes the very attributes themselves (not their data) are objects belonging to a class object, and can be handled like other objects. These units of data are declared with concise calls, like: has x_val =&gt; is =&gt; 'lazy', isa =&gt; PositiveInt, builder =&gt; sub { my ( $self ) = @_; return $self-&gt;y_val * 10; }; And can be modified with calls like: has +x_val =&gt; isa =&gt; PositiveOrZeroInt; Meaning it is easy to change a single attribute's setup without having to jump around between all the various points in a class where init, getter and setters are implemented. They can also be encapsulated in roles: package My::Role; use Moo::Role; has x_val =&gt; is =&gt; 'lazy', isa =&gt; PositiveInt, builder =&gt; sub { my ( $self ) = @_; return $self-&gt;y_val * 10; }; And reused in many classes: package My::Class; use Moo; with 'My::Role'; # now My::Class has the *attribute* x_val, # and can use `has +x_val` to modify it further Under the hood all of this works with primitives that are almost exactly the same as in Python, and all of those are still accessible anytime. But as far as i know there is nothing in Python that provides a hood, gauges, levers and ornaments even approaching this.
It is certainly quite possible for people new to Perl to write large abominations of write-only scripts, I know I have done so when starting out. But any experienced perl programmer will not do so (unless they're a contractor looking for job security). Modularizing a program is the easiest way to make it maintainable and there are lots of great tools on CPAN that can help make your code simpler to read and maintain. That said there will always be "idioms" and other perlisms which people unfamiliar with the language will call "line noise" regardless of how clean they are. But every language has these, there is plenty of python code that I won't understand at first glance because I don't know the language and syntax, but that just means I should learn it.
As an intellectual exercise, it's quite interesting to compare the tone of the comments here vs the thread posted on the python subreddit.
&gt;But as far as i know there is nothing in Python that provides a hood, gauges, levers and ornaments even approaching this. This sounds a lot like what metaclasses, accessors, and mixins/multiple inheritance can provide. Metaclasses allow customization of class initialization (python3's [Enum](https://docs.python.org/3/library/enum.html) is created with a metaclass) to an extreme degree, such that methods and fields can be injected and modified at will and programmatically, accessors (most notably the @property decorator) allow the creation of getters and setters (and combined with metaclasses, you can programatically provide getters and setters for every field if you wanted, and stuff like [attrs](https://attrs.readthedocs.io/en/stable/why.html#hand-written-classes) can create most of the boilerplate and do [validation](https://attrs.readthedocs.io/en/stable/examples.html#validators), much like what I see here. And of course multiple inheritance just means this can all be reused as mixin classes as you wish. Edit: I should add, all of this is an "I think", I got a bit lost in some of your syntax, but I think I understood the main ideas (that fields/attributes can be defined with types and used across classes).
I find those documentations quite hard to read. That said, i did not see anything there that currently does provide setters or getters. And the linked validation only applies on construction or manually triggered (i assume to be used in hand-crafted accessors). attrs also does not provide simple things like having constructor arguments be required or optional. The point about the Moose-likes is that they're a batteries-included OO system that covers the full spectrum. It's not just about the *idea* of having first class attributes, but also going whole hog with it and saving the developer not just tens of lines of repetition, but hundreds and thousands. Also, if you and i are thinking of the same "multiple inheritance", then it is entirely orthogonal to roles. With roles no diamond problem ever happens. Try reading: https://metacpan.org/pod/distribution/Moose/lib/Moose/Manual/Attributes.pod Also, to repeat my tl;dr, this is absolutely paramount, and unless you're exactly there, you're not there: Never ever write an `__init__`, setter or getter ever again.
&gt;I find those documentations quite hard to read. That said, i did not see anything there that currently does provide setters or getters. And the linked validation only applies on construction or manually triggered (i assume to be used in hand-crafted accessors). attrs also does not provide simple things like having constructor arguments be required or optional. Well, you're assuming that getters and setters are common. Python doesn't use them except when necessary. I've maybe written 2 getters and setters, ever, in years of writing python, maybe. And unless I'm misunderstanding, you do still need to write those getters and setters, you just write them per-attribute, not per class. Which is only helpful if you are reusing fields across objects? &gt;Also, if you and i are thinking of the same "multiple inheritance", then it is entirely orthogonal to roles. With roles no diamond problem ever happens. I'm speaking of mixin-based multiple inheritance, which is to say I can define a class in Python class Serializeable: def serialize(self): for attr in self.__dict__: ... Then another class, person: class Person(Serializable): pass This person class has the serialize method defined on it that, if written correctly, will work on a person just as well as on any other thing. I've yet to find anything in the Moose docs you linked that I couldn't do in python (in a manner like the attrs library I linked would, although I might define a different API), but my main question is 'why'. Python intentionally didn't include access control in its OOP system and much of the other things you've listed here aren't any less verbose, they're just moving things around (field initialization out of `__init__` and into the object's declaration itself). By the above, I mean that I could hack the following to work in python: from moose import MooseLike, attr, extend def set_weight(...): ... class Person(MooseLike): weight = attr(access='ro', writer=set_weight) name = attr(access='ro', required=True) size = attr(access='ro', default='medium', predicate='has_size') def _build_size(...): ... class Lilliputian(Person): size = attr(builder=_build_size, extends=True) # this last bit probably isn't even necessary That highly resembles the Moose code, but I guess, I don't feel like I'm missing any of this functionality. I enjoy not having to deal with public/private, and enjoy not needed to define setters and getters, even autogenerated ones, except when it actually matters. Am I missing something here?
Someone asked me to share my shell script I use to install plenv on all the things. I can't remember who asked me where, but here it is any way! 
They are going to remove the few functional features they had, so perl programs will need significant refactoring. 
Perl's regular expressions are jokingly called "irregular expressions" because they are way more powerful than what's offered in any other language. Perl's re are actually grammars, they can do way more than what Python's re can.
The recommended solution for anyone using the . in @INC is to add it back in the program in a BEGIN {} phaser.
&gt; I don't feel like I'm missing any of this functionality. [...] Am I missing something here? A little short on time, so: Yes, you are. It's a chicken/egg problem. You've never worked in a fully-featured OO system, so you're unaware of just how many features are offered in Moose, and you have various disparate systems in python (attrs, @property) that can be individually bolted on to paper over the most egregiously lacking things. Additionally, due to attribute features in Python being so lacking, they provide you with little use, so you end up, as you say, not using getters/setters, as you can tie magic behavior to cover a handful of things to the direct data accesses themselves. (Something Perl also had in wide use for a while, but ran away from screaming fairly quickly.) I linked the Moose attribute docs to help you see just how *many* features there are, but i guess it is a little overwhelming to fully make sense at a glance. You run into an 80:20 problem. You can imagine how to solve 20% of the issue, but haven't fully understood the 80%, so it appears to you as if the problem were fully solved. Just to give an example of a deep feature you don't seem to have mentioned yet: Are you aware of "lazy" attributes? (I've also not even mentioned method modifiers yet, which are decorators on steroids.) Some random bits and bobs: &gt; And unless I'm misunderstanding, you do still need to write those getters and setters What do you mean with "write" exactly? &gt; mixin-based multiple inheritance How is this different from sub-classing? With roles the list of super classes of a class is completely separate from the list of roles composed into it. They're different mechanisms, as the role is composed into the class at compile time, and no look-ups into the role itself happen at runtime. &gt; `code` In Moose any method names given in attr declaration are strings, embedded as literals into generated code, and are resolved through inheritance at runtime, which leads to slightly different behavior from what your example shows. Not sure what extends on an attribute would do, as in Moose it's the call you make to declare a super class of the current one. `has_size` and `_build_size`: Ok, granted, on those i forgot that Moo.pm is much advanced over Moose.pm, as in Moo you can just go `builder =&gt; sub {}` to declare it directly, or `builder =&gt; 1` to have it auto-gen the method name, as well as ´predicate =&gt; 1`. In Moose you need to load a plugin to add that behavior. ( Said plugin: https://metacpan.org/pod/MooseX::AttributeShortcuts || Moo docs: https://metacpan.org/pod/Moo#has ) Your example doesn't have type-checking (which in Moose-likes fires on construct and set). 
Only thing I'm finding at a quick glance is [this talk](http://act.yapc.eu/ye2014/talk/5532) from YAPC::EU in 2014. Video [here on YouTube](https://www.youtube.com/watch?v=2XyPO6wt8oY). Very possible there are other things out there, as well. I might not be opposed to messing around a bit myself, seems like an interesting idea (and I was surprised to not see anything specifically related to it already on CPAN). EDIT - [This may be another place to start?](http://search.cpan.org/~skonno/Net-UPnP-1.4.3/lib/Net/UPnP.pm)
Yah I just got this chromecast audio and quickly did some searches for a usable media player for my personal files and everything is talking about dragging and dropping the file into a chrometab or uploading to google play. Don't wanna do that. Thx from some direction anyway.
Reference in `perldoc perlfunc`.
Now subscribed. i did not know that it made a difference. Only one to get 10k again!
Ah, ok. Thanks
ITYM `goto &amp;sub` though `goto EXPR` does do the same if EXPR is a code reference.
Watch Perl 6, though. I would be it's the next trendy language. It's picking up steam fast.
This is quite true, I agree. 
Python is taking out the few features they had of functional programming, even. It's becoming an even poorer language. Ruby never solved the problems people disliked about it. Perl6 solves the issues people had with Perl.
&gt; functools That's exactly what I mean, Python won't have first class functions.
While good to know in case you ever get passed some Perl 4 code, I think it should be strongly recommended not to ever do this except for in [silly modules](https://metacpan.org/pod/Acme::Don::t).
[removed]
They are also commonly used this way in Perl in my experience. It is an easy-to-follow alternative to having to pass contextual variables around.
snmpwalk output has probably changed in 12 years (and between different OSes). Your best bet would be to try it and then verify snmpwalk output matches what you expect. You'll likely need help scraping text output and modify some regular expressions. Good luck!
That's cool! I wonder how they gathered the data, impressive if it's entirely using crawler bot.
Cross-posted :)
I've used [Net::SNMP](http://search.cpan.org/~dtown/Net-SNMP-v6.0.1/lib/Net/SNMP.pm) CPAN module for over a decade. It has served me exceptionally well. It is a pure Perl module (last time I checked) and should run on any operating system. To me it is the vastly superior solution as it should remain portable as it does not depend on any external programs like `snmpwalk`.
Is there any current editor which can syntax-highlight this properly? My emacs' cperl-mode can handle `$foo'bar` but bleeds when I type `package Foo'Bar`.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/unexpectedfactorial] [\[\/r\/perl\] We broke 10k!](https://np.reddit.com/r/unexpectedfactorial/comments/5kv6tg/rperl_we_broke_10k/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
interesting, I should implement a don't macro in C
If you want to round numbers e.g. 2.4 to 2 or 2.6 to 3, see http://perldoc.perl.org/perlfaq4.html If you want to format 1048576 as "1 MB", try using the [Number::Format](https://metacpan.org/pod/Number::Format) module.
Or poetry.
what language/tool do you usually use regex in? sed? grep? worry not, from the basic stuffs, to recursive subpattern, to doing grammar/parsing in regex, to control verbs, perl regex will keep you busy :)
Be aware that the Mac filesystem is not case sensitive.
That works most of the time, except for a couple things: floating point errors can occasionally cause .5 to be rounded the wrong way, and that won't work properly for negative numbers. Conveniently, [Math::Round](https://metacpan.org/pod/Math::Round) handles these cases for you.
Do you have an example? 
 my $stuff; $stuff-&gt;[0] = 'foo'; # or alternatively push @$stuff, 'foo'; `$stuff` is undefined at first, but once you dereference it as an array reference with an attempt to assign values, it turns into an array reference, so the above examples "just work". (Same for using it as a hash reference.) I wouldn't exactly tout it as an amazing feature, as much as something that can be used to greatly simplify code but also something that perl programmers must be aware of. There is a pragma to [disable](https://metacpan.org/pod/autovivification) the functionality, because some may prefer to be more explicit in how they create data structures. Another example, perhaps more commonly encountered: my %hash; if (exists $hash{foo}[0]{bar}) { # now $hash{foo} has been created as an arrayref, # and $hash{foo}[0] has been created as an (empty) hashref }
 #define dont while(0)
I recommend Params::Validate
You can also look at Method::Signatures for some extra sugar. The module brings syntax for declaring methods and subroutines with a typed signature in the style of Perl 6. It isn't perfect for every use case but it is very nice if you are embracing Moose, Mouse or Moo.
Perl is a block structured language. C programmers and Perl go hand in hand. I use the former to create full systems as well as rapid prototyping. Anyone who complains about Perl as "write once" is reading crappy code. Just like crappy Python code. Or crappy C code. Period. Python is like programming in FORTRAN. Indentation? No stack/scoping? Python -- Visible Bugs in Invisible Whitespace. (Is it me or my text editor?) Python is for programmers who don't know any better and need all the help they can get. 
The origin of PVC has nothing to do with Type::Tiny. I wrote it for work after benchmarking found PV to a be a significant area where we were spending time. We were using Moose types at work but it wasn't much harder to support, Moose, Type::Tiny, and Specio.
I read a little about the module. I had no idea a non-anonymous subroutine could close over variables in the block where the definition physically is. { my $validator = &lt;...&gt;; sub func { my ($foo, $bar) = @_; } } I thought you needed some silly trick like *func = do { my $validator = &lt;...&gt;; sub { my ($foo, $bar) = @_; }; }; Is there an advantage to doing that over using a `state` variable? I suppose with a state variable initialization is deferred until the first time you use the function... that might be the only difference. Is it possible to generate a separate .pm file containing your validators as part of the build process so no dynamic code generation happens at runtime? `source_for` seems to generate a string and environment capable of being consumed by `Eval::Closure`. I'm not sure how hard it would be to wrap that up into a module-scoped function.
&gt; Is there an advantage to doing that over using a state variable? I suppose with a state variable initialization is deferred until the first time you use the function... that might be the only difference. That could well be an important difference depending on your use case. * If you're writing a persistent (e.g. web) app, you should probably precompile everything using a lexical to avoid uneven runtimes for the first request for a child process. * If you're writing a CLI app, delayed initialization is probably better. * If you're writing a CPAN module, I'm not sure but I'd lean towards eager init, and the caller can choose to delay loading of the module if that's important. (require or Module::Runtime::use_module)
I was only talking about the named params case: &gt; For named arguments, I tend to use: &gt; my %args = @_; &gt; Some people use hashref, but I dislike the extra {} pair. (having both positional and named params seems to bring little value over just using named params) 
Lazy load all the definitions and create a sub that loads all of them. Is it worth it though, when there are existing ways to deal with it, if it's an issue?
Hmm that seems easy to do if you're using an OO-interface (meaning that your module is organized around a single class that you're expected to instantiate *once* (not sure what that's called)). If you want a procedural interface though, it seems like the most straightforward way to do lazy loading would be with a `state` variable, but those have the unfortunate downside that there isn't an easy way to force their evaluation. I guess you could say that all your functions support being called with no arguments as a no-op and then make your loader function call the functions with no arguments, but that seems really, really ugly.
I would say that it is rather common in Perl to write functions that perform differently based on how arguments are passed, as long as the difference is explicitly distinguishable and documented. As a most basic example see object accessors which are commonly both setters and getters depending on whether a new value has been passed. Checking types of parameters is not much of a stretch beyond that, it is still possible to make this a very explicit difference. As an example of that, see https://metacpan.org/pod/Mojo::UserAgent::Transactor#tx which is the basis of the [Mojo::UserAgent](https://metacpan.org/pod/Mojo::UserAgent) get/post/etc methods, which interprets arguments differently mainly depending on where hashrefs occur.
I would recommend [Function::Parameters](https://metacpan.org/pod/Function::Parameters) as it uses the keyword API rather than Devel::Declare hackery, and also has experimental support for Moose types as well as custom type reifiers.
For complex things, i prefer using a hash for named arguments and assigning it in the sub like `my %params = @_;` then assigning each var from it like `my $var = $params{'var'}` (if it's going to be used multiple times or needs to be deleted from the hash like `my $var = delete $params{'var'}`) which allows you to have optional args or args which have a deep data structure as values. When using highly generic code that maybe involves variable sub names or dispatch tables or closures, this allows you to just add and delete things from the hash as you go through each sub just using @_ and inheriting vars along the way. It can obviously be a little dangerous in terms of stomping on variables or getting stuck in a loop when forgetting to delete something because hash assignment ordering is last-one-wins, but it really reduces a lot of the boilerplate variable assignment.
Yeah, I should remove that. It's stable enough at this point, I think. I may add more features but I don't think the existing API will change a lot.
If you're in an environment that forks child processes (like many web apps) then you want to compile the validator in the parent process. If you use `state` you'll likely compile it in each child, which wastes a bit of memory.
Yes. The source code is simply: sub indir ($where, Callable $what) is export { mkpath $where; temp $*CWD = chdir($where); $what() } It'd be nice if perl6 had [openat](http://man7.org/linux/man-pages/man2/open.2.html) so we didn't need the current directory anymore...
Perl 5 has File::chdir, but this is a nice interface too.
&gt; If you want a procedural interface though, it seems like the most straightforward way to do lazy loading would be with a state variable Wouldn't the most straightforward way simply be `require Foo` inside a sub or block? To allow eagerness (preload all delayed modules), there are various ways depending on the tools you use. You can use Dist::Zilla, for example. Or modules like [prefork](https://metacpan.org/pod/prefork) or something similar.
&gt; (having both positional and named params seems to bring little value over just using named params) It depends on your preference or situation. If 99% of the time you just use positional arguments, e.g.: my $path = module_path("Foo"); then only 1% of the time you want: my $paths = module_path({all =&gt; 1}, "Foo"); then it makes more sense than having to write this all of the time: my $path = module_path(module =&gt; "Foo", ...); 
Sweet, thanks! Might just have to install or migrate, getting tired of formatting the code myself.
Ohh, this is how experience differ. I'm programming Python professionally for only 3 years, but I met quite a lot of code written this style. I must admit my work is mostly patching open source code, may be you are used to better python code quality?
Except this routine is currently not part of Perl 6 language, as brian has been told on one of the tickets he filed. I don't know why he still went ahead and posted about it and even went as far as invite someone to test and document it.
[removed]
Sorry not `@attribute` but `@property`, had to much to drink yesterday :)
Are you talking about defining functions inside for loops? Do you really see that quite a lot?
Start every post from Marc Lehmann with a heavy heavy dose of skepticism.
Yeah, i don't know about the technical merits, but he entirely ignored the most important word in the definition of "griefing", when justifying his choice, which is "purposeful", while being aware he was doing it. Where i come from this kind of arguing is "trolling". Edit: Honestly curious why anyone would downvote this.
Then php what!?
I love the "irony" of him complaining about changes in the non published side of the api breaking code that depends on it, then his getting upset when Leonerd uses unpublished interfaces from Marc's code.
https://metacpan.org/source/MLEHMANN/AnyEvent-7.13/lib/AnyEvent.pm#L1439 This is him hardcoding a die into a module because he doesn't like it.
[removed]
[removed]
This is all well and good... but why are we talking about anything Perl 4 at all any more? We should be talking about modern Perl, and not mentioning the ugly past as it just confuses new users.
Is that backported Perl 6 declaration syntax to inside out objects in Perl 5?
I was wondering why this problem is still present, but then I realized this scheme is found everywhere: there are lots of environment variables that can be set to alter loading order like INC, PYTHONPATH, LD_LIBRARY_PATH, CLASSPATH, PATH...
The only discussion I've ever seen of it in /r/perl was [when I mentioned it 3 months ago](https://www.reddit.com/r/perl/comments/51iupx/so_its_been_a_while_since_i_touched_perl/d7cwefm/).
[removed]
Same question here. Is there an e version?
Does anyone know how extensive the section on grammars is?
TBH I am not yet fast enough to read a several hundred page book with extensive sections on anything "at a glance". (That's just me being picky about the name - it's probably a great manual)
Perl 5 libraries and modules have the same problem. The last thing to export symbols wins.
Heh, reminds me to finally release [this abomination of mine](https://twitter.com/tsosnierz/status/730859455898918912)
Looks more like JavaScript to me
I want generate declarations of variables in assembly language. I have a hash: they keys represent the variables' names. If the value is a number, I would like print "&lt;variable&gt; dq &lt;value&gt;", and if it is a string, I would like to print "variable db "&lt;value&gt;", 0".
I rarely care, but when I do, I would like to know in an elegant way, not using the workaround that I've mentioned in the post.
I want to do a simple thing: https://www.reddit.com/r/perl/comments/5ml0q3/perl_numeric_value_vs_string/dc4eea8/ I don't see why I should define my own types when I just want to distinguish between two basic types: numbers and strings
looks_like_number('1') and looks_like_number(1) both return true; I want to be able to distinguish between these 2 cases.
To what end is this? Is there a reason you have to use Perl? There are other similar languages that are more strongly typed. Perl usually doesn't care what type a value has when first referenced so long as it can be implicitly converted to whatever type it expects it to be when used in a function/whatever; this is deliberate and usually considered a feature. 
Ah, gotcha. Thanks. :)
I'm super-excited to be helping organize TPC 2017 in DC (in a parallel universe this would be YAPC::NA 2017)! A great conference needs a few important ingredients, and one of them is good talks! Please submit talks on any perl-programmer related topics, even far-flug things. I'm happy to help you brainstorm ideas if you would like to talk (especially if you've never given a talk before), just DM me!
Ok, thanks, this seems to be a good approach. I'll look into Perl's OOP, although it seems a little strange to be able to bless any scalarref into an object. My other thought was to have an array, for instance, where the first element would be the type and the second the value. But my main problem is that although Perl knows what type it stores in memory, it doesn't want to let us know. I guess it's just a limitation so that it can work transparently with strings and numbers.
Well, Perl is the best language that deals with regular expression and I need regular expressions in order to transform data from one format to another.
And why does xor behave differently if Perl doesn't care if it deals with numbers or strings? Isn't this an inconsistency?
[removed]
Thanks for the reply! I can't say that I have a real problem with not being able to clearly distinguish between strings and numbers, it's more of an annoyance. I'm glad I'm getting this much feedback, it's helping me understand Perl's internals a little better.
It's really nice to see the name YAPC fall by the wayside ... I vividly remember trying to persuade my aging professor that Yet Another Perl Conference was a serious event that would benefit the group if I attended. The Perl Conference sound so much more respectable. 
If you are using a dict of key=&gt;values and you need to know the type after the fact - why not expand on the structure a bit - say data = { key1 =&gt; { type =&gt; "string", value =&gt; "foo" } } - so each value is another hash with 2 keys; type and value, which dictate the behavoir for you.
YAPC was the affordable, community-driven alternative to the overpriced corporate TPC (which became OSCON the same year that YAPC started). So now that the cost of attending YAPC has gone up 10x and the community aspects have taken a backseat to revenue generation, sponsor exposure, and good marketing, I agree — the name change is appropriate. Maybe a little too spot-on, really.
Thanks, this would work. I guess there's no quicker way to do it, since I've understood now that Perl doesn't clearly differentiate between these 2 types.
Ok, that makes sense. Maybe they didn't fix this because of backwards compatibility issues.
Hi Scot, This program helped me and result is coming as expected and thank you.
Has the price gone up? I went to Munich 2002 and it was a £100 registration, Cluj 2016 was £120 I've never paid more than that. Accommodation has been variable with the city as has travel, normally ~£300-400 total. The difference I've seen is they have been able to drop the auction because they get sponsorship. Perhaps the other YAPC's have been different... 
Yes, for the first 10 years I was going, ::NA was between $85-100 early price and between $100-150 late price; now (and also last year) it's $250 early price, $350 late price. And it used to be the majority of people would stay in dorms for around $50/night, with a nearby hotel as an alternative; now the conference hotel runs $180/night *with* the discount.
Has the number of NA delegates gone up much? I understand it's pretty cheap and easy to find a venue for 'small' meetings it gets progressively harder and more expensive as numbers rise 
Perl 6 has a carefully designed type system so it's trivial to determine data types if you need to. (That said, in Perl 6, just like in Perl 5, operations coerce data to the type they expect so that `say '19' + '84'` returns the number `103` and `say 19 ~ 84` returns the string `'1984'`. Imo this is a clear advantage of Perl languages.)
Thanks! Is it difficult to learn Perl 6? I can already code pretty well in Perl 5, but I didn't start learning Perl 6 yet.
&gt; Is it difficult to learn Perl 6? In depth? Yes. (Mostly because of stuff that's not inherent to the language such as compiler immaturity, missing documentation, and weak tooling.) The basics are easy, easier than Perl 5's imo. Note also that you can use many Perl 5 modules directly in Perl 6. Maybe [join the freenode IRC channel #perl6](https://kiwiirc.com/client/irc.freenode.net/perl6) and chat with the folk there to see what you think?
[removed]
The ActivePerl recommendation sounds like something for Windows users - since Ubuntu already has perl installed, ActivePerl should not be necessary. Note that Perl is used by a few tools - `git add -p`, for example - and if you add a new Perl installation into the PATH and PERL5LIB environment variables, those can end up loading the wrong modules. Perhaps worth checking with the lecturer or TA to confirm what they advise for Ubuntu? If they have specific reasons for ActivePerl on Ubuntu, it would be interesting to hear them. 
[removed]
There is another security concern to keep in mind from this: *any* relative directory in @INC opens you up to this vulnerability, not just `.`. Consider that just as easily as you could be running code from a world-writable directory, you could be running code near a world-writable directory that you didn't intend. This only came up because `.` is the only relative path that perl puts in @INC by default. To mitigate this somewhat, I always use File::Spec-&gt;rel2abs or Cwd::abs_path on a relative path before passing it to "use lib" or similar.
You can also develop them in a lib/ dir, and then run your code with `perl -Ilib path/to/script` to temporarily add that to your @INC; this is a common practice while developing and testing.
You're right. When i was posting i was making the wrong supposition about what OP wanted.
Please don't refer to Perl 6 as a new version even as a joke, it's confusing enough as it is.
[removed]
Nice. Thanks for the info!
Or [free](http://modernperlbooks.com/books/modern_perl_2016/index.html), if that's what you prefer 
[removed]
My experience was that by 2011 most people were no longer staying in dorms, but we explicitly worked with the venue then (and again in 2014) to have room rates that worked out to $50-$60/night if you split a room (something you'd do in a dorm anyway).
 -r File is readable by effective uid/gid. -w File is writable by effective uid/gid. -x File is executable by effective uid/gid. -o File is owned by effective uid. -e File exists. -z File has zero size (is empty). -s File has nonzero size (returns size in bytes). -f File is a plain file. -d File is a directory. -l File is a symbolic link (false if symlinks aren't supported by the file system). -M Script start time minus file modification time, in days. -A Same for access time. -C Same for inode change time (Unix, may differ for other platforms)
You can define several packages within a single file. We don't make this clear to new coders. It can be a useful technique. Example: #! /usr/bin/perl =pod TODO my plans =cut use strict; use warnings; package appStrs { sub showhelp { my $this=shift; return "Help:\n".$this-&gt;arg_msg1;} sub arg_msg1 { return "myarg=1"; } }; package myObj { sub new { my ($class,$objname) = @_; my $self = { objname =&gt; $objname || $class, objID =&gt; time }; my $object = bless $self, $class; $object-&gt;_init; return $object; } sub _init { my $this=shift; } #init stuff sub otherMethod { my ($this, $prop)=@_; } #another method }; sub main { my $oStrs=appStrs-&gt;new(); $oStrs-&gt;showhelp(); } ####### &amp;main; 
We don't make it clear to new coders because it's a huge trap if you don't know what you're doing. Proper organization of a project relies on `use Foo::Bar` being able to find Foo/Bar.pm and then finding a `Foo::Bar` package when it loads it, so that it can call the import method. Anything else should be reserved for "magic tricks" that hide their true nature from the user (sometimes for good reasons, sometimes to be cute). You should also not give new coders examples that involve an unnecessary "main" sub, calling subroutines with `&amp;`, or reinventing object systems (unless the latter is the purpose of the example).
Part of it is fueled by the fact that Python is being taught in schools. Also, I think Python is becoming more popular in general with a fairly steady development stream. I often hear about new Python releases but seldom hear about Perl releases. I know Perl 6 is a thing now, so maybe we'll see it pick up a bit? I code in both because I was a Perl guy but the company I work for has a more active Python development group. I find that for most stuff it doesn't matter too much. I'll usually choose Perl for its quick and easy to use Regex functions.
This looks cool but the only way to sign up is to authorize it to have admin access to my github repos. That's a pretty big ask.
&gt; Does Python have anything approaching the convenience of WWW::Mechanize? Yes, for quite a while. Everybody does these days. Here's the Python one http://wwwsearch.sourceforge.net/mechanize/ (I do appreciate the shout out and Perl mention)
I trust vti in this, but i think it's a good point to bring up. He should explain in detail what accesses he needs and what for before asking you to give them.
I've used PhantomJS and, while it is more browser-like in the sense that it executes the JavaScript, it is extraordinarily taxing on the CPU. It is completely inadequate for higher volume web scraping - such as a Nagios plugin.
In general I've been able to do whatever I needed to do by using developer mode in a web browser to see what cookies needed to be set and what asynchronous data URLs to call. If you can keep it all in text without having to render in a headless browser then it frees up the CPU to do other work. To be honest the only time I found a valid use case for PhantomJS when attempting to load test a website accurately.
&gt; In general I've been able to do whatever I needed to do by using developer mode in a web browser to see what cookies needed to be set and what asynchronous data URLs to call. If you can keep it all in text without having to render in a headless browser then it frees up the CPU to do other work. I don't disagree with this at all and would usually go this route, but this time I built my tool around phantomjs and didn't regret. It just makes things very easy.
I've been thinking about this a lot lately. I have a new-ish take on it. Perl was built as a text-processing language primarily. Because the Unix philosophy was that everything was a file and programs interchanged via text and pipes etc Perl was uniquely suited to the task. First-class regexes, expressive syntax etc. Perl made for good glue. But in some sense that was the writing on the wall for its own utility. Rather than make small single-purpose tools, our Perl glue built monolithic administration tools. The Unix philosophy applied less and less. Once this happens you don't glue them together with text processing tools. Now ease of use reigns. Hacking up quick glue one-liners doesn't have the utility that it used to. So people use whichever language they can learn most quickly. Python positioned itself well at that time to pick up from there. It was the embedded scripting language of several of the scientific tools I used (can't do that with Perl) and it got a bounce when Google etc tapped it as its preferred scripting language. I personally like Perl over Python. I think Python gets more credit for beauty than it deserves and has some very hard to use parts in it. That said, without a strong Unix philosophy in the tooling these days, the "glue" can be whatever can access a database or talk to a REST api. Perl is quite capable but not appreciably better than Python or Ruby or ... 
&gt; &gt; Python naturally enforces better habits &gt; It doesn't. I think it does. It just doesn’t enforce better code quality. With Python you’re not going to get the sort of obfuscated code contest entry that you will sometimes see with Perl – but that doesn’t make the code well thought out and properly designed. It can easily be spaghetti code no less than it could be in Perl, just that instead of too little structure you tend to also find superfluous structure, e.g. pointless classes (akin to a less excessive Java). What happens with Python is that you just can’t tell at a glance how bad the code is, because bad code doesn’t look all that different from good code at a superficial level. Of course, bad Perl code can’t be equated to bad-looking Perl code alone – particularly in the wake of the rise of Moose, Perl code can suffer from similar “lipstick on a pig” problems. So this is a more nuanced issue than simply “Python hides bad code under superficial good practices”. Which is my actual point: that Python probably does have a benefit in that respect, but that in practice it’s worth less than it might seem, and is less of straightforward win than it would seem. (A lot of language design choices boil down to such inscrutable bottom lines.)
&gt; With Python you’re not going to get the sort of obfuscated code contest Hanging out with Python people i've seen a bunch of those. For example people trying to jam closures into a single expression due to syntax rules, or this: http://p-nand-q.com/programming/obfuscation/python/more.html Not disagreeing with the rest though. :)
&gt; appreciably better If by that you mean "obviously and easily understandably better", then i agree. Otherwise, Perl's OO is vastly superior to either Python or Ruby and in fact most other languages i know of. Many people are just so stuck in their small boxes that they can't even understand in what manner it is superior.
This is a good point. Perl's aftermarket OO is so much better than any in-built OO that I've used in any language so far. I keep hoping for either some of stevan's work or maybe Moo or something could eventually be made Perl core so that it could get more notice outside of the echo chamber. (argh, if I ever have to write another `__init__` method where I just take arguments and pass them to the new object again ...)
perldelta doesn't really show much for 8 months work. the p5p weekly mailing summary does a much better job showing where all the time goes: http://blogs.perl.org/users/sawyer_x/p5p-summary/
I think your second paragraph is a big part of it. The world, and Perl, was built around text, and regexes were about all you needed. Then, everything became XML, and then JSON. Now, the most important thing isn't the language features, it's the availability and quality of libraries and APIs.
I'm not sure what the point here is; what are you trying to say in relation to Perl? The Perl 5.x platform is incredibly stable albeit with the one major breaking change that turned `for @array` into a fatal compilation error (I think that was a major mistake to force that breaking change upon system administrators world-wide). Are you referencing the proposed Perl 6? But that's an entirely different language.
&gt; it's a huge trap if you don't know what you're doing It's good for single-file programs that need OO structures. &gt; an unnecessary "main" sub The above characteristics are useful for tighter control of variable scope. &gt; calling subroutines with &amp;, or reinventing object systems It's useful to know about &amp;sub, and the "reinvented object system" is Perl OO. 
[removed]
As it should? These are stable releases and most of the development work goes into the 5.25 branch.
Do you have the output of the failed build? Put it on pastebin and post the link here. There is also \#perl on irc.freenode.net. But it sounds to me like maybe you just need the -dev package of whatever you're trying to build against.
Sorry, I meant SO, Stackoverflow. &gt; You probably just need to install the libbam development libraries. What do you mean by this? Sorry, I'm a n00b. 
Here is the output after running `$sudo cpan Bio::DB::Sam` (strangely enough, I needed `sudo`) http://pastebin.com/mSdwUDiE And it is true, that within the path for `~/samtools-1.3.1`, no file `khash.h` exists. But I'm not sure what to do about that. I've compiled samtools successfully....
Installing modules through CPAN won't install external dependencies. Installing the libs you want shouldn't be difficult, but the instructions will differ depending on your operating system's package manager. What operating system are you using? E.g. Debian/ubuntu, fedora/centos etc. 
&gt; I can help if you if you tell me what OS you are running. I'm actually doing this on Mac OS X as well. What would be the best approach in this case? The CPAN installation isn't correct? 
I get the same error trying the two options detailed above. Using the macports version of samtools, I tried the path `/opt/local/include/bam/`. It's the same error `lib/Bio/DB/Sam.xs:29:10: fatal error: 'khash.h' file not found`
I haven't used it. I'll check it out.
[removed]
[removed]
README states: The more traditional install requires you to separately download, unpack and compile SAMtools 0.1.10 through 0.1.17 in some accessible directory. Typing "make" in the samtools directory will usually work. SAMtools versions 0.1.18 and higher do not work with this library.
You need sudo because without additional instructions, cpan will install modules in system space, usually /usr/local/bin.
Most of the time was spent sorting out the `. in @INC` security issue as discussed here (and mentioned in perldelta): https://www.masteringperl.org/2017/01/perl-v5-26-removes-from-inc-but-dont-think-youre-safe/ It was difficult to find solutions that were both effective at closing the vulnerability and didn't break CPAN. The main sticking point was the `base` pragma, and it was finally decided to hold off on changes to `base` until the next release.
I'll also add that [Mojo::Phantom](https://metacpan.org/pod/Mojo::Phantom) exists for running javascript though it primarily is documented for use with [Test::Mojo](https://metacpan.org/pod/Test::Mojo) currently, so I'm not sure how it could be used with Mojo::UserAgent directly. But that's only needed if you cannot perform your task without running javascript, which is rare.
It's an absolute mess. I cannot 'make' samtools version 0.1.10 to 0.1.17. 
I still get an error with 0.1.17 at `Make`: 3 warnings generated. gcc -c -g -Wall -O2 -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -D_USE_KNETFILE -D_CURSES_LIB=1 -I. bam2depth.c -o bam2depth.o gcc -g -Wall -O2 -o samtools bam_tview.o bam_plcmd.o sam_view.o bam_rmdup.o bam_rmdupse.o bam_mate.o bam_stat.o bam_color.o bamtk.o kaln.o bam2bcf.o bam2bcf_indel.o errmod.o sample.o cut_target.o phase.o bam2depth.o -Lbcftools libbam.a -lbcf -lcurses -lm -lz Undefined symbols for architecture x86_64: "___ks_insertsort_heap", referenced from: _ks_combsort_heap in libbam.a(bam_sort.o) _ks_introsort_heap in libbam.a(bam_sort.o) ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation) make[1]: *** [samtools] Error 1 make: *** [all-recur] Error 1 
http://bash.org/?7444
I have both Strawberry and AS. But none of that is in the perl and perl64 folders (which are both at the first level under C:\). They have only the perl programs I write. I only use the perl folder, but many of the folders and programs are copied by something into the perl64 folder. The perl folder is about 800KB, the perl64 folder about 200KB. By what rationale do you say "No"?
You're contradicting yourself, first you claimed perl and perl64 are identical, now you say they differ by 600 kb. They also don't contain the perl installations, but only what you wrote, so i have no idea how the fuck they could come into existence, since i have never seen either perl flavor do that. Come to that, having both perl flavors is in itself super strange, and you're leaving out details. Frankly, all of this is so bizarre i suspect you're trying to confuse us into wasting time with a made-up scenario. &gt; By what rationale do you say "No"? You need both Program Files and Program Files (x86). That question is also so bizarre it makes me think you're trolling.
We got some reports on this, but there's clearly a whole bunch of Perl in there, so please reserve your reports for submissions that don't have Perl.
Emojis are pretty frustrating no matter how you slice it. If only people didn't freak out if smilies didn't work
There is a standard encoding: UTF-8.
The one that is standard is the network line break, /r/n. If anything else is used, it's by tradition.
Check the line endings in your local text files. If you're using Windows, they're probably "\r\n". If you're using some form of Unix (i.e. Linux or OS X), they're probably "\n". Then try to fetch something on the internet. HTTP headers are probably "\r\n". FTP might translate "\n" to "\r\n" if it's in text mode. Encoding bugs will be with us for decades. And your slashes are backwards.
It's not Unicode that's bad. It's human language, which Unicode just represents. And it's a problem programmers have to deal with, otherwise people can't write. 
Hahaha sigh. Mostly. Except when it's not used. I deal with a LOT of user-generated text.
Well, it is a standard, and some implementations break the standard. What you hope for is that more implementations followed the standard.
Possibly useful idea. However, most of the time when I do this, it's based on dynamic data (so the shortcut is not useful to me in that case, as it only works for literals in the code). Also, the choice of the value is not a consensus, many people prefer to use `undef` as the value when checking for `exists`.
Less security problems than what there was before, which was multiple locale encodings. Including some with different widths.
Happy ~~f~~phishing.
I don't understand your problem. He is showing things he is doing with Perl. The things might not be to everyone's interest, but the Perl is definitely on-topic.
Both posts in the series benefit from the use of Perl: In one, I show a Perl script which others can use to cut out sub-series out of a longer one and line them up in a format suitable for further analysis in a Stats package. In the other, I calculate vectors norms, dot products, and cosine similarity in and present the information in a neat table using a Perl script. Sure, the scripts are not the *focus* of the posts, but if I did not have Perl, I would not have bothered at all with the task of chopping the single S&amp;P 500 series into multiple pieces corresponding to each election. The ease of doing so in a few lines was essential to how I came to write the posts instead of just moving on after seeing a chart that obscured interesting differences in market behavior across elections.
FWIW, u/kentnl pointed out that the two directories are recommended to be created for side-by-side installations of ActivePerl x86 and x64. Check the timestamps of their contents. If you've uninstalled the ActivePerls and if they don't contain recently updated files and if they don't contain files you know you still need and their sum of contents is truly in the kilobytes and under 1 megabyte, then they're leftovers and can both be removed.
 my $ar = [qw(one two three)]; Doesn't seem like that big of a deal... not enough to warrant creating a new `qa` operator/function. Maybe I don't write enough of these, but it just seems like overkill.
Good point.
from where did you get the data ?
Ummm, the entirety of CPAN is a reasonable 4GB. I don't see how anybody got a hold of 2TB of code.
It comes from BigQuery. BigQuery [stores snapshot of GitHub](https://cloudplatform.googleblog.com/2016/06/GitHub-on-BigQuery-analyze-all-the-open-source-code.html) and I use that to parse words. However, I'm detecting language by file extension. Which is not very reliable in case of Perl (Prolog has the same `.pl` extension)...
Could you possibly re-run your code searching only for .pm files? I would be very interested in the results. 
Yes! Let me do it once I get back home. Would you suggest to drop .pl altogether?
What was weird about the results?
That looks a lot saner—there are still quite a few things in there which are unfamiliar, but that's probably just because you're getting both Perl 5 and 6 on GitHub. The real bulk of Perl code is in CPAN in Perl 5, but Perl 6 being new, it's more likely to be on GitHub. 
Is this a source build for Linux environments only?
Also [on HN][1]. [1]: https://news.ycombinator.com/item?id=13438835
What's koha? Is't that "Death" in Korean?
The main reason is Python appears to be the new kid on the block. Despite the fact that it is only like two years younger than Perl did not get as much traction in the beginning so there are fewer people who wrote Python for over 20 years and know everything and who put you down whenever you have an idea, telling you "it was tried around 1997, in June or July if I remember well, but it did not work and it was not pretty when it blew up in my face, so don't waste my time and go back to writing validation scripts for my validation framework from 1998 which takes about half the processing power required by our invoice processing code but makes me feel like I'm still young and programming APL". Don't worry about Python. Worry about D2 (search for "rdmd" if you want to be really worried ) and Rust.
Yeah, I'm somewhat familiar with this stuff, but none of the core test tools every emitted or parsed any of these proposals.
I think you could be more specific, though. If you create a version of your script which only has (let's imagine) the first line, does it work at all? If so, add in the next line, and so on. Eventually, either you're done, or you can say at which line it stopped working.
[removed]
I didn't include all of the script, because it works fine when I run it from the command line and from the webpage. The email doesn't send when using the webpage for some reason.
There's no rule against asking for pointers, just as long as you don't expect people to write your code for you, ask away! I'll give you two pointers (if I'm not clear, feel free to ask): - ALL your "if" statements are tested one after the other for EVERY string entered. that should not be the case. - You only need to test for the two specific inputs, so 2 "if"s in your code.
**EDIT** s/elif/elsif/g - thanks /u/workrestplay Well one way would be to use `if / elsif / else` - you can remove the `@input` array e.g. if ($input eq '') { ... } elsif ($input eq '42') { ... } else { ... } Also, the `$input eq @input` check doesn't do what you think it does.
you may want to check the error logs
How would I do that?
Make sure to put at the top: use strict; use warnings; This will resolve a lot of your ambiguous failures.
this is in the /var/log/apache2/error.log [Sun Jan 22 01:50:45.773431 2017] [cgi:error] [pid 793] [client 180.158.162.195:58982] AH01215: : /var/cgi-bin/feedback_form.cgi, referer: http://www.pilatesshanghai.com/feedback_form.html 
check the first line of the script "#!/usr/bin/perl" and make sure it,s the actual location of perl. you will need to make the script executable with a chmod 755 script name
the script is executing. I get the thank you page when I push submit from the webpage. there is a permission error preventing the script from using the command "msmtp".
Perhaps start by writing in plain English some comments for each line of what you think each statement is doing. Then we can see where the problem is in your thinking? There is rarely a problem with the programming language, its your program you have to intellectually own it. If you don't you likely copy pasted far too much and have no understanding of what's there. Trace through in words exactly what you think is happening and you will either find the problem in the program or your thinking. Eventually this just becomes an innate skill, but when starting out its genuinely a good idea to always start out in plain simple English then add in the code. If your code naturally has a decision to make use the word `if` and make bullets for each possible outcome, you then know what your if() elsif() blocks should look like. If you need to do something many times, first write the condition of continuing and finishing doing that repetition and then bullet/indent the list of things to do. Just format the story of your program broken down as much as possible into the simplest of operations. Format and use as much of the white space and keywords you can muster. Then after you just need to google each of your sentences for the Perl docs. Go slow, go statement by statement, start simple and add complexity. Try to always start with major decisions and points of repetition first, before detailing the exact operations.
*elsif
Oops - too used to shell. Thanks :-)
I have been switching from PerlApp to PAR::Packer over the last 6 months and it is working fine (actually some old app’s I have, have had some random crashes with ParlApp that I don’t see when packed with PAR::Packer). One little minus though is that dependency scanning is quite slow, what I have done is simply to turn off dependency scanning and then adding them manually – it’s a bit more work up front, but when done I find PAR::Packer to be faster at building exe-files and to be more stable then PerlApp. 
It's spam. http://imgur.com/a/xndlq
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/web_design] [I am having trouble with a simple cgi script on my lamp stack. Can anyone help me out?](https://np.reddit.com/r/web_design/comments/5pls5e/i_am_having_trouble_with_a_simple_cgi_script_on/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Been getting a ton of that in /r/postgresql too.
**Here's a sneak peek of /r/PostgreSQL using the [top posts](https://np.reddit.com/r/postgresql/top/?sort=top&amp;t=all) of the year!** \#1: [PostgreSQL: PostgreSQL 9.6 Released!](https://www.postgresql.org/about/news/1703/) | [9 comments](https://np.reddit.com/r/PostgreSQL/comments/552356/postgresql_postgresql_96_released/) \#2: [On Ubers choice of databases](http://use-the-index-luke.com/blog/2016-07-29/on-ubers-choice-of-databases) | [16 comments](https://np.reddit.com/r/PostgreSQL/comments/4v7idb/on_ubers_choice_of_databases/) \#3: [What are some bad things about PostgreSQL?](https://np.reddit.com/r/PostgreSQL/comments/4nz9of/what_are_some_bad_things_about_postgresql/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
https://github.com/bradhaywood/p5-Discord This one is actually quite far along (though still seems to be missing a lot of features). It's under active development and written in Perl 5. There's one being developed in perl 6 too - https://github.com/Skarsnik/perl6-discord My advice is to contribute to one of them instead of starting from scratch. God knows Perl needs a library, so if you work together we might actually get one completed.
No idea, I'm pretty annoyed by that too. But the interface is not the best so i just live with what they provide.
I do understand that times have moved on but I am learning Perl as a hobby and this is my level, or actually a little above, of understanding. I could just copy some script off the Internet but that doesn't help me to learn to code and that code would be unmaintainable by me. 
Since I have a feeling it would help a lot, something like this: my $perl = 'print "hello world\n"'; eval $perl; Be careful about what you put in the $perl string, if any part of it comes from user input.
I've been doing it in [Graphics::GVG::OpenGLRenderer](https://metacpan.org/pod/Graphics::GVG::OpenGLRenderer). It takes a GVG document (a simple vector format for games), and then compiles it into a Perl object. When you call `draw()` on that object, it runs the OpenGL commands to render the original data.
This entire module exists to generate Perl: https://metacpan.org/source/HAARG/Moo-2.003000/lib/Method/Generate/Accessor.pm
To bring home the import of the "careful" bit: if what you eval includes perl code that's equivalent to "drop a nuclear bomb" then evaling it will drop a nuclear bomb. If you wrote the code that's being eval'd then fine; if even a single bit of it comes from user input, can you be 110% sure you won't destroy the world by evaling it?
All of the generated code will come from me, so I'll be 100% sure it won't blow up the world. Basically I'm doing a Google Analytics query and stuffing the results in a database. I'm going to be doing this for lots of different websites with lots of different query parameters so I want to generalise the code rather than do what I'm doing which is write a bespoke program for every query. SO it's pretty boiler plate with the variables being the exact syntax of the GA query and the exact syntax of the database insert query.
Never thought of eval.. how does it work with multiple line commands? A la: use Net::Google::Analytics; use Net::Google::Analytics::OAuth2; use Net::Google::Analytics::Row; my $req = $analytics-&gt;new_request( start_date =&gt; "$startDate", end_date =&gt; "$startDate", ids =&gt; "ga:$profile_id", dimensions =&gt; "ga:country,ga:pagePath,ga:date,ga:hour,ga:minute,ga:latitude,ga:longitude", metrics =&gt; "ga:users,ga:entrances", max_results =&gt; 10000, ); etc etc etc 
Many thanks, I'll look into it
It really depends on how you want it set up but in addition to the mount plugin, there's [Toadfarm](https://metacpan.org/release/Toadfarm) which builds upon mount for a really strong kit to glue your apps together.
I met some of the YouPorn team at a Perl conference many years ago. So, a lot of folks porn runs on Perl.
I used to try to used system packages where possible, but given that they tend to lag behind even when they are available, I find it easier to just install all modules from CPAN in a unified fashion with cpanm. On top of what others said about using a [cpanfile](https://metacpan.org/pod/cpanfile) to keep track of your dependencies, and using perlbrew or plenv to isolate your installations from system perl, there are additional options: [Perl::Build](https://metacpan.org/pod/Perl::Build) which is like perlbrew or plenv without the parts to switch between installations, is nice for simple systems where you just want one perl but not the system perl. [local::lib](https://metacpan.org/pod/local::lib) lets you install modules locally (by default in `~/perl5`) but still using the system perl. In fact if you try to install modules with cpanm without write access to the perl, it will install to a local::lib by default. The main thing to remember when dealing with multiple perls is that CPAN installers will install to their own perl (unless a local::lib is configured in your env), so just check which `cpan` or `cpanm` you are running. Above all try to avoid `sudo cpan` or `sudo cpanm` to install modules into the system perl. There are a couple problems you can run into with this. Dual-life modules (modules both in core and on CPAN) can overwrite core files which will screw up your package manager, and before perl 5.12 they *have to* overwrite them when updating due to how libraries were set up back then. The other problem with installing directly to system perl is that if your package manager upgrades perl to a new major version, like 5.14 to 5.16, that's fine for all of the packaged modules which will be upgraded along with it, but you'll have to reinstall any modules that you installed with a CPAN client, or any XS code (modules that use compiled C code) will fail with strange errors. This also means that you will have the same problem if you are just using a local::lib attached to that perl. However, if you keep your dependencies in a cpanfile, you can easily reinstall them after wiping the local::lib or in a new perl installation by running `cpanm --installdeps .`.
Toadfarm is a good option, but also consider that webservers like Apache and nginx are very well-developed in terms of virtualhost routing combined with things like SNI for SSL. If your apps are sufficiently unique or complex you might be best using Apache for what it's good at and routing to multiple separate application servers. Though I certainly don't enjoy configuring it.
Looking at your example it's very unclear why you need to eval at all. Can't this just be in a function that you call?
This program (created in a string) I plan to be completely self-sufficient, not requiring any variable setting from the outside world. So any variables declared within it are completely non-global, if you see what I mean. I was planning to do it in heredoc syntax. There's about six parts to it: 1/ boilerplate initial code 2/ Define the analytics query code and concat to the boilerplate beginning code 3/ boilerplate get the analytics data and cycle through the query 4/ Define and execute the database staging routines - every analytics dimension and metric has a "get_" routine defined to get at the value 5/ Define and execute the post staging routine 6/ Boilerplate cleanup. I think the heredoc variable has to be surrounded by single quotes in order for the variables in the code not to be interpreted.
I have a slightly different setup, in nginx.conf, in the appropriate places: proxy_set_header X-PSGI-App app1 and then in my app.psgi: my %dispatch_table = ( app1 =&gt; require "./app1.psgi", app2 =&gt; require "./app2.psgi", ... ); my $app = sub { my $env = shift; my $which = $dispatch_table{$env-&gt;{'X-PSGI-App'} || $env-&gt;{'HTTP_X_PSGI_APP'}}; return $which-&gt;($env) if $which; # return 404... }; 
[removed]
If someone's obviously trolling, please refrain from slapping down iceburns as furiously as possible and report instead. ;)
Fair 'nuff
It's good to see more people working with hardware in Perl.
Are you writing this code yourself or did you get it from somewhere else?
I would put an giant `if` at the place in the code that is failing, that checks to see that every piece of that nested hash actually exists, and if it doesn't (which is clearly doesn't sometimes), uses `Data::Dumper` to print it to a log. Then next time the error happens, you can see exactly what is happening without having to guess. if it *still* doesn't illuminate the real problem, move backwards in the code and find the place that creates the bit that is missing. Dump the input data there and see why it isn't creating what you expect to find later. Repeat until everything becomes clear and the bug is fixed.
[removed]
This is a different concept. An attribute like that would still allow you to modify the hash keys and values, as would the `constant` pragma; the readonly designation only means that you cannot assign a new hashref to the attribute. You can use [Const::Fast](https://metacpan.org/pod/Const::Fast) or [ReadonlyX](https://metacpan.org/pod/ReadonlyX) to mark a hash as readonly so the keys and values are not allowed to be modified. Locked hashes are slightly different from that: this specifically references that you get an error when accessing a key that does not exist, for the purposes of preventing typos (sort of an analog of `use strict 'vars'` preventing typos when trying to access `$foo` and typing `$ffo`). Though in practice using ReadonlyX or Const::Fast to make a hash readonly also makes it restricted. This is mentioned in the blog post: ...locked hashes *die* when you try to access a non-existent key, which goes against the general expectations of a read-only hash.
Then use a Dict validator from [Types::Standard](https://metacpan.org/pod/Types::Standard). You're trying to install too much magic for the purposes of locking down the variables. Perl is not a statically-typed language. It is a dynamically-typed one. Quit trying to make it what it's not. Code can be monkey patched or circumvented to change the data, but caveat utilitor, as these things are undocumented and changes can suddenly break your hacking. This risk is built into the language. Developers are well aware of it. Sacrificing speed or stability to force static types is a bad trade.
&gt; You're trying to &gt; Quit trying to Wow, the dude explained to you what a locked hash is. He didn't advocate using them or not using them. Chill out. You're not in a position to be condescending to him about how Perl works considering your first post.
Okay.
Just saw the thread on p5p. We don't use them. Also from what Yves wrote the definition of the feature is pretty useless. I can understand the desire for both behaviours, making read access to non existent key fatal (which is way better than having a typo in $hashref-&gt;{soem_attribute} and hunting a silent bug) and just restricting write access. But in both cases locked hashes are simply the hammer to a box of not-nail problems.
Still never learned the first thing about how conversation between reasonable human beings works in all that time, though, I take it?
You say this as you berate and insult me, right?
It is pages 112-137
It doesn't seem ideal to me, especially since it would appear to grow from the bottom (as the header gets higher with each inserted row). This is actually exactly what I'm doing now, as it was the quickest way to hack together the proof-of-concept. Ideally, I'd like a little more control over where things are placed. I know curses also helps a lot with getting information about the terminal -- e.g. number of rows and columns, etc. Maybe this is all possible and easy without curses, but I'm not experienced enough with a "terminal UI" to know. I've done plenty of `print`s and `say`s, but a persistent, updating UI throws some new challenges into the mix. Thanks for the input.
For async updates, one alternative is [Tickit](https://metacpan.org/pod/Tickit). There's a table widget that should do what you're asking for, although the fading background isn't currently implemented: [Tickit::Widget::Table](https://metacpan.org/pod/Tickit::Widget::Table). (disclaimer: I wrote that widget, and the documentation and examples are not very good)
To get the terminal size, I've used Term::Readline's get_screen_size() method. Also, depending on the amount of data, what about repainting the screen with each new row? Inefficient, but easy to do. **Edit** the shell command 'stty size' provides row/column information. I've looked at Curses in the past, was frankly intimidated by the number of variables. 
I am a big fan of todo.txt by Gina Trapani so I thought I would try in Perl. There is a module in cpan but I couldn't get it to work. I learned a lot by doing this project, which was the main point. I had just started reading "Intermediate Perl" when I started and didn't know anything about derefencing. About half way through I figured out that what I was getting in json needed to be dereferenced rather than trying to use regex. I am sure their are a lot of places I can improve, please feel free to make suggestions.
That's a valid point. Unfortunately, the project in question is "munin-influxdb" which reads state-files from munin. These in turn use the "storable" format and it's out of my control.
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: https://www.reddit.com/r/Serendipity/comments/5r9ef2/need_help_with_the_storable_module_to_correctly/
This looks interesting. Currently I have one Mojolicious app. It's configured to run under Apache using virtual hosts (httpd-vhosts.conf). I'd like to explore the sanest way to deploy multiple Mojolicious apps under the same host. I'm not sure if I'm reading this right but I don't know if Toadfarm is what I want to be looking at. I'll try and do some more digging. Thanks
CGI.pm offers [a feature](https://metacpan.org/pod/CGI#Progress-bars-for-file-uploads-and-avoiding-temp-files) to allow you to do this. Plack::Request does not, but you can with raw psgi.
it is my pleasure to announce that O'Reilly has posted an early release (i.e. incomplete and not fully edited version) of my new book on Perl 6: Think Perl 6 - How to Think Like a Computer Scientist by Laurent Rosenfeld (with Allen B. Downey) Early Release Ebook ISBN: 978-1-4919-8048-4 | ISBN 10: 1-4919-8048-6 At this point, only the first seven chapters (about 150 pages out of a total 450 pages) are publicly available as HTML. The book is fully written, the rest only needs to be processed in O'Reilly's editing process, which should take another few weeks. O'Reilly's page on this book: http://shop.oreilly.com/product/0636920065883.do Cheers, Laurent. 
&gt; Then use a Dict validator from Types::Standard. Dict validation guards against totally different things than this problem: package Obj; use Moose; has foo =&gt; ( is =&gt; 'ro', isa =&gt; 'HashRef[Str]', ); ... my $obj = Obj-&gt;new(foo =&gt; { a =&gt; 1 }); $obj-&gt;foo-&gt;{a} = 10; # oops, we just altered the 'a' key, even though it's read-only?! $obj-&gt;foo-&gt;{b} = 20; # oops, we just added a new key to the hash, even though it's read-only?! The proper way to do that is to prevent access to the reference entirely: package Obj; use Moose; has foo =&gt; ( isa =&gt; 'HashRef[Str]', traits =&gt; ['Hash'], handles =&gt; { foo =&gt; 'elements' }, ); ... my $obj = Obj-&gt;new(foo =&gt; { a =&gt; 1 }); my %data = $obj-&gt;foo; # returns ( a =&gt; 1 ) &gt; Perl is not a statically-typed language. It is a dynamically-typed one. Quit trying to make it what it's not. Perl can be anything you want it to be, because it's that flexible.
[Modern Perl](http://modernperlbooks.com/) is a great resource if you already know perl decently well. At a brief glance I would recommend using HTTP::Tiny over LWP::UserAgent as it's simpler and a core module, and using JSON::MaybeXS over JSON as it's faster and uses a more correct JSON encoder. One other thing is that I see this sort of foreach loop several times: foreach my $pros ( 0 .. $#{$decodetasks_ref-&gt;{'projects'}} ) { $project_id{$decodetasks_ref-&gt;{'projects'}[$pros]{'id'}} = $decodetasks_ref-&gt;{'projects'}[$pros]{'name'} , } You're only operating on the elements of the array, not the indexes, so that could be rewritten to be clearer: foreach my $project ( @{$decodetasks_ref-&gt;{projects}} ) { $project_id{$project-&gt;{id}} = $project-&gt;{name}; } Also hash keys don't need to be quoted as long as they are alphanumeric + underscore (valid identifier).
&gt; Also hash keys don't need to be quoted as long as they are alphanumeric + underscore Though many would say it is a good idea anyway.
Though the OP seems stuck with Storable in this instance, another option for such things is [Sereal](https://github.com/Sereal/Sereal) which is designed ground-up to be cross-language and has Perl and Python implementations. EDIT: Though at a closer look, the Python implementation is only a decoder and "Not Perl compatible", whatever that means.
I'm still waiting for the end of
Same with ] so long as it's first. Oddly though, this doesn't work in JavaScript regexes.
Or using postderef: foreach my $project ($decodetasks_ref-&gt;{projects}-&gt;@*) { ... } Of course he will either need to upgrade to 5.24, and `use 5.024;` or on 5.20/5.22: use feature 'postderef'; no warnings 'experimental::postderef';
Just purchased the Early Edition E-Book! Will start going through it tonight.
It could be a UTF-8 encoded string, or not. It could be any bytes at all. You don't know, so the right thing for a deserializer to do is return bytes, and allow the app to decode if it knows for a fact that what it's getting ought to be a string. Unconditionally decoding would make the deserializer useless if it was given a structure containing binary data.
Everyone seems to be in a hurry to publish perl6 books. I just wish the e-versions were reasonably priced.
I wil keep that as a an option . How about getting it without database..
Ah, you didn't start with my [py3 port?](https://github.com/quasarj/python-storable3) :P I basically ended up doing the same thing (decoding as utf8 for many values). I also don't think it is entirely correct, though in practice it usually works. I think /u/hobbified is more correct below though; you should probably make it return bytes, and let the "user" figure out if it is utf8 or anything else. 
I did have a look at the different forks and have the intention to merge them somehow. But I first want to get the unit-tests right. Without them it's too risky to unintentionally break something. Once I'm confindent enough about the tests, I'll have a look at merging.
After thinking about it, I've completely moved away from alternative serialisation formats (I was using both JSON and Pickle). In this particular case (I only need it for unit-tests), I now opted for plain Python source files which I will either `eval` or `compile` during unit-test execution. I now use `eval` but I may need to go with `compile` to test references stored in the `storable` file. Note that for the end-result I *have* to use `storable` as that's the main reason for the existence of the library. I concluded that comparing a deserialisation result with an *actual* Python object resulting from `eval`/`compile` is the only right way to go.
I agree. I prefer the first one in this case as well. I just wasn't sure how Perl handles this particular case. I had the suspicion that it would be interpreted as plain bytes (maybe even dependent on encoding of the source script). I've had to deal with plenty of encoding/decoding errors in my carreer, and I *strongly* prefer the first one. Unless Perl would have stored strings as UTF8 of course. Thanks a lot for the info. This confirms my gut-feeling and gives me higher confidence to continue my work!
I'm already well on track :) I believe I only need to update the "expected" values in the "tests/results" folder and I'm good (assuming that the original deserialisation code is correct of course) ;)
If one doesn't mind the length of the line, I suppose reading from STDIN until `^Z` could be done like so: `perl6 -e 'lines.map({ /\x1A/ ?? exit() !! .say })'`. Not great, but it's a start. A point Sinan and I agree on is the exit code with output issue. I'm aware of the existing [bug](https://rt.perl.org/Ticket/Display.html?id=125757) but it's quite an old bug which I hoped would have been squashed by now. I do think Sinan is a little hard on what is ultimately a 1.0. As he said *"the only reason I fell in love with Perl is because I started with 5.6, not any of the earlier versions."* There was a good 10+ years of development between Perl 1.0 and Perl 5.6. Regardless of how long it took to get to version 1, I think it's a little unfair to be so harsh on it, which seems like it will only serve to drive people away from Perl 6.
I didn't read it that way. Sinan doesn't mind encountering bugs, but he felt baffled with the responses of the bug reports, mainly that he was told to use a stable distribution instead building from source from the dev branch. 
I can't usefully comment on everything, but the installation compilation comments are deserved. The Rakudo README states: https://pbs.twimg.com/media/C3qBIpmWQAAe7pc.jpg &gt; Rakudo Star can be built on Windows either using Microsoft tools (MSVC) and nmake or using gcc and gmake as bundled with Strawberry Perl. In the latter case use cmd.exe rather than bash as a shell. In light of that, reports of breakage should NEVER be answered with: &gt; "I installed using .msi installer, which is how most people should." &gt; "CTRL-D works when perl6 is built with MinGW" But with: &gt; Please give us detailed reproduction instructions.
Reading Op's article he comes across as having a reasonable tone and he describes very reasonable behaviour on his part. Is he sugar-coating the way he actually behaved? If so, would you mind sharing any links showing how he was pushing really hard?
He took completely reasonable advice as hostile answers. When he asked how to install from source, he expected an elitist answer. #Perl6 answered as they always do: assumed he was a noob and gave baby steps. He got offended by this.
&gt; They do take feedback. If this were true, it'd take *the entire* feedback better.