So what? It is clear the theme of her talk is what she wrote about in her letter and during the discussions that ensued from it: &gt; Perl is more about a mind set and a community than just a single implementation. is exactly the postulate she used to justify her points, one of which being that the answer to "how we can reappropriate the Perl brand in the coming years" is that there should be a unique brand for Perl 5 and Perl 6 (aka keep the mess going on).
I'm working from these premises: 1. Perl 6 is alive and kicking and getting more traction week by week. 2. Perl 6 is not going to change its name. 3. Larry is not going to change his mind about the naming of Perl 6. So, with or without me or my presentation, this "mess" as you call it, will go on. My proposition is that we should take this "mess" and turn it into our advantage compared to other programming languages / communities, because I believe that at this point in time, we are in a unique position to do so by combining the strengths of all versions of Perl in the world.
The "So what" comment is quite dismissive, and it would be most unfair to disregard your many contributions to Perl over the years. I also think that jumping on a few words in a synopsis rather than waiting for full content of the talk is premature at best. Sure, things don't happen in a vacuum, and while waiting this is clearly a fine opportunity to engage in conspiracy theories based on how to interpret "reappropriate", "Perl brand" and even "we" in that synopsis... I mean, I take one look at the 3 premises, notice that they are all about perl6, and draw a conclusion that this is going to be "how can the perl6 community appropriate the Perl brand to further our sinister plan of world domination". A more reasonable person might think "oh good, someone is actually thinking ahead to the future and trying to avoid community fragmentation". Others are likely to have their own take - but getting those different mindsets and opinions into the same room and having something to talk about is one of the strengths of a conference. Seems fair enough to do a presentation and expect others to join in with an open mind (bias is one thing, prejudgment quite another). Could lead to some interesting alternative suggestions in hallway track discussions too.
I don't have time to code this all out, but the main problem seems to be with your external script. It should be "Content-Type: application/x-www-form-urlencoded; charset=UTF-8", and instead of *returning* the "results", they need to be printed to STDOUT encoded in JSON. ... @rows = $sth-&gt;fetchrow(); $result_supervisory_org = $rows[0]; $sth-&gt;finish(); push @results, $result_supervisory_org; **print to_json(@results); return;** Whatever is picking up the results from the external script should run them through the "from_json" function in the JSON library to encode them back into a perl hash/array structure. Just a note, the work doing the JSON calls should really be in javascript, if there is any time that a perl script needs to call another perl script for information, it should be done using object oriented programming, or just copying the code from the external script into the internal script. Do the dynamic stuff *after* the page loads.
to_json and from_json are incorrect for this use case (and most use cases in newbie code which is why they are discouraged in the docs). You need to use encode_json and decode_json to turn data into (and from) printable bytes. Unless there's a `:encoding(UTF-8)` layer on STDIN or it's similarly been decoded when you read it, but that doesn't sound like the case here.
I disagree with premise 2, as the only way our communities can move forward together is with the hope that it is incorrect; and only one person has insight into premise 3.
&gt; Printing an array in double quotes or anywhere with interpolation will print out a string of the values delimited by a comma @nums = (1, 2, 3); # Note: (...), not [...] to create an array print "@nums"; # Prints "1 2 3" - spaces not commas You're right about the problems caused by turning it into a string representation, but not about the details about what that representation is.
I have yet to understand why you make such a distinction between Perl 5 as a language and as a runtime. There is currently no distinction; and even *if* someone were determined and ambitious enough to attempt reimplementing the entire language in another implementation, it would by necessity be functionally the same as the runtime (except garbage collection would work differently if it's the VM implementation we're talking about, so that's fun), and it would either be maintained by the same people it is now, or it would fade out once the author loses interest in keeping it up to date as Perl diverges once again in the next version. There is no point to the distinction until and unless the core development team decides to make such as a part of their development practices.
&gt; enough investment in Perl5 continues to keep it performing well, keep it relevant and keep its assets (up to date CPAN modules) strong That is exactly how I see the future of Perl 5. &gt; Investment from large brains such as yours Thank you :-) But truth be told: when I retired ~ 6 year ago, I was looking for something new to sink my teeth into. Perl 5 was *not* that thing for me, Perl 6 *was*. So in that sense I was already "lost" for the Perl 5 development effort. &gt; Is attention to Perl6 diverting investment in Perl5? I would argue that that has been the case until Perl 5.12 came out, but not really after that. I would argue that at the moment, the most difficult thing for Perl 5 is to find people with enough stamina and knowhow to work on Perl 5 internals, even if they are getting sponsored. And the number of abandoned modules on CPAN keeps growing. I would also argue that this abandonment is caused by authors / stakeholders no longer using Perl 5, rather than authors / stakeholders using Perl 6 instead.
Because her suggestion to save Perl 5 as a language is to write a more modern runtime for it.
I am familiar with her suggestion. I asked why that matters. A more modern runtime will be in exactly the same situation.
I think most people vastly under-estimate the difficulty of re-implementing the perl5 runtime. To get something that implements every bit of current perl language functionality, including all the weird edge cases involving tying, overload etc, and with a performance comparable with the current runtime, would take, IMHO, a team of several people several years. To also have the new runtime support all existing XS modules would be nearly impossible. 
Liz is very well experienced in runtime implementations.
dave_the_m2 is an *expert* in the Perl implementation. Trust him.
One of the points I will be addressing in my presentation, is the dependency of Perl 5 on XS. Intended as a gateway to interfacing with external libraries, XS has turned into a drug that will be turned to whenever Perl 5 doesn't cut it performance-wise. Perl 5 needs to be weaned from this use of XS to be able to move forward. Most of the user code in the world, does *not* create its own XS submodules: if a user does do it for private code, they know what they're getting into. But usually it is so much effort that it either lives in a local module, or finds its way to CPAN after all. So my premise is that most of the XS in the world either lives in core, or on CPAN. And thus provides an opportunity for replacement, without having to need to support XS itself.
Thank you, but as I've already stated: it's not a itch that I want to be scratching personally. Although I would support anybody who would.
For what it's worth, I've been described as too pragmatic by some in the past. I know in one case, it means that a large code base is still suffering from a dependency on a severely borgified version of `Class::DBI` (as far as I know). However, this dependency at the time, allowed the company to quickly grow with manageable scaling issues. As a pragmatist, I see the current situation ("mess" as some would call it) and try to come up with a path towards the future that will be beneficial for all involved in the end. Because I still believe that the sum of Perl 5 and Perl 6 is greater than its parts. This doesn't mean it will be smooth sailing getting there.
One way to solve the problem is to make the "Perl" brand an umbrella brand - and create sub-brands for Perl-related languages, projects and conferences etc. A proposal for Perl's branding has been recently updated with some new sub-brand names for Perl 6: http://nigelhamilton.com/perl-branding-proposal.html 
Disturbingly, this is *not* an April Fools joke. 
Why accept Bash but not Perl? :(
I totally understand that approach. I just don't see any possibility for it to work unless the name changes, realistically.
If I'm understanding correctly, this means that your proposal to reimplement the language in a modern runtime also requires reimplementing half of CPAN in the same fell swoop.
Yet more anti perl bigotry it seems :/
I think it all boils down to knowhow drain: if you don't have enough people available to judge results, then you cannot be expected to accept results in that language :-( I also find this worrying.
For some numbers rather than hyperbole: A cursory search of CPAN shows [1547 distributions using XS](https://grep.metacpan.org/search?p=52&amp;qd=&amp;qft=&amp;qci=&amp;q=(use|require)\s*(Dyna|XS)Loader&amp;qls=) and the search gave up after getting to M, so the number is likely around 3000. There are currently 37037 indexed distributions on CPAN.
I don't think it's bigotry as much as lack of interest.
Can you inline the perl and stick it as a bash script. 
&gt; I had to use Bash (yes, it's supported) and Java (where floats were needed) There is nothing in-between? Bash and Java are such two opposite ends from Perl.
&gt; We may expand the list of supported languages prior to the launch of the Qualification Round, and we will keep the FAQs updated accordingly. https://code.google.com/codejam/resources/faq#languages Maybe there's a feedback link somewhere to request Perl support?
That's a good question. Since Perl is usually installed by default, as long as you don't have any dependencies, it's hard to argue that there's any difference between using `perl` and using anything else, like `sed` or `grep` (unless you're a hater and, man, are there haters).
[We've had this discussion before](https://www.reddit.com/r/perl/comments/7rio6d/long_live_perl_5/). I believe the idea that "XS is primarily used to speed up Perl" is dangerously wrong. Liz believes it's desirable to reimplement Perl without XS.
There's a fair amount of active hatred of Perl, rather than just ignorance or lack of experience/interest. It's a real shame, because Perl continues to be the first tool I reach for (because it's my "native" language). Not because I can't use anything else, but because nothing else makes as much sense to me. Nothing else lets me be myself. My usual answer to people who think Perl is ugly or "write-only" or slow or whatever is that the difference between Perl and most other languages is freedom. Perl gives you the freedom to write code the way you want to write it. The only problem with a lot of freedom is that we can get ourselves into lots of trouble, and sometimes those problems that we create can impact others as well. Lots of people have found themselves on the receiving end of those Perl freedom problems. And there are also lots of people who got themselves into their own kind of Perl trouble, and rather than learning about how to prevent those problems in the future, they blamed the language that gave them the freedom in the first place, and moved to a community where there is less freedom.
That link doesn't work for me. But thanks for the idea. If that number is true, than the Butterfly Perl 5 Project would even make more sense than I thought. And the number of troublesome modules to migrate to Perl 6 is even lower than I thought :-)
I think I fixed the link -- reddit was interpreting a backslash in the regex. While it's not half of CPAN, it's... an incredibly ambitious prospect, on top of that of reimplementing all of Perl.
Just out of curiosity, I googled the typical questions.. I felt very lost when trying to figure out the problems. What's the best way to learn how to solve the problems ? Is there a specific book(s) that I could pick up to learn more ? 
As someone who's been putting off learning python, why would I work to reduce the number of people who use perl regularly by abandoning it for python, when I already know perl very well, and there are no distinct advantages that python offers, other than perhaps more widespread use, because people are ditching perl for python, because others are ditching perl for python? Sure, it's not a bad idea to add another language to your tool kit, but I have to ask; is there a good reason to _stop_ using perl?
&gt; Apparently I cannot explain that you can have a Perl 5 without SV's. I thought Perl is "whatever passes the test suite". If you can make Perl's test suite pass completely without XS, I'll eat my words.
I find the people who think Perl is "write-only" are the same people who can't be bothered to pick up a book and learn the language.
I don't think there is any good reason to stop using Perl. It is never going to stop being installed nearly everywhere, as so many things rely on it. You can pretty much count on Perl being available on any UNIX-y system. That being said, one reason I am learning Python is so that I can take advantage of things like Matplotlib where there is no analog of the same quality in CPAN. Another of the major drawbacks of Perl is lack of good threading and multiprocessing support. (This is being corrected in Perl6, but that language hasn't gained much traction yet.)
They do have this on the page: &gt; May I use Unix utilities, e.g., invoking sed or cat via bash? &gt; Generally speaking, common Unix tools are available on our judging system. We encourage you to use the Practice Session to try any such utilities that you foresee using in the contest, to make sure that those tools are actually installed and that your code has the needed permissions to run them on the system.
It's certainly true that lots of terrible Perl code has been written, and because it has been such a life-blood of the internet, lots of that code is still around, and people hate to maintain it. Of course, lots of wonderful Perl code has been written too, but that's not what these people remember.
Whoa, did you read the context? I even quoted some.
Long story short: because of an implementation of Perl 6 arriving way too late, and because of Perl 6 being perceived as a completely different language from Perl 5.
Perl is too clever, too flexible, too powerful, too extensile with CPAN modules. Sounds like no reasons to give on Perl? Well because TIMTOWTDI, people code in Perl differently. This gives the impression of obfuscation. People prefer simplicity over cleverness or power.
1. Perl 6 taking 20 years and being seen as "The next version of perl" for the first 10 didn't help. 2. Really seriously crappy .com boom code giving it a bad rep. 3. Perl is easy to learn, but has a lot of depth - so it's hard to master. In a crowded landscape where you're expected to have fluency in javascript, python, ruby, PHP, go, java and others, that's a tall ask, so in many environments it's fallen off the radar. 4. Perl's provides a programming environment that's highly pragmatic - and thus lacks the theoretical purity of other languages (or is not filthy-dirty-pragmatic like PHP). So academics - i.e. influencers of students - tend to really hate it. Managers can be not fond of it too, because you can do a lot with a small team of competent perl developers, so understanding and demonstrating your staffs' productivity can be difficult. 5. Perl's biggest strength is also its biggest weakness - 'There's more than one way to do it'. However, for any 'normal' programming task perl is absolutely fine, and will give any other language a run for its money, (pragmatic)performance wise, readability wise and reliability wise. Personally my perl skills have been in such high demand over the last 10 years I've not had the opportunity to learn another language in the same depth. I'd quite like to do so - as long as said other language wasn't java or c#
No one did that here, so let me blame education. Can we expect people learning to code in Java to value flexibility and TIMTOWTDI-ness? These programmers confuse there are many ways to do it with let's do it in the most fucked up way possible. No explicit casting between numbers and strings IMO is awesome. But I heard other smart people say it gives programmers too much freedom to make a mess. Maybe true, but I trust myself and my fellow coders not to and use these features appropriately. In a world where we teach students to not trust themselves and fellow coders by teaching them an orthodox language we can not expect them to love Perl the way smart hackers neither sworn to Lisp nor APL do.
I'm afraid I'm a bit more pragmatic than that. I'll be going for whatever module / system written in Perl 5 has for testing, and count every complete pass as a success towards. Having the Perl's test suite pass completely is a goal that would be nice to reach, but in this case I think the travelling there is more important. So don't worry, chances that you will need to eat your words are minimal. But this is not about you or me. This is about Perl.
It feels like it is not being developed anymore: that is lack of open big corporation support, like Google, Microsoft, or Facebook. Even the most impressive effort put currently at core development, that is MoarVM back-end in Perl6, feels like a three souls hobby project with big trolling issues, that could get a huge use of 10 fulltime paid developers. In fact it is the whole free software concept and perhaps internet as a whole that has been mostly taken over. But it is very difficult to grasp at a short sight.
Yeah, I comment about this fairly frequently, about the freedom of Perl. Not only is that what I love about it, and why I continue to use it so much. But it's also a big reason why people hate it. With great freedom comes great opportunity to do Bad Things. Those things can result in code that is very difficult to understand, code that doesn't perform well, or both. That freedom can also result in code that performs incredibly well, and which is super easy to read and follow. Another thing about old Perl code... there's a lot of it. Perl was very heavily used in the early days of the internet, and has continued to be used as a "glue" language for lots of things. Nobody really likes going into where things have been glued and pulling apart that glue and replacing it with something else, so people love to throw out the old glue and replace it with anything besides glue. So you add the "freedom problem" to the fact that there has been very little excitement in the Perl 5 space (I won't even get into Perl 6 and its relationship with Perl 5), plus lots of excitement in the JavaScript space (Node, React, etc) -- then all sorts of new things like Go and a million other projects I haven't even heard of yet -- it's no surprise at all that people are not gravitating towards Perl. If they do want to use a "dinosaur" language, it's going to be Python or Ruby, in most cases.
Which other languages? Today's flashy, shiny companies are all ad-tech, i.e. "surveilling people's web browsing and shoving targeted ads at their faces." That's JS on the front-end and something like C for analysis on the back-end. Google standardized on Python for its scripting, while (I think) Facebook uses PHP; I'm not sure what MS uses internally, but I doubt it's Perl. So I'd say Perl's unpopularity is mostly a historical accident. And although it may not be a "cool" language, it's still a great glue language, and it's not going away anytime soon.
&gt; it's not going away anytime soon. You say that. But every client I've worked for in the last nine years (oh, wait - there might be one exception) has at least started to move away from Perl. And people aren't doing it because Perl is a particularly bad language to use - they're doing it because they can't find enough Perl developers.
1, Nobody is doing new work in Perl 5 because Perl 6 has arrived. Why would you learn the outdated language? If it's not outdated, why do you have two languages named the same thing that are different? 2. Python - which fills the exact same space as Perl has surpassed Java as the language of choice for Colleges and Universities to teach students with. Students are leaving schools already knowing Python - why would they learn another language that doesn't buy them anything, and why would businesses start new projects in Perl, when most of their new employees already know Python. I like Perl 5, but it's time to move on. Technology continues to change, and so must we. I know plenty of COBOL programmers that couldn't get a job because they didn't update their skills and stay current. RPG3 - it was great for reports, but nobody ever hears of it now. DOS? Windows NT, HP-UX, Fortran, BASIC? Yea, some of that is still around - sort of. But you can't get a job doing them as your primary skill. Perl is headed this way. Here's the TIOBE index: https://www.tiobe.com/tiobe-index/ Perl used to be #3 on the list. In a few years it won't even be in the top 20 
Legacy code. It's a victim of it's own popularity. Easy to pick up. Easy to say you know it. Easy to make something that works, even if it isn't easy to maintain. Hell that last one has lead to my day job--I maintain some ugly-ass perl code. (on 5.10, no less :-| ). Give it more time and I think similar things will happen with python and other tremendously popular languages--I've seen some ugly python code in our code base too. We're constantly chasing the next big thing--look at ruby, it's sprang up as better-perl but is rapidly losing favor.
&gt; ugly ass-perl code *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
Perl 6 **most definitely is** a different language from Perl 5. It has neither backward compatibility nor any plans toward it. The perception is valid and desired. At this point, Perl6 needs a completely different name: Papillon perhaps, or some other word for butterfly. This could reflect a logo that took six minutes in MS Paint.
It's annoying enough when real users do this. Do we really need this fucking bot?
Here's my laundry list: * Low performance * High memory usage * Lack of threading * obtuse syntax with tons of {} %@$ crap, * the named-vs-reference container dichotomy, e.g. @foo vs. @$foo, * too many language shortcuts / odd features that keep on surprising even people who already use the language. My favorite example of the last category: $ perl -wle 'for my $x (qw(foo foo)) { print "yes" if $x =~ m?foo?; }' yes $ perl -wle 'for my $x (qw(foo foo)) { print "yes" if $x =~ m/foo/; }' yes yes
Multiple languages have been named for coffee, only two of which relate to each other. I try to be positive in life. However the P6 situation is where my emotions have decided to bank lots of my ire and bile. So I must fight myself not to get angry about the mamby-pamby talk that comes from the P6ers. "It's different, but it's not, but it's the future, but we have no plans...". It's as if Larry Wall had taken [est](https://en.wikipedia.org/wiki/Erhard_Seminars_Training): "I really wanna find myself, even though this means abandoning my existing family." So I hope the Parrot Butterfly Committee Horse one day finds the gumption to be something new. Then we can simply pick up with Perl 5.24 as Perl v24 and apply some renewal.
**Erhard Seminars Training** Erhard Seminars Training (marketed as est, though often encountered as EST or Est), an organization founded by Werner Erhard in 1971, offered a two-weekend (60-hour) course known officially as "The est Standard Training". This seminar aimed "to transform one's ability to experience living so that the situations one had been trying to change or had been putting up with, clear up just in the process of life itself". An est site claims that it "brought to the forefront the ideas of transformation, personal responsibility, accountability, and possibility". Est seminars took place from late 1971 to late 1984, and spawned a number of books from 1976 to 2011. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
* I think you'd have to be more specific about "low performance" since Perl is consistently shown to be pretty performant when using the right tools -- and usually you can leverage someone else's C code from CPAN if you really have a performance bottleneck. Give the latest release a try, performance of common tasks is greatly optimized release after release. Compared to every other scripting language I'm not seeing how performance is an issue. * Absolutely agree with the memory usage and threading problems. Though as with most scripting languages there are workarounds for better memory management, and in 90% of cases threading was not the optimal solution to your problem anyway (and to be clear, I am not discounting the cases where it would be). * The sigil syntax is completely personal preference and familiarity with the language. Personally (and I hear many other Perl programmers say) the sigils make code much more readable as I can see where variables are and what they are doing at a glance. * [the named-vs-referenced container dichotomy, e.g. @foo vs. @$foo] I'm afraid I don't understand this criticism. * [lack of standardized exception model, and no stack trace when program dies] This is indeed still a deficiency in the core, fortunately there is now [Syntax::Keyword::Try](https://metacpan.org/pod/Syntax::Keyword::Try) to provide a very close experience to standardized try/catch in other languages, and [Exception::Class](https://metacpan.org/pod/Exception::Class) has long been a standard way to create exception objects (and of course, there are plenty of choices). For stack traces you can run a program with [Devel::Confess](https://metacpan.org/pod/Devel::Confess), or use [confess from Carp](https://metacpan.org/pod/Carp) or a stack-aware exception object like [Throwable::Error](https://metacpan.org/pod/Throwable::Error). Stack-aware exceptions are usually not used by default to avoid cluttering up logs though it is indeed unfortunate when you need such a trace. * [too many language shortcuts / odd features that keep on surprising even people who already use the language] Absolutely, though I would challenge you to prove that there are less of these in any other scripting language. For what it's worth, I wrote some [policies](https://metacpan.org/pod/Perl::Critic::Freenode) that help you avoid some of the worst gotchas.
You know Perl 5.26 is out now right? ;)
You could say this about Javascript or a few other languages. That's no reason to hate the language. But eh, here we are, I guess.
Perl 5 is definitely not outdated, though.
Do you know how hard it is to find a good COBOL programmer these days?
My experience from colleagues: * perl is perceived as being less maintainable * Python is perceived as having a much more robust suite of libraries A former colleague of mine, who was quite fluent in perl (although he tended to write "c-like perl"), spoke of learning Python and appreciating its being high-level. He also said "I can go back six months later and understand what I wrote." In my experience, I learned Python because I had trouble finding libraries to format my output to my liking. I was able to, in about a day, learn Python and write a program that reds an Excel spreadsheet, extract and correlate data, and then present formatted data. I still like perl and will likely continue using it when I need to do "system level" stuff -- a step above Bash scripts. For team-oriented things, and for maintainability, I will likely use Python. 
It's perceived as old and ugly. Herd behavior. Everything dies. However I noticed 300% percent of increase in browsing of this sub within last 12 months.
True dat. And as python and perl are really similar to each other (I’ve described python as perl for java programmers before) it gives the kids a useful skill under their belt. I don’t think python scales to large code based as well as perl does though. 
&gt; A programming language is only good if people are using it. That entirely depends on your definition of "good". Perl will continue being good as long as it's useful.
&gt; The Amiga computer wasn't outdated either The thing is, the Amiga is outdated. _Perl 5 isn't._ It's being actively developed nowadays, and still being used. I also like Visual Basic 6.0 (yeah, in a twisted sort of way), but I don't code new projects in it anymore because, well, it's a _truly_ outdated language. Perl is getting new tweaks and new bug fixes as we speak. To be honest, as long as it gets the job done and well, I'll keep using it for as long as I can. It's a fun language. 
From the languages available, I just chose the ones I knew best. It would have taken me weeks before I knew as much about Python as I know about Bash.
My first year or so on my first job out of college we had some perl scripting going on, but nothing really heavy. Was mostly a lot of log parsing. I picked up a book and sort of learned on the go and then ended up using it over a few years when I had tasks that fit where perl is strong. Overall I liked it but I had a hard time reading other people's perl code if they did it differently. There are so many implicit variables in perl you can shorten things up a lot. It's fine if you only do perl, but if you are switching languages up, it can be rough to come back into it and remember all the details. They aren't right in front of you if you take advantage of you which makes it just harder to read. Another issue I had, which is also probably due to a learning gap, was moving the perl script around. I also happened to run into a wide variety of machines, and this was around the 2005ish era so we had 32/64 bit windows machines, mac, linux, just all over the place. If I used something from CPAN most likely it wasn't going to work on someone else's machine and a lot of times that person wouldn't even know what cpan is. I used activestate when I could because module installing was a GUI that was easier on people not having the time to set up their machine. I think I switched to strawberry in the end because at least it was more consistent. But honestly you'd get weird things where the module wasn't compiled or available in the os / 32/64 bit / perl version combination that was on that machine. I found PAR but I honestly couldn't figure out how to get it working. Maybe docker would have been helpful but not sure if that was around when I was doing it. This part was again probably an education gap on my end, but I wasn't the only one that stumbled on moving their perl scripts around to other machines. It was mostly okay if you didn't touch cpan, which then loses a lot of the strength of perl. I haven't used a lot of python but from the few things I've seen it feels closer to other languages. Again probably a learning gap but I never figured out perl objects and ended up using hashes of hashes to store things which was sort of it's own mess. I'd honestly use python going forward if I could get myself to learn it, though when I started my most recent job had to just go full out perl mode due to needing to get things done fast. Still works great and is nice to use just, eh. But yeah those were some of the downfalls I ran into using it over the years, and I'm very sure there were ways to avoid the problems I ran into had I been able to find them. At the end of the day though I have some fond memories of banging out scripts to crunch large text files with perl and it really does do its job super nice. 
I think it's sad that nobody challenged the assumption here. This is a perfect example of what's called begging the question. What does it mean for perl to be "unpopular"? Where's the evidence that it is being abandoned?
I would have replied with counter argument, but you say in your profile you are a "bot". 
I am many things. The bot parts are Perl. Happy to see your "counter argument", but my point remains. You posted "why is X true?" without proving that X is true. I'm shocked that nobody challenged you. I'm not even challenging you. I'm surprised that nobody else did. As English is the official language of the USA, why don't more immigrants learn to speak it properly?
Though I think there's sufficient evidence of this, I don't think there's sufficient evidence that it's a recent trend. Perl is not really any more unpopular or abandoned than it was 10 years ago.
I think you can safely add "6. While ported to windows, it's still perceived as more of a linux tool". I've had a large number of "windows only java/C developers" work for me, and the idea of using perl seems foreign, even when they are working on a linux box. Younger devs are also more likely to have been taught python as it's gained traction as a teaching language. 
&gt; It's falling off the top 20 list rapidly 13 Years ago I worked with people who claimed perl was absolutely dead. Yet now it clearly isn't. That doesn't seem very rapid to me.
Why do you think I wrote it?
My first programming job was perl back in '97 for the LAMP stack. There was a lot of neat things that I did with it back then... and clever too. I remember writing a neat Tie::Array that was backed by a database... and then undoing it because it was too clever and not something that was maintainable. The last time I touched perl professionally was in '09 during the perl winter. The web stack was moving in other directions - especially that of Java (I'm a corporate back end line of business keep the gears of the company turning type). I write boring code - which is good. Boring code doesn't surprise people and when I pull it up from 10 years ago, it still works. I try to avoid clever code now - it takes too long to get back into the mindset that I had when I wrote it. I'll admit to one bit of clever code with annotations on an enum that I've written in the past half decade... and that is in place to force what would be runtime errors to be compile time errors instead. I looked at perl 6... there's even a [bug report with my name on it](https://github.com/rakudo/rakudo/commit/8d04bec). I really want to like the language - it makes me think about some things differently... and here's the "but". But it all feels too clever. Code needs to be reasonable - something that I can come back to later and pick up again and continue on with minimal switching of the mind. Unicode operators, Junctions (as neat as they are), redefining operators... its letting me and encouraging me to write clever code. I pull up the docs and see things from [Operators - Common Perl 6 infixes, prefixes, postfixes, and more!](https://docs.perl6.org/language/operators) that make me wonder if its gone too far. There's more than one way to do it... but there are more of them than [Java 8's list](https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html). I feel that there's more than one way is "more than one approach" not "more than one way to type '+'". The code just doesn't feel reasonable anymore. For what its worth, after not touching perl professional since '09, this past month I was called on to fix a LAMP stack. There's the CGI with a nice 'use CGI.pm' (the last change time on the file was from 2011). I was able to open it up, read it, debug it, and fix it in under an hour. It was straight forward, sensible, and reasonable code. I shutter to think what it will be like in another decade if someone comes by and asks someone to debug some 10 year old perl6 code and they open it up to find unicode scattered through it and trying to remember what =~= or ∘ does. For my scripting needs now... I've been a Java coder for the past decade. When I want a script I'm more likely to fire up groovy. It runs, its stable, and it doesn't try to make me write clever code. Sorry perl... you're just not my go to language for thought to code anymore.. and thinking in perl6 just isn't something that I'll find myself easily writing once or being able to figure out when coming back to later. And perl5, you aren't what the industry is calling for anymore. As I said, I've been a Java coder for the past decade. It pays the bills quite nicely and I know that if I keep up with that tech stack, I'll always have a job without having to look too far. To pivot back to perl as a language, the jobs that list perl now are a handful of sysadmin and bioinformatics (which I don't know squat about). LAMP isn't a stack that is asked for anymore. Schools are turning out programmers that have a not awful fit for Java or C# shops and the industry is asking for those skills. Building big code in Perl is certainly possible, but its harder to teach to students that only know one language. The free wheeling thoughts that are so easy to express in perl are the anathema of larger organizations that need consistency of code and desire the ability to juggle developers from team to team or onboard more quickly. Hiring someone out of college for perl means months of getting them adjusted to a way of thinking that was never conceived of in college... and hiring another perl programmer means months of shifting to the conventions of that stack. It takes a lot of work to keep the scripting languages reasonable when its too easy to do things that might not be the best thing to do. The ROI is debatable on hiring another perl coder (the only time the experienced ones show up is when another company closes... and then half of the perl coders from that company retire instead). It is possibly better to shift that code to python (no, I don't like that language at all) or ruby on rails (ick), or powershell (which doesn't look too unperlish) and be able to hire people out of bootcamps more easily.
I think to add to the list: cpan and package management is daunting. I've always thought the cpan system needs an overhaul on how they are installed and managed in a project. Metacpan does a refresh of the web of cpan but if you look at a tool like maven (java), npm (js), those seem to be easier to get things running. I think cpanminus has really helped, I think also what hurts cpan is stale and forgotten modules, one could have 10 reviews with 5 stars but then 3 issues from 2008...and its last update was 2008. I also wish the hurdle to add modules to cpan was easier for beginners to get into it. Is this hurting the language, possibly. 
&gt; Where's the evidence that it is being abandoned? I'm a freelance Perl programmer. Here's a list of the clients I've worked for in the last ten years. They were all using Perl when I was working for them. * 2008 (well-know newpaper) - rewrote all of their systems in Java and other languages. * 2008/9 (DVD rental service) - taken over by a much larger company and rewrote most of their systems in Java. * 2009/11 (classified ads site) - rewrote their systems in Java. * 2011 (web site builder) - taken over by a larger company and rewrote all of their systems (not sure what language) * 2011-15 (fashion business) - moving to a microservices architecture and very little new development in Perl * 2015/16 (recruitment services) - I think most of their development is still Perl * 2016 (investment bank) - Still use a tiny amount of Perl * 2017/8 (property portal) - Moving to a microservices architecture to remove their reliance on Perl I've been freelancing as a Perl developer in London since 1995. There's no question that the market for those skills has fallen over that time. The only reason I can still find work realtively easily is because the number of developers wanting to work on Perl is falling quicker than the number of companies who need Perl developers.
OOC, why can't you give it a GUI in Perl 6?
Because GTK::Simple won't install, and I don't think there are other GUIs available that will work on my system. 
Then perhaps open an issue at https://github.com/perl6/gtk-simple/issues ? Also with regards to `Inline::Perl5` perhaps? https://github.com/niner/Inline-Perl5/issues
Sys::Linux::Syscall::Execve! That's me! As it documents, it's mostly useless to anybody who isn't using Seccomp or similar sand boxing technologies. I'm using it as part of App::EvalServerAdvanced that powers https://perl.bot/ and the perlbot IRC bot on freenode, magnet and oftc.
Similarly: https://rt.cpan.org/Public/Dist/Display.html?Name=Inline-Perl6
&gt; anything less will probably not work. Bummer! I know *nothing* about sockets. Guess it's time to start learning. ;) &gt; what modules are you having trouble with on Strawberry Perl? Honestly? I don't remember. I've tried so many things and gone so deep into the rabbit hole that I couldn't tell you right now. But I'll do some cleanup and report back. ツ
&gt; Then perhaps open an issue at https://github.com/perl6/gtk-simple/issues ? It's already open: [This is my exact problem.](https://github.com/perl6/gtk-simple/issues/82) &gt; Also with regards to Inline::Perl5 perhaps? Will do!
I think it's a good example of begging the question, but probably not necessary here. To address your question - because we're tired of challenging this assumption, especially in this forum. To address the original poster's question - IMO all languages are on the slope to irrelevance, if relevance is defined as popularity, I partially addressed this a few months ago in a [blog post](https://leejo.github.io/2017/12/17/tpc_and_the_end_of_language_dominance/). 
I wonder if time would be better spent trying to figure out why you "active state modules" don't work on strawberry, and fix them to work on strawberry/both.. I didn't have any problems making Prima and Wx work on the recent strawberry releases (Win x64), and since working with GUI in Perl is always a pain, I'd get other parts working to reduce pain points.
https://shadow.cat/blog/matt-s-trout/mstpan-1/ goes over them pretty well.
Yeah, you're probably right. It's just that I only installed Strawberry Perl recently, so I haven't used it much. I was wary of installing it for fear of breaking my current workflow, but it turned out to be very well-behaved. So I'll be experimienting with it quite a bit in the next few weeks.
For starters, as much as possible, utilise only up until column 80. Adhere to a coding standards. I myself use a modified version of the Drupal coding standards. 
Most of my stylistic suggestions would be represented by what these policies I wrote check for: https://metacpan.org/pod/Perl::Critic::Freenode More generally, modularity (in organizing your code in actual modules, as well as in subroutines that do specific straightforward things) and testing (which is easier with more modular code) are qualities important to keep code maintainable that are often skipped when trying to hack up solutions quickly. You can always add them/refactor later but it's even better to start with them in mind. Don't be afraid of CPAN. Set up a mechanism to be able to install and deploy with any CPAN modules you might want to use in the future. [Carton](https://metacpan.org/pod/Carton) is a good way to manage this and pin your dependency versions to avoid surprises (and carton exec is not actually needed, see https://github.com/perl-carton/carton/issues/197). Alternatively you can use a package management system like RPM.
This is for starting new processes, it won't be helpful here.
- Always `use strict;` and `use warnings;`. - Meaningful variable names, consistently used. (Never one letter names, unless it's 'special' variables like `$a` and `$b` in a sort) - Format your code - `perltidy -pbp` is a pretty good default. (You can customise perltidy to 'house style' if you prefer). - Subroutines that stay shorter than 'a page' on screen, so they're readable in one go. (That also goes for your 'main' program). - Don't go nuts with "clever" code - perl lets you do this really easily, and it's a massive temptation - but write _clear_ code first, even if it's longer. - Don't prematurely optimise - write the code to be clear, optimise later if you've profiled it and it needs it (it often doesn't). - Profile code if you're trying to get it to be fast, don't guess. - Use perl inbuilt functions rather than shelling out. (e.g. don't call `sed` to do a search/replace) - Don't magic-regex. If your regex is getting complicated, decompose the problem into multiple. It's a lot clearer to have two regexes for "must contain a letter" and "must contain a number" than it is to try and glue them together into a single one. - Use `x` with any regexes that are looking slightly complicated, and format and comment them. - you will forget what it does in 6 months. Make it easy to come back to. This will also help other maintenance programmers. 
I would argue that XML is entirely unsuitable for almost everything. Not overkill, just unsuitable. Unfortunately many parts of the industry have adopted XML because they like being wrong.
`use warnings; use strict;`. Or `use Moo;`. If learning Moo, learn about lazy attributes early, and use them often. This has the effect of making it easy to create objects with the minimum number of things required to make a `-&gt;new` one. And really makes extending/modifying things later easy. Learn about lexical scope, and use it to your advantage. 
See suggestions of u/sobrique below. Very good advice. Some of my own advice after 9 years Perl development. Perl if often criticized for being line noise, mostly due to `$@%` sigils. Few people know you can remove so much line noise of other kinds: quotes and parens. * Learn the precedence of *commonly used* operators, avoid parens if unnecessary if ($foo == 2 &amp;&amp; $bar == 42) # e.g. (un)equality operator always take precedence over logical ones * Predeclared function calls don't need parens, unless it's ambiguous open FH, $filename; * Addressing hashes auto-quotes keys, if consisting of word chars $foo{bar} $foo{'baz-spam'} * Use the fat-comma `=&gt;` operator in lists, e.g. key-value pairs, it auto-quotes strings in front of them %nums = (one =&gt; 1, two =&gt; 2, three =&gt; 3); * Use `qw` to define a list of strings @words = ('foo', 'bar', 'baz', 'spam'); # ugly like Python @words = qw(foo bar baz spam); * Use `qq` to define a double-quoted string containing double quotes, instead of escaping them $xml = "&lt;node attr=\"foo\"&gt;$variable&lt;/node&gt;"; # Ugly $xml = qq(&lt;node attr="foo"&gt;$variable&lt;/node&gt;); # Nice * Use here-docs for defining multi-line strings, instead of concatenating multiple ones $sql = "select * from foo f\n" . "left join bar b on f.baz = b.baz\n" . "where f.spam = 'egg';" $sql = &lt;&lt;EOF; select * from foo f left join bar b on f.baz = b.baz where f.spam = 'egg'; EOF Git friendly coding, taking advantage of Git's auto-merging where possible, even if it's contrary to [perlstyle](https://perldoc.perl.org/perlstyle.html): * In long lists of key-value pairs, each pair stands alone on a line, and each is closed by a comma, even the last one, and the pairs are NOT lined up. Thus you never need to modify lines containing existing key-value pairs, helping to merge engine to find context for changes. Good example: Original code: aliens( 'Casey Stoner' =&gt; 27, 'Marc Marquez' =&gt; 93, ); Changed on one branch: aliens( 'Casey Stoner' =&gt; 27, 'Jorge Lorenzo' =&gt; 99, 'Marc Marquez' =&gt; 93, ); Changed on another branch: aliens( 'Valentino Rossi' =&gt; 46, 'Casey Stoner' =&gt; 27, 'Marc Marquez' =&gt; 93, 'Johann Zarco' =&gt; 5, ); Merged automatically aliens( 'Valentino Rossi' =&gt; 46, 'Casey Stoner' =&gt; 27, 'Jorge Lorenzo' =&gt; 99, 'Marc Marquez' =&gt; 93, 'Johann Zarco' =&gt; 5, ); 
Thank you!
Regarding the 'line noise' - I think a lot of that is down to regular expressions. Being able to inline `s` and `m` regex is really useful, but it's also a good road to hard-to-grok code. I'd advocate for that case using `qr//` to compile a regex when it's complicated, and replace the regex with a variable. e.g.: my $valid_username = qr/^[A-Z] #starts with a capital letter \w{6,8} #6-8 alphanumerics $ #nothing else /x; And then use that instead of inlining it.
Actually, Dist::Zilla is the 110% solution, with everything you might possibly need. https://metacpan.org/pod/Minilla is the 90% solution for CPAN authors, with just the right defaults and trade-offs. Would reccomend.
`use strict` but don't declare everything at the top of the file or with `use vars`. That defeats half the purpose of strict. `use warnings` and fix the source of the warnings. Code should not produce earnings; if it does you didn't account for something. If you generate SQL statements from code, always prefer bind parameters rather than quoting. Don't become the fruit through which SQL injection occurs. Write meaningful unit tests for your code. Run the tests. Fix any that fail. I would suggest starting with the test but that can be a difficult mindset to get into properly. Sanitize all user input. ALL OF IT. I would say "trust but verify" but the wrong. "Trust nothing and bake everything. 
In complicated regexes, I prefer to put the modifiers up-front: my $identifier = qr/(?ix) # case insensitive, extended: [aoueiy] # a vowel \w{3} # three alpha-nums \S # anything that is not whitespace /; 
Hmm, that's a good tip. I'll probably start doing that. 
Short answer: write *idiomatic* Perl. Slightly longer answer: read [Higher-Order Perl](https://hop.perl.plover.com/) or just about anything by the great masters of the craft. 
Just to add that even if I can do it all in Strawberry and thus avoid the need for interprocess communication, implementing this would be interesting anyway because it would open the door to stuff like writing the interface in a completely different language. 
I think this one is arguably the most important for any language: &gt; Don't go nuts with "clever" code - perl lets you do this really easily, and it's a massive temptation - but write *clear* code first, even if it's longer. A couple of other things that came to mind: there's Damian Conway's *Perl Best Practices*. It was published in 2005 so it's a bit dated, but most of it still applies. Or check the *perlstyle* document that comes with Perl (which is also rather old). 
Prioritize readability over cleverness. 
I would suggest to try writing it in Perl then translate into Python. The first day can be slow as you will google a lot (a book would help significantly), but the second day can be faster. By the third day, you probably will prefer writing in Python directly (while still think in Perl). Both bash and Java will force you to think very differently. Most of the programming skill is not in the language itself, so you may be surprised that there is not that much for you to catch up -- other than habits (so-called convenience).
Lots of good suggestions here. My snarky $.02 is that many Perl 5 devs are going to make fun of you or be patronizing, no matter [what you do](https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it). Looking at you, [PerlMonks](http://perlmonks.org/). I started coding in Perl in y2k, then moved to languages where there are fewer jerks in the community. I love Perl. I still have applications written in Perl written in 2004 running in various countries around the world, processing massive amounts of telecom data. Hopefully the community has lightened up a bit.
**There's more than one way to do it** There's more than one way to do it (TMTOWTDI or TIMTOWTDI, pronounced Tim Toady) is a Perl programming motto. The language was designed with this idea in mind, in that it “doesn't try to tell the programmer how to program.” As proponents of this motto argue, this philosophy makes it easy to write concise statements like or the more traditional or even the more verbose: This motto has been very much discussed in the Perl community, and eventually extended to There’s more than one way to do it, but sometimes consistency is not a bad thing either (TIMTOWTDIBSCINABTE, pronounced Tim Toady Bicarbonate). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/perl/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
$0.02 Once you're already in the world of coordinating two programs separating logic from GUI that much just use a web interface and standalone webapp packaging its own server. It's a lot easier with far more support in the world than a perl binding for a native GUI library. In Perl 6 you could use a single page app via Cro in Perl 5 Mojolicious?
I always hear this, but I never really understand why. Terminals have been more than 80 chars for a LONG time. On my 1080p monitor I can get 130 characters on a line and **still** have 30% of the screen left. I feel like the 80 char thing is an arbitrary limitation that causes more problems than it helps. &lt; 1% of my code is more than 80 chars, and the part that is longer isn't really a problem for me.
I wish I could upvote this 100x. This is spot on advice, not just for Perl but for programming in general. Well said.
Do people still use Perl::Critic? I found that useful. Also, chromatic's Modern Perl and Moose.
Write code that you will be able understand when you come back to it in 6 months or 6 years. 
Many people focus on the syntax and what you type, but I'd rather you wrote baby Perl in a well organized and thoughtfully architected bit of code than the other way around. Instead of thinking at the statement level, organize the much larger picture. It's easier to later go back to improve the statements than it is to change the organization.
Try kritika.io too. It has some preconfigured rules that you can later adjust.
Don't you occasionally print your code? Hardcopy is still the best way to scribble and draw arrows and question marks all over code. Not to mention being preferable whilst on the train or in the, um, Reading Room.
&gt; Storable might look like a good idea, but it rarely is because it's perl (and sometimes version/platform) specific. [Sereal](https://metacpan.org/pod/Sereal) is sometimes a good solution in this area because it's not specific to a version of Perl, or even Perl (it has interfaces in other languages). Also it's usually faster, supports built-in compression, and supports regex refs.
I would take Perl Best Practices with a heavy grain of salt. Note that its suggestions are implemented in the default perlcritic rules, and many of them are not good ideas -- they are practices to consider, not to enforce (and in some cases they are just outdated).
+1 to Minilla. I always recommend this to new authors as a way to get started without having to read a bunch first.
`use strict;` and `use warnings;` at the top of *every* file (except the ones starting `use Moo;`, `use Moose;`, or `use Moops;`). Run `perlcritic -5` or `-4` regularly. If you want to go further, examine each coding practice and follow it. Use the `/x` flag on complicated regexes or, better, don't write them in the first place. Use CPAN. Particularly, use modern libraries, like `Moo` / `Moose` and DBIC (`DBIx::Class`). Use a recent version of Perl, and learn its features (subroutine signatures, `-&gt;@*` de-referencing, etc.).
While you're reviewing, explain your code to your sock puppet. If you can, and you're proud of it, it's good. If your sock puppet doesn't get what it's doing, you're writing bad code.
hi! I just pushed a commit to GTK::Simple's Build.pm that tries to use windows' built in (hopefully!) CertUtil.exe to do the sha256. Please try installing GTK::Simple again.
If all your lines are short, then you have less empty space on your screen (the few lines going out to 130 chars should be outliers) and you can fit more windows in.
Ah, thanks! Trying it right now. ... aaaand it failed. I did a `zef update` before trying to install just in case, but I'm still receiving the same error as before. C:\rakudo\bin&gt;zef install GTK::Simple ===&gt; Searching for: GTK::Simple ===&gt; Building: GTK::Simple:ver&lt;0.1.6&gt; At line:1 char:192 + ... )) -replace \"-\",\"\" } get-sha256 C:\Users\bit\.zef\store\gtk-simple.git\90475 ... + ~ You must provide a value expression following the '-' operator. At line:1 char:192 + "function get-sha256 { param($file);[system.bitconverter]::tostring([System.Secu ... + ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Unexpected token '\",\"\" } get-sha256 C:\Users\bit\.zef\store\gtk-simple.git\9047525955d2037ccc0ce7b5e2c9cb7b508c625 + CategoryInfo : ParserError: (:) [], ParentContainsErrorRecordException + FullyQualifiedErrorId : ExpectedValueExpression Bad download of libatk-1.0-0.dll (got: SHA256hashoffileC:\Users\bit\.zef\store\gtk-simple.git\9047525955d2037ccc0ce7b 1ff7464eda0c7ec9b87d23a075f7486c13d74c02a3b5d83a267ad091424185d9 CertUtil:-hashfilecommandcompletedsuccessfully. ; expected: 1FF7464EDA0C7EC9B87D23A075F7486C13D74C02A3B5D83A267AD091424185D9) in block at C:\Users\bit\.zef\store\gtk-simple.git\9047525955d2037ccc0ce7b5e2c9cb7b508c6252\Build.pm line 103 in method build at C:\Users\bit\.zef\store\gtk-simple.git\9047525955d2037ccc0ce7b5e2c9cb7b508c6252\Build.pm line 49 in block &lt;unit&gt; at -e line 1 ===&gt; Building [OK] for GTK::Simple:ver&lt;0.1.6&gt; ===&gt; Testing: GTK::Simple:ver&lt;0.1.6&gt; # Failed test at t\01-sanity.t line 12 # Failed to copy 'C:\Users\bit\.zef\store\gtk-simple.git\9047525955d2037ccc0ce7b5e2c9cb7b508c6252\resources\blib\lib\ # Failed test at t\01-sanity.t line 13 # Failed to copy 'C:\Users\bit\.zef\store\gtk-simple.git\9047525955d2037ccc0ce7b5e2c9cb7b508c6252\resources\blib\lib\ ry # Failed test at t\01-sanity.t line 14 # No such method 'run' for invocant of type 'Any' # Looks like you failed 3 tests of 3 ===&gt; Testing [FAIL]: GTK::Simple:ver&lt;0.1.6&gt; Aborting due to test failure: GTK::Simple:ver&lt;0.1.6&gt; (use --force-test to override) in code at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 385 in method test at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 36 in code at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 540 in sub at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 537 in method install at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line in sub MAIN at C:\rakudo\share\perl6\site\sources\9E04C517E18C976DC9F459E2CE31A87142034020 (Zef::CLI) line 152 in block &lt;unit&gt; at C:\rakudo\share\perl6\site\resources\3DCC2E58BBBF1E42EA4C8C976F9BE97162B9EFA2 line 3 in sub MAIN at C:\rakudo\share\perl6\site\bin\zef line 2 in block &lt;unit&gt; at C:\rakudo\share\perl6\site\bin\zef line 2 It looks like CertUtil did work? but there is a "bad download" of a dll? I'm bad for this. ¯\\\_(ツ)_/¯
The received sha is lowercase, but it's checking against an uppercase string. I've just pushed a fix for it. Try installing again. I don't know how long it takes zef to update its version database; if it fails, try direct URL to repo: zef --debug install https://github.com/perl6/gtk-simple/archive/master.zip
Same error with `zef install`. With the line you gave me, I get this other error: C:\rakudo&gt;zef --debug install https://github.com/perl6/gtk-simple/archive/master.zip ===&gt; Fetching: https://github.com/perl6/gtk-simple/archive/master.zip Fetching with plugin: Zef::Service::Shell::PowerShell::download+{&lt;anon|200476368&gt;} ===&gt; Fetching [FAIL]: https://github.com/perl6/gtk-simple/archive/master.zip from https://github.com/perl6/gtk-simple Aborting due to fetch failure: https://github.com/perl6/gtk-simple/archive/master.zip (use --force-fetch to override) in code at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 226 in method fetch at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 1 in method fetch at C:\rakudo\share\perl6\site\sources\9062A39D0256C0BD797016C3FE93D839191AFE2B (Zef::Client) line 1 in sub MAIN at C:\rakudo\share\perl6\site\sources\9E04C517E18C976DC9F459E2CE31A87142034020 (Zef::CLI) line 114 in block &lt;unit&gt; at C:\rakudo\share\perl6\site\resources\3DCC2E58BBBF1E42EA4C8C976F9BE97162B9EFA2 line 3 in sub MAIN at C:\rakudo\share\perl6\site\bin\zef line 2 in block &lt;unit&gt; at C:\rakudo\share\perl6\site\bin\zef line 2 I didn't say it before, but thanks for getting at this so quickly! 
&gt; I get this other error: Oh. I thought zef would work with a `.zip` URL. Do you have git installed? If yes, then this should work: zef --debug install https://github.com/perl6/gtk-simple.git If not, then wait a bit for zef to update its online database. Basically, running `zef update &amp; zef info GTK::Simple` should print `- Identity: GTK::Simple:ver&lt;0.1.7&gt;` with `0.1.7` there (the version). Or you could download https://github.com/perl6/gtk-simple/archive/master.zip unpack it somewhere, and then run `zef --debug install C:/that-directory-where-you-unpacked-it/` 
ＹＥＳＳＳＳＳＳＳＳＳＳＳＳ WE DID IT, REDDIT!!! (?) 
&gt; As English is the official language of the USA [Actually, it's not.](https://en.wikipedia.org/wiki/Languages_of_the_United_States#Official_language_status)
Whoosh. 
As a still relatively new noob to Perl, thanks for all the feedback on how to code well in Perl 5. I am sure this feedback will be useful for many new people to Perl in years to come. I am thinking about all the feedback, and am thinking how to apply it as I code all my business processes in Perl 5. This has already helped me improve my code for something I wrote last night. 
Vertical space is at a premium, losing that through excessive linewrapping is a high price to pay. Even Reddit doesn't have an 80 character line limit! "Write short but readable code", "use linebreaks consistently", "don't try to pack everything into one line" - advice like this might be reasonable enough, but an arbitrary 80-character limit doesn't really strike me as a great answer to the original question.
A couple of recent favorites: * [https://metacpan.org/pod/File::fgets](File::fgets) (or PerlIO::fgets) to do fgets(), which Perl surprisingly lacks. * [https://metacpan.org/pod/File::SortedSeek](File::SortedSeek) to do binary search over a sorted file. * 
hmm... I think you're missing the point: if the 80-character rule is supposed to cover indentation, then why not make the rule "don't have too many levels of indentation" in the first place? ... but if you really want to know why people use &gt;80 characters, ask CPAN! https://grep.metacpan.org/search?q=%5E.%7B80%2C%7D p.s. if you want to enforce maximum indentation levels, I'd recommend right-justifying the code - it's quite effective =) 
Thanks for the tip! This is good to know, I hadn't thought about the separation of Server and JS cookies before this!
To clarify two things: it's a bad practice if you're using OOP; and an OOP framework can be as simple and fast as [Class::Tiny](https://metacpan.org/pod/Class::Tiny).
Thank you for this list. I have downloaded perltidy and git. I will start using these recommendations in my coding. 
I doubt I will ever be the perfect Perl 5 coder, but I will focus on mapping out by task and the process of steps before I code. I will make sure all my commenting shadows this in the coding. Great advice, thank you. 
Absolutely. There's simply no value in a holy war over the one 'true style' of code. Whether you indent with tabs, spaces, hanging brackets, line lengths, etc. Just don't bother, and perltidy it as you commit. And then perltidy it back to the way _you_ like when you check it out. 
I think if you're _writing_ OO even. I mean, pulling a module off CPAN and using an OO interface I think is fine. And I don't care what they used behind the scenes (which is rather the point of OO). 
Are you sure it'll be an RSS feed? I ask because people often use the term "RSS feed" when they actually mean "web feed" (which could be either RSS or Atom. For that reason, I recommend [XML::Feed][https://metacpan.org/pod/XML::Feed]. It handles both types of feed in the seem way. If you're sure about the type of feed you're getting and you're confident that it will never change - then use [XML::RSS](https://metacpan.org/pod/XML::RSS) or [XML::Atom](https://metacpan.org/pod/XML::Atom) as appropriate (XML::Feed is actually just a wrapper around those two modules).
The RSS icon (sadly) doesn't always point to an RSS feed. Well, because some people don't realise that there are different kinds of web feeds. I'd recommend going with XML::Feed as it will give you the flexibility to deal with Atom feeds too, should you need it in the future.
Is the whole of Bugzilla moving to Mojo?
Looks like [it's a real possibility](https://github.com/mozilla-bteam/bmo/pull/517). The gentleman that wrote the blog post works for Mozilla and is one of the main contributors. 
That would be really cool.
Simple. Perl 6 isn't there and solves nothing. And, Perl 5 lacks a benevolent dictator/corporate bandwagon and frankly is rotting. Active Perl 5 developer here.
Yep, it is a possibility although it is early days :) See this video starting at 4 minutes for more: https://air.mozilla.org/bugzilla-project-meeting-20180404/
Oh man, this survey is all over the place. I wouldn't take the results seriously, at all.
https://github.com/apache/incubator-mxnet/tree/master/perl-package
Possible? Yes, but the library support is pretty low I'm guessing. Whatever could be lumped into the category of 'AI' would require a lot of supporting code. I think Perl has some image recognition tools?
https://metacpan.org/pod/AI::MXNet is a Perl interface to the MXNet machine learning library and has almost full parity with the Python API. Obviously image recognition is supported. 
I mean, I probably wouldn't. Python is where all the action is.
That is correct. But with this attitude we can just say to perl goodbye permanently.
I will still use Perl to glue together various systems. Python is nowhere near as useful in devops. But it’s not wrong to acknowledge that Perl is massively outclassed in the AI field.
Have you looked at the option I recommended ? It's one of major libs on the market and the perl interface has parity with python one. Moreover perl api is written in a way that makes it extremely easy to reuse python's examples. The lib supports GPUs/conv nets/rnns of all kinds and is backed by Amazon. If your all code is in perl why don't try it ? 
I’ve worked with mxnet — it’s good for some things, but pretty limited in terms of a production ML pipeline. With python you can easily plug in all kinds of data cleaning, normalization, whitening, model stacking with svm, logistic regression, boosted trees, etc. And that’s just in terms of basic training and making a prediction. In Perl you are going to have to provide your own scaffolding for cross validation, visualization of metrics like ROC curves, and so on. Compare that to installing Jupyter/ Anaconda and just having it all there.
All the stuff that you mentioned can be done in Perl but sure with more effort than just using a stock solution. I see your point, thanks.
Hi. I'm a hobbyist coder who learned on perl and was hoping you could expand on memory usage? If you don't feel like it, maybe point me to some articles?
One way to do AI is with AIML (Artificial intelligence markup language) and in that vein, there is Program V, a parser for aiml. https://github.com/kirsle/programv There might be others but I'm not aware of them. tl;dr: yes.
I'm not sure I understand what you mean by formatting the input but if you want to use the subroutines declared in the module S17, this is how you do it: 1. The module must end with that .pm extension and must be named appropriately. Also if you look inside the module you see the following: `package HT::Conlang::S17`. The module's name is S17 and the words HT and Conlang dictate where it's located. In Linux, it could be something like this: `HT/Conlang/S17`. If you want you can create a directory `mydir` where you can place the main.pl (for example) and the module itself. So the directory tree is as follows: `mydir/main.pl` and `mydir/HT/Conlang/S17.pm` 2. Now we're in the main.pl file and we should have the following to use the subroutines: use strict; use warnings; # We could have listed the module directory in the # standard directory of perl but we didn't so we'll use lib to tell perl # where to find our module directory. use lib './'; # Now we can use the module and export the subroutines we'll use. use HT::Conlang::S17 qw( split_syl step_EIS_ISorth step_EIS_MIS step_Latin_PG ); my $word = "doctor"; print split_syl($word), "\n"; print step_EIS_ISorth($word), "\n"; print step_EIS_MIS($word), "\n"; print step_Latin_PG($word), "\n"; __END__ doctor dokjtor toctor Doctor [More about lib](http://perldoc.perl.org/lib.html).
Perl tends to use a lot of extra memory in order to provide features and performance related to data structures. It also does not release this memory back to the OS when structures are freed (but it can reuse the memory). So when dealing with particularly large amounts of data, a bit of care has to be taken on how you scope and manage your variables. Another thing to watch out for is Perl's garbage garbage collection strategy is refcounting which has the issue of not being able to clean up memory cycles/circular references. Each structure/object has a counter of how many strong references are held to it, and when the counter gets to 0 the structure is cleaned up (memory reclaimed for reuse). So if a structure holds a reference to something else which holds a reference to the first, their counters are both still 1 after you've cleaned up all explicit references to them, and you've created a memory leak. To work around this you can [weaken](https://metacpan.org/pod/Scalar::Util#weaken) a reference, so it will not count toward its target's refcount, but it will also not keep the target alive by itself, so this is only useful when a strong reference is being kept somewhere else. On the flipside, one way to conserve memory in a program that does a lot of forking is to preload modules that will be used in the forks, since forking in Unix-like systems is copy-on-write, so the memory already in use by those modules at the time of the fork will be shared with the child process automatically. Threading via interpreter-based threads works the opposite way, in that everything is immediately copied, which is part of what makes it less useful than most people think.
Probably worth including a link to your earlier question, for context: https://www.reddit.com/r/perl/comments/6df68a/desperate_how_can_i_get_this_perl_module_to_work/
Nice to see this. Just FYI, before you start, make sure you've enabled JS (otherwise, you'll have to do it twice).
Thank you for the thorough explanation. You gave me a lot of roads to go down for my research. 
&gt;Lets say I want to take the output of step\_Latin\_PG and run it through step\_PG\_PN, is there a way I can do that easily? You'd do it just like with any other functions in Perl. Let's say you want to store the return value in the variable `output`, you'd do something like this: my $output = step_PG_PN(step_Latin_PG($word)); # Or without any parenthesis: $output = step_PG_PN step_Latin_PG $word; &gt;Also there are various options and settings subroutines that would make the output behave in certain ways such as the ones below, how can I turn them "on" or "off" so to speak. option_short_i_umlaut option_shorten_final_i option_syncope_shortening are variables in the module that are set to a particular value \(either 0 or 1\) and set_option_short_i_umlaut set_option_shorten_final_i set_option_syncope_shortening are subroutines that act as setters for their respective variables. For example, invoking `set_option_short_i_umlaut(2)` would set the variable `option_short_i_umlaut` to 2.
Got it, that really worked for me, thank you. I was wondering how I can make the output display correctly, I have certain letters that like ö æ á that aren't displaying correctly. They show up like so in the command console. ├╢ Is there any way I can make these display correctly in the command console? If not is there a way I can make it use utf-8 and output correctly to a txt file?
another question, are you a professional?
You need to encode the output to UTF-8 as that's what your terminal expects. You can either use Encode (or the [simpler wrapper](https://metacpan.org/pod/Encode::Simple)): `print encode 'UTF-8', $text;` or you can set the output layer to encode all output to UTF-8: `binmode \*STDOUT, ':encoding(UTF-8)';`
I use Perl for my day job if that's what you're asking.
I mean I learned about RAM and low-level memory usage as part of a CS degree but this is mainly just experience with Perl and the problems people tend to run into with memory usage.
[removed]
~~A clever person~~ I developed a saying a while back: "Python helps you think more like the computer does. Perl helps the computer think more like you. Because AI/ML is pretty alien, and having some assistance to think more like the computer, I think that python is a better fit for ML tasks.
The output still won't show up correctly in the terminal and I keep getting an error message. Here is the .pl I am using, it results in an error message. https://pastebin.com/VZLCy0Vm When I remove your simple wrapper and use the following instead: binmode \*STDOUT, ':encoding(UTF-8)'; after this print $word7, "\n"; I get "mj÷l≡nir". I am supposed to get an output of "mjölnir" What am I doing wrong exactly?
I've just tried this using your code and it works fine on Fedora 27. I had to make one tiny edit to your code. You had this line: print encode('UTF-8', $word7;) Which has the `;` and `)` at the end of the line the wrong way round. I had to change it to: print encode('UTF-8', $word7); I should also point out that running your `binmode` command **after** the `print` statement (as it is in your code) will have no effect at all. A call to `binmode` will only affect subsequent calls to `print`. You say that you "keep getting an error message". It would probably be easier to help you with that if you were to tell us what the error message actually is.
Ok the error message went away after I made that edit. Thank you. However I am still getting the messed up output in the terminal: TRACE: .mel≡unjaR. (300: PG&gt;PN: z &gt; R) TRACE: mel≡u.niaR. (300: PG&gt;PN: j &gt; i in last syllable of polysyllabic words) TRACE: .mjal.≡uniaR (490: PN&gt;ON: early breaking (heavy syllable)) TRACE: mjal≡uni.R. (550: PN&gt;ON: syncope: ultimate a after light syllable) TRACE: .mjQl.≡uniR (600: PN&gt;ON: u-umlaut, primary syllable) TRACE: mjQl.≡.niR (850: PN&gt;ON: syncope of second of originally &gt;= four syllables) TRACE: .mjQl≡nir. (1000: PN&gt;ON: r and R collapse) TRACE: .mj2l≡nir. (1250: ON&gt;EIS: vowel mergers) TRACE: .mj÷l≡nir. (3000: EIS&gt;ISorth: vowel orthography) mj├â┬╢l├â┬░nirPress any key to continue . . . I am running the program on the Windows 10 terminal, is that the problem? It seems like it cannot output the proper symbols.
Ok. All these answers have been written on the assumption that you're using a sane terminal that uses UTF8 as its encoding. But that's not the case. You're using the Windows terminal. I also assumed that the Windows terminal would use the same character encoding as the rest of the world, but I've just tested that theory and found it's wrong. You can find the character set by typing `chcp` (for "change code page") in a terminal window. The result I get is: Active code page: 850 That's not UTF8. That's nothing like UTF8. It's a ridiculous code page to use. But Perl supports it. Your code will work as expected if you change the business part of your program so it looks like this: my $word = "melðunjaz"; binmode \*STDOUT, ':encoding(cp850)'; my $word2 = step_PG_PN ($word); my $word3 = step_normalise_PN ($word2); my $word4 = step_PN_ON ($word3); my $word5 = step_ON_EIS ($word4); my $word6 = step_normalise_EIS ($word5); my $word7 = step_EIS_ISorth ($word6); print $word7; Basically, we've abandoned all pretence of displaying UTF8 and the call to `binmode` tells Perl to encode all output from the program using code page 850. And on my Windows 10 terminal, it works correctly.
Do you have any experience in programming? Or any interest in learning? Because it rather looks like you're asking us to write your program for you, one problem at a time :-) So I'm not going to give you working code, but here are some ideas. * Write a subroutine that takes a word as input, applies the transformations you want and returns the transformed word. * Pass the words to your program on the command line. Those words will appear in your program in the special array `@ARGV`. * Iterate across `@ARGV` processing the words one at a time by passing them to your new subroutine.
I have no experience with programming whatsoever, I do have an interest in helping. I'll try those ideas out. Thank you for all your help, I gave up on this problem and only came back to it recently.
I think I could easily write multi-threaded Perl quicker and more efficiently than Python, because of Python’s GIL. 
Perl threads are horrific. But don't take it from me, take it from the [official docs](https://perldoc.perl.org/threads.html): &gt; WARNING &gt;The "interpreter-based threads" provided by Perl are not the fast, lightweight system for multitasking that one might expect or hope for. Threads are implemented in a way that make them easy to misuse. Few people know how to use them correctly or will be able to provide help. &gt;The use of interpreter-based threads in perl is officially discouraged.
Hmmm, interesting. Thanks. 
If you do want to do some multithreaded programming, check out Perl6 - its a whole new language, and I wouldn't recommend learning it for profit yet (probably nobody is using it in production yet) - but its a really fantastic creation. I'm very excited for the future of Perl6. https://docs.perl6.org/language/concurrency
Can you explain the difference between `m/foo/` and `m?foo?`? I'm scratching my head on this one...
And 5.28 will be out on May 22.
`chcp 65001` is UTF-8.
Not according to Zip Recruiter.
The "age group" question is required. Instead, having a "prefer not to answer" category would increase confidence in the other responses. The only question about Perl 6 is whether the respondent has tried it out. By not following up on whether the respondent liked it, or whether the respondent plans to sink further time into it, the question is designed so that it can be stretched to imply that Perl 6 is gaining in popularity among Perl programmers. It's a sure bet that anyone who is somewhat involved in Perl might have tried it. Whether they think the effort to use it is worth the opportunity cost is the operative question. It is possible to give blank answers in "Yes/No/Other" questions which clearly ought to have been "Yes/No/Prefer not to answer" questions. Generally, you ask identifying questions (e.g. email address) after the survey has been completed so that the respondent is not constantly thinking about what other ways the survey designers may want to associate one's identity with one's responses and use it in their marketing. Survey design is finicky business. Sometimes, just getting a single question correct (i.e., effective in eliciting a truthful and useful response) can take several hundred drafts. This seems to be the first draft. 
I know of a lot of businesses that have software which is Too Big To Reimplement - monolithic applications which handle all or almost all of their core products. Even if perl *does* go extinct for new development, it will still be around for a long while supporting those existing applications. Not to mention how many systems still rely on it as a scripting language - try doing `sudo rm /usr/bin/perl` on even a bleeding-edge unix system, and see how long it stays up.
Is there any limit to the damage inflicted by the refusal to rename The Whole Nother Language Which Should Not Be Called Perl? 
I'm not sure that's the only reason. There was that language, but there was also the inability to move Perl 5 forward for years and years before little flashes started to go off. Those looking for a language that was willing to continue rapid development went looking elsewhere.
It's fashionable to be down on Perl. The best we can do is keep chipping away at this attitude by actually coding something new and interesting in Perl even if it's only for github/CPAN.
m?foo? is a special delimiter that will only match once until you call `reset`. See https://metacpan.org/pod/perlop#m?PATTERN?msixpodualngc
Good! Perl coders will be very valuable, even just for rewriting old apps in any other language (do you still have spec from 15 years ago? Maybe you need to have someone understanding it first). Maintenance of old apps could be even more lucrative as some systems have way too many dependencies to be killed. The same goes for other languages or systems, e.g., the run porting from Solaris to other Unixes / Linux after Oracle's moves. I recently had to rewrite a full application from Fortran (not a math app, just old as me) to a bunch of Python scripts: it was good fun!
Perl hasn't cared much for the popularity contest in a long time. All that's useful for is ensuring a large community of code and resources available, and CPAN is already there.
&gt; Even if perl does go extinct for new development, it will still be around for a long while supporting those existing applications. This is hardly a position of strength.
Way in over my head here...
I thought you knew what this piece of code is supposed to do and you wanted help translating it for a novice. Now, I realize maybe you meant you were the novice who wanted to understand what this code did. If that's the case, **my recommendation is not to waste your time understanding this kind of garbage at this point**. Eventually, you'll probably get to a point where bad formatting and horrible variable naming will not prevent you from understanding something like this, but, at this point, it is a waste of time. See also [What is `-f&gt;@+?*&lt;.-&amp;'_:#/%!` in Perl?](https://www.nu42.com/2012/07/what-is-f-in-perl.html), [What does `int a, b, c` do in Perl?](https://www.nu42.com/2014/11/what-does-int-b-c-do-in-perl.html), and [How does `open 0; print &lt;0&gt;;` turn every Perl program into a quine?](https://www.nu42.com/2014/10/how-does-open-0-print-turn-every-perl.html) for some examples of deciphering what an obscure bit of Perl does. However, you may find the [`B::Deparse`](https://metacpan.org/pod/B::Deparse) module useful for resolving Perl ambiguities etc. 
I know what it does, and it works. I primarily write relatively simple perl that outputs html pages. I did not write this particular code, however. I want to customize it further though, and I can't change anything without breaking it.
So, full circle then: Throw it away, [`use CGI::Simple;`](https://metacpan.org/pod/CGI::Simple).
https://www.youtube.com/watch?v=Xe1TZaElTAs
What alternative? Is there anything that even comes close to perl for manipulating text?
No, not at all. It generates n lines of psuedo random text given starting parameters.
perl is dead as far as well compensated employment is concerned. The writing has been on the wall for a long time. If you are still employed doing perl, chances are it's on a project to reimplement in python or something else.
Define 'well compensated' plz. 
&gt; Perl coders will be very valuable, even just for rewriting old apps in any other language (do you still have spec from 15 years ago? Maybe you need to have someone understanding it first). I'm not available for those sorts of jobs: I'm too busy writing new Perl applications.
well you could start with some line breaks
&gt; perl is dead as far as well compensated employment is concerned. Tell that to the half-dozen or so companies that immediately come knocking as soon as I change my employment status to "contemplating looking for new opportunities". I've based most of my career on Perl and am nowhere near done.
We're hiring for Perl5 programmers, and I like to think we pay a fair rate. Over half the new developers we've hired in the last 6 months have had little or no Perl experience. One reason we choose this as a language is that a good developer can pick up the basics very quickly. I've had people who have never touched Perl work through https://qntm.org/files/perl/perl.html in a morning and be submitting useful bug fixes and small features by the end of their first day. Just one anecdotal piece of evidence, anyway. I'm sure many companies have moved away from Perl5, but we have no plans to do so.
I try to break it up as best I can, which is not much better than the original. In places where it appears easy to line break, the execution breaks. I've never seen perl code written like this before. I deal with simple switches and calls for web browsers, mostly.
while I am also tired of the 'perl is dead' thing, the point about the community is totally correct IMO. all I see the perl community do is complain and deflect from the perl6 issue. outside of perl-related websites and content, i haven't heard anything about perl6 for years. 
6 companies is not exactly proving your point. Pickings are slim, and the pool is shrinking, not growing. It would be irresponsible advice to tell a new graduate to focus on perl and begin his career with it. These are harsh words to read, but they are true.
how about you use that money to finish perl6 instead?
This is the stuff that give perl it's bad rep.
My point was actually that pickings are *not* slim. There is lots of work available. What's good advice for a new grad is totally different. I wouldn't ever suggest to anyone to only settle on one language. I have professional experience with many, and different languages are suitable to different environments.
What does that have to do with Perl?
You're right. This adds no value, particularly because it's TIOBE whose methodology is beyond flawed. I removed the post and will be removing other posts that rely on TIOBE in the future.
Once again, programmers should not pretend to be translators. The word [Angst](https://en.wikipedia.org/wiki/Angst) encompasses so much more than "to be afraid of". I know only a little German, but Google Translate translation of the sentence "*Warum muss man Angst vor der Programmiersprache Perl 6 haben*" does not do justice to the actual meaning conveyed by the original sentence. Personally, I was excited about Perl6 for quite a long time and disappointed shortly after its release. Now that we find out [Perl 6 developers want to cannibalize Perl](https://www.perl.com/article/an-open-letter-to-the-perl-community/), I do feel *apprehensive* about Perl 6. Not because its greatness is going to eclipse Perl's, but because I feel more perfidy might be on the horizon. 
nice ;) just backed the ebook.
Because 7 8 9?
heh - today's sales pitch is "it'll only take you 7 years to reach the same perl6 level as you already have in perl5", then? It's a bold strategy, Cotton - let's see if it plays out...
You still need this decoded?
What sort of new applications?
&gt; It is said that Perl 5 is being actively developed. But that only means that Perl 5 can be made more stable and somewhat more modern. Basically architecture can not change because of backward compatibility. &gt; Perl 4 code also runs in Perl 5, so Perl 5 code should also be able to run in Perl 6. Perhaps it's the translation, but I don't follow this reasoning at all.
&gt;&gt; Perl 4 code also runs in Perl 5, so Perl 5 code should also be able to run in Perl 6. &gt; Perhaps it's the translation, but I don't follow this reasoning at all. The German original is: &gt;&gt; Perl 4 Code läuft auch in Perl 5, also soll Perl 5 Code auch in Perl 6 laufen können. Admittedly, my German is weak, but I think the intended meaning is more like "j*ust like `perl` 5 can run Perl 4 code, `perl` 6 should be able to run Perl 5 code*".
I think the author meant the longest they stayed with one thing before starting out something new is 7 years. It took me just 8 months from starting with Perl 6 to reaching proficiency level sufficient enough where I could join core dev team.
See https://metacpan.org/pod/IO::Pipely#Windows. pipe and socketpair don't work. AnyEvent has a similar workaround: https://metacpan.org/source/MLEHMANN/AnyEvent-7.14/lib/AnyEvent/Util.pm#L98-166
Just slapping on mod_perl with `ModPerl::PerlRun` should get you a free speed boost with little to no backwards compatibility issues. Using `ModPerl::Registry` will do even better, though there may be a few more compatibility issues, especially in messy code. Also, if you don't need threads (you usually don't, unless you're on Windows), then compile your perl without. You'll also need your mod_perl to be compiled against this version. For the long run, you should look at the more modern web frameworks, such as Dancer or Mojolicious.
I too have issues with maintaining legacy sites. Is there a best practices for cgi, or should it be completely forsaken? I ask from a security standpoint, speed has never been an issue. I just don’t see someone kicking around with my servers enough to really do any damage unless they’re basically capable of wreaking such havok anywhere should they be so inclined.
"stop using CGI" is hyperbole. CGI the library is indeed somewhat dated, and there are flaws.... But if your script is simple ish, then no one cares. CGI:: Simple is an easy replacement though. I wouldn't spend too much effort on "upgrading" something that's stable and working. For new code or rewrites PSGI/Plack or Mojolicous are worth a look, and perhaps Dancer or Catalyst. Stuff listed under CGI::Alternatives basically 
As long as you aren't being dumb, there aren't really any security issues. There are a few places where you might have code injection, but you run in taint mode, don't you?
I am just running some old games based on Perl. I always run -wt.
I would not recommend CGI::Simple either. It suffers from the same interface issues that led to the big bugzilla-publicized vulnerability, and doesn't appear to have added the multi_param method or list context warning that CGI.pm added to attempt to mitigate the problem. You can use CGI perfectly fine by deploying a Plack-based or Mojolicious application as a cgi script; and then transparently deploy that application in a more performant way if needed.
Another option, rather than burdening the code with yet another layer of legacy, is to use something like [Plack::App::WrapCGI](https://metacpan.org/pod/Plack::App::WrapCGI) to compile the CGI scripts into PSGI applications which can then be deployed using plackup in [whatever method suits your fancy](https://shadow.cat/blog/matt-s-trout/mstpan-2/).
In either translation, that's a completely incorrect statement. Perl 6 runs Perl 5 code the same way it runs Python code. Perl 5 runs Perl 4 code due to most of Perl 4 syntax still being supported.
&gt; What I like about Perl 6 is that Perl 5 still plays a role. It is being worked on Perl 6 to execute Perl 5 code directly. Some special cases like concurrency are excluded. Perl 4 code also runs in Perl 5, so Perl 5 code should also be able to run in Perl 6. So you want to continue the Perl idea, that the business does not loose its once developed solutions, just because you install a recent version on newer systems. You can renew code, but you do not have to do it necessarily. For security reasons, I can work with the latest version of Perl without disturbing the development process of the company. This entire paragraph (if the translation is accurate) speaks to ignorance of the current state of affairs, and an excellent example of the confusion the Perl 6 name is continuing to cause.
Also Apache::DBI. Just one line and you have database connection persistence.
&gt; In either translation, that's a completely incorrect statement. I made no representations as to the correctness of the statement, but commented on what the correct translation might be.
It wasn't a comment against you :)
These statements may no longer be accurate. Or, I might be misunderstanding exactly what is not working.
I don't have any Windows development machines, but they seemed to be accurate as the tests for [one of my modules](https://metacpan.org/release/Mojo-IOLoop-Stream-Role-LineBuffer) failed when run on a Windows machine until I switched them to use IO::Pipely instead of pipe().
I don't know whether to interpret the word "should" as "by intent this feature works, and if it does not work, there is a bug". The other likely interpretation is "I am making analogous reasoning about backwards compatibility between version numbers", which is not the case.
Thanks, I just wanted to clear up any possible confusion, just in case. The thing is, Perl 5 was a strict improvement over previous Perls. The same cannot be said for so-called Perl 6.
Interesting. That test works with `socketpair`, but fails with `pipe`. On the other hand, [this script works perfectly on Windows](https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/regexredux-perl-4.html).
&gt; "It is being worked on Perl 6 to execute Perl 5 code directly." I'm not aware of that being planned at all. All Perl 5 usage is done via [Inline::Perl5](https://github.com/niner/Inline-Perl5) and while its support is encoded in the spec, it's hardly "execute Perl 5 code directly"
FWIW, I think Steffen referred to `use v5` and its reboot / reimagining "The Butterfly Perl 5 Project", as proposed by me in https://www.perl.com/article/an-open-letter-to-the-perl-community/ .
Ah. I forgot that was part of the plan in Butterfly Perl 5.
To me it sounds exactly like the original intent of `use v5`, which of course is completely abandoned. But it could be a translation issue.
Yes, I agree with this, but you may also find that the `strict` pragma wasn't used, in which case running the CGI scripts in mod_perl will likely get you into trouble with variable scoping. So, once you get mod_perl up and running, you have to add `use strict` to the script(s), and then you'll start getting errors. Then you will spend the next _little while_ chasing down errors (hours? Could be days, but with less experience, could be longer without help). Once you get through those errors, you _might_ be in good shape. Couldn't hurt to have a Perl guy give it a once over. While I agree with what everybody else has said about replacing it with Dancer or whatnot, I realize that might not be practical, and if a rewrite is in store, that rewrite is likely to be in something other than Perl (just based on the fact that it sounds like it's not your forte).
and don't do that either, use DBIx::Connector instead. Apache::DBI is problematic.
you're asking me what perl6 has to do with perl?
Mojolicious is excellent. If you code perl web apps use mojolicious.
Yes. If you're under the impression its development is currently related to that of Perl then I'm afraid you're another victim of the naming issue. Also, the developers mentioned develop *with* Perl, they are not developers of Perl.
There's a reason it's the [most favorited distribution on metacpan](https://metacpan.org/favorite/leaderboard).
shhhhhhhhhh
This article is quite right stating that the language is developed by community and has been this way for a long time. What I really don't understand is why the worldwide community that has much at stake is held hostage at the whim of one man. No, seriously? It must be obvious that Mr. Wall made a big mistake. Naming aside, the divide created in the community and handling of this divide till now (or lack thereof) is evident. From what I see it is not likely that Mr. Wall changes his mind so maybe it's up to the community to take steps to solve this problem? Maybe the right answer is not to rename Perl 6 to something else, but rename Perl 5 to something else. Fork it, rename and move on from whatever version seems logical. The new name does not even have to be related to Perl, camels, or whatever; who cares anymore? I certainly don't as long as it's the same trusty old perl under the hood; the baggage attached to the name Perl is more of a liability than asset at this point anyway. Say, let's rename Perl to Prune to keep the P* and all acronyms intact, just for convenience. This would both open the path for major releases and allow ditching most egregious backwards compatibility issues moving forward. With all due respect to Mr. Wall, this situation does not seem to be resolving itself. If the mountain won't come to Muhammad... * The logically following demotion of Pumking to mere Duke is of course but a pure coincidence.
It can be integrated into your Perl applications. I've decided that it may be useful for comminity projects...
If you're thinking "web apps" and "Perl", you should be thinking "[PSGI](https://metacpan.org/pod/distribution/PSGI/PSGI.pm)". Running your code in PSGI environment gives you three immediate advantages. * Your code is immediately decoupled from your deployment environment. You can take exactly the same code and run it as a CGI program, under `mod_perl` or even as a separate service behind a proxy. * You get access to great testing and debugging tools. * You get access to the Plack Middleware ecosystem. Getting legacy CGI programs into a PSGI environment isn't hard. There are three steps you can take. * Use [CGI::Emulate::CGI](https://metacpan.org/pod/CGI::Emulate::PSGI) to get your existing code running under PSGI. * Use the techniques I describe in [this blog post](https://perlhacks.com/2016/01/easy-psgi/) to move to a more "pure PSGI" approach. * Rewrite your code to use a PSGI-based framework like Dancer2 or Catalyst. There are a few steps you can take to
Please, tell me more about how this is "blockchain\-powered".
lol ^^ There are not many situations where that's appropriate, but here we are
The module Speedy::CGI gets you a dramatic speed increase with minimal modifications to your main calling script.
&gt; held hostage at the whim of one man That's inaccurate. There are plenty of people who don't want a rename and believe it will be detrimental. Neither is [Larry holding anyone hostage](https://youtu.be/E5t8qaAGw9w?t=1h21m43s). &gt; it's up to the community to take steps to solve this problem It's already [being solved](https://github.com/perl6/6.d-prep/tree/master/TODO#language-extended-naming). Those who are impatient can expedite the process by [resolving the 6.d blocker](https://github.com/rakudo/rakudo/issues/1289). &gt; rename Perl 5 to something else That was [already attempted](https://shadow.cat/blog/matt-s-trout/pumpkin-perl-breakdown/) 5 years ago. As I heard, there weren't many takers. &gt; Say, let's rename Perl to Prune That's a bad move. Perl 6 needs to be renamed and Perl 5 needs to stay as Perl and cater to its userbase. If the people who incessantly bring everyone down with their whining about the decline of Perl shut the hell up and instead post exciting write ups about Perl projects they're working on, you'll get new users too. &gt; major releases and allow ditching most egregious backwards compatibility issues moving forward That too is [a bad idea](http://blogs.perl.org/users/leon_timmermans/2017/12/smartmatch-in-5277.html). Leave perl alone. Provide stability, performance, and fixes. Invest into CPAN. People who want Perl that isn't Perl are already using it.
Why wait? Plack/PSGI has been the standard for at least ten years now and all the modern web development frameworks are built on top of it.
Technically, Mojolicious is not built on top of it (since it has spotty/ugly async support) but does support it for non-async applications.
&gt; There are plenty of people who don't want a rename and believe it will be detrimental. Of course there are. There also are people who actively want Perl to die the flaming death, and even more people who don't know what Perl is. Like, 97% of the developers out there? I'm not sure what kind of detriment you are talking about here really, given that Perl has become something to never discuss in public lest you get ridiculed all the way out of the hall. &gt; Neither is Larry holding anyone hostage. Thanks for the link. I've listened to that particular piece several times and one thing I noticed is that while Mr. Wall was talking about "marketing" the language with different names, or versions, his intent seemed directed towards marketing Perl 6. Does that mean Perl 5 does not need any marketing? I'm sorry but that message sounded controversial and very much inconclusive. Again with all due respect to Mr. Wall his wording gave me an impression that he was trying to acknowledge a mistake without actually admitting it. &gt; It's already being solved. I'm not sure what you mean by solution here. If Perl 6 gets marketed under different names *including* Perl 6, how does that solve the problem we have? &gt; Those who are impatient can expedite the process by resolving the 6.d blocker. This fair offer looks like a plea to roll up our sleeves and help to get annoying obnoxious teenager pack off to college. :) Thanks but no thanks. Between my day job that does not involve Perl in any capacity, home, and family I don't get enough time to work with the language I *am* interested in, much less on butterfluey things that are not even on the radar. &gt; That was already attempted 5 years ago. As I heard, there weren't many takers. Maybe the time wasn't ripe then? Maybe it is now. Maybe the idea wasn't communicated clearly and didn't get enough buy-in then. Who knows. &gt; That's a bad move. Perl 6 needs to be renamed and Perl 5 needs to stay as Perl and cater to its userbase. This, right here. *What* user base? Ever shrinking pool of old timer die hards? There are hardly any green field projects started in Perl. Without new *commercial* projects you can't create new jobs requiring Perl knowledge and give no incentive to gain it in the first place. It's no wonder Mr. Wall was talking about *marketing* Perl. He must realize that without money behind it there's no future for the language. &gt; If the people who incessantly bring everyone down with their whining about the decline of Perl shut the hell up and instead post exciting write ups about Perl projects they're working on, you'll get new users too. Whoa there. Why all the aggression? I thought this was the right place for a civil discussion. Also sorry but you're mistaken, completely and utterly. The public perception of Perl is that of a pit of poisonous snakes writhing in a heap of toxic garbage, and no amount of exciting write ups is going to change that. Facts do not matter here, messaging and marketing does - and that train has sailed a long long time ago. This hurts both Perl 5 and Perl 6 equally by the way. All the co-workers I ever mentioned Perl to were recoiling as if I was contagious. Their minds shut down at the mention of Perl, and nobody cares that Perl 6 is supposed to be the bright new shiny thing. As long as it's Perl it's automatically awful, sinful, and something never to be touched with a ten foot pole. &gt; That too is a bad idea. I beg to differ. This situation exactly *validates* my point, let me try to explain. There are some people that want Perl 5 dead as in being an asset. I get that, I'm in the same camp. I want Perl 5 to be stable and worry-free so that it can be safely used as general scripting language instead of shell (uggrh). You actually don't need much more than 5.8 had in the core for this purpose, and all the recent activity with getting rid of non-essential core modules is going in that direction. But I also like to use Perl 5 for things way more complicated than general scripting, as seemingly do many other people. Data retrieval and conversion, SQL manipulation, Web application back end -- all these things go way beyond the general scripting a la `sed`. And safe 5.8 feature set/bundled modules are so very underpowered for this that it's not even funny in 2018. There's CPAN for that of course but there's a limit to how many essential advanced features can live outside of the core. Srsly, `try/catch` on CPAN? That's funny. Do you notice the conflict of interest here? We have at least *two* different set of requirements for the same language. That happened simply because Perl is fscking awesome but that's beyond the point. I believe all the angst and conflict stems from trying to cater to both set of requirements under the roof of one language with deep history of backwards compatibility, which creates a lot of hot friction in many places. So let's take the fork idea and try to think about it with no emotion attached. I see a win-win-win situation: * Perl 5 stays as it is, forking it means *both* roads are taken at the same time. Stability achievement unlocked, the language only gets fixes, speedups and the like. No new features, no breakage to old features. Only essential modules in the core. General scripting at its best, with all the bells and whistles. Nothing to rename, all backwards compatible. Slow trickle of releases improving the same old stuff, predictable and manageable. OS vendors would have such a hard-on for this that it would hurt. * New features go into Prune, breakage flows more freely in dev versions (in sane fashion). There's a lot of improvement at ditching things like Perl 4 compatibility -- it's a new language, remember? Even having always-strict mode would be a huge gain in itself. Getting rid of garbage and introducing new features that modern developers want allows for different marketing message as well, which is the Big Deal. Heck, the name itself implies getting rid of unneeded stuff! * Perl 6 can do whatever its community wants. Let it stay Perl 6 for all I care. No controversy anymore, no angst. Prune on, never look back. &gt; Provide stability, improve performance, and fix bugs. I don't see this contradicting the fork idea. Much of the code base is going to be shared between Perl and Prune for a long long time, so even performance improvements and bug fixes can be easily shared. Gain-gain. &gt; Invest into CPAN. How many new modules do you see on CPAN that are aimed at general scripting purpose? I've published a few modules and help maintaining some (in between breaking them, heh) but I can't recall even *one* time when I've created or ever looked for a CPAN module that didn't involve a complex application. From my point of view pretty much all of CPAN can be placed in the Prune camp simply because Perl doesn't need it. &gt; People who want Perl that isn't Perl are already using it. And there are many people who want to use Perl that is Perl but can't because of the stigma. And there are many people who want to use Perl that is Perl and *do* use it, otherwise where all the new development would come from? But they also suffer from the don't-break-the-world stigma. Forking is the way to cover all the bases without losing *anything*. Scripting? Use Perl. Application? Go for Prune. Two Languages, One Love. Come on, think about it. I can even imagine working around the chief maintainer title. Like kings of old, being both King and Duke at the same time is not something unheard of. Right?
Thanks to you (and everyone else) for all the awesome replies. So much new information. Looks like Mojolicious is my new long-term plan. So I just did this: $ perl -Mmod_perl2\ 999 mod_perl2 version 999 required--this is only version 2.000010. BEGIN failed--compilation aborted. I'll try `ModPerl::PerlRun` first. Does it require anything to be done with Apache, too?
There's a little Apache config to be done. See: https://metacpan.org/pod/distribution/mod_perl/docs/api/ModPerl/PerlRun.pod
&gt; What I meant is *among people who have any weight in the matter*, especially among the core developers of Perl 6, there are people who wish to avoid the rename. ... Which is a not-so-thinly veiled way to tell me to fsck off because my opinion does not have any opinion in the matter. Yeah sure, that's a good way of keeping community inclusive. Also did you actually read my post above? One of the points is that forking *Perl 5* is a way to avoid renaming *Perl 6*. What exactly do you not like in that proposal? :) &gt; I don't hear him refer to Perl 6 in that segment and the question he's responding to is about his opinion on both languages: Pumpking Perl (a proposal for Perl 5) and Rakudo Perl (a proposal for Perl 6). There's no need to argue with this statement. You heard one thing, I heard another, which is exactly my point: everybody has their own bias, and Mr. Wall giving inconclusive answers is not helping to bridge the gap. &gt; Let's first be clear on the problem: a portion of people believe Perl 6 will benefit from the name change and want it changed; a portion of people believe it will be detrimental and don't want it changed Duh. I'm trying to communicate here, please don't stonewall me. Again: did you read what I posted above? Forking Perl 5 allows to **avoid changing Perl 6 name**. Sorry for added emphasis, maybe that would help getting the idea across. &gt; the creator of the language, who by established policy is always right by definition, belongs to the second group. Now that's just silly. I never met Mr. Wall in person but just looking at the video you posted he appears to meet all the basic requirements for being human: two legs, two arms and hands, a body and a head with a hat on. Being human implies being biased and prone to making mistakes. This directly contradicts the established policy. Now I do realize the amount of effort it took to bring Perl about. I truly admire the level of genius it took to design the language that still manages to give me pleasant goosebumps even after working with it for many years. I have deepest respect for Mr. Wall, I really do. But admiration is not the same as worship. I think the origins of that policy was at the tip of the tongue in someone's cheek that was taken all out of context and blown all out of proportion later. We're adult people here (I hope), we got to recognize our limitations and try to work with them. I certainly try to. Do you? &gt; The creation of the alias is the means for the rename camp to prove their claims. They say repetition is the mother of learning. Yet another time: **Let's not rename Perl 6. Let's leave it Perl 6. Let's keep Perl 6 crowd happy**. Here, does that sound attractive enough for you to actually listen and pay attention? &gt; Because all the whining about "dying perl" is exactly why I left Perl 5 two years ago. I'm not sure where you found me asking why you left Perl 5 two years ago. I did ask you why, in replying to my level headed and civil post, you were using passive aggressive language towards me. The implied meaning there was that if something is bothering you, there are ways to deal with it besides attacking someone just because you happen not to agree with their ideas. In fact I'm also not sure why you did reply at all. If you left Perl 5 behind, what's your beef with forking it then? &gt; Why would newcomers want to be made depressed when they can join happy communities of a multitude of other languages? That's right, I totally agree with you on this one. There is no need for newcomers to associate with Perl moniker that has so much meaning attached to it, most of it bad. Let's fork Perl 5 and start afresh with a new name, problem solved. How Perl 6 deals with that problem is not my concern. I have nothing against Perl 6 but I'm not interested in it either. &gt; Indeed! Now flip through this very subreddit and tell me the messaging in it I'm afraid you're giving this Reddit section way more credit than it is due. Also, the messaging problem is not that people are bashing Perl. The problem that most people nowadays don't even know what Perl is and that bashing it was quite a fashionable sport back in the day. &gt; That about sums up the loudest voices that want instant solutions to complex issues. So let me get this straight: you want *me* to spend time and effort trying to fix issues in *your* language that I have no knowledge of and no interest in, all in the name of *your* language apparently moving forward without actually solving the problem it has created simply by existing. And then you get all sarcastic at me politely saying No. Do you guys always use this tactic to recruit new people into Perl 6 camp? No wonder it couldn't ship a barely working beta in 10 years.
&gt; start fighting for Perl future If I might put in a suggestion, *fighting* is not the best word to use. Too much adversity attached to it, many people will not read past it and attach all kinds of negative meaning to it. The last thing we need is antagonizing any of the few people remaining about. In my personal opinion, forking Perl 5 is a clean and practical way to give it a shot at new life *and* heal the divide in the community. I'm not sure what would be the best way to spread the word and get more people on board with discussing this idea. Thoughts?
Sorry but I don't think a 'fork rename' is going to happen, nor do I think it should. I have the same problem with it that I had with the "pumpkin perl" proposal: Perl has 30 years of legacy tied to that name. There's no way around that. You're essentially proposing that be abandoned and the core developers (because no, nobody else is going to pick up this flag and maintain it) start working on a language that looks a lot like Perl but suddenly is allowed to break backcompat, thus not being useful for any existing Perl programs. No, the realistic way forward for Perl is to still be Perl and use the deprecation policy that's in place to improve the language.
&gt; ... Which is a not-so-thinly veiled way to tell me to fsck off You're putting words in my mouth. You originally accused Larry of being "one man" "holding everyone hostage". I said that's inaccurate and several people don't want a rename. You lumped people who "don't know what Perl is" into that group and said they don't matter. I clarified that isn't the group I meant. &gt; Also did you actually read my post above? It was extremely long, so I read the first half only. &gt; forking Perl 5 is a way to avoid renaming Perl 6 But that doesn't solve the problem of incorrect branding. In fact, makes it worse by making the product the brand belongs to discard it and start from scratch, while letting the product that doesn't fit the brand keep it. You're dumping those who trust the brand and hope to attract those who dislike the brand with the exact same old offer, by simply changing the name. &gt; What exactly do you not like in that proposal? I want Perl 6 branded correctly and that proposal doesn't accomplish that. &gt; Here, does that sound attractive enough for you to actually listen and pay attention? No, it sounds condescending, makes no logical sense, and calls for aborting the process already in the works in favour of performing a much more difficult and much less effective process of renaming something that doesn't need a rename. &gt; using passive aggressive language towards me I wasn't. I referred to, and I quote, "people [...] with their whining about the decline of Perl". It was a sentence included in the response to your post that didn't say anything about decline of Perl in any form. Both the aggressive language towards you and the "telling to fsck off" exist only in your imagination. &gt; you want me to spend time You called for the community to solve the problem, didn't you? We've been solving it since last summer and that's the next step in the process. Don't act so indignant at the suggestion that you help out. 
Ok good, now we have a real discussion. Let me try to convince you. Firstly, fork-rename to Prune (let's keep this as code name for now) is essentially *not* the same as renaming Perl to Pumpkin Perl, for at least two reasons: * Prune is Perl in all but the name, at least at first. However the name not being Perl opens up the way for breaking changes exactly of the sort that needs to be done to move forward. There's no need to get overboard with breakage but something like always-strict would alone be a huge improvement *and* be compatible with much of the Modern Perl code, to the point of being a drop-in replacement. `try/catch` in the core? OOP in the core? Async/await and Promise support in the core? You can't do that with Perl but you can with Prune. And these are all the things you don't really need in scripts, you need them in complex applications. * Renaming Perl 5 to Pumpkin Perl implies keeping the legacy, just under a different name. This might be why the idea didn't float, because the changes involved are not enough to bring sufficient benefit at the expense of work involved and breakage implied. My proposal involves leaving Perl 5 as it is, with no renaming or changes to it whatsoever. But most importantly, Prune is not Perl in the name. This allows marketing it as different language and get traction again without the 30 year legacy you mentioned. &gt; You're essentially proposing that be abandoned No I didn't propose that. Simply forking Perl 5 is not going to change the codebase, so any fixes and improvements will be directly applicable to both languages for quite some time. How much time is a question of course but that again depends on the direction Prune takes and that's for community to decide. Personally I'd advocate for compatibility, but keeping all 30 years of it is not reasonable IMO. &gt; language that looks a lot like Perl but suddenly is allowed to break backcompat, thus not being useful for any existing Perl programs Nope, that's another point I would like to clarify. When I said "allow breakage" that meant getting away from the toxic legacy stuff that nobody worth their `$@` is using anymore anyway. I'm not that much familiar with Perl 5 internals but I can imagine there is a lot of cruft in the core that is kept there for the sake of compatibility with everything under the sun since the time immemorial. Well that's exactly what Prune fork is going to address: Perl 5 is not going to change, it will keep the same binary name and everything. Prune will have the new binary and it won't be a drop-in substitute for ancient scripts, that's all. No breakage to the world. Essentially what I mean by relaxing back compat requirements is getting rid of stuff that doesn't meet current Modern Perl recommendations. Any program or application written with best practices in mind should work in Prune with no problem at all. How is that not useful? &gt; Perl is to still be Perl and use the deprecation policy that's in place to improve the language. There's more than one side to the current state of the Onion. What I'm proposing is a way to get rid of the toxic publicity that has been attached to Perl name for many years. On the technical side I don't see any reason to change the current deprecation policy at all, it seems quite reasonable to me. Think about it this way: there's Perl 5 as scripting language and there's Perl 5 as application development language. When you use it for scripting, usually you are limited to what is installed on the system; `local::lib` is fine but most of the time is not even necessary because whatever is installed is enough. That's `/usr/bin/perl`. When you use it for application, you would probably want to use the latest version with the features you need, and you would have to install it separate from Perl 5 anyway. That's `/usr/bin/prune`. These *effectively* are two distinct but very similar languages. Why not make them officially different? What is there to lose? Maybe one way to go about this is to start it as an experiment. I don't think there is much extra work involved in applying patches to essentially the same codebase in two repos and seeing how much they diverge over time. My prediction is that the compatibility level is going to be very high for very long time, if new features are added carefully in Prune first and maybe backported to Perl in time. Something like Fedora/RHEL dichotomy perhaps?
Yeah, I am lousy with words. The action needs to be taken by Perl porters. How to get them on board, I don't know.
&gt; You're putting words in my mouth. I apologize for that, wasn't my intention. &gt; You originally accused Larry of being "one man" "holding everyone hostage". What I meant was along the lines of the community holding itself hostage. But considering the amount of influence the language founder usually wields, the fact that Mr. Wall still does not have a clear message regarding Perl 5/Perl 6 naming controversy after almost 20 years is not really helping anything. &gt; I clarified that isn't the group I meant. Thanks for the clarification, I must have misread your emphasis then. It was very hard to follow otherwise. &gt; It was extremely long, so I read the first half only. I would advise you to take the time and read that message in its entirety, with an open mind. I seriously hope you might find a good point or two in there. &gt; You're dumping those who trust the brand How is freezing Perl 5 new feature development is equal to dumping those who trust the brand? People who want Perl 5 for stability will get exactly that. That's a win. It's not even necessary to freeze new development in Perl 5. Features can be backported if necessary but that seems to contradict the stability goal. &gt; hope to attract those who dislike the brand with the exact same old offer, by simply changing the name. No. I hope to attract people who are entirely unaware of what Perl *can do* and only judge it by the name they maybe overheard in conversations between older colleagues a long time ago. Attracting factor is not going to be the new name. It will be the lack of support for bad practices that Perl 5 is infamous for, and more support for good practices Modern Perl is not as famous for as it deserves. That's another win. &gt; I want Perl 6 branded correctly and that proposal doesn't accomplish that. I don't see a contradiction here. I want Perl 5 to move forward, being marketed under new name and attracting new user base. You want Perl 6 to be marketed under different name and attracting new user base. Why can't we have both? Do you think that Perl 5 has to stay Perl 5 forever for Perl 6 to succeed under a different name? &gt; No, it sounds condescending, makes no logical sense, More like frustrated at having to repeat something several times just to get you to read it. As for not making sense, let's agree to disagree. &gt; and calls for aborting the process already in the works Wrong. I said I don't care what happens to Perl 6, if you want to rename it that's fine with me. &gt; in favour of performing a much more difficult and much less effective process of renaming something that doesn't need a rename. Wrong again. Reiterating: the idea is to leave Perl 5 as is. How it can be more effective as this I can't fathom. Seriously, if you are going to argue maybe you could at least read the long post? Pretty please with sugar on top? &gt; Both the aggressive language towards you and the "telling to fsck off" exist only in your imagination. Right, both that emphasis on *people who have any weight in the matter* and your hearty advice to imaginary whiners to shut the hell up and keep soldiering on happening in reply to my post, without any connection whatsoever to it has also happened entirely in my imagination. Okay whatever, let's leave it a that. &gt; You called for the community to solve the problem, didn't you? Yes I did. The idea here is that the solution might be easier to achieve than you think. &gt; We've been solving it since last summer and that's the next step in the process. And exactly how long will it take to solve the problem of complete renaming of Perl 6 to whatever butterfly still not extinct by that time? Another 20 years? You seem to be sure that there is only one solution to the problem, and every effort should go towards advancing Perl 6. I don't see why this should be the case. Not to mention that renaming Perl 6 which I don't care about does nothing to solve the problem of keeping 30 years of legacy and bad publicity with Perl 5 that I *do* care about. &gt; Don't act so indignant at the suggestion that you help out. I *am* trying to help. Don't act so indignant at the fact that my notion of helping does not correlate to yours.
Cool. I couldn't tell from your post whether you had Perl experience or not. It wouldn't be the first time somebody had to take over some old Perl stuff, having never seen it before.
This sounds like a good candidate for a distribution, like strawberryperl.com. You can already bundle the functionality into a pragma: package Some::App::Module; use Prune; try { Useful::Thing-&gt;new } catch : async { await cleanup(); } The "core support for objects/MOP" idea has wasted a lot of time and effort over the years, and I think if Moo is too spartan for you then a common base that Moo and Moose build on would be even worse. I'd love the idea of a "modern Perl" development effort that does not have to spend time supporting gcc 3.4.5 or Amiga or MS-DOS 3.22 or whatever else we have on the backcompat list. I'm not even that bothered about backcompatibility with older Perl code. One question, though: who is going to be doing all this work?
Very cool!
A distro might be a good idea indeed. Not sure if refactoring internals is something feasible in a distro but certainly worth thinking about. Maybe a distro could be the first step. &gt; You can already bundle the functionality into a pragma: Sure. The question is why do I need to do that at all. Because scripting and 30 year old legacy? &gt; then a common base that Moo and Moose build on would be even worse. I don't see why that should be the case. I don't think the effort was wasted, we have a very good toolset as the result of that. There's room for improvement, too. &gt; I'm not even that bothered about backcompatibility with older Perl code. That's the idea. Out with the old and discouraged, keep the best practices and move forward. &gt; One question, though: who is going to be doing all this work? Community? As in, people who think it might be a good idea. I certainly would pitch in, and if the Perl based project I'm working on currently takes off I might be able to contribute something more substantial than a limited number of hours. :) So far it doesn't seem like there's a lot of interest though. I think the best course of action would be to spread the word and try to get more people on board with the idea. Kick it around, see what happens. There's no rush.
So, he produced some obfuscated code for her, and she just ran it? That does not sound like marriage-material to me!
&gt; Sure. The question is why do I need to do that at all. Because scripting and 30 year old legacy? Because `use Prune;` then works on any existing CPAN-capable Perl install, so you immediately have access to the full target Perl userbase: anyone building the larger applications you've mentioned presumably has CPAN access or a penchant for masochism. It also means any regular-Perl modules you load are *not* affected by the changes that Prune.pm makes automatically. An example of where this could be problematic would be the API differences between Try::Tiny/Syntax::Keyword::Try, or older modules that still use indirect object syntax, or things that define their own `has`/`extends`/`requires`. I can't see this project as being successful if step 1 is "fork+fix all the CPAN modules that no longer work"! The "wasted time and effort" is specifically about "core MOP/OO" - far as I'm aware, no significant changes have been made in core as a result, unless you count the perldoc pages maybe?
&gt; Because `use Prune;` then works on any existing CPAN-capable Perl install, so you immediately have access to the full target Perl userbase This is a very valid point. I don't see it contradicting either fork or distro idea though: the act of forking by itself does not introduce any changes. Immediately after forking Prune is going to be 100% Perl 5 and 100% compatible with all of CPAN. What to keep and what to get rid of is a clean slate. The new thing here is that we *will have* this clean slate, unlike Perl 5 that simply cannot because compat. My approach to that would be slow and careful: * Fork and rename, see what breaks. Nothing should break because of simple rename but who knows. * `s/Perl/Prune/g` in the docs. See what breaks. * Turn `use strict` on by default. See what breaks. Maybe backport fixes to Perl. * Remove a bit of cruft from the core. See what breaks. Rinse, repeat. It's not going to happen overnight. It might take years. But it's a *path forward*; not even as much important technically as psychologically. Even if Perl 6 magically disappears tomorrow there's still the 30 years of bad rap that won't go away and releasing Perl 7 or Perl 28 won't solve any of it. Renaming does. &gt; An example of where this could be problematic would be the API differences between Try::Tiny/Syntax::Keyword::Try This is one obvious example, I agree. One way to work around this is something like: * Settle on one of these for core Prune -- I'd prefer `Syntax::Keyword::Try`, especially if it gets value assignment semantics problem solved * Include `Syntax::Keyword::Try` in the default pragma so that it is available by default * Patch `Try::Tiny` to be compatible with `Syntax::Keyword::Try` in the sense of unloading `S::K::T` when `use Try::Tiny` is encountered in a module I'm pretty sure we can do this with minimal surgical effort (if any), and then work with module authors to come up with better compat semantics. Maybe ship our own wrapper around `Try::Tiny` to provide compatibility layer on top of `Syntax::Keyword::Try`. &gt; The "wasted time and effort" is specifically about "core MOP/OO" - far as I'm aware, no significant changes have been made in core as a result I'm not aware of core OOP support in any recent versions but I wouldn't call that effort wasted anyway. More like, now we know 100500 new and exciting ways of how *not* to implement OOP in Perl core. That experience can be used to do things right in Prune, especially if back compat is not as far-reaching as in Perl. BTW I've been thinking, maybe the idea doesn't float because people think Prune is a bad name. What about Pea? Pea is round and green and and is somewhat like pearl. It's nutritious and full of vitamins and good for you. I can envision a hip trendy logo, too, with leaves and cool vibes. And `pea` is 3 characters, 25% less than `perl`. Give Peas a Chance! What'd you think?
As a business and as a new coder I have adopted Perl 5. I won't use another programming language, neither Perl 6 which is another programming language. Perl 5 in my opinion will always be supported and there will always be Perl 5 developers around. 
Wx may have a perl5 module but the module installation compiles the Wx background as a separate windows service. Both environments (active state and strawberry) cannot install that same module unless both somehow link to that windows service. I tinkered with 6'ing that WxWidgets install so I could somehow use the AST...but my skills are not up to that. My feeling is that the C code in WxWidgets ought to be directly importable into P6...then all the all the happy horse-pucky of not linking to the Wx service goes away. Wishful thinking probably. :-)
For web pages that are built withJS, I find that this package works better - it works really well as a matter of fact - as long as you don’t require headless: http://search.cpan.org/~corion/WWW-Mechanize-Firefox/lib/WWW/Mechanize/Firefox.pm
I know, right ? Perl 5 has more in common with Python than with Perl 6. Why in the world they want to keep Perl name ?
Perl 5 and Perl 6 have nothing much in common it seems, and those who developed Perl 6 seems to have taken the strategy to make Perl 6 so different to Perl 5 that using the same name confuses me. 
I'd recommend moving from the C-style `for` loop to `foreach`. The two examples in your code then become: for my $c (0 .. $#temparray) And: for my $d (0 .. $c - 1) They both seem easier to understand to me.
Are you reinventing [`map`](https://perldoc.perl.org/functions/map.html) or [`grep`](https://perldoc.perl.org/functions/grep.html)?
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://perldoc.perl.org/functions/map.html) - Previous text "map" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
If you have the motivation to go through with it - with either name - then sure, why not. I'd still suggest starting as a CPAN module, rather than expecting people to install a full build of Perl. If that works and gains momentum, upgrade that to a forked perl and start making changes.
Ok, that's a first. Code involving &gt;&gt;= that's easier to understand. Nice one.
If it's one of your favorite pieces of code, it might be useful to say what it does, rather than everybody having to read the code to determine if it's an interesting problem to them. I realize there are two comments in the code, but... if it's so useful, I assume this is a use case that you encounter quite a bit. And by sharing it, I assume you think others have the same use case from time to time.
oh i thought the comment explained it in the code. it takes a random integer in, like 13560, writes in in binary like 10010100101. then that binary number corresponds to the indices of an array, and it makes a new sub-array out of which ever indices were indicated. like, if the array was (a,b,c,cat,5,0) and the input decider was 01001, then the output array would be (a,cat)
probably i dunno what grep is. i just write all my own stuff, the only stuff i really trust perl to do is the stuff an ALU can do. though i understand that there is a lot out there, but i don't want to be relying on it if i don't know what it is.
You might enjoy [this](https://twitter.com/sinan_unur/status/976482999830237184) and [this](https://www.nu42.com/2016/01/excellent-optimization-story.html). But, of course, the biggest bang for buck comes from using a [better algorithm](https://www.nu42.com/2016/01/excellent-numbers-explicit-solution.html). Which is why I recommend the *Combinatorial Algorithms* book.
 sub fisher_yates_shuffle { my $array = shift; my $i; if (@$array &lt; 2) { return; } for ($i = @$array; --$i; ) { my $j = int rand ($i+1); next if $i == $j; @$array[$i,$j] = @$array[$j,$i]; } } One of my favorite subs... to use; `fisher_yates_shuffle(\@array);`
Thank you for sharing that book resource, I'll be reading it over lunch at work.
just to save a bit of typing: this is the same algorithm as `List::Util::shuffle()`.
I didn't vote in either direction, but at a guess downvotes may be due to: - not using strict (`use strict;` at the top of the code tends to avoid a lot of common problems) - lack of clarity in the post title - you might have a better response with something like "Example code to select elements from a powerset"? - the defensive replies: "i dunno what grep is" and "i never used the word favorite" - posting an article that isn't about perl5 vs. perl6 (no one here actually *codes* in perl any more, we just argue about it and quietly write Python when we think no one is looking) Please don't take downvotes too seriously, there are few enough articles that everyone is going to read it regardless of the number of votes. If just one person reads your code and learns something, it was worth posting!
oh yeah i don't mind a couple of downvotes, but it's just, when i get an overwhelming amount negative feedback without any explanation, i think that's incredibly cruel. If i don't like someone i tell them exactly why. if i like someone i tell them exactly why. i think it's just basic human decency rather than to walk up the street and randomly shove someone out of the way and say nothing.
Keep in mind that Fisher-Yates is only [appropriate for small lists](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Pseudorandom_generators): &gt; as the sequence of numbers output by such a generator is entirely determined by its internal state at the start of a sequence, a shuffle driven by such a generator cannot possibly produce more distinct permutations than the generator has distinct possible states. Even when the number of possible states exceeds the number of permutations, the irregular nature of the mapping from sequences of numbers to permutations means that some permutations will occur more often than others. Thus, to minimize bias, the number of states of the PRNG should exceed the number of permutations by at least several orders of magnitude. &gt; For example, the built-in pseudorandom number generator provided by many programming languages and/or libraries may often have only 32 bits of internal state, which means it can only produce `2**32` different sequences of numbers. If such a generator is used to shuffle a deck of 52 playing cards, it can only ever produce a very small fraction of the `52! ≈ 2**225.6` possible permutations. **It is impossible for a generator with less than 226 bits of internal state to produce all the possible permutations of a 52-card deck.** (emphasis mine)
&gt; i thought the response to "i dunno what X is" is to immediately tell me basically what it is. You do realize that `map` and `grep` in my original reply link to the documentation, right? 
You might want to look into array and hash slices. For example, to get the same conversion slightly differently, i'd do: my @in = qw( a b c cat 5 0); my @out = @in[0, 3]; # (a,cat)
I still code in Perl. I even get paid for the efforts. 
For the second because it's always using `$d + 1` just use the range `1 .. $c`. 
ok yes but i meant, explaining it for the widest possible general audience. like, i'd explain coding itself to someone who didn't know what it was as "telling the little men who live in the computer tower what to do". it's like that youtube series "guy explains x at 5 levels of difficulty". https://www.youtube.com/watch?v=opqIa5Jiwuw i could look up the documentation for map or grep if i needed to. but "map" or "grep" don't tell me what they are and random documentation without the proper context makes no sense. i mean, "map treats an array like a set and picks elements of the power set" would be the technical explanation i'm looking for but isn't it almost always the case that two people's specific technical understandings are always disjoint? i can't just read the documentation for either of them and go "oh given an integer and a list, grep would output an identical list to what my code would output." takes a bit of time to digest them
I think it's the fact that you can write Perl but don't know what grep is, that you're getting downvoted for. \\\_\(ツ\)\_/
Yeah, I regretted typing "favorite" after I submitted it. You didn't use the word favorite. But you did say it's code you use over and over again, so I didn't think "favorite" was too far out of line. Clearly you disagreed :) It's also clear that your programming is focused on a different area than mine is. I'm a web developer and I also use Perl to munge data and deal with stats and stuff. I'm not much of a math guy either, so your whole post is over my head. No harm, no foul. 
Is this an architectural limitation, or can I work around it by re-seeding before each shuffle with an external, true RNG (eg. [Net::Random](https://metacpan.org/pod/Net::Random)).
Perl is indeed great for doing stuff - and it's pretty stable, so it's a fine place to keep workhorse code! I included that comment to trigger a frenzied flood of downvotes, call it a gesture of solidarity =)
I don't think the first segment is limited to 999, you can compare v1000.999.999 with v5000.999.999 with no problem, for example.
I don't care about my internet points I just care that if I'm looking for help, that, since I have done a lot to help other people on the internet in math forums/music, that my actions get reciprocated. I really do not like when I am getting downvoted and pushed away without any explanation. If you down vote and push a person away they are just going to come back worse. So, unless you want a subreddit or any online community with such a voting system to become degenerate and hostile, you have to *explain* people's transgressions *to them*.
Good point :)
"Really well"? 👎 Mozrepl is not installable any more. Use &lt;http://p3rl.org/WWW::Mechanize::Chrome&gt; or &lt;http://p3rl.org/WWW::Mechanize::FAQ#Which-modules-work-like-Mechanize-and-have-JavaScript-support?&gt;.
&gt; it's really grown on me &gt; i have no valuation to any particular piece of code. 
One note is I would not recommend using Perl::Version for Perl versions (name aside). Its "bump" utility only supports the tuple version style, it will bump decimal versions incorrectly (1.9 -&gt; 1.10). The two scripts installed by [App::RewriteVersion](https://metacpan.org/pod/App::RewriteVersion) can be used to homogenize or bump Perl module versions regardless of scheme and work similarly to to [[RewriteVersion\]](https://metacpan.org/pod/Dist::Zilla::Plugin::RewriteVersion) Dist::Zilla plugin.
grown on me because i use it because it works for what i need it for. i don't value one piece of code over the other with one being a "favourite" in a sentimental sense. my favourite is the one with the lowest number of clock cycles to achieve a given task.
Dude, you keep disagreeing with yourself. &gt; I don't care about my internet points I just care that if I'm looking for help 
My point is that you confuse people by saying one thing and then denying it. This code grew on you... but you're not attached to it. You're upset that people disregard you when you're looking for help... but you're not looking for help. You make it hard for others to understand what you want, and then you get upset and make it even harder. 
i posted some code i use to see what people would say. that was my only intention. i mean if you want to be pedantic, i said "if" there as a keyword, meaning, i'm not guaranteeing i'm looking for help, i'm only saying what is the case under the assumption that i am looking for help in that statement. this will get confusing. i posted some code to see what people would say. i was talking about help with what grep means. i guess i'm quite flattered you are interested in all the bullshit logical connectives in my head haha. this is enough of this game now
&gt; My point is that you confuse people by saying one thing and then denying it. in future i shall remember to define precisely every word i use and to label each statement i make and to label my fundamental starting points as to avoid all possible confusion. it doesn't bother me if what i say confuses other people. if they care enough about wondering what i'm thinking, they can ask... clearly you care whatever it is i'm thinking so you keep asking... but i don't know what you are continuing this conversation for? do you have nothing better to do than to nitpick at every thing i said and make sure i made it clear to you exactly what belongs to which context?
&gt; This code grew on you... but you're not attached to it. i shall also add that if this is the perception you had then it is a consistent perception. something that grows on you need not be attached to you... a cancerous tumor being a prime example of such thing
&gt; This code grew on you... but you're not attached to it. i shall also add that if this is the perception you had then it is a consistent perception. something that grows on you need not be attached to you... a cancerous tumor being a prime example of such thing
Fuck off, dude. You whine and call people cowards for downvoting without explanation. I give you an explanation and you act all ironic and condescending. At this point I just wish you leave this subreddit and don't come back. FUCK. OFF. 
not going anywhere sorry bud
Hm, I seem to bit out of date, sorry - it used to work really well.
&gt; I am going to be okay if I keep practicing You are going to be okay if you keep practicing. &gt; intimidates me. […] I just feel dumb Just take your time and don't try to remember everything. You can always come back to the material and re-read it and learn more from it. I wrote my first program 18 years ago and I can name plenty of stuff that's over my head at the moment, but I plan to become competent at it in a year or two. In programming, there's a ton to learn and it just takes time.
Wow! I'm lost for words. Thank you and thanks for sharing links to the Modern Perl. I will be sure to check it out.
Modern Perl is great. See the Tutorials link the sidebar which prioritizes good and up to date tutorials. Also for sending email, check out [Email::Sender](https://metacpan.org/pod/Email::Sender) and [Email::Stuffer](https://metacpan.org/pod/Email::Stuffer) (Stuffer is a wrapper that makes sending attachments easy).
"The people who developed Perl 6". It was the Perl 5 community who developed the language specification for Perl 6.
You should consider that you are indeed talking with a professional in marketing: branding is his job. 
You see, they want Perl 6, as long as it's not called Perl6.
You mean zoffix's? That is a very interesting consideration, thanks for the info. His (or her, I'm not clear on this) replies seemed to address the Perl 5/6 naming problem in the aspect of furthering Perl 6 development. I am as much interested in Perl 6 as in Python or Ruby, e.g. I wish them all the luck but these languages are not my concern. What I did not see in "Rename Perl 6" movement is how Perl 5's branding going to be improved as the result. I am not a marketing expert, and in my truly humble opinion there is not much value in keeping Perl brand at all outside of the general scripting purpose. There used to be a joke around Silicon Valley that a surefire way *not* to get funded is to use Perl in your startup. Do you consider that a valuable trait for a brand?
Every single startup will use Perl. It's a namebrand everywhere. And there's no talks about what to do regarding the Perl5 brand because the Perl 5 community isn't involved in this at all.
The Perl brand is entrenched. It has its brand for better or worse, and it can work to improve that. The Perl 6 naming confusion and implication of a newer version/replacement/compatible language makes things worse, and those implications being untrue also hurts Perl 6. Fixing it won't solve Perl 5's issues, but it is a step in the right direction.
&gt; Every single startup will use Perl. It's a namebrand everywhere. That is how it was back 20 years ago. In 2018 there are very few, if any, greenfield projects in Perl 5. Keeping one's head in the sand and partying like it's still 1998 is not going to solve any of the problems accumulated in these 20 years. &gt; And there's no talks about what to do regarding the Perl5 brand because the Perl 5 community isn't involved in this at all. I am not sure how to interpret this statement. Is this discussion not an involvement itself?
If you ask people that track things like this, like Gartner, that's what they will tell you: everyone is using Perl. &gt; discussion Only the Perl 6 community is talking about branding. 
&gt; abandoning the brand that serves as the identity of the language and what it has accomplished over 30 years would be foolish. This is where our opinions differ in a major way. I have had a dubious privilege of working primarily in JavaScript world for the last 7 or so years; having met and spoken to many front end developers I think that Perl might have had more of a chance to be a language of choice for the back end *if*. You know the ifs. Branding and identity has a major impact on it, 100% negative. I believe that setting the identity (and reputation) aside is going to help, not harm. Technically Perl is still very much par for the course against many competing languages out there. But it is not even getting considered because of its reputation as a failure. Nobody wants to fail or having themselves associated with a failure, hence nobody is choosing Perl. This is the reality, and ignoring it is not productive. &gt; Fixing it won't solve Perl 5's issues, but it is a step in the right direction. I believe it is a step sideways. That is, renaming Perl 6 might help Perl 6 but it will have no meaningful impact on Perl 5.
Yes. I wrote a nearest neighbor categorizer in 2010 in Perl. It was tons of fun and came out well! But as another commented here, there was no library support. I did it all myself.
Lots of good tips in this recent thread: https://www.reddit.com/r/perl/comments/89b581/what_must_i_do_to_write_good_perl_5_code_in_the/ (also to /u/spore_777_mexen)
If you have suggestions for new brand names/aliases for Perl 5 or Perl 6 - I can add them to the growing list: http://nigelhamilton.com/perl-branding-proposal.html
/u/nohuhu might be interested in this.
Make an installer? This seems like you'd want to target experienced Perl developers anyway, so "install some module from CPAN" is trivial, "download this suspicious binary that isn't Perl" is unlikely to gain traction. And yes, you'd have to `use Prune;` in every module. You'll break CPAN modules if you don't. Whichever option you choose, best to make a new top-level post so people actually see it.
This looks really interesting, but I'm unable to get it to install using carton in an ubuntu docker container: Error evaling version line ' my $dummy = q# Hide from _packages_inside() #; package Module::Metadata::_version::p3229; use version; sub { local $VERSION; use perl5i::VERSION; our $VERSION = perl5i::VERSION-&gt;VERSION;; $VERSION }; ' in /carton/local/lib/perl5/perl5i.pm: Can't locate perl5i/VERSION.pm in @INC (you may need to install the perl5i::VERSION module) (@INC contains: FatPacked::25398176=HASH(0x1838ba0) /etc/perl /usr/local/lib/x86_64-linux-gnu/perl/5.22.1 /usr/local/share/perl/5.22.1 /usr/lib/x86_64-linux-gnu/perl5/5.22 /usr/share/perl5 /usr/lib/x86_64-linux-gnu/perl/5.22 /usr/share/perl/5.22 /usr/local/lib/site_perl /usr/lib/x86_64-linux-gnu/perl-base .) at (eval 6148) line 6, &lt;$handle&gt; line 11. BEGIN failed--compilation aborted at (eval 6148) line 6, &lt;$handle&gt; line 11. failed to build version sub for /carton/local/lib/perl5/perl5i.pm at /usr/share/perl5/App/cpanminus/fatscript.pm line 4928. Installing modules failed
As the person who not only completed the courses, but wrote them too :\-\) I'd be happy to answer any questions you might have.
Such things are brilliant. What would be more brilliant is if things like this can be gradually shifted into the core.
Fair warning: lots of these "fixes" are controversial because of surprises or performance issues. You'd be best using this in an isolated project and making sure to consistently use it across the project.
And BIG WARNING since I just realized this: this module enables Devel::Declare-based signatures, not core signatures, which is [problematic](https://metacpan.org/pod/Devel::Declare#WARNING).
Damnit, it uses its own custom Devel::Declare based signature parser. Speaking as the author of Devel::Declare, CUT THAT SHIT OUT THE KEYWORD API WAS ADDED TO CORE BECAUSE Devel::Declare IS A MASSIVE MASSIVE HACK AND ENTIRELY MADE OUT OF DUCT TAPE AND CRACK. If you want sane signatures, look at http://p3rl.org/Function::Parameters instead.
Thanks for the pointer! I didn't even know this module existed. :) Which sort of confirms my suspicion that if a seemingly useful (by 2009 standard) CPAN module hasn't got much traction in almost 10 years then this approach might be less than optimal.
&gt; "download this suspicious binary that isn't Perl" is unlikely to gain traction. One of the goals for fork/rename is to gain traction with new user base. Downloading a suspicious binary or even a shell script to run it under `sudo` is absolutely what most front end developers would do without even as much as blinking. Also it seems that CPAN module approach has been tried at least once: https://metacpan.org/pod/perl5i. Doesn't seem as if it worked well though.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://perldoc.perl.org/functions/tr.html) - Previous text "tr" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
perl? on mobile? interesting choice!
Oh yes. This is indeed an imrovement. The specification is a little vague in this regard :) 
Not Perl but Reddit on mobile - so, yes.
Argh, the survey does not provide Back/Previous. 
No need for regexes here. I'd use the `tr//` operator. #!/usr/bin/env perl use strict; use warnings; use feature 'say'; # tr/// works on $_ by default $_ = shift; tr/0-9A-Z//cd; say; The `/c` option "complements" (or inverts) the list of characters. And the `/d` option removes anything that isn't in the list of characters. So this means "remove anything that isn't a digit or an upper case letter.
If the program is run with the string to be worked on as the only argument, isn't the "$_=shift;" unnecessary? In fact, doesn't the fact that you're calling "shift" without an argument mean that it's already working on $_ cast as an array? I'd check myself but I'm on mobile. 
No. The `$_ = shift` is required. `shift()` is unusual in that it's default argument is not `$_`. In fact, its default argument changes depending on where it is called. Inside a subroutine, calling `shift()` with no arguments will work on `@_` (the array where subroutine parameters are stored). Outside of a subroutine (as in this example), calling `shift()` with no arguments will work on `@ARGV` (the array where command line arguments are stored). So, outside of a subroutine, `$_ = shift` means "remove the first element from `@ARGV` and store it in `$_`". Without it, `$_` would be uninitialised.
thanks, I like that.
I have to second this. My first thought at looking at Perl5i was that that the signature stuff wasn't going to cut it.
&gt; What would be more brilliant is if things like this can be gradually shifted into the core. What is preventing this from happening and can it be changed?
So, um, yeah, this is a bit self-serving, but I've been talking about this game for years and it's *finally* publicly available. The backend is entirely written in Perl using a standard Catalyst, DBIx::Class, Template Toolkit stack (we're very conservative with our technology choices because we're building a product, not a CV). Currently it's all Perl 5.24, using signatures, and too much Moose (I hate saying that, but it's a performance issue and we should have stuck with Moo for most of our work). I have some talks on Youtube about this. The best is probably my [Modeling a Universe in Perl](https://www.youtube.com/watch?v=UmLwYLSmTSs) talk that I gave in Amsterdam. People keep saying "don't talk about Perl, show the great things you can build with Perl!" Well, here's my attempt. Give it a shot and let me know what you think. Also, if you have any friends who are blind, color-blind, have mobility issues, or are otherwise challenged using a web-browser, please let them know about the game. We've worked hard on accessibility. So far our blind players have been very happy with it. And the game is entirely free to play, but if you spend money (you'll see the "Shop" link in the upper-righthand corner), it will help keep the lights on. Feel free to fire away with any questions you like.
&gt; show the great things you can build with Perl! Mission accomplished! This game looks really nice, though I think a pulled a muscle unloading cargo at the docks...
I signed up. Look forward to checking it out.
So, a mud with a browser interface?
Nope.
Congratulations on the release! I've been checking it out for the last 30 minutes, and it looks really nice.
Can't comment on the other developers, but I almost exclusively use vim for my editing.
Was about to sign up... until I read this comment. /s
what do you mean?
"/s" means "sarcasm". The person was making a joke.
Thank you. It's been a heck of a lot of work to get here!
You could also use `s/[^[:upper:][:digit:]]//gu` so it allows both non-ascii uppercase letters and digits (and make sure to decode your input first!)
except I'd strongly recommend against ever writing $_ = shift; in real code - this has a tendency to overwrite unexpected variables elsewhere in the code if it's called from constructs such as `map/grep/for/while(&lt;&gt;)`. Other options: - assign it to something else and use `$properly_named_variable =~ tr/.../` - `for (...) { ... }` which will give you a temporary alias instead of assigning directly to `$_`
The `for` loop is a good idea. You could iterate across all command line arguments to process multiple strings. for (@ARGV) { ... }
I love seeing successful examples of Perl 5 coding. Good work.
Signed up. It looks very, very well done. I am super inspired by your efforts.
LMAO... (not /s)
If you think my using vim is funny, that's fine. But it's nice to have discussions instead of insults. _Why_ do you find it amusing that I use vim? I can't possibly understand what you mean by "LMAO".
Sorry, I think you misunderstood. I am not insulting you. I am using Vim as well. I LMAO because @hurricup asked such a question.
[My observations](https://www.reddit.com/r/perl/comments/8a12lr/built_in_perls_perl_developer_survey_2018/dx2hien/).
My bad. You're right I misunderstood :)
Not necessarily the **best way** (using Perl *5* is often better than using Perl *6*) but one way to write this in Perl 6 that I think is easy to read is: say "Mickey Mouse 2018" .trans: / &lt;-upper -digit&gt; / =&gt; '' `.trans` is a method version of the `tr` function in P6 (which is like a slower but more powerful version of `tr` in P5). `.trans` / `tr` take various argument types. in this case I've passed a pair. The left hand side is a P6 regex that matches any character that's neither an uppercase character (any language, not just English) nor a decimal digit (any language, not just English). The right side is the replacement, in this case a null string.
I was about to comment on this. `A-Z` isn't Unicode-aware IIRC, so strings like "Álvaro" would cause trouble. Maybe the OP's best bet is filter through `unidecode` first.
`s/[^A-Z0-9]+//g` would just remove any non-ascii characters. The problem requirements in this area were not sufficiently stated to decide whether removal, decoding, or unicode treatment was desired :)
You can't do everything, sure, but executing this script was not a problem for me...was it for you?
Yeah, something for the OP to consider. 
&gt; Whether they think the effort to use it is worth the opportunity cost is the operative question. Seconding this observation. I held my nose and answered "Yes", but would have liked to follow up with "... and have no plans to continue."
Thank you for truthfully answering that question. From my point of view, I find the lack of followup Perl 6 questions annoying because I could not say "and I have plans to continue". Also, the question about moving to another language didn't even include Perl 6 as an option. Which to me just shows that they put in a "token" Perl 6 question because they felt they had to, for whatever reason. So rather than assuming some evil Perl 6 influence here, assume Hanlon's Razor instead.
This is great, congratulations! Still waiting on seeing your cats in-game though :3
Interesting!
Parsing experts, please critique the following: &gt; In the strict sense, a recognizer cannot driver a compiler -- a compiler needs a parser. But recognizers can be far easier to write, and are often hacked up and pressed into service as parsers. For example, if your semantics is simple and non-recursive, you might be able to drive your semantics phase with the output of a regex engine, using captures. If one replaces "recognizers" per current formal parsing theory terminology (finite state machines that either accept or reject a string as matching) with "recognizers-too" per practical common sense (sufficiently powerful automata -- turing machines if necessary -- that either accept or reject a string as matching), then one can replace the above paragraph with: &gt; A recognizer-too can driver a compiler. Recognizer-toos can be far easier to write than other forms of parsers, and are often ideal as parsers. For example, even if your semantics are turing complete, you can easily drive your semantics phase with the output of a recognizer-too equipped grammar engine, using captures. Hence, P6 grammars. Is this a reasonable perspective?
Calling /u/daxim/, I hope you don't mind me summoning you, but I recognize you as someone who is A) sufficiently knowledgeable about parsing and B) uncompromising in pushing back against what you consider poor guidance. As such your opinion about the above would likely be instructive and I would appreciate your response, presuming no one else has yet provided one you consider adequate. To be clear, even though I currently think the above *is* a reasonable perspective, I recognize that my claims may be dubious (especially that "Recognizer-toos ... are often ideal as parsers" -- my intent was to contrast that with Jeffrey's "recognizers ... are often hacked up and pressed into service as parsers", which is of course true of much traditional regexing) so I half expect a laundry list of negatives. I intend to be ultra careful to be gracious no matter what your view is. Would you be willing to comment and/or do you know someone else who would? TIA.
Why is this better than just setting a 'debug' flag, and maybe setting it by reading a command line or environment variable?
Amen! :) Same here. I'm not an everyday developer, but in 15 years I made countless scripts and small tools that made mine, colleagues, friend's life easier, and it was almost all made with Perl (mostly for Windows!). I've done some stuff in C#, php, JS, earlier in VB over the years, tried Python for some tasks, but whenever possible I always use Perl. Perl 5 is an amazing language.
I love the idea of release a major version of Perl 5 to Perl 7. Its been talked about before.
Part of the problem is you define "perfect tool for the job", but can't state why. Then you go on to mention legacy -- *which age made too complex and variegated*. Legacy tools die off at some point. Perl's point is nearing.
Great to hear :-)
What do you miss when you go to JS. For a counter-case, I'm still active with Perl, and I have multiple modules on CPAN. I like the JS community a lot more, but the only thing I miss with ES6 is Moose.pm, and most Perl modules aren't Moosified anyway.
No, I think you're missing my point. Those legacy compilation chains will also go away. Give it time. And legacy compilation chains don't make a "perfect tool" in any capacity, ask the people using it. Their response is typically prefaced with "we wouldn't do it like this now... but...."
Easy Unix and C interop. On the other hand, JS has a module to [check if a number is even](https://github.com/jonschlinkert/is-even).
I funnily started learning Perl as a mistake originally. I was listening to a Q&amp;A by John Carmack (the doom, wolfenstein, id software guy) where he was talking about how he started learning Lisp by rewriting doom in it. I thought that sounded cool, so I went to my local bookstore a few days later. In the programming section, I saw a book called “Learning Perl.” For some reason, my brain thought Perl was Lisp, so I bought the book. When I got home, needless to say I was a little surprised 😂. However, I stuck with the book and now use Perl in my daily life. It’s by far one of my favorite languages, and I couldn’t see myself NOT doing it! Thanks John Carmack... I guess?
Well played, though IsEven doesn't have enough dependencies to be trusted. Still, I will "consider starring the project to show my ❤️ and support."
Aren't Perl 5 and Perl 6 both members of the Perl family of programming languages? I know they're different languages but they're still Perl.
&gt; nobody uses perl anymore There are dozens of us. Dozens!
Yea Perl has no place in professional development any more than COBOL....wait...
This is one interpretation, but Perl 6 is very much incompatible with the established Perl language, and brings very different strengths to the table. In this sense, it is not Perl.
No need for a module when, % is built-in, no? 
`%` is a builtin in Javascript too
% isn't used in the JS isEven() implementation. Is there a reason? 
I was working at an ISP in about 1995, and my boss dropped "Learn Perl in 21 Days" on my desk and said I needed to learn to write CGI programs so we could make web sites for people. So I did. It was pretty ugly back then -- CGI.pm wasn't around yet (or I hadn't found it), but there was a small library that at least parsed query strings. Perl's come a long way.
I know of three companies in my state which use Perl, one of which, I work at. I can get a job almost guaranteed at the other places because I am adept at wading my way through 15 year old Perl code swamps.
`isEven` is written in terms of `isOdd`. In general `%` is more expensive than bitwise `&amp;`, so `isOdd` is implemented in terms of that. Sadly, JavaScript cannot handle integers larger than 53 bits.
I was a beginner PHP developer. Than, quite suddenly, I ended up in a big company on new important Perl project (as part of the team)... In six months I was a proficient Perler. Love that language since. Too bad it got write-once vibe from the old times. I feel like this is the reason why its declining.
Yeah, exactly. MSA has taken a lot of heat over the years, as it's easy to criticize after the fact. Matt himself has advised people to not use his earlier scripts. But it was really cool to have some real-world examples of things we needed that were readily available, to learn from -- even if we eventually started doing those things in different ways.
I can state why, if you have used:- C, java, php, javascript, bash. then perl is pretty easy to pick up and run with. The only competitor seems to be python, which looks very much like visual basic. I can see why it's popular in schools, you have to teach to the lowest common denominator. Same with group projects. However, if you give someone with a c style language background a choice, they'll choose Perl. 
Definitely. We were all figuring it out as we went along. Kinda still are, but we have a lot more resources now. MSA was an important one when there weren't many others.
&gt; The sense of pride ... and accomplishment?
Yes, and accomplishment. 
Now I don't know if you got the reference... but anyway, forget it, it's a silly reddit thing. ツ Welcome to the Perl lovers community!
I like the scaffold. It's all there: tests, profiling, debugging, web frameworks. And of course dealing with CSV, JSON, XML is a breeze.
&gt; A number of times in recent weeks people say you should use Python, nobody uses Perl anymore. People who say this are not developers - they couldn't code in C and they probably couldn't write a BASH script. Perl offered the best of both worlds - the readable syntax of C with the power of BASH scripting - and a reasonable execution speed for a scripting language. I've experimented with so many languages and Perl won me over because it was fast, extensible, and practical. Python, on the other hand, brought a better object model at significant cost: an unprofessional indentation scheme that made re-formatting with a pretty-printer next to impossible. Sadly we live in a world now where we expect so little of our developers and system administrators. It is as if the world went into a race to the bottom - where "devops" is now an unskilled job for operators to use off-the-shelf tools and paste together the most basic of scripts. Ten years ago "devops" was all Perl because the scripts were advanced and maintained by skilled developers.
I started out trying PHP - but back in those days (think RedHat 3, not RedHat Enterprise Linux 3, I'm talking RedHat 3) the PHP executable took a long time to load - as it threw in the kitchen sink (pulled in lots of linked libraries - including graphing). Perl, on the other hand, was extremely lightweight and you had the option of pulling in modules that you wanted - so it could fly if all you needed was something basic, and it could get bogged down if you really needed a ton of extra functions (say, graphing). That's how Perl won it for me hands-down over PHP. Perl gave me choices. PHP was far too rigid and bulky.
&gt; What do you miss when you go to JS A decent debugger. Perl has had reasonable debugging forever. Good luck debugging a server-side Node.JS script.
Perl 6 is to Perl what Scala is to Java.
Perl 5 and 6 have a common community and ethos ("there is more than one way to do it"). Oh, and hands-down the best unicode and regular expression support. That's about all they have in common. The rest is all different. Completely different.
Does Amazon still use Perl?
Thank you for the report and the hard work. 
I started learn perl about 18 months ago. The work systems are running linux and i wanted to start scripting some mundane task. In uni i had been taught C,PHP,javascript,java, + little bit of matlab. I read up on many of the big one :- bash - tried it for a while, but it was too slow and awkard. took a long time to make progress, too much debugging. spend a couple of months on it TCL - again trid it for a while, it's good but the capture groups for regex make it very slow going. Plus the syntax was very clunky ruby - looked very nice, but not realy supported don the work system. did spend a week learning the syntax python - look like ruby cross vb6 from the naughties. I saw it very much like ruby but ruby just looked a nicer syntax. I did not like the inforced formatting on either. perl - finally i gave perl a try. On the internet people said it's old. but the work system was old, and this was a strength, it means all my questions would have been answered years ago. --------------------------- I write very php like code at the start. It took me about a month to get to a point where i could write scripts more than a couple of lines. Now i wish i had have picked it up earlier. The speed i can chuck something together compared to colleagues is amazing. The fact i can make a script to my rules is really a selling point for me. I'm really glad i spent the time to choose a language, not just pick the one someone said on the Internet is good.
Hey, barryoff, just a quick heads-up: **realy** is actually spelled **really**. You can remember it by **two ls**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
How about some articles on interfacing with Python?
Just visited &lt;https://perl6.org/&gt; and I'm greeted with: &gt; Hi, my name is Camelia. I'm the spokesbug for Perl 6, the plucky little sister of Perl 5. Calling it "Camelia" would help both Perl 6 and Perl 5.
Except that Scala is a really useful language to know for practical reasons rather than something you work on as a hobby. Also, [Scala is more like Perl](https://github.com/garu/scala-for-perl5-programmers) than Perl 6 is like Perl. Also, Scala has [impressive parallelism](https://alvinalexander.com/scala/scala-parallel-programming-collections-par-performance). Also, Scala has [Akka](https://akka.io/).
I like your idea! Oh man, "spokesbug". Someone must be hovering over the web content folks with a shotgun. * Writer: "Wait, bugs are bad in code. Why would we want the bugs to represent an upcoming language?" * Totally not Larry Wall, no sirree bob: "Camelia speaks or you can take a hike." * Writer: "I'm not even getting paid." * TnLWnsb: /sets writer's hair on fire
I dunno, seems like it would be kind of rude to hijack the next major version number from a project -- and it might send the wrong message, that the project with the hijacked version number is a dead end, expected to go nowhere. That would strand tens of users.
The Scala to Perl comparison is very neat! However, no analogy is perfect. ;)
Rather defensive statement from TIOBE, painting Perl users as "diehards" starting a "religious war" and an out of context inclusion of an active Perl developer's talk; as always, its index should be taken with several grains of salt. That said, I agree with the assessment of the issue with continuing Perl 6 confusion.
Dying since 2008, then?
Seems like I need to be using C more. Oh wait!
I don't know why anyone bothers reading TIOBE. It tells you nothing more than "These things appeared in some searches more than others". What possible use is that information? I certainly hope nobody makes any sort of decisions based on the raw data and punditry. As a moderator of /r/perl, I approved this posting. As a participant, I downvoted it immediately.
So today i started building a mojo web app to see if mojo will work for my new project at work. its awesome. Perl is very alive...only confusion on Perl 6 and the future of Perl...but we all know this on /r/perl its almost a weekly post.
I have been playing this during lunch for a few days now. It's really good. Really, really good. It's text based so it's SFW which I absolutely love because I rarely leave my desk anyway.
Indeed, if they're claiming the language is going extinct then let the numbers bear it out - no need to defend their claims from 10 years ago that still haven't come to pass. Python beating C# or VB.net edging past PHP both seem like more interesting datapoints to call out. Also: - R is accelerating past MATLAB - Kotlin barely scrapes into the top 50 despite Google's support in their official IDE - The official search index still uses the obsolete + notation in their Google search query - As with previous years, the "C programming" query seems quite likely to have a disproportionately higher count than just the unique name of a language (5.8m for "C programming", 18.8m for "Perl") - Google still counts for the majority of the score (country-specific domains for 16 of the 25 "search engines" they use) I'm sure they put a lot of effort into this thing, but I'm not planning on using these statistics for any hiring or career choices.
I'm not comfortable with the "religious war" and "diehards" language but, other than that, I can't disagree with anything in that post. Perl has been dying since 2005 (probably before that). Lots of people have put a lot of effort in trying to turn that around and they've certainly slowed things down, but I don't think we've done enough to stop the decline. There is far less Perl work in London now than there was in 2000. Pretty much every client I've worked for in the last ten years has begun (or even finished) a project to move away from Perl. The only reason that I can get work these days is because programmers are abandoning Perl at a faster rate than companies are. Of course, the Perl tools that are available get better and better all the time. But what does that matter if people outside of the community don't know that and have no interest in finding out? Here are three questions I ask myself to judge how well Perl is doing: * When did you last hear of a company using Perl that you were previously unaware of? * When did you last read a general programming book that used Perl in any of its examples? * When did you last use a new API that included Perl examples in its documentation? For me, the answer to all three questions is "I can't remember". I'm old. I'm really past caring. I'm pretty sure I can make enough of a living maintaining old Perl code until I retire. But I really wouldn't recommend anyone younger than my investing any time in it.
I had a paragraph about the Perl 5/6 confusion, but I deleted it. Every time I talk about that in public, I get myself in trouble :-/
I try not to, but every now and then I can't help myself. I usually regret it later :-)
&gt; There is far less Perl work in London now than there was in 2000 Not too surprising, since there's also a lot more choice out there. Python, node.js, Rust, PHP, various .net things, maybe even Go: these all tend to be viable alternatives to Perl, 18 years ago the options were limited at best. We use a range of languages, but Perl is still the main development focus - we hire+train developers, rather than just looking for Perl programmers, since one of Perl's strengths is that it tends to be easy to get an experienced developer up and running. It's useful to have JS, Python, C++, R, PostgreSQL, Lua and ES6 developers around rather than being a pure Perl shop, since this encourages people to learn from the other languages and libraries. We use Perl because it works, not just because we have legacy code - there's certainly no business case for porting to anything else at the moment! (I wouldn't mind being able to use a battle-tested [async/await](https://metacpan.org/pod/Future::AsyncAwait) implementation in production code, though - this is one area that people rightly point out ES6/C#/etc. are ahead of us)
&gt; &gt; There is far less Perl work in London now than there was in 2000 &gt; &gt; Not too surprising, since there's also a lot more choice out there. Python, node.js, Rust, PHP, various .net things, maybe even Go: these all tend to be viable alternatives to Perl, 18 years ago the options were limited at best Sure, there are lots of options. But, as far as I can, no-one chooses Perl these days. I wouldn't mind if Perl was considered with the list of languages you mention above. But unless a company has an existing Perl codebase, they won't even consider it. And that will be for one of three reasons: * The Perl code we wrote in 2000 turned out to be completely unmaintainable. * Perl hasn't had a major new release since 1994. * We can't find Perl programmers. I know that the first two of those reasons are nonsense. But it's what I hear development managers tell me time and time again.
Also perhaps hash ordering changes and enforced parentheses for `for` loops.
Given the other options, it would almost certainly be the latter.
Sure. What is it and what part of it you're having trouble with?
If a TIOBE has a commentary on Perl in this light then it shouldn't be hidden from the Perl community here.
Yeah, and the same goes for "...choosing Microsoft." I just started a new full-time gig in a Microsoft shop. It will be a hoot. C# isn't terrible, but the culture is just suffocating. However, there is no job that I've ever had where I didn't eventually write something in Perl that ended up saving the day, and this job will be no different, I assume. That has something to do with Perl, of course, and also something to do with the attitude that lots of Perl people have: pragmatism.
It's seven hours since you posted your urgent request, so your deadline might have passed. But you you post a specific question, you're very likely to get useful help here.
Create a Perl 5 script to do your homework for you. 
I've actually figured it out, first time i posted on here and forgot to keep checking for responses, i just stayed up all night and figured it out. Essentially, I Created a database using sql with three tables and multiple values that would input values from an executed program and display the output on a csv file. Sorry for replying late, but yes i would have paid and not to just have someone do the homework but to actually teach me what i'm doing wrong. I'd prefer to know what i'm getting myself into and not just get by on chance. I tried multiple sites such as chegg and coursemart and every tutor i messaged either was not confident enough or lacked perl programming knowledge. Thanks again for the reply, i really wasn't sure how active the community was.
Figured it out but, thank you:)
Unfortunately, it's the right answer. There are no Perl bindings for Android libraries, you would have to implement them by yourself using XS.
With [Future.pm](https://metacpan.org/pod/Future), I'd suggest the [fmap_concat](https://metacpan.org/pod/Future::Utils#fmap_concat) helper function. It allows you to set the number of concurrent requests to have active, sometimes useful if you want to avoid overloading the target system(s). Futures also allow you to do something like sub request { my $self = shift; $self-&gt;{request} ||= $self-&gt;fetch_all_items()-&gt;on_ready(sub { delete $self-&gt;{request} }) } if multiple things can be requesting the data at the same time, and you want to consolidate those into a single DB request without caching it indefinitely. Do at most 4 concurrent DB queries at a time, allowing 5 seconds for each one: sub fetch_all_items { my ($self) = @_; return fmap_concat { Future-&gt;wait_any( timeout(5), # anything that returns a Future which fails after N seconds $self-&gt;fetch_single_item($_) )-&gt;else(sub { Future-&gt;done() # empty list if there was a timeout or failure }) } foreach =&gt; [ @items ], # presumably these come from a method or constant somewhere concurrent =&gt; 4 } my @results = $self-&gt;request-&gt;get; The idea behind promises is similar, but unfortunately the API is not compatible.
Thank you very much for taking the time to reply. I'll review this and put together some tests
So are you saying it is possible...? Is Android/Cyanogen open enough to allow this?
It's far more effort than writing a app in, say, Java or Kotlin. You could try starting with https://metacpan.org/source/SHAY/perl-5.26.2/README.android, which is very outdated, but note that it's specifically aimed at building Perl for Android, rather than Perl applications.
The first question is what database you are using. Non-blocking query support varies wildly between databases, and if you can't do a non-blocking query, you're going to need to fork in order to do any of this concurrently.
It can be made compatible (at least in that direction): https://metacpan.org/pod/Mojo::Promise::Role::Futurify
Just push each line onto an array and when you hit the next start label, run a function that arranges so the data in the array however you want, then empty the array
What have you tried so far? You can use regex to identify the line that says "start" (this would be a simple one: `$line =~ m/^start$/`), but you don't really need it for the rest of the problem. [split](http://perldoc.perl.org/functions/split.html), [join](http://perldoc.perl.org/functions/join.html), and [sort](http://perldoc.perl.org/functions/sort.html) will probably be useful.
 #!/usr/bin/perl use warnings; use strict; use feature qw{ say }; sub func { join ' ', sort { $a &lt;=&gt; $b } @_ } sub output { return unless @_; say 'startEdited'; say func(@_); } my @numbers; while (&lt;&gt;) { chomp; if (/start/) { output(@numbers); @numbers = (); } else { push @numbers, split; } } output(@numbers); 
One-liner (bash shell): echo 'start 5 6 2 8 5 2 6 4 start 1 2 8 2 6 8 5 5' | perl -0777 -wnE'($a = $_) =~ s/(?&lt;=\d)\n(?=\d)/ /g; @b = map { /^\d/ ? join(" ", map { int(rand(9))} split) : "${_}Edited" } split /\n/, $a; say foreach @b' 
I'm not sure I understand your requirements. You want a function that takes a list of numbers like `(5 6 2 8 5 2 6 4)` and returns `(1 2 3 4 5 6 7 8)`? How do you want it to decide what numbers to return? Should it just return the first counting numbers equal to the quantity of numbers in the original lines? So if there are 10 numbers in the original set of lines, should the function return `(1 2 3 4 5 6 7 8 9 10)`?
Lots of different ways to get there and some good ones already posted. This one doesn't use too much magic and doesn't slurp the entire standard input into ram: local $/='start'; while (&lt;&gt;) { next unless my (@a) = /(\d+)/g; print "startEdited\n", someFunc("@a"), "\n"; } 
local $/='start'; while (&lt;&gt;) { if (my (@a) = /(\d+)/g) { print "startEdited\n", someFunc("@a"), "\n"} } 
local $/='start'; while (&lt;&gt;) { my @a; print "startEdited\n", someFunc("@a"), "\n" if (@a) = /(\d+)/g }
my @a; $/='start'; while (&lt;&gt;) { print "startEdited\n", someFunc("@a"), "\n" if @a = /(\d+)/g }
Just a caveat: If you're anticipating large files, it's generally best to avoid loading the whole file into memory. You risk ["out of memory" errors](https://stackoverflow.com/questions/28329568/perl-out-of-memory-with-large-text-file).
Oracle. Each database lives on it's own server.
Yes, this is ineffecient anyway, why on earth would you use a regex in the first place (as the OP requests) What I would *actually* do is something like: $/ = "start"; while(&lt;&gt;) { chomp; somefunction($_); # write 'startEdited' + the output of somefunction here to whever it goes } Which would be faster by an order of magnitude, and have no memory issues, but confining myself to a regex, I'd rather do it in whole file mode for simplicity (If you're going to use a regex, you might as well use it as a regex, right?). I've also processed some very very large files (much larger than the 400mb one in that link, larger even than my available RAM, yay for page files) with perl, with no issues (other than extreme slowness from paging to disk), I suspect that's a result of strawberry's specific implementation, rather than a language restriction.
We need to get this as a pi image. I will try this later, looks cool.
Using /u/tm604's suggestions combined with subprocesses (warning: untested) use Mojolicious::Lite; use Future::Mojo; use Future::Utils 'fmap_concat'; use Mojo::IOLoop; get '/' =&gt; sub { my $c = shift; $c-&gt;render_later; my $all_f = fmap_concat { my $db = $_; my $f = Future::Mojo-&gt;new; Mojo::IOLoop-&gt;subprocess(sub { return do_query_on_db($db); }, sub { my ($subprocess, $err, @results) = @_; $err ? $f-&gt;fail($err) : $f-&gt;done(@results); }); return Future::Mojo-&gt;wait_any( Future::Mojo-&gt;new_timeout(5), $f, )-&gt;else(sub { Future::Mojo-&gt;done; }); } foreach =&gt; [ @dbs ], concurrent =&gt; 4; # need to keep reference to the futures around $c-&gt;stash(queries_future =&gt; $all_f-&gt;then(sub { delete $c-&gt;stash-&gt;{queries_future}; # break ref cycle foreach my $f (@_) { my @results = $f-&gt;get; # empty if timed out # form response } $c-&gt;render(json =&gt; $response); })); }; Sure there are less complex ways to do it, but they'll end up taking more code; there's no simple way to get both concurrent blocking DB queries (which subprocesses handle) and timeouts (which Future handles). As for the database connections, I would use [DBIx::Connector](https://metacpan.org/pod/DBIx::Connector) objects to encapsulate them and pass them around, but keep in mind since you need to do the query in subprocesses, each subprocess will end up creating a new connection.
Mandrivia's package manager, urpmi, is also written in Perl.
If you're using Oracle extensively, I'd consider implementing the TNS protocol (or finding someone to implement it for you). It's relatively simple, although you'd need to be careful about testing: at one point sending certain combinations of flags would cause the server to lock up with 100% CPU usage. Hopefully that's now fixed...
Glad to see my book was of some use!
I guess those that missed the Indiegogo have no way of getting it?
Thanks for the quality answers everyone. Exactly what I needed!
That does seem like a failure for Perl on all platforms. Is multi threading support being addressed? There's much talk about Perl and it's future, Perl 6, etc. For me, I'd suggest multi thread is necessary for any language to survive into the future, is it not?0
FUCK. 
Threading in interpreted languages is tricky to add without introducing performance potholes. A lot of languages don't bother -- Python has very limited threading, for instance, and Node has none at all.
Interesting. Isn't node Chrome's V8 JavaScript engine? So not really a distinct language? Doesn't it therefore have Web Services (is it?). 
&gt; Is multi threading support being addressed? No &gt; For me, I'd suggest multi thread is necessary for any language to survive into the future, is it not? Not necessarily - typically on Unix-like systems, Perl code tends to use processes for blocking/CPU-bound cases. Threads aren't really an issue for Android and Perl, either: life is easier if you avoid sharing data between the UI thread and any I/O threads, and rely on posting instead or have Java take care of the UI with Perl running in the background. A bigger problem is how you actually build the application - bundling the entire Perl+CPAN dependencies makes the resulting APK not very attractive compared to Java/Kotlin/NDK. Also, if you *do* let Perl drive the UI, it ends up noticeably slower than Java for anything more than a trivial application. That's not threads, it's just the overhead in Perl for all the scalar handling and method calls that does not compare favourably to the performance that you'll get with the "standard" languages. That also translates to worse battery life. It'd be nice to have better threading options in Perl, but by the time performance starts to be an issue, there are much better language options out there. Refcounting and threads aren't a great mix, and it'd take some work on the Perl internals to implement or modify the thread handling - if anyone's interested in doing that, they are keeping very quiet about it! Using Perl to generate Java/Kotlin/layout XML, on the other hand...
Interesting thoughts. Thanks!
so I hear yes. Most of what you see on amazon.com I believe is perl (mason) code transpiled to C++. So I hear anyway. There's a tonne of perl at amazon, but I hear the team structure is such that there are lots and lots of independent small groups working together using the tools they want.
Oh snap! Your book is easily one of my favorite programming books! It made the weird, confusing, off the wall stuff of Perl seem really approachable, and gave me the confidence to actually use the language daily after I finished reading. Thanks!
Maybe you use sock() and work with the IO::Socket object it returns?
This doesn't really seem like a problem with the Perl code...
Unless the front-end is somehow perl code compiled to javascript (as I was writing this post I found about [perlito](https://github.com/fglock/Perlito), I'm definitely going to try that), I fail to see how the *perl* sub is going to help you with a front-end related problem.
&gt; I don't see a problem, except for laundry list of major examples of the problem Each of those things you cited broke things outside of CPAN, many of them were undermaintained, and this muchly triggered lots of responses downstream of "how about we migrate away from ..." 
Well, guys, and gals.....I apologize if this seems to be the wrong place for the question. The application is all Perl, and I had been asking here before for help with the Ajax aspects of it, so I posted here in the hopes that someone--anyone--might be able to help out. I also posted in the Javascript sub, and got some good tips over there. Sorry to have polluted the sub, so to speak. :-)
Problem is now solved. Believe it or not, Chrome doesn't like me typing too quickly. If I slowed down the typing, it was fine. So I put a delay into the javascript to monitor for a pause in the typing before executing the Ajax, and now things seem to work just fine.
Can you provide an example of what you want to do with poll?
So '.'-in-@INC was a security issue, what would you have suggested p5p do instead? Regex changes - I'm specifically talking about `{` handling - had workarounds to reduce breakage (autotools being one example, IIRC). That's two items, the laundry list is looking more like a pair of socks to me! You mention there were many things which broke: I'd suggest sharing that list with p5p, and posting it in Perl forums (such as this one!) so that people could help fix the code. I wouldn't say that a single change over several decades would count as "keep changing their code", that seems like an exaggeration - but yes, avoiding any changes at all would be preferable. Can you suggest any other changes which broke back-compatibility? Again, if so I'd suggest raising that with p5p - they have limited resources and imperfect visibility of the entire Perl-using community, I'm sure any help would be appreciated.
lol 👍
You're missing the point. Those changes, regardless of their motivations, required end user code to change in order to continue working. This, by necessity, needs a skilled perl developer. If you have no skilled perl developer, you're going to either: a) try to find one b) switch away from Perl If you can't find a skilled perl developer, then option b will occur.
For comparion, this is the [perl5 implementation](https://metacpan.org/source/ETHER/Acme-LookOfDisapproval-0.006/lib/Acme/LookOfDisapproval.pm/): ``` sub ಠ_ಠ { goto &amp;CORE::warn } ``` 
I doubt you'll find anything perl specific, but that's ok, because all the things you need to learn are language agnostic. ML is a lot of matrix math, and data clean up. I took Andrew Ng's online class, and used octave, which translates pretty easy to perl's pdl.
Some of those questions are avoided because they go nowhere. Like, we have a handful of people who *already* raise back-compatibility issues with P5P *before* they happen, and it just turns into a flame war, and frequently turns up on the side of preferring change instead, to the point people get demotivated about bothering to say anything. One might argue we're better at this than other languages, but using other languages as our standard is not acceptable. This is one of our selling points, we need to set the gold standard.
&gt; frequently turns up on the side of preferring change instead Just as frequently does not, from what I see. Every case has its own impact and importance.
Perl is a pretty great language for ML, but I don't know of any books for it.
Just curious, what features or tools do you think make perl great for ML?
you got mostly AI::FANN and AI::MXNet that link to MXNET library. I would not say that perl is the best language for AI but it can run neural network,train and solve.
Way too many dependencies &gt; Bailing out the installation for App-genpw-0.007. &gt; 147 distributions installed 
I've never heard of G-WAN. Can anyone confirm it lives up to the bold claims?
Based on a cursory examination of the website, G-WAN sounds too good to be true: faster, easier, less resource intensive, language agnostic, etc. Despite being active since 1999, I had never heard of G-WAN prior to today. However, according to their website they've been around a long time. &gt;Since its first release in June 2009, G-WAN is the undisputed technical leader of a well-financed (20 years old) market. Maybe this is why our customer base is so loyal since 1998. If the technology is truly superior, and it's been available since 2009 (but they've had customers since 1998?!?) why isn't it even a blip on the Netcraft webserver stats? It's very intriguing but something doesn't smell right.
It doesn't. G-WAN is the Time Cube of web servers. Closed-source, questionable security (compiles C "scripts" on the fly?!), intentionally confusing and outright rigged benchmarks...
Frequently != Mostly. Frequently = "often enough that it causes problems, by being non-zero, and those problems cause damage sufficient that people have to actually debate the issue". Its not a question of what happens "in majority", because "we only break perl in 1% of the things it does" is still not acceptable. Its majorityness has zero effect on whether or not downstream code will become broken, and subsequently has zero effect when it comes to management deciding what to do about realizing their platform will become broken when they next do their OS updates. They will either acquire the skills to fix the problem, ( which will cost them time and/or money, which will potentially have more costs down the road ), or they'll switch to a cheaper alternative for which they don't need to acquire additional talent. 
 $ perl -e 'sub ಠ_ಠ { goto &amp;CORE::warn }' Illegal declaration of anonymous subroutine at -e line 1.
 #!/usr/bin/env perl use strict; use feature qw{ say }; use warnings; my $keyhash = { D =&gt; { AC =&gt; { key =&gt; 'value' } } }; my %ACD = %{ $keyhash-&gt;{D}-&gt;{AC} }; say $keyhash-&gt;{D}{AC}, ' == ', \%ACD, ' ?'; # No. my $ACD; # Not the same as %ACD. { my @one = qw( 1 2 ); my @two = qw( 42 43 ); $ACD-&gt;{one} = \@one; # @ was missing. $ACD-&gt;{two} = \@two; # Same here. } # End of scope. say "@$_" for @$ACD{qw{ one two }}; 
&gt;&gt; When you dereference a question like this: `my %ACD = %{ $keyhash-&gt;{D}-&gt;{AC} };` &gt;&gt; Does this create a copy of the hash pointed to? It creates a shallow copy of the hash. That means that the keys and values will be copied into the new hash. So changing the value of a key in one hash will not change it in the second hash. However, if you have references to other data structures in your hash, then those references will still point to the same data. my %hash1 = ( blah =&gt; { a =&gt; 1, b =&gt; { foo =&gt; 'bar' }, }, ); my %hash2 = %{ $hash1{blah} }; $hash1{blah}{a} = 2; $hash1{blah}{b}{foo} = 'baz'; say $hash2{a}; # not changed, will display 1 say $hash2{b}{foo}; # has changed, will display 'baz' As for the scoping question, perl keeps a count of how many references are pointing to a data structure. The data does not go away until all of the references pointing to it disappear. So in your example, if @one goes out of scope, but $ACD-&gt;{one} still points to the data in that array, then the data is still accessible. If you then do `$ACD-&gt;{one} = [1,2]`, now the original array data disappears, and a new array is created and a reference to it stored in this hash.
Just as an FYI `$keyhash-&gt;{D}-&gt;{AC}` is the same as `$keyhash-&gt;{D}{AC}`. After the first arrow the rest are assumed. For calling a function from in the hash I usually then add in an arrow `-&gt;()` to make it obvious that's happening, as just `()` in the middle of something might look like a simple access. But hey TIMTOWTDI.
&gt; It creates a shallow copy of the hash. That means that the keys and values will be copied into the new hash. So changing the value of a key in one hash will not change it in the second hash. I'm not sure about terminology in the Perl world, but in the C++ world that would be called a deep copy.
No. However, see https://github.com/jgm/pandoc/pull/497 and https://metacpan.org/pod/Pod::Pandoc - or use one of the formats with common converters, e.g. markdown.
thank you
thank you
thank you
I'm old school. If it's a ref, it gets a -&gt; because I'm OCD that way. Plus, to me, it also re-enforces the shallowness of copying around these data structures. But that's just me. I guess it depends on the audience. Internal code, make your typing easier. Public published CPAN module, I'd include the -&gt;s.
You need `-Mutf8` (and also in the code where you plan to call the sub)
Nothing Perl related...
Sparrow is written on Perl. You use sparrow plugins with Sparrow.
So what advantages does using sparrow and sparrow plugins (written in perl) does this action have over installing git with your flavors package manager followed by `vi ~/.gitconfig`
See &lt;http://seriot.ch/parsing_json.php&gt; for context. The article was recently updated with the latest JSON RFC and also the result from the Cpanel::JSON::XS module is new in this version. ---- JSON's value is overrated by its users, mistaking popularity for quality. You can anecdotally verify that by going to your next tech meetup and interviewing people abouts its merits in comparison to formats that occupy the same problem space. ---- Now, the thing is, we would not need to be in this situation of this mind-boggling incompatibility among implementations of the format – seventeen years into its existence – if it were properly designed. The blame falls on the shoulders of format authors like Crockford and Gruber who do not make good governance for properly shepherding their creation. JSON and Markdown could be really good, but because they are the persons they are, it's impossible. It's one thing to adamantly say no to change requests, but throwing up one's arms and walking away after putting it into the world, never even wanting to take care of removing low-hanging design mistakes such as well-known warts, undefined behaviour and opportunities for misparsing (as detailed in the article), *but then also* blocking other people from getting it done, I find reprehensive and foul. Their irresponsible behaviour is to be exposed and they deserve to be criticised and shamed for externalising costs over many years to millions of developers. At least Markdown has a hostile fork that gained some traction, but I can't see that happening with JSON. 
&gt; the result from the Cpanel::JSON::XS module is new in this version. It doesn't look like it was included actually: it's not listed in the matrix at the top and the section under "Cpanel::JSON::XS" is empty. The results of JSON are irrelevant because it just uses JSON::XS.
I would expect it to do better, since it received fixes specifically for these tests.
I've recently used it like this: … CFLAGS="-g -finstrument-functions" … uftrace record ./a.out ; \ uftrace dump --flame-graph | \ flamegraph &gt; uftrace.svg
Is this somehow specifically Perl related?
I don't either. I just happened to know about it ¯\\_(ツ)_/¯
I have retrieved these for you _ _ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
I've learned very early in my career that you make your life a lot easier if you make it about the journey, rather than reaching the goal. So, whenever you find out that you could have saved yourself a lot of work, ask yourself: what did you learn from doing the work, and what did you learn from finding out you didn't need to have done it.
You can plan a program out enough to know exactly what is necessary and what is supported before writing a line of code. This usually involves a bit of note taking though. When possible [and reasonable], breadth first &gt; depth first.
Yes indeed. For interesting tasks, I almost hope that there is no ready module for it, even if it would mean I would save time using it. Nowadays I mostly work with JavaEE, and it almost feels like I’m not a programmer anymore, as all I do is to piece together ready modules and frameworks in an IDE that does much of the gluing for you. A bit boring actually.
Heh, heh! It happens frequently. Sometimes I'll also write some code only to find later that I've already written it before some years previously, and had forgotten about it. (Periodically, I'll find old code and integrate it into my archive. When looking for the 'best' place to put it, I'll occasionally find a totally different program that does basically the same thing.)
The opposite happens too. You find a cpan module that seems to do exactly what you want. You fiddle and fight with it, wasting hours and then finally realize it isn't *that* hard or *that* much work to just roll your own solution.
While planning should occur prior to writing any code, requirements change over time. Sometimes as the code is being written, sometimes after the fact. The standard USED to be to implement a prototype, that can be used for experiments to help determine what is needed, but we've gone on to selling the prototype, and nowadays to selling the unimplemented concept.
I have a dear friend who spent literally years being paralyzed by these thoughts. As folks say, this is inevitable. Yes, do a search for something that already meets your needs, but don't let that consume you. Certainly, don't spend more time searching for something that it would take to write it! If the libraries you do find are under documented or are a poor match for your use case, don't feel bad about just moving on with your own implementation.
Never ever? I know that's the conventional advice, but it seems extreme to me.
I had this boss one time . . . \(They're like "Hold my beer and watch this." stories . . .\) . . . He wanted us to use the pre\-built modules to "save time" writing a bunch of reports. But after we'd have 98&amp;#37; of the project done, he'd always throw in one late requirement like, "We need an Asterisk \* between the Actual and Standard Efficiencies on the report, if the Actual is more than 2&amp;#37; off \(higher or lower\) the Standard." Invariably, the "pre\-built module" wouldn't allow that, and we'd either spend more time trying to edit/rebuild the "time saving" pre\-built module, to do that one exotic thing, or just give up and write the report line the hard way. My point is, "pre\-built" things \(of any type\) are only valuable, as long as you are willing and able to adhere to what they were pre\-designed and originally intended to do. As soon as you start to veer off the original design, you'll either pay for it in writing the exception code, or pay for it \(100 times over\) later, when the pre\-built library is updated, and it breaks all your custom edits.
If you're parsing unknown input that's HTML, you will not write a regex that works. If your input is already known, why do you need to parse it?
This is how I would get started using [Mojo::DOM](https://metacpan.org/pod/Mojo::DOM), a parser with CSS-based traversal: use Mojo::DOM; my $dom = Mojo::DOM-&gt;new($html); my $forms = $dom-&gt;find('form'); foreach my $form (@$forms) { # $form is a Mojo::DOM that stringifies to the form tag and its contents }
Thanks to everybody! I went with the regex since I figure I can fix it in post, but I need to get this done now and don't strictly need to parse anything at this point. The points about Mojo::DOM and HTML:TreeParser are well noted however, I'm going to look into them now that I have a bit of breathing room again. :) You guys saved my arse! :)
FYI, Mojo::Util has a trim function as well, and the -M commandline option has special syntax for imports: perl -MMojo::Util=trim -Mojo -E'...'
Cheers ears.
Perl isn't an acronym apparently, so the article says. It doesn't stand for Practical Extraction and Report Language then or even for Pathologically Eclectic Rubbish Lister. Apart from that, the article is a general and very basic introduction to Perl, it does that successfully but doesn't give any real world examples of what Perl might be useful for.
Happens to me all the time. I think an attempt at solving a problem on one's own is crucial to understanding the underlying logic, caveats, and limitations of a stock module that would later fit the bill. It would also save from an "all you have is a hammer" situation. That happened a lot, too - trying to adapt a module that says it does what I need, only to find out later that my code around it exceeds the size of an ad-hoc solution. Or, as some guy on some Russian forum said long ago: Add $$$ to your salary expectations if you had the wit to roll out your own framework. Add the same amount again if you had the courage to throw it away.
The article is right about Perl not being an acronym. [The FAQ says so](http://perldoc.perl.org/perlfaq1.html#What's-the-difference-between-%22perl%22-and-%22Perl%22%3f).
Ok. How about this version \- "Never use regexes to parse HTML \(unless you can explain why it's usually a terrible idea and why your case is an exception to the rule\)."
It was an acronym when I started using it, in about 1990.
Larry says it was never an acronym. It was just a word he liked \(he originally liked "Pearl", but then he discovered [PEARL](https://en.wikipedia.org/wiki/PEARL_(programming_language)) \- which **is** an acronym \- and dropped the "a"\). Both of the expansions you list above are "backronyms" \- they were made up later to fit the name \(not much later \- they're both mentioned in the Pink Camel\).
I wouldn't have said "more powerful". That just invites attacks. Articles on Perl should just show it.
The article claims Python is the reason for the decline in popularity of Perl. What bullshit. Python is almost as old as Perl. 
That doesn't mean anything. It could very well be that Python rose to fame later in it's lifetime for whatever reason, and with that rise took some of Perl's popularity. In fact, I'm pretty sure that's what actually happened.
Why are you scraping the &lt;form&gt; tags? What will you do once you have them? Are you going to do form submissions back to a web server? If so, go look at WWW::Mechanize which will take care of all that for you without having to parse anything yourself.
&gt; has anyone ever written code/program, only to find out later on that there was a module available in CPAN, which would have saved you tons of work? Sure, but then I learned to scour CPAN, too.
&gt; Perl is not a programming language by itself, but rather a group of programming languages which are interpreted and dynamic. The family includes Perl 5 and Perl 6 and development of both languages take place independent of each other. While the second sentence is correct, the first one is confusing since the rest of the article is only about Perl (5). I don't believe it's useful to talk about "the Perl family of languages" unless you're talking about the shared community and infrastructure. Also, the examples don't use strict and warnings, abuse the `$a` and `$b` special sort globals, and are invalid syntax because the quotes got converted to smart quotes in whatever editor the author used. I can't recommend that anyone read this.
I'd rather blame Node. Well, "blame" is not exactly what I'd call it...
Minor code error in array example ( `scalar @array` should be `scalar @days` ) unless demonstrating that size of an undefined array is 0. Nice intro for those who have never heard of Perl, though.
To separate the form from the rest of the page, I think.
That's about the gist of it yes. :)
No nothing that complicated, if it had been I'd have passed on the job. A friend who does web development subcontracted me to just go through a site, find all these forms, make sure they contain the right data, and send a list of URLs back. Basically sifting through all the fluff so he doesn't have to.
If you just want to dump the contents of forms from pages, you can look at WWW::Mechanize's mech-dump utility.
I'd point at PHP before Python for web stuff in the early 00s at least.
Apologies in advance for this dumb question - aren't parsers sometimes written with regexes? That would seem to blur the lines a little (to me).
Because your conditional is a syntax error. 
I'm trying to input two numbers and a symbol into the terminal, is it not possible to do the way I wrote this? 
Change, $z == * to, $z eq '*' and give it another try. "eq" is used for string comparisons; "==" is used for number comparison. "*" could potentially be seen in Perl as a special character as well, so you'll want to quote it - I chose single quotes. 
thanks!! : ) 
$z == * is not valid perl code and I have no idea what you want to do there. First of all * is not a valid Perl value and also == compares numbers, which * is neither. 
From my reading of your post, I'd guess you're going something like this at the command line: ```perl -e 'use strict; use warnings; my ($x,$y,$z) = @ARGV; ...' 2 3 *``` (Typing on mobile and I don't know Reddit markup; hopefully that posts correctly.) If so, you have several issues, but the first is the shell messing with your quoting. Try putting that Perl into a file and running the Perl interpreter against it. The compiler will complain about the syntax of your `if` statement. 
Rather harsh...I think it was meant primarily for those who have never heard of Perl, and the vast majority of Perl users use Perl5. The trouble is that nowadays, whenever I search for code I get only Python or Javascript. Perl resources are very outdated. Unless you can make the introduction make Perl *look* easy, you wont get much uptake. 
it is number 1 for students. At many universities they no longer teach c as the first language; they teach python. IMO this is because some students cant handle c. So if a young professional already knows python, there isn't much reason to change. perl is basically made for people who already know C and BASH, if they kids are not learning these two then perl is not ready for them to pick up.
From the article: *Now, to declare a variable:* $str=”My name is Akshay”; print “$str\n”; *Output: My name is Akshay* No, no, no, no, no. I understand that these are simple examples, but this is the 21st century. You must introduce use strict; use warnings; then explain that they are IMPLIED for all future examples and make sure they would run under those statements. The example should read: my $str="My name is Akshay"; print "$str\n"; with the correct quotes. That's just for starters.
I saw the explanation in the first camel book, have not seen a comment from Larry Wall saying otherwise. 
Yes, the thought was in the right place, but if this is someone's first introduction to Perl, it will be a bad one. There are much better introductions existing, which are linked to at http://perl-tutorial.org/.
https://www.reddit.com/r/perl/comments/8i4pvl/what_is_perl_how_relevant_it_is_and_how_to_get/
i suggest codefights.com , i'd been coding in perl for about a year. these little challenges made me far more nimble at my real projects. FYI there are other similar sites which can be found here https://alternativeto.net/software/codefights/
I would do a fun program, that you could progressively extend. The first significant program I wrote in Perl was one that drew pictures on a console window by printing "*"s and spaces. It started off by plotting "*" in a grid of spaces, give row and column parameters. Then I extended the plot function into a drawline function, then circles etc, eventually creating a Logo-like script interpreter....effectively creating your own programming language. 
Cool, thank you for the links. I really have to delve into Mojolicious now. I guess my objection is that whenever someone asks the classic question, I feel there's a swift round of scolding (not you, but it does happen). :)
It's a fair criticism. I try to give reasons behind my rebukes, but after the 100th time of giving the same advice it can feel tedious and it's easy to forget that a newbie doesn't know why the advice is relevant to their situation.
It's a web browser in an object that saves you from having to deal with forms manually. https://metacpan.org/pod/WWW::Mechanize use WWW::Mechanize (); my $mech = WWW::Mechanize-&gt;new(); $mech-&gt;get( $url ); $mech-&gt;follow_link( n =&gt; 3 ); $mech-&gt;follow_link( text_regex =&gt; qr/download this/i ); $mech-&gt;follow_link( url =&gt; 'http://host.com/index.html' ); $mech-&gt;submit_form( form_number =&gt; 3, fields =&gt; { username =&gt; 'mungo', password =&gt; 'lost-and-alone', } ); See also https://metacpan.org/pod/distribution/WWW-Mechanize/lib/WWW/Mechanize/Examples.pod
Automate All The Things!
I saw this list on Medium earlier. Might be useful. [The secret to being a top developer is building things! Here’s a list of fun apps to build!](https://medium.freecodecamp.org/the-secret-to-being-a-top-developer-is-building-things-heres-a-list-of-fun-apps-to-build-aac61ac0736c)
http://perldoc.perl.org/perlcheat.html is a handy reference while you are coding. As far as a project, what kind of things do you do every day on a computer that would work nicely if automated? And if your computer is a WindowsPC, fear not: http://strawberryperl.com https://www.cygwin.com https://www.bing.com/search?q=windows+linux+subsystem&amp;FORM=R5FD4 
That's /very/ cool! I've been idly looking for something along these lines for a while now.
I love Perl and always will, but I must admit that these things are more elegant in Lisp.
hopefully someone will fix the code where it says `apply($first-&amp;gt;($val)`
Well maybe just [write it in "Lisp" -- in "Perl"](https://www.youtube.com/watch?v=Nq2HkAYbG5o&amp;t=0s&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK#t=25m30s). (J/K)
Hehe, wow!
A plugin written in C to display the gtk widget waits for the script to return data to it via STDOUT. If I had the script stay running, the widget would never update.
I did not know it has this capability. Honestly just started using it, this sounds perfect for what I'm doing. Thanks 
it's just a formatting error, should be: $first-&gt;($val) Same problem exists in a few other spots too.
I'd be interested in a P6 translation.
That is no longer used in the latest version of Reddit::Client. You have referenced how sessions were handled before OAUTH was introduced. I believe it's all handled internally now.
Thanks a lot folks. Much appreciated :)
It's an hour long tour de force isn't it? I've heard that TheDamian has always done great presentations but I've only gotten to see some in recent years via online videos. Imo the one I just linked from 2016 and ["Three Little Words" from 2017](https://www.youtube.com/watch?v=ob6YHpcXmTg&amp;list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK&amp;index=27&amp;t=0s) are both masterpieces. Among the wonderfully varied styles used by Perl presenters I particularly love Larry's fearlessly authentic and predictably unpredictable infinite-layers-of-meaning style and jnthn's genial genius for wielding occam's razor in all things including his presentations. But imo TheDamian really is in a class of his own as a presenter. PS. If you generally like video presentations as a way of absorbing info and are interested in P6, [the Perl 6 (English) videos collection](https://www.youtube.com/playlist?list=PLRuESFRW2Fa77XObvk7-BYVFwobZHdXdK&amp;disable_polymer=true) has 180 that are at least watchable including the two I just linked above (the collection includes a few that are arguably only tangentially about Perl 6 such as "Three Little Words").
The [3rd edition](https://docstore.mik.ua/orelly/perl3/lperl/ch01_02.htm#FOOTNOTE-11) of the llama book also claims it's a retronym.
&gt; use strict; &gt; &gt; use warnings; &gt; *use feature 'say';* &gt; say 'no'; 
The collection contains `Mojo::DOM` objects, each representing one found `ns2:msisdn`. You can [`map`](https://metacpan.org/pod/Mojo::Collection#map) over the collection and get the `-&gt;text` from each of the found `Mojo::DOM` object. say for @{ $dom-&gt;find( 'ns2:msisdn' )-&gt;map('text') };
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://metacpan.org/pod/Mojo::Collection#map) - Previous text "map" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Thank you, robot. Have a botsnack: 🍪
Whose DNA?
The bible was written, transliterated, and altered by people. As far as I know no branch of the christian church has ever claimed it was written by g.d himself. This is just bible codes, tea leaves, and cloud shapes again.
I've heard evangelicals claim it is. They don't deny that humans wrote it down, but they insist on it being the infallible word of God, and that it is somehow immune to human meddling. 
You're not remembering what's in the Camel book, it always said exactly what people said above.
For those not on Perl 5.24+, that last statement would be written like: say $_-&gt;text for @{$dom-&gt;find('ns2:msisdn')};
thatsthejoke.jog
Did you just censor yourself from typing "god"? Is that like typing "f*ck" because swears are naughty? 
It's a little deeper than that. In Judaism, the direct name of God is not to be invoked, lest one invoke it in vain (even accidentally). There is also some stuff about not being worthy of the name, so [other handles get invoked](http://www.abarim-publications.com/Meaning/Adonai.html). It's like Paul Atreides becoming Usul (the plinth, the base of the pillar) among the Fremen but Muad'Dib (the face of the second moon) as the public name. The weirding modules find great power in his public name, so there is some inversion.
As a christian let me tell you this is utterly bullshit. No one in their right minds would ever claim that.
Thanks for that, I had no idea.
There are, in my experience, many Christians who are not in their right mind :\-\)
Everyone knows the bible was written by Alexander Dumas.
Thank you!
I grew up going to Catholic school and had never heard of such a thing either. But then I ended up becoming close to a few evangelicals and they swear by the Bible being the infallible, direct word of God. To each their own though. They're very nice people so I'm more inclined to listen carefully and try to understand where they're coming from. It doesn't feel right to immediately reject their beliefs. I mean, what do I know?
/r/perl is not the place for discussions of religions, especially discussions that turn into attacks on religion.
That's only because you aren't familiar with Perl 6.
If Perl 5 and Haskell had a child...
I think you would want specifically a selector like 'ns2|msisdn' that will use the alias passed in. See https://metacpan.org/pod/Mojo::DOM::CSS#A|E It also looks like 'ns2\:msisdn' would work, given some examples scattered through the Mojo::DOM docs; but the namespace alias is probably more "correct".
Just in case the other set of XML isn't using it, note that the XML declaration (`&lt;?xml...&gt;`) is causing Mojo::DOM to switch to XML semantics when parsing; to force this mode unconditionally, construct the object like this: my $dom = Mojo::DOM-&gt;new-&gt;xml(1)-&gt;parse($data);
I had discovered this in my previous tail-chasing, yes. Thank you for mentioning it. Now that I've removed the namespace references, my little test program is working fine. Now I need to take that logic and apply it to my real program that works with real data.
Okay, that's something I didn't see earlier. In my defense, I didn't think CSS had much to do with XML. :\) I think that ns2\\:msisdn is actually the better solution, as I think I've seen some API documentation from some companies that might use something like 'ns2:id' and 'ns3:id'.
Thanks, everyone. I now have 'collection' arrays that have information about each wireless widget. My next question: I'm trying to find only the widgets that have a status of Active. I'm currently iterating over the collection like so: for my $wireless ($dom-&gt;find( 'wireless' )-&gt;each ) { say $1 if $wireless =~ /&lt;ns2:status&gt;Active&lt;\/ns2:status&gt;/ &amp;&amp; $wireless =~ /&lt;ns2:msisdn&gt;(\d{10})&lt;\/ns2:msisdn&gt;/; # do cool stuff here } Surely there's a better way to do this?
Great overview and explanation of why it's necessary. This was done in [Perl 5.18](https://metacpan.org/pod/perl5180delta#Hash-randomization) as well.
Use C, perl is for pussies
You could write a program that submits your binary to the form on those online converters and then scrape the answer from the HTML. (Mostly joking... But it would work)
First you need to turn that bitstring into the bytes that represent the float: my $packed = pack 'B32', '01000011011011111011111111000100'; # or from the integers you started with, which are 16-bit: my $packed = pack 'nn', 17263, 49092; Then you need to extract the float represented by those bytes. Since you know it's an IEEE-754 single precision float, this seems to work: my $float = unpack 'f&gt;', $packed; See https://metacpan.org/pod/perlfunc#pack - it's very difficult to keep straight and I still mostly just stumble through it until it works, but it's exactly what you need for these sorts of operations.
The horror...
That was exactly what I was looking for, thank you very much. 
my @bytes = ( 0xC2, 0xED, 0x40, 0x00 ); my $float = unpack 'f', pack 'C4', @bytes; Or if the source and destination have Different endianness. $float = unpack 'f', pack 'C4', reverse @bytes; On my phone so not tested and a guess based on IEEE-754 numbers.
Hey, TMTOWTDI...
What!? Oh, they're working on metacpan.org to replace. Looks like somebody's headed to a well-deserved retirement.
Not for the uninformed.
Goodbye, and thanks for all the fish. I truly spent uncountable hours on that site back in the days before metacpan.
You can make any interface suggestions to https://github.com/metacpan/metacpan-web. Metacpan is open source and maintained by the Perl community!
[This blog post from 2013](https://perlhacks.com/2013/01/give-me-metacpan/) has some suggestions for how to redirect any CPAN links you click to MetaCPAN \(so you can get the full experience before the site implements the redirects itself\).
Most SCO pages now have a link to the metacpan equivalent in the upper right as well now.
Sure. But the solution in my blog post doesn't even hit the SCO site.
The redirects should soon fix that.
It's not just Perl. Python 2.7 documentation shows up first, Java 7 shows up first...
And I left a comment on that entry talking about a GreaseMonkey script I wrote to let me keep using the s.c.o search while viewing results on MetaCPAN – because while MetaCPAN *looks* better, and has much better URLs, it also *works* worse. Switching from s.c.o to MetaCPAN felt like switching from Google to Bing – half the time I couldn’t find what I was looking for on MetaCPAN. I liked looking *at* things on MetaCPAN more than I liked looking at them on s.c.o, but only after I had first looking *for* them on s.c.o. It’s now 5 years later. The situation is exactly the same: MetaCPAN looks better, s.c.o works better. Will that ever change? Other than by simply doing away with the better-working site. Will MetaCPAN’s ranking ever close ranks with the level s.c.o’s ranking had 15 years ago? So we’re losing CPAN’s Google and are left with its Bing. \o/ I’m so excited!
You are welcome to suggest changes and send PRs. https://github.com/metacpan/metacpan-api is where the searching and ranking implementation lives.
I accidentally introduced a new bug: https://github.com/ingydotnet/yaml-pm/issues/208 Fixed in 1.25_002
Bugs I’m sure will be processed reasonably. But I’m not talking about concrete bugs like the “attributes a package to the wrong distribution” example ticket you linked. I’m talking about “when I throw keywords at it without already knowing what module I’m looking for, s.c.o finds me useful modules more likely than MetaCPAN” – which I don’t know what to tell them to do to replicate. So now I’m about to have to just live without it.
All I can suggest is (before it goes away) to keep track of when cpansearch finds or ranks better results than metacpan does, record what you searched for, what you got from metacpan, and what results would have been more helpful, and report that dataset as something that can be improved; this way your preferences can be made into more concrete suggestions which may lead to correlations and ways to improve it in general.
What does this mean for people that install modules via cpanm? 
You mean like the [bug I filed in 2013?](https://github.com/metacpan/metacpan-web/issues/984) And its compatriots filed by other people: * [Missing pause packages](https://github.com/metacpan/metacpan-web/issues/757) * [Author page should show dev releases](https://github.com/metacpan/metacpan-web/issues/496) * [ \[Feature request\] Make devel releases (more) visible ](https://github.com/metacpan/metacpan-web/issues/229) Which was apparently going to be fixed as a result of [this bug filed in 2014?](https://github.com/metacpan/metacpan-api/issues/366) Yeah. Cool. 4 years. Soon. For an entire class of package, the easiest way to find it is still to search `search.cpan.org` first and then work out where that would be on metacpan. Its not even a case of "make the order of results more clevererer", its a case of "how about those items actually be in the results at all when an obvious query maps directly to the result" 
So where's your PR?
I can't find it, but there have been conversations about this sort of thing in the past. The problem was nobody agreed on *how* it should be implemented, because some people *insisted* that metacpan *shouldnt* find these things by default. And then we get stuck in the bikeshed of how we're going to tweak the user interface to either opt-in/opt-out on a search-by-search basis (irritating) or add more metadata to the user preferences (which is something metacpan want to avoid) Filing a PR without resolving either of those issues is impossible. And the point remains that search.cpan.org is better for many tasks, and that nobody has made metacpan really compete in that regard. But at least now I've been able to cite a concrete example of "And here's the way in which metacpan repeatedly and predictably and clearly fails at search" which has a concrete and definite achievable fix. ( Unlike the google-vs-bing comparison, where the solution might involve statistical woo )
You should probably have these conversations in a ticket where something can actually be done about it. Moaning about an issue I already linked is not a constructive discussion.
Maybe you are not allowed to run a sub process from the other box? Maybe there are some shell env settings that mess with your system() call. The path, perl5lib etc isn't set correctly? What happens when you test it with a Dockerfile locally? https://hub.docker.com/r/library/perl/tags/has 5.8.9 threaded so you could see if that is the problem or not.
Maybe try providing a bunch of examples of that while s.c.o is still there so people can try and guess how it found them? Like, I am aware many people find the s.c.o search better but if we can't get graham to describe it or release the code then concrete examples are going to be necessary to try and improve stuff.
Thanks for the suggestions, I appreciate it. I took a sideways step instead: [commit](https://github.com/dnmfarrell/Test2-Tools-SkipUntil/commit/b9124971694f4c8b04a7542603f2bc8942a9a43b).
A better solution imo :)
According to http://tldp.org/LDP/abs/html/exitcodes.html#EXITCODESREF 2 can mean a syntax error or a permissions problem, but of course it could be anything else. Taking a look at [the test file](https://metacpan.org/source/DFARRELL/Test2-Tools-SkipUntil-0.03_2/t/03-skip_all_until.t) I confirmed that 2 is the error code resulting from Perl failing to load a module. This is probably because you are using `system $^X` to execute a new perl interpreter which does not maintain the current interpreter's `@INC`. You could try a trick more like https://github.com/Grinnz/Unix-Groups-FFI/blob/master/xt/author/sudo.t#L11-L14 (but note I usually only do this in author tests, because it can fail if there are too many or too long directories in @INC)
I would do some research on scope in perl. What you want can be solved as you mentioned by moving the %crystal hash outside the scope of the subroutine and then it will be available to there method. Alternatively. You could use a return statement in your subroutine to return the %crystal hash. 
Yes, anything within the parentheses after the subroutine name is passed as arguments. These are accessible within the subroutine from the special `@_` array. Note that passing a hash directly like you did will *flatten* it, which means the subroutine will not receive the hash but a list of keys and values (which you can assign to another hash); this also is what happens when you return a hash. If you want to retain the hash structure, you want to pass and return it as a [reference](http://mvp.kablamo.org/basics/references/), but both passing as a reference and as a list of the contents will work. There are lots of tutorials on http://perl-tutorial.org/ that have good info on this like [MVP](http://mvp.kablamo.org/basics/functions/) but here's the basics: sub get_hash { my %foo = ...; return \%foo; # or return %foo to return it as a list } sub pass_hash { my ($hashref) = @_; # or my %hash = @_; if passed in as a list } # if passing as ref my $ref = get_hash; pass_hash($ref); # if passing as list my %hash = get_hash; pass_hash(%hash);
Either you have typos in what you posted or you don't understand the fundamentals of perl's subroutines. I suggest you Google perlsub. This should take you to perl subroutine documentation. If that doesn't answer your question, please late a short, but representative example of of your code showing what you think should work. This code should read from to to bottom so that we can test, modify and return to you. Hth, lbe
Thanks, that explains the @_ - I knew what it was doing and what it could be used but not the specifics as you posted. ~~I understand your code snip, but unable to process the logic behind it If I was to use by reference method as it's simpler data to use.~~ I'm still confused by the last two lines. espcially pass_hash~~ -- nevermind. I get it now. #### working code sub crystalSend {; my %life_crystal = ( animal =&gt; { 'life' =&gt; "0", 'animal' =&gt; "/fox", 'name' =&gt; "/paw", 'owner' =&gt; "Yaroze"}, ); return \%life_crystal; }; my $life_crystal = crystalSend; crystalRecv($ref); sub crystalTransmit {; my $ref = crystalSend; crystalRecv($ref); }; sub crystalRecv {; my ($hashref) = @_; my $value = $hashref; print "Value: $value\n"; print Dumper(\$hashref); }; #### Thank you, this makes me happy. 
&gt; If the decision has been made to kill it off, no matter what, then there’s not much I can do than just resign myself to a more frustrating experience with CPAN from now on. That's my understanding of the situation. I do understand your frustration as well. We've worked very hard on MetaCPAN, but it's a beast. This is partly because the problem it tries to solve is also a beast, historical reasons, etc. I'm happy to hear an honest assessment of what you think is terrible and what isn't. Nobody is going to tell you that MetaCPAN always gets it right and some of these things are complex enough that some kind of major architectural change is needed in order to fix them. At the end of the day, I think the issue is limited human resources. Part of me is also sad to see search.cpan.org disappear, mostly because that alternative is now no longer available. Even if you preferred one site over the other, you had options. You won't have that now.
For learning resources check out the tutorial site from the sidebar: http://perl-tutorial.org/ as well as https://learn.perl.org and https://books.perl.org depending what you're looking for.
Please re-read what I said. We did. There were tickets. But I just can't find them just now. Disregarding things that actually happened and actual arguments as "moaning" is pretty much an attempt to goad. If people insist we should use A instead of B, it is the people who insist A is better who's duty it is to make it so. Telling us A is better then demanding we submit patches when we retort "A is not better, please don't kill B" is pretty much "blame the victim" mentality.
This discussion is not about which is better. The old site is going away. The only thing we can do is improve the new one. I don't care to bemoan whatever axe you have to grind otherwise.
There are people who have [offered their services](https://www.reddit.com/r/perl/comments/8k1tk0/the_end_of_an_era_saying_goodbye_to_searchcpanorg/dz5na3g/) to keep the existing site running. That its not even a conversation, just an "its going away" is a real issue here. Why is it going away? Surely, if people are able to look after it, then it should stay. Unless, there are other arguments for killing it besides the costs of keeping it operating. Pray tell, what are these arguments?
&gt; The old site is going away. But why? There appear to be two reasons. Reason 1 is the effort required to keep it operational. That could be fixed by asking someone else to step forward. I’d be willing and I’ve been told I’d have all the backup manpower I’d need. Reason 2 are people who are irritated that MetaCPAN hasn’t been able to displace s.c.o. For them, reason 1 represents an opportunity to get s.c.o killed off. “Patches welcome for what you don’t like on MetaCPAN” doesn’t really address “I want s.c.o sticking around”.
Personally I’m puzzled by the lack of MetaCPAN Google juice. Sure, there’s all the old links to s.c.o boosting its ranking. If it was 2013, I could buy that that puts a ceiling on MetaCPAN’s SEO. But when I search for Perl stuff on Google, MetaCPAN is often not just second or third place, it’s not even on the map. At all. I don’t think that can possibly be because of s.c.o. I mean heck, when GitHub renders POD, module links go to MetaCPAN. That should be a hell of a lot of Google juice right there. And yet somehow it’s not doing much for MetaCPAN. Given the facts of the situation I cannot buy that the reason is something other than MetaCPAN itself. I have no idea why that would be the case. I have no reason to believe it is unfixable, but I don’t know how. However, I therefore cannot believe that killing s.c.o will improve whatever MetaCPAN’s SEO problem is. So if we try to 301 s.c.o to MetaCPAN, even if this does boost it, the problem won’t be gone, so the Google juice won’t transfer 1:1. The bottom line I expect is that Perl module related Google search results will thus tank quite a bit as a whole. Let’s just say that I’m already pessimistic about the relevance of Perl&amp;#160;5 given what I’ve been seeing in the job market lately, so imagining this outcome makes me a little queasy. If we *are* going to kill off s.c.o, can we postpone that until after someone figures out why MetaCPAN continues to rank so poorly? (Do we have any in with anyone in even the vicinity of the Google search team who could maybe tell us why for real?)
Upthread your paraphrase was more polite. 😊
Multiple people complaining at me about something I already said I don't care about is frustrating. This is the best I could do.
Yes I have. I’m procrastinating on mailing him because we’ve never intersected in any form, not even online, and so I assume he’ll have no idea who the yahoo mailing him out of the blue to ask for the code would be… but yes I’m gearing up to it. (I’m also curious to hear firsthand what made him never open the code… because all of the thirdhand reports about his attitude puzzle me a bit.)
That’s the obvious route, yes. Problem is I haven’t been consciously actively comparing the sites much. Most of the time I just search on s.c.o using my GreaseMonkey script that links results out to MetaCPAN. So now I have a deadline for sitting down and trying to contrive some scenarios of looking for something, in order to generate data. I’m gonna have to do that if that’s the only course of action left, of course. It’s just… not ideal.
I suspect it's at least partly down to age. SCO has been around about as long as Google and for most of that time, it's been the definitive source for information about Perl modules. It's hard to displace that authority. But that will change when it closes down. When SCO starts to 301 to MetaCPAN, then most of its Googlejuice will be transferred to MetaCPAN and MetaCPAN will see a large improvement in its Google rankings. I'm pretty sure it'll be fine. But it would be interesting to track that. I'll look into setting something up.
But I’m not puzzled why it’s not ranked first. I’m puzzled why it’s often not even on the map. Surely it has to have *some* Google juice of its own? GitHub and basically every Perl article/blogpost in the last couple years points at it. How come it seems to be *invisible* to Google?
Probably because it looks to similar to SCO. Google thinks it's duplicate content.
Do we know that? Can we get answers on it from some search person at Google?
&gt; I'm happy to hear an honest assessment of what you think is terrible and what isn't. I’d be happy to give one! This is [hard to tackle](/r/perl/comments/8k1tk0/-/dz87nad), from both sides. (I appreciate that it’s not exactly obvious how to fulfil “can you make search results better plz”.) &gt; At the end of the day, I think the issue is limited human resources. Yes, I understand that this was also the issue with the MetaCPAN’s team handling of suggestions that I referred to.
I used to use Perl to process the output of Unix commands, for instance, before top was available, I wrote a script that ran ps -ef and displayed the top twenty processes, then top came along and I turned the output of iostat into a histogram style graph showing disk activity - updating once a second. Run the command "on the end of a pipe", read each line of output and do something with it. Disclaime: Code may be completely untested. Possibly. while(){ open(PS, "ps -ef|"); while(&lt;PS&gt;){ if(/line is interesting/){ fiddle_with_it; print; } } close PS; sleep 1; }
*sigh* how do you format code in here again?
Well, it's SEO \- so, no, we don't know much at all. We do know that the content on the two web sites is very similar. And we do know that Google penalises sites that it thinks are duplicating another site's content. So we can make assumptions.
Please don't use global filehandles :)
Impolite isn't the right word here, yeah. He is not interested in a conversation, or even a compromise and only interested in beating you over the head so you go away. While i can't do much about the sco situation, i can and will slap wrists of people of whom i can expect better.
I've said this a few times on here. there are websites made exactly for this. https://alternativeto.net/software/codefights/ . i use codefights.com (FYI i dont work for them) , i'd been coding in perl for about a year or so. these little challenges made me far more nimble at my real projects. As for scripts, if you using *nix, i recommend getting comfortable for Bash too.
Like this... I took some liberties with your code. use strict; use warnings; while(1) { open my $ps_stdout, '-|', 'ps -ef'); while (my $process = &lt;$ps_stdout&gt;) { if ($process =~ /line is interesting/) { print fiddle_with_it($process); } } close $ps_stdout; sleep 1; } But I would just do in the shell: `watch -n 1 'ps -ef | grep "line is interesting"'`
Nicely done. It's not Perl though...
Ah I didn't know that, thanks!
It sucks. I tried to get Graham to give me the full algorithm. I failed. Somebody should probably try again. The deadline, ftr, wasn't the metacpan side's idea. Maybe rather than trying to contrive, you could tweak your script to record the search terms somewhere? Or even to show both sets of results or something. I'd *love* to have data to try and do this stuff better from assuming we can't just get the algo.
You are my hero! Beside the module author of course...
I'm not sure exactly if this is what you're looking for, but [Mojolicious](https://mojolicious.org) can be deployed as a persistent daemon process that can serve requests asynchronously with the help of its built in event loop and promises.
I would not recommend relying on Coro. It's a single-interpreter threading model with questionable stability and has [broken before](http://blogs.perl.org/users/aristotle/2016/05/coro-vs-5022.html) due to its usage of undocumented Perl internals, leading the often uncooperative author to [fork Perl](http://blog.schmorp.de/2015-06-06-a-stable-perl.html).
I use Java to pay my mortgage. But of all of the languages I've toyed with in my spare time, my two favorites are Lisp (and Lisp dialects like Scheme, Racket, and Clojure) and Perl 6. Which keeps striking me as odd, because the two seem to be syntactically opposite. Lisp-family: keep syntax as bare as possible but in a way that supports the user working magic with and on the code. Perl 6: build in all of the magic a user could possibly want.
I think a good instructor can start any novice student on any programming language, but in my experience most introductory CS teachers and teaching materials aren't that good. So it's less "Billy and Jane can't handle C" and more "Billy and Jane's instructor couldn't teach C to Dennis Ritchie, so he's just confusing them." I've been writing code professionally for over fifteen years and I love it, but I was completely confused for my first three computer science classes in college. I answered all of the theory questions properly but got most of the code example questions wrong, and had to get more experienced students to help me with almost all of the programming assignments. 
Some slight misunderstanding of what's happening here. [search.cpan.org](https://search.cpan.org) is closing down. It's not moving anywhere. There will be redirections to the appropriate pages on [metacpan.org](https://metacpan.org/). I doubt that [search.mcpan.org](https://search.mcpan.org) will be involved at all.
Yeah, you can't ever get answers from Google on that stuff, so we can't *know*. But looking like duplicate content was my first guess as to why it wouldn't show up at all.
Things of note: 1. [In-place editing is now safer](https://metacpan.org/pod/release/XSAWYERX/perl-5.28.0-RC1/pod/perldelta.pod#In-place-editing-is-now-safer) 2. [Sort algorithm can no longer be specified](https://metacpan.org/pod/release/XSAWYERX/perl-5.28.0-RC1/pod/perldelta.pod#Sort-algorithm-can-no-longer-be-specified) 3. [Performance enhancements](https://metacpan.org/pod/release/XSAWYERX/perl-5.28.0-RC1/pod/perldelta.pod#Performance-Enhancements) 4. Lots of [updated modules](https://metacpan.org/pod/release/XSAWYERX/perl-5.28.0-RC1/pod/perldelta.pod#Updated-Modules-and-Pragmata) Mostly behind the scenes stuff. About what you'd expect from a mature language like Perl.
Enabling diagnostics will give you a more verbose message. 
Just curious, as I don't use metacpan much. Why didn't that just become search.cpan? 
Metacpan URLs have a different format so it would break all existing links. Redirects will hopefully allow google to index the content properly and bookmarks to continue working.
&gt; If a script attempts to use a module that you don't have installed you get a pretty cryptic error message No you don't, and throwing around words like that is insulting.
It says right there, in the original error message: &gt; you may need to install the Foo::Bar module What's cryptic about that?
Those age group numbers are quite striking, fewer than 15&amp;#37; under 30. It would be interesting to see solid number of other languages, but this seems massively skewed an older crowd.
&gt; Here we have a slight change from 2017 that does not bode well for Perl 6 [...] The yes option dropped 9% from last year An odd conclusion. The available data only tells 9 percentage points of people who completed this survey haven't tried Perl 6 yet. You can't infer how well that bodes for Perl 6. Especially since when the survey was shared, multiple people said it was a Perl survey and not Perl 6 survey, thus discouraging Perl 6 programmers from participating in it. The survey question is flawed as well. Both a person who says "Perl 6 looks amazing, but I haven't had the time to try it" and one who says "I fucking hate Perl 6, I never tried it and I hope it dies" can only choose "No" as a valid response, yet they represent diametrically opposed viewpoints on Perl 6. The same is true for the "Yes" option: both a person who tried it out for an hour, got disappointed, and will never touch it again, and one who makes a living programming in Perl 6 are combined in this answer, giving a very flawed gauge for the interest in the language. It would be nice to have those combined data separated with more response options for this question in future years. As for the survey itself, it'd be nice if it were clearer on whether it's collecting data on Perl 5 and Perl 6 programmers or just on Perl 5. It starts off by referring to "Perl 5" in the first question and "Perl" in the next, suggesting it covers both languages, yet later questions (e.g. frameworks) only include Perl 5's frameworks.
I wonder who came up with the icon for this blog post. It's probably projection on my part, but I feels to me that the red part signifies a crossed out butterfly. Leaving the interpretation of the symbolism of that as an exercise to the reader.
That error message is as clear as the blue sky. Plus do not suggest running `cpan`. It may not be installed on the system. On the other hand, what is a bit cryptic is this error message: Can't locate object method "method" via package "0" (perhaps you forgot to load "0"?) at ./err line 5. And the code emitting it: #!/usr/bin/perl use strict; use warnings; sub should_return_object { 0 }; should_return_object()-&gt;method(); 
A more charitable view is that much like the survey contents, the icon did not really concern Perl 6 at all.
This is an unfortunate side effect of the fact that methods can be called on class names rather than just objects, and class names can be a large variety of strings ('0' is a valid class name, though using it for real would probably break lots of things).
Exactly. But see my EDIT. Without the *perhaps* clause, the error message would be less misleading.
Looks more like a ✔/✘ icon, with ✔ stylized as a camel.
A P6 user may be inclined to think using "Perl 5" followed by "Perl" in the same document may allow "Perl" to imply "Perl 6", but I'm sure that's a P6-Only thing. Perl 5 people are probably more likely to have simply concluded that "Perl 5" was used early on, followed by using "Perl" everywhere else simply out of simplicity, because for them, "Perl == Perl 5" ( I really really don't want to mentally hear 'perl 5' every single time I talk about the commonly used language known otherwise as perl ) However, that conclusion I make does basically agree that yes, it is too vague to draw reliable conclusions without making hard-to-prove retroactive inferences.
In my experience in teaching live, in-person Perl classes, this error message shows up as a wall of text to people. It's also a common question in places like StackOverflow. It's not that it's incorrect or uninformative. It's first seen as a big hunk. It doesn't matter if we think that people should just read it because they tend to not do that. Our opinion doesn't matter there when that's the actual observed behavior. Some simple formatting can break down that wall of text and drive behavior the way that we want it. 
Which word? "pretty"? =) I think there's a good argument for qualifying this message as "cryptic", just look at the number of concepts involved: - `Can't locate Foo/Bar.pm` - modules are typically loaded via `use Foo::Bar`, the mapping from Foo::Bar to pathname may not be immediately obvious to a beginner - `in @INC` - again, this user may not even have learned about arrays vs. scalars, let alone memorised the contents of `perlvar` - `(you may need to install the Foo::Bar module)` - as I think the main point of this post describes, "install X" is inevitably going to prompt the hapless user to ask *how* to achieve this task! - `(@INC contains: many things` - I'd be thinking "wow, that's a lot of words, is it a good thing that `@INC` includes those or have I messed up something?" - `BEGIN failed` wait what - `compilation aborted` hang on this isn't C what is this Probably a few more I missed as well. User expectation: "you need to install XYZ, run this command to fix" Perl expectation: so of course you'll need to know about @INC, BEGIN blocks, that `use` is actually compiling to `require` behind the scenes, and you should have a favourite CPAN module installer, and of course you know that CPAN is the Perl module repository, except we call them distributions there, and you might need to set things up, don't run `cpan` as root, maybe install `local::lib`, sometimes the tests will fail unless you're lucky... and if you think this is cryptic we'll take it as an insult! Actual problem: might just have been a typo in the module name.
List of DWHEELER's current perms: https://cpanmeta.grinnz.com/perms#dwheeler~
Thanks for your feedback. I too would like to see folk continuing to raise issues like these. I personally automatically mentally substitute as you suggest. I had no problem with the OP and agree with its sentiment and upvoted it as soon as I'd read it despite having the sense it was worded unnecessarily provocatively. Indeed, I appreciated briandfoy's much sharper commentary and upvoted that too. \-\-\- When I read the OP's title, before I clicked on it, I immediately simultaneously thought "I agree" and "Uhoh". The body of the post led to much the same experience. The wording was such that it was obvious \(to me\) that it might not go down well and when I looked, sure enough, there was no clear support but rather two negative responses and one that wasn't affirmative. My own perspective on what goes on in instances like this is pretty much the same as [Tim Bunce's](https://www.youtube.com/watch?v=Y24QnadqqJ4&amp;t=210s). Imo, using the word "should" in the manner used in the OP's title is a mistake. It's a trigger word for a large percentage of the English speaking population, along with "never", "always", "no", and a handful of others. You'll always raise hackles unnecessarily if you ever simplistically assert something should this ir that \-\- even if it should. So a better approach is do something like watch Tim's talk and use its wisdom to pick a different approach. Imho.
&gt; Oh but I would be remiss not to commend the politeness of your “go fuck yourself”. I didn't read it like that at all, but rather more like "please send us specific examples of where s.c.o. performs better, and we will try to fix the search engine to compensate". It's hard to fix problems one doesn't know about, and more samples is always better.
Amen 
The message is for programmers, not users. If a *user* sees this message, then someone (an app developer or packager) has seriously screwed up. The user shouldn't be encouraged to run cpan, they should bother whoever supplied them this defective piece of software. If a *programmer* sees it and doesn't know what an array is, then they need their computer taken away and put under lock and key until they learn; they certainly shouldn't be encouraged to copy-paste command lines and run them blindly. At best it will screw up their system in annoying ways, and at worst it will actually *work*, allowing them to do further damage.
Aw :( Best of luck, though!
Try double percent encoding the file name?
There is no need for the URL filename to be readable at all, right? $ perl -MDigest -E 'my $url = "https://foo.bar/bang"; say Digest-&gt;new("MD5")-&gt;add($url)-&gt;hexdigest;' 3e34ffeda47954672af034f7013d9a9f A simple hash like that would do the trick.
&gt; compilation aborted hang on this isn't C what is this It's something called Perl. Which is a compiled language. Are you suggesting pretending that it's not, so that people don't suffer the unease of *becoming less ignorant*?
&gt;After some testing, I found that the problem is the percent sign. It's a legal filename character on Linux, but for some reason, $mech-&gt;get_local() chokes on it. Just a guess: I think this is not considered as a filename, but as an *url-encoded* filename, so Mechanize will unencode it first. Try to encode it once more, for example with s/%/%25/g 
&gt; Also, this is supposed to be a "quick and dirty" hobbyist project. I'm not after creating a framework. I'm trying to get something functional in the shortest amount of time / least amount of effort. If it were me, I'd set up a webserver serving the files on http://localhost, and so not need to work around get_local - the idea is to get something together that'll download over HTTP, and it's quite easy to just have your own thing serving HTTP.
That text is taken from perldiag. It is intended for new users, but I agree it's not doing a very good job at that. Some modernization (why mention "do" first?) and better instruction would certainly be good improvements. Patches welcome, I guess.
For what it's worth, we've pretty much come to a conclusion on how we want it to work to show dev releases. We want dists that have dev releases but no stable releases to show up in the search and author pages. The problem at this point is getting it implemented. It involves adding an additional flag for releases like this, and updates to our indexing process to populate it. At that point adding them to results is pretty straightforward.
Yes, one need a different mindset, and I am really struggling to wrap my head around it.
Did you pick up a book? I got this one for like 3-4 dollars used on Amazon, and it has a lot of material in it. Sams Teach Yourself Perl in 24 Hours (3rd Edition)
Yes, I have had this experience. I would recommend that you get the book "Programming Perl", and work your way through it. That's what I did as an intermediate, 16 year old BASIC programmer.
I have the Lama book: Learning Perl and I hate it. The book takes too much time to get to the point. Halfway each chapter I just give up.
Why do you recommend this particular book? And not, for example, Learning Perl or Intermediate Perl? 
This is also the book that I used to learn Perl back in the 90s. I love how concise and too the point it is.
Those links are really helpful. Thank you.
I have taken a look at the Modern Perl book and I like what I read. Compared to Programming Perl it is more complete. That is my opinion of course.
One thing that might help is to spend some time on the perlmonks site and see the answers proposed by others. That will expose you to aspects of the language you've overlooked.
&gt; Modern Perl book http://onyxneon.com/books/modern_perl/modern_perl_a4.pdf
What does this print: my $pwd = $ENV{PWD}; print "PWD is '$pwd'\n"; $o{certificate} ||= $pwd . 'some_path_to_a_cert';
What shell is invoking the Perl script? It might be one that doesn't export `PWD` into the environment.
$pwd is empty on the print.
bash
Yeah, so don't rely on the shell setting that in your environment. If you use the Perl way, it's portable - even to Windows! use Cwd; my $pwd = getcwd;
I also found the real power of vim was by "regressing" to use more fundamental commands like the ex commands, or going back even further and trying out ed for a serious task. It really reinforces the foundations of the editor. I eschew all plugins and have no vimrc.
Perl can be somewhat opaque at times. However it is also a very powerful language. I wish that I could offer updated book recommendations, but it's been at least a decade since I bought a Perl book and any recommendations I would have are about as old. However, Randall Shwartz's Objects and References book was a great addition to my library. It filled a gap that existed between Intermediate Perl and Advanced Perl. Perl Best Practices was both good and controversial when it came out, but a lot of the details has become dated even as reasoning behind it is still solid. To get into some of the more powerful features of Perl, Higher Order Perl is great. Passing functions as arguments to functions is a something that can take work to wrap your head around, but it's been a part of Perl for decades. My two favorite examples are `map` and `grep`. Understanding those might be a good step in unlocking one aspect of Perl's power features. 
I love how perl has "accents" and you can frequently guess what the authors other main languages are.
Give up using $ENV{PWD} \- maybe there's a taint in there the gets rid of the ENV? Use use Cwd; my $pwd = getcwd;
*Programming Perl* is the definitive reference book, but also valuable for browsing because it communicates so much of the mindset. I learned a lot from flipping through it, absorbing an idea here, a trick there. But I'd recommend working your way through something more curricular, ideally *Modern Perl.* Read code, especially from good coders---search metacpan.org for terms you're interested in, read some module synopses and examples, and for a couple of modules actually go to the source code and read that. And at least look through *Higher-Order Perl* once or twice. 
No, absolutely no requirement to be readable at all. I will get around to all the suggestions eventually because I'd like to *know* what's happening, but in terms of getting the script functional, I think this is the shortest / least work. Thank you!!!
It would be interesting to know: 1. How those with less than 1 year of experience got started with Perl 1. How many new Perl projects have folks started in the past year 1. What type of project it was 1. Why Perl was chosen 
Most of the time, I prefer foreach to map unless I am specifically using a functional programming style. To me, foreach reads easier and I have not found a significant performance difference between the two. Others will have a preference for map and will likely speak up
Using foreach everywhere is fine, map is just nice for performing a transformation inline, possibly combined with other inline operations (grep and map are often combined into one statement to transform and filter a list).
Perl man pages are a great way to see how folks think in Perl and pickup its depths. Some pages that come to mind: * [perlre](https://perldoc.perl.org/perlre.html) * [perlfaq](https://perldoc.perl.org/perlfaq.html) * [perlipc](https://perldoc.perl.org/perlipc.html) The [Perl section|http://pleac.sourceforge.net/pleac_perl/index.html] of the Programming Language Examples Alike Cookbook is great too. 
I personally would think you'd need to show more than just "no-stable-release yet" cases, particularly for cases where search results would viably match a *new module* that exists *only in a dev release*, but stable releases of the *dist* already exist. Same logic applies to searching for new documentation phrases ( eg: stuff that gets mentioned in perldeltas ) which are yet to appear in a stable release. I don't care if they get ranked slightly lower than comparable stable release results, they should just be discoverable without painful contortions. ( That's why search exists as a concept after all, because well, humans suck at knowing what the contortions required are )
note that you can leave out the `floor`, since those numbers are integers anyway - so `perl -i.bak -pe "s/([0-9]+)/$1+1/ge" sample.txt` should work
Works like a charm, thank you for mentioning this! The only nota bene, for the sake of putting the info out there for Google, is that get_local() requires that the filename ends in ".html" otherwise it won't read in the file correctly. This is the final form of the "get" function for my podcast scraper with cache. It's cool because the website doesn't even see me log in a billion times as I use trial-and-error, figuring out the proper XPath selections. Thank you -- your suggestion is a game changer for me. sub get($) { say YELLOW 'PBrowser::get()'; my ($self, $url) = @_; die '$url is undefined.' unless defined $url; my $result; my $cachename = Digest-&gt;new("MD5")-&gt;add($url)-&gt;hexdigest; # my $file = "cache/9c03330611b00aeef67e3875a89a05e5"; ### no dice. # my $file = "cache/9c03330611b00aeef67e3875a89a05e5.html"; ### works! my $file = "cache/$cachename.html"; ### works! if( -e "$file" ) { # Page is cached say YELLOW 'PBrowser::get(): Getting cached copy.'; $result = $mech-&gt;get_local( $file ); } else { # Page is NOT cached say YELLOW 'PBrowser::get(): Cache does not exist. Downloading.'; doLogIn() if( $self-&gt;{'loggedIn'} != 1 ); $result = $mech-&gt;get( $url ); die 'PBrowser::get(): \$mech-&gt;success is false. \$mech-&gt;status is &lt;' . $mech-&gt;status . '&gt;' if not $mech-&gt;success(); die 'PBrowser::get(): \$mech-&gt;status should be 200, but instead it is &lt;' . $mech-&gt;status() . '&gt;' if $mech-&gt;status() != 200; say YELLOW 'PBrowser::get(): Get operation succeeded with status &lt;' . $mech-&gt;status() . "&gt;\n"; # Cache the page. string_to_file($self, $mech-&gt;content(), $file); say YELLOW 'PBrowser::get(): Page has been cached.\n'; } $self-&gt;{'lastURL'} = $url; say YELLOW 'PBrowser::~get()'; } 
&gt; Error messages for professionals as opposed to, say, those for whom this is just a hobby?
The book that took me from "a programmer who uses Perl" to "a Perl Programmer" was the first edition of *Effective Perl Programming*. The second edition is just as good.
Can you please clarify, maybe with an example, what you mean by "converting a string to a *safe* filename"? Potentially, "hello world" is a fine file name in the current directory
The * matches zero or more instances of the previous character so [0-9]* is matching the absence of a digit between the letters. + matches one or more. 
I will accept _any_ string as input, and then I want to convert that string to a legal file/dir name without getting rid of _too many_ characters, i.e. I want to preserve the input string as much as possible, so that the file/dir name is still recognisable (hopefully) even if lots of garbage is sent as input.
I will accept any string as input, and then I want to convert that string to a legal file/dir name without getting rid of too many characters, i.e. I want to preserve the input string as much as possible, so that the file/dir name is still recognisable (hopefully) even if lots of garbage is sent as input.
I only want to change it _if necessary_ for it to "work." Right now I have this simple function: sub { my $filename = shift; $filename =~ s/[^A-Za-z0-9]/_/g; return $filename; } But I know that this regex is extremely paranoid and removes a lot of stuff that _is_ allowed in file/dir names. So I want to improve on this regex to allow as much as possible in the original `$filename`.
Who, what, you name it. :) The wanted filename can come from everything; a user who just inputs something random, or a string coming from an extreme password generator. The point is: I have _no control_ over the input, so I have to make sure that the input is converted to something that is guaranteed safe, _while_ preserving as much of the original input as possible. I now understand that there isn't a module which can provide me with any help, so I'll just expand on my whitelist regex above instead.
If you have no control on it, you should return an error asking for a valid file name and not just changing it. If you change it, you should at least return the one you produced. Moreover, your system could make the life of the caller very hard: if I pass you "abcdë" and "abcdé", I am passing your interface two names that are different but in your system they map to the same file which is not said to be the intuitive / intended behaviour (my €0.02)
I can/should of course return the resulting filename, but in this case the caller doesn't care about the resulting filename. It's kind of "fire and forget, just make sure that the value is stored."
Hey, n00belig, just a quick heads-up: **should of** is actually spelled **should have**. You can remember it by **should have sounds like should of, but it just isn't right**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Encode::Safename?
 use Crypt::Eksblowfish::Bcrypt qw( bcrypt en_base64 ); https://github.com/andk/pause/blob/master/lib/PAUSE/Crypt.pm 
People often say encryption when they mean "cryptographic hash".
No. As opposed to consumers who have bought a product and are expected to have no idea how it works.
Well, I think that should be made clearer in the course registration process and website description. If the class is literally CS101 and states that no prerequisites are required beyond some basic algebra, I would expect the need for spoon feeding. If the class is designed assuming students have prior programming experience, that's fine but make it clear - and then cut loose anyone that doesn't qualify. I took CS101 in 1995, my own high school had no computer classes and material, and my family didn't own a computer. So I couldn't have prepared better even if I wanted to (and I did want to). Today most families have a better situation, but even now I don't think many high schools in the US offer CS classes and our ludicrous poverty rate means many families don't have home computers.
How is Selenium different from PhantomJS? Can I use Selenium + XPath for web scraping?
$node is an HTML::Element so call $node-&gt;attr("attribute"); # will return attr0 and attr1 and $node-&gt;as_text; # to get the text
Shortest solution: use Web::Query::LibXML 'wq'; my $html = ...; wq($html)-&gt;find('tr')-&gt;each(sub { say wq($_)-&gt;find('td.class1 span')-&gt;attr('attribute'); say wq($_)-&gt;find('td:not(.class1)')-&gt;text; }); __END__ attr0 text0 attr1 text1 
Underrated comment. Just start with perldoc perl and traverse the tree. Soo much of knowledge lies down there.
Ahh, that's really helpful. Thank you! I was wondering if maybe that was the direction I was going to have to take.
Hmmm, interesting. I'll name my ignorance and just say I'm not familiar enough with all of that without looking into to see if it'd work or not. I'll dig in and see what I can find out. A bit of context, this script will be run inside of FreeBSD virtual machine that the users are putty'ing into and then executing the script from there.
As a Perl lover who's been using it for something like 20 years, I had a play with Perl 6 last year out of curiosity. I very quickly gave up on it as I came to realise *just* how utterly unrelated the two languages are. I'm not sure I really understand why they don't give it a different name, rather than pretending it's a natural successor to the Perl I know and love. I'm not really sure what niche "Perl" 6 is aimed at; certainly I can't see any good reason to spend any time learning it when "real" Perl is so much more familiar and productive.
That sounds like my experience. It does some neat things, and was fun to tinker with for a while, but it never felt *useful* to me the way Perl 5 (and some 4, really, when I started) always did.
If you understand `grep`, then `map` is only a minor difference. If `grep` is: Allow items through for which this expression returns truthy Then `map` is: Allow through the result of this expression. In practice, it essentially means _perform this expression on all the things!_ As a quick example... my @numbers = (1 .. 10); my @even_numbers = grep { $_ % 2 == 0 } @numbers; my @squared_numbers = map { $_ * $_ } @numbers; my @squared_evens = map { $_ * $_ } grep { $_ % 2 == 0 } @numbers; You just need to remember that - like all assignments - the values flow from right to left. Perl 6 wisely implements `map` and `grep` as methods on lists, which allows for a more readable approach my @squared_numbers = @numbers.map(-&gt; $n { $n × $n }); However, if you want something similar in Perl 5, there's various autobox modules, or just something like a `Mojo::Collection` use Mojo::Collection 'c'; my @numbers = (1..10); my @squares = c(@numbers)-&gt;map(sub { $_ * $_ })-&gt;each; # `each` on a Mojo::Collection returns a list # or with experimental signatures enabled! my @squares = c(@numbers)-&gt;map(sub ($n) { $n * $n })-&gt;each; Lastly, remember that in Perl 5, `map` and `grep` are eager, so don't replace complex loops with `map`s. It's best to keep `map` and `grep` expressions short and simple. 
Oh, come on. It's not about Perl, it's all about Gnome2::VFS. &gt; I guess that the options are: &gt; * port shutter from Gnome2::VFS to GVFS or GIO &gt; * replace Gnome2::VFS with other Perl modules. &gt; Unfortunately, Debian perl team do not have the skills or bandwidth to work on this port, I hope that someone will be able to help.
This is a bit of a poor title. "Reducing Docker image size for a Cro webapp" might be better.
Some sample code: use strict; use warnings; use feature 'say'; sub graphical { my $obj = shift; $obj-&gt;{foo} = sub { "graphical foo" }; $obj; } sub textical { my $obj = shift; $obj-&gt;{foo} = sub { "textical foo" }; $obj; } my $g = graphical({}); # constructor my $t = textical({}); say $g-&gt;{foo}(); # method call say $t-&gt;{foo}(); # transform from one class to another by initializing say graphical($t)-&gt;{foo}() # looks like you don't know the class your objects belong to # unless you provide a field to hold the class name 
Yes, since Dot is designed to be a base class inherited by all objects I only added the most essential methods, the ISA relationship could easily be implemented as a Dot class itself and contained by other classes. use feature 'say'; sub ISA { my $obj = shift; my %ISA; @$obj{qw/add del query print/} = (sub { $ISA{+shift} = 1 }, sub { delete $ISA{+shift} }, sub { exists $ISA{+shift} }, sub { say 'ISA: ', join ', ', keys %ISA }); $obj; } sub person { my $obj = shift; @$obj{qw/ISA eat sleep/} = (ISA({}), sub { say 'eating...' }, sub { say 'sleeping...' }); $obj-&gt;{ISA}{add}('person'); $obj; } sub death { my $obj = shift; delete @$obj{qw/eat sleep/}; $obj-&gt;{ISA}{del}('person'); $obj-&gt;{ISA}{add}('nothing'); $obj; } my $obj = person({}); $obj-&gt;{eat}(); # eating... $obj-&gt;{sleep}(); # sleeping... say $obj-&gt;{ISA}{query}('person'); # true say $obj-&gt;{ISA}{query}('dog'); # false $obj-&gt;{ISA}{print}(); # person death($obj); say $obj-&gt;{ISA}{query}('person'); # false $obj-&gt;{ISA}{print}(); # nothing 
It's certainly familiar, it's also productive if you know it well and stick to one of the familiar modules, but Perl 6 has been designed from scratch to be a concurrent language, for instance. Try to do threads or asynchronous stuff with Perl 5, and your productivity will suffer. You will have the option of learning Go, Scala or Perl 6. What would you rather do? 
&gt; Try to do threads or asynchronous stuff with Perl 5, and your productivity will suffer. Perl 5 has some fine modules for async coding. The Mojolicious team might disagree with you on the productivity aspect here. Also, the async features were added to perl6 very late in the game, far as I recall.
Did you read that linked bug report? &gt; Well, as mentioned by others, it's a really nice screenshot application. One &gt; of the best looking Perl application, like gcstar or frozen-bubble. It's a &gt; shame that there's no "powered by Perl" somewhere on the UI. &gt; &gt; And shutter is still quite popular according to popcon [1]. CPAN dependencies are a key part of Perl, so I'm not sure why you'd say this isn't "about Perl". Projects in other languages also risk deprecation for gnome2 features, but the maintainer pools tend to be larger.
uh... the post is very much about the removal of that nice screenshot app from Debian. Someone needs to update this app or it'll be removed. It's a call for help. You'd have to skip quite a few words from the title to think it's about removing Perl itself...
Looks Javascript-y.
I would use a special flair for Perl6 but leave all Perl5 posts unflaired. There is a specific subreddit for Perl6 so Perl5 should be kind of the "default" here. But this is admittedly my personal preference and YMMV.
Bahahaha, TIL ;) 
This link might help https://www.perl.org/learn.html 
There are already flairs you can select after posting (camel and raptor would be Perl 5, camelia would be Perl 6), not sure if they work from the title as you mentioned.
Should be possible to get a screenshot using ImageMagick or Imager::Screenshot. That might work, presumably, regardless of Desktop environment and automatically better than something that is Gnome specific. So one could either weave these screen grabbing tools into Shutter, or create a new one...
Yes, it's quite possible, the $1 variable might be a good thing for you to start looking at
don't be too sure :\-\) anyway, you may find [Perl Executing Browser](https://github.com/ddmitov/perl-executing-browser) interesting...
Oh yeah, that book was terrific. I learned from first edition too, but I'll second what you said about the second edition. 
If you're coming to Salt Lake, I'll be giving a talk on this topic, or at least [a very closely related one](https://perlconference.us/tpc-2018-slc/session/fatpack-it-full-featured-perl-apps-in-a-single-file/).
Suggestion: Do the exercises from the Llama book, but learn how to do them by * reading Modern Perl and/or Curtis Poe's edition of Beginning Perl * looking things up in [perldoc](http://perldoc.perl.org/) or the Camel book (Programming Perl) Of course you can always program something else if you choose. Start browsing Effective Perl Programming ASAP. Don't feel obliged to read it from front to back. If hidden treasure is what you're looking for, open it literally anywhere and start reading. Use the Ram (The Perl Cookbook) if it grabs you, but I don't like it much. Neither the way it discusses things nor the code it presents are that great by present-day standards, IMO. Higher-Order Perl is neato, but it doesn't strike me as a beginner's book. Learning the true power of Perl will sooner or later mean learning `map` and `grep`. If you find that you like them them, go look up Higher-Order Perl and get ready to blast off into a mind-expanding wonderland. 
Probably better to just post on jobs.perl.org.
[https://www.youtube.com/watch?v=F7SNEdjftno](https://www.youtube.com/watch?v=F7SNEdjftno) I completely imagined you saying this like the manager in this clip... Probably just the olde Per 6 victimised feeling.
For Linux, Windows and OSX support without spending time debugging on those systems, I'd go with Docker. One advantage is that you can push the image to a (free) service like hub.docker.com and not have to worry too much about distribution or updates. https://docs.docker.com/get-started/
holy crap, i just tested it out and it's gorgeous! so many nice little \(and big\) useful features!
Seconded. And the perl jobs fb group. Or talk to me, I’m looking:)
Don't underestimate the power of docker here. The ability to hand off a container that is completely pre-build with all the needed libraries, etc, is a very powerful way to quicker adoption.
I agree. Do you know that I only recently found what the command: perldoc perltoc did? It is certainly not in the book "Learning Perl". 
Previous discussion: http://redd.it/758qaw#do4h69w &gt; I'm trying to figure out a better way Again, the teflon-tape correct answer to your problem is to learn packaging. You will distribute your application as a package that is appropriate for each target platform. You are correct in your surmise that the setup you have now in the code repo is developer friendly, but not end user friendly. Ideally, your installation instructions boil down to only one command. &gt; Automatically determine project dependencies I like [scan_prereqs](http://p3rl.org/Perl::PrereqScanner::App). See http://neilb.org/reviews/dependencies.html#conclusion ---- The first step is to modify your application into a dist that produces a CPAN-ready tarball because then all the packaging tools that you will use later work semi-automatically. CPAN-ready does not mean that you are required to upload the software to PAUSE/CPAN, instead just that it conforms to the format expected by backend PAUSE and the various CPAN clients. For your code in concrete, you need to add a build system, a version number, a manifest, a metafile and some documentation for the end user; and decide on a dist name (`App-steam_sell_trading_cards` is fine). Nice to have are documentation for the maintenance programmer, a changelog, and tests. The easiest ways to achieve that are probably using [ExtUtils::MakeMaker::CPANfile](http://p3rl.org/ExtUtils::MakeMaker::CPANfile) to leverage your existing cpanfile, or making a new dist skeleton with [Module::Starter::PBP](http://p3rl.org/Module::Starter::PBP) and then flesh it out by transferring your existing code into it. The main .pl file goes into a [subdirectory named `script`](https://perlmaven.com/distribution-directory-layout). Since you cannot rely anymore on the end user being able to write into the installdir, you also need to change the config location. Supply a sensible default (`File::HomeDir-&gt;my_config` should work once RT#76717 is resolved), but also let the user override the file name with a command-line option. Run the build system to create a tarball (`make dist` or perhaps `./Build dist`). Since this is probably your first time, it's a good idea to ask volunteers to check whether it installs correctly on various Perl installations, try [Perlmonks](http://perlmonks.org/) or [module-authors](https://lists.perl.org/list/module-authors.html). ---- The next step is packaging. This is different for each platform, but the concepts are broadly the same. Learn and do it yourself (look into [OBS](http://enwp.org/Open_Build_Service), you get many platforms at once), or befriend packagers and have them do it. Perhaps start with the Debian pkg-perl group, they are nice people.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://enwp.org/Open_Build_Service) - Previous text "OBS" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
FWIW, I think it would be valuable to see job postings in this subreddit. I think the signal effect would be good \(Perl\-people \*are\* in demand\) and who knows, maybe new people can be reached and join the Perl community? :\)
Yup +1 Docker. This of course still requires Docker setup and some technical knowledge. At $work we have migrated our local dev environments to docker, been a generally good experience. Occasionally Docker can shit the bed and crash but it's rare. 
Hi! [sparrow](https://sparrowhub.org) - scripts distribution system could be of interest for you.
It’s been a while, but as I recall, TT worked fine for most cases. What features do you miss? Perhaps you could create own extensions to TT if it’s only one or two features you miss?
https://stackoverflow.com/questions/14236318/perl-alternatives-to-template-toolkit
Hi! I am not quite happy with IF/UNLESS construction which does not work with boolean types or when when I pass $var="" it still treats this as a true in `IF $var` . Also '$var' inside template tries to interpolate $var which is not proper default _for_ me. The last but not the least is dependencies are too many imho. 
j.p.o is absolutely the right place to post and ensure you get to focus on applicants in the know. That said, I'd personally love to see us change our stance and for you to start a ball rolling that leads to /r/perl being overwhelmed by so many serious job postings it becomes a problem. Please consider also posting here tomorrow unless by then this comment has gotten downvoted and/or otherwise drawn ire. TIA.
text::xslate is really fast.... i think mojo::template exists...on mobile so thats the best i got for now.
I'm planning on it, and I'll definitely be attending your talk. Thanks for the heads up.
That's an interesting idea. I just spent a pretty considerable amount of time fixing [Net::Heroku](https://github.com/rage311/net-heroku), [Mojolicious::Command::deploy::heroku](https://github.com/rage311/mojolicious-command-deploy-heroku), and the Perl buildpack [perloku](https://github.com/rage311/perloku), since they had been unmaintained for some time. They're only fixed in my github repo (not on CPAN) at the moment, and they need a little more testing, but I do plan to get them updated on CPAN eventually... But a few of these utilities that I write might be a good fit for a Heroku app with the output going to the browser instead of the CLI. I'll have to play around with that.
Thank you for the detailed reply. That's a lot to take in, but you've included some of the stuff that seems to be foundational Perl packaging knowledge, which I don't have much of. I'm definitely going to dive into this approach and see where it will get me.
It does seem like a good fit, aside from having the user install Docker too. It's a small price to pay though, I suppose. I have a friend that would like to use his existing FreeNAS box to run some of my scripts, and I know that FreeBSD now has an experimental port of Docker that uses FreeBSD jails. I should look into whether that can be used in FreeNAS as well...
Seconding these suggestions, and I would add Text::Template as another option. Links for the lazy: [Text::Xslate](https://metacpan.org/pod/Text::Xslate) [Mojo::Template](https://metacpan.org/pod/Mojo::Template) [Text::Template](https://metacpan.org/pod/Text::Template)
I really appreciate all answers, will take a look more closely later and make a decision :))
here's something you can try [HTML::Template](http://search.cpan.org/~samtregar/HTML-Template-2.6/Template.pm) Been using it @ work for about 3 years now. 
I'll piggy back on this reply. Try [Dist::Zilla](https://metacpan.org/pod/Dist::Zilla) \(or friends\), it really makes it easy to create a CPAN ready tarball and with the correct plugins you have a [Makefile.PL](https://Makefile.PL) and/or cpanfile with all the correct dependencies. You can make your scripts available on CPAN as well. cpanminus is the bombshizzle, just cpanm Your::Module and your are good to go. That said. cpanm uses Fatpacker, where one downloads just one script and you are good to go. You just need perl to run it. Also an option. While Docker is a good option it does require something extra and your user need to learn your script and Docker, which is IMO a steep learning curve and may not work well on all platforms \(at work we have issues with people on MacOS, but that may be developer only issues\). 
Perl has a built-in templating system: string interpolation. print &lt;&lt;EOF; [Random section 1] randomvalue: $var1 [Random section 2] somevalue: @{[ random_function $var2 ]} othervalue: @{[ $var3 ? $var4 : $var5 ]} EOF
(Text::Template)[https://metacpan.org/pod/Text::Template]
Uh Template Toolkit works just fine with booleans and empty string is false just like in perl.
I use vim...
maybe ask on an appropriate reddit: r/eclipse/
I second vim. &gt;I decided I need an IDE for my perl programming. EPIC seems to be the choice of the web. &gt;In order to download EPIC I need to Download Eclipse for Java and need to have a suitable Java installed. &gt;So I downloaded Eclipse from the IBM site and it wouldn't run because of a Java problem. Eclipse is like that. Frankly, if you're not part of a dev-team using a defined configuration, it's probably not worth the hassle. Reality is, Step 1: Become an Eclipse Configuration Expert. https://www.perlmonks.org/?node_id=1182967 Also, this thread is useful. Notepad++ to write it, and run it in a shell window. 
For perl? IDE don't help that much anyway. You can use padre though I hear byterock uses it all the time. As for me... I use vim. With tabs and perl tidy and exuberant and all that kind of help. It's not bad. 
No, Eclipse is not what it once was.... If you can get it going it works well but can quit turn into its own project. Everyone is going to tell you to use vim. Perl folks love them some vim (or emacs). The best thing I've found on windows is IntelliJ IDEA with the Camelcade perl plug-in installed. The plug-in is actively developed and works well. Both IntelliJ and the plugin can be had for free but if you like it consider throwing the plugin author a couple bucks on the plugin page. The other OK IDE for perl is Komodo Edit. Its specifically built for perl but interestingly I find IntelliJ with Camelcade perl to work way better than the community or pro versions of Komodo. Good Luck!
I use Atom and it does code completion, smart colors, paren matching and more. For Perl, for free.
+1 IntelliJ and Camelcade It is very good for larger Perl programs. Nothing beats Vim configured for Perl for hacking scripts in the terminal though.
Honestly, I think that the Template Toolkit is the most fully\-featured templating engine available for Perl. If you're having problems with it, I'd suggest that your best approach would be to post descriptions of those problems here so that we can help you address them.
TT is the only sane one for me and I've probably used all of them. Catalyst uses TT by default and that's good enough for me.
&gt; EPIC http://www.epic-ide.org/ 
https://mojolicious.org/perldoc/Mojo/UserAgent#build_tx shows how to post request bodies. 
For the full IDE experience surely Komodo IDE rather than Edit might be the recommend \(though pay for\). Sublime and Atom with all the Perl plugins \(like crytic and perl \-c linters\) setup are quite good too if you want a GUI editor.
Mojolicious lets you do a lot of things more concisely than some other frameworks/modules, too. This type of setup/flow is normally what I use in my client-side scripts: my $ua = Mojo::UserAgent-&gt;new; my $post_result = $ua-&gt;post( $endpoint, { SOAPAction =&gt; $soapaction, 'Content-Type' =&gt; 'text/xml' }, # headers $message # request body )-&gt;result; 
Yeah, IMO Komodo IDE didn't work as well as IntelliJ for me but YMMV. I have not tried Sublime or Atom but both seem to be very popular.
Don't be mislead by the documentation for each individual module in the Mojo toolkit; when you are using many modules together, they often instantiate the other objects for you, in this case you only need to construct the UserAgent object. Take a look at the [post method](https://metacpan.org/pod/Mojo::UserAgent#post) and the tx method it links to for more ways it accepts arguments.
I use VSCode which is very similar developed open-source by Microsoft.
Thanks. That got me to: my $t = Mojo::UserAgent::Transactor-&gt;new; $t-&gt;tx( POST =&gt; $endpoint =&gt; $headers =&gt; $message ); But I wasn't really sure where to go from there. Regardless, I appreciate you chiming in.
...and that's exactly what was happening. I was getting overwhelmed by the sheer number of ways to \(for instance\) add custom headers to an HTTP request and trying to figure out how to put the pieces together. I'm gonna go with rage\_311's proposal since it's so close to my existing code. Thanks for your advice, the more I work with Mojo the more I like it \- but sometimes it makes my head hurt. :\)
I suspect [Mojolicious::Guides::Cookbook](https://mojolicious.org/perldoc/Mojolicious/Guides/Cookbook#USER-AGENT) can show a few pointers here (not necessarily SOAP, but the general way of using Mojo::UA.) To "see" the request the way Mojo::UA would see it, I'd run with your script with `MOJO_USERAGENT_DEBUG=1` to see the full request/response.
Why are you moving to mojo\-based tools?
TT (when I last used it at least) had a reasonably full set of standard extensions, but if you felt like writing one of your own it was a bit of an annoyance-- I ended up looking at the code of some of the existing ones. Myself, I prefer Mason's approach, where it's pretty obvious how to write extensions, and you can drop in chunks of perl code at will. I gather some people get burned by undisciplined use of these features, but you know, my solution is "don't do that". https://metacpan.org/pod/Mason
Thank you. I don't remember seeing that in any of the docs, but my eyes had probably glazed over.
Because most of my prior code was whatever procedural baby Perl I was able to cobble together at the time.
Oh ok, I've been out of the perl game for a few years and hadn't heard of it before, seems to do a lot
And of course now I see it \- in the 'debugging' section of the doc for mojo useragent. :\)
The TT interpolation of `$var` only happens if you use it inside _double quotes_. If you don't want TT to interpolate, use _single_ quotes instead. That is: [% SET bar = 'THIS IS NOT A BAR'; "foo $bar baz"; "\n"; 'foo $bar baz'; "\n"; %] … will yield: foo THIS IS NOT A BAR baz foo $bar baz
At `$work` I mainly use Template Toolkit, as that's what was present prior, and it works Just Fine for the most part. But, it's _slow_. It's good, but _slow_. So, for personal projects this days I mostly use `Text::Xslate` instead. It's got most features TT also has (_aside from_ `PROCESS file.tt`, that is - but there are ways around that), and it's _fricking fast_. See: https://darkpan.com/files/compare-templates-cleaned.pl.txt …and another benchmark I've been doing to test the speedup gained by migrating a few "choice template kinds" from TT to TX: TT: Template Toolkit with disk cache TX: Text::Xslate with disk cache and cache =&gt; 1 (default) Function TT/s TX/s ±TX/TT 1s 100_runtime_inclusion 4978.58 35301.28 +609.06% 1s 030_include_for_macro_call 1365.62 13958.02 +922.10% 1s 020_macro_loop_data 2680.44 44021.18 +1542.31% 1s 020_macro_loop 3379.81 54103.07 +1500.77% 1s 011_include_small_variable 10791.85 88554.30 +720.57% 1s 010_include_small_literal 12210.76 79163.14 +548.31% 1s 005_deep_data_structure 15066.95 113540.64 +653.57% 1s 004_simple_loop_if_else_constant 1162.41 11586.22 +896.74% 1s 004_simple_loop_if_else 1469.15 14714.50 +901.56% 1s 003_urls_pipe_uri 6776.07 49334.74 +628.07% 1s 002_simple_loop_vars 1991.73 41346.86 +1975.93% 1s 002_simple_loop 1227.68 12007.29 +878.04% 1s 001_simple_loop 6874.87 110738.92 +1510.78% 1s 001_simple_hashref 6185.73 55478.98 +796.89% 1s 000_two_vars 13795.08 136378.87 +888.60% 1s 000_single_var 18210.24 150477.13 +726.33% 1s 000_literal_text 22882.55 167636.03 +632.59% 
[Mojo::Util](https://metacpan.org/pod/Mojo::Util) is worth checking out, it's a collection of nice reinventions and wrappers of useful utilities for web (and other) development that's mostly equivalent or better than what you could cobble together otherwise.
Sorry, maybe I did not have it clear, if I have template: { "$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#" } I need to rewrite it as to suppress interpolation: { "\$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#" } or as { '$schema': "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#" } 
Sorry, looks like I was wrong, I just created a test, and yeah TT works as expected.
You should be able to just use `&lt;$lessonDir/*.mp4&gt;`.
Perhaps `opendir` and `readdir` would better suit your needs. 
 As u/amdpox mentioned, you can just do `&lt;$some_dir/*&gt;` (or `glob("$some_dir/*")`), which will return a list of strings of the relative directory. for my $f ( &lt;'../files/*'&gt; ) { say $f; # ../files/some_file.mp4 } Using `opendir` and `readdir` will iterate through the directory. There are a few things to remember. Unlike `glob, it will also return files in a random order, and will inclide hidden files (including `.` and `..` on Unix-like file systems). Additionally, if you `opendir` on a different directory, it returns only the basename of the file opendir(my $dir, '../files'); while ( my $f = readdir($dir) ) { say $f; # some_file.mp4 } closedir($dir); Be careful with this, because if you then delete a file (`unlink $f`), _you may be operating on a file in your CWD_, **not** in the directory you `opendir`. The solution is to prepend the directory. Also, there's no way to filter files with `readdir` so you have to handle it youreself in the loop. opendir(my $dir, '../files'); while ( my $f = readdir($dir) ) { next if index($f, '.') == 0; # Skip hidden files next unless substr( $f, rindex($f, '.') ) eq '.mp4'; my $path = "../files/$f"; say $path; # ../files/some_file.mp4 } closedir($dir); To be honest, I wouldn't recommend using `opendir`/`readdir` unless you are working with a lot of paths (eg. doing a recursive directory walk) and don't want to use up a lot of memory. Personally, I like to use a module like [`Path::Tiny`](https://metacpan.org/pod/Path::Tiny) so I get file objects, rather than just strings. You can give the `children` method a compiled regex to filter the returned objects. Additionally, you can for my $f ( path('../files')-&gt;children(qr/\.mp4$/) ) { say $f; # ../files/some_file.mp4 say $f-&gt;basename; # some_file.mp4 }
Thank you!!! I found double quotes in the glob are necessary when there are spaces in the path name. I guess the &lt;&gt; operator can take multiple arguments... but I would've thought the arguments are comma separated rather than space separated. Anyway, doesn't matter. Lesson learned. Path::Tiny is a good thing to have in my toolbox. I have to use VBA a lot at work, and it looks a whole lot like the FileSystemObject. Very convenient. I think this will become a standard workhorse for me when working with files in Perl. You are really good tutor. Thanks!
Perl needs a lot of things, an AppStore isn't one. CPAN got a much needed code-refresh with Meta.CPAN. The problem is that it's lagging other languages and the community has shifted from an adventurous community of hackers with a unique culture to a cesspool of a few large companies, and IBM consultant-wannabes with long hair. It's not that you can't go that route and be successful, it's that perl is less well-poised to succeed in that direction.
You offer zero reasons why you think an app store isn't needed. For that matter, you offer zero reasons for anything in this weird, negative rant.
I love this idea. Years ago, people did try to rewrite Matt's Script stuff. It's possible that WordPress plugins consumed a lot of those use cases. By any chance, are you familiar with this? https://sparrowhub.org/ 
&gt; start a ball rolling that leads to /r/perl being overwhelmed by so many serious job postings it becomes a problem. lol Not to hijack the thread, but j.p.o. is at a sad state/really slim pickings, no? 
 Not Matt’s Script already exists.
Valid point on second read. Because an App-Store would provide the ability for app-developers to get paid for writing Perl. It's a market based solution for a community that is suffering mostly from an overwhelming social problem, with some valid technical problems. You want me to revisit all the drama and technical failures of Perl 5?
It’s called dockerhub.
I hadn't been aware of that...but that is interesting indeed. Now this is a platform for plugins that reinforces that idea that Perl is a handy way of producing scripts that do scripty things for servers and CLIs. IMO Perl is capable of much more. [Slic3r](https://github.com/slic3r/Slic3r), for example, is a powerful 3D slicing tool is written in C++ and Perl. 
Evan, I get your point, of course. The trouble is that that "cesspool of a few large companies, and IBM consultant-wannabes with long hair" is not the group that is going to drive Perl's success in the long term. Now I agree there are plenty of technical or social reasons why a coder might shift from Perl to something else. One can accept that set of affairs and abandon Perl, or recognise the real benefits and value of Perl and use a platform (such as an Perl specific application repo) to demonstrate this value.
[With 16 applications](http://nms-cgi.sourceforge.net/scripts.shtml) some of them not useful, apart from as a resource to learn Perl. 
&gt;lol Exactly. I'd be super surprised to see even one job post a month emerge from any attempt to encourage job posting. But I sure don't see any point in discouraging someone who asks. &gt;Not to hijack the thread, but j.p.o. is at a sad state/really slim pickings, no? For those hiring? I thought it was still a sensible place to post positions available to get exposure to those who know of its existence. But perhaps that's no longer true. Let's take your personal anecdata; have you stopped visiting it altogether because there are less postings than there used to be? If so, where do you now go instead?
Yes, I don't think we're at risk of overwhelming this subreddit anytime soon, or even ever. I think if a thread/stickie gets developed here where folks can actually search for/discuss PERL jobs is not a bad idea, though the odds of that taking off seems low. No I don't know of a better place. Glassdoor I think is not too terrible when you search on PERL, though many only mention PERL in passing, e.g. "Basic knowledge of a server-side scripting language (PHP, Perl, Ruby, PHP, C++, etc) " sort of thing, rather than as the primary skill. Personally I have accepted the fact that to stay relevant, I must put my eggs in more than the PERL basket. I'm sure this can be an interesting tangent discussion: what's happening with PERL at your workplace? At mine, there was a major initiative to rebuild the existing 10-year old system in Python. It did not succeed but I've been aggressively studying Python (hackerrank, leetcode, meetups) on the side; to deal with interviews if nothing else: as vast majority of shops are now Python-centric and it seems with PERL-only jobs, I'm inevitably looking at a step down in compensation.
There's no legitimate reason for an app store user to give a shit what language something is written in.
&gt; You want me to revisit all the drama and technical failures of Perl 5? Yes, and don't skimp on the haircut stuff.
&gt;Years ago, people did try to rewrite Matt's Script stuff Oh, I think we succeeded :\-\) [The nms project.](http://nms-cgi.sourceforge.net/) \(I should really think about moving that stuff away from Sourceforge!\)
The project was called "Not Matt's Scripts" for about two weeks, over fifteen years ago. It's *the nms project*. \(It might not seem important, but changing the disparaging name was part of an agreement I reached with Matt Wright which led to him [promoting the project](http://www.scriptarchive.com/nms.html) on his web site.\)
&gt;apart from as a resource to learn Perl I really wouldn't want anyone to learn Perl from that code. It was pretty good stuff 15 years ago \(certainly far better than Matt's own code\) but it looks really dated now. A few years ago, [I started a project](https://www.slideshare.net/davorg/psgi-25200302) to rewrite them all again using modern tools like PSGI.
There's [a scripts section on CPAN](https://www.cpan.org/scripts/). It never took off. I don't know why that is. Patches welcome :\-\)
some possible reasons for not taking off: - no search - very first entry starts off with "THIS SOFTWARE DOES NOT COME WITH ANY WARRANTY WHATSOEVER. USE AT YOUR OWN RISK." - categories include such hot topics as "CGI" and "VersionControl :: CVS" - many of the items have no description at all - only single-file scripts supported - no automated support for dependencies - no upgrade procedure - no installer - no (obvious?) link or mention from metacpan.org - no reviews - no documentation 
Damn. Matt's Scripts still exists?
The key point here is that people who work in Perl create great applications, but they create them from scratch, using \(we hope\) trusted components. Your suggestion is like saying a company which makes bricks, mortar and concrete blocks ought to start a house store. Prebuilt houses, mobile homes, emergency shelters and double\-wide trailers all exist. But that's not the business we're in. That's someone else's business.
All potentially soluble, IMO. This is a useful list for me to work on, thank you.
Yes. When I said "I don't know why that is", I was being slightly sarcastic. The site clearly hasn't been touched for over twenty years. I was slightly surprised when I checked and found the link still worked.
This is true, and this is the problem. You make a wonderful program from scratch exactly solving your complex problem and nobody else but you benefits; you die and your code dies with you. As a business model, it stinks because (using your analogy) there are more people who need houses than able to build them.
Indeed if the resulting filename is unimportant, why not use filenames like 1, 2, 3, and so on? Then keep a database mapping input filenames to those numbers. The entire exercise sounds like you want a logging system, not a file system.
I just don't understand the idea of a language-specific app-store. When you buy a house, you generally don't care who made the bricks.
&gt;Glassdoor I think is not too terrible when you search on PERL I hadn't realized that glassdoor has been bought by the same company that owns indeed. Talking of which, I had presumed that OP knew to post to indeed and glassdoor as well if they wanted that \(massive\) audience. \^\^\^ /u/tvmaly Btw most folk in the Perl community who care about aesthetics call it Perl, not PERL. You may find you do epsilon better for some job applications if you avoid calling it PERL. Silly, perhaps, but I thought I'd mention it. &gt;though many only mention PERL in passing Oh sure. I think that's the case for almost all jobs mentioning Perl. &gt;I have accepted the fact that to stay relevant, I must put my eggs in more than the PERL basket. I've always considered it healthy for devs to be polyglot. &gt;I'm sure this can be an interesting tangent discussion: what's happening with PERL at your workplace? Nothing I feel comfortable sharing, sorry. Though I will say I plan to buy [this](https://commaide.com/) tonight or next week. &gt;At mine, there was a major initiative to rebuild the existing 10\-year old system in Python. It did not succeed What's your takeaway from that effort and failure? &gt;but I've been aggressively studying Python \(hackerrank, leetcode, meetups\) on the side; to deal with interviews if nothing else: as vast majority of shops are now Python\-centric Right. Growth in Python use has been something like 10\-20x Perl growth this century. &gt; and it seems with PERL\-only jobs, I'm inevitably looking at a step down in compensation. Some stats I've seen suggested the inverse for senior Perl devs \-\- that their salaries have been rising faster than average. How long have you been writing Perl?
if you run `say $tree-&gt;findnodes( $xpath0 )-&gt;[0]-&gt;as_XML_indented;` you'll see there's a `&lt;ul&gt;` after that div. so it looks like this: &lt;div aria-labelledby="relatedLessons" id="panelRelatedLessons" role="tabpanel"&gt; &lt;ul&gt; &lt;li class="list-group-item"&gt; &lt;div class="media"&gt; ... &lt;/div&gt;&lt;/li&gt; &lt;li class="list-group-item"&gt; I know you are saying WTF, it's not in source and not in Chrome dev tools. But there it is in Tree Builder. And that's why your xpath doesn't work. Why it is there is another question. I'll have to guess it tries to fix invalid HTML. I'm lazy to look up, but as far as I know `&lt;li&gt;` tags should be surrounded by `&lt;ul&gt;` or `&lt;ol&gt;`. Maybe TreeBuilder needs to have valid HTML it parses it into it's object, so it trys to be smart and fix anything that it thinks is invalid. Just my 2 cents.
I poured over the output of $mech-&gt;content to figure out what was going on. I like your method muuuuuuch better. as_XML_indented is now in my bag of tricks. Thanks for that. You know, I looked through the PhantomJS documentation and didn't see anything about fixing invalid HTML. I also tried contacting the maintainer, but no response so far. I did a small test though. I created a proof of concept html file with &lt;li&gt; but no enclosing ordered/unordered list. Using get_local(), the content of Mechanize is exactly what the file contains, so whatever is going on is associated with getting a remote webpage, not local files. One would think that Mechanize wouldn't care whether a DOM came from a file or a remote webpage, but the docs hint that the two are indeed different -- it basically says that getting a webpage from a file is somewhat broken. Guess this is one of those things that you get bitten by once or twice and then suddenly you can answer other peoples' questions when they get stumped by the same weirdness. :)
A few thoughts as I'm reading all this... \* Props for finding a problem and solution yourself! :\) \* Ha, imagine doing test automation everyday where you have to use PhantomJS and run into all this quirks all the time :\) But it's not only Pahntom's problem, really. I've ran into similar issues with other tools, sometimes DOM can differ if you use a different browser! \* When Chrome release headless mode PhantomJS creator announced that developing Phantom doesn't make sense anymore, and he will stop. See here: [https://github.com/ariya/phantomjs/issues/15344](https://github.com/ariya/phantomjs/issues/15344) \* The `as_XML_indented` was in the documentation in HTML::TreeBuilder::XPath wich you are using, its always good to read the docs :\) I'm not sure why you went on to reading DOM with Phantom while trying to figure this out. Does not sound HTML::TreeBuilder uses PhantomJS underneath. It wasn't the best idea, because these two tools could be building DOM completely different, each with own quirks. This could lead you to some other direction. You got lucky :\)
but if you want people to buy your bricks, it's nice to have a house or two you can use as demonstrations. Perhaps Lego would be a better analogy than a house?
Perl is still a workhorse in many established financial companies. I think the meta capabilities of Per exceeds those of Python.
My HR department posts the job on the major boards, but I find better people for Perl when I look in only Perl places.
Thanks for explaining the delineation between Mojolicious:: and Mojo::, as I'd wondered about that.
Those that make the bricks might care to make things easier for people to use their bricks maybe?
Well, that sounds like CPAN.
Correct, there is an application script section on CPAN (with certain deficiencies) as davorg and tm604 pointed out for me.
These days Perl apps/scripts are often just packaged as regular CPAN distributions.
From my initial look at this, here are my thoughts: Pros: * truly private data and methods * trivially easy inheritance Cons: * nonstandard method call syntax * not sure how well it would work with other classes Here's my sample code: *path: ./lib/Local/NameHandler.pm* package NameHandler; use feature qw/say/; use strict; use warnings; use Data::Dumper; sub new { # public hash ref, only holds public method my $obj = shift; # private hash ref my $priv = {'name'=&gt;'Bob'}; # private method my $expand = sub { my $str = shift @_; my @p = split(//, $str); return join('_', @p); }; # public method $obj-&gt;{hello} = sub { my $tmp = $expand-&gt;($priv-&gt;{name}); say "Hello, $tmp"; }; # public method $obj-&gt;{rename} = sub { $priv-&gt;{name} = shift @_; }; # public method, attr getter $obj-&gt;{getName} = sub{ $priv-&gt;{name} }; return $obj; } # subclass to add another public method # this subclass has NO ACCESS to parent class' private data or methods package NameHandler2; sub new { my $obj = shift; $obj-&gt;{formal} = sub { my $name = $obj-&gt;{getName}(); say "Salutations, Sir or Madam $name"; }; return $obj; } 1; *path: ./test.pl* #!/usr/bin/perl use feature qw/say/; use strict; use warnings; use Data::Dumper; use FindBin qw/$Bin/; use lib "./lib"; use Local::NameHandler; my $f1 = NameHandler2::new(NameHandler::new({})); $f1-&gt;{hello}(); $f1-&gt;{rename}('Edward'); $f1-&gt;{hello}(); $f1-&gt;{formal}(); my $f2 = NameHandler::new({}); $f2-&gt;{hello}(); print Dumper $f1, $f2; $f2-&gt;{discombobulate}(); # not a real method *here's the output:* Hello, B_o_b Hello, E_d_w_a_r_d Salutations, Sir or Madam Edward Hello, B_o_b $VAR1 = { 'getName' =&gt; sub { "DUMMY" }, 'hello' =&gt; sub { "DUMMY" }, 'rename' =&gt; sub { "DUMMY" }, 'formal' =&gt; sub { "DUMMY" } }; $VAR2 = { 'rename' =&gt; sub { "DUMMY" }, 'hello' =&gt; sub { "DUMMY" }, 'getName' =&gt; sub { "DUMMY" } }; Can't use an undefined value as a subroutine reference at ./test.pl line 22.
I was also able to create a singleton. *path: ./lib/Local/Singleton.pm* package Singleton; my $obj; my $priv; sub new { if( defined $obj ){ return $obj; } $obj = shift @_; $obj-&gt;{setFruitPrice} = sub { my($fruit,$price) = @_; $priv-&gt;{$fruit} = $price; return 1; }; $obj-&gt;{getFruitPrice} = sub { my $fruit = shift; if( defined $priv-&gt;{$fruit} ){ return $priv-&gt;{$fruit}; }else{ return undef; } }; $obj; } 1; *path: ./tet2.pl* #!/usr/bin/perl use feature qw/say/; use strict; use warnings; use Data::Dumper; use FindBin qw/$Bin/; use lib "./lib"; use Local::Singleton; my $o1 = Singleton::new({}); say "set prices in object 1"; $o1-&gt;{setFruitPrice}('Apple',1.00); $o1-&gt;{setFruitPrice}('Banana',1.25); $o1-&gt;{setFruitPrice}('Cherry',0.15); my $o2 = Singleton::new({}); say "get prices from object 2"; say $o2-&gt;{getFruitPrice}('Apple'); say $o2-&gt;{getFruitPrice}('Banana'); say $o2-&gt;{getFruitPrice}('Cherry'); print Dumper $o2; *output:* set prices in object 1 get prices from object 2 1 1.25 0.15 $VAR1 = { 'setFruitPrice' =&gt; sub { "DUMMY" }, 'getFruitPrice' =&gt; sub { "DUMMY" } };
I’m in Apollo, but are there any docs or do I have to read the code?
`Set`s in Perl 6 are immutable. As are `Bag`s and `Mix`es. my $s = &lt;a b c d&gt;.Set; Documentation at https://docs.perl6.org/language/setbagmix
Thanks. That's not the full set of features I would like, but it's a start.
What features are you missing specifically?
 Concern trolls ruin everything
Congratulations, EU. You killed the internet. -- These logs were valuable ways of learning code, avoiding asking redundant questions, and establishing a community. And still no-one has explained how a European law could be enforced against those of us not under its jurisdiction. Utterly infuriating.
I don't keep up with the news much, but I *think* Germany is still under European jurisdiction...
 I like that not everything on the Internet tries to be written in stone. If you know that every single thing you say is meant to go up online forever you don't talk quite as freely. You can still go and be on that IRC channel, and keep logs, until your utter infuriation subsides. And I guess you can publish the conversations, and host them from outside the EU, or just host them from the EU and don't worry that you're breaking a law if you feel that strongly about it. 
Please don't take this post the wrong way, since I really don't mean to downplay your efforts. But are you sure this really warrants a separate module? Anybody that's familiar with `JSON` and `IO::Uncompress` will recognize that both of them have incremental modes, and that gluing those together is just going to need a simple loop. Moreover, many people requiring incremental parsing are likely to need integration with some _other_ part of their code -- e.g. they may be streaming the JSON blob from a remote server, they make want to hook it into their LWP response handling or network event loop -- and it's not clear whether your proposed module would be useful in those kinds of situations. Maybe it's just that I don't fully understand what extra benefits your module will provide. I do think it ought to provide something over and above what can be achieved simply by gluing those two modules together manually. For instance, one thing I think would be _really_ neat would be a streaming [JSONPath](http://goessner.net/articles/JsonPath/) evaluator.
Can you run the log s/w yourself and publish them?
It's code that reads from a file, not a socket or whatever. I'm not trying to make a general purpose one-size-fits-all function. Just something that reads from an optionally compressed file. And why a module? So you don't have to write your own loop every time, possibly introducing bugs each time. Why do that when you can use an existing solution known to work right the first time?
Incremental parsing is tricky. But other than that part of your post, [File::JSON::Slurper](https://metacpan.org/pod/File::JSON::Slurper) is a cute little module that combines the recommended approaches for reading in a file quickly and decoding JSON quickly. (Special note: JSON.pm uses JSON::XS by default which has many bugs fixed in Cpanel::JSON::XS, and also adds overhead to JSON::XS's normally speedy parsing; JSON::MaybeXS uses Cpanel::JSON::XS directly and normally with no added overhead.)
That's one of the thin wrapper modules I referred to.
Also I realized it's still broken unfortunately; it double-encodes output and double-decodes input (it should be using read_binary+decode_json, not read_text, but it has an encoding option unfortunately...)
you should also see if JSON::SL helps your use case.
For example: https://metacpan.org/pod/App::SimpleHTTPServer or https://metacpan.org/pod/Yancy
Hmm. Maybe? I'll have to play around with it some.
I believe the law applies regardless of where it's hosted as long as the rights of EU citizens are involved. Anyway common/polite practice is for publicly logged channels to declare themselves as publicly logged in the topic or a join notice, as public logs are very different from each user's logs (which you have to assume always will exist on IRC).
It's *The Great Undefing*.
Right. I'd still post in [https://news.ycombinator.com/item?id=17205865](https://news.ycombinator.com/item?id=17205865) I would have thought there's some time/cost effective way to get exposure at [https://perlconference.us/tpc\-2018\-slc/](https://perlconference.us/tpc-2018-slc/). And at least consider [http://perlweekly.com/](http://perlweekly.com/)
I’m American and don’t give a toss about EU law. I just need to find a server to host them that’s not in the EU to share freely with the world. I’m sure there’s someone else out there like me who actually cares to log and share the Perl chat. 
From the linked page: \&gt; The source code of the underlying software is [still available from GitHub.](https://github.com/moritz/ilbot) Use it based on your own judgement and understanding of the law.
I liked this site. 
&gt; For instance, one thing I think would be really neat would be some kind of SAX-like streaming evaluator for JSON. https://metacpan.org/pod/JSON::SL::Tuba (also JSON::SL, which has better documentation)
I hate what the internet has become.
&gt; It's code that reads from a file, not a socket or whatever. I'm not trying to make a general purpose one-size-fits-all function. Just something that reads from an optionally compressed file. &gt; &gt; And why a module? So you don't have to write your own loop every time, possibly introducing bugs each time (Like forgetting to tell the parser that the decompressed text is raw UTF-8, as I learned the hard way). Why do that when you can use an existing solution known to work right the first time? Good answers! I'm fine with piecing together other modules as necessary -- I usually find these kinds of one-shop do-everything modules do only about 95% of what I'm looking for. But I can certainly see the benefit in hiding all the rough edges in these modules. So to answer your question, how about `JSON::Slurp`? It's kind of "slurp this file, decompress it if necessary, parse it as JSON and spit out a data structure".
Isn't Reddit or StackOverflow essentially the same thing? If not, what is the difference?
&gt; but here is the problem, when I come the next day I have to run the hypnotoad command again but only once and it says hot deployment and I can use it fine again. This is the part where you forgot to state the actual problem. I suspect what you want to say is: if you make a request to the server the next day, it doesn't respond. Is that right? 
&gt; If you know that every single thing you say is meant to go up online forever you don't talk quite as freely. Oh, if the presence of the IRC logs had been imposing some kind of self-censorship among Perl 6 developers, I shudder to think what they are doing behind closed doors. At least, Roseanne got cancelled for her public racist attack. The Perl 6 developer who did the same is getting paid by the Perl Foundation.
yeah, sorry you're right, I've been trying to fix this problem for days and I can't seem to understand what is going on
You might be interested in Perl 6's Lists and Maps, although you need to be careful to decontainerize some things. You can also bind (instead of assign) literal values.
[https://docs.perl6.org/language/list#Immutability](https://docs.perl6.org/language/list#Immutability) for the array like things. The answer broadly is yes there are immutable types for anything you want. From my own personal experience I disagree with your general premise though. At least you present a problem that feels very artificial in its importance given my experience programming. I imagine it perhaps holds more for something like C not really higher level memory managed languages. It takes a special kind of developer to write hacky mutated pass by reference semantics in a high level language, even in C it's only really ever done around wanting to pass memory allocation outside of a library so that its easier to reason about what/who owns memory \(which is a far bigger real problem\). That just doesn't hold in a garbage collected language. Perhaps try writing Perl 6 in an idiomatic style and see how well you get on before worrying about if enforcing immutability everywhere. I'd love some examples from your experience of how this is a big issue, because I cant really think of any times I've been super bitten by memory changing underneath me in a way that wasn't very obvious from the code, threading being an obvious real exception.
I've seen this before with an app which had a persistent database connection open. It was fine until the next day, then nothing from it until we restarted it and no particularly useful error messages. Do you think this might be a possible cause in your case?
I work with Java at my day job but toy with languages like Scheme and Perl 6 in my spare time because I like them better. With Java, at least, the static type system (which isn't that great as far as static type systems go) stops us from most classes of type error. But we get bit by pass-by-reference errors more often than you might expect. For example, some class holds a list of objects and someone absentmindedly makes the class method getList() return a reference to the original instead of a copy. 99.5% of the time the caller just uses the returned list as-is, but 0.5% of the time the caller filters out all list entries from NYC before performing some calculation. And even then, 90% of the time users aren't querying the US East Coast so it doesn't matter. But that 10% of the 0.5% of the time users query US East Coast but not NYC the filter removes the NYC entries from the calculation and the bare list output - and we have a bug it takes two weeks of full time investigation for a developer to track down for a one line fix. That kind of thing happens periodically with Lists, Maps, and Sets in Java. More generally with Objects, it's common practice (syntactically convenient) to build objects with mutable instance fields and a few methods. As before, most of the time it's fine. But periodically some method that assumes all instance fields have been initialized will be run before all initialization happened due to some kind of logic error, and it crashes. Or in the simplest term, some code tries to write to a file handle or query from a database connection that was already closed. In Java, the language can't fix these kinds of thing for you automatically. I have two practices I just remember to always apply. First, when performance concerns don't dictate otherwise always return copies of Lists, Maps, and Sets. Second, make all of your objects immutable with all possible initialization done by the constructor. It forces you to structure the code that creates and uses the object differently, and prevents most of the unpredictable field initialization patterns that could otherwise occur. Someone - Larry Wall, maybe? - said that the important differences between computer languages isn't what they make possible but instead what they make easy. But I prefer the same general idea as expressed from a slightly different angle in the Clojure community: the important difference between computer languages isn't what they make possible but instead what they make *idiomatic*. You *can* pass around and manipulate mutable objects in Clojure, but you have to do more work (use more syntax).
I'm not sure I agree with his interpretation of GDPR. Nicks, especially when you can't prove they're authenticated, are not PII by any means. As such, none of the data is linked or related to an individual.
I did reach out to Gabor in the weekly. I always post on the HN Who’s hiring thread
With these projects, I want to mirror the phrase "don't invent your own crypto" for physical security. Problem is, that phrase is based on the fact that publicly verified encryption algorithms are pretty damn good. Conversely, common home security systems on the market are invariably shit, and you can almost certainly do better on your own.
This is rather unfortunate given, for example, [commit messages](https://github.com/search?q=irclog.perlgeek.de&amp;type=Commits) that reference the site, along with [issues](https://github.com/search?q=irclog.perlgeek.de&amp;type=Issues) that also reference the site. So now a tonne of history has effectively been destroyed. I think the lesson is clear, always put full context into your commit logs/issues where possible and avoid only providing links. I mean, we know this already but still...
Two things that I found interesting is that code is clear and readable for a newbie like me (belying the reputation of Perl as a natural obfuscator), and secondly that he refrained from using the already well established RPi modules on CPAN. Instead he reads directly from "/sys/class/gpio/gpioXXX/value", and writes to it.
Speaking of GDPR generally, any EU citizen, no matter where they're living, can submit a complaint under the law. To an extent, I feel like America has meddled in so many other countries, and now the karma is coming back. Still, GDPR is a well-intentioned failure.
They probably can't actually collect the fine if you don't have a business in the EU and don't plan to ever travel there. If you do either one, you had better start to care about GDPR.
It's not about Moritz' *interpretation* of the GDPR, but about *managing his risk* of receiving cease and desist letters. There are three options: * You are confident that your site is absolutely compliant and you can reject these letters \(thus opening the possibility of a lawsuit, which is time\-consuming and potentially costly\). * You accept these letters and pay their attorney fees. * The only winning move is not to play. He chose the latter option, which saves him tedious compliance work and reduces his financial risk to zero. Since he offered the logging service at no charge, I can totally understand that. Also, any IRC logging service naturally contains lots of personal data: usernames/handles, timestamps for joining/quitting, and message contents. Those are very much related to an individual, and could at most be considered pseudonymized \(though the natural person behind many handles is often well\-known, which weakens this argument\). [Art. 4\(1\)](https://gdpr-info.eu/art-4-gdpr/) explicitly calls out names and online identifiers as personal data. I don't think this makes GDPR compliance impossible, just very very tricky *unless* Freenode and other IRC networks start collecting user consent \(a notification through a MOTD or channel topic is not suitable consent\).
Thanks. It took me a while to hunt that down in the documentation and grasp it. This is what I worked out: # immutable list my @a := (2, 3, 4); # @a is immutable List 2, 3, 4 @a[1] = 5; # fails my @b := (1, | @a); # @b is immutable List 1, 2, 3, 4 @b[1] = 5; # also fails That's exactly what I had in mind for convenient Lists, and not that much extra work as far as syntax (just := instead of = and vertical bar). I don't see a similar option for the default Map.
In this case the fix would be to use a proper database connection manager like [DBIx::Connector](https://metacpan.org/pod/DBIx::Connector) or [Mojo::Pg](https://metacpan.org/pod/Mojo::Pg).
What happens when you try to request? Any information in the log? Can you check to see if the normal number of hypnotoad processes are running when this happens? (manager + preforked children)
That's what I meant really. You can run the sw yourself if you're not in the eu.
Glad to hear you contacted Gabor. I missed the HN post when I first looked, see it now, so my PM, which was because I was thinking that perhaps you didn't use the word 'perl' at all at HN, was/is moot. I see there's [https://perlconference.us/tpc\-2018\-slc/session/introduction\-to\-go/](https://perlconference.us/tpc-2018-slc/session/introduction-to-go/). 
Ah. D'oh. :)
Why are you using UDP for this project? UDP does not provide any way of detecting and handling packet loss, so in my understanding you could be missing events. 
Non\-standard method call syntax also means method dispatching is ditched completely, so no matter how complex your inheritance hierarchy is your method is always a hash look up away from you. I never bothered to create a Dot class that inherits from a non\-Dot class, should be possible by hiding a Dot object and a non\-Dot object behind a tied hash and setup the delegation, indeed this is an interesting question and should be investigated further during the future development of Dot.
we would get an error back and the request would fail. Also I think the workers stop running but the manager is still running. No information in the Log except for database connection failing. 
I think you maybe right, we'll change it to DBIx and hopefully that may solve our problem
I didn't take the connection into consideration and I think that is what is causing the error with DBI connection only lasts about 8 hours as a default and we'd return later than that and so when we request it fails because the database handle has timed out. Also figured this out by writing a script and setting it up in a cron job to send a request every minute and send the output to a text file. The result was that the database handle was still alive and I was able to request and receive a proper result. Thanks for your help.
Aye
a notification through a MOTD or channel topic is perfectly suitable consent. "You join this network, here's the rule, don't like it. Disconnect" Blunt, simple to the point. If a person whines, k:line. 
FWIW, there's an alternate logger that's still available: colabti.org/irclogger/irclogger_log/perl6 So while some of the data is indeed gone and the URLs no longer point to exact lines, at least the linked-to conversations can still be accessed in some form.
&gt; I don't see a similar option for the default Map. There isn't one. And above it's not the `:=` (binding operator) that makes it immutable. You already have a `List` on the right hand side. You could equally write `my $a := (2, 3, 4)`. It's just the [the behaviour of storing into the `@` sigiled variables](https://perl6advent.wordpress.com/2017/12/02/) that automatically creates Arrays, even if you're assigning a `List`. There isn't any special syntax for creating a `Map`, but you can equally bind it to a `%`-sigilled var, after constructing it via `.new` method or by coercing a `Hash` or a `List` of `Pair`s to a `Map`: my %h1 := Map.new: (:42foo :70bar); my %h2 := (:42foo :70bar).Map; my %h3 := %some-other-hash.Map;
&gt; The Perl 6 developer who did the same is getting paid by the Perl Foundation. Probably because they're smart enough to notice that your little smear article cobbled together two disparate conversations that happened more than a month apart to pretend like they were one, to weave a false narrative of "racist Perl 6 developers" ignoring your Issues (which, upon investigation, turned out were non-existent) to gather ad clicks for your little blog. Or they know the ["pet ape" reference](https://www.facebook.com/BestInbetweenersMoments/videos/1406927922879338/?video_source=permalink) that existed [for over a century](https://en.wikipedia.org/wiki/Winged_monkeys) isn't a racist slur you're so desperately trying to make it out to be. You're a drama queen, manipulator, and a liar. I neither know nor care what your race is. The fact that you're trying to make race an issue here, I think shows who the real racist is.
&gt;‘consent’ of the data subject means any freely given, specific, informed and unambiguous indication of the data subject’s wishes by which he or she, by a statement or by a clear affirmative action, signifies agreement to the processing of personal data relating to him or her; ([Art 4(11)](https://gdpr-info.eu/art-4-gdpr/)) A MOTD lacks an *unambiguous affirmative action* of the user – they could overlook the message and start typing. Also, withholding service if the user doesn't give consent may be problematic under [Art 7(4)](https://gdpr-info.eu/art-7-gdpr/) unless we argue that logging is strictly necessary for this IRC channel. A notification in a MOTD or channel topic may be sufficient transparency if we base the legitimacy of the logs not on *user consent* ([Art 6(1)(a)](https://gdpr-info.eu/art-6-gdpr/)), but on *public interest* (Art 6(1)(e)) or *legitimate interests* of the controller (Art 6(1)(f)). But those have to clear a higher bar. E.g. public interest probably requires an explicit law, and legitimate interest requires the data controller's interests to be carefully weighed against the rights and freedoms of the user. But then the user can object to further processing ([Art 21](https://gdpr-info.eu/art-21-gdpr/)). And the user can always demand that logs involving them get deleted ([Art 17](https://gdpr-info.eu/art-17-gdpr/)). So there's a lot going on here. All of these problems are not unsolvable, but solving them properly (and with minimum liability) takes a lot of effort. There is no shortcut to compliance, other than stopping all processing of personal data.
Thanks. What I was looking for in particular with Maps is some way to construct a new Map from an old one.
Hacked something together to make `#perl6` log links mappable to the new logger: https://rakudo.party/post/How-To-Make-Old-Perl-6-IRC-Log-Links-Work
Same as what you've done with Lists. Use a slip operator to slip the existing `Map` into the list of extra `Pair` objects you want to add or replace: my %m := Map.new: (:42foo :70bar); my %m2 := (|%m, :50foo, :72meows).Map; dd %m2; # OUTPUT: «Map.new((:bar(70),:foo(50),:meows(72)))␤» For deletion, can't think of anything more concise/performant than going through a temp `Hash` or grepping for keys you don't wnat: my %m := Map.new: (:42foo :70bar :100meow); my %m2 := %m.grep(*.key ne 'foo').Map; dd %m2; # OUTPUT: «Map.new((:bar(70),:meow(100)))␤» Doing it this way is really weird, IMO. You're imposing a constraint of immutability to avoid bugs, but then you wish to mutate the data anyway and create these workarounds (that themselves are a place for bugs to breed). Feels like simply using mutable structures when you want mutable structures is the simpler way out.
Excellent! Although there are several other channels that are gone (forever?) like #mojo. Anyway, in future I would take the approach of just pasting the relevant IRC lines into the commit message rather than using any sort of link.
metacpan favorites have never worked properly for me. i tested the feature when it was first added years ago and have still not to this day been able to unfavorite them.
Have you checked again recently? Some months after it was first added, the entire database of favourites was wiped, so if you tested before that point those should have been cleared... if it's not working, probably best to [raise an issue](https://github.com/metacpan/metacpan-web/issues).
just checked again, same results. was wondering if deleting my account and recreating would help, but was surprised to see no option to allow account deletion. remember hearing lot of work was done for GDPR and thought that was a requirement.
You could also pop a `--rm` in there to automatically remove the container on exit
Is there somewhere the number of times a module is downloaded recorded, or the number of dependants a module has? Would this a reasonably objective metric for qualifying how useful a module is without requiring a user to submit a review?
Modules tend to be downloaded from mirrors and there is no centralised tracking for statistics there. I suspect that's unlikely to change any time soon. Dependencies are indicated by the blue bars in metacpan, see the explanation (and screenshot) in https://blog.urth.org/2017/12/25/swimming-in-the-river-of-cpan/
Sigh, another service going down. Although search.cpan.org and cpanratings.perl.org are not in great shape nowadays anyway so, well.
Another problem that affected me was double ++, because I used to link my GitHub account to a PAUSE ID, and then at one time switched to another PAUSE ID. But this is fixed now I think. Nevertheless, the ++ feature is not a proper replacement for CPAN Ratings.
Yeah, we are really against download stats for some reason (or perhaps are so full of the first virtue). The feature has been requested from time to time since... decades. Repositories of other languages and systems also have mirrors but they maintain download stats.
Hmm, thanks for the post. Keep channel in +m, and then +v anyone who agrees to channel logging via a bot or something of the sort but would be as annoying as "this site uses cookies" banner that was required by the EU but would work. Users then can't partake in channel content and hence moan they are in-logs apart from user/join. What if you based the legitimacy of logs for moderation and educational purposes? "This channel actions channel logging for the following two purposes; one: moderation teams can ensure safety of all users and two: education and shared knowledge share. Log Content has been made available for informational; moderation and educational purposes only? 
Well, with trivial examples it looks absurd. But the point is that I can have functions that take Lists and Maps as inputs that return the same values or when appropriate new Lists and Maps that are immutable. So it's Haskell-style functional derivation of new immutable data from old immutable data. And if I pass %m as an input to a function that returns another immutable Map as an assignment to %n, I can still use %m and %n separately without fearing changes to one messes with the other. 
You need to parse the datetime string into a DateTime object before you can call object methods on it. Look at DateTime::Format::Strptime
Alternatively you can use Date::Parse and create the DateTime object from an epoch: use strict; use warnings; use DateTime; use Date::Parse; my $dt_str = '2010-01-10T10:50:30.000Z' my $dt = DateTime-&gt;from_epoch(epoch =&gt; str2time($dt_str)); print $dt-&gt;ymd('-');
You’re not creating $dt. Strict and warnings are your friends.
He's using strict and warnings. He omitted the initialization of $dt from his snippet, but clearly did do it, as reflected by the error message
Thus demonstrating that these types of sites are rubbish. I’ll stop trying to help.
Thanks I just did something similar. my $parser = DateTime::Format::Strptime-&gt;new(pattern =&gt; '%Y-%m-%d',on_error =&gt; 'croak',); my $dt = $parser-&gt;parse_datetime($dt);` print $dt = $dt-&gt;ymd('-');
Your code is missing where you declared the contents of the $dt object, which seems to have been done incorrectly, as it contains a string and not a DateTime object. Also, your posted use statements are incorrect, keywords in perl are case sensitive and lowercase.
Not really sure what you're getting at. People do this when asking for help anywhere.
You're implying much more intent than likely exists. Anyone can host a CPAN mirror, nobody has successfully persuaded every CPAN mirror to track downloads.
Where they get pointed at a pastebin.
&gt; I think shows who the real racist is This is not a discussion for this subreddit.
&gt; This is not a discussion for this subreddit. No, it isn't. Maybe you should point that out to the person who started it, instead of me.
I'm pointing it out to everyone. Drop it.
Thanks. Dropped.
I think I described that phenomenon frequently in the comp.lang.perl days. I tended to speak Perl with a Lisp accent. :)
The modern version of the "PROM" book is "Intermediate Perl", a title O'Reilly wouldn't let me use for the first edition (long story).
Remember to include the program you were actually running instead of typing it in by hand. Before you can do something with a value you have to turn it into the object that you want. In this case you have to turn the date string that you have into a DateTime object. That module doesn't parse strings so there's an extra step involved: use v5.010; use strict; use warnings; use DateTime; use Date::Parse qw(str2time); # start with your date in a string my $date_string = '2010-01-10T10:50:30.000Z'; # convert that to an epoch time with Date::Parse. This is a single # number my $epoch = str2time($date_string); # construct the DateTime object from the epoch time. The DateTime # module does no parsing. my $dt = DateTime-&gt;from_epoch( epoch =&gt; $epoch ); # Now do your thing with the DateTime object: say 'DateTime: ', $dt-&gt;ymd('-'); # Instead of DateTime you might like the lightweight Time::Moment: use Time::Moment; my $tm = Time::Moment-&gt;from_string( $date_string ); say 'Time::Moment: ', $tm-&gt;strftime( '%Y.%m.%d' ) 
You're implying more seriousness from my post :) I was being half sarcastic. The download stats can also be collected by the client and sent to a central server. cpanm for example at least [send perl version reports](https://weblog.bulknews.net/perl-versions-usage-stats-with-cpanm-89c5f80fe91). Perhaps cpanm or other client has even been collecting stats?
`perl -d`?
- https://metacpan.org/pod/Devel::hdb - https://metacpan.org/pod/Devel::Trepan 
There is a [Pry](https://metacpan.org/pod/Pry) for Perl which is similar to Ruby's. `perl -d` is also available out-of-the-box (see [perldebug](http://perldoc.perl.org/perldebug.html) as well as [Effective Perler](https://www.effectiveperlprogramming.com/2011/11/trace-your-perl-programs/).)
`perl -d` works, but isn't very usable when it comes to showing where you are in the source. If you use Emacs, there's cperl-mode which has a slightly nicer interface to `perl -d` via the standard Emacs debugger.