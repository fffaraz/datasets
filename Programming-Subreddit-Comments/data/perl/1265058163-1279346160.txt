I think I've heard conflicting answers on that over the years (or maybe it changed between major releases?). Anyway, thanks for the clarification. Is it still true that you have to explicitly compile Perl with threads enabled? Or is that the default these days?
&gt; in particular Perl resorts to using sockets and TCP No it doesn't. There is a module (forks) that does this, and which you seem to talk about. That's not the native ithreads implementation though.
I don't remember how 5.005 threads worked, but ithreads in 5.6 have worked this way from the start (on most platforms I know). You do have to compile Perl 5 with threads, though that's often the default compilation strategy for pre-built distributions.
Random thoughts ... &gt; # list context, thanks to print &gt; say reverse $name; Nitpick: "print" is nowhere to be found. I tend to think this would confuse a newbie that didn't know that "`say blah`" is more or less an alias for "`print blah, "\n"`". &gt; my @items = scalar fetch\_something\_awesome(); # scalar context This line is kind of weird. In most books, the comment would call out that it's probably wrong (array -&gt; scalar -&gt; back to array). Any discussion of context should also point out that it's dynamic and depends on the call*er*. foo() may be called in list or scalar context -- it's not an intrinsic part of foo(). &gt; my %values = &gt; ( &gt; # list context, thanks to hash assignment &gt; name =&gt; get_name(), &gt; rank =&gt; get_rank(), &gt; ); get\_name() and get\_rank() being in list context actually confused me for a moment and I had to stop and remember that "=&gt;" is just a fancy comma. I see and use it so much in hash assignments that somehow I'd gotten into the habit of thinking it yielded scalar context on its right side. And yet I've used `foo =&gt; `*[some list]* before, so it was just mildly weird. *Edit*: Markdown
Good points. I've changed the first comment to match the code. I also changed the array assignment to a `push`, which should be much more obvious.
There's also [SD](http://syncwith.us/sd/), it also has git integration.
What? No mention of SDL-Perl?
I love the idea of SP - does one still need to use something like Cygwin to have a real terminal/shell experience (which I know is independent of SP)...
Note: I'm going to update this part with some 20 additional one-liners, a few each week.
I'm an experienced Perl-on-Unix user/developer, but only recently heard of Strawberry Perl. I was curious about why "strawberry"? As near as I can tell (I couldn't find anything "official"; they probably think it's obvious), it's kind of a pun on the "Vanilla Perl" project (and an offshoot of it), and there's also a "Chocolate Perl" distribution (which may predate Strawberry, I dunno). So you have Vanilla, Chocolate, and Strawberry. Hah. I post this to enlighten others if I'm right and invite corrections if I'm wrong. :)
100 Gigabytes on disk for the OS? I have a hard time believing this one. 
A programmer good enough to work on a OS that knows Perl?! No way!
Put it on github
Bah, it wants me to come up with a project name. I hate coming up with names. I will work on that once I get home from work.
perl-asterisk
Microsoft paid ActiveState to make Perl on Windows better.
This week has turned my brain to mush. It is now on github: http://github.com/rrb3942/perl-Asterisk-AMI
That's a complete source checkout, intermediate files (.o), crazy linker output or whatever, etc, etc. The final deliverable is smaller (fits on a DVD) because it throws away most of that.
This is mainly unbelieveable, true or not. And I wish it were true. 
Google's Chromium needs up to 10GB of disk to check out and build, and weighs in at under 50MB shipped. A lot of it is to do with the *massive* test suite.
Thanks for this. The asterisk dialer for my [gtkdial](http://github.com/geocar/gtkdial) uses the asterisk http-interface simply because I didn't want to write what you just did.
Yep, and that is the point. It appeared to me that if someone did want to interface with the AMI they would spend a good amount of time just working on getting the interface to work, rather than working on their application itself.
Last week I wanted to add a small module to CPAN for the first time. I wrote the module and documentation, tested it thoroughly. I figured my first module will be available on CPAN tomorrow - yay! A week later it still isn't there... 1. First it took 6 days for PAUSE id to get approved. So, if you even thinking that _maybe_ one day you'll want to contribute to CAPN - apply for PAUSE ID now :-) Then turns out CPAN is not very Windows friendly. 2. You need to pack your module as .tar.gz. 7-Zip did it in two steps, but I had to install it. I hate installing shit on my PC that I'll only be using once or twice. 3. I takes 3 days! to delete a file from CPAN - wtf? I understand you want to give ppl an option to undelete it, but implement it in such a way that, if I do delete it because I wanted to, I can upload fixed file without having to wait for three days. - first, I forgot to all version to the archive. very few of the "Contributing to cpan" articles mention this, even though it's a widespread practice. so, i figure I fix it... - then I forgot to pack it so it unpacks into a single directory - another thing nobody mentions. when I usually pack something up for myself i only pack contents of a directory. so, I had to bump the version in all files that included it just so the .tar.gz file name is now different, just so I can upload it the same day. finally when I got that fixed... - it failed again, because "The distribution contains the .. world writable directories or files and is therefore considered a security breach and as such not being indexed"................. there's no native way to fix this on Windows or with 7-zip. Only after getting stuck with this I found someone having the same issue and provided Perl solution, but all that is too much shit for submitting 30 lines of potentially useful to someone code. CPAN did provide a "fixed" version of that last issue (the linke worked for only short period of time, but good thing I checked email shortly after submitting and was able to download the file). So, now I'm done fucking with it and just waiting for the files to be deleted from my account so I can upload "fixed" version, hoping it will finally take it. After all that I know what to expect next time, but right now I feel like I don't think I'll be contributing to CPAN anymore. If I write something I think is useful, I'll just dump it somewhere on the web with links to it on some Perl forums - contributing to CPAN should be easier.
You can use .zip to publish modules on CPAN. Or with Module::Build and Archive::Tar you can create .tar.gz without third-party utilities.
I know now. But when I started, no article I found through google mentioned that.
That's okay, if you use zip people will be cursing you behind your back anyway, for having to install Archive::Zip and/or 'unzip' ;) As to the rest... use Dist::Zilla or the Module::Build stuff that Module::Starter generates for you and you don't have to think about it, you just "dzil build" or "Build dist" and you get a proper versioned archive ready to upload. Dist::Zilla takes it one step further: 1. You can dispense with all of the other boilerplate crap too: you just put code in `lib/`, tests in `t/`, and whatever other stuff actually pertains to your work, and dzil can generate MANIFEST and README and Makefile.PL and META.yml, update version numbers, and create `inc/`, all before packing the dist. 2. If you put your PAUSE username and password in a config file, you can even dispense with logging into PAUSE; just use `dzil release` instead of `dzil build`, and it will build, test, upload, and submit for processing.
&gt; but implement it in such a way that, if I do delete it because I wanted to, I can upload fixed file without having to wait for three days. There's no reason at all you can't; just make sure that the new upload doesn't have the same filename. The reason you can't do *that* is because it would fuck up the indexer something good, and it's bad practice anyway -- if you're deleting and reuploading then something must be *different*, so bump the version. It doesn't matter if you didn't make any code changes, someone could have downloaded the broken file while it was up, and when they come to you and ask you why it was broken you should be able to look at it and say "oh, that was v5.001, which is busted. Grab v5.002 off of incoming, will you?"
Fascinating - it's a widely held belief that we'd make better decisions without being emotional. This article turns that on it's head and explains why emotions enable us to make complex decisions that would get hopelessly bogged down in logical deduction.
Is Dist::Zilla now the somewhat preferred best practice? I can't keep up ... is there a canonical place to look to see what the current best-practice modules to use are? I want an opinionated list of recommended modern best-practice modules that I should be using for new development. This way, when someone asks "there's too many choices -- what module should I be using for $foo?", they can be pointed directly to that list. And I can look there too. :) 
It's *my* preferred best practice, it's got a lot of smart people working on it, and it's the first thing that really properly separates the module *authoring* scripts from the module *installing* scripts. It makes my life easier, that's all I can say. :)
 echo 'let perl_extended_vars=1' &gt;&gt; ~/.vimrc
Yes, I agree. It would be good to see more involvement from the Perl community. But I don't see the fact that Perl is so poorly represented as a reflection on the language. Well, not directly, at least. Unpopularity is not the same thing as unsuitability. In the end this a competition testing the ability of the programmers to devise better algorithms, rather than a reflection of the capability of a particular language. Of course there will be people who say "Yah Boo! Python/C++/etc is the winniest! Your language sucks!", but I think it's safe to ignore them. The real reason that Perl is so low down in the rankings is not that it's an inferior language. Rather, it is that so few people use it these days compared to the currently fashionable languages like Python and Ruby that all the new kids on the block are using. It's a shame, but when you're uncool there's little you can do or say to convince the cool kids that you're fun to hang out with. Even if Perl occupied every position in the top 20, you'd still be hearing people saying "Yeah, but Perl sucks, har har". Ho hum. 
In a contest like this, the language doesn't really matter much.
Except that it matters, specially performance-wise. For example dynamically-typed language have a slower nature than statically-typed ones.
Oh, so this contest has a CPU time limit?
Of course. (1 second per move) Update: typo fixed!
Then it's interesting how many Python apps are among the top.
What does that have to do with the lack of Perl apps up there?
It has to do with the CPU time limit. Reread the thread.
I read the thread. It sounds like you're trolling Python instead of focusing on the topic.
What does "trolling python" even mean? If speed is a limiting factor, it is surprising to see dynamic languages as top contenders, as they are obviously lower to execute. Why that statement upsets you, I cannot fathom.
The cookbook is awesome... I think I might try this out for a project I've had in mind for a while!
would like to see a db base session handler.
Indeed, I was thinking of putting one together... will see what I can do :)
You're pretty much right...
(sorry, just checked this) You mean #!/usr/bin/perl ... which isn't supported by Windows, so you DO need to "perl &lt;script&gt;" (but see "perldoc pl2bat" for something that might help)
Has anyone tested it? 
Brilliant! Although I already use Strawberry perl when on Windows, and just install Padre from CPAN. I don't use Moose or Catalyst when writing my code so is there much benefit to using this "professional" version?
&gt; I've long promised to write about the Perl 5 support and deprecation policy and how that affects users. Is this your long-promised kvetch about Perl 5?
No need to wait for Wx/Padre install - Wx compilation it is a long process
No, I've written about that plenty. This is documentation of the current policy, suitable to become *perlsupport.pod*.
Perl itself still compiles and runs on Windows 2000, but then you're asking about distributions so maybe a little further than you want to go.
&gt;There is a terribly tension between those who need stability and those who need new features. I don't have the right answer here, but the problem is not as simple as some would suggest. The solution is a Change Advisory Board and a Declining/Not Permitted List with a policy of "Currently maintained components cannot be more than 2 versions behind the current release" or suchlike. That way, all the old stuff is continually refreshed as a standard maintenance activity, aside from other project work.
ActiveState runs on Win2k. You're not a legend, Win2k is also my favorite system!
There's always cygwin
Usually lasts until team that needs stability claims that they do not have the resources to do an upgrade now, and btw. their app makes a ton of money for the company. I'm just an admin so I don't build web apps. But my scripts/apps often have to run on a large collection of servers. Just finished a script today and it had to work on perl 5.005_03, core libraries only. I'm quite envious when he writes that his libraries are a year old... We even have servers that only have perl4... 
See, that's the thing about moving it from projects to maintenance. The team that needs stability will *have to* allocate the resources, if not this budget, the next budget. Upgrades need to be planned, and executed in test environments first. If the managers *can't* budget and plan for needed maintenance, then *there's* your problem. If you wanna play in the big leagues, you gotta play the game as it's played in the big leagues.
I have found less than satisfactory problems with perl on cygwin. 
Impressed. On my macbook with CPAN installed via local::lib getting a Mojo hello world up is; cd ~/bin &amp;&amp; wget http://bit.ly/cpanm &amp;&amp; chmod +x cpanm &amp;&amp; cpanm install Mojo cd /tmp &amp;&amp; wget http://pastie.org/pastes/835984/download -O hw.pl &amp;&amp; chmod +x hw.pl &amp;&amp; ./hw.pl daemon Mojo hello world now running on port 3000
I don't know what you mean by big league, profit in 2008 was over 7 billion USD. My comment is really about who has the power in a company, it may be different in a software company, but the company I work in is not a software company. The real power is often in the business side. The different business units "controls" the app teams that support them, and the more important the business unit, the more power to the app team supporting it. Audit/risk/advisory boards have power if there is laws backing them up, otherwise the power is where the money is. Bitter? Nah... 
If you don't need the XS part of it, use Module::Starter to start modules, not h2xs.
It took a long time, but I'm really happy to see someone finally made a sane CPAN client. Beautiful.
This looks like a nice step forward. Is there any way to configure it to always use local::lib by default? Also, sounds like a great way to identify modules exhibiting those "nasty edge cases" so that the author/maintainer can be contacted to let them know about the problem. 
Really, Mr. Lester... $ module-starter My::Module (useless garbage) $ module-starter --module My::Module Must specify an author at /Library/Perl/5.10.0/Module/Starter/App.pm line 104 Why is this useful? 
I haven't looked at the internals of CPAN.pm and CPANPLUS, but to be fair, my guess is that they are probably rather large and complex because of all the edge cases they handle. It could be that the reason something like cpanminus can even happen at all is because more and more packages are adhering to modern packaging conventions these days, but I don't have any numbers to back that up. 
For now, if you've already installed local::lib and sourced the shell rc, cpanm just uses those configurations by default so you don't have to do anything. And yes, I'm working on with local::lib developers to automatically bootstrap local::lib in the initial launch if you haven't configured it and you don't have a write access to sitelib (i.e you're non-root). Stay tuned.
Yes, I don't have an exact number either, but i'm pretty sure 99% of the recently updated modules on CPAN can be installed using cpanminus because they're packed in the sane way. And yes, to be fair, the code to handle the rest 1% edge cases (and ancient packages) would have made CPAN.pm/CPANPLUS code unnecessarily complicated.
The non-troll who works with the tool and iterates through the process and specifies an author and email address will be left with a working fairly modern skeleton of a module distribution. The troll will simply throw up an annoyance and pretend that there is no value beyond.
I think there's more to it. Why is CPAN trying to use external programs for `gzip`, `tar` and `ftp`, which are inherently not portable? A lot of installation problems with modules on Windows are due to diverging behavior of one (or more) of these programs. Just use Perl modules instead, just like it can, and those problems go away.
&gt; external programs for gzip, tar and ftp, which are inherently not portable Those programs are ubiquitous and there are excellent free software implementations of them all, so, I'd say that they're quite portable indeed. 
Yes cpanminus tries to load pure perl modules first, (some of them are fortunately core in 5.10 thanks to CPANPLUS) and falls back to tar, wget etc. I have a plan to embed HTTP::Lite and stuff for the environment without those at all, as well. For now, I have been hearing many success reports from Win32 users if they have LWP or wget.exe etc. They're the only requirements in addition to core perl. BTW there's a benefit of using external programs when available: less memory usage than to untar archives, for instance, using Archive::Tar. It's often a source of OOM/thrashing on 256MB VPS. For that reason cpanminus tries to use 'tar' executable first rather than the perl implementation if possible.
Ah but Archive::Tar was notorious for loading the *entire* archive into memory. I don't know if it still does that in newer versions, but it really shouldn't. For the normal case (not compressed), it should use the tar archive as the source and not be afraid to possibly read it several times over, using `seek` to get access to specific parts. 
There are uncompressed tar archives on CPAN. Usually they are .tar.gz - this means that whole file will be read into memory.
My problems with cpan don't have anything to do with packaging conventions. Here are some things that have happened to me when using cpan, in the past: - I tried to install something, cpan had never been run on the machine, and I didn't know the answer to any of the dozens of questions it asks during setup, and didn't know how to avoid those questions (this was before it had a mode where it would try to guess most stuff, or before I knew such a mode existed...though even that fails in embarrassingly many cases, in my experience). I gave up. - I tried to install something using cpan, and it began installing dozens of dependencies, eventually going all the way down to upgrading cpan itself, which led to upgrading Perl! Obviously, this was disastrous, and I had no idea what was happening. It also didn't actually install the module I had set out to install several hours before. I gave up. - I tried to install a module on a system that wasn't mine. cpan had never been configured. I'd already learned my lesson about configuring cpan in the past...I gave up. I don't know how much of this has improved in the past few years. These days, if there isn't an RPM or deb in a yum or apt-get repo of the module, I either build a package from the tarball and drop it into my companies software repository, or I give up. I'm simply too afraid of cpan to even use it. That might mean I'm just too stupid to be allowed to use Perl...but I've been misusing Perl for 15 years, and I guess I'll keep doing it for the foreseeable future. But, cpan has taught me not to even bother with it if I can possibly avoid it.
It's not just you; CPAN can be fiddly. cpanminus attempts to fix the first (and will likely soon fix the third, through the use of local::lib). The second was a bug (I believe) in the Perl 5.6.0 or 5.6.1 timespan and hasn't occurred for several years.
So (1) a name and email address are mandatory parts of a Perl module, and (2) there's no way to provide sensible defaults (hint: "A. U. Thor" and "email@example.com" work)?
1) Yes, 2) patches welcome, and 3) it's still better than h2xs.
Not that I expect it to be applied, but... diff -u /Library/Perl/5.10.0/Module/Starter/Simple.pm /private/tmp/buffer-content-156lDQ --- /Library/Perl/5.10.0/Module/Starter/Simple.pm 2009-07-27 00:24:34.000000000 -0600 +++ /private/tmp/buffer-content-156lDQ 2010-02-23 09:59:21.000000000 -0700 @@ -55,8 +55,8 @@ croak "Invalid module name: $_" unless /\A[a-z_]\w*(?:::[\w]+)*\Z/i; } - croak "Must specify an author\n" unless $self-&gt;{author}; - croak "Must specify an email address\n" unless $self-&gt;{email}; + $self-&gt;{author} = 'A. U. Thor' unless $self-&gt;{author}; + $self-&gt;{email} = 'email@example.com' unless $self-&gt;{email}; ($self-&gt;{email_obfuscated} = $self-&gt;{email}) =~ s/@/ at /; $self-&gt;{license} ||= 'perl'; Diff finished. Tue Feb 23 09:59:21 2010 EDIT: This incredibly complicated use of `grep` makes me think that "patches welcome" is an alternative spelling of "fuck you," not a request for patches. 
A. U. Thor is one of the reasons that I require author to be specified in Module::Starter. It is not a "sensible default." It is a default that is in all cases incorrect. The same is true of email@example.com. If you have some other way to find the author name and email address, that could be interesting. 
So someone wanting to donate code needs to make up a string called "name" and another called "email" because... what? The stupid, it burns...
[Indigo Perl](http://www.indigostar.com/indigoampp.php) also can run on Windows 2000.
&gt; we where able to get a working version on 64bit and Mac. Yay! 
Yay indeed!
Offtopic, but any chance you can make a guess as to how far along parrotSDL will be when Rakudo Star is released (April 2010)? Do you expect parrotSDL to be the canonical Perl 6 SDL binding? Do you know of any other Perl 6 SDL bindings in the works? 
I have started some work on parrotSDL. http://github.com/kthakore/parrotSDL The major problem is that NCI is due for a huge redesign to get threaded callbacks working. So here is the plan I have in mind now: * add configure boiler plate to find libs, and image files * make demos work * move back into core * help get NCI redesign done * make a real plumage module * parrotSDL 0.01 -&gt; * modular design, Video|Audio|.. so on * two layers |low level NCI binding |higher level sugar PIR/NPQ | As you can see it depends hugely on when the NCI bindings will be looked at by parrot devs (mr_chromatic can guess). If it is before April. I can get real far in a few months as parrot NCI is a lot easier then XS on perl5. Also the more parrotdevs flock to this project the faster we will be able to give something of value to rakudo*. But by my estimate you will have simple video capabilities a month of after the redesign. I don't know if parrotSDL will be *the* canonical Perl 6 SDL binding. I will try to get it there for sure. Also I haven't seen other perl6 bindings for SDL. If anyone finds any let me know I will go help or get them on parrotSDL. I just want this done don't care whose library does it ;) EDIT: Also now it seems the threaded system on parrot needs work too. But the good news is SDL only needs threads in a few places like timers , event filter and audiospec. So we can still have something usable.
Thanks for the detailed info and all the hard work, Kartik! 
&gt; As you can see it depends hugely on when the NCI bindings will be looked at by parrot devs.... That seems unlikely to me, unless one or two people appear with that as a big priority. We have two other priorities for Rakudo Star: a revision to the Parrot calling conventions and an improved garbage collector. Even so, you can't predict what volunteers will do.
&gt; someone wanting to donate code needs to make up a string called "name" and another called "email" because... ... PAUSE uses them to organize modules on the CPAN.
Make sense. So what was the discussion here referring to? http://irclog.perlgeek.de/parrot/2010-02-20#i_2012537 Should I go ahead and start using NCI as is now for the redesign?
We'll get to the redesign at some point in the near future, but it's not a project-wide priority through April. Go ahead with it now; most things will work and we'll help you migrate the bindings as we change them.
&gt; die "###ERROR### Building from sources not supported on MS Windows platform"; :(
Really? I thought PAUSE used a PAUSE ID (an arbitrary string), and only needed that when you tried to upload something to CPAN. How is that related to requiring two unrelated strings when you create a module? EDIT: Anyways, I'm not sure someone who insists on being called "chromatic-with-a-lower-case-c" has a leg to stand on here.
&gt; Anyways, I'm not sure someone who insists on being called "chromatic-with-a-lower-case-c" has a leg to stand on here. We both know that's a non sequitur.
please get the built binaries selection 1. Building from sources is insane on windows. [1] Use: Binaries Win/32bit SDL-1.2.13 + gfx,image,mixer,net,smpeg,ttf
Well that is good news! Thanks
about getting shit done, I have a text file with 123179 lines that needed to be analyzed, I put together a perl program this morning, and got the analysis done in an hours time. I am fairly new to Perl but I love it more daily.
I've written a more featureful init script that handles things like checking whether the app compiles before restarting it, `local::lib`, and some LSB-targeted improvements. As a bonus, it works just as well for a non-root user wanting to manage an app running an app under their own account, just by leaving blank the config lines for the user to run as. It lives [on the Catalyst wiki](http://dev.catalystframework.org/wiki/deployment/fcgi-init) and [on GitHub](http://github.com/arodland/cat-fcgi-init).
Thanks will try this out.
good luck. Also #sdl irc.perl.org or sdl-devel@perl.org if you need help.
[CPAN](http://www.hexten.net/cpan-faces/)? :)
It's spelled 'Perl'. The interpreter is called 'perl' Command line arguments are stored in an array ( @ARGV ) ( where the '@' sign is a 'sigil' denoting the variable's type. N.B.: In variable usage, sigils can represent the expected output. e.g.: The @ARGV array has elements $ARGV[0] $ARGV[1] ( because the data value stored in that slot in the array is a scalar. ) .... SO.... Just pick up the additional command line arguments from @ARGV.
I do bioinformatics too (one year left to get my grade as bioinformatics engineer), all I can tell you about how to learn perl is use google!, lol, after some searches for examples you will learn the stuff and will be able to use it in your own problems, of course there are many books about perl worth of reading :), also try to read some of bioperl when you get time after learning some perl, is really usefull for working with bioinformatics (speaking about sequences mostly) for your arguments problem you already got the answer from mikelieman... for the first one i found this: [Example](http://perl.about.com/od/programmingperl/qt/perlsubstr.htm) for the second one you can use what mikelieman wrote plus the link I gave you for the third one i'd like to see the example :P hope this helps anyway...
[StackOverflow](http://stackoverflow.com) is very good site for questions. You might al want to try the [Beginner Perl mailing list](http://lists.perl.org/list/beginners.html). Perl comes with commandline documentation, so you can type perldoc -f substr to get the docs for the substr function. I would also suggest taking a look at [Learning Perl](http://oreilly.com/catalog/9780596520113/) and possibly [Beginning Perl for Bioinformatics](http://oreilly.com/catalog/9780596000806/) (I have never read this book, so I don't know how good it is).
It's also convenient to get multiple args at once: my ($arg1, $arg2, $arg3) = @ARGV;
Seriously, whoever the hell names those text files is a fucking moron. Yeah they're almost readable. Oh wait. ------ Anyway... you'll want to look at the [online perldoc](http://perldoc.perl.org/perl.html) site when you're trying to get info on a particular command (like [substr](http://perldoc.perl.org/functions/substr.html)). In terms of the hash, think of it like an index for information. So say you get your "common key" or whatever for each piece of information. To assign to the hash you need scalar context ($ sigil). my %hash; $hash{ $common_key } = $information; The thing to note is that "$information" can be either a scalar or even an array/hash ref! So if there are multiple pieces of information you can still store all of them to the same hash key like so: push @{ $hash{ $common_key } }, $information; You'll notice that you have to tell Perl that `$hash{ $common_key }` is pointing to an array ref by wrapping it in the array sigil '@' and some braces. After you've stored all of your information, you can easily iterate over all of the elements in the hash and print them. for my $key (keys %hash) { my $information = $hash{ $key }; # Best to use printf here to join the pieces of information and still use a newline printf( "%s\n", join "\t", ($key, $information) ); # Or you could do it the "easy" way #print "$key\t$information\n"; # But that isn't very pragmatic } Above all, always include this in your scripts!!! use strict; use warnings;
What school do you go to that offers an engineering degree on bioinformatics? Im considering doing a phd but am having second thoughts about being a scientist I like making things. 
Not mentioned so far: perlmonks.org is a very good site for questions. Take the time to search, show what you've tried, and you'll get tons of help. You may want to start searching for "bioinformatics" to see what other questions have been asked and answered.
[This](http://www.perlmonks.org/?node_id=821858) is a good article to start reading at Perlmonks.org (which has been an invaluable resource to me as well when I was studying bioinformatics. I even mentioned them in the acknowledgments section of my Masters thesis). 
Beginning Perl for Bioinformatics by James Tisdall seems about right for you. It is out of date (2001) but it introduces general programming concepts and syntax before leading you through the processing of fasta and other common formats. Here are a few mirrors: http://superkuh.ath.cx/users/superkuh/Library/000-Bio%20And%20Chemistry/000-Biotechnology%20and%20Bioinformatics/Beginning%20Perl%20for%20Bioinformatics.pdf http://ifile.it/hxw49t/j.tisdall_-_beginning_perl_for_bioinformatics.rar And more advanced: http://superkuh.ath.cx/users/superkuh/Library/000-Bio%20And%20Chemistry/000-Biotechnology%20and%20Bioinformatics/eBook.OReilly.-.Mastering.Perl.for.Bioinformatics.ShareReactor.pdf
Or, if you want to make your life a bit simpler, go to CPAN and get [GetOpt::Long.](http://search.cpan.org/~jv/Getopt-Long-2.38/lib/Getopt/Long.pm)
There's even a game with the CPAN faces: [pexeso](http://search.cpan.org/perldoc?Game::Pexeso).
&gt; I have found less than satisfactory problems with perl on cygwin. I believe that the problems with Perl on Cygwin are now completely satisfactory.
OK I will try it again. I had a specific problem so i will report back.
I know University of Texas at Dallas has a master's degree in bioinformatics. I'm not sure what they offer phd-wise though.
Sorry, I was being a smart-ass and picking on your language, rather than being helpful. I meant (on the basis of no experience on my part) that there were plenty of problems, and that therefore the problems were satisfactory; not that the results were satisfactory.
So one of the things you will find helpful is using Perl in Windows. Download it from [www.activestate,com ](http://www.activestate.com/activeperl/downloads/) The main reason for this is you wont have to learn vi or emacs as an editor. Now you probably SHOULD learn vi or emacs (learn vi), but it sounds like you are under the gun and need to get an assignment out. I recommend using [Notepad++](http://notepad-plus.sourceforge.net/uk/download.php) for a good text editor in windows. Secondly, check out the following sites for help with syntax: [perlmonks.org](http://www.perlmonks.org) [stack overflow](http://www.stackoverflow.org) [perl guru beginner forum](http://perlguru.com/gforum.cgi?forum=2;guest=) Thirdly, pick up the [llama book](http://www.perl.com/pub/a/2000/10/begperl1.html) And the [tadpole book](http://www.megaupload.com/?d=Z0B9MUWN) Good luck. Bioinformatics is fascinating to me. Is it a good career choice? What are the salary ranges?
i'll reply later to this, we have a serious earthquake situation over here :S
Very cool, Thanks. If the might of a developer community is measured by the number of beards (and I'm pretty certain it is), then Perl is second only to Common Lisp. :) Also, I hereby award the following CPAN faces awards: * best beard: [cowens](http://search.cpan.org/~cowens/) * bluesiest: [dcantrell](http://search.cpan.org/~dcantrell/) * most likely to face the "The Lone Biker of the Apocalypse": [ejs](http://search.cpan.org/~ejs/) * most wizardly: [herveus](http://search.cpan.org/~herveus/) * classiest moustache: [jcnorton](http://search.cpan.org/~jcnorton/) BTW, what is it that [miyagawa](http://search.cpan.org/~miyagawa/), [nobjas](http://search.cpan.org/~nobjas/), and [yappo](http://search.cpan.org/~yappo/) are holding in front of their faces? 
If you can understand the biology behind the programming then you can make a lot of money off of it. One of the guys in my program makes Perl scripts that he sells for a good bit of money; he doesn't even have a PhD yet. I would say that if you were a good programmer you could understand bioinformatics fairly well.
Yeah ... I need to work on context in how I write.
It is nice to finally receive the recognition that my facial follicles deserve.
Ask nicely, and I'll try to explain this one to you. PS: "You dissed me" bans are the last refuge of someone with no argument but lots of (at least in one forum) online power.
As for how this works, first notice that Perl regular expressions are much more powerful than traditional regular expressions: you can, for example, execute Perl code inside a regular expression, allowing you to solve problems once thought "impossible" to solve with regexps, such as matching arbitrarily deeply nested parents ... or executing a complete 99 bottle of beer program inside a regexp. :-) Second, notice that dynamic languages (such as Perl and many others) allow you to build a code string from an expression, then compile and execute it on the fly. In this case, the rather long expression is a series of bit-twiddling operations joined together with the string concat operator (.) producing a 99 bottle of beer program string. BTW, as this is a constant expression, the Perl parser sees it more clearly than the human reader.
Original script: use Acme::EyeDrops qw(sightly get_eye_string hjoin_shapes); my $ninety_nine = &lt;&lt;'BURP'; $==pop||99;--$=;sub _{($;=($=||No)." bottle"."s"x!!--$=." of beer")." on the wall"} print+_,", $;! Take one down, pass it around, ",_,"! "while++$= BURP chop($ninety_nine); $ninety_nine =~ s/\nprint/print/; print sightly( { Regex =&gt; 1, Compact =&gt; 1, ShapeString =&gt; hjoin_shapes(2, (get_eye_string('bottle2'))x6), SourceString =&gt; $ninety_nine } );
This is why I'm afraid to learn Perl.
this is why I want to learn Perl.
Indent four spaces.
More succinct explanation of how this works: [Acme::EyeDrops](http://search.cpan.org/perldoc/Acme::EyeDrops).
You mean two, dear sir.
This is why I love Perl.
What do you guys think? I know I would find it useful; one of the first things I did when learning dbix-class and catalyst was to watch the presentations up on shadowcat so I could at least begin to understand the progression of thought that went into them. Edit: Here is the direct link to the presentations: http://www.presentingperl.org/ I personally can't wait to see this thing fill up...
I'm in Chile, my university is University of Talca and they started offering the career since 2003, it's the only one in Chile, and I think it was the one of the first ones in south america with brazil.
I'm not sure why it needs a separate site. Why not use something like slideshare and just have a community effort to organize and place content there.
slideshare is limited to slides, youtube to videos, etc.
I think its a good idea. Make sure to support as much sites to embed from. Add tags for filtering/categorization. Add search. Keep it Perl, minimize off-topic content. Change to UTF-8 to allow multilingual content (description, comments, etc). Get those comments done... A lot of work ahead :-)
For those of us who live too far away from where the action happens, this is nothing short of awesome. I'm looking forward to "virtually" attending the upcoming YAPC::NA and the rest of conferences and workshops that will follow. community++
My friends, you should consider using ` on either side of the code.
I ran this program and it sunk my battleship. Who do I complain to?
[google should tell](http://www.google.com/search?hl=en&amp;q=what+is+miyagawa+holding+in+his+avatar)
Isn't this duplicating the (seemingly dead) yapc.tv site?
I appreciate and agree with the sentiment of your comment, but the big league game seems to be one of "If it isn't broke enough, don't fix it." Code bases are huge and brittle, relying on hacks and outdated library/language versions. When somebody gets enough political momentum to start a project in a new version of language X, it will run right alongside earlier projects which run on older versions. When enough teams get the momentum to upgrade old projects, the house of cards which make up the old project comes tumbling down and half the time the upgrade never happens. Even worse: rather than being honest and saying "Yeah we wrote some crappy code in year yyyy," the language itself gets blamed and somebody mandates that the next round of projects will be written in an entirely new language. Naturally the old, non-upgraded projects will continue limping along in the background, running on the blackest of magic and foulest of expletives. Employee turnover has churned enough by this point that there is not a sufficient skill pool to maintain the legacy code, let alone add new features or refactor the existing features. Contractors are hired for legacy maintenance. Although they *may* have sufficient language knowledge to do their job, tribal knowledge related to the old code has long since been diluted by employee churn. Tiny things get fixed at a disproportionately high cost. Yet the company surprisingly continues to profit, thanks to a combination of new features - probably implemented in language Z, by this point - and clever marketing. The shareholders are content. Everything is working well enough, so there's really no sense in rocking that boat. We'll get around to the upgrade when we have the resources leftover from adding the next features. Meanwhile that old code sits in some forgotten server room. Ancient. Angry. Waiting. At least, that's how the game gets played in the bigger leagues that I've seen.
What problems does cpanminus solve? I had no problem installing softeware with old clients..
Originally, installing CPAN modules with very low RAM requirements.
Perhaps not problems you personally have had, but problems that the maintainers have in maintaining the old clients? 
I'd rather finally see a feature (plugin?) to *remove* modules
[The doc](http://search.cpan.org/~miyagawa/App-cpanminus-0.9913/lib/App/cpanminus.pm#But_why_a_new_client?) have all the reasonings i wanted to say. If you have no problems installing with old clients, then there's no reason to switch to :)
I read the docs a few hours ago, now I'm reading the source code. I always thought that the old CPAN client are robust enought, so there's no need for improvement. OTOH, it's good to question all the premises we're working under, I think..
Right, it's not the "robustness" that cpanminus is trying to improve :)
jobs.perl.org has two job openings in Ottowa listed, http://jobs.perl.org/job/11650 and http://jobs.perl.org/job/11622.
Thanks for the links, but they appear to be in Toronto, not in Ottawa.
have you looked for telecommute jobs? I know that my employer is looking to hire one highly-experienced Perl dev for a 100% telecommute position. There are many others. If you want to find Perl jobs, get involved in the Perl community. That's how I've found every single job I've had in the past 10 years.
Anyone wanting to move to Flagstaff, AZ? I'm looking for a talented Perl coder now. [Jobs](https://www.norchemlab.com/main/careers.pl)
You might want to try out odesk.com if you're interested in telecommute jobs.
I love perl but this is actually a task that's pretty easily done with only bits in POSIX: cut -d' ' -f1 access.log | sort | uniq -c | sort -nr | head -n 10 
How may I find more information about your employer's requirements?
Indeed. And if one were to find himself on a system without `cut`, one can use good-ol' `[g]awk` to the same effect: awk '{print $1}' &lt; /path/to/access.log | sort | uniq -c | sort -nr | head
email me at rob *dot* kinyon *at* gmail *dot* com and i'll send it to you.
I need to use the awk &lt; file syntax more. I've always used the cat file | awk.
I always forget that awk is specced in POSIX. Good call.
I'm so glad that the effects of ironman are reaching far and wide. Good job ironman participants! 
I was curious as to the performance implications of doing it this way vs doing it the way the OP did: Using the POSIX toolchain for this is nearly 4X faster. :O Poking at the reasons for this, it appears that building the hash is the bottleneck. Replacing the hash assignment with a simple counter incrementing (effectively counting lines instead) made it run 8X faster than before.
I get a feeling that it depends on the number of lines you're counting. The POSIX version does a full sort on the list of IP addresses before passing it to uniq, which is more work than is strictly necessary to count them. With a large number of lines that would probably show up as a problem.
I ran it on 1.88 million lines of log for my testing.
`cpanp -u Module`
I'm not entirely convinced by requiring 100% test coverage. A mix of testing and code review seems like it would be a better combination. Testing alone will never catch all your bugs.
I was going to suggest StackOverflow as well.
I already have the code to uninstall modules from the .packlist. it's in the plan to add --uninstall command to cpanminus as a core command, hopefully soon :)
Let me guess, ummmm, windows?
You guessed... poorly.
Why guess? The answer is a click away.
Ok, CPAN doesn't provide "integration of separate components managed by separate maintainers with wildly disparate ideas of the semantics of change over indeterminate periods of time" Does that sum it up? How are people approaching this problem? Has anyone attempted a solution to allow us "to know which versions of which distributions work together, and for end users to be able to download a known-working graph of their desired distribution and its dependencies."?
Module::Install (and a couple of other projects) bundle some of the compile-time dependencies into distributions themselves. This has advantages and disadvantages. PAR allows you to bundle an entire application into a single distributable archive, though it has its limitations. (Mostly it's poorly behaved modules which play with the include path.) I haven't used Shipwright, but I understand that it can group a single application and its dependencies into an installable bundle. None of these solve the problem that Perl 5 and the CPAN assume that a distribution with a greater version number than that requested is always sufficient to meet a dependency.
Wow, thanks to all for the valuable input :-)
I agree heavily. Why upload an entire app that's specific to your case when you can put the core logic into a module and others can extend that to what's useful to them?!?
You don't have to choose between one or the other. [App::Ack](http://search.cpan.org/perldoc?App::Ack) is a good example; you get the modules for the reusable core behavior as well as the CLI program which almost all users will use unmodified.
Are you sure? I wasn't aware that it had an API I could use in my programs. I had asked for that a long time ago, but Andy said "no", fearing that it would slow things down.
Sort of an API anyway... it's not what I would write if I were writing a generic backend for that sort of thing.
Over the years my Perl scripts have got shorter and shorter as I've moved towards this kind of architecture. Here's one I wrote yesterday. use Badger lib =&gt; '../../perl/lib'; use CR; CR-&gt;daily_cleaner # returns a CR::Cleaner::Daily object, not that it matters -&gt;config_args(@ARGV) -&gt;clean_all; A little later I wrote a web front end to the same app: sub clean_daily_action { my $self = shift; return $self-&gt;present( daily_cleaner =&gt; $self -&gt;CR -&gt;daily_cleaner -&gt;config_params( $self-&gt;params ) -&gt;clean_all ); } The cleaner object cleans old records out of the database, but that's not important. It's just some chunk of functionality that I want to invoke for this particular project. This kind of high-level re-use is undoubtedly a good thing. Even though I'm using the core behaviour unmodified in both cases, the benefit of being able to deploy it either as a command line script or via a web front-end, is invaluable. So to me it's a no-brainer. Why write a script that you can *only* deploy as a script when you can write a module that you can deploy anywhere and a wafer-thin wrapper script to run it. *modul*e == *modul*arity
Does anyone know where I could find a version for Win32 ActivePerl Build 822?
Thanks for the heads up about gitpan - I just forked SNMP::MIB::Compiler, w00t. That thing wouldn't compile several standard Cisco MIBs without some workarounds/bug fixes. Only 10+ years since the last update on it, haha.
&gt; Why the hell can I use chomp $input or chomp($input) but I must use scalar(@array) instead of scalar @array) Different routines have different calling syntax. Any of the O'Reilly books are good.
Different languages have different nuances. More complete answer to your question, though, is that 'scalar' is an operator not a function. Take a look here for an explanation : http://perldoc.perl.org/functions/scalar.html
What's even more: `scalar @array` works too. Unless the parser gets confused by the *rest* of your code (due to precedence rules), that is.
You can write either of: scalar(@array) or scalar @array In most cases the parenthesis are optional. You only need them when things become ambiguous. For example: scalar @foo, @bar # FAIL! DON'T DO THIS is the same as scalar(@foo, @bar) # FAIL! I SUCK :-( ** EDIT: the above is incorrect - see [cowens' reply below](http://www.reddit.com/r/perl/comments/bi8mu/need_help_on_learning_perl/c0mwfss). I'll leave it here for posterity so everyone can be reminded how important it is to always test your code before making claims. ** So if you wanted to call a function passing the size of the array followed by the elements of the array then you would write: foo(scalar(@foo), @bar) and not foo(scalar @foo, @bar) which is the same as: foo( scalar(@foo, @bar) ) # FAIL! NO IT'S NOT - IT'S THE SAME AS THE FIRST EXAMPLE So the general rule is that function calls without parens will greedily gobble up arguments. Use parens to be explicit. 
The point is to allow for the most convenient syntax for a particular purpose. There's no use in forcing everything into the same straightjacket, even when it doesn't make sense.
You chose the wrong language to learn. As legend has it Perl is the language of gods. Therefore learning this language is not a common task, it's as pointless as a religion, it's completely useless , it is a task comparable with a journey, it's a way of life, a je-ne-sais-quoi if you will :P The point I'm trying to make is that you will waste tremendous amounts of time trying to learn what you would otherwise learn much more efficiently for your future career by picking a language such as Python or C++. I do not know who fooled you into making such a gargantuan mistake as learning Perl but I wish all the worst to that particular person(I wish he will die spiked while he is sitting on a toilet seat, or that someone hangs fishing needles from the ceiling of his room and he enters the room unsuspecting of what's about to happen). [so yes I will down vote your question]
See http://learn.perl.org.
my ass .. it's because the language is so "epic" that it's syntax hasn't change to something normal ...
Just always use parenthesis. After you get used to everything else, you might decide to leave them off sometimes for readability.
If you want to master more languages, I would try learning languages of different paradigms. These are just examples (there are others): C for procedural, Java for OO, and Lisp for recursive. One thing to note is that there is probably more work involved with understanding the nuances of the paradigms than in learning the syntax of the these languages. I would probably describe Perl as a working language not a learning language. As you have discovered, its syntax is diverse to say the least. Now if you actually have something you need to do in Perl. I would recommend two O'Reilly books: *Programming Perl* and the *Perl Cookbook*. Some people don't like the cookbook because it presents solutions with very little discussion of how/why and it consistently references packages that need to be downloaded/installed from [CPAN](http://www.cpan.org/). But if you are trying to quickly accomplish a certain task with a Perl script, it can quickly lead you to a working solution.
scalar @a, @b is not the same as scalar(@a, @b). This code perl -le '@a = "a" .. "c"; @b = "d" .. "h"; print scalar @a, @b' prints "3defgh\n". This is because scalar is a unary function (i.e. it takes only one argument). This means it will only operate on @a (thereby putting @a in scalar context which yields 3). The rest of the arguments are passed to print. Normally, passing two arguments to a unary function will yield an error: perl -le 'ord("a", "b")' Too many arguments for ord at -e line 1, at end of line Execution of -e aborted due to compilation errors. But scalar is different. This is because it is not so much a function as a context. When scalar is given a list, it provides void context to each item in the list up to the last, which it gives scalar context. The practical upshot of this is that perl -le '@a = "a" .. "c"; @b = "d" .. "h"; print scalar(@a, @b)' prints 5 (the number of elements in @b). Note, I have been using Perl professionally for ten years now and I would have expected it to throw the same sort of error that ord does.I was originally going to post that point and then thought I should test it first. When it comes to Perl, you should always test your code before making claims. 
Perl is really easy to learn - you just need to know programming.
If it can't be done in Perl, it can't be done.
&gt; When it comes to Perl, you should always test your code before making claims. ... or read the fine manual. From `perldoc -f scalar`: Because "scalar" is unary operator, if you accidentally use for EXPR a parenthesized list, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.
Because it makes things like this work: print "This is a random number between 0 and (less than) 6:", rand 6, "\n"; The parser knows that rand will only ever take one argument, so it hands 6 to the rand and "\n" to print.
Congrats ;)
My list is: * some assembler (I don't care what architecture) to get the feel of a raw machine * ANSI C because it is ubiquitous and important to understanding UNIX and POSIX-like OSes * Java, C++, C#, Objective C, or Go to learn the basics of OO in a statically typed environment * Python, Ruby, or Perl to learn about dynamically type environments * Haskell to learn about pure Functional languages * Common Lisp, Scheme, or Clojure to learn about true flexibility * Prolog to learn declarative style * Forth to learn about stack based style
I think I found a bug... everything was going fine and suddenly it bit my sister. 
You just need to be a good software person to be able to roll with Perl. For every application I've written in another language there have been multiple moments where I've gone "FUCK I wish I could be writing this in Perl". Learn a bit about the language and you'll understand why.
It's an arbitrary designation, but I'm happy. "1.00" just has a nice ring to it when talking about software.
omg I like the fact that it's 1.0 now I can bitch all I want if I find bugs and I'm sure if I spend very little time nitpicking I will find one ! 1.00 means "COMPLETE" in an ideal world of software development.
I stand corrected. &gt; Note, I have been using Perl professionally for ten years now [...] you should always test your code before making claims. I too have been using Perl professionally for, well, a fair bit more than ten years now, and I'm not only surprised at this weird behaviour, but also humbled. You're absolutely right, both in your evaluation of how scalar() works, and in stating that one should **always test your code before making claims**. This example lends some support the OP's claim that Perl is full of weird things just waiting to catch you out. Yes, it is. But that said, in 15 or so years of using Perl, I've never been caught out by this particular weirdness. Intuitively scalar feels like it should be a list operator, but it's not. Ho hum. You live and learn. My general rule is to always use parenthesis unless there's just one argument and the code is clearly unambiguous. 
&gt; Intuitively scalar feels like it should be a list operator, but it's not. I disagree; it makes sense to me that it has the equivalent of a `($)` prototype.
It's open source... When you bitch about finding a bug, the overwhelming response is, "*Where's your patch?*"
Nobody pays me to patch open source software. The grand benvolence or kindness that is apparent in open source is mostly fake as the people who send patches most likely use the software at work so they get compensated for their work(it is the public release of the patches that probably is the only **true** part of the *kindness*). Would you not agree mickey ?
If you are using Moose at work, then consider patching Moose a part of your work. If you are not using Moose at work, then why would you expect to be paid for patching it? Because other people do get paid by patching it? Well, it's called having a job. Get one, get paid. That said, if the options are: 1) have the bug correctly reported, or 2) not have the bug reported at all due to a lack of a patch from the submitter, I've rather have option 1. So please do submit any bugs that you find, I'm sure it will be appreciated.
Reporting bugs is part of a profession. It's called [Software Tester](http://en.wikipedia.org/wiki/Software_testing) , that is actual work, people get paid for that. I'm sure that 90% of people who report bugs to Moose or send patches have jobs working with Moose which is the primary reason why they report bugs to it. My point is, this is not any different from commercial software,there is no actual difference, the only difference is the name.
I was disappointed that this wasn't about 2 racehorses writing AJAX apps competitively.
&gt; Any of the O'Reilly books are good. I like Learning Perl, Intermediate Perl, and Mastering Perl. I couldn't get into Programming Perl, but I'm in the minority on that.
Maybe he wants to become a Perl monk. I know I've always enjoyed the zen that is Perl.
I think the only valid career choices in your list are: Assembly, C/C++, Python. Haskell is very nice but I seriously doubt you'll ever get to use it in a real-world situation. If, however, you are in need of esoteric code and you want to feel you're writing cool code it might serve your purposes pretty well, but I doubt someone is going to let you do rocket science that they won't understand. If you don't start your own business you're probably be a "replaceable piece" so you can't really use esoteric stuff that your future replacements won't understand. The rest is stuff that will completely disappear in the next couple of years. We'll watch together and in 5 years time I guarantee you this will be true. Perl has little chances of gaining any popularity, instead it will slowly go down and fade away. It's purpose will be to replace bash as part of build system and automation systems in general. Perl6 will not be out for at least 4-6 years(judging by its progress so far) only if serious money will be pumped into it. An effort that is only supported by good will is not going to make it very far. ( The company building Java has been pretty much **owned** , *Closure* ? I think you meant **Clojure!** along with Scheme and Lisp will disappear pretty fast,maybe will be maintained as an attraction, like some monkeys at the zoo, for computer science students C# will be switched M$ by some other crappy language that's Java-like, Go is developed by Google only, I don't know anyone who uses it, who'd want to adopt a new language really ? It probably has an extremely large amount of bugs that are not yet thought of, let alone discovered, let alone reported ... Ruby is really slow, has nice syntax, it's metaprogramming is nice, but the average monkey will not be able to use it because it's hard and so it will disappear also Prolog is a very very niche language ... I do not think think anyone in their right minds will use it only because it has built-in backtracking But all of this is applicable if you want to write serious code. If you want to write web code that will be completely obsolete in like 1 year , then you can choose any of the trendy languages out there... All in all I think you must be very pragmatic when adopting a new language. Otherwise, it will probably be a language you'll hack on in a weekend(which is wasted time...if you're not planning on getting a job with it).
How would that help him in any way ? The language itself is a complete and unrecoverable mess, the community cannot change that.
&gt; Perl 6 will not be out for at least 4-6 years.... That explains it! You're posting from the years 2002-2004.
And English is a horrid jumble that's mostly a pile of bits ripped from other languages with more exctptions to rules than rules. Who on earth would want to try and express themself in such a language?! Perl is an amazing language. The fact that it has one of the best communities is just a nice bonus. If you don't like it then don't use it. It takes more than a day to wrap your head around Perl. I remember starting out and seeing some dense Perl and exclaiming "WTF?!". After many months of study and practice I could see the beauty in it all. I understand your dislike of the language; you simply have yet to reach Perl enlightenment.
Well, except for the part about how you can locally patch your issue, and then circulate that patch to others. I'm *pretty sure* that commercial software very seldom offers that level of control.
&gt; Reporting bugs is part of a profession. It's called Software Tester , that is actual work, people get paid for that. Good for them. I don't understand why that prevents you from feeling ok with reporting and fixing bugs without getting paid. Some people get paid to have sex, they are professionals at it. Does that mean that us amateurs shouldn't also do it for free? 
Your analogy is broken.
It's not.
From all your comments you seem very bitter. I'm not sure you understand the mindset of most people in the open sorce world. We love software for it's own sake. No money has to be involved because we do it for the enjoyment we get from the work. It's fun solving problems. Some people do indeed do it as part of their job but many of us do it out of passion. Lucky people do it for both.
 perl -lane '$s{$F[0]}++; END{foreach $k(sort {$s{$b} &lt;=&gt; $s{$a}} keys %s){print "$k\t$s{$k}"}}' /path/to/access/log About twice as fast as the equivalent awk | sort | uniq for my limited testing. Edit: I should have read the article first.
Yeah, the main problem with the `uniq -c` approach to counting is that the `sort` before it is really a lot of wasted work. Now, `awk` is actually in POSIX, so you could do something like awk '{ count[$1] ++ } END { for (i in count) print count[i], " ", i }' access.log | sort -nr | head -n 10 or whatever, but being a perl guy myself that's not exactly the solution I think of first. It's probably possible to do the sort itself in awk somehow but I couldn't figure out how :)
I'm actually very up to date with what's happening with both Perl5 and Perl6.
I've reached Perl enlightenment long ago but I'm far from mastering the language(I probably never will since it's poorly organized and by the time I will master it, if I keep at it, it will have completely disappeared from the job market, or be used as a replacement for Bash, so what's the point ?). 
.sh = Saint Helena? Far Out!
you're confusing sex with programming man ... come on .. just wake up
No, I'm not. That's what an analogy is.
You are right about Clojure, but you missed to point of that list. No one has the ability to accurately predict what the future holds. Cobol's death has been predicted for twenty years now. Each of those bullet points represents a significantly different style of language. By learning all of them you prepare yourself for whatever the future may hold (by learning how to learn). Each different style will also change how you think about the act of programming and will make you a better programmer in whatever language you eventually use.
&gt; make you a better programmer what exactly does that mean ? a programmer is better if he knows how to write testable,debuggable code, if he knows how to refactor it and break it down into bits and pieces, if he knows a couple of modules that he uses for common tasks. if he knows network programming, some graphics, maybe some algorithms and the API of whatever he's working with at that particular moment. that's what makes a great programmer. it has nothing to do with what you're recommending which is **NOT** knowing any language well, but learning many and not knowing any of them well. that is completely useless. it's hard enough to learn one language very well, why waste so much time on so many languages which you won't use ? &gt; you prepare yourself for whatever the future may hold boy I'll tell you what the future holds, I'll read it right now from my crystal ball and you better believe me. it's all about C, assembly and maybe Python(the scripting languages change quickly so that's why I said maybe for Python). it's pretty obvious what's going to happen. &gt;Each different style will also change how you think about the act of programming no it won't. programming means you need to do **LOADS** of it to be good. knowing different *styles* and not knowing one well leads to complete waste of your precious time &gt; Cobol's death has been predicted for twenty years now I don't like the term *death*(too dramatic for me). I think it's just been replaced with more capable langauges. Actually,even at the time of Cobol there were much more viable alternatives. Cobol was(like Java or Visual Basic) written so that non-programmers could write code. It tried to simplify a lot of stuff. The fact of the matter is, programming is not simple, it never will be. Perl is a bit different, people tried to stuff into it so many *paradigms* that now it's unclear how exactly stuff should be written in it, it's even confusing and the TIMTOWDI is not necessarily an advantage, sometimes it's a great disadvantage. It's unclear what you should use with Perl if you want to do a particular thing, you have many choices ... many of which are deprecated and obsolete. Noone tells you *"these are the modules we use in Perl"*, you just need to waste loads of time hunting them down. Perl5 doesn't even have an official specification. You know what other languages share this trait ? Visual Basic for applications. Oh wait !!! Even [VBA has a language specification](http://bit.ly/bpYZdc) ! I think we need to be realistic, Perl will be dropped pretty soon and there will be just a bunch of fanatic zealotists using it.
yeah, monoids are like pizza recipes, cats are like condoms and boats are like skyscrapers. do you like my analogies ? I just learned how to make them from you :)
what exactly is a *recursive paradigm* ?!?! what's that supposed to mean ? are you making words up ?
do not learn this langauge, it's a complete waste of your time.
Really? Then why don't you act like you've been enlightened?
The cat is under the table. My mother likes spelling furniture out of the window mats. Do you like my response? I just learned how to reply from you.
What ? Was I supposed to say "I'm enlightened, Perl is so fantastic!!!" ? 
Basicly.
&gt; [No one] tells you "these are the modules we use in Perl.... [Task::Kensho](http://search.cpan.org/perldoc?Task::Kensho) &gt; [Perl 5] doesn't even have an official specification. You know what other languages share this trait ? Most of them.
&gt; Basicly Bazikly
This is not a Perl subset, it's a somewhat Perl-like language that hasn't been updated since 2002. Nothing very interesting IMHO.
omg, it wasn't sufficient that Perl is slow as hell and has a syntax worthy of thedailywtf, **NOW** we have it implemented in Java !!! dear god. epic fail.
&gt; what exactly does that mean ? It means that when you have a problem, you will be able to see more than one approach to solving it. Certain problems are easier to solve with different methods, but if all you have is a hammer, every problem looks like a nail. &gt; it's hard enough to learn one language very well, why waste so much time on so many languages which you won't use ? I am not saying you need to master every language on the list. I have only spent to time to master two languages (ANSI C and Perl), but I know dozens or other languages to at least an intermediate level. This knowledge allows me more flexibility than someone who only knows only a few. &gt; boy I'll tell you what the future holdsC, assembly and maybe Pythonit's pretty obvious what's going to happen. It must be that nice to be so certain, until the rug gets pulled out from under you that is. From where I am sitting it is fairly obvious that ANSI C is going to get relegated to sort of tasks assembler is used for today and assembler is going to become even more of a nich language. Given that CPUs have stopped getting faster and have started to get wider (i.e. for CPUs rather than faster CPUs), I expect that some language that makes programming for those environments easier will be the future. Something like Erlang, Haskell, or Google's Go. You picked on Go because "only Google uses it", I would remind you that there was a time when only AT&amp;T used K&amp;R C. Of course, I have no real confidence that multi-core CPUs will remain the norm for the future. I don't even know if the computer as we know it will still exist in ten years time (quantum computing could take off and change the entire landscape). What I do know is that being able to work with whatever comes down the pike will be more enjoyable than being stuck like the drones who write Cobol for mainframes. &gt; no it won't Have you ever spent any time learning anything other than the imperative style with maybe some OO thrown in? I can tell you for certain that the time I spent with Common Lisp changed how I view programming, and the time I spent learning about Prolog changed me in a different way. &gt; It's unclear what you should use with Perl if you want to do a particular thing, you have many choices ... many of which are deprecated and obsolete. Noone tells you "these are the modules we use in Perl", you just need to waste loads of time hunting them down. You claim "I'm actually very up to date with what's happening with both Perl5 and Perl6", but this is obviously not the case or you would know about [Enlightened Perl](http://www.enlightenedperl.org) or [Modern Perl](http://modernperlbooks.com/mt/index.html) which have both gone a long way toward eliminating the problem you are talking about. In fact, I am willing to bet that mr_chromatic on reddit *is* chromatic. So, either you are ignorant of what is going on in the Perl 5 community, or you are trying to give offense. Of course, I can turn that problem back on ANSI C. There are hundreds of thousands on libraries out there for C. Which ones should I use? Which ones don't work well together? And yes, Perl 5 famously does not have a specification. The reason why is that it didn't need one; there was one implementation. This is a limitation, which is why Perl 6 is a specification and there will be more than one implementation.
http://tinyurl.com/yk56vfd I would say that the "recursive paradigm" is in use when recursion (usually tail-recursion) is a first class flow control structure rather than a side-effect of how functions work. Classic examples would be Common Lisp, Scheme, Clojure, Haskell, XSLT, Erlang, etc. I believe the class of language is more commonly referred to as functional, but that gets you into arguments about whether Lisp-like languages are really functional languages.
&gt; which is why Perl 6 is a specification Perl 6 has a looooooong way until it's going to be out of the **experimental** zone. It's a very interesting language, but I don't think I'll be using it before 2014 or 2015 (it's very clear to me that you need to invest loads of programmer power into something before it becomes bug-free and no, I'm not going to help you solve your bugs,I've plenty of my own). Saying that Perl6 *does have an specification* is useless, it's not even an excuse for Perl5 not having one. &gt; I am willing to bet that mr_chromatic on reddit is chromatic. yep, the guy who babbles a lot about a lot of things and probably doesn't know a quarter of what he speaks about. &gt; Have you ever spent any time learning anything other than the imperative style with maybe some OO thrown in? I can tell you for certain that the time I spent with Common Lisp changed how I view programming, and the time I spent learning about Prolog changed me in a different way. Of course I have. Quite a lot of time. *changed how I view programming* , is that what you're going to tell someone interviewing you , that Lisp/Prolog *changed how you view programming* ? He's going to laugh in your face. People are interested in stuff you can use today, now!! something that solves a problem, and something that you can use to collaborate with other people also(people who **won't** know any Haskell or Prolog or Lisp or ML or Ocaml or F# or whatever fancy language). If I want to build spaceships and write code that's more similar to science fiction than reality, sure I can do that, but nobody cares about it. People care about *real skills* with *real languages* that you can use in collaboration with other programmers. By reading many posts on reddit, I think the dream-job of many redditors would be to have a job writing Lisp or Haskell or Prolog(and I can understand why, those languages allow a programmer to express himself properly), but the reality is that there are **extremely** few jobs with those languages, so you won't use them, **ever** ,forget about it. By doing very impractical things and writing software that nobody will use in languages such as the ones mentioned I am learning progressively that I will be using them nowhere and never. They are very nice, I like them a lot, but they are just used by herds of fanatic zealotists here on reddit to make noise, whereas average programmers(even very good ones) have no ideea they(the languages) exist. &gt; you would know about Enlightened Perl or Modern Perl which have both gone a long way toward eliminating the problem you are talking about yep I know about both, but none are official ! they're just posted on some peoples blogs. they are not visible. you need to be deep into Perl to know about them &gt; Of course, I can turn that problem back on ANSI C. There are hundreds of thousands on libraries out there for C. Which ones should I use? Which ones don't work well together? You just look at the large software projects and see what libraries they use. With Perl you can't apply this, because Perl people apparently only think about how to write a new wiki or a new blogging system(that is they're raison d'etre). So when you want to write other kind of software non-webrelated you need to dig reaaaally deep to find anything. &gt; You picked on Go because "only Google uses it" No, I picked on Go because it's a new language and it has tons of undiscovered bugs(and problems). How do you trust something that's this new. What if it's written by Google ? It could have been written by Microsoft for all I care. As a comparison C has been around so much time that it's proven itself and there are compilers written in a long long time which by now are pretty good. &gt; or you are trying to give offense please don't get all emo on me &gt; What I do know is that being able to work with whatever comes down the pike will be more enjoyable than being stuck like the drones who write Cobol for mainframes How can you prepare for something when you don't know exactly what to prepare for ? Do you have the newspapers of tommorow today ? No you don't. The most you can do is sit down and watch what's going on to see if some technology/language/whatever picks up and if it does, only then learn it(given that you also need/like it). &gt; I expect that some language that makes programming for those environments easier will be the future. Something like Erlang, Haskell, or Google's Go Writing C is hard enough. As a comparison writing good assembly code is much much harder(and by good I mean of course, writing better assembly code than the compiler generates). Imagine how well you'd need to know the machine and a complicated functional language in order to write good/worthy code. How much would you need to invest in a programmer for him to reach the level where he writes good functional code ? A lot ! Does it pay off ? Can he get a job after he learned the stuff ? No. Can he reuse his skills from a functional language in other languages such as Perl ? Not really ... Perl is a lousy replacement for FP even after reading HoP. You can't expect a language who was not designed FP to be used for FP.
Please try to add value to discussions in this subreddit.
There is none. The current version has an issue compiling on MS VC++. This is fixed in the soon to be released 0.24 release.
excuse me , what value can you add to JPerl ?!
&gt; If it can't be done in Perl, it can't be done. If it can't be done *properly* in Perl, it can be done(but of course not in Perl).
The only thing the author mentions that could be problematic is the cryptic error message for undefined methods, which would confuse a "perl novice". Other than that I don't see anything in the article that could be considered harmful..
Yeah, should be changed to 'considered annoying'.
No, I am not making this up. I received an ABET accredited degree in Computer Science in 1997. At that time writing software in a tail-recursive language was specifically considered a separate paradigm from functional or OO programming. Tail-recursive languages are considered the lowest of the high-level languages. Though C (along with C++ and Java) support recursion, LISP and LISP-like languages (Forth, Scheme, Haskell) are defined by recursion. Your user-name suggests some software development experience. But based on your comment history, I am not sure my reply will be much use to you. You ask about learning Haskell as it pertains to getting a job, while at the same time bashing Perl as a waste of time. All I can say is good luck in your endeavors; you are going to need it.
I think there are as many rankings as there are sites that make them. Indeed.com probably has very bad code running on the backend for making those charts because frankly PHP has always provided much more jobs than Perl. Even now PHP completely owns Perl on the job market. So your whole article is based on wrong data. There are also problems of the following nature: Many job ads contain stuff such as "Perl programmer position - Knowing Java,Haskell,Assembly,hyperbolic trigonometry is considered an advantage" (because managers or whoever writes job ads think people can be good at everything, that translates to good at nothing, but sshh don't tell them) so you count stuff twice while you don't exactly know what the job ad wants, so again, this is a reason why the charts are completely useless. The only proper way to find what you need is to see the title of the job ad, and check if a technology name is in it, if not you'll probably have a hard time identifying it from the text(but suppose it will be in the first part of the job ad, right after the *"We're a big company"*-crap) you get that and you need to label this and hash it so you don't count it twice later and so on. I doubt those guys do that, they probably just have some solr set up that let's you search stuff and gives you back (i)relevant results.
&gt; Indeed.com probably has very bad code running on the backend for making those charts because frankly PHP has always provided much more jobs than Perl. Do you have proof for this, or do you work for TIOBE?
That makes absolutely no sense.
no, but I'm going to downvote his article because it's based on numbers which I personally don't know how were computed and it's clear as day that those numbers are wrong. I mean PHP should clearly be higher than Perl. For example you can get a job with Perl only if you're in U.S. or in UK at the moment, all the jobs on various Perl sites suggest that. While if you're in the rest of europe(non-UK) your chances of getting a job with Perl are extremely low.
What you're overlooking is that the graphs do not show job count, but job growth.
Even in job growth the graphs are wrong and cannot reflect reality. Actually having a list of companies that use Perl professionally would be very good to exemplify my point but I don't have time to put one together, but if I had time I'm sure I'd get my point across.
&gt; no, but You can stop there. I'll rely on statistics from an organization with an obvious source of data and the incentive to report that data accurately over someone on the Internet who objects to that data because it doesn't match his or her feelings but has no data.
dood, look at the job listings, you don't need to be a statistician to figure out that there are much more PHP jobs than there are Perl jobs. these growth charts or whatever are completely useless and they're made by people who are well aware that Perl is going down down down because it's an old language. you can't really stop this by showing charts
Any list that names Delphi as being more popular than Ruby or Perl is a worthless list.
It lists Delphi as more popular than *JavaScript*. Just... wow.
How many doctors are using CPRS right now? 
TIOBE claims not to measure the *use* of projects written in a language but the discussion of the language. How many doctors are talking about that great new Delphi software CPRS?
Nah, it's all of those people discussing how they use Oracle with Delphi... in Greece.
It's not new, which may be one of the reasons it's under-appreciated.
One thing I wonder about with all the doodads that get layered on top of Perl is the speed hit. Perl is hardly a speed demon to begin with (and I really wish it was...).
autobox is the only part of perl5i that imposes much in the way of performance penalties, and you only pay that price if you use those features.
Sure, but are people talking about Delphi en masse because of it? I don't know, but I find that unlikely.
No, they aren't.
Thanks for the writeup mr_chromatic! I have to try this out! I've already fallen in love with local::lib for obvious reasons and this looks to be a very simmaler idea.
Yeah, what chromatic said: at runtime, you only pay for what you use. And no vanilla perl statements are slowed down due to perl5i. There is a compile time hit to load some of the modules that are required from the start (like autodie or utf), but the rest are lazily loaded when and if needed; we were really careful about that.
&gt; The most significant feature added to Perl 5 (released on 17 October 1994) is the module system Certainly not! The most significant feature is references to hashes and arrays. I could live without a module system, but not without refs. 
It's easy to argue either way, but the biggest problem I remember from Perl 4 was the idea of fragmentation. If you wanted to use Oracle from Perl, you had to use oraperl. If you wanted to use Sybase from Perl, you had to use sybperl. An extension mechanism which didn't require recompiling Perl itself was a huge advantage, and it made the CPAN possible.
mr_chromatic, having been laughed off of p5p by actual Perl developers, hopes that spamming various "social media" sites with links to his vanity blog will help sell copies of his book. Doubtful.
&gt; it made the CPAN possible. That is over course true, and one of the greatest assets perl has. 
Another important criteria is that you don't trample all over someone else's namespace. Like the `Template::*` one, for example... ;-) [edit: added smiley wink so I didn't sound like too much of an asshat]
No one owns Template::*. In fact, no one owns any generic top level namespace tree. That's not the way CPAN works.
There is an official list of [registered Perl modules](http://www.cpan.org/modules/00modlist.long.html). It says: Template RdpO? Extensive Toolkit for template processing ABW The Template namespace is registered (via modules@perl.org) for the use of the Template Toolkit, and has been since 1999. 
I should have been more clear. I meant namespace tree, not namespace (just updated my previous comment). To quote the document you linked to: "So if you have registered any namespace, it does not mean that you own the whole namespace tree that starts there. If you are registered as the contact for Foo::Bar, you are not necessarily also associated with Foo::Bar::Baz."
True, you are not *necessarily* also associated with modules under that namespace. The `Template::Plugin::*` namespace is a good example of that. But that isn't to say that if you're thinking of releasing a module under a namespace that someone else is using that you shouldn't consult with them about it, or at least inform them of your intentions. For example, I wouldn't think of releasing a `DBI::*` module without checking with Tim Bunce first, or a `Moose::*` module without running it past Stevan. Unfortunately, some people regard `Template::*` as a generic namespace like `Text::*`, say, and forget that there's already a whole tree of modules living under there that have been carefully and deliberately organised in a particular way. Sam touches on the issue of module names in the article: &gt; If you know that the Template::Sandbox plugin for Template::Benchmark is Template::Benchmark::Engines::TemplateSandbox, you can make a stab at what the HTML::Template one might be. I didn't know about Template::Sandbox or Template::Benchmark until I read the article. They look great and I have no objection to them (nor would I have any real right to make an objection, as you correctly point out). Sam certainly wasn't obliged to check with me or the TT mailing list before releasing the modules. But it would have been nice, if only to be kept aware of what's going on. There have been occasions in the past where people have released `Template::*` modules that clashed with existing ones in TT or under development. None of the problems were unsurmountable. In one case the author renamed his module, in other cases I've renamed mine. But these problems could have been avoided by a quick email in advance. This is particularly relevant at the moment because TT3 is in the pipeline and that will introduce a whole bunch more "official" `Template::*` modules that not only have to be self-consistent in their own naming, but also have to sit alongside the TT2 `Template::*` modules without clashing, so that people can use both TT2 and TT3 together. Add to that the fact that I also have to watch out for other `Template::*` modules popping up and it can all get a bit hairy! Anyway, I didn't mean to appear to be too critical of Sam. I should probably have put a smiley wink at the end of my first comment. But there is a valid point to be made: the science of naming often involves fitting in with what other people are doing. It is preferable to work with them than work around them. 
I understand why this is a problem, but it's IMHO an inevitable consequence of using a high value piece of namespace real-estate as Template. Like it or not, the name Template is rather generic description for what the module does, unlike for example Moose or Catalyst. I think it's counterintuitive that it apparently isn't (at least for me it is). People who want to give their templating module a descriptive name will want to use it. I definitely agree consulting you and the rest of the TT team would be a good idea. It's just one that won't pop up in the heads of many people precisely because the namespace sounds so generic.
Go away, you silly funny rabbit, or be replaced with a simple regular expression.
Which?
&gt; but it's IMHO an inevitable consequence of using a high value piece of namespace real-estate as Template. Yep, agreed. Although when I took the name, there were something like 30+ templating modules already on CPAN dotted all over the place. The original goal was to try and unify as much of that as possible into one set of modules that implemented a generic templating framework with everything pluggable, including the template language itself. Hence the name, Template *Toolkit*. Admittedly that didn't quite work out in practice with versions 1 and 2 as the language and framework ended up being more tightly intertwined than originally planned (mainly for reasons of efficiency). But it's still part of the goal for the `Template::*` namespace and hopefully TT3 will be a step closer to that. 
Hi, thanks for your comments on my article, I hope you enjoyed reading it, and yes, your point (including smileys) about thinking about namespaces when naming things is an important and valid one. Consistency of naming covers fitting in with the existing ecosystem, but (and take this with a smiley too, so that I don't sound like an asshat either...) although the existence of Template Toolkit in the Template:: namespace was something I was aware of, it was something I felt was the lesser evil compared to misnaming my Template::Sandbox module. Fact is, everyone calls Template Toolkit by it's name Template _Toolkit_, that should be a big indication of what namespace it really belongs in. Shouldn't be too hard to fix, just change a few module names and tell a couple of end users to change their scripts, right? ;) I have plenty of respect for all the people who have contributed to Template Toolkit and made it so successful, but the fact that it squats inappropriately on the entire of the most-appropriate namespace for any template module, well that's a problem. Even if it was originally, and may in the future, be a generic framework, this is perl we're talking about, "there's more than one way to do it", there's is, and shouldn't be, one true template system to rule them all. Not just that, but the assumption that anything under the template namespace is or must be automatically a template framework (using the one template system to rule them all), is a bit dodgy too, there's a lot of things that could be to do with templating that logically belong under Template:: but aren't directly template engines, just as there's many different sorts of things under the CGI:: or WWW:: namespace. I appreciate the situation you're in with Template Toolkit, and that it's not something that can be changed easily by you, even if you wanted, because of legacy issues, but I had to choose the most accurate name for my module, and that's what it was. Unfortunately it's not a problem of my making. but of an over-broad namespace grab in the first place. :) I _did_ consider the issue though, I just happened to reach a conclusion you're not entirely happy with. Thanks for the comments though, and for the work you've done over the years too, don't think I don't appreciate it.
That's such a beautiful looking mind map, any idea which software was used to create it? Edit: My bad for not reading the video's description before asking. The software is called [gource](http://code.google.com/p/gource/)
This belongs in WTF. BTW does any programmer have an idea what kind of algorithm to use to get this kind of graphs? I think there's probably a balance between attraction (only for related items) and rejection, and eventually it'll balance out, but... what terms to search for? (Note: I don't want to *use* this software, I want to *write* some that does something similar.)
It is called [Gource](http://code.google.com/p/gource/). There is a [github source repository](http://github.com/acaudwell/Gource). The author has a blog [here](http://www.thealphablenders.com/2009/12/gource-software-version-control-visualization/) where he writes about the algorithms he used.
For a project in my undergraduate algorithms class, I used a tool based on (IIRC) [Drawing Graphs Nicely Using Simulated Annealing][1]. I don't recall much about the specifics of the assignment except we were each supposed to select an NP-complete problem, make some kind of cut at it, and give one-on-one demos to Dr. Grahamwho jokingly referred to himself as Rong Graham because although he also worked in graph theory, when people hear Dr. Graham in that context, they're almost always thinking of a different [Dr. Graham][3]. I wrote a Perl/Tk application that allowed creation of arbitrary graphs and generated random ones. I used the aforementioned tool to draw the graph more nicely. The program colored the nodes as it searched for valid colorings, which it checked using a regular expression. I even found a [post to p5p][2] from when I was working on that project. I've lost that and so much other code from those days. It'd be fascinating (and maybe horrifying) to go back watch my own progress. You whippersnappers today with yer fancy GitHubs and Patch-Tags and bitbuckets ought to be journaling your work! All that said, the algorithm used in this video probably isn't using the same technique, but the subject tugged on an old man's sentimental heartstrings. [1]: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.5663 [2]: http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/1997-03/msg02573.html [3]: http://en.wikipedia.org/wiki/Ronald_Graham
why do you insist so much on COW ? have you heard of [ropes](http://bit.ly/AE1aI) ? I thought Rakudo isn't even usable in production because it lacks a lot of stuff a mature language has(it lacks it in implementation, in theory it has big goals) , so what's the point in optimizing something that's currently unusable ? must be something I don't understand
&gt; why do you insist so much on COW ? To save memory. &gt; have you heard of ropes ? Indeed. Most strings in Parrot and Rakudo *aren't* long enough to benefit from ropes. &gt; I thought Rakudo isn't even usable in production It certainly is, depending on the specifics of your production needs. &gt; what's the point in optimizing something that's currently unusable ? Making Parrot run faster and use less memory helps people building things with and on Parrot. Why wouldn't we optimize?
&gt;&gt; I thought Rakudo isn't even usable in production &gt; It certainly is, depending on the specifics of your production needs. are you sure it is ? can I make any of the following applications with it ? * a game * a website * a TCP or UDP server * a threaded application * does it have mysql/posgres/sqlite/oracle support ? can it talk to databases ? * is there any host out there offering Rakudo ? * can I write stable applications with it ? * can I run a program with it and let it run for a long amount of time without crashing ? does the compiler have memory leaks ? What can I do today with Rakudo ? I mean serious stuff not adding 1+1 or making simple arithmetic(that's not the definition of production-ready btw). But I'm curious what your definition of production-ready is ? &gt; Making Parrot run faster and use less memory helps people building things with and on Parrot. Why wouldn't we optimize? ah this would be reasonable. is there some language using parrot currently that really helps someone ? because I really know of nothing that's in production with it.
You've opened my eyes. We totally shouldn't be working on Parrot at all because it's not perfect yet.
&gt; You've opened my eyes. We totally shouldn't be working on Parrot at all because it's not perfect yet. I didn't say that, I just claim it's not production-ready, that's all.
long story short, use cpanminus instead of cpan.
What use is a newborn baby?
&gt; I just claim it's not production-ready, that's all. That's a silly position to take if you have to ask someone else what kind of applications you can write with it. (It's especially silly if you have a boolean flag for production ready or not, as if all production uses of a piece of software had the same requirements.)
And without people working on it -- including optimization -- it'll never fit your definition of 'production-ready'. :) Language implementations don't appear ex nihilo.
&gt; Some focused profiling with this combination revealed that the big difference before and after the memory fix came from the code path when concatenating two strings. This is in the Parrot function Parrot\_str\_concat(). If both strings exist and have contents (if neither string is empty), the code copied the first string into a result string, then appended the second string to the result. That copy operation performed a reified copy on write. I read [the Wikipedia article on "reification"](http://en.wikipedia.org/wiki/Reification_(computer_science\)) and still can't figure out what you mean by "That copy operation performed a reified copy on write." *Edit*: Markdown
I mean "creating a new buffer, copying the contents of the old buffer into the new buffer, making the header with the COW flag point to the new buffer, then flipping the COW flag".
So you mean you performed a copy-on-write, i.e., you were writing on the string, so you copied it first. Where does the reification come in? Maybe (Wikipedia notwithstanding) I still don't understand the term, but at very least I definitely don't understand your usage of it.
It's sort of a pun. Yes, the copied buffer actually exists and the current string header never points to a non-existent buffer, but only at this point does it get its own buffer. I wanted a word to describe the concept without repeating the word "copy" too often, and "reification" was the least wrong at the time.
I think we're talking past each other. My question has nothing to do with the existence of the buffer and what-have-you. My understanding of "reification" is to take an abstract idea (e.g. "a memory address") and make it concrete so that you can manipulate it (e.g. a pointer). The Wikipedia article I linked above has other examples: Scheme reifies the call stack as continuations, Perl reifies the interpreter by providing the `eval` function, and so on. You appear to be using it in a very different sense (I suppose that's the pun) where you're saying "I've defined this data structure as 'copy-on-write', and so now that I'm writing on it, I have to copy it, and this function, in fact, does that copying, and thus has concretized or "reified" the specs for my data-structure specification in code." That's a weird usage, and inconsistent with the definitions I could find, is all I'm saying. I'm not trying to troll you, honest. I really enjoyed *Perl Testing* and I'm looking forward to reading *Modern Perl*, and since you seem to be asking for book-reviewer type comments by posting all your articles here, well, this is my comment for that article: That sentence confused me, and by extension I think it will confuse others. It seems to make just as much sense without the word "reified" in it. Perhaps I'm nit-picking. :(
Python uses immutable strings, seems to work well there.
That's definitely an argument for them. Python's string interning is also a validation of the concept of caching seen strings.
Until I wanted to do a Project Euler question in Python, it was too slow so I swapped back to Perl and it was done in a flash.
I've got no clue, please explain !
Looks like it's built on top of this module: http://search.cpan.org/dist/DB-Pluggable/lib/DB/Pluggable.pm
I use [DB::Pluggable](http://search.cpan.org/~marcel/DB-Pluggable/) to make this work. However, it also requires a heavy knowledge of debugger internals. Those internals can best be described as a steaming pile of ones and zeroes. Further, you can't run the debugger on the debugger, thus forcing you to locally fork it and debug with print statements.
I haven't seen many Project Euler problems where string performance should be a bottleneck.
There's one where checking if the reverse of a number was the same as the number, abusing reverse() on an integer is definitely not the fastest way of doing the problem but that method required by far the least thought and was very readable.
I'd forgotten that one. Good point!
I agree. That was awful. O'Reilly effectively abandoned the site but wouldn't let anyone else keep it up to date. Hopefully that situation will change in the near future.
You *don't* have to do this for your tests to work normally in 99% of all cases. This is a really obscure edge condition. Ovid is doing heavy wizardry: why do you expect that to be simple?
because *"heavy wizardry"* should be associated with things that are really supposed to be hard not with simple stuff.
The Perl debugger is *heavy wizardry* and it's a mess internally.
That's pretty obvious from what I read in Ovid's article ... but thanks for reinforcing that :) I think you(not you in particular) could write a book with all these quircks/bugs/fixes of Perl. What I would like to know is if there's any chance that it will get better in the future ?
&gt; I think you(not you in particular) could write a book with all these quircks/bugs/fixes of Perl. Such as *Perl Hacks*? The "name an anonymous function with `local *__ANON__ = 'foo';" trick is in there. I've also used `$^P` in real code somewhere. &gt; What I would like to know is if there's any chance that it will get better in the future ? Yes, because free software means that the only thing standing between anyone and the solution to a problem is the desire to solve the problem. Maybe, because the Perl 5 internals are complex and arcane, and cleaning those up to make the debugger cleaner is very difficult, especially given the desire to maintain backwards compatibility with XS.
&gt; Yes, because free software means that the only thing standing between anyone and the solution to a problem is the desire to solve the problem. Don't look at me! Fixing a problem means spending time on it which equates in actual money being spent on it which I don't intend to do. &gt; Maybe, because the Perl 5 internals are complex and arcane, and cleaning those up to make the debugger cleaner is very difficult, especially given the desire to maintain backwards compatibility with XS. So it won't be solved. I just wonder what some employer or company thinks when it reads on the internet there are **so many** of these *Perl hacks* as you call them ? They become documented and piled together in a book that is visible only when someone decides to put in the effort of writing one which again costs large amounts of money and time.
&gt; I just wonder what some employer or company thinks when it reads on the internet.... Anyone who reads about these on the Internet and thinks "Wow, I'd better not use that language because it's abusable!" has a facile understanding of programming. I know of a company which, while interviewing C programmers for embedded devices, asks them to explain Duff's Device. They don't have to have it memorized, but they at least have to be able to say "Wow, I didn't know you could do that. That's very clever!" &gt; Fixing a problem means spending time on it which equates in actual money being spent on it which I don't intend to do. That's a shame. A fraction of the time spent complaining about things on the Internet could, properly invested, fix many of those things.
&gt; Anyone who reads about these on the Internet and thinks "Wow, I'd better not use that language because it's abusable!" has a facile understanding of programming. Or maybe they are thinking "Hey, programmers are basically replaceable cogs, we need to choose a language that doesn't require them to read all the Library of Alexandria in order to learn it". &gt; They don't have to have it memorized, but they at least have to be able to say "Wow, I didn't know you could do that. That's very clever!" The competent programmer is fully aware of the limited size of his own skull. He therefore approaches his task with full humility, and avoids clever tricks like the plague. Edsger Dijkstra &gt; That's a shame. A fraction of the time spent complaining about things on the Internet could, properly invested, fix many of those things. If somebody has a broken piece of software, and knowing for a fact that people get paid to fix it, why would I fix it when complaining is free ? It's free for me and it's also free for the ones who wrote the broken software to read my words while at the same time they are embarrased by their clumsy creation. My hope is that in their complete embarrasement they will feel the urge to fix stuff. At the same time I'd like to note that there is a direct correlation between the following events: * experienced developers uncovering the quircks of Perl in various articles * programmers creating sites such as perlisdead.com , isperldeadyet.com etc, everybody saying Perl is dead * angry Perl programmers writing blog posts trying to disprove and counter people at the previous point by making statistics based on various job site searches Things are not accidental, they happen for precise and exact reasons which can be spotted if you look closely.
Will this help perl programmers to get dates? :)
&gt; My hope is that in their complete embarrasement they will feel the urge to fix stuff. Oh, that's brilliant! No one's ever thought of that before! Mockery is *clearly* the *best* way to get someone to do what you want! I'll just type this here and hope that the President reads it, as I'm sure of two things. First, that your insight and wit will help him with both his domestic and foreign agendas. Second, that he reads this forum like all good-thinking and pure-hearted people do. After all, he has plenty of time to do that, because he's already read both books on his job. You helped save the world today, Passive-Aggressive Superman.
I wish I were trolling, but I think all I just said is 100% true, so there's no mockery involved really. Also, it's started to become a bit annoying to see this flame war that is every day displayed on various sites and blogs..
Is it just me, or are plenty of other people equally annoyed by the arrow in front of each link? Jeezes, if you want to mark up a link, at least do it inobtrusively.
&gt; ... there's no mockery involved really. Believe what you will, but I guarantee that this site or your blog or comments on someone else's blog isn't the same thing as a bug tracker.
The correct/compatible dichotomy I see often. If correct isn't compatible, then it means that "correct" leads to bugs. And we all just love buggy software. But in this case, the programmer is being vindictive and self righteous as if the entire world needs to rotate around the lightbulb he's supposed to screw in.
You're welcome to contribute a less annoying graphic for external links.
In this case, the difference between fixing the problem the right way for good and fixing the problem in most cases is the difference between lightning and a lightning bug.
I always liked *Fast, good, cheep. Pick two*
with this article you managed to make my bullshit alarm go off so loud, it bothered neighbours 3 blocks away !!!
Why?
Yes. It's called cpanminus. Do this once: cpan App::cpanminus And then after that: cpanm My::Module Edit: better use miyagawa's bootstrapping command in the replies below to avoid the configuration questions. Had forgotten about those :/
If you're asking about dependencies -- CPAN by default will ask you if you'd like to install every. damn. dependency. Try: perl -MCPAN -e'shell' or cpan And you get rougly: cpan[1]&gt; Type: o conf prerequisites_policy follow o conf commit To tell CPAN to just install everything needed and then save it. Also, as a side note, you may want to look into using [local::lib](http://search.cpan.org/dist/local-lib/lib/local/lib.pm) if you're going to be doing a bunch of CPAN stuff, as, by default, it will install all over your system and not be part of your distro's package management. local::lib puts a "perl5/" in your homedir and -- if you follow the directions -- allows you to use that to supersede any system modules.
Looking at [perldoc ExtUtils::MakeMaker](http://search.cpan.org/dist/ExtUtils-MakeMaker/lib/ExtUtils/MakeMaker.pm#ENVIRONMENT), it seems that PERL_MM_USE_DEFAULT=1 cpan yadda should do what you want.
isn't it just `cpan yadda`? But yes, I also believe cpanminus is the future.
 man cpan
Using cpan to install cpanminus sounds silly if what they want to avoid is the CPAN shell configuration. In such case, do: curl -L http://cpanmin.us | sudo perl - --self-upgrade would bootstrap itself.
Yet I didn't find a way to upgrade packages easily using cpanminus. I'm sticking with CPANPLUS for now (which, relevant to the TS, is also easily configurable to follow prerequisites [s conf prereqs 1]). And another addition: I prefer to let my OS' package manager install the perl packages it requires. When I need custom packages, for development etc, I install them in a local perl5 folder (using local::lib). By adding this folder to Perl's @INC and loading local::lib at login (bashrc, all documented in local::lib's POD), this provides seamless integration, where I can install all packages I want using cpan[p|m]?, as a regular user, without polluting my system.
right, cpanminus doesn't support OS packages and doesn't have any plan to do so - use CPANPLUS::Dist or CPAN::Packager for that. cpanm automatically detects if local::lib shell env is setup, and also supports built-in local::lib installation with -l (--local-lib) or -L (--local-lib-contained) option.
I have done this using Jquery + perl http://search.cpan.org/~peterg/JQuery-1.06/lib/JQuery.pm http://wayfarerweb.com/animate-example.php
This looks like a good option! Do you have any examples of doing it with file transfers?
A few days ago I was trying to decipher that beast (Perl newbie here...) and found this: http://perl.jonallen.info/writing/articles/install-perl-modules-without-root 
I tried to hunt for one ... but my computer is a total mess. I was just playing around with this tutorial. http://articles.sitepoint.com/article/uploading-files-cgi-perl ( You will probably be using some other catalyst/dancer uploading thing) Then I just did callback to change the width for with the animate function. I am sorry I don't have more. I really need to clean up my ~/junk folder
And please just don't say processed text.
My first Perl program was reporting script to gather user statistics. The hard part was that the info was scattered to different servers. I ended up with a program that could be most accurately be described as distributed fork-bomb :)
1995 - webapp that managed an image repository.
You dirty wabbit
Turned an old linux box into a CD jukebox with dd and Samba edit: holy shit I've been coding Perl for 11 years
It read XML from a server, took out some of the data, and then both inserted it into a database and submitted it to an internal search engine by posting more XML.
Please post this project, documentation, pics, anything 
If by 'real' you mean the first one I was paid for, it was a ghetto backup system for the webhost I was working at.
Read an AOL Instant Messenger "TOC" format buddy-list and wrote out a gaim-format XML buddy list. Back when gaim was still gaim and compatibility with TOC was still relevant :) Alternative answer to make asdfqewr happy: it processed text.
My first real perl program polled a specified router every second via snmp for a given specified interface, and reported back the Mbps in and out. It was helpful because even today, most graphing applications work in 5 minute cycles, and this being once per second, you could see immediate changes in traffic. It was only good against a single interface on a single network device at a time.
*calls ACTA* ;) I used gaim; I used your feature daily so I could chat in our school's computer lab. Now unless you're gonna write me a program to take care of my lawn I'm gonna have to go with my only analog alternative EDIT: nevermind about my assumption that you contributed this feature for gaim, although it would've been cool
JAPH :|
I don't have it saved anywhere - went away with the job. It was my first real program, period, and still in the grey zone between script and program. I'd been screwing around with BASIC and various other things on occasion since 2nd grade, but didn't really do much of anything. I did a sort-of-program that was a very poor space invaders clone in BASIC, but this was never what I'd call finished or real. My first _real_ script was an autoexec.bat boot menu for our elementary school computer lab to boot the 2(3?)86s into Doom, Wolfenstein, etc instead of Win 3.11. Not enough memory to run them in Windows. That was in 6th grade, I think.
Worked alongside a C program to parse X protocol and find the absolute location of buttons as they rendered on the screen. After parsing it, it emitted commands to control a X-window based testing program. Did I mention I like perl? It was a monolithic monster though.
Did a content-management system type of deal for news articles and alerts and such. Actually posted some info and screenshot about it in a similar thread on hardforum.com: http://hardforum.com/showpost.php?p=1028254193&amp;postcount=10 "action" shot from an internal site i had that used it. much better options out there for this kind of stuff these days but it was fun: http://lamentation.net/dump/newsflash-purity.jpg that was after about 4 months or so of learning perl, which i'd consider my first programming language. edit: in retrospect i have no idea on earth why i found any utility in posting news/alerts to what was essentially myself. maybe i was just using that as a test bed of sorts....actually i think i had planned on making the site my little "homepage" at some point and opening it up to the internets....just thought it looked funny reading them...
Process management and monitoring ala NAGIOS with a web frontend, several years before NAGIOS. Prettier interface than NAGIOS, either, but not nearly as deep in functionality. Monitored access to systems via ping, SMB, SMTP, telnet, SSH, and HTTP/HTTPS, alerting via pager using some command line *nix modem dialer pager app I've since forgotten. Wow, that was... 15 or 16 years ago. I'd written much shorter Perl programs for a couple years before that, just to do simple sys-adminny things.
Ripped CDs and converted audio file formats.
I spent my first 2 years of Perl doing pretty much nothing but that though. That doesn't make it not a real program. I converted typesetter files from various outsides sources (and formats) to SGML that we used to bring the publishing in house. This saved my company over a million dollars that first year. These were not little one liner programs. That being said the next thing I did was a web-based research tool for case law to replace the ancient java one we had. It was my first webapp with zero knowledge. I didn't use a framework, I didn't use templating (well... rolled my own). I didn't use ORM. Hell, it's also one big ball of wax. I wasn't very bright. But it's still running 8 years later.
Good question. That was circa 16 years ago, before Perl5 even came out (or at least before it came into my workplace). I think I downloaded a report from a mainframe-based bug tracking system (I'd tell you the name, but then you'd have to kill me\*) and reformatted into a more readable format and printed it out. \* True story: A friend of mine was contemplating returning to work for this particular employer. I warned him that he'd have to work with this bug tracking system, which I alluded to but did not name. He looked at me quizzically and said "what?" And I said "**INFOMAN**!" and he shouted "***GOD DAMN YOU TO HELL FOR SAYING THAT WORD IN MY HOUSE!***"
Sadly I started learning Perl way to late. My first real Perl program was/is PIMPD - an MPD Client. ( http://github.com/trapd00r/pimpd ). I think I've rewritten it four times now, started in december last year. Since then, I've learned, learned and learned. The next thing is to modularize the thing, and implement some of all the things I've learned, to make it sexier. **Edit** Okay, appearantly this doesnt come close in comparing what you other hackers did for your first project. :c
trackback: [somebody's been reading your question](http://blogs.perl.org/users/ovid/2010/04/is-cpanminus-the-future.html)
Your mom.
It was either a rewrite of a turbo pascal program I had written to print cassette tape j-cards or a terrible space-themed Risk knock-off that had vague hopes of becoming a Tradewars knock-off. 
My first real Perl script was a streaming server, part of a larger video surveillance application. It took a bunch of jpegs ( saved by [motion](http://www.lavrsen.dk/twiki/bin/view/Motion/WebHome) ), added some metadata and sent them to a Java applet (via inetd). Later replaced by a mod_perl thingie + javascript "player" :) Later on, the system uncovered some night watchmen that were stealing stuff from my client's warehouse and the footage got on TV.
My first 'real' Perl program did this: [alt.devilbunnies archive](http://devilbunnies.org/cgi-bin/fetch?newsgroup=alt.devilbunnies). It has been running for 15 years now...
Translating phrases, based on a table of regular expressions and their counterpart in another language. The untranslated (wildcarded) parts were mostly numeric.
Got a list of hardware of all of the shared hosting production servers. cpu, memory, disk, nic (awful kingstons needed replacing) and raid controller. I felt like such a pimp afterward.
Read some data, automatically generate gnuplot scripts and gnuplot friendly data files, plot hundreds of figures, generate some statistics, and finally output TeX to generate a completely automated report. The report was actually a beamer presentation with hyperlinks and lots of other neat things.
It parsed the terrible ASCII invoices output by some ancient commercial software and generated nice paginated PDFs from it.
Wow, really?
The debugging was the hardest part.
My first real perl program grabed information from three separate sources: ldap, sql, and a script on the user machine that recorded how often a computer was logged into. All to determine how often a machine was used. Script was 376 lines. We were trying to lower the cost of pc upgrades by eliminating machines that were not used. Of course if you called the branch office up they would always insist that the computer was always used and that if we took it away then they couldn't do their job. Having the evidence to show that the machine is just lingering the back doing nothing and that the last time it was used was over 3 months ago encouraged them toward giving us the computer rather than giving us a fight. 
Ha! Thanks.
"Hello, World!"
Is this why she never leaves me alone?
Since I was into the "hacking" scene at the time, my first real Perl program (I think I was 17 at the time) grabbed HTTP, FTP, SMTP and SSH headers from servers. It had a nice shell-like interface to it. The code was horrible.
My first real Perl program was an SQL Editor written with Gtk::Perl and DBI (http://sourceforge.net/projects/gsqleditor), sadly I have never updated it to use Gtk2.
[A calculator](http://www.reddit.com/r/perl/comments/a2dw6/my_first_perl_program/)
My first proper Perl tool that wasn't CGI related was used to parse the output of an old AIX based 4GL tool. This was around 1999 I believe. The parse process would quickly isolate the valuable bits of information and then make sense of it qualitatively for the other members of our team who weren't as well versed in the cryptic syntax of the 4GL tool. The Perl code was crude at first. It was awkward to have to run the 4GL tool to start with and then point the Perl tool at the output. The parser started off in its initial form making three sweeps over the data before I could figure out how to make it more intelligent about remembering what it had already seen. Eventually this little Perl tool went on to become a mod_perl based web application that replaced our company's use of the 4GL tool altogether.
My first Perl script launched and monitored layout checks.
It bridged CA7 Mainframe scheduling software with EMC NetWorker backup software. Yes, it was at a bank.
A webinterface, part of a plugin I made for the Smoothwall firewall distribution. Must have been about 6 years ago, one of my first "real" programming experiences (apart from some calculator basic). Have been using Perl ever since :)
My first Perl program, which I probably wrote about 10 years ago, was basically a number cruncher: it took as input a date and the name of a planet (in our solar system) and computed the position of the planet relative to the sun on that day.
I just made one which I could possibly use. Its a stock screener which allows a user to select the top ( or worst) stock for any date in terms of volume increase, price increase or least volatility. I have not used it at all, to trade in the market ( which I dont do otherwise too). So I am not sure if it passes the "real" test. But it is still useful to me, to start as a jumping point to know about stocks which are "interesting" , from a traders perspective. The program works on End Of Day data for the stock exchange, the Bombay Stock Exchange, available freely. The values are dumped into a mysql db, from which the screener picks them up to analyze. And yes, I use mod_perl too, as part of XAMPP. [here](http://imgur.com/VwMsx.jpg) is the request page. The [results](http://imgur.com/7Fen5.jpg). Please excuse the rookie interface. I added only basic gui, mostly because I am the only user etc. Also its something I am going to change too. The only saving grace in interface is I added [Kevin Luck's](http://www.kelvinluck.com/projects/jquery-date-picker/) date picker, but anyway this is the html part. 
A nastier prank would be to install Acme::Bleach and set PERL5OPT=-MAcme::Bleach on someone's environment.
Careful messing with coworkers computers. I had a coworker FREAK OUT when I played a small prank, which I immediately owned up to. It was weird because we were on good terms, having gone out socially numerous times, and joked around a lot. He got the CEO involved and made a huge fuss. I found out later that he had been targeted for dismissal, and was therefore hugely paranoid. Well it wasn't paranoia, they ended up canning him a month or two later. But I wouldn't do that again.
wow, what a stupid piece of shit. nice work Perl people, apparently Perl is also good(among other things) for pulling pranks on your co-workers
so you just described how Dist::Zilla is good in like 1 page.. but we already knew this since it's in Task::Kensho. mr_chromatic, you are truly the master of reiteration
it sucked, like all software does
wow, Perl is a lot about websites, not much other than websites/blogs or wikis. 
This, kids, is why we use debuggers :)
Correct and Compatible, pick two
let's suppose *Reductio ad absurdum* that I am silly as you say.. please describe a production use of Perl6 (trying to do some constructive criticism over here... at least in concept)
I'm sure p5p welcomes a patch to make the semantics of scope unwinding safe while preserving backwards compatibility to 5.6. Good luck.
&gt; "[...] because you should use , but we dont talk about that until the end of this Item." Should use what? Something's missing from this sentence.
My first "real" Perl program was (and is) a world-class healthcare information system. (Full revenue cycle management (i.e., "billing and collections", electronic health record, etc.)
I have very little knowledge about Perl 6, but my feeling is Perl 5 will be relevant long after Perl 6 becomes usable, but their domains will (at first?) specialize. I am hoping that having Moose-under-the-hood and a better C interface (and possibly Parrot integration) will more than draw me to Perl 6 when I'm seeking those requirements, for sure. Obviously CPAN2 will take a while to catch up, but I doubt that long if adoption rates are decent - the infrastructure is already there. And with the rate of development of Perl 6, it's likely the code will be written long before a stable interpreter becomes available :/ There's also the answer to the very first [Perl 6 FAQ](http://dev.perl.org/perl6/faq.html), which is transportability from Perl 5 to 6. I don't think that really answers your question though.
I think this is a very good topic so I will upvote it. [see here](http://www.reddit.com/r/perl/comments/bnspc/dont_copy_that_string/c0np2yx) for a way to assess if Perl6 (and in particular Rakudo) is production-ready and what does it mean for it to be production ready. I encourage that discussion because it will let the truth surface.
it needs time... a lot of it. it also needs money and it needs people.
right, so you're telling me that it's my fault that it's not production ready. you didn't really grasp my position on this, I am completely neutral of the whole Parrot/Perl6 thing, I just want to assess if it's production-ready or not today !
Perl 6 also gets stuff done, just not at the moment - mostly due to limited IO implementation in most compilers, and due to not being optimized (and thus being slow). I'm not quite sure it's as well suited for oneliners as Perl 5 (We'll see that as soon as a compiler actually implements S19), but for the typical scripts of 10 lines or more it's very concise and gets your job done. I've tried it :-) It will take a long time to get the same richness of modules that Perl 5 offers, but people are working on a perl 5 bridge which lets you use Perl 5 modules in any parrot based compilers, and over time people will port modules to Perl 6 too. For modules you just have to think in larger time scales, in 5 to 10 years or so.
I haven't followed Perl6 for years, after I got the impression that it was abandoning a lot of what made perl great, and trying to become more like those other languages, with "there's one right way to do it" and strictness and I just wasn't interested in that. Has it changed direction since then?
Reencoding the file with CRLF line endings is much better in this regard.
Being PHP was never what made Perl 5 great.
Most people will not use perl 6 until it appears as /usr/bin/perl or /usr/bin/perl6 or something on major Linux distros and other OS's like Solaris. 
I should hope not. Perl is my favorite language to write in, and PHP grates on me. It's just messy and sloppy without elegance, IMO.
Just as a data point here, installing Rakudo is as simple as downloading, unpacking, and then running the following: cd rakudo perl Configure.pl --gen-parrot make make install (That will cause it to download and build Parrot for you first, then build Rakudo. I think it even courteously "installs" into the Parrot dir in the current dir, rather than filling up your /usr/local with stuff.) So, it's pretty easy to get started with. Uninstalling is just deleting that rakudo directory in the dir where you ran the build commands (please correct me if I'm wrong). 
september 2000 - I wrote a bug report cgi script. The code was terrible, the ui was worse. We used it for 2 years before moving on to bugzilla, then RT.
Thanks for showing a code example of THE RIGHT WAY to open a file, Mr. "three arg open is better". :P I'm sure nobody's going to look at your article, copy and paste the bad example you gave, and put that into production code. Nope. That'll never happen.
Anyone who copies and pastes an example with a comment reading "INSECURE CODE; do not use" has bigger problems than I can solve... but good point about adding an example of the right way.
Much better now. +1 for you.
I don't really get it. First of, I don't buy the argument that having three parameters is clearer then two. And what if someone wants the magic behavior? The actual problem the article talks about is what if the filename comes from user input and the user entered something like '&gt;' at the begging to effect this functionality. Really if you suffer from this problem its your own fault for not sanitizing user input. So is their an actual reason to use the three parameter method over the two?
Why is having two arguments clearer than having one? I don't buy the argument that having two parameters is clearer than one.
&gt; but for the typical scripts of 10 lines or more it's very concise and gets your job done. That's good to hear, but does concise == simple and practical? Although Perl 5 can do lots of crazy stuff, I still think it adhere's to "makes easy stuff easy". Do you think Perl 6 does as well? 
&gt; I don't buy the argument that having three parameters is clearer then two. Imagine that there's no `warn` builtin. If you want to throw a warning, call `die` and add a special symbol to the start of its argument. If you use a string as its first argument, any number at the start represents the severity of the exception, where `0` is a warning and `10` is a fatal exception. Alternately, you could make distinct things look distinct, rather than conflating them. Even `fopen(3)` separates the mode from the filename. &gt; And what if someone wants the magic behavior? That someone can still use the magic behavior. &gt; Really if you suffer from this problem its your own fault .... I've heard that argument used to justify 40 years of null terminated C strings, and it's silly there, too.
explode was probably a bad example-comment, but if you could safely pass in an array for example, that would expand to the 4th argument to open() then there's your security risk? I'll go back under my head now.
Perhaps, you could display the arrows only on :hover? That would eliminate the annoying distraction, and they will be displayed if someone wants to click on the link (precisely the moment one needs to know if the link is external.) &gt; a[href^="http://"]:hover { &gt; background-image:url("/images/new-external.png"); &gt; ... &gt; } You might need to keep the padding-left on non-hovered links as well, in order to minimize the text-shift on hover.
perl has always helped me get things done, but i'm also looking forward to taking the time to learn perl6 and having my mind blown again. this will almost certainly the last massive rebuilding perl will get in my professional life, so i'm going to enjoy it and not try to cram to much past bias into the experience. 
perl6 will "hockey stick" when larry rewrites the camel book for it (which i sincerely hope he does)
"It thankfully steals nothing from PHP." -- that made me chuckle
Wow, surprising amount of Lisp hate in the comments...
I believe that the four-argument form only makes sense if you open to a pipe, so your mode has to be `"|-"`, but I've never had reason to use it so I can't confirm that. The documentation is obtuse on the subject. As for passing an array to `open`, it has a prototype of `*;$`, so you'll have to go through lots of contortions to get a sneaky array past code that intends to use the three-arg form.
&gt; Perl 6 also doesn't have "everything is an expression". That's unfortunate. It's one feature I'm fond of in Ruby and (almost) Scheme. It saves code, makes missing assignments a lot less likely, and dependencies are a little clearer. Any particular reason why Perl6 didn't go that route?
There is. But I have to say, I think this one is spot on: &gt; Lisp is not something to aspire to. It's alleged beauty lies in its rejection of all the useful tools of communication in favor of the dubious benefits of homoiconicity. I like Perl because of its basis in natural language; data should look different from code because they are different. Different operations should look different because they do different things. This whole notion of "you can do everything with one big S-expression" is an interesting curiosity, but it's a terrible notion upon which to build a programming language. I think Lisp is *conceptually* a most elegant language. But in practice, the lack of syntax makes it very hard to read/skim through (for me at least). If it's any consolation I think Perl goes too far the other way in having custom syntax (line noise, anyone?). Perl 6, with its multitude of funky operators, takes that even further into Haskell territory. *shivers* 
Is there any way you could provide an example of such convoluted code?! I'd love to see how that would work.
I read a 3 part article about Perl 6 in a computer magazine. Must have been 2008 or 2009. Very interesting. And very complex. But I like the grammar stuff. Haven't coded anything in Perl 6, though. Are there good sources to learn Perl 6 which are not for total newcomers? Last time I seriously used Perl (5) was over 6 years ago. Ruby and Python after that. 
I'm not sure how to do it. I don't want to say that it's impossible, but unless I've overlooked something sneaky and simple it's too convoluted to be practical.
Are you referring to the articles in the "iX" magazine by heise? Try the chapters from http://github.com/perl6/book/ . Also http://perl6.org/ has lots of links to other resources.
Yes, it was in iX. perl6.org has a Link to http://perlgeek.de/en/article/5-to-6 which seems to be a good starting point. Last century I learned Perl with Perl 5, a Perl 4 book, and the documentation about the changes. :-) 
What about the use of overloading? (anyone who was on freenode's #perl yesterday will kill me) and source filters?!
&gt;**@INC Reorganized** &gt;A reorganization of the order of these directories in the default @INC in Perl 5.12 makes Perl 5 prefer to load user-installed modules over core-supplied modules. Uh... Isn't that what some Perl ports have done for years: putting `site` in front of `lib`? In MacPerl, the Perl port for Mac prior to OSX, that was patched what must be more than 10 years ago! Nice to see Unix catching up...
And the Perl guy spends all day digging through his bag of outdated, duplicate, and unmaintained attachments...
Actually, after having used both, I've often found with Perl that although there are some outdated/unmaintained ones in there, and some duplicates, with the help of cpanratings (and also perlmonks) you can often find a well-maintained module for just what you need. And the docs for that module are generally straight and to the point: 'Here's what it does, here's why you might want to use it, here's how to use it. Hope you brought your earplugs.' :) 
I believe you're right. Yet isn't this behavior what distributors want? They don't have to maintain downstream patches any more, and distributors who didn't know to do this now get the right behavior without having to do anything.
So we can do use Switch; switch ... any more? crap I use it in places
You really want to use given/when instead.
You can, if you install Switch from the CPAN. The problem is that Switch's implementation can cause strange errors which are difficult to debug. If you use 5.10.0 or newer, migrating your code to use given/when instead is worthwhile.
Cool thanks
&gt; Any particular reason why Perl6 didn't go that route? AFAICT, Perl 6 has been lovingly and painstakingly designed, over a number of years. My guess is that there's very likely a particular reason. :) You might be able to find an answer to your question on [#perl6](http://perl6.org/community/irc). 
I've found this as well. Engage the community just a little and it's really not hard to find out what is considered a good module. That being said, I think a lot of programmers don't engage enough.
Um ... what am I doing wrong (copied from [perlsyn](http://perldoc.perl.org/perlsyn.html ) ) use strict; use warnings; use feature "switch"; my $something = 'abca'; given ($something) { print 1 when /^abc/; } &gt;syntax error at given.pl line 9, near "1 when" EDIT: added use feature "switch" 
`when` isn't usable as a statement modifier until Perl 5.12. Are you running this code on Perl 5.10? If so, you need instead: given ($something) { when (/^abc/) { print 1 } }
Ah ok. I am on perl 5.10 ... maybe it should be told like so in perlsyn no?
Hmm, I like [this page](http://use.perl.org/~nicholas/journal/40320) better for a link. It's Nicholas' own words to what he's done.
I checked perlsyn in both 5.10 and 5.12, and the 5.10 version says nothing about using `when` as a statement modifier. Were you looking at the docs on perldoc.perl.org, perhaps?
Good article... takes a little to get to the point, but it's well worth it. I use regex's pretty regularly and this is a good tip.
My first perl program was a Usenet moderation bot. Did the us.jobs.* groups, iirc.
ya. They must have made it 5.12 specific then.
If you want the picture of the future, imagine Perl 6 rewriting your accelerated selves forever :D
I'm writing a program that determines whether other programs halt
Let me know when you finish.
Do you think you'll finish?
Isn't it a bit like the static keyword in C ?
I went and asked on #perl on freenode but no one came up with a good suggestion ... I hope I'll get something from here ! To be more specific, I'd like to fetch quotes for this ISIN : FR0010128587 (that's a real world example, I've got others I'm interested in too) I hope a fellow redditor will come up with something ! :-)
Yes, you can think of it that way. (I won't say anything about how it works with Perl threads, because I haven't read much on the subject and I haven't experimented with threads and state myself.)
Why is Finance::Quote not good enough? When you mean 'better than F::Q' do you mean: * speed * more comprehensive * ... Basically clarify your requirements. Also make a perl CPAN module for google finance api might be a way to go. http://code.google.com/apis/gdata/docs/2.0/basics.html
Did you even try searching CPAN? http://search.cpan.org/search?query=Stock+Quotes&amp;mode=all
The issue is that the above ISIN is not for a stock. If you try fetching its data either with F::Q or just via GoogleFinance you won't have anything  nothing is available in generic open sources like Google or Yahoo. This seems like one of the funds managed by BNP Paribas
Then the first question is not: what module to use, but rather: what (web) source should the data come from? Even CPAN cannot do miracles.
Like you say, more comprehensive. Finance::Quote running speed is OK, I mean I don't have strong requirements at all. Thanks for pointing the google finance API; I'll have a better look, however at a first glance it seems to me that there are only American exchanges (not European, and I'd need that).
I most certainly did. But the problem is always the same, this pulls tons of modules, and I can't just try them all to see which one works :-) That's why I ask the question, hoping that someone knows a module which works well, and help me pick the right module. Thanks anyway.
Yes, that's why I'm searching for something more comprehensive. F::Q does a good job for most of my stocks (using the yahoo_europe source), but this ISIN and a few others, nothing gets pulled. I can find the information on the web interface of boursorama.fr. But the "bourso" source doesn't fetch the data (neither for this ISIN, nor for my other stocks). I was hoping that another module would work better.
web source boursorama.fr has the data I need, but the bourso source of F::Q unfortunately doesn't fetch it. Or maybe the mistake is mine ! Care to see my source code ? Where should I post it ?
Old news. The announcement originally already dates from [April 13th](http://use.perl.org/article.pl?sid=10/04/13/1953252), just over 2 weeks ago.
Has there been any movement on using Moose in Padre? (That is, writing Padre itself using Moose.) Last thing I read about it was [back in September](http://use.perl.org/comments.pl?sid=43745&amp;cid=70495). 
Not as far as I know. It would be nice, but I'm guessing most people on the project have other priorities right now.
&gt; innovations like Iron Man help too. that's not an innovation, it's just that Perl programmers understand that Perl is plummeting extremely fast and they had to do something about it, so that their beloved language won't completely disappear and that they won't loose their jobs or will continue to get new work. the idea of creating buzz around the language is obviously meant to create the impression that it is still relevant and useful. it remains to be seen what changes it will bring. the job market for Perl is still very bad and because of Perl's reputation as a language for writing obfuscated code and because it's used mainly by sysadmins things won't change anytime soon. &gt; Perl Monks has always been the envy of other communities no it's not. it's just another website where programmers as questions and other answer them. &gt; Why Padre is important Padre is not that important for non-Perl programmers... it has a limited userbase because it's a WYSIWYG editor/IDE thing and it's focused on Perl. it's brings more burdens then actual benefits. I think vim offers much more than Padre does, and vim will continue to be better. 
Iron Man is an innovation within the Perl community at least. It was created because a lot of the talk around Perl was not indexable (and therefore searchable). Perl Monks was set to turn Google away for a while as well. Things like TIOBE (which are fairly poor indicators of popularity, but quoted often nonetheless) were showing a decline which people within the community didn't think reflected what was going on. And surprise surprise, Perl's TIOBE ranking is now improving. As for jobs, do you have evidence to support that? There are more Perl jobs than most other languages, including Ruby, Python, and most other things besides Java, C, C++, C# and maybe PHP. (No evidence either, but I'll dig up links when you do). As for whether Padre is important to Perl, are you really qualified to comment? You clearly don't like the language, and have a negative opinion of the community. I really wonder why you're even reading this subreddit.
&gt; I really wonder why you're even reading this subreddit. For the same reason he/she trolled that Perl 6 thread on PerlMonks anonymously.
Can you remember any of the things that made you feel so? 
I'd like to see a module that can give me tomorrow's stock quotes.
Oh you caught it! I was reading his post and was like where have I read this before. 
&gt; Things like TIOBE (which are fairly poor indicators of popularity of course it's not a poor indicator. it's very precise. It's just Perl's popularity is very very small and is being used in less and less projects. &gt; Iron Man is an innovation within the Perl community you're ridiculous. there was stuff like planet perl and use.perl.org and perlbuzz and many many others. Iron man is just a rss blog aggregator. They made it in order to index Perl's buzz-buzz to turn Google into thinking Perl really is important. &gt; There are more Perl jobs than most other languages, including Ruby, Python, and most other things besides Java, C, C++, C# and maybe PHP. (No evidence either, but I'll dig up links when you do). What the heck are you talking about ? I've a rss feed for jobs.perl.org and there's like 7 jobs every 1-2 weeks and they're all in the U.S. or UK. That's lame. &gt; As for whether Padre is important to Perl, are you really qualified to comment? You clearly don't like the language, and have a negative opinion of the community. I really wonder why you're even reading this subreddit. Wat ?! Of course I'm qualified to comment , and yes I know the language. It's a technology that is plummeting quickly. If you don't know that by now you're either a zealot or just a fool. &gt; You clearly don't like the language, and have a negative opinion of the community. I really wonder why you're even reading this subreddit. because I don't like people jerking off at each other over how important Padre is and I find that ridiculous and stupid.
it sounds familiar because you've read this before in many places. that's because it's true.
not my fault people jerk off at each other and promote technologies that are not production-ready as **ready today** or **you can use Perl6 today!** which is of course extremely lame... because anyone who's been using it for more than 1 hour knows it's not ready and 10-20 years need to pass until it will be.
&gt; it's just that Perl programmers understand that Perl is plummeting extremely fast You've got to be joking. I'm still seeing regular releases, popular modules receiving updates, and the usual upbeat news from various perl-related blogs. &gt; &gt; Perl Monks has always been the envy of other communities &gt; no it's not. it's just another website where programmers as questions and other answer them. I disagree. Other languages have q &amp; a forums, but Perlmonks is different. People there make it their *business* to be courteous and helpful, and any rudeness is decidedly frowned upon. 
sure anyone can say something is true without any facts. btw I just shat out a gold brick. it's true. 
&gt;What the heck are you talking about ? I've a rss feed for jobs.perl.org and there's like 7 jobs every 1-2 weeks and they're all in the U.S. or UK. LMAO. This is your proof. Do you even know how to make an argument? You do realize the difference between real life and a web site right? You lack the most basic understanding of statistics. 
wat ? dude, 7 jobs world-wide every 2 weeks. keep your understanding of statistics for yourself...
LMAO you still don't get it. This is hilarious. Man I love you man. You made my day.
no I don't, go ahead and explain what you mean, if you're capable of explaining.
Ok when you point to a job site and say look there are only 7 jobs here so that means you have only 7 jobs for Perl in the whole world! But you don't take into account: - Not everyone uses jobs.perl.org, you don't even know how many companies use jobs.perl.org - That number of jobs published != number of jobs there are Let me elaborate on the 2nd point. Most companies don't publish job offerings externally on public but rather internally or in closed circles. see this: http://www.computerworld.com/s/article/print/9004788/The_Truth_About_Internal_Job_Openings Next you cannot use a sample of 1 site to prove anything. The sample is too small. That is like if I asked 2 guys on the street do they like bananas or oranges. If they both said bananas that doesn't mean 100% of people like bananas. This is why TIOBE and all this 'facts' are bogus. They don't take into account bias, sample sizes, variances, loaded questions ... and a lot more other things. The bottom line is I can make anything seem true by picking a specific site or number that caters to my conclusion. 
&gt; Let me elaborate on the 2nd point. Most companies don't publish job offerings externally on public but rather internally or in closed circles. see this: http://www.computerworld.com/s/article/print/9004788/The_Truth_About_Internal_Job_Openings dude do you have any idea what [you linked me to](http://www.computerworld.com/s/article/print/9004788/The_Truth_About_Internal_Job_Openings) ? that article talks about how to get a job in a company you're already hired to. how is that relevant to our discussion ? did you just make some random search on google and gave me the first link without even bothering to read that article ? also, if a company doesn't post its job offering on jobs.perl.org it probably means one of the following * it's not a company taking Perl seriously so it doesn't bother to post the job ads where they should be.. * it's looking for local candidates and puts the job offer where local candidates are looking * they probably have some "careers" section on their website where they publish the job (but they usually publish it on some job site like monster or whatever, so this item in the list shouldn't really be here..) (if you can add enough elements to this list I'll probably give up and admit you're right..) &gt; Not everyone uses jobs.perl.org, you don't even know how many companies use jobs.perl.org &gt; number of jobs published != number of jobs there are thanks Captain obvious! &gt; Next you cannot use a sample of 1 site to prove anything. The sample is too small Cool, give me some more sites so I can prove it to you that I'm right. &gt; The bottom line is I can make anything seem true by picking a specific site or number that caters to my conclusion Ok great. Make me a list of sites you think are relevant for Perl jobs, and I'll give you a detailed statistics of the number of jobs Perl has and also locations. I hope you won't feel bad when you'll find out that I actually am right. I'm not reluctant to actually proving my claim with a very strong argument, and I will show to you that I'm right.
LMAO you are funny and a total troll. Nice! Thanks for making my day. 
&gt;because I don't like people jerking off at each other over how important Padre is and I find that ridiculous and stupid. wow, I'm really glad we've got people like you who have so much time on their hands, they can sit around monitoring reddit, and waiting for us to post something so they can tell us how stupid we are. Seriously, you don't like Perl. We get it. But maybe you should move on with your life and let us do something we enjoy. Maybe get out of the house once in a while? Try to find a girlfriend? Or just do something *you* enjoy, instead of being upset that other people are the ones enjoying themselves. You'll be much happier with life I'm sure :)
Yes. The one perl developer in poland has a good job. Horray for him.
Haskell's higher than Perl ;)
Without looking at the data, my guess is not that it is the _jobs_ that are better paid, but the developers, whom are more likely to be older and more experienced.
so I just offered to give you detailed statistics on the sites that you find relevant, and I'm a troll ... right.
&gt;Perl developers earn the highest salaries in Poland (50% more than PHP coders) Of course. That's very reasonable, as PHP "programmers" are not actually programmers, but more glorified web site designers -- or rather, automaters. Don't expect a standard professional PHP programmer to solve complex programming problems.
Gah ... people need to stop using websites as authorities on the job market.
:)
or maybe "Why Perl 6 isn't finished and thus is useless"
What the hell is 'Business Awareness', and why would anyone think the population of a general purpose social networking site be correlated to "Business Acumen", ( If that's what 'Business Awareness' means ) 
I wasn't talking about the programming language and whether or not it's a scripting language. I was talking about typical PHP jobs. 80% of those people's jobs are developing websites, i.e. HTML; automating it with PHP is pretty much an afterthought.
you have been served!
You are so right I have been so blind! I will go delete all my Perl and PHP code. You da man kywoto.
haha! Zing! You got them boss! They will not do this useless thing no more! W00T! you da man Kywoto
Which is exactly what Perl developers do. Look at 99% of the job ads on jobs.perl.org they are exactly what you wrote, writing Perl , HTML/CSS whatever, writing in a framework for web development, automating, testing... that kind of stuff. It's only that Perl people have this false feeling of superiority which is just stupid and ridiculous. Perl has Catalyst , PHP has symfony/cakephp which is like 100x times more popular. The main motif/theme of Perl is web development and crappy little sysadmin scripts.
just put it on a private disk and lock it in a drawer or something where it will be far from the light of day.
you know I'm right
I like this very much so I will upvote it. The author has taken a lot of care in gathering statistics and made a very good and objective comparison. I think more honest statistics(like this one) with numeric evidence are needed to see where exactly Perl stands at the moment instead of the big circlejerk that is present in the Perl community today.
LMAO you again! :) you make my day!
OH please make more post like this I wanna see kywoto implode. PLEASE!
Least helpful comment ever!
Try submitting this to /r/apple. And you might consider packaging things a bit more, if possible.
You might be interested in [`String::ShellQuote`](http://search.cpan.org/perldoc?String::ShellQuote).
Ok will do. We can't package this yet as we are waiting for reviewers.
I looked at its code for ideas when I first approached this. It's not useful as-is in this situation.
I just tried to install it over 5.10.1.1 and it broke. trying to uninstall and reinstall. Edit: 5.12.0.0 does not seem to work on my machine I think I'll switch back to 5.10.1.1 for now Edit2: nevermind looks like I had to delete the old folder after uninstall and then reinstall. looks to work now. I'll have to rebuild my modules now. Oh well. 
Uses GCC-4.4.3 instead of the GCC-3.4.5 now.
You can't install Perl 5.12.x over a perl 5.10.x (like you could install various releases of the 5.10.x series (which was still a bad idea)). The new release has a different folder structure, a new C compiler, and modules compiled to link with the older perl510.dll won't work with the perl512.dll. Good luck rebuilding. It is worth it. 
Ideally you'd avoid the shell via "system @cmd" (if you don't need to capture output/send input) or IPC::Run/IPC::Run3 (if you do).
Since I do need the output (as I mentioned above) and since this is a remote command being sent via ssh, I can't completely avoid the shell. I couldn't completely avoid the shell even if I didn't need to capture the output. I *could* avoid the local shell with a module, but in this particular case adding modules that weren't bundled with Perl5 on the OS would've introduced various other headaches. The gain in having to quote for one shell rather than two would've been more than outweighed by the effort required to deal with module distribution.
Urm, wait. Didn't I read somewhere that MinGW was something to stay far away from? Either use gcc 3.x, or gcc 5.x, but *never* 4.x...? Maybe I'm wrong, maybe it's MinGW 4 you have to steer clear from. Yeah, that's probably it, as MinGW 5.1.6 appears to be using gcc 4.5. __update__ I've been hunting around for info about MinGW in this regard, but I couldn't find anything. Well, that info would probably be obsolete anyway... So: never mind. You can only get MinGW 5, anyway.
I think then it would have been a better idea to name the root directory differently than "c:\strawberry", just like the old one. 
Strawberry Perl 5.12 is out?? Man, that was quick! It's only been a few weeks since the main release, targeted at Unix, came out...
It's not really accurate to say that the main release is "targeted at Unix". Perl 5 has had a unified codebase since the 5.6 days. Strawberry's a distribution that Curtis and company have already built. It's more like a .deb or an RPM than a port.
You can call the root directory anything you choose. Just avoid giving it a name with spaces in it, or installing it in any directory path where there are spaces in the names. 'C:/strawberry' works, so does 'C:/perl' or 'C:/users/perl' - but 'C:/My perl' or 'C:/program files/perl' may lead to unpredictable consequences.
The MinGW-5.1.6 installer will install GCC-3.4.5. There is no official automatic installer for the latest GCC-4.5.0 yet. GCC-4.2.x had problems, but this release of Strawberry Perl was compiled with, and uses GCC-4.4.3 so it is cool. It is a better compiler all round. MinGW is just a distribution of GCC for Windows. The name stands for **'Min**imalist **G**nu for **W**indows'. There are others - such as DGPP, Cygwin, Microsoft services for Unix, MKS Toolkit, Uwin, Interix - all of which are attempting to port some Unix functionality to Windows. 
Not sure, but have you tried posting on perlmonks.org?
Maybe a stupid remark, but have you enabled $Storable::Deparse too? What you posted it is a deparse of a hashref (or actually an DBI::st object), not a coderef, are you sure you're feeding it the right thing?
Or stackoverflow.com?
definitely perlmonks.org , people have skills there while on reddit it's mostly "blabla blabla bla bla bla bla"
Yes. The DBI::st likely contains the coderef. I didn't post all the log file crapping, for one operation, it emits more than 16K. There's no way I can put that into production.
Bye ... don't let the door hit you on the ass on the way out.
You're trying to store a DBI statement handle, which wouldn't be the least bit useful even if it didn't make all of that noise.
I'm not concerned about reusing it. The object being stored has a ref to the handle. I just want the noise to stop.
If you're trying to store a datbase handle via serialization, you won't have much fun anyway. For that you should look for different persistence solutions (that can keep objects within a perl process) That said, I think it's a bug that Storable produces debugging output. If it's not fixed in a newer version of perl, please report it as a bug.
I'm not actually trying to store the DBI handle, it is just a member of the object being stored. What I posted is an excerpt of a 16K byte trace emitted by a single operation. Where do you report bugs in CPAN modules?
On it's bug trackers. For Storable it is https://rt.cpan.org/Public/Dist/Display.html?Name=Storable .
Chrome tells me: &gt; You attempted to reach memberservices.informit.com, but the certificate that the server presented has been revoked by its issuer. This means that the security credentials the server presented absolutely should not be trusted. You may be communicating with an attacker. You should not proceed.
Perl 6 is as vaporous as Duke Nukem Forever, imho.
Did you try to find help with your problem? I've always had good luck with the Perl community if I had a problem I couldn't solve. Perhaps I'm just lucky, but with the exception of some poorly made libraries I've encountered, I've had minimal difficulties with the language.
I heard that the only successful test is the one that fails - if you write a new test, it should fail until you fix it the problem.
Yeah... no one... except every place I worked for in the last 10 years... all of whom had both legacy Perl and new development in Perl all the time.
Sometimes you can't help but feed the trolls.
Thanks.
I am curious, where do you work? Do you work with Perl? 
You can install Perl 6 and try right now.
The most correct thing to do is probably to delete the handle from your object being stored immediately before you store it. Serializing objects with live connections to something just means that when you thaw it later on you'll get connection errors.
I recall reading that Mouse was no longer being supported and the developers were recommending that people didn't use it any more. However, that's clearly not the case as the most recent version of Mouse was released just a couple of days ago. Am I confused? Did I imagine something that didn't happen, or has Mouse been resurrected? 
I haven't heard that, but I'm not very much in the loop. [Squirrel](http://search.cpan.org/dist/Mouse/lib/Squirrel.pm) has been deprecated in favor of Any::Moose, though.
The [main POD](http://search.cpan.org/~gfuji/Mouse-0.58/lib/Mouse.pm) says so: "Moose is wonderful, use Moose instead of Mouse". Mainly due to lack of maintainer, [as it seems](http://www.nntp.perl.org/group/perl.moose/2009/04/msg653.html).
Ah, maybe it's Squirrel I'm thinking of. Apologies for my confused state of mind. 
Yup, and it's entirely correct. You should use Moose. However, for things where startup time is paramount Mouse is around to make things better.
Indeed, and I can fully understand why one would prefer to use Mouse for certain projects. However, that choice might not be very future proof: I have already experienced slight incompatibilities between Mouse and Moose, and I guess that -- being unmaintained -- that won't get much better either. I can't wait until Perl 6 becomes usable though, providing core alternatives for Moose et al.
I'm not sure I'd call Mouse "unmaintained", since the last release (0.58) was one day after the last Moose update and there have been seven Mouse updates in the last month. If you see incompatibilities between the two that are in the realm of what Mouse is trying to do, I'm sure the maintainers would appreciate bug reports in rt.
Oh, after reading that mailing post I just assumed it still was unmaintained and Mouse v0.58 correlated with Moose ~v0.53 (last release before that post). I'll be sure to have another look at the incompatibility, it concerned type coercion IIRC.
You misspelled Ruby.
You assume I'm going to try to use the connection later, which I'm not.
Of course not, so there's no harm in removing it, which saves you all the trouble :)
I think the original maintainer left and told people not to use Mouse, but then someone else picked it up and started working on it again. They forgot to remove that note from the POD, though.
Perl is the glue that holds infrastructure together. It is the duct tape of the IT industry when shit breaks on a grand scale and a simple resolution is not viable perl is the first thing I have always turned to. LDAP replicas not syncing? Perl. All the computers dropped from the domain? You need a perl script. Trying to find out why you have 3000 computers on your domain when you only have 700 users? Perl. Is it broken? Perl can fix it. Industry strength, high protein and guaranteed to solve your fucking problems. It @slices it dices it even makes julienne fries.
what has impressed me is how open to change the perl community has been over the years. look at something like moose...on its own it has generated a micro-community within the larger perl community...same with plack, anyevent, and lots of other foundational package sets perl also has a quality community of skilled coders. look at the relative sizes of the perl and php communities. now look at the community contributions...pear should be 10x the size of cpan and 10x as good...yet the opposite holds. when it comes to communities, i will take quality over quantity any day
obligatory xkcd: [Regular Expressions](http://xkcd.com/208/) and [Lisp](http://xkcd.com/224/)
Try running that with original set [4; 0; 0; 0; 3; 3]. I'm not a perl 6 programmer, but I suspect it won't do what you want.
The log is only an excerpt. Storable is barfing out 16K of log per operation, and on things I do want to store.
You are right. I updated the code above to handle zero values. Thanks.
Well I'm not sure using a stateful counter counts as a functional approach. My initial try is perl 5 and ugly as sin: use List::Util qw/reduce/; my @input = ( 4, 5, 5, 5, 3, 3 ); my @r = splice( @{ ( reduce { defined( $a-&gt;[ 1 ] ) &amp;&amp; defined( $b ) &amp;&amp; $a-&gt;[ 1 ] == $b ? [ $a-&gt;[ 0 ] + 1, @{$a}[ 1, 2 ] ] : [ 1, $b, [ @{$a-&gt;[ 2 ]}, @{$a}[ 0, 1 ] ] ] } [ undef, undef, [] ], @input, undef )-&gt;[ 2 ] }, 2 ); print "(", join( ",", @r ), ")\n"; # (1,4,3,5,2,3) There's probably much nicer ways to carry the anonymous arrayrefs around and to dereference them, but I'm a too fuzzy-headed to think on it further today. :)
Wow, I am asleep, soon as I post I realise I'm being an idiot: use List::Util qw/reduce/; my $input = [ 4, 5, 5, 5, 3, 3, ]; my $r = ( reduce( { defined( $a ) ? ( defined( $b ) &amp;&amp; $a-&gt;[ 1 ] == $b ? [ $a-&gt;[ 0 ] + 1, @{$a}[ 1, 2 ] ] : [ 1, $b, [ @{$a-&gt;[ 2 ]}, @{$a}[ 0, 1 ] ] ] ) : [ 1, $b, [] ] } undef, @{$input}, undef )-&gt;[ 2 ]; print "(", join( ",", @{$r} ), ")\n"; Some careful fudging with ref( $a ) might let you trim the first undef off if it bothers you, but there's nothing wrong with using delimiters to mark the start and end of your data IMO.
I like the way Perl 5 has it as a declaration so you get to have subroutine definitions aligned to the left. making it a block would result in too much horizontal whitespace. Most of the time you only have one per file anyway.
Problems with msnbot don't appear to be unique to cpantesters. Many people complain that [msnbot ignores robots.txt](http://www.google.com/search?q=msnbot+ignoring+robots.txt). 
What standard does microsoft EVER follow ?
How much do you know about programming already? Was your previous experience work experience, or was it dabbling as a student?
It was as a student in high school. I started with basic in elementary and moved on to pascal and C. I played with Java when it was new, but I have not legitimately coded in more than a decade. I still consider myself a decent logician, but I have more than a little rust when it comes to putting down code. 
If you're comfortable working with Git and Github (and don't feel badly if you aren't, as you don't need to be to start learning Perl), I'm finishing a book called Modern Perl which intends to be useful for people in your situation: you know the basics of how to program, but you want to learn how Perl works. See [Modern Perl on Github](http://github.com/chromatic/modern_perl_book). If you're not comfortable getting the book from GH, installing a handful of CPAN modules, and building the HTML let me know and I'll figure out another approach.
Ask lots of questions on [perlmonks](http://perlmonks.org), even if you think they're dumb. If you think they're too dumb then search Google for 'foo' with 'foo site:perlmonks.org' for over a decade's worth of quality advise. Posting code in questions improves answers dramatically. In fact the most basic questions tend to be the most enlightening. Perl is a pretty esoteric language, but it's extremely expressive once you get the hang of it. Really try to understand data structures, references, [map](http://perldoc.perl.org/search.html?q=map) and [grep](http://perldoc.perl.org/search.html?q=grep). Learn how to install a module from CPAN, understand its API, load it into your program and call its methods. These are the most essential Perl skills in my opinion. Also: Perl has copious documentation (perldoc). Use it! Bookmark http://perldoc.perl.org/search.html?q=%s in Firefox and assign it some short keyword ('pd' or the like). Then CTR+L, 'pd foo' to search perldoc for foo.
Disclaimer: I would characterize myself as an intermediate-level Perl programmer. I am pretty familiar with the language and have my own style with it for general utility scripts, but I don't regularly work on huge projects and have never gotten my druthers together to submit anything to CPAN. I would say that it's fine to learn from the standard beginning Perl books (like *Perl in a Nutshell*), but they (and a lot of tutorials on the Web) are written in an old style of Perl that should be allowed to die out. I don't know *Beginning Perl for Bioinformatics*, but the Google Books preview shows that it doesn't demonstrate great Perl programming. It may be great for showing how to do different manipulations of bioinformatic-style data with Perl, but don't take it as a good source of how to actually structure well-engineered programs in Perl using all the tools that today's CPAN and Perl distributions have to offer. I'm not familiar with *Modern Perl*, but it sounds like a good place to start. If you become comfortable with Perl, I recommend [Higher-Order Perl](http://hop.perl.plover.com/) as a stop along your way to read about some interesting and very useful programming techniques that can be expressed easily in Perl. Random bits of advice: * Utilize [Perlmonks](http://perlmonks.org/). If you have a Perl question you think might have been answered somewhere on the Web, be sure to check there. * Find a Perl development environment that works well for you. [Padre](http://padre.perlide.org/) has been self-promoting heavily lately, and I am very fond of cperl-mode in Emacs. You should experiment and find something that works well for you, eventually feeling like an extension of your mind that helps you write and modify code fluently. * Use the right tool for the job. Perl is great at data munging and quickly putting together scripts which glue things together, but if you ever decide you want to write a Viterbi sequence classifier or chart parser for things on the scale you find in bioinformatics, you are probably better off looking at a language that is better suited to that task.
[This should get you very far](http://korflab.ucdavis.edu/Unix_and_Perl/index.html)
You will study the works of one Damian Conway. You will wear a tinfoil hat.
[BioPerl](http://bioperl.org/) has an extensive (some say daunting) collection of modules that make a lot of biology programming easier (particularly but not exclusively sequence analysis oriented). There is also a mailing list that has a number of experience and generous bioinformatics programmers who are often able to help out. My advice would be to just start with some problems you want to code up and ask there (and perlmonks as has been suggested elsewhere here) when you stumble.
The standard about not following other standards.
One piece of advice that it doesn't seem anyone has offered yet: don't call it PERL if you want to be taken seriously. It's a shibboleth, plain and simple. "Perl is the language, `perl` is the program, PERL isn't anything." Randal Schwartz used to have a game of pretending that anyone writing "PERL" meant the conservation organization [Protecting Escarpment Rural Land](http://perlofburlington.org/). Another piece of advice: *references* and *context* are the two keystones to understanding intermediate-level Perl. Once you feel like you have a grasp on the basic language, go out and try to *really* understand how references work in Perl and how context affects the meaning of every statement you write. To reiterate what roguebagel said, read the perldocs! Especially `perlreftut`, `perlrequick` and/or `perlretut`, `perlsyn`, `perldata`, `perlop`, the `perlfaq`1-9 pages, and `perlfunc` as a reference. Every module on your computer or on CPAN also has embedded documentation; never hesitate to use it.
In all honesty, I learned Perl from the manpages. perlintro, perlreftut, perlrequick, and perltoot are what got me started with the language. That, and working with a fairly large Perl codebase. So read some manpages, and work on someone elses code, even if you don't ever send your patches to them. perldoc is also incredibly useful. If you're curious about a function built into Perl, use perldoc -f &lt;function_name&gt;, or if you want more information about a Perl package or class, use perldoc &lt;class/package_name&gt;.
I would suggest the O'Reilly books for Perl. "Learning Perl" and "Programming Perl" were the books that helped me the most when I first started. And once you get the basics, it doesn't hurt to get "Perl Cookbook" to see some interesting examples of doing certain things. Whether I'm downvoted or not, I don't care, these are the things that helped me get started and helped me to learn the easiest. I also agree that using PerlMonks is a great place to ask questions. One thing that I have noted, however, is that Perl programmers tend to be a bit more cynical than the average.. so going on the IRC might seem helpful, but you'll spend a lot of time dealing with assholes.
Oh and as a follow up.. O'Reilly even has a book called "Beginning Perl for Bioinformatics".. I can't help being an O'Reilly fanboi.
It would be nice if you could set up an automated monthly build of the book html and make it available somewhere. 
Have a look at [this tutorial](http://learnperl.scratchcomputing.com/), but use [Moose](http://search.cpan.org/dist/Moose/lib/Moose/Manual.pod) instead of raw Perl 5 features for creating classes and objects. 
&gt; Well I'm not sure using a stateful counter counts as a functional approach. Goes to show how much I know about functional programming :( Anyhow, here's pretty much a translation of your code into Perl 6: use v6; my @in = @*ARGS || (4, 5, 5, 5, 3, 3); ( reduce { $^a.elems ?? $^b != $^a[*-1] ?? [ $^a[*], 1, $^b ] !! [ $^a[0..$^a.elems-3], $^a[*-2]+1, $^b ] !! [ 1, $^b ] }, [], @in ).perl.say; Hopefully, that's functional enough :)
Randal Schwartz' *Learning Perl* is an excellent book to start with, followed by *Learning Perl Objects, References &amp; Modules.*, by Randal Schwartz and Tom Phoenix. For a practical reference or browsing book full of examples, get *Perl Cookbook* by Tom Christiansen and Nathan Torkington. I learned a considerable amount from it, too. For tips on writing clear and maintainable code, Damian Conway's *Perl Best Practices* is highly recommended. For more advanced topics when and if you need them, try Damian Conway's *Object-Oriented Perl* and Mark-Jason Dominus' *Higher Order Perl*. For far more than you probably ever wanted to know about regular expressions, see Jeffrey Friedl's *Mastering Regular Expressions*. All of the above are very well-written by well-known, respected, and knowledgeable people in the Perl community. Unless you're writing large systems that many people will work with, the first three will teach you just about everything you need for short hack-it-together utility programs. Don't forget the voluminous documentation bundled with Perl, especially the FAQs. That should keep you busy for quite a while. 
I was a Perl programmer for a few years. When I started at that new job, I had just moved to a new home and didn't have the Internet nor TV for a month. I used it to read Programming Perl thoroughly, and found that's all I needed.
Conway's book is a must. HOP is a later good read - mainly because in biology, you use a lot of algorithms that can take advantage of dynamic programming. Also, obvious: BioPerl?
Their books are almost all out of date, unfortunately. Beginning Perl for Bioinformatics came out in 2001. At least Learning Perl covers Perl 5.10.
The OP said s/he already had *Beginning Perl for Bioinformatics*, so there seemed to me to be no reason to recommend it. And I haven't read it, so I have no opinion.
This. Read perlfunc, perlvar, and perlre. Use "perldoc -q" to search the FAQ. Pay attention to the examples, as they show idiomatic ways to do things. Then ask on Perlmonks if you still can't find the answer. 
Thank you everyone for all the great resources. I am going to look into them and then I will check back with an update.
Thanks for the tip. I saw that after I posted the question. Unfortunately it was too late to change the name in the submission. I don't know if properly calling it Perl is going to be enough for me to be taken seriously, but it is a step in the right direction. 
Making an attempt, and providing well though out questions indicating that you have read the appropriate documentation (perldoc is excellent) with code examples and example data when needed will be enough to be taken seriously. Using the right name is just icing.
&gt; What should this code produce? my $x = 'hello'; my $y = 'world'; print $x + $y; **ERROR: Attempt to add non-numerical values $x ('hello') and $y ('world') at line 3 of chromatics_example.pl (did you mean to use '~' for string concatenation?)** I once thought that overloading '+' for string concatenation was a pretty nifty trick. Now I recognise it for the abomination that it is. Don't get me wrong - polymorphic operators are a good thing. 10 + 20 # add two int 3.0 + 0.14 # add two floats And if, like Perl, your language support implicit conversion between strings and numbers (a useful, but questionable policy, IMHO), then the following are also acceptable. '10' + '20' # 30 '3.0' + '0.14' # 3.14 However, overloading '+' to mean both numerical addition and string concatenation (and/or array concatenation) is a very dangerous practice that leads to ambiguous code. Yes, Javascript, I'm looking at you. If Perl overloaded '+' for string concatenation then what result should this code yield? '555' + '-1234' The answer I'm expecting depends if I'm adding sales figures or constructing telephone numbers. Perl (assuming implicit numification of the arguments) would yield -689. Javascript (which would require parseInt() to force numification) would yield '555-1234'. In short, you can have implicit numification of string *or* you can overload '+' for string concatenation, but you can't have both. (I realise I'm repeating much of the gist of Chromatic's post, but this one touched a nerve with me...)
&gt; With a 100,000 row file: Perl - 10.96 s Scala - 13.31 s Go - 16.77 s &gt; With a 1,000,000 row file: Perl - 111.3 s Scala - 115.5 s Go - 154.3 s 
&gt; I once thought that overloading '+' for string concatenation was a pretty nifty trick. Now I recognise it for the abomination that it is. It works, technically, if you have polymorphic operators and a strict value typing system. It *may* work syntactically, if your users can handle operator overloading where the semantics of operators can change.
I knew perl was gonna win, because this was posted to /r/perl.
&gt;(I don't know why Blogger is pushing the table half a mile down the page; any suggestions?) 27 `&lt;br&gt;` tags between this question and the table, that's why.
I can't seem to actually run the shooter.run file... do I need the SDL module installed? It kind of hinders the idea of packaging a script if you need to install an additional module. 
F'n nifty! I hope we'll have full Perl script support on Android devices in the near future.
well what was the prank?
There are some modules for working with an SSH connection. I think the best option is Net::SSH2, as long as you can install libssh2.
I substituted his email program desktop shortcut for a simple script that popped up a fake error message, giving him two (fake) choices, one was format his hard drive and the other I forget, but it wasn't much better. It really didn't do anything. And I was right there so I fessed up immediately. The guy was just a paranoid. But I guess you never know who's worried about getting axed and thinks everyone is out to get him.
I'm sorry to say, but this is a lame test. &gt;This project benchmarks the performance of Perl, Go and Scala with some basic data processing from a CSV file. And this is the core from the Perl routine: &gt; use Text::CSV; &gt; my $csv = Text::CSV-&gt;new; &gt; while (not $csv-&gt;eof) { &gt; my $cols = $csv-&gt;getline_hr($fh); &gt; next unless $cols; &gt; printf('%s is %.02f%s', &gt; $cols-&gt;{name}, &gt; ($cols-&gt;{'integer'} * $cols-&gt;{'float'}), &gt; "\n" &gt; ); &gt; } There's not much that Perl does: the bottleneck will be largely be just the speed of reading from the file. And that'll be the same bottleneck for every language. 
Did you chmod a+x the file? Also note it is still alpha. Please place your bug report here. http://sdlperl.ath.cx/projects/SDLPerl/newticket
like it, thanks for the reply to such a late comment :)
Excellent post chromatic. Probably one of your best recently. It's a nice soft presentation of the merits of OSS, as well as a gentle reminder that you can't expect something provided to you for free will come with 24x7 support and commercial level SLA's (not that I've seen (m)any commercial SLAs worth the paper they're written on). The fair consolation is that anyone competent in the language can be turned to for support, because everything you need is there in the open.
Ooo I didn't know this was possible. So soon we should be able to run our own code?! Awesome. Just for fun I'll make a script that (hopefully can utilize cron of some kind) will change ringer styles depending on time of day. If at work or school, its silent.. or something. I'm not very good at perl but it would be fun to toy with
Ok, so I took the survey. I have to say that I'm not sure the questions quite captured my relationship to Perl: I use it regularly to solve small (but important) problems, and my Perl experience has shaped my interaction with every language I've used since I first learned it, and I'd still use it to solve more (relatively) big problems if I weren't stuck solving (relatively) big problems in (sigh) PHP because my employers decided years ago (god dammit) to install osCommerce (rage), which doesn't strike me as a thing that reflects much on _Perl_... (Note to self: Stop commenting here while drinking.)
I'm doing **everything** in Perl. Perl is the reason I'm programming at all. I've struggled with python (I just cant grasp that syntax), C++ (learned a little, but never made any REAL applications) and, sigh, some Java. It wasnt until I found Perl that I finally found **my** language. You know that feeling, 'this is where I belong'? It was exactly like that. What do you think of the Perl Certificate? I think it would be a truly awesome thing, and I'd certainly get one.
Shoulda just used PAR.
&gt;What do you think of the Perl Certificate? Well... I think it would mostly attract the wrong kind of programmers, the people that are now drawn to ASP and .NET... Now, if people apply for a Perl job, you *know* he's into Perl by his own choice. With a certification, you would no longer be sure...
I guess I need to get off my ass and contribute to CPAN. I have a module I meant to upload, but I never got around to writing up all the other bits that are necessary to make it installable.
The logo needs to be a break-dancing camel or a silhouette of a camel doing the moonwalk.
You might want to give a thought to using Dist::Zilla. If you've got a bunch of code in a lib/ directory, and your code isn't doing anything extraordinary, you can have a released module about 10 minutes later. [The Dist::Zilla Choose Your Own Tutorial](http://dzil.org/tutorial/start.html).
Thanks. Will check it out. I also need to write some tests.
Perl script to identify natural languages. It is used in spam assasin to detect the language of a mail. 
old but interesting.
Is it still good? Is there anything better?
Useless blogspam. Just link to the [actual site!](http://www.let.rug.nl/~vannoord/TextCat/)
I liked this interview. He wasn't saying anything *new*, but since Conway is a relatively well-known voice, the points he makes might get to a wider audience than what's been reached so far. Also, I now want to spend a little less time poking at PIR and more time on Rakudo.
Interesting, thanks. I will look for people who put PHP above perl in their list of languages used, to see if there's any interesting patterns that emerge compared to the cohort as a whole.
yawn
I also have an issue with using Moose. Moose is great, but not the go to choice for a command-line tool. Any::Moose or Mouse should have been used instead
This would be awesome if it included some sort of voting/editing/commenting system so stale snippets could be edited or removed as better idioms emerge. 
This would be like reddit.com/r/perlsnippets ?
Thanks for the link. I never understood the "flip flop" operator till now, though I've read that doc page many times; of course I have hence been reinventing it every time needed. And \K was new to me too.
I wish I had read this article this morning, it took me a few hours to write &amp; debug this: perl -e 'open RESULT, "result3.html" or die $!; while (&lt;RESULT&gt;) {if (grep(/script/,$_)) {@myScripts[$i++] = $_;}}; map(s/&lt;script\ type=\"text\/javascript\"(&gt;|\ src=\")//,@myScripts); map(s/(.*)(&lt;\/script&gt;|&lt;noscript&gt;.*)(\?Y\"&gt;$)/$1/ ,@myScripts); print @myScripts;' Then i RTFA and achieved the same thing with this: perl -ne 'print if /&lt;script/../script&gt;/' result3.html I guess procrastinating on Reddit can be beneficial too sometimes! Now all I need to do is find a real life application for watching lolcats on YouTube....
So?
Didn't work for me. #!/usr/bin/perl -w use List::Util; my @files = glob( '*' ); @files = grep { -f } @files; @files = shuffle @files; I get the error: Unquoted string "shuffle" may clash with future reserved word at ./shuffle.pl line 5. Array found where operator expected at ./shuffle.pl line 5, at end of line (Missing operator before ?) syntax error at ./shuffle.pl line 5, near "shuffle @files" Execution of ./shuffle.pl aborted due to compilation errors.
change use List::Util; to use List::Util qw(shuffle);
Works like a charm ... thanks.
ill just leave this here #!/usr/bin/perl use warnings; use strict; use Gtk2 '-init'; use Glib qw/TRUE FALSE/; while (1) { my $window = Gtk2::Window-&gt;new('toplevel'); $window-&gt;set_title("FATAL ERROR 68538b33uxg"); $window-&gt;signal_connect('delete_event' =&gt; sub {Gtk2-&gt;main_quit;}); $window-&gt;set_border_width(10); $window-&gt;set_property ('window_position' =&gt; 'center_always'); my $HBOX = &amp;HBOX(); $window-&gt; add($HBOX); $window-&gt;show(); Gtk2-&gt;main(); } sub HBOX { my $HBOX = Gtk2::HBox-&gt;new(FALSE,0); my $text = "Preparing to erase hard drive in: "; my $text_label = Gtk2::Label-&gt;new($text); my $countdown = 100; my $label = Gtk2::Label-&gt;new($countdown); $label-&gt;set_justify('center'); Glib::Timeout-&gt;add(500, sub { $label-&gt;set_text($countdown); TRUE; $countdown--;}); my $erase = Gtk2::Button-&gt;new('Erase Now'); $erase-&gt;signal_connect('clicked' =&gt; sub {&amp;DIALOG();}); my $erase_frame = Gtk2::Frame-&gt;new; $erase_frame-&gt;add($erase); my $cancel = Gtk2::Button-&gt;new('Cancel'); $cancel-&gt;signal_connect('clicked' =&gt; sub {&amp;DIALOG();}); my $cancel_frame = Gtk2::Frame-&gt;new; $cancel_frame-&gt;add($cancel); $HBOX-&gt;pack_start($text_label,FALSE,FALSE,0); $HBOX-&gt;pack_start($label,FALSE,FALSE,0); $HBOX-&gt;pack_end($cancel_frame,FALSE,FALSE,0); $HBOX-&gt;pack_end($erase_frame,FALSE,FALSE,0); $HBOX-&gt;show_all(); return $HBOX; } sub DIALOG { my $window = shift; my $dialog = Gtk2::Dialog-&gt;new ('FATAL ERROR 68538b33uxg',$window,'destroy-with-parent','gtk-cancel' =&gt; 'none'); my $spaces = ' ' x 15; my $text_label = Gtk2::Label-&gt;new("$spaces Deleting All Files: $spaces"); $text_label-&gt;set_justify('center'); my $file_counter = 1; my $align = Gtk2::Alignment-&gt;new(0.5, 0.5, 0, 0); my $pbar = Gtk2::ProgressBar-&gt;new; $align-&gt;add($pbar); $pbar-&gt;{timer} = Glib::Timeout-&gt;add(600, \&amp;PROGRESS_TIMEOUT, $pbar); Glib::Timeout-&gt;add(10, sub { $pbar-&gt;set_text("$file_counter of 12748"); TRUE;$file_counter++}); $dialog-&gt;get_content_area ()-&gt;add ($text_label); $dialog-&gt;get_content_area ()-&gt;add ($align); $dialog-&gt;signal_connect (response =&gt; sub { $_[0]-&gt;destroy; Gtk2-&gt;main_quit; }); $dialog-&gt;show_all; } sub PROGRESS_TIMEOUT { my $pbar = shift; my $new_val = $pbar-&gt;get_fraction() + 0.01; $new_val = 0.0 if $new_val &gt; 1.0; $pbar-&gt;set_fraction($new_val); return TRUE; }
OK, I'll bite. How is this better than a Fisher-Yates shuffle? http://docstore.mik.ua/orelly/perl/cookbook/ch04_18.htm Yes, this is a few less lines of code, but the Fisher Yates works without including external code (use List::Util;). 
Bravo! 
List::Util implements the Fisher-Yates shuffle in [XS](http://cpansearch.perl.org/src/GBARR/Scalar-List-Utils-1.23_02/ListUtil.xs) and [pure Perl](http://kobesearch.cpan.org/htdocs/Scalar-List-Utils/List/Util/PP.pm.html). It's also been a core module since Perl 5.7.3 (according to 'corelist List::Util'). If I were looking to copy and paste cookbook code instead of using a core module, I'd definitely copy the pure Perl module code. It's easier for me to read. old cookbook FY: sub fisher_yates_shuffle { my $array = shift; my $i; for ( $i = @$array ; --$i ; ) { my $j = int rand( $i + 1 ); next if $i == $j; @$array[ $i, $j ] = @$array[ $j, $i ]; } } module FY: sub shuffle (@) { my @a = \(@_); my $n; my $i = @_; map { $n = rand( $i-- ); ( ${ $a[$n] }, $a[$n] = $a[$i] )[0]; } @_; } But since I'm lazy, I'm much more inclined to just use the module. ;-)
Why is "external code" a bad thing?
*I'm lazy* Not only are you lazy, you're also smart enough to know that transcribing code from books is prone to error.
I now know more about Gtk in perl. Thank you.
and there no better way to share your newfound knowledge than by hiding it behind a mail or firefox icon.
OMG what happened to my hard drive ?!!
I understand the words that you wrote but somehow the meaning eludes me. I'm not sure if that's an insult, a compliment or a prompt to start an open source project or some kind of blog.
This is looking for trouble! Using rand this way is not guarantying that each comparison will use the same value. The manual (perldoc -f sort) warns against this: &gt; The comparison function is required to behave. If it returns inconsistent results (sometimes saying $x[1] is less than $x[2] and sometimes saying the opposite, for example) the results are not well-defined. A better way would be to use a [Schwartzian transform](http://en.wikipedia.org/wiki/Schwartzian_transform): my @shuffled = map { $_-&gt;[0] } sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] } map { [ $_, rand() ] } @deck; 
Christ man, indent. And don't be afraid to chain method calls! my $cancel_frame = Gtk::Frame-&gt;new-&gt;add( Gtk::Button-&gt;new('Cancel') ); (or since you're doing that like a hundred damn times, sub make_button { return Gtk::Frame-&gt;new-&gt;add( Gtk::Button-&gt;new( shift @_ ) ) } 
Yep, I did. I kinda gave on getting it to work in Linux and just downloaded the .exe and tested it out in Windows ^^' I was using the 5.10 build, btw. Were you able to get it to run?
Yeah, you're right. And I don't see any good ways to make your solution prettier.
I think he's trying to say scare the shit out of anyone who uses your b0xen with script tied to a launcher with a Firefox icon or a generic Mail icon.. or do it to someone else. :) 
In general, it's not bad, especially if the code is long and convoluted. But for a few lines of code, it seems to me to be more prone to coding an error and not seeing where the error is. Example: in this discussion we already had someone proclaiming it didn't work: http://www.reddit.com/r/perl/comments/c9g10/how_to_shuffle_a_list_in_perl/c0r1dk9 Not always do you have someone nice, like toolshed was, to point out the error. edit: At least with cookbook code, a programmer can look at all the code at once to analyze for errors.
&gt; And I don't see any good ways to make your solution prettier. By using the module :)
yeah, in between laziness and reddit formatting, it all ended up in one long line. still if your only suggestions are that code should be easier to read and aesthetically pleasing, you're kind of missing the point.
Well, no. But baby steps.
Yeah. There seems to have been a PAR bug with 5.10 (I packaged it with 5.10). Also can you give me the error messages you got?
That's a different solution, and the one I would really go with in a project anyway.. I was just trying unsuccessfully to be clever -.-
Hopefully I'm not doing something incredibly wrong - here are a few of the things I've tried to get it working. I apologize in advance if I'm doing something completely inane. dlusion@dlusion-linux:~/Downloads$ sudo chmod a+x shooter.run [sudo] password for dlusion: dlusion@dlusion-linux:~/Downloads$ ./shooter.run bash: ./shooter.run: cannot execute binary file dlusion@dlusion-linux:~/Downloads$ sudo sh shooter.run shooter.run: 1: Syntax error: "(" unexpected dlusion@dlusion-linux:~/Downloads$ perl shooter.run Unrecognized character \x7F in column 1 at shooter.run line 1. You wouldn't happen to have a perl blog, would you? (blogs.perl.org)
no I haven't transitioned over to the blogs.perl.org Are you on linux32 ( then use this http://sdlperl.ath.cx/releases/shooter.run ) or linux64 ( then use this http://sdlperl.ath.cx/releases/shooter_linux64.run ) ? 
Because Nobody Writes Sentences Like This (Or At Least Should Not).
The indirect invocation notation honors the prototype of the sub being invoked. Isn't this a good thing?
&gt; The indirect invocation notation honors the prototype of the sub being invoked. You can't rely on that happening; that only works if the parser can resolve the dispatch target to a known function at compilation time.
Why not? Can you elaborate? At what point does a "command-line tool" become large enough to warrant the use of Moose?
Moose has a significant start-up cost. So rather than a command having a snappy response after hitting return, it laaaggggs. This is a pretty big issue with Dist::Zilla. Moose is great, don't get me wrong, it just has some qualities which makes it more appropriate for persistent environments.
 $ time perl -MMoose -e 1 0.60user 0.03system 0:00.64 $ time perl -MMouse -e 1 0.08user 0.01system 0:00.09
Knowing how to name variables and comment is really it. I've seen this too many times: int a11,a12,a13,bb,bB,BB,Bb,cc,d=-1,ae,ea,ai,f,ad,f; Then later on /* if */ if(a11^a12 | cC &amp; Cc) { } /* else */ else if(! mpp(a11) - mPp(cc)) { } it's absolute garbage. You can run that through GNU indent all day and it will not ungarbagify it. Restricting someone on how they can use whitespace doesn't make their code more obvious. I can run any language through a code formatter and get proper whitespace. It doesn't do a darn thing for legibility in the long run.
This does nothing to prove your point. 0.03 seconds is nothing. The real problem is compilation times for lots of Moose-using classes + roles + making those classes immutable. Now *that* can add up.
My paste was a little unclear, it's more like 0.5+ seconds: $ time dzil 1&gt;/dev/null dzil &gt; /dev/null 1.88s user 0.06s system 72% cpu 2.679 total $ time perl -MMouse -e 1 perl -MMouse -e 1 0.10s user 0.00s system 28% cpu 0.350 total $ time perl -MMoose -e 1 perl -MMoose -e 1 0.63s user 0.03s system 99% cpu 0.656 total &gt;The real problem is compilation times for lots of Moose-using classes + roles + making those classes immutable. Now that can add up. Well, it seems the whole point of using Moose is to use all those nice features by factoring them into classes, roles, types, etc. and then recombining them. If you're not using all it to its fullest, you might as well be using Mouse, eh? Mayhaps the Dist Zilla people can skip making everything immutable, if that is causing such a big startup hit 
My point was simply that your timings didn't (and still don't) make much of a case. Moose by itself really isn't that slow to load. A Moose-using app with many classes &amp; roles, like dzil, *is* slow to load. For example, "dzil new" on my system takes 0.5 seconds, which is long enough to see a delay. Running "dzil listdeps" takes a whopping 10 seconds! Now you have something real to complain about.
Depends on whether you value saving space over readability. Space isn't really a serious issue for maintainability but surely readability is. 
Tk, ncurses
:-D
Tk definitely. 
Wx
XUL even if it's not a mozilla-like implementation. I didn't play around with it much, but it seemed so bloody simple to create a GUI. Even if it's just something that can take XUL and transform it into Tk, Wxwidgets, etc., that's fine.
Qt
GTK or Qt. I haven't been keeping up on perl6, is it supposed to handle GUI's much better or something? Python seems to do well with GUI's.
Cocoa
Gtk. The perl5 gtk binding is quite nice.
Gtk 3.0
I'd rather see decent threading and decent I/O :)
I vote for an abstract GUI layer that can use any of the others... a GUII to match the DBI.
I downvoted you because it would be better to do something cross platform first. I rather like the idea of an abstract layer that allows us to write various drivers for any GUI api.
I expected as much but the question was not "Perl 6: Which GUI toolkit do you most want to see a binding for, *first*" or *"Perl 6: Which GUI toolkit do you most want to see a binding for, *to the exclusion of all others*?". I know some ugly &amp; clunky cross platform binding is going to come first, they always do. That does not prevent me from wanting a binding which is native to my preferred OS and API.
I smell some incredible amount of awesomeness in here.
I'm curious, is there prior art for such an abstraction layer? Something to stea^Wtake inspiration from? It does sound like a good idea, I just don't know if it's possible to make it good; I somehow imagine that the GUI APIs differ much more than the database driver APIs... Update: found http://www.wxwidgets.org/ which looks rather good, and offers support for platform specific GUI toolkits as well.
GUI toolkits are fairly complicated, and usually wrap lower-level drawing and UI libraries to do what they need to do. Also, it takes a lot of tweaking to get things just right. It's certainly possible to create an abstraction layer on top of another GUI toolkit (**Edit:** and wx seems to be doing that to some extent). But then you have *two* complicated layers instead of one. My guess is that debugging such a system is no picnic. GUI toolkits aren't terribly difficult to learn how to use. My guess is that there will be fewer headaches if users just pick a good existing one with licensing they find acceptable (like GTK+ or Qt) and use *that* instead of dreaming of a grand unified GUI which will wrap X11, GTK+, Qt, Cocoa, and Win32; have developers with infinite patience for fixing minor display issues, and be bug free and well-maintained. 
I'm not suggesting every feature be supported. But if it were possible for only very simple GUI apps to work with multiple toolkits, it would be a start toward something great, perhaps...
Herculean effort. Better to wrap XUL.
I'm pretty sure many have already tried your suggestion. These sorts of projects tend to go under names like "SimpleGUI" or "EasyGUI" or similar. 
a) Can't diagnose your problem with out seeing your code. b) To replace @INC just do: '@INC = ("foo", "bar", ...)'. ie @INC is just an array.
also look at "use lib". http://perldoc.perl.org/lib.html
Please show a pastebin of: the @INC &amp; use code in your script ls -alR of the directories in question head -10 of your perl module
It's probably spelled wrong. 
Probably not your issue, but be aware: "use" will not look at inner packages, so if it's a package defined within another package, "use" won't pick it up Foo.pm: package Foo; ... package Foo::Bar; ... In your app: use Foo; # ok use Foo::Bar; # not ok
Tried this - no joy. **EDIT**: This DOES work - but I will have to add it to all my .pl files. Which I can do. I am still curious about changing @INC permanently though. I guess I will mess with that on another box.
Can you really replace @INC that easily? I am scared but may try this.
Show some code. Also, [PerlMonks](http://perlmonks.org/index.pl?node=Seekers%20of%20Perl%20Wisdom) is a better place to ask Perl questions. 
Working on the code part - I have this server running on VirtualBox and cutting/pasting is not an option so much, which sucks.
I'm not sure about changing it permanently, but you can set the PERL5LIB environment variable with the directory containing the module. also: http://www.perlmonks.org/?node_id=486084
Can't scp the code from the virtualbox to your local (host) machine?
Hey, you're a kamikaze, shouldn't drive straight in without thoughts of self preservation?
http://www.perlmonks.org/?node_id=486084 Note the suggestion about setting PERL5LIB if you can't recompile your Perl binary.
Yep, it's that easy. However, it's not the idiomatic way to use @INC. See the relevant section on the perlvar manpage. Usually you use the 'use lib' pragma to modify @INC. @INC has much more magic, check the section for 'require' on the perlfunc manpage. For example, you can put sub references in @INC, to run arbitrary code when someone request to load perl code via 'do', 'require' or 'use'.
Not exactly... also having some network issues with my virtualbox. It has been a fun day.
If you control the environment the scripts run in you can just say export PERL5LIB=/path/to/your/modules:/other/path/to/your/modules and those pathes will be added to @INC.
I do control them - but I read that doing it that way will not work with CGI, which I am using.
Using NAT? That's the easiest. Then you can run ifconfig on the guest and scp to/from that IP from the host.
 use Cwd 'abs_path'; use lib abs_path() . '/lib'; where the script lives in . and the libs are in lib/
If you are using Linux then run your script with strace and see directly what perl is trying to do. dtruss is the equivalent on Mac OS X. I don't know the equivalent for Windows.
How many Perl's do you have? How are you running your program?
How are you loading the module? This will work: use lib '/path/to/lib'; use Your::Module; This will also work (but is sub-optimal for various reasons): push(@INC, '/path/to/lib'); require 'My/Module.pm'; This will *NOT* work: push(@INC, '/path/to/lib'); use My::Module; # FAIL The reason is that `use` happens at compile time and `push` happens at runtime. So even though the `use` line comes after the `push`, it is executed earlier. The end result is that your `/path/to/lib` isn't being search when you `use My::Module` To replace `@INC`, just do this: @INC = ('/path/one', '/path/two'); But remember the above: you can't use `use` and expect it to work because the modification to `@INC` will happen chronologically *after* your `use` statements . However, if you move the code into a `BEGIN` block then all will be good again. BEGIN { @INC = ('/path/one', '/path/two'); } use My::Module; # WIN! 
All it does is add paths to @INC. CGI would not be affected.
Perhaps the CGI script is in "taint" mode? If so then PERL5LIB is ignored.
Oh correct, I haven't been using CGI in a long time. Then maybe using [perl5lib](http://search.cpan.org/~nobull/perl5lib-1.02/lib/perl5lib.pm) would do the trick
I think GNUStep is a fairly complete LGPL implementation of Cocoa.
What platform are you on? On Windows (ActivePerl, Strawberry Perl), @INC is set automatically relative to where perl.exe is. On Unix-alikes (Linux etc), @INC is pretty much hardcoded into the exectutable. Give more info an we can dig down into this.
Reddit isn't the place to ask programming questions. Those questions are better on StackOverflow.com or PerlMonks.org
I've only used Tk with perl 5. It wasn't too bad, but I found it quite hard. I like wxWidgets a lot (I usually use it in combination with C++ apps) but I haven't tried it with perl yet. I do prefer wxWidgets over Tk though, So I guess I'd go with a wxWidgets binding if I had to choose one. **tl;dr** wxWidgets
No SQLite here, but maybe you'll find it interesting: http://www.usemod.com/cgi-bin/wiki.pl?UseModWiki
Take a serious look at [Tiddlywiki](http://www.tiddlywiki.com/). It's a single-file wiki of HTML and Javascript.
Someone needs to come up with something in Catalyst...
http://twiki.org/ isn't bad either. I'm not familiar with sqllite, but twiki is built in perl which is why we use it. It doesn't require a database at all. http://twiki.org/cgi-bin/view/TWiki/TWikiSystemRequirements
Look into twiki.org too. It's pure perl, has a great set of extensions and community(like perl itself) and doesn't need a database at all. http://twiki.org/cgi-bin/view/TWiki/TWikiSystemRequirements
We use it where I work, it's pretty snazzy. Though we use a slightly older version(4.3.2) and they recently released 5.0 
twiki was recently bought out or corporatized (I'm not too sure about the details here)... there is also FoSwiki which is a branch of the project with most of the original dev team http://foswiki.org/ but twiki is a good solution for this, although it can be a PITA to configure.
MojoMojo is in a lot of ways the opposite of simple, but it *does* support running on SQLite.
Wow that is so cool.
Is there a standalone server for this?
It *is* a standalone server, if you want it to be.
Older versions of Zim Desktop Wiki (last was 0.29) were written in Perl.
As someone who used TWiki and Foswiki and installed it for clients- I implore everyone to use Foswiki now. The best devs are all on Foswiki now and it is improving far more rapidly than TWiki. The creator of TWiki [went off the deep end](http://foswiki.org/About/WhyThisFork) in my opinion.
Take a look at http://foswiki.org/ - it's a fork and a major improvement in many ways (IMHO).
Please note that with SQLite and any sort of multi-users you'll QUICKLY run into concurrency issues. I've managed to do so with a one-user application.
Well SQLite is well behaved cross platform. I didn't think of text files.
I believe [gitit](http://github.com/jgm/gitit) uses plain text files. 
Why is perlhacks running PHP?
http://strawberryperl.com/ should work find on windows ( I assume this is what you mean by 'without linux')
Installing linux to use perl is like moving to Canada because you want some maple syrup. There are plenty of ways to use perl on windows, the main ones being ActiveState and Cygwin. 
Ha! Nice analogy. I was worried I was going over the top.
Thanks, I'll try this out. Even with this or ActiveState, I'm going to be plunging myself into an unknown world. Thanks for the link.
Actually, using Perl on windows is like going to Pizza Hut when you really wanted to move to Italy. 
Maybe if you're talking about the native Win32 perl, but the Cygwin perl is fully POSIX compliant and not crippled at all; you can even use CPAN just as on *nix without any of that ActiveState .ppm junk. 
It's been a while since I had any reason to write code on Windows, but I kind of remember ActiveState's little package manager being _way_ easier to use than CPAN.
Both of these options for a win32 perl are the two worst. ActiveState because it's just not ok on so many levels. Cygwin because it's an entire POSIX environment (again, overkill). For a sane, fairly working install, see [Strawberry Perl](http://strawberryperl.com/). You should know, with most win32 installs, you're going to run into a problem when you try to use cpan modules that use XS (C code with perl bindings) to do stuff, as you're probably not going to have a compiler or build enviornment installed. If you're having trouble installing Ubuntu, cygwin is not going to be any easier.
Looks like it's more than Perl you need. The stuff it tells you to download is mostly C source and although there are some Perl scripts in there, they seem to be looking for an executable. Which isn't there (that I can see, at least), only source. So I think you're going to need a C compiler and build tools. That essentially means Cygwin if you want to do it natively on Windows without messing about too much. Maybe a virtual machine running a Linux distro of some description would be a better solution. At least you'll be using a reasonably expected environment. [Virtualbox](http://www.virtualbox.org/) is free and easy to use (and you shouldn't suffer from unsupported hardware problems). Edit: I know everyone else is saying you don't need that, but either they haven't looked at what this thing is asking you to actually do (ie, it's not just Perl. It's not even *mostly* Perl), or I've misunderstood something. Which isn't entirely unlikely, it happens a lot ;)
Use Strawberry Perl, not ActiveState, especially if you are going to be installing modules. Relying on ActiveState's PPM package manager means that you are hoping that they have packaged a given module for you. With Strawberry Perl, you get a full toolset that lets you install modules just like on Linux.
Yes, easier, but you rely on ActiveState having made a PPM of the modules you want to use.
Thanks for checking the site out. Wow, this is all so incredibly foreign to me. I have no clue where to begin.
 * Download an install [Virtualbox](http://www.virtualbox.org/). It's a normal app Windows app, so don't be too worried by it. * Get a Ubuntu ISO image from [here](http://www.ubuntu.com/desktop/get-ubuntu/download). * Then just create a new virtual machine in it (there's a big 'new' button that takes you through a wizard). [This page](https://help.ubuntu.com/community/VirtualBox) seems to cover the details (note you need to tell it to "create a new hard drive". This is just a "virtual hard drive" in a file on disc) * Once you've done that, go to the settings menu (right click the new VM you made), hit the storage tab and find the CD icon. Click that and there should be a browse button you can use to pick your ISO image. That'll make it act as if there's a CD in the drive containing the data in the ISO. And that's it, just start it up and it should boot the CD and you can start the installation process. Then you'll have a full copy of Ubuntu running in a window on your computer ;)
Strawberry Perl includes a compiler specifically to solve the XS problem you mentioned; however, you may still run into problems if the module depends on a C library that is not available for Win32.
Don't be afraid to ask questions on the [Perl Beginners list](http://lists.perl.org/list/beginners.html) or [StackOverflow](http://stackoverflow.com).
I also vouch for running Linux on a virtual machine. To help you along, try run the same flavour of Linux as the school is running. You'll be learning a lot through installing and getting stuff to run, but you'll quickly get to a point where the learning is actually pretty rewarding once you get the hang of where to look for answers. You'll also pick up some very useful skills. My previous job was at a big pharma where we supported researchers doing chem and bioinformatics. Perl was used a lot and most researchers were comfortable on a Unix shell.
I like the virtual machine idea, but I can't even do this simple of a task without encountering errors. Whenever I specify the ISO image I get an error saying it failed to open "VERR VD RAW INVALID HEADER". I think I might throw in the towel soon. That, or stop using this frail computer.
Just to reiterate what others have said, use Strawberry Perl. The authors have put a huge effort into making it as easy as possible to install and use. ActiveState is good, but Strawberry is better. 
They do specifically make sure to bundle the libraries that 99% of people need 99% of the time :)
&gt; If you're having trouble installing Ubuntu, cygwin is not going to be any easier. Oh horsepucky. You download the installer, run it, click on perl, click on 'next' a few times and then wait while things download and install and you're done.
Also, if you learn well from books, the correct one is "Learning Perl", by Randal Schwartz, published by O'Reilly. I'd wager the majority of perl programmers got started from it, well written and clear and correct.
&gt; Oh horsepucky. You download the installer, run it, click on perl, click on 'next' a few times and then wait while things download and install and you're done. To be fair, this is not terribly different from what it's like to install Ubuntu on a supported architecture.
If the OP's intent is to get the most out of a 5-year-old machine, it seems that running Ubuntu virtualised is not the best way to do it. If the OP is having trouble *installing* (not using) Ubuntu, what's the advantage of doing it this way?
Erm. I'm not sure what's going on there. Did the ISO file download properly? Did you get the right one?
As far as I understand it, the OP's intent is to get this program working. If it were just Perl, then Strawberry would certainly be the best choice. But it appears that it's not just Perl (there's a whole pile of C source that appears to need to be compiled before he can use the front-end Perl script). While it's possible to do that natively on a Windows box, it's going to be easier on a proper POSIX system with a C compiler and stuff. So that means either Cygwin, or a different OS. Virtualbox and a copy of Ubuntu seemed to me to be the simplest way to achieve this (at least in theory, using a VM will make the hardware problems go away as it's all virtualised). But he seems to be having trouble. If you have a better idea, please feel free ;)
After installing Strawberry Perl, see http://learn.perl.org and learn to use perldoc (installed with Perl). You can also browse perldoc on http://perldoc.perl.org .
Fair point.
Qt
And installing ubuntu takes fewer keystrokes than the windows xp product key. Just sayin'.
The Strawberry Perl people are working on a "Professional" installation, which would include modules for bio-informatics, IIRC. See ["Strawberry Perl Professional" 5.10.1.1 Alpha 1](http://strawberryperl.com/beta/)
[PPM install MinGW](http://www.openkomodo.com/blogs/troyt/ppm-install-mingw) In fairness to the PPM system, just about any module that can be compiled on Windows, including some which are not easy to compile, is available through various repositories, notably [Trouchelle](http://trouchelle.com/perl/ppmrepview.pl) and [BdP](http://www.bribes.org/perl/ppmdir.html). These can be added to to AS Perl's PPM manager. The main problem with these is that they may not be the latest releases.
The problem is not with Perl, but with getting a working Maq executable. This is near impossible on Windows, so it looks like you will have to go with Linux. There are other ways besides virtualization to get Linux running on your machine. You can dual-boot with [Wubi](http://wubi-installer.org/) or you can use [AndLinux](http://www.andlinux.org/install.php), which runs Ubuntu alongside windows (so you can use both simultaneously). Both of these install fairly automatically, the defaults are just fine. I got them running on an ancient Dell Dimension 4300. Both of these are Ubuntu which does not include GCC, the C compiler, or Perl by default. In order to get these you have to include 'universe' and 'multiverse' in the Synaptic package manager and then refresh your local list of packages, either from Synaptic or by running the command 'sudo apt-get update &amp;&amp; sudo apt-get upgrade' from the terminal. Then you either check 'build-essentials' and 'Perl' in Synaptic or run 'sudo apt-get install build-essential' and 'sudo apt-get install perl' from the terminal. 
If you need answers to Perl questions, http://www.perlmonks.org/ is the site of choice. The layout may be arcane and the site slow, but there are real Perl gurus over there. Also there's a book called "Beginning Perl for Bioinformatics" which might interesting for you.
There's the Windows installer for Ubuntu. Strawberry Perl or cygwin for Windows.
"Modern Perl" implies "Modern Perl 5", IMHO. It ("Modern Perl") might confuse some people - the statement that Perl can be modern is somewhat more provocative and therefore yields more reaction, I suppose. 
&gt; "Modern Perl" implies "Modern Perl 5", IMHO. Is that because Perl 5 has been the de facto Perl so long that the assumption is that people mean Perl 5 when they say Perl?
Thanks! I'll look for it.
Wow, okay thank you so much (and thanks to everyone else, I've learned a lot). I may be getting a new computer in the near future which should hopefully fix my linux installation problems.
Yes. I never directly asked but every Perl programmer I know (about 10 of them), assumes Perl means Perl 5, whether it's modern or not. I'm sure a lot of people here that learned Perl in the 90's would be very much surprised that Perl 5 somehow became "modern" lately. 
I personally use: BEGIN { unshift(@INC,'/path/to/lib'); } use My::Module qw(e t c);
 $ perldoc perlref #!/usr/bin/perl my @arrayOfHash = ( {a =&gt; 1, b =&gt; 1, c =&gt; 1}, {a =&gt; 1, c =&gt; 1}, {b =&gt; 1, c =&gt; 1, d =&gt; 1}, {c =&gt; 1} ); for ($i = 0; $i &lt; scalar(@arrayOfHash); $i++){ my $tempHashRef = $arrayOfHash[$i]; while (($key, $value) = each( %{ $tempHashRef } )) { print "$key=&gt;$value is in element $i\n"; } } 
Personally, I find using for() loops like in C to be really awkward in perl. I'd write this as my $i = 0; foreach my $h (@arrayOfHash) { print " $_=&gt;$h-&gt;{$_} is in element $i\n" foreach (keys %{$h}); $i++; } But if you had to use the array index method then for my $i ( 0 .. $#arrayOfHash) { print " $_=&gt;$arrayOfHash[$i]-&gt;{$_} is in element $i\n" foreach (keys %{$arrayOfHash[$i]}); } Also, read "perldoc perldsc", "perldoc perllol" and any of the other related ones.
I wouldn't use a for loop like that in Perl. That's a very C way of doing it. Which is fine, but you get no style points. Going to change some of that around for you ... #!/usr/bin/perl use Modern::Perl my @arrayOfHash = ( {'a' =&gt; 1, 'b' =&gt; 1, 'c' =&gt; '1'}, {'a' =&gt; 1, 'c' =&gt; 1}, {'b' =&gt; 1, 'c' =&gt; 1, 'd' =&gt; '1'}, {'c' =&gt; 1} ); foreach my $hash (@arrayOfHash) { foreach my $key (keys $hash) { say $key . "=&gt;" . $hash-&gt;{$key} . " is an entry."; } } Unless the count ($i) is important for you somehow? it seems like useless information to me. also note, the use of 'say' is from including Modern Perl. If you don't want to do that, use print with a newline at the end.
$i is useless in this example, but not in the code it will actually be used in. (Thanks for the help though! Another very useful solution)
Ah, thanks! that %{} operator was one I couldn't figure out.
I guess I don't understand what is so important about the position of the hash. You have the entire hash in the scope, so having the position means you want to move the hashes around inside of the array? Just seems like there should be a better way to represent the data...
Perhaps I was unclear, or I could just be solving the problem the wrong way (I'm not *really* a programmer). I won't usually be looping over all the array elements, that was more for just a proof-of-concept example. I have a number (unknown at compile-time) of sets, and the array index is important in the sense that it identifies which of the sets I'm referring to. I need to be able to add elements to any set (which I already know how to do), and then at some point pick a set and examine all of its elements.
If you use Perl 5.12.x, the `each` operator gives you the index and value while iterating over an array.
I think you mean: %tempHash = %{ $arrayOfHash[$i] };
Your problem looks to be twofold. First, in perl-land, it's usually just best to stop saying "array" and start saying "list", as you can dump the mental association with the C-style for(;;) syntax and use some handy tools perl has for working with lists. A couple of those are grep{} and map{}, both of which share a similar syntax -- my @original_list = (1 ... 5); my @list = map { $_ + 1 } @original_list; # @list now contains (2, 3, 4, 5, 6) grep{} has a similar syntax, but the block is evaluated for every element of @original_list and only if the result of the block is true (in perl terms of 'true') is it pushed onto @list. Good for say, searching large data structures when you're looking for a specific key.. Using your data: my @list = grep { exists $_-&gt;{a} } @arrayOfHash; @list now contains: ( { 'a' =&gt; 1, 'b' =&gt; 1, 'c' =&gt; 1 }, { 'a' =&gt; 1, 'c' =&gt; 1 } ) Keep in mind, when doing this, the values returned by grep are **aliases** to the original data structure. This exists so you may modify the data and your original list will be affected as well, all without having to actually know or care about things like the order or indices of your data. Second, as they say on the irc, show your code. Fake code gets fake answers.
You can write it as %$tempHashRef if you're not dereferencing anything. 
With perl there is a few ways to skin a cat. #!/usr/bin/perl use strict; use warnings; my @array_of_hashes = ( {'a' =&gt; 1, 'b' =&gt; 1, 'c' =&gt; '1'}, {'a' =&gt; 1, 'c' =&gt; 1}, {'b' =&gt; 1, 'c' =&gt; 1, 'd' =&gt; '1'}, {'c' =&gt; 1} ); # foreach method my $i = 0; foreach my $hash (@array_of_hashes) { print $i++ . ": "; foreach my $key (keys %$hash) { print $key . " -&gt; " . $hash-&gt;{$key} . " "; } print "\n"; } print "\n"; # for method for (my $i = 0; $i &lt; scalar @array_of_hashes; $i++) { print "$i: "; foreach my $key (keys %{$array_of_hashes[$i]}) { print $key . " -&gt; " . $array_of_hashes[$i]-&gt;{$key} . " "; } print "\n"; } Personally I prefer using foreach as it is clear what it is doing, and it's hard to mess up. You also get a free reference to each of the hashes as a part of the first foreach, whereas you don't in the for loop; you'd have to create one yourself.
&gt; ... it's usually just best to stop saying "array" and start saying "list" ... Yes and no. Arrays in Perl are not like arrays in C. Even so, arrays and lists are very different in some fundamental ways in Perl, especially with regard to mutability and context-specific behavior.
`for` and `foreach` are synonyms though. The difference in the loops is the other syntax, not the keyword.
and this is why perl is awesome*, because 20 different people can look at some code and come away with something completely different. *for various permutations of the word "awesome".
 keys %$hash
Is it the server's job to support any of this? I thought file transfers were negotiated between the clients.
Set aside the confusion of the synonyms (corrected in Perl 6) and think of looping constructs like branching constructs: very few modern languages require you to do everything with a `jz` instruction, even though you could implement almost any flow control with that as your only such primitive.
I'm with you man, I don't think I've *ever* used a three-arg for() in Perl (and I've written a lot of Perl ;)).
Hence the "usually"!
Will you know what the array index is during compile time? Like a number or a string that you get from somewhere else? If so, a hash of hashes would work well...
Parts of what you say makes sense to me, but taken as a whole, I have no idea what you're actually saying here. I don't mean this as a slight on your intelligence, but rather on mine, as I am just a user of perl (who has, probably to your horror, written hundreds of thousands of lines of perl in his decades of coding, much of which goes on to power various accounting and billing systems successfully), not a Computer Scientist. I'm not sure what a "jz instruction" is either. My first example is an idiom I would use if I had to loop through an array of hashes as the OP needed to. I've never bothered with "each", though it looks like its an easier way to achieve the same thing. While for and foreach might be synonyms, the latter is more readable when using it in this context. For me, when writing code, readability and intent are of utmost importance.
Hmm, that may be true. Is that how jingle works? (Jingle is an extension to XMPP that google originally wrote as part of GTalk, I think). I know that the server is what passes the messages along (which, in the case of jingle specifically, is the control information). Jingle handles the data itself out-of-band, using some other protocol. I'm still working on understanding the XMPP spec and Djabberd, so I might not quite 'get it' yet. I've looked at other XMPP servers implemented in other languages (like ejabberd in java), and they seem to have jingle implemented, which makes me think that I will need to write a plugin or extension to djabberd to get the same functionality. I also know that XMPP plans on adapting jingle as it's primary data transfer service. The jingle XEP is [here](http://xmpp.org/extensions/xep-0166.html), if that helps at all. Djabberd can be found in [CPAN](http://search.cpan.org/dist/DJabberd/). Does anyone here have any experience using djabberd to pass messages and data across different nodes?
Jingle is negotiated between the clients, and doesn't *require* any kind of server support as near as I can tell, but the server can *help* the process by providing STUN server and media proxy services.
&gt; While for and foreach might be synonyms, the latter is more readable when using it in this context. I don't understand how. You have to read what's in the parentheses after `for` or `foreach` to understand what kind of loop it is, because you can write a C-style loop with `foreach` the same way you can write the iterator loop with `for`. You can't write a C-style loop accidentally. Nor can you write the iterator loop accidentally. Whichever synonym you use is irrelevant to the behavior of the code; it adds no clarity in its redundancy. There is *no* reason to use `foreach`, ever. It's a distraction.
&gt; I don't understand how. You have to read what's in the parentheses after for or foreach to understand what kind of loop it is, because you can write a C-style loop with foreach the same way you can write the iterator loop with for. You can't write a C-style loop accidentally. Nor can you write the iterator loop accidentally. Whichever synonym you use is irrelevant to the behavior of the code; it adds no clarity in its redundancy. I guess it depends on how you code and what you're used to. I always write an iterator over a container using foreach, and use for for C style loops. &gt; There is no reason to use foreach, ever. It's a distraction. Ah, ok, this was what you were trying to say? Fair enough. So you'd just use "for"? Or would you use "each" for this specific type of loop?
I never use the `foreach` keyword. For this particular problem, if I could use 5.12, I'd use `each`.
That's *almost* the same as this: use lib '/path/to/lib'; use My::Module qw(e t c); From `perldoc lib`: &gt; Saying use lib LIST; &gt; is *almost* the same as saying BEGIN { unshift(@INC, LIST) } &gt; For each directory in `LIST` (called `$dir` here) the lib module also checks to see if a directory called `$dir/$archname/auto` exists. If so the `$dir/$archname` directory is assumed to be a corresponding architecture specific directory and is added to `@INC` in front of `$dir`. The upshot is that `use lib` will Do The Right Thing to ensure your program works portably across all platforms. Manually adjusting `@INC` doesn't. If you're not using any platform-dependent modules (i.e. those that have XS/C components) then it makes no difference. But as a general rule `use lib` is to be preferred because it's "more correct".
Ah, we are currently stuck on 5.10. I hadn't come across `each` until today :)
Basically your list doesn't contain hashes, it contains hash _references_. If you have a hash reference named $ref, you can make a hash from it with %{$ref} (can often be spelled %$ref), and you can lookup values in it with $ref-&gt;{$key} instead of %{$ref}{$key}.
This is where you go wrong: my %tempHash = $arrayOfHash[$i]; while (($key, $value) = each( %tempHash )) What you have is a reference to a hash, not a hash. So you can do: my $tempHashRef = $arrayOfHash[$i]; while (($key, $value) = each( %$tempHashRef )) Also, though this must work, it's not very Perlish: for ($i = 0; $i &lt; scalar(@arrayOfHash); $i++){ my $something = $arrayOfHash[$i]; I would make that foreach (@arrayOfHash) { (which puts an alias to the original array item in `$_`) or foreach my $something (@arrayOfHash) { although if you need a loop counter `$i`, you'll either have to provide it separately, or keep using your old code.
Ok, thanks. This has cleared up a lot for me. I'm a young bioinformaticist, so I'm still getting my head around application development.
 Why do people post Perl help questions to reddit? This isn't the right forum for that. Reddit isn't where people go to answer questions nor where they would search for answers. So anything you answer here isn't going to be noticed or helpful to those that come after you. Please ask these kinds of questions on either http://perlmonks.org or http://stackoverflow.com
*if your only suggestions are that code should be easier to read and aesthetically pleasing* You make it sound like "aesthetically pleasing" is unimportant.
Two things for general debugging: use Data::Dumper; print Dumper(\@arrayOfHash); The other is Smart::Comments. I LOVE Smart::Comments. just: use Smart::Comments; and then add a comment like \#\#\# array of hash : @arrayOfHash And you can see their structures.
redbar [told an interesting story about this](http://www.reddit.com/r/programming/comments/btjx4/why_perl_6_is_different/c0oifq3): &gt;&gt; Language wars are really just different use-cases. &gt;The year is 2042. The human/robot war has been ongoing for about a decade. &gt; &gt;Two troopers meet at a pub. After each having bragged about their preferred anti-robot weaponry, they decide to meet the next day at the range to compare hardware. &gt; &gt;They arrive at the range -- each with a few friends -- and there are various targets set up for practice: old blown-out robo-tanks, 5-gallon steel drums, etc. &gt; &gt;The first fellow removes his hardware from a large ragged canvas duffle bag. It's a late-model PL5. It's a bit heavy, but has shoulder straps to help hold it up. It' got 6 barrels that rotate gatlin-gun style when fired. The rotating assembly is chain-driven, and you need to watch your fingers lest they get caught in the mechanism when in use. Judging by the less-than-staight fingers on some of PL5-guy's friends, you surmise that they've paid the price for not being careful enough with it. Aside from a few other jagged and sharp pieces, most of its other parts are worn smooth. The PL5 is well-oiled ({cough} you need to wipe off your hands after using it) and mostly made of steel. We say "mostly" because if you look closely you could swear that some pieces seem to be fashioned from bicycle parts or even kitchen appliances. After tweaking a few adjustments here and there, PL5-guy indicates he's ready for some competition. &gt;The second fellow, after watching this messy spectacle, now removes his hardware from it's case. It's a beautiful case -- brushed aluminum. It opens like a clamshell, and inside is foam rubber with hollowed-out compartments for the rifle as well as its attachments. This is a model PY. You may have seen them in the trade magazines. Generously padded stock, titanium finish, well-balanced, silencer. Just lovely. PY-guy gingerly removes the hardware from his case. It hardly weighs anything (in fact, most of its weight seems to be due to the batteries, which are included). PY-guy checks the laser scope and indicates that he's ready. &gt; &gt;PL5-guy scratches his beard, levels the PL5 at a distant steel drum and lets fly. The PL5 roars. Through the smoke, flame, and noise, PL5-guy can be heard alternately laughing and cursing. Moments later it stops and the rotating barrels slow to a stop. The steel drum (or what's left of it) is in half. &gt; &gt;After PL5-guy's friends have finished high-fiving eachother, PY-guy unlocks the safety, takes aim at a steel drum, and fires. Amazingly, there's almost no noise at all due to the silencer. PY-guy comfortably cuts a neat circle out of the steel drum without even messing up his neatly combed hair, and then raises an eyebrow at PL5-guy. &gt; &gt;PL5-guy gives a "hrumph", disengages the chain drive on the PL5, pulls out his own laser-scope attachment, and creates a "happy face" on one of the steel drums. Wee hoo! &gt;Just then, announcements come over the practice range PA saying that robo-enemy forces are advancing over the hill, right into the practice range! &gt; &gt;Both of our brave troopers decide to stay and hold off the enemy until reinforcements arrive. As the toasters are coming over the hill they begin firing, but then realize that these robots are carrying heavy armor. Their standard rounds aren't getting through. PY-guy calls to PL5-guy: "It's no use, they've got heavy armor. We're going to have to aim carefully for any weak spots we can find! Not sure if we're going to be able to finish our competition today! :)" &gt; &gt;PL5-guy yells back, "Hang on a sec..." as his friends dig into a 2nd battered duffle bag which seems to contain mostly attachments for the PL5. PL5-guy pops off the laser scope and says, "I hope you brought your earplugs" while his friends help fasten on one of the grenade launcher attachments.
Why not?
Upvoted for best language war story ever.
Text based programming languages are the punch cards of the future.
Visual programming languages will always be the languages of the future.
Oh, good. We need another one of these.
Given upstart's continuing inability to do common, simple things and daemontools' status as djbware, yes, I think we do need another one of these.
You mean only native English speakers have something to say about technology?
I noticed that too, but in this example it's not a problem. If `bar` is a normal Perl function, it'll take all three parameters. If it's not a normal Perl function--if it has a different arity--the parser will warn about the use of one or more constants in void context at compilation time.
That's right. The problem only occurs if the function call is part of another expression. I recommend always using parentheses on function and method calls.
I disagree. I believe that ambiguity is a bigger problem than clutter. In $x = foo, is foo a variable or a function? You'd have to go searching through the code to find out where foo is declared or defined, or else retain all those declarations and definitions in your working memory. In $x = $foo(), the ambiguity is removed, so the code is easier to understand at sight. 
You're right, however this problem primarily stems from naming the function 'foo' in the first place. Names are not just identifiers, but semantics and comments for the gentle reader too.
Also, foo could be a string constant without strict.
 open my ($fh), "&lt;", $file is probably to avoid open my $fh, "&lt;", $file looking like the 'my' is slurping more and open (my $fh), "&lt;", $file would fall afoul of Perl's "looks like a function" rule. That said, I do the second if I have "or die" on it and if (open(my $fh, "&lt;", $file)) { if I'm using 'if'.
Always using parentheses with `my` causes problems in other places, where people should use a scalar assignment but instead write a single-element list assignment. The solution to thinking that `my` slurps up too much in the `open` case is learning the signature of `open`.
&gt; In $x = foo, is foo a variable or a function? It's not a variable without a sigil.
&gt; Names are not just identifiers, but semantics and comments for the gentle reader too. That's true, but even semantically significant identifiers may suffer the false cognate problem too.
&gt;Therefore, we've decided to to let the release date slip one more month and release Rakudo Star not later than July 29, 2010. It seems that you got the headline wrong.
perl 6 is like the Duke Nukem Forever of languages.
Except it actually exists.
Of course, my bad. Any idea how (if?) can I edit the title?
You can't. You can delete and repost though.
Oh god. I cringe when I read Perl "discussions" in that subreddit.
/r/programming talking about perl. :'(
the mention of "tie" in the context of object-oriented capabilities gives away a lack of knowledge in the area. either that or trolling perl devs who like to bite.
Yeah, it's interesting how there's always posts about Python, Ruby, etc in there, but hardly anyone has the courage to post specifically about Perl.
Anyone used this or played with it a bit? Read this: &gt; The all-in-one CMS. Makes me have Joomla flashbacks.
Duke Nuke Em jokes are the programmer equivalent of stand-up comedians doing bits about foreigners working at convenience stores.
Yeah, I want Postgres support. Oh wait, you threw that one out.
*cough* SPAM! *cough* *cough* 
why? WebGUI is written in Perl
Simple; In order to make this determination I asked myself: As a Perl enthusiast is the question of whether or not I want more from my CMS relevant? The answer is clearly no. Sure, there may be about a paragraph worth of light information about the decision to use Perl and Catalyst (my web framework of choice) which basically everyone reading /r/perl already can already come up with at least a few reasons to make the same decision I'm sure. The rest of the Article is really aimed at content providers. And while there are plenty of Perl enthusiasts that are content providers I am sure if they are looking to "Get more from their CMS" I am sure they would probably go to a forum on CMS before going to /r/perl. I mean the article doesn't have even one piece of information about programming in Perl.
I don't really disagree with this quote, at least in the context it's in. In Ruby, unlike Perl or Python, everything is an object, including all core language types. Perl adds OO on top of a non-OO imperative language. The real problem is that there's no good definition of what it means to say that a language "is" object-oriented. 
Alien::SDL seems to want Alien/SDL/ConfigData.pm, which isn't in the package. $ make test PERL_DL_NONLAZY=1 /opt/local/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'blib/lib', 'blib/arch')" t/*.t t/001_load.................. # Failed test 'use Alien::SDL;' # in t/001_load.t at line 5. # Tried to use 'Alien::SDL'. # Error: Can't locate Alien/SDL/ConfigData.pm in @INC
Alien::SDL::ConfigData.pm is autogenerated. Please update your Module::Build. 
Judging by the output, I would guess this is a problem of 'traditional' Makefile compatibility. That only works for simple cases. Try using 'small' Makefile compatibility.
I am using Module::Build. There is no Makefile.
 Checking prerequisites... build_requires: ! Test::Most is not installed Test::Most won't install because it's taking a vacation in CPAN circular dependency hell with Exception::Class. Then I get a whole bunch of errors like this: [Alien::SDL] Testing header(s): SDL_imageFilter.h /var/folders/Fu/FuhhDWGe2RWE0U+1YsyK4U+++TI/-Tmp/pxNf_2hADo.c:5:29: \ error: SDL_imageFilter.h: No such file or directory Same for SDL_framerate.h, SDL_gfxBlitFunc.h, SDL_gfxPrimitives.h, SDL_rotozoom.h, SDL_framerate.h, SDL_Pango.h, and tiff.h. During `perl Build` I get lots of warnings like this: ld: warning: in /opt/local/lib/libSDLmain.a, file was built for unsupported file format \ which is not the architecture being linked (i386) Then `perl Build bundle` fails big time. [abw@gmesh ~/build/sdl/kthakore-SDL_perl-2cc5e57] perl Build bundle Building SDL gcc -o "SDLPerl.app/Contents/MacOS/SDLPerl" MacOSX/main.c \ -arch x86_64 -arch i386 -arch ppc -g -pipe -fno-common \ -DPERL_DARWIN -fno-strict-aliasing -I/usr/local/include \ -I/System/Library/Perl/5.10.0/darwin-thread-multi-2level/CORE -I/opt/local/include/SDL \ -D_GNU_SOURCE=1 -D_THREAD_SAFE -I -I -I/usr/X11R6/include -I/usr/local/include \ -arch x86_64 -arch i386 -arch ppc -L/usr/local/lib \ -L/System/Library/Perl/5.10.0/darwin-thread-multi-2level/CORE -lperl -ldl -lm -lutil -lc \ -L/opt/local/lib -lSDLmain -lSDL -Wl,-framework,Cocoa \ -L/usr/local/lib -L/usr/X11R6/lib -lSDLmain MacOSX/main.c:3:21: error: SDL/SDL.h: No such file or directory MacOSX/main.c:3:21: error: SDL/SDL.h: No such file or directory {standard input}:147:non-relocatable subtraction expression, "_my_perl" minus "L00000000002$pb" {standard input}:147:symbol: "_my_perl" can't be undefined in a subtraction expression Followed by many more similar errors.
What option did you use to build in Alien::SDL?
Somehow s_m_c is using make, don't ask me how if there's no Makefile.PL generation
I think it was number 1 - use existing installation.
hm. That seems to be the problem. As you don't have headers or Alien::SDL can't find it.
I had to run perl Build install to get `shooter.pl` and `test/checkkeys.pl` to work (it complained about not being able to find `SDL.pm` otherwise). What is `test/checkkeys.pl` supposed to do? It just came up as a black window for me. `shooter.pl` worked as expected. No crash occurred for either program when closing from the window or by clicking on the app in the doc and saying quit.
Press keys (on the keyboard) for check keys. Thanks for the 'install' tip. I added it. 
Can you give SDLx::TTF a try? It seems to be dying on the header search. This module is for frozen-bubble. Please post the gcc command. Or email me
Is this what you were looking for? Building SDLx-TTF cc -Isrc -I/Users/cowens/perl5/perlbrew/perls/perl-5.12.1/lib/5.12.1/darwin-2level/CORE -DXS_VERSION="0.004" -DVERSION="0.004" -I/Users/cowens/perl5/perlbrew/perls/perl-5.12.1/lib/site_perl/5.12.1/auto/share/dist/Alien-SDL/1.407_4271c9c5/include -fnested-functions -c -fno-common -DPERL_DARWIN -no-cpp-precomp -fno-strict-aliasing -pipe -fstack-protector -I/usr/local/include -I/opt/local/include -O3 -o lib/SDLx/TTF.o lib/SDLx/TTF.c lib/SDLx/TTF.xs:39:21: error: SDL/SDL.h: No such file or directory lib/SDLx/TTF.xs:40:27: error: SDL/SDL_image.h: No such file or directory
Typing quickly is seizure inducing, I assume this is what it is supposed to do.
yup. can you manually try cc -Isrc -I/Users/cowens/perl5/perlbrew/perls/perl-5.12.1/lib/5.12.1/darwin-2level/CORE -I/Users/cowens/perl5/perlbrew/perls/perl-5.12.1/lib/site_perl/5.12.1/auto/share/dist/Alien-SDL/1.407_4271c9c5/include -DXS_VERSION="0.004" -DVERSION="0.004" -fnested-functions -c -fno-common -DPERL_DARWIN -no-cpp-precomp -fno-strict-aliasing -pipe -fstack-protector -O3 -o lib/SDLx/TTF.o lib/SDLx/TTF.c also ls /Users/cowens/perl5/perlbrew/perls/perl-5.12.1/lib/site_perl/5.12.1/auto/share/dist/Alien-SDL/1.407_4271c9c5/include Would it be possible for you to come on #sdl irc.perl.org?
Pretty much. It is supposed to test event subsystem.
OK, I tried again selecting option 2. I got as far as `perl Build` and everything seemed to go OK until I got here: Running make install SDL_gfx... (cmd: make install) /bin/sh ./libtool --tag=CC --mode=compile gcc -DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE=\"SDL_gfx\" -DVERSION=\"2.0.20\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DBUILD_DLL -I. -I/Users/abw/build/kthakore-Alien_SDL-0c4cec6/sharedir/v0.8.0_6aca4eea/include -O -DUSE_MMX -I/Users/abw/build/kthakore-Alien_SDL-0c4cec6/sharedir/v0.8.0_6aca4eea/include/SDL -D_GNU_SOURCE=1 -D_THREAD_SAFE -MT SDL_imageFilter.lo -MD -MP -MF .deps/SDL_imageFilter.Tpo -c -o SDL_imageFilter.lo SDL_imageFilter.c gcc -DPACKAGE_NAME=\"\" -DPACKAGE_TARNAME=\"\" -DPACKAGE_VERSION=\"\" -DPACKAGE_STRING=\"\" -DPACKAGE_BUGREPORT=\"\" -DPACKAGE=\"SDL_gfx\" -DVERSION=\"2.0.20\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_DLFCN_H=1 -DBUILD_DLL -I. -I/Users/abw/build/kthakore-Alien_SDL-0c4cec6/sharedir/v0.8.0_6aca4eea/include -O -DUSE_MMX -I/Users/abw/build/kthakore-Alien_SDL-0c4cec6/sharedir/v0.8.0_6aca4eea/include/SDL -D_GNU_SOURCE=1 -D_THREAD_SAFE -MT SDL_imageFilter.lo -MD -MP -MF .deps/SDL_imageFilter.Tpo -c SDL_imageFilter.c -fno-common -DPIC -o .libs/SDL_imageFilter.o /var/folders/...blah.../ccxpbxRb.s:10:`pusha' is not supported in 64-bit mode /var/folders/...blah.../ccxpbxRb.s:14:`popa' is not supported in 64-bit mode The previous 2 errors were repeated for a number of different locations in that file. BTW, I selected 'Y' each time it prompted me thus: Run ./configure for 'SDL_XXX' again? [n ] y 
What is your archname? perl -e "use Config; print \$Config{'archname'};"
darwin-thread-multi-2level
ok I think I will look into this. Thanks for testing.
OK. And thanks for all your hard work, too.
I have updated the ticket, thank you. http://sdlperl.ath.cx/projects/SDLPerl/ticket/23#comment:4
Thanks chromatic. When do you expect to have this out in print form?
I hope sometime in August, but that depends on how much editing I need from now.
Well, I checkouted RakuDo repo a few times lately, and perl6 never really works.And now I figured it out: perl6 binary must be run from it parent dir, not from the my test program dir, as normally could be expected. Yeaay, I can has perl6 programming now! (slurps more black tea...)
Looks great. Thanks. :) Noticed a typo/duplicated-link in chapter 8 ("Stylish Perl") after "Join in a mailing list such as the Perl Beginners list". Also, chp.11, typo in "presume to dictate what you most maintainable". 
Trololololo. I have absolutely no problems with it (it's installed though).
Troll? What do you call this then: ~/path/to/myscript&gt; ~/path/to/git/rakudo/perl6 myscript.pl Null PMC access in find_method('new_class') current instr.: '' pc -1 ((unknown file):-1) (:5458) Segmentation fault. 
I didn't say you lie and it actually works. What you posted is a known bug, and you are right. But calling the whole Perl 6 unusable because of it is not really right, as it works just fine when installed. I, for example, have never experienced this.
I never got to installing stage. I wanted to test it as soon as build finishes, and it never worked. I never thought I run the binary in the unexpected way. After install, perl6 works fine, but I discovered it the hard way.
Well, IIRC this is alredy on RT and is going to be fixed in the next release, plenty of people were reporting it on IRC. The mentioned irc channel is very helpful by the way, a good way to check if something is a bug or a feature.
The installation instructions work fine... But it seems to be slow to run even the hello world script.. more than 1sec for me.. 
The generated code is not yet optimized, the whole effort is put into implementing the whole Perl 6. See [here](http://stackoverflow.com/questions/3135673/what-performance-increases-can-we-expect-as-the-perl-6-implementations-mature/3136192#3136192)
The "conventional" Moose style for declaring attributes is: has foo =&gt; ( is =&gt; 'ro', isa =&gt; 'Str', another_option =&gt; 'blah', more =&gt; 'blah', ); (I see you touched on this at http://www.modernperlbooks.com/mt/2010/07/when-sugar-and-semantics-collide.html, so... never mind, I guess...) 
Open source Integrated development editor for Perl
wow, and it was not even my post! promise!
the E stands for Environment, not Editor. But yes. Padre is awesome.
I've used Komodo Edit for a long time, is this better?
I believe they're both based on the [Scintilla editing component](http://en.wikipedia.org/wiki/Scintilla_%28editing_component%29), however, it doesn't look like Komodo supports syntax highlighting specifically for Perl 6 yet. How does Padre accomplish this? 
Spammy spammer is spammy. Reported.
Or emacs and cperl.
Isn't it great that Class::Struct is still recommended in the official perl documentation (http://perldoc.perl.org/perltoot.html#Class%3a%3aStruct) :-/
*That's* where I saw the lousy "use `new()` as a function!" code. That documentation has not aged well.
perltoot and perltooc are so dated that even deleting them might be an improvement. Sometimes it feels like there's more harmful than helpful advice in it.
It might please you to learn that I've patched the rakudo README to emphasize the importance of the 'make install' step: http://github.com/rakudo/rakudo/commit/261eb2ae08fee75a0a0e3935ef64c516e8bc2b98 I don't like that limitation, but it's hard to solve in a portable manner, so we're at least trying to document it properly. Now if people don't read the README, we're out of luck, but I wouldn't know how to reache these people anyway. Any ideas?
Thanx! That's cool! I'm a README guy, so it's fine by me. The other way would be to put that "make install" info somewhere into the build process - into Configure.pl, for example, to be printed to the user before she hits make.
Network Administration task. Cacti, MRTG, and most others graph traffic rates in 5 minute intervals. But when you are making the switch from one major traffic route to another, you don't have 5 minutes to wait and see if all the traffic shifted properly... you need to see that traffic moving as close to *instantly* as possible. PERL's SNMP functionality is awesome. In my script I did the following- * allow the user to pick two interfaces on a router. * SNMP poll those interfaces once per second for traffic rates (ifINOctets and IfOUTOctets I believe). * Spit those responses out ASAP for timeliness. For the first time I could say, *"Now I'm making the routing changes"* and someone else or myself could see the immediate effect. From that moment on I was hooked on PERL.
perl -de 0 That sets it in an immediate debug mode where you can enter and evaluate expressions. With it I was able to experiment with all aspects of perl - hashes, arrays, modules, anything. I was hooked. Granted a lot of languages have something similar, but this was a long time ago (perl 4x was just coming in the scene).
Somewhere between several hundred GB and a few TB of system logs, and I needed to sort through the logs and do different string operations on lines that had a certain pattern. That, and some server-side scripting for a different part of the same project. The scripts needed to do some basic string parsing.
I don't even remember anymore. But in 11 years, I don't think I've stumbled across but one or two problems that someone hadn't already written a module for.
I took computer class during my junior year in highschool (1994-1995) as a "gimme" course. I finished all my assignments the first week and was writing silly programs in C while the rest of the class tried to figure out how a word processor program worked. Needless to say my teacher realized what I was doing and set me up with going to work with the local freenet to earn my grade for the class. The only language I knew at the time was C (besides some old Commodore programming) and they got me started learning HTML. My second day they handed me a book about Perl and I was hooked. I use it for web programming any chance I get.
I think I was reading about CGI security problems in high-school at the time, and all the code was in Perl and full of long regular expressions for detecting bad user input... Yeah, I wanted to learn how to construct such a monstrosity of a line of code. Did some of the horrible tutorials that are (were?) floating around and I still loved Perl.
I started playing with Perl ages and ages ago, when it was one of the only languages available for online free web development (ah, Tripod!), but didn't really get very far with it. That little experience came in handy during my undergrad days, when I had to do some biological data processing and turned to Perl because of the powerful regular expressions. I also grew to love the expressive power of the language: I could say "y if($x)" or "y unless $x" or "if($x) { y }" depending on precisely what it was I intended to say. I gave it up as a primary development language when I had to do a lot of UI programming, and decided to use Java AWT as a simple, cross-platform one with first-class support on Macs (although I did continue using it to write small, quick tools to do straightforward tasks too complex for Bash). I returned to Perl in my second job as a language to "throw a website" together in, and got seriously hooked to CPAN. Since then, Perl has been my first language of choice for anything I've had to do anywhere: no other language is as expressive, useful, featureful and reliable.
There were two things that really drew me into Perl. The first: I was working together with one other guy on a website in PHP (this was about 1999, and it was a portal site). We needed to do some kind of schema migration in the DB (the details are lost to the mists of time) and I was all ready to write something using the CLI version of PHP, but the guy I was working with told me that Perl and DBI were much better tools for the job. That got me curious, although I didn't do anything about it right away. A few years later (but not too many) I was using gaim. It couldn't have been that much later because gaim's Oscar support was still brand new, and they recommended that people use TOC instead. Gaim had support for downloading the buddy list from the TOC server, but it was ignoring the attached privacy settings. Since the TOC buddy list and the gaim buddy list were both text formats, I sat down with the perldocs and wrote myself a script that would read a TOC buddy list and write a gaim client-side buddy list, with the privacy settings intact. And that's how I got started with Perl for real.
My first exposure to Perl was in high school, when I'd worked with BASIC, C, and a little C++. I remember finding it incomprehensible. About a year later, I had a job as a sysadmin with the university's CS department. When I needed small utilities, I wrote them in C. Another guy who worked in the same office had utilities that he'd written in that same weird language. What sold me was how much he was able to do with amazingly little code, and I also wanted to learn to decipher the secrets of the doctors' prescriptions. He loaned me his copy of the Llama book (the first edition, pink in those days), and I read it cover-to-cover that night. I started using it at work. Practice, practice, practice. Soon I was regularly answering questions in comp.lang.perl.misc and participating in p5p. Later I was sending patches, writing in TPJ, speaking at yapc, and moderating comp.lang.perl.moderated.
Fixing a COBOL bug in 150 lines of code and reduced it to 80 lines. I rewrote it in this language called "Perl" a friend told me about. It was 10 lines of code and that was with error checking. I never looked back.
I moved to a new country and the council of a rather large city wanted a reverse proxy installed and wanted a fixed price quoted for the solution. I thought I'd be able to pull this off by using squid, but with the extra layer of authentication it became impossible. I tried all sorts of other bits of FOSS to try achieve this goal but eventually since I needed the cash badly I decided to jump in and learn perl and write this reverse proxy, it took me just over 2 weeks. It was such a success that I got more work out of it, and they used it for years until they finally got budget to replace it with an appliance. I was hooked since. However, if I think of the code I wrote for that project, I cringe bigtime.
Money. I started a job claiming to know perl. Had to learn it to earn the money. Sadly I've been addicted for a while. I do have a shiny new mistress though; she's red and like a precious gem.
Reading the title took me back to the old ["Don't copy that floppy"](http://www.youtube.com/watch?v=up863eQKGUI) commercial. Thanks.
or the sequel... http://www.youtube.com/watch?v=hUCyvw4w_yk
I couldn't find a good rhyme. Otherwise it would have reminded you more!
A mime is a terrible thing to waste.
This is awesome! I didn't know perl was still used on the web. How would one create search queries with perl? Disgusting looking regex matches?
As someone who gets paid to code Perl all day long, I approve. 
Stop parsing that darn string! Oh, you said *good* rhyme, didn't you? Sorry.
Not sure what the reddiquette is here, but upon further reflection I thought this topic might generate more interesting discussion on r/programming, so I resubmitted there. 
what a surprise... big downvotes!
There are slant rhymes and there are *italic* rhymes and there's that.
It's ok, we're not bitter. We'll continue gluing the web together quietly.
As perlmonks works as it works, here's the version I managed to get http://wklej.org/id/362235/
Welcome to the internet, you must be new here.
There's also one on [Wall's website](http://www.wall.org/~larry/cheatsheet).
ok! We have a fix! It was a misbehaving regex. http://github.com/kthakore/Alien_SDL/commit/0f364cf3f4d3dde0748d9fa6297137572282c909 Can you try now?
Would also be nice to see a Perl 6 Quick Reference like [the rgruet one they have for Python](http://rgruet.free.fr/PQR26/PQR2.6.html) (though I could live without the multiple colors). 
(Just FYI: the "la" in " la" literally means "the" in French, making your sentence very weird to read, at least for me)
Fixed. Thanks. That's what I get for trying to sound sav wha fair. :-)
No, I just forgot how harsh the internets are against legitimate questions of curiosity. Pretty brutal.
&gt; legitimate questions It's not necessarily what you say, it's how you say it. Starting with an implication that a particular language was not used on the web anymore: &gt; I didn't know perl was still used on the web. Well, that would be excusable if it were not ignorance confirmed by a rather trollish question: &gt; How would one create search queries with perl? Which could be answered by either "ask a guy who uses it for that functionality" or "like in every other language". However with something like &gt; Disgusting looking regex matches? tossed at the gentle reader, the latter will assume that you're a troll, or a clever guy or gal whose realization of irony is much to elaborated.
You can find more [Perl cheat sheets on DevCheatSheet.com](http://devcheatsheet.com/tag/perl/). I will add this one once perlmonks is up again.
Greetings, As one who is only a hobbyist allow me to add in a way cool. I really liked the way that preference changes are saved immediately. No more "Click here to save changes." How do you do that? 
It's just a question, no need to get all fired up over it. &gt;How would one create search queries with perl? was a legitimate question. Genuine curiosity, thats what the comments sections are for. Discussions on a particular thread. There was no trollish comments here. &gt; Disgusting looking regex matches? &gt;tossed at the gentle reader, the latter will assume that you're a troll, or a clever guy or gal whose realization of irony is much to elaborated. Not really, I do use perl but I'm by no means some perl god which is why I asked...........
I took up Perl because it was one of the preferred CGI languages of the day. And Python, Tcl et al. horrified me.
Well, use CGI (or whatever) to get the search parameters... my $query = CGI-&gt;new; my $input_string = $query-&gt;param('input_field_name'); ... then process that string. E.g. reduce all whitespace accumulations to single spaces and kill leading/trailing whitespace ... $input_string =~ s/\s+/ /g; $input_string =~ s/^ //; $input_string =~ s/ $//; ... You can now check for syntax (like parentheses, quotes, special characters in general and whatnot), but fuck that. Pass this fucker and do whatever to him you want... my @words_to_search_for = split(/ /,$input_string); do_stuff_to_our @words_to_search_for; If that's disgusting to you, you can always refrain from them anyway. Everything beyond that is an act of really creating software, a task that is neither to fit a single comment nor to be language-dependent. Know how to store your data. Write a spider. Implement `do_stuff_to_our`. Use Levenshtein distance or similar functions to account for typos. Use a tree instead of a list if your syntax is non-trivial. Etc etc. To quote myself: &gt; &gt; "ask a guy who uses it for that functionality" or "like in every other language"
&gt; Disgusting looking regex matches? I'm a Perl guy and love regexes, and I found this hilarious
Didn't know about App::cpanoutdated. Really liking these useful tools under the App:: namespace. On another note, it would be useful if perlbrew let me install multiple Perls of the same version, and name them, as in: perlbrew install perl-5.12.1 try-crazy-stuff perlbrew install perl-5.12.1 keep-this-clean perlbrew install perl-5.12.1 testing-for-client-x perlbrew install perl-5.12.1 prod-for-client-x 
Hmm... &gt; http://gist.github.com/478440 Nice.
hmm? 
Canada? Toronto? 
Nope.
What Activestate does certainly has no bearing on what version of Perl I use; that article smells a lot like a paid press release from them. Anyway, I'm still using 5.10.1 in production, but 5.12 will come in time. I have testing boxes set up to make sure that our apps still work fine on 5.12, but for the sake of simplicity I'd rather wait until Debian ships 5.12 before running stuff on it :)
CentOS is still on 5.8.8 - the bastards. I guess we should start rolling our own; it's getting ridiculous how out-of-date the distro is.