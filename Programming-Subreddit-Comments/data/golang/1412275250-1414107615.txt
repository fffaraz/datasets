At the moment, I'm using unit-testing and Bash to test things. Were I at the point where I had to test a compiled CLI binary, I would probably write a BASH script to automate most of that. I'm a contributor on [go-toml](http://github.com/pelletier/go-toml). This uses a rather interesting setup for automated testing beyond Go's unit-tests. The project uses the BurntSushi test suite to drive a test CLI stub for the library. A BASH wrapper downloads the suite, compiles the test runner, and runs the go-toml test stub program through the suite.
I don't have much experience in Go, but if I don't have the possibility to do step-by-step debugging of code, I would do [TDD](https://en.wikipedia.org/wiki/Test-driven_development) (test driven development) to ensure code quality. This means before writing the actual code - write a unit test for it. The unit test acts like an contract your code must meet. If a change to your code breaks something, your unit tests will fail.
I saw this page. But it looks a hard to me. And this is a C debugger, not a Go debugger, right? Oh, and this quote came from the page: &gt; "although GDB can be useful in some situations, it is not a reliable debugger for Go programs, particularly heavily concurrent one."
I still use C in a lot of my projects. However, for things like making a web server or file server, I generally prefer using Go for that. C is a very, very nice language for many, many, many things.
It's a debugger, not a C debugger. It debugs binaries the only dependency is to have debug and symbols information available, which most of the compilers will have a way provide.
&gt; With C, it is possible (even if not advisable) to go into arbitrary memory locations and bit twiddle. You can't do that with go. var arbitraryMemoryLocation uintptr = 234 var somethingToTwiddle *byte somethingToTwiddle = (*byte)(unsafe.Pointer(arbitraryMemoryLocation)) If the GC runs while `somethingToTwiddle` is in scope, the program will crash. So switch GC off.
Yeah. I think I need to restructure that code fundamentally. I've been keeping parallel versions in erlang and go... Just for fun. Neither done "well" in any sense.
Is there anything like this for vim?
Ah, thanks!
printing log lines out is more than sufficient for me
I don't really understand your problem. What's defined in the file? Functions? And regarding a file containing ints, the `strconv` package lets you converts strings to ints, but I don't see why you'd need to convert a *slice* to an int. A slice of what?
Is the way the text file is read supposed to be defined by the user or just the actual contents of the file? 
I don't think I really understand what you're trying to accomplish, but what's wrong with: shouts := make([]func(Mammal, string), 0) shouts = append(shouts, Mammal.Shout, Mammal.Shout) for i, fn := range(shouts) { fn(mammals[i], message) }
The file has state transitions to an machine based on the automata theory. I was planning on using a code that reads the .txt to a string, putting each line from the .txt in a slice of the string, but I would need to compare a slice element later on, but couldn't do it with the slice.
Okay, for reading from a file I'd recommend using a `bufio.Scanner`. If you open the file as you normally would, you can pass the resulting file into the scanner and use this pattern to parse it line by line: // where s := bufio.NewScanner(os.Open('myfile')) for s.Scan() { this_line := s.Text() // string // Do stuff with this_line. } As for your statement &gt; putting each line from the .txt in a slice of the string That makes no sense. Do you want to make a slice of strings? 
Thanks, that actually helped. Actually I was a bit confused myself. I actually figured out how to accomplish what I originally intended and got somewhat sidetracked with this experiment. http://play.golang.org/p/Qio4roM5dF In this version the part where Human screams/shouts is the sort of functionality I actually needed.
Thanks for the input, but how will the filename variable receive the name of the txt? Would a fmt.Scan work? Sorry if I sound noob, thats because I am one...
Just a follow-up. This is exactly what I wanted to do in the first place. Basically the net/http package offers two methods for adding handlers: creating something that implements the Handle interface or create a handler func. I wanted to pass in the same structure but with multiple handlers operating on the same struct. This is one solution. But I wonder if there is a more elegant solution? package main import "fmt" func main() { handlers := make([]func(string),0) foo := new(Foo) foo.A = "first" foo.B = "second" fnA := func(s string) { foo.AFunc(s) } fnB := func(s string) { foo.BFunc(s) } handlers = append(handlers, fnA, fnB) param := "input" for _, fn := range(handlers) { fn(param) } } type Foo struct { A string B string } func (f *Foo) AFunc(param string) { fmt.Println("param: " + param + ", A: " + f.A) } func (f *Foo) BFunc(param string) { fmt.Println("param: " + param + ", B: " + f.B) } 
It's already in PC's repository!
While GDB might run, it still has trouble understanding Go programs, irrespective of platform. More details here: https://golang.org/doc/gdb
&gt; How do I prevent Go from doing this and allow my script to run, even with unused imports and unused variables? To fix the *unused imports* just use an editor that can run *goimports* each time the file is saved. Any scriptable editor can be configured to do this, so as you can imagine that means there are quite a editors to choose from. As an example of how this is done, here's the *goimports* [script ](http://www.zeusedit.com/zforum/viewtopic.php?t=7111) for the Zeus IDE.
Finally. Sorry for the delay. One day Go will be better integrated into the various linux distro's release schedule and this won't be needed any more.
Yeah, because of its virtues, C has been overused. I love it but it's hard to justify using it given its lack of safety. I do disagree about "need" though. Could I use a different language? Yes, but that's nearly always true. However, given runtime requirements like high performance and minimal memory usage, you're basically talking about C/C++. There is a space between those languages and Java/C#, and I think Go fits in that space well. I am interested in Rust, but it's convoluted syntax and constantly changing spec have put me off ( I know it's still quite new so all this is understandable). I look forward to a more complete version in hopes of relegating C to a lower level of programming (reluctantly though... man, there's just something about it).
Could this be able running on Android? 
GDB can run under OSX, you have to generate a certificate (use keychain access) to sign the gdb binary. 
I'm only building tarballs for the released (and sometimes beta) versions of Go. If you want to play with the android build you should follow the development branch. Also, building for android means you will be _cross compiling_ from something to android/arm, so these tarballs are not what you are looking for anyway.
There are other projects working on Android.
Well, i guess this is my opportunity to try and learn vimscript… I'm not looking forward to this, haha.
When you run the file, it goes in the arguments. 
https://github.com/fatih/vim-go -- everything you need for a great vim experience... I too am a vimmer (come say hi in #vim on freenode). https://gobyexample.com/ is great for quick fixes. Additionally, Go is a very simple language, read the spec ( 50 pages: https://golang.org/ref/spec ). A spec might seem intimidating at first, but once you get over the hump, it is the definitive source. 
knockout and go - good choice.
Do you not want to read a file after all, but write it? Is this like a utility that generates a file based on commandline parameters or comparable user input? It's hard to grasp what you want to accomplish. 
Not making a variable useful isn't an error. It's not writing proper go code, but it's technically not an error. By assigning it to_ you're technically using it.
Maybe it is more elegant solution is to use foo := Foo{ A: "first", B: "second" }
Yup, knockout is seriously cool stuff. The event propagation chain was so clean and elegant.
&gt; There is a possibility where it may not be using slices I'm still not following. With the above code, the only way that would happen is if you get `nil`, and in that case the error message should tell you what's wrong.
Thanks, already watched it :)
I considered it, but the separator (well defined indeed) might be inside comment. That's why I'm looping over the runes manually.
It very often is an error... I've had this feature save me from bugs like this: 1 foo, count := getStuff() 2 if count &gt; 0 { 3 foo := foo + "s" 4 } the above will generate an unused variable error for line 3's foo, which will show that you're not actually modifying the foo from line 1 inside the if statement (which is most likely what you meant to do). This is a fairly simplistic example, but I've had mistakes like this caught by the unused variable check multiple times. Also, it keeps your code clear. If you don't use a variable, and someone goes back to look at your code, they're going to wonder if that's a mistake or not. The nice thing about the unused variable check is that it forces you to make your code explicit. You have to say "yes, I really am intentionally ignoring this variable" by doing something like foo, _ := stuff() // look ma, it's obvious I don't care about the second return here Here's a full post I did about why the unused variable check is a good thing: http://npf.io/2014/03/unused-variables-in-go/
Screenshots?
A screenshot added to the README file.
...What? Of course it's using slices! You're *defining a slice*!
Just to pile on, the type system combined with a good IDE/plugin elucidates a variable's type quite effectively. For example, some might argue that "r" is non descriptive, but when viewed in context plus seeing the IDE/plugin hint that it's an io.Reader, "r" gets the job done.
Good points. Good article. Thanks.
Oohhh, a todo list application ... I thought a task manager as in OS tasks/processes.
Mo, This is a really good write-up. It should be marked as required reading for beginners. Low level, yet clear and thoroughly explained.
Not everyone uses an IDE tough, code should be readable without it.
Glad you dug it, was worried I'd missed the mark again after some down votes!
I agree, descriptive method &amp; variable names is desirable.
Are you coding in TextEdit?
*sigh* That seems about right for MongoDB. I'm absolutely not mocking Go in any way, but MongoDB has an unparalleled ability to seem like they're just jumping on stuff because it's the new shiny.
Go's been there for 5 years now.
MongoDB is also 5 years old. Did you jump on it?
That's precisely why it's messy - they simply stored code in folders under GOPATH to github. Hence src/&lt;go-gettable package import path goes here&gt;
`go get github.com/mongodb/mongo-tools/src/github.com/mongodb/mongo-tools/*` way to mess that one up, Mongo
no?
As a Windows user, i was confused as well.
screen shot?
No, because I'm appropriately paranoid about my data, and they consistently show that they're not (though they've been getting better on that score). Using an immature language with an unstable API, that hadn't even reached version 1.0 at the time is a perfect example. *Even* if we're talking about tools surrounding the main product.
Awesome my man, thanks a bunch!
They can't event release a project properly. I bet it locked :D
Oh this is awesome! I might use this in my project: https://cryptoballot.com (written in go). 
Just added to the readme. Thanks for the suggestion.
I opened up a ticket: https://github.com/mongodb/mongo-tools/issues/1
Their CTO has a very bizarre attitude towards GOPATH. I heard him explain it once. This is the way he has the team organize their Go projects. 
My suggestion: https://github.com/mongodb/mongo-tools/issues/1#issuecomment-57866484
Hit their JIRA instead, under the `TOOLS` component. Although be warned that if you have an account in MongoDB JIRA, you will absolutely receive marketing e-mail and surveys, and all opt-outs will be ignored. Because scraping an issue tracker for marketing opportunities is clearly the right play. I've been in correspondence with their Director of Marketing about it, and there's always some new issue that somehow re-allows their marketing mail to end up in my inbox, opt-out be damned. https://jira.mongodb.org/browse/TOOLS
no problemo...looks nice!
I just want more voting types, this is a great way to learn about them. 
Have you tried filing a complaint with the FTC under the CAN Spam act?
They're a vendor, so I wouldn't exactly want to go nuclear yet. It's better to work with them.
It also makes reordering things sooooo nice, but has the unintended consequences of hating CSV in other languages.
&gt; I replaced a 14.5 kloc C++ tool with 300 lines of Go very recently. That's really interesting. Would you mind elaborating on what about Go let you shave 14.2k loc?
People actually use Mongodb?
It's a bit disingenuous, because that old system had a lot of cruft in it, too. That being said, there was a pretty significant batch of the usual C++ boilerplate in it which Go made unnecessary. It spoke custom serialization, not even protobuf, to its server, and Go let me switch to JSON using the standard library. That was a majority of the win.
I think if done well -- this could be an incredible teaching tool for explaining (and experimenting with) different voting systems. I was just poking around Wikipedia to see the common voting types. I would love to see all the major systems covered (order isn't terribly important to me). If you go to http://en.wikipedia.org/wiki/Table_of_voting_systems_by_country and group by voting system, you can do it by popularity... the popular ones at a quick browse seem to be Plurality-at-large (bloc), D'Hondt, FPTP (First Past The Post), Largest Remainder, Parallel, Sainte-Lague, Instant-runoff, Single transferable, Single non-transferable, Hare quota, Two-round and Binomial... you already got some of these covered... Awesome start either way, I can't wait to play with it more. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Table of voting systems by country**](https://en.wikipedia.org/wiki/Table%20of%20voting%20systems%20by%20country): [](#sfw) --- &gt; &gt;This table deals with [voting](https://en.wikipedia.org/wiki/Voting_systems) to select candidates for office, not for the passing of legislation. &gt;==== &gt;[**Image**](https://i.imgur.com/iCFk6Mv.png) [^(i)](https://commons.wikimedia.org/wiki/File:Electoral_systems_for_heads_of_state_map.svg) --- ^Interesting: [^Instant-runoff ^voting](https://en.wikipedia.org/wiki/Instant-runoff_voting) ^| [^Proportional ^representation](https://en.wikipedia.org/wiki/Proportional_representation) ^| [^First-past-the-post ^voting](https://en.wikipedia.org/wiki/First-past-the-post_voting) ^| [^Two-round ^system](https://en.wikipedia.org/wiki/Two-round_system) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckzw5ak) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckzw5ak)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Majority Judgment**](https://en.wikipedia.org/wiki/Majority%20Judgment): [](#sfw) --- &gt; &gt;__Majority judgment__ is a single-winner [voting system](https://en.wikipedia.org/wiki/Voting_system) proposed by [Michel Balinski](https://en.wikipedia.org/wiki/Michel_Balinski) and Rida Laraki. Voters freely grade each candidate in one of several named ranks, for instance from "excellent" to "bad", and the candidate with the highest [median](https://en.wikipedia.org/wiki/Median) grade is the winner. If more than one candidate has the same median grade, a tiebreaker is used which sees the "closest-to-median" grade. Majority judgment can be considered as a form of [Bucklin voting](https://en.wikipedia.org/wiki/Bucklin_voting) which allows equal ranks. &gt; --- ^Interesting: [^Majority ^judgment](https://en.wikipedia.org/wiki/Majority_judgment) ^| [^Voting ^system](https://en.wikipedia.org/wiki/Voting_system) ^| [^Majority ^criterion](https://en.wikipedia.org/wiki/Majority_criterion) ^| [^Condorcet ^criterion](https://en.wikipedia.org/wiki/Condorcet_criterion) ^| [^Reversal ^symmetry](https://en.wikipedia.org/wiki/Reversal_symmetry) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckzwekn) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckzwekn)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
huh?
When i first started with Go, I hated practically every stance it had on syntax and workflow. Little stuff like this drove me nuts, tripped me up, and frustrated me to no end. But after *doing* it for a while, stuff like this turns into the things i like about go. 
If it perhaps wandered into the language specification accidentally in the beginning, I'm sure it was kept deliberately for exactly this.
js shits on you for trailing commas. sql just disallows them entirely. and probably a lot more
And I hate that JSON doesn't allow a trailing comma at the last item of a list. 
The problem is that "optional" means "it's not always there", whereas in go it's required, so it is. I'm sure you can bug your coworkers all day long, and unless it's a compiler error, they'll forget half the time.
Yes. Its pretty good. Not sure what people about.
Yeah man.. I went down a Wikipedia black hole yesterday -- this stuff is incredibly interesting... the more I read, the more sure I am that a single vote winner take all system is just awful. The ability to actually play around with systems is amazing enlightening. It would be fun to create a virtual pool of users with set likes / dislikes (known input) and pipe it through multiple voting systems and see the outcomes. 
That's a toolchain thing. If your team decides on trailing commas, you should use automated formatters to enforce it, just like you should with tabs vs spaces, brackets at the end of ifs, etc. Go takes an interesting approach by forcing it, and it is slightly more convenient, but not everyone is crazy about opinionated tools.
I nearly did, then found out Postgres 9.3 supports queryable JSON fields. 
In Haskell there's a thing where you get around the language disallowing trailing commas by doing let foo = [ 1 , 2 , 3 ] Annoying, but it accomplishes what go's trailing comma does. 
I do see the advantages of the trailing comma, but I love the no-comma-at-all syntax of the imports directive more.
There's no relation. Expressions are separated by a semicolon and values by a comma. Semicolon are optional, that's why import syntax is terminator-free. Commas can't be optional, as you can't have simultaneously two optional terminators.
Looks interesting. But why do you want to do this since spinning up Go routines is so cheap in Go? And, what happens when request 101 that needs another Go routine hits the server?
I don't know if there's a handbook, but there are some common dissatisfactions with C: * Lack of safety (types, bounds checks) * Manual memory management creates huge potential for errors * Concurrency is complex and thus error-prone * The preprocessor is a bad idea (conditional compilation, complexity, etc. etc.) Most of the dissatisfaction with C++ comes from its size and complexity. Furthermore, the fact is that it fixes very little about C. C++'s type system is much improved, and RAII/shared pointers can help with manual memory management, but the preprocessor is still a big part of C++, and concurrency remains complex. OOP, C++'s main contribution, is essentially syntactic sugar (the improved type system notwithstanding), and is falling out of favor these days anyway. When you consider that the huge heft of C++ (compared to C) only "solves" one of the problems, you start to understand why people have been looking for C++ alternatives for decades. That said, don't hate C! C is a wonderful language and if/when it falls out of the mainstream, I will mourn its loss.
It just wait. The problem is that every time a new request hits the server, Go spawns a new Goroutine and, without this wrapper (or other fixes), that Goroutine starts to process the request and compute the response. Goroutines are cheap, it is true, but the work your server will require probably it is not. This module just imposes a limit to the number of concurrent executions of the handler, not to the number of spawned Goroutines. Imagine for example that 10k concurrent requests hit the server, and imagine that responses are CPU or I/O intensive, you probably would not have 10k Goroutines competing for your resources.
Personally, I would prefer that my webserver not be limited, as there are also endpoints which *aren't* CPU or IO intensive; and those which are should have the work done via RPC, so that the RPC server pool can handle rate limiting if needed, for any given intensive endpoint.
I think it's an interesting idea; but, ideally my webserver just does what it does best, and isn't coupled to the performance of tasks which may be performed on any given external box. This way, each RPC server can set a limit for each endpoint if needed; and the webserver never needs to change if I add 1,2, or n servers to the RPC cluster.
My opinion is the problem is more with relying on the cloud in order to have reproducible builds, less on the tools. If you want to have reproducible builds, you copy and store all the dependencies yourself. I think that by trying to dodge devops efforts in managing dependencies we make this problem harder to solve. In my opinion every larger project that do store copy of its dependencies should be able to be built with external dependencies. (disclaimer: I did not use nor build Camlistore, the following is purely theoretical) For example if I want to use Camlistore's packages altogether with other packages that the Camlistore uses two things must happen: 1) Camlistore should be able to be built with my dependencies (that is any external package it imports must not be imported by the ".../third_party/&lt;external_pkg&gt;" path but rather by the canonical one [*]) 2) I must ensure that Camlistore works with the dependencies provided by me (the devops effort should be on the user, neither on the vendor nor the toolchain) [*] Having those non-canonical imports (".../third_party/&lt;package&gt;") is very tempting, as it allows to build the project with single Go build - but this causes the problem which the proposal is trying to workaround instead of fixing. Camlistore should be built explicitly by GOPATH=&lt;camlistore&gt;/third_party:$GOPATH go build &lt;camlistore&gt; Or if I want to alter its dependencies by: GOPATH=&lt;my deps&gt;:$GOPATH go build &lt;camlistore&gt; I don't see how having "/external/" affecting the search path order would help me avoid devops efforts. Moreover it's backward incompatible change, if I had right now a project that do deliver custom dependencies for Camlistore (tested, with carefuly configured and structured GOPATHs) the introduction of '/external/' will change the way go toolchain works for me (assuming all the projects I rely on start introducing '/external/'s).
your webserver is limited, whether or not you'd like it to be. there are finite resources on a machine, and QoS suffers before 100% utilization which requires limiting resource usage at every stage
Sure, I see your point. In that case this module would just limit the number of connections to the RPC servers. Probably it just doesn't fit in that scenario.
Of course, but I'd prefer not to implement another layer of limits on the machines (for specific requests) being passed the requests from my router/DNS/proxy etc.
I think his brain locked
You're welcome! Would be happy to hear about your experience with pongo2. (pongo2 author here)
So you'd rather allow a stampede of requests choke up and take down your web servers?
When you refer to scrypt as 'encrypting' the plaintext, you really do lose a lot of credibility immediately; the intersection of people who know what scrypt is and those who would trust your simple wrapper after reading that you apparently encrypt using scrypt is tiny. [Scrypt is for key derivation, which is defined as being one way, rather than encryption, which is a two way process.](http://stackoverflow.com/questions/4948322/fundamental-difference-between-hashing-and-encryption-algorithms) Why are you not using crypto/subtle to compare the result? You open users of your package up to timing attacks right there. You are rolling crypto, promoting it, and don't seem to, from your readme and comments, understand the difference between two extremely basic parts of crypto. Please read the stackexchange answer I linked to in the first paragraph. If it seems I'm being especially mean, that's because crypto is something you can only get right once in production.
What the heck is "devops effort"? You keep using that word, I don't think you know what it means. 
This thread has been linked to from elsewhere on reddit. - [/r/programmingcirclejerk] [Idiomatic Generics in Go (web scale!)](http://np.reddit.com/r/programmingcirclejerk/comments/2ib39y/idiomatic_generics_in_go_web_scale/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
Didn't put much thought into the example to show what I was thinking. I fixed it so now maybe you can give an alternate way.
http://play.golang.org/p/QbDVK_gfU6
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Baader-Meinhof phenomenon**](https://en.wikipedia.org/wiki/Baader-Meinhof%20phenomenon): [](#sfw) --- &gt; &gt;__Cognitive biases__ are tendencies to think in certain ways. Cognitive biases can lead to systematic deviations from a standard of [rationality](https://en.wikipedia.org/wiki/Rationality) or good judgment, and are often studied in [psychology](https://en.wikipedia.org/wiki/Psychology) and [behavioral economics](https://en.wikipedia.org/wiki/Behavioral_economics). &gt;Although the reality of these biases is confirmed by [replicable](https://en.wikipedia.org/wiki/Replication_(scientific_method\)) research, there are often controversies about how to classify these biases or how to explain them. Some are effects of information-processing rules (i.e. mental shortcuts), called *[heuristics](https://en.wikipedia.org/wiki/Heuristics)*, that the brain uses to produce decisions or judgments. Such effects are called *[cognitive biases](https://en.wikipedia.org/wiki/Cognitive_bias)*. Biases in judgment or decision-making can also result from [motivation](https://en.wikipedia.org/wiki/Motivation), such as when beliefs are distorted by [wishful thinking](https://en.wikipedia.org/wiki/Wishful_thinking). Some biases have a variety of cognitive ("cold") or motivational ("hot") explanations. Both effects can be present at the same time. &gt;There are also controversies as to whether some of these biases count as truly [irrational](https://en.wikipedia.org/wiki/Irrationality) or whether they result in useful attitudes or behavior. For example, when getting to know others, people tend to ask [leading questions](https://en.wikipedia.org/wiki/Leading_question) which seem biased towards confirming their assumptions about the person. This kind of [confirmation bias](https://en.wikipedia.org/wiki/Confirmation_bias) has been argued to be an example of [social skill](https://en.wikipedia.org/wiki/Social_skills): a way to establish a connection with the other person. &gt; --- ^Interesting: [^List ^of ^cognitive ^biases](https://en.wikipedia.org/wiki/List_of_cognitive_biases) ^| [^Red ^Army ^Faction](https://en.wikipedia.org/wiki/Red_Army_Faction) ^| [^Recency ^illusion](https://en.wikipedia.org/wiki/Recency_illusion) ^| [^The ^Raspberry ^Reich](https://en.wikipedia.org/wiki/The_Raspberry_Reich) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl0ohfx) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl0ohfx)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
There's a mustache package: https://github.com/hoisie/mustache/network
I'd remove the communications from String. Maybe create a type which stores the states of all the nodes, with a Step method, which updates the states using the output channels, and a String method to print it with. Then you wouldn't call String directly, but instead just print the value. Also, you don't need to take the address of a value to call a pointer method on it. Just call the pointer method directly. It takes the address for you. You probably don't need to use `*Nodes`s. Passing around a `Nodes` directly should work just fine. Up to you, though.
I've been trying to write something which is a bit more like twig than pongo2 is (though pongo2 is sort of a halfway house between django templates and jinja2). It is not yet functional, but if you are interested in contributing I'd love some help. http://github.com/jmoiron/jigo 
I love the objectives of **jigo**. I'll take a look at it, play with it, and maybe even contribute to it! Thanks for the share!
Will azul3d work in the future with wayland?
Hi! Developer here. With the `azul3d.org/gfx/window.v2` package we are using GLFW 3 -- which does indeed support Wayland. You *should* be able to build any Azul3D application with `-tags "wayland"`. If you run into any issues [please create an issue](https://github.com/azul3d/issues/issues).
Interesting. It looks like it's still a very early WIP that sort of does what goimports does on save (which is my preference, to be honest). But I'm glad to see that the little functionality this package has so far is somewhat under test. Also, I'm not comfortable with anything editing and overwriting my source files other than `go fmt` which is mature and really understands Go code. I think that anything else should make a temporary file with the modified source instead and leave the original unchanged.
I read this several times and I still don't quite understand what this is doing or why. * What's a self-balancing pool * why do we need one? why do we need a pool at all? * is this problem not solved by a semaphore? func Gate(h http.Handler, n int) http.Handler { ch := make(chan struct{}, n) return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) { ch &lt;- struct{}{} defer func() { &lt;-ch }() // avoid deadlock if the handler panics h.ServeHTTP(rw, req) }) } func GateFunc(h http.HandlerFunc, n int) http.Handler { return Gate(h, n) } 
I agree with what you said and I didn't know about goimports. It's amazing that it made it into the official go.tools repo Perhaps, I could use a TempFile (as you suggested) to `go run` a copy of the target file. Thanks for the great feedback :)
Yup, you're right, I could have used some synonyms instead, as from the writing viewpoint the vocabulary sounds poor. On the other hand it's just comment on reddit, not a blog post ;)
You are not being mean. Many thanks for clarifying that. This is a learning project for me to get into cryptography. So if I stumble, please feel free to correct me ! I will re-word my README. I knew the difference but wasn't aware that saying 'encryption' instead of 'key derivation' would make that much of a difference. Now I know :) And thanks for pointing out crypto/subtle ! I did not know that. All I wanted was a nice wrapper for someone planning to use scrypt for password derivation.
This is just a little helper module to avoid re-implementing things again and again when needed... &gt; What's a self-balancing pool &gt; is this problem not solved by a semaphore? Yes, the implementation has been simplified. &gt; why do we need one? why do we need a pool at all? See [this thread](http://www.reddit.com/r/golang/comments/2ia3bp/go_http_wrapper_for_limited_concurrency_handlers/cl08w8n).
Thanks for the good points on this. Some notes on the choices made (apologies for the text wall, although hopefully this can spur on further discussion): --- I left the channel-based communication to further abuse channels. The whole project is more of a proof-of-concept anyway. There are numerous ways to make the code more efficient by not using channels at all, and I had considered doing that with Out, but I wanted to really lean on channels for sync across the board. --- Regarding the address thing, funny story, but only for instances of funny that involve learning about something perhaps non-intuitive about Go (esp. for those coming from other languages). The original code for that was: for _, node := range(self.nodes) { node.Init() } for index, node := range(self.nodes) { // Computing x/y node.Setup(&amp;self, x, y, initFn(x,y)) } When run, all nodes would deadlock immediately at the first output: NW &lt;- state After much head scratching, I found NW to all be the same, and the passed values to Setup() to all be nil. Why? (SteveMcQuark already knows the answer to this I'm guessing) **range() makes *copies* for its iterating variable**. Now when I stop to think about it, it makes sense that **range []int** would produce **int**s and not **\*int**s, so obviously it would be making copies of Node. Mentally, though, when I put a struct into **range** my brain's first instinct is to think I'll get references through the slice. So the buggy code above would initialize copies of the nodes in the self.nodes slice, and would have zero-nodes in the self.nodes slice by the time it reached Setup (which also had copies of Node). So the code evolved (in an attempt to work out what was going on) from **node.Init()** to **(&amp;node).Init()** to finally **(&amp;self.nodes[index]).Init()**. After all that, I was so happy to not get deadlocks I didn't bother to clean up that **(&amp;self.nodes[index])** bit. It's fixed and on Docker/GitHub now. Is there some method to acquire references instead of copies? [(It turns out that stackoverflow doesn't think so.)](http://stackoverflow.com/questions/15945030/change-values-while-iterating-in-golang) --- Regarding passing *Nodes instead of Nodes. I would have thought that if the struct is larger than the pointer size then it should be a pointer (not that Nodes is large, since it's just two ints and a slice, but still would seem larger). Is the suggestion for copy-based Nodes based on the de-reference cost of the pointer? It'd probably require more timing analysis than I'll probably give this project to determine which is better. Right now, my gut says to stay with the pointer ATM. Might be worth another proof-of-concept down the road though to test out when to use which...
Template sets, cool!
I recently add goimports as a before-save hook in Emacs. It's amazing! I can't believe I survived this long without it.
&gt; I left the channel-based communication to further abuse channels. The whole project is more of a proof-of-concept anyway. There are numerous ways to make the code more efficient by not using channels at all, and I had considered doing that with Out, but I wanted to really lean on channels for sync across the board. I didn't mean to remove the `Out` channels. I meant that having the `String` method advance the state of the computation is surprising. Maybe call it `NextFrameString` or something. &gt; Is there some method to acquire references instead of copies? As far as Go is concerned, the index *is* the "reference", and you "dereference" it by indexing the slice with it. &gt; Regarding passing *Nodes instead of Nodes. I would have thought that if the struct is larger than the pointer size then it should be a pointer (not that Nodes is large, since it's just two ints and a slice, but still would seem larger). Is the suggestion for copy-based Nodes based on the de-reference cost of the pointer? The difference is probably so small as to be irrelevant in this instance. However, I would personally expect copying 5 words to be less expensive than accessing them indirectly. As I said, really not a big deal and more a matter of personal preference.
Saw this on HN this morning. Only managed to skim the article at the moment but it looks good.
Thank you
I imagine most people won't use rust until it hits 1.0
&gt; Although possibly an unintended consequence, this means that when proposing a one line change, it really is a one line change. Unless gofmt needs to realign comments and all.
&gt; I didn't mean to remove the Out channels. I meant that having the String method advance the state of the computation is surprising. Maybe call it NextFrameString or something. Ah. Got it. The first cut didn't have the FPS thing and just printed each frame out (so it was originally fmt.Println(nodes)). The rename probably does make sense though. &gt; As far as Go is concerned, the index is the "reference", and you "dereference" it by indexing the slice with it. Yeah, I kind-of see that in one sense, but in another it's just more boilerplate than would be needed. It would seem (to me anyway) that a common use case would involve referencing each element of the slice, especially if the thing is something a couple of layers deep. But, I can see what you're saying as well and it clearly fits what I know of what the designers intended. &gt; As I said, really not a big deal and more a matter of personal preference. Make sense. Thanks again for the insights. I hope you don't see my replies as argumentative instead of inquisitive (as they were intended to be the latter). :)
Good read, thanks. Offtopic, but the code formatting on your blog or whatever is wonky. [Here is an example](https://i.imgur.com/KsVkj94.png). The first horizontal scrollbar is for some interior content, and the second one for the entire thing including the interiour scrollbar. Makes reading the entirity of the code a bit of nightmare. You need to increase the width of the body, or whatever element, or something. Edit: The indentation of the code in general is all messed up as well.
Looks good, I'd compare it to [beego](http://beego.me/). I'm honestly not sure which I prefer at the moment, so if I were you, I'd look at both.
About documentation is revel unbeatable agains beego.
Have you looked at Go's net/http package - http://golang.org/pkg/net/http/ - along with Javascript MVC framework like Angular.js ? That could be a good option as well. The thought here is to pick and choose the components you want, instead of relying on a bigger framework. 
To develop in revel is much more fast. I've looked at negroni too, its is very tiny.
I'm not sure I understand the relevance of that thread. I was referring to the *self-balancing* pool and a pool in general. The request is already running in its own goroutine, so it wasn't clear why you'd need more. Adding more would just add comminication overhead and complexity with the bookkeeping, if it wasn't necessary. The updated code got rid of the pool (although the documentation still uses that word), so I guess a pool wasn't needed.
Every time one of these questions pops up, the net/http answer is the most upvoted. Consider this before writing it off!
I avoid Revel now. It was the first framework for Go web-dev that I tried (and I enjoyed the familiar patterns initially), but find that it's too reminiscent of the problems I was/am trying to escape from within the Php realm. I'm likely missing the wisdom in the choices being made with Revel's direction, but I've become a fan of the more light-weight and "Go-like" Gin Gonic - http://gin-gonic.github.io/gin/. Alongside Gin, I use Gorm - https://github.com/jinzhu/gorm, and within and without Gin, I use Gorilla for more direct needs - http://www.gorillatoolkit.org/. However, I'm open to thoughts on why any of these are not worthwhile. In regards to using the net/http package alone; A good framework simply replaces code one would likely create anyway. My usage of a framework is flatly dependent on whether or not I will save some time/effort as I'm not interested in recreating available conveniences.
Regular NFS server that would allow cd:ing into a zip file would be kind of nice.
I started with the premise, like you, to use a Framework to create something. Along the way I found several moments when the Framework doesn't allow me to do something or, if I do, it will be in a *hackish* way to do it. A few days ago I started creating something entirely from the ground up using just net/http. It's true what others said: each time someone ask this question here, net/http wins by a huge margin and it's because of that: you can mix and match your components, while using a Framework like Revel will lock you up there: if you find a problem or don't like how something is built, you'll have to spend time modifying the code to work as you wish or, just, create a package from your own mind. Yes, it's true that you can "start" developing faster with the help of a framework. But once you have the grounds of your application, the framework is no longer "useful" because you've already created your ground. You can think the same way by using just net/http. You'll surely spend more time creating the base of your app, but once it's ready, you can gain speed easily.
Most projects will also want a middleware mechanism and a more powerful router. For middleware, check out [Alice](https://github.com/justinas/alice) and [Negroni](https://github.com/codegangsta/negroni) For routers, I've pretty much stuck with [Gorilla mux](https://github.com/gorilla/mux). It comes with all of the features you'd ever need and has URL reversing so you don't need to hard code URLs. Some projects will also want to be able to pass data between middleware and the HTTP handlers, for example if you wanted to associate a user with a request. In those cases, just use [Gorilla context](http://www.gorillatoolkit.org/pkg/context). Then you'll also need CSRF protection, most people are using [nosurf](https://github.com/justinas/nosurf) for that. These packages are all rock solid in my experience and I'd highly recommend this approach over something monolithic.
Here's the writeup: http://blog.golang.org/context It seems to be mainly intended for HTTP requests; I think it makes quite a lot of sense in that, er, context. Using it everywhere you use goroutines seems like overkill, to put it mildly.
What happened to the repository?
That actually makes sense, as the call-path for an HTTP request shouldn't be very deep or long. A well structured web-app should actually have most of it's logic split off into independent libraries / packages, leaving the HTTP part fairly small and primarily concerned with HTTPy stuff.
&gt; Sweet, monit just sent a DMCA takedown notice to @github to remove Inspeqtor. From @mperham, creator of Inspeqtor. [Tweet](https://twitter.com/mperham/status/518796150733033472)
It's not just HTTP. It's RPC; so any code that needs to talk to other servers over the network will pass a context around. It's not as onerous in practice as it sounds.
[Author's tweet](https://twitter.com/mperham/status/518796150733033472) and [the project Inspeqtor](https://github.com/mperham/inspeqtor)
Indentation is still wonky.
Oh yeah, totally forgot to fix the indentation. Should be a bit better now. 
Seems like the creator of Inspeqtor should just release it all under AGPL, then there would be no issue.
Gin Gonic fan here, as I've read, Gin uses a radix tree wich out performs all the other routers.
No, that is not the claim. The claim is that the design was completely copied, making it a derivative work and not merely a program that happens to do something similar. As a derivative work, it would be subject to the original's license. I can not speak to the accuracy of their claim of copying. I can only assure you that your summary is inaccurate. You are free to write a monitoring program. You are not free to directly copy another program in the process. Also, I am not speaking of what ought to be here, I'm speaking of what is. YMMV on the question of "ought".
"influenced by" is very different from "derived from". If Inspeqtor doesn't contain any actual code from Monit (or code translated from it) then this copyright claim is pushing the boundaries of copyright law.
If, as claimed, it was a line-for-line rewrite of Monit, then I think it's totally legitimate to file a DCMA takedown - especially since what they are asking is that the author comply with the license restrictions.
My reading is that they don't claim it was a line for line rewrite. All they say is: &gt; ...is far from a “clean-room” implementation. This is basically a rewrite of Monit in Go... You could interpret that as implying that it was translated line for line, but it doesn't actually say that and I don't think that's what they're claiming. All they're really saying here is that it was rewritten as a functional equivalent, and they think the author had access to the Monit documentation and/or sources. That would be completely ok, copyright-wise. (It wouldn't be ok if it was a line for line translation though)
&gt; It's not as onerous in practice as it sounds. Yeah, and the alternative (for HTTP at least) is what Flask does where you have thread-local request context objects. I'm not saying that's necessarily bad, but my point is that I immediately understand passing a context object around, whereas I don't understand how Flask's thread locals work, and it seems like some implicit magic to me. Plus, I'd assume that makes testing harder, whereas it's very easy to use a mock request object.
The person who filed the claim doesn't understand that the project he sabotaged is not legally a derivative program and as such the Affero public license does not apply.
The claim from Monit is flat out illegal.
&gt;No, that is not the claim. The claim is that the design was completely copied, making it a derivative work and not merely a program that happens to do something similar. The courts won't see it that way. Copyright prohibits unlicensed copies and derivative works, not new programs based on the same ideas. The writer of the DMCA claim confused copyright with patent. 
I don't think it's so clear cut. The GNU folks feel differently: &gt; **What does the GPL say about translating some code to a different programming language?** &gt; &gt; Under copyright law, translation of a work is considered a kind of modification. Therefore, what the GPL says about modified versions applies also to translated versions. [source](http://www.gnu.org/licenses/gpl-faq.html#TranslateCode) 
As a note, that DMCA notice has been [officially retracted](https://github.com/github/dmca/blob/master/2014-10-06-tildeslash-retraction.md).
Well that's a nice *mea culpa*.
Thread local storage also means you can't use multiple threads to service a single request, otherwise you break the thread-local context. In Go, where goroutines are cheap and should be used with abandon, that would be very restrictive.
"First Open Source Golang project" I've seen others.
I love how simple it is to deploy on [dokku](https://github.com/progrium/dokku), which is a wrapped docker used by Digital Ocean.
I wonder if this could be turned into a tool for automatic differentiation
Not sure what OP is trying to say here, this is neither the first open source, nor Mike's first open source, nor the first Go, or Mike's first Go project… confused, misleading title.
I believe he's trying to say it's **the first** open source Go project **to be taken down by DMCA**.
[Monit Source](https://bitbucket.org/tildeslash/monit/src) [Inspeqtor Source](https://github.com/mperham/inspeqtor) I'm having a hard time finding sections similar enough to be considered translations. Even the parse code is clearly not a 1:1 translation (Monit uses a very long yacc based parser. Inspeqtor uses some bnf based parser generator with a much shorter grammar.) I obviously didn't look at all the code, but if Monit wants to make legal threats, they certainly need some harder proof (line by line comparisons are probably most convincing, even if it's just a few sections).
I know what a clean-room rewrite is. The author of Inspeqtor claims to have never seen the Monit code. That's why I used the term.
Yes they do, in numerous places. While they don't talk about all of their uses of it, it appears to be widely used internally. A couple of examples we do know of are [dl.google.com](https://talks.golang.org/2013/oscon-dl.slide#1) and its [use by Youtube](https://github.com/youtube/vitess).
I have thought about writing something similar myself. This looks simple and useful! Just a note the Readme says: "go get github.com/SaidinWoT/timespan/timespan" When it should say: "go get github.com/SaidinWoT/timespan" 
Very nice! Clean API? testcases? Double-yes! Well-done!
Yes they do. I've worked at google (as an intern) and used Go for one of my projects. The Go community is pretty big in Google.
There's a lot of dragons here, but you seem to have dodged most of them. My only suggestion would be for Intersection to return (bool, Span) where the bool indicates whether the arguments intersected at all; it's a bit dangerous and IMHO "non-Go-ic" to return a zero value there and hope the user checks for it. (A `false` here is essentially an error, except that in this case `error` would be total overkill.)
In general once you accepted the idea of tearing into an AST you can pretty much do anything you want. However you'll be taking yet another big step in a direction that Go is not all that interested in going in general. You'd probably be better off using Haskell for that bit and wrapping Go around it if that meets your needs.
Agreed. I don't know what I was thinking there.
Would be in someday, that golang go to replace java?
Doubt it. Android is based on Java and although I would LOVE for the to retool Android to be based on Go, there's just too big a community and I don't see that happening. 
Thanks for catching that! I've corrected it now. I hope this can serve whatever purposes you were considering making one for!
That's an excellent point - I don't have time at this moment, but later this evening I'll be updating it to make use of the (Span, bool) order /u/loganjspears mentioned below. Thanks to both of you! Edit: This has now been updated.
There is a serious problem with the domain of the span. The `time` package's `Before` and `After` methods of `Time` do not return true when the value compared is exactly equal to the time. Therefore, if you have adjacent time spans, with the idea that you cover a larger span with them, you will have holes at some instants that are before the last End and after the first Begin. Specifically, if one span's end is equal to the following span's start, then the border between them will not be in a span. This is bad news. To fix this, you need to be able to tell the span that it is inclusive on either the start or end. edit: you'll basically have to rewrite the functions. You might want different types of spans, or a bool explaining each span's domain, or something else. edit edit: Instead of having gaps there are duplicates because it is inclusive on both sides, which is still a problem. Sorry, I was just looking at the standard lib before and after functions, and noticed that your ContainsTime function treated the start and end the same way.
Hmm.
Thanks for posting that. I'm excited at the prospect but am cautious until I get some hands on with how that actually works in the wild. To the OP point though, java is part of Android and that's not going anywhere.
I would think in the short-run certainly not, there's just too much java out there to easily replace. In the longer run it could be a different story. When starting a new project from scratch, many projects that might have used java are now starting to use go. 
Spans are inclusive. Before and after are false in that case because 10am is not before 10am nor is it after. Being inclusive also means adjacent time spans join properly. 
"Using haskell for that bit" could easily be the majority of the code. Anyway, I'm not expecting anyone to write one anytime soon, but it would be awesome if someone did. I suspect that it would be more robust than adol-c or tapenade given the relative simplicity of Go (easier to tell the difference between pointer reference and array access, numeric conversions are explicit, etc.). 
So use [syslog](http://golang.org/pkg/log/syslog/)? That's what it's there for.
Translating Harry Potter books from English to French doesn't escape the copyright of the original text. Translating Monit to Go can definitely be a derivative work without containing any of the original code verbatim.
Howdy all, I'm Mike, the author of Inspeqtor. Inspeqtor is not a rewrite of Monit. It is not a clone of Monit. It is a totally new project which takes a fresh look at process and service monitoring. Monit happens to be the tool which I used to solve the same problem in the past so parts of Inspeqtor were influenced by Monit, especially the "inq" configuration grammar. This has led some people to think it's a clone but that grammar is merely one small portion of the overall program. So I want to make clear: the code was 100% written by hand by myself over the last few months.
Not very optimistic about it. There was a Go project in GSoC 2014 (escape analysis for gccgo), which failed. 
It represents data flow in the direction of the arrow. For example, in your first case data from do(job) is being sent to the channel
I can understand some confusion. It's represents passing information from one structure to the next. It's not an assignment operator (=) as the value doesn't equal it, it just passes from and to a structure or channel and thus the arrow. I tend to think of it as something similar to popping a value off one queue and pushing into another . Hopefully I haven't set myself up with a bad mental model but that's how I think of it in my head.
seeing that they have spent tons on developing it and put multiple of their best programmers on it what do you think?
This is very subjective.
I disagree while ruby is a complex language you don't need to know it all most of the things are taken care of automatically. Go while it has technically simpler syntax, is often more verbose and requires you do things manually which often adds complexity. Eleanor's slides seem to make the ruby examples overly complicated for what she is trying to achieve.
Based solely on syntax? No, Go has a lot more going for it than that.
Of course Go is worse syntax-wise. You pick Go for speed, simplicity and safety from compilation, it's a compiled language, there's no way it can compare to Ruby when talking about syntax candy.
Who? 
When in doubt, read the [spec](http://golang.org/ref/spec).
He is [MongoDB core developer](http://spf13.com/) and author of [Hugo](https://github.com/spf13/hugo)
Nice project, do you have screenshots or gifs? 
Just wanted to let you know about our new start-up, Documize. It’s open source and built using Go. Here’s the Hacker News announcement: https://news.ycombinator.com/item?id=8426254 Using Go, Gorilla, Negroni, SQLX, Logrus plus AngularJS. We’re the Gold sponsor at dotGo conference (Paris) - come say hi if you are going to be there! 
Where is the source?
Coming soon on github!
Thanks !
Neat :) I hadn’t heard about the gopencils library before. I did however spend last night writing my own client library for the Hacker News API: https://github.com/peterhellberg/hn Edit: Your encodedTime package looks useful
Thanks :) I like gopencils because it cut's down on a lot of boilerplate, like the `NewRequest` and `Do`. Otherwise our libs are really similar, I guess yours was insipred by the `github` or `thesrc` client, too?
Yes, primarily inspired by the sourcegraph client.
To talk about how one might surpass the other, you'd first need to specify by what _standard_. Go doesn't let you override operators... do you consider that an advantage over Ruby or a disadvantage? There's some matters of taste there. And that's just one example. Regardless, Go syntax is unlikely to do any "surpassing" in any direction anyhow... both Go and Ruby syntax are pretty much done. Whatever they are, they are what they are and will be what they are now.
And the first one perpetuates the idea that a SHA256 of a password is a good idea for an encryption scheme. "But it's only a synthetic problem, not real code" Then don't "pretend" it is, in a dangerous way. Use something more obviously bad (like XOR with "dontdothis"). And afaics, this approach even suffers from the "pass the hash" problem: http://en.wikipedia.org/wiki/Pass_the_hash i.e. Anyone seeing the hash can use it themselves as a password. The problem is: "bad security looks like good security" (to a generalist developer). A naive coder will look at this problem and think this is good security. And all the software they design until they learn otherwise will be broken. Hence this challenge is a bad thing.
Hey guys, This will be the handout for my DotGo workshop on Go web development. It's not as comprehensive as I eventually want it to be but I think it is a good start. The book is MIT licensed and I plan on improving it with more content over time. Would love some feedback from you guys! :)
Looks cool! If you don't mind the feedback, I'd recommend redoing the video without the rhyme and music. It cheapens the service. 
Many "script" languages also compile to binary before running. It's an artificial distinction. And C can be run like a script.
Not yet, but coming soon. The examples right now look ugly. It's high on my TODO list though =)
Here you go: http://godoc.org/code.google.com/p/go.net/context?importers
Thanks for the feedback.
Haha, guys she's the girl with funky colored hair from the video.. :)
Nice reference, Max :) :D
Heheh..
I've had a message or two asking for more detail about this, so here's an expansion on the subject. I have to preface my comments with "I am not a security expert". I am a generalist programmer, who is aware of some of the problems we face in this area. There are a couple of intertwined issues here: 1) The authentication system sprinkles "crypto" over the password. What are we protecting against? (Security speak for this is "what is your threat model"). Probably "someone sniffing the network communication and seeing the password". In this case, the answer is simple - use https. That's how you stop somone with readonly access to your network stream seeing your data. Note that if your threat model includes your man-in-the-middle (MITM) being able to *change* your data (e.g. anyone providing you wifi), you also need to be careful about a bunch more stuff. In particular, it's no good submitting your login credentials over https if your login form is served over http, since the active MITM can simply serve a bogus login page which POSTs your data whereever they like. Further, if your threat model includes people who might be able to make up valid https certs for your site (e.g. nation states), then you need to go deeper. People are working on this (google chrome will alert if a "valid but unexpected" cert is presented on google sites - others are working to make this a more general system. See TACK and other efforts: http://tack.io/draft.html) 2) Developers often need to store authentication information serverside. After a user signs up and chooses a password, we need to store something which allows the user to prove that they know the password. The most obvious way to do this is to store the user's password and compare it next time. But lots of general developers by now know this is wrong. (For various reasons, one good one being "people reuse passwords, and if your database is hacked then lots of bad people have nice tuples of (username, email, password) to try on other sites). So they hash it (e.g. with SHA256). If they've done some reading, they might add some salt. This isn't good enough. One of the design constraints on crypto hashes is that they are *fast*. People generally choose lousy passwords. The combination of these two facts means that someone in posession of your SHA256 passwords can brute force them easily (here's one estimate: http://forums.udacity.com/questions/6016855/hashing-passwords-using-sha256-is-not-enough-today which suggest 3 * 10^9 hashes/second). That doesn't take long to find your password with an adaptive dictionary search. The take away message from shouldn't be "sha256 is fast, do something else". It should be "crypto systems are hard and broken cryptosystems look just like good cryptosystems to generalist developers". Use whole cryptosystems (HTTPS/TLS, PGP, BCRYPT) instead of putting your own together with low-level primitives. For an idea of how many problems are in common crypto systems - have a go at these: http://cryptopals.com/ and then realise that a recent browser bug was based on http://cryptopals.com/sets/6/challenges/42/ (https://twitter.com/tqbf/status/514891618458271746).
3:30pm update: we are now seriously considering dropping Martini. Sounds like Oleg was right all along. https://groups.google.com/forum/#!topic/golang-nuts/uuHcEafYxDw
Great expansion, thank you for taking the time.
This is something I have been looking for. I think, so far, you did pretty damn good. EDIT: Though I wish the "dependency" on heroku wasn't there.
From https://twitter.com/francesc/status/519960736408563712 -&gt; blog.golang.org/io2014
Does anybody wish to offer an opinion on our tech stack and/or Martini?
“So out of the box Negroni will provide you with a lot a value without a lot of value or overhead.” I _do_ think you get a lot of value from Negroni :)
Thanks for the references. Just what I needed. 
Option type. Algebraic types. Pattern matching.
approach C++ performance when doing calculations so that Go can be used for scientific purposes
Possibility to dynamically load external Go code. Use case: Make an (Open Source) Minecraft server in Go, give the possibility for the users/devs to make their own mods, also in Go.
Process management like Erlang. 
This is the biggest reason why I'm slightly more excited for Rust than Go to be honest.
List comprehension.
You've all just described some ungodly python/scala/c++ car crash. I think you've missed the point of Go being a _simple_ _small_ language.
A built-in decimal type.
Alternative transports for channels (eg. TCP) Memory mirroring across clusters (master-master) float256 Dynamic linking of external Go code 
I used to work on server emulator for a certain online game that hashed passwords using md5 with constant salt on the client side. People were happy to dump their packet logs *publicly* on a forum to help development because the passwords were "encrypted". I quickly figured out how to log in with the salt and hacked together a script to read a packet dump, log in to the game and read their inventory contents. I ran it on some hundreds of dumps and if I remember correctly the stuff was worth thousands of dollars at the time. That made me realize how big issue it was and boy was it scary as fuck to a kid like me. Soon I wrote a custom packet logger that replaced the username, hash, bank pin and similar stuff with dummy values so people could help with the development without risking their own accounts. Someone else in our group tried to get the victims to change passwords before bringing the issue to public. Later on when I had already left someone made people to manually opt-in to logging certain types of packets that could be used to identify the user such as trades, guild activities and so on. TL;DR: Security is easy... to completely fuck up. And never give away your packet logs.
Better package/dependency version management. I've been spoiled by Java's build tools like Maven, which allow you to specify dependency repositories and versions outside of your source code, so that: 1. You can control which versions of packages your code will be built against. 2. If something moves from code.google.com to github, you only have one file to change. It really bothers me that in golang the repository is sort of hard-coded in the ``import`` statement. 
1. Operator overloading. I'd like to do matrixA + matrixB. 2. Generics just so I don't get to hear about it again. 
Yes, you can test other types of code to see if it works. You can't test security other than by "look for plaintext". Imagine if you shipped the first version of your app code which compiled and ran and never tested it beyond that. That's how good your homebrew crypto is.
Not sure if that'd be possible... perhaps it is still better to use external queues like Rabbit
Agreed that matrices need to happen also. But they can at least be modeled through slice-slices even if that is not optimal. I just wanted to mention a point that does not deal with new features and would still benefit the language immensely.
We should ask "which feature could possibly left out"...
Generics, so people will shut up.
FWIW until then you could provide an interface similar to the `sql` package and make mods register themselves in their `init` function. It requires source (or maybe object files are enough?) and recompilation though.
Just something that makes it possible to create custom containers, may not need full-fledged generics.
1. A notion of ownership / move semantics, similar to what is used in Rust. I think that Go really gets it with its valuation of simplicity, and I think little has to change in its syntax for ownership to be incorporated. Having ownership will further reduce overhead and badly structured code. (And I believe it's analoguous to how we now also advice on certain goroutine management patterns, so it shouldn't be outside of Go's comfort zone.) 2. Continue making goroutines as light, flexible and accessible as possible. The linux kernel improvements about user-level threads in last year's Linux Plumbers Conference sounded very interesting and might be applicable to Go too. (Even though that would mean taking another approach to threading. Maybe we can select runtime behaviour?)
1. I know this may be a bad idea but optional garbage collection. Go does many things correct. Go is a minimal language (even better than C in many regards) and I love that. If GC was optional, I would replace C (and maybe C++ for some uses) with it. 2. Multidimensional Arrays 3. Operator Overloading (but in a good way; not how C++ "weirdly" uses `&lt;&lt;` and `&gt;&gt;`. This may be due to a C background but `cout(a, b, ...)` would have been better than `cout &lt;&lt; a &lt;&lt; b &lt;&lt; ...`). Operator Overloading makes many things very simple to read and use but it can cause problems of overuse or bad-use. My idea: func (m *Matrix) operator+ Matrix { // implementation } P.S. I know loads of people want generics but please, do not add them as it is not needed in the way Go is structured. Generics may seem like an easier approach but in the end, it may not be what you need. 
this. 
Any reference? I couldn't find anything about that in the sql package.
My wishlist: 1. No useless "improvements". Keep the syntax simple and small. 
Could you specify?
Instead of operating overloading, why not operator addition. Say, only new operators on the form {*} or {+} are allowed
&gt; 1. You can control which versions of packages your code will be built against. You can have this now with [Godep](https://github.com/tools/godep), but it's not integrated into the `go` tool. I don't think it does recursive checking, but the end user should be able to set/override this anyway if it were. I totally agree about 2, but [Andrew Gerrand](http://blog.golang.org/io2014) mentioned that it may be on track for 1.4, so it can be done in a backwards compatible way (mostly tooling anyhow).
It's exactly the sort of thing that could be added if 2.0 comes around and a decent proposal has been made. The Go developers aren't against generics, just bad implementations of it.
Oh, so that means you need to compile the main (server) at the same time as the "modules" :-( No quite useful, especially if I want to be able to "send" modules to the clients...
Here's two examples from /u/Ainar-G/ which I don't like: &gt;- Built-in sets. Yes, I know that map[T]struct{} does what I need, but it's a hack and I would like to have easy set operations as in Pascal. - Multidimensional arrays. Again, there is a proposal and an issue on the tracker for that. Both would IMHO be unnecessary extensions of the go-syntax. - Sets are already possible, as he points out himself. "Easy set operations" can be written as a reusable library. - Multidimensional arrays of the form [][]int are already possible, so I assume he means multidimensional arrays ~~with a "width" and "height"~~ with uniform subarray length. These can be made as a one dimensional array and calling the elements with array[width * y + x]. Go was consciously designed with a small syntax and going against that decision would make Go less unique. If you really want a large syntax, you should use another language, like Swift. 
You mean something like reflection? So you could load an external binary library and call methods inside it using reflection.
I saw stubs in the 1.3 code that were commented out - they had semver support written all over them. Hope springs eternal.
Their approaches are vastly different, but their goals are the same - to bring high-level programming features to systems programming. 
This point should not be underestimated. One of the compelling cases for Go is that is easily peer-reviewed by a team with mixed skill levels.
But that's just not true. Rust is a completely safe language that you'd want to implement a browser in. Go is a partially safe language that you'd want to implement a webserver in.
I read that more as dynamic linking. But I have no idea whatsoever...
Like this? https://github.com/docker/libchan
1) Dynamic go or go as a script. Compile strings to go code on the fly from go programs, and interoperate with them. Something like runtime.eval() and runtime.compile() 2) Garbage collector as a service. Use it if you want, if not, authomatic reference counting for objects can be provided.
Heads up, this is unstable and freshly released. It may destructively rewrite your code. Please post issues at https://github.com/sqs/goreturns.
I'm sure the tools will evolve. Java's build tools emerged very gradually after years of people using ``make`` and ``ant`` before things settled down. For now though, Go's tools feel a little clumsy, so it's an area I'd like to see improved.
If you would like to post a question to the panel of speakers at dotGo tomorrow, please use the link above. proptip: If you leave your question here as a comment, that doesn't count.
Personally I hope Go never gets them just to keep the noisy jerks irritated.
It wouldn't be a problem if there's no default function for a particular operator right? For example, there's no function for + or - for struct types (I think, I'm not 100% certain) so it wouldn't hurt as much to have an operator definition for those types. Just the ability to define operator functions for types that don't have any, might be enough. Not that I desperately need them. I'm just thinking of possibilities.
The first remark I agree with but the second I do not. Multidimensional arrays can be good without it be an unnecessary extension. The common way of making a multidimensional array in Go at the moment is this: a := make([][]int, rowSize) for i := range a { a[i] = make([]int, colSize) } // or maintaining it locally a := make([][]int, rowSize) e := make([]int, rowSize * colSize) for i := range a { a[i] = e[i*colSize:(i+1)*colSize] } This is similar to how it is done in C but something like `a := [3][5]int` or even `a := [3, 5]int` is terse and understandable. 
Ever since I saw the gorilla context package, I wondered why a simple Items map[string]interface{} was never added to the http.Request struct to store request related state. +1 for generics e.g. to use a custom context object with an existing router
* parameterized mux in net/http * map[string]interface on http.Request for context
I think the missing generics are a decision to improve compilation performance. 
Right, Rust has a much larger scope than Go. The point is with Go that you wouldn't want to implement particularly large projects that might need to for example, dynamically link. I'd like to see that added in Go 2.0, but there's not much else that I feel is required. I love the simplicity and not having to spend as much time considering lifetimes and classes and overloading etc.
Decouple nullability and pointers with options. I want to be able to specify that the pointer my function returns is either - not optional and does not need to be checked for nullability Or - optional and **must** be checked before use Today, every function that returns a pointer might be nil, so enforcing nil checks isn't really an option.
I should add that even if you're not physically attending the conference, the Q&amp;A session will be filmed and uploaded on YouTube in the next few weeks, so ask away!
Have you seen how `vulcanbundle` works: http://blog.vulcanproxy.com/vulcanbundle/ https://github.com/mailgun/vulcand/tree/master/vulcanbundle It's not dynamic, but it lets you build module/plugins for Vulcan fairly easily. 
Holy smokes; I just read a group thread linked in multidimensional array issue. [This](https://groups.google.com/forum/#!topic/golang-nuts/Q7lwBDPmQh4%5B1-25-false%5D) How people get through life being so abrasive is beyond me. (John Nagle)
People need something to bikeshed over right?
Ups for "so people will shut up"
Want to suggest something? 
Seconded.
I'm fine with just proper gdb support too.
One of the things that helped me make peace with not having generics was observing that all the languages that have them are continually sniping with each other over the details, and there is just as much anger about it. When just discussing Go people are all like "Yeah, generics are just so obvious and obviously necessary" and don't want to get into the details because they are So Obviously Right that they aren't necessary, but get them to start arguing about C++ vs Java vs. C# and suddenly it's not obvious anymore. Without meaning to, they end up proving the Go designer's point about it being rather harder than just handwaving the word "Generics" over the language spec.
Use inter-process communication for your plugin system. Much more secure and possibly better performance-wise.
It isn't, with the exact same semantics. If you loosen the semantics it is, but they aren't really "Channels" anymore. In particular, when a sync channel completes an operation, the sender _knows_ the item has been sent and received by the receiver. In the network world, you can't know whether the receiver has received the item or not. (If you think you can solve that problem, think harder about the hostility of the network. For instance, if the receiver sends an acknowledgment, bear in mind the acknowledgment can be lost, leaving the sender unsure while the recipient received it. No matter how you slice it, somebody's in a state where they aren't quite sure what's happened yet.) On that note, a more dynamic "select" statement would be nice; I often want to select from a set of things and have to bend around not being able to select from a list of channels. I believe "reflect" has one but I could stand to see it built into the language, and not lose performance for using it. Being able to select something other than channels would be nice, too.
&gt; EDIT: I completely forgot one thing. I would really like more seamless C interop. Yes, we have cgo, but it has problems with performance and it's not always possible to create a statically linked binary as with pure Go. Then there is the problem with Go pointer getting into the C space and vice versa causing all kinds of fun time. Having something that would make calls to C code as easy as calls to Go code with no (or fewer) 'buts' would be golden. cgo is already as unintrusive as possible. The reason why it isn't possible for you as an end-user to embed C code without any overhead is that Go uses a custom ABI and does not use the libc by default. C code from the Go project is even compiled with a custom compiler just to get all that stuff right. And all of that is subject to change, which is a good thing as it makes reimplementing Go easier.
[Not gonna happen](http://www.jerf.org/iri/post/2930#no_async_exceptions). Or at least not without a crapload more changes that would leave Go 2.0 unrecognizable from Go 1.0.
I'm a noob. How is the inter process communication faster than the intra process communication?
That guy looks like a jerk who wants others to do 200% of the work for him. He's too lazy to open an issue. I bet he's one of the guys who hops from language to language trying to push his features in and then he vanishes, never to be seen again.
No way for 1. Just not a good fit for the language.
The communication itself is a bit slower but since the plugin is a process on its own, it can run in parallel with the main application. Also, plugin crashes cannot cause the main application to crash.
I don't think anyone is confused by "go-" prefixes.
New
I would prefer if they wouldn't implement any features that made the language significantly more complicated. I would also like if they removed some of the warts from the standard library, like having symbols that follow the naming convention of Unix instead of Go's.
Qt-like GUI toolkit...
what are you missing with gdb?
You mean, just like a function? Tell me how matrix1.multiply(matrix2) is easier to understand than say: matrix1 {*} matrix2
Gdb cannot display the local variables correctly. Makes it essentially useless. No fix is expected. See: https://code.google.com/p/go/issues/detail?id=8256 
Exception handling. Having to always check the return type of a function call is tedious. It would be much more convenient if specific exceptions could be registered and when an specific exception is thrown, the code to handle that exception could do so. Exception handling has always been top of my wish list for Golang. 
Team walkbase will be representing :) https://twitter.com/njern (that's me!) and https://twitter.com/bjornsjolund 
Also, naked returns.
Should they ever shut up? Is any language perfect?
You are aware that "Go 2.0" means "never", right? Really, who wants another python 3000 schism?
I agree with @usernameliteral. Edit: i removed the prefix since it's not a Go convention https://github.com/lafikl/fluent/issues/3#issuecomment-58557889
That's true. To do that, there necessarily has to be some sort of a VM and that would drive a knife through the heart of one of Go's best selling points - compilation to native binary without any dependency.. The article you've linked to was quite a good read. Thanks.
My #1 hope for Go 2.0 is that they don't worry about source code compatibility from 1.x too much. Soft deprecating functions or even just leaving useless old stuff is a big reason why most modern languages suck. Go 1.x will still compile Go 1.x programs, if there are better ways to do things in 2.x let's just have those instead.
Read it already in the plane to Paris. Its a good start for sure ! It seems to me that the Controller chapter could have some more info. I do not thing the code like that will provide something functional ? But I am not very familiar with the concept. Furthermore I think 'the world' is moving towards Docker now, so it should be included as well ? Anyway: see you Saturday ! O, and are you in Paris NOW as well ?! If you like you can email my at greulen at planet dot nl 
While true, there are different reasons for that situation. Java and C++ got generics very late in their development, and Java's implementation is intentionally hobbled by language limitations related to type erasure and boxing, problems that could probably not be solved without breaking backwards compatibility. Bolting generics onto any old language is not a great. It works best with languages where generics dovetail organically with core concepts. Standard ML invented generics, as far as I know, and in ML-derived languages such as Haskell, OCaml and F#, generics feels like a first-class citizen that doesn't compete with other language concepts. So far, I haven't seen anyone bicker about Rust's generics, either, although it's entirely possible to argue that its syntax is a lot more complex and complicated than Go's due to generics — something which isn't true about Haskell, for example. Generics is one of those things that flavour a language from the ground up: Once you have generics, it gives you a whole new perspective on how to arrange a standard library. As it stands, I feel like classical generics, akin to what Swift has implemented, is probably too late and would go against the grain of the simplicity that Go has established. Once you have generics, you open up the landscape to all sorts of things that inherently complicate a language: GADTs, traits, class constraints, etc., and of course anything that involves a type must support generics: Structs, interfaces, functions, type aliases. It's something of a can of worms. 
I'd like any trailing return arguments to silently be ignored, if not assigned to anything: val, ok := Find(whatever) val := Find(whatever) Also, map and filter functions for maps and slices, as well as index functions/methods to slices. Finally, a proper way to compare structs, even if they have slice members
The lack of generics or *some* kind of custom container is why I don't use Go anymore. :/
lldb would be great since gdb no longer ships with OS X/Xcode
Native C++ support in CGO so we wouldn't have to use swig.
This, 100% this.
I would love a repl
You can get gdb through [Homebrew](http://brew.sh/) if you want it but I find lldb to be much better than gdb when I use clang.
Just a correction, you mean to request multidimensional slices. You can make multidimensional arrays in go with [m][n]T. These have fixed sizes, like arrays have fixed sizes. Slices have dynamic sizes, and so it's a multidimensional slice you want.
For what purpose do you need float256 for?
I've never had that problem myself. Homebrew is like a godsend for me as installing libraries and tools are so easy.
I don't believe there have been any serious proposals.
It might have been because it was a brand new Mac and I hadn't yet turned Gatekeeper off, but yeah Homebrew is amazing. If you haven't, toss this in your crontab: `@daily /usr/local/bin/brew update`
Because Python 3.0 was such a great success?
THANK YOU!!!!!!!!!!!!!!!!!!!!!!!! Why did I not think of this early!
I've wondered why they don't suggest it :) Pipe that to /dev/null (or elsewhere) if you don't want mail notifications too.
I don't think there are enough packages that are popular and ubiquitous enough that backwards incompatibility would drag adoption, at least not as much as with Python.
I don't even think bleeding edge linux distributions like Arch, Gentoo, or (to a lesser extent) Fedora recommend doing that. It's just a recipe for pain if you're developing against libraries that change versions each time you go to bed.
Do you have any examples of why? I'm quite curious. My first thought was that, given the availability of a stack, the fact that pointers are available and in the open, the availibility of escape analysis for stack vs. heap, etc. That there was quite some focus on these sort of aspects. Escape analysis could determine whether to copy the data or "move" it. I figured it could be quite a natural fit with the language's existing features. But, as I've said, I'm quite curious on why you think it shouldn't.
* A better http mux, maybe taken from gorilla mux. * Better logging support (glog is really under-documented if you don't come from c++) * Better flags support (plan9 flags are a bit outdated :)) 
This updates the formula list, it doesn't upgrade any packages.
It's this guy: https://en.wikipedia.org/wiki/User:Nagle Pretty impressive pedigree, actually.
I expect (and hope) that Go 2.0 will mostly be a clean up release. It will be a good opportunity to fix some (small) mistakes in the language and standard library. For example, there has been some mistakes in the API of some packages spotted in golang-dev (sorry, I don't remember any one from the top of my head). It would also be nice to reduce the number of ways to declare variables and make something with strings and bytes (Brad Fitzpatrick will probably have some interesting ideas about this). Of course, there will be some new feature too. Personally, I would like to have improved support to use Go in scientific computing (for example, with multidimensional arrays), but I would not bet my money.
&gt; "Easy set operations" can be written as a reusable library. Not with type-safety. You either need generics or you need a lot of built-in types like queues, stacks, sets, etc. Go has neither. The other day I had to look up how to best open-code a type-safe stack using slices. In 2014 I should take for granted that I can do push() and pop().
An example of a switch using type assertion, straight from a 2013 talk *Go Best Practices*: switch x := v.(type) { case string: w.Write(int32(len(x))) w.Write([]byte(x)) case int: w.Write(int64(x)) default: w.err = binary.Write(&amp;w.buf, binary.LittleEndian, v) } https://talks.golang.org/2013/bestpractices.slide#9
Damn it, you're right. I didn't think of that. 
Fallthrough. Edit: And I'm not the only one who doesn't like it. From a 2014 GopherCon panel session: &gt; Q: What is your least favorite Go keyword? &gt; &gt; A from Rob: fallthrough &gt; &gt; A from Brad: fallthrough
What about renaming it from the unsearchable Go to "GoTo" ;) ?
Optional named arguments like in Python. Or at least C++ style ones.
Another option is to use a scripting language like Lua for plugins. Less overhead than separate processes, without losing any potential for plugins to be portable between Minecraft implementations.
Go does not need this feature because it has a garbage collector. You don't need to track allocations and thus don't need to track allocations explicitly. The compiler can do that for you and it already does a pretty good job at it. The reason why I think that it is not a good fit for the language is that Go tries very hard to be simple. There is no `const`, no complex typing, no inheritance, etc. etc. An ownership tracking system is highly complex and either useless (if you don't use it in the standard library) or a lot of extra burden for users who don't need it (if the standard library does use it). In this case, Go is a counterdesign to Rust: Less complexity, less speed but easier to learn and master, and enabling more rapid development.
Maybe you already know, but CGO will build C++ code, but you must interface with it over a C API. I prefer that over swig.
Detailed signal processing
What's wrong with Python3? Besides a bunch of lazy code monkeys that are too lazy to update their code?
I’ll be there. https://twitter.com/peterhellberg
&gt; d = bI * a * v This looks like it's just multiplying 3 numbers, and assigning it to a value. At most this would be some quick register swapping and copying 4 bytes for an int64. But you're actually doing vector multiplication, so it's possible that one little line might actually be doing a million multiplications and copying the resulting 4 million bytes of values to a new vector. That's a big deal. And it's totally hidden behind that little operator overloading.
Thanks! I haven't had much reason to work with interface{}'s yet, as most of my code can be written just with static types, but this really helped explain how it works!
I usually search for go stuff with "golang". I've always gotten the result I wanted.
Faster than this? https://github.com/mynameisfiber/gohll
No. Fallthrough is an advantage over C. No more forgotten `break`s.
http://golang.org/pkg/math/big/#Int.SetString The description of that method includes a pretty good explanation of how it's supposed to work in that package.
This isn't functionally different from a `void` type. Or if you're from a managed background - the Object class. EDIT: sorry, missed an asterisk. I meant void pointer.
In reality, I realize that the go team will never implement any of these good ideas. Not to say that go isn't full of great stuff, but my biggest beef is that go is unsuitable for functional programming. It's a shame it's an imperative lang uage with an odd, half-complete type system. Still, it has the best out of the box tools and absolute best concurrency model. It's the only language where I've written a multithreaded concurrent program that worked perfectly after compilation. In the end go is really here to replace ruby and python (python for webservers only....). And that's at least an improvement.
We've decided to drop Martini from our tech stack and stick with pure Go and net/http. :)
No Generics. Keep things simple.
SetBytes would be preferable, if you can use it.
Honestly, I'd prefer a library for this. Though a standard gui interface (like the db interface) might be interesting. I am not sure the various gui toolkits are interchangeable enough for that to be feasible, though. 
Why not map[string]string? It's all text in the protocol. Attempting to parse numbers, times, etc. is an opportunity for something to fail.
Jumped into Go a few weeks ago - would love some feedback / code review.
I actually like this compile error. You shouldn't just be able to change the input or output of a function without checking to see what callers you're affecting. Would you also want additional input parameters to be ignored (like javascript)?
I think you missed his point that he isn't for overloading operators. He's for allowing a syntax for writing new *clearly marked* operators. "a * b" would always be standard multipication. "a {*} b" or even "a {mmult} b" would be some user-defined operator. I'm not saying i think the language needs this, but your worry wouldn't be an issue.
I thougt it was more of a void * type
well, not yet. Do I need to learn QML right?
If [this proposal](https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/preview?sle=true) goes through, then I think you could write the code to a file, compile it, link it in, and then call it. Even better, you could write a neat little library to do all that for you. It would require on the go compiler to be installed on the machine that your code was running on, but otherwise, it would do basically what you want.
I'll be there. http://twitter.com/sqs If anyone wants to help me and a couple other volunteers liveblog dotGo at http://dotgo.sourcegraph.com (similar to how we did at http://gophercon.sourcegraph.com), let me know. Email me at sqs@sourcegraph.com or contact me at @sqs soon.
Oops ignore that last reply, the benchmarks require some changes to my implementation, to set a max limit for sparse representation instead of computing it on the fly.
Yeah, but it's pretty easy to pick up. If you've ever used json and javascript, it feels pretty familiar.
I'll be presenting the State Of The Gopher. https://twitter.com/bradfitz 
I just use JSON with Python, like this: import json d = {"hello": "world", "data": 19827} json_data = json.dumps(d) So, that's basically my problem with QML :) #NeedToLearnItFirst
I haven't taken a look at any of the actual code yet, but one file per test isn't the way to go. Tests that relate to each other should probably go in one file. Since you have such few tests, you could probably just create one gophernews_test.go file.
If you haven't read it, http://research.swtch.com/interfaces
*This, so much*. I truly hope that Go 2 will be simpler, or as simple as Go is today.
I'd suggest taking a look at this "style guide": https://code.google.com/p/go-wiki/wiki/CodeReviewComments I would try to use less indentation, for example I see a few occurrences of if condition { .... return something } else { return otherThing } This can just be: if condition { ... return something } return otherThing (for example here: https://github.com/caser/gophernews/blob/master/gophernews.go#L105) Another thing you might like to do is name the variables in the return arguments so that you don't need to instantiate empty ones. In that same function, if you name the return args (s Story, err error) then you can: return s, err instead of: return Story{}, err Should result in a few less LOC. Otherwise it looks pretty good to me. I've seen worse for beginners :P. Welcome to Gopherland. 
- better standard log package - stack traces in error - remove var syntax - fix nil comparison on interfaces - reduce variable shadowing - split http client and server in net/http - byte view as the preferred standard - ability to _view_ panics about to take the process down - debugger - go get vendoring tooling - comma ok channel sends to identify failed sends rather than panic - required struct fields (non zero, possibly smaller subset of non nullable types) - ability for c to call into a go library
Welcome, some thoughts: * let the user supply a *http.Client if they wish * use Decode instead of ReadAll and Unmarshal * when you know there is an error just return nil, err instead of Struct{}, err See [peterhellberg/hn](http://godoc.org/github.com/peterhellberg/hn) for a more idiomatic approach. 
&gt; remove var syntax And instead of it use... what? How are you going to declare variables of an interface type?
Generics so that angry bloggers would have one less thing to be angry about. 
Yeah, would probably just be easier to bind to lua or something.
I really wondering, if go will replace java in web application? 
Nice to see new content about Golang. Like language too. :)
It depends on how much you hate yourself, I guess.
&gt; * In addition to built-in sets, Pascal's set types (and Ada's range types) would be great. This is a lot like const with iota except that the compiler would be able to catch silly things like var w Weekday = May. The compiler can already do that. Just use typed constants: const ( Monday Weekday = iota Tuesday Wednesday // ... ) 
&gt; float256 Since most machines do not provide hardware support for a 256-bit float type today, it would probably be a better idea to provide a type `big.Float` in the [big](http://golang.org/pkg/big) package that can be used for floating point computations with configurable precision.
While this looks good on paper, it is really pain in the ass for commercial software because someone has to comb through the code and fix all the breakage. One thing that sets "professional" languages and tools apart from the others is that they care about backwards-compatibility in an anal way. Every breakage costs man-hours for all your users, so better do not break things. That said, Go 2 will be allowed to be backwards incompatible but they should provide scripts for `go fix` to automatically fix breakages coming from code written for Go 1.
&gt; naked returns ?
Well, there are maps, slices, and channels. Lots of data structures.
One example would be that `Seek` is defined in `io`, but the corresponding symbolic constants are in `os` and do not follow the naming conventions of Go.
I must have confused it with something else. Thanks, I'll correct my post.
Fixed that, I was messing with color schemes and forgot to reset it.
I would like if they added the alternative spelling `any` for `interface{}` as the latter appears quite often and the former is just much more obvious.
I think this is the main missing thing from Go. 
I'm not sure what commercial software has to do with anything. If they're sending you a binary, that binary doesn't just stop working. If it's your own source tree, the old Go 1.x compilers don't stop working. You just don't get to use new Go 2.x syntax or features until your program is a Go 2.x program. If you're talking about unmaintained software, I like to think that we've generally moved past the concept of depending on unmaintained software. Having 'go fix' do what it can sounds reasonable to me, but the idea that the anal focus of backwards compatibility at the source level is a feature is awful. We have those languages, they're full of cruft and crap and warnings about how this function was deprecated in 1999 and you should stop using it, but you know they're never going to remove it. C will always have gets(), and that's not a good thing. 
Code doesn't exist in isolation and a lot of (commercial) software exists in the form of libraries. Having paid for a library that doesn't work with Go 2 any more is a real bummer. Also, companies will be reluctant to support both a Go 1 and Go 2 version of their library. Of couse, if you have the source you could patch the library for Go 2 on your own, but you have to redo this for every update forever. All of this costs money. Lots of money. All these issues do not pop up if language designers give a shit about backwards-compatibility and proper migration paths.
This is valid syntax: func foo() (baz string, bar int, err error) { // some code return } If you have named return arguments and a naked return statement (a return with no values after it), the compiler will automatically return the named return arguments. This saves on a tiny bit of code, but in the case of longish functions it becomes unclear exactly where the return values are coming from or when they are getting modified. In the end, it's not a big deal either way; I just think it's a feature that could be dropped without really effecting how the language is used. 
Yes, there are some data structures lol. Have you tried adding one? I'd love to do that and keep the type checker, too.
I used to think that being able to do this is exactly the point of having named return variables. Not that I like that feature very much...
Like a switch in a range?
I've written some Go code and for my applications, the builtin data structures where usually enough. For the few cases where they weren't, I coded them like I would do in C. Granted, my programming style is a bit straightforward without too many layers of abstraction (think C code from the 80's), so I didn't have the need for generic data structures yet.
Other than conversions from `void*` having no runtime checking, sure.
Go would need to change core features of the language in order to approach C/C++ speeds. It is not meant to approach bare metal speeds, it has too much safety features for that.
Named returns are nice because they allow code to be self documenting Consider this signature: func SplitEmail(email string) (string, string, bool) vs func SplitEmail(email string) (local string, domain string, ok bool) 
But if the return variable has a name, why do you need to explicitly mention it when returning?
cool just what i was needing to check if a error is an specific type var dst T1Data if err := json.Unmarshal(m.Data, &amp;dst); err != nil { if err, ok := err.(*json.UnmarshalTypeError); ok { if err.Value == "string" &amp;&amp; err.Type == reflect.TypeOf(Message{}) { return dst, nil } } return T1Data{}, err } return dst, nil
Explicit is better than implicit. Sure, it's not a necessity (that's how the language is currently designed), but it could also be designed to require return values. IMO it makes the language more consistent (when you encounter a "return" at the end of a function you know exactly how many variables it returns: zero) and easier to understand. 
Ask the guy who posted http://www.reddit.com/r/golang/comments/2g3nkz/golang_vs_java/ckfb253 – maybe he knows.
You've got a `Part`, an `Item`, and a method for converting an Item to a Part. This is unnecessary, because you can: // I copied and pasted this, no changes type Part struct { By string Id int Parent int Score int Text string Time int } type Item { Deleted string Kids []int // all the rest of the fields Part doesn't have here ... Part } And you'll be surprised at how little code change this takes. Also, run golint on your code. It'll tell you to do a lot of things that will make the godoc of your library more useful. You should then find that most of your README.md file becomes redundant. I mostly give a quick explanation of the motivation of the library in mine, then point to the godoc right away. [This is your godoc view]( http://godoc.org/github.com/caser/gophernews). You should at least move the Usage into there and clean up the rest of the golint suggestions.
You're taking a huge leap. Not working with Go 2 any more? Never worked with Go 2. Works with Go 1, which still works just fine. You may as well be upset that the library doesn't work right with Perl 6. You aren't going to get a better language if one of your requirements is that it can't change. Go has adopted the idea of code compatibility within a major release, and that should be enough.
Nothing at all. He just wanted to make the point that a lot of people stuck with Python 2.x in spite of the release of 3.x. While this is true, it also emphasizes the idea that you aren't throwing away all your Go 1.x code just because 2.x came out, you just have to use the 1.x tools for 1.x code, and if you want the new 2.x features, you have to use 2.x code to get them. Python 3 is relatively popular, and while I'm not personally a fan of it, it's a much better example in support of language changes than against it.
Even more reason for designing Go 2 in a way that old code can be migrated with `go fix`.
Does your server have a root signed CA, or self signed? I know older versions of android had issues with some certs if the signing chain wasn't setup perfectly. 
Also, I second the use of "any" as an allowable way to write "interface{}"
In addition to the other fine suggestions, be sure that your TLS configuration permits a cipher both can use. If you've set your CipherSuites to a sane setting, try toning it back down experimentally. If you got an A- from ssllabs.com, you probably have it set to something sane. Hopefully you can find something safe that Android can still use.
On my birthday! Does that mean I can come in for free?
Reminds me of Rob Pike's post about options. http://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html
I used namecheap.
It rejects the certificate on three different android devices, all pretty new.
Not sure what this means, how would the CipherSuites be configured?
It's more like Object than void pointer, as noted by /u/stackv
Sure. OP noted this was something for "new gophers". I didn't find his post all that effective, so I figured I'd throw out something that might tie it together for anyone who stumbled on this while coming from a different perspective.
Brad Fitzpatrick talked about that at dotgo. I think he's right that even if they add generics people will complain that it's the wrong kind and they don't work as they expected.
 &gt;&gt;&gt; 1 + True 2 
This looks like a nice idea, but why wait for Go 2 with it?
This would be much more intrusive than you think. I don't think the amount of extra complexity needed would be justifiable for a tiny feature like this.
&gt; A thread safe Oracle library, then again isolating all DB operations to a single go routine is an ok work-around. How about locking database accesses inside the DB driver?
Why would you need a special array type for that? There is an array type and I don't see what's stopping compiler vendors from implementing vectorizeable operations on arrays of suitable size with vector instructions.
It appears to be "configuration". I'm pretty sure that's allowed. Especially in example code in a blog post.
Booleans are a subclass of integer in python
[yah, sha256 is not enough](http://i.imgur.com/dXvfKks.png)
* an inarray function. I know why it doesn't exist, but it's code I find boiler plating over and over. * native strtotime library Bah. Can you tell I've come from PHP?
oh sweet! You rock Fatih!
http://golang.org/pkg/crypto/tls/#Config . There's also a ConnectionState() method in that package that you could use to diagnose the TLS connection - it contains details of which of the suites is used, TLS version etc.
This is actually a pretty good tutorial. For deployment, can you add some other options in addition from Heroku?
No, it's a conspiracy to make everyone outside of Google less productive by making generics and matrix operations less ubiquitous in the public.
Awesome feature. vim-go is a fantastic plugin; nice work on it. 
I think it is wrong for a strongly typed language.
It's not the blog author's job to write code for you to copy and paste into your project. Programmers who can't configure a file path are probably more incompetent than the ones who are busy writing examples for others to learn from.
 const ( user = "you" badkey = "/Users/" + you + "/.ssh/id_rsa2" goodkey = "/Users/" + you + "/.ssh/id_rsa" server = "myserver.com::22" ) Not only that, it only works if you're logged into OSX as `you`, and only for connections to `myserver.com`! This code is completely useless for everyone else!
I had the exact problem with an SSL cert from namecheap/COMODO and android devices. Adding intermediate certs resolved the issue.
Locking would work. But was unnecessary in my app. I was loading all the data from serveral tables and when I tried to do it concurrently, I hit that bug. Doing it all serially, seemed preferable to doing it in parallel with locking.
Yes I have extra crt files I ignored, thanks for the info. Guess I'll have to take a deep dive into the crypto/tls package to figure this stuff out?
The user variable is called `user` and not `you`. So it probably won't work on OS X either. In any event, SupersonicSpitfire can use const ( homedir = os.Getenv("HOME") badkey = path.Join(homedir, ".ssh", "id_rsa2") goodkey = path.Join(homedir, ".ssh", "id_rsa") server = "myserver.com::22" )
A: If they depend on each other that much, put them in the same package. B: Factor out the "owning" into a third package that can pull in both. (i.e., like a many-to-many database table.) C: Express the target relationship via an interface that one side or the other happens to implement. In this particular case, A would by far be the preferable choice, but as I assume this was just am example I answered more generically.
Thanks big.. have merged and added a test file, albeit small.. next task.. how to cycle the file ! 
Can I put them in the same package if they are in different folders?
Sorry, was away for a while, and that post above was from my phone. CipherSuites is a list of possible ciphers that the TLS session will accept from the other end. If the server and the client can't agree on one, the connection will fail. I don't know what the default list is if you don't specify one but I wouldn't be surprised that it would fail to include one that Android uses. You could try to add the less secure ones on to see if it works by passing them in from the list of constants that define the suites.
In Go, I believe packages can not span folders. (I'm like 99% on that but not quite ready to be definitive.) Putting them in the same package implies that they are in the same folder.
Thanks for the help, turned out I had to concatenate the COMODO cert files in the correct order into the final pem certificate file.
Every vim-go update is like christmas. I'd still be screwing around with Sublime Text if it wasn't for vim-go. &lt;3
The lack of generics is a dead horse. https://www.google.com/search?q=generics+golang
Thanks, I usually work with dynamic languages (JavaScript, Clojure, Python) and was just looking to confirm my understanding. I'm going to read up on the implementation of C++ templates to fill in my knowledge gaps.
This is an interesting tool. My main suggestion would be to not tie it directly to goimports. It should be trivial to wrap all three together if that's what you want, but as is it seems like it's overstepping it's goals. For example if another tool comes along with similar goals (auto fix simple errors) and it also includes goimports then now users have no choice but to run goimports twice if they want to use both tools. With go:generate possibly on the way I can see this becoming a problem as more and more tools start to transform go code.
'go build' expects all files for a package to be in a single directory. It's common for people to end up with import cycles when they think of Go packages as classes. They aren't, they are more like Ruby gems, Python eggs or npm packages. The net/http package contains ~25k lines of code, it's a single package in a single directory. 
Hi there ! Would you be kind enough to go over my git repo one more time ? https://github.com/agnivade/easy-scrypt I have changed "encryption" to "hash". And used crypto/subtle for comparison. I am actually looking for more places where I can use constantTimeCompare(). In the main DerivePassphrase function, I could not find any such chance. Your thoughts would be most appreciated !
Doesn't that mean it gets very messy without a nice folder structure?
Yes, /u/sqs and I discussed just this at dinner the other day.
I personally use nginx as my TLS endpoint and reverse proxy to my go app. I find it easier to reconfigure nginx when certs change than to modify source and redeploy, but there's nothing wrong with getting to know crypto/tls a bit better either.
Seems that GoRename can't work with single file go programs situated somewhere different than GOPATH: /tmp/main.go for example.
What do you mean by plugin system? Go doesn't have dynamic linking, so you can't load Go code at runtime.
Yep, for now there is no way for `gorename` to suppor that kind of files. Maybe the `-from` flag provides that capability. With `-offset` it's not possible right now.
[Packer](https://github.com/mitchellh/packer), to name one.
Not really. As other folks have said it makes you reconsider your system design. When done properly you avoid cyclic dependency and have well reasoned, clear to follow code. It is important to realise / remember that Go takes a different approach than traditional oo languages such as Java.
it is unsafe because you can get type errors at runtime. And Errors at runtime are considered unsafe
CORS does not apply to WebSocket. With WebSocket, there is an "origin" header, which browser MUST fill with the origin of the HTML containing the JS that opens the WS connection. Non-browser clients may or may not fill that header (and can fill it with anything they like anyway). The WS server then is able to decide whether to accept the connection or not. http://stackoverflow.com/questions/11076658/cross-origin-websockets-with-golang
I am actually doing something very similar. The problem is that the Gorillas websocket upgrader object takes another field `CheckOrigin`. It can be filled like so: var wsUpgrader = websocket.Upgrader{ ReadBufferSize: 1024, WriteBufferSize: 1024, CheckOrigin: func(r *http.Request) bool { return true }, } If CheckOrigin returns false, you will get the error you described. By default, it returns false if the request is cross-origin. [Godoc for websocket.Upgrader](http://godoc.org/github.com/gorilla/websocket#Upgrader)
Thanks for the hints.
He meant that your beloved commercial Go library will not work with Perl 6, just like it won't work with Go 2. If it is commercial, you should upgrade to the one that supports Go 2 or if it is abandoned, then maybe there is a reason for it. Backwards compatibility is seriously stupid.
As somebody at the dotGo conference said: a package should represent one idea. It's both just not right to put every type into a separate package or everything into one package, like a utility package. If there's too much in one package or there are too many packages than you can handle, that's when you do things wrong and you should rethink your code structure.
And the other 99% of the time? I certainly don't have enough experience with ago to understand how to properly factor code into Go pkgs. Most examples I have seen are either "one class one pkg" or "big blob of poorly factored, highly coupled stuff".
This! Thanks for linking to the continue reading aswell! 
If it's not yet developed, why do you advertise it now ? What's the goal ?
Well, it seems like you have never worked on software that comes with expectations of stability.
I've needed an in-memory b-tree for about 3 different projects and I've used github.com/cznic/b for all of them. It's quite a bit faster than github.com/google/btree and also includes a convenient method for generating specialized versions of the library (e.g., keys=[]byte, values=int instead of interface{} everywhere) that you can drop in your project directly as a single file package. I don't have my own benchmarks handy but Tv has this: https://github.com/tv42/benchmark-ordered-map
I did not find any definitive definition of "robust error handling". Exception handling is important for reliable systems. I can not understand how checking for errors every time a function is called could be more reliable than exception handling. To me, exception handling is more reliable than checking for error states since you can minimize the number of times you need to writing code to catch and handle exceptions. I have seen a lot of developers get lazy when checking for error returns, or they will check for errors inconsistently on a called function. Constantly checking for error returns leads to code duplication, inconsistent handling, forgetting to check for errors, silently failing, software maintenance problems.
https://github.com/calmh/gonative
I think you can't seem to grasp that you could still use Go 1.0 and Go 2.0 will be a different thing.
Interfaces are super powerful and a great way to facilitate testing, especially in situations where you interact with another service or system call. The ability to check errors that may be hard to normally trigger is something that can be easy to overlook. Another key point is to keep your interfaces as minimal as you can as this allows for easy testing and easier slide-in replacements. We just did this with a small set of pub-sub calls in one of our newer services that posts data to Kafka. The interface is simply "Publish(key, value []byte) error". I'm not familiar if this is a reddit faux pas (so let me know if it is!); while the meat of this piece is about testing, I wanted to plug SendGrid's library for sending emails in Go. Disclaimer: I'm a dev at SendGrid. https://github.com/sendgrid/sendgrid-go
You can't have a cake and eat the cake at the same time. People like you are the reason other languages suck so much. Go to your Java or whatever, this community doesn't need "backwards compatible" people.
func gzipWriter(path string) (zipOut io.Writer, success bool) { out err := os.Create(path + ".gz") if err == nil { zipOut, err = gzip.NewWriterLevel(out, gzip.BestCompression) success = err == nil } if success { return } glog.Errorln(err) return io.Writer(nil), false }
Please go and enjoy your ever moving platform with the consequently incurring waste of man-hours to fix pointless breakage caused by people who don't understand the concept of stability and compatibility. I don't want that and I am pretty sure I share this vision with the developers of the Go platform.
I would highly recommend refactoring this code completely for a few reasons. 1. The file is not returned, so it cannot be closed, which is a resource leak. 2. The bool return value is unnecessary, since the caller should just check whether the writer is nil. 3. If the calling function is so complex that it can't handle an error being returned, you probably need to rewrite the calling function. Something like the following is idiomatic: func callingFunc(path string, data []byte, useGzip bool) error { if useGzip { path += ".gz" } f, err := os.Create(path) if err != nil { return err } defer f.Close() var w io.Writer = f if useGzip { w, err = gzip.NewWriterLevel(w, gzip.BestCompression) if err != nil { return err } } _, err = w.Write(data) return err }
Pointless breakage? I know you are probably used to people doing pointless breakages, but useful and important one is by no means pointless. Stability and compatibility seems like the leftist zero-growth concept socialists poison nowadays life with. Really dude, just go away.
I went from python to go and haven't gone back. I like writing python, but go does everything I used python for, but it runs faster, has a better standard lib (at least for my command-line-app/webapp purposes), awesome first-class concurrency support, etc. I also found it much easier to read and write, but that might be too subjective. Both languages are fun, I just don't have any practical reasons to use python these days... I only use it for nostalgia.
Is typing really the bottleneck in your development process? Personally, I think Go's up-front error handling is partially attributable to the robustness of go programs compared to java or python programs. The reduced debug time is well worth the extra few keystrokes. 
Or just use [gox](https://github.com/mitchellh/gox).
&gt; you're ignoring the error returned from f.Close() +1. man 2 close: Not checking the return value of close() is a common but nevertheless serious programming error. It is quite possible that errors on a previous write(2) operation are first reported at the final close(). Not checking the return value when closing the file may lead to silent loss of data. This can especially be observed with NFS and with disk quota. 
You're absolutely right. My bad.
Thanks
Thanks
Thanks. I wanted to minimize the number of if's in the function, but it seems there is no way around it.
&gt; the fact that I am proudly voting for the socialist party So I read you correctly. IT really doesn't need you - you have a flaw in reasoning and you proved that with your comments already. Case closed.
not sure if thinly veiled heroku ad...
*plonk*
I don't suppose any of the dotGo talks were recorded. I'd love to the video of this talk (and the others)
Please return the error. The added complexity to the calling function is minimal, and you can make much better error messages for it. With this code, you could get an error message like "open foo/bar.gz: No such file or directory" But the person reading the message may have no idea why the code would be trying to open foo/bar.gz. If you pass the error up to the caller you can make the log much more informative: if err != nil { glog.Errorf("Failed to save financial data at end of transaction: %s", err) } which will give you: &lt;timestamp&gt; ERROR Failed to save financial data at end of transaction: open foo/bar.gz: No such file or directory Which gives the error some much needed context.
You're not really starting a debate with such answer, but I'll reply to clarify my points. 1. There seem to be a real and serious demand from the numerical world to use go. They seem to view Go as a possible replacement for C and C++. That's great. But until it's possible to use Matrix easily, then it's probably not going to happen. C++ gained a lot of power through this community for example. It would be a great strategic move for the popularity of the language to get traction in this space. You can add operator to a Numeric interface for example, and them Matrix could inherit them. That would still avoid the mess created by having operators defined on anything (which can be a mess).
The great problem with operator overloading is that it makes source code much less obvious than it is. Without overloading, people see a `*` and immediately understand that it multiplies something, that it does not cause any side-effects, etc. All of the implications of writing `a * b` are easy to reason about. Now with operator overloading, you loose a lot of this. The function that implements an overloaded operator could cause side effects or does other things the programmer does not realize. All of the sudden `a * b` can no longer be seen as a simple operation but could be a function with thousands of lines of code, all of which have to be understood. My experience with all other languages that allow overloading / creating operators (C++, Haskell) is that regardless of the caveats that come with this feature, people abuse the hell out of them. This begins with the classic abuse of shift operators for IO, continues with people who use operators for other operations than they should represent (I have seen people using `*` for the dot-product in one library, while others used `*` for the cross-product in a different library) and goes to people who think that everything should be an operator. For me, operator overloading has brought minor convenience writing formulæ for matrices but brought huge pain in the 80% of the applications where people abused them or used them incorrectly because they were clueless. I do agree with you that it would be great to be able to do vector and matrix operations in Go with *real* operators instead of functions, but I also strongly believe that overloaded operators are not the solution. I think a better solution would be to: * Add a multi-dimensional array / slice type to the language * Define arithmetic operators on multi-dimensional arrays of integral or floating point types This would probably satisfy all the number-crunching guys while not opening the huge can of worms operator overloading is. &gt; You can add operator to a Numeric interface for example, and them Matrix could inherit them. Go has no inheritance. You could of course implement operator overloading using a built-in interface, so that `a + b` decays to `a.Add(b)`, but this would require considerate rework of the type system because it is not possible to mention the type that implements the interface in the signature of an interface member. Something like this is not possible: type Monoid interface { Add(x ???) ??? } There is no way to mention the type `Add` receives from the interface. Also, this would not stop anybody; you could simply implement that interface for all the functions you need and put stubs in place for the remaining functions. A pretty shitty solution, but that's how people abuse things.
&gt; * native strtotime library What's the problem with [time.Parse](http://golang.org/pkg/time/#Parse)?
&gt; Add a multi-dimensional array / slice type to the language &gt; Define arithmetic operators on multi-dimensional arrays of integral or floating point types Oh yeah, I think that would fit the bill for 99% of where operator overloading is necessary. I agree that operators on anything else than numbers is heretic (sort-of) and is very unlike go. The reason Go may get traction in numerics circle is because it's simple, and quick compilation is also important, so can't lose those things. PS: also, realized go interface via Numeric isn't possible after I wrote it :) 
&gt; Python is still faster to write due to the amount of boilerplate code in Go (especially error handling) &gt; I didn't say typing. And no, typing is not a bottleneck at all. Then what's the time-cost of writing boilerplate if not typing? I get really bored of the "errors vs exceptions" argument. It's such a silly thing to focus on. Once you spend a little time with the language, you quickly learn to read the error handling code and probably appreciate that it: 1. Explicitly tells you what happens to the error. When you see a function call in the code, you can pretty easily tell if there is an error that needs to be handled, and you can see very clearly where it goes. What is so special about errors that they need a special flow control mechanism that hides much of the flow control? 2. Encourages everyone to think about handling their errors at every context (as opposed to deferring the handling at some broader scope). I think this is one reason Go's libraries are more robust than other languages. It doesn't require a team to be disciplined--the right thing is encouraged out of the box. 3. Distinguishes between errors and exceptions. There are a few truly exceptional circumstances for which Go provides panic/recover. Unexpected user input is not one of them. It's odd to group exceptions and errors together and call them all "exceptions" when the majority of cases really aren't exceptional. 4. Simplifies the language; if you can understand return values, you can understand errors. No need to grok exceptions. I can appreciate the "error handling = boilerplate" argument. I don't like writing `if err != nil { return err }` three times in a function, but I can appreciate that it's the lesser of all evils. Most importantly though, it's a very minor criterion in programming language selection (right up there with semicolon-terminated statements). It shouldn't make or break a language for you. &gt; But you can write nasty Go, too. I've seen some awful things done with interface{} Yup. My argument is not that Go prevents bad code. Just that Go's boilerplate is no big deal in the grand scheme. Certainly not a deal breaker. &gt; No holy war there, they're just two tools. It's not a holy war on my end either; I came to Go from Python. It's just that there are almost no things that I find Python does better than Go (I think GUI toolkit support is the only thing I've encountered), and many, many things that Go does better than Python (concurrency, std lib [concurrency, servers, cli tools, etc], type system, ecosystem/tooling, top-to-bottom simple design, performance, etc). I've just had much, much better mileage with Go than with Python. But mileage varies.
Thanks for posting!
I created an extension implementation for [Flotilla](https://github.com/thrisp/flotilla), which semantics aside, is a naive plugin implementation in a web application context.
Sorry about that. In any case, I found &amp; posted [another cuckoo implementation](https://github.com/salviati/cuckoo) in Go which seems to be active &amp; stable.
Why B-tree? It seems ancient - there are better ways like Fractal trees. Why do you introduce old and inefficient stuff to Go?
Wow. So crazy to see this bounce around reddit, twitter, and HN all day. This book was originally intended to be the curriculum for the workshop I gave a couple days ago at Dotgo. Looks like the reception validated the need for this in the community. Next step is to flesh out the examples more and perhaps add a couple chapters.
You should probably include some benchmarks. And I think anyone even remotely interested in this is going to understand that it's going to be slower than a built-in. It would still be nice to have an idea of what we're looking at, though. (And you get to run your own optimization pass over the code before revealing any numbers. :) )
I couldn't find an example of a fractal tree index implemented in Go. Even if implementations exist, I can imagine cases where the added complexity of a fractal tree implementation would not be justified.
They were all recorded and will be posted (not sure when).
&gt; Why do you introduce old and inefficient stuff to Go? That's a real shoddy attitude.
Vagrant! Not perfect, but next to painless. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Cuckoo hashing**](https://en.wikipedia.org/wiki/Cuckoo%20hashing): [](#sfw) --- &gt; &gt;__Cuckoo hashing__ is a scheme in [computer programming](https://en.wikipedia.org/wiki/Computer_programming) for resolving [hash collisions](https://en.wikipedia.org/wiki/Hash_collision) of values of [hash functions](https://en.wikipedia.org/wiki/Hash_function) in a [table](https://en.wikipedia.org/wiki/Hash_table), with [worst-case](https://en.wikipedia.org/wiki/Worst_case_analysis) [constant](https://en.wikipedia.org/wiki/Constant_time) lookup time. The name derives from the behavior of some species of [cuckoo](https://en.wikipedia.org/wiki/Cuckoo), where the cuckoo chick pushes the other eggs or young out of the nest when it hatches; analogously, inserting a new key into a cuckoo hashing table may push an older key to a different location in the table. &gt;==== &gt;[**Image**](https://i.imgur.com/8LlIm3y.png) [^(i)](https://commons.wikimedia.org/wiki/File:Cuckoo.svg) - *Cuckoo hashing example. The arrows show the alternative location of each key. A new item would be inserted in the location of A by moving A to its alternative location, currently occupied by B, and moving B to its alternative location which is currently vacant. Insertion of a new item in the location of H would not succeed: Since H is part of a cycle \(together with W\), the new item would get kicked out again.* --- ^Interesting: [^Hash ^table](https://en.wikipedia.org/wiki/Hash_table) ^| [^Hopscotch ^hashing](https://en.wikipedia.org/wiki/Hopscotch_hashing) ^| [^Tabulation ^hashing](https://en.wikipedia.org/wiki/Tabulation_hashing) ^| [^Hash ^function](https://en.wikipedia.org/wiki/Hash_function) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl8fzi2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl8fzi2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
It's a package by Google, not me. And nobody is introducing anything to the *language* Go. This is just a github package. And surely, B-trees are not outdated. In case you haven't noticed, this is for **in-memory applications**.
Why? You normally use one type of item with B-trees.
I'm impressed! It hits all of the major features people use in Lucene, with the possible exception of near real time search (the wiki doesn't seem to have much info about how the index is structured or how index updates work). But the absence of a pile of configuration options related to merging would seem to indicate that the index doesn't use a Lucene-style log-merge segment structure.
I hate when old stuff keeps creeping in to the Go. B-trees belong to C++ or Java
CSP is a concept from 1976/1978, which is the basis of Channel communication.
Yeah, agreed. I wanted it to be a drop-in replacement for goimports to make it easy to try it out, but long term that'll get really messy. I'm going to contact the maintainers of the various Go editor plugins to see how we can chain multiple tools (goimports, goreturns) together in post-save hooks.
Thanks for the great resource. It's awesome to have a resource that explains web development with golang. I can't wrap my head around one bit: func (c *ViewController) HTML(code int, name string, opts ...render.HTMLOptions) { c.renderer.HTML(c.ResponseWriter, code, name, c.View, opts...) } I don't understand how this could work. Reading the sourcecode of [codegangsta/controller](https://github.com/codegangsta/controller) it looks like controller actions don't accept arguments.
&gt; You're comparing apples and oranges though; that's a B+ tree. Well, kind of. These two libraries fit the same use cases, for the most part, so I think a direct comparison is useful. You'd expect the B+tree to be faster at iteration, which github.com/cznic/b is, by a factor of 5 or more, but you'd expect a B-tree to be faster at random lookups, and github.com/cznic/b is faster at those as well. &gt; I think you do a similar thing with Google's package (replace interfaces with a struct, that implements the interface). I'm not quite sure what this means. There is a btree.Item interface which is satisfied by the elements you insert into the tree. But to do anything with the items, you'll still require a type assertion. For instance, if you wanted to map []bytes to float64s in the tree, you'd do something like this: type MyItem struct { key []byte value float64 } func (it *MyItem) Less(other *MyItem) bool { return bytes.Compare(it.key, other.key) &lt; 0 } tree := btree.New(5) // insert a bunch of items... // Now get the value corresponding to "yellow submarine" if item := tree.Get(&amp;MyItem{key: []byte("yellow submarine")}); item != nil { // You still have to do a type conversion here to get the value out: value := item.(*MyItem).value } **Edit:** Typo
Have people given any meaningful amount of money in return yet?
But it's not "creeping in to the Go." It's a library that you can go get and import like any other. Go implement Fractral trees in Go if you're so enlightened.
It supports targets for now, I'm working on supporting remote templates but I'm trying to come up with a way to minimize abuse (since I'd have to clone the remote template and modify it). However you can do something like `go get generics.pw/t/set/customType:gh:somedude:somerandompkg:U/int` which will import `github.com/somedude/somerandompkg/int` (notice the **U** in the go get url).
Nothing meaningful. But honestly that was not the point. It was kinda just a box that I checked in the GitBook UI. The master scheme is to have books like these become supplements and maybe even help sell the screencasts I'm working on http://screencasts.codegangsta.io/ ;) I like the idea of having the curriculum free and open source for everybody, while still supplementing the work with income from screencasts. People enjoy high quality screencasts and aren't afraid to spend some money on useful ones.
&gt; You'd expect the B+tree to be faster at iteration, which github.com/cznic/b is, but a factor of 5 or more, but you'd expect a B-tree to be faster at random lookups, and github.com/cznic/b is faster at those as well. That sounds to be true for data on spinning disk though, not in-memory data. Did you profile the code? A factor of 5 sounds to be quite serious. Maybe you can submit an issue. &gt; I'm not quite sure what this means. I mean, you can modify the btree package itself such that the code doesn't use interfaces at all (and replace the definition of btree.Item with the struct you want to use).
Most of them are listed under the Go2 tag on the issue tracker: https://code.google.com/p/go/issues/list?q=label:Go2
They're not plan9-style flags, they match Google's C++ flag package: https://code.google.com/p/gflags/
&gt; It's a library that you can go get and import like any other. And why would I do that? &gt; Go implement Fract~~**r**~~al trees in Go if you're so enlightened. FTFY Maybe I will, but now I have a bigger fish to fry
Regarding screencasts, any chance for one on using SDL2 with Go? After that, OpenGL?
Also if you really care about data persistence you have to fsync the file descriptor using Sync(). 
Ah, cool. I know with GoSublime you can just set up a list of commands to run on save, so I have goimports, golint, and govet setup. Not sure about vim and others.
Not sure if its just my experience, but the Topcoder website seems to be a jumbled mess. With multiple was to sign up, which don't seem to be compatible, and several different skinning for the pages, depending on how you arrived at it. Let alone the sign up methods have different password rules, and even when submitting there are multiple ways to submit which have different upload restrictions. It was a fun little challenge i used to learn goji with, but wow that site is frustrating.
&gt; Reading the sourcecode of codegangsta/controller[1] it looks like controller actions don't accept arguments. Yes, and must return an `error`. Something like this will work: http.Handle("/", controller.Action(func(c *ViewController) error { (*ViewController).HTML(c, 200, "index.html") return nil })) http.Handle("/admin", controller.Action(func(c *ViewController) error { (*ViewController).HTML(c, 404, "admin.html") return nil })) 
Posted month ago: http://www.reddit.com/r/golang/comments/2fo82l/bleve_modern_text_indexing_for_go/
&gt; Why would you need to use a constant time compare during key derivation Umm .. to prevent timing attacks wherever possible ? &gt;What is your reasoning for including a sha hash of the derived key? Just a way to maintain the integrity of the content. I looked up some good cryptography practices and I saw that almost everywhere a sha hash was appended at the end. Although I agree this would be most useful when sending/receiving data as there is a higher chance of data corruption. But thought of adding it here too as a safety feature. &gt; Regarding log.Fatalf() Once again you are right ! I had no idea that it was followed by a call to os.Exit(1). I simple thought log.fatalf would write to error stream and log.printf would write to output stream. Coming from a Python background, I thought this was the norm here too. Apparently not.. No worries I will fix that.
A proven solution is absolutely needed in this space. The response to your Martini effort is a pretty good sign of the interest in using GO to create what is now being created using Rails and Django... but without the complexity and magic. | Next step is to flesh out the examples more and perhaps add a couple chapters. To fill this need will take more than that. In particular input from someone who is a Go newbie with some experience using HTML5, CSS3, SQL and JS. The existing examples take a lot for granted in terms of the reader's grasp of Go and the Go way. A newbie perspective would help identify areas where more explanation, or a reference to prerequisite knowledge, needs to be added. 
&gt; "Part of the reason why we don’t care as much about dependency management inside Google is that we don’t use the go tool inside Google." So what do they use?
git, hg
7601, that's high enough. Granting networking permission isn't that big of a deal. Terminating process is.
That chapter is incomplete and doesn't have the full example. I will go ahead and flag it as such for the time being 
Not only is the book helpful, but so are the videos you put up at https://gophercasts.io/lessons . Thanks for all that :) 
http://google-engtools.blogspot.com/2011/08/build-in-cloud-how-build-system-works.html Building Software at Google Scale Tech Talk: http://youtu.be/2qv3fcXW1mg
Inside Google we use a custom build system for all our code. It is massively overcomplicated, and the go tool is something of a reaction to that.
Just some thoughts about how we selected Go for our latest product (as opposed to .NET). That is not to say that .NET is no good -- it's just horses for courses!
I've managed to work a couple small go apps in our shop here. I'm taking over from the inside! :)
I also do not understand why the standard library is not enough when we all know it is. Third-party libraries are only hiding the actual mechanics of Go
go is compiled, so in theory, its faster and use less memory. go is getting faster and faster in each release. go has the easiest deploy ever, its just a single binary ( well, may have assets like images, htmls, etc.. ), don't have any dependency on libraries or vms. go has built in concurrency, im yet to find a language that makes concurrency easier than go, just put "go" in front of a call and its done. channels are also a greate way to share data without locks. the async io is native in go, you dont have to use netty ou check if every library that you use do a blocking io like in eventmachine/tornado or deal of callbacks in nodejs. and the list goes on and on :] hahaha we are a microsoft shop too, im trying to convince my boss to do a new project in go, the developers miss hard visual studio and the debugger &gt;.&gt; stil trying to find a way out
**EDIT:** Looks very interesting, nice job! One question/feature request. Does GoDev support vim-mode? It's hard to go back to mouse-augmented editing once you've enjoyed mouselessness of vim :) Also, a GitHub link?
Nate, I just don't like Java from our dotcom boom-bust days. Remember those days well. It's a personal thing but I reckon Java is bloat for us today. Everyone is different.
Definitely try running LiteIDE as administrator (right click on it in start or search results)
 ...and Emacs mode for us weirdo's out there.
`go install github.com/sirnewton01/godev`
We use GoDev for one of our projects, but it would be awesome if it added support for real-time collaborative editing
I argued all your points until I saw some benchmarks somewhere about Java vs Go. Java is surprisingly fast these days. I'd make the argument that Go doesn't require a virtual machine, which makes it much easier to deploy. A single binary without any system dependencies is pretty awesome. This makes it much easier to containerize and ship to the cloud as well. 
Right, sorry about that. The correct command to install it is this: go get github.com/sirnewton01/godev To update it: go get -u github.com/sirnewton01/godev
I'm curious what sorts of workflows you have in mind. Is it pair-programming, collaborative code reviews or something else that you are looking for?
How hard would it be to add [static analysis](http://golang.org/lib/godoc/analysis/help.html) and [go-oracle](https://docs.google.com/document/d/1SLk36YRjjMgKqe490mSRzOPYEDe0Y_WQNRv-EiFYUyw/view) support ? (maybe like [this](https://atom.io/packages/go-oracle)?) 
This nowadays the only practical reason why I don't choose Java for my personal projects (especially web stuff).
Oh, I'm totally on board with Go over Java for most things. Java is fast once you get the thing going. Go's gonna compile and start up much faster. 
I tried already. And my user IS administrator. Maybe its because I am running LiteIDE as portable application? I mean, its not installed like other apps. But then eclipse would have similar problems... Very strange. Anyway guys, thanks for your help.
I was considering that, but I got a little side tracked. I appreciate the feedback.
More to the point, suffering install issues because of "wrong" version of framework / JAVA_HOME can result in a lost business opportunity. For those of us that ship products to enterprises, I am sure you have heard at least once "yeah, I couldn't get their stuff installed". Seen the same on .NET frameworks (although ASP.NET vNext looks to have resolved this issue).
I am *not* familiar with v8.go, but just as an idea, have you already tried console.log(\"bar.y\")?
pair-programming often a colleague will ask me to come by for some questions. if i could "log on" to his session and work on his code while i'm explaining things this would speed things up immensely. (some are on macs, linux... and there are freelancers who come and go: i'm not looking for a lower-level (to take over their entire desktop) solution, which i'd find too intrusive anyways.)
'bar.y' in javascript, since it's often embedded in HTML (or embeds HTML), which mandates double-quotes (like go), single quotes are preferred. /pedant
I'm currently using mux/context with this, along with helper functions to do cast (think GetLocale(http.Request) Locale). It works fine. "data that is needed by middleware to service a request", is not part of a request. (passing context using Dynamic Scoping would be sweet though)
&gt; go has the easiest deploy ever, its just a single binary ( well, may have assets like images, htmls, etc.. ), don't have any dependency on libraries or vms. It is getting easier these days to bake those into the final Go executable too.
broken link to Quora in the article...s/b https://www.quora.com/Why-does-Go-seem-to-be-the-most-heavily-criticised-among-the-newer-programming-languages?share=1
That's correct with regard to camlistore. I too am using the "myproject/third-party/github.com/gorilla/mux" import path (as well as rewriting the import paths in gorilla/mux). And it absolutely picks up the correct version. Where I'm being lazy is that I'm allow "goimports" (via vim-go) to write the imports for me. And goimports is not finding the "correct" import path I would expect it to. It's hard to draw it out in a tiny text box...but let me try... Given the following GOPATH GOPATH=~/go/projects:~/go/common ~/go/projects/src | - my-project | - main.go | - third-party | - github.com | - gorilla | - mux ~/go/common/src | - github.com | - gorilla | mux In main.go, I do "mux.NewRouter()". When I run goimports on main.go, it pulls in "github.com/gorilla/mux" and not "my-project/third-party/github.com/gorilla/mux" even though the latter is in GOPATH first. This make sense? edit: fixed formatting edit2: More text.
Just tangentially related, but if you use cgo on Windows, particularly with C++, this issue may be important to you: https://code.google.com/p/go/issues/detail?id=4069 
Oops, thanks, I'll fix it.
Inspired? I wasn't using derived in any kind of a strictly technical form.
Why don't you stop expecting others to do *everything* for you and run go test -bench=. ?
Scala and Haskell are ML influenced according to the ML wiki page.
Answer: they don't.
Nate, great post. I really enjoyed your insights. Please keep writing.
&gt;This is the Koolaid-point - where people have started to drink the Koolaid and get fooled into thinking Go is a good language. The post is demeaned by the author's confusion of what "Drinking the Kool-aid" means. It means that someone is fervently in favor of doing something that is considered harmful. It *doesn't* mean that people get frustrated when others disagree. Linking and referencing that post just brings in a load of negative association with feminism, confused usage of the "drinking the kool-aid", and it dilutes the point of the post. People say Go developers have drunk the kool aid, but only because they don't understand that Go alleviates a lot of problems that more obese languages suffer from. They don't hate Go purely because other people like Go, they hate it because they tried working with it and couldn't wrap their head around its design principles - which are derived from native code and pragmatism, not from managed languages and syntax sugar.
I would advise being extremely skeptical of any line of reasoning that results in "they disagree with me because they are using emotion instead of logic, rather than because they have any valid points". Generally, any attempt to psychoanalyse someone you disagree with will result in coming up with some reason why their arguments are worthless without regard to the actual correctness of their arguments. Most people who use one language a lot and like it will tend to take that into their identity to a greater or lesser extent. This is not rare, nor does it mean that their arguments are wrong. A much better way to find out why someone (in particular! Different people are different!) would be to just ask. Obviously, you'll just get the surface stuff initially, but with a bit of back and forth you can find the point where you first disagree -- which is usually a matter of which tradeoffs you are willing to make.
&gt; The most vocal Go detractors are those developers who write in ML-derived languages (Haskell, Rust, Scala, et al) [citation needed] I can't much speak for Rust or Scala, but I do dabble in the Haskell community, and in the Haskell community Go is simply not discussed, in much the same way that the Go community never discusses Haskell. In this case what I mean is that the languages are _so_ different philosophically that there's hardly any point to even _arguing_... if one is "on" one side or the other the arguments are so obvious as to not be worth reciting.
I don't like Go due to the community that's growing around it. I don't appreciate being told I'm a terrible developer because I like to use frameworks and libraries that make my job easier instead of writing boilerplate. It's the same reason I won't play MOBA video games, the community is toxic.
Whats the ETA on the screencasts? I've been waiting for some time :)
Haha, no. I would like to see generics in Go but that's not been a big point of contention for me (and I've never brought it up as a language failing). I like Go and I like the syntax, I just can't stand some of the people in the IRC channel with their "holier than thou" attitude.
Yeah, that's what drove me to check out rust. I'd originally written off rust due to the constant syntax churn (at this point) but I decided to give it a try when I got sick of the Go IRC channel and I was pleasantly surprised with how nice the people were to noobs. The Go channel seemed to start out that way but got progressively worse over time. Haskell is another of the languages I'd like to learn at some point but I have a huge number of them on the list and that's lower than some of the others (such as Erlang or Elixir).
Append `?share=1` to the end of that link so those of us who refuse to sign up for Quora, but don't yet know this trick, aren't duped by their hiding of community written content.
If it uses Hindley-Milner, it's safe to say it's derived from ML.
Um... How about if you don't visit the IRC channel then? You do realize that 99% of all Go developers (and developers in all other languages as well) never use IRC, right? It seems extremely silly to reject an entire programming language because a few random individuals on IRC are big meanies.
&gt; There is no pattern matching, there’s no borrowing, there’s no pure functional programming, there’s no immutable variables, there’s no option types, there’s no exceptions, there’s no classes, there’s no generics…. there’s a lot Go doesn’t have. &gt; The most vocal Go detractors are those developers who write in ML-derived languages (Haskell, Rust, Scala, et al) who have tied their preferred programming language into their identity. I struggle with this point a little bit. I love pattern matching, options, favoring immutability, and lots of other stuff I've found in Haskell/Scala/Clojure! It's because a) I think it's more enjoyable and makes programming less mentally taxing when you have those features at your disposal and b) because I think those ideas lead to cleaner programs that have less errors and fewer bugs. I guess you could argue that my love of those features leads me to identify with the languages that have them. But I don't think that identifying with them means that I can't think about them rationally, or that go's existence is an insult to my having identified with them. I just think that go not having some of the features I've come to enjoy leads to me to enjoy programming in go a little less. If people are writing great programs in go (and they clearly are), then that's great and I think they should keep doing it. 
No Generics -&gt; "Go is a language stuck in the 70’s." Has a GC -&gt; "Go is a language for blue collar (mediocre) developers." GC is "stop the world" -&gt; "Gophers are ok with working in Java 1.0." I think he did a pretty good job abstracting the arguments against Go.
How does Rust differ from the HM type system?
...Church-sama? Seriously?
Rust uses Hindley-Milner too. It won't infer across functions, because it wants them to be manually annotated for clarity. There are some weird edge cases that it won't infer either (as does Haskell).
I like to talk with other people with the same interests as me and IRC is my preferred way to do it? There are a number of other languages out there that I'd love to learn so if I can't get involved the way I'd like it's no skin off my back to go somewhere else.
I have been arguing with Go detractors for nearly five years now, and I have to say this article doesn't resonate with me at all. Go's detractors come from many backgrounds and have many different arguments. That's to be expected, because Go can't be everything to everyone and doesn't try to be. Sure, some people do make irrational arguments based in emotion, but there are people in the Go community that do this too.
The complaint that Go's garbage collector relegates it to Java 1.0 performance levels is misguided. Java 1.0 was an interpreted langages, the JIT came in later releases. You'll need to find a new catch cry to hang your criticisms from.
It's understandable though.. being Go designed around the concept of "less is more" their community is daily assaulted by hordes of noobs that start up their conversation with: "what? Go doesnt have X??? What is this? Add it NOW or I will leave"... the reaction is usually very defensive and annoyed. I personally experienced that when I discovered the immense cost of calling into C when using Go and went to the Go newsgroup to voice my concerns as a game developer.. it ended up with a bunch of webapp developers trying to teach me my job which is.. frankly.. pathetic and laughable. But I stepped out and understood that they do have to take a lot of crap everyday and that I still love coding in Go. 
I read the link to the so-called "gender issues" post that the article links to, and it was mainly about a woman enduring seven years of violent, explicit, and plausible threats against herself and her family. Could you explain the ironic similarity to that? I'm not getting that part.
This is a small project I've been working lately for fun. Any tips on code style or the program itself would be really welcome!
Impressive response time on the page. Are you using Varnish or nginx to cache the content? Edit: Yes, the listed demo page on Github.
with a title like that, I'm guessing you working for one of Murdoch's newspapers...
&gt; The reason go is successful is because it's good and opinionated about how things should be. &gt; The reason people complain about go is because it's good, and opinionated about how things should be, and not everyone agrees with the guiding principals that are driving it. Hear hear. &gt; The reason go gets a bad rap, is because the go community, including the core developers react badly to such critique. I don't think the core developers are really to blame here.
I've heard about this overhead. Could you link to the mailing list post?
I'd ask you look through your comment history on HN and decide if you're leading by example with how you'd like the golang community to behave. 'The community isn't our fault, we let it be whatever it wants to be' is a convenient abrogation of social responsibility, but the fact is you *are* the leaders of that community, and like it or not *it reflects on you guys, personally* what the community is right now.
No, a read/write URL where you see the cursors of other users editing the document, where they select and what they change. Like Google Documents when multiple people are editing at the same time! http://www.codingmonkeys.de/subethaedit/ does it, but not many other editors solve it in a nice way...
They do have benchmarks now. Seems it's about 1.6x slower than the native map, but it uses 5x less RAM (code seems to be using runtime.MemStats.Alloc to measure that).
It's true there are plenty of languages, but it remains the fact that it's silly to reject an entire language because of the perceived (by *you* — your perception is much different from mine) unfriendliness of a few people on a completely non-essential support channel.
I agree that we should take responsibility for the community, and it's something that I've been working on since I started working with Go nearly 5 years ago. It's hard to get it right. I regularly do look back at my comments on HN and Reddit, being mindful that it's easy to get carried away sometimes. However, looking back on the past 6 months I see myself discussing tradeoffs and more generally correcting the gross misconceptions and FUD that people tend to spread about Go. If there are particular comments you're referring to, I'd like to know. I'm personally very receptive to criticism. 
So it's a blog engine, whereas WordPress is a CMS?
I think one of the most plausible options is [go-bindata](https://github.com/jteeuwen/go-bindata). Works pretty well, but I've found out that it tooks a few more seconds to generate the bundled binary...
I'd say it really depends on the user and their use case. I've personally only used Vertigo as a blog engine, but with a help of a web designer someone could use it as a small and simple CMS. You would trade a lot of the functionality of a fully blown CMS away, but if your site consists of like five different pages, then something like Vertigo might work for you. That being said, Wordpress itself does not draw clean line on the matter either. In fact, their homepage says: &gt; WordPress is web software you can use to create a beautiful website or blog. I'd describe Vertigo much the same, but it is currently more leaned towards the blogging part. Though I wouldn't deny that it couldn't be used for basic homepage. For example, my homepage has an about me page which is not listed as a blog entry because it is unpublished. However, the draft is still public and can be viewed with permalink. One could use this technique to link Home, About us, Contact us and etc to a navigation with HTML. As the posts can still be edited on user control panel, you could then theoretically call Vertigo a content management system. I give you that I did not think the description in README all through in case of Wordpress, but I think that giving the user and idea what the software is is more important. I hope this helps.
Very cool - if you'd like this linked to on the gocql README, feel free to submit a pull request.
Wow. Way to be nasty for no reason. I take back my compliment.
Disclaimer: I don't hate Go, I like some things of it but find it lacking in others. Sorry, but this article is awful and insulting in many levels. It tries to argue that if you criticize Go you are being irrational and you can't have a valid point, as if the language was perfect. It's the worst kind of argument because it forecloses any possibility of discussion. If I think Golang has flaws and it's not as good as it could be, it doesn't have anything to do with the language, it's because it challenges my identity as a programmer, OK... You see, there's a pattern emerging from part of the Golang community which I feel is quite toxic. This kind of argument is one example, but I've also read "Go solves real problems" or "Go is for people who gets sh*t done". It seems that at least part of the Golang community sees the rest of the programming world as living in some kind of Ivory Tower where they have byzantine discussions about inexistent problems and never have to do real work. And Go is the knight in the shining armor that will save us from all those highbrows who don't have a clue about the real world. I'm not interested in discussing the specific merits and flaws of this language compared to other languages, I want to warn that these kinds of arguments are fallacious and make the Golang community look like a a bunch of people too full of themselves, which is exactly the kind of attitude you wanted to fight in the first place. Think about it.
In my experience, I do see a lot of people complaining that go "ignores the last 40 years of programming language research", which is mainly a complaint about parametric polymorphism, non-nullable types, error handling (mainly that it's not very DRY), etc. I also see a lot of complaints about a lack of a good debugger and the refusal of the core team to work on improving dependency management because they are waiting for the "community" to pick a winner. As a application developer, the former complaints are easy to ignore because it's hard for me to grasp out how adding things like parametric polymorphism to a language would really affect my productivity. However, the latter type of complaints about weaknesses in the tooling I often find myself agreeing with. 
My only company with that package is the size inflation for small text assets. Not a real issue, but something to consider. 
I would like to hear your reply to this if any? I have heard this may times also, and I can't come up with a solid response.
I think I didn't make myself very clear. I know that my article doesn't encompass everyone who dislikes go, I just meant that those who are the most vocal opponents of Go, who actively seek out discussions about Go in order to say bad things about it - I suspect it is because they feel threatened by the language. Maybe I'm totally wrong, maybe they're just boring old internet trolls. I don't know.
Maybe lumping Haskell in there was incorrect. I did not mean to pick out any communities in particular. Just that I do see a lot of people complaining that Go forgoes a lot of the programming language improvements that have been developed since C was released, and that by not using them, Go is bad and anyone who uses it should feel bad.
I don't think I am confused about what the Kool-aid point is. However, I might be *wrong* about whether that's the reason people tend to get malicious in their arguments against using Go. The reason I think the kool-aid point is valid is because recently there are more and more arguments against Go that go beyond "no generics, no exceptions" and start being negative for the sake of being negative. Not everyone arguing against Go is doing so from an emotional point of view, and generally the people that aren't, also don't use the same kind of malicious language. And that's fine. You can argue logically that option types or exceptions or generics make a language better. It's when someone starts trying to insult the users of the language that it goes too far. I'm sorry if I didn't make that clear enough in my post.
Go also poses danger to hosting industry or to those Java contractors that do "enterprise class" services and bill per day. With Go you can do a lot in 10% of the time you would otherwise spent on Java and that uses 10% or less of resources. Stories lime switching to Go reduced number of servers from like 20 to just 2, whilst delivering stability and better user experience are not uncommon. A lot of Go projects are "run and forget" whilst Java needs constant baby sitting. Thats why developers who invested in Java for example are trying to ridicule Go because it has huge impact on their earnings.
I can see where you're coming from, but I think your article is condescending to those who have thoughtful technical criticisms of Go. Maybe it's just that "Why Everyone Hates Go" is too inflammatory a title.
These points are also hard to argue against. I like working with Go, but the dependency management issue is particularly bad. It's irritating that 'go get' is put up as a solution, yet it fails on a lot of levels and is basically a toy for running demos and learning the language. The point about language research sounds like a good argument, until you realize that the very same argument is actually a point *for* Go. You don't need every last theoretical construct of the computer science zoo to write high quality software. In fact, I would argue that requiring a deep understanding of how your programming language implements all those things can work against the real-world concern of simply verifying that everyone coded things correctly. Moreover, knowing a language is a world apart from using it correctly; just read on thedailywtf.com for some examples. Go side-steps much of this by providing a handful of useful tools, many of which are tough to get wrong. The rest avails itself to peer-review brilliantly by not being too clever or hiding behavior in obscure syntax. This way, Go lets teams write high-quality code.
Thank you for the clarification
why?
Go and Python are very different. Go is not a natural progression of Python. If anything, Go is an evolution of C.
Yeah, the title was supposed to be tongue in cheek, but I don't think it comes across that way. A better title would be "Why some people are so angry about Go"
I am out in the community, speaking, teaching and discussing Go all the time. From the experiences I have, the post resonated with me. People are often very passionate about the languages they use and can get emotional about them. I have great passion for Go and it shows (I am told). Nate was expressing possible reasons for the behavior and comments he experiences from others. The same behavior and comments I experience. You don't have to agree with him, but I don't believe these thoughts were expressed in a way that was demeaning or condescending. I appreciate the time Nate took to write this post and the conversation that is now taking place. This is a great time for everyone to reflect on their own behavior and find ways to improve.
This should really be used for http clients as well as servers. The setup is essentially the same. tlsconf := &amp;tls.Config{MinVersion: tls.VersionTLS10} tr := &amp;http.Transport{tlsconf} client := &amp;http.Client{Transport: tr} The configuration of TLS can be moved inside the creation of the Transport but I separated them for clarity and to match the posted example.
Haha, just remind yourself that its still better than JavaScript.
How far were you able to get? I was able to be slightly successful (everything but libc is static) by: - Installing the static libraries for c and stdc++ (package manager) - Building zeromq static (I had to manually uninstall kerberos / gssapi devel to prevent it from sneaking in) - Copying out the library (src/.libs/libzmq.a) and includes - editing zmq4.go (forking) and changing the pkg-config line to: \#cgo linux CFLAGS: -I/somewhere/zeromq-static/include \#cgo linux LDFLAGS: -static-libgcc -static-libstdc++ -L/somewhere/zeromq-static/lib -Wl,-Bstatic -lzmq -lstdc++ -lgcc -Wl,-Bdynamic building examples/hw{server,client}.go works and the binaries work. They are only dynamically linked against glibc, but libstdc++ and zmq are static, at least. It complains about PIE when I try to explicitly link libc inside the static portion, but I haven't figured out why yet. 
http://blog.campoy.cat/2014/03/github-and-go-forking-pull-requests-and.html is a good read on how to deal with such issues
... there are a lot of godep (and friends) already out. You found none of them when researching? There are a ton of go deps pinning tools. Maybe your time would be better spent contributing to them rather than building another tool? http://imgs.xkcd.com/comics/standards.png
[Original Source](http://xkcd.com/927/) **Title:** Standards **Title-text:** Fortunately, the charging one has been solved now that we've all standardized on mini-USB. Or is it micro-USB? Shit. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=927#Explanation) **Stats:** This comic has been referenced 916 times, representing 2.4639% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_clanqmw)
If I want to contribute back, it is fairly straightforward. 1. go get the project (go get github.com/otherguy/project) 2. create a github fork of the project 3. under the project $GOPATH/src/github.com/otherguy/project add my fork as a remote: git add remote fork https://github.com/me/projectfork 4. work work, zug zug, commit, commit, git push fork master 5. go on github and create a PR -- no renaming, no duplicate copies of the project on your system, no nonsense. 
godep looks awesome, but if I'm not mistaken, godep (and friends) typically require you to manage a separate dependencies file (instead of just being able to use "go get" itself). If anything, I'd argue that this (and gopkg.in) is using more of the go "standard" than what godep is, since you use "go get" just like you have been all along.
&gt; I don't think I am confused about what the Kool-aid point is [...] The reason I think the kool-aid point is valid is because recently there are more and more arguments against Go that go beyond "no generics, no exceptions" and start being negative for the sake of being negative. That means you're misunderstanding what "drinking the kool-aid" means. As i said above, it's *not* about the popularity of something, it's about doing (and liking) something that's directly harmful to your interests because others are doing it. And it's possible that you picked this up from the author of the post linked in your post, who also didn't seem to know what it was. I can't help but give a link now. http://en.wikipedia.org/wiki/Drinking_the_Kool-Aid
&gt;I'm fiddling with something that extends Interfaces in a useful manner. I'd love to hear more about that when you are ready.
This and only this - it's the only sane way to fork a Go project.
Sorry for the late reply. Thanks, this was exactly what I needed.
The secret is to stick with go get and add a remote. Katrina Owen wrote an excellent article to walk you through the process: https://blog.splice.com/contributing-open-source-git-repositories-go/
The article mentioned there were bug reports from users wanting to `go get github.com/coreos/etcd`. In the end it also states, &gt; `godep` adds some additional complexity for the etcd team. But, the simplicity it presents to regular contributors and users used to `go get` make it worth the additional effort. AFAIK, godep makes the repository incompatible with `go get` (unless compromising on reproducible builds). What simplicity for users used to `go get`, are they referring to here?
Really cool project! Took a look at your blog as well - Saw http://www.juusohaavisto.com/post/talking-twitch-tv Any reason you didn't connect to it via IRC? http://help.twitch.tv/customer/portal/articles/1302780-twitch-irc You can use nick "justinfan21349" and no password to connect just to read messages.
I think that goven is the missing piece you're looking for? It seems to rewrite imports to use vendored packages. Same author as godep so presumably they are complementary.
The website (http://www.juusohaavisto.com/) is offline right now.
goven is basically deprecated in favor of godep. godep save -r rewrites import paths the same way as goven, so that go get still works.
Thanks for the heads up! Although my logs do not show anything, except that the process restarted after someone loading the homepage... Might be a twitch on DO's part as well, seen that a lot lately. I appreciate that you took the time to inform me, anyhow.
Thank you! I haven't been aware of this! I'll definitely replace using Chromium with IRC. I respect your time to write this!
Thanks! I was quite pleased with the snappiness as well, even though Martini is knowingly slower than the standard library. I just feel like that all the contribution libraries made to Martini make everything faster to implement, so I did not want to re-invent the wheel just for few milliseconds off from the HTTP router.
&gt; They don't hate Go purely because other people like Go, they hate it because they tried working with it and couldn't wrap their head around its design principles - which are derived from native code and pragmatism, not from managed languages and syntax sugar. I don't think so. I haven't seen any criticism of go that would imply that it boils down to *not being a managed language*. But what do you mean by *managed*? From what I could find, it could mean anything from having a runtime with things like garbage collection (in which case Go seems like a managed language), to being an implementation with a virtual machine, to being a language that runs under CLR (Windows). In the latter case, I haven't seen languages like C# come up in discussions about the supposed shortcomings of Go. 
Would you say that a language that uses a specific algorithm for garbage collection first used in language X, is *derived from X*?
I think you're still misunderstanding the point of the article I linked to. The people who are so maliciously negative about Go think people who *like* go have drunk the kool aid. They think gophers are harming themselves and others by using a bad language, and they get mad because Google and gophers are convincing people to use Go, this horribly bad language. *update* - I just went back and re-read that section in my article, and I can see how what I wrote could be misinterpreted. The "They" in "they'd drunk the koolaid" was not well defined. I meant "people who like go" had drunk the koolaid, and that's what made the detractors of go so mad.
Oh sorry... stupid reddit indenting always screws me up. Yes, I thought you were replying to me. Never mind. I agree, there's no ironic similarity between the two. 
Honestly, I am not a language snob, so if derived is the wrong word, my apologies. Wikipedia lists ML as an influencer for all these languages, and in my experience, they're generally grouped together as having similar approaches to programming.
godep save -r moves all your dependencies into your repo, and rewrites the import paths of the rest of the files to use the moved paths, so you don't have to reference anything outside the repo. This means that go get still works. The added complexity is that if you want to update a dependency (something likely only to be done by a core contributor), you have you use godep to explode out the dependencies, update the one you want, and then run godep save -r again. Not the end of the world, but non-trivial.
With the exception of file system operations, doesn't network I/O cover the vast majority of potentially blocking operations?
tl;dr: Go is boring and that is good, because simple is good, because KISS.
tl;dr: Troll
I wrote the same article two years ago: http://aerokode.com/blog/go-is-boring
Hmm yeah this is way out of my league I guess. I'm running it inside Docker based on the official golang:1.3.3 image, then I simply tried to run install gccgo and libc6 and then run: go build -compiler gccgo --gccgoflags "-static" which gives me error: undefined reference to 'zmq_strerror' (and all other zmq_* stuff) But if your attempt still dynamically depends on libc, then it can't be run on something like busybox, right? It's so annyoing that if I'm able to build a statically linked go program, the Docker image can be 5-10Mb. Otherwise it'll end up like 200Mb since I typically use debian and have to install ZeroMq... Or do you have any other ideas for a solution to the problem? 
Aliens
Hi, other have already answered you. Pretty much what the others have said. Sometimes we are not in the same geographic location and would like to do some pair-programming while we do a Hangout. Being able to just see and not edit would be nice (if there's a fast way to swap who writes and who watches), but I was asking for something like what Google Docs (or etherpad) does. Btw, thank you for GoDev, it is awesome :)!
I try not to change the article's original title, but I agree they are getting pretty "I started looking at Golang and you won't believe what happend next!"
Go bots
I don't think there's anything wrong with making a title that states a truth, but then explains why it's true in a way that's different than you may originally assume. I think it's different than those "You won't believe what happened next!" titles. The "Go is Boring" style is succinct, and you can usually tell that the person is using hyperbole. The "you won't believe..." titles generally leave you with a cliffhanger right in title and are are pure clickbait with the real punchline hidden from the reader. It's hard to explain, but this style post doesn't bother me, while I expressly avoid the "you won't believe!" articles. Yes, I know I was one of the people writing headlines like this. It's sort of fun to approach an article from a negative perspective and then show how it's actually a positive. Much less boring than just "Go is good, here's why". But I don't think anyone wants to annoy people with their titles.
Godep seems like one of the better solutions. It's easy enough to point people to that. At from DotGo conference, they said they are waiting for one to stand one. Once it has, they will endorse it on their own site (then maybe pull it into core at some point). As for Debugger, Rob and Nigel are working on a prototype debugger right now: https://code.google.com/p/ogle/source/list
One of the most unnecessary articles that I have ever read in my entire life. OP, you owe thirty seconds to me that I wasted to read that.
Go is just C, but with some of the annoying and insecure parts taken out, some decent libraries written by people who are not security-naïve, and a big rocket engine made of concurrency strapped to the back. Oh, and the compiler is faster than butt. Other than those things, Go is no big deal. *(Those things are kind of a big deal.)*
And GC
Well, it's a toss up between that and "16 Ways Haskell is *Exactly* Like Joseph Goebbels"...
I am unsure how to answer this question, it's very hard to quantify such a thing. http://tip.golang.org/src/syscall/syscall_linux.go#L786 All the syscalls without nb (i.e. the sys ones) are potentially blocking. In Windows and Solaris it's worse. In Windows virtually everything can potentially block. How this translates into "a majority" is hard to say. You'd have to actually measure time spent during blocking system calls and compare it to whatever your expectation is (e.g. time spent in networking I/O). 
The sentiment is the same, though.
I can't upvote this up enough! Great pattern and explanation!
Sorry, was feeling particularly cheeky.
The only thing that I have seen so far (and I haven't searched much, to be honest) is [this](https://github.com/jadekler/git-go-websiteskeleton).
Another one is this: https://github.com/elcct/defaultproject It uses goji+gorilla+mgo, pretty good taste I must admit :)
Pretty sure you can fit both in there... I get 240 when combining them with ", And Also ". That's going to be one heck of an article. I'm upvoting it on the title alone.
I was looking for something similar. I thought I couldn't find it because I just had no idea what I was looking for. This caught me off guard: // AppKey should be replaced by applications using gothic. var AppKey = "XDZZYmriq8pJ5k8OKqdDuUFym2e7Im5O1MzdyapfotOnrqQ7ZEdTN9AA7K6aPieC" 
This slide: http://dave.cheney.net/wp-content/uploads/2014/10/Screenshot-from-2014-10-15-033713.png Doesn't the definition of "timeout" and "tls" trap the "srv" variable in a closure, then changing the values of the first server variable when the new server is created?
There is a project called Notejam for web app seeds in different frameworks/languages. You can contribute to it and using their frontend code. Go is still missing there, btw. https://github.com/komarserjio/notejam
Why is this better than a simple bourne shell for loop?
It's fine :)
So, how is this different than godep?
I didn't know that. Thanks.
&gt; type stateFn func(*lexer) stateFn Uh, this is straight from the [Lexical Scanning in Go](https://www.youtube.com/watch?v=HxaD_trXwRE) talk by Rob Pike. A written summary is great, but I think you should at the very least give credit where credit is due.
Very cool idea. My one concern is how obvious the pattern is to the consumer of your package, and how the documentation makes it clear what's an option. For example, in your [documentation](https://godoc.org/github.com/pkg/term) on the term package, you have RawMode, CBreakMode and Speed as options... but the first two are passed in directly to Open, and the last returns the value to pass to Open. This could easily be confusing to someone new to the pattern. My opinion is that you'd be well served by using a named type for the configuration option, so as to make it more clear what's an option and what's not. For example: type Option func(*Term) error func Speed(baud int) Option func RawMode() Option func CBreakMode() Option func Open(name string, options ...Option) (*Term, error) This does add one extra (arguably spurious) set of parentheses in your calling line: t, _ := term.Open("/dev/ttyUSB0", term.Speed(115200), term.RawMode()) However, I think the named type makes the use of the package a lot clearer to the consumer, and (IMO) you have less of a chance of people writing this code: t, _ := term.Open("/dev/ttyUSB0") term.RawMode(t) 
It's minimal/lightweight. You also don't need to prefix `go` commands.
there is a conflict between the crypo/tls package and the unfortunate name I chose for the local variable. 
I find this example a bit silly. As soon as your PR is rejected, you have a legit fork (by its very nature). At that point you have only 1 project yourproject/X (which is a now differentiated fork of originalproject/X)... you do the renames and then you maintain your fork going forward. 
Also `fmt.Fprint(w, "hello")` with `w` is `http.ResponseWriter`
Missing too many features to be practical. How does it skip Down host, use ssh keys, run in parallel, capture output, send scripts, etc. dish or ansible is much easier.. And who doesn't have python installed? Nice simple script though demonstrating how to use the ssh library
&gt;But what do you mean by managed? Managed languages are ones that run in a "managed" environment. E.g., a VM. Java, C#, python, ruby, and JS are all managed languages. Unmanaged languages are run directly by the host OS using an executable, although they may also have runtime library dependencies. Generally, you could say that a managed language requires an interpreter for bytecode or plaintext, whereas unmanaged compiles to a binary in the same fashion as native code. When you see people criticize Go, you almost always hear it from people coming from managed languages, because it distinctly lacks syntax sugar and "me too" features that other languages embrace. People attacking it for assertions, generics, exceptions, etc are under the impression that lacking these things is a sign that it's a much older language that's harder to work with, when really it tries to solve more problems with fewer features, rather than tacking new syntax and features onto a base set of functionality.
If "you can choose between passing by value or passing by reference" is the worst complaint you have about Go, I'll take it.
some relevant work I did a while ago: https://github.com/taylorchu/toki 
The number of comments obsessing over the title is amazing. Fodder for psychological analysis of the Go community. Moving on, the article itself provides an alternate perspective on what makes Go attractive to an experienced developer who has maintained a healthy curiosity about language alternatives. Any Go evangelist will benefit from reading it. Alternate title... An Alternate Perspective on the Go Alternative. 
My first Go application is a web app using [beego](http://beego.me) which was mentioned as an alternative. It's worth noting that **beego** goes way beyond what the OP, or other comments, have mentioned. I hope to have the app hosted and running by the end of the month. I'll also create a git repository with all the code. I have spent at least as much time learning what's available and how to best use beego as I have learning what's available and how to best use Go. I don't mean that in a negative sense, only as a point of information. It sort of falls under the category of "you get what you pay for", where you are paying with a lot of learning time offset by much more time saved in the long run. 
Wow, I expected this to be yet another rant about generics. I consider the inclusion of pointers, but also the presence of garbage collection, to be on the list of Go's positive features. Now let's get back to ranting about generics.
From what I have read from others, and have started to see in writing code, is that frameworks aren't necessary (and by necessary, you can do pretty well with the stdlib + gorilla + some helpers). I am tending to shy away from DI that most frameworks are using since that is part of the benefit of using a statically typed language over dynamic typed. What I was getting at in the post, is that there are a number of web frameworks, but it seems like many people who have worked a lot with Go web apps recommend just using vanilla go with perhaps gorilla. That being said, it would be nice to have a starting point for a project which leads to writing something in this style
I would be fine with spending time learning more, since so far my time spent investing in learning things in the way intended by language authors has mostly paid off. The main thing is having a seed/example which functionally is a minimal app, but which has baked in many things which if you were doing a stdlib + gorilla implementation, you would want to include. For example, have some common middleware and have a decent pattern for routes etc. I know that web frameworks commonly have that, but I haven't had much luck on how to accomplish the same thing with the stdlib. Basically having sane "defaults" for a project that you want to build using stdlib + gorilla.
Not silly at all. Our app is released and we make fixes and enhancements on versions 1.x.x while we work on the next version. It's a problem we face and have clever bash scripts and sed to change imports. When we finish, it will just be our fork. In the meantime, we have to manually swap between the two.
Thats true. I guess I am looking for a head start, but feel that once I get that I can do just fine with the stdlib. I could just do this by trying different things, but I would have to think that someone has done that work. I have looked at the source of some projects, but it can be easy to get lost in large projects and miss some of the ideas about why they structured things a certain way and the patterns used from experience to cleanly abstract and separate code.
It's notable that the creator of Martini has [crossed it off](http://blog.codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/) his own list. It may be that his latest project [Negroni](https://github.com/codegangsta/negroni) could be combined with Gorrilla Mux and other tools put to together a functional starting point. That said, building a secure, functional, commercial quality web site involves way more moving parts that I had imagined. When I see comments indicating that frameworks aren't necessary, I'm always disappointed when there is not a link to a publicly hosted example of such a "built from scratch" site. I'm sure it can be, and has been, done. But I'm pretty sure it involves reinventing wheels that already exist in a framework. Not that that is a bad thing, especially if the code base will be used to build a lot of web sites. 
Beego has pluses and minuses when it comes to idiomatic Go. I've learned a lot about Go by digging through beego source files and source code for the [beego.me](https://github.com/beego/beeweb) site itself. I like the overall structure in terms of package directories and MVC implementation. You will notice stdlib functionality is frequently enhanced by putting a function in a compatible wrapper that adds new attributes and methods. Poking around in this code might give you some ideas on what to include in a much "lighter" starting point for building your own web sites. I dislike some of the naming conventions and the use empty interfaces and reflection to do seemingly magical things deep within the code. Since you see the same sort of thing in Go source code, I guess it is idiomatic though type safety is no longer guaranteed by the compiler. 
While the title of the post may be a sign of our sensationalist times, I think you have misread the body of the post.
pythonista's love the de-structuring nature of tuples x, y, rest = somethingthatreturnsanarray() I don't see much need for them given Go has real multiple returns
Thanks for the advice, I will take a look at Beego/Goji source code since they differ in philosophy on doing interface/reflection (it seems from what I have heard). I don't actually have a huge deal with magic coming from Railsland, but part of the reason I am working on learning to do web apps in Go is to have less of that magic if its not necessary
You mean in the sense that this might just be constructive feedback? In that case maybe I did let the title stop me from being objective. I should note I'm completely biased towards go, ironically I'm posting this wearing my green 70's style gopher tee. Which has had much wear
&gt; `x, y, rest = somethingthatreturnsanarray()` You will not, however, get all the remaining return values in `rest`. If `somethingthatreturnsanarray()` doesn't return exactly three values, you'll get an exception.
&gt; When you see people criticize Go, you almost always hear it from people coming from managed languages, because it distinctly lacks syntax sugar and "me too" features that other languages embrace. Syntax sugar has nothing to do with being managed or not. You might have causations mixed up; it might be that simply man of the modern high level languages are managed, and that they come from high level languages in general. Not that they particularly care about them being managed to begin with. Besides, those who know a little about older programming languages know that things like generics and other high level stuff can be had in unmanaged languages, like ML. From what I've seen, many of the *proponents* of Go are coming from managed languages, like scripting languages like Python and Ruby. 
With godep save -r you don't need to prefix go commands either. It vendors the dependencies and rewrites the import paths to point to the vendored directories.
&gt; For the most part I think Java got that right, apart from the orthogonal &gt; issue of null/nil values and how to handle them, i.e., all object references &gt; are pointers, all scalar types are values, do some auto-boxing, etc. So they got it so right, they want to bring now value types to Java?
But then you couldn't do term.Open("/dev/ttyUSB0", func(t *Term) error { // something something set a timeout or something }) 
So, there's several problems with this approach: 1.) It doesn't work on Windows. 2.) If you forget to unvendor, you're suddenly screwing up the workspace of a different project when you go-get 3.) It requires a manual step (removing the .git directory) 4.) It changes your GOPATH only for that shell, so editor tools won't work right. 
That still works, I just tried it: http://play.golang.org/p/kqR_bNhMAD
Lack of real value types is one of the reasons Java applications are so memory bloated. It's also performance hit having to box and unbox stuff all the time. If you rewrote the title of this post as "Why Go is better than Java", you could almost leave the body untouched and it would still be valid.
meh, that's why I'm a Go programmer, we don't have to worry about exceptions.
&gt; Nice simple script though demonstrating how to use the ssh library that's mainly why I posted it here.
 x, y, *rest = somethingsomethingarray()
Exactly and it's also (part of) the reason you get all these inconsistencies when comparing strings. The fact that Java doesn't have proper values is one of my biggest gripes with the language.
As the writer of the original tweet that started this thread, I'll expand on a couple of points and reply to some of the comments below. I wrote this in response to a colleague's question, 'Q for #CodeNewbie folk: What are some of the words in programming that scare you, or did when you first started learning?' https://twitter.com/pamasaur/status/522753876156760064 I jokingly said C++, then asserted that I didn't like the fact that Go has explicit pointers, in comparison to, say, Java, which does not. By explicit I mean the programmer uses a syntactic construct to indicate the pointer-ness of an entity. I didn't say I don't like Go, and I didn't say I loved Java either; I just consider this to be something that is done better in Java, for a couple of reasons: experience teaching intro C classes where students had a hard time getting their heads around pointers, and the fact that there is a large body of developers out there familiar with the Java model and syntax for objects. In the abstract I'd claim that a language is objectively simpler if it doesn't have to handle both values and pointers to values at the source code level. As noted in the article, I do recognise the importance of optimising memory layout, but the gist of the article is supposed to be that a) in an ideal world the compiler would automatically do the right thing, but b) since that isn't practical, I'd prefer a more focused approach than just pointers as first class language construct.
Although briefly mentioned at the bottom of the article, this is a repackaged version of the excellent (and original...) ["Self-referential functions and the design of options"](http://commandcenter.blogspot.nl/2014/01/self-referential-functions-and-design.html?m=1) post/idea by Rob Pike.
This is correct, I hope that this time around Rob's excellent idea will get more attention.
A couple of comments from the original LinkedIn post, my responses here might help clarify the point I was trying to make: &gt; What specifically do you not like about pointers that you think java improved on, please be specific I think Java improved on C/C++ by removing explicit pointer syntax from the language. The essence of my post is (supposed to be) about syntactic simplicity, while recognising that there are valid reasons to add language features - pointers and structure values, for example - in the service of narrowly focused goals. &gt; Pointers are just values that point to another value's memory address. I don't understand what you mean by "leaking all over the language", apart from agreeing, yes the use of pointer values in Go is pervasive. See below, but pervasiveness is a nicely concise way of characterising what I was trying to get at. &gt; Can you please be more specific, perhaps with a few examples, where Go's value and pointers semantics lead you to an error which Java's reference semantics would have prevented. That wasn't the point I was trying to make, so I don't have examples other than trivial/superficial ones, caught at compile time by the type system, where I tried to pass a Foo instead of a *Foo. Those are annoying, but ultimately not a big deal. It's really more about having to explain/teach when and why to use pointers. Perhaps I can turn the question around, and ask when to use a struct by value rather than a pointer to the struct. Given a hypothetical Java programmer's inclination to always pass structures by reference, how do you decide when to pass by value? What about embedding in other structures, which actually seems the more important case (for memory layout optimisation, since there seems to be general agreement that call by reference isn't that exciting)? Alternatively, if you built Go-- by removing all pointer syntax from Go, and so structures (and other entities) were always passed or embedded by value, what are the places where you would need to add pointer syntax back in? For example, if you do actually want call by reference, that would be a relatively minor addition. If you want to be able to embed a pointer to a structure, either for sharing purposes or because it's too large to embed, that also's small in scope. What other places are there? The gist of my argument against pervasive pointers is that that set of places is small. But perhaps even just adding pointer qualifiers in structure declarations open up the whole can of worms, and this becomes a moot point.
&gt; whether you forget to initialise pointers, how is that different than an uninitialized reference in java? &gt;spend extra time getting all the types correct wut? 
What you're looking for might not exist yet; just enough boilerplate and structure, but without DI and not a full framework, in go. Perhaps you will author the first good one. :) I'd try building a toy site with a few frameworks, muse on the boilerplate they generate, then throw it away and develop just the parts you need, or see if you can poach individual libraries from them.
Good pull, Negroni looks like one of the better suggestions for what OP was looking for - it encourages a nice separation of concerns into middleware and stdlib usage with a BYO router.
Also missing: returns_two_elements()[1] to get the second element without having to use two lines. 
&gt; I would advise being extremely skeptical of any line of reasoning that results in "they disagree with me because they are using emotion instead of logic, rather than because they have any valid points". Well, excessive complaining about a programming language you don't like or use seems kind of fundamentally irrational. Any positive discussion about Go seems to attract people who seem....angry that other people like Go.
Interesting tool. One thought: Shouldn't readDir return (map[string]string, error) instead of map[string]string? That way you could exit that code path immediately if there was a problem getting data out of etcd. It looks to me like you currently just print an error inside of readDir and return the empty map to main(), which will then be arraify'd and run even though the etcd lookup was unsuccessful. This would lead to unintended behavior, no? Not to mention doing more work (arrayify and run) when there is no reason to.
Well sure, an engineer with a BS in CS should understand the concept of pointers, but students in intro classes, by definition, don't have a BS yet. As they develop a better holistic understanding of computer systems then pointers become more intuitive, but for students that have only ever been exposed to, say, Python or Java (or even a functional language), it might not be so straightforward. Just to elaborate, I don't think 'simple' pointers to values confused many students, but pointers to pointers absolutely did, at least initially. But perhaps those are mostly contrived examples and/or not actually used that much in practice, which makes this point perhaps somewhat moot. Having said that, I don't think I'm the first person to observe that pointers are often a 'hard' concept for students to grasp.
Great post. BTW, the post says to look out for Francesc's slides. They're now available at https://speakerdeck.com/campoy/things-i-learned-teaching-go.
Well, remember that choice of programming languages has network effects. If a lot of developers like Go, then they are going to be developing more libraries and such for Go. So from the perspective of people who prefer other languages, the more people like Go, the fewer people will be developing cool libraries in their language of choice, and the more likely they will *have* to work in Go due to, e.g. their team voting to move to it or something. And having to deal with a language you dislike *sucks*.
&gt;Syntax sugar has nothing to do with being managed or not. I never said it did. Though (with the possible recent exception of C++14 and 0x) it is a trait that is owned dominantly by managed languages.
We do work to make sure that folks who sign up for JIRA accounts to file tickets do not wind up on the company newsletters (one of the higher frequency communications), but our JIRA database does get included in larger databases from which targeted emails are sent. That said, we certainly want to respect opt-out. JIRA is used extensively at MongoDB, not only for issue tracking but also to provide commercial support. You can also email me personally if this problem persists: andrew at mongodb.com. 
What are you trying to actually do? Your example doesn't make much sense since HTTP headers are case insensitive anyway.
as http proxy,i want read and modify these headers. so i cannot change the header's name.
but some http system are case-sensitive.
Then they're not HTTP by definition. :) If you want to build a TCP proxy, the net package has net.Listen and net.Dial and net.Conn.{Read,Write}. 
yes,i think,i'd to deal it as you say
There is also a package for generating html on the fly here: https://github.com/xyproto/onthefly 
This is great work and I always love seeing the progress reports. But geez oh man... SCREENSHOTS! :P
screenshots for the wav package? :) some code examples would also be nice
I have still never managed to get this to work. I follow the "guide" on how to install it, but the examples don't run. Which is a shame.
I wrote a pretty neat package with audio/wav.v1, if you'd like a code example: http://github.com/mdlayher/waveform
I didn't say natural progression **of** Python, I said **from** Python. I completely agree that it's more C based, but my comment was meant to talk about the set of problems you want to solve in Go rather than Python. Go is a natural progression from Python for people that are concurrency-problem oriented, but there isn't a chance I'm writing webapps in it quite yet.
I am really sorry to hear that the examples don't run -- I'd really like to help you troubleshoot it! My top priority is making sure that it's easy to install and run on each platform, so it really saddens me to hear that it didn't work out too well for you. If you wouldn't mind, could you please create an issue at on our [issue tracker](https://github.com/azul3d/issues/issues)? Some things that would really help me debug the issue further are: * What operating system / arch are you running? * What version of Go? (run `go version`) * Is there any error at all? If so please include it. * Anything else you can think of that relates to the issue. 
&gt; I always love seeing the progress reports I am glad to hear it. I really want to keep everyone updated with how the project is going. For the very few amount of people working on the project I think we're making good progress. &gt; But geez oh man... SCREENSHOTS! :P I absolutely hear you! * This is my primary goal right now -- but a little work needs to be done first. * The existing examples are going to be replaced with *pretty and cool* ones. Right now the examples aren't impressive because they just show how to do things -- not what it's capable of. * Keep in mind that Azul3D is more than just a game engine -- it's also a collection of useful packages -- for instance the wav package can be used to encode and decode WAV files: it is *related to* game development but it's not tied to any other Azul3D package at all.
The developer responded within github. Thanks for the feedback. https://github.com/mongodb/mongo-tools/issues/1
Is this on Windows, Linux or something else? Do you have the drivers installed? You may just have to wrap an existing C library. It is not that hard.
Look at the gobot.io packages. They are doing a lot of serial communication over Bluetooth. They may have USB support or give you hints. http://gobot.io https://github.com/hybridgroup/gobot 
Thanks very much for this. I've been muddling my way through a very similar process. Being new to Go, I had trouble groking things like sessions and flash messages. This left me looking at reinventing those wheels based on other tools. Not pretty! I've downloaded your [Sequel code](https://github.com/horrido/acme2) and will use it as a guide to fix the ugliness. 
Good work! Can't wait until model loading is done.
Yes, I was thinking these guys did it with multiple usb devices, on their github, it looks like they're using a c library called opendevice.c: https://github.com/hybridgroup/gobot/blob/master/platforms/digispark/opendevice.c 
You can make screenshots of a game, but not of a game engine, period.
Rust does not have optional garbage collection. The last time I spoke to Alex Crichton, a dev on the Rust team, he told me that the current implementation is reference counted with cycle detection when the task concludes. However, my understanding is that Rust's use of lifetimes allows for memory to be cleaned up automatically -- the compiler inserts the deallocation calls for you. I don't know how accurate that is.
Rust has greater safety than Go; ownership lifetimes + immutability makes nil pointer exceptions impossible. However, Go's runtime array-bounds checking is a primary reason it's slower than C/C++, to my light understanding.
Interesting thoughts! I think your article strays a bit away from it's primary topic (IMO) but overall I agree with your general thought process. Interfaces *allow you to interface different types in abstract ways*. There are many ways to do it, but *the most obvious way to do this is when you already have multiple types that have similar routines*.
The author never really explained why she thinks exporting interfaces "unnecessarily" is a problem. Yes, there's a (very) small performance hit when passing a value into an interface, but that doesn't seem to be her beef. What exactly is being "polluted" and why is this a concern?
Doh, sorry, wasn't paying attention.
http://c2.com/cgi/wiki?YouArentGonnaNeedIt
This is (perhaps subtly) a really great article. I made many of the mistakes that she mentions when writing sqlx; I saw clearly the "missing" interface uniting sql.Stmt, sql.DB, and sql.Tx as something that was lacking, but really the lack of a prescriptive interface makes it much easier for people to use smaller, more flexible ones. Large interfaces make it *harder*, not easier, to share functionality; you can look at each method in an interface as a requirement and a coupling, and interfaces with more of them are more difficult and complex to satisfy and reason about. It took a while for the example set by the standard library to manifest itself as an actual *philosophy* in my brain that I could then use to reason about code and hopefully follow. Sadly, the lookup overhead for interfaces, while very small, is still to large in the hottest of codepaths in CPU bound systems. I wonder if some work can be done in the compiler to mitigate this.
You are right, that may be more idiomatic Go. We will definitely look into this in a future release.
I say this as a former vociferous opponent of tabs as indentation: just get over it. The blocks align exactly the same way. Learn to stop worrying and love the `gofmt`.
naah. I would not recommend writing frontend MVC apps in go.
I tried getting over it for a couple of projects but, in java I use Allman, in C Allman, php Allman, in c# Allman in php ditto when I finally learn mozilla rust, hey Allman again. I respect that code for the public to use should be in go's format so my script does that, and all of us can still code in the way we like; what possible downside is there? Honestly this drives me crazy: func main (){ for some_long_conditional_blah_blah{ } } I guess the blocks do match still, but it just doesn't work for me.
plntsq, but why not? Beego seems to be a nice choice for writing web applications in Go
Not answering the question, but I thought it'd be worth pointing out that unlike Swift, Go doesn't allow *any* Unicode character as a symbol. For example, identifiers can only contain a letter (or underscore) then any number of letters, numbers, and underscores. Things like emoticons are not allowed.
I've found that rather than export interfaces I'm defining them internally in my packages so I can interface cleanly with external packages. In other words I define interfaces that are subsets of what other packages provide which reduces my coupling and assists me with testing. For example, I might use only 2 methods from a connection type in a database package, so I define an interface that covers those 2. It's automatically satisfied by the connection type and I can write mocks/stubs against it too.
It's a nice pattern. What I prefer is a further refinement, namely defining an interface with an unexported set method: type Option interface { set(*T) } and defining options as functions that return that, such as func Speed(baud int) Option { ... } It ends up with a slightly stricter API, because code outside the package can't implement options (usually what you want, since if enough is exposed for other packages to twiddle with your type then you don't need the options in the first place!). It also has the nice benefit of godoc grouping the options together; I don't believe it does that if your options are unnamed func types.
Allman style is not valid Go. That's a pretty excellent reason. If you ever want to read, publish, or maintain Go code, it will be in the Go brace style as produced by Go fmt. So what's the point of clinging to Allman? It's a brace style. The program you wrote doesn't even *have* braces. I thought tab use would bother me, but there's a program that takes care of everything for me, and now I hate going back to not having it. Just get used to it, it's really not a big deal. And when you do, you won't have to waste time writing things like this.
Curious as to what you see as the down side? When I decided to learn Go six weeks ago, I wanted to create a website. After researching the options, I decided to go with a framework and selected Beego. The project is going well and I've learned a LOT about Go, a Lot about Beego and a lot about what is involved in creating a secure, scalable, consumer facing website. 
The author actually brings up a case study where the most straightforward solution was to use an interface for test mockability. I've used exactly that technique to great effect. If there is something wrong with this approach, it is abstract enough that I have never even noticed the presence of a problem.
There are two mutual exclusive options: 1. Let everyone format their code the way they want, or 2. Ensure that everyone can easily read any other developer's code. The Go creators have chosen the latter option. And i think this is the right choice, even if this means compromising on some personal preferences. Tip: Try an editor that can display visual indenting guides. Or train your eyes to recognize Go-style blocks. It might be easier than you think.
Were you using Allman in your python code? 
Lots.
Like ?
Can't agree more, :-)
Very good example, very well explained
"Directives" - no. I assume you mean in the form of a metadata "attribute" or something. You might have noticed there are a distinct lack of such things in Go (which I personally like). You can create immutable structures by not exposing their mutable fields (in the case of pointers that is..) instead exposing their values through getter methods. I am failing to understand how that is innefficient for your requested requirement (other than something like const pointers perhaps..).
thats a good idea, I'm sure vim has a setting for that somewhere.
Such 'getters' will inline and come at zero cost. Also, if you pass the value as a value, rather than a pointer, then you also get this immutability without the ceremony of getters. note: before people freak out about the cost of copying, consider that a slice is a three word value, 24 bytes on amd64, and nobody freaks out about copying those. *edit*: yes, a slice
But it is only invalid due to a semicolon instertion problem..... Eh it doesn't matter; for those like me the script is there, and we can write in a way we like, run this script, run gofmt and blam we have it in the brace style other folk want. At any rate, the point of allman as I said is to me its more readable and the fact that all my other non-python code uses it(well when I had to use lithp....). Python gets a pass because I only write small scripts, and it is "different enough", go on the other hand is completely familiar so it trips me up whenever I mess up here. (probably due to using vim, so such mistakes aren't noticed until compilation)
I guess it depends what level of atomicity you require in the copying case. I am yet to reach such a fine grained level though. Perhaps its a consideration for an ARM environment though (which I believe you are quite fond of! :))
That is exact suggestion I got when I first mentioned immutable structures.. Wrapping all fields in getter-functions? In addition one has to write own "constructor" function for the structure itself. And if we would like to have another "immutable" structure as a field.. we would need to wrap its fields as well. But that is quite a lot of code for such a simple task. Don't you think? My suggestion is something similar to this: immutable struct Person { Firstname, Lastname string } Or maybe even better to have unchangable pointer: struct Person { const Firstname, Lastname string } 
Or you could just pass the struct by value and therefore changes won't affect your copy?
That is no different to languages like C#, Java and a slew of other languages. A constructor that initializes the type and getter methods to retrieve values. Using const in the way you have provided would mean that the const keyword has different meanings depending on context. I personally don't think that is appropriate for Go.
Do you have a specific problem, you're facing? In this case I wouldn't use any methods at all. If I'm not supposed to modify the fields of that struct, then why would I? I guess maybe it's a matter one's POV, but I think that if a user intends to mis-use your API, then it's not worth the trouble of trying to force them to use it correctly. Also, in this specific case, passing that struct to anything will copy it. The receiver cannot modify your original struct or anything inside it.
Or do they? :) Slides aren't immutable, and this guy is freaking out
That is actually a very good point. Can one send a copy of a structure to the channel?
True. My point was that its very situational where people may freak out about that non atomic copy. I haven't been in that situation yet.. perhaps one day I will though :)
Yes. Unless you're having a channel of pointers, each send and receive will create a copy.
It's great to see that you're so thoughtful and calculated in your advocation of Go.
The first rule of Go is, everything is pass by value. type Foo struct { Name string } foos := make(chan Foo) // any Foo value passed to the foos channel will be copied, // so changes will not be reflected in your own copy The second rule of Go is, some values are actually pointers to values (like pointers, maps, slices, interfaces, and channels) and so even if you're copying the pointer value, changes will still be reflected in the backing values.
Whether or not the copy is atomic, if you're worried about thread safety, you need a lock. An atomic copy won't help you if someone has half-finished changes made to the struct. I guess my point is - if someone is worried about the atomicity of the copy, they're worrying about the wrong thing.
It suck to write getters in Java but at least there is "final" keyword and one can have "public final" fields to create lightweight immutable data structures. C# has "accessors" directive for "automatic" getters and setters instead of writing them by hand. Which means there are alternatives in other languages you mentioned. So I don't understand your point.. "Overloading" const keyword meaning depending of the context might be confusing - that is possible, I understand that. 
The % key is your friend :)
it's worth remembering that if Foo contains a pointer, the pointer will be copied and thus point to the same thing which could void any intended immutability. http://play.golang.org/p/k6mjkYMRGn
Yes, that's true. Pointers, and the higher level abstractions that are implemented with pointers (maps, slices, channels, interfaces) cannot be safely shared without explicit copying.
Do the LLVM Go bindings support compiling for iOS, or are there other issues that would need to be resolved first (go library incompatibilities, iOS library bindings)?
Anyone cares to explain what this means for Go?
Broader compiler support is usually an indication of a language's maturity, as well as its stability as a specification. Beyond that, there is a greater opportunity for faster Go executables since Google, GCC, and LLVM all use different strategies for code generation.
&gt; The nature of the Go language is beside the point [...] The fact that a framework may not be idiomatic Go is completely irrelevant Why do you use Go if you throw away a huge amount of its features? &gt; greater simplicity and safety Because learning new magic, DSLs, configurations, generators, ... is so very simple, and because bugs hidden deep inside the framework never have bitten anyone. &gt; isolated from potential programming errors that you might make if you had to do your own integration Obviously, programming errors in a highly complex ball of magic are easier to deal with than programming errors in simple, separate components. &gt; immediately and rapidly productive Immediately, you know, after learning the framework, that is, with its own preconceptions of how you should do things. &gt; In reality, nearly all software projects have hard deadlines, as well as expectations of hard deliverables on schedule. These schedules are never generous, and they are almost always too tight Yes, let's keep setting utterly unrealistic deadlines (by managers) instead of actually improving the situation. &gt; A well-chosen framework can dramatically lower the barrier to entry and make web development much easier. So does PHP.
This does not mean llvm can compile go or compile to go or anything like that. It means somebody made a library to interact with the llvm c code programatically. 
Just to clarify... *unicode* alphanumerics are ok, so, for example, you can use delta (Δ) as a variable name, or chinese characters as variable names, just not random emoji etc. e.g. http://play.golang.org/p/N9YZMWi8Tz
&gt; consider that a slide is a three word value, 24 bytes on amd64 You meant slice? If you return a slice without defensive copying (e.g. what os.Environ() is doing), user can still alternate the values it holds, so it's still a problem.
&gt; Why do you use Go if you throw away a huge amount of its features? Nothing is thrown away. Web frameworks are built on top of Go features. &gt; Because learning new magic, DSLs, configurations, generators, ... is so very simple, and because bugs hidden deep inside the framework never have bitten anyone. Oftentimes it's much easier than trying to roll your own or build a mess of a code with various 3rd party libraries (you need to learn each of them). If you think net/http is enough to build most Web application, dream on. Gorilla Toolkit will get you close. But then learning it is no easier than learning full-stack framework. &gt; Immediately, you know, after learning the framework, that is, with its own preconceptions of how you should do things. See above. Also, full-stack frameworks add relatively thin layer on top of net/http, mostly convenient wrappers and helpers which you have to come up with one way or another. &gt; Yes, let's keep setting utterly unrealistic deadlines (by managers) instead of actually improving the situation. Using full-stack frameworks IS improving the situation. &gt;&gt; A well-chosen framework can dramatically lower the barrier to entry and make web development much easier. &gt; So does PHP. Yes. Yii, Laravel, Symfony, etc. help writing well structured, maintainable code. What's wrong with that? 
What are you asking here? 
Erlang has pervasive immutability and the rigid walls of the process boundary. I wouldn't expect their experience to provide much guidance to Go here, which has neither.
&gt; Nothing is thrown away. Web frameworks are built on top of Go features Such as its idioms and ideologies? Or its type safety (interface{} everywhere)? &gt; But then learning it is no easier than learning full-stack framework. Yes it is. Learning each library separately, and knowing their strengths and weaknesses, is both easier and more valuable than learning a framework, as that only teaches you how to do the common stuff, the stuff that the designer of the framework had in mind. You will, to some degree, know how all components work together, but not how the separate components work on their own. Once I know a library, such as gorilla/mux, I can combine it with any other library without having to learn gorilla/mux over and over again. I can create a solution that fits my needs perfectly, not a solution that fits 80% of my needs 95% of the time, and that won't allow me to implement the other 20% in any sensible way. Each different framework,however, has their own spin on things, even when they reuse existing libraries, e.g. some libraries adding special magic on top of html/template, but behaving differently in some very subtle ways you will run into eventually. If I have to work with two projects that use plain html/template, I learn html/template once. If I have to work with two different frameworks that both use html/template, I have to learn how each framework mangles it. &gt; See above. See above. &gt; Using full-stack frameworks IS improving the situation No, it's avoiding the problem by piling on more bad things. Improving the situation would mean educating decision makers, not working around their decisions. &gt; Yes. Yii, Laravel, Symfony, etc. help writing well structured, maintainable code. What's wrong with that? Why go through the effort of adopting a new technology if you disregard its actual benefits, while working around its deficiencies? Go isn't the best choice for your usual frontend web stuff in many cases already. Adding frameworks and pretending Go is now PHP/Ruby/... doesn't make Go any more suitable, it makes it less suitable.
I have to agree with you. I began my Go journey using nothing but Martini and it really held me back from learning Go properly. I felt very safe as a .NET developer and Martini's setup but wow was I misguided about my Go skills after a few months. I ended up dumping it completely in favour of vanilla net/http and I now feel like I have a much better grasp of Go as a whole. Granted, moving away from web applications also helped me grasp the language better, but I honestly feel like those "full stack" frameworks held me back in a way that would not allow me to write the sort of Go code I would encounter further into my journey.
&gt; My question is this: is it considered non-idiomatic to write web applications using non-idiomatic frameworks, or is it considered non-idiomatic to write web applications using frameworks at all? &gt; Depending on your definition of framework, `net/http` and `database/sql` already are frameworks, and `gorilla` could probably be considered a framework to some degree, even though the name it chose for itself, toolkit, fits better. In either case, the issue lies with using non-idiomatic frameworks, and "full stack frameworks" fall into that category.
So basicaly I end up where I started.. Which leads me to conclusion that I need immutable pointer or rather read-only pointer: a mechanism to restrict manipulation with any kind of type after it was initialized. What do you think?
I don't see your point.. neither about *static* nor *final*. Maybe I missed the part where Rob explains why there is no need for immutability mechanism for language users even though *string* is immutable type but video is entertaining though.
I think this is a good observation. Without trying suggest that immutability is _not_ a good thing I wonder how much of the calls for immutable data structures and option monads is driven by people scarred for life by languages like Java who's idiom for returning null on error and only supporting reference types has caused so many developers to develop these calouses to protect them from the harm of their coworkers. 
I think it's a stretch to call net/http and database/sql frameworks. A framework is intended to be inclusively comprehensive. People don't even refer to Gorilla as a framework.
Hey, I'm the github.com/google/btree maintainer. Thanks for pointing out the tv42 benchmarks, really interesting! I'm surprised that google/btree isn't performing that well compared to the B+ tree, I'll see if I can find any low-hanging fruit to speed things up. One thing I did notice: The tv42 benchmark is using a degree-2 btree when testing [google/btree](https://github.com/tv42/benchmark-ordered-map/blob/master/bench/google-btree/google-btree_test.go#L16), but a built-in degree of 32 for [cznic/b](https://github.com/cznic/b/blob/master/btree.go#L67). Testing against google/btree's built-in benchmarks, I get this for degree 2: BenchmarkInsert 2000000 908 ns/op BenchmarkDelete 2000000 818 ns/op BenchmarkGet 5000000 613 ns/op and this for degree 32: BenchmarkInsert 5000000 454 ns/op BenchmarkDelete 5000000 472 ns/op BenchmarkGet 5000000 405 ns/op So it looks like changing the degree alone will get you a pretty substantial speedup. I might send a pull request to tv42 to get comparable degrees for the trees.
I've also added a sync.Pool for internal nodes... this should make node allocation a little nicer, especially since it means foregoing reallocation of internal node slices.
Despite dire warnings of the "inevitable dire consequences", there will be a popular (as in Rails or Django) full stack framework for web site development based on Go. There will likely be widely used, though less popular full stack frameworks as in Lotus or Flask. Richard Eng explains why the success of such frameworks is inevitable. His presentation also makes it clear why the consequences will be no worse than the consequences experienced by users of Rails, Django, Lotus or Flask. IMO, the real issue is that in the Go world we don't yet know which of the competing fs frameworks will eventually stand in the winners circle. Richard obviously prefers **Beego**. I've also chosen Beego. We could both be betting on an also ran. **Revel** looks to be a strong contender as well. Based solely on review comments indicating that it strayed further from the "go way" as compared to Beego, I didn't look any deeper. Looking at the performance charts referenced in the article, I couldn't help but notice that Beego has only entered in one category while Revel entered them all. Time will tell whether or not rejecting Revel was a mistake. **Martini** got off to a strong start, but faltered in the far turn as scaling and performance issues emerged. As its developer put it "As I grew from a baby gopher to a well respected Go developer in the community, this was the toughest pill for me to swallow. Martini, and it’s design, is simply not idiomatic Go." He's now gone the Go + toolbox route with [Negroni](https://github.com/codegangsta/negroni), which looks promising for those who choose to follow that road. The point of this rambling is that those who develop websites, whether for fun or for profit, will have to decide which road to take. Those in the for profit group may find that Richard makes a good case for using a full stack framework. I don't expect that they will promote fs frameworks as the end all, be all. Those who choose Go+tools would do well to avoid claiming that their road is the only road to salvation. 
You get all LLVM goodies for Go.
I disagree, every Erlang system I have ever touched in production had pervasive mutability... because they do actual work. They modify ETS, they modify Mnesia, they modify various databases and files... Even ignoring that, just because a language has rigid walls and immutability doesn't mean it can't be broken by you doing something stupid... "Don't call X before Y"... my point was about the communities response to such things, which is anti-paternalistic... read the docs and don't do the thing it tells you not to do.
Based on http://en.wikipedia.org/wiki/Software_framework: &gt; Inversion of control The server in `net/http` calls your handlers, it doesn't wait for you to retrieve the next request &gt; default behavior 404s, open-ended muxing, and a bunch of HTTP things that `net/http` automates for you &gt;extensibility and &gt; non-modifiable framework code should be self explanatory. And yes, I do think that there is a fine line between library and framework, and I also think that the term "framework" in itself carries very little meaning, as I feel that only "inversion of control" is a real difference between libraries and frameworks, and said inversion of control is the primary reason I call the server in `net/http` a framework. Now, calling `database/sql` might've been a stretch indeed.
Quiche-eaters use frameworks. Real Programmers(TM) use libraries.
Why would anyone need darwin_386 binaries?
There have been Go bindings on top of LLVM's C API for a long time now. They were originally written by nsf, and I picked up maintenance while working on [llgo](https://github.com/go-llvm/llgo). What this announcement means is that Go now has *first class* bindings for LLVM, alongside Python and OCaml. The bindings will be built and tested along with the rest of LLVM, and maintained by the LLVM developers.
For those who might be wondering, the "other Little book" he's referring to is his other book "[The Little Redis Book](http://openmymind.net/2012/1/23/The-Little-Redis-Book/)", which became popular as well.
No, the standard flag package does not support combining flags. You'd need to use a completely separate flag parser (maybe one of the getopt packages) for your program to accept them.
Alright thanks! Just wanted to make sure I wasn't missing something. Looks like same deal if I want to also provide longopts with the -- syntax
Nice book! Another small Go book in my small Go library! 
I enjoy all the DBZ references. May your power level be always over 9000!
No. Flags defined by the `flag` package can be used both as `-foo` and `--foo`. It's just that everyone I know prefers the former since it's shorter.
That's what she's saying with this - that users can always make their own interfaces around your types: "If a user requires some level of “inversion of control”, an on-the-fly interface definition in their own scope would just work. This possibility minimizes the presumptions you have to make about the way your package is being consumed and the initial abstractions you have to work on."
Doesn't actually solve your problem, but FYI I find the [codegangsta/cli](https://github.com/codegangsta/cli) to be a better parser generally.
Yeah but that is a pun on [Mao's Little Red Book](http://en.wikipedia.org/wiki/Quotations_from_Chairman_Mao_Tse-tung).
Very nice book man, thank you
&gt;&gt; Nothing is thrown away. Web frameworks are built on top of Go features &gt; Such as its idioms and ideologies? Or its type safety (interface{} everywhere)? Using interface{} is idiomatic to Go. If someone comes up with a smart way to use language features, it becomes idiomatic. Idiomatic Go is not set in stone. &gt; Yes it is. Learning each library separately, and knowing their strengths and weaknesses, is both easier and more valuable than learning a framework, as that only teaches you how to do the common stuff, the stuff that the designer of the framework had in mind. You will, to some degree, know how all components work together, but not how the separate components work on their own. Of course. I started with pure net/http, migrated to Gorilla, then to Goji, then to Gin. I probably will not go to full stack because I invested so much in my own "wheel." Using full stack framework does not shield you from the language though and you have plenty of opportunities to learn Go. &gt; Once I know a library, such as gorilla/mux, I can combine it with any other library without having to learn gorilla/mux over and over again. I can create a solution that fits my needs perfectly, not a solution that fits 80% of my needs 95% of the time, and that won't allow me to implement the other 20% in any sensible way. Standard net/http library is severely lacking in context/middleware support. Various libraries try to remedy that, and Gorilla is one of them. It is the most net/http-friendly one but implementation is nasty in my opinion (parallel structures indexed by pointer to request). It works, yes. Other libraries use other approaches: override request, override response writer, add another version of HandleFunc with a context structure. All of these are incompatible, which means not all combinations with other libraries will work. Typically you end up with router/muxer tightly integrated with middleware provider. And then you can use only middleware that is written for a specific middleware provider. You got a large part of full stack right there. &gt; Each different framework,however, has their own spin on things, even when they reuse existing libraries, e.g. some libraries adding special magic on top of html/template, but behaving differently in some very subtle ways you will run into eventually. If I have to work with two projects that use plain html/template, I learn html/template once. If I have to work with two different frameworks that both use html/template, I have to learn how each framework mangles it. Template rendering and ORM/database access, while can be part of full-stack framework, are generally swappable. Both are a matter of taste, of course. &gt;&gt; Using full-stack frameworks IS improving the situation &gt; No, it's avoiding the problem by piling on more bad things. Improving the situation would mean educating decision makers, not working around their decisions. What bad things? Full stack frameworks are attempting to help solving problems. The choice is up to developer. Don't like it? Don't use it. Look at the Ruby and Python communities: full-stack frameworks and micro frameworks coexist just fine. No one suggests that full-stack is the right/only way. But do not dismiss it either. It may work wonders for a project. In fact, it's probably best for prototyping a Web application. &gt; Why go through the effort of adopting a new technology if you disregard its actual benefits, while working around its deficiencies? Go isn't the best choice for your usual frontend web stuff in many cases already. Adding frameworks and pretending Go is now PHP/Ruby/... doesn't make Go any more suitable, it makes it less suitable. Go is very well fit for Web server-side development. It is a direct competitor to PHP/Ruby/Python and is doing just fine, thank you. 
&gt; Why do you use Go if you throw away a huge amount of its features? What are those features that you are throwing away just from using a framework? &gt; bugs hidden deep inside the framework never have bitten anyone. Bugs will always exist. But is very less likely you find a bug on a framework than in your own rolled up a bunch of libs glued together. Simply there are more "eyes" looking at the framework. &gt; Immediately, you know, after learning the framework, that is, with its own preconceptions of how you should do things. That applies to frameworks, but also to libraries or to programming languages. I don't see how that is relevant to this topic. &gt; Yes, let's keep setting utterly unrealistic deadlines (by managers) instead of actually improving the situation. The deadlines is an unfortunate example. The key point is that using a framework has a lesser cost to produce something. &gt; So does PHP. So does Go. How is that a problem? It is good to have a lower barrier to entry. That is one of the best selling points of Go. Having a lower barrier is always good.
I personally prefer to follow the conventions of GNU's programs, so a single dash for single-character flags and a double dash for verbose flags. Also, check out [docopt](https://github.com/docopt/docopt.go).
"A struct type is exported into other packages if the name of the struct starts with a capital letter. " Misleading: Any const, var, function or type that starts with a capital letter is exported. "In most object-oriented languages, methods are associated with class, but in Go, methods associate with a struct type." Wrong: Methods can be defined on any type that is no builtin type. 
If you can build them, why not?
Try the [pflag](https://github.com/ogier/pflag) package. Its API is compatible with the standard flag package, but it parses arguments in the more familiar way.
[github.com/jessevdk/go-flags]( https://github.com/jessevdk/go-flags) has that functionality and also does flags idiomatically on windows automatically.
In my mind, I've distinguished between libraries, toolkits, and frameworks. Libraries are special-purpose, relatively low-level collections of code designed to support a specific task. Just about anything in the standard library is a good example, but I'd argue that the text and html templating packages are more than libraries. Toolkits are generally abstractions of libraries to allow faster development for the most common cases. They rarely add new features, but when they do, they're features that most people can agree on and are probably considered 'industry standard' kinds of features. They usually expect the programmer to understand the abstracted libraries. In my experience, toolkits work well alongside libraries. The Gorilla Toolkit is pretty awesome at being a toolkit IMHO. Frameworks are larger, more complex things that are designed to provide additional structure to the programmer, usually in the form of a subset of features and directives. While the structure provided in a good framework does allow the common case to be written MUCH more quickly and easily, it is rare that a framework allows the less common case to be as easy or easier than it is outside the framework. Frameworks are great for 'bread and butter projects'. I prefer to live in the library-toolkit area because I do a lot of programming that isn't common. Previously in my life, I've had a number of clients that all wanted pretty much the same thing, and I did a lot more programming with frameworks. I think that the 'frameworks are evil' and 'frameworks are awesome' arguments stem from how well frameworks assist the programmer in their arena. If you're not doing the same kinds of programming repetitively, frameworks aren't going to help you very much, and are likely going to get in your way. I believe that another origin for 'frameworks are evil' is the 'super framework'. This happens when programmers that work with frameworks want to extend the feature set of a framework because they're broadening their horizons. They expect the framework to also broaden its horizons. An extension is created. When you get enough people doing this, you end up with a super framework. In a super framework, you can do almost anything that you can do with libraries and toolkits, but in a very different way. Why learn a super framework if you can just learn the standard library and a few toolkits? I would guess that most people would agree that once a framework reaches super framework status, the bubble bursts, the shark is jumped, and mass hysteria has been achieved.
I'd also recommend taking a look at this flag package. https://github.com/alecthomas/kingpin
&gt; Methods can be defined on any type that is no builtin type. This is a little misleading as well, since the builtins aren't special in this regard. You can only define methods in the same package that a type was defined.
Also his other book, "[The Little MongoDB Book](http://openmymind.net/2011/3/28/The-Little-MongoDB-Book/)". I believe that was his first "little book".
My presentation starts about 52 minutes in. http://youtu.be/RdwZXw4B_xM?t=52m45s
you'd be hard pressed to beat vim-go
I think their motivation goes way beyond that.
&gt; I disagree, every Erlang system I have ever touched in production had pervasive mutability... **because they do actual work**. Clearly you don't understand what immutability means or entails.
In another effort to start learning some vim I set it up for Go and JS development. You can see the [notes from that experience](http://blog.v-studios.com/2014/08/setting-up-vim-for-development-with-go.html). Hopefully that is helpful. 
No. Garbage collection makes it impossible, you can have a go app that calls to a c++ library that calls back to a go function because main() should be handled by go, but it is not advised. Try james' json parser https://github.com/udp/json-parser it maybe the fastest around
time.Parse still requires you know exactly what day you're talking about, the PHP strtotime literally lets you say "next thursday" and you don't have to care about if today is Tuesday or not to get the date, we used it all the time to do things like "last thursday of the month", whereas even with the time.Parse you would have to figure out what day that is yourself.
It looks like PHP wraps the `getdate` function from the libc for its strtotime function. It should be easy to use `cgo` to wrap `getdate` from Go.
Why not use a C library like http://zserge.bitbucket.org/jsmn.html?
&gt;JSON is a pain in C/C++ &gt;it maybe the fastest around These two things are not related.
I'm following it. Really like the exercises, they are tiny but useful to custom yourself to the language. I say this because am not happy doing mathematical exercises to learn a programming language :|
But project euler is fun!
I use Qt Creator extensively for Qt/QML work, so I'm quite interested in this plugin, but I've never (knowingly) used a Qt Creator plugin before and I use OS X, not Ubuntu, so… anyone know where I can find a how-to guide?
&gt; Using interface{} is idiomatic to Go Using interface{} is a last resort and throws away any kind of type safety you had. Your other replies all miss the point, so I won't go into further detail there.
Wonderful. I've been begging for someone to write logstash in Go for a while now. Will check it out, thanks!
If you need a JSON parser and a way to access all the elements, there's always [boost::property_tree](http://www.boost.org/doc/libs/1_55_0/doc/html/property_tree.html)
The line `*userb = *userb` is saying "hey, the User struct stored at pointer `userb` should have the same data as the struct stored at pointer `usera`. When you say `user.username` on the next line, you're doing the equivalent of C++'s `(*userb).username`. Go knows that you have a `*User` instead of a `User`, so it knows to dereference the pointer to a normal `User` before doing the field operation.
Gah, I knew there had to be some magic happening. Thanks a lot!
How would one apply this pattern to a mix of options that need to run before and after the main part of the constructor? To pick up the `port` example from the slides, I need to know and apply the port before creating the first listener, not afterwards, but the `tls` option needs to run afterwards. Yes, in this particular instance, the port can be made part of the host argument, but there are other such optional options that can't.
Should have avoided being unclear on a technical post. My point was about cultural (specifically paternalistic tendencies) not specifically about Erlang. Languages that protect internals by convention with _ are another example of "mature consenting adults"... the _ tells you "please don't touch this..." ... but you can, it is hint as to expectation, not a rule. 
Great i love QtCreator its just smooth.
Also, you shouldn't use copy as a function name, since it's already the name of a built-in function.
Yep all the commands are in the `autoload` folder so they are already lazy loaded :)
Which leveldb library are you using? if its one that uses CGO, and just so happens that there are any memory leaks in the C leveldb impl, then memory will climb. This is one of the biggest issues I have with CGO. Try the pure Go version: https://github.com/syndtr/goleveldb
Its not the db case 100%. By that i mean it uses some memory, but not too much. Yes, thank You, i'm using exactly this implementation after using boltdb for some time.
If I could just get used to modal editing and have time to learn all new key bindings, I would be using vim all the time. Alas, I destroy files a smuch as I create them with vim still:/
I find it helps to leave the application running for a while before taking a heap profile. Also, are you sure you're looking at the residential memory (RES) and not virtual (VIRT)?
Thank You, i was taking heap profile exactly same way. Yes, i'm looking at residential memory, virtual is about ~600-700M. And i need to correct my numbers btw.
Not really a fan of exposing unexported structs in exported methods. func NoShutdownHook(c *config) My first reaction is always "what is config? Wait, it's not even exported, wtf?" I get that it's an implementation detail, but I think it makes the godoc too ugly. 
&gt; JSON is a pain in C/C++, Not if you use libraries :) http://jsoncpp.sourceforge.net/old.html The new page is at https://github.com/open-source-parsers/jsoncpp
From [the docs](http://golang.org/pkg/runtime/): &gt; The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit. So you'll need to run your application like so: $ GOMAXPROCS=4 ./mandel blah blah
In case you are still interested, I've now updated my homepage to SQLite. You can find the new homepage, to which I will eventually transit to, at http://heroku.juusohaavisto.com. You can still compare the performance of RethinkDB and SQLite as my homepage still runs RethinkDB. Nevertheless, the performance difference seems to only be 100ms, even though the Heroku deployment on SQLite is running with less resources. I doubt they would scale the same, but I think the performance on Heroku is actually very decent.
You can set it programmatically as well: runtime.GOMAXPROCS(runtime.NumCPU())
Yes, I found that on page 327 in my book now. Obviously I did not read through the book, but only used as a reference to get up to speed. I have to say that I find there are lot of things that I like about Go ( I have background with C / C++ / python / scheme / OpenCL)
Agreed, and JSONcpp is what I'm probably going to use. The downside is that I have code that is dependant on legacy structs I need to serialize/deserialize. In Go this is built in. In C++ I'm going to have to write a layer that takes the struct and converts it to JSON via JSONcpp. Just one extra layer I'd rather not need! Thanks for this!
Many folks who are anti-Go-frameworks seem like the type of folks who usually get into language wars. The state of Go web frameworks is very premature. The idea of a framework is language independent. You can have light weight or full stack frameworks, regardless of the language used to build the frameworks. There are use cases where barebone light-weight frameworks are sufficient and preferable. There are other cases where full-stack frameworks would make your life easier. But it should not be about Go, the underlying language. 
It's pretty great. Goroutines are cool, but once I learned how to really use channels, I was hooked. 
&gt; How does the range for iterating over a channel work? Does it wait for the channel to close? Yes. It will wait forever if necessary. &gt; Also if it's taking a really long time to generate the 101st number and Filter and Sum proceed to process the first 100 numbers, and put the result in the result channel, and since fmt.Println(&lt;-result) was blocked on having a value in the result channel, it will print the value (wrong/intermediate one) and quit, right? I don't know where it would get a "wrong" or "intermediate" value. It will only print what it receives. If it never receives anything, it will never print anything. &gt; More generally, it seems like I have a new hammer. Want to transform(sum/sq/product etc) a list? Send to a channel and filter. Is this a good pattern? For this sort of thing, no. Idiomatic Go is to just do it in code in a loop. In particular, channels are fast in relative terms compared to other synchronization techniques but compared to single assembler instructions on integers they are very, very slow. In the more general sense it may be a good pattern, especially if you have a pipeline with some sort of side effect (like one of the goroutines is logging, etc.), and the elements of the pipeline are doing something more than a simple numerical manipulation. That said, I've used many "pipeline" libraries in many languages and my personal experience is that one rarely ends up with a significant usage of this pattern. It seems to me to be a perennial attractive nuisance, something that sounds really good in a lot of our heads but in practice isn't that interesting. My personal record is a straight-line composition of 5 elements in Haskell, which in Go would still have been only about three (Incoming TCP data -&gt; marshal out of JSON -&gt; handle -&gt; marshal JSON to TCP bytes -&gt; outgoing TCP data, in Go in some equivalent code I merged the JSON marshaling together with the socket handling because it was just as easy). YMMV but just hooking up goroutine after goroutine after goroutine with channels in some long sequence tends not to come up in real code, because after all there's usually some way to just _do_ the thing you're trying to hook together in some complicated network in a much more straightforward manner with conventional code composition. As in this case, but no criticism intended; it was good practice code.
? I am at a bit of a loss here...
Maybe send debug output to stderr? &gt; I don't like to "flush" the output not sure what you mean. You just need to do it once when your program terminates. 
You're referencing dealers &amp; growers ... pot ... 2 states that are licensed to sell it.
Agreed, under that naming I expect it would return a Boolean. Though I'd not always terminate on errors, maybe in this case but often times that may just terminate that flow while others carry on fine.
More of a general programming point, but you only ever check for the unique count, thus a uniqueCount function would be better. You could also make it considerably faster by checking using a map[string]bool to deduplicate values instead of looping repeatedly.
&gt; In particular, channels are fast in relative terms compared to other synchronization techniques but compared to single assembler instructions on integers they are very, very slow. To put this into a more pointed perspective, each channel is actually a pair of mutexes along with a buffer and index. So it's actually an extremely heavy construct. Unless the algorithm really wants a channel, I recommend only using them for system level (e.g., rare) abstractions.
Here's him talking explicitly about Go: https://www.youtube.com/watch?v=sln-gJaURzk
Take a look at http://godoc.org/code.google.com/p/go.crypto/ssh. There is an SSH client / server implementation in the go.crypto subrepo, a sub-repository of the official Go repository that is maintained by the same people.
lol I feel really slow on that one :) You know those dealers really stepping up their game.
Well there's your problem. You shouldn't be using a logging package to make an interactive interface. edit: use fmt.Println(...) for the interactive stuff and the log.Println(...) for debugging. log.SetOutput(os.Stderr)
I did think about doing this, but I am not sure how to write the xml values into a map[string]bool ( I tried this with a map[string]struct{} to reduce the memory footprint). Have you had any experience with this? edit: Also great catch on the uniqueCount! I didn't even notice this.
A good CLI tool is neither interactive nor verbose, and it doesn't have spinners, progress bars, etc.: http://monkey.org/~marius/unix-tools-hints.html
You should start your doc comments with the name of the function you're documenting. http://blog.golang.org/godoc-documenting-go-code Consider doing away with isErr. Sure, you'll end up with a lot more if statements inline, but merely logging the error is rarely the right thing to do. For example, if os.Open fails and xmlFile is invalid, it makes no sense to try to read from it later. You should nearly never ignore errors. You should handle the error from ioutil.ReadAll. If you're assigning to a new variable, consider the pattern of doing the assignment in an if statement and handling any error immediately. For example: if dir, err := os.Getwd(); err != nil { fmt.Println(err) return } Your sum function is doing more than the name implies. Consider instead having one function to parse a slice of strings into a slice of numbers (handling errors properly, such as omitting them from the output) and another function to actually sum the numbers. Or just give the function a more expressive name. Depending on the size of your list, the O(n^2) behaviour of unique may not be acceptable. If that's the case, you might have better luck accumulating an entire list, sorting it, then making a single pass through the list removing all duplicates (now that they're all next to each other). Don't forget to write tests! :) 
Tiny nit-pick: SSH is the protocol you'd be implementing a server for, OpenSSH is an existing implementation of it (and the client). Other than that: crypto is hard, and there's many potential pitfalls that even experts get wrong. Using the library that tux21b mentions will take you many steps forwards and avoid many problems - not that there aren't more things to be careful of. http://www.snailbook.com/protocols.html has a listing of a bunch of information regarding SSH (in the form of RFCs). Fairly heavy (but also accessible) reading.
Thanks for the link, I will keep that in mind.
Thanks for the detailed response, but I do have a question about your last point. If I do a sort and then a pass through the list isn't that still the same behavior? Since the sort will pass through each element once and then the pass through the list, or will it only be slightly worse than O(2n)? (It does seem like icholy's approach is a better choice if I could figure out how to write the values to a map[string]bool) and I was planning to write some tests shortly actually. This is an on going learning experience for me. Next step tests, then I want to implement channels to process multiple files concurrently, and then I want it all to be output into excel. Anyways that's the longer term goal (hopefully be end of week).
And I can discard this by default, unless the "verbose" flag is set. Thanks for the idea, I like that :) Something like: log.SetOutput(ioutil.Discard) if verbose { log.SetOutput(os.Stderr) } should be enough.
Practically speaking, the processing you're doing and the dataset you're drawing from are probably simple enough that the following will never really come into play. That said, here's a little excursion into complexity analysis: Right now, the worst case behaviour for your unique function is when you pass in a list of unique items. In that case, each time you examine an element of list, you're increasing the size of result by 1. For each item, you call contains, which also goes through each item of the list. So contains examines *n* items, and it gets called with 1 item, then 2, 3, 4, ..., n-1, n. When you add those up, you get n^2/2 + n/2 operations. (See http://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF) In big-O notation, that's O(n^2). (To be a bit imprecise, this is because the biggest term is the n^2 at the beginning.) Sorting a list takes O(n log n) operations, and it only needs to be done once. (See http://en.wikipedia.org/wiki/Comparison_sort#Number_of_comparisons_required_to_sort_a_list) After that you can scan through the list and say "Hey, is this element the same as the previous one? If yes, remove it. If no, keep it." Since you go from start to finish only once, this is O(n) operations. O(n log n) + O(n) is still O(n log n) (since that's the bigger term). Let me know if you want me to clarify any of this. I've made this a bit too advanced for a non-CS major, and a bit too basic for someone who knows their big-O notation, so I hope at least part of this makes sense to you and helps. Also, that's really cool that you're thinking of building this out. Go tests look really different from tests in other languages, and it was a bit eye-opening to see how thing do things. Hope you have fun reading about it!
I do appreciate the explanation, it's been a few years since I had to deal with it. I am actually a CS major, I just work as a Business Analyst now. So small scripts like this is all I get to do. Not to mention that you rarely get into questions like this when working with customer facing application in a big corporation. It's more about lets just make it work and never worry about optimization because we have enough money to throw at hardware. The biggest thing was that I wasn't sure how efficient go's implementation of sort was, but your explanation really made it clear of why going that way would improve it. I will try to refactor it and post just the new functionality so you could see your handy work in changing this algorithm :)
http://play.golang.org/p/Gr-ZebNfey shows how you might count the unique strings.
&gt; &gt; How does the range for iterating over a channel work? Does it wait for the channel to close? &gt; Yes. It will wait forever if necessary. Just for clarification it waits not for closing, but for receiving value from channel. And yes, closing operation is also sending zero value in channel. So if You need to differentiate if channel is closed, You could either use separated channel for closing of do such check x, ok := &lt;-c And need to mention, that channels You use have no buffer, which means that just as You put 1 value into it, next put operation will block until You get value from there. So, it becomes pretty synchronous. To do buffered channels, just pass second parameter to make operation, which represent number of values, which can be stored in channel before being get from it. 
Basically it's about avoiding name collisions from the outset. Similar ideas are recommended in other languages, e.g. Java. Sure you can remove those 'ridiculous / pointless' dirs if you want to, but the day you want to share some code, you'll want to add them again. Secondly, the package name can be used as a lookup mechanism, furthermore for basic dependency management (see the `go get` command).
Why not this though? src/github.com/user/ myproject/ main.go other.go As opposed to src/github.com/user/ myproject/ main/ main.go other/ other.go
Both are fine, but different. The first example has 2 files in the same package, and the second has files in separate packages. It's common practice to have several files per package.
So basically go doesn't treat files as namespaces or modules? Does this mean both files share the same namespace?
Oh okay, then that's alright. But does this mean both files have access to each others namespace or something like that, since you don't import them I'm assuming there's no way to distinguish between the namespaces. Is that correct?
Yup. Files in the same package are in the same namespace.
Thanks, I think that answers the last of my questions.
Yes. As long as the files are in the same folder they are treated as being a single package.
It is much easier to use, talk and think about the concepts which are actually used: Go has packages and no namespaces. It is okay to compile a single package from several files (the might be even in different folders). The go tool uses all files in a folder (neglecting build constraints) to prepare a package; this is a convention which is useful as it nicely groups code of one package into one folder. The concept of a source code file is used for build constraints and test code but does not influence packages or visibility (i.e. being exported or not from a package).
I feel like "how to install Go" has been rewritten many, many times. They should all point to one place that explains it well, and will get updated if needed.
You can have as many files in a package as you want. They all share a namespace and have access to the internals of each other. Every directory is it's own package, and one package cannot access the internals of another package. That is all. You may organize your code however you see fit.
Personally I found it useful to have a function: panicIf(err), in addition you could have a logIf(err)
Indeed, and that location is the [official documentation](http://doc.golang.org/doc/install).
If you're coming from a C/C#/Java ish background, I understand your confusion. Packages in Go are similar to CommonJS modules in JavaScript. The idea behind packages is not to structure files (like folders/namespaces), but rather to group functionality. The same way, in Go, you would typically put the same type of things into a single file (e.g. middleware, crypto) instead of a file per class. If such a file becomes unmaintainable, you would then create a specialized package implementing an interface (which in most cases, the specialized package doesn't need to be aware of the interface definition). Packages are meant to be self contained, with nested packages depending on upper level packages. A package might define an interface (e.g. io) that is depended on by a nested/sub package (e.g. io/ioutil - because it knows about io.Reader/io.Writer). This is an example of a specialization package. Unlike other languages, in Go a package doesn't have to know an interface to implement it. Hence making it simpler to redefine an interface in a package that requires such functionality, instead of creating a separate package and depending on it - avoiding the 'common assembly' that's quite prevalent in static typed languages. An example of CommonJS similarity is the ability to treat a package as a singleton. This typically entails creating an Instance variable (which can be replaced) with functions exposing the objects functions. e.g. package cache import "sync" type Cache interface { Get(key string) interface{} Set(key string, value interface{}) } type MemoryCache struct { entries map[string]interface{} lock *sync.RWMutex } func NewMemoryCache() *MemoryCache { return &amp;MemoryCache{entries: make(map[string]interface{}, 0), lock: new(sync.RWMutex)} } func (c *MemoryCache) Get(key string) interface{} { c.lock.RLock() defer c.lock.RUnlock() return c.entries[key] } func (c *MemoryCache) Set(key string, value interface{}) { c.lock.Lock() defer c.lock.Unlock() c.entries[key] = value } var Instance Cache = NewMemoryCache() func panicOnInstanceNil() { if Instance == nil { panic("Instance is nil") } } func Get(key string) interface{} { panicOnInstanceNil() return Instance.Get(key) } func Set(key string, value interface{}) { panicOnInstanceNil() Instance.Set(key, value) } The first time cache is imported, the instance variable "Instance" will be initialized to a MemoryCache object. You could then do: package other import "cache" import "testing" func TestCache(t *t.Testing) { given := "hello cache" cache.Set("key", given) got, ok := cache.Get("key").(string) if !ok || given != got { t.Failf("Given and expected \"%s\", got \"%s\"\n", given, got) } } You can then also substitute the cache singleton used by creating a new cache.Cache implementation and setting cache.Instance = &lt;new cache&gt;. There's another import/package trick you can use to separate structure and implementation within a single package, given that the implementation depends on the structure. E.g. instead of creating a single package called "web" to contain the structure and implementation of your website, you can create a different package e.g. "webcore" to hold the structure types (e.g. middleware, mux/router, context etc.) and on the "web" (implementation) package, use import . "webcore" (dot before package name) inside the "web" package to be able to access the types from "webcore" as if they were contained within the "web" package. e.g. instead of "webcore.Context", you can then just use "Context". I hope that gives you a better idea of how packages are and can be used in go. 
Thanks for the example. I ran both of these with benchmarks (just out of curiosity) and they had almost identical execution times. Which isn't suprising since I am guessing most of the work is done in other places. I decided to go with map solution because it looked much cleaner, but I did use a map[string]struct{} instead to avoid the extra memory usage.
Yeah we broke his beautiful toys... in the beginning you didn't need passwords on Unix, because people just weren't misbehaving.
1. `go fmt` your code. 2. Don't ignore errors, return them. 3. https://code.google.com/p/go-wiki/wiki/CodeReviewComments
You should be able to use a stream decoder instead of reading all the bytes into memory like you do here: https://github.com/collectivebias/socialshares/blob/master/shares.go#L116 Take a look at http://golang.org/pkg/encoding/json/#Decoder This will let you unmarshal into json using the io stream you already have instead of reading the stream into a byte slice first.
Thanks. I haven't seen that page before. That will be helpful!
I find the official docs to not be worded in the most accessible way. Given the number of people that say installing Go is hard, I'm obviously not the only one.
Pass the resp.Body directly to json.Unmarshal? json.Unmarshal(resp.Body, &amp;c)
Look at the docs I linked. You can use a decoder to unmarshal the stream
Sorry. I didn't catch NewDecoder on my first look. How would you handle [https://github.com/collectivebias/socialshares/blob/master/shares.go#L48](https://github.com/collectivebias/socialshares/blob/master/shares.go#L48)? The response is not raw json.
Will the requester block while waiting for data to be fetched? If it does, why bother with channels? Just call the 'request data' function and then use whatever it returns (however long that takes). If you intend the main thread to continue while data is being fetched, you could kick the data request/handling off in a separate go routine: func main() { go func() { data := RequstData(requestParameters) // handle data }() } 
Yep. And the article was good, but the installation steps should have been moved out into a separate article I think.
The functions handling the data requests will be running in a different goroutine, so I'll need to interact with them via a channel. I want to hide the data handling logic from the requester, so it can change as needed. If the data were to reside in memory, for example, each requesting goroutine would have to use locks to prevent a race condition by potentially accessing the same values at the same time.
So in general, should the client always be responsible of handling the error? 
Ok, that makes sense. Yeah your model sounds good. Although I don't think you should start off with a sync.Pool. Just have everyone allocate their own channel. It should be relatively cheap and fast and you won't have to futz with type conversions. Down the line, if it turns out the channel allocations/garbage collections are actually causing performance problems, then consider adding it.
Not necessarily. One of the authors said he is really excited about GO and wants to implement it. He just hasn't seen the community support for it. That's actually what triggered me to post this on here.
Good news then! I count on you to post here when it's available, hehe.
A channel seems like the wrong primitive, more like you need a persistent queue, see if rabbitmq or zeromq suports what you need 
A matlab file access library is very much needed! I have to convert gigabytes worth of matlab files to csv and it's a total pain. Did you end up implementing one?
Took a while to find the Go option on the poll. I was looking for the Gopher, not "GO" which threw me off.
http://godoc.org/github.com/google/go-github/github#RepositoriesService.CreateFile ?
$16,000 for a 12-week course on a niche implementation of an open source language. Lol.
what I would love is a rundown of the interfaces provided by the standard library, to avoid re-inventing the wheel. Such a list is not easy to find. (Or at least I'm not aware of it)
In addition to a message queue, you could just use a database table for the queue if you are already hooked up to a db.
That is a bit of an anti-pattern (database as a queue). http://mikehadlow.blogspot.com/2012/04/database-as-queue-anti-pattern.html